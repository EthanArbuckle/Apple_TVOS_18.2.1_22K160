BOOL sub_1876B3398(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

uint64_t sub_1876B33AC()
{
  return sub_187860C30();
}

uint64_t sub_1876B33F0()
{
  return sub_187860C24();
}

uint64_t sub_1876B3418()
{
  return sub_187860C30();
}

CFErrorRef sub_1876B3468(__SecKey *a1)
{
  v7[1] = *(CFErrorRef *)MEMORY[0x1895F89C0];
  v7[0] = 0LL;
  CFDataRef v1 = SecKeyCopyExternalRepresentation(a1, v7);
  if (v1)
  {
    CFDataRef v2 = v1;
    CFErrorRef v3 = (CFErrorRef)sub_187860750();
  }

  else
  {
    CFErrorRef v3 = v7[0];
    if (v7[0])
    {
      type metadata accessor for CFError(0LL);
      sub_1876B9CE4();
      swift_allocError();
      CFErrorRef *v4 = v3;
    }

    else
    {
      sub_1876B9C0C();
      swift_allocError();
      _BYTE *v5 = 0;
    }

    swift_willThrow();
  }

  return v3;
}

id NEIKEv2CryptoKitHPKE.__allocating_init(payload:aad:psk:pskID:keyRef:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, void *a9)
{
  id v18 = objc_allocWithZone(v9);
  id v19 = sub_1876B8D08(a1, a2, a3, a4, a5, a6, a7, a8, a9);

  sub_1876B8E88(a7, a8);
  sub_1876B8E88(a5, a6);
  sub_1876B8ECC(a3, a4);
  sub_1876B8E88(a1, a2);
  return v19;
}

id NEIKEv2CryptoKitHPKE.init(payload:aad:psk:pskID:keyRef:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, void *a9)
{
  id v17 = sub_1876B8D08(a1, a2, a3, a4, a5, a6, a7, a8, a9);

  sub_1876B8E88(a7, a8);
  sub_1876B8E88(a5, a6);
  sub_1876B8ECC(a3, a4);
  sub_1876B8E88(a1, a2);
  return v17;
}

id NEIKEv2CryptoKitHPKE.__allocating_init(payload:aad:psk:pskID:keyData:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, unint64_t a10)
{
  id v18 = objc_allocWithZone(v10);
  id v19 = sub_1876B8EE0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  sub_1876B8E88(a9, a10);
  sub_1876B8E88(a7, a8);
  sub_1876B8E88(a5, a6);
  sub_1876B8ECC(a3, a4);
  sub_1876B8E88(a1, a2);
  return v19;
}

id NEIKEv2CryptoKitHPKE.init(payload:aad:psk:pskID:keyData:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, unint64_t a10)
{
  id v17 = sub_1876B8EE0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  sub_1876B8E88(a9, a10);
  sub_1876B8E88(a7, a8);
  sub_1876B8E88(a5, a6);
  sub_1876B8ECC(a3, a4);
  sub_1876B8E88(a1, a2);
  return v17;
}

void sub_1876B3B20(uint64_t a1@<X8>)
{
  uint64_t v40 = a1;
  uint64_t v3 = sub_1878608DC();
  uint64_t v36 = *(void *)(v3 - 8);
  uint64_t v37 = v3;
  ((void (*)(void))MEMORY[0x1895F8858])();
  v39 = (char *)&v35 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = sub_187860B64();
  uint64_t v51 = *(void *)(v5 - 8);
  uint64_t v52 = v5;
  ((void (*)(void))MEMORY[0x1895F8858])();
  v50 = (char *)&v35 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v47 = sub_187860954();
  uint64_t v45 = *(void *)(v47 - 8);
  ((void (*)(void))MEMORY[0x1895F8858])();
  v46 = (char *)&v35 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = sub_18786093C();
  uint64_t v42 = *(void *)(v8 - 8);
  uint64_t v43 = v8;
  ((void (*)(void))MEMORY[0x1895F8858])();
  v44 = (char *)&v35 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v41 = sub_187860948();
  uint64_t v10 = *(void *)(v41 - 8);
  ((void (*)(void))MEMORY[0x1895F8858])();
  v12 = (char *)&v35 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_187860930();
  ((void (*)(void))MEMORY[0x1895F8858])();
  v48 = (char *)&v35 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v49 = sub_187860870();
  uint64_t v56 = *(void *)(v49 - 8);
  uint64_t v14 = ((uint64_t (*)(void))MEMORY[0x1895F8858])();
  v53 = (char *)&v35 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  id v18 = (char *)&v35 - v17;
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  v21 = (char *)&v35 - v20;
  MEMORY[0x1895F8858](v19);
  v23 = (char *)&v35 - v22;
  uint64_t v38 = v1;
  v24 = *(void **)(v1 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_key);
  uint64_t v25 = *(void *)(v1 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_key + 8);
  if ((v25 & 0x2000000000000000LL) != 0)
  {
    CFErrorRef v54 = *(CFErrorRef *)(v1 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_key);
    unint64_t v55 = v25 & 0xDFFFFFFFFFFFFFFFLL;
    sub_1876B9070((uint64_t)v24, v25 & 0xDFFFFFFFFFFFFFFFLL);
    sub_187860864();
    if (v2) {
      return;
    }
  }

  else
  {
    CFErrorRef v26 = sub_1876B3468((__SecKey *)v24);
    if (v2)
    {
      sub_1876B9A24(v24, v25);
      return;
    }

    CFErrorRef v54 = v26;
    unint64_t v55 = v27;
    sub_187860864();
    sub_1876B9A24(v24, v25);
    v21 = v18;
  }

  uint64_t v28 = v56;
  v29 = v21;
  uint64_t v30 = v49;
  (*(void (**)(char *, char *, uint64_t))(v56 + 32))(v23, v29, v49);
  (*(void (**)(char *, char *, uint64_t))(v28 + 16))(v53, v23, v30);
  (*(void (**)(char *, void, uint64_t))(v10 + 104))(v12, *MEMORY[0x189605B28], v41);
  (*(void (**)(char *, void, uint64_t))(v42 + 104))(v44, *MEMORY[0x189605B18], v43);
  (*(void (**)(char *, void, uint64_t))(v45 + 104))(v46, *MEMORY[0x189605B38], v47);
  sub_187860924();
  v31 = v50;
  sub_187860B58();
  sub_187860B4C();
  unint64_t v33 = v32;
  (*(void (**)(char *, uint64_t))(v51 + 8))(v31, v52);
  if (v33 >> 60 == 15)
  {
    __break(1u);
  }

  else
  {
    uint64_t v34 = v38;
    (*(void (**)(char *, uint64_t, uint64_t))(v36 + 16))( v39,  v38 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_psk,  v37);
    sub_1876B9070( *(void *)(v34 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_pskID),  *(void *)(v34 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_pskID + 8));
    sub_187860960();
    (*(void (**)(char *, uint64_t))(v56 + 8))(v23, v30);
  }
}

void sub_1876B3FA4(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v72 = a1;
  unint64_t v73 = a2;
  uint64_t v69 = sub_1878608DC();
  uint64_t v68 = *(void *)(v69 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](v69);
  v63 = (char *)&v61 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v5);
  v62 = (char *)&v61 - v7;
  uint64_t v8 = sub_187860B64();
  uint64_t v84 = *(void *)(v8 - 8);
  uint64_t v85 = v8;
  MEMORY[0x1895F8858](v8);
  v83 = (char *)&v61 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = sub_187860954();
  uint64_t v80 = *(void *)(v10 - 8);
  uint64_t v81 = v10;
  MEMORY[0x1895F8858](v10);
  v82 = (char *)&v61 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v78 = sub_18786093C();
  uint64_t v76 = *(void *)(v78 - 8);
  MEMORY[0x1895F8858](v78);
  v79 = (char *)&v61 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = sub_187860948();
  uint64_t v74 = *(void *)(v13 - 8);
  uint64_t v75 = v13;
  MEMORY[0x1895F8858](v13);
  v77 = (char *)&v61 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = sub_187860930();
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  v89 = (char *)&v61 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  v67 = (char *)&v61 - v18;
  uint64_t v19 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1AF0);
  MEMORY[0x1895F8858](v19);
  v21 = (char *)&v61 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = sub_1878608F4();
  uint64_t v23 = *(void *)(v22 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  v65 = (char *)&v61 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v24);
  v66 = (char *)&v61 - v26;
  uint64_t v64 = sub_1878608A0();
  unint64_t v88 = *(void *)(v64 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v64);
  v86 = (char *)&v61 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  v31 = (char *)&v61 - v30;
  uint64_t v32 = MEMORY[0x1895F8858](v29);
  uint64_t v34 = (char *)&v61 - v33;
  MEMORY[0x1895F8858](v32);
  v87 = (char *)&v61 - v35;
  uint64_t v70 = v3;
  uint64_t v36 = *(__CFError **)(v3 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_key);
  uint64_t v37 = *(void *)(v3 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_key + 8);
  uint64_t v71 = a3;
  if ((v37 & 0x2000000000000000LL) != 0)
  {
    CFErrorRef v90 = v36;
    unint64_t v91 = v37 & 0xDFFFFFFFFFFFFFFFLL;
    sub_1876B9070((uint64_t)v36, v37 & 0xDFFFFFFFFFFFFFFFLL);
    uint64_t v43 = v92;
    sub_187860888();
    if (!v43) {
      goto LABEL_5;
    }
  }

  else
  {
    uint64_t v38 = v36;
    v39 = v92;
    sub_1878608E8();
    if (v39)
    {

      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 56))(v21, 1LL, 1LL, v22);
      sub_1876B9C94((uint64_t)v21, &qword_18C6E1AF0);
      CFErrorRef v40 = sub_1876B3468(v38);
      unint64_t v42 = v41;
      CFErrorRef v90 = v40;
      unint64_t v91 = v41;
      sub_1876B9070((uint64_t)v40, v41);
      sub_187860888();
      sub_1876B9A24(v36, v37);
      sub_1876B8E88((uint64_t)v40, v42);
      uint64_t v34 = v31;
LABEL_5:
      uint64_t v45 = v87;
      unint64_t v44 = v88;
      uint64_t v46 = v64;
      (*(void (**)(char *, char *, uint64_t))(v88 + 32))(v87, v34, v64);
      (*(void (**)(char *, char *, uint64_t))(v44 + 16))(v86, v45, v46);
      (*(void (**)(char *, void, uint64_t))(v74 + 104))(v77, *MEMORY[0x189605B28], v75);
      (*(void (**)(char *, void, uint64_t))(v76 + 104))(v79, *MEMORY[0x189605B18], v78);
      (*(void (**)(char *, void, uint64_t))(v80 + 104))(v82, *MEMORY[0x189605B38], v81);
      sub_187860924();
      uint64_t v47 = v83;
      sub_187860B58();
      sub_187860B4C();
      unint64_t v49 = v48;
      (*(void (**)(char *, uint64_t))(v84 + 8))(v47, v85);
      if (v49 >> 60 != 15)
      {
        uint64_t v50 = v70;
        (*(void (**)(char *, uint64_t, uint64_t))(v68 + 16))( v63,  v70 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_psk,  v69);
        uint64_t v51 = v50 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_pskID;
        uint64_t v52 = *(void *)(v50 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_pskID);
        unint64_t v53 = *(void *)(v51 + 8);
        sub_1876B9070(v72, v73);
        sub_1876B9070(v52, v53);
        sub_187860990();
        (*(void (**)(char *, uint64_t))(v88 + 8))(v87, v46);
        return;
      }

      __break(1u);
      goto LABEL_11;
    }

    v92 = 0LL;
    (*(void (**)(char *, void, uint64_t, uint64_t))(v23 + 56))(v21, 0LL, 1LL, v22);
    CFErrorRef v54 = v66;
    (*(void (**)(char *, char *, uint64_t))(v23 + 32))(v66, v21, v22);
    (*(void (**)(char *, char *, uint64_t))(v23 + 16))(v65, v54, v22);
    (*(void (**)(char *, void, uint64_t))(v74 + 104))(v77, *MEMORY[0x189605B28], v75);
    (*(void (**)(char *, void, uint64_t))(v76 + 104))(v79, *MEMORY[0x189605B18], v78);
    (*(void (**)(char *, void, uint64_t))(v80 + 104))(v82, *MEMORY[0x189605B38], v81);
    sub_187860924();
    unint64_t v55 = v83;
    sub_187860B58();
    v89 = (char *)sub_187860B4C();
    unint64_t v57 = v56;
    (*(void (**)(char *, uint64_t))(v84 + 8))(v55, v85);
    unint64_t v88 = v57;
    if (v57 >> 60 == 15)
    {
LABEL_11:
      __break(1u);
      return;
    }

    uint64_t v58 = v70;
    (*(void (**)(char *, uint64_t, uint64_t))(v68 + 16))( v62,  v70 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_psk,  v69);
    uint64_t v60 = *(void *)(v58 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_pskID);
    unint64_t v59 = *(void *)(v58 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_pskID + 8);
    sub_1876B9070(v72, v73);
    sub_1876B9070(v60, v59);
    sub_187860990();
    (*(void (**)(char *, uint64_t))(v23 + 8))(v66, v22);
    sub_1876B9A24(v36, v37);
  }

void NEIKEv2CryptoKitHPKE.performHPKESeal()()
{
  uint64_t v2 = sub_187860984();
  MEMORY[0x1895F8858](v2);
  sub_1876B3B20((uint64_t)v12 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  if (!v1)
  {
    v12[7] = v2;
    uint64_t v4 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_payload);
    unint64_t v5 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_payload + 8);
    v12[4] = v4;
    v12[5] = v5;
    uint64_t v6 = v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_aad;
    uint64_t v7 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_aad);
    unint64_t v8 = *(void *)(v6 + 8);
    if (v8 >> 60 == 15) {
      uint64_t v9 = 0LL;
    }
    else {
      uint64_t v9 = v7;
    }
    if (v8 >> 60 == 15) {
      unint64_t v10 = 0xC000000000000000LL;
    }
    else {
      unint64_t v10 = *(void *)(v6 + 8);
    }
    v12[2] = v9;
    v12[3] = v10;
    sub_1876B9070(v4, v5);
    sub_1876B90B4(v7, v8);
    sub_1876B90C8();
    v12[1] = sub_187860978();
    sub_1876B8E88(v9, v10);
    sub_1876B8E88(v4, v5);
    sub_18786096C();
    __asm { BR              X11 }
  }

uint64_t sub_1876B4948()
{
  return ((uint64_t (*)(void))((char *)&loc_1876B4980 + dword_1876B4A44[v0 >> 62]))();
}

void sub_1876B4990(uint64_t a1@<X8>)
{
  if (!__OFADD__(a1, BYTE6(v3)))
  {
    *(void *)(v6 - 96) = sub_1876B910C(a1 + BYTE6(v3));
    *(void *)(v6 - 88) = v7;
    sub_18786075C();
    uint64_t v8 = *(void *)(v6 - 120);
    sub_18786075C();
    sub_1876B8E88(v4, v5);
    sub_1876B8E88(v8, v3);
    (*(void (**)(uint64_t, void))(v1 + 8))(v2, *(void *)(v6 - 72));
    JUMPOUT(0x1876B48D4LL);
  }

  __break(1u);
  JUMPOUT(0x1876B4A24LL);
}

uint64_t NEIKEv2CryptoKitHPKE.performHPKEOpen()()
{
  uint64_t v2 = sub_1878609A8();
  uint64_t v3 = *(void *)(v2 - 8);
  MEMORY[0x1895F8858](v2);
  unint64_t v5 = (char *)&v17 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_payload);
  unint64_t v7 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_payload + 8);
  sub_1876B9070(v6, v7);
  sub_1876B4C60(32LL, v6, v7);
  uint64_t v9 = v21;
  unint64_t v8 = v22;
  sub_1876B9070(v6, v7);
  sub_1876B4DDC(32LL, v6, v7);
  uint64_t v10 = v21;
  unint64_t v11 = v22;
  sub_1876B3FA4(v9, v8, (uint64_t)v5);
  if (v1)
  {
    sub_1876B8E88(v10, v11);
    sub_1876B8E88(v9, v8);
  }

  else
  {
    uint64_t v18 = v3;
    uint64_t v23 = v2;
    uint64_t v21 = v10;
    unint64_t v22 = v11;
    uint64_t v12 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_aad);
    unint64_t v13 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_aad + 8);
    if (v13 >> 60 == 15) {
      uint64_t v14 = 0LL;
    }
    else {
      uint64_t v14 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_aad);
    }
    if (v13 >> 60 == 15) {
      unint64_t v15 = 0xC000000000000000LL;
    }
    else {
      unint64_t v15 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_aad + 8);
    }
    uint64_t v17 = v14;
    uint64_t v19 = v14;
    unint64_t v20 = v15;
    sub_1876B90B4(v12, v13);
    sub_1876B90C8();
    uint64_t v0 = sub_18786099C();
    sub_1876B8E88(v9, v8);
    sub_1876B8E88(v17, v15);
    (*(void (**)(char *, uint64_t))(v18 + 8))(v5, v23);
    sub_1876B8E88(v10, v11);
  }

  return v0;
}

void sub_1876B4C60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a1 & 0x8000000000000000LL) == 0) {
    __asm { BR              X9 }
  }

  __break(1u);
  JUMPOUT(0x1876B4DA8LL);
}

void sub_1876B4DDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a1 & 0x8000000000000000LL) == 0) {
    __asm { BR              X9 }
  }

  __break(1u);
  JUMPOUT(0x1876B4F38LL);
}

void NEIKEv2CryptoKitHPKE.init()()
{
}

BOOL sub_1876B5064(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2) & 1) == 0;
}

uint64_t NEIKEv2CryptoKitSPAKE2Plus.__allocating_init(seed:initiatorID:responderID:salt:context:forInitiator:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, unint64_t a10, char a11)
{
  id v17 = objc_allocWithZone(v11);
  return NEIKEv2CryptoKitSPAKE2Plus.init(seed:initiatorID:responderID:salt:context:forInitiator:)( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  a10,  a11);
}

uint64_t NEIKEv2CryptoKitSPAKE2Plus.init(seed:initiatorID:responderID:salt:context:forInitiator:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, unint64_t a10, char a11)
{
  unint64_t v74 = a8;
  uint64_t v12 = v11;
  unint64_t v75 = a6;
  uint64_t v76 = a3;
  uint64_t v72 = a5;
  unint64_t v77 = a4;
  unint64_t v78 = a2;
  uint64_t v79 = a1;
  ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v14 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A28);
  MEMORY[0x1895F8858](v14);
  uint64_t v61 = (char *)&v57 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A30);
  MEMORY[0x1895F8858](v16);
  uint64_t v60 = (char *)&v57 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = sub_187860780();
  uint64_t v82 = *(void *)(v18 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  uint64_t v71 = (char *)&v57 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v70 = (char *)&v57 - v22;
  MEMORY[0x1895F8858](v21);
  uint64_t v80 = (char *)&v57 - v23;
  uint64_t v24 = sub_187860B64();
  uint64_t v25 = *(void *)(v24 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v27 = (char *)&v57 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v28 = (uint64_t)v11 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_prover;
  uint64_t v29 = sub_1878607BC();
  uint64_t v30 = *(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v29 - 8) + 56LL);
  uint64_t v63 = v28;
  uint64_t v59 = v29;
  uint64_t v58 = v30;
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v28, 1LL, 1LL);
  uint64_t v31 = (uint64_t)v12 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_verifier;
  uint64_t v32 = sub_1878607F8();
  uint64_t v33 = *(void (**)(char *, void, uint64_t, char *))(*(void *)(v32 - 8) + 56LL);
  uint64_t v62 = v31;
  unint64_t v57 = v33;
  v33((char *)v31, 1LL, 1LL, (char *)v32);
  id v34 = v12;
  sub_187860B58();
  uint64_t v35 = sub_187860B4C();
  unint64_t v37 = v36;
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v25 + 8))(v27, v24);
  if (v37 >> 60 != 15)
  {
    uint64_t v67 = v35;
    unint64_t v68 = v37;
    (*(void (**)(char *, void, uint64_t))(v82 + 104))(v80, *MEMORY[0x18960F108], v18);
    uint64_t v65 = v18;
    id v64 = v34;
    uint64_t v66 = a7;
    if ((a11 & 1) != 0)
    {
      *((_BYTE *)v34 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_role) = 0;
      (*(void (**)(char *, char *, uint64_t))(v82 + 16))(v70, v80, v18);
      unint64_t v39 = v78;
      sub_1876B9070(v79, v78);
      uint64_t v40 = a7;
      unint64_t v41 = v74;
      sub_1876B9070(v40, v74);
      sub_1876B9070(a9, a10);
      uint64_t v42 = v72;
      unint64_t v43 = v75;
      sub_1876B9070(v72, v75);
      uint64_t v45 = v76;
      unint64_t v44 = v77;
      sub_1876B9070(v76, v77);
      uint64_t v46 = v66;
      uint64_t v47 = v73;
      sub_1878607A4();
      uint64_t v73 = v47;
      if (!v47)
      {
        uint64_t v48 = a9;
        id v49 = v64;
        uint64_t v50 = v46;
        (*(void (**)(char *, uint64_t))(v82 + 8))(v80, v65);
        uint64_t v51 = (uint64_t)v60;
        v58(v60, 0LL, 1LL, v59);
        uint64_t v52 = v63;
        swift_beginAccess();
        unint64_t v53 = &qword_18C6E1A30;
LABEL_8:
        sub_1876B9230(v51, v52, v53);
        swift_endAccess();

        v81.receiver = v49;
        v81.super_class = ObjectType;
        id v56 = objc_msgSendSuper2(&v81, sel_init);
        sub_1876B8E88(v48, a10);
        sub_1876B8E88(v50, v74);
        sub_1876B8E88(v42, v75);
        sub_1876B8E88(v76, v77);
        sub_1876B8E88(v79, v78);
        return (uint64_t)v56;
      }
    }

    else
    {
      uint64_t v70 = (char *)v32;
      *((_BYTE *)v34 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_role) = 1;
      (*(void (**)(char *, char *, uint64_t))(v82 + 16))(v71, v80, v18);
      unint64_t v39 = v78;
      sub_1876B9070(v79, v78);
      uint64_t v54 = a7;
      unint64_t v41 = v74;
      sub_1876B9070(v54, v74);
      sub_1876B9070(a9, a10);
      uint64_t v42 = v72;
      unint64_t v43 = v75;
      sub_1876B9070(v72, v75);
      uint64_t v45 = v76;
      unint64_t v44 = v77;
      sub_1876B9070(v76, v77);
      uint64_t v46 = v66;
      uint64_t v55 = v73;
      sub_1878607E0();
      uint64_t v73 = v55;
      if (!v55)
      {
        uint64_t v48 = a9;
        id v49 = v64;
        uint64_t v50 = v46;
        (*(void (**)(char *, uint64_t))(v82 + 8))(v80, v65);
        uint64_t v51 = (uint64_t)v61;
        v57(v61, 0LL, 1LL, v70);
        uint64_t v52 = v62;
        swift_beginAccess();
        unint64_t v53 = &qword_18C6E1A28;
        goto LABEL_8;
      }
    }

    sub_1876B8E88(a9, a10);
    sub_1876B8E88(v46, v41);
    sub_1876B8E88(v42, v43);
    sub_1876B8E88(v45, v44);
    sub_1876B8E88(v79, v39);
    (*(void (**)(char *, uint64_t))(v82 + 8))(v80, v65);
    sub_1876B9C94(v63, &qword_18C6E1A30);
    sub_1876B9C94(v62, &qword_18C6E1A28);
    id v56 = v64;

    swift_deallocPartialClassInstance();
    return (uint64_t)v56;
  }

  __break(1u);
  return result;
}

uint64_t NEIKEv2CryptoKitSPAKE2Plus.getFirstMessage()()
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A28);
  MEMORY[0x1895F8858](v3);
  unint64_t v5 = (char *)&v18 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A30);
  MEMORY[0x1895F8858](v6);
  unint64_t v8 = (char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((*(_BYTE *)(v0 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_role) & 1) != 0)
  {
    uint64_t v9 = v0 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_verifier;
    swift_beginAccess();
    sub_1876B9C50(v9, (uint64_t)v5, &qword_18C6E1A28);
    uint64_t v10 = sub_1878607F8();
    uint64_t v11 = *(void *)(v10 - 8);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v11 + 48))(v5, 1LL, v10);
    if ((_DWORD)result != 1)
    {
      uint64_t v13 = sub_1878607EC();
      if (!v1) {
        uint64_t v2 = v13;
      }
      (*(void (**)(char *, uint64_t))(v11 + 8))(v5, v10);
      return v2;
    }

    __break(1u);
  }

  else
  {
    uint64_t v14 = v0 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_prover;
    swift_beginAccess();
    sub_1876B9C50(v14, (uint64_t)v8, &qword_18C6E1A30);
    uint64_t v15 = sub_1878607BC();
    uint64_t v16 = *(void *)(v15 - 8);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v16 + 48))(v8, 1LL, v15);
    if ((_DWORD)result != 1)
    {
      uint64_t v17 = sub_1878607B0();
      if (!v1) {
        uint64_t v2 = v17;
      }
      (*(void (**)(char *, uint64_t))(v16 + 8))(v8, v15);
      return v2;
    }
  }

  __break(1u);
  return result;
}

id sub_1876B5AE4(void *a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  id v5 = a1;
  uint64_t v6 = a4();
  unint64_t v8 = v7;

  uint64_t v9 = (void *)sub_187860744();
  sub_1876B8E88(v6, v8);
  return v9;
}

uint64_t NEIKEv2CryptoKitSPAKE2Plus.processFirstPeerMessage(_:)()
{
  if ((*(_BYTE *)(v0 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_role) & 1) != 0)
  {
    uint64_t v1 = v0 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_verifier;
    swift_beginAccess();
    uint64_t v2 = sub_1878607F8();
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v2 - 8) + 48LL))(v1, 1LL, v2);
    if ((_DWORD)result != 1)
    {
      uint64_t v4 = sub_1878607D4();
LABEL_6:
      uint64_t v7 = v4;
      swift_endAccess();
      return v7;
    }

    __break(1u);
  }

  else
  {
    uint64_t v5 = v0 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_prover;
    swift_beginAccess();
    uint64_t v6 = sub_1878607BC();
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 48LL))(v5, 1LL, v6);
    if ((_DWORD)result != 1)
    {
      uint64_t v4 = sub_187860798();
      goto LABEL_6;
    }
  }

  __break(1u);
  return result;
}

uint64_t NEIKEv2CryptoKitSPAKE2Plus.processSecondPeerMessage(_:)()
{
  uint64_t v2 = sub_187860774();
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = MEMORY[0x1895F8858](v2);
  uint64_t v6 = (char *)v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = MEMORY[0x1895F8858](v4);
  uint64_t v9 = (char *)v17 - v8;
  MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)v17 - v10;
  if ((*(_BYTE *)(v0 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_role) & 1) != 0)
  {
    uint64_t v12 = v0 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_verifier;
    swift_beginAccess();
    uint64_t v13 = sub_1878607F8();
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v13 - 8) + 48LL))(v12, 1LL, v13);
    if ((_DWORD)result != 1)
    {
      sub_1878607C8();
      uint64_t result = swift_endAccess();
      uint64_t v9 = v6;
      if (v1) {
        return result;
      }
LABEL_7:
      (*(void (**)(char *, char *, uint64_t))(v3 + 32))(v11, v9, v2);
      sub_1876B91E0();
      sub_187860768();
      (*(void (**)(char *, uint64_t))(v3 + 8))(v11, v2);
      return v17[1];
    }

    __break(1u);
LABEL_9:
    __break(1u);
    return result;
  }

  uint64_t v15 = v0 + OBJC_IVAR____TtC16NetworkExtension26NEIKEv2CryptoKitSPAKE2Plus_prover;
  swift_beginAccess();
  uint64_t v16 = sub_1878607BC();
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v16 - 8) + 48LL))(v15, 1LL, v16);
  if ((_DWORD)result == 1) {
    goto LABEL_9;
  }
  sub_18786078C();
  uint64_t result = swift_endAccess();
  if (!v1) {
    goto LABEL_7;
  }
  return result;
}

id sub_1876B5FD4@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return sub_1876B7584(a1, a2, a3);
}

void NEIKEv2CryptoKitSPAKE2Plus.init()()
{
}

uint64_t NEIKEv2CryptoKitECDH.keyExchangeData.getter()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_keyExchangeData);
  sub_1876B9070(v1, *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_keyExchangeData + 8));
  return v1;
}

uint64_t NEIKEv2CryptoKitECDH.sharedSecret.getter()
{
  uint64_t v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A48);
  MEMORY[0x1895F8858](v1);
  uint64_t v3 = (char *)v10 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = sub_1878608B8();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](v4);
  uint64_t v7 = (char *)v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = v0 + OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_internalSharedSecret;
  swift_beginAccess();
  sub_1876B9C50(v8, (uint64_t)v3, &qword_18C6E1A48);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v5 + 48))(v3, 1LL, v4) == 1)
  {
    sub_1876B9C94((uint64_t)v3, &qword_18C6E1A48);
    return 0LL;
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v5 + 32))(v7, v3, v4);
    sub_1876B91E0();
    sub_1878608AC();
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    return v10[2];
  }

uint64_t sub_1876B6330()
{
  return sub_1876B75EC();
}

uint64_t NEIKEv2CryptoKitECDH.processPeerPayload(_:)(uint64_t a1, uint64_t a2)
{
  return sub_1876B7664( a1,  a2,  &qword_18C6E1A48,  (uint64_t (*)(void))MEMORY[0x189605988],  &OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_internalSharedSecret);
}

void NEIKEv2CryptoKitECDH.init()()
{
}

id NEIKEv2CryptoKitECDH.__deallocating_deinit()
{
  return sub_1876B79A8(type metadata accessor for NEIKEv2CryptoKitECDH);
}

id NEIKEv2CryptoKitP256.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);
  return NEIKEv2CryptoKitP256.init()();
}

id NEIKEv2CryptoKitP256.init()()
{
  id v1 = v0;
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A48);
  MEMORY[0x1895F8858](v2);
  uint64_t v4 = (char *)&v24 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = sub_1878609C0();
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](v5);
  uint64_t v8 = (char *)&v24 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_1878609E4();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_1878609D8();
  (*(void (**)(char *, char *, uint64_t))(v10 + 16))( &v0[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitP256_privateKey],  v12,  v9);
  sub_1878609CC();
  uint64_t v13 = sub_1878609B4();
  unint64_t v15 = v14;
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  uint64_t v16 = (uint64_t)&v1[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_internalSharedSecret];
  uint64_t v17 = sub_1878608B8();
  uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v17 - 8) + 56LL);
  v18(v16, 1LL, 1LL, v17);
  uint64_t v19 = (uint64_t *)&v1[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_keyExchangeData];
  *uint64_t v19 = v13;
  v19[1] = v15;
  v18((uint64_t)v4, 1LL, 1LL, v17);
  swift_beginAccess();
  uint64_t v20 = v1;
  sub_1876B9070(v13, v15);
  sub_1876B9230((uint64_t)v4, v16, &qword_18C6E1A48);
  swift_endAccess();

  uint64_t v21 = (objc_class *)type metadata accessor for NEIKEv2CryptoKitECDH(0LL);
  v25.receiver = v20;
  v25.super_class = v21;
  id v22 = objc_msgSendSuper2(&v25, sel_init);
  sub_1876B8E88(v13, v15);
  (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v9);
  return v22;
}

uint64_t sub_1876B6674(uint64_t a1, unint64_t a2)
{
  return sub_1876B71C0( a1,  a2,  (uint64_t (*)(void))MEMORY[0x189605C08],  MEMORY[0x189605BD8],  (uint64_t)&OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitP256_privateKey,  MEMORY[0x189605C18]);
}

uint64_t sub_1876B66A8()
{
  return sub_1876B72D4( &OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitP256_privateKey,  (uint64_t (*)(void))MEMORY[0x189605C68]);
}

id NEIKEv2CryptoKitP384.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);
  return NEIKEv2CryptoKitP384.init()();
}

id NEIKEv2CryptoKitP384.init()()
{
  id v1 = v0;
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A48);
  MEMORY[0x1895F8858](v2);
  uint64_t v4 = (char *)&v24 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = sub_1878609FC();
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](v5);
  uint64_t v8 = (char *)&v24 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_187860A20();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_187860A14();
  (*(void (**)(char *, char *, uint64_t))(v10 + 16))( &v0[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitP384_privateKey],  v12,  v9);
  sub_187860A08();
  uint64_t v13 = sub_1878609B4();
  unint64_t v15 = v14;
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  uint64_t v16 = (uint64_t)&v1[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_internalSharedSecret];
  uint64_t v17 = sub_1878608B8();
  uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v17 - 8) + 56LL);
  v18(v16, 1LL, 1LL, v17);
  uint64_t v19 = (uint64_t *)&v1[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_keyExchangeData];
  *uint64_t v19 = v13;
  v19[1] = v15;
  v18((uint64_t)v4, 1LL, 1LL, v17);
  swift_beginAccess();
  uint64_t v20 = v1;
  sub_1876B9070(v13, v15);
  sub_1876B9230((uint64_t)v4, v16, &qword_18C6E1A48);
  swift_endAccess();

  uint64_t v21 = (objc_class *)type metadata accessor for NEIKEv2CryptoKitECDH(0LL);
  v25.receiver = v20;
  v25.super_class = v21;
  id v22 = objc_msgSendSuper2(&v25, sel_init);
  sub_1876B8E88(v13, v15);
  (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v9);
  return v22;
}

uint64_t sub_1876B693C(uint64_t a1, unint64_t a2)
{
  return sub_1876B71C0( a1,  a2,  (uint64_t (*)(void))MEMORY[0x189605CC8],  MEMORY[0x189605CB0],  (uint64_t)&OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitP384_privateKey,  MEMORY[0x189605CD0]);
}

uint64_t sub_1876B6970()
{
  return sub_1876B72D4( &OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitP384_privateKey,  (uint64_t (*)(void))MEMORY[0x189605CE8]);
}

id NEIKEv2CryptoKitP521.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);
  return NEIKEv2CryptoKitP521.init()();
}

id NEIKEv2CryptoKitP521.init()()
{
  id v1 = v0;
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A48);
  MEMORY[0x1895F8858](v2);
  uint64_t v4 = (char *)&v24 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = sub_187860A38();
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](v5);
  uint64_t v8 = (char *)&v24 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_187860A5C();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_187860A50();
  (*(void (**)(char *, char *, uint64_t))(v10 + 16))( &v0[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitP521_privateKey],  v12,  v9);
  sub_187860A44();
  uint64_t v13 = sub_1878609B4();
  unint64_t v15 = v14;
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  uint64_t v16 = (uint64_t)&v1[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_internalSharedSecret];
  uint64_t v17 = sub_1878608B8();
  uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v17 - 8) + 56LL);
  v18(v16, 1LL, 1LL, v17);
  uint64_t v19 = (uint64_t *)&v1[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_keyExchangeData];
  *uint64_t v19 = v13;
  v19[1] = v15;
  v18((uint64_t)v4, 1LL, 1LL, v17);
  swift_beginAccess();
  uint64_t v20 = v1;
  sub_1876B9070(v13, v15);
  sub_1876B9230((uint64_t)v4, v16, &qword_18C6E1A48);
  swift_endAccess();

  uint64_t v21 = (objc_class *)type metadata accessor for NEIKEv2CryptoKitECDH(0LL);
  v25.receiver = v20;
  v25.super_class = v21;
  id v22 = objc_msgSendSuper2(&v25, sel_init);
  sub_1876B8E88(v13, v15);
  (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v9);
  return v22;
}

uint64_t sub_1876B6C04(uint64_t a1, unint64_t a2)
{
  return sub_1876B71C0( a1,  a2,  (uint64_t (*)(void))MEMORY[0x189605D90],  MEMORY[0x189605D88],  (uint64_t)&OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitP521_privateKey,  MEMORY[0x189605D98]);
}

uint64_t sub_1876B6C38()
{
  return sub_1876B72D4( &OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitP521_privateKey,  (uint64_t (*)(void))MEMORY[0x189605DB0]);
}

id NEIKEv2CryptoKitX25519.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);
  return NEIKEv2CryptoKitX25519.init()();
}

id NEIKEv2CryptoKitX25519.init()()
{
  id v1 = v0;
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A48);
  MEMORY[0x1895F8858](v2);
  uint64_t v4 = (char *)&v24 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = sub_187860870();
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](v5);
  uint64_t v8 = (char *)&v24 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_1878608A0();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_187860894();
  (*(void (**)(char *, char *, uint64_t))(v10 + 16))( &v0[OBJC_IVAR____TtC16NetworkExtension22NEIKEv2CryptoKitX25519_privateKey],  v12,  v9);
  sub_18786087C();
  uint64_t v13 = sub_187860858();
  unint64_t v15 = v14;
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  uint64_t v16 = (uint64_t)&v1[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_internalSharedSecret];
  uint64_t v17 = sub_1878608B8();
  uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v17 - 8) + 56LL);
  v18(v16, 1LL, 1LL, v17);
  uint64_t v19 = (uint64_t *)&v1[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_keyExchangeData];
  *uint64_t v19 = v13;
  v19[1] = v15;
  v18((uint64_t)v4, 1LL, 1LL, v17);
  swift_beginAccess();
  uint64_t v20 = v1;
  sub_1876B9070(v13, v15);
  sub_1876B9230((uint64_t)v4, v16, &qword_18C6E1A48);
  swift_endAccess();

  uint64_t v21 = (objc_class *)type metadata accessor for NEIKEv2CryptoKitECDH(0LL);
  v25.receiver = v20;
  v25.super_class = v21;
  id v22 = objc_msgSendSuper2(&v25, sel_init);
  sub_1876B8E88(v13, v15);
  (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v9);
  return v22;
}

uint64_t sub_1876B6EC8(uint64_t a1, unint64_t a2)
{
  return sub_1876B71C0( a1,  a2,  (uint64_t (*)(void))MEMORY[0x189605890],  (uint64_t (*)(void *, void, void))MEMORY[0x189605880],  (uint64_t)&OBJC_IVAR____TtC16NetworkExtension22NEIKEv2CryptoKitX25519_privateKey,  MEMORY[0x1896058A0]);
}

uint64_t sub_1876B6EFC()
{
  return sub_1876B72D4( &OBJC_IVAR____TtC16NetworkExtension22NEIKEv2CryptoKitX25519_privateKey,  (uint64_t (*)(void))MEMORY[0x1896058C8]);
}

id NEIKEv2CryptoKitX448.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);
  return NEIKEv2CryptoKitX448.init()();
}

id NEIKEv2CryptoKitX448.init()()
{
  id v1 = v0;
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A48);
  MEMORY[0x1895F8858](v2);
  uint64_t v4 = (char *)&v24 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = sub_187860A74();
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](v5);
  uint64_t v8 = (char *)&v24 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_187860A98();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_187860A8C();
  (*(void (**)(char *, char *, uint64_t))(v10 + 16))( &v0[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitX448_privateKey],  v12,  v9);
  sub_187860A80();
  uint64_t v13 = sub_187860A68();
  unint64_t v15 = v14;
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  uint64_t v16 = (uint64_t)&v1[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_internalSharedSecret];
  uint64_t v17 = sub_1878608B8();
  uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v17 - 8) + 56LL);
  v18(v16, 1LL, 1LL, v17);
  uint64_t v19 = (uint64_t *)&v1[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitECDH_keyExchangeData];
  *uint64_t v19 = v13;
  v19[1] = v15;
  v18((uint64_t)v4, 1LL, 1LL, v17);
  swift_beginAccess();
  uint64_t v20 = v1;
  sub_1876B9070(v13, v15);
  sub_1876B9230((uint64_t)v4, v16, &qword_18C6E1A48);
  swift_endAccess();

  uint64_t v21 = (objc_class *)type metadata accessor for NEIKEv2CryptoKitECDH(0LL);
  v25.receiver = v20;
  v25.super_class = v21;
  id v22 = objc_msgSendSuper2(&v25, sel_init);
  sub_1876B8E88(v13, v15);
  (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v9);
  return v22;
}

uint64_t sub_1876B718C(uint64_t a1, unint64_t a2)
{
  return sub_1876B71C0( a1,  a2,  (uint64_t (*)(void))MEMORY[0x189605E40],  MEMORY[0x189605E38],  (uint64_t)&OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitX448_privateKey,  MEMORY[0x189605E48]);
}

uint64_t sub_1876B71C0( uint64_t a1, unint64_t a2, uint64_t (*a3)(void), uint64_t (*a4)(void *, void, void), uint64_t a5, void (*a6)(char *))
{
  uint64_t v17 = a6;
  v15[1] = a5;
  uint64_t v10 = a3(0LL);
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)v15 - v12;
  v16[0] = a1;
  v16[1] = a2;
  sub_1876B9070(a1, a2);
  uint64_t result = a4(v16, MEMORY[0x189606D70], MEMORY[0x189606D58]);
  if (!v6)
  {
    v17(v13);
    return (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v13, v10);
  }

  return result;
}

uint64_t sub_1876B72C0()
{
  return sub_1876B72D4( &OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitX448_privateKey,  (uint64_t (*)(void))MEMORY[0x189605E60]);
}

uint64_t sub_1876B72D4(void *a1, uint64_t (*a2)(void))
{
  uint64_t v3 = v2 + *a1;
  uint64_t v4 = a2(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8LL))(v3, v4);
}

uint64_t sub_1876B7324(uint64_t a1, uint64_t a2, void *a3, uint64_t (*a4)(void))
{
  uint64_t v4 = a1 + *a3;
  uint64_t v5 = a4(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v5 - 8) + 8LL))(v4, v5);
}

id sub_1876B7368(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = (uint64_t *)(a1 + *a3);
  uint64_t v4 = *v3;
  unint64_t v5 = v3[1];
  sub_1876B9070(*v3, v5);
  uint64_t v6 = (void *)sub_187860744();
  sub_1876B8E88(v4, v5);
  return v6;
}

uint64_t NEIKEv2CryptoKitKEM.keyExchangeData.getter()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_keyExchangeData);
  sub_1876B9070(v1, *(void *)(v0 + OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_keyExchangeData + 8));
  return v1;
}

uint64_t NEIKEv2CryptoKitKEM.sharedSecret.getter()
{
  uint64_t v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A50);
  MEMORY[0x1895F8858](v1);
  uint64_t v3 = (char *)v10 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = sub_1878608DC();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](v4);
  uint64_t v7 = (char *)v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = v0 + OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_internalSharedSecret;
  swift_beginAccess();
  sub_1876B9C50(v8, (uint64_t)v3, &qword_18C6E1A50);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v5 + 48))(v3, 1LL, v4) == 1)
  {
    sub_1876B9C94((uint64_t)v3, &qword_18C6E1A50);
    return 0LL;
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v5 + 32))(v7, v3, v4);
    sub_1876B91E0();
    sub_1878608C4();
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    return v10[2];
  }

id sub_1876B7584@<X0>(id result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (result)
  {
    uint64_t result = objc_msgSend((id)objc_opt_self(), sel__newZeroingDataWithBytes_length_, result, a2 - (void)result);
    if (result)
    {
      *a3 = result;
      return result;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

uint64_t sub_1876B75EC()
{
  *uint64_t v0 = 2;
  return swift_willThrow();
}

uint64_t NEIKEv2CryptoKitKEM.processPeerPayload(_:)(uint64_t a1, uint64_t a2)
{
  return sub_1876B7664( a1,  a2,  &qword_18C6E1A50,  (uint64_t (*)(void))MEMORY[0x1896059B0],  &OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_internalSharedSecret);
}

uint64_t sub_1876B7664(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t (*a4)(void), void *a5)
{
  uint64_t v12 = __swift_instantiateConcreteTypeFromMangledName(a3);
  MEMORY[0x1895F8858](v12);
  unint64_t v14 = (char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))((*MEMORY[0x18961B398] & *v5) + 0x68LL))(a1, a2);
  if (!v6)
  {
    uint64_t v16 = a4(0LL);
    (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v16 - 8) + 56LL))(v14, 0LL, 1LL, v16);
    uint64_t v17 = (uint64_t)v5 + *a5;
    swift_beginAccess();
    sub_1876B9230((uint64_t)v14, v17, a3);
    return swift_endAccess();
  }

  return result;
}

uint64_t sub_1876B7794( void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t *a5, uint64_t (*a6)(void), void *a7)
{
  uint64_t v12 = __swift_instantiateConcreteTypeFromMangledName(a5);
  MEMORY[0x1895F8858](v12);
  unint64_t v14 = &v23[-((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  id v15 = a3;
  uint64_t v16 = a1;
  uint64_t v17 = sub_187860750();
  unint64_t v19 = v18;

  (*(void (**)(uint64_t, unint64_t))((*MEMORY[0x18961B398] & *v16) + 0x68LL))(v17, v19);
  uint64_t v20 = a6(0LL);
  (*(void (**)(_BYTE *, void, uint64_t, uint64_t))(*(void *)(v20 - 8) + 56LL))(v14, 0LL, 1LL, v20);
  uint64_t v21 = (uint64_t)v16 + *a7;
  swift_beginAccess();
  sub_1876B9230((uint64_t)v14, v21, a5);
  swift_endAccess();

  sub_1876B8E88(v17, v19);
  return 1LL;
}

id NEIKEv2CryptoKitKEM.__allocating_init()()
{
  return objc_msgSend(objc_allocWithZone(v0), sel_init);
}

void NEIKEv2CryptoKitKEM.init()()
{
}

id NEIKEv2CryptoKitKEM.__deallocating_deinit()
{
  return sub_1876B79A8(type metadata accessor for NEIKEv2CryptoKitKEM);
}

id sub_1876B79A8(uint64_t (*a1)(void))
{
  v3.receiver = v1;
  v3.super_class = (Class)a1(0LL);
  return objc_msgSendSuper2(&v3, sel_dealloc);
}

uint64_t sub_1876B79FC(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4, void *a5)
{
  return sub_1876B8E88(*(void *)(a1 + *a5), *(void *)(a1 + *a5 + 8));
}

void (**NEIKEv2CryptoKitMLKEM768.__allocating_init()())(char *, uint64_t)
{
  id v1 = objc_allocWithZone(v0);
  return NEIKEv2CryptoKitMLKEM768.init()();
}

void (**NEIKEv2CryptoKitMLKEM768.init()())(char *, uint64_t)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A50);
  MEMORY[0x1895F8858](v2);
  uint64_t v29 = (char *)&v25 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = sub_187860AEC();
  uint64_t v5 = *(void (***)(char *, uint64_t))(v4 - 8);
  MEMORY[0x1895F8858](v4);
  uint64_t v7 = (char *)&v25 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = sub_187860ABC();
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v25 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = v0;
  sub_187860AB0();
  if (v1)
  {

    swift_deallocPartialClassInstance();
  }

  else
  {
    uint64_t v13 = &v12[OBJC_IVAR____TtC16NetworkExtension24NEIKEv2CryptoKitMLKEM768_privateKey];
    (*(void (**)(char *, char *, uint64_t))(v9 + 16))( &v12[OBJC_IVAR____TtC16NetworkExtension24NEIKEv2CryptoKitMLKEM768_privateKey],  v11,  v8);
    (*(void (**)(char *, void, uint64_t, uint64_t))(v9 + 56))(v13, 0LL, 1LL, v8);

    sub_187860AA4();
    uint64_t v14 = sub_187860AD4();
    uint64_t v26 = v8;
    unint64_t v16 = v15;
    v5[1](v7, v4);
    uint64_t v17 = (uint64_t)&v12[OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_internalSharedSecret];
    uint64_t v18 = sub_1878608DC();
    unint64_t v19 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v18 - 8) + 56LL);
    v19(v17, 1LL, 1LL, v18);
    uint64_t v20 = (uint64_t *)&v12[OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_keyExchangeData];
    *uint64_t v20 = v14;
    v20[1] = v16;
    uint64_t v27 = 0LL;
    uint64_t v21 = (uint64_t)v29;
    v19((uint64_t)v29, 1LL, 1LL, v18);
    swift_beginAccess();
    id v22 = v12;
    sub_1876B9070(v14, v16);
    sub_1876B9230(v21, v17, &qword_18C6E1A50);
    swift_endAccess();

    uint64_t v23 = (objc_class *)type metadata accessor for NEIKEv2CryptoKitKEM(0LL);
    v28.receiver = v22;
    v28.super_class = v23;
    uint64_t v5 = (void (**)(char *, uint64_t))objc_msgSendSuper2(&v28, sel_init);
    sub_1876B8E88(v14, v16);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v26);
  }

  return v5;
}

char *NEIKEv2CryptoKitMLKEM768.__allocating_init(publicKeyData:)(uint64_t a1, unint64_t a2)
{
  id v5 = objc_allocWithZone(v2);
  return NEIKEv2CryptoKitMLKEM768.init(publicKeyData:)(a1, a2);
}

char *NEIKEv2CryptoKitMLKEM768.init(publicKeyData:)(uint64_t a1, unint64_t a2)
{
  uint64_t ObjectType = swift_getObjectType();
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A50);
  MEMORY[0x1895F8858](v5);
  uint64_t v39 = (uint64_t)&v33 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v38 = sub_187860918();
  uint64_t v7 = *(void *)(v38 - 8);
  MEMORY[0x1895F8858](v38);
  uint64_t v40 = (char *)&v33 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_187860AEC();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v33 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = &v2[OBJC_IVAR____TtC16NetworkExtension24NEIKEv2CryptoKitMLKEM768_privateKey];
  uint64_t v14 = sub_187860ABC();
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v14 - 8) + 56LL))(v13, 1LL, 1LL, v14);
  uint64_t v43 = a1;
  unint64_t v44 = a2;
  unint64_t v15 = v2;
  unint64_t v16 = a2;
  uint64_t v17 = v15;
  sub_1876B9070(a1, v16);
  uint64_t v18 = v45;
  sub_187860AE0();
  if (v18)
  {
    sub_1876B8E88(a1, v16);
    sub_1876B9C94((uint64_t)v13, (uint64_t *)&unk_18C6E1A58);

    swift_deallocPartialClassInstance();
  }

  else
  {
    uint64_t v35 = v10;
    uint64_t v36 = a1;
    uint64_t v34 = v7;
    unint64_t v37 = v16;
    uint64_t v45 = v9;
    unint64_t v19 = v40;
    sub_187860AC8();

    uint64_t v21 = sub_187860900();
    unint64_t v23 = v22;
    uint64_t v24 = (uint64_t)&v17[OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_internalSharedSecret];
    uint64_t v25 = sub_1878608DC();
    uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v25 - 8) + 56LL);
    uint64_t ObjectType = v25;
    v26(v24, 1LL, 1LL, v25);
    uint64_t v27 = (uint64_t *)&v17[OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_keyExchangeData];
    *uint64_t v27 = v21;
    v27[1] = v23;
    v26(v39, 1LL, 1LL, v25);
    swift_beginAccess();
    objc_super v28 = v17;
    sub_1876B9070(v21, v23);
    uint64_t v29 = v39;
    sub_1876B9230(v39, v24, &qword_18C6E1A50);
    swift_endAccess();

    uint64_t v30 = (objc_class *)type metadata accessor for NEIKEv2CryptoKitKEM(0LL);
    v42.receiver = v28;
    v42.super_class = v30;
    id v31 = objc_msgSendSuper2(&v42, sel_init);
    sub_1876B8E88(v21, v23);
    uint64_t v13 = (char *)v31;
    sub_18786090C();
    sub_1876B8E88(v36, v37);
    (*(void (**)(char *, uint64_t))(v34 + 8))(v19, v38);
    (*(void (**)(char *, uint64_t))(v35 + 8))(v12, v45);
    v26(v29, 0LL, 1LL, ObjectType);
    uint64_t v32 = (uint64_t)&v13[OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_internalSharedSecret];
    swift_beginAccess();
    sub_1876B9230(v29, v32, &qword_18C6E1A50);
    swift_endAccess();
  }

  return v13;
}

uint64_t sub_1876B810C(uint64_t a1, uint64_t a2)
{
  return sub_1876B89BC( a1,  a2,  (uint64_t *)&unk_18C6E1A58,  (uint64_t (*)(void))MEMORY[0x189605E88],  &OBJC_IVAR____TtC16NetworkExtension24NEIKEv2CryptoKitMLKEM768_privateKey,  MEMORY[0x189605E78]);
}

uint64_t sub_1876B8140()
{
  return sub_1876B9C94( v0 + OBJC_IVAR____TtC16NetworkExtension24NEIKEv2CryptoKitMLKEM768_privateKey,  (uint64_t *)&unk_18C6E1A58);
}

void (**NEIKEv2CryptoKitMLKEM1024.__allocating_init()())(char *, uint64_t)
{
  id v1 = objc_allocWithZone(v0);
  return NEIKEv2CryptoKitMLKEM1024.init()();
}

void (**NEIKEv2CryptoKitMLKEM1024.init()())(char *, uint64_t)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A50);
  MEMORY[0x1895F8858](v2);
  uint64_t v29 = (char *)&v25 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = sub_187860B40();
  uint64_t v5 = *(void (***)(char *, uint64_t))(v4 - 8);
  MEMORY[0x1895F8858](v4);
  uint64_t v7 = (char *)&v25 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = sub_187860B10();
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v25 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = v0;
  sub_187860B04();
  if (v1)
  {

    swift_deallocPartialClassInstance();
  }

  else
  {
    uint64_t v13 = &v12[OBJC_IVAR____TtC16NetworkExtension25NEIKEv2CryptoKitMLKEM1024_privateKey];
    (*(void (**)(char *, char *, uint64_t))(v9 + 16))( &v12[OBJC_IVAR____TtC16NetworkExtension25NEIKEv2CryptoKitMLKEM1024_privateKey],  v11,  v8);
    (*(void (**)(char *, void, uint64_t, uint64_t))(v9 + 56))(v13, 0LL, 1LL, v8);

    sub_187860AF8();
    uint64_t v14 = sub_187860B28();
    uint64_t v26 = v8;
    unint64_t v16 = v15;
    v5[1](v7, v4);
    uint64_t v17 = (uint64_t)&v12[OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_internalSharedSecret];
    uint64_t v18 = sub_1878608DC();
    unint64_t v19 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v18 - 8) + 56LL);
    v19(v17, 1LL, 1LL, v18);
    uint64_t v20 = (uint64_t *)&v12[OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_keyExchangeData];
    *uint64_t v20 = v14;
    v20[1] = v16;
    uint64_t v27 = 0LL;
    uint64_t v21 = (uint64_t)v29;
    v19((uint64_t)v29, 1LL, 1LL, v18);
    swift_beginAccess();
    unint64_t v22 = v12;
    sub_1876B9070(v14, v16);
    sub_1876B9230(v21, v17, &qword_18C6E1A50);
    swift_endAccess();

    unint64_t v23 = (objc_class *)type metadata accessor for NEIKEv2CryptoKitKEM(0LL);
    v28.receiver = v22;
    v28.super_class = v23;
    uint64_t v5 = (void (**)(char *, uint64_t))objc_msgSendSuper2(&v28, sel_init);
    sub_1876B8E88(v14, v16);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v26);
  }

  return v5;
}

uint64_t sub_1876B8478(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  return a4();
}

char *NEIKEv2CryptoKitMLKEM1024.__allocating_init(publicKeyData:)(uint64_t a1, unint64_t a2)
{
  id v5 = objc_allocWithZone(v2);
  return NEIKEv2CryptoKitMLKEM1024.init(publicKeyData:)(a1, a2);
}

char *NEIKEv2CryptoKitMLKEM1024.init(publicKeyData:)(uint64_t a1, unint64_t a2)
{
  uint64_t ObjectType = swift_getObjectType();
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1A50);
  MEMORY[0x1895F8858](v5);
  uint64_t v39 = (uint64_t)&v33 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v38 = sub_187860918();
  uint64_t v7 = *(void *)(v38 - 8);
  MEMORY[0x1895F8858](v38);
  uint64_t v40 = (char *)&v33 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_187860B40();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v33 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = &v2[OBJC_IVAR____TtC16NetworkExtension25NEIKEv2CryptoKitMLKEM1024_privateKey];
  uint64_t v14 = sub_187860B10();
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v14 - 8) + 56LL))(v13, 1LL, 1LL, v14);
  uint64_t v43 = a1;
  unint64_t v44 = a2;
  unint64_t v15 = v2;
  unint64_t v16 = a2;
  uint64_t v17 = v15;
  sub_1876B9070(a1, v16);
  uint64_t v18 = v45;
  sub_187860B34();
  if (v18)
  {
    sub_1876B8E88(a1, v16);
    sub_1876B9C94((uint64_t)v13, &qword_18C6E1A68);

    swift_deallocPartialClassInstance();
  }

  else
  {
    uint64_t v35 = v10;
    uint64_t v36 = a1;
    uint64_t v34 = v7;
    unint64_t v37 = v16;
    uint64_t v45 = v9;
    unint64_t v19 = v40;
    sub_187860B1C();

    uint64_t v21 = sub_187860900();
    unint64_t v23 = v22;
    uint64_t v24 = (uint64_t)&v17[OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_internalSharedSecret];
    uint64_t v25 = sub_1878608DC();
    uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v25 - 8) + 56LL);
    uint64_t ObjectType = v25;
    v26(v24, 1LL, 1LL, v25);
    uint64_t v27 = (uint64_t *)&v17[OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_keyExchangeData];
    *uint64_t v27 = v21;
    v27[1] = v23;
    v26(v39, 1LL, 1LL, v25);
    swift_beginAccess();
    objc_super v28 = v17;
    sub_1876B9070(v21, v23);
    uint64_t v29 = v39;
    sub_1876B9230(v39, v24, &qword_18C6E1A50);
    swift_endAccess();

    uint64_t v30 = (objc_class *)type metadata accessor for NEIKEv2CryptoKitKEM(0LL);
    v42.receiver = v28;
    v42.super_class = v30;
    id v31 = objc_msgSendSuper2(&v42, sel_init);
    sub_1876B8E88(v21, v23);
    uint64_t v13 = (char *)v31;
    sub_18786090C();
    sub_1876B8E88(v36, v37);
    (*(void (**)(char *, uint64_t))(v34 + 8))(v19, v38);
    (*(void (**)(char *, uint64_t))(v35 + 8))(v12, v45);
    v26(v29, 0LL, 1LL, ObjectType);
    uint64_t v32 = (uint64_t)&v13[OBJC_IVAR____TtC16NetworkExtension19NEIKEv2CryptoKitKEM_internalSharedSecret];
    swift_beginAccess();
    sub_1876B9230(v29, v32, &qword_18C6E1A50);
    swift_endAccess();
  }

  return v13;
}

uint64_t sub_1876B88DC( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  id v6 = a3;
  uint64_t v7 = sub_187860750();
  uint64_t v9 = v8;

  return a5(v7, v9);
}

uint64_t sub_1876B8988(uint64_t a1, uint64_t a2)
{
  return sub_1876B89BC( a1,  a2,  &qword_18C6E1A68,  (uint64_t (*)(void))MEMORY[0x189605ED0],  &OBJC_IVAR____TtC16NetworkExtension25NEIKEv2CryptoKitMLKEM1024_privateKey,  MEMORY[0x189605EC0]);
}

uint64_t sub_1876B89BC( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t (*a4)(void), void *a5, void (*a6)(uint64_t, uint64_t))
{
  uint64_t v21 = a6;
  uint64_t v20 = a2;
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(a3);
  MEMORY[0x1895F8858](v11);
  uint64_t v13 = (char *)&v20 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = a4(0LL);
  uint64_t v15 = *(void *)(v14 - 8);
  MEMORY[0x1895F8858](v14);
  uint64_t v17 = (char *)&v20 - v16;
  sub_1876B9C50(v6 + *a5, (uint64_t)v13, a3);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v15 + 48))(v13, 1LL, v14) == 1)
  {
    sub_1876B9C94((uint64_t)v13, a3);
    sub_1876B9C0C();
    swift_allocError();
    *uint64_t v18 = 1;
    return swift_willThrow();
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v15 + 32))(v17, v13, v14);
    v21(a1, v20);
    return (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v17, v14);
  }

uint64_t sub_1876B8B34()
{
  return sub_1876B9C94(v0 + OBJC_IVAR____TtC16NetworkExtension25NEIKEv2CryptoKitMLKEM1024_privateKey, &qword_18C6E1A68);
}

id _s16NetworkExtension20NEIKEv2CryptoKitHPKECfD_0()
{
  v2.receiver = v0;
  v2.super_class = (Class)swift_getObjectType();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

uint64_t sub_1876B8BBC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4 = __OFADD__(a1, a2);
  uint64_t v5 = a1 + a2;
  if (v4)
  {
    __break(1u);
    JUMPOUT(0x1876B8C1CLL);
  }

  return ((uint64_t (*)(uint64_t))((char *)&loc_1876B8BD4 + *((int *)qword_1876B8C20 + (a4 >> 62))))(v5);
}

uint64_t sub_1876B8C30(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return ((uint64_t (*)(void))((char *)&loc_1876B8C40 + *((int *)qword_1876B8CE8 + (a4 >> 62))))();
}

uint64_t sub_1876B8C54@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, unsigned int a3@<W8>)
{
  if (BYTE6(a2) < a1 || a1 < 0)
  {
    __break(1u);
    JUMPOUT(0x1876B8CE0LL);
  }

  return ((uint64_t (*)(void))((char *)&loc_1876B8C90 + *((int *)qword_1876B8CF8 + a3)))();
}

id sub_1876B8D08( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, void *a9)
{
  uint64_t v10 = v9;
  uint64_t v32 = a7;
  unint64_t v33 = a8;
  id v31 = a9;
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v17 = sub_1878608DC();
  uint64_t v18 = *(void *)(v17 - 8);
  MEMORY[0x1895F8858]();
  uint64_t v20 = (char *)&v31 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = (uint64_t *)&v10[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_payload];
  uint64_t *v21 = a1;
  v21[1] = a2;
  unint64_t v22 = (uint64_t *)&v10[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_aad];
  *unint64_t v22 = a3;
  v22[1] = a4;
  uint64_t v36 = a5;
  unint64_t v37 = a6;
  unint64_t v23 = v10;
  sub_1876B9070(a1, a2);
  sub_1876B90B4(a3, a4);
  sub_1876B9070(a5, a6);
  sub_1878608D0();
  (*(void (**)(char *, char *, uint64_t))(v18 + 32))( &v23[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_psk],  v20,  v17);
  uint64_t v24 = (uint64_t *)&v23[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_pskID];
  uint64_t v25 = v32;
  unint64_t v26 = v33;
  uint64_t *v24 = v32;
  v24[1] = v26;
  uint64_t v27 = &v23[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_key];
  objc_super v28 = v31;
  *(void *)uint64_t v27 = v31;
  *((void *)v27 + 1) = 0LL;
  sub_1876B9070(v25, v26);
  id v29 = v28;

  v35.receiver = v23;
  v35.super_class = ObjectType;
  return objc_msgSendSuper2(&v35, sel_init);
}

uint64_t sub_1876B8E88(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_release();
  }

  return swift_release();
}

uint64_t sub_1876B8ECC(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60 != 15) {
    return sub_1876B8E88(a1, a2);
  }
  return a1;
}

id sub_1876B8EE0( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, unint64_t a10)
{
  uint64_t v11 = v10;
  uint64_t v35 = a7;
  unint64_t v36 = a8;
  unint64_t v33 = a10;
  uint64_t v34 = a9;
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v18 = sub_1878608DC();
  uint64_t v19 = *(void *)(v18 - 8);
  MEMORY[0x1895F8858]();
  uint64_t v21 = (char *)&v32 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v22 = (uint64_t *)&v11[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_payload];
  *unint64_t v22 = a1;
  v22[1] = a2;
  unint64_t v23 = (uint64_t *)&v11[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_aad];
  uint64_t *v23 = a3;
  v23[1] = a4;
  uint64_t v39 = a5;
  unint64_t v40 = a6;
  uint64_t v24 = v11;
  sub_1876B9070(a1, a2);
  sub_1876B90B4(a3, a4);
  sub_1876B9070(a5, a6);
  sub_1878608D0();
  (*(void (**)(char *, char *, uint64_t))(v19 + 32))( &v24[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_psk],  v21,  v18);
  uint64_t v25 = (uint64_t *)&v24[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_pskID];
  uint64_t v26 = v35;
  unint64_t v27 = v36;
  *uint64_t v25 = v35;
  v25[1] = v27;
  unint64_t v29 = v33;
  uint64_t v28 = v34;
  uint64_t v30 = (uint64_t *)&v24[OBJC_IVAR____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE_key];
  *uint64_t v30 = v34;
  v30[1] = v29 | 0x2000000000000000LL;
  sub_1876B9070(v26, v27);
  sub_1876B9070(v28, v29);

  v38.receiver = v24;
  v38.super_class = ObjectType;
  return objc_msgSendSuper2(&v38, sel_init);
}

uint64_t sub_1876B9070(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_retain();
  }

  return swift_retain();
}

uint64_t sub_1876B90B4(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60 != 15) {
    return sub_1876B9070(a1, a2);
  }
  return a1;
}

unint64_t sub_1876B90C8()
{
  unint64_t result = qword_18C6E1A20;
  if (!qword_18C6E1A20)
  {
    unint64_t result = MEMORY[0x1895AD9F8](MEMORY[0x189606D48], MEMORY[0x189606D70]);
    atomic_store(result, (unint64_t *)&qword_18C6E1A20);
  }

  return result;
}

uint64_t sub_1876B910C(uint64_t result)
{
  if (result)
  {
    unint64_t v1 = result;
    if (result < 15)
    {
      return 0LL;
    }

    else
    {
      sub_187860714();
      swift_allocObject();
      sub_187860708();
      if (v1 >= 0x7FFFFFFF)
      {
        sub_18786072C();
        unint64_t result = swift_allocObject();
        *(void *)(result + 16) = 0LL;
        *(void *)(result + 24) = 0LL;
      }

      else
      {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = MEMORY[0x1895AD9EC]((char *)a1 + (int)result, -(result >> 32), 0LL, 0LL);
    *a1 = result;
  }

  return result;
}

unint64_t sub_1876B91E0()
{
  unint64_t result = qword_18C6E1A40;
  if (!qword_18C6E1A40)
  {
    objc_opt_self();
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_18C6E1A40);
  }

  return result;
}

uint64_t type metadata accessor for NEIKEv2CryptoKitECDH(uint64_t a1)
{
  return sub_1876B97A8(a1, (uint64_t *)&unk_18C6E18B0);
}

uint64_t sub_1876B9230(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 40LL))(a2, a1, v5);
  return a2;
}

uint64_t type metadata accessor for NEIKEv2CryptoKitKEM(uint64_t a1)
{
  return sub_1876B97A8(a1, qword_18C6E1888);
}

uint64_t sub_1876B9288()
{
  return type metadata accessor for NEIKEv2CryptoKitHPKE(0LL);
}

uint64_t type metadata accessor for NEIKEv2CryptoKitHPKE(uint64_t a1)
{
  return sub_1876B97A8(a1, qword_18C6E18E0);
}

uint64_t sub_1876B92A4()
{
  uint64_t result = sub_1878608DC();
  if (v1 <= 0x3F)
  {
    uint64_t result = swift_updateClassMetadata2();
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t method lookup function for NEIKEv2CryptoKitHPKE()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of NEIKEv2CryptoKitHPKE.__allocating_init(payload:aad:psk:pskID:keyRef:)()
{
  return (*(uint64_t (**)(void))(v0 + 120))();
}

uint64_t dispatch thunk of NEIKEv2CryptoKitHPKE.__allocating_init(payload:aad:psk:pskID:keyData:)()
{
  return (*(uint64_t (**)(void))(v0 + 128))();
}

uint64_t sub_1876B935C()
{
  return type metadata accessor for NEIKEv2CryptoKitSPAKE2Plus(0LL);
}

uint64_t type metadata accessor for NEIKEv2CryptoKitSPAKE2Plus(uint64_t a1)
{
  return sub_1876B97A8(a1, qword_18C6E19C8);
}

void sub_1876B9378()
{
  if (v0 <= 0x3F)
  {
    sub_1876B97FC(319LL, &qword_18C6E1870, (void (*)(uint64_t))MEMORY[0x18960F168]);
    if (v1 <= 0x3F) {
      swift_updateClassMetadata2();
    }
  }

uint64_t method lookup function for NEIKEv2CryptoKitSPAKE2Plus()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of NEIKEv2CryptoKitSPAKE2Plus.__allocating_init(seed:initiatorID:responderID:salt:context:forInitiator:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v3 + 104))(a1, a2, a3);
}

uint64_t sub_1876B9468()
{
  return type metadata accessor for NEIKEv2CryptoKitECDH(0LL);
}

void sub_1876B9470(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t method lookup function for NEIKEv2CryptoKitECDH()
{
  return swift_lookUpClassMethod();
}

uint64_t sub_1876B9490()
{
  return type metadata accessor for NEIKEv2CryptoKitP256(0LL);
}

uint64_t type metadata accessor for NEIKEv2CryptoKitP256(uint64_t a1)
{
  return sub_1876B97A8(a1, (uint64_t *)&unk_18C6E1900);
}

uint64_t sub_1876B94AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1876B94F4(a1, a2, a3, (uint64_t (*)(uint64_t))MEMORY[0x189605C68]);
}

uint64_t method lookup function for NEIKEv2CryptoKitP256()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of NEIKEv2CryptoKitP256.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 120))();
}

uint64_t sub_1876B94CC()
{
  return type metadata accessor for NEIKEv2CryptoKitP384(0LL);
}

uint64_t type metadata accessor for NEIKEv2CryptoKitP384(uint64_t a1)
{
  return sub_1876B97A8(a1, (uint64_t *)&unk_18C6E1918);
}

uint64_t sub_1876B94E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1876B94F4(a1, a2, a3, (uint64_t (*)(uint64_t))MEMORY[0x189605CE8]);
}

uint64_t sub_1876B94F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t))
{
  uint64_t result = a4(319LL);
  if (v5 <= 0x3F)
  {
    uint64_t result = swift_updateClassMetadata2();
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t method lookup function for NEIKEv2CryptoKitP384()
{
  return swift_lookUpClassMethod();
}

uint64_t sub_1876B956C()
{
  return type metadata accessor for NEIKEv2CryptoKitP521(0LL);
}

uint64_t type metadata accessor for NEIKEv2CryptoKitP521(uint64_t a1)
{
  return sub_1876B97A8(a1, qword_18C6E1930);
}

uint64_t sub_1876B9588(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1876B94F4(a1, a2, a3, (uint64_t (*)(uint64_t))MEMORY[0x189605DB0]);
}

uint64_t method lookup function for NEIKEv2CryptoKitP521()
{
  return swift_lookUpClassMethod();
}

uint64_t sub_1876B95A0()
{
  return type metadata accessor for NEIKEv2CryptoKitX25519(0LL);
}

uint64_t type metadata accessor for NEIKEv2CryptoKitX25519(uint64_t a1)
{
  return sub_1876B97A8(a1, qword_18C6E1968);
}

uint64_t sub_1876B95BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1876B94F4(a1, a2, a3, (uint64_t (*)(uint64_t))MEMORY[0x1896058C8]);
}

uint64_t method lookup function for NEIKEv2CryptoKitX25519()
{
  return swift_lookUpClassMethod();
}

uint64_t sub_1876B95D4()
{
  return type metadata accessor for NEIKEv2CryptoKitX448(0LL);
}

uint64_t type metadata accessor for NEIKEv2CryptoKitX448(uint64_t a1)
{
  return sub_1876B97A8(a1, (uint64_t *)&unk_18C6E1950);
}

uint64_t sub_1876B95F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1876B94F4(a1, a2, a3, (uint64_t (*)(uint64_t))MEMORY[0x189605E60]);
}

uint64_t method lookup function for NEIKEv2CryptoKitX448()
{
  return swift_lookUpClassMethod();
}

uint64_t sub_1876B9608()
{
  return type metadata accessor for NEIKEv2CryptoKitKEM(0LL);
}

void sub_1876B9610(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1876B9624(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, void (*a5)(uint64_t))
{
  if (v5 <= 0x3F) {
    swift_updateClassMetadata2();
  }
}

uint64_t method lookup function for NEIKEv2CryptoKitKEM()
{
  return swift_lookUpClassMethod();
}

uint64_t sub_1876B96AC()
{
  return type metadata accessor for NEIKEv2CryptoKitMLKEM768(0LL);
}

uint64_t type metadata accessor for NEIKEv2CryptoKitMLKEM768(uint64_t a1)
{
  return sub_1876B97A8(a1, qword_18C6E1988);
}

void sub_1876B96C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1876B96DC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, void (*a5)(uint64_t))
{
  if (v5 <= 0x3F) {
    swift_updateClassMetadata2();
  }
}

uint64_t method lookup function for NEIKEv2CryptoKitMLKEM768()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of NEIKEv2CryptoKitMLKEM768.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 120))();
}

uint64_t dispatch thunk of NEIKEv2CryptoKitMLKEM768.__allocating_init(publicKeyData:)()
{
  return (*(uint64_t (**)(void))(v0 + 128))();
}

uint64_t sub_1876B978C()
{
  return type metadata accessor for NEIKEv2CryptoKitMLKEM1024(0LL);
}

uint64_t type metadata accessor for NEIKEv2CryptoKitMLKEM1024(uint64_t a1)
{
  return sub_1876B97A8(a1, (uint64_t *)&unk_18C6E19A8);
}

uint64_t sub_1876B97A8(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (!*a2) {
    return swift_getSingletonMetadata();
  }
  return result;
}

void sub_1876B97DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t method lookup function for NEIKEv2CryptoKitMLKEM1024()
{
  return swift_lookUpClassMethod();
}

void sub_1876B97FC(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255LL);
    unint64_t v4 = sub_187860B88();
    if (!v5) {
      atomic_store(v4, a2);
    }
  }

_BYTE *__swift_memcpy1_1(_BYTE *result, _BYTE *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for NEIKEv2CryptoKitSPAKE2Plus.Role(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 2;
  int v8 = v6 - 2;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 3;
  int v8 = v6 - 3;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

  if (v9) {
    uint64_t v28 = v9[1];
  }
  else {
    uint64_t v28 = 0LL;
  }
  v6->_endOfQueriesOffset = v28;
  unint64_t v29 = 0LL;
  if (v14)
  {
    uint64_t v30 = 0;
    while (1)
    {
      id v31 = -[NEDNSResourceRecord initFromByteParser:](objc_alloc(&OBJC_CLASS___NEDNSResourceRecord), v9);
      if (!v31) {
        break;
      }
      uint64_t v32 = v31;
      if (!v29) {
        unint64_t v29 = (void *)[objc_alloc(MEMORY[0x189603FA8]) initWithCapacity:v14];
      }
      [v29 addObject:v32];

      if (++v30 >= v14) {
        goto LABEL_25;
      }
    }

    ne_log_obj();
    objc_super v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      uint64_t v66 = v30;
      _os_log_error_impl(&dword_1876B1000, v42, OS_LOG_TYPE_ERROR, "Failed to parse answer %u", buf, 8u);
    }

    unint64_t v33 = 0LL;
    goto LABEL_77;
  }

    int v8 = 1LL;
    goto LABEL_18;
  }

  if ([v5 status] == 2)
  {
    BOOL v7 = (void (**)(void))a1[6];
LABEL_22:
    v7[2]();
    goto LABEL_26;
  }

  if ([a1[4] status] != 3)
  {
    BOOL v7 = (void (**)(void))a1[7];
    goto LABEL_22;
  }

  uint64_t v10 = a1[4];
  if (v10) {
    uint64_t v10 = objc_getProperty(v10, v9, 80LL, 1);
  }
  [v10 getUUIDBytes:uuid];
  uint64_t v11 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_int64(v11, "command", 4LL);
  xpc_dictionary_set_uuid(v11, "flow-uuid", uuid);
  xpc_dictionary_set_int64(v11, "direction", 2LL);
  uint64_t v12 = a1[4];
  if (v12) {
    uint64_t v13 = v12[25];
  }
  else {
    uint64_t v13 = 0LL;
  }
  xpc_dictionary_set_int64(v11, "byte-count-inbound", v13);
  uint64_t v14 = a1[4];
  if (v14) {
    uint64_t v15 = v14[26];
  }
  else {
    uint64_t v15 = 0LL;
  }
  xpc_dictionary_set_int64(v11, "byte-count-outbound", v15);
  if (-[NEFilterSource generateCryptoSignature:length:](a1[4], bytes, &length))
  {
    xpc_dictionary_set_data(v11, "crypto-signature", bytes, length);
  }

  else
  {
    ne_log_obj();
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = a1[4];
      if (v21) {
        uint64_t v21 = objc_getProperty(v21, v20, 80LL, 1);
      }
      *(_DWORD *)buf = 138412290;
      uint64_t v28 = v21;
      _os_log_error_impl( &dword_1876B1000,  v19,  OS_LOG_TYPE_ERROR,  "NEFilterSource failed to sign data complete message for %@",  buf,  0xCu);
    }
  }

  unint64_t v22 = a1[7];
  unint64_t v23 = a1[6];
  ne_filter_send_message();

LABEL_26:
}
}
}

  return v6;
}

  -[NEIKEv2Session reportPrivateNotifiesInPacket:](*(id **)(a1 + 40), *(void **)(a1 + 48));
  uint64_t v28 = *(void **)(a1 + 40);
  if (v28) {
    uint64_t v28 = (void *)v28[49];
  }
  unint64_t v29 = v28;
  uint64_t v30 = [v29 count];

  if (v30)
  {
    id v31 = *(void **)(a1 + 40);
    if (v31) {
      uint64_t v32 = (void *)v31[49];
    }
    else {
      uint64_t v32 = 0LL;
    }
    unint64_t v33 = v32;
    -[NEIKEv2Session reportPrivateNotifies:](v31, v33);

    -[NEIKEv2Session setPendingPrivateNotifies:](*(void *)(a1 + 40), 0LL);
  }

  uint64_t v34 = *(void **)(a1 + 32);
  uint64_t v35 = *(void **)(a1 + 56);
  unint64_t v36 = v5;
  unint64_t v37 = v34;
  objc_super v38 = v35;
  objc_opt_self();
  if (!v37)
  {
    ne_log_obj();
    uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_FAULT)) {
      goto LABEL_265;
    }
    *(_DWORD *)buf = 136315138;
    v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
    uint64_t v60 = "%s called with null ikeSA";
    goto LABEL_38;
  }

  if (!v38 && (v37[23] & 1) == 0)
  {
    ne_log_obj();
    uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_FAULT)) {
      goto LABEL_265;
    }
    *(_DWORD *)buf = 136315138;
    v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
    uint64_t v60 = "%s called with null childSA";
    goto LABEL_38;
  }

  unint64_t v40 = objc_getProperty(v37, v39, 96LL, 1);

  if (!v40)
  {
    ne_log_obj();
    uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
    {
LABEL_265:
      v239 = 0LL;
      goto LABEL_266;
    }

    *(_DWORD *)buf = 136315138;
    v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
    uint64_t v60 = "%s called with null ikeSA.chosenProposal";
LABEL_38:
    _os_log_fault_impl(&dword_1876B1000, v43, OS_LOG_TYPE_FAULT, v60, buf, 0xCu);
    goto LABEL_265;
  }

  unint64_t v41 = -[NEIKEv2Packet initResponse:]((uint64_t)objc_alloc(&OBJC_CLASS___NEIKEv2IKEAuthPacket), v36);
  if (!v41)
  {
    ne_log_obj();
    uint64_t v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl( &dword_1876B1000,  v73,  OS_LOG_TYPE_FAULT,  "[[NEIKEv2IKEAuthPacket alloc] initResponse:] failed",  buf,  2u);
    }

    uint64_t v43 = 0LL;
    goto LABEL_265;
  }

  uint64_t v43 = (os_log_s *)v41;
  unint64_t v44 = -[NEIKEv2IKESA copyResponderIdentifier](v37, v42);

  if (v44)
  {
    uint64_t v46 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ResponderIdentifierPayload);
    objc_setProperty_atomic(v43, v47, v46, 104LL);

    id v49 = -[NEIKEv2IKESA copyResponderIdentifier](v37, v48);
    objc_getProperty(v43, v50, 104LL, 1);
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v53 = v51;
    if (v51) {
      objc_setProperty_atomic(v51, v52, v49, 24LL);
    }

    objc_getProperty(v43, v54, 104LL, 1);
    uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue();
    id v56 = -[NEIKEv2Payload isValid]((uint64_t)v55);

    if ((v56 & 1) == 0)
    {
      ne_log_obj();
      v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
        goto LABEL_264;
      }
      *(_DWORD *)buf = 136315138;
      v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
      v98 = "%s called with null packet.idr.isValid";
LABEL_141:
      v240 = v97;
      v241 = 12;
LABEL_142:
      _os_log_fault_impl(&dword_1876B1000, v240, OS_LOG_TYPE_FAULT, v98, buf, v241);
      goto LABEL_264;
    }
  }

  v506 = v5;
  unint64_t v57 = objc_getProperty(v37, v45, 96LL, 1);
  if (-[NEIKEv2IKESAProposal hasEAPMethods](v57))
  {

    goto LABEL_106;
  }

  -[NEIKEv2IKESA authenticationProtocol](v37, v58);
  uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v85 = [v84 method];

  if (!v85) {
    goto LABEL_106;
  }
  v86 = -[NEIKEv2IKESA authenticationProtocol](v37, v59);
  v87 = [v86 isSecurePassword];

  if (v87)
  {
    unint64_t v88 = objc_alloc_init(&OBJC_CLASS___NEIKEv2AuthPayload);
    objc_setProperty_atomic(v43, v89, v88, 128LL);

    -[NEIKEv2IKESA authenticationProtocol](v37, v90);
    unint64_t v91 = (void *)objc_claimAutoreleasedReturnValue();
    objc_getProperty(v43, v92, 128LL, 1);
    v93 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2AuthPayload setAuthProtocol:]((uint64_t)v93, v91);

    v94 = -[NEIKEv2IKESA createResponderGSPMAuthenticationDataUsingPrimeKey:]((os_log_s *)v37, 0LL);
    objc_getProperty(v43, v95, 128LL, 1);
    v96 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2AuthPayload setAuthenticationData:]((uint64_t)v96, v94);
  }

  else
  {
    v94 = -[NEIKEv2IKESA copyAuthenticationPayloadUsingPrimeKey:]((id *)v37, 0LL);
    objc_setProperty_atomic(v43, v171, v94, 128LL);
  }

  objc_getProperty(v43, v172, 128LL, 1);
  v173 = (void *)objc_claimAutoreleasedReturnValue();
  v174 = -[NEIKEv2Payload isValid]((uint64_t)v173);

  if ((v174 & 1) == 0)
  {
    ne_log_obj();
    v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v5 = v506;
    if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
      goto LABEL_264;
    }
    *(_DWORD *)buf = 136315138;
    v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
    v98 = "%s called with null packet.auth.isValid";
    goto LABEL_141;
  }

  objc_getProperty(v37, v175, 224LL, 1);
  v176 = (void *)objc_claimAutoreleasedReturnValue();

  if (v176 && !-[NEIKEv2Packet addNotification:data:](v43, 0x4034uLL, 0LL))
  {
    ne_log_obj();
    v238 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v238, OS_LOG_TYPE_FAULT)) {
      goto LABEL_136;
    }
    *(_WORD *)buf = 0;
    v293 = "[packet addNotification:NEIKEv2NotifyTypePPKIdentity] failed";
    v294 = v238;
    v295 = 2;
    goto LABEL_206;
  }

      int v8 = v55;
    }

    uint64_t v18 = -[NEIKEv2Packet copyNotification:](v4, (const char *)0x4011);
    uint64_t v20 = v18;
    if (v18) {
      uint64_t v18 = objc_getProperty(v18, v19, 32LL, 1);
    }
    uint64_t v21 = v18;

    if (v21)
    {
      if (v20) {
        unint64_t v23 = objc_getProperty(v20, v22, 32LL, 1);
      }
      else {
        unint64_t v23 = 0LL;
      }
      uint64_t v24 = v23;
      objc_setProperty_atomic(v8, v25, v24, 288LL);
    }

    uint64_t v26 = v4;
    unint64_t v27 = v8;
    objc_opt_self();
    uint64_t v28 = -[NEIKEv2Packet initResponse:]((uint64_t)objc_alloc(&OBJC_CLASS___NEIKEv2InformationalPacket), v26);
    if (v28)
    {
      uint64_t v30 = (id)v28;
      objc_getProperty(v27, v29, 288LL, 1);
      id v31 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v31
        || (objc_getProperty(v27, v32, 288LL, 1),
            unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(),
            uint64_t v34 = -[NEIKEv2Packet addNotification:data:](v30, 0x4011uLL, v33),
            v33,
            v34))
      {
        uint64_t v30 = v30;
        uint64_t v35 = (os_log_s *)v30;
        goto LABEL_44;
      }

      ne_log_obj();
      uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( &dword_1876B1000,  v39,  OS_LOG_TYPE_FAULT,  "[packet addNotification:NEIKEv2NotifyTypeCookie2] failed",  buf,  2u);
      }
    }

    else
    {
      ne_log_obj();
      objc_super v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( &dword_1876B1000,  v38,  OS_LOG_TYPE_FAULT,  "[[NEIKEv2InformationalPacket alloc] initOutbound:] failed",  buf,  2u);
      }

      uint64_t v30 = 0LL;
    }

    uint64_t v35 = 0LL;
LABEL_44:

    if (v35)
    {
      if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v35, 0LL) & 1) == 0)
      {
        unint64_t v41 = objc_getProperty(a1, v40, 336LL, 1);
        ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"MOBIKE reply",  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v54);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v41, 3uLL, ErrorFailedToSend);

        -[NEIKEv2Session reportState](a1, v50);
        -[NEIKEv2Session resetAll]((uint64_t)a1, v51);
      }
    }

    else
    {
      ne_log_obj();
      uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1876B1000, v52, OS_LOG_TYPE_ERROR, "Failed to create MOBIKE packet", buf, 2u);
      }

      uint64_t v35 = 0LL;
    }

            goto LABEL_18;
          }

          unint64_t v23 = objc_getProperty(a1, v21, 336LL, 1);
          ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"delete reply",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(uint64_t *)v35);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v23, 3uLL, ErrorFailedToSend);

          -[NEIKEv2Session reportState](a1, v32);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v33);
        }

        else
        {
          ne_log_obj();
          unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t v35 = 138412290;
            *(void *)&v35[4] = a1;
            _os_log_error_impl(&dword_1876B1000, v22, OS_LOG_TYPE_ERROR, "%@ Failed to create Delete packet", v35, 0xCu);
          }

          uint64_t v10 = 0LL;
        }
      }

      else
      {
        ne_log_obj();
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v35 = 138412290;
          *(void *)&v35[4] = a1;
          uint64_t v11 = "%@ Failed to process Delete packet";
LABEL_27:
          _os_log_error_impl(&dword_1876B1000, (os_log_t)v10, OS_LOG_TYPE_ERROR, v11, v35, 0xCu);
        }
      }
    }

    else
    {
      ne_log_obj();
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v35 = 138412290;
        *(void *)&v35[4] = a1;
        uint64_t v11 = "%@ Failed to receive Delete packet";
        goto LABEL_27;
      }
    }

    uint64_t v12 = 0;
    goto LABEL_10;
  }

        a1 = 0LL;
        goto LABEL_18;
      }

      ne_log_obj();
      unint64_t v22 = (id)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v22, OS_LOG_TYPE_FAULT)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136315138;
      id v56 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthPart1AsInitiator:beforeEAP:]";
      objc_super v38 = "%s called with null ikeSA.chosenProposal";
    }

    else
    {
      ne_log_obj();
      unint64_t v22 = (id)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v22, OS_LOG_TYPE_FAULT)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136315138;
      id v56 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthPart1AsInitiator:beforeEAP:]";
      objc_super v38 = "%s called with null ikeSA.isInitiator";
    }

    _os_log_fault_impl(&dword_1876B1000, (os_log_t)v22, OS_LOG_TYPE_FAULT, v38, buf, 0xCu);
    goto LABEL_17;
  }

      if (v16 + 16 <= v14 && v63 != 0)
      {
        uint64_t v61 = v14;
        uint64_t v62 = v15;
        uint64_t v58 = v10;
        uint64_t v60 = 0LL;
        uint64_t v21 = 0LL;
        unint64_t v22 = v16 + 8;
        unint64_t v23 = 1;
        do
        {
          uint64_t v24 = &v8[v22];
          uint64_t v25 = bswap32(*(unsigned __int16 *)&v8[v22 + 2]) >> 16;
          uint64_t v26 = v8[v22 + 4];
          switch(v8[v22 + 4])
          {
            case 1u:
              uint64_t v32 = v25 >= 0xC && *((_WORD *)v24 + 4) == 3712 && *((_WORD *)v24 + 5) == 1;
              unint64_t v27 = (NEIKEv2PRFProtocol *)-[NEIKEv2EncryptionProtocol initWithEncryptionWireType:is256Bit:]( objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol),  bswap32(*((unsigned __int16 *)v24 + 3)) >> 16,  v32);
              [v62 encryptionProtocols];
              unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();

              if (v41)
              {
                [v62 encryptionProtocols];
                uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
                [v34 arrayByAddingObject:v27];
                uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
                [v62 setEncryptionProtocols:v35];
                goto LABEL_50;
              }

              unint64_t v68 = v27;
              [MEMORY[0x189603F18] arrayWithObjects:&v68 count:1];
              uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
              [v62 setEncryptionProtocols:v34];
              break;
            case 2u:
              unint64_t v27 = -[NEIKEv2PRFProtocol initWithType:]( objc_alloc(&OBJC_CLASS___NEIKEv2PRFProtocol),  "initWithType:",  bswap32(*((unsigned __int16 *)v24 + 3)) >> 16);
              [v62 prfProtocols];
              unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();

              if (v33)
              {
                [v62 prfProtocols];
                uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
                [v34 arrayByAddingObject:v27];
                uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
                [v62 setPrfProtocols:v35];
                goto LABEL_50;
              }

              uint64_t v67 = v27;
              [MEMORY[0x189603F18] arrayWithObjects:&v67 count:1];
              uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
              [v62 setPrfProtocols:v34];
              break;
            case 3u:
              unint64_t v27 = -[NEIKEv2IntegrityProtocol initWithType:]( objc_alloc(&OBJC_CLASS___NEIKEv2IntegrityProtocol),  "initWithType:",  bswap32(*((unsigned __int16 *)v24 + 3)) >> 16);
              [v62 integrityProtocols];
              unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();

              if (v36)
              {
                [v62 integrityProtocols];
                uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
                [v34 arrayByAddingObject:v27];
                uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
                [v62 setIntegrityProtocols:v35];
                goto LABEL_50;
              }

              uint64_t v66 = v27;
              [MEMORY[0x189603F18] arrayWithObjects:&v66 count:1];
              uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
              [v62 setIntegrityProtocols:v34];
              break;
            case 4u:
              unint64_t v27 = -[NEIKEv2KEMProtocol initWithMethod:]( objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol),  "initWithMethod:",  bswap32(*((unsigned __int16 *)v24 + 3)) >> 16);
              [v62 kemProtocols];
              unint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();

              if (v37)
              {
                [v62 kemProtocols];
                uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
                [v34 arrayByAddingObject:v27];
                uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
                [v62 setKemProtocols:v35];
LABEL_50:
              }

              else
              {
                uint64_t v65 = v27;
                [MEMORY[0x189603F18] arrayWithObjects:&v65 count:1];
                uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
                [v62 setKemProtocols:v34];
              }

              break;
            case 5u:
              ne_log_obj();
              unint64_t v27 = (NEIKEv2PRFProtocol *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled((os_log_t)v27, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)buf = 0;
                _os_log_debug_impl( &dword_1876B1000,  (os_log_t)v27,  OS_LOG_TYPE_DEBUG,  "Ignoring ESN transform found in IKE SA proposal",  buf,  2u);
              }

              goto LABEL_52;
            case 6u:
            case 7u:
            case 8u:
            case 9u:
            case 0xAu:
            case 0xBu:
            case 0xCu:
              objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedChar:");
              unint64_t v27 = (NEIKEv2PRFProtocol *)objc_claimAutoreleasedReturnValue();
              uint64_t v28 = -[NEIKEv2KEMProtocol initWithMethod:]( objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol),  "initWithMethod:",  bswap32(*((unsigned __int16 *)v24 + 3)) >> 16);
              if (!v21) {
                uint64_t v21 = objc_alloc_init(MEMORY[0x189603FC8]);
              }
              objc_msgSend(v21, "objectForKeyedSubscript:", v27, v55);
              unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();

              if (v29)
              {
                [v21 objectForKeyedSubscript:v27];
                uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
                [v30 arrayByAddingObject:v28];
                id v31 = (void *)objc_claimAutoreleasedReturnValue();
                [v21 setObject:v31 forKeyedSubscript:v27];
              }

              else
              {
                id v64 = v28;
                [MEMORY[0x189603F18] arrayWithObjects:&v64 count:1];
                uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
                [v21 setObject:v30 forKeyedSubscript:v27];
              }

              goto LABEL_52;
            default:
              objc_super v38 = v60;
              if (!v60)
              {
                objc_super v38 = objc_alloc_init(MEMORY[0x189603FE0]);
                uint64_t v26 = v24[4];
              }

              objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedChar:", v26, v55);
              uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
              uint64_t v60 = v38;
              [v38 addObject:v39];

              ne_log_obj();
              unint64_t v27 = (NEIKEv2PRFProtocol *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled((os_log_t)v27, OS_LOG_TYPE_INFO))
              {
                unint64_t v40 = v24[4];
                *(_DWORD *)buf = 67109120;
                LODWORD(v70[0]) = v40;
                _os_log_impl( &dword_1876B1000,  (os_log_t)v27,  OS_LOG_TYPE_INFO,  "Found unsupported transform type %u in IKE SA proposal",  buf,  8u);
              }

              goto LABEL_52;
          }

          uint64_t v14 = v61;
LABEL_52:

          v22 += v25;
        }

        while (v22 + 8 <= v14 && v23++ < v63);
        uint64_t v15 = v62;
        if (v62) {
          v62[8] = v8[4];
        }
        int v2 = v57;
        uint64_t v10 = v58;
        uint64_t v11 = &off_18A087000;
        if (v21)
        {
          uint64_t v43 = (void *)[objc_alloc(MEMORY[0x189603F68]) initWithDictionary:v21];
          [v62 setAdditionalKEMProtocols:v43];
        }

        if (v60)
        {
          uint64_t v45 = (void *)[objc_alloc(MEMORY[0x189604010]) initWithSet:v60];
          if (v62) {
            objc_setProperty_atomic(v62, v44, v45, 80LL);
          }

          uint64_t v20 = v60;
          goto LABEL_71;
        }

  uint64_t v25 = 0LL;
LABEL_18:

  return v25;
}
}

        return;
      }

      ne_log_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_17;
      }
      *(_WORD *)buf = 0;
      uint64_t v9 = "Transport connection invalid, ignoring";
    }

    _os_log_error_impl(&dword_1876B1000, v9, OS_LOG_TYPE_ERROR, v10, (uint8_t *)&buf, 2u);
    goto LABEL_10;
  }

  uint64_t v17 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "NEIPSecDBCopyPolicy";
    _os_log_fault_impl(&dword_1876B1000, v17, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&buf, 0xCu);
  }

  return 0LL;
}

    uint64_t v16 = v5;
  }

  return v5;
}

  return v6;
}
}

  [v6 objectForKeyedSubscript:@"use-passive-ftp"];
  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue();

  if (v25)
  {
    [v6 objectForKeyedSubscript:@"use-passive-ftp"];
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEProxySettings setUsePassiveFTP:](v9, "setUsePassiveFTP:", [v26 BOOLValue]);
  }

  [v6 objectForKeyedSubscript:@"match-domains"];
  unint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
  if (isa_nsarray(v27))
  {
    -[NEProxySettings setMatchDomains:](v9, "setMatchDomains:", v27);
  }

  else if (isa_nsstring(v27))
  {
    uint64_t v30 = v27;
    [MEMORY[0x189603F18] arrayWithObjects:&v30 count:1];
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEProxySettings setMatchDomains:](v9, "setMatchDomains:", v28);
  }

  [v8 setProxySettings:v9];

LABEL_24:
  return v8 != 0LL;
}

    uint64_t v9 = 0LL;
  }

  if (v17) {
    MEMORY[0x1895AC894]();
  }
  return v9;
}
}

uint64_t storeEnumTagSinglePayload for NEIKEv2CryptoKitSPAKE2Plus.Role( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFE) {
    return ((uint64_t (*)(void))((char *)&loc_1876B9934 + 4 * byte_187870935[v4]))();
  }
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_1876B9968 + 4 * byte_187870930[v4]))();
}

uint64_t sub_1876B9968(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1876B9970(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x1876B9978LL);
  }
  return result;
}

uint64_t sub_1876B9984(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x1876B998CLL);
  }
  *(_BYTE *)uint64_t result = a2 + 1;
  return result;
}

uint64_t sub_1876B9990(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1876B9998(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1876B99A4(unsigned __int8 *a1)
{
  return *a1;
}

_BYTE *sub_1876B99B0(_BYTE *result, char a2)
{
  *uint64_t result = a2 & 1;
  return result;
}

ValueMetadata *type metadata accessor for NEIKEv2CryptoKitSPAKE2Plus.Role()
{
  return &type metadata for NEIKEv2CryptoKitSPAKE2Plus.Role;
}

void *initializeBufferWithCopyOfBuffer for NEIKEv2CryptoKitKey(void *a1, uint64_t a2)
{
  id v3 = *(id *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  sub_1876B9A08(*(id *)a2, v4);
  *a1 = v3;
  a1[1] = v4;
  return a1;
}

id sub_1876B9A08(id a1, uint64_t a2)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    return (id)sub_1876B9070((uint64_t)a1, a2 & 0xDFFFFFFFFFFFFFFFLL);
  }
  else {
    return a1;
  }
}

void destroy for NEIKEv2CryptoKitKey(uint64_t a1)
{
}

void sub_1876B9A24(id a1, uint64_t a2)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    sub_1876B8E88((uint64_t)a1, a2 & 0xDFFFFFFFFFFFFFFFLL);
  }
  else {
}
  }

uint64_t assignWithCopy for NEIKEv2CryptoKitKey(uint64_t a1, uint64_t a2)
{
  id v3 = *(id *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  sub_1876B9A08(*(id *)a2, v4);
  uint64_t v5 = *(void **)a1;
  uint64_t v6 = *(void *)(a1 + 8);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  sub_1876B9A24(v5, v6);
  return a1;
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t assignWithTake for NEIKEv2CryptoKitKey(uint64_t a1, _OWORD *a2)
{
  id v3 = *(void **)a1;
  uint64_t v4 = *(void *)(a1 + 8);
  *(_OWORD *)a1 = *a2;
  sub_1876B9A24(v3, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for NEIKEv2CryptoKitKey(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 3 && *(_BYTE *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 3);
  }
  unsigned int v3 = ((2 * ((*(void *)(a1 + 8) & 0x1000000000000000LL) != 0)) | ((*(void *)(a1 + 8) >> 60) >> 1) & 1) ^ 3;
  if (v3 >= 2) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for NEIKEv2CryptoKitKey(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 2)
  {
    *(void *)__n128 result = a2 - 3;
    *(void *)(result + 8) = 0LL;
    if (a3 >= 3) {
      *(_BYTE *)(result + 16) = 1;
    }
  }

  else
  {
    if (a3 >= 3) {
      *(_BYTE *)(result + 16) = 0;
    }
    if (a2)
    {
      *(void *)__n128 result = 0LL;
      *(void *)(result + 8) = (unint64_t)((2 * (a2 & 1)) | 1) << 60;
    }
  }

  return result;
}

uint64_t sub_1876B9B58(uint64_t a1)
{
  return (*(void *)(a1 + 8) >> 61) & 1LL;
}

uint64_t sub_1876B9B64(uint64_t result)
{
  *(void *)(result + 8) &= ~0x2000000000000000uLL;
  return result;
}

uint64_t sub_1876B9B74(uint64_t result, char a2)
{
  *(void *)(result + 8) = *(void *)(result + 8) & 0xCFFFFFFFFFFFFFFFLL | ((unint64_t)(a2 & 1) << 61);
  return result;
}

ValueMetadata *type metadata accessor for NEIKEv2CryptoKitKey()
{
  return &type metadata for NEIKEv2CryptoKitKey;
}

void type metadata accessor for Verdict(uint64_t a1)
{
}

void type metadata accessor for NETrafficDirection(uint64_t a1)
{
}

unint64_t sub_1876B9BC8()
{
  unint64_t result = qword_18C6E1AE0;
  if (!qword_18C6E1AE0)
  {
    unint64_t result = MEMORY[0x1895AD9F8](&unk_187870C94, &type metadata for NEIKEv2CryptoKitSPAKE2Plus.Role);
    atomic_store(result, (unint64_t *)&qword_18C6E1AE0);
  }

  return result;
}

unint64_t sub_1876B9C0C()
{
  unint64_t result = qword_18C6E1AE8;
  if (!qword_18C6E1AE8)
  {
    unint64_t result = MEMORY[0x1895AD9F8](&unk_187870D80, &type metadata for NEIKEv2CryptoKitErrors);
    atomic_store(result, (unint64_t *)&qword_18C6E1AE8);
  }

  return result;
}

uint64_t sub_1876B9C50(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, a1, v5);
  return a2;
}

uint64_t sub_1876B9C94(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8LL))(a1, v3);
  return a1;
}

void type metadata accessor for CFError(uint64_t a1)
{
}

unint64_t sub_1876B9CE4()
{
  unint64_t result = qword_18C6E1AF8;
  if (!qword_18C6E1AF8)
  {
    type metadata accessor for CFError(255LL);
    unint64_t result = MEMORY[0x1895AD9F8](MEMORY[0x189607278], v1);
    atomic_store(result, (unint64_t *)&qword_18C6E1AF8);
  }

  return result;
}

uint64_t getEnumTagSinglePayload for NEIKEv2CryptoKitErrors(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFE) {
    goto LABEL_17;
  }
  if (a2 + 2 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 2) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 2;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }

uint64_t storeEnumTagSinglePayload for NEIKEv2CryptoKitErrors(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFD) {
    return ((uint64_t (*)(void))((char *)&loc_1876B9E08 + 4 * byte_18787093F[v4]))();
  }
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_1876B9E3C + 4 * byte_18787093A[v4]))();
}

uint64_t sub_1876B9E3C(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1876B9E44(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x1876B9E4CLL);
  }
  return result;
}

uint64_t sub_1876B9E58(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x1876B9E60LL);
  }
  *(_BYTE *)unint64_t result = a2 + 2;
  return result;
}

uint64_t sub_1876B9E64(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1876B9E6C(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

_BYTE *sub_1876B9E78(_BYTE *result, char a2)
{
  *unint64_t result = a2;
  return result;
}

ValueMetadata *type metadata accessor for NEIKEv2CryptoKitErrors()
{
  return &type metadata for NEIKEv2CryptoKitErrors;
}

void type metadata accessor for SecKey(uint64_t a1)
{
}

void sub_1876B9EA4(uint64_t a1, unint64_t *a2)
{
  if (!*a2)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v4) {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }

unint64_t sub_1876B9EEC()
{
  unint64_t result = qword_18C6E1B10;
  if (!qword_18C6E1B10)
  {
    unint64_t result = MEMORY[0x1895AD9F8](&unk_187870D58, &type metadata for NEIKEv2CryptoKitErrors);
    atomic_store(result, (unint64_t *)&qword_18C6E1B10);
  }

  return result;
}

uint64_t dispatch thunk of NEIKEv2CryptoKitMLKEM1024.__allocating_init()()
{
  return dispatch thunk of NEIKEv2CryptoKitMLKEM768.__allocating_init()();
}

uint64_t dispatch thunk of NEIKEv2CryptoKitMLKEM1024.__allocating_init(publicKeyData:)()
{
  return dispatch thunk of NEIKEv2CryptoKitMLKEM768.__allocating_init(publicKeyData:)();
}

uint64_t NENetworkRule.init(destinationNetworkEndpoint:prefix:protocol:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_187860804();
  if (result)
  {
    id v7 = objc_msgSend( objc_allocWithZone((Class)swift_getObjCClassFromMetadata()),  sel_initWithDestinationNetworkEndpoint_prefix_protocol_,  result,  a2,  a3);
    swift_unknownObjectRelease();
    uint64_t v8 = sub_187860810();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v8 - 8) + 8LL))(a1, v8);
    return (uint64_t)v7;
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t NENetworkRule.init(destinationHostEndpoint:protocol:)(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_187860804();
  if (result)
  {
    id v5 = objc_msgSend( objc_allocWithZone((Class)swift_getObjCClassFromMetadata()),  sel_initWithDestinationHostEndpoint_protocol_,  result,  a2);
    swift_unknownObjectRelease();
    uint64_t v6 = sub_187860810();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8LL))(a1, v6);
    return (uint64_t)v5;
  }

  else
  {
    __break(1u);
  }

  return result;
}

id NENetworkRule.init(remoteNetworkEndpoint:remotePrefix:localNetworkEndpoint:localPrefix:protocol:direction:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v25 = a5;
  uint64_t v26 = a6;
  uint64_t v24 = a4;
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C10);
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v23 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v23 - v13;
  sub_1876BA248(a1, (uint64_t)&v23 - v13);
  uint64_t v15 = sub_187860810();
  uint64_t v16 = *(void *)(v15 - 8);
  uint64_t v17 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v16 + 48);
  if (v17(v14, 1LL, v15) == 1)
  {
    sub_1876BA290((uint64_t)v14);
    uint64_t v18 = 0LL;
  }

  else
  {
    uint64_t v18 = sub_187860804();
    (*(void (**)(char *, uint64_t))(v16 + 8))(v14, v15);
  }

  sub_1876BA248(a3, (uint64_t)v12);
  if (v17(v12, 1LL, v15) == 1)
  {
    sub_1876BA290((uint64_t)v12);
    uint64_t v19 = 0LL;
  }

  else
  {
    uint64_t v19 = sub_187860804();
    (*(void (**)(char *, uint64_t))(v16 + 8))(v12, v15);
  }

  id v20 = objc_allocWithZone((Class)swift_getObjCClassFromMetadata());
  id v21 = objc_msgSend( v20,  sel_initWithRemoteNetworkEndpoint_remotePrefix_localNetworkEndpoint_localPrefix_protocol_direction_,  v18,  a2,  v19,  v24,  v25,  v26);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  sub_1876BA290(a3);
  sub_1876BA290(a1);
  return v21;
}

uint64_t sub_1876BA248(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C10);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

uint64_t sub_1876BA290(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C10);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8LL))(a1, v2);
  return a1;
}

uint64_t NENetworkRule.matchRemoteHostOrNetworkEndpoint.getter()
{
  return sub_1876BA2E8((SEL *)&selRef_matchRemoteHostOrNetworkEndpoint);
}

uint64_t NENetworkRule.matchLocalNetworkEndpoint.getter()
{
  return sub_1876BA2E8((SEL *)&selRef_matchLocalNetworkEndpoint);
}

uint64_t sub_1876BA2E8(SEL *a1)
{
  id v2 = [v1 *a1];
  return sub_18786081C();
}

uint64_t NEHotspotHelperCommand.interface.getter()
{
  id v1 = objc_msgSend(v0, sel_interface);
  return sub_187860840();
}

uint64_t (*NEFilterPacketProvider.handler.getter())(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t)
{
  uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))objc_msgSend(v0, sel_packetHandler);
  if (result)
  {
    id v2 = result;
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = v2;
    uint64_t v4 = swift_allocObject();
    *(void *)(v4 + 16) = sub_1876BA63C;
    *(void *)(v4 + 24) = v3;
    uint64_t v5 = swift_allocObject();
    *(void *)(v5 + 16) = sub_1876BA6F4;
    *(void *)(v5 + 24) = v4;
    return sub_1876BA6FC;
  }

  return result;
}

void *sub_1876BA400@<X0>( id *a1@<X0>, uint64_t (**a2)@<X0>(uint64_t *@<X0>, uint64_t *@<X2>, uint64_t *@<X3>, uint64_t *@<X8>)@<X8>)
{
  uint64_t result = objc_msgSend(*a1, sel_packetHandler);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = swift_allocObject();
    *(void *)(v5 + 16) = v4;
    uint64_t result = (void *)swift_allocObject();
    result[2] = sub_1876BAC8C;
    result[3] = v5;
    uint64_t v6 = sub_1876BAC90;
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  *a2 = v6;
  a2[1] = (uint64_t (*)@<X0>(uint64_t *@<X0>, uint64_t *@<X2>, uint64_t *@<X3>, uint64_t *@<X8>))result;
  return result;
}

void sub_1876BA494(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  if (*a1)
  {
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = v1;
    *(void *)(v3 + 24) = v2;
    uint64_t v4 = sub_1876BA6FC;
  }

  else
  {
    uint64_t v4 = 0LL;
    uint64_t v3 = 0LL;
  }

  sub_1876BABF4(v1);
  NEFilterPacketProvider.handler.setter((uint64_t)v4, v3);
}

void NEFilterPacketProvider.handler.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  if (a1)
  {
    uint64_t v6 = swift_allocObject();
    *(void *)(v6 + 16) = a1;
    *(void *)(v6 + 24) = a2;
    uint64_t v7 = swift_allocObject();
    *(void *)(v7 + 16) = sub_1876BA7FC;
    *(void *)(v7 + 24) = v6;
    v9[4] = sub_1876BA828;
    v9[5] = v7;
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 1107296256LL;
    v9[2] = sub_1876BA82C;
    v9[3] = &block_descriptor;
    uint64_t v8 = _Block_copy(v9);
    swift_retain();
    swift_release();
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  objc_msgSend(v3, sel_setPacketHandler_, v8);
  sub_1876BA700(a1);
  _Block_release(v8);
}

uint64_t sub_1876BA618()
{
  return swift_deallocObject();
}

uint64_t sub_1876BA63C()
{
  return (*(uint64_t (**)(void))(*(void *)(v0 + 16) + 16LL))();
}

uint64_t sub_1876BA65C@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t)@<X4>, uint64_t *a5@<X8>)
{
  uint64_t v7 = *a1;
  uint64_t v8 = *a2;
  uint64_t v9 = *a3;
  uint64_t v10 = a3[1];
  uint64_t result = sub_187860828();
  if (result)
  {
    if (v9) {
      uint64_t v12 = v10 - v9;
    }
    else {
      uint64_t v12 = 0LL;
    }
    uint64_t v13 = a4(v7, result, v8, v9, v12);
    uint64_t result = swift_unknownObjectRelease();
    *a5 = v13;
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t sub_1876BA6F4@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, uint64_t *a4@<X8>)
{
  return sub_1876BA65C(a1, a2, a3, *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v4 + 16), a4);
}

uint64_t sub_1876BA700(uint64_t result)
{
  if (result) {
    return swift_release();
  }
  return result;
}

uint64_t sub_1876BA710@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, uint64_t *a4@<X4>, uint64_t (*a5)(uint64_t, char *, uint64_t, uint64_t, uint64_t)@<X5>, uint64_t *a6@<X8>)
{
  unint64_t v22 = a6;
  uint64_t v11 = sub_187860834();
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v21 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = *a1;
  uint64_t v16 = *a2;
  uint64_t v17 = *a3;
  uint64_t v18 = *a4;
  swift_unknownObjectRetain();
  sub_187860840();
  uint64_t v19 = a5(v15, v14, v16, v17, v17 + v18);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v14, v11);
  *unint64_t v22 = v19;
  return result;
}

uint64_t sub_1876BA7FC@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, uint64_t *a4@<X4>, uint64_t *a5@<X8>)
{
  return sub_1876BA710( a1,  a2,  a3,  a4,  *(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t))(v5 + 16),  a5);
}

uint64_t sub_1876BA804()
{
  return swift_deallocObject();
}

uint64_t sub_1876BA82C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = *(uint64_t (**)(id, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 32);
  swift_retain();
  id v12 = a2;
  swift_unknownObjectRetain();
  uint64_t v13 = v11(v12, a3, a4, a5, a6);
  swift_release();

  swift_unknownObjectRelease();
  return v13;
}

uint64_t block_copy_helper(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper()
{
  return swift_release();
}

void (*NEFilterPacketProvider.handler.modify(void *a1))(uint64_t a1, char a2)
{
  uint64_t v2 = v1;
  uint64_t v4 = malloc(0x48uLL);
  *a1 = v4;
  v4[8] = v2;
  uint64_t v5 = objc_msgSend(v2, sel_packetHandler);
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = swift_allocObject();
    *(void *)(v7 + 16) = v6;
    uint64_t v8 = swift_allocObject();
    *(void *)(v8 + 16) = sub_1876BAC8C;
    *(void *)(v8 + 24) = v7;
    uint64_t v5 = (void *)swift_allocObject();
    v5[2] = sub_1876BAC90;
    v5[3] = v8;
    uint64_t v9 = sub_1876BA6FC;
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  v4[6] = v9;
  v4[7] = v5;
  return sub_1876BA9BC;
}

void sub_1876BA9BC(uint64_t a1, char a2)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 48LL);
  uint64_t v4 = *(void *)(*(void *)a1 + 56LL);
  if ((a2 & 1) != 0)
  {
    if (v3)
    {
      uint64_t v5 = swift_allocObject();
      *(void *)(v5 + 16) = v3;
      *(void *)(v5 + 24) = v4;
      uint64_t v6 = swift_allocObject();
      *(void *)(v6 + 16) = sub_1876BAC88;
      *(void *)(v6 + 24) = v5;
      v2[4] = sub_1876BA828;
      v2[5] = v6;
      *uint64_t v2 = MEMORY[0x1895F87A8];
      v2[1] = 1107296256LL;
      v2[2] = sub_1876BA82C;
      v2[3] = &block_descriptor_23;
      uint64_t v7 = _Block_copy(v2);
      swift_retain_n();
      swift_release();
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    objc_msgSend((id)v2[8], sel_setPacketHandler_, v7);
    sub_1876BA700(v3);
    _Block_release(v7);
    sub_1876BA700(v2[6]);
  }

  else
  {
    if (v3)
    {
      uint64_t v8 = swift_allocObject();
      *(void *)(v8 + 16) = v3;
      *(void *)(v8 + 24) = v4;
      uint64_t v9 = swift_allocObject();
      *(void *)(v9 + 16) = sub_1876BAC88;
      *(void *)(v9 + 24) = v8;
      v2[4] = sub_1876BA828;
      v2[5] = v9;
      *uint64_t v2 = MEMORY[0x1895F87A8];
      v2[1] = 1107296256LL;
      v2[2] = sub_1876BA82C;
      v2[3] = &block_descriptor_34;
      uint64_t v10 = _Block_copy(v2);
      swift_retain();
      swift_release();
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    objc_msgSend((id)v2[8], sel_setPacketHandler_, v10);
    sub_1876BA700(v3);
    _Block_release(v10);
  }

  free(v2);
}

uint64_t sub_1876BAB9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void (*v6)(uint64_t *__return_ptr, uint64_t *, uint64_t *, uint64_t *, uint64_t *, uint64_t *);
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v6 = *(void (**)(uint64_t *__return_ptr, uint64_t *, uint64_t *, uint64_t *, uint64_t *, uint64_t *))(v5 + 16);
  uint64_t v13 = a1;
  uint64_t v11 = a3;
  id v12 = a2;
  uint64_t v9 = a5;
  uint64_t v10 = a4;
  v6(&v8, &v13, &v12, &v11, &v10, &v9);
  return v8;
}

uint64_t sub_1876BABF4(uint64_t result)
{
  if (result) {
    return swift_retain();
  }
  return result;
}

uint64_t sub_1876BAC04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void (*v6)(uint64_t *__return_ptr, uint64_t *, uint64_t, uint64_t *, void *);
  uint64_t v8;
  void v9[2];
  uint64_t v10;
  uint64_t v11;
  uint64_t v6 = *(void (**)(uint64_t *__return_ptr, uint64_t *, uint64_t, uint64_t *, void *))(v5 + 16);
  uint64_t v11 = a1;
  v9[1] = a5;
  uint64_t v10 = a3;
  v9[0] = a4;
  v6(&v8, &v11, a2, &v10, v9);
  return v8;
}

uint64_t NEAppProxyTCPFlow.remoteFlowEndpoint.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C10);
  MEMORY[0x1895F8858](v4);
  uint64_t v6 = (char *)&v11 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  id v7 = objc_msgSend(v2, sel_remoteFlowEndpoint);
  sub_18786081C();
  uint64_t v8 = sub_187860810();
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 48))(v6, 1LL, v8);
  if ((_DWORD)result != 1) {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v9 + 32))(a1, v6, v8);
  }
  __break(1u);
  return result;
}

uint64_t NEFilterSocketFlow.remoteFlowEndpoint.getter()
{
  return sub_1876BA2E8((SEL *)&selRef_remoteFlowEndpoint);
}

uint64_t NEFilterSocketFlow.localFlowEndpoint.getter()
{
  return sub_1876BA2E8((SEL *)&selRef_localFlowEndpoint);
}

void NEAppProxyUDPFlow.readDatagrams(completionHandler:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = swift_allocObject();
  *(void *)(v5 + 16) = a1;
  *(void *)(v5 + 24) = a2;
  v7[4] = sub_1876BB110;
  v7[5] = v5;
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 1107296256LL;
  CFErrorRef v7[2] = sub_1876BB308;
  v7[3] = &block_descriptor_0;
  uint64_t v6 = _Block_copy(v7);
  swift_retain();
  swift_release();
  objc_msgSend(v2, sel_readDatagramsAndFlowEndpointsWithCompletionHandler_, v6);
  _Block_release(v6);
}

size_t sub_1876BAE38( size_t a1, unint64_t a2, uint64_t a3, void (*a4)(size_t, uint64_t), uint64_t a5)
{
  uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C10);
  MEMORY[0x1895F8858](v10);
  id v12 = (char *)v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = sub_187860810();
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v13);
  id v31 = (char *)v26 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (!a1)
  {
LABEL_20:
    a4(a1, a3);
    return swift_bridgeObjectRelease();
  }

  if (!a2)
  {
    a1 = 0LL;
    goto LABEL_20;
  }

  v26[1] = a1;
  uint64_t v27 = a3;
  uint64_t v28 = a5;
  unint64_t v29 = a4;
  if (a2 >> 62) {
    goto LABEL_23;
  }
  uint64_t v16 = *(void *)((a2 & 0xFFFFFFFFFFFFFF8LL) + 0x10);
  while (1)
  {
    uint64_t v17 = MEMORY[0x18961AFE8];
    if (!v16)
    {
LABEL_18:
      uint64_t v24 = (char *)swift_bridgeObjectRetain();
      size_t v25 = sub_1876BBD50(v24, v17);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      v29(v25, v27);
      return swift_bridgeObjectRelease();
    }

    uint64_t v32 = MEMORY[0x18961AFE8];
    size_t result = sub_1876BBAA0(0LL, v16 & ~(v16 >> 63), 0);
    if (v16 < 0) {
      break;
    }
    uint64_t v19 = 0LL;
    uint64_t v17 = v32;
    unint64_t v30 = a2 & 0xC000000000000001LL;
    while (v16 != v19)
    {
      if (v30) {
        MEMORY[0x1895AB52C](v19, a2);
      }
      else {
        swift_unknownObjectRetain();
      }
      swift_unknownObjectRetain();
      sub_18786081C();
      size_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v14 + 48))(v12, 1LL, v13);
      if ((_DWORD)result == 1) {
        goto LABEL_25;
      }
      id v20 = *(void (**)(char *, char *, uint64_t))(v14 + 32);
      v20(v31, v12, v13);
      swift_unknownObjectRelease();
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      uint64_t v32 = v17;
      if ((isUniquelyReferenced_nonNull_native & 1) == 0)
      {
        sub_1876BBAA0(0LL, *(void *)(v17 + 16) + 1LL, 1);
        uint64_t v17 = v32;
      }

      unint64_t v23 = *(void *)(v17 + 16);
      unint64_t v22 = *(void *)(v17 + 24);
      if (v23 >= v22 >> 1)
      {
        sub_1876BBAA0(v22 > 1, v23 + 1, 1);
        uint64_t v17 = v32;
      }

      ++v19;
      *(void *)(v17 + 16) = v23 + 1;
      v20( (char *)(v17 + ((*(unsigned __int8 *)(v14 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80))
               + *(void *)(v14 + 72) * v23),
        v31,
        v13);
      uint64_t v32 = v17;
      if (v16 == v19) {
        goto LABEL_18;
      }
    }

    __break(1u);
LABEL_23:
    swift_bridgeObjectRetain();
    uint64_t v16 = sub_187860BDC();
    swift_bridgeObjectRelease();
  }

  __break(1u);
LABEL_25:
  __break(1u);
  return result;
}

uint64_t sub_1876BB0EC()
{
  return swift_deallocObject();
}

size_t sub_1876BB110(size_t a1, unint64_t a2, uint64_t a3)
{
  return sub_1876BAE38(a1, a2, a3, *(void (**)(size_t, uint64_t))(v3 + 16), *(void *)(v3 + 24));
}

uint64_t sub_1876BB118(uint64_t a1)
{
  uint64_t v27 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1BE8);
  uint64_t v3 = *(void *)(v27 - 8);
  uint64_t v4 = MEMORY[0x1895F8858](v27);
  uint64_t v6 = (uint64_t *)((char *)&v22 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v4);
  uint64_t v26 = (char *)&v22 - v7;
  int64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = MEMORY[0x18961AFE8];
  if (v8)
  {
    uint64_t v22 = v1;
    uint64_t v28 = MEMORY[0x18961AFE8];
    sub_1876BBABC(0LL, v8, 0);
    uint64_t v10 = (uint64_t *)(a1 + ((*(unsigned __int8 *)(v3 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80)));
    uint64_t v25 = *(void *)(v3 + 72);
    uint64_t v11 = sub_187860810();
    uint64_t v24 = *(void *)(v11 - 8);
    unint64_t v23 = *(void (**)(char *, char *, uint64_t))(v24 + 16);
    do
    {
      uint64_t v12 = v27;
      uint64_t v13 = *(int *)(v27 + 48);
      uint64_t v14 = &v26[v13];
      uint64_t v15 = *v10;
      unint64_t v16 = v10[1];
      v23(&v26[v13], (char *)v10 + v13, v11);
      uint64_t v17 = (char *)v6 + *(int *)(v12 + 48);
      *uint64_t v6 = v15;
      v6[1] = v16;
      (*(void (**)(char *, char *, uint64_t))(v24 + 32))(v17, v14, v11);
      sub_1876B9070(v15, v16);
      sub_1876B9070(v15, v16);
      sub_1876BB84C((uint64_t)v6);
      uint64_t v9 = v28;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        sub_1876BBABC(0LL, *(void *)(v9 + 16) + 1LL, 1);
        uint64_t v9 = v28;
      }

      unint64_t v19 = *(void *)(v9 + 16);
      unint64_t v18 = *(void *)(v9 + 24);
      if (v19 >= v18 >> 1)
      {
        sub_1876BBABC((char *)(v18 > 1), v19 + 1, 1);
        uint64_t v9 = v28;
      }

      uint64_t v10 = (uint64_t *)((char *)v10 + v25);
      *(void *)(v9 + 16) = v19 + 1;
      uint64_t v20 = v9 + 16 * v19;
      *(void *)(v20 + 32) = v15;
      *(void *)(v20 + 40) = v16;
      --v8;
    }

    while (v8);
  }

  return v9;
}

uint64_t sub_1876BB308(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = *(void (**)(uint64_t, uint64_t, void *))(a1 + 32);
  if (!a2)
  {
    uint64_t v7 = 0LL;
    if (!a3) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  uint64_t v7 = sub_187860B7C();
  if (v5)
  {
LABEL_3:
    __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1BF0);
    uint64_t v5 = sub_187860B7C();
  }

LABEL_4:
  swift_retain();
  id v8 = a4;
  v6(v7, v5, a4);
  swift_release();

  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

LABEL_5:
    uint64_t v4 = 0LL;
    newValue = 0LL;
    uint64_t v65 = 0LL;
    goto LABEL_6;
  }

  prefs = SCPreferencesCreate((CFAllocatorRef)*MEMORY[0x189604DB0], @"NEConfigurationManager prefs sync", 0LL);
  ne_log_obj();
  id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v3 = v8;
  if (!prefs)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v59 = SCError();
      *(_DWORD *)buf = 136315138;
      unint64_t v88 = SCErrorString(v59);
      _os_log_error_impl(&dword_1876B1000, v3, OS_LOG_TYPE_ERROR, "SCPreferencesCreate failed: %s", buf, 0xCu);
    }

    goto LABEL_4;
  }

  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    unint64_t v88 = "-[NEConfigurationManager syncConfigurationsWithSC:completionQueue:completionHandler:]_block_invoke";
    v89 = 1024;
    LODWORD(v90) = 1899;
    _os_log_debug_impl(&dword_1876B1000, v3, OS_LOG_TYPE_DEBUG, "%s:%d: Locking SCPreferences", buf, 0x12u);
  }

  if (!SCPreferencesLock(prefs, 1u))
  {
    ne_log_obj();
    uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      uint64_t v60 = SCError();
      uint64_t v61 = SCErrorString(v60);
      *(_DWORD *)buf = 136315138;
      unint64_t v88 = v61;
      _os_log_error_impl(&dword_1876B1000, v27, OS_LOG_TYPE_ERROR, "SCPreferencesLock failed: %s", buf, 0xCu);
    }

    CFRelease(prefs);
    goto LABEL_5;
  }

  Property = *(id *)(a1 + 32);
  if (Property) {
    Property = objc_getProperty(Property, v9, 120LL, 1);
  }
  uint64_t v65 = Property;
  SCPreferencesGetSignature(prefs);
  newValue = (char *)objc_claimAutoreleasedReturnValue();
  if (v65 && ([v65 isEqualToData:newValue] & 1) != 0)
  {
    ne_log_obj();
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( &dword_1876B1000,  v11,  OS_LOG_TYPE_INFO,  "SCPreferences signature matches saved signature, change origin was NetworkExtension",  buf,  2u);
    }

    goto LABEL_67;
  }

  unint64_t v77 = 0LL;
  unint64_t v78 = &v77;
  uint64_t v79 = 0x2020000000LL;
  uint64_t v80 = 0;
  ne_log_obj();
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412546;
    unint64_t v88 = newValue;
    v89 = 2112;
    CFErrorRef v90 = v65;
    _os_log_impl( &dword_1876B1000,  v12,  OS_LOG_TYPE_INFO,  "SCPreferences signature (%@) does not match saved signature (%@), checking updated configurations",  buf,  0x16u);
  }

  uint64_t v14 = *(void **)(a1 + 32);
  if (v14)
  {
    objc_setProperty_atomic(v14, v13, newValue, 120LL);
    uint64_t v15 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  unint64_t v16 = *(void **)(a1 + 40);
  applier[0] = MEMORY[0x1895F87A8];
  applier[1] = 3221225472LL;
  applier[2] = __85__NEConfigurationManager_syncConfigurationsWithSC_completionQueue_completionHandler___block_invoke_142;
  applier[3] = &unk_18A08B9E0;
  applier[4] = v15;
  unint64_t v74 = 0LL;
  unint64_t v75 = &v77;
  uint64_t v76 = prefs;
  xpc_array_apply(v16, applier);
  unint64_t v18 = v78;
  unint64_t v19 = *(void *)(a1 + 32);
  if (*((_BYTE *)v78 + 24))
  {
    if (v19)
    {
      *(void *)objc_super v81 = 0LL;
      uint64_t v82 = 0u;
      v83 = 0u;
      uint64_t v84 = 0u;
      uint64_t v85 = 0u;
      uint64_t v20 = objc_getProperty((id)v19, v17, 88LL, 1);
      uint64_t v22 = [v20 countByEnumeratingWithState:&v82 objects:buf count:16];
      if (v22)
      {
        unint64_t v23 = *(void *)v83;
        do
        {
          for (i = 0LL; i != v22; ++i)
          {
            if (*(void *)v83 != v23) {
              objc_enumerationMutation(v20);
            }
            objc_msgSend( objc_getProperty((id)v19, v21, 88, 1),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v82 + 1) + 8 * i));
            uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue();
            +[NEConfigurationManager updateFlags:withConfiguration:]( (uint64_t)&OBJC_CLASS___NEConfigurationManager,  (unint64_t *)v81,  v25);
          }

          uint64_t v22 = [v20 countByEnumeratingWithState:&v82 objects:buf count:16];
        }

        while (v22);
        uint64_t v26 = *(void *)v81;
      }

      else
      {
        uint64_t v26 = 0LL;
      }

      -[NEConfigurationManager postChangeNotificationWithGeneration:andFlags:onlyIfChanged:]( (_DWORD *)v19,  *(const char **)(v19 + 104),  v26,  0);
      unint64_t v18 = v78;
    }

    if (*((_BYTE *)v18 + 24)) {
      goto LABEL_66;
    }
    unint64_t v19 = *(void *)(a1 + 32);
  }

  if (v19)
  {
    ne_log_obj();
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1876B1000, v28, OS_LOG_TYPE_INFO, "Updating the saved SCPreferences signature", buf, 2u);
    }

    if ((*(_BYTE *)(v19 + 23) & 1) != 0)
    {
      unint64_t v30 = (void *)[objc_alloc(MEMORY[0x1896078F8]) initRequiringSecureCoding:1];
      unint64_t v29 = v30;
      objc_msgSend(v29, "encodeInt64:forKey:", 1, @"Version", prefs);
      if (objc_getProperty((id)v19, v31, 56LL, 1))
      {
        objc_msgSend(v29, "encodeObject:forKey:", objc_getProperty((id)v19, v32, 56, 1), @"Index");
        uint64_t v84 = 0u;
        uint64_t v85 = 0u;
        uint64_t v82 = 0u;
        v83 = 0u;
        objc_msgSend( objc_getProperty((id)v19, v33, 56, 1),  "objectForKeyedSubscript:",  @"ConfigurationProperties");
        uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v36 = [v34 countByEnumeratingWithState:&v82 objects:buf count:16];
        if (v36)
        {
          unint64_t v37 = *(void *)v83;
          do
          {
            for (j = 0LL; j != v36; ++j)
            {
              if (*(void *)v83 != v37) {
                objc_enumerationMutation(v34);
              }
              objc_msgSend( objc_getProperty((id)v19, v35, 88, 1),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v82 + 1) + 8 * j));
              uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
              unint64_t v40 = v39;
              if (v39)
              {
                [v39 identifier];
                unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
                [v41 UUIDString];
                objc_super v42 = (void *)objc_claimAutoreleasedReturnValue();
                [v29 encodeObject:v40 forKey:v42];
              }
            }

            unint64_t v36 = [v34 countByEnumeratingWithState:&v82 objects:buf count:16];
          }

          while (v36);
        }
      }

      objc_msgSend( v29,  "encodeObject:forKey:",  objc_getProperty((id)v19, v32, 120, 1),  @"SCPreferencesSignature2");
      [v29 finishEncoding];
      [v29 encodedData];
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v44 = [v43 writeToFile:@"/Library/Preferences/com.apple.networkextension.plist" atomically:1];

      if ((v44 & 1) == 0)
      {
        ne_log_obj();
        uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)objc_super v81 = 0;
          _os_log_error_impl( &dword_1876B1000,  v45,  OS_LOG_TYPE_ERROR,  "Failed to write the new file while updating the SCPreferences signature",  v81,  2u);
        }
      }
    }

    else
    {
      ne_log_obj();
      unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v29, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl( &dword_1876B1000,  (os_log_t)v29,  OS_LOG_TYPE_ERROR,  "Some non-nehelper process is trying to save the SCPreferences signature",  buf,  2u);
      }
    }
  }

  uint64_t v4 = 0LL;
LABEL_6:

  return v4;
}

  uint64_t v4 = 0LL;
LABEL_6:

  return v4;
}

    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_20;
  }

  ne_log_obj();
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    uint64_t v14 = "PFKey";
    uint64_t v35 = "NEIKEv2PacketTunnelProviderGetSocket";
    unint64_t v36 = 2112;
    *(_DWORD *)buf = 136315906;
    unint64_t v37 = v9;
    if ((_DWORD)a2) {
      uint64_t v14 = "IKE";
    }
    objc_super v38 = 2080;
    uint64_t v39 = v14;
    unint64_t v40 = 2080;
    unint64_t v41 = a5;
    _os_log_impl(&dword_1876B1000, v13, OS_LOG_TYPE_INFO, "%s: %@: socket type %s (%s)", buf, 0x2Au);
  }

  if ((_DWORD)a2)
  {
    if (!a3 || !a4)
    {
      ne_log_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136315394;
        uint64_t v35 = "NEIKEv2PacketTunnelProviderGetSocket";
        unint64_t v36 = 2112;
        unint64_t v37 = v9;
        _os_log_impl(&dword_1876B1000, v11, OS_LOG_TYPE_INFO, "%s: %@: Null local/remote", buf, 0x16u);
      }

      goto LABEL_4;
    }

    uint64_t v11 = (os_log_s *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:a3 length:*a3];
    uint64_t v15 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:a4 length:*a4];
    if (a5) {
      a5 = (void *)[objc_alloc(NSString) initWithUTF8String:a5];
    }
  }

  else
  {
    a5 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t v11 = 0LL;
  }

  unint64_t v16 = dispatch_semaphore_create(0LL);
  objc_setProperty_atomic(v9, v17, v16, 160LL);

  v26[0] = MEMORY[0x1895F87A8];
  v26[1] = 3221225472LL;
  void v26[2] = __NEIKEv2PacketTunnelProviderGetSocket_block_invoke;
  v26[3] = &unk_18A08D650;
  unint64_t v18 = v9;
  unint64_t v29 = a2;
  uint64_t v27 = v18;
  uint64_t v28 = &v30;
  [v18 requestSocket:a2 interface:a5 local:v11 remote:v15 completionHandler:v26];
  uint64_t v20 = (dispatch_semaphore_s *)objc_getProperty(v18, v19, 160LL, 1);
  uint64_t v21 = dispatch_time(0LL, 2000000000LL);
  uint64_t v22 = dispatch_semaphore_wait(v20, v21);

  if (v22)
  {
    ne_log_obj();
    uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v35 = "NEIKEv2PacketTunnelProviderGetSocket";
      unint64_t v36 = 2112;
      unint64_t v37 = v18;
      _os_log_error_impl(&dword_1876B1000, v24, OS_LOG_TYPE_ERROR, "%s: %@ Wait Timeout\n", buf, 0x16u);
    }
  }

  objc_setProperty_atomic(v18, v23, 0LL, 160LL);
  uint64_t v12 = *((unsigned int *)v31 + 6);

LABEL_20:
  _Block_object_dispose(&v30, 8);

  return v12;
}

    uint64_t v5 = v4;
LABEL_5:
    uint64_t v6 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      unint64_t v19 = 134218240;
      uint64_t v20 = v5;
      uint64_t v21 = 2048;
      uint64_t v22 = v3;
      uint64_t v7 = "invalid pfkey message length p %p and ep %p";
      id v8 = v6;
      uint64_t v9 = 22;
LABEL_31:
      _os_log_error_impl(&dword_1876B1000, v8, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&v19, v9);
    }
  }

  else
  {
    uint64_t v10 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      uint64_t v7 = "msg/mhp is NULL";
      id v8 = v10;
      uint64_t v9 = 2;
      goto LABEL_31;
    }
  }

  return 0xFFFFFFFFLL;
}

        -[NEIKEv2RTT resetRTTMeasurement](a1);
        goto LABEL_8;
      }

      ne_log_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v24 = v5;
        _os_log_error_impl(&dword_1876B1000, v17, OS_LOG_TYPE_ERROR, "%@, failed to update RTT", buf, 0xCu);
      }
    }

    else
    {
      ne_log_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        uint64_t v7 = *(_DWORD *)(a1 + 12);
        *(_DWORD *)buf = 138412802;
        uint64_t v24 = v5;
        uint64_t v25 = 1024;
        uint64_t v26 = a3;
        uint64_t v27 = 1024;
        uint64_t v28 = v7;
        _os_log_impl( &dword_1876B1000,  v6,  OS_LOG_TYPE_INFO,  "%@, response message ID(%u) != request message ID(%u)",  buf,  0x18u);
      }
    }
  }

uint64_t block_copy_helper_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper_0()
{
  return swift_release();
}

uint64_t NEAppProxyUDPFlow.readDatagrams()()
{
  *(void *)(v1 + 144) = v0;
  return swift_task_switch();
}

uint64_t sub_1876BB3EC()
{
  uint64_t v1 = v0;
  uint64_t v2 = v0 + 16;
  uint64_t v3 = (void *)v0[18];
  v1[7] = v2;
  v1[2] = v1;
  v1[3] = sub_1876BB504;
  uint64_t v4 = swift_continuation_init();
  uint64_t v5 = swift_allocObject();
  *(void *)(v5 + 16) = v4;
  uint64_t v6 = swift_allocObject();
  v1[10] = MEMORY[0x1895F87A8];
  v1 += 10;
  *(void *)(v6 + 16) = sub_1876BB59C;
  *(void *)(v6 + 24) = v5;
  v1[4] = sub_1876BC2D0;
  v1[5] = v6;
  v1[1] = 1107296256LL;
  v1[2] = sub_1876BB308;
  v1[3] = &block_descriptor_10;
  uint64_t v7 = _Block_copy(v1);
  swift_retain();
  swift_release();
  objc_msgSend(v3, sel_readDatagramsAndFlowEndpointsWithCompletionHandler_, v7);
  _Block_release(v7);
  swift_release();
  return swift_continuation_await();
}

uint64_t sub_1876BB504()
{
  return (*(uint64_t (**)(void, void))(*(void *)v0 + 8LL))( *(void *)(*(void *)v0 + 128LL),  *(void *)(*(void *)v0 + 136LL));
}

uint64_t sub_1876BB544(uint64_t a1, void *a2, uint64_t a3)
{
  id v6 = a2;
  uint64_t v7 = *(void **)(*(void *)(a3 + 64) + 40LL);
  *uint64_t v7 = a1;
  v7[1] = a2;
  return swift_continuation_resume();
}

uint64_t sub_1876BB58C()
{
  return swift_deallocObject();
}

uint64_t sub_1876BB59C(uint64_t a1, void *a2)
{
  return sub_1876BB544(a1, a2, *(void *)(v2 + 16));
}

void NEAppProxyUDPFlow.writeDatagrams(_:completionHandler:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v29 = a2;
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1BE8);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  uint64_t v10 = (_OWORD *)((char *)&v26 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (_OWORD *)((char *)&v26 - v11);
  uint64_t v13 = sub_1876BB118(a1);
  uint64_t v14 = *(void *)(a1 + 16);
  if (v14)
  {
    uint64_t v26 = v13;
    uint64_t v27 = a3;
    uint64_t v28 = v3;
    aBlock[0] = MEMORY[0x18961AFE8];
    sub_187860BB8();
    uint64_t v15 = a1 + ((*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
    uint64_t v16 = *(void *)(v7 + 72);
    while (1)
    {
      sub_1876BB804(v15, (uint64_t)v12);
      uint64_t v17 = *(int *)(v6 + 48);
      unint64_t v18 = (char *)v10 + v17;
      unint64_t v19 = (char *)v12 + v17;
      _OWORD *v10 = *v12;
      uint64_t v20 = sub_187860810();
      uint64_t v21 = *(void *)(v20 - 8);
      (*(void (**)(char *, char *, uint64_t))(v21 + 16))(v18, v19, v20);
      uint64_t v22 = sub_187860804();
      (*(void (**)(char *, uint64_t))(v21 + 8))(v18, v20);
      if (!v22) {
        break;
      }
      sub_1876BB84C((uint64_t)v12);
      sub_187860BA0();
      sub_187860BC4();
      sub_187860BD0();
      sub_187860BAC();
      v15 += v16;
      if (!--v14)
      {
        a3 = v27;
        uint64_t v3 = v28;
        goto LABEL_6;
      }
    }

    __break(1u);
  }

  else
  {
LABEL_6:
    unint64_t v23 = (void *)sub_187860B70();
    swift_bridgeObjectRelease();
    __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1BF0);
    uint64_t v24 = (void *)sub_187860B70();
    swift_bridgeObjectRelease();
    aBlock[4] = v29;
    aBlock[5] = a3;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 1107296256LL;
    aBlock[2] = sub_1876BB88C;
    aBlock[3] = &block_descriptor_13;
    uint64_t v25 = _Block_copy(aBlock);
    swift_retain();
    swift_release();
    objc_msgSend(v3, sel_writeDatagrams_sentByFlowEndpoints_completionHandler_, v23, v24, v25);
    _Block_release(v25);
  }

uint64_t sub_1876BB804(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1BE8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

uint64_t sub_1876BB84C(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1BE8);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8LL))(a1, v2);
  return a1;
}

void sub_1876BB88C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void (**)(void *))(a1 + 32);
  swift_retain();
  id v4 = a2;
  v3(a2);
  swift_release();
}

uint64_t NEAppProxyUDPFlow.writeDatagrams(_:)(uint64_t a1)
{
  *(void *)(v2 + 80) = a1;
  *(void *)(v2 + 88) = v1;
  return swift_task_switch();
}

uint64_t sub_1876BB8F8()
{
  uint64_t v1 = v0[10];
  v0[2] = v0;
  v0[3] = sub_1876BB984;
  uint64_t v2 = swift_continuation_init();
  uint64_t v3 = swift_allocObject();
  *(void *)(v3 + 16) = v2;
  NEAppProxyUDPFlow.writeDatagrams(_:completionHandler:)(v1, (uint64_t)sub_1876BBA60, v3);
  swift_release();
  return swift_continuation_await();
}

uint64_t sub_1876BB984()
{
  uint64_t v1 = *v0;
  if (*(void *)(v1 + 48)) {
    swift_willThrow();
  }
  return (*(uint64_t (**)(void))(v1 + 8))();
}

uint64_t sub_1876BB9D8(void *a1)
{
  if (!a1) {
    return swift_continuation_throwingResume();
  }
  __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C00);
  swift_allocError();
  *uint64_t v2 = a1;
  id v3 = a1;
  return swift_continuation_throwingResumeWithError();
}

uint64_t sub_1876BBA50()
{
  return swift_deallocObject();
}

uint64_t sub_1876BBA60(void *a1)
{
  return sub_1876BB9D8(a1);
}

uint64_t NEAppProxyUDPFlow.localFlowEndpoint.getter()
{
  id v1 = objc_msgSend(v0, sel_localFlowEndpoint);
  return sub_18786081C();
}

size_t sub_1876BBAA0(size_t a1, int64_t a2, char a3)
{
  size_t result = sub_1876BBAD8(a1, a2, a3, (void *)*v3);
  *id v3 = result;
  return result;
}

char *sub_1876BBABC(char *a1, int64_t a2, char a3)
{
  size_t result = sub_1876BBC4C(a1, a2, a3, *v3);
  *id v3 = result;
  return result;
}

size_t sub_1876BBAD8(size_t result, int64_t a2, char a3, void *a4)
{
  char v5 = result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
LABEL_30:
        __break(1u);
        return result;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (!v9)
  {
    uint64_t v13 = (void *)MEMORY[0x18961AFE8];
    goto LABEL_19;
  }

  __swift_instantiateConcreteTypeFromMangledName(qword_18C6E1C20);
  uint64_t v10 = *(void *)(sub_187860810() - 8);
  uint64_t v11 = *(void *)(v10 + 72);
  unint64_t v12 = (*(unsigned __int8 *)(v10 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80);
  uint64_t v13 = (void *)swift_allocObject();
  size_t result = _swift_stdlib_malloc_size(v13);
  if (!v11)
  {
    __break(1u);
LABEL_29:
    __break(1u);
    goto LABEL_30;
  }

  if (result - v12 == 0x8000000000000000LL && v11 == -1) {
    goto LABEL_29;
  }
  v13[2] = v8;
  v13[3] = 2 * ((uint64_t)(result - v12) / v11);
LABEL_19:
  uint64_t v15 = *(void *)(sub_187860810() - 8);
  if ((v5 & 1) != 0)
  {
    if (v13 < a4
      || (unint64_t v16 = (*(unsigned __int8 *)(v15 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v15 + 80),
          (char *)v13 + v16 >= (char *)a4 + v16 + *(void *)(v15 + 72) * v8))
    {
      swift_arrayInitWithTakeFrontToBack();
    }

    else if (v13 != a4)
    {
      swift_arrayInitWithTakeBackToFront();
    }

    a4[2] = 0LL;
  }

  else
  {
    swift_arrayInitWithCopy();
  }

  swift_release();
  return (size_t)v13;
}

char *sub_1876BBC4C(char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C08);
    uint64_t v10 = (char *)swift_allocObject();
    int64_t v11 = _swift_stdlib_malloc_size(v10);
    uint64_t v12 = v11 - 32;
    if (v11 < 32) {
      uint64_t v12 = v11 - 17;
    }
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * (v12 >> 4);
  }

  else
  {
    uint64_t v10 = (char *)MEMORY[0x18961AFE8];
  }

  uint64_t v13 = v10 + 32;
  uint64_t v14 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v13 >= &v14[16 * v8]) {
      memmove(v13, v14, 16 * v8);
    }
    *((void *)a4 + 2) = 0LL;
  }

  else
  {
    swift_arrayInitWithCopy();
  }

  swift_release();
  return v10;
}

size_t sub_1876BBD50(char *a1, uint64_t a2)
{
  uint64_t v74 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1BE8);
  uint64_t v4 = *(void *)(v74 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](v74);
  int64_t v7 = (unint64_t *)((char *)&v59 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v8 = MEMORY[0x1895F8858](v5);
  uint64_t v10 = (uint64_t *)((char *)&v59 - v9);
  MEMORY[0x1895F8858](v8);
  uint64_t v65 = a2;
  uint64_t v66 = (uint64_t)&v59 - v11;
  unint64_t v12 = *((void *)a1 + 2);
  unint64_t v13 = *(void *)(a2 + 16);
  if (v13 >= v12) {
    int64_t v14 = *((void *)a1 + 2);
  }
  else {
    int64_t v14 = *(void *)(a2 + 16);
  }
  uint64_t v63 = v10;
  uint64_t v64 = v4;
  unint64_t v71 = v12;
  unint64_t v73 = v13;
  uint64_t v62 = a1;
  if (v14)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C18);
    uint64_t v15 = *(void *)(v4 + 72);
    unint64_t v16 = (*(unsigned __int8 *)(v4 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80);
    uint64_t v60 = *(unsigned __int8 *)(v4 + 80);
    uint64_t v17 = (void *)swift_allocObject();
    size_t result = _swift_stdlib_malloc_size(v17);
    if (!v15)
    {
LABEL_61:
      __break(1u);
      goto LABEL_62;
    }

    int64_t v19 = result - v16;
    BOOL v20 = result - v16 == 0x8000000000000000LL && v15 == -1;
    uint64_t v72 = v16;
    if (v20) {
      goto LABEL_63;
    }
    uint64_t v21 = v19 / v15;
    uint64_t v61 = (char *)v14;
    v17[2] = v14;
    v17[3] = 2 * (v19 / v15);
    uint64_t v69 = v17;
    size_t result = sub_187860810();
    size_t v70 = result;
    if (v12)
    {
      int64_t v14 = 0LL;
      uint64_t v22 = v69;
      uint64_t v23 = *(void *)(v70 - 8);
      uint64_t v68 = v65 + ((*(unsigned __int8 *)(v23 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v23 + 80));
      uint64_t v59 = v21 & 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v24 = (unint64_t *)(v62 + 40);
      uint64_t v67 = v61 - 1;
      a1 = (char *)v69 + v15;
      while (v13 != v14)
      {
        unint64_t v13 = *(v24 - 1);
        unint64_t v12 = *v24;
        uint64_t v25 = v68 + *(void *)(v23 + 72) * v14;
        uint64_t v26 = (char *)v7 + *(int *)(v74 + 48);
        *int64_t v7 = v13;
        v7[1] = v12;
        (*(void (**)(char *, uint64_t, size_t))(v23 + 16))(v26, v25, v70);
        sub_1876BC27C((uint64_t)v7, (uint64_t)v22 + v16);
        v24 += 2;
        size_t result = sub_1876B9070(v13, v12);
        ++v14;
        a1 += v15;
        uint64_t v22 = (void *)((char *)v22 + v15);
        unint64_t v16 = v72;
        unint64_t v13 = v73;
        if (v71 == v14) {
          goto LABEL_15;
        }
      }

      __break(1u);
      goto LABEL_55;
    }

LABEL_15:
    __break(1u);
LABEL_16:
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    size_t result = sub_1876B9070(v13, v12);
    uint64_t v27 = v60;
    uint64_t v28 = ~v14 + v59;
    unint64_t v12 = v71;
    uint64_t v29 = (uint64_t)&a1[v72];
    uint64_t v10 = v63;
    uint64_t v30 = v64;
    unint64_t v13 = v73;
    int64_t v14 = (int64_t)v61;
    if (v71 > v73)
    {
LABEL_19:
      uint64_t v68 = v27 | 7;
      else {
        unint64_t v32 = v14;
      }
      size_t v70 = v32;
      unint64_t v33 = (unint64_t *)&v62[16 * v14 + 40];
      int64_t v34 = v14;
      while (v12 != v34)
      {
        if (v13 == v34) {
          goto LABEL_49;
        }
        if (v70 == v34) {
          goto LABEL_56;
        }
        uint64_t v35 = *(v33 - 1);
        unint64_t v36 = *v33;
        uint64_t v37 = sub_187860810();
        uint64_t v38 = *(void *)(v37 - 8);
        unint64_t v39 = v65
        unint64_t v40 = (char *)v10 + *(int *)(v74 + 48);
        uint64_t *v10 = v35;
        v10[1] = v36;
        (*(void (**)(char *, unint64_t, uint64_t))(v38 + 16))(v40, v39, v37);
        size_t result = sub_1876BC27C((uint64_t)v10, v66);
        if (v28)
        {
          size_t result = sub_1876B9070(v35, v36);
          unint64_t v41 = v69;
        }

        else
        {
          unint64_t v42 = v69[3];
          int64_t v43 = v42 & 0xFFFFFFFFFFFFFFFELL;
          if (v43 <= 1) {
            uint64_t v44 = 1LL;
          }
          else {
            uint64_t v44 = v43;
          }
          __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C18);
          uint64_t v45 = *(void *)(v30 + 72);
          uint64_t v46 = v72;
          unint64_t v41 = (void *)swift_allocObject();
          size_t result = _swift_stdlib_malloc_size(v41);
          if (!v45) {
            goto LABEL_59;
          }
          int64_t v47 = result - v46;
          if (result - v46 == 0x8000000000000000LL && v45 == -1) {
            goto LABEL_60;
          }
          uint64_t v49 = v47 / v45;
          v41[2] = v44;
          v41[3] = 2 * (v47 / v45);
          uint64_t v50 = (char *)v41 + v46;
          uint64_t v51 = v69[3] >> 1;
          uint64_t v52 = v51 * v45;
          uint64_t v29 = (uint64_t)v41 + v46 + v51 * v45;
          uint64_t v53 = v46;
          uint64_t v28 = (v49 & 0x7FFFFFFFFFFFFFFFLL) - v51;
          if (v69[2])
          {
            uint64_t v54 = v69;
            if (v41 < v69 || v50 >= (char *)v69 + v53 + v52)
            {
              sub_1876B9070(v35, v36);
              swift_arrayInitWithTakeFrontToBack();
              uint64_t v10 = v63;
            }

            else
            {
              uint64_t v61 = (char *)v69 + v53;
              uint64_t v67 = v50;
              sub_1876B9070(v35, v36);
              uint64_t v10 = v63;
              if (v41 != v54) {
                swift_arrayInitWithTakeBackToFront();
              }
            }

            v54[2] = 0LL;
            size_t result = swift_release();
            uint64_t v30 = v64;
          }

          else
          {
            sub_1876B9070(v35, v36);
            size_t result = swift_release();
            uint64_t v10 = v63;
            uint64_t v30 = v64;
          }

          unint64_t v12 = v71;
        }

        unint64_t v13 = v73;
        BOOL v55 = __OFSUB__(v28--, 1LL);
        if (v55) {
          goto LABEL_57;
        }
        ++v34;
        size_t result = sub_1876BC27C(v66, v29);
        v29 += *(void *)(v30 + 72);
        v33 += 2;
        uint64_t v69 = v41;
        if (v12 == v34) {
          goto LABEL_50;
        }
      }

LABEL_16:
  unint64_t v41 = 0u;
  unint64_t v42 = 0u;
  unint64_t v39 = 0u;
  unint64_t v40 = 0u;
  objc_msgSend(a1, "relay", 0);
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  [v21 relays];
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();

  uint64_t v23 = [v22 countByEnumeratingWithState:&v39 objects:v47 count:16];
  if (v23)
  {
    uint64_t v24 = v23;
    uint64_t v25 = *(void *)v40;
    do
    {
      for (j = 0LL; j != v24; ++j)
      {
        if (*(void *)v40 != v25) {
          objc_enumerationMutation(v22);
        }
        uint64_t v27 = *(void **)(*((void *)&v39 + 1) + 8 * j);
        [a1 payloadInfo];
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
        [v27 clearKeychainItemsInDomain:a2 removeItems:v28 == 0];
      }

      uint64_t v24 = [v22 countByEnumeratingWithState:&v39 objects:v47 count:16];
    }

    while (v24);
  }

  -[NEConfiguration syncWithKeychainInDomain:](a1, a2);
}

    goto LABEL_16;
  }

  uint64_t v24 = v16;
  uint64_t v25 = (const char *)[v24 UTF8String];
  if (v25)
  {
    xpc_dictionary_set_string(v20, "query", v25);
    ne_log_obj();
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uuid = 138412290;
      *(void *)&uuid[4] = v24;
      uint64_t v27 = "Set query string: %@";
      uint64_t v28 = v26;
      uint64_t v29 = 12;
LABEL_18:
      _os_log_debug_impl(&dword_1876B1000, v28, OS_LOG_TYPE_DEBUG, v27, uuid, v29);
      goto LABEL_15;
    }

    goto LABEL_15;
  }

  unint64_t v18 = objc_alloc_init(MEMORY[0x189603FC8]);
  int64_t v19 = v18;
  if (!*((void *)a1 + 17)) {
    [v18 setObject:MEMORY[0x189604A88] forKeyedSubscript:@"no-app-filter"];
  }
  [MEMORY[0x189603F90] preferredLanguages];
  BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
  if ([v20 count]) {
    [v19 setObject:v20 forKeyedSubscript:@"preferred-languages"];
  }
  uint64_t v21 = objc_alloc(&OBJC_CLASS___NEHelper);
  uint64_t v23 = -[NEHelper initWithDelegateClassID:queue:additionalProperties:]( v21,  "initWithDelegateClassID:queue:additionalProperties:",  6LL,  objc_getProperty(a1, v22, 40LL, 1),  v19);
  objc_setProperty_atomic(a1, v24, v23, 112LL);

LABEL_20:
  return a1;
}

  if (!v9) {
    goto LABEL_18;
  }
  [*(id *)(a1 + 32) setConfiguration:v9];
LABEL_19:
  unint64_t v18 = *(void *)(a1 + 32);
  if (v18) {
    *(_BYTE *)(v18 + 8) = 1;
  }

LABEL_22:
  int64_t v19 = *(void **)(a1 + 40);
  if (v19)
  {
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __62__NEDNSProxyManager_loadFromPreferencesWithCompletionHandler___block_invoke_2;
    block[3] = &unk_18A0908C8;
    uint64_t v23 = v19;
    uint64_t v22 = v5;
    dispatch_async(MEMORY[0x1895F8AE0], block);
  }

  objc_sync_exit(v6);
}

  objc_sync_exit(v8);
}

    unint64_t v13 = 1LL;
    goto LABEL_16;
  }

  if ([(id)v5 status] == 3)
  {
    uint64_t v8 = *(id *)(a1 + 32);
    if (v8) {
      uint64_t v8 = objc_getProperty(v8, v7, 64LL, 1);
    }
    [v8 appendData:*(void *)(a1 + 40)];
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = [*(id *)(a1 + 40) length];
    if (v9) {
      *(void *)(v9 + 200) += v10;
    }
    uint64_t v11 = *(void *)(a1 + 32);
    v19[0] = MEMORY[0x1895F87A8];
    v19[1] = 3221225472LL;
    v19[2] = __47__NEFilterSource_receivedData_decisionHandler___block_invoke_7;
    v19[3] = &unk_18A090940;
    BOOL v20 = *(id *)(a1 + 56);
    if ((-[NEFilterSource sendDataToPluginWithConnection:completionHandler:](v11, v4, v19) & 1) == 0) {
      (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
    }
    unint64_t v12 = v20;
LABEL_21:

    goto LABEL_22;
  }

  (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
LABEL_22:
}

  return v14;
}
}

  return 0;
}

    return;
  }

  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  if (v5 && (int64_t v7 = objc_getProperty(v5, v4, 232LL, 1)) != 0LL)
  {
    uint64_t v8 = v7[2];
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  if (v6 == v8)
  {
    uint64_t v9 = *(void **)(a1 + 32);
    if (!v9 || (Property = objc_getProperty(v9, v4, 128LL, 1)) == 0LL || (Property[8] & 1) == 0)
    {
      ne_log_obj();
      unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        unint64_t v13 = "no companion proxy present, ignoring";
LABEL_14:
        _os_log_impl(&dword_1876B1000, v12, OS_LOG_TYPE_INFO, v13, buf, 2u);
        goto LABEL_15;
      }

      goto LABEL_15;
    }

    BOOL v20 = *(_BYTE **)(a1 + 32);
    if (!v20 || (v20[75] & 1) == 0)
    {
      ne_log_obj();
      unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_INFO)) {
        goto LABEL_15;
      }
      *(_WORD *)buf = 0;
      unint64_t v13 = "no companion outbound datapath detected, ignoring";
      goto LABEL_14;
    }

    uint64_t v22 = objc_getProperty(v20, v11, 232LL, 1);
    uint64_t v23 = *(void **)(a1 + 32);
    if (v23)
    {
      uint64_t v24 = objc_getProperty(v23, v21, 232LL, 1);
      uint64_t v25 = v24;
      if (v24)
      {
        uint64_t v26 = (void *)*((void *)v24 + 12);
LABEL_30:
        uint64_t v27 = -[NEIKEv2CompanionDatapath getStopReasonFromConnectionError:]((uint64_t)v22, v26);

        uint64_t v29 = *(id *)(a1 + 32);
        if (v29) {
          uint64_t v29 = objc_getProperty(v29, v28, 240LL, 1);
        }
        unint64_t v31 = [v29 state];
        unint64_t v32 = *(_BYTE **)(a1 + 32);
        if (v31 == 2 && v32 && (v32[79] & 1) != 0)
        {
          unint64_t v33 = objc_getProperty(v32, v30, 168LL, 1);
          if (!v33 || (v33[8] & 1) == 0)
          {
            uint64_t v35 = *(id *)(a1 + 32);
            if (v27 == 4)
            {
              if (v35 && (uint64_t v35 = objc_getProperty(v35, v34, 168LL, 1), (v36 = *(void *)(a1 + 32)) != 0)) {
                uint64_t v37 = *(void **)(v36 + 248);
              }
              else {
                uint64_t v37 = 0LL;
              }
              -[NEIKEv2MOBIKE initiateMOBIKE:pathStatus:serverAddress:earlyDisconnect:]((uint64_t)v35, v37, 2LL, 0LL, 0);
            }

            else
            {
              -[NEIKEv2PacketTunnelProvider handleInterfaceChange:]((uint64_t)v35, 0LL);
            }
          }
        }

        else
        {
          v38[0] = MEMORY[0x1895F87A8];
          v38[1] = 3221225472LL;
          v38[2] = __67__NEIKEv2PacketTunnelProvider_handleCompanionProxyDatapathFailure___block_invoke_133;
          v38[3] = &unk_18A08D3E8;
          v38[4] = v32;
          unint64_t v39 = v27;
          [v32 stopTunnelWithReason:14 completionHandler:v38];
        }

        return;
      }
    }

    else
    {
      uint64_t v25 = 0LL;
    }

    uint64_t v26 = 0LL;
    goto LABEL_30;
  }

  ne_log_obj();
  int64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    unint64_t v16 = *(void **)(a1 + 32);
    uint64_t v17 = *(void *)(a1 + 40);
    if (v16 && (unint64_t v18 = objc_getProperty(v16, v15, 232LL, 1)) != 0LL)
    {
      int64_t v19 = v18[2];
    }

    else
    {
      int64_t v19 = 0LL;
    }

    *(_DWORD *)buf = 134218240;
    unint64_t v41 = v17;
    unint64_t v42 = 2048;
    int64_t v43 = v19;
    _os_log_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_INFO,  "companion proxy datapath don't match %llu != %llu, ignoring",  buf,  0x16u);
  }
}

  return a1;
}

    unint64_t v13 = v25;
    int64_t v14 = (const void *)v25[3];
    if (v14)
    {
      CFRelease(v14);
      v13[3] = 0LL;
    }

    uint64_t v15 = v21[3];
    if (v15)
    {
      unint64_t v16 = _NEIPSecDBGetQueue();
      *(void *)buf = v7;
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = __NEIPSecDBRemoveQueuedRequest_block_invoke;
      uint64_t v29 = &__block_descriptor_tmp_163;
      uint64_t v30 = v15;
      dispatch_sync(v16, buf);
      free((void *)v21[3]);
    }

    _Block_object_dispose(&v20, 8);
    _Block_object_dispose(&v24, 8);
    return v10;
  }

  if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = "NEIPSecDBDeleteSA";
    _os_log_fault_impl(&dword_1876B1000, v5, OS_LOG_TYPE_FAULT, "%s called with null session", buf, 0xCu);
  }

  return 0LL;
}

    free(v9);
    uint64_t v17 = 0;
LABEL_19:
    unint64_t v18 = v16 ^ 1;
    if (!v12) {
      unint64_t v18 = 1;
    }
    if ((v18 & 1) == 0)
    {
      *(_OWORD *)buf = *(unsigned int *)(a1 + 48);
      int64_t v19 = *(dispatch_source_s **)(*(void *)(a1 + 40) + 64LL);
      BOOL v20 = _NEIPSecDBGetQueue();
      if (!NEPFKeySendGetStats(v19, (uint64_t)v20, 0, (unint64_t *)buf, 1, 1, v12, v16))
      {
        uint64_t v21 = (os_log_s *)ne_log_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          uint64_t v26 = 136315138;
          uint64_t v27 = "NEIPSecDBCreateStatsTimer_block_invoke";
          _os_log_error_impl( &dword_1876B1000,  v21,  OS_LOG_TYPE_ERROR,  "%s: failed to send stats request for inbound SA\n",  (uint8_t *)&v26,  0xCu);
        }
      }

      free(v12);
      ++*(_DWORD *)(*(void *)(a1 + 32) + 64LL);
    }

    if (v14 && v15)
    {
      *(_OWORD *)buf = *(unsigned int *)(a1 + 52);
      uint64_t v22 = *(dispatch_source_s **)(*(void *)(a1 + 40) + 64LL);
      uint64_t v23 = _NEIPSecDBGetQueue();
      if (!NEPFKeySendGetStats(v22, (uint64_t)v23, 0, (unint64_t *)buf, 1, 2, v15, v17))
      {
        uint64_t v24 = (os_log_s *)ne_log_obj();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          uint64_t v26 = 136315138;
          uint64_t v27 = "NEIPSecDBCreateStatsTimer_block_invoke";
          _os_log_error_impl( &dword_1876B1000,  v24,  OS_LOG_TYPE_ERROR,  "%s: failed to send stats request for outbound SA\n",  (uint8_t *)&v26,  0xCu);
        }
      }

      free(v15);
      ++*(_DWORD *)(*(void *)(a1 + 32) + 64LL);
    }

    return;
  }

  uint64_t v25 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = "NEIPSecDBStatsCreateArrays";
    _os_log_fault_impl(&dword_1876B1000, v25, OS_LOG_TYPE_FAULT, "%s called with null session", buf, 0xCu);
  }

  return v6;
}

      if (v9)
      {
        int64_t v19 = *(void **)(a1 + 32);
        if (!v19)
        {
LABEL_22:

          goto LABEL_23;
        }

        objc_setProperty_atomic(v19, v18, v9, 40LL);
LABEL_20:
        BOOL v20 = *(void *)(a1 + 32);
        if (v20) {
          *(_BYTE *)(v20 + 8) = 1;
        }
        goto LABEL_22;
      }
    }

    else
    {
    }

    -[NEDNSSettingsManager createEmptyConfigurationWithGrade:](*(void **)(a1 + 32));
    uint64_t v9 = 0LL;
    goto LABEL_20;
  }

    free(v3);
    return @"No domain trie entry";
  }

  if (strerror_r(12, __strerrbuf, 0x80uLL)) {
    __strerrbuf[0] = 0;
  }
  ne_log_obj();
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)uint64_t v29 = 12;
    *(_WORD *)&v29[4] = 2080;
    *(void *)&v29[6] = __strerrbuf;
    uint64_t v10 = "Failed to dump all tries: [%d] %s";
    uint64_t v11 = buf;
    goto LABEL_36;
  }

          ++v17;
        }

        while (v15 != v17);
        uint64_t v24 = [v13 countByEnumeratingWithState:&v29 objects:v36 count:16];
        uint64_t v15 = v24;
      }

      while (v24);
    }

    uint64_t v25 = v34;
    int64_t v7 = v27;
    uint64_t v6 = v28;
  }

  else
  {
    ne_log_obj();
    uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      uint64_t v38 = v6;
      unint64_t v39 = 2112;
      unint64_t v40 = v7;
      _os_log_error_impl( &dword_1876B1000,  v25,  OS_LOG_TYPE_ERROR,  "Payload UUID (%@) and/or profile UUID (%@) is invalid",  buf,  0x16u);
    }
  }
}

    uint64_t v11 = 0LL;
    goto LABEL_16;
  }

  uint64_t v8 = (const __CFString *)NEGetValueWithType(v7, (const void *)*MEMORY[0x18960CAB0], CFSTRING_TYPE);
  if (!v8 || (uint64_t v9 = (__CFString *)v8, !NEGetAddressFamilyFromString(v8)))
  {
    ne_log_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      int64_t v19 = "Legacy dictionary does not have a remote address string in its VPN dictionary";
LABEL_23:
      _os_log_error_impl(&dword_1876B1000, v17, OS_LOG_TYPE_ERROR, v19, buf, 2u);
      goto LABEL_15;
    }

    goto LABEL_15;
  }

  v22.receiver = self;
  v22.super_class = (Class)&OBJC_CLASS___NETunnelNetworkSettings;
  uint64_t v10 = -[NETunnelNetworkSettings init](&v22, sel_init);
  uint64_t v11 = v10;
  if (v10)
  {
    objc_storeStrong((id *)&v10->_tunnelRemoteAddress, v9);
    unint64_t v12 = (const __CFDictionary *)NEGetValueWithType(v5, (const void *)*MEMORY[0x18960C580], CFDICTIONARY_TYPE);
    if (v12)
    {
      unint64_t v13 = v12;
      if (CFDictionaryGetCount(v12) >= 1)
      {
        if (CFDictionaryContainsKey(v13, (const void *)*MEMORY[0x18960C620])
          || (BOOL v20 = (const void *)*MEMORY[0x18960C618], CFDictionaryContainsKey(v13, (const void *)*MEMORY[0x18960C618]))
          && (uint64_t v21 = (const __CFArray *)NEGetValueWithType(v13, v20, CFARRAY_TYPE)) != 0LL
          && CFArrayGetCount(v21))
        {
          int64_t v14 = -[NEDNSSettings initFromLegacyDictionary:]( objc_alloc(&OBJC_CLASS___NEDNSSettings),  "initFromLegacyDictionary:",  v13);
          -[NETunnelNetworkSettings setDNSSettings:](v11, "setDNSSettings:", v14);
        }
      }
    }

    uint64_t v15 = (const __CFDictionary *)NEGetValueWithType(v5, (const void *)*MEMORY[0x18960C5A8], CFDICTIONARY_TYPE);
    if (v15)
    {
      unint64_t v16 = v15;
      if (CFDictionaryGetCount(v15) >= 1)
      {
        self = -[NEProxySettings initFromLegacyDictionary:]( objc_alloc(&OBJC_CLASS___NEProxySettings),  "initFromLegacyDictionary:",  v16);
        -[NETunnelNetworkSettings setProxySettings:](v11, "setProxySettings:", self);
LABEL_16:
      }
    }
  }

  return v11;
}

  os_unfair_lock_unlock((os_unfair_lock_t)&g_currentNotificationLock);
  if (v6)
  {
    unint64_t v13 = a2 & 3;
    if ((_DWORD)v13 == 1)
    {
      int64_t v14 = 0LL;
    }

    else if ((_DWORD)v13 == 3)
    {
      int64_t v14 = 0LL;
      unint64_t v13 = 2LL;
    }

    else
    {
      int64_t v14 = objc_alloc_init(MEMORY[0x189603FA8]);
      uint64_t v15 = 0LL;
      unint64_t v16 = (const __CFString *)*MEMORY[0x1896056B8];
      do
      {
        ResponseValue = CFUserNotificationGetResponseValue(a1, v16, v15);
        if (!ResponseValue) {
          break;
        }
        [v14 addObject:ResponseValue];
        ++v15;
      }

      while (v15 != 10);
      unint64_t v13 = 0LL;
    }

    unint64_t v18 = (dispatch_queue_s *)objc_getProperty(v6, v12, 32LL, 1);
    int64_t v19 = v6[5];
    [v6 cancel];
    if (v18 && v19)
    {
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 3221225472LL;
      block[2] = __authCallback_block_invoke;
      block[3] = &unk_18A08FCA0;
      uint64_t v23 = v19;
      uint64_t v24 = v13;
      uint64_t v22 = v14;
      dispatch_async(v18, block);
    }
  }

  else
  {
    ne_log_obj();
    int64_t v14 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)BOOL v20 = 0;
      _os_log_error_impl( &dword_1876B1000,  (os_log_t)v14,  OS_LOG_TYPE_ERROR,  "Failed to find current notification on auth callback",  v20,  2u);
    }
  }
}

    if (v9)
    {
      int64_t v19 = *(void **)(a1 + 32);
      if (v19)
      {
        objc_setProperty_atomic(v19, v18, v9, 16LL);
        BOOL v20 = *(void *)(a1 + 32);
      }

      else
      {
        BOOL v20 = 0LL;
      }

      +[NERelayManager loadedManagers]();
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
      Property = *(id *)(a1 + 32);
      if (Property) {
        Property = objc_getProperty(Property, v21, 16LL, 1);
      }
      uint64_t v24 = Property;
      [v24 identifier];
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue();
      [v22 setObject:v20 forKeyedSubscript:v25];

      goto LABEL_23;
    }
  }

  else
  {
  }

  -[NERelayManager createEmptyConfigurationWithGrade:](*(void **)(a1 + 32));
  uint64_t v9 = 0LL;
LABEL_23:
  uint64_t v26 = *(void *)(a1 + 32);
  if (v26) {
    *(_BYTE *)(v26 + 9) = 1;
  }

LABEL_26:
  uint64_t v27 = *(void **)(a1 + 40);
  if (v27)
  {
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __59__NERelayManager_loadFromPreferencesWithCompletionHandler___block_invoke_2;
    block[3] = &unk_18A0908C8;
    unint64_t v31 = v27;
    uint64_t v30 = v5;
    dispatch_async(MEMORY[0x1895F8AE0], block);
  }

  objc_sync_exit(v6);
}

  objc_msgSend( v7,  "appendPrettyInt:withName:andIndent:options:",  -[NEVPNIKEv1ProposalParameters diffieHellmanGroup](self, "diffieHellmanGroup"),  @"diffieHellmanGroup",  v5,  a4);
  objc_msgSend( v7,  "appendPrettyInt:withName:andIndent:options:",  -[NEVPNIKEv1ProposalParameters lifetimeSeconds](self, "lifetimeSeconds"),  @"lifetimeSeconds",  v5,  a4);
  return v7;
}

  objc_msgSend( MEMORY[0x189607968],  "numberWithInt:",  -[NEVPNIKEv1ProposalParameters diffieHellmanGroup](self, "diffieHellmanGroup"));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  [v3 setObject:v6 forKeyedSubscript:@"DHGroup"];

  objc_msgSend( MEMORY[0x189607968],  "numberWithInt:",  -[NEVPNIKEv1ProposalParameters lifetimeSeconds](self, "lifetimeSeconds"));
  int64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  [v3 setObject:v7 forKeyedSubscript:@"Lifetime"];

  return v3;
}

LABEL_55:
      __break(1u);
LABEL_56:
      __break(1u);
LABEL_57:
      __break(1u);
LABEL_58:
      __break(1u);
LABEL_59:
      __break(1u);
LABEL_60:
      __break(1u);
      goto LABEL_61;
    }
  }

  else
  {
    uint64_t v27 = *(unsigned __int8 *)(v4 + 80);
    unint64_t v31 = *(void *)(MEMORY[0x18961AFE8] + 24LL);
    uint64_t v72 = (v27 + 32) & ~v27;
    uint64_t v69 = (void *)MEMORY[0x18961AFE8];
    uint64_t v29 = MEMORY[0x18961AFE8] + v72;
    uint64_t v28 = v31 >> 1;
    swift_bridgeObjectRetain();
    size_t result = swift_bridgeObjectRetain();
    uint64_t v30 = v4;
    if (v12 > v13) {
      goto LABEL_19;
    }
  }

  return a1;
}
    }
  }

  else
  {
    ne_log_obj();
    uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1876B1000, v53, OS_LOG_TYPE_ERROR, "Failed to receive Create Child SA packet", buf, 2u);
    }

    [*(id *)(a1 + 32) sendCallbackSuccess:0 session:*(void *)(a1 + 40)];
    uint64_t v54 = *(void *)(a1 + 48);
    uint64_t v62 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Failed to receive Create Child SA packet",  v55,  v56,  v57,  v58,  v59,  v60,  v61,  v99);
    -[NEIKEv2ChildSA setState:error:](v54, 3uLL, v62);

    -[NEIKEv2Session reportState](*(void **)(a1 + 40), v63);
    -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 48));
  }
}

LABEL_49:
  unint64_t v41 = v69;
LABEL_50:
  swift_bridgeObjectRelease();
  size_t result = swift_bridgeObjectRelease();
  unint64_t v56 = v41[3];
  if (v56 < 2) {
    return (size_t)v41;
  }
  unint64_t v57 = v56 >> 1;
  BOOL v55 = __OFSUB__(v57, v28);
  unint64_t v58 = v57 - v28;
  if (!v55)
  {
    v41[2] = v58;
    return (size_t)v41;
  }

    goto LABEL_50;
  }

  v99 = a3;
  v122 = 0u;
  v123 = 0u;
  v120 = 0u;
  v121 = 0u;
  [v8 encryptionProtocols];
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v18 = [v17 countByEnumeratingWithState:&v120 objects:v135 count:16];
  if (!v18) {
    goto LABEL_26;
  }
  int64_t v19 = v18;
  BOOL v20 = *(void *)v121;
LABEL_20:
  uint64_t v21 = 0LL;
  while (1)
  {
    if (*(void *)v121 != v20) {
      objc_enumerationMutation(v17);
    }
    uint64_t v22 = *(void *)(*((void *)&v120 + 1) + 8 * v21);
    [(id)a1 encryptionProtocols];
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v24 = [v23 containsObject:v22];

    if (v24) {
      break;
    }
    if (v19 == ++v21)
    {
      int64_t v19 = [v17 countByEnumeratingWithState:&v120 objects:v135 count:16];
      if (!v19)
      {
LABEL_26:

        ne_log_large_obj();
        uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
        {
          [(id)a1 encryptionProtocols];
          uint64_t v26 = (char *)objc_claimAutoreleasedReturnValue();
          [v8 encryptionProtocols];
          uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138412546;
          v132 = v26;
          v133 = 2112;
          v134 = v27;
          uint64_t v28 = "Failed to match encryption algorithms (%@ vs %@)";
          goto LABEL_28;
        }

        goto LABEL_29;
      }

      goto LABEL_20;
    }
  }

  if (v22)
  {
    uint64_t v29 = *(void *)(v22 + 16);
    uint64_t v30 = v29 >= 0x20;
    unint64_t v31 = (0xD01C0000 >> v29) & 1;
    if (v30) {
      unint64_t v32 = 0;
    }
    else {
      unint64_t v32 = v31;
    }
  }

  else
  {
    unint64_t v32 = 0;
  }

  [v8 integrityProtocols];
  unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
  if ([v33 count])
  {
    [(id)a1 integrityProtocols];
    int64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v35 = [v34 count];

    if (v35)
    {
      v118 = 0u;
      v119 = 0u;
      v116 = 0u;
      v117 = 0u;
      [v8 integrityProtocols];
      unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v37 = [v36 countByEnumeratingWithState:&v116 objects:v130 count:16];
      if (!v37) {
        goto LABEL_44;
      }
      uint64_t v38 = v37;
      unint64_t v39 = *(void *)v117;
LABEL_38:
      unint64_t v40 = 0LL;
      while (1)
      {
        if (*(void *)v117 != v39) {
          objc_enumerationMutation(v36);
        }
        unint64_t v41 = *(void *)(*((void *)&v116 + 1) + 8 * v40);
        [(id)a1 integrityProtocols];
        unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
        LOBYTE(v41) = [v42 containsObject:v41];

        if ((v41 & 1) != 0) {
          break;
        }
        if (v38 == ++v40)
        {
          uint64_t v38 = [v36 countByEnumeratingWithState:&v116 objects:v130 count:16];
          if (!v38)
          {
LABEL_44:

            ne_log_large_obj();
            uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
            {
              [(id)a1 integrityProtocols];
              uint64_t v26 = (char *)objc_claimAutoreleasedReturnValue();
              [v8 integrityProtocols];
              uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138412546;
              v132 = v26;
              v133 = 2112;
              v134 = v27;
              uint64_t v28 = "Failed to match integrity algorithms (%@ vs %@)";
LABEL_28:
              _os_log_impl(&dword_1876B1000, v25, OS_LOG_TYPE_INFO, v28, buf, 0x16u);
            }
}

      uint64_t v72 = (void *)objc_msgSend(v21[16], "copy", v147);
      -[NEConfigurationManager setAppGroupMap:]((uint64_t)v24, v72);

      goto LABEL_50;
    }

    ne_log_obj();
    uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl( &dword_1876B1000,  v45,  OS_LOG_TYPE_DEBUG,  "IKE SA already rekeying, skipping (initiate rekey)",  buf,  2u);
    }

    uint64_t v46 = v4;
    int64_t v47 = 1LL;
  }

  else
  {
    ne_log_obj();
    v146 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v167 = "-[NEIKEv2Session(Exchange) initiateRekeyIKESA:]";
      _os_log_fault_impl(&dword_1876B1000, v146, OS_LOG_TYPE_FAULT, "%s called with null oldIKESA", buf, 0xCu);
    }

    uint64_t v46 = v4;
    int64_t v47 = 0LL;
  }

  [v46 sendCallbackSuccess:v47 session:a1];
LABEL_83:
}

        uint64_t v4 = 0LL;
        goto LABEL_57;
      case 8u:
        uint64_t v22 = (const __CFUUID *)CFDictionaryGetValue(a4, @"NetAgentUUID");
        if (!v22) {
          goto LABEL_201;
        }
        uint64_t v23 = (__CFString *)CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x189604DB0], v22);
        uint64_t v24 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDString:v23];

        uint64_t v25 = +[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v24);
        goto LABEL_48;
      case 9u:
        v127 = a2;
        v129 = v7;
        v123 = v8;
        [MEMORY[0x189603FA8] array];
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v27 = (const __CFArray *)CFDictionaryGetValue(a4, @"RouteRules");
        if (v27)
        {
          uint64_t v28 = v27;
          uint64_t v29 = CFArrayGetCount(v27);
          if (v29 >= 1)
          {
            uint64_t v30 = v29;
            unint64_t v31 = 0LL;
            unint64_t v32 = @"Action";
            alloc = (const __CFAllocator *)*MEMORY[0x189604DB0];
            v131 = v28;
            do
            {
              unint64_t v33 = (const __CFDictionary *)CFArrayGetValueAtIndex(v28, v31);
              if (v33)
              {
                int64_t v34 = v33;
                uint64_t v35 = CFDictionaryGetValue(v33, v32);
                unint64_t v36 = NEMapStringToInteger((const void **)&kNEPolicyRouteRuleActionMapping, v35);
                uint64_t v37 = CFDictionaryGetValue(v34, @"Type");
                uint64_t v38 = NEMapStringToInteger((const void **)&kNEPolicyRouteRuleTypeMapping, v37);
                unint64_t v39 = CFDictionaryGetValue(v34, @"Interface");
                if (v36)
                {
                  unint64_t v40 = v39;
                  if (v36 - 5 <= 1
                    && (unint64_t v41 = (const __CFUUID *)CFDictionaryGetValue(a4, @"NetAgentUUID")) != 0LL)
                  {
                    unint64_t v42 = v30;
                    int64_t v43 = v32;
                    uint64_t v44 = v26;
                    uint64_t v45 = (__CFString *)CFUUIDCreateString(alloc, v41);
                    uint64_t v46 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDString:v45];

                    uint64_t v26 = v44;
                    unint64_t v32 = v43;
                    uint64_t v30 = v42;
                    uint64_t v28 = v131;
                  }

                  else
                  {
                    uint64_t v46 = 0LL;
                  }

                  if (v40) {
                    +[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forInterfaceName:",  v36,  v40);
                  }
                  else {
                    +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  v36,  v38);
                  }
                  int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
                  uint64_t v48 = v47;
                  if (v47)
                  {
                    [v47 setNetworkAgentUUID:v46];
                    [v26 addObject:v48];
                  }
                }
              }

              ++v31;
            }

            while (v30 != v31);
          }
        }

        uint64_t v4 = +[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v26);

        uint64_t v8 = v123;
        int64_t v7 = v129;
        a2 = v127;
        goto LABEL_57;
      case 0xBu:
        uint64_t v49 = (const __CFUUID *)CFDictionaryGetValue(a4, @"NetAgentUUID");
        if (!v49) {
          goto LABEL_201;
        }
        uint64_t v50 = (__CFString *)CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x189604DB0], v49);
        uint64_t v24 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDString:v50];

        uint64_t v25 = +[NEPolicyResult scopedNetworkAgent:](&OBJC_CLASS___NEPolicyResult, "scopedNetworkAgent:", v24);
        goto LABEL_48;
      case 0xCu:
        uint64_t v10 = +[NEPolicyResult scopeToDirectInterface](&OBJC_CLASS___NEPolicyResult, "scopeToDirectInterface");
        goto LABEL_56;
      case 0xDu:
        uint64_t v10 = +[NEPolicyResult allowUnentitled](&OBJC_CLASS___NEPolicyResult, "allowUnentitled");
        goto LABEL_56;
      case 0xEu:
        uint64_t v10 = +[NEPolicyResult prohibitFilters](&OBJC_CLASS___NEPolicyResult, "prohibitFilters");
        goto LABEL_56;
      case 0xFu:
        uint64_t v51 = (const __CFUUID *)CFDictionaryGetValue(a4, @"NetAgentUUID");
        if (!v51) {
          goto LABEL_201;
        }
        uint64_t v52 = (__CFString *)CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x189604DB0], v51);
        uint64_t v24 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDString:v52];

        uint64_t v25 = +[NEPolicyResult removeNetworkAgentUUID:](&OBJC_CLASS___NEPolicyResult, "removeNetworkAgentUUID:", v24);
LABEL_48:
        uint64_t v4 = v25;

        goto LABEL_57;
      default:
        goto LABEL_202;
    }
  }

  return v4;
}

          ;
        }

        unint64_t v40 = [v57 countByEnumeratingWithState:&v67 objects:v84 count:16];
        if (v40) {
          continue;
        }
        break;
      }
    }

    uint64_t v53 = 0;
    int64_t v7 = v60;
  }

  else
  {
    uint64_t v53 = 1;
  }

LABEL_62:
  __break(1u);
LABEL_63:
  __break(1u);
  return result;
}

  v130 = 0u;
  v131 = 0u;
  v128 = 0u;
  v129 = 0u;
  [v6 prfProtocols];
  uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
  int64_t v47 = [v46 countByEnumeratingWithState:&v128 objects:v146 count:16];
  if (!v47) {
    goto LABEL_70;
  }
  uint64_t v48 = v47;
  uint64_t v49 = *(void *)v129;
LABEL_64:
  uint64_t v50 = 0LL;
  while (1)
  {
    if (*(void *)v129 != v49) {
      objc_enumerationMutation(v46);
    }
    uint64_t v51 = *(void *)(*((void *)&v128 + 1) + 8 * v50);
    [a1 prfProtocols];
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
    LOBYTE(v51) = [v52 containsObject:v51];

    if ((v51 & 1) != 0) {
      break;
    }
    if (v48 == ++v50)
    {
      uint64_t v48 = [v46 countByEnumeratingWithState:&v128 objects:v146 count:16];
      if (!v48)
      {
LABEL_70:

        ne_log_large_obj();
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          [a1 prfProtocols];
          uint64_t v29 = (char *)objc_claimAutoreleasedReturnValue();
          [v6 prfProtocols];
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138412546;
          v149 = v29;
          v150 = 2112;
          v151 = v30;
          unint64_t v31 = "Failed to match PRF algorithms (%@ vs %@)";
LABEL_72:
          _os_log_impl(&dword_1876B1000, v28, OS_LOG_TYPE_INFO, v31, buf, 0x16u);
        }

  objc_super v81 = +[NSData sensitiveDataWithBytes:length:](MEMORY[0x189603F48], &v65[v72], v108);
  if ((*(_BYTE *)(a1 + 9) & 1) != 0) {
    uint64_t v82 = 144LL;
  }
  else {
    uint64_t v82 = 160LL;
  }
  objc_setProperty_atomic((id)a1, v80, v81, v82);

  if ((*(_BYTE *)(a1 + 9) & 1) != 0) {
    uint64_t v84 = 144LL;
  }
  else {
    uint64_t v84 = 160LL;
  }
  uint64_t v85 = objc_getProperty((id)a1, v83, v84, 1);

  if (!v85)
  {
    ne_log_obj();
    v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v4 = v111;
    uint64_t v60 = v113;
    uint64_t v9 = v109;
    if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67109120;
      v125 = v108;
      _os_log_fault_impl( &dword_1876B1000,  v94,  OS_LOG_TYPE_FAULT,  "[NESensitiveData sensitiveDataWithBytes:length:%u] failed",  buf,  8u);
    }

    uint64_t v61 = 0LL;
    unint64_t v41 = 0LL;
    v92 = 0LL;
    v123 = 0;
    unint64_t v16 = v110;
    goto LABEL_92;
  }

  uint64_t v4 = v111;
  if (!v107) {
    goto LABEL_77;
  }
  v87 = +[NSData sensitiveDataWithBytes:length:](MEMORY[0x189603F48], &v65[v73 + v108], v107);
  unint64_t v88 = (*(_BYTE *)(a1 + 9) & 1) != 0 ? 152LL : 168LL;
  objc_setProperty_atomic((id)a1, v86, v87, v88);

  CFErrorRef v90 = (*(_BYTE *)(a1 + 9) & 1) != 0 ? 152LL : 168LL;
  unint64_t v91 = objc_getProperty((id)a1, v89, v90, 1);

  if (!v91)
  {
    ne_log_obj();
    v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v99, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67109120;
      v125 = v107;
      _os_log_fault_impl( &dword_1876B1000,  v99,  OS_LOG_TYPE_FAULT,  "[NESensitiveData sensitiveDataWithBytes:length:%u] failed",  buf,  8u);
    }

    uint64_t v61 = 0LL;
    unint64_t v41 = 0LL;
    v92 = 0LL;
    v123 = 0;
  }

  else
  {
LABEL_77:
    uint64_t v61 = 0LL;
    unint64_t v41 = 0LL;
    v92 = 0LL;
    v123 = 1;
  }
            v118 = +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]( (uint64_t)&OBJC_CLASS___NEIKEv2CreateChildPacket,  v4,  v102,  0LL);
            if (v118)
            {
              if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v118, 0LL) & 1) != 0)
              {
                if (v102 == 14)
                {
LABEL_68:

                  goto LABEL_69;
                }

                v120 = objc_getProperty(a1, v119, 336LL, 1);
                ErrorFailedToSend = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Failed to process Create Child SA packet (receive rekey)",  v121,  v122,  v123,  v124,  v125,  v126,  v127,  v361);
LABEL_67:
                v136 = ErrorFailedToSend;
                -[NEIKEv2IKESA setState:error:]((uint64_t)v120, 3uLL, ErrorFailedToSend);

                -[NEIKEv2Session reportState](a1, v137);
                -[NEIKEv2Session resetAll]((uint64_t)a1, v138);
                goto LABEL_68;
              }

uint64_t sub_1876BC27C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1BE8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32LL))(a2, a1, v4);
  return a2;
}

uint64_t dispatch thunk of NEAppProxyUDPFlowHandling.handleNewUDPFlow(_:initialRemoteFlowEndpoint:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 8))();
}

uint64_t sub_1876BC2E4(uint64_t a1)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C10);
  MEMORY[0x1895F8858](v3);
  uint64_t v5 = (char *)v16 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = sub_187860810();
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](v6);
  uint64_t v9 = (char *)v16 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int64_t v19 = v1;
  sub_1876BC514();
  id v10 = v1;
  __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C40);
  if (!swift_dynamicCast())
  {
    uint64_t v18 = 0LL;
    memset(v17, 0, sizeof(v17));
    sub_1876BC550((uint64_t)v17);
    return -1LL;
  }

  sub_1876BC590(v17, (uint64_t)v20);
  v16[1] = &unk_18C6FDA20;
  swift_dynamicCastObjCProtocolUnconditional();
  swift_unknownObjectRetain();
  sub_18786081C();
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v7 + 48))(v5, 1LL, v6);
  if ((_DWORD)result != 1)
  {
    (*(void (**)(char *, char *, uint64_t))(v7 + 32))(v9, v5, v6);
    uint64_t v12 = v21;
    uint64_t v13 = v22;
    __swift_project_boxed_opaque_existential_1(v20, v21);
    char v14 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v13 + 8))(a1, v9, v12, v13);
    (*(void (**)(char *, uint64_t))(v7 + 8))(v9, v6);
    uint64_t v15 = v14 & 1;
    __swift_destroy_boxed_opaque_existential_1((uint64_t)v20);
    return v15;
  }

  __break(1u);
  return result;
}

unint64_t sub_1876BC514()
{
  unint64_t result = qword_18C6E1C38;
  if (!qword_18C6E1C38)
  {
    objc_opt_self();
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_18C6E1C38);
  }

  return result;
}

uint64_t sub_1876BC550(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C48);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8LL))(a1, v2);
  return a1;
}

uint64_t sub_1876BC590(__int128 *a1, uint64_t a2)
{
  __int128 v2 = *a1;
  __int128 v3 = a1[1];
  *(void *)(a2 + 32) = *((void *)a1 + 4);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

void *__swift_project_boxed_opaque_existential_1(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80LL) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80LL) + 16LL) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80LL)));
  return result;
}

uint64_t __swift_destroy_boxed_opaque_existential_1(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 24) - 8LL);
  if ((*(_BYTE *)(v1 + 82) & 2) != 0) {
    return swift_release();
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

uint64_t NEAppProxyFlow.open(withLocalFlowEndpoint:completionHandler:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C10);
  MEMORY[0x1895F8858](v8);
  id v10 = (char *)aBlock - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_1876B9C50(a1, (uint64_t)v10, &qword_18C6E1C10);
  uint64_t v11 = sub_187860810();
  uint64_t v12 = *(void *)(v11 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v12 + 48))(v10, 1LL, v11) == 1)
  {
    sub_1876B9C94((uint64_t)v10, &qword_18C6E1C10);
    uint64_t v13 = 0LL;
  }

  else
  {
    uint64_t v13 = sub_187860804();
    (*(void (**)(char *, uint64_t))(v12 + 8))(v10, v11);
  }

  aBlock[4] = a2;
  aBlock[5] = a3;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 1107296256LL;
  aBlock[2] = sub_1876BB88C;
  aBlock[3] = &block_descriptor_1;
  char v14 = _Block_copy(aBlock);
  swift_retain();
  swift_release();
  objc_msgSend(v4, sel_openWithLocalFlowEndpoint_completionHandler_, v13, v14);
  _Block_release(v14);
  return swift_unknownObjectRelease();
}

uint64_t block_copy_helper_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper_1()
{
  return swift_release();
}

uint64_t NEAppProxyFlow.open(withLocalFlowEndpoint:)(uint64_t a1)
{
  *(void *)(v2 + 80) = a1;
  *(void *)(v2 + 88) = v1;
  return swift_task_switch();
}

uint64_t sub_1876BC788()
{
  uint64_t v1 = v0[10];
  v0[2] = v0;
  v0[3] = sub_1876BB984;
  uint64_t v2 = swift_continuation_init();
  uint64_t v3 = swift_allocObject();
  *(void *)(v3 + 16) = v2;
  NEAppProxyFlow.open(withLocalFlowEndpoint:completionHandler:)(v1, (uint64_t)sub_1876BBA60, v3);
  swift_release();
  return swift_continuation_await();
}

uint64_t sub_1876BC814()
{
  return swift_deallocObject();
}

uint64_t NEAppProxyFlow.setMetadata(on:)()
{
  return swift_unknownObjectRelease();
}

uint64_t NEAppProxyFlow.interface.getter@<X0>(uint64_t a1@<X8>)
{
  if (objc_msgSend(v1, sel_networkInterface))
  {
    swift_unknownObjectRetain();
    sub_187860840();
    uint64_t v3 = sub_187860834();
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v3 - 8) + 56LL))(a1, 0LL, 1LL, v3);
    return swift_unknownObjectRelease();
  }

  else
  {
    uint64_t v5 = sub_187860834();
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 56LL))( a1,  1LL,  1LL,  v5);
  }

uint64_t sub_1876BC8FC@<X0>(id *a1@<X0>, uint64_t a2@<X8>)
{
  if (objc_msgSend(*a1, sel_networkInterface))
  {
    swift_unknownObjectRetain();
    sub_187860840();
    uint64_t v3 = sub_187860834();
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v3 - 8) + 56LL))(a2, 0LL, 1LL, v3);
    return swift_unknownObjectRelease();
  }

  else
  {
    uint64_t v5 = sub_187860834();
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 56LL))( a2,  1LL,  1LL,  v5);
  }

uint64_t sub_1876BC994(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C58);
  MEMORY[0x1895F8858](v2);
  uint64_t v4 = (char *)&v6 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_1876B9C50(a1, (uint64_t)v4, &qword_18C6E1C58);
  return NEAppProxyFlow.interface.setter((uint64_t)v4);
}

uint64_t NEAppProxyFlow.interface.setter(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C58);
  MEMORY[0x1895F8858](v4);
  uint64_t v6 = (char *)&v12 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = sub_187860834();
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v7);
  id v10 = (char *)&v12 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_1876B9C50(a1, (uint64_t)v6, &qword_18C6E1C58);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v6, 1LL, v7) == 1)
  {
    sub_1876B9C94((uint64_t)v6, &qword_18C6E1C58);
    objc_msgSend(v2, sel_setNetworkInterface_, 0);
    return sub_1876B9C94(a1, &qword_18C6E1C58);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v10, v6, v7);
    uint64_t result = sub_187860828();
    if (result)
    {
      objc_msgSend(v2, sel_setNetworkInterface_, result);
      swift_unknownObjectRelease();
      sub_1876B9C94(a1, &qword_18C6E1C58);
      return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v10, v7);
    }

    else
    {
      __break(1u);
    }
  }

  return result;
}

void (*NEAppProxyFlow.interface.modify(void *a1))(uint64_t a1, char a2)
{
  *a1 = v1;
  size_t v3 = *(void *)(*(void *)(__swift_instantiateConcreteTypeFromMangledName(&qword_18C6E1C58) - 8) + 64LL);
  a1[1] = malloc(v3);
  uint64_t v4 = malloc(v3);
  a1[2] = v4;
  if (objc_msgSend(v1, sel_networkInterface))
  {
    swift_unknownObjectRetain();
    sub_187860840();
    uint64_t v5 = sub_187860834();
    (*(void (**)(void *, void, uint64_t, uint64_t))(*(void *)(v5 - 8) + 56LL))(v4, 0LL, 1LL, v5);
    swift_unknownObjectRelease();
  }

  else
  {
    uint64_t v6 = sub_187860834();
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 56LL))(v4, 1LL, 1LL, v6);
  }

  return sub_1876BCC6C;
}

void sub_1876BCC6C(uint64_t a1, char a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  size_t v3 = *(void **)(a1 + 16);
  if ((a2 & 1) != 0)
  {
    sub_1876B9C50(*(void *)(a1 + 16), (uint64_t)v2, &qword_18C6E1C58);
    NEAppProxyFlow.interface.setter((uint64_t)v2);
    sub_1876B9C94((uint64_t)v3, &qword_18C6E1C58);
  }

  else
  {
    NEAppProxyFlow.interface.setter(*(void *)(a1 + 16));
  }

  free(v3);
  free(v2);
}

uint64_t NEPacketTunnelProvider.virtualInterface.getter@<X0>(uint64_t a1@<X8>)
{
  if (objc_msgSend(v1, sel_virtualInterface))
  {
    swift_unknownObjectRetain();
    sub_187860840();
    uint64_t v3 = sub_187860834();
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v3 - 8) + 56LL))(a1, 0LL, 1LL, v3);
    return swift_unknownObjectRelease();
  }

  else
  {
    uint64_t v5 = sub_187860834();
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 56LL))( a1,  1LL,  1LL,  v5);
  }

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0LL);
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3LL;
  }
  uint64_t v4 = *(_BYTE **)result;
  if (*(void *)result == -1LL) {
    goto LABEL_68;
  }
  uint64_t v5 = &v4[v3];
  uint64_t v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    uint64_t v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1LL)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_69;
      }
      char v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15) {
            unint64_t v17 = *v12;
          }
          else {
            unint64_t v17 = v7 - 1;
          }
          BOOL v10 = v5 >= v14;
          unint64_t v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3) {
              return 0LL;
            }
LABEL_34:
            uint64_t result = 0LL;
            *a3 = v15;
            return result;
          }

LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }

        return 3LL;
      }

      unint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3LL;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3LL;
      }
      if (v14 >= v5 || v14 < v4) {
        goto LABEL_69;
      }
      if (!*v14) {
        return 3LL;
      }
      unint64_t v15 = 0LL;
      uint64_t v21 = (v19 - 1);
      unint64_t v22 = v7 - v21 - 2;
      unint64_t v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (_BYTE *)-1LL)
      {
        if (v14 >= v5) {
          goto LABEL_69;
        }
        BOOL v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_70;
        }
        unsigned int v24 = *v14++;
        unint64_t v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!(_DWORD)v19)
        {
          if (a3) {
            BOOL v25 = 0;
          }
          else {
            BOOL v25 = v15 > v22;
          }
          char v26 = v25;
          uint64_t result = 3LL;
          if (v15 < 0x80 || (v26 & 1) != 0) {
            return result;
          }
          if (v15 >= v22) {
            unint64_t v27 = v22;
          }
          else {
            unint64_t v27 = v15;
          }
          BOOL v10 = (unint64_t)v5 >= v23;
          uint64_t v28 = &v5[-v23];
          a2[1] = v23;
          a2[2] = v27;
          if (a3) {
            goto LABEL_34;
          }
          return 0LL;
        }
      }
    }

          [v26 interfaceProtocolMapping];
          uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue();
          [v48 objectForKeyedSubscript:@"AlwaysOnVPNInterfaceWiFi"];
          self = (NEConfiguration *)objc_claimAutoreleasedReturnValue();

          if (!self)
          {
            ne_log_obj();
            uint64_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v50, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl( &dword_1876B1000,  v50,  OS_LOG_TYPE_INFO,  "NEConfiguration setCertificatesAOVpn: no WiFi tunnel config",  buf,  2u);
            }

            goto LABEL_83;
          }

          if (-[NEConfiguration authenticationMethod](self, "authenticationMethod") != 1)
          {
LABEL_83:
            buf[0] = 1;

            LOBYTE(self) = buf[0];
            goto LABEL_84;
          }

          [v12 objectForKeyedSubscript:@"_PayloadCertificateRefForWifi"];
          uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();

          if (isa_nsdata(v49))
          {
            -[NEConfiguration setIdentityReferenceInternal:](self, "setIdentityReferenceInternal:", v49);
LABEL_82:
            unint64_t v42 = v49;
            goto LABEL_83;
          }

          if ((-[NEConfiguration useExtendedAuthentication](self, "useExtendedAuthentication") & 1) != 0) {
            goto LABEL_82;
          }
          ne_log_obj();
          BOOL v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
          {
            unint64_t v57 = "invalid";
            if (!v49) {
              unint64_t v57 = "missing";
            }
            *(_DWORD *)buf = 136315138;
            uint64_t v65 = v57;
            _os_log_error_impl( &dword_1876B1000,  v55,  OS_LOG_TYPE_ERROR,  "NEConfiguration setCertificatesAOVpn: tunnel cert %s for WiFi tunnel",  buf,  0xCu);
          }

LABEL_58:
          LOBYTE(self) = 0;
LABEL_84:

          goto LABEL_85;
        }
      }

      else
      {
        ne_log_obj();
        int64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( &dword_1876B1000,  v47,  OS_LOG_TYPE_INFO,  "NEConfiguration setCertificatesAOVpn: no cellular tunnel configs",  buf,  2u);
        }
      }

      unint64_t v42 = 0LL;
      goto LABEL_69;
    }

    -[NEConfiguration contentFilter](self, "contentFilter");
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();

    if (v44)
    {
      [v8 objectForKeyedSubscript:@"_PayloadCertificateRef"];
      uint64_t v12 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v45 = -[NEConfiguration setCertificateContentFilter:](self, v12);
LABEL_64:
      LOBYTE(self) = v45;
      goto LABEL_85;
    }

    -[NEConfiguration dnsSettings](self, "dnsSettings");
    uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();

    if (v46)
    {
      [v8 objectForKeyedSubscript:@"_PayloadCertificateRef"];
      uint64_t v12 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v45 = -[NEConfiguration setCertificateDNSSettings:](self, v12);
      goto LABEL_64;
    }

    -[NEConfiguration relay](self, "relay");
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();

    if (v51)
    {
      LOBYTE(self) = -[NEConfiguration setCertificatesRelay:keyRefs:specs:](self, v8, v9, v10);
      goto LABEL_86;
    }
  }

  else
  {
    ne_log_obj();
    unsigned int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v65 = (const char *)v8;
      _os_log_debug_impl( &dword_1876B1000,  v24,  OS_LOG_TYPE_DEBUG,  "NEConfiguration setCertificates: malformed certificate references %@",  buf,  0xCu);
    }
  }

  LOBYTE(self) = 0;
LABEL_86:

  return (char)self;
}

                  goto LABEL_23;
                }

                if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl( &dword_1876B1000,  v40,  OS_LOG_TYPE_DEFAULT,  "Wrong PPK ID received, falling back to non-PPK AUTH data",  buf,  2u);
                }

                uint64_t v44 = (os_log_s *)*(id *)(v6 + 384);
                char v14 = 0;
                unint64_t v8 = v44;
LABEL_74:

                goto LABEL_13;
              }
            }

            else
            {
            }

            unint64_t v40 = (os_log_s *)+[NEIKEv2IKESA copyPPKFromConfig:]((uint64_t)&OBJC_CLASS___NEIKEv2IKESA, v3);
            if (v40)
            {
              if ((-[NEIKEv2IKESA generateDerivativesFromPPK:](v6, v40) & 1) != 0)
              {

                char v14 = 1;
                goto LABEL_74;
              }

              ne_log_obj();
              uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
              {
                BOOL v55 = *(const char **)(a1 + 32);
                *(_DWORD *)buf = 138412290;
                unint64_t v58 = v55;
                _os_log_error_impl( &dword_1876B1000,  v54,  OS_LOG_TYPE_ERROR,  "%@ Failed to generate PPK-derived keys",  buf,  0xCu);
              }
            }

            else
            {
              ne_log_obj();
              uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_fault_impl( &dword_1876B1000,  v54,  OS_LOG_TYPE_FAULT,  "PPK use negotiated but PPK not present in configuration",  buf,  2u);
              }
            }

            goto LABEL_69;
          }

          ne_log_obj();
          unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            uint64_t v50 = *(const char **)(v6 + 416);
            *(_DWORD *)buf = 134218240;
            unint64_t v58 = v50;
            uint64_t v59 = 2048;
            uint64_t v60 = v27;
            _os_log_error_impl( &dword_1876B1000,  v31,  OS_LOG_TYPE_ERROR,  "PPK Type %zu != Expected Type %zu",  buf,  0x16u);
          }

          goto LABEL_46;
        }

        ne_log_obj();
        unint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136315138;
        unint64_t v58 = "-[NEIKEv2IKESA(Crypto) copyValidateAuthBlock]_block_invoke";
        uint64_t v49 = "%s called with null authCheckConfig.ppkID";
      }

      else
      {
        ne_log_obj();
        unint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136315138;
        unint64_t v58 = "-[NEIKEv2IKESA(Crypto) copyValidateAuthBlock]_block_invoke";
        uint64_t v49 = "%s called with null packetAuthentication";
      }

      _os_log_fault_impl(&dword_1876B1000, v16, OS_LOG_TYPE_FAULT, v49, buf, 0xCu);
      goto LABEL_23;
    }
  }

  else
  {
    uint64_t v6 = ne_log_obj();
    if (os_log_type_enabled((os_log_t)v6, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      unint64_t v58 = "-[NEIKEv2IKESA(Crypto) copyValidateAuthBlock]_block_invoke";
      _os_log_fault_impl( &dword_1876B1000,  (os_log_t)v6,  OS_LOG_TYPE_FAULT,  "%s called with null authCheckConfig.remoteAuthentication",  buf,  0xCu);
    }
  }

  unint64_t v11 = 0LL;
LABEL_64:

  return v11;
}
}

    _os_log_fault_impl(&dword_1876B1000, v29, OS_LOG_TYPE_FAULT, v30, (uint8_t *)&buf, 0xCu);
    goto LABEL_24;
  }

LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }

  unsigned int v9 = *v6;
  BOOL v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3LL;
  }
  unint64_t v8 = 0LL;
  uint64_t result = 3LL;
  while (v7 >= 2)
  {
    unint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_69;
    }
    uint64_t v12 = (char *)(v6 + 1);
    --v7;
    unsigned __int8 v13 = *v6;
    unint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3LL;
      }
      goto LABEL_20;
    }
  }

  return result;
}

        a3 = v40;
        a4 = v119;
      }
    }

    if (!objc_getProperty(v9, v62, 104LL, 1))
    {
      ne_log_obj();
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        unint64_t v22 = "No chosen integrity protocol";
        goto LABEL_167;
      }

      ++v48;
    }

    while (v46 != v48);
    uint64_t v61 = [v43 countByEnumeratingWithState:&v429 objects:&v441 count:16];
    uint64_t v46 = v61;
  }

  while (v61);
LABEL_73:

  unint64_t v3 = self;
  if (![v41 count]) {
    goto LABEL_109;
  }
  uint64_t v63 = v41;
  if (!v63)
  {
    ne_log_obj();
    uint64_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_FAULT)) {
      goto LABEL_108;
    }
    LODWORD(block) = 136315138;
    *(void *)((char *)&block + 4) = "-[NEIKEv2Session reportServerAdditionalAddresses:]";
    v286 = "%s called with null additionalAddresses";
LABEL_242:
    _os_log_fault_impl(&dword_1876B1000, v64, OS_LOG_TYPE_FAULT, v286, (uint8_t *)&block, 0xCu);
    goto LABEL_108;
  }

  if (!objc_getProperty(v39, v62, 336LL, 1))
  {
    ne_log_obj();
    uint64_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_FAULT)) {
      goto LABEL_108;
    }
    LODWORD(block) = 136315138;
    *(void *)((char *)&block + 4) = "-[NEIKEv2Session reportServerAdditionalAddresses:]";
    v286 = "%s called with null self.ikeSA";
    goto LABEL_242;
  }

  [v39 additionalAddressesUpdateBlock];
  uint64_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  [v39 clientQueue];
  uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue();

  if (v65 && v64)
  {
    [v39 clientQueue];
    uint64_t v66 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
    *(void *)&block = MEMORY[0x1895F87A8];
    *((void *)&block + 1) = 3221225472LL;
    *(void *)&v438 = __50__NEIKEv2Session_reportServerAdditionalAddresses___block_invoke;
    *((void *)&v438 + 1) = &unk_18A08FB50;
    *(void *)&v439 = v39;
    uint64_t v64 = v64;
    *(void *)&v440 = v64;
    *((void *)&v439 + 1) = v63;
    dispatch_async(v66, &block);
  }

LABEL_36:
        ++v7;
      }

      while (v5 != v7);
      char v26 = -[NEIKEv2IKEAuthPacket countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v27,  v36,  16LL);
      uint64_t v5 = v26;
    }

    while (v26);
  }
}

uint64_t DERDecodeItemPartialBuffer(uint64_t result, unint64_t *a2, int a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3LL;
  }
  uint64_t v4 = *(_BYTE **)result;
  if (*(void *)result == -1LL) {
    goto LABEL_54;
  }
  uint64_t v5 = &v4[v3];
  uint64_t v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    uint64_t v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1LL)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_55;
      }
      char v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        BOOL v17 = v16 < v15 && a3 == 0;
        unint64_t v18 = (unint64_t)(v12 + 1);
        if (v17) {
          return 3LL;
        }
LABEL_28:
        if (v15 > (~v18 & 0x7FFFFFFFFFFFFFFFLL)) {
          return 7LL;
        }
        if (v18 <= v18 + v15)
        {
          uint64_t result = 0LL;
          a2[1] = v18;
          a2[2] = v15;
          return result;
        }

        goto LABEL_55;
      }

      unint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3LL;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3LL;
      }
      if (v14 >= v5 || v14 < v4)
      {
LABEL_55:
        __break(0x5519u);
LABEL_56:
        __break(0x5515u);
        return result;
      }

      if (!*v14) {
        return 3LL;
      }
      unint64_t v15 = 0LL;
      uint64_t v21 = (v19 - 1);
      unint64_t v22 = v7 - v21 - 2;
      unint64_t v18 = (unint64_t)&v12[v21 + 2];
      while (v14 != (_BYTE *)-1LL)
      {
        if (v14 >= v5) {
          goto LABEL_55;
        }
        BOOL v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_56;
        }
        unsigned int v23 = *v14++;
        unint64_t v15 = (v15 << 8) | v23;
        LODWORD(v19) = v19 - 1;
        if (!(_DWORD)v19)
        {
          if (v15 <= v22) {
            char v24 = 1;
          }
          else {
            char v24 = a3;
          }
          uint64_t result = 3LL;
          if (v15 >= 0x80 && (v24 & 1) != 0) {
            goto LABEL_28;
          }
          return result;
        }
      }
    }

LABEL_54:
    __break(0x5513u);
    goto LABEL_55;
  }

  unsigned int v9 = *v6;
  BOOL v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3LL;
  }
  unint64_t v8 = 0LL;
  uint64_t result = 3LL;
  while (v7 >= 2)
  {
    unint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_55;
    }
    uint64_t v12 = (char *)(v6 + 1);
    --v7;
    unsigned __int8 v13 = *v6;
    unint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3LL;
      }
      goto LABEL_20;
    }
  }

  return result;
}

          uint64_t v50 = v77;
          uint64_t v51 = [v77 count];
          unint64_t v11 = v72;
          BOOL v10 = v75;
          if (v51 != [v39 count])
          {
            uint64_t v53 = v27;
            if (!v74 || (uint64_t v53 = v36) != 0LL) {
              [v53 setAppRules:v77];
            }
            uint64_t v54 = *(void *)(a1 + 32);
            if (v54) {
              BOOL v55 = objc_getProperty(*(id *)(a1 + 32), v52, 80LL, 1);
            }
            else {
              BOOL v55 = 0LL;
            }
            unint64_t v56 = v55;
            [v13 identifier];
            unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
            [v56 objectForKeyedSubscript:v57];
            unint64_t v58 = (void *)objc_claimAutoreleasedReturnValue();

            -[NEConfigurationManager saveConfigurationToDisk:updateSCPreferences:currentSignature:userUUID:notifyNow:isUpgrade:]( v54,  v13,  prefs,  v58,  0LL,  1,  0);
            uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();

            BOOL v10 = v75;
            if (v59)
            {
              ne_log_obj();
              uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
              {
                [v13 name];
                uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136315650;
                uint64_t v85 = "-[NEConfigurationManager handleApplicationsRemoved:completionQueue:withCompletionHandler:]_block_invoke";
                v86 = 2112;
                v87 = v62;
                unint64_t v88 = 2112;
                v89 = v59;
                _os_log_error_impl(&dword_1876B1000, v60, OS_LOG_TYPE_ERROR, "%s: failed to save %@: %@", buf, 0x20u);
              }
            }

            a1 = v79;
            uint64_t v50 = v77;
          }
        }
      }

        uint64_t v85 = v83;
        v86 = 12;
        goto LABEL_55;
      }

      ne_log_obj();
      v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
        goto LABEL_56;
      }
      LOWORD(v90) = 0;
      uint64_t v84 = "[packet addNotification:NEIKEv2NotifyTypeUseTransportMode] failed";
    }

    else
    {
      ne_log_obj();
      v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
        goto LABEL_56;
      }
      LOWORD(v90) = 0;
      uint64_t v84 = "[packet addNotification:NEIKEv2NotifyTypeRekeySA] failed";
    }

    uint64_t v85 = v83;
    v86 = 2;
LABEL_55:
    _os_log_fault_impl(&dword_1876B1000, v85, OS_LOG_TYPE_FAULT, v84, (uint8_t *)&v90, v86);
    goto LABEL_56;
  }

  ne_log_obj();
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
  {
    CFErrorRef v90 = 136315138;
    unint64_t v91 = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyRequestChildSA:]";
    v87 = "%s called with null childSA.rekeyRequestProposals";
LABEL_49:
    _os_log_fault_impl(&dword_1876B1000, v6, OS_LOG_TYPE_FAULT, v87, (uint8_t *)&v90, 0xCu);
  }

    if (v5)
    {
      int64_t v43 = objc_getProperty((id)v5, v21, 80LL, 1);
      if (v43)
      {

LABEL_58:
        objc_msgSend((id)v5, "filloutPayloads", v53);
LABEL_59:
        uint64_t v2 = v54;
        goto LABEL_11;
      }

      if (objc_getProperty((id)v5, v44, 48LL, 1)) {
        goto LABEL_58;
      }
    }

    ne_log_obj();
    uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      uint64_t v48 = "Cannot parse packet, no acceptable payloads found";
      uint64_t v49 = v45;
      uint64_t v50 = 2;
LABEL_72:
      _os_log_error_impl(&dword_1876B1000, v49, OS_LOG_TYPE_ERROR, v48, buf, v50);
    }

        uint64_t v53 = CFDictionaryGetValue(a4, @"TunnelInterface");
        if (v53)
        {
          BOOL v10 = +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v53,  v20);
LABEL_56:
          uint64_t v4 = v10;
LABEL_57:
          if (v4)
          {
            alloca = (CFAllocatorRef)v4;
            v128 = a2;
            v130 = v7;
            uint64_t v54 = a3;
            Count = CFArrayGetCount(a3);
            if (Count >= 1)
            {
              unint64_t v56 = Count;
              unint64_t v57 = 0LL;
              v132 = (const __CFAllocator *)*MEMORY[0x189604DB0];
              v124 = v8;
              do
              {
                ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v54, v57);
                if (ValueAtIndex)
                {
                  uint64_t v59 = ValueAtIndex;
                  uint64_t v60 = CFDictionaryGetValue(ValueAtIndex, @"ConditionType");
                  uint64_t v61 = NEMapStringToInteger((const void **)&kNEPolicyConditionsMapping, v60);
                  uint64_t v62 = 0LL;
                  switch(v61)
                  {
                    case 1u:
                      unint64_t v75 = (const __CFUUID *)CFDictionaryGetValue(v59, @"ApplicationUUID");
                      if (v75)
                      {
                        uint64_t v76 = (__CFString *)CFUUIDCreateString(v132, v75);
                        unint64_t v77 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDString:v76];

                        unint64_t v78 = +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v77);
                        goto LABEL_78;
                      }

                      break;
                    case 2u:
                      uint64_t v79 = (const __CFUUID *)CFDictionaryGetValue(v59, @"RealApplicationUUID");
                      if (v79)
                      {
                        uint64_t v80 = (__CFString *)CFUUIDCreateString(v132, v79);
                        unint64_t v77 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDString:v80];

                        unint64_t v78 = +[NEPolicyCondition realApplication:](&OBJC_CLASS___NEPolicyCondition, "realApplication:", v77);
LABEL_78:
                        uint64_t v62 = (void *)v78;

                        if (v62) {
                          goto LABEL_192;
                        }
                      }

                      break;
                    case 3u:
                      HIDWORD(valuePtr) = 0;
                      objc_super v81 = (const __CFNumber *)CFDictionaryGetValue(v59, @"PID");
                      uint64_t v82 = +[NEPolicyCondition effectivePID:]( &OBJC_CLASS___NEPolicyCondition,  "effectivePID:",  HIDWORD(valuePtr));
                      goto LABEL_191;
                    case 4u:
                      HIDWORD(valuePtr) = 0;
                      v83 = (const __CFNumber *)CFDictionaryGetValue(v59, @"UID");
                      uint64_t v82 = +[NEPolicyCondition uid:](&OBJC_CLASS___NEPolicyCondition, "uid:", HIDWORD(valuePtr));
                      goto LABEL_191;
                    case 5u:
                      uint64_t v84 = CFDictionaryGetValue(v59, @"AccountID");
                      if (!v84) {
                        break;
                      }
                      uint64_t v82 = +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  v84);
                      goto LABEL_191;
                    case 6u:
                      uint64_t v85 = CFDictionaryGetValue(v59, @"Domain");
                      if (!v85) {
                        break;
                      }
                      uint64_t v82 = +[NEPolicyCondition domain:](&OBJC_CLASS___NEPolicyCondition, "domain:", v85);
                      goto LABEL_191;
                    case 7u:
                      uint64_t v82 = +[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces");
                      goto LABEL_191;
                    case 8u:
                      v86 = CFDictionaryGetValue(v59, @"InterfaceName");
                      if (!v86) {
                        break;
                      }
                      uint64_t v82 = +[NEPolicyCondition scopedInterface:](&OBJC_CLASS___NEPolicyCondition, "scopedInterface:", v86);
                      goto LABEL_191;
                    case 9u:
                      v87 = NEGetIntFromDictionary(v59, @"StartTrafficClass", 0LL);
                      unint64_t v88 = NEGetIntFromDictionary(v59, @"EndTrafficClass", 0LL);
                      if (CFDictionaryContainsKey(v59, @"StartTrafficClass")
                        && CFDictionaryContainsKey(v59, @"EndTrafficClass"))
                      {
                        +[NEPolicyCondition trafficClassStart:end:]( &OBJC_CLASS___NEPolicyCondition,  "trafficClassStart:end:",  v87,  v88);
                        uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue();
                      }

                      else
                      {
                        uint64_t v62 = 0LL;
                      }

                      goto LABEL_161;
                    case 0xAu:
                    case 0x13u:
LABEL_161:
                      v112 = NEGetIntFromDictionary(v59, @"ProtocolIndex", 0LL);
                      if (!v112) {
                        goto LABEL_181;
                      }
                      if (v61 == 10) {
                        +[NEPolicyCondition ipProtocol:]( &OBJC_CLASS___NEPolicyCondition,  "ipProtocol:",  (unsigned __int16)v112);
                      }
                      else {
                      v113 = +[NEPolicyCondition flowIPProtocol:]( &OBJC_CLASS___NEPolicyCondition,  "flowIPProtocol:",  (unsigned __int16)v112);
                      }

                      uint64_t v62 = (void *)v113;
                      if (!v113) {
                        break;
                      }
                      goto LABEL_192;
                    case 0xBu:
                    case 0xDu:
                    case 0x14u:
                    case 0x16u:
                      uint64_t v63 = CFDictionaryGetValue(v59, @"Address");
                      uint64_t v64 = CFDictionaryGetValue(v59, @"Port");
                      uint64_t v65 = (const __CFNumber *)CFDictionaryGetValue(v59, @"SubnetPrefix");
                      if (!v63) {
                        break;
                      }
                      if (v65)
                      {
                        HIDWORD(valuePtr) = 0;
                        else {
                          uint64_t v66 = -1;
                        }
                        if (v64)
                        {
LABEL_68:
                          uint64_t v67 = CFStringCreateWithFormat(v132, 0LL, @"%@", v64);
                          goto LABEL_131;
                        }
                      }

                      else
                      {
                        uint64_t v66 = -1;
                        if (v64) {
                          goto LABEL_68;
                        }
                      }

                      uint64_t v67 = @"0";
LABEL_131:
                      [MEMORY[0x189608DE8] endpointWithHostname:v63 port:v67];
                      v104 = (void *)objc_claimAutoreleasedReturnValue();
                      uint64_t v62 = 0LL;
                      if (v61 > 0x13u)
                      {
                        if (v61 == 20)
                        {
                          v105 = +[NEPolicyCondition flowLocalAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowLocalAddress:prefix:",  v104,  v66);
                        }

                        else
                        {
                          if (v61 != 22) {
                            goto LABEL_170;
                          }
                          v105 = +[NEPolicyCondition flowRemoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddress:prefix:",  v104,  v66);
                        }
                      }

                      else if (v61 == 11)
                      {
                        v105 = +[NEPolicyCondition localAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "localAddress:prefix:",  v104,  v66);
                      }

                      else
                      {
                        if (v61 != 13) {
                          goto LABEL_170;
                        }
                        v105 = +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v104,  v66);
                      }

                      uint64_t v62 = (void *)v105;
LABEL_170:
                      if (v67) {
                        CFRelease(v67);
                      }

                      if (!v62) {
                        break;
                      }
                      goto LABEL_192;
                    case 0xCu:
                    case 0xEu:
                    case 0x15u:
                    case 0x17u:
                      uint64_t v68 = CFDictionaryGetValue(v59, @"StartAddress");
                      uint64_t v69 = CFDictionaryGetValue(v59, @"StartPort");
                      size_t v70 = CFDictionaryGetValue(v59, @"EndAddress");
                      unint64_t v71 = CFDictionaryGetValue(v59, @"EndPort");
                      if (!v68 || !v70) {
                        break;
                      }
                      uint64_t v72 = v71;
                      if (v69)
                      {
                        unint64_t v73 = CFStringCreateWithFormat(v132, 0LL, @"%@", v69);
                        if (v72) {
                          goto LABEL_73;
                        }
                      }

                      else
                      {
                        unint64_t v73 = @"0";
                        if (v71)
                        {
LABEL_73:
                          uint64_t v74 = CFStringCreateWithFormat(v132, 0LL, @"%@", v72);
                          goto LABEL_140;
                        }
                      }

                      uint64_t v74 = @"0";
LABEL_140:
                      [MEMORY[0x189608DE8] endpointWithHostname:v68 port:v73];
                      v106 = (void *)objc_claimAutoreleasedReturnValue();
                      [MEMORY[0x189608DE8] endpointWithHostname:v70 port:v74];
                      v107 = (void *)objc_claimAutoreleasedReturnValue();
                      uint64_t v62 = 0LL;
                      if (v61 > 0x14u)
                      {
                        if (v61 != 21)
                        {
                          uint64_t v54 = a3;
                          if (v61 == 23)
                          {
                            v108 = +[NEPolicyCondition flowRemoteAddressStart:end:]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddressStart:end:",  v106,  v107);
LABEL_147:
                            uint64_t v62 = (void *)v108;
                          }

        uint64_t v35 = 0LL;
        goto LABEL_62;
      }

      if ([v30 isEqualToString:@"IKEv2"])
      {
        [v20 objectForKeyedSubscript:@"IKEv2"];
        unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();

        if (!v31) {
          goto LABEL_54;
        }
        [v31 objectForKeyedSubscript:@"ExtendedAuthEnabled"];
        uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v35) {
          goto LABEL_62;
        }
        [v31 objectForKeyedSubscript:@"LocalCertificate"];
        unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
        if (v36
          || ([v31 objectForKeyedSubscript:@"PayloadCertificateUUID"],
              (unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue()) != 0LL)
          || ([v31 objectForKeyedSubscript:@"PayloadCertificateFileName"],
              (unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue()) != 0LL)
          || ([v31 objectForKeyedSubscript:@"PayloadCertificateIdentityUUID"],
              (unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue()) != 0LL))
        {

          goto LABEL_54;
        }

        [v31 objectForKeyedSubscript:@"ExtensibleSSOProvider"];
        v96 = (void *)objc_claimAutoreleasedReturnValue();

        if (v96) {
          goto LABEL_54;
        }
        v97 = [v31 objectForKeyedSubscript:@"AuthName"];
        v98 = v6->_userName;
        v6->_userName = (NSString *)v97;

        [v31 objectForKeyedSubscript:@"AuthPassword"];
        uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
        v6->_userNameRequired = 1;
      }

      else
      {
        if ([v30 isEqualToString:@"VPN"])
        {
          uint64_t v35 = 0LL;
          unint64_t v31 = v26;
          goto LABEL_62;
        }

        [v20 objectForKeyedSubscript:@"PPP"];
        unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();

        v6->_userNameRequired = 1;
        if (!v31) {
          goto LABEL_54;
        }
        uint64_t v37 = [v31 objectForKeyedSubscript:@"AuthName"];
        uint64_t v38 = v6->_userName;
        v6->_userName = (NSString *)v37;

        if (v25)
        {
          if (v29) {
            goto LABEL_54;
          }
        }

        [v31 objectForKeyedSubscript:@"AuthPassword"];
        uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
      }

      v6->_passwordRequired = 1;
LABEL_62:
      else {
        uint64_t v45 = v35;
      }
      password = v6->_password;
      v6->_password = v45;

      int64_t v47 = v20;
      ne_log_large_obj();
      uint64_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v60 = (void *)objc_opt_class();
        *(_DWORD *)buf = 138412546;
        v108 = v60;
        v109 = 2112;
        v110 = v47;
        uint64_t v61 = v60;
        _os_log_debug_impl( &dword_1876B1000,  v48,  OS_LOG_TYPE_DEBUG,  "%@ extractPayloadContentsSharedSecret: dict %@",  buf,  0x16u);
      }

      [v47 objectForKeyedSubscript:@"VPNType"];
      uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v50 = v49;
      if (!v49)
      {
LABEL_127:

        uint64_t v85 = v47;
        [v85 objectForKeyedSubscript:@"VPNType"];
        v86 = (void *)objc_claimAutoreleasedReturnValue();
        if ([v86 isEqualToString:@"IPSec"])
        {
          [v85 objectForKeyedSubscript:@"IPSec"];
          v87 = (void *)objc_claimAutoreleasedReturnValue();
          unint64_t v88 = v87;
          if (v87)
          {
            [v87 objectForKeyedSubscript:@"PromptForVPNPIN"];
            v89 = (void *)objc_claimAutoreleasedReturnValue();
            if (v89)
            {
              objc_opt_class();
            }

            goto LABEL_135;
          }
        }

        else
        {
          unint64_t v88 = 0LL;
        }

        v89 = 0LL;
LABEL_135:

        goto LABEL_136;
      }

      if (([v49 isEqualToString:@"IPSec"] & 1) != 0
        || ([v50 isEqualToString:@"L2TP"] & 1) != 0)
      {
        uint64_t v51 = kNEIPSecKey;
      }

      else
      {
        uint64_t v51 = kNEIKEv2Key;
      }

      [v47 objectForKeyedSubscript:*v51];
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v52) {
        goto LABEL_127;
      }
      uint64_t v53 = v52;
      [v52 objectForKeyedSubscript:@"AuthenticationMethod"];
      uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();
      BOOL v55 = v54;
      if (!v54 || ([v54 isEqualToString:@"Certificate"] & 1) == 0)
      {
        [v53 objectForKeyedSubscript:@"PayloadCertificateUUID"];
        unint64_t v56 = (id)objc_claimAutoreleasedReturnValue();
        if (!v56)
        {
          [v53 objectForKeyedSubscript:@"PayloadCertificateIdentityUUID"];
          char v26 = (void *)objc_claimAutoreleasedReturnValue();
          if (!v26) {
            goto LABEL_88;
          }
        }

        [v53 objectForKeyedSubscript:@"ExtendedAuthEnabled"];
        unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
        if (!isa_nsnumber(v57))
        {

          if (!v56) {
            unint64_t v56 = v26;
          }
          goto LABEL_125;
        }

        v104 = v55;
        [v53 objectForKeyedSubscript:@"ExtendedAuthEnabled"];
        unint64_t v58 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v59 = [v58 BOOLValue];

        if (v56)
        {

          BOOL v55 = v104;
          if (!v59) {
            goto LABEL_126;
          }
LABEL_88:
          [v53 objectForKeyedSubscript:@"IPSecSharedSecret"];
          unint64_t v56 = (id)objc_claimAutoreleasedReturnValue();
          if (v56
            || ([v53 objectForKeyedSubscript:@"SharedSecret"],
                (unint64_t v56 = (id)objc_claimAutoreleasedReturnValue()) != 0LL))
          {
            if (!isa_nsdata(v56))
            {
              if ((isa_nsstring(v56) & 1) != 0) {
                goto LABEL_115;
              }
              ne_log_obj();
              uint64_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
              {
                v99 = v55;
                v100 = (void *)objc_opt_class();
                v101 = v100;
                v102 = (void *)objc_opt_class();
                *(_DWORD *)buf = 138412546;
                v108 = v100;
                v109 = 2112;
                v110 = v102;
                v103 = v102;
                _os_log_debug_impl( &dword_1876B1000,  v64,  OS_LOG_TYPE_DEBUG,  "%@ extractPayloadContentsSharedSecret: Invalid shared secret object type %@, setting to nil",  buf,  0x16u);

                BOOL v55 = v99;
              }

              uint64_t v63 = 0LL;
              goto LABEL_114;
            }

            uint64_t v62 = (CFStringRef)[objc_alloc(NSString) initWithData:v56 encoding:4];
          }

          else
          {
            [v53 objectForKeyedSubscript:@"ExportedSharedSecret"];
            uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue();
            if (v65)
            {
              unint64_t v56 = v65;
              if ([v56 length])
              {
                uint64_t v66 = v55;
                uint64_t v67 = [v56 length];
                uint64_t v68 = (char *)malloc(v67);
                [v56 getBytes:v68 length:v67];
                if (v67)
                {
                  uint64_t v69 = &kVPNObfuscationKey;
                  size_t v70 = v68;
                  do
                  {
                    unint64_t v71 = *v69++;
                    *v70++ ^= v71;
                    if (v69 == "؛[]y<I@") {
                      uint64_t v69 = &kVPNObfuscationKey;
                    }
                    --v67;
                  }

                  while (v67);
                }

                uint64_t v72 = strlen(v68);
                uint64_t v63 = (const __CFString *)[objc_alloc(NSString) initWithBytes:v68 length:v72 encoding:4];
                memset_s(v68, v72, 0, v72);
                free(v68);
                BOOL v55 = v66;
              }

              else
              {
                uint64_t v63 = &stru_18A0915E8;
              }

              goto LABEL_114;
            }

            [v53 objectForKeyedSubscript:@"IPSecSharedSecretObf"];
            unint64_t v73 = (void *)objc_claimAutoreleasedReturnValue();
            unint64_t v56 = v73;
            if (!v73) {
              goto LABEL_115;
            }
            if (![v73 length])
            {
              uint64_t v63 = &stru_18A0915E8;
              goto LABEL_114;
            }

            uint64_t v74 = v55;
            if (*CFDataGetBytePtr((CFDataRef)v56)) {
              unint64_t v75 = 335544576;
            }
            else {
              unint64_t v75 = 268435712;
            }
            BytePtr = (const char *)CFDataGetBytePtr((CFDataRef)v56);
            unint64_t v77 = strlen(BytePtr);
            unint64_t v78 = (const __CFAllocator *)*MEMORY[0x189604DB0];
            uint64_t v79 = CFDataGetBytePtr((CFDataRef)v56);
            uint64_t v80 = v75;
            BOOL v55 = v74;
            uint64_t v62 = CFStringCreateWithBytes(v78, v79, v77, v80, 0);
          }

          uint64_t v63 = v62;
LABEL_114:

          unint64_t v56 = (id)v63;
LABEL_115:
          v6->_sharedSecretRequired = 1;
          objc_storeStrong((id *)&v6->_sharedSecret, v56);
          if (v6->_sharedSecretRequired
            && [v50 isEqualToString:@"IKEv2"]
            && [v55 isEqualToString:@"None"])
          {
            [v53 objectForKeyedSubscript:@"ExtendedAuthEnabled"];
            objc_super v81 = (void *)objc_claimAutoreleasedReturnValue();
            if ((isa_nsnumber(v81) & 1) != 0)
            {
              [v53 objectForKeyedSubscript:@"ExtendedAuthEnabled"];
              v105 = v55;
              uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
              v83 = [v82 BOOLValue];

              BOOL v55 = v105;
              if (v83) {
                v6->_sharedSecretRequired = 0;
              }
            }

            else
            {
            }
          }

          ne_log_obj();
          uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
          {
            unint64_t v91 = v55;
            v92 = (void *)objc_opt_class();
            v93 = v92;
            v94 = (void *)objc_opt_class();
            *(_DWORD *)buf = 138412546;
            v108 = v92;
            v109 = 2112;
            v110 = v94;
            v95 = v94;
            _os_log_debug_impl( &dword_1876B1000,  v84,  OS_LOG_TYPE_DEBUG,  "%@ extractPayloadContentsSharedSecret: (value class %@)",  buf,  0x16u);

            BOOL v55 = v91;
          }

LABEL_125:
          goto LABEL_126;
        }

        BOOL v55 = v104;
        if ((v59 & 1) != 0) {
          goto LABEL_88;
        }
      }

uint64_t DERParseBitString(uint64_t result, unint64_t *a2, _BYTE *a3)
{
  *a3 = 0;
  *a2 = 0LL;
  a2[1] = 0LL;
  if (!*(void *)(result + 8)) {
    return 3LL;
  }
  unsigned int v3 = **(unsigned __int8 **)result;
  *a3 = v3;
  uint64_t v4 = *(void *)(result + 8);
  if (v4 != 1)
  {
    if (v3 <= 7)
    {
      unint64_t v5 = v4 - 1;
      if (!v4)
      {
LABEL_20:
        __break(0x5515u);
        goto LABEL_21;
      }

      unint64_t v6 = *(void *)result;
      unint64_t v7 = *(void *)result + v4;
      unint64_t v8 = (unsigned __int8 *)(*(void *)result + v5);
      if ((unint64_t)v8 >= v7 || (unint64_t)v8 < v6)
      {
LABEL_19:
        __break(0x5519u);
        goto LABEL_20;
      }

      if (((0xFFu >> (8 - v3)) & *v8) == 0)
      {
        if (v6 == -1LL)
        {
LABEL_21:
          __break(0x5513u);
          return result;
        }

        unint64_t v10 = v6 + 1;
        if (v6 + 1 <= v7 && v6 <= v10)
        {
          uint64_t result = 0LL;
          *a2 = v10;
          a2[1] = v5;
          return result;
        }

        goto LABEL_19;
      }
    }

    return 3LL;
  }

  if (v3) {
    return 3LL;
  }
  else {
    return 0LL;
  }
}

uint64_t DERParseBoolean(unsigned __int8 **a1, BOOL *a2)
{
  int v2 = **a1;
  if (v2 != 255 && v2 != 0) {
    return 3LL;
  }
  uint64_t result = 0LL;
  *a2 = v2 != 0;
  return result;
}

uint64_t DERParseBooleanWithDefault(unsigned __int8 **a1, BOOL a2, BOOL *a3)
{
  unsigned int v3 = a1[1];
  if (!v3) {
    goto LABEL_9;
  }
  if (v3 == (unsigned __int8 *)1)
  {
    int v4 = **a1;
    if (v4 == 255 || v4 == 0)
    {
      a2 = v4 != 0;
LABEL_9:
      uint64_t result = 0LL;
      *a3 = a2;
      return result;
    }
  }

  return 3LL;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  v4[1] = *MEMORY[0x1895F89C0];
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = DERParseInteger64(a1, v4);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v4[0]))
    {
      return 7LL;
    }

    else
    {
      uint64_t result = 0LL;
      *a2 = v4[0];
    }
  }

  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2 = (unint64_t)a1[1];
  if (!v2) {
    return 3LL;
  }
  unsigned int v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0) {
    return 3LL;
  }
  if (**a1)
  {
    if (v2 > 8) {
      return 7LL;
    }
    goto LABEL_10;
  }

  if (v2 >= 2)
  {
    if (v2 > 9) {
      return 7LL;
    }
  }

LABEL_10:
  unint64_t v5 = 0LL;
  do
  {
    unsigned int v6 = *v3++;
    unint64_t v5 = v6 | (v5 << 8);
    --v2;
  }

  while (v2);
  uint64_t result = 0LL;
  *a2 = v5;
  return result;
}

    unsigned int v6 = 0LL;
    goto LABEL_11;
  }

  unint64_t v5 = [v2 copy];
LABEL_4:
  unsigned int v6 = (void *)v5;
LABEL_11:

  return v6;
}
}

    unsigned int v6 = 0LL;
    goto LABEL_4;
  }

  unsigned int v6 = v5;
  [v4 dataUsingEncoding:4];
  self = (NEIKEv2FQDNIdentifier *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2Identifier setIdentifierData:](v6, "setIdentifierData:", self);
LABEL_4:

  return v6;
}

    unsigned int v6 = 0LL;
    goto LABEL_4;
  }

  unsigned int v6 = v5;
  -[NEIKEv2Identifier setIdentifierData:](v5, "setIdentifierData:", v4);
LABEL_4:

  return v6;
}

    unint64_t v7 = 0LL;
    goto LABEL_4;
  }

  unint64_t v7 = v5;
  objc_setProperty_atomic(v5, v6, v4, 16LL);
  [v4 hostname];
  self = (NEIKEv2AddressIdentifier *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2AddressIdentifier dataUsingEncoding:](self, "dataUsingEncoding:", 4LL);
  unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2Identifier setIdentifierData:](v7, "setIdentifierData:", v8);

LABEL_4:
  return v7;
}

    unsigned int v6 = 0LL;
    goto LABEL_4;
  }

  unsigned int v6 = v5;
  -[NEIKEv2Identifier setIdentifierData:](v5, "setIdentifierData:", v4);
LABEL_4:

  return v6;
}

    unsigned int v6 = 0LL;
    goto LABEL_4;
  }

  unsigned int v6 = v5;
  [v4 dataUsingEncoding:4];
  self = (NEIKEv2UserFQDNIdentifier *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2Identifier setIdentifierData:](v6, "setIdentifierData:", self);
LABEL_4:

  return v6;
}

  return a1;
}

  unint64_t v5 = 0LL;
LABEL_11:

  return v5;
}
}

  return a1;
}

  unsigned int v9 = *MEMORY[0x18960C6C0];
  [v5 objectForKeyedSubscript:*MEMORY[0x18960C6C0]];
  unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v11 = isa_nsarray(v10);

  if (v11)
  {
    [v5 objectForKeyedSubscript:v9];
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v12 count])
    {
      [v12 objectAtIndexedSubscript:0];
      unsigned __int8 v13 = (void *)objc_claimAutoreleasedReturnValue();
      char v14 = isa_nsstring(v13);

      if (v14)
      {
        unint64_t v15 = [v12 copy];
        addresses = v6->_addresses;
        v6->_addresses = (NSArray *)v15;
      }
    }
  }

  BOOL v17 = *MEMORY[0x18960C720];
  [v5 objectForKeyedSubscript:*MEMORY[0x18960C720]];
  unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v19 = isa_nsarray(v18);

  if (v19)
  {
    [v5 objectForKeyedSubscript:v17];
    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v20 count])
    {
      [v20 objectAtIndexedSubscript:0];
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v22 = isa_nsstring(v21);

      if (v22)
      {
        unsigned int v23 = [v20 copy];
        subnetMasks = v6->_subnetMasks;
        v6->_subnetMasks = (NSArray *)v23;
      }
    }
  }

  BOOL v25 = *MEMORY[0x18960C718];
  [v5 objectForKeyedSubscript:*MEMORY[0x18960C718]];
  char v26 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v27 = isa_nsstring(v26);

  if (v27)
  {
    [v5 objectForKeyedSubscript:v25];
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v29 = [v28 copy];
    router = v6->_router;
    v6->_router = (NSString *)v29;
  }

  unint64_t v31 = *MEMORY[0x18960C7B8];
  [v5 objectForKeyedSubscript:*MEMORY[0x18960C7B8]];
  unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v33 = isa_nsnumber(v32);
  int64_t v34 = (uint64_t *)MEMORY[0x18960C6F0];
  if (!v33
    || ([v5 objectForKeyedSubscript:v31],
        unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue(),
        ![v3 BOOLValue]))
  {
    [v5 objectForKeyedSubscript:*v34];
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v36 = isa_nsarray(v35);

    if (v33)
    {

      if ((v36 & 1) != 0) {
        goto LABEL_29;
      }
    }

    else
    {

      if (v36) {
        goto LABEL_29;
      }
    }

    uint64_t v37 = 0LL;
    goto LABEL_30;
  }

LABEL_29:
  uint64_t v37 = objc_alloc_init(MEMORY[0x189603FA8]);
LABEL_30:
  [v5 objectForKeyedSubscript:v31];
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v39 = isa_nsnumber(v38);

  if (v39)
  {
    [v5 objectForKeyedSubscript:v31];
    unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    v6->_overridePrimary = [v40 BOOLValue];

    if (v6->_overridePrimary)
    {
      +[NEIPv4Route defaultRoute](&OBJC_CLASS___NEIPv4Route, "defaultRoute");
      unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
      [v37 addObject:v41];
    }
  }

  unint64_t v42 = *v34;
  [v5 objectForKeyedSubscript:*v34];
  int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v44 = isa_nsarray(v43);

  if (v44)
  {
    [v5 objectForKeyedSubscript:v42];
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v69 = 0u;
    size_t v70 = 0u;
    unint64_t v71 = 0u;
    uint64_t v72 = 0u;
    uint64_t v46 = [v45 countByEnumeratingWithState:&v69 objects:v74 count:16];
    if (v46)
    {
      int64_t v47 = v46;
      uint64_t v48 = *(void *)v70;
      do
      {
        for (i = 0LL; i != v47; ++i)
        {
          if (*(void *)v70 != v48) {
            objc_enumerationMutation(v45);
          }
          uint64_t v50 = -[NEIPv4Route initFromLegacyDictionary:]( objc_alloc(&OBJC_CLASS___NEIPv4Route),  "initFromLegacyDictionary:",  *(void *)(*((void *)&v69 + 1) + 8 * i));
          [v37 addObject:v50];
        }

        int64_t v47 = [v45 countByEnumeratingWithState:&v69 objects:v74 count:16];
      }

      while (v47);
    }
  }

  if (v37) {
    objc_storeStrong((id *)&v6->_includedRoutes, v37);
  }
  uint64_t v51 = *MEMORY[0x18960C6E8];
  [v5 objectForKeyedSubscript:*MEMORY[0x18960C6E8]];
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v53 = isa_nsarray(v52);

  if (v53)
  {
    uint64_t v64 = v7;
    [v5 objectForKeyedSubscript:v51];
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();
    BOOL v55 = (NSArray *)objc_alloc_init(MEMORY[0x189603FA8]);
    uint64_t v65 = 0u;
    uint64_t v66 = 0u;
    uint64_t v67 = 0u;
    uint64_t v68 = 0u;
    unint64_t v56 = v54;
    unint64_t v57 = [v56 countByEnumeratingWithState:&v65 objects:v73 count:16];
    if (v57)
    {
      unint64_t v58 = v57;
      uint64_t v59 = *(void *)v66;
      do
      {
        for (j = 0LL; j != v58; ++j)
        {
          if (*(void *)v66 != v59) {
            objc_enumerationMutation(v56);
          }
          uint64_t v61 = -[NEIPv4Route initFromLegacyDictionary:]( objc_alloc(&OBJC_CLASS___NEIPv4Route),  "initFromLegacyDictionary:",  *(void *)(*((void *)&v65 + 1) + 8 * j));
          -[NSArray addObject:](v55, "addObject:", v61);
        }

        unint64_t v58 = [v56 countByEnumeratingWithState:&v65 objects:v73 count:16];
      }

      while (v58);
    }

    excludedRoutes = v6->_excludedRoutes;
    v6->_excludedRoutes = v55;

    unint64_t v7 = v64;
  }

LABEL_54:
  return v6;
}

  unsigned int v9 = *MEMORY[0x18960C730];
  [v5 objectForKeyedSubscript:*MEMORY[0x18960C730]];
  unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v11 = isa_nsarray(v10);

  if (v11)
  {
    [v5 objectForKeyedSubscript:v9];
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v12 count])
    {
      [v12 objectAtIndexedSubscript:0];
      unsigned __int8 v13 = (void *)objc_claimAutoreleasedReturnValue();
      char v14 = isa_nsstring(v13);

      if (v14)
      {
        unint64_t v15 = [v12 copy];
        addresses = v6->_addresses;
        v6->_addresses = (NSArray *)v15;
      }
    }
  }

  BOOL v17 = *MEMORY[0x18960C760];
  [v5 objectForKeyedSubscript:*MEMORY[0x18960C760]];
  unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v19 = isa_nsarray(v18);

  if (v19)
  {
    [v5 objectForKeyedSubscript:v17];
    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v20 count])
    {
      [v20 objectAtIndexedSubscript:0];
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v22 = isa_nsnumber(v21);

      if (v22)
      {
        unsigned int v23 = [v20 copy];
        networkPrefixLengths = v6->_networkPrefixLengths;
        v6->_networkPrefixLengths = (NSArray *)v23;
      }
    }
  }

  BOOL v25 = *MEMORY[0x18960C788];
  [v5 objectForKeyedSubscript:*MEMORY[0x18960C788]];
  char v26 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v27 = isa_nsstring(v26);

  if (v27)
  {
    [v5 objectForKeyedSubscript:v25];
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v29 = [v28 copy];
    router = v6->_router;
    v6->_router = (NSString *)v29;
  }

  unint64_t v31 = *MEMORY[0x18960C7B8];
  [v5 objectForKeyedSubscript:*MEMORY[0x18960C7B8]];
  unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v33 = isa_nsnumber(v32);
  int64_t v34 = (uint64_t *)MEMORY[0x18960C750];
  if (!v33
    || ([v5 objectForKeyedSubscript:v31],
        unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue(),
        ![v3 BOOLValue]))
  {
    [v5 objectForKeyedSubscript:*v34];
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v36 = isa_nsarray(v35);

    if (v33)
    {

      if ((v36 & 1) != 0) {
        goto LABEL_29;
      }
    }

    else
    {

      if (v36) {
        goto LABEL_29;
      }
    }

    uint64_t v37 = 0LL;
    goto LABEL_30;
  }

LABEL_29:
  uint64_t v37 = objc_alloc_init(MEMORY[0x189603FA8]);
LABEL_30:
  [v5 objectForKeyedSubscript:v31];
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
  if (!isa_nsnumber(v38))
  {
LABEL_33:

    goto LABEL_34;
  }

  [v5 objectForKeyedSubscript:v31];
  unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v40 = [v39 BOOLValue];

  if (v40)
  {
    +[NEIPv6Route defaultRoute](&OBJC_CLASS___NEIPv6Route, "defaultRoute");
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
    [v37 addObject:v38];
    goto LABEL_33;
  }
    }
  }
}

      char v24 = objc_getProperty(self, v14, 112LL, 1);
      Property = objc_getProperty(self, v25, 80LL, 1);
LABEL_11:
      [v24 addObject:Property];

      goto LABEL_31;
    }

    goto LABEL_36;
  }

  if ([v8 isEqualToString:@"packet-tunnel"])
  {
    BOOL v17 = objc_alloc_init(&OBJC_CLASS___NETunnelProviderManager);
    unint64_t v19 = v17;
    if (self)
    {
      objc_setProperty_atomic(self, v18, v17, 80LL);

      objc_msgSend(objc_getProperty(self, v20, 80, 1), "setLocalizedDescription:", v7);
      if (!objc_getProperty(self, v21, 112LL, 1))
      {
        unint64_t v22 = objc_alloc_init(MEMORY[0x189603FA8]);
        objc_setProperty_atomic(self, v23, v22, 112LL);
      }

      goto LABEL_10;
    }

    [0 setLocalizedDescription:v7];
LABEL_36:

    char v24 = 0LL;
    Property = 0LL;
    goto LABEL_11;
  }

  if ([v8 isEqualToString:@"filter"])
  {
    +[NEFilterManager sharedManager](&OBJC_CLASS___NEFilterManager, "sharedManager");
    unint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
    [v27 setLocalizedDescription:v7];

    if (self)
    {
      if (!objc_getProperty(self, v28, 112LL, 1))
      {
        uint64_t v30 = objc_alloc_init(MEMORY[0x189603FA8]);
        objc_setProperty_atomic(self, v31, v30, 112LL);
      }

      unint64_t v32 = objc_getProperty(self, v29, 112LL, 1);
    }

    else
    {

      unint64_t v32 = 0LL;
    }

    unint64_t v33 = &OBJC_CLASS___NEFilterManager;
  }

  else if ([v8 isEqualToString:@"dns-proxy"])
  {
    +[NEDNSProxyManager sharedManager](&OBJC_CLASS___NEDNSProxyManager, "sharedManager");
    int64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    [v34 setLocalizedDescription:v7];

    if (self)
    {
      if (!objc_getProperty(self, v35, 112LL, 1))
      {
        uint64_t v37 = objc_alloc_init(MEMORY[0x189603FA8]);
        objc_setProperty_atomic(self, v38, v37, 112LL);
      }

      unint64_t v32 = objc_getProperty(self, v36, 112LL, 1);
    }

    else
    {

      unint64_t v32 = 0LL;
    }

    unint64_t v33 = &OBJC_CLASS___NEDNSProxyManager;
  }

  else
  {
    if (![v8 isEqualToString:@"dns-settings"])
    {
      objc_msgSend( NSString,  "stringWithFormat:",  @"Invalid configuration type, valid types are lite, packet-tunnel, filter, dns-proxy, and dns-settings");
      uint64_t v46 = 0;
      *a4 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_32;
    }

    +[NEDNSSettingsManager sharedManager](&OBJC_CLASS___NEDNSSettingsManager, "sharedManager");
    unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
    [v39 setLocalizedDescription:v7];

    if (self)
    {
      if (!objc_getProperty(self, v40, 112LL, 1))
      {
        unint64_t v42 = objc_alloc_init(MEMORY[0x189603FA8]);
        objc_setProperty_atomic(self, v43, v42, 112LL);
      }

      unint64_t v32 = objc_getProperty(self, v41, 112LL, 1);
    }

    else
    {

      unint64_t v32 = 0LL;
    }

    unint64_t v33 = &OBJC_CLASS___NEDNSSettingsManager;
  }

  uint64_t v44 = v32;
  -[__objc2_class sharedManager](v33, "sharedManager");
  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
  [v44 addObject:v45];

LABEL_31:
  uint64_t v46 = 1;
LABEL_32:

  return v46;
}

  unsigned int v9 = *MEMORY[0x18960C9B0];
  [v4 objectForKeyedSubscript:*MEMORY[0x18960C9B0]];
  unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v11 = isa_nsstring(v10);

  if (v11)
  {
    [v4 objectForKeyedSubscript:v9];
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    unsigned __int8 v13 = [v12 copy];
    char v14 = (void *)v5[26];
    v5[26] = v13;
  }

  unint64_t v15 = (void *)[objc_alloc(MEMORY[0x189603FC8]) initWithDictionary:v4];
  [v15 removeObjectsForKeys:initFromLegacyDictionary__nsprotocolkeys];
  if (![v15 count])
  {

    unint64_t v15 = 0LL;
  }

  unint64_t v16 = (void *)v5[27];
  v5[27] = v15;
  BOOL v17 = v15;

  unint64_t v18 = [v4 objectForKeyedSubscript:@"NEProviderBundleIdentifier"];
  unint64_t v19 = (void *)v5[23];
  v5[23] = v18;

  BOOL v20 = [v4 objectForKeyedSubscript:@"DesignatedRequirement"];
  uint64_t v21 = (void *)v5[25];
  v5[25] = v20;

  unint64_t v22 = v5;
LABEL_15:

  return v5;
}

  BOOL v17 = _SCNetworkServiceCopyActive();
  if (v17)
  {
    unint64_t v18 = (const void *)v17;
    SCNetworkServiceSetPrimaryRank();
    CFRelease(v18);
  }

  return v9;
}

uint64_t DERDecodeSeqInit(uint64_t a1, void *a2, void *a3)
{
  v8[3] = *MEMORY[0x1895F89C0];
  memset(v8, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v8, 0LL);
  if (!(_DWORD)result)
  {
    unint64_t v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008LL)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }

      else
      {
        unint64_t v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          uint64_t result = 0LL;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }

      __break(0x5519u);
    }

    else
    {
      return 2LL;
    }
  }

  return result;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }

  else
  {
    unint64_t v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0LL;
    }
  }

  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  v10[2] = *MEMORY[0x1895F89C0];
  v10[0] = 0LL;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (*a1 >= v3) {
    return 1LL;
  }
  v10[0] = *a1;
  v10[1] = v3 - v2;
  uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0LL);
  if (!(_DWORD)result)
  {
    unint64_t v8 = a2[1];
    unint64_t v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      unint64_t v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        uint64_t result = 0LL;
        *a1 = v9;
        return result;
      }

      __break(0x5519u);
    }

    __break(0x5513u);
  }

  return result;
}

uint64_t DERParseSequenceToObject( uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  v12[3] = *MEMORY[0x1895F89C0];
  memset(v12, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v12, 0LL);
  if (!(_DWORD)result)
  {
    if (v12[0] == 0x2000000000000010LL) {
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    }
    else {
      return 2LL;
    }
  }

  return result;
}

uint64_t DERParseSequenceContentToObject( unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  unint64_t v32 = 0LL;
  if (a6)
  {
    if (a6 > a5) {
      goto LABEL_59;
    }
    bzero((void *)a4, a6);
  }

  unint64_t v10 = *a1;
  unint64_t v11 = a1[1];
  if (__CFADD__(*a1, v11)) {
    goto LABEL_58;
  }
  unint64_t v12 = v10 + v11;
  if (v10 > v12) {
LABEL_59:
  }
    __break(0x5519u);
  unint64_t v32 = *a1;
  unint64_t v33 = v12;
  if (a2)
  {
    unsigned __int16 v13 = 0;
    uint64_t v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      unint64_t v15 = v32;
      unint64_t v14 = v33;
      uint64_t result = DERDecodeSeqNext(&v32, v31);
      if ((_DWORD)result) {
        break;
      }
      if (a2 <= v13) {
        return 2LL;
      }
      while (1)
      {
        unsigned __int16 v17 = v13;
        __int16 v18 = *(_WORD *)(a3 + 24LL * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(void *)(a3 + 24LL * v13 + 8)) {
          break;
        }
        uint64_t result = 2LL;
        if ((v18 & 1) != 0)
        {
          ++v13;
        }

        return result;
      }

      if ((v18 & 4) == 0)
      {
        unint64_t v19 = *(void *)(a3 + 24LL * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5) {
          return 7LL;
        }
        if (v19 > ~a4) {
          goto LABEL_58;
        }
        uint64_t v21 = (char *)(a4 + v19);
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((void *)v21 + 1) <= v14 - v15)
            {
              *(void *)uint64_t v21 = v15;
              return 3LL;
            }

            goto LABEL_59;
          }

          if (v21 + 16 > v29) {
            goto LABEL_59;
          }
          uint64_t v23 = *((void *)v21 + 1);
          unint64_t v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }

          if (v14 < v15 || v24 > v14 - v15) {
            goto LABEL_59;
          }
          *(void *)uint64_t v21 = v15;
          *((void *)v21 + 1) = v24;
        }
      }

      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          unint64_t v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            unint64_t v10 = v31[1] + v31[2];
            unint64_t v12 = *a1 + v28;
            goto LABEL_47;
          }
        }

LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }

      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        unint64_t v10 = v32;
        unint64_t v12 = v33;
        goto LABEL_47;
      }
    }

    if ((_DWORD)result == 1)
    {
      if (a2 <= v13)
      {
        return 0LL;
      }

      else
      {
        BOOL v25 = (__int16 *)(a3 + 24LL * v13 + 16);
        unint64_t v26 = a2 - (unint64_t)v13;
        uint64_t result = 0LL;
        while (1)
        {
          __int16 v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0) {
            break;
          }
          if (!--v26) {
            return result;
          }
        }

        return 5LL;
      }
    }
  }

  else
  {
LABEL_47:
    if (v10 == v12) {
      return 0LL;
    }
    else {
      return 3LL;
    }
  }

  return result;
}

      _os_log_fault_impl(&dword_1876B1000, v77, OS_LOG_TYPE_FAULT, v78, buf, 0xCu);
      goto LABEL_59;
    }
  }

  [v17 remoteEndpoint];
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();

  if (v30) {
    goto LABEL_14;
  }
LABEL_31:
  objc_storeWeak((id *)v25 + 68, obj);
  objc_setProperty_atomic_copy(v25, v55, v20, 552LL);
  objc_storeWeak((id *)v25 + 70, v21);
  v123 = v21;
  unint64_t v22 = v124;
  if (v21) {
    *((_BYTE *)v25 + 25) = 1;
  }
  objc_storeWeak((id *)v25 + 71, v124);
  [v17 outgoingInterfaceName];
  unint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_setProperty_atomic(v25, v57, v56, 304LL);

  *((_BYTE *)v25 + 9) = [v17 serverMode] ^ 1;
  *((void *)v25 + 6) = 3LL;
  objc_setProperty_atomic(v25, v58, 0LL, 56LL);
  uint64_t v59 = objc_alloc_init(&OBJC_CLASS___NEIKEv2IKESPI);
  objc_setProperty_atomic(v25, v60, v59, 32LL);

  v122 = v18;
  if ((*((_BYTE *)v25 + 25) & 1) != 0 && (*((_BYTE *)v25 + 9) & 1) != 0)
  {
    uint64_t v62 = objc_getProperty(v25, v61, 72LL, 1);
    if (!v62 || (v63 = v62, uint64_t v64 = objc_getProperty(v25, v61, 64LL, 1), v63, !v64))
    {
      v121 = v29;
      uint64_t v65 = 1;
      uint64_t v67 = 1;
      if ((objc_msgSend(objc_getProperty(v25, v61, 80, 1), "requestChildlessSA") & 1) == 0)
      {
        v129 = 0u;
        v130 = 0u;
        v127 = 0u;
        v128 = 0u;
        [v122 configurationRequest];
        Property = (void *)objc_claimAutoreleasedReturnValue();
        size_t v70 = Property;
        if (Property) {
          Property = objc_getProperty(Property, v69, 16LL, 1);
        }
        v120 = v19;
        unint64_t v71 = Property;

        uint64_t v72 = [v71 countByEnumeratingWithState:&v127 objects:v138 count:16];
        if (v72)
        {
          unint64_t v73 = v72;
          uint64_t v65 = 0;
          uint64_t v67 = 0;
          uint64_t v74 = *(void *)v128;
          do
          {
            for (i = 0LL; i != v73; ++i)
            {
              if (*(void *)v128 != v74) {
                objc_enumerationMutation(v71);
              }
              uint64_t v76 = *(void **)(*((void *)&v127 + 1) + 8 * i);
              if ([v76 attributeType] == 25958) {
                uint64_t v65 = 1;
              }
              else {
                v67 |= [v76 attributeType] == 25959;
              }
            }

            unint64_t v73 = [v71 countByEnumeratingWithState:&v127 objects:v138 count:16];
          }

          while (v73);
        }

        else
        {
          uint64_t v65 = 0;
          uint64_t v67 = 0;
        }

        unint64_t v19 = v120;
        unint64_t v22 = v124;
      }

      if (!objc_getProperty(v25, v66, 64LL, 1) && (v65 & 1) != 0)
      {
        [MEMORY[0x189608DE8] endpointWithHostname:@"::" port:@"500"];
        uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();
        objc_setProperty_atomic(v25, v81, v80, 64LL);
      }

      uint64_t v29 = v121;
      if (((objc_getProperty(v25, v79, 72LL, 1) == 0LL) & v67) == 1)
      {
        [MEMORY[0x189608DE8] endpointWithHostname:@"::1" port:@"500"];
        uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
        objc_setProperty_atomic(v25, v83, v82, 72LL);
      }
    }
  }

  uint64_t v84 = newValue;
  if (newValue)
  {
    uint64_t v85 = (char *)newValue[5];
    if ((unint64_t)(v85 - 2) < 2)
    {
      *((_BYTE *)v25 + 13) = 1;
      v86 = v25;
      v87 = newValue;
      unint64_t v88 = 480LL;
    }

    else if (v85 == (char *)1)
    {
      *((_BYTE *)v25 + 12) = 1;
      v86 = v25;
      v87 = newValue;
      unint64_t v88 = 472LL;
    }

    else
    {
      if (v85)
      {
LABEL_84:
        v102 = objc_getProperty(v25, v61, 32LL, 1);
        -[NEIKEv2Transport addClient:delegate:](v84, v102, obj);
        v104 = objc_getProperty(v84, v103, 24LL, 1);
        objc_setProperty_atomic(v25, v105, v104, 72LL);

        newValue = v84;
        v107 = objc_getProperty(v84, v106, 16LL, 1);
        objc_setProperty_atomic(v25, v108, v107, 64LL);

        ne_log_large_obj();
        v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v109, OS_LOG_TYPE_INFO))
        {
          v111 = objc_getProperty(v25, v110, 72LL, 1);
          v113 = objc_getProperty(v25, v112, 80LL, 1);
          *(_DWORD *)buf = 138412802;
          v133 = (const char *)v25;
          v134 = 2112;
          v135 = v111;
          v136 = 2112;
          v137 = v113;
          _os_log_impl(&dword_1876B1000, v109, OS_LOG_TYPE_INFO, "Created %@ to %@ with configuration %@", buf, 0x20u);
        }

        ne_log_large_obj();
        a1 = (void *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled((os_log_t)a1, OS_LOG_TYPE_INFO))
        {
          v115 = (const char *)objc_getProperty(v25, v114, 88LL, 1);
          *(_DWORD *)buf = 138412290;
          v133 = v115;
          _os_log_impl(&dword_1876B1000, (os_log_t)a1, OS_LOG_TYPE_INFO, "Session configuration %@", buf, 0xCu);
        }

        __int16 v18 = v122;
        uint64_t v21 = v123;
        goto LABEL_89;
      }

      v86 = v25;
      v87 = newValue;
      unint64_t v88 = 464LL;
    }

    objc_setProperty_atomic(v86, v61, v87, v88);
    goto LABEL_84;
  }

  v89 = [v17 forceUDPEncapsulation];
  unint64_t v91 = objc_getProperty(v25, v90, 72LL, 1);
  v93 = objc_getProperty(v25, v92, 64LL, 1);
  v95 = objc_getProperty(v25, v94, 304LL, 1);
  uint64_t v84 = +[NEIKEv2Transport createTransport:remote:local:localPort:boundInterface:queue:socketGetBlock:packetDelegate:]( (uint64_t)&OBJC_CLASS___NEIKEv2Transport,  v89,  v91,  v93,  v29,  v95,  v19,  v20,  v123);

  if (v84)
  {
    if ([v17 forceUDPEncapsulation])
    {
      *((_BYTE *)v25 + 12) = 1;
      v97 = v25;
      v98 = v84;
      v99 = 472LL;
    }

    else
    {
      v97 = v25;
      v98 = v84;
      v99 = 464LL;
    }

    objc_setProperty_atomic(v97, v96, v98, v99);
    unint64_t v22 = v124;
    goto LABEL_84;
  }

  ne_log_obj();
  v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v18 = v122;
  if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
  {
    v117 = objc_getProperty(v25, v101, 72LL, 1);
    *(_DWORD *)buf = 138412546;
    v133 = (const char *)v25;
    v134 = 2112;
    v135 = v117;
    _os_log_error_impl(&dword_1876B1000, v100, OS_LOG_TYPE_ERROR, "%@ failed to create transport for %@", buf, 0x16u);
  }

  newValue = 0LL;
  a1 = v25;
  BOOL v25 = 0LL;
  uint64_t v21 = v123;
LABEL_60:
  unint64_t v22 = v124;
LABEL_89:

LABEL_90:
  return v25;
}

  if (-[NEVPNProtocolIKEv2 enableFallback](self, "enableFallback"))
  {
    objc_msgSend(MEMORY[0x189607968], "numberWithBool:", -[NEVPNProtocolIKEv2 enableFallback](self, "enableFallback"));
    unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v26 forKeyedSubscript:@"EnableFallback"];
  }

  if (-[NEVPNProtocolIKEv2 mtu](self, "mtu"))
  {
    objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedInteger:", -[NEVPNProtocolIKEv2 mtu](self, "mtu"));
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v27 forKeyedSubscript:@"MTU"];
  }

  -[NEVPNProtocolIKEv2 ppkConfiguration](self, "ppkConfiguration");
  unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();

  if (v28)
  {
    Property = -[NEVPNProtocolIKEv2 ppkConfiguration](self, "ppkConfiguration");
    unint64_t v31 = Property;
    if (Property) {
      Property = objc_getProperty(Property, v30, 32LL, 1);
    }
    [Property data];
    unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();

    if (v32)
    {
      -[NEVPNProtocolIKEv2 ppkConfiguration](self, "ppkConfiguration");
      unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v35 = v33;
      if (v33) {
        unint64_t v33 = objc_getProperty(v33, v34, 32LL, 1);
      }
      [v33 data];
      unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
      [v3 setObject:v36 forKeyedSubscript:@"PPK"];
    }

    -[NEVPNProtocolIKEv2 ppkConfiguration](self, "ppkConfiguration");
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    [v37 identifier];
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v39 = (void *)[v38 copy];
    [v3 setObject:v39 forKeyedSubscript:@"PPKIdentifier"];

    unint64_t v40 = (void *)MEMORY[0x189607968];
    -[NEVPNProtocolIKEv2 ppkConfiguration](self, "ppkConfiguration");
    unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v40, "numberWithBool:", objc_msgSend(v41, "isMandatory"));
    unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v42 forKeyedSubscript:@"PPKMandatory"];

    -[NEVPNProtocolIKEv2 ppkConfiguration](self, "ppkConfiguration");
    int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
    [v43 keychainReference];
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();

    if (v44)
    {
      -[NEVPNProtocolIKEv2 ppkConfiguration](self, "ppkConfiguration");
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
      [v45 keychainReference];
      uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
      int64_t v47 = (void *)[v46 copy];
      [v3 setObject:v47 forKeyedSubscript:@"PPKReference"];
    }
  }

  return v3;
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

unint64_t *DERParseSequenceContent( unint64_t *result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return (unint64_t *)DERParseSequenceContentToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSequenceWithBlock(uint64_t a1, uint64_t a2)
{
  v4[3] = *MEMORY[0x1895F89C0];
  memset(v4, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v4, 0LL);
  if (!(_DWORD)result)
  {
    if (v4[0] - 0x2000000000000012LL >= 0xFFFFFFFFFFFFFFFELL) {
      return DERDecodeSequenceContentWithBlock(&v4[1], a2);
    }
    else {
      return 2LL;
    }
  }

  return result;
}

uint64_t DERDecodeSequenceContentWithBlock(unint64_t *a1, uint64_t a2)
{
  v9[2] = *MEMORY[0x1895F89C0];
  v9[0] = 0LL;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (__CFADD__(*a1, v3))
  {
    __break(0x5513u);
LABEL_13:
    __break(0x5519u);
  }

  unint64_t v4 = v2 + v3;
  if (v2 > v4) {
    goto LABEL_13;
  }
  v9[0] = *a1;
  v9[1] = v4;
  memset(v8, 170, sizeof(v8));
  char v7 = 0;
  while (1)
  {
    LODWORD(result) = DERDecodeSeqNext(v9, v8);
    if ((_DWORD)result) {
      break;
    }
    LODWORD(result) = (*(uint64_t (**)(uint64_t, unint64_t *, char *))(a2 + 16))(a2, v8, &v7);
    if ((_DWORD)result) {
      break;
    }
    if (v7) {
      return 0LL;
    }
  }

  else {
    return result;
  }
}

BOOL DEROidCompare(uint64_t a1, uint64_t a2)
{
  BOOL result = 0LL;
  if (a1 && a2)
  {
    size_t v4 = *(void *)(a1 + 8);
    return v4 == *(void *)(a2 + 8) && memcmp(*(const void **)a1, *(const void **)a2, v4) == 0;
  }

  return result;
}

LABEL_8:
  unint64_t v9 = 1;
LABEL_9:
  if (-[NEAOVPNException action](self, "action") != 1 && -[NEAOVPNException action](self, "action") != 2)
  {
    +[NEConfiguration addError:toList:]( (uint64_t)&OBJC_CLASS___NEConfiguration,  @"Invalid action for service exception",  v4);
    unint64_t v9 = 0;
  }

  return v9;
}

  unint64_t v5 = 0;
LABEL_80:

  return v5;
}

  return 0;
}

  return 0;
}

    return 0;
  }

  uint64_t v29 = 0;
  objc_msgSend(objc_getProperty(self, v4, 16, 1), "getBytes:length:", &v29, 4);
  self->_notifyType = bswap32(HIWORD(v29)) >> 16;
  if (v29 == 3)
  {
    if (BYTE1(v29) != 4)
    {
      ne_log_obj();
      unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        buf[0] = 67109120;
        buf[1] = BYTE1(v29);
        unsigned __int16 v13 = "Invalid Notify ESP SPI length %u";
        goto LABEL_24;
      }

      goto LABEL_28;
    }

    unint64_t v14 = objc_msgSend(objc_getProperty(self, v7, 16, 1), "length");
    if (v14 < (unint64_t)BYTE1(v29) + 4)
    {
      ne_log_obj();
      unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_15;
      }
      goto LABEL_28;
    }

    buf[0] = 0;
    objc_msgSend(objc_getProperty(self, v15, 16, 1), "getBytes:range:", buf, 4, 4);
    unint64_t v16 = objc_alloc(&OBJC_CLASS___NEIKEv2ESPSPI);
    unsigned __int16 v17 = -[NEIKEv2ESPSPI initWithValue:](v16, "initWithValue:", buf[0]);
LABEL_27:
    unint64_t v10 = (os_log_s *)v17;
    objc_setProperty_atomic(self, v18, v17, 40LL);
    goto LABEL_28;
  }

  if (BYTE1(v29) != 8)
  {
    ne_log_obj();
    unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      buf[0] = 67109120;
      buf[1] = BYTE1(v29);
      unsigned __int16 v13 = "Invalid Notify IKE SPI length %u";
      goto LABEL_24;
    }

    goto LABEL_28;
  }

  unint64_t v8 = objc_msgSend(objc_getProperty(self, v7, 16, 1), "length");
  if (v8 >= (unint64_t)BYTE1(v29) + 4)
  {
    *(void *)buf = 0LL;
    objc_msgSend(objc_getProperty(self, v9, 16, 1), "getBytes:range:", buf, 4, 8);
    unint64_t v19 = objc_alloc(&OBJC_CLASS___NEIKEv2IKESPI);
    unsigned __int16 v17 = -[NEIKEv2IKESPI initWithValue:](v19, "initWithValue:", *(void *)buf);
    goto LABEL_27;
  }

  ne_log_obj();
  unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
LABEL_15:
    unint64_t v12 = objc_msgSend(objc_getProperty(self, v11, 16, 1), "length");
    buf[0] = 67109120;
    buf[1] = v12;
    unsigned __int16 v13 = "Invalid Notify payload length %u cannot hold SPI";
LABEL_24:
    _os_log_error_impl(&dword_1876B1000, v10, OS_LOG_TYPE_ERROR, v13, (uint8_t *)buf, 8u);
  }

    return 0LL;
  }

  size_t v4 = objc_getProperty(self, v3, 32LL, 1);
  unint64_t v6 = objc_msgSend(v4, "subdataWithRange:", 1, objc_msgSend(objc_getProperty(self, v5, 32, 1), "length") - 1);

  return v6;
}

    unint64_t v11 = 0LL;
    goto LABEL_9;
  }

  nw_frame_array_first();
  unint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (!v8)
  {
    unint64_t v11 = 0LL;
    goto LABEL_10;
  }

  unint64_t v11 = 0LL;
  unint64_t v15 = 0;
  do
  {
    unint64_t v16 = a4 - v15;
    if (a4 <= v15) {
      break;
    }
    nw_frame_array_next();
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    if (nw_frame_unclaimed_length() + v15 <= a4)
    {
      nw_frame_array_remove();
      nw_frame_array_append();
      v15 += nw_frame_unclaimed_length();
      uint64_t v21 = v8;
      unint64_t v8 = v17;
    }

    else
    {
      __int16 v18 = malloc(a4 - v15);
      if (!v18)
      {

        break;
      }

      unint64_t v19 = v18;
      BOOL v20 = (void *)nw_frame_create();
      nw_frame_array_append();
      uint64_t v21 = v20;
      unint64_t v22 = (const void *)nw_frame_unclaimed_bytes();
      memcpy(v19, v22, v16);
      nw_frame_claim();
      unint64_t v15 = a4;
    }

    unint64_t v11 = (v11 + 1);
  }

  while (v8);
LABEL_9:

LABEL_10:
  _Block_object_dispose(&v24, 8);
  return v11;
}
}
}

  unint64_t v11 = -[NEIPv6Settings router](self, "router");
  if (v11)
  {
    unint64_t v12 = (void *)v11;
    unsigned __int16 v13 = -[NEIPv6Settings router](self, "router");
    unint64_t v14 = inet_pton(30, (const char *)[v13 UTF8String], v50);

    if (!v14)
    {
      ne_log_obj();
      unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1876B1000, v15, OS_LOG_TYPE_ERROR, "Invalid IPv6 router", buf, 2u);
      }
    }
  }

  -[NEIPv6Settings networkPrefixLengths](self, "networkPrefixLengths");
  unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
  unsigned __int16 v17 = [v16 count];
  -[NEIPv6Settings addresses](self, "addresses");
  __int16 v18 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v19 = [v18 count];

  if (v17 != v19)
  {
    ne_log_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      -[NEIPv6Settings addresses](self, "addresses");
      uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v39 = [v38 count];
      -[NEIPv6Settings networkPrefixLengths](self, "networkPrefixLengths");
      unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v41 = [v40 count];
      *(_DWORD *)buf = 134218240;
      uint64_t v54 = v39;
      BOOL v55 = 2048;
      unint64_t v56 = v41;
      _os_log_error_impl( &dword_1876B1000,  v20,  OS_LOG_TYPE_ERROR,  "Missing networkPrefixLengths (address count = %lu, prefix length count = %lu)",  buf,  0x16u);
    }
  }

  -[NEIPv6Settings networkPrefixLengths](self, "networkPrefixLengths");
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  if (![v21 count]) {
    goto LABEL_21;
  }
  -[NEIPv6Settings networkPrefixLengths](self, "networkPrefixLengths");
  unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
  [v22 objectAtIndex:0];
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v24 = [v23 intValue];

  if (v24 >= 129)
  {
    ne_log_obj();
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1876B1000, (os_log_t)v21, OS_LOG_TYPE_ERROR, "Invalid IPv6 prefix length", buf, 2u);
    }

  unint64_t v8 = *MEMORY[0x18960CA58];
  [v4 objectForKeyedSubscript:*MEMORY[0x18960CA58]];
  unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v10 = isa_nsarray(v9);

  if (v10)
  {
    unint64_t v11 = [v4 objectForKeyedSubscript:v8];
    matchDomains = v5->_matchDomains;
    v5->_matchDomains = (NSArray *)v11;
  }

  unsigned __int16 v13 = *MEMORY[0x18960CA60];
  [v4 objectForKeyedSubscript:*MEMORY[0x18960CA60]];
  unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v15 = isa_nsarray(v14);

  if (v15)
  {
    unint64_t v16 = [v4 objectForKeyedSubscript:v13];
    useDNSServers = v5->_useDNSServers;
    v5->_useDNSServers = (NSArray *)v16;
  }

  __int16 v18 = *MEMORY[0x18960CA68];
  [v4 objectForKeyedSubscript:*MEMORY[0x18960CA68]];
  unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
  BOOL v20 = isa_nsstring(v19);

  if (v20)
  {
    uint64_t v21 = (void *)MEMORY[0x189604030];
    [v4 objectForKeyedSubscript:v18];
    unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v23 = [v21 URLWithString:v22];
    probeURL = v5->_probeURL;
    v5->_probeURL = (NSURL *)v23;
  }

  BOOL v25 = v5;

LABEL_15:
  return v5;
}

  packetDataArray = (uint64_t)v5->_packetDataArray;
  if (packetDataArray && v5->_packetLengths && v5->_packetProtocols)
  {
    for (i = 0LL; ; ++i)
    {
      if (i >= -[NSArray count](v4, "count"))
      {
        packetDataArray = (uint64_t)v5->_packetDataArray;
        goto LABEL_22;
      }

      -[NSArray objectAtIndexedSubscript:](v4, "objectAtIndexedSubscript:", i);
      unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
      [v12 data];
      unsigned __int16 v13 = (void *)objc_claimAutoreleasedReturnValue();

      if ((isa_nsdata(v13) & 1) == 0) {
        break;
      }
      unint64_t v14 = v13;
      v5->_packetDataArray[i] = (char *)[v14 bytes];
      v5->_packetLengths[i] = [v14 length];
      -[NSArray objectAtIndexedSubscript:](v4, "objectAtIndexedSubscript:", i);
      unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
      v5->_packetProtocols[i] = [v15 protocolFamily];
    }

    ne_log_obj();
    __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      BOOL v20 = 136315394;
      uint64_t v21 = "-[NEPacketTunnelFlow writePacketObjects:]";
      unint64_t v22 = 2048;
      uint64_t v23 = i;
      _os_log_error_impl( &dword_1876B1000,  v18,  OS_LOG_TYPE_ERROR,  "%s: object at index %lu of packets array is not an NSData",  (uint8_t *)&v20,  0x16u);
    }

    goto LABEL_29;
  }

  if (sysctlbyname("net.necp.drop_all_level", 0LL, 0LL, &v18, 4uLL))
  {
    ne_log_obj();
    char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      unint64_t v15 = v18;
      unint64_t v16 = __error();
      unsigned __int16 v17 = strerror(*v16);
      *(_DWORD *)buf = 136315650;
      BOOL v20 = "net.necp.drop_all_level";
      uint64_t v21 = 1024;
      unint64_t v22 = v15;
      uint64_t v23 = 2080;
      unint64_t v24 = v17;
      _os_log_error_impl(&dword_1876B1000, v7, OS_LOG_TYPE_ERROR, "Failed to set %s to %d: %s", buf, 0x1Cu);
    }
  }

  else
  {
    if (a2 != 1) {
      return 1LL;
    }
    [MEMORY[0x189604030] fileURLWithPath:@"/Library/Preferences/com.apple.networkextension.necp.plist" isDirectory:1];
    char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (v18)
    {
      unint64_t v10 = (void *)[objc_alloc(MEMORY[0x189603F68]) initWithContentsOfURL:v7];
      unint64_t v11 = (id)[v10 mutableCopy];
      [v11 setObject:cf1 forKeyedSubscript:@"drop_all_level"];
    }

    else
    {
      unint64_t v11 = objc_alloc_init(MEMORY[0x189603FC8]);
      [v11 setObject:@"Unknown" forKeyedSubscript:@"drop_all_level"];
    }

    unint64_t v12 = [v11 writeToURL:v7 atomically:1];
    ne_log_obj();
    unsigned __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v14 = v13;
    if ((v12 & 1) != 0)
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138412290;
        BOOL v20 = (const char *)v7;
        _os_log_debug_impl(&dword_1876B1000, v14, OS_LOG_TYPE_DEBUG, "Saved NECP drop level to <%@>", buf, 0xCu);
      }

      unint64_t v8 = 1LL;
      goto LABEL_12;
    }

    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      BOOL v20 = (const char *)v7;
      _os_log_error_impl(&dword_1876B1000, v14, OS_LOG_TYPE_ERROR, "Failed to save NECP drop level to <%@>", buf, 0xCu);
    }
  }

  unint64_t v8 = 0LL;
LABEL_12:

  return v8;
}

    return 0;
  }

  return v4;
}

  if (a3) {
    *a3 = if_nametoindex(a2);
  }
  if (a4)
  {
    if (!strncmp(a2, "utun", 4uLL))
    {
      unint64_t v14 = 1LL;
    }

    else if (!strncmp(a2, "ipsec", 5uLL))
    {
      unint64_t v14 = 2LL;
    }

    else
    {
      unsigned __int16 v13 = strncmp(a2, "utap", 4uLL);
      unint64_t v14 = 3LL;
      if (v13) {
        unint64_t v14 = 0LL;
      }
    }

    *a4 = v14;
  }

  if (a5)
  {
    uint64_t v21 = 4;
    if (getsockopt(a1, 2, 1, a5, &v21))
    {
      __int16 v18 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        unint64_t v19 = *__error();
        *(_DWORD *)buf = 67109120;
        LODWORD(v24) = v19;
        _os_log_error_impl( &dword_1876B1000,  v18,  OS_LOG_TYPE_ERROR,  "getsockopt flags failed on kernel control socket (errno = %d)\n",  buf,  8u);
      }

      return 0LL;
    }
  }

  return 1LL;
}
}

  unint64_t v12 = a4 & 0xFFFFFFFFFFFFFFF7LL;
  -[NEVPNProtocolIPSec sharedSecretKeychainItem](self, "sharedSecretKeychainItem");
  unsigned __int16 v13 = (void *)objc_claimAutoreleasedReturnValue();
  [v9 appendPrettyObject:v13 withName:@"sharedSecret" andIndent:v5 options:a4 & 0xFFFFFFFFFFFFFFF7];

  -[NEVPNProtocolIPSec sharedSecretReference](self, "sharedSecretReference");
  unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
  [v9 appendPrettyObject:v14 withName:@"sharedSecretReference" andIndent:v5 options:v10];

  -[NEVPNProtocolIPSec localIdentifier](self, "localIdentifier");
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v16 = a4 | 9;
  [v9 appendPrettyObject:v15 withName:@"localIdentifier" andIndent:v5 options:v16];

  -[NEVPNProtocolIPSec remoteIdentifier](self, "remoteIdentifier");
  unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
  [v9 appendPrettyObject:v17 withName:@"remoteIdentifier" andIndent:v5 options:v16];

  objc_msgSend( v9,  "appendPrettyBOOL:withName:andIndent:options:",  -[NEVPNProtocolIPSec useExtendedAuthentication](self, "useExtendedAuthentication"),  @"useExtendedAuthentication",  v5,  v10);
  -[NEVPNProtocolIPSec legacyProposals](self, "legacyProposals");
  __int16 v18 = (void *)objc_claimAutoreleasedReturnValue();
  [v9 appendPrettyObject:v18 withName:@"legacyProposalParameters" andIndent:v5 options:v12];

  -[NEVPNProtocolIPSec legacyExchangeMode](self, "legacyExchangeMode");
  unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
  [v9 appendPrettyObject:v19 withName:@"legacyExchangeMode" andIndent:v5 options:v12];

  objc_msgSend( v9,  "appendPrettyBOOL:withName:andIndent:options:",  -[NEVPNProtocolIPSec extendedAuthPasswordPrompt](self, "extendedAuthPasswordPrompt"),  @"extendedAuthPasswordPrompt",  v5,  v12);
  return v9;
}

void sub_1876C0838( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

LABEL_40:
}

      uint64_t v37 = 0;
      uint64_t v38 = v27;
LABEL_43:
      [v38 appRules];
      unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
      if (v39)
      {
        [v13 externalIdentifier];
        unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();

        if (v40)
        {
          uint64_t v74 = v37;
          unint64_t v77 = (void *)[v39 mutableCopy];
          unint64_t v41 = [v39 count];
          if (v41 >= 1)
          {
            unint64_t v42 = v41 + 1;
            while (1)
            {
              int64_t v43 = v42 - 2;
              [v39 objectAtIndexedSubscript:v42 - 2];
              uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
              uint64_t v45 = *(void **)(a1 + 48);
              [v44 matchSigningIdentifier];
              uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
              LODWORD(v45) = [v45 containsObject:v46];

              if ((_DWORD)v45) {
                break;
              }

              --v42;
              a1 = v79;
              if (v42 <= 1) {
                goto LABEL_54;
              }
            }

            ne_log_obj();
            int64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
            {
              [v44 matchSigningIdentifier];
              uint64_t v48 = (char *)objc_claimAutoreleasedReturnValue();
              [v13 name];
              uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138412546;
              uint64_t v85 = v48;
              v86 = 2112;
              v87 = v49;
              _os_log_impl( &dword_1876B1000,  v47,  OS_LOG_TYPE_INFO,  "Removing app rule %@ from configuration %@ because the corresponding application has been removed",  buf,  0x16u);
            }

            [v77 removeObjectAtIndex:v43];
            a1 = v79;
          }

    uint64_t v51 = 0LL;
    goto LABEL_41;
  }

  uint64_t v49 = (NSMutableSet *)objc_alloc_init(MEMORY[0x189603FE0]);
  browseAssertions = v4->_browseAssertions;
  v4->_browseAssertions = v49;

  uint64_t v51 = v4;
LABEL_41:

  return v51;
}

        return 109LL;
      }

      unint64_t v26 = -[NEHotspotConfiguration hs20Settings](self, "hs20Settings");
      if (v26)
      {
        __int16 v27 = (void *)v26;
        -[NEHotspotConfiguration hs20Settings](self, "hs20Settings");
        unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          -[NEHotspotConfiguration hs20Settings](self, "hs20Settings");
          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
          [v29 domainName];
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
          if ([v30 length])
          {
            -[NEHotspotConfiguration hs20Settings](self, "hs20Settings");
            unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
            [v31 domainName];
            unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
            unint64_t v33 = [v32 length];

            if (v33 <= 0x80)
            {
              uint64_t v34 = -[NEHotspotConfiguration eapSettings](self, "eapSettings");
              if (v34)
              {
                uint64_t v35 = (void *)v34;
                -[NEHotspotConfiguration eapSettings](self, "eapSettings");
                unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  uint64_t v37 = -[NEHotspotConfiguration validateEAPSettings]((uint64_t)self);

                  if ((v37 & 1) != 0)
                  {
                    -[NEHotspotConfiguration hs20Settings](self, "hs20Settings");
                    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
                    unint64_t v39 = [v38 isRoamingEnabled];

                    if (v39)
                    {
                      -[NEHotspotConfiguration hs20Settings](self, "hs20Settings");
                      unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
                      [v40 roamingConsortiumOIs];
                      unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
                      if ([v41 count])
                      {
                      }

                      else
                      {
                        -[NEHotspotConfiguration hs20Settings](self, "hs20Settings");
                        uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
                        [v63 naiRealmNames];
                        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
                        uint64_t v65 = [v64 count];

                        if (!v65)
                        {
                          ne_log_obj();
                          v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 138412290;
                            v102 = (id)objc_opt_class();
                            unint64_t v91 = v102;
                            _os_log_error_impl( &dword_1876B1000,  v87,  OS_LOG_TYPE_ERROR,  "%@ invalid HS2.0 configuration(roaming consortium OIs/NAI realms not provided).",  buf,  0xCu);
                          }

                          return 105LL;
                        }
                      }
                    }

                    -[NEHotspotConfiguration hs20Settings](self, "hs20Settings");
                    uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue();
                    [v66 MCCAndMNCs];
                    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
                    uint64_t v68 = [v67 count];

                    if (!v68) {
                      goto LABEL_78;
                    }
                    v98 = 0u;
                    v99 = 0u;
                    v96 = 0u;
                    v97 = 0u;
                    -[NEHotspotConfiguration hs20Settings](self, "hs20Settings");
                    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();
                    [v69 MCCAndMNCs];
                    size_t v70 = (void *)objc_claimAutoreleasedReturnValue();

                    unint64_t v71 = [v70 countByEnumeratingWithState:&v96 objects:v100 count:16];
                    if (!v71)
                    {
LABEL_114:

                      goto LABEL_78;
                    }

                    uint64_t v72 = v71;
                    unint64_t v73 = *(void *)v97;
                    uint64_t v74 = 0x189607000uLL;
                    unint64_t v75 = 0x189607000uLL;
                    v94 = *(void *)v97;
                    v95 = v70;
                    while (1)
                    {
                      uint64_t v76 = 0LL;
LABEL_99:
                      if (*(void *)v97 != v73) {
                        objc_enumerationMutation(v70);
                      }
                      unint64_t v77 = *(void **)(*((void *)&v96 + 1) + 8 * v76);
                      unint64_t v78 = v74;
                      objc_opt_class();
                      if ((objc_opt_isKindOfClass() & 1) == 0 || [v77 length] != 6) {
                        break;
                      }
                      uint64_t v79 = v75;
                      [*(id *)(v75 + 2064) characterSetWithCharactersInString:@"0123456789"];
                      uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();
                      for (i = 0LL; i != 6; ++i)
                      {
                        uint64_t v82 = objc_msgSend(v77, "characterAtIndex:", i, v94);
                        v83 = [v80 characterIsMember:v82];
                        if (i == 3)
                        {
                          if ((_DWORD)v82 == 70) {
                            uint64_t v84 = 1;
                          }
                          else {
                            uint64_t v84 = v83;
                          }
                          if ((v84 & 1) == 0)
                          {
                            ne_log_obj();
                            uint64_t v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
                            {
LABEL_126:
                              v89 = (void *)objc_opt_class();
                              *(_DWORD *)buf = 138412290;
                              v102 = v89;
                              CFErrorRef v90 = v89;
                              _os_log_error_impl( &dword_1876B1000,  v85,  OS_LOG_TYPE_ERROR,  "%@ invalid HS2.0 configuration.",  buf,  0xCu);
                            }

  unint64_t v2 = 0x189604000LL;
LABEL_41:
  [(id)v1 eapSettings];
  int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
  [v47 setTlsClientCertificateRequired:1];

LABEL_42:
  [(id)v1 eapSettings];
  uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue();
  [v48 trustedServerCertificateReferences];
  uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v50 = [v49 count];

  [(id)v1 eapSettings];
  uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v52 = v51;
  if (!v50)
  {
    [v51 trustedServerNames];
    uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v62 = [v61 count];

    if (!v62)
    {
      ne_log_obj();
      unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_ERROR)) {
        goto LABEL_53;
      }
      uint64_t v63 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412290;
      v170 = v63;
      unint64_t v56 = v63;
      unint64_t v57 = "%@ EAP settings must have either trusted server certificates or trusted server names configured.";
      goto LABEL_89;
    }

    goto LABEL_72;
  }

  [v51 trustedServerCertificateReferences];
  uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v54 = [v53 count];

  if (v54 < 0xB)
  {
    objc_msgSend( MEMORY[0x189603FC8],  "dictionaryWithObjectsAndKeys:",  *MEMORY[0x189604DE8],  *MEMORY[0x18960BE30],  *MEMORY[0x18960BB40],  *MEMORY[0x18960BB38],  0);
    uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue();
    *(_OWORD *)certificateRef = 0u;
    v164 = 0u;
    v165 = 0u;
    v166 = 0u;
    [(id)v1 eapSettings];
    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
    [v67 trustedServerCertificateReferences];
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue();

    uint64_t v69 = [v68 countByEnumeratingWithState:certificateRef objects:buf count:16];
    if (v69)
    {
      size_t v70 = v69;
      unint64_t v71 = *(void *)v164;
      uint64_t v72 = *MEMORY[0x18960BE80];
LABEL_61:
      unint64_t v73 = 0LL;
      while (1)
      {
        if (*(void *)v164 != v71) {
          objc_enumerationMutation(v68);
        }
        uint64_t v74 = (void *)*((void *)certificateRef[1] + v73);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0 || ![v74 length]) {
          break;
        }
        cf = 0LL;
        [v66 setObject:v74 forKeyedSubscript:v72];
        if (SecItemCopyMatching((CFDictionaryRef)v66, &cf))
        {
          ne_log_obj();
          v121 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
          {
            v122 = (void *)objc_opt_class();
            *(_DWORD *)trust = 138412290;
            *(void *)&trust[4] = v122;
            v123 = v122;
            v124 = "%@ failed to find the certificate item in the keychain.";
            goto LABEL_136;
          }

      a1 = 0LL;
LABEL_120:

LABEL_121:
      goto LABEL_122;
    }

    if (v20)
    {
      unint64_t v26 = v20[8];
      if ([v23 count] < v26)
      {
        ne_log_obj();
        __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          unint64_t v28 = (char *)[(id)a1 copyShortDescription];
          *(_DWORD *)buf = 138412290;
          v161 = v28;
          uint64_t v29 = "%@ Child SA proposal out of range";
LABEL_69:
          _os_log_error_impl(&dword_1876B1000, v27, OS_LOG_TYPE_ERROR, v29, buf, 0xCu);

          goto LABEL_40;
        }

        goto LABEL_40;
      }

      unint64_t v36 = v20[8];
    }

    else
    {
      [v23 count];
      unint64_t v36 = 0;
    }

    [v23 objectAtIndexedSubscript:v36 - 1];
    __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if ((-[NEIKEv2ChildSAProposal matchesLocalProposal:preferRemoteProposal:checkKEMethod:]((uint64_t)v20, v27, 0, 1) & 1) != 0)
    {
      uint64_t v37 = -[NEIKEv2ChildSAProposal copyFromRemote:preferRemoteProposal:checkKEMethod:](v27, v20, 0, 1);
      objc_setProperty_atomic(v5, v38, v37, 56LL);

      unint64_t v40 = objc_getProperty(v5, v39, 56LL, 1);
      if (v40)
      {
        objc_setProperty_atomic(v5, v41, 0LL, 176LL);
        *((_BYTE *)v5 + 9) = 1;
        unint64_t v42 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
        objc_getProperty((id)a1, v43, 112LL, 1);
        uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();

        if (v44)
        {
          objc_getProperty((id)a1, v45, 112LL, 1);
          uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v48 = v46;
          if (v46) {
            uint64_t v46 = objc_getProperty(v46, v47, 24LL, 1);
          }
          uint64_t v49 = v46;

          if (v49)
          {
            WeakRetained = objc_loadWeakRetained(v5 + 3);
            uint64_t v52 = WeakRetained;
            if (WeakRetained) {
              WeakRetained = objc_getProperty(WeakRetained, v51, 80LL, 1);
            }
            uint64_t v53 = WeakRetained;
            uint64_t v54 = [v53 strictNonceSizeChecks];

            if (v54)
            {
              objc_getProperty((id)a1, v55, 112LL, 1);
              unint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
              unint64_t v58 = v56;
              if (v56) {
                unint64_t v56 = objc_getProperty(v56, v57, 24LL, 1);
              }
              uint64_t v59 = v56;
              uint64_t v60 = [v59 length];

              if ((unint64_t)(v60 - 257) <= 0xFFFFFFFFFFFFFF0ELL)
              {
                ne_log_obj();
                uint64_t v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v63 = (char *)[(id)a1 copyShortDescription];
                  *(_DWORD *)buf = 138412546;
                  v161 = v63;
                  v162 = 2048;
                  v163 = v60;
                  uint64_t v64 = "%@ NONCE data length %zu is out of bounds";
                  uint64_t v65 = v62;
                  uint64_t v66 = 22;
LABEL_112:
                  _os_log_error_impl(&dword_1876B1000, v65, OS_LOG_TYPE_ERROR, v64, buf, v66);
LABEL_113:
                }

LABEL_41:
        uint64_t v38 = 0LL;
        goto LABEL_42;
      }
    }
  }

  if ((v12 & 1) != 0)
  {
    -[NEIKEv2IKESA initiatorSPI](v5, v17);
    unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESA responderSPI](v5, v25);
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
    if (v5) {
      unint64_t v28 = objc_getProperty(v5, v26, 64LL, 1);
    }
    else {
      unint64_t v28 = 0LL;
    }
    uint64_t v29 = v28;
    unint64_t v16 = (os_log_s *)+[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  v24,  v27,  v29);

    if (-[NEIKEv2Packet addNotification:data:](v7, 0x4004uLL, v16))
    {
      -[NEIKEv2IKESA initiatorSPI](v5, v30);
      unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEIKEv2IKESA responderSPI](v5, v32);
      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
      if (v5) {
        uint64_t v35 = objc_getProperty(v5, v33, 72LL, 1);
      }
      else {
        uint64_t v35 = 0LL;
      }
      unint64_t v36 = v35;
      uint64_t v37 = (os_log_s *)+[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  v31,  v34,  v36);

      if (-[NEIKEv2Packet addNotification:data:](v7, 0x4005uLL, v37))
      {

        goto LABEL_33;
      }

      ne_log_obj();
      unint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( &dword_1876B1000,  v40,  OS_LOG_TYPE_FAULT,  "[packet addNotification:NEIKEv2NotifyTypeNATDetectionDestinationIP] failed",  buf,  2u);
      }

      goto LABEL_40;
    }

    ne_log_obj();
    uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      unint64_t v39 = "[packet addNotification:NEIKEv2NotifyTypeNATDetectionSourceIP] failed";
LABEL_44:
      _os_log_fault_impl(&dword_1876B1000, v37, OS_LOG_TYPE_FAULT, v39, buf, 2u);
      goto LABEL_40;
    }

    goto LABEL_40;
  }

LABEL_41:
          unint64_t v24 = 0LL;
          goto LABEL_42;
        }

        unint64_t v22 = *v12;
        switch(v22)
        {
          case 3:
            if (v12[1])
            {
              uint64_t v23 = (void *)[objc_alloc(NSString) initWithBytes:v12 + 2 length:v12[1] encoding:4];
              [MEMORY[0x189608DF8] endpointWithHostname:v23 port:@"0"];
              unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();

LABEL_42:
              goto LABEL_43;
            }

            ne_log_obj();
            unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
              goto LABEL_40;
            }
            unint64_t v28 = v12[1];
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v28;
            __int16 v18 = "Invalid FQDN length %u";
            break;
          case 2:
            memset(buf, 0, sizeof(buf));
            unint64_t v36 = 0;
            if ((_DWORD)v14 == 16)
            {
              *(_WORD *)buf = 7708;
              *(_OWORD *)&buf[8] = *(_OWORD *)(v12 + 2);
              goto LABEL_27;
            }

            ne_log_obj();
            unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
              goto LABEL_40;
            }
            __int16 v27 = v12[1];
            uint64_t v37 = 67109120;
            uint64_t v38 = v27;
            __int16 v18 = "Invalid IPv6 address length %u";
            goto LABEL_34;
          case 1:
            *(void *)buf = 0LL;
            *(void *)&buf[8] = 0LL;
            if ((_DWORD)v14 == 4)
            {
              *(_WORD *)buf = 528;
              *(_DWORD *)&buf[4] = *(_DWORD *)(v12 + 2);
LABEL_27:
              [MEMORY[0x189608DE8] endpointWithAddress:buf];
              unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
              goto LABEL_42;
            }

            ne_log_obj();
            unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
              goto LABEL_40;
            }
            unint64_t v26 = v12[1];
            uint64_t v37 = 67109120;
            uint64_t v38 = v26;
            __int16 v18 = "Invalid IPv4 address length %u";
LABEL_34:
            unint64_t v19 = (uint8_t *)&v37;
LABEL_38:
            BOOL v20 = v15;
            uint64_t v21 = 8;
            goto LABEL_39;
          default:
            ne_log_obj();
            unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
              goto LABEL_40;
            }
            BOOL v25 = *v12;
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v25;
            __int16 v18 = "Server redirect has invalid type %u";
            break;
        }

        unint64_t v19 = buf;
        goto LABEL_38;
      }

      ne_log_obj();
      unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_FAULT))
      {
LABEL_47:

        goto LABEL_48;
      }

      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = "-[NEIKEv2Session reportServerRedirect:]";
      unint64_t v11 = "%s called with null self.ikeSA";
    }

    else
    {
      ne_log_obj();
      unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_FAULT)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = "-[NEIKEv2Session reportServerRedirect:]";
      unint64_t v11 = "%s called with null packet";
    }

    _os_log_fault_impl(&dword_1876B1000, (os_log_t)v8, OS_LOG_TYPE_FAULT, v11, buf, 0xCu);
    goto LABEL_47;
  }
  }
}

    unint64_t v22 = v13;
    goto LABEL_39;
  }

    unint64_t v22 = v13;
    goto LABEL_39;
  }

            ++v18;
          }

          while (v16 != v18);
          uint64_t v49 = [obj countByEnumeratingWithState:&v61 objects:v65 count:16];
          unint64_t v16 = v49;
        }

        while (v49);
      }

      uint64_t v50 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithArray:v58];
      [v59 setAppRules:v50];

      [v59 configuration];
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      [v51 appVPN];
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
      [v52 excludedDomains];
      uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v54 = [v53 count];

      if (v54)
      {
        [v59 configuration];
        BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();
        [v55 appVPN];
        unint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
        [v56 excludedDomains];
        unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
        [v59 setExcludedDomains:v57];
      }
    }
  }
}

LABEL_14:
        objc_msgSend(objc_getProperty(a1, v9, 16, 1), "setObject:forKeyedSubscript:", v6, v7);
LABEL_15:
      }
    }

    else
    {
      ne_log_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
      {
        unint64_t v19 = 136315138;
        BOOL v20 = "-[NEAppInfoCache addAppInfoToCache:]";
        _os_log_fault_impl( &dword_1876B1000,  v18,  OS_LOG_TYPE_FAULT,  "%s called with null appInfo",  (uint8_t *)&v19,  0xCu);
      }
    }
  }
}

    LOBYTE(value) = 0;
LABEL_15:

    goto LABEL_16;
  }

  if (a3 == 16)
  {
    ne_log_obj();
    unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      unint64_t v10 = "App wasn't foreground, didn't show alert";
      goto LABEL_13;
    }

    goto LABEL_14;
  }

  if (!a3 && v6 && MEMORY[0x1895ADD58](v6) == MEMORY[0x1895F9228])
  {
    value = xpc_BOOL_get_value(v6);
    ne_log_obj();
    unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v16) = value;
      _os_log_impl(&dword_1876B1000, v9, OS_LOG_TYPE_INFO, "App got response: %u", buf, 8u);
    }

    goto LABEL_15;
  }

  LOBYTE(value) = 0;
LABEL_16:
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  v12[2] = __108__NEConfigurationManager_showLocalNetworkAlertForApp_pid_uuid_query_hasEntitlement_completionQueue_handler___block_invoke_197;
  v12[3] = &unk_18A08FC50;
  unint64_t v14 = value;
  unint64_t v11 = *(dispatch_queue_s **)(a1 + 32);
  unsigned __int16 v13 = *(id *)(a1 + 40);
  dispatch_async(v11, v12);
}

                goto LABEL_53;
              }
            }

  return 0LL;
}

  return ErrorInternal;
}

        return 0LL;
      }

      unint64_t v32 = objc_msgSend(objc_getProperty(self, v12, 80, 1), "randomizeLocalPort");
      uint64_t v34 = objc_getProperty(self, v33, 72LL, 1);
      unint64_t v36 = objc_getProperty(self, v35, 64LL, 1);
      uint64_t v38 = objc_getProperty(self, v37, 304LL, 1);
      unint64_t v40 = objc_getProperty(self, v39, 536LL, 1);
      unint64_t v42 = objc_getProperty(self, v41, 552LL, 1);
      if (v32) {
        int64_t v43 = 0;
      }
      else {
        int64_t v43 = 4500;
      }
      uint64_t v44 = +[NEIKEv2Transport createTransport:remote:local:localPort:boundInterface:queue:socketGetBlock:packetDelegate:]( (uint64_t)&OBJC_CLASS___NEIKEv2Transport,  1uLL,  v34,  v36,  v43,  v38,  v40,  v42,  WeakRetained);

      objc_setProperty_atomic(self, v45, v44, 472LL);
      int64_t v47 = objc_getProperty(self, v46, 472LL, 1);
      uint64_t v49 = objc_getProperty(self, v48, 32LL, 1);
      -[NEIKEv2Transport addClient:delegate:](v47, v49, v6);
    }

    Property = objc_getProperty(self, v10, 472LL, 1);
  }

  else
  {
    if (!objc_getProperty(self, a2, 464LL, 1))
    {
      size_t v4 = objc_loadWeakRetained(self + 70);
      unint64_t v6 = objc_loadWeakRetained(self + 68);
      if ((*((_BYTE *)self + 25) & 1) != 0 && !v4)
      {
        ne_log_obj();
        char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          uint64_t v50 = 0;
          unint64_t v8 = (uint8_t *)&v50;
LABEL_28:
          _os_log_error_impl( &dword_1876B1000,  v7,  OS_LOG_TYPE_ERROR,  "Cannot create transport for packet delegate, delegate no longer valid",  v8,  2u);
          goto LABEL_14;
        }

        goto LABEL_14;
      }

      unint64_t v14 = objc_msgSend(objc_getProperty(self, v5, 80, 1), "randomizeLocalPort");
      unint64_t v16 = objc_getProperty(self, v15, 72LL, 1);
      __int16 v18 = objc_getProperty(self, v17, 64LL, 1);
      BOOL v20 = objc_getProperty(self, v19, 304LL, 1);
      unint64_t v22 = objc_getProperty(self, v21, 536LL, 1);
      unint64_t v24 = objc_getProperty(self, v23, 552LL, 1);
      if (v14) {
        BOOL v25 = 0;
      }
      else {
        BOOL v25 = 500;
      }
      unint64_t v26 = +[NEIKEv2Transport createTransport:remote:local:localPort:boundInterface:queue:socketGetBlock:packetDelegate:]( (uint64_t)&OBJC_CLASS___NEIKEv2Transport,  0LL,  v16,  v18,  v25,  v20,  v22,  v24,  v4);

      objc_setProperty_atomic(self, v27, v26, 464LL);
      uint64_t v29 = objc_getProperty(self, v28, 464LL, 1);
      unint64_t v31 = objc_getProperty(self, v30, 32LL, 1);
      -[NEIKEv2Transport addClient:delegate:](v29, v31, v6);
    }

    Property = objc_getProperty(self, v3, 464LL, 1);
  }

  return Property;
}

      goto LABEL_15;
    }

    char v7 = *(nw_listener **)(a1 + 48);
    if (v7) {
      nw_listener_cancel(v7);
    }
    unint64_t v8 = nw_listener_create(v5);
    unint64_t v9 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = v8;

    unint64_t v10 = *(void **)(a1 + 48);
    if (!v10)
    {
      ne_log_obj();
      unint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        LOWORD(location) = 0;
        _os_log_fault_impl( &dword_1876B1000,  v6,  OS_LOG_TYPE_FAULT,  "nw_listener_create failed",  (uint8_t *)&location,  2u);
      }

      goto LABEL_14;
    }

    unint64_t v11 = v10;
    [(id)a1 listenerQueue];
    unint64_t v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
    nw_listener_set_queue(v11, v12);

    objc_initWeak(&location, (id)a1);
    unsigned __int16 v13 = *(id *)(a1 + 48);
    unint64_t v14 = (nw_listener *)*(id *)(a1 + 48);
    unint64_t v15 = MEMORY[0x1895F87A8];
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 3221225472LL;
    handler[2] = __56__NEIKEv2Listener_createListenerWithParameters_attempt___block_invoke;
    handler[3] = &unk_18A08D370;
    objc_copyWeak(&v28, &location);
    unint64_t v16 = v13;
    unint64_t v26 = v16;
    uint64_t v29 = a3;
    __int16 v27 = v5;
    nw_listener_set_state_changed_handler(v14, handler);

    unsigned __int16 v17 = (nw_listener *)*(id *)(a1 + 48);
    v22[0] = v15;
    v22[1] = 3221225472LL;
    v22[2] = __56__NEIKEv2Listener_createListenerWithParameters_attempt___block_invoke_4;
    v22[3] = &unk_18A08D398;
    objc_copyWeak(&v24, &location);
    __int16 v18 = v16;
    uint64_t v23 = v18;
    nw_listener_set_new_connection_handler(v17, v22);

    unint64_t v19 = (nw_listener *)*(id *)(a1 + 48);
    nw_listener_start(v19);

    ne_log_large_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v21 = 0;
      _os_log_impl(&dword_1876B1000, v20, OS_LOG_TYPE_DEFAULT, "Created IKE listener", v21, 2u);
    }

    objc_destroyWeak(&v24);
    objc_destroyWeak(&v28);

    objc_destroyWeak(&location);
  }
}

LABEL_15:
  return v12;
}

    unint64_t v12 = 0LL;
    goto LABEL_15;
  }

  if (!NEGetValueWithType((const __CFDictionary *)a1, @"IKEVersion", CFNUMBER_TYPE))
  {
    ne_log_obj();
    unint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v250 = "NEIPSecIKEValidateSessionDictionary";
      v251 = 1024;
      v252 = 1375;
      v253 = 2112;
      v254 = @"IKEVersion";
      v255 = 2048;
      v256 = CFNUMBER_TYPE;
      unint64_t v14 = "%s:%d: value for key %@ is missing or type != %lu";
      unint64_t v15 = v11;
      unint64_t v16 = 38;
LABEL_22:
      _os_log_error_impl(&dword_1876B1000, v15, OS_LOG_TYPE_ERROR, v14, buf, v16);
      goto LABEL_14;
    }

    goto LABEL_14;
  }

  valuePtr = 0;
  size_t v4 = (const __CFNumber *)NEGetValueWithType((const __CFDictionary *)a1, @"IKEVersion", CFNUMBER_TYPE);
  CFNumberGetValue(v4, kCFNumberIntType, &valuePtr);
  if (valuePtr != 2)
  {
    ne_log_obj();
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v250 = "NEIPSecIKEValidateSessionDictionary";
      v251 = 1024;
      v252 = 1380;
      _os_log_error_impl(&dword_1876B1000, v5, OS_LOG_TYPE_ERROR, "%s:%d: Session IKE version is not 2", buf, 0x12u);
    }

    unint64_t v12 = 0LL;
    goto LABEL_569;
  }

  unint64_t v5 = a1;
  if (CFDictionaryContainsKey(v5, @"LocalIdentifier")
    && !NEGetValueWithType(v5, @"LocalIdentifier", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      goto LABEL_567;
    }
    *(_DWORD *)buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    v251 = 1024;
    v252 = 1387;
    v253 = 2112;
    v254 = @"LocalIdentifier";
    v255 = 2048;
    v256 = CFSTRING_TYPE;
    __int16 v18 = "%s:%d: type of value for key %@ != %lu";
LABEL_52:
    _os_log_error_impl(&dword_1876B1000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0x26u);
    goto LABEL_567;
  }

  if (!CFDictionaryContainsKey(v5, @"LocalIdentifier")) {
    goto LABEL_44;
  }
  if (!NEGetValueWithType(v5, @"LocalIdentifierType", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      goto LABEL_567;
    }
    *(_DWORD *)buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    v251 = 1024;
    v252 = 1389;
    v253 = 2112;
    v254 = @"LocalIdentifierType";
    v255 = 2048;
    v256 = CFSTRING_TYPE;
    __int16 v18 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_52;
  }

  -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalIdentifier");
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  [v6 dataUsingEncoding:4];
  char v7 = (void *)objc_claimAutoreleasedReturnValue();

  -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalIdentifierType");
  unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v9 = [v8 isEqualToString:@"IDFQDN"];

  if ((v9 & 1) == 0)
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalIdentifierType");
    unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = [v19 isEqualToString:@"IDUserFQDN"];

    if ((v20 & 1) != 0)
    {
      unint64_t v10 = 3LL;
      goto LABEL_43;
    }

    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalIdentifierType");
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v22 = [v21 isEqualToString:@"ADASN1DN"];

    if ((v22 & 1) != 0)
    {
      unint64_t v10 = 9LL;
      goto LABEL_43;
    }

    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalIdentifierType");
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v24 = [v23 isEqualToString:@"KeyID"];

    if ((v24 & 1) != 0)
    {
      unint64_t v10 = 11LL;
      goto LABEL_43;
    }

    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalIdentifierType");
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v26 = [v25 isEqualToString:@"IDAddress"];

    if (!v26
      || (-[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalIdentifier"),
          __int16 v27 = (__CFString *)objc_claimAutoreleasedReturnValue(),
          unint64_t v28 = (unsigned __int8 *)NECreateAddressStructFromString(v27, 0LL, 0LL),
          v27,
          !v28))
    {
      unint64_t v10 = 0LL;
      goto LABEL_43;
    }

    uint64_t v29 = v28[1];
    if (v29 == 30)
    {
      uint64_t v30 = [MEMORY[0x189603F48] dataWithBytes:v28 + 8 length:16];
      unint64_t v10 = 5LL;
    }

    else
    {
      if (v29 != 2)
      {
        unint64_t v10 = 0LL;
        goto LABEL_42;
      }

      uint64_t v30 = [MEMORY[0x189603F48] dataWithBytes:v28 + 4 length:4];
      unint64_t v10 = 1LL;
    }

    char v7 = (void *)v30;
LABEL_42:
    free(v28);
    goto LABEL_43;
  }

  unint64_t v10 = 2LL;
LABEL_43:
  unint64_t v31 = +[NEIKEv2Identifier createIdentifierWithType:data:]( &OBJC_CLASS___NEIKEv2Identifier,  "createIdentifierWithType:data:",  v10,  v7);
  -[NEIKEv2SessionConfiguration setLocalIdentifier:](v2, "setLocalIdentifier:", v31);

LABEL_44:
  if (!NEGetValueWithType(v5, @"RemoteIdentifier", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      goto LABEL_567;
    }
    *(_DWORD *)buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    v251 = 1024;
    v252 = 1421;
    v253 = 2112;
    v254 = @"RemoteIdentifier";
    v255 = 2048;
    v256 = CFSTRING_TYPE;
    __int16 v18 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_52;
  }

  if (!NEGetValueWithType(v5, @"RemoteIdentifierType", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v250 = "NEIPSecIKEValidateSessionDictionary";
      v251 = 1024;
      v252 = 1422;
      v253 = 2112;
      v254 = @"RemoteIdentifierType";
      v255 = 2048;
      v256 = CFSTRING_TYPE;
      __int16 v18 = "%s:%d: value for key %@ is missing or type != %lu";
      goto LABEL_52;
    }

      objc_msgSend(v6, "addObject:", v14, v25);

      ++v12;
    }

    while (v10 != v12);
    uint64_t v23 = [v8 countByEnumeratingWithState:&v27 objects:v33 count:16];
    unint64_t v10 = v23;
  }

  while (v23);
LABEL_27:

  ne_log_obj();
  unint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    unint64_t v32 = v6;
    _os_log_debug_impl(&dword_1876B1000, v24, OS_LOG_TYPE_DEBUG, "Updating configuration with %@", buf, 0xCu);
  }

  WeakRetained = v25;
  ((void (*)(void *, void, uint64_t, id, uint64_t))[v25 clientCallback])( v25,  0,  4608,  v6,  objc_msgSend(v25, "clientCallbackInfo"));

  unint64_t v3 = v26;
LABEL_30:
}
}

  return v11;
}

    unint64_t v31 = 0u;
    unint64_t v32 = 0u;
    uint64_t v29 = 0u;
    uint64_t v30 = 0u;
    unint64_t v11 = objc_getProperty(v10, v18, 32LL, 1);
    unint64_t v19 = [v11 countByEnumeratingWithState:&v29 objects:v47 count:16];
    if (v19)
    {
      BOOL v20 = v19;
      uint64_t v21 = *(void *)v30;
      do
      {
        unint64_t v22 = 0LL;
        do
        {
          if (*(void *)v30 != v21) {
            objc_enumerationMutation(v11);
          }
          unint64_t v16 = *(_DWORD **)(*((void *)&v29 + 1) + 8 * v22);
          if (v16)
          {
            if (v16[12] == a2) {
              goto LABEL_28;
            }
          }

          else if (!a2)
          {
            goto LABEL_26;
          }

          ++v22;
        }

        while (v20 != v22);
        uint64_t v23 = [v11 countByEnumeratingWithState:&v29 objects:v47 count:16];
        BOOL v20 = v23;
      }

      while (v23);
    }

  return v26;
}
}
  }

LABEL_15:
  return v16;
}

void sub_1876C1CFC(_Unwind_Exception *a1)
{
}

LABEL_23:
      }

      unint64_t v9 = [v8 countByEnumeratingWithState:&v38 objects:v46 count:16];
      if (!v9)
      {
LABEL_25:

        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        block[2] = __73__NETransparentProxyManager_loadAllFromPreferencesWithCompletionHandler___block_invoke_8;
        block[3] = &unk_18A0904A8;
        uint64_t v34 = v42;
        unint64_t v32 = v29;
        unint64_t v33 = *(id *)(a1 + 32);
        dispatch_group_notify(group, MEMORY[0x1895F8AE0], block);

        _Block_object_dispose(v42, 8);
        char v7 = v29;
        goto LABEL_26;
      }
    }
  }

  +[NEVPNManager mapError:]((uint64_t)&OBJC_CLASS___NEVPNManager, v5);
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  char v7 = v29;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();

LABEL_26:
}

  objc_sync_exit(v9);
}
}

    unint64_t v16 = 0LL;
    goto LABEL_12;
  }

  unint64_t v9 = -[NEIKEv2PRFProtocol length]((uint64_t)v8);
  unint64_t v10 = +[NSMutableData mutableSensitiveDataPrefilledWithMaxCapacity:](MEMORY[0x189603FB8], v9);
  if (!v10)
  {
    ne_log_obj();
    unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
    {
      BOOL v20 = 67109120;
      LODWORD(v21) = v9;
      _os_log_fault_impl( &dword_1876B1000,  v19,  OS_LOG_TYPE_FAULT,  "[NEMutableSensitiveData mutableSensitiveDataPrefilledWithMaxCapacity:%u] failed",  (uint8_t *)&v20,  8u);
    }

    unint64_t v15 = 0LL;
    goto LABEL_23;
  }

  unint64_t v11 = v10;
  unint64_t v12 = [v8 type] - 1;
  if (v12 < 7 && ((0x73u >> v12) & 1) != 0)
  {
    unint64_t v14 = dword_187872D30[v12];
  }

  else
  {
    ne_log_obj();
    unsigned __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      BOOL v20 = 67109120;
      LODWORD(v21) = [v8 type];
      _os_log_fault_impl(&dword_1876B1000, v13, OS_LOG_TYPE_FAULT, "Unknown PRF type %u", (uint8_t *)&v20, 8u);
    }

    unint64_t v14 = 0;
  }

  CCHmac( v14,  (const void *)[v7 bytes],  objc_msgSend(v7, "length"),  (const void *)objc_msgSend(v6, "bytes"),  objc_msgSend(v6, "length"),  (void *)-[__CFData mutableBytes](v11, "mutableBytes"));
  unint64_t v15 = v11;
  unint64_t v16 = v15;
LABEL_12:

  return v16;
}

  return a1;
}

  uint64_t v21 = *(void **)(a1 + 40);
  if (v21)
  {
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __65__NEDNSSettingsManager_loadFromPreferencesWithCompletionHandler___block_invoke_2;
    block[3] = &unk_18A0908C8;
    BOOL v25 = v21;
    unint64_t v24 = v5;
    dispatch_async(MEMORY[0x1895F8AE0], block);
  }

  objc_sync_exit(v6);
}

    unsigned __int16 v17 = 1;
    goto LABEL_77;
  }

  if (!v7) {
    goto LABEL_23;
  }
LABEL_17:
  if (!-[NEUtilConfigurationClient setPasswordWithParameters:errorStr:]( self,  "setPasswordWithParameters:errorStr:",  v6,  a4))
  {
LABEL_76:
    unsigned __int16 v17 = 0;
    goto LABEL_77;
  }

  [v6 objectForKeyedSubscript:@"on-demand-enabled"];
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();

  if (v21)
  {
    [v6 objectForKeyedSubscript:@"on-demand-enabled"];
    unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v23 = [v22 BOOLValue];
  }

  else
  {
    uint64_t v23 = 0LL;
  }

  [v6 objectForKeyedSubscript:@"disconnect-on-demand-enabled"];
  BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v25)
  {
    __int16 v27 = 0LL;
    if (!v21) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }

  [v6 objectForKeyedSubscript:@"disconnect-on-demand-enabled"];
  unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
  __int16 v27 = [v26 BOOLValue];

  if (v21) {
LABEL_27:
  }
    -[NEUtilConfigurationClient setOnDemandEnabled:](self, "setOnDemandEnabled:", v23);
LABEL_28:
  if (v25) {
    -[NEUtilConfigurationClient setDisconnectOnDemandEnabled:](self, "setDisconnectOnDemandEnabled:", v27);
  }
  [v6 objectForKeyedSubscript:@"on-demand-user-override-disabled"];
  unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();

  if (v28)
  {
    [v6 objectForKeyedSubscript:@"on-demand-user-override-disabled"];
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEUtilConfigurationClient setOnDemandUserOverrideDisabled:]( self,  "setOnDemandUserOverrideDisabled:",  [v29 BOOLValue]);
  }

  [v6 objectForKeyedSubscript:@"disconnect-on-idle-timeout"];
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();

  if (v30)
  {
    [v6 objectForKeyedSubscript:@"disconnect-on-idle-timeout"];
    unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "setDisconnectOnIdleTimeout:", objc_msgSend(v31, "intValue"));
  }

  [v6 objectForKeyedSubscript:@"disconnect-on-sleep"];
  unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();

  if (v32)
  {
    [v6 objectForKeyedSubscript:@"disconnect-on-sleep"];
    unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "setDisconnectOnSleep:", objc_msgSend(v33, "BOOLValue"));
  }

  [v6 objectForKeyedSubscript:@"identity"];
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();

  if (v34)
  {
    [v6 objectForKeyedSubscript:@"identity"];
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v36 = [v35 integerValue];

    if (!self
      || (uint64_t v38 = objc_getProperty(self, v37, 48LL, 1)) == 0LL
      || (unint64_t v40 = v38, v41 = objc_msgSend(objc_getProperty(self, v39, 48, 1), "count"), v40, v36 >= v41))
    {
      [NSString stringWithFormat:@"Invalid %@ index, use the list-identities command to obtain a list of available identities and their indicies", @"identity"];
      unsigned __int16 v17 = 0;
      *a4 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_77;
    }

    objc_msgSend(objc_getProperty(self, v42, 48, 1), "objectAtIndexedSubscript:", v36);
    int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
    [v43 objectForKeyedSubscript:@"domain"];
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v45 = [v44 integerValue];

    if (v45)
    {
      [NSString stringWithFormat:@"Invalid %@, an identity in the %s keychain is required", @"identity", "system"];
      *a4 = (id)objc_claimAutoreleasedReturnValue();

      goto LABEL_76;
    }

    [v43 objectForKeyedSubscript:@"persistent-reference"];
    uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
    [v7 setIdentityReferenceInternal:v46];
  }

  if (!-[NEUtilConfigurationClient setProviderTypeWithParameters:errorStr:]( self,  "setProviderTypeWithParameters:errorStr:",  v6,  a4)) {
    goto LABEL_76;
  }
  [v6 objectForKeyedSubscript:@"provider-bundle-identifier"];
  int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();

  if (v47)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      unsigned __int16 v17 = 0;
      __int16 v18 = @"provider-bundle-identifier can only be specified for provider-based configurations";
      goto LABEL_9;
    }

    [v6 objectForKeyedSubscript:@"provider-bundle-identifier"];
    uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue();
    [v7 setProviderBundleIdentifier:v48];
  }

  [v6 objectForKeyedSubscript:@"designated-requirement"];
  uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v49)
  {
LABEL_54:
    [v6 objectForKeyedSubscript:@"extensible-sso-provider"];
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();

    if (v52)
    {
      [v6 objectForKeyedSubscript:@"extensible-sso-provider"];
      uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
      [v53 stringByRemovingPercentEncoding];
      uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();
      [v7 setExtensibleSSOProvider:v54];
    }

    [v6 objectForKeyedSubscript:@"access-group"];
    BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();

    if (v55)
    {
      [v7 passwordKeychainItem];
      unint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();

      if (v56)
      {
        [v6 objectForKeyedSubscript:@"access-group"];
        unint64_t v58 = (void *)objc_claimAutoreleasedReturnValue();
        [v7 passwordKeychainItem];
        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
        [v59 setAccessGroup:v58];
      }

      uint64_t v60 = objc_getProperty(v7, v57, 96LL, 1);

      if (v60)
      {
        [v6 objectForKeyedSubscript:@"access-group"];
        uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v63 = objc_getProperty(v7, v62, 96LL, 1);
        [v63 setAccessGroup:v61];
      }
    }

    [v6 objectForKeyedSubscript:@"include-all-networks"];
    uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();

    if (v64)
    {
      [v6 objectForKeyedSubscript:@"include-all-networks"];
      uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "setIncludeAllNetworks:", objc_msgSend(v65, "BOOLValue"));
    }

    [v6 objectForKeyedSubscript:@"exclude-local-networks"];
    uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue();

    if (v66)
    {
      [v6 objectForKeyedSubscript:@"exclude-local-networks"];
      uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "setExcludeLocalNetworks:", objc_msgSend(v67, "BOOLValue"));
    }

    [v6 objectForKeyedSubscript:@"exclude-cellular-services"];
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue();

    if (v68)
    {
      [v6 objectForKeyedSubscript:@"exclude-cellular-services"];
      uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "setExcludeCellularServices:", objc_msgSend(v69, "BOOLValue"));
    }

    [v6 objectForKeyedSubscript:@"exclude-apns"];
    size_t v70 = (void *)objc_claimAutoreleasedReturnValue();

    if (v70)
    {
      [v6 objectForKeyedSubscript:@"exclude-apns"];
      unint64_t v71 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "setExcludeAPNs:", objc_msgSend(v71, "BOOLValue"));
    }

    [v6 objectForKeyedSubscript:@"exclude-device-communication"];
    uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue();

    if (v72)
    {
      [v6 objectForKeyedSubscript:@"exclude-device-communication"];
      unint64_t v73 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "setExcludeDeviceCommunication:", objc_msgSend(v73, "BOOLValue"));
    }

    [v6 objectForKeyedSubscript:@"enforce-routes"];
    uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue();

    if (v74)
    {
      [v6 objectForKeyedSubscript:@"enforce-routes"];
      unint64_t v75 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "setEnforceRoutes:", objc_msgSend(v75, "BOOLValue"));
    }

    [v6 objectForKeyedSubscript:@"cellular-slice-UUID"];
    uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v76) {
      goto LABEL_23;
    }
    [v6 objectForKeyedSubscript:@"cellular-slice-UUID"];
    unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue();
    [v77 componentsSeparatedByString:@"/"];
    unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();

    if ((unint64_t)[v24 count] >= 2)
    {
      unint64_t v78 = objc_alloc(NSString);
      [v24 objectAtIndexedSubscript:0];
      uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
      [v24 objectAtIndexedSubscript:1];
      uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();
      objc_super v81 = (void *)[v78 initWithFormat:@"%@:%@", v79, v80];
      [v7 setSliceUUID:v81];
    }

    goto LABEL_22;
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    [v6 objectForKeyedSubscript:@"designated-requirement"];
    uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
    [v50 stringByRemovingPercentEncoding];
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
    [v7 setDesignatedRequirement:v51];

    goto LABEL_54;
  }

  unsigned __int16 v17 = 0;
  __int16 v18 = @"designated-requirement can only be specified for provider-based configurations";
LABEL_9:
  *a4 = v18;
LABEL_77:

  return v17;
}

                  unint64_t v2 = v2 | 4;
                  goto LABEL_27;
                }

void sub_1876C22D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
}

uint64_t __Block_byref_object_copy__131(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__132(uint64_t a1)
{
}

void sub_1876C2BB8(_Unwind_Exception *a1)
{
}

void sub_1876C3940( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id obj, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

uint64_t __Block_byref_object_copy__180(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__181(uint64_t a1)
{
}

void sub_1876C42D4(_Unwind_Exception *a1)
{
}

LABEL_33:
  return v8 & 1;
}

      [v13 appVPN];
      __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
      [v13 contentFilter];
      unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
      [v28 perApp];
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();

      unint64_t v78 = v14;
      if (v29)
      {
        [v13 contentFilter];
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
      }

      else
      {
        [v13 dnsProxy];
        unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
        [v31 perApp];
        unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();

        if (v32)
        {
          [v13 dnsProxy];
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
        }

        else
        {
          [v13 relay];
          unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
          [v33 perApp];
          uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v34)
          {
            unint64_t v36 = 0LL;
            if (!v27)
            {
              unint64_t v39 = 0LL;
              goto LABEL_66;
            }

            goto LABEL_40;
          }

          [v13 relay];
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
        }
      }

      uint64_t v35 = v30;
      [v30 perApp];
      unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v27)
      {
        if (!v36)
        {
          unint64_t v39 = 0LL;
          goto LABEL_66;
        }

        uint64_t v37 = 1;
        uint64_t v38 = v36;
        goto LABEL_43;
      }

  return v3;
}

  uint64_t v38 = v7;
LABEL_42:

  return v38;
}

  unint64_t v19 = NEVirtualInterfaceWriteMultipleIPPackets( (uint64_t)v8->_interface,  (uint64_t)v8->_packetProtocols,  packetDataArray,  (uint64_t)v8->_packetLengths,  -[NSArray count](v6, "count")) != 0;
LABEL_44:
  objc_sync_exit(v8);

  return v19;
}

  if (*(void *)(a1 + 40))
  {
    __int16 v27 = (void *)_CFXPCCreateCFObjectFromXPCObject();
    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  }

LABEL_36:
}

LABEL_24:
  -[NEAppRule matchAccountIdentifiers](self, "matchAccountIdentifiers");
  unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
  if ([v31 count])
  {

    unint64_t v32 = v16 & 1;
  }

  else
  {
    [v4 matchAccountIdentifiers];
    unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v34 = [v33 count];

    unint64_t v32 = v16 & 1;
    if (!v34)
    {
      uint64_t v53 = 0;
      uint64_t v54 = 0;
      goto LABEL_43;
    }
  }

  -[NEAppRule matchAccountIdentifiers](self, "matchAccountIdentifiers");
  uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
  if (![v35 count])
  {

    goto LABEL_47;
  }

  [v4 matchAccountIdentifiers];
  unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v37 = [v36 count];

  if (v37)
  {
    -[NEAppRule matchAccountIdentifiers](self, "matchAccountIdentifiers");
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v39 = [v38 count];

    if (v39)
    {
      unint64_t v40 = 0;
      unint64_t v41 = 0LL;
      do
      {
        -[NEAppRule matchAccountIdentifiers](self, "matchAccountIdentifiers");
        unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
        [v42 objectAtIndexedSubscript:v41];
        int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();

        [v4 matchAccountIdentifiers];
        uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v45 = [v44 count];

        if (v45)
        {
          uint64_t v46 = 0LL;
          do
          {
            [v4 matchAccountIdentifiers];
            int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
            [v47 objectAtIndexedSubscript:v46];
            uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue();

            ++v46;
            [v4 matchAccountIdentifiers];
            uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v50 = [v49 count];
          }

          while (v46 < v50);
        }

        ++v41;
        -[NEAppRule matchAccountIdentifiers](self, "matchAccountIdentifiers");
        uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v52 = [v51 count];
        uint64_t v53 = v40 & 1;
      }

      while (v41 < v52 && (v40 & 1) == 0);
    }

    else
    {
      uint64_t v53 = 0;
    }

    uint64_t v54 = 1;
LABEL_43:
    if ((v30 | v54) == 1 && (v32 & 1) == 0 && !v53)
    {
LABEL_46:
      BOOL v55 = 0;
      goto LABEL_50;
    }
  }

    goto LABEL_25;
  }

  if (state == 1)
  {
    ne_log_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      unint64_t v15 = *(void *)(v122 + 32);
      if (v15) {
        LODWORD(v15) = *(_DWORD *)(v15 + 28);
      }
      *(_DWORD *)buf = 136315394;
      v151 = "com.apple.neconfigurationchanged";
      v152 = 1024;
      *(_DWORD *)v153 = v15;
      unint64_t v16 = "Failed to get the current %s (token %u) notification state because the notification does not exist";
LABEL_22:
      _os_log_error_impl(&dword_1876B1000, v14, OS_LOG_TYPE_ERROR, v16, buf, 0x12u);
      goto LABEL_24;
    }

    goto LABEL_24;
  }

  if (state)
  {
    ne_log_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      v119 = *(void *)(v122 + 32);
      if (v119) {
        LODWORD(v119) = *(_DWORD *)(v119 + 28);
      }
      *(_DWORD *)buf = 136315650;
      v151 = "com.apple.neconfigurationchanged";
      v152 = 1024;
      *(_DWORD *)v153 = v119;
      *(_WORD *)&v153[4] = 1024;
      *(_DWORD *)&v153[6] = v11;
      _os_log_fault_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_FAULT,  "Failed to get the current %s (token %u) notification state: %u",  buf,  0x18u);
    }

    goto LABEL_24;
  }

  unint64_t v12 = state64[0] & 0x1FFFFFFFFFFFFFLL;
  unsigned __int16 v13 = *(void *)(v122 + 32);
  if (v13) {
    unsigned __int16 v13 = *(void *)(v13 + 104);
  }
  if (v13 == v12)
  {
    (*(void (**)(void))(*(void *)(v122 + 40) + 16LL))();
    return;
  }

  ne_log_obj();
  int64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
  {
    uint64_t v48 = *(void *)(v122 + 32);
    if (v48) {
      uint64_t v48 = *(void *)(v48 + 104);
    }
    *(_DWORD *)buf = 134218240;
    v151 = (const char *)v48;
    v152 = 2048;
    *(void *)v153 = v12;
    _os_log_impl( &dword_1876B1000,  v47,  OS_LOG_TYPE_INFO,  "current generation (%lld) does not equal posted generation (%llu), fetching a new index",  buf,  0x16u);
  }

  if (!v12)
  {
    ne_log_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    uint64_t v49 = *(void *)(v122 + 32);
    if (v49) {
      LODWORD(v49) = *(_DWORD *)(v49 + 28);
    }
    *(_DWORD *)buf = 134218240;
    v151 = (const char *)state64[0];
    v152 = 1024;
    *(_DWORD *)v153 = v49;
    unint64_t v16 = "current generation is 0, notification state == %llu, token == %u";
    goto LABEL_22;
  }

        a1 = 0LL;
        goto LABEL_25;
      }
    }

    unint64_t v15 = 0LL;
    goto LABEL_24;
  }

LABEL_25:
  unint64_t v14 = 0LL;
LABEL_26:

LABEL_27:
  return v14;
}

  unint64_t v10 = v2;
  (*(void (**)(uint64_t))(v1 + 16))(v1);
}

      return v21;
    default:
      ne_log_obj();
      unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_16;
      }
      LODWORD(v23) = 67109120;
      HIDWORD(v23) = a3;
      unint64_t v16 = "Unknown identifier type %u";
      unsigned __int16 v17 = v15;
      __int16 v18 = 8;
      goto LABEL_26;
  }

          goto LABEL_25;
        }

        if (v2) {
          objc_setProperty_atomic(v2, v9, v8, 88LL);
        }
LABEL_25:
        ++v7;
      }

      while (v5 != v7);
      unint64_t v5 = -[NEIKEv2IntermediatePacket countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v19,  v25,  16LL);
    }

    while (v5);
  }
}
  }

  else
  {
    unint64_t v22 = 0LL;
  }

  return v22;
}

      goto LABEL_25;
    }
  }

  unint64_t v10 = 0;
LABEL_28:

  return v10;
}
}

  [v6 objectForKeyedSubscript:@"extensible-sso-provider"];
  __int16 v18 = (void *)objc_claimAutoreleasedReturnValue();

  if (v18) {
    [v7 setExtensibleSSOProvider:0];
  }
  [v6 objectForKeyedSubscript:@"include-all-networks"];
  unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();

  if (v19) {
    [v7 setIncludeAllNetworks:0];
  }
  [v6 objectForKeyedSubscript:@"exclude-local-networks"];
  BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();

  if (v20) {
    [v7 setExcludeLocalNetworks:0];
  }
  [v6 objectForKeyedSubscript:@"exclude-cellular-services"];
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();

  if (v21) {
    [v7 setExcludeCellularServices:0];
  }
  [v6 objectForKeyedSubscript:@"exclude-apns"];
  unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();

  if (v22) {
    [v7 setExcludeAPNs:0];
  }
  [v6 objectForKeyedSubscript:@"exclude-device-communication"];
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();

  if (v23) {
    [v7 setExcludeDeviceCommunication:0];
  }
  [v6 objectForKeyedSubscript:@"enforce-routes"];
  unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();

  if (v24) {
    [v7 setEnforceRoutes:0];
  }
  [v6 objectForKeyedSubscript:@"cellular-slice-UUID"];
  BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();

  if (v25) {
    [v7 setSliceUUID:0];
  }
  unint64_t v26 = 1;
LABEL_47:

  return v26;
}

                    unint64_t v2 = v2 | 0x10;
                    goto LABEL_27;
                  }

LABEL_47:
  ne_log_obj();
  unint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    -[NEAppRule matchSigningIdentifier](self, "matchSigningIdentifier");
    unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v59 = 138412290;
    uint64_t v60 = v57;
    _os_log_impl( &dword_1876B1000,  v56,  OS_LOG_TYPE_DEFAULT,  "App Rule for %@ overlaps with an existing app rule",  (uint8_t *)&v59,  0xCu);
  }

  BOOL v55 = 1;
LABEL_50:

  return v55;
}

  ne_log_obj();
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1876B1000, v23, OS_LOG_TYPE_DEFAULT, "DNS settings are enabled", buf, 2u);
  }

  if ((a3 & 0x1000000000000000LL) == 0)
  {
LABEL_28:
    if ((a3 & 0x400000000000000LL) == 0) {
      goto LABEL_29;
    }
    goto LABEL_53;
  }

    unint64_t v19 = 0LL;
    goto LABEL_48;
  }

  uint64_t v61 = v17;
  uint64_t v62 = v16;
  unint64_t v19 = 0LL;
  if (v12)
  {
    BOOL v20 = 0;
    uint64_t v60 = v12;
    while (1)
    {
      uint64_t v21 = -[NEByteParser parseDomainName](v9, v18);
      if (!v21)
      {
        ne_log_obj();
        int64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          uint64_t v66 = v20;
          _os_log_error_impl( &dword_1876B1000,  v43,  OS_LOG_TYPE_ERROR,  "Failed to parse DNS packet query %u name",  buf,  8u);
        }

        unint64_t v22 = 0LL;
        goto LABEL_72;
      }

      unint64_t v22 = (void *)v21;
      uint64_t v23 = -[NEByteParser parse16Bits:]((uint64_t)v9, &v64);
      if (!v64) {
        break;
      }
      unint64_t v24 = v23;
      BOOL v25 = -[NEByteParser parse16Bits:]((uint64_t)v9, &v64);
      if (!v64)
      {
        ne_log_obj();
        uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          goto LABEL_68;
        }
        *(_DWORD *)buf = 67109120;
        uint64_t v66 = v20;
        uint64_t v45 = "Failed to parse DNS packet query %u class";
        goto LABEL_85;
      }

      unint64_t v26 = -[NEDNSQuery initWithName:recordType:recordClass:]( objc_alloc(&OBJC_CLASS___NEDNSQuery),  "initWithName:recordType:recordClass:",  v22,  v24,  v25);
      if (!v26)
      {
        ne_log_obj();
        uint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          uint64_t v66 = v20;
          _os_log_error_impl( &dword_1876B1000,  v49,  OS_LOG_TYPE_ERROR,  "Failed to allocate a query object for query %u",  buf,  8u);
        }

LABEL_72:
        uint64_t v64 = 0;
LABEL_73:

LABEL_48:
        uint64_t v29 = 0LL;
        unint64_t v33 = 0LL;
        uint64_t v37 = 0LL;
LABEL_49:
        uint64_t v38 = 0LL;
        goto LABEL_50;
      }

      __int16 v27 = v26;
      if (!v19) {
        unint64_t v19 = (void *)[objc_alloc(MEMORY[0x189603FA8]) initWithCapacity:v60];
      }
      objc_msgSend(v19, "addObject:", v27, v60);

      if (++v20 >= v12) {
        goto LABEL_17;
      }
    }

    ne_log_obj();
    uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
LABEL_68:

      goto LABEL_73;
    }

    *(_DWORD *)buf = 67109120;
    uint64_t v66 = v20;
    uint64_t v45 = "Failed to parse DNS packet query %u type";
LABEL_85:
    _os_log_error_impl(&dword_1876B1000, v44, OS_LOG_TYPE_ERROR, v45, buf, 8u);
    goto LABEL_68;
  }

    unint64_t v14 = 0;
LABEL_48:

    goto LABEL_49;
  }

  unint64_t v14 = 0;
LABEL_49:

  return v14;
}

    a1 = 0LL;
    goto LABEL_48;
  }

  if ((v3[9] & 1) == 0)
  {
    ne_log_obj();
    char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      buf = 136315138;
      v384 = "-[NEIKEv2IKESAInitPacket(Exchange) validateSAInitAsInitiator:]";
      v196 = "%s called with null ikeSA.isInitiator";
      goto LABEL_118;
    }

    goto LABEL_47;
  }

  v381 = 0u;
  v382 = 0u;
  v379 = 0u;
  v380 = 0u;
  char v7 = (os_log_s *)objc_getProperty((id)a1, v6, 64LL, 1);
  unint64_t v8 = -[os_log_s countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v379,  v390,  16LL);
  if (!v8) {
    goto LABEL_14;
  }
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)v380;
  do
  {
    for (i = 0LL; i != v9; ++i)
    {
      if (*(void *)v380 != v10) {
        objc_enumerationMutation(v7);
      }
      unint64_t v12 = *(void **)(*((void *)&v379 + 1) + 8 * i);
      if (v12 && (unint64_t)(v12[3] - 1LL) <= 0x3FFE)
      {
        BOOL v20 = (__CFString *)-[NEIKEv2NotifyPayload copyError](*(const __CFString **)(*((void *)&v379 + 1) + 8 * i));
        ne_log_obj();
        unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          unint64_t v75 = (char *)[(id)a1 copyShortDescription];
          buf = 138412546;
          v384 = v75;
          v385 = 2112;
          v386 = (NEIKEv2AuthenticationProtocol *)v20;
          _os_log_error_impl( &dword_1876B1000,  v22,  OS_LOG_TYPE_ERROR,  "%@ Initiator init received notify error %@",  (uint8_t *)&buf,  0x16u);
        }

        if (v12[3] == 17LL)
        {
          unint64_t v24 = objc_getProperty(v12, v23, 32LL, 1);
          BOOL v25 = v24;
          if (v24)
          {
            LOWORD(buf) = 0;
            [v24 getBytes:&buf length:2];
            unint64_t v26 = objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol);
            __int16 v27 = -[NEIKEv2KEMProtocol initWithMethod:](v26, "initWithMethod:", bswap32((unsigned __int16)buf) >> 16);
            objc_setProperty_atomic((id)v5, v28, v27, 144LL);
          }

          else
          {
            -[NEIKEv2IKESA setState:error:](v5, 3uLL, v20);
          }
        }

        else
        {
          -[NEIKEv2IKESA setState:error:](v5, 3uLL, v20);
        }

    uint64_t v53 = v19;

    unsigned __int16 v17 = v16;
LABEL_48:

    goto LABEL_49;
  }

  type = nw_endpoint_get_type(v18);
  if (type != nw_endpoint_type_address)
  {
    unint64_t v58 = type;
    ne_log_obj();
    uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v58;
      BOOL v55 = "Unexpected endpoint type %d";
      unint64_t v56 = v54;
      unint64_t v57 = 8;
      goto LABEL_36;
    }

    goto LABEL_47;
  }

  [v5 listenerQueue];
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v22 = v16;
  uint64_t v23 = v21;
  objc_opt_self();
  if (!v23)
  {
    ne_log_obj();
    unint64_t v24 = (NEIKEv2Transport *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = "+[NEIKEv2Transport createTransportWithConnection:queue:]";
      _os_log_fault_impl(&dword_1876B1000, (os_log_t)v24, OS_LOG_TYPE_FAULT, "%s called with null queue", buf, 0xCu);
    }

    goto LABEL_39;
  }

  unint64_t v24 = objc_alloc_init(&OBJC_CLASS___NEIKEv2Transport);
  if (!v24)
  {
LABEL_39:
    uint64_t v52 = 0LL;
    goto LABEL_40;
  }

  BOOL v25 = nw_connection_copy_parameters(v22);
  ip_protocol = nw_parameters_get_ip_protocol();
  uint64_t v61 = v19;
  if (ip_protocol == 6)
  {
    else {
      unint64_t v31 = 2LL;
    }
    v24->_transportType = v31;
  }

  else if (ip_protocol == 17)
  {
    __int16 v27 = nw_parameters_copy_default_protocol_stack(v25);
    uint64_t v30 = 0;
    if (v27)
    {
      unint64_t v28 = NEIKEv2TransportCopyNATTFramerDefinition();
      uint64_t v29 = nw_protocol_stack_includes_protocol();

      if ((v29 & 1) != 0) {
        uint64_t v30 = 1;
      }
    }

    v24->_transportType = v30;
  }

  unint64_t v32 = (void *)MEMORY[0x189608DF0];
  unint64_t v33 = nw_connection_copy_endpoint(v22);
  [v32 endpointWithCEndpoint:v33];
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_setProperty_atomic(v24, v35, v34, 24LL);

  unint64_t v36 = (void *)MEMORY[0x189608DF0];
  uint64_t v37 = (void *)MEMORY[0x1895AD020](v25);
  [v36 endpointWithCEndpoint:v37];
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_setProperty_atomic(v24, v39, v38, 16LL);

  objc_setProperty_atomic(v24, v40, v23, 72LL);
  objc_setProperty_atomic(v24, v41, v22, 56LL);
  Property = (nw_connection *)objc_getProperty(v24, v42, 56LL, 1);
  nw_connection_set_queue(Property, v23);
  uint64_t v45 = objc_getProperty(v24, v44, 56LL, 1);
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = __56__NEIKEv2Transport_createTransportWithConnection_queue___block_invoke;
  uint64_t v63 = &unk_18A08DBA0;
  uint64_t v46 = v24;
  uint64_t v64 = v46;
  MEMORY[0x1895ACCFC](v45, buf);
  uint64_t v48 = (nw_connection *)objc_getProperty(v46, v47, 56LL, 1);
  nw_connection_start(v48);
  os_unfair_lock_lock((os_unfair_lock_t)&g_transport_lock);
  uint64_t v49 = (void *)g_transports;
  if (!g_transports)
  {
    uint64_t v50 = objc_alloc_init(MEMORY[0x189603FE0]);
    uint64_t v51 = (void *)g_transports;
    g_transports = (uint64_t)v50;

    uint64_t v49 = (void *)g_transports;
  }

  [v49 addObject:v46];
  os_unfair_lock_unlock((os_unfair_lock_t)&g_transport_lock);
  unint64_t v24 = v46;

  uint64_t v52 = v24;
  unint64_t v19 = v61;
LABEL_40:

  ne_log_obj();
  uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v60 = v59;
  if (!v52)
  {
    if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = "-[NEIKEv2Listener handleNewConnection:]";
      _os_log_fault_impl(&dword_1876B1000, v60, OS_LOG_TYPE_FAULT, "%s called with null transport", buf, 0xCu);
    }

    uint64_t v54 = 0LL;
    goto LABEL_47;
  }

  if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    *(void *)&buf[4] = v52;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v22;
    _os_log_impl(&dword_1876B1000, v60, OS_LOG_TYPE_DEFAULT, "Created %@ with connection %@", buf, 0x16u);
  }

  [*((id *)v5 + 8) addObject:v52];
  -[NEIKEv2Transport setWildcardDelegate:preventsInvalidation:]((uint64_t)v52, v5, 0);

LABEL_54:
}

LABEL_7:
  return 1;
}

    unint64_t v10 = v3;
LABEL_14:

    return v10;
  }

  return 0LL;
}

    unint64_t v8 = 0LL;
    goto LABEL_8;
  }

  unint64_t v8 = v7;
  v7->_notifyStatus = v4;
  unint64_t v9 = (NSData *)v6;
  self = (NEIKEv2PrivateNotify *)v8->_notifyData;
  v8->_notifyData = v9;
LABEL_8:

  return v8;
}

  unint64_t v12 = +[NEIKEv2EAP codeForPayload:]((uint64_t)&OBJC_CLASS___NEIKEv2EAP, v9);
  if (v12 != 1)
  {
    BOOL v25 = 0;
LABEL_23:
    if (*(void *)(a1 + 168))
    {
      *(void *)buf = 0LL;
      v207[0] = 0;
      LODWORD(v210) = 0;
      [v9 bytes];
      unint64_t v26 = EAPClientModulePluginProcess();
      if (*(void *)buf)
      {
        unint64_t v24 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603F48]), "initWithBytes:length:");
        if (!a5) {
          goto LABEL_60;
        }
      }

      else
      {
        unint64_t v24 = 0LL;
        if (!a5) {
          goto LABEL_60;
        }
      }

      if ((_DWORD)v210) {
        *a5 = (_DWORD)v210 == 19;
      }
LABEL_60:
      if (v26 == 1)
      {
        if (v10)
        {
          v10[18] = 1;
          v10[20] = 1;
        }

        if (!a4) {
          goto LABEL_72;
        }
        uint64_t v60 = 1;
        goto LABEL_71;
      }

      if (v26 || v207[0])
      {
        if (a4)
        {
          uint64_t v60 = 0;
LABEL_71:
          *a4 = v60;
        }
      }

      else if (a4)
      {
        uint64_t v60 = *(void *)buf != 0LL;
        goto LABEL_71;
      }

      if (v4)
      {
        unsigned __int16 v13 = objc_getProperty(v4, v12, v8[746], 1);
        if (v13)
        {

          goto LABEL_18;
        }

        uint64_t v29 = objc_getProperty(v4, v14, 144LL, 1);
      }

      else
      {
        uint64_t v29 = 0LL;
      }

      uint64_t v30 = v29;

      if (!v30
        && (-[NEIKEv2IKEAuthPacket validateAuthPart1AsInitiator:beforeEAP:]((uint64_t)v4, *(void **)(a1 + 40), 0) & 1) == 0)
      {
        uint64_t v51 = *(id *)(a1 + 32);
        if (v51) {
          uint64_t v51 = objc_getProperty(v51, v31, 336LL, 1);
        }
        uint64_t v52 = v51;
        -[NEIKEv2IKESA setState:error:]((uint64_t)v52, 3uLL, 0LL);

        -[NEIKEv2Session reportState](*(void **)(a1 + 32), v53);
        -[NEIKEv2Session resetAll](*(void *)(a1 + 32), v54);
        goto LABEL_19;
      }

    unint64_t v6 = 0;
    goto LABEL_75;
  }

  if ((unint64_t)objc_msgSend(objc_getProperty(self, v3, 16, 1), "length") <= 7)
  {
    ne_log_obj();
    size_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v68[0] = "-[NEIKEv2ChildSAPayload parsePayloadData]";
      unint64_t v5 = "%s called with null (self.payloadData.length >= sizeof(ikev2_proposal_t))";
LABEL_69:
      _os_log_fault_impl(&dword_1876B1000, v4, OS_LOG_TYPE_FAULT, v5, buf, 0xCu);
      goto LABEL_7;
    }

    goto LABEL_7;
  }

  size_t v4 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
  selfa = self;
  unint64_t v8 = objc_getProperty(self, v7, 16LL, 1);
  unint64_t v9 = (unsigned __int8 *)[v8 bytes];
  BOOL v55 = v8;
  unint64_t v11 = [v8 length];
  *(void *)&unint64_t v12 = 67109376LL;
  uint64_t v54 = v12;
  unint64_t v57 = v4;
  while (v11 >= 8)
  {
    unsigned __int16 v13 = bswap32(*((unsigned __int16 *)v9 + 1));
    unint64_t v14 = HIWORD(v13);
    if (v11 < HIWORD(v13))
    {
      ne_log_obj();
      uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v49, OS_LOG_TYPE_ERROR))
      {
LABEL_73:

        break;
      }

      *(_DWORD *)buf = v54;
      LODWORD(v68[0]) = v11;
      WORD2(v68[0]) = 1024;
      *(_DWORD *)((char *)v68 + 6) = v14;
      uint64_t v50 = "Not enough bytes remaining (%u) to process proposal length %u";
      uint64_t v51 = (os_log_s *)v49;
      uint64_t v52 = 14;
LABEL_77:
      _os_log_error_impl(&dword_1876B1000, v51, OS_LOG_TYPE_ERROR, v50, buf, v52);
      goto LABEL_73;
    }

    if ((unint64_t)v9[6] + 8 > v14)
    {
      ne_log_obj();
      uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v49, OS_LOG_TYPE_ERROR)) {
        goto LABEL_73;
      }
      *(_DWORD *)buf = 67109120;
      LODWORD(v68[0]) = v14;
      uint64_t v50 = "Proposal length %u is too short";
      uint64_t v51 = (os_log_s *)v49;
      uint64_t v52 = 8;
      goto LABEL_77;
    }

    uint64_t v62 = v9[7];
    unint64_t v15 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ChildSAProposal);
    if (v9[6] == 4)
    {
      unsigned __int16 v17 = -[NEIKEv2ESPSPI initWithValue:]( objc_alloc(&OBJC_CLASS___NEIKEv2ESPSPI),  "initWithValue:",  *((unsigned int *)v9 + 2));
      if (v15) {
        objc_setProperty_atomic(v15, v16, v17, 80LL);
      }
    }

    else
    {
      ne_log_obj();
      unsigned __int16 v17 = (NEIKEv2ESPSPI *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_ERROR))
      {
        int64_t v47 = v9[4];
        uint64_t v48 = v9[6];
        *(_DWORD *)buf = v54;
        LODWORD(v68[0]) = v47;
        WORD2(v68[0]) = 1024;
        *(_DWORD *)((char *)v68 + 6) = v48;
        _os_log_error_impl( &dword_1876B1000,  (os_log_t)v17,  OS_LOG_TYPE_ERROR,  "SA proposal %u has wrong length %u",  buf,  0xEu);
      }
    }

    unint64_t v58 = v11;

    __int16 v18 = v9[6];
    unint64_t v19 = v18 + 16 > v14 || v62 == 0;
    uint64_t v61 = v15;
    if (v19)
    {
      BOOL v25 = 0LL;
      uint64_t v59 = 0;
      uint64_t v60 = 0LL;
    }

    else
    {
      uint64_t v60 = 0LL;
      uint64_t v59 = 0;
      BOOL v25 = 0LL;
      unint64_t v26 = v18 + 8;
      __int16 v27 = 1;
      do
      {
        unint64_t v28 = &v9[v26];
        uint64_t v29 = bswap32(*(unsigned __int16 *)&v9[v26 + 2]) >> 16;
        uint64_t v30 = v9[v26 + 4];
        switch(v9[v26 + 4])
        {
          case 1u:
            unint64_t v36 = v29 >= 0xC && *((_WORD *)v28 + 4) == 3712 && *((_WORD *)v28 + 5) == 1;
            unint64_t v31 = (NEIKEv2IntegrityProtocol *)-[NEIKEv2EncryptionProtocol initWithEncryptionWireType:is256Bit:]( objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol),  bswap32(*((unsigned __int16 *)v28 + 3)) >> 16,  v36);
            -[NEIKEv2ChildSAProposal encryptionProtocols](v15, "encryptionProtocols");
            uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();

            if (v45)
            {
              -[NEIKEv2ChildSAProposal encryptionProtocols](v15, "encryptionProtocols");
              uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
              [v38 arrayByAddingObject:v31];
              unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
              -[NEIKEv2ChildSAProposal setEncryptionProtocols:](v15, "setEncryptionProtocols:", v39);
              goto LABEL_56;
            }

            uint64_t v66 = v31;
            [MEMORY[0x189603F18] arrayWithObjects:&v66 count:1];
            uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
            -[NEIKEv2ChildSAProposal setEncryptionProtocols:](v15, "setEncryptionProtocols:", v38);
            break;
          case 3u:
            unint64_t v31 = -[NEIKEv2IntegrityProtocol initWithType:]( objc_alloc(&OBJC_CLASS___NEIKEv2IntegrityProtocol),  "initWithType:",  bswap32(*((unsigned __int16 *)v28 + 3)) >> 16);
            -[NEIKEv2ChildSAProposal integrityProtocols](v15, "integrityProtocols");
            uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();

            if (v37)
            {
              -[NEIKEv2ChildSAProposal integrityProtocols](v15, "integrityProtocols");
              uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
              [v38 arrayByAddingObject:v31];
              unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
              -[NEIKEv2ChildSAProposal setIntegrityProtocols:](v15, "setIntegrityProtocols:", v39);
              goto LABEL_56;
            }

            uint64_t v65 = v31;
            [MEMORY[0x189603F18] arrayWithObjects:&v65 count:1];
            uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
            -[NEIKEv2ChildSAProposal setIntegrityProtocols:](v15, "setIntegrityProtocols:", v38);
            break;
          case 4u:
            unint64_t v31 = -[NEIKEv2KEMProtocol initWithMethod:]( objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol),  "initWithMethod:",  bswap32(*((unsigned __int16 *)v28 + 3)) >> 16);
            -[NEIKEv2ChildSAProposal kemProtocols](v15, "kemProtocols");
            unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();

            if (v40)
            {
              -[NEIKEv2ChildSAProposal kemProtocols](v15, "kemProtocols");
              uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
              [v38 arrayByAddingObject:v31];
              unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
              -[NEIKEv2ChildSAProposal setKemProtocols:](v15, "setKemProtocols:", v39);
LABEL_56:
            }

            else
            {
              uint64_t v64 = v31;
              [MEMORY[0x189603F18] arrayWithObjects:&v64 count:1];
              uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
              -[NEIKEv2ChildSAProposal setKemProtocols:](v15, "setKemProtocols:", v38);
            }

            break;
          case 5u:
            v59 |= *((_WORD *)v28 + 3) == 0;
            goto LABEL_59;
          case 6u:
          case 7u:
          case 8u:
          case 9u:
          case 0xAu:
          case 0xBu:
          case 0xCu:
            objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedChar:");
            unint64_t v31 = (NEIKEv2IntegrityProtocol *)objc_claimAutoreleasedReturnValue();
            unint64_t v32 = -[NEIKEv2KEMProtocol initWithMethod:]( objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol),  "initWithMethod:",  bswap32(*((unsigned __int16 *)v28 + 3)) >> 16);
            if (!v25) {
              BOOL v25 = objc_alloc_init(MEMORY[0x189603FC8]);
            }
            objc_msgSend(v25, "objectForKeyedSubscript:", v31, v54);
            unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();

            if (v33)
            {
              [v25 objectForKeyedSubscript:v31];
              uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
              [v34 arrayByAddingObject:v32];
              uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
              [v25 setObject:v35 forKeyedSubscript:v31];

              unint64_t v15 = v61;
            }

            else
            {
              uint64_t v63 = v32;
              [MEMORY[0x189603F18] arrayWithObjects:&v63 count:1];
              uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
              [v25 setObject:v34 forKeyedSubscript:v31];
            }

            goto LABEL_58;
          default:
            unint64_t v41 = v60;
            if (!v60)
            {
              unint64_t v41 = objc_alloc_init(MEMORY[0x189603FE0]);
              uint64_t v30 = v28[4];
            }

            objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedChar:", v30, v54);
            unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v60 = v41;
            [v41 addObject:v42];

            ne_log_obj();
            int64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
            {
              uint64_t v44 = v28[4];
              *(_DWORD *)buf = 67109120;
              LODWORD(v68[0]) = v44;
              _os_log_impl( &dword_1876B1000,  v43,  OS_LOG_TYPE_INFO,  "Found unsupported transform type %u in Child SA proposal",  buf,  8u);
            }

            unint64_t v15 = v61;
            goto LABEL_59;
        }

LABEL_58:
LABEL_59:
        v26 += v29;
      }

      while (v26 + 8 <= v14 && v27++ < v62);
    }

    if (v15)
    {
      v15->_proposalNumber = v9[4];
      v15->_noESNTransformPresent = v59 & 1;
    }

    size_t v4 = v57;
    if (v25)
    {
      BOOL v20 = (void *)[objc_alloc(MEMORY[0x189603F68]) initWithDictionary:v25];
      -[NEIKEv2ChildSAProposal setAdditionalKEMProtocols:](v61, "setAdditionalKEMProtocols:", v20);

      unint64_t v15 = v61;
    }

    if (v60)
    {
      unint64_t v22 = (void *)[objc_alloc(MEMORY[0x189604010]) initWithSet:v60];
      if (v15) {
        objc_setProperty_atomic(v15, v21, v22, 72LL);
      }
    }

    -[os_log_s addObject:](v57, "addObject:", v15, v54);
    uint64_t v23 = v15;
    unint64_t v24 = *v9;
    unint64_t v11 = v58 - v14;
    v9 += v14;

    if (v24 != 2) {
      break;
    }
  }

  objc_setProperty_atomic(selfa, v10, v4, 24LL);
  unint64_t v6 = -[NEIKEv2ChildSAPayload hasRequiredFields](selfa, "hasRequiredFields");

LABEL_75:
  return v6;
}

    return 0;
  }

  if ((unint64_t)objc_msgSend(objc_getProperty(self, v3, 16, 1), "length") <= 3)
  {
    ne_log_obj();
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      unsigned __int16 v17 = 136315138;
      __int16 v18 = "-[NEIKEv2KeyExchangePayload parsePayloadData]";
      unint64_t v6 = "%s called with null (self.payloadData.length >= sizeof(ikev2_payload_ke_hdr_t))";
LABEL_11:
      _os_log_fault_impl(&dword_1876B1000, v5, OS_LOG_TYPE_FAULT, v6, (uint8_t *)&v17, 0xCu);
      goto LABEL_7;
    }

    goto LABEL_7;
  }

  unsigned __int16 v17 = 0;
  objc_msgSend(objc_getProperty(self, v4, 16, 1), "getBytes:length:", &v17, 4);
  unint64_t v8 = objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol);
  unint64_t v9 = -[NEIKEv2KEMProtocol initWithMethod:](v8, "initWithMethod:", bswap32((unsigned __int16)v17) >> 16);
  objc_setProperty_atomic(self, v10, v9, 24LL);

  unint64_t v12 = objc_getProperty(self, v11, 16LL, 1);
  unint64_t v14 = objc_getProperty(self, v13, 16LL, 1);
  objc_msgSend(v12, "subdataWithRange:", 4, objc_msgSend(v14, "length") - 4);
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();

  objc_setProperty_atomic(self, v16, v15, 32LL);
  return -[NEIKEv2KeyExchangePayload hasRequiredFields](self, "hasRequiredFields");
}

    return 0;
  }

  if ((unint64_t)objc_msgSend(objc_getProperty(self, v3, 16, 1), "length") <= 3)
  {
    ne_log_obj();
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)BOOL v20 = "-[NEIKEv2IdentifierPayload parsePayloadData]";
      unint64_t v6 = "%s called with null (self.payloadData.length >= sizeof(ikev2_payload_id_hdr_t))";
LABEL_16:
      _os_log_fault_impl(&dword_1876B1000, v5, OS_LOG_TYPE_FAULT, v6, buf, 0xCu);
      goto LABEL_7;
    }

    goto LABEL_7;
  }

  __int16 v18 = 0;
  objc_msgSend(objc_getProperty(self, v4, 16, 1), "getBytes:length:", &v18, 4);
  unint64_t v9 = objc_getProperty(self, v8, 16LL, 1);
  unint64_t v11 = objc_getProperty(self, v10, 16LL, 1);
  objc_msgSend(v9, "subdataWithRange:", 4, objc_msgSend(v11, "length") - 4);
  unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();

  unsigned __int16 v13 = +[NEIKEv2Identifier createIdentifierWithType:data:]( &OBJC_CLASS___NEIKEv2Identifier,  "createIdentifierWithType:data:",  v18,  v12);
  objc_setProperty_atomic(self, v14, v13, 24LL);

  if (objc_getProperty(self, v15, 24LL, 1))
  {
    char v7 = -[NEIKEv2IdentifierPayload hasRequiredFields](self, "hasRequiredFields");
  }

  else
  {
    ne_log_obj();
    unint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      v20[0] = v18;
      LOWORD(v20[1]) = 2112;
      *(void *)((char *)&v20[1] + 2) = v12;
      _os_log_error_impl( &dword_1876B1000,  v16,  OS_LOG_TYPE_ERROR,  "Failed to parse identifier type %u data %@",  buf,  0x12u);
    }

    char v7 = 0;
  }

  return v7;
}

    return 0;
  }

  if ((unint64_t)objc_msgSend(objc_getProperty(self, v3, 16, 1), "length") <= 3)
  {
    ne_log_obj();
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v42[0] = "-[NEIKEv2TrafficSelectorPayload parsePayloadData]";
      unint64_t v6 = "%s called with null (self.payloadData.length >= sizeof(ikev2_payload_ts_hdr_t))";
LABEL_44:
      _os_log_fault_impl(&dword_1876B1000, v5, OS_LOG_TYPE_FAULT, v6, buf, 0xCu);
      goto LABEL_7;
    }

    goto LABEL_7;
  }

  unint64_t v39 = 0;
  objc_msgSend(objc_getProperty(self, v4, 16, 1), "getBytes:length:", &v39, 4);
  unint64_t v8 = v39;
  unint64_t v9 = objc_alloc_init(MEMORY[0x189603FA8]);
  unint64_t v11 = objc_msgSend(objc_getProperty(self, v10, 16, 1), "length");
  unint64_t v14 = v11;
  if (v11 < 0xCuLL)
  {
    unint64_t v15 = [v9 count];
    goto LABEL_36;
  }

  unsigned __int16 v17 = v11;
  uint64_t v37 = v8;
  uint64_t v38 = v9;
  __int16 v18 = 4LL;
  *(void *)&unsigned __int16 v13 = 67109376LL;
  unint64_t v36 = v13;
  while (1)
  {
    unint64_t v19 = objc_getProperty(self, v12, 16LL, 1);
    BOOL v20 = (unsigned __int8 *)([v19 bytes] + v18);
    uint64_t v21 = *((unsigned __int16 *)v20 + 1);
    unint64_t v22 = __rev16(v21);
    ne_log_obj();
    uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v31 = *v20;
      *(_DWORD *)buf = v36;
      LODWORD(v42[0]) = v31;
      WORD2(v42[0]) = 1024;
      *(_DWORD *)((char *)v42 + 6) = v22;
      _os_log_debug_impl( &dword_1876B1000,  v23,  OS_LOG_TYPE_DEBUG,  "Parsing traffic selector of type %u length %u",  buf,  0xEu);
    }

    __int16 v18 = v18 + v22;
    unint64_t v24 = objc_alloc_init(&OBJC_CLASS___NEIKEv2TrafficSelector);
    -[NEIKEv2TrafficSelector setIpProtocol:](v24, "setIpProtocol:", v20[1]);
    -[NEIKEv2TrafficSelector setStartPort:](v24, "setStartPort:", bswap32(*((unsigned __int16 *)v20 + 2)) >> 16);
    -[NEIKEv2TrafficSelector setEndPort:](v24, "setEndPort:", bswap32(*((unsigned __int16 *)v20 + 3)) >> 16);
    BOOL v25 = *v20;
    if (v25 == 8)
    {
      if (v21 == 10240)
      {
        memset(v42, 0, 24);
        *(_DWORD *)buf = 7708;
        *(_OWORD *)((char *)v42 + 4) = *(_OWORD *)(v20 + 8);
        memset(&v40[1], 0, 24);
        v40[0] = 7708;
        *(_OWORD *)&v40[2] = *(_OWORD *)(v20 + 24);
        goto LABEL_20;
      }

      ne_log_obj();
      __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v42[0]) = v22;
        uint64_t v29 = v27;
        uint64_t v30 = "Bad traffic IPv6 traffic selector length (%u)";
        goto LABEL_31;
      }
    }

    else
    {
      if (v25 != 7)
      {
        ne_log_obj();
        __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
        {
          unint64_t v28 = *v20;
          *(_DWORD *)buf = 67109120;
          LODWORD(v42[0]) = v28;
          _os_log_impl(&dword_1876B1000, v27, OS_LOG_TYPE_INFO, "Unknown traffic selector type %u", buf, 8u);
        }

        goto LABEL_26;
      }

      if (v21 == 4096)
      {
        LODWORD(v42[1]) = 0;
        v42[0] = 0LL;
        *(_DWORD *)buf = 528;
        LODWORD(v42[0]) = *((_DWORD *)v20 + 2);
        v40[3] = 0;
        *(void *)&v40[1] = 0LL;
        v40[0] = 528;
        v40[1] = *((_DWORD *)v20 + 3);
LABEL_20:
        objc_msgSend(MEMORY[0x189608DE8], "endpointWithAddress:", buf, v36);
        unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEIKEv2TrafficSelector setStartAddress:](v24, "setStartAddress:", v26);

        [MEMORY[0x189608DE8] endpointWithAddress:v40];
        __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        -[NEIKEv2TrafficSelector setEndAddress:](v24, "setEndAddress:", v27);
        goto LABEL_26;
      }

      ne_log_obj();
      __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v42[0]) = v22;
        uint64_t v29 = v27;
        uint64_t v30 = "Bad traffic IPv4 traffic selector length (%u)";
LABEL_31:
        _os_log_error_impl(&dword_1876B1000, v29, OS_LOG_TYPE_ERROR, v30, buf, 8u);
      }
    }

    return 0;
  }

  if ((unint64_t)objc_msgSend(objc_getProperty(self, v3, 16, 1), "length") <= 3)
  {
    ne_log_obj();
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v23 = "-[NEIKEv2DeletePayload parsePayloadData]";
      unint64_t v6 = "%s called with null (self.payloadData.length >= sizeof(ikev2_payload_delete_hdr_t))";
LABEL_23:
      _os_log_fault_impl(&dword_1876B1000, v5, OS_LOG_TYPE_FAULT, v6, buf, 0xCu);
      goto LABEL_7;
    }

    goto LABEL_7;
  }

  BOOL v20 = 0;
  objc_msgSend(objc_getProperty(self, v4, 16, 1), "getBytes:length:", &v20, 4);
  unint64_t v9 = v20;
  self->_protocol = v20;
  if (v9 == 3)
  {
    if (BYTE1(v20) == 4)
    {
      if (HIWORD(v20))
      {
        unint64_t v10 = 0LL;
        unint64_t v11 = 4LL;
        do
        {
          if (objc_msgSend(objc_getProperty(self, v8, 16, 1), "length") < v11) {
            break;
          }
          unsigned __int16 v13 = objc_getProperty(self, v12, 16LL, 1);
          unint64_t v14 = -[NEIKEv2ESPSPI initWithValue:]( [NEIKEv2ESPSPI alloc],  "initWithValue:",  *(unsigned int *)([v13 bytes] + 4 * v10 + 4));
          if (objc_getProperty(self, v15, 32LL, 1))
          {
            objc_msgSend(objc_getProperty(self, v16, 32, 1), "arrayByAddingObject:", v14);
          }

          else
          {
            uint64_t v21 = v14;
            [MEMORY[0x189603F18] arrayWithObjects:&v21 count:1];
          }

          unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
          objc_setProperty_atomic(self, v18, v17, 32LL);

          ++v10;
          v11 += 4LL;
        }

        while (v10 < bswap32(HIWORD(v20)) >> 16);
      }
    }

    else
    {
      ne_log_obj();
      unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v23) = BYTE1(v20);
        _os_log_error_impl(&dword_1876B1000, v19, OS_LOG_TYPE_ERROR, "Invalid DELETE SPI length %u", buf, 8u);
      }
    }
  }

  return -[NEIKEv2DeletePayload hasRequiredFields](self, "hasRequiredFields");
}

    return 0;
  }

  if ((unint64_t)objc_msgSend(objc_getProperty(self, v3, 16, 1), "length") <= 3)
  {
    ne_log_obj();
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)uint64_t v38 = "-[NEIKEv2ConfigPayload parsePayloadData]";
      unint64_t v6 = "%s called with null (self.payloadData.length >= sizeof(ikev2_payload_config_hdr_t))";
LABEL_26:
      _os_log_fault_impl(&dword_1876B1000, v5, OS_LOG_TYPE_FAULT, v6, buf, 0xCu);
      goto LABEL_7;
    }

    goto LABEL_7;
  }

  unint64_t v36 = 0;
  objc_msgSend(objc_getProperty(self, v4, 16, 1), "getBytes:length:", &v36, 4);
  unint64_t v8 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
  objc_setProperty_atomic(self, v9, v8, 24LL);

  unint64_t v10 = v36;
  Property = objc_getProperty(self, v11, 24LL, 1);
  if (Property) {
    Property[1] = v10;
  }
  unsigned __int16 v13 = objc_alloc_init(MEMORY[0x189603FA8]);
  unint64_t v15 = objc_getProperty(self, v14, 24LL, 1);
  if (v15) {
    objc_setProperty_atomic(v15, v16, v13, 16LL);
  }

  __int16 v18 = objc_msgSend(objc_getProperty(self, v17, 16, 1), "length");
  uint64_t v21 = v18;
  if (v18 >= 5)
  {
    unint64_t v22 = v18;
    uint64_t v23 = 4;
    *(void *)&BOOL v20 = 67109376LL;
    uint64_t v35 = v20;
    while (1)
    {
      unint64_t v24 = objc_getProperty(self, v19, 16LL, 1);
      BOOL v25 = (unsigned __int16 *)([v24 bytes] + v23);
      unint64_t v26 = bswap32(v25[1]) >> 16;
      __int16 v27 = bswap32(*v25) >> 16;
      ne_log_obj();
      unint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = v35;
        v38[0] = v27;
        LOWORD(v38[1]) = 1024;
        *(_DWORD *)((char *)&v38[1] + 2) = v26;
        _os_log_debug_impl( &dword_1876B1000,  v28,  OS_LOG_TYPE_DEBUG,  "Parsing configuration attribute of type %u length %u",  buf,  0xEu);
      }

      uint64_t v29 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v25 + 2 length:v26];
      -[NEIKEv2ConfigPayload createConfigAttributeFromData:attributeName:attributeLen:attributeType:customType:]( (uint64_t)self,  v29,  0LL,  v26,  v27,  0LL);
      unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
      if (v31)
      {
        unint64_t v32 = objc_getProperty(self, v30, 24LL, 1);
        if (v32) {
          unint64_t v32 = objc_getProperty(v32, v33, 16LL, 1);
        }
        uint64_t v34 = v32;
        [v34 addObject:v31];
      }

      v23 += v26 + 4;

      if (v23 >= v21) {
        return -[NEIKEv2ConfigPayload hasRequiredFields](self, "hasRequiredFields", v35);
      }
    }
  }

  return -[NEIKEv2ConfigPayload hasRequiredFields](self, "hasRequiredFields", v35);
}

    return 0;
  }

  if ((unint64_t)objc_msgSend(objc_getProperty(self, v3, 16, 1), "length") <= 3)
  {
    ne_log_obj();
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)unint64_t v57 = "-[NEIKEv2ResponseConfigPayload parsePayloadData]";
      unint64_t v6 = "%s called with null (self.payloadData.length >= sizeof(ikev2_payload_config_hdr_t))";
LABEL_58:
      _os_log_fault_impl(&dword_1876B1000, v5, OS_LOG_TYPE_FAULT, v6, buf, 0xCu);
      goto LABEL_7;
    }

    goto LABEL_7;
  }

  BOOL v55 = 0;
  objc_msgSend(objc_getProperty(self, v4, 16, 1), "getBytes:length:", &v55, 4);
  unint64_t v8 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
  objc_setProperty_atomic(self, v9, v8, 24LL);

  unint64_t v10 = self;
  unint64_t v11 = v55;
  selfa = v10;
  Property = objc_getProperty(v10, v12, 24LL, 1);
  if (Property) {
    Property[1] = v11;
  }
  unint64_t v14 = objc_alloc_init(MEMORY[0x189603FA8]);
  unint64_t v15 = selfa;
  unsigned __int16 v17 = objc_getProperty(selfa, v16, 24LL, 1);
  if (v17) {
    objc_setProperty_atomic(v17, v18, v14, 16LL);
  }

  uint64_t v50 = objc_msgSend(objc_getProperty(selfa, v19, 16, 1), "length");
  if (v50 >= 5)
  {
    unint64_t v22 = 4;
    *(void *)&uint64_t v21 = 67109376LL;
    uint64_t v48 = v21;
    uint64_t v23 = &off_18A087000;
    do
    {
      unint64_t v24 = objc_getProperty(v15, v20, 16LL, 1);
      unint64_t v26 = (unsigned __int16 *)([v24 bytes] + v22);
      __int16 v27 = bswap32(v26[1]) >> 16;
      if (v27 + (unint64_t)v22 + 4 > v50)
      {

        return -[NEIKEv2ConfigPayload hasRequiredFields](v15, "hasRequiredFields", v48);
      }

      unint64_t v28 = 0LL;
      uint64_t v29 = bswap32(*v26);
      uint64_t v30 = HIWORD(v29);
      if (v29 >> 16 >= 0x4000 && (unsigned __int16)(HIWORD(v29) - 25960) <= 0xFFFDu)
      {
        uint64_t v53 = 0u;
        uint64_t v54 = 0u;
        uint64_t v51 = 0u;
        uint64_t v52 = 0u;
        unint64_t v31 = objc_getProperty(v15, v25, 32LL, 1);
        if (v31) {
          unint64_t v31 = objc_getProperty(v31, v32, 16LL, 1);
        }
        unint64_t v33 = v31;
        unint64_t v28 = (id)[v33 countByEnumeratingWithState:&v51 objects:v58 count:16];
        if (v28)
        {
          uint64_t v34 = *(void *)v52;
          while (2)
          {
            for (i = 0LL; i != v28; i = (char *)i + 1)
            {
              if (*(void *)v52 != v34) {
                objc_enumerationMutation(v33);
              }
              unint64_t v36 = *(void **)(*((void *)&v51 + 1) + 8LL * (void)i);
              if ((unint64_t)objc_msgSend(v36, "attributeType", v48) >= 0x4000
                && !((unint64_t)[v36 attributeType] >> 15)
                && [v36 attributeType] == v30)
              {
                unint64_t v28 = v36;
                goto LABEL_31;
              }
            }

            unint64_t v28 = (id)[v33 countByEnumeratingWithState:&v51 objects:v58 count:16];
            if (v28) {
              continue;
            }
            break;
          }

  unint64_t v14 = v7;
LABEL_8:

  return v14;
}

  unint64_t v14 = v7;
LABEL_8:

  return v14;
}

    unint64_t v9 = 0;
    goto LABEL_8;
  }

  objc_msgSend(objc_getProperty(self, v6, 24, 1), "addObject:", v5);
  Property = objc_getProperty(self, v7, 32LL, 1);
LABEL_4:
  [Property removeObject:v5];
  unint64_t v9 = 1;
LABEL_8:

  return v9;
}

    unint64_t v9 = 0;
    goto LABEL_8;
  }

  objc_msgSend(objc_getProperty(self, v6, 24, 1), "removeObject:", v5);
  Property = objc_getProperty(self, v7, 24LL, 1);
LABEL_4:
  [Property addObject:v5];
  unint64_t v9 = 1;
LABEL_8:

  return v9;
}

    goto LABEL_8;
  }

  -[NEIPv6Settings addresses](self, "addresses");
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  char v7 = [v6 objectAtIndexedSubscript:0];
  unint64_t v8 = inet_pton(30, (const char *)[v7 UTF8String], v50);

  if (!v8)
  {
    ne_log_obj();
    unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      unint64_t v10 = "Invalid IPv6 address";
LABEL_43:
      _os_log_error_impl(&dword_1876B1000, v9, OS_LOG_TYPE_ERROR, v10, buf, 2u);
      goto LABEL_7;
    }

    goto LABEL_7;
  }

  objc_sync_exit(v4);
}

  if (result) {
    CFRelease(result);
  }

  return v12;
}

  return v5;
}

  unint64_t v10 = 0LL;
LABEL_8:
  if (v7) {
    free(v7);
  }
  if (v9) {
    free(v9);
  }
  return v10;
}

  close(v0);
  return 0LL;
}

LABEL_31:
    unint64_t v11 = 0LL;
  }

  [a1 appVPN];
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
  [v38 protocol];
  unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();

  if (v39) {
    goto LABEL_33;
  }
  unint64_t v40 = -[NETunnelProviderProtocol initWithPluginType:]( objc_alloc(&OBJC_CLASS___NETunnelProviderProtocol),  "initWithPluginType:",  v31);
  [a1 appVPN];
  unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
  [v41 setProtocol:v40];

  [a1 appVPN];
  unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
  [v42 protocol];
  int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();

  if (v43)
  {
LABEL_33:
    [a1 appVPN];
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    [v44 protocol];
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();

    unint64_t v10 = (id)v31;
    unint64_t v12 = v100;
LABEL_37:
    v101 = v12;
    if (!+[NETunnelProviderProtocol isLegacyPluginType:]( &OBJC_CLASS___NETunnelProviderProtocol,  "isLegacyPluginType:",  v10))
    {
      [a1 setApplication:v10];
      [a1 setApplicationIdentifier:v10];
      if (v45) {
        objc_setProperty_atomic(v45, v51, @"com.apple.managed.vpn.shared", 88LL);
      }
    }

    [v14 objectForKeyedSubscript:@"RemoteAddress"];
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
    [v45 setServerAddress:v52];

    [v14 objectForKeyedSubscript:@"AuthName"];
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
    [v45 setUsername:v53];

    [v45 setPasswordReference:0];
    [v45 setPasswordKeychainItem:0];
    [v14 objectForKeyedSubscript:@"AuthPassword"];
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEConfiguration setConfigurationVPNPassword:](a1, v54);

    [v45 setIdentityReferenceInternal:0];
    [v13 objectForKeyedSubscript:@"PayloadCertificateUUID"];
    BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();

    if (v55)
    {
      unint64_t v56 = v13;
    }

    else
    {
      [v14 objectForKeyedSubscript:@"PayloadCertificateUUID"];
      unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v57)
      {
        [v13 objectForKeyedSubscript:@"LocalCertificate"];
        v83 = (void *)objc_claimAutoreleasedReturnValue();

        if (v83)
        {
          uint64_t v84 = v13;
        }

        else
        {
          [v14 objectForKeyedSubscript:@"LocalCertificate"];
          CFErrorRef v90 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v90) {
            goto LABEL_48;
          }
          uint64_t v84 = v14;
        }

        [v84 objectForKeyedSubscript:@"LocalCertificate"];
        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
        setLocalCertificate(v59);
        uint64_t v61 = (id)objc_claimAutoreleasedReturnValue();
        [v45 setIdentityReferenceInternal:v61];
LABEL_47:

LABEL_48:
        [v14 objectForKeyedSubscript:@"AuthenticationMethod"];
        uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue();
        [v14 objectForKeyedSubscript:@"PayloadCertificateUUID"];
        uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
        if (v63
          || ([v13 objectForKeyedSubscript:@"PayloadCertificateUUID"],
              (uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue()) != 0LL))
        {
        }

        else if (([v62 isEqualToString:@"Certificate"] & 1) == 0)
        {
          if (([v62 isEqualToString:@"Password"] & 1) == 0)
          {
            uint64_t v85 = [v45 username];
            if (!v85
              || (v86 = (void *)v85,
                  [v14 objectForKeyedSubscript:@"AuthPassword"],
                  v87 = (void *)objc_claimAutoreleasedReturnValue(),
                  v87,
                  v86,
                  !v87))
            {
              ne_log_obj();
              v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
              {
                v95 = (__CFString *)objc_opt_class();
                *(_DWORD *)buf = 138412546;
                v104 = v95;
                v105 = 2112;
                v106 = v62;
                v96 = v95;
                _os_log_error_impl( &dword_1876B1000,  v94,  OS_LOG_TYPE_ERROR,  "%@ configurePluginWithPayload: unsupported authen type %@.",  buf,  0x16u);
              }

              goto LABEL_95;
            }
          }

          uint64_t v64 = 0LL;
LABEL_52:
          [v45 setAuthenticationMethod:v64];
          [v13 objectForKeyedSubscript:@"VendorConfig"];
          uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue();

          if (v65)
          {
            [v13 objectForKeyedSubscript:@"VendorConfig"];
            uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v67 = (void *)[v66 copy];
            [v45 setProviderConfiguration:v67];
          }

          [v14 objectForKeyedSubscript:@"AuthPasswordPluginType"];
          uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue();
          [v45 setAuthenticationPluginType:v68];

          if (-[NEConfiguration ingestDisconnectOptions:](a1, v14))
          {
            [v14 objectForKeyedSubscript:@"ProviderBundleIdentifier"];
            uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();
            [v45 setProviderBundleIdentifier:v69];

            [v14 objectForKeyedSubscript:@"ExtensibleSSOProvider"];
            size_t v70 = (void *)objc_claimAutoreleasedReturnValue();
            [v45 setExtensibleSSOProvider:v70];

            [v14 objectForKeyedSubscript:@"EnforceRoutes"];
            unint64_t v71 = (void *)objc_claimAutoreleasedReturnValue();
            v99 = v71;
            objc_msgSend(v9, "payloadAtom", v62);
            uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue();
            [v72 objectForKeyedSubscript:@"CellularSliceUUID"];
            unint64_t v73 = (void *)objc_claimAutoreleasedReturnValue();

            if (v73)
            {
              [v9 payloadAtom];
              uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue();
              [v74 objectForKeyedSubscript:@"CellularSliceUUID"];
              unint64_t v75 = (void *)objc_claimAutoreleasedReturnValue();
              [v45 setSliceUUID:v75];
            }

            [a1 VPN];
            uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue();
            [v76 protocol];
            unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue();
            objc_opt_class();
            isKindOfClass = objc_opt_isKindOfClass();

            if ((isKindOfClass & 1) != 0)
            {
              [v14 objectForKeyedSubscript:@"Order"];
              uint64_t v79 = (__CFString *)objc_claimAutoreleasedReturnValue();
              if (isa_nsnumber(v79))
              {
                [a1 VPN];
                uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();
                [v80 protocol];
                objc_super v81 = (void *)objc_claimAutoreleasedReturnValue();

                if (-[__CFString integerValue](v79, "integerValue") < 0
                  || (unint64_t)-[__CFString unsignedIntegerValue](v79, "unsignedIntegerValue") >> 31)
                {
                  ne_log_obj();
                  uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 138412290;
                    v104 = v79;
                    _os_log_error_impl( &dword_1876B1000,  v82,  OS_LOG_TYPE_ERROR,  "Transparent proxy order is invalid: %@",  buf,  0xCu);
                  }

                  v102 = 0;
LABEL_91:
                  unint64_t v12 = v101;

                  goto LABEL_79;
                }

                objc_msgSend(v81, "setOrder:", -[__CFString unsignedIntegerValue](v79, "unsignedIntegerValue"));
              }
            }

            ne_log_obj();
            unint64_t v91 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
            {
              [v45 serverAddress];
              v92 = (__CFString *)objc_claimAutoreleasedReturnValue();
              [v45 providerConfiguration];
              v93 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138412546;
              v104 = v92;
              v105 = 2112;
              v106 = v93;
              _os_log_debug_impl( &dword_1876B1000,  v91,  OS_LOG_TYPE_DEBUG,  "configurePluginWithPayload: done, serverAddress %@, providerConfiguration %@",  buf,  0x16u);
            }

            v102 = 1;
            goto LABEL_91;
          }

    goto LABEL_32;
  }

  v432 = 1;
LABEL_43:

LABEL_44:
  v444 = 0;
  if ((*(_BYTE *)(a1 + 23) & 1) == 0)
  {
    unint64_t v31 = v16;
    -[NEConfigurationManager errorWithCode:specifics:](a1, 10LL, 0LL);
    unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v33 = 0LL;
    uint64_t v34 = 0LL;
    uint64_t v35 = 0LL;
    unint64_t v36 = 0LL;
    uint64_t v37 = 0LL;
    uint64_t v38 = 0LL;
    unint64_t v39 = 0LL;
    unint64_t v40 = 0LL;
    unint64_t v41 = 0LL;
    goto LABEL_411;
  }

  unint64_t v42 = objc_getProperty((id)a1, v30, 88LL, 1);
  [v17 identifier];
  int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
  [v42 objectForKeyedSubscript:v43];
  uint64_t v44 = (id)objc_claimAutoreleasedReturnValue();

  v414 = v44;
  v424 = v17;
  if (!v44 || v44 == v17) {
    goto LABEL_101;
  }
  uint64_t v45 = v44;
  uint64_t v46 = v17;
  int64_t v47 = [v45 VPN];
  if (v47)
  {
    uint64_t v48 = (void *)v47;
    uint64_t v49 = [v46 VPN];
    if (!v49)
    {

      a1 = v418;
      goto LABEL_54;
    }

    uint64_t v50 = (void *)v49;
    [v45 VPN];
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v52 = [v51 protocol];
    if (v52)
    {
      uint64_t v53 = (void *)v52;
      [v45 VPN];
      v426 = (void *)objc_claimAutoreleasedReturnValue();
      [v426 protocol];
      v356 = v16;
      uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();
      v430 = [v54 type];
      unint64_t v12 = [v46 VPN];
      [(id)v12 protocol];
      BOOL v55 = v46;
      unint64_t v56 = v13;
      unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
      v420 = [v57 type];

      unsigned __int16 v13 = v56;
      uint64_t v46 = v55;

      unint64_t v15 = v416;
      unint64_t v16 = v356;

      a1 = v418;
      unsigned __int16 v17 = v424;
      if (v430 == v420) {
        goto LABEL_56;
      }
LABEL_54:
      [v45 VPN];
      unint64_t v58 = (void *)objc_claimAutoreleasedReturnValue();
      goto LABEL_59;
    }

    a1 = v418;
    unsigned __int16 v17 = v424;
  }

          unint64_t v15 = selfa;
          uint64_t v23 = &off_18A087000;
        }
      }

      ne_log_obj();
      uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = v48;
        *(_DWORD *)unint64_t v57 = v30;
        *(_WORD *)&v57[4] = 1024;
        *(_DWORD *)&v57[6] = v27;
        _os_log_debug_impl( &dword_1876B1000,  v37,  OS_LOG_TYPE_DEBUG,  "Parsing configuration attribute of type %u length %u",  buf,  0xEu);
      }

      uint64_t v38 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v26 + 2 length:v27];
      if (v28)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            uint64_t v30 = 1LL;
          }

          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              uint64_t v30 = 8LL;
            }

            else
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                uint64_t v30 = 2LL;
              }

              else
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0) {
                  uint64_t v30 = 15LL;
                }
              }
            }
          }

          objc_msgSend(v28, "attributeName", v48);
          uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
          -[NEIKEv2ConfigPayload createConfigAttributeFromData:attributeName:attributeLen:attributeType:customType:]( (uint64_t)v15,  v38,  v44,  v27,  v30,  [v28 attributeType]);
          unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v42) {
            goto LABEL_53;
          }
LABEL_50:
          uint64_t v45 = objc_getProperty(v15, v43, 24LL, 1);
          if (v45) {
            uint64_t v45 = objc_getProperty(v45, v46, 16LL, 1);
          }
          int64_t v47 = v45;
          [v47 addObject:v42];

          goto LABEL_53;
        }

        unint64_t v39 = (void *)objc_msgSend( objc_alloc(NSString), "initWithBytes:length:encoding:", objc_msgSend(v38, "bytes"), v27, 4);
        unint64_t v40 = objc_alloc((Class)v23[404]);
        [v28 attributeName];
        unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v42 = (void *)[v40 initCustomWithAttributeType:v30 attributeName:v41 stringValue:v39];

        uint64_t v23 = &off_18A087000;
        if (v42) {
          goto LABEL_50;
        }
      }

      else
      {
        -[NEIKEv2ConfigPayload createConfigAttributeFromData:attributeName:attributeLen:attributeType:customType:]( (uint64_t)v15,  v38,  0LL,  v27,  v30,  0LL);
        unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
        if (v42) {
          goto LABEL_50;
        }
      }

      unint64_t v6 = 0LL;
LABEL_32:

      return v6;
    case '""':
      unint64_t v5 = off_18A087BB8;
      goto LABEL_25;
    case '#':
      unint64_t v5 = off_18A087B68;
      goto LABEL_25;
    case '$':
      unint64_t v5 = off_18A087C38;
      goto LABEL_25;
    case '%':
      unint64_t v5 = off_18A0879C8;
      goto LABEL_25;
    case '&':
      unint64_t v5 = off_18A0879D0;
      goto LABEL_25;
    case '\'':
      unint64_t v5 = off_18A0879B8;
      goto LABEL_25;
    case '(':
      unint64_t v5 = off_18A087BE8;
      goto LABEL_25;
    case ')':
      unint64_t v5 = off_18A087BF0;
      goto LABEL_25;
    case '*':
      unint64_t v5 = off_18A087A40;
      goto LABEL_25;
    case '+':
      unint64_t v5 = off_18A087CD8;
      goto LABEL_25;
    case ',':
      unint64_t v5 = off_18A087B70;
      goto LABEL_25;
    case '-':
      unint64_t v5 = off_18A087C40;
      goto LABEL_25;
    case '.':
      goto LABEL_25;
    case '/':
      unint64_t v5 = off_18A087A00;
      goto LABEL_25;
    case '0':
      unint64_t v5 = off_18A087A50;
      goto LABEL_25;
    case '1':
      unint64_t v5 = off_18A087AA8;
      goto LABEL_25;
    case '5':
      unint64_t v5 = off_18A087A68;
LABEL_25:
      unint64_t v6 = (os_log_s *)objc_alloc_init(*v5);
      if (v6) {
        goto LABEL_26;
      }
      goto LABEL_27;
    default:
      ne_log_obj();
      unint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        unsigned __int16 v17 = 67109120;
        LODWORD(v18) = a2;
        _os_log_impl( &dword_1876B1000,  v8,  OS_LOG_TYPE_INFO,  "Received unknown payload type %u, saving as custom",  (uint8_t *)&v17,  8u);
      }

      unint64_t v9 = objc_alloc_init(&OBJC_CLASS___NEIKEv2CustomPayload);
      unint64_t v6 = (os_log_s *)v9;
      if (!v9) {
        goto LABEL_27;
      }
      v9->_customType = a2;
LABEL_26:
      objc_setProperty_atomic(v6, v10, v4, 16LL);
      *((_BYTE *)v6 + 8) = 1;
LABEL_27:
      if ((-[os_log_s parsePayloadData](v6, "parsePayloadData") & 1) != 0) {
        goto LABEL_32;
      }
      ne_log_obj();
      unint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        unsigned __int16 v17 = 138412290;
        __int16 v18 = v6;
        _os_log_error_impl( &dword_1876B1000,  v11,  OS_LOG_TYPE_ERROR,  "Failed to parse payload data for %@",  (uint8_t *)&v17,  0xCu);
      }

      goto LABEL_31;
  }

  if (v48) {
    free(v48);
  }
  if (v47) {
    free(v47);
  }
  unint64_t v28 = v37[3];
  if (v28)
  {
    uint64_t v29 = _NEIPSecDBGetQueue();
    *(void *)buf = v7;
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = __NEIPSecDBRemoveQueuedRequest_block_invoke;
    uint64_t v53 = &__block_descriptor_tmp_163;
    uint64_t v54 = v28;
    dispatch_sync(v29, buf);
    free((void *)v37[3]);
  }

  uint64_t v30 = *((unsigned int *)v41 + 6);
  _Block_object_dispose(&v36, 8);
  _Block_object_dispose(&v40, 8);
  return v30;
}
    }

    unint64_t v11 = [v10 countByEnumeratingWithState:&v42 objects:v52 count:16];
  }

  while (v11);
LABEL_33:

  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __71__NETunnelProviderManager_loadAllFromPreferencesWithCompletionHandler___block_invoke_35;
  block[3] = &unk_18A0904A8;
  uint64_t v38 = &v46;
  unint64_t v36 = v33;
  uint64_t v37 = *(id *)(v30 + 32);
  dispatch_group_notify(group, MEMORY[0x1895F8AE0], block);

LABEL_35:
  _Block_object_dispose(&v46, 8);

  objc_sync_exit(obj);
}

LABEL_32:
  self->_resolvedProviderMachOUUIDs = 1;
  if ([v11 count])
  {
    unint64_t v26 = (NSArray *)[objc_alloc(MEMORY[0x189603F18]) initWithArray:v11];
    providerMachOUUIDs = self->_providerMachOUUIDs;
    self->_providerMachOUUIDs = v26;
  }

  unint64_t v28 = self->_providerMachOUUIDs;

  return v28;
}

  uint64_t v34 = 0LL;
LABEL_43:

LABEL_44:
  return v34;
}

        goto LABEL_33;
      }

  unsigned __int16 v13 = 0LL;
LABEL_17:
  unint64_t v14 = *(void *)(a1 + 48);
  if (v14) {
    unint64_t v15 = *(void *)(v14 + 16);
  }
  else {
    unint64_t v15 = 0LL;
  }
  (*(void (**)(uint64_t, void *))(v15 + 16))(v15, v13);
}

  return v27;
}

      char v7 = 0LL;
      goto LABEL_5;
    }

    if (((1LL << a2) & 0x3000000000LL) != 0)
    {
      unint64_t v9 = objc_alloc(&OBJC_CLASS___NEIKEv2KeyExchangeHandlerMLKEM);
      unint64_t v10 = (id *)v4;
      unint64_t v6 = v10;
      if (!v9) {
        goto LABEL_32;
      }
      if (!v10)
      {
        ne_log_obj();
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136315138;
          unint64_t v32 = "-[NEIKEv2KeyExchangeHandlerMLKEM initWithMLKEMMethod:peerPayload:]";
          _os_log_fault_impl(&dword_1876B1000, v23, OS_LOG_TYPE_FAULT, "%s called with null peerPayload", buf, 0xCu);
        }

        goto LABEL_30;
      }

      char v7 = (NEIKEv2KeyExchangeHandlerMLKEM *)-[NEIKEv2KeyExchangeHandler initWithMethod:](v9, a2);
      if (!v7) {
        goto LABEL_5;
      }
      ne_log_obj();
      unint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        method = (const char *)v7->super._method;
        *(_DWORD *)buf = 134217984;
        unint64_t v32 = method;
        _os_log_debug_impl(&dword_1876B1000, v11, OS_LOG_TYPE_DEBUG, "Encapsulate ML-KEM %zu secret", buf, 0xCu);
      }

      unint64_t v12 = v7->super._method;
      if (v12 == 37)
      {
        unsigned __int16 v13 = &OBJC_CLASS____TtC16NetworkExtension25NEIKEv2CryptoKitMLKEM1024;
      }

      else
      {
        if (v12 != 36)
        {
          ne_log_obj();
          uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
          {
            unint64_t v26 = (const char *)v7->super._method;
            *(_DWORD *)buf = 134217984;
            unint64_t v32 = v26;
            _os_log_fault_impl(&dword_1876B1000, v23, OS_LOG_TYPE_FAULT, "Invalid ML-KEM type %zu", buf, 0xCu);
          }

              unint64_t v31 = v100;
            }

            BOOL v25 = v101;
            v102 = [v30 countByEnumeratingWithState:&v117 objects:buf count:16];
            if (v102) {
              continue;
            }
            break;
          }
        }

        ne_log_obj();
        unint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v9 = v103;
        char v7 = v104;
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          if (v14) {
            v96 = objc_getProperty(v14, v40, 96LL, 1);
          }
          else {
            v96 = 0LL;
          }
          v97 = v96;
          v98 = [v97 method];
          *(_DWORD *)buf = 138412546;
          *(void *)&buf[4] = v6;
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v98;
          _os_log_error_impl( &dword_1876B1000,  v39,  OS_LOG_TYPE_ERROR,  "%@ Received KE method preference %tu is not in Child rekey proposal (child rekey retry KE)",  buf,  0x16u);
        }

        [v104 sendCallbackSuccess:0 session:v6];
        if (v14) {
          unint64_t v42 = objc_getProperty(v14, v41, 96LL, 1);
        }
        else {
          unint64_t v42 = 0LL;
        }
        ErrorCrypto = v42;
        uint64_t v44 = [ErrorCrypto method];
        ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Received KE method preference %tu is not in Child rekey proposal (child rekey retry KE)",  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v44);
        -[NEIKEv2ChildSA setState:error:]((uint64_t)v14, 3uLL, ErrorPeerInvalidSyntax);

LABEL_50:
        -[NEIKEv2Session reportState](v6, v85);
        -[NEIKEv2Session resetChild:]((char *)v6, v14);
      }

    unint64_t v78 = (os_log_s *)v63;
    uint64_t v79 = 2;
LABEL_38:
    _os_log_fault_impl(&dword_1876B1000, v78, OS_LOG_TYPE_FAULT, v77, buf, v79);
    goto LABEL_63;
  }

  ne_log_obj();
  unint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v215 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitForInitiatorIKESA:]";
    uint64_t v80 = "%s called with null ikeSA.preferredKEMProtocol";
LABEL_40:
    _os_log_fault_impl(&dword_1876B1000, v6, OS_LOG_TYPE_FAULT, v80, buf, 0xCu);
  }

        *(_WORD *)buf = 0;
        uint64_t v23 = v22;
        unint64_t v24 = "Traffic selector missing start address";
LABEL_33:
        _os_log_error_impl(&dword_1876B1000, v23, OS_LOG_TYPE_ERROR, v24, buf, 2u);
        goto LABEL_34;
      }

      if (!v18)
      {
        ne_log_obj();
        unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          goto LABEL_34;
        }
        goto LABEL_32;
      }

      if (!v20)
      {
        ne_log_obj();
        unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          goto LABEL_34;
        }
        goto LABEL_32;
      }

      *(void *)buf = 0LL;
      *(void *)&buf[8] = 0LL;
      buf[0] = -[NEIKEv2TrafficSelector type]((uint64_t)v15);
      *(_WORD *)&buf[2] = 4096;
      buf[1] = [v15 ipProtocol];
      *(_WORD *)&buf[4] = __rev16([v15 startPort]);
      else {
        uint64_t v21 = -1;
      }
      *(_WORD *)&buf[6] = v21;
      *(_DWORD *)&buf[8] = *(_DWORD *)(v18 + 4);
      *(_DWORD *)&buf[12] = *(_DWORD *)(v20 + 4);
      v12 += 16LL;
      unint64_t v26 = objc_alloc(MEMORY[0x189603F48]);
      __int16 v27 = 16LL;
LABEL_39:
      unint64_t v28 = (void *)objc_msgSend(v26, "initWithBytes:length:", buf, v27, selfa);
      [v40 addObject:v28];
    }

    unint64_t v11 = [v9 countByEnumeratingWithState:&v46 objects:v51 count:16];
  }

  while (v11);
LABEL_47:

  *(_DWORD *)buf = 0;
  buf[0] = [v40 count];
  unint64_t v31 = (void *)[objc_alloc(MEMORY[0x189603FB8]) initWithCapacity:v12 + 4];
  [v31 appendBytes:buf length:4];
  int64_t v43 = 0u;
  uint64_t v44 = 0u;
  unint64_t v41 = 0u;
  unint64_t v42 = 0u;
  unint64_t v32 = v40;
  unint64_t v33 = [v32 countByEnumeratingWithState:&v41 objects:v50 count:16];
  if (v33)
  {
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)v42;
    do
    {
      for (j = 0LL; j != v34; ++j)
      {
        if (*(void *)v42 != v35) {
          objc_enumerationMutation(v32);
        }
        objc_msgSend(v31, "appendData:", *(void *)(*((void *)&v41 + 1) + 8 * j), selfa);
      }

      uint64_t v34 = [v32 countByEnumeratingWithState:&v41 objects:v50 count:16];
    }

    while (v34);
  }

  unint64_t v2 = selfa;
  if (selfa)
  {
    objc_setProperty_atomic(selfa, v37, v31, 16LL);

    goto LABEL_56;
  }

  Property = 0LL;
  return Property != 0LL;
}
    }

    unsigned __int16 v13 = -[__CFArray countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v31,  v35,  16LL);
    if (v13) {
      continue;
    }
    break;
  }

  unint64_t v22 = 0LL;
LABEL_43:
  size_t v4 = v28;
  uint64_t v3 = v29;
LABEL_45:

  CFRelease(v11);
LABEL_46:
  CFRelease(v7);
  ne_log_obj();
  BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    uint64_t v37 = (uint64_t)v22;
    _os_log_debug_impl( &dword_1876B1000,  v25,  OS_LOG_TYPE_DEBUG,  "getServiceIDForPayload found matching service %@",  buf,  0xCu);
  }

LABEL_49:
  return v22;
}

LABEL_12:
  -[NEConfiguration contentFilter](self, "contentFilter");
  __int16 v18 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v18) {
    goto LABEL_18;
  }
  -[NEConfiguration contentFilter](self, "contentFilter");
  unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
  [v19 provider];
  BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
  [v20 pluginType];
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3)
  {
    unint64_t v22 = [v3 isEqualToString:v21];

    if ((v22 & 1) != 0) {
      goto LABEL_18;
    }
    uint64_t v21 = 0LL;
    unint64_t v19 = v3;
  }

  else
  {
  }

  uint64_t v3 = v21;
LABEL_18:
  -[NEConfiguration dnsProxy](self, "dnsProxy");
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v23) {
    goto LABEL_24;
  }
  -[NEConfiguration dnsProxy](self, "dnsProxy");
  unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  [v24 protocol];
  BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
  [v25 pluginType];
  unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3)
  {
    __int16 v27 = [v3 isEqualToString:v26];

    if ((v27 & 1) != 0) {
      goto LABEL_24;
    }
    unint64_t v26 = 0LL;
    unint64_t v24 = v3;
  }

  else
  {
  }

  uint64_t v3 = v26;
LABEL_24:
  -[NEConfiguration appPush](self, "appPush");
  unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();

  if (v28)
  {
    -[NEConfiguration appPush](self, "appPush");
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    [v29 pluginType];
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v3)
    {
      uint64_t v3 = v29;
      goto LABEL_29;
    }

    unint64_t v31 = [v3 isEqualToString:v30];

    if ((v31 & 1) == 0)
    {
      uint64_t v30 = 0LL;
LABEL_29:

      uint64_t v3 = v30;
    }
  }

  return (NSString *)v3;
}

  return v2;
}
}

  BOOL v20 = 0LL;
LABEL_20:

LABEL_21:
  if (v20)
  {
    uint64_t v23 = *(void *)(a1 + 32);
    unint64_t v24 = *(void *)(a1 + 40);
    if (v23)
    {
      BOOL v25 = *(void *)(v23 + 48);
      unint64_t v26 = *(_DWORD *)(v23 + 28);
    }

    else
    {
      BOOL v25 = 0LL;
      unint64_t v26 = 0;
    }

    Error = (void *)NEIKEv2CreateError(3LL);
    v80[0] = MEMORY[0x1895F87A8];
    v80[1] = 3221225472LL;
    v80[2] = __48__NEIKEv2Session_Exchange__initiateMOBIKEInner___block_invoke_459;
    v80[3] = &unk_18A08D280;
    v80[4] = *(void *)(a1 + 40);
    objc_super v81 = v20;
    uint64_t v82 = *(id *)(a1 + 32);
    v83 = *(id *)(a1 + 48);
    unint64_t v28 = -[NEIKEv2Session sendRequest:retryIntervalInMilliseconds:maxRetries:timeoutError:resend:sendMessageID:sendCompletionHandler:replyHandler:]( v24,  v81,  v25,  v26,  Error,  0,  0xFFFFFFFFLL,  0LL,  v80);

    if (v28 == -1)
    {
      unint64_t v36 = *(id **)(a1 + 32);
      uint64_t v37 = *(void **)(a1 + 40);
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"initiator update addresses",  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v77);
      -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](v36, 0LL, v37, ErrorFailedToSend);

      Property = *(id *)(a1 + 40);
      if (Property) {
        Property = objc_getProperty(Property, v39, 336LL, 1);
      }
      unint64_t v41 = Property;
      uint64_t v49 = (void *)NEIKEv2CreateErrorFailedToSend( @"initiator update addresses",  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v78);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v41, 3uLL, v49);

      -[NEIKEv2Session reportState](*(void **)(a1 + 40), v50);
      -[NEIKEv2Session resetAll](*(void *)(a1 + 40), v51);
    }
  }

  else
  {
    ne_log_obj();
    uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl( &dword_1876B1000,  v52,  OS_LOG_TYPE_ERROR,  "Initiate MOBIKE failed to create Update Addresses packet",  buf,  2u);
    }

    uint64_t v53 = *(id **)(a1 + 32);
    uint64_t v54 = *(void **)(a1 + 40);
    ErrorInternal = (void *)NEIKEv2CreateErrorInternal( @"Initiate MOBIKE failed to create Update Addresses packet",  v55,  v56,  v57,  v58,  v59,  v60,  v61,  v76);
    -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](v53, 0LL, v54, ErrorInternal);

    uint64_t v64 = *(id *)(a1 + 40);
    if (v64) {
      uint64_t v64 = objc_getProperty(v64, v63, 336LL, 1);
    }
    uint64_t v65 = v64;
    unint64_t v73 = (void *)NEIKEv2CreateErrorInternal( @"Initiate MOBIKE failed to create Update Addresses packet",  v66,  v67,  v68,  v69,  v70,  v71,  v72,  v79);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v65, 3uLL, v73);

    -[NEIKEv2Session reportState](*(void **)(a1 + 40), v74);
    -[NEIKEv2Session resetAll](*(void *)(a1 + 40), v75);
  }
}

      goto LABEL_13;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      ne_log_obj();
      unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        *(void *)&buf[4] = v6;
        unint64_t v11 = "Listener received non SA_INIT packet %@";
        goto LABEL_41;
      }

      goto LABEL_12;
    }

    if (self)
    {
      WeakRetained = (os_log_s *)objc_loadWeakRetained((id *)&self->_packetDelegate);
      unint64_t v15 = self->_ikeConfig;
      if (WeakRetained) {
        goto LABEL_21;
      }
      ikeConfig = self->_ikeConfig;
    }

    else
    {
      unint64_t v15 = 0LL;
      ikeConfig = 0LL;
    }

    unsigned __int16 v17 = v15;
    __int16 v18 = ikeConfig;
    unint64_t v15 = (NEIKEv2IKESAConfiguration *)-[NEIKEv2IKESAConfiguration copy](v18, "copy");

    if (v7) {
      Property = objc_getProperty(v7, v19, 24LL, 1);
    }
    else {
      Property = 0LL;
    }
    uint64_t v21 = Property;
    unint64_t v22 = (void *)[v21 copy];
    -[NEIKEv2IKESAConfiguration setRemoteEndpoint:](v15, "setRemoteEndpoint:", v22);

    WeakRetained = 0LL;
    unint64_t v10 = 0LL;
    uint64_t v23 = 0LL;
    if (!self)
    {
LABEL_22:
      unint64_t v24 = v23 == 0LL;
      BOOL v25 = objc_alloc(&OBJC_CLASS___NEIKEv2Session);
      -[NEIKEv2Listener listenerQueue](self, "listenerQueue");
      unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
      if (v24)
      {
        if (self)
        {
          kernelSASessionName = self->_kernelSASessionName;
          uint64_t v34 = (os_log_s *)v25;
          uint64_t v35 = v15;
          unint64_t v36 = self;
          uint64_t v37 = v26;
        }

        else
        {
          uint64_t v34 = (os_log_s *)v25;
          uint64_t v35 = v15;
          unint64_t v36 = 0LL;
          uint64_t v37 = v26;
          kernelSASessionName = 0LL;
        }

        unint64_t v32 = -[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:kernelSASessionName:transport:packetDelegate:]( v34,  v35,  v36,  v37,  kernelSASessionName,  v7,  v10);
      }

      else
      {
        if (self)
        {
          saSession = self->_saSession;
          unint64_t v28 = (os_log_s *)v25;
          uint64_t v29 = v15;
          uint64_t v30 = self;
          unint64_t v31 = v26;
        }

        else
        {
          unint64_t v28 = (os_log_s *)v25;
          uint64_t v29 = v15;
          uint64_t v30 = 0LL;
          unint64_t v31 = v26;
          saSession = 0LL;
        }

        unint64_t v32 = -[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:saSession:shouldCopySASession:transport:packetDelegate:]( v28,  v29,  v30,  v31,  saSession,  v7,  v10);
      }

      uint64_t v38 = v32;

      if (v38)
      {
        if (self) {
          sessionsBeforeAuth = self->_sessionsBeforeAuth;
        }
        else {
          sessionsBeforeAuth = 0LL;
        }
        -[NSMutableSet addObject:](sessionsBeforeAuth, "addObject:", v38);
        ne_log_large_obj();
        unint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          *(void *)&buf[4] = v38;
          uint64_t v49 = 2112;
          uint64_t v50 = v6;
          _os_log_impl(&dword_1876B1000, v40, OS_LOG_TYPE_DEFAULT, "Created new session %@ to handle %@", buf, 0x16u);
        }

        -[os_log_s receivePacket:](v38, "receivePacket:", v6);
        if (self)
        {
          unint64_t v41 = objc_loadWeakRetained((id *)&self->_delegate);
          objc_initWeak((id *)buf, v41);

          delegateQueue = self->_delegateQueue;
        }

        else
        {
          delegateQueue = 0LL;
          *(void *)buf = 0LL;
        }

        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        block[2] = __43__NEIKEv2Listener_receivePacket_transport___block_invoke;
        block[3] = &unk_18A08D3C0;
        int64_t v43 = delegateQueue;
        objc_copyWeak(&v47, (id *)buf);
        block[4] = self;
        uint64_t v46 = v38;
        dispatch_async(v43, block);

        objc_destroyWeak(&v47);
        objc_destroyWeak((id *)buf);
      }

      else
      {
        ne_log_obj();
        uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = "-[NEIKEv2Listener receivePacket:transport:]";
          _os_log_fault_impl(&dword_1876B1000, v44, OS_LOG_TYPE_FAULT, "%s called with null newSession", buf, 0xCu);
        }
      }

      goto LABEL_12;
    }

  return v3;
}

  return v3;
}

  return v3;
}

    _os_log_error_impl(&dword_1876B1000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&buf, 2u);
    goto LABEL_13;
  }

  unsigned __int16 v17 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "NEIPSecDBDeletePolicy";
    _os_log_fault_impl(&dword_1876B1000, v17, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&buf, 0xCu);
  }

  return 0LL;
}

  return v11;
}

  packetDataArray = (uint64_t)v8->_packetDataArray;
  if (packetDataArray && v8->_packetLengths && (v8->_interfaceType != 1 || v8->_packetProtocols))
  {
    for (i = 0LL; ; ++i)
    {
      if (i >= -[NSArray count](v6, "count"))
      {
        packetDataArray = (uint64_t)v8->_packetDataArray;
        goto LABEL_33;
      }

      -[NSArray objectAtIndexedSubscript:](v6, "objectAtIndexedSubscript:", i);
      unint64_t v16 = (id)objc_claimAutoreleasedReturnValue();
      if ((isa_nsdata(v16) & 1) == 0) {
        break;
      }
      unint64_t v16 = v16;
      v8->_packetDataArray[i] = (char *)[v16 bytes];
      v8->_packetLengths[i] = [v16 length];
      if (v8->_interfaceType == 1)
      {
        -[NSArray objectAtIndexedSubscript:](v7, "objectAtIndexedSubscript:", i);
        unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
        if ((isa_nsnumber(v17) & 1) == 0)
        {
          ne_log_obj();
          BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            unint64_t v22 = 136315394;
            uint64_t v23 = "-[NEPacketTunnelFlow writePackets:withProtocols:]";
            unint64_t v24 = 2048;
            BOOL v25 = i;
            _os_log_error_impl( &dword_1876B1000,  v20,  OS_LOG_TYPE_ERROR,  "%s: object at index %lu of protocols array is not an NSNumber",  (uint8_t *)&v22,  0x16u);
          }

          goto LABEL_42;
        }

        v8->_packetProtocols[i] = [v17 unsignedIntValue];
      }
    }

    ne_log_obj();
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_ERROR))
    {
      unint64_t v22 = 136315394;
      uint64_t v23 = "-[NEPacketTunnelFlow writePackets:withProtocols:]";
      unint64_t v24 = 2048;
      BOOL v25 = i;
      _os_log_error_impl( &dword_1876B1000,  (os_log_t)v17,  OS_LOG_TYPE_ERROR,  "%s: object at index %lu of packets array is not an NSData",  (uint8_t *)&v22,  0x16u);
    }

      unsigned __int16 v13 = self;
      unint64_t v14 = 2LL;
      unint64_t v15 = 0LL;
      goto LABEL_13;
    }

    Property = objc_getProperty(self, v10, 56LL, 1);
  }

  else
  {
    if (!v6)
    {
      if (!v7) {
        goto LABEL_14;
      }
      goto LABEL_10;
    }

    Property = 0LL;
  }

  if (Property == v6)
  {
    if (v9)
    {
      if (self) {
        unint64_t v12 = objc_getProperty(self, v8, 48LL, 1);
      }
      else {
        unint64_t v12 = 0LL;
      }
      [v12 stopWithReason:7];
      goto LABEL_10;
    }

    goto LABEL_12;
  }
  }

  return v5;
}

  BOOL v20 = 1;
LABEL_15:

  return v20;
}
  }

  else
  {
    unint64_t v6 = 0LL;
  }

  return v6;
}

  [v4 objectForKeyedSubscript:@"HashAlgorithm"];
  unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
  __int16 v18 = isa_nsstring(v17);

  if (v18)
  {
    [v4 objectForKeyedSubscript:@"HashAlgorithm"];
    unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = [@"SHA1" isEqualToString:v19];

    if ((v20 & 1) != 0)
    {
      uint64_t v21 = 1LL;
LABEL_17:
      -[NEVPNIKEv1ProposalParameters setIntegrityAlgorithm:](v5, "setIntegrityAlgorithm:", v21);
      goto LABEL_18;
    }

    [v4 objectForKeyedSubscript:@"HashAlgorithm"];
    unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v23 = [@"MD5" isEqualToString:v22];

    if (v23)
    {
      uint64_t v21 = 2LL;
      goto LABEL_17;
    }
  }

  return v5;
}

void sub_1876CA200(_Unwind_Exception *a1)
{
}

LABEL_85:
      goto LABEL_86;
    }

    -[NEConfiguration alwaysOnVPN](self, "alwaysOnVPN");
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();

    if (v34)
    {
      unint64_t v12 = v8;
      if (!self) {
        goto LABEL_85;
      }
      -[NEConfiguration alwaysOnVPN](self, "alwaysOnVPN");
      unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
      ne_log_obj();
      uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
      {
        [v26 interfaceProtocolMapping];
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412546;
        uint64_t v65 = (const char *)v12;
        uint64_t v66 = 2112;
        uint64_t v67 = v52;
        _os_log_debug_impl( &dword_1876B1000,  v35,  OS_LOG_TYPE_DEBUG,  "NEConfiguration setCertificatesAOVpn: certs %@, mapping %@",  buf,  0x16u);
      }

      if (!v26) {
        goto LABEL_55;
      }
      unint64_t v36 = [v26 interfaceProtocolMapping];
      if (!v36
        || (uint64_t v37 = (void *)v36,
            [v26 interfaceProtocolMapping],
            uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue(),
            unint64_t v39 = [v38 count],
            v38,
            v37,
            !v39))
      {
LABEL_55:
        ne_log_obj();
        int64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl( &dword_1876B1000,  v43,  OS_LOG_TYPE_ERROR,  "NEConfiguration setCertificatesAOVpn: alwaysOnVPN Tunnel Configuration missing",  buf,  2u);
        }

        goto LABEL_58;
      }

      [v26 interfaceProtocolMapping];
      unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
      [v40 objectForKeyedSubscript:@"AlwaysOnVPNInterfaceCellular"];
      unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();

      if (v41)
      {
        if ([v41 authenticationMethod] == 1)
        {
          [v12 objectForKeyedSubscript:@"_PayloadCertificateRefForCellular"];
          unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
          if (isa_nsdata(v42))
          {
            [v41 setIdentityReferenceInternal:v42];
          }

          else if (([v41 useExtendedAuthentication] & 1) == 0)
          {
            ne_log_obj();
            uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            {
              unint64_t v56 = "invalid";
              if (!v42) {
                unint64_t v56 = "missing";
              }
              *(_DWORD *)buf = 136315138;
              uint64_t v65 = v56;
              _os_log_error_impl( &dword_1876B1000,  v53,  OS_LOG_TYPE_ERROR,  "NEConfiguration setCertificatesAOVpn: tunnel cert %s for Cellular tunnel",  buf,  0xCu);
            }

            goto LABEL_58;
          }

  uint64_t v64 = 0LL;
LABEL_100:

  return v64;
}

      return;
    }
  }

  else
  {
  }

  [(id)v1 defaultPath];
  unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_setProperty_atomic((id)v1, v33, v32, 208LL);

  uint64_t v34 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
  uint64_t v35 = *(void *)(v1 + 248);
  v103 = *(_BYTE *)(v1 + 75);
  v105 = *(_BYTE *)(v1 + 74);
  if (objc_msgSend(objc_getProperty((id)v1, v36, 208, 1), "status") == 1)
  {
    objc_msgSend(objc_getProperty((id)v1, v37, 208, 1), "scopedInterface");
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v40 = objc_getProperty((id)v1, v39, 208LL, 1);
    if (v38) {
      [v40 scopedInterface];
    }
    else {
      [v40 interface];
    }
    unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(void *)(v1 + 248) = [v41 interfaceIndex];

    *(void *)(v1 + 256) = objc_msgSend(objc_getProperty((id)v1, v42, 208, 1), "status");
    objc_msgSend(objc_getProperty((id)v1, v43, 208, 1), "scopedInterface");
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v46 = objc_getProperty((id)v1, v45, 208LL, 1);
    int64_t v47 = v46;
    if (v44) {
      [v46 scopedInterface];
    }
    else {
      [v46 interface];
    }
    uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v48 type] == 2) {
      *(_BYTE *)(v1 + 73) = 1;
    }
    else {
      *(_BYTE *)(v1 + 73) = objc_msgSend(objc_getProperty((id)v1, v49, 208, 1), "usesInterfaceType:", 2);
    }

    objc_msgSend(objc_getProperty((id)v1, v50, 208, 1), "scopedInterface");
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v53 = objc_getProperty((id)v1, v52, 208LL, 1);
    if (v51) {
      [v53 scopedInterface];
    }
    else {
      [v53 interface];
    }
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();
    *(_BYTE *)(v1 + 74) = [v54 subtype] == 5001;
  }

  else
  {
    *(void *)(v1 + 248) = 0LL;
    *(void *)(v1 + 256) = 2LL;
    *(_BYTE *)(v1 + 73) = 0;
    *(_BYTE *)(v1 + 74) = 0;
  }

  *(_BYTE *)(v1 + 75) = 0;
  objc_msgSend(objc_getProperty((id)v1, v37, 208, 1), "interface");
  BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v56 = [v55 subtype];

  if (v56 != 5001) {
    goto LABEL_72;
  }
  unint64_t v58 = 1LL;
  if ((objc_msgSend(objc_getProperty((id)v1, v57, 208, 1), "usesInterfaceType:", 1) & 1) == 0)
  {
    unint64_t v58 = 2LL;
  }

  else {
    uint64_t v61 = v58;
  }
  *(_BYTE *)(v1 + 75) = v61 != 0;
  uint64_t v62 = objc_getProperty((id)v1, v60, 128LL, 1);
  if (!v62
    || (uint64_t v64 = objc_getProperty(v62, v63, 56LL, 1)) == 0LL
    || (uint64_t v65 = v64,
        uint64_t v66 = (os_unfair_lock_s *)objc_getProperty((id)v1, v63, 232LL, 1),
        uint64_t v67 = -[NEIKEv2CompanionDatapath connected](v66),
        v65,
        !v67))
  {
    unint64_t v88 = objc_getProperty((id)v1, v63, 128LL, 1);
    if (v88)
    {
      CFErrorRef v90 = objc_getProperty(v88, v89, 56LL, 1);
      uint64_t v34 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
      if (v90)
      {
        unint64_t v91 = *(_BYTE *)(v1 + 75);

        if ((v91 & 1) == 0)
        {
          ne_log_obj();
          unint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v107 = v1;
            _os_log_impl( &dword_1876B1000,  v26,  OS_LOG_TYPE_DEFAULT,  "%@: No outbound companion path detected. Ignoring companion path",  buf,  0xCu);
          }

          goto LABEL_85;
        }
      }
    }

    else
    {
      uint64_t v34 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
    }

    if ((v105 & 1) != 0 && (*(_BYTE *)(v1 + 75) & 1) != 0 && (v103 & 1) == 0)
    {
      ne_log_obj();
      v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v107 = v1;
        _os_log_impl(&dword_1876B1000, v98, OS_LOG_TYPE_DEFAULT, "%@: outbound companion path detected", buf, 0xCu);
      }

      goto LABEL_91;
    }

    goto LABEL_72;
  }

  if (objc_msgSend(objc_getProperty((id)v1, v63, 208, 1), "status") == 1)
  {
    if ((*(_BYTE *)(v1 + 75) & 1) == 0)
    {
      ne_log_obj();
      uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v107 = v1;
        size_t v70 = "%@: No companion outbound path detected. Cancelling companion path";
        unint64_t v71 = v69;
        uint64_t v72 = 12;
LABEL_63:
        _os_log_impl(&dword_1876B1000, v71, OS_LOG_TYPE_DEFAULT, v70, buf, v72);
        goto LABEL_64;
      }

      goto LABEL_64;
    }

    uint64_t v76 = objc_getProperty((id)v1, v68, 232LL, 1);
    if (v76) {
      unint64_t v78 = v76[3];
    }
    else {
      unint64_t v78 = 0LL;
    }
    if (v61 != v78 || (*(_BYTE *)(v1 + 79) & 1) != 0)
    {
      ne_log_obj();
      uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v82 = objc_getProperty((id)v1, v81, 232LL, 1);
        if (v82) {
          v83 = v82[6];
        }
        else {
          v83 = 0;
        }
        *(_DWORD *)buf = 138412802;
        v107 = v1;
        v108 = 1024;
        *(_DWORD *)v109 = v83;
        *(_WORD *)&v109[4] = 1024;
        *(_DWORD *)&v109[6] = v61;
        size_t v70 = "%@: MOBIKE tunnel due to Companion network path change %u --> %u";
        unint64_t v71 = v69;
        uint64_t v72 = 24;
        goto LABEL_63;
      }

      int64_t v43 = 0LL;
      uint64_t v44 = v62;
      uint64_t v45 = v60;
      goto LABEL_86;
    }

    BOOL v25 = (2 * v20);
    unint64_t v26 = &v62[16 * v25];
    __int16 v27 = &v61[56 * v20];
    *((void *)v27 + 2) = v26;
    *((_DWORD *)v27 + 6) = 2;
    unint64_t v28 = &v18[v20];
    *(void *)unint64_t v26 = &v18[v20];
    uint64_t v29 = &v62[16 * ((2 * (_DWORD)v20) | 1)];
    *(void *)uint64_t v29 = *(void *)(a5 + 8 * v20);
    *((void *)v29 + 1) = v22;
    uint64_t v30 = *(void *)(a2 + 8 * v21);
    unint64_t v31 = *(unsigned __int8 *)(v30 + 1);
    *(_DWORD *)&v18[v20] = v31 << 24;
    if (v31 == 30)
    {
      unint64_t v39 = *(unsigned __int8 *)(a1 + 72);
      unint64_t v40 = v28 + 4;
      if (*(_BYTE *)(a1 + 72)) {
        unint64_t v40 = v28 + 20;
      }
      *(void *)&v62[16 * v25 + 8] = 44LL;
      unint64_t v41 = *(void *)(a3 + 8 * v21);
      *(_OWORD *)(v40 + 8) = *(_OWORD *)(v30 + 8);
      *(_OWORD *)(v40 + 24) = *(_OWORD *)(v41 + 8);
      if (v39) {
        unint64_t v42 = 20LL;
      }
      else {
        unint64_t v42 = 4LL;
      }
      *((_WORD *)v40 + 2) = bswap32(*(unsigned __int16 *)(a6 + 8 * v20)) >> 16;
      v40[6] = *(_BYTE *)(a4 + v21);
      v28[v42] |= 0x60u;
    }

    else if (v31 == 2)
    {
      unint64_t v32 = 0;
      unint64_t v33 = (unsigned __int16 *)(v28 + 4);
      if (*(_BYTE *)(a1 + 72))
      {
        unint64_t v33 = (unsigned __int16 *)(v28 + 20);
        uint64_t v34 = 20LL;
      }

      else
      {
        uint64_t v34 = 4LL;
      }

      *(void *)&v62[16 * v25 + 8] = 24LL;
      uint64_t v35 = *(void *)(a3 + 8 * v21);
      *((_DWORD *)v33 + 3) = *(_DWORD *)(v30 + 4);
      *((_DWORD *)v33 + 4) = *(_DWORD *)(v35 + 4);
      v33[1] = bswap32(*(unsigned __int16 *)(a6 + 8 * v20) + 20) >> 16;
      *((_BYTE *)v33 + 9) = *(_BYTE *)(a4 + v21);
      *((_BYTE *)v33 + 8) = 64;
      v28[v34] = 69;
      v33[5] = 0;
      unint64_t v36 = 22;
      uint64_t v37 = v33;
      do
      {
        uint64_t v38 = *v37++;
        v32 += v38;
        v36 -= 2;
      }

      while (v36 > 3);
      v33[5] = ~(HIWORD(v32) + v32 + ((HIWORD(v32) + (unsigned __int16)v32) >> 16));
    }

    else
    {
      *(void *)&v62[16 * v25 + 8] = 4LL;
    }

    ++v20;
  }

  while (v20 != v19);
  if (sendmsg_x() > 0)
  {
    int64_t v43 = 1LL;
    uint64_t v44 = v62;
    uint64_t v45 = v60;
    goto LABEL_87;
  }

  uint64_t v53 = v18;
  unint64_t v56 = (os_log_s *)ne_log_obj();
  uint64_t v45 = v60;
  if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
  {
    unint64_t v57 = __error();
    unint64_t v58 = strerror(*v57);
    *(_DWORD *)buf = 136315138;
    uint64_t v64 = v58;
    _os_log_error_impl(&dword_1876B1000, v56, OS_LOG_TYPE_ERROR, "User Tunnel write error: %s", buf, 0xCu);
  }

  int64_t v43 = 0LL;
  uint64_t v44 = v62;
LABEL_86:
  __int16 v18 = v53;
LABEL_87:
  if (v45 <= a7)
  {
    free(v44);
    free(v61);
    free(v18);
  }

  return v43;
}

LABEL_28:
  if (v20)
  {
    [v20 proxySettings];
    unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    [v24 HTTPServer];
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    [v25 setAuthenticationRequired:1];

    if (v19)
    {
      unint64_t v26 = (id)v19[7];
      [v20 proxySettings];
      __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
      [v27 HTTPServer];
      unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
      [v28 setUsername:v26];

      uint64_t v29 = (void *)v19[8];
    }

    else
    {
      [v20 proxySettings];
      uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue();
      [v84 HTTPServer];
      uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue();
      [v85 setUsername:0];

      uint64_t v29 = 0LL;
    }

    uint64_t v30 = v29;
    [v20 proxySettings];
    unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
    [v31 HTTPServer];
    unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
    [v32 setPassword:v30];

    [v20 proxySettings];
    unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    [v33 HTTPSServer];
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    [v34 setAuthenticationRequired:1];

    if (v19)
    {
      uint64_t v35 = (id)v19[7];
      [v20 proxySettings];
      unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
      [v36 HTTPSServer];
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
      [v37 setUsername:v35];

      uint64_t v38 = (void *)v19[8];
    }

    else
    {
      [v20 proxySettings];
      v86 = (void *)objc_claimAutoreleasedReturnValue();
      [v86 HTTPSServer];
      v87 = (void *)objc_claimAutoreleasedReturnValue();
      [v87 setUsername:0];

      uint64_t v38 = 0LL;
    }

    unint64_t v39 = v38;
    [v20 proxySettings];
    unint64_t v40 = (id)objc_claimAutoreleasedReturnValue();
    [v40 HTTPSServer];
    unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
    [v41 setPassword:v39];
  }

  else
  {
    ne_log_obj();
    unint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    unint64_t v42 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412290;
    unint64_t v91 = v42;
    unint64_t v40 = v42;
    _os_log_error_impl( &dword_1876B1000,  v39,  OS_LOG_TYPE_ERROR,  "%@ setPayloadInfoIdentityProxy: missing  protocol info",  buf,  0xCu);
  }

        unint64_t v15 = 0;
        goto LABEL_29;
      }
    }

    else
    {
      unint64_t v11 = 0LL;
      if (v5) {
        goto LABEL_9;
      }
    }

    unint64_t v12 = 0LL;
    goto LABEL_10;
  }

  unint64_t v15 = 0;
LABEL_30:

  return v15;
}

    goto LABEL_29;
  }

  v138 = 0u;
  v139 = 0u;
  v136 = 0u;
  v137 = 0u;
  [v6 encryptionProtocols];
  BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v21 = [v20 countByEnumeratingWithState:&v136 objects:v152 count:16];
  if (!v21) {
    goto LABEL_39;
  }
  unint64_t v22 = v21;
  uint64_t v23 = *(void *)v137;
LABEL_33:
  unint64_t v24 = 0LL;
  while (1)
  {
    if (*(void *)v137 != v23) {
      objc_enumerationMutation(v20);
    }
    BOOL v25 = *(void *)(*((void *)&v136 + 1) + 8 * v24);
    [a1 encryptionProtocols];
    unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    __int16 v27 = [v26 containsObject:v25];

    if (v27) {
      break;
    }
    if (v22 == ++v24)
    {
      unint64_t v22 = [v20 countByEnumeratingWithState:&v136 objects:v152 count:16];
      if (!v22)
      {
LABEL_39:

        ne_log_large_obj();
        unint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          [a1 encryptionProtocols];
          uint64_t v29 = (char *)objc_claimAutoreleasedReturnValue();
          [v6 encryptionProtocols];
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138412546;
          v149 = v29;
          v150 = 2112;
          v151 = v30;
          unint64_t v31 = "Failed to match encryption algorithms (%@ vs %@)";
          goto LABEL_72;
        }

        goto LABEL_73;
      }

      goto LABEL_33;
    }
  }

  if (v25)
  {
    unint64_t v32 = *(void *)(v25 + 16);
    unint64_t v33 = v32 >= 0x20;
    uint64_t v34 = (0xD01C0000 >> v32) & 1;
    if (v33) {
      uint64_t v35 = 0;
    }
    else {
      uint64_t v35 = v34;
    }
  }

  else
  {
    uint64_t v35 = 0;
  }

  [v6 integrityProtocols];
  unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
  if ([v36 count])
  {
    [a1 integrityProtocols];
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v38 = [v37 count];

    if (v38)
    {
      v134 = 0u;
      v135 = 0u;
      v132 = 0u;
      v133 = 0u;
      [v6 integrityProtocols];
      unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v40 = [v39 countByEnumeratingWithState:&v132 objects:v147 count:16];
      if (!v40) {
        goto LABEL_55;
      }
      unint64_t v41 = v40;
      unint64_t v42 = *(void *)v133;
LABEL_49:
      int64_t v43 = 0LL;
      while (1)
      {
        if (*(void *)v133 != v42) {
          objc_enumerationMutation(v39);
        }
        uint64_t v44 = *(void *)(*((void *)&v132 + 1) + 8 * v43);
        [a1 integrityProtocols];
        uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
        LOBYTE(v44) = [v45 containsObject:v44];

        if ((v44 & 1) != 0) {
          break;
        }
        if (v41 == ++v43)
        {
          unint64_t v41 = [v39 countByEnumeratingWithState:&v132 objects:v147 count:16];
          if (!v41)
          {
LABEL_55:

            ne_log_large_obj();
            unint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
            {
              [a1 integrityProtocols];
              uint64_t v29 = (char *)objc_claimAutoreleasedReturnValue();
              [v6 integrityProtocols];
              uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138412546;
              v149 = v29;
              v150 = 2112;
              v151 = v30;
              unint64_t v31 = "Failed to match integrity algorithms (%@ vs %@)";
              goto LABEL_72;
            }

            goto LABEL_73;
          }

          goto LABEL_49;
        }
      }

      goto LABEL_62;
    }
  }

  else
  {
  }

  if ((v35 & 1) == 0)
  {
    ne_log_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_WORD *)buf = 0;
    unint64_t v15 = "Failed to match integrity algorithms, none provided";
    goto LABEL_12;
  }

    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v67) = a2;
      _os_log_fault_impl(&dword_1876B1000, v17, OS_LOG_TYPE_FAULT, "Unknown KE method %u", buf, 8u);
    }

    return 0LL;
  }

  unint64_t v8 = objc_alloc(&OBJC_CLASS___NEIKEv2KeyExchangeHandlerECDH);
  if (!v8) {
    return 0LL;
  }
  unint64_t v9 = (id *)-[NEIKEv2KeyExchangeHandler initWithMethod:](v8, a2);
  if (v9)
  {
    ne_log_obj();
    unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v48 = (unint64_t)v9[1];
      *(_DWORD *)buf = 134217984;
      uint64_t v67 = v48;
      _os_log_debug_impl(&dword_1876B1000, v10, OS_LOG_TYPE_DEBUG, "Generate ECDH %zu key", buf, 0xCu);
    }

    unint64_t v11 = (uint64_t)v9[1];
    if (v11 <= 20)
    {
      if (v11 == 19)
      {
        unint64_t v12 = &OBJC_CLASS____TtC16NetworkExtension20NEIKEv2CryptoKitP256;
        goto LABEL_57;
      }

      if (v11 == 20)
      {
        unint64_t v12 = &OBJC_CLASS____TtC16NetworkExtension20NEIKEv2CryptoKitP384;
        goto LABEL_57;
      }
    }

    else
    {
      switch(v11)
      {
        case 21LL:
          unint64_t v12 = &OBJC_CLASS____TtC16NetworkExtension20NEIKEv2CryptoKitP521;
          goto LABEL_57;
        case 31LL:
          unint64_t v12 = &OBJC_CLASS____TtC16NetworkExtension22NEIKEv2CryptoKitX25519;
          goto LABEL_57;
        case 32LL:
          unint64_t v12 = &OBJC_CLASS____TtC16NetworkExtension20NEIKEv2CryptoKitX448;
LABEL_57:
          uint64_t v30 = objc_alloc_init(v12);
          unint64_t v31 = v9[4];
          v9[4] = v30;

          ne_log_obj();
          unint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v49 = (unint64_t)v9[1];
            *(_DWORD *)buf = 134217984;
            uint64_t v67 = v49;
            _os_log_debug_impl(&dword_1876B1000, v32, OS_LOG_TYPE_DEBUG, "Generated ECDH %zu key", buf, 0xCu);
          }

          unint64_t v33 = (id *)v9[4];
          uint64_t v34 = [v33 keyExchangeData];
          uint64_t v35 = v9[2];
          v9[2] = (id)v34;
LABEL_60:

          return v9;
      }
    }

    ne_log_obj();
    uint64_t v35 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v35, OS_LOG_TYPE_FAULT))
    {
      uint64_t v51 = (unint64_t)v9[1];
      *(_DWORD *)buf = 134217984;
      uint64_t v67 = v51;
      _os_log_fault_impl(&dword_1876B1000, (os_log_t)v35, OS_LOG_TYPE_FAULT, "Invalid ECDH type %zu", buf, 0xCu);
    }

    unint64_t v33 = v9;
    unint64_t v9 = 0LL;
    goto LABEL_60;
  }

  return v9;
}

  return a1;
}

LABEL_29:
  BOOL v20 = objc_msgSend(objc_getProperty(self, v7, 16, 1), "length");
  if (v20 > (unint64_t)BYTE1(v29) + 4)
  {
    unint64_t v22 = objc_getProperty(self, v21, 16LL, 1);
    uint64_t v23 = BYTE1(v29);
    BOOL v25 = objc_getProperty(self, v24, 16LL, 1);
    unint64_t v26 = [v25 length];
    objc_msgSend(v22, "subdataWithRange:", v23 + 4, v26 - BYTE1(v29) - 4);
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();

    objc_setProperty_atomic(self, v28, v27, 32LL);
  }

  return -[NEIKEv2NotifyPayload hasRequiredFields](self, "hasRequiredFields");
}

          goto LABEL_29;
        }

        if (v2) {
          objc_setProperty_atomic(v2, v9, v8, 88LL);
        }
LABEL_29:
        ++v7;
      }

      while (v5 != v7);
      unint64_t v5 = -[NEIKEv2FollowupKEPacket countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v21,  v27,  16LL);
    }

    while (v5);
  }
}

LABEL_29:
  (*(void (**)(void))(a1[6] + 16LL))();
}

  CFRelease(v8);
  return 0LL;
}

      [v5 willChangeValueForKey:@"lastDisconnectError"];
      objc_storeStrong(v5 + 9, a2);

      objc_sync_exit(v5);
      [v5 didChangeValueForKey:@"lastDisconnectError"];
      goto LABEL_29;
    }

    ne_log_obj();
    unsigned __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_28;
    }
    unsigned __int16 v17 = *v7;
    if (*v7)
    {
      [*v7 localizedDescription];
      unint64_t v15 = (__CFString *)objc_claimAutoreleasedReturnValue();
      if (v4)
      {
LABEL_15:
        [v4 localizedDescription];
        __int16 v18 = (__CFString *)objc_claimAutoreleasedReturnValue();
        goto LABEL_24;
      }
    }

    else
    {
      unint64_t v15 = @"none";
      if (v4) {
        goto LABEL_15;
      }
    }

    __int16 v18 = @"none";
LABEL_24:
    unint64_t v19 = 138412546;
    BOOL v20 = v15;
    uint64_t v21 = 2112;
    unint64_t v22 = v18;
    _os_log_impl( &dword_1876B1000,  v13,  OS_LOG_TYPE_DEFAULT,  "Last disconnect error changed from %@ to %@",  (uint8_t *)&v19,  0x16u);
    if (v4) {

    }
    if (!v17) {
      goto LABEL_28;
    }
LABEL_27:

    goto LABEL_28;
  }

  objc_msgSend(MEMORY[0x189607968], "numberWithInteger:", objc_msgSend(a1, "diffieHellmanGroup"));
  unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 setObject:v5 forKeyedSubscript:@"DiffieHellmanGroup"];

  objc_msgSend( v2,  "setObject:forKeyedSubscript:",  objc_getProperty(a1, v6, 40, 1),  @"AdditionalKeyExchangeMethods");
  objc_msgSend(MEMORY[0x189607968], "numberWithInt:", objc_msgSend(a1, "lifetimeMinutes"));
  char v7 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 setObject:v7 forKeyedSubscript:@"LifeTimeInMinutes"];

  return v2;
}

  uint64_t v37 = 0LL;
LABEL_29:

LABEL_30:
  return v37;
}

LABEL_34:
LABEL_38:
  if (v19)
  {
    int64_t v43 = (__CFString *)(id)v19[9];
    if (v43) {
      goto LABEL_50;
    }
  }

  -[NEConfiguration VPN](self, "VPN");
  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
  [v44 protocol];
  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
  if ([v45 type] == 5)
  {
  }

  else
  {
    -[NEConfiguration VPN](self, "VPN");
    uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
    [v46 protocol];
    int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v48 = [v47 type];

    if (v48 != 1)
    {
LABEL_47:
      ne_log_obj();
      uint64_t v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl( &dword_1876B1000,  v51,  OS_LOG_TYPE_DEBUG,  "setPayloadInfoIdentityIPSecSharedSecret: no SharedSecret found, set to blank",  buf,  2u);
      }

      int64_t v43 = &stru_18A0915E8;
LABEL_50:
      uint64_t v50 = v43;
      -[NEConfiguration VPN](self, "VPN");
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
      [v52 protocol];
      uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v54 = [v53 type];

      if (v54 != 5)
      {
        if (v54 == 2)
        {
          uint64_t v63 = objc_alloc(&OBJC_CLASS___NEKeychainItem);
          -[NEConfiguration VPN](self, "VPN");
          unint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v64 = [v56 protocol];
          uint64_t v65 = (void *)v64;
          if (v64) {
            uint64_t v66 = *(void *)(v64 + 80);
          }
          else {
            uint64_t v66 = 0LL;
          }
          -[NEConfiguration VPN](self, "VPN");
          unint64_t v88 = (void *)objc_claimAutoreleasedReturnValue();
          [v88 protocol];
          Property = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v69 = Property;
          v89 = v4;
          if (Property) {
            Property = objc_getProperty(Property, v68, 88LL, 1);
          }
          size_t v70 = Property;
          unint64_t v71 = -[NEKeychainItem initWithPassword:domain:accessGroup:]( v63,  "initWithPassword:domain:accessGroup:",  v50,  v66,  v70);
          -[NEConfiguration VPN](self, "VPN");
          uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue();
          [v72 protocol];
          unint64_t v73 = (void *)objc_claimAutoreleasedReturnValue();
          [v73 setSharedSecretKeychainItem:v71];

          size_t v4 = v89;
          goto LABEL_62;
        }

        if (v54 != 1)
        {
LABEL_63:

          goto LABEL_64;
        }
      }

      -[NEConfiguration VPN](self, "VPN");
      BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();
      [v55 protocol];
      unint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();

      unint64_t v58 = objc_alloc(&OBJC_CLASS___NEKeychainItem);
      if (v56)
      {
        uint64_t v59 = v56[10];
        uint64_t v60 = objc_getProperty(v56, v57, 88LL, 1);
      }

      else
      {
        uint64_t v59 = 0LL;
        uint64_t v60 = 0LL;
      }

      uint64_t v61 = v60;
      uint64_t v62 = -[NEKeychainItem initWithPassword:domain:accessGroup:]( v58,  "initWithPassword:domain:accessGroup:",  v50,  v59,  v61);
      [v56 setSharedSecretKeychainItem:v62];

      if (![v56 authenticationMethod]) {
        [v56 setAuthenticationMethod:2];
      }
LABEL_62:

      goto LABEL_63;
    }
  }

  -[NEConfiguration VPN](self, "VPN");
  uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
  [v49 protocol];
  uint64_t v50 = (__CFString *)objc_claimAutoreleasedReturnValue();

  if ((-[__CFString authenticationMethod](v50, "authenticationMethod")
     || (-[__CFString useExtendedAuthentication](v50, "useExtendedAuthentication") & 1) == 0)
    && -[__CFString authenticationMethod](v50, "authenticationMethod") != 1)
  {

    goto LABEL_47;
  }
        }

        uint64_t v29 = 0LL;
LABEL_36:
      }

      ++v8;
    }

    while (v8 != v6);
    unint64_t v33 = -[NSArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v50,  v62,  16LL);
    unint64_t v6 = v33;
  }

  while (v33);
LABEL_44:

  uint64_t v34 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FB8]),  "initWithBytes:length:",  -[NSData bytes](v43->_data, "bytes"),  6);
  v43->_flags = v43->_flags & 0x7BF0 | 0x8400;
  uint64_t v35 = [v44 count];
  flags = v43->_flags;
  if (!v35)
  {
    flags |= 3u;
    v43->_flags = flags;
  }

  LOWORD(v57) = __rev16(flags);
  objc_msgSend(v34, "replaceBytesInRange:withBytes:length:", 2, 2, &v57, 2);
  *(_WORD *)buf = bswap32([v44 count]) >> 16;
  [v34 appendBytes:buf length:2];
  v63[0] = 0;
  [v34 appendBytes:v63 length:4];
  if (v43->_endOfQueriesOffset >= 0xD) {
    objc_msgSend(v34, "appendBytes:length:", -[NSData bytes](v43->_data, "bytes") + 12, v43->_endOfQueriesOffset - 12);
  }
  uint64_t v48 = 0u;
  uint64_t v49 = 0u;
  uint64_t v46 = 0u;
  int64_t v47 = 0u;
  uint64_t v37 = v44;
  uint64_t v38 = [v37 countByEnumeratingWithState:&v46 objects:v61 count:16];
  if (v38)
  {
    unint64_t v39 = v38;
    unint64_t v40 = *(void *)v47;
    do
    {
      for (j = 0LL; j != v39; ++j)
      {
        if (*(void *)v47 != v40) {
          objc_enumerationMutation(v37);
        }
        [v34 appendData:*(void *)(*((void *)&v46 + 1) + 8 * j)];
      }

      unint64_t v39 = [v37 countByEnumeratingWithState:&v46 objects:v61 count:16];
    }

    while (v39);
  }

  unint64_t v42 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithData:v34];
  return v42;
}

    goto LABEL_35;
  }

  unint64_t v14 = [*(id *)(a1 + 32) createDataReply:v10 controlSocket:handle direction:*(void *)(a1 + 56) verdict:v3 context:*(void *)(a1 + 48)];
  if (!v10) {
    goto LABEL_22;
  }
  unint64_t v15 = *(id *)(a1 + 32);
  if (v15) {
    unint64_t v15 = objc_getProperty(v15, v13, 144LL, 1);
  }
  unint64_t v16 = v15;

  if (!v16)
  {
    ne_log_obj();
    uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      [*(id *)(a1 + 32) identifierString];
      unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v30 = 138412290;
      unint64_t v31 = v26;
      __int16 v27 = "Flow %@ does not have a connection to update its verdict";
      goto LABEL_38;
    }

    goto LABEL_34;
  }

  __int16 v18 = *(id *)(a1 + 32);
  if (v18) {
    __int16 v18 = objc_getProperty(v18, v17, 144LL, 1);
  }
  unint64_t v19 = (_xpc_connection_s *)v18;
  xpc_connection_send_message(v19, v10);

LABEL_22:
  if (v14) {
    -[NEFilterDataExtensionProviderContext closeFlow:](*(id **)(a1 + 48), *(void **)(a1 + 32));
  }
  if (v3)
  {
    BOOL v20 = *(void **)(a1 + 48);
    uint64_t v21 = *(void **)(a1 + 32);
    if (v21) {
      unint64_t v22 = objc_getProperty(v21, v13, 112LL, 1);
    }
    else {
      unint64_t v22 = 0LL;
    }
    uint64_t v23 = (os_log_s *)v22;
    -[NEFilterDataExtensionProviderContext reportFlow:forVerdict:absoluteVerdict:](v20, v21, v3, v23);
    goto LABEL_34;
  }

    CFRelease(v10);
    goto LABEL_10;
  }

  ne_log_obj();
  unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    unint64_t v26 = *(void *)(a1 + 40);
    *(_DWORD *)unint64_t v28 = 138412290;
    *(void *)&v28[4] = v26;
    _os_log_error_impl( &dword_1876B1000,  v22,  OS_LOG_TYPE_ERROR,  "%@ received unexpected data for Wi-Fi information request",  v28,  0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (v10) {
    goto LABEL_34;
  }
LABEL_10:
}

  uint64_t v82 = 0LL;
LABEL_59:

  return v82;
}

    BOOL v20 = 0LL;
    goto LABEL_16;
  }

  if (!v7)
  {
    ne_log_obj();
    unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    {
      __s = 136315138;
      uint64_t v34 = "-[NEIKEv2SecurityContextAESGCM decryptPayloadData:authenticatedHeaders:]";
      unint64_t v22 = "%s called with null authenticatedHeaders";
      goto LABEL_21;
    }

    goto LABEL_34;
  }

  unint64_t v9 = [v6 length];
  unint64_t v10 = v9;
  if (self)
  {
    if (self->super._minimumEncryptedPayloadSize > v9)
    {
      ne_log_obj();
      unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        __s = 67109120;
        LODWORD(v34) = v10;
        _os_log_error_impl( &dword_1876B1000,  v12,  OS_LOG_TYPE_ERROR,  "Cannot decrypt, encrypted data length %u too short",  (uint8_t *)&__s,  8u);
      }

      goto LABEL_34;
    }

    decryptionContext = self->_decryptionContext;
  }

  else
  {
    decryptionContext = 0LL;
  }

  unint64_t v12 = decryptionContext;
  -[os_log_s mutableBytes](v12, "mutableBytes");
  ccaes_gcm_decrypt_mode();
  unsigned __int16 v13 = ccgcm_reset();
  if (v13)
  {
    uint64_t v23 = v13;
    ne_log_obj();
    unint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
    {
      __s = 67109120;
      LODWORD(v34) = v23;
      _os_log_fault_impl(&dword_1876B1000, v24, OS_LOG_TYPE_FAULT, "ccgcm_reset failed: %d", (uint8_t *)&__s, 8u);
    }

    goto LABEL_34;
  }

  unint64_t v36 = 0;
  uint64_t v35 = 0LL;
  if (self) {
    incomingEncryptionSalt = self->_incomingEncryptionSalt;
  }
  else {
    incomingEncryptionSalt = 0LL;
  }
  -[NSData getBytes:length:](incomingEncryptionSalt, "getBytes:length:", &v35, 4LL);
  [v6 getBytes:(char *)&v35 + 4 length:8];
  unint64_t v15 = ccgcm_set_iv();
  if (v15)
  {
    BOOL v25 = v15;
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      goto LABEL_37;
    }
    __s = 67109120;
    LODWORD(v34) = v25;
    unint64_t v26 = "ccgcm_set_iv failed: %d";
LABEL_29:
    _os_log_fault_impl(&dword_1876B1000, v17, OS_LOG_TYPE_FAULT, v26, (uint8_t *)&__s, 8u);
    goto LABEL_37;
  }

  [v8 length];
  [v8 bytes];
  unint64_t v16 = ccgcm_aad();
  if (v16)
  {
    __int16 v27 = v16;
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      goto LABEL_37;
    }
    __s = 67109120;
    LODWORD(v34) = v27;
    unint64_t v26 = "ccgcm_aad failed: %d";
    goto LABEL_29;
  }

  unsigned __int16 v17 = (os_log_s *)[objc_alloc(MEMORY[0x189603FB8]) initWithLength:v10 - 24];
  [v6 bytes];
  -[os_log_s mutableBytes](v17, "mutableBytes");
  __int16 v18 = ccgcm_update();
  if (v18)
  {
    unint64_t v28 = v18;
    ne_log_obj();
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v29, OS_LOG_TYPE_FAULT))
    {
LABEL_36:

      goto LABEL_37;
    }

    __s = 67109120;
    LODWORD(v34) = v28;
    uint64_t v30 = "ccgcm_update failed: %d";
    p_s = (uint8_t *)&__s;
LABEL_39:
    _os_log_fault_impl(&dword_1876B1000, (os_log_t)v29, OS_LOG_TYPE_FAULT, v30, p_s, 8u);
    goto LABEL_36;
  }

  objc_msgSend(v6, "getBytes:range:", &__s, v10 - 16, 16);
  unint64_t v19 = ccgcm_finalize();
  memset_s(&__s, 0x10uLL, 0, 0x10uLL);
  if (v19)
  {
    ne_log_obj();
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v29, OS_LOG_TYPE_FAULT)) {
      goto LABEL_36;
    }
    v32[0] = 67109120;
    v32[1] = v19;
    uint64_t v30 = "ccgcm_finalize failed: %d";
    p_s = (uint8_t *)v32;
    goto LABEL_39;
  }

  if (!+[NEIKEv2SecurityContext removePaddingFromDecryptedPayload:]((uint64_t)&OBJC_CLASS___NEIKEv2SecurityContext, v17))
  {
LABEL_37:
    BOOL v20 = 0LL;
    goto LABEL_15;
  }

  BOOL v20 = v17;
LABEL_15:

LABEL_16:
  return v20;
}

    BOOL v20 = 0LL;
    goto LABEL_16;
  }

  if (!v7)
  {
    ne_log_obj();
    unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__s = 136315138;
      *(void *)&__s[4] = "-[NEIKEv2SecurityContextChaCha20Poly1305 decryptPayloadData:authenticatedHeaders:]";
      unint64_t v22 = "%s called with null authenticatedHeaders";
      goto LABEL_21;
    }

    goto LABEL_34;
  }

  unint64_t v9 = [v6 length];
  unint64_t v10 = v9;
  if (self)
  {
    if (self->super._minimumEncryptedPayloadSize > v9)
    {
      ne_log_obj();
      unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__s = 67109120;
        *(_DWORD *)&__s[4] = v10;
        _os_log_error_impl( &dword_1876B1000,  v12,  OS_LOG_TYPE_ERROR,  "Cannot decrypt, encrypted data length %u too short",  __s,  8u);
      }

      goto LABEL_34;
    }

    incomingEncryptionContext = self->_incomingEncryptionContext;
  }

  else
  {
    incomingEncryptionContext = 0LL;
  }

  unint64_t v12 = incomingEncryptionContext;
  -[os_log_s mutableBytes](v12, "mutableBytes");
  ccchacha20poly1305_info();
  unsigned __int16 v13 = ccchacha20poly1305_reset();
  if (v13)
  {
    uint64_t v23 = v13;
    ne_log_obj();
    unint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__s = 67109120;
      *(_DWORD *)&__s[4] = v23;
      _os_log_fault_impl(&dword_1876B1000, v24, OS_LOG_TYPE_FAULT, "ccchacha20poly1305_reset failed: %d", __s, 8u);
    }

    goto LABEL_34;
  }

  *(_DWORD *)&__s[8] = 0;
  *(void *)__s = 0LL;
  if (self) {
    incomingEncryptionSalt = self->_incomingEncryptionSalt;
  }
  else {
    incomingEncryptionSalt = 0LL;
  }
  -[NSData getBytes:length:](incomingEncryptionSalt, "getBytes:length:", __s, 4LL);
  [v6 getBytes:&__s[4] length:8];
  unint64_t v15 = ccchacha20poly1305_setnonce();
  memset_s(__s, 0xCuLL, 0, 0xCuLL);
  if (v15)
  {
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      goto LABEL_37;
    }
    unint64_t v31 = 67109120;
    unint64_t v32 = v15;
    BOOL v25 = "ccchacha20poly1305_setnonce failed: %d";
LABEL_29:
    _os_log_fault_impl(&dword_1876B1000, v17, OS_LOG_TYPE_FAULT, v25, (uint8_t *)&v31, 8u);
    goto LABEL_37;
  }

  [v8 length];
  [v8 bytes];
  unint64_t v16 = ccchacha20poly1305_aad();
  if (v16)
  {
    unint64_t v26 = v16;
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      goto LABEL_37;
    }
    unint64_t v31 = 67109120;
    unint64_t v32 = v26;
    BOOL v25 = "ccchacha20poly1305_aad failed: %d";
    goto LABEL_29;
  }

  unsigned __int16 v17 = (os_log_s *)[objc_alloc(MEMORY[0x189603FB8]) initWithLength:v10 - 24];
  [v6 bytes];
  -[os_log_s mutableBytes](v17, "mutableBytes");
  __int16 v18 = ccchacha20poly1305_decrypt();
  if (v18)
  {
    __int16 v27 = v18;
    ne_log_obj();
    unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v28, OS_LOG_TYPE_FAULT))
    {
LABEL_36:

      goto LABEL_37;
    }

    unint64_t v31 = 67109120;
    unint64_t v32 = v27;
    uint64_t v29 = "ccchacha20poly1305_decrypt failed: %d";
LABEL_39:
    _os_log_fault_impl(&dword_1876B1000, (os_log_t)v28, OS_LOG_TYPE_FAULT, v29, (uint8_t *)&v31, 8u);
    goto LABEL_36;
  }

  unint64_t v19 = ccchacha20poly1305_verify();
  if (v19)
  {
    uint64_t v30 = v19;
    ne_log_obj();
    unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v28, OS_LOG_TYPE_FAULT)) {
      goto LABEL_36;
    }
    unint64_t v31 = 67109120;
    unint64_t v32 = v30;
    uint64_t v29 = "ccchacha20poly1305_verify failed: %d";
    goto LABEL_39;
  }

  if (!+[NEIKEv2SecurityContext removePaddingFromDecryptedPayload:]((uint64_t)&OBJC_CLASS___NEIKEv2SecurityContext, v17))
  {
LABEL_37:
    BOOL v20 = 0LL;
    goto LABEL_15;
  }

  unsigned __int16 v17 = v17;
  BOOL v20 = v17;
LABEL_15:

LABEL_16:
  return v20;
}
}

        continue;
      }

      unint64_t v16 = -[NEIKEv2TrafficSelector type]((uint64_t)v15);
      [v15 startAddress];
      unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
      __int16 v18 = [v17 address];

      [v15 endAddress];
      unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = [v19 address];

      if (v16 != 7)
      {
        if (v18)
        {
          if (v20)
          {
            memset(buf, 0, 40);
            buf[0] = -[NEIKEv2TrafficSelector type]((uint64_t)v15);
            *(_WORD *)&buf[2] = 10240;
            buf[1] = [v15 ipProtocol];
            *(_WORD *)&buf[4] = __rev16([v15 startPort]);
            else {
              BOOL v25 = -1;
            }
            *(_WORD *)&buf[6] = v25;
            *(_OWORD *)&buf[8] = *(_OWORD *)(v18 + 8);
            *(_OWORD *)&buf[24] = *(_OWORD *)(v20 + 8);
            v12 += 40LL;
            unint64_t v26 = objc_alloc(MEMORY[0x189603F48]);
            __int16 v27 = 40LL;
            goto LABEL_39;
          }

          ne_log_obj();
          unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            goto LABEL_34;
          }
        }

        else
        {
          ne_log_obj();
          unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            goto LABEL_34;
          }
        }

        *(_DWORD *)buf = 0;
        *(_WORD *)buf = bswap32(-[NEIKEv2ConfigPayload attributeType](v22, "attributeType")) >> 16;
        *(_WORD *)&buf[2] = 0;
        v18 += 4LL;
        unint64_t v33 = (id)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:buf length:4];
        goto LABEL_49;
      }
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      -[NEIKEv2ConfigPayload address](v22, "address");
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v30) {
        goto LABEL_34;
      }
      -[NEIKEv2ConfigPayload address](v22, "address");
      unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v32 = [v31 address];

      if (-[NEIKEv2ConfigPayload valueType](v22, "valueType") == 1 && *(_BYTE *)(v32 + 1) == 2)
      {
        *(_DWORD *)buf = 0;
        *(_WORD *)buf = bswap32(-[NEIKEv2ConfigPayload attributeType](v22, "attributeType")) >> 16;
        *(_WORD *)&buf[2] = 1024;
        unint64_t v33 = objc_alloc_init(MEMORY[0x189603FB8]);
        [v33 appendBytes:buf length:4];
        p_b = (int *)(v32 + 4);
        goto LABEL_47;
      }

      if (-[NEIKEv2ConfigPayload valueType](v22, "valueType") == 2 && *(_BYTE *)(v32 + 1) == 30)
      {
        *(_DWORD *)buf = 0;
        *(_WORD *)buf = bswap32(-[NEIKEv2ConfigPayload attributeType](v22, "attributeType")) >> 16;
        *(_WORD *)&buf[2] = 4096;
        v18 += 20LL;
        unint64_t v33 = (id)[objc_alloc(MEMORY[0x189603FB8]) initWithCapacity:20];
        [v33 appendBytes:buf length:4];
        p_b = (int *)(v32 + 8);
        unint64_t v40 = v33;
        unint64_t v41 = 16LL;
        goto LABEL_48;
      }
    }

    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_50;
      }
      -[NEIKEv2ConfigPayload address](v22, "address");
      uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v35) {
        goto LABEL_34;
      }
      -[NEIKEv2ConfigPayload address](v22, "address");
      unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v37 = [v36 address];

      if (-[NEIKEv2ConfigPayload valueType](v22, "valueType") == 3 && *(_BYTE *)(v37 + 1) == 2)
      {
        uint64_t v38 = -[NEIKEv2ConfigPayload prefix](v22, "prefix");
        *(_DWORD *)buf = 0;
        *(_WORD *)buf = bswap32(-[NEIKEv2ConfigPayload attributeType](v22, "attributeType")) >> 16;
        *(_WORD *)&buf[2] = 2048;
        __b = 0;
        if (v38 <= 0x20)
        {
          if (v38 >= 8)
          {
            memset(&__b, 255, v38 >> 3);
            unint64_t v39 = v38 >> 3 <= 1 ? 1LL : v38 >> 3;
          }

          else
          {
            unint64_t v39 = 0LL;
          }

          if ((v38 & 7) != 0) {
            *((_BYTE *)&__b + v39) = 0xFF00u >> (v38 & 7);
          }
        }

        v18 += 12LL;
        unint64_t v33 = (id)[objc_alloc(MEMORY[0x189603FB8]) initWithCapacity:12];
        [v33 appendBytes:buf length:4];
        [v33 appendBytes:v37 + 4 length:4];
        p_b = &__b;
LABEL_47:
        unint64_t v40 = v33;
        unint64_t v41 = 4LL;
LABEL_48:
        [v40 appendBytes:p_b length:v41];
LABEL_49:
        [v10 addObject:v33];

        goto LABEL_50;
      }

      if (-[NEIKEv2ConfigPayload valueType](v22, "valueType") == 4 && *(_BYTE *)(v37 + 1) == 30)
      {
        LOBYTE(__b) = -[NEIKEv2ConfigPayload prefix](v22, "prefix");
        *(_DWORD *)buf = 0;
        *(_WORD *)buf = bswap32(-[NEIKEv2ConfigPayload attributeType](v22, "attributeType")) >> 16;
        *(_WORD *)&buf[2] = 4352;
        v18 += 21LL;
        unint64_t v33 = (id)[objc_alloc(MEMORY[0x189603FB8]) initWithCapacity:21];
        [v33 appendBytes:buf length:4];
        [v33 appendBytes:v37 + 8 length:16];
        p_b = &__b;
        unint64_t v40 = v33;
        unint64_t v41 = 1LL;
        goto LABEL_48;
      }
    }

        unint64_t v14 = (os_log_s *)v81;
        goto LABEL_35;
      }

      unint64_t v9 = 256LL;
    }

    else
    {
      if ((int)a1[5] <= 3)
      {
        unint64_t v9 = 248LL;
        goto LABEL_22;
      }

      unint64_t v8 = a1[4] - 4;
      unint64_t v9 = 248LL;
    }

    if (v8 != -1 && (int)v7 <= v8)
    {
      ne_log_obj();
      unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412290;
        CFErrorRef v90 = (const char *)a1;
        unint64_t v15 = "%@ Discarding stale fragment";
        goto LABEL_20;
      }

      goto LABEL_37;
    }

    goto LABEL_22;
  }

    goto LABEL_35;
  }

  if (*v33 <= 0xFu)
  {
    ne_log_obj();
    uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)unint64_t v91 = 136315138;
      v92 = "-[NEIKEv2IKESA switchToTCPEncapsulation]";
      uint64_t v84 = "%s called with null (remoteAddress->sa_len >= sizeof(struct sockaddr_in))";
      goto LABEL_59;
    }

    goto LABEL_34;
  }

  [MEMORY[0x189608DE8] endpointWithAddress:v33];
  uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  unint64_t v36 = __rev16(objc_msgSend(objc_getProperty(v32, v35, 80, 1), "tcpEncapsulationPort"));
  *(_WORD *)(-[os_log_s address](v34, "address") + 2) = v36;
  if (!*(_WORD *)(-[os_log_s address](v34, "address") + 2)) {
    *(_WORD *)(-[os_log_s address](v34, "address") + 2) = -27631;
  }
  if (!objc_getProperty(v32, v37, 480LL, 1))
  {
    WeakRetained = objc_loadWeakRetained(v32 + 70);
    unint64_t v41 = objc_loadWeakRetained(v32 + 68);
    if ((*((_BYTE *)v32 + 25) & 1) != 0 && !WeakRetained)
    {
      ne_log_obj();
      unint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unint64_t v91 = 0;
        _os_log_error_impl( &dword_1876B1000,  v42,  OS_LOG_TYPE_ERROR,  "Cannot create transport for packet delegate, delegate no longer valid",  v91,  2u);
      }

      goto LABEL_34;
    }

    else {
      uint64_t v51 = 2LL;
    }
    uint64_t v52 = objc_getProperty(v32, v50, 304LL, 1);
    uint64_t v54 = objc_getProperty(v32, v53, 536LL, 1);
    unint64_t v56 = objc_getProperty(v32, v55, 552LL, 1);
    unint64_t v57 = +[NEIKEv2Transport createTransport:remote:local:localPort:boundInterface:queue:socketGetBlock:packetDelegate:]( (uint64_t)&OBJC_CLASS___NEIKEv2Transport,  v51,  v34,  0LL,  0,  v52,  v54,  v56,  WeakRetained);

    objc_setProperty_atomic(v32, v58, v57, 480LL);
    uint64_t v60 = objc_getProperty(v32, v59, 480LL, 1);
    uint64_t v62 = objc_getProperty(v32, v61, 32LL, 1);
    -[NEIKEv2Transport addClient:delegate:](v60, v62, v41);

    uint64_t v64 = objc_getProperty(v32, v63, 480LL, 1);
    if (v64) {
      uint64_t v64 = objc_getProperty(v64, v65, 24LL, 1);
    }
    uint64_t v66 = v64;
    objc_setProperty_atomic(v32, v67, v66, 72LL);

    uint64_t v69 = objc_getProperty(v32, v68, 480LL, 1);
    if (v69) {
      uint64_t v69 = objc_getProperty(v69, v70, 16LL, 1);
    }
    unint64_t v71 = v69;
    objc_setProperty_atomic(v32, v72, v71, 64LL);

    uint64_t v74 = objc_getProperty(v32, v73, 480LL, 1);
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __40__NEIKEv2IKESA_switchToTCPEncapsulation__block_invoke;
    v89 = &unk_18A090390;
    CFErrorRef v90 = v32;
    -[NEIKEv2Transport waitForTransport:]((uint64_t)v74, buf);
  }

  unint64_t v75 = objc_getProperty(v32, v38, 480LL, 1);

  if (!v75) {
    goto LABEL_36;
  }
  ne_log_obj();
  uint64_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
  {
    unint64_t v77 = *(void *)(a1 + 32);
    uint64_t v79 = *(_DWORD *)(a1 + 72);
    unint64_t v78 = *(_DWORD *)(a1 + 76);
    *(_DWORD *)buf = 138412802;
    *(void *)&buf[4] = v77;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v78;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v79;
    _os_log_impl( &dword_1876B1000,  v76,  OS_LOG_TYPE_INFO,  "%@ Hit max send retries (%u) for request %u, trying TCP encapsulation",  buf,  0x18u);
  }

  objc_super v81 = *(id *)(a1 + 32);
  if (v81) {
    objc_super v81 = objc_getProperty(v81, v80, 336LL, 1);
  }
  uint64_t v82 = -[NEIKEv2IKESA copyTransport]((id *)v81, v80);
  v85[0] = MEMORY[0x1895F87A8];
  v85[1] = 3221225472LL;
  v85[2] = __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_65;
  v85[3] = &unk_18A08D820;
  v83 = *(void **)(a1 + 40);
  v85[4] = *(void *)(a1 + 32);
  v86 = v83;
  v87 = *(void *)(a1 + 72);
  -[NEIKEv2Transport waitForTransport:]((uint64_t)v82, v85);
}

  unint64_t v41 = *v34;
  [v5 objectForKeyedSubscript:*v34];
  unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
  int64_t v43 = isa_nsarray(v42);

  if (v43)
  {
    [v5 objectForKeyedSubscript:v41];
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v68 = 0u;
    uint64_t v69 = 0u;
    size_t v70 = 0u;
    unint64_t v71 = 0u;
    uint64_t v45 = [v44 countByEnumeratingWithState:&v68 objects:v73 count:16];
    if (v45)
    {
      uint64_t v46 = v45;
      int64_t v47 = *(void *)v69;
      do
      {
        uint64_t v48 = 0LL;
        do
        {
          if (*(void *)v69 != v47) {
            objc_enumerationMutation(v44);
          }
          uint64_t v49 = -[NEIPv6Route initFromLegacyDictionary:]( objc_alloc(&OBJC_CLASS___NEIPv6Route),  "initFromLegacyDictionary:",  *(void *)(*((void *)&v68 + 1) + 8 * v48));
          [v37 addObject:v49];

          ++v48;
        }

        while (v46 != v48);
        uint64_t v46 = [v44 countByEnumeratingWithState:&v68 objects:v73 count:16];
      }

      while (v46);
    }
  }

  if (v37) {
    objc_storeStrong((id *)&v6->_includedRoutes, v37);
  }
  uint64_t v50 = *MEMORY[0x18960C740];
  [v5 objectForKeyedSubscript:*MEMORY[0x18960C740]];
  uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v52 = isa_nsarray(v51);

  if (v52)
  {
    uint64_t v63 = v7;
    [v5 objectForKeyedSubscript:v50];
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v54 = (NSArray *)objc_alloc_init(MEMORY[0x189603FA8]);
    uint64_t v64 = 0u;
    uint64_t v65 = 0u;
    uint64_t v66 = 0u;
    uint64_t v67 = 0u;
    BOOL v55 = v53;
    unint64_t v56 = [v55 countByEnumeratingWithState:&v64 objects:v72 count:16];
    if (v56)
    {
      unint64_t v57 = v56;
      unint64_t v58 = *(void *)v65;
      do
      {
        uint64_t v59 = 0LL;
        do
        {
          if (*(void *)v65 != v58) {
            objc_enumerationMutation(v55);
          }
          uint64_t v60 = -[NEIPv6Route initFromLegacyDictionary:]( objc_alloc(&OBJC_CLASS___NEIPv6Route),  "initFromLegacyDictionary:",  *(void *)(*((void *)&v64 + 1) + 8 * v59));
          -[NSArray addObject:](v54, "addObject:", v60);

          ++v59;
        }

        while (v57 != v59);
        unint64_t v57 = [v55 countByEnumeratingWithState:&v64 objects:v72 count:16];
      }

      while (v57);
    }

    excludedRoutes = v6->_excludedRoutes;
    v6->_excludedRoutes = v54;

    char v7 = v63;
  }

LABEL_55:
  return v6;
}

  -[NEVPNProtocol identityDataPassword](self, "identityDataPassword");
  uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();

  if (v37)
  {
    -[NEVPNProtocol identityDataPassword](self, "identityDataPassword");
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_36:
    [v3 setObject:v38 forKeyedSubscript:@"IdentityDataPasswordKeyStr"];
LABEL_37:

    goto LABEL_38;
  }

  -[NEVPNProtocol identityDataPasswordKeychainItem](self, "identityDataPasswordKeychainItem");
  unint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();

  if (v56)
  {
    -[NEVPNProtocol identityDataPasswordKeychainItem](self, "identityDataPasswordKeychainItem");
    unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
    [v57 password];
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v38) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }

LABEL_64:
  uint64_t v74 = v19;
  unint64_t v6 = v74;
  if (v19) {
    unint64_t v75 = (void *)*((void *)v74 + 10);
  }
  else {
    unint64_t v75 = 0LL;
  }
  uint64_t v76 = v75;

  if (v76)
  {
    if (v19) {
      unint64_t v77 = (void *)*((void *)v6 + 10);
    }
    else {
      unint64_t v77 = 0LL;
    }
    unint64_t v78 = v77;
    -[NEConfiguration setConfigurationVPNPassword:](self, v78);
  }

          BOOL v55 = 0LL;
        }

        if (v55) {
          [v41 addObject:v55];
        }
      }

      -[NEIKEv2PacketTunnelProvider invalidateCompanionProxyDatapath]((void *)v1, v84);
      v86 = objc_getProperty((id)v1, v85, 128LL, 1);
      -[NEIKEv2Server resetPathProxyState](v86, v87);
      uint64_t v34 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
LABEL_91:
      ne_log_obj();
      v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v99, OS_LOG_TYPE_INFO))
      {
        v100 = *(void *)(v1 + v34[800]);
        *(_DWORD *)buf = 138412802;
        v107 = v1;
        v108 = 2048;
        *(void *)v109 = v35;
        *(_WORD *)&v109[8] = 2048;
        v110 = v100;
        _os_log_impl(&dword_1876B1000, v99, OS_LOG_TYPE_INFO, "%@: Scoped interface changed: %lu --> %lu\n", buf, 0x20u);
      }

      -[NEIKEv2PacketTunnelProvider handleInterfaceChange:](v1, (const char *)1);
      return;
    }

    uint64_t v79 = objc_getProperty((id)v1, v77, 240LL, 1);
    objc_msgSend( v79,  "sendKeepaliveWithRetries:retryIntervalInMilliseconds:callbackQueue:callback:",  3,  1000,  objc_getProperty((id)v1, v80, 264, 1),  &__block_literal_global_11648);

    uint64_t v34 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
LABEL_72:
    ne_log_obj();
    v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v92, OS_LOG_TYPE_INFO))
    {
      v93 = *(void *)(v1 + v34[800]);
      if (*(void *)(v1 + 256) == 1LL) {
        v94 = "SATISFIED";
      }
      else {
        v94 = "UNSATISFIED";
      }
      v95 = *(_BYTE *)(v1 + 73);
      *(_DWORD *)buf = 138413058;
      if ((v95 & 1) != 0) {
        v96 = " Cellular";
      }
      else {
        v96 = "";
      }
      v107 = v1;
      v108 = 2048;
      *(void *)v109 = v93;
      *(_WORD *)&v109[8] = 2080;
      v110 = (uint64_t)v94;
      v111 = 2080;
      v112 = v96;
      _os_log_impl(&dword_1876B1000, v92, OS_LOG_TYPE_INFO, "%@: Updated scoped ifIndex %lu (%s%s)", buf, 0x2Au);
    }

    if (v35 == *(void *)(v1 + v34[800]) && (!v35 || objc_getProperty((id)v1, v97, 240LL, 1)))
    {
      ne_log_obj();
      unint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138412290;
        v107 = v1;
        _os_log_debug_impl( &dword_1876B1000,  v26,  OS_LOG_TYPE_DEBUG,  "%@: Scoped interface unchanged, ignore\n",  buf,  0xCu);
      }

      goto LABEL_85;
    }

    goto LABEL_91;
  }

  ne_log_obj();
  unint64_t v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v107 = v1;
    _os_log_impl( &dword_1876B1000,  v75,  OS_LOG_TYPE_DEFAULT,  "%@: tearing down tunnel due to Companion link loss",  buf,  0xCu);
  }

  -[NEIKEv2PacketTunnelProvider handleInterfaceDown]((void *)v1);
}
              }
            }

            ++v13;
          }

          while (v13 != v79);
          int64_t v47 = [v75 countByEnumeratingWithState:&v91 objects:v108 count:16];
          uint64_t v79 = v47;
        }

        while (v47);
LABEL_70:

        ne_log_obj();
        uint64_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v61 = (void *)objc_opt_class();
          uint64_t v62 = v61;
          [v7 name];
          uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = v66;
          v112 = v61;
          v113 = 2112;
          v114 = v63;
          v115 = 2112;
          v116 = v72;
          _os_log_debug_impl(&dword_1876B1000, v48, OS_LOG_TYPE_DEBUG, "%@ newPathRules for %@: %@", buf, 0x20u);
        }

        [v7 pathController];
        uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
        [v49 pathRules];
        uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v51 = [v50 count];
        uint64_t v52 = v72;
        uint64_t v53 = [v72 count];

        if (v51 == v53)
        {
          v89 = 0u;
          CFErrorRef v90 = 0u;
          v87 = 0u;
          unint64_t v88 = 0u;
          [v7 pathController];
          uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();
          [v54 pathRules];
          BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();

          unint64_t v56 = [v55 countByEnumeratingWithState:&v87 objects:v107 count:16];
          if (v56)
          {
            unint64_t v57 = v56;
            unint64_t v58 = *(void *)v88;
            while (2)
            {
              for (k = 0LL; k != v57; ++k)
              {
                if (*(void *)v88 != v58) {
                  objc_enumerationMutation(v55);
                }
                if (![v72 containsObject:*(void *)(*((void *)&v87 + 1) + 8 * k)])
                {

                  uint64_t v52 = v72;
                  goto LABEL_83;
                }
              }

              unint64_t v57 = [v55 countByEnumeratingWithState:&v87 objects:v107 count:16];
              if (v57) {
                continue;
              }
              break;
            }
          }

          uint64_t v52 = v72;
        }

        else
        {
LABEL_83:
          [v7 pathController];
          uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
          [v60 setPathRules:v52];

          -[NEProfileIngestion saveConfiguration:returnError:](self, v7, 0LL);
        }

        i = v71;
      }

      size_t v70 = [obj countByEnumeratingWithState:&v95 objects:v109 count:16];
    }

    while (v70);
  }

  return 1;
}

LABEL_70:
  return 1;
}

          uint64_t v35 = 0;
LABEL_71:

          if (!v35) {
            goto LABEL_25;
          }
LABEL_72:
          unint64_t v14 = v5;
          break;
        case 12LL:
          uint64_t v38 = -[NEByteParser parseDomainName](v3, v8);
          unint64_t v39 = (void *)v5[6];
          v5[6] = v38;

          if (v5[6]) {
            goto LABEL_72;
          }
          ne_log_obj();
          unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
            goto LABEL_24;
          }
          *(_WORD *)buf = 0;
          unsigned __int16 v13 = "Failed to parse RR PTR";
          goto LABEL_23;
        default:
          if (v9 == 16)
          {
            unint64_t v40 = -[NEByteParser parseBytes:]((uint64_t)v3, v8);
            if (v40)
            {
              unint64_t v41 = [objc_alloc(NSString) initWithBytes:v40 length:v5[5] encoding:4];
              unint64_t v42 = (void *)v5[6];
              v5[6] = v41;

              goto LABEL_72;
            }

            ne_log_obj();
            unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              unsigned __int16 v13 = "Failed to parse RR TXT";
              goto LABEL_23;
            }
          }

          else
          {
            if (v9 != 28) {
              goto LABEL_72;
            }
            if ((_DWORD)v8 != 16) {
              goto LABEL_25;
            }
            unint64_t v16 = -[NEByteParser parseAddressWithFamily:]((uint64_t)v3, 30);
            unsigned __int16 v17 = (void *)v5[6];
            v5[6] = v16;

            if (v5[6]) {
              goto LABEL_72;
            }
            ne_log_obj();
            unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              unsigned __int16 v13 = "Failed to parse RR AAAA address";
              goto LABEL_23;
            }
          }

          goto LABEL_24;
      }

      goto LABEL_26;
    }

    ne_log_obj();
    unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    *(_WORD *)buf = 0;
    unsigned __int16 v13 = "Failed to parse RR length";
    goto LABEL_23;
  }

  ne_log_obj();
  unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    unsigned __int16 v13 = "Failed to parse RR TTL";
    goto LABEL_23;
  }

  v438 = 0;
  uint64_t v76 = objc_getProperty(self, v75, 136LL, 1);
  unint64_t v78 = v76;
  if (v76) {
    uint64_t v76 = objc_getProperty(v76, v77, 24LL, 1);
  }
  uint64_t v79 = v76;
  -[NEIKEv2EAP createPayloadResponseForRequest:ikeSA:success:reportEAPError:]( (uint64_t)obj,  v79,  v21,  (BOOL *)&v438 + 1,  (BOOL *)&v438);
  uint64_t v80 = (uint64_t)v21;
  objc_super v81 = (void *)objc_claimAutoreleasedReturnValue();

  v410 = (_BYTE *)v80;
  if (v33)
  {
    -[NEIKEv2IKESA setState:error:](v80, 3uLL, v33);
    uint64_t v68 = 0LL;
    unint64_t v22 = self;
    goto LABEL_181;
  }

  if (HIBYTE(v438) || v81)
  {
    v117 = -[NEIKEv2Packet initOutbound](objc_alloc(&OBJC_CLASS___NEIKEv2IKEAuthPacket));
    unint64_t v22 = self;
    if (!v117)
    {
      ne_log_obj();
      v189 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v189, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( &dword_1876B1000,  v189,  OS_LOG_TYPE_FAULT,  "[[NEIKEv2IKEAuthPacket alloc] initOutbound:] failed",  buf,  2u);
      }

      v197 = (void *)NEIKEv2CreateErrorInternal( @"[[NEIKEv2IKEAuthPacket alloc] initOutbound:] failed",  v190,  v191,  v192,  v193,  v194,  v195,  v196,  v409);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v410, 3uLL, v197);

      goto LABEL_143;
    }

    if (v81)
    {
      v118 = objc_alloc_init(&OBJC_CLASS___NEIKEv2EAPPayload);
      objc_setProperty_atomic(v117, v119, v118, 136LL);

      v121 = objc_getProperty(v117, v120, 136LL, 1);
      v123 = v121;
      if (v121) {
        objc_setProperty_atomic(v121, v122, v81, 24LL);
      }

      v415 = v117;
      ne_log_obj();
      v124 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v124, OS_LOG_TYPE_DEBUG))
      {
        v313 = (void *)[self copyShortDescription];
        *(_DWORD *)buf = 138412290;
        *(void *)&buf[4] = v313;
        _os_log_debug_impl( &dword_1876B1000,  v124,  OS_LOG_TYPE_DEBUG,  "%@ Received request for device identity notify payload.",  buf,  0xCu);
      }

      v126 = objc_getProperty(v410, v125, 88LL, 1);
      [v126 IMEI];
      v127 = (void *)objc_claimAutoreleasedReturnValue();
      v129 = objc_getProperty(v410, v128, 88LL, 1);
      [v129 IMEISV];
      v130 = (void *)objc_claimAutoreleasedReturnValue();
      v131 = +[NEIKEv2IKEAuthPacket prepareDeviceIdentityNotifyPayload:IMEISV:lastResponderPacket:](v412, v127, v130, self);
      if (!v131
        || (v132 = +[NEIKEv2NotifyPayload createNotifyPayloadType:data:]( (uint64_t)&OBJC_CLASS___NEIKEv2NotifyPayload,  0xA08DuLL,  v131),  v133 = -[NEIKEv2Packet addNotifyPayload:](v415, v132),  v132,  v133))
      {

        unint64_t v22 = self;
LABEL_157:
        v117 = v415;
        goto LABEL_158;
      }

      ne_log_obj();
      v237 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v237, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( &dword_1876B1000,  v237,  OS_LOG_TYPE_FAULT,  "[responsePacket addNotifyPayload:notifyPayload] failed",  buf,  2u);
      }

      v245 = (void *)NEIKEv2CreateErrorInternal( @"[responsePacket addNotifyPayload:notifyPayload] failed",  v238,  v239,  v240,  v241,  v242,  v243,  v244,  v409);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v410, 3uLL, v245);

      goto LABEL_178;
    }

    v199 = objc_alloc_init(&OBJC_CLASS___NEIKEv2AuthPayload);
    objc_setProperty_atomic(v117, v200, v199, 128LL);

    v201 = -[NEIKEv2AuthenticationProtocol initWithMethod:]( objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol),  "initWithMethod:",  2LL);
    objc_getProperty(v117, v202, 128LL, 1);
    v203 = v117;
    v204 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2AuthPayload setAuthProtocol:]((uint64_t)v204, v201);

    v205 = -[NEIKEv2IKESA createInitiatorEAPAuthenticationDataUsingPrimeKey:]((os_log_s *)v410, 0LL);
    v207 = objc_getProperty(v203, v206, 128LL, 1);
    -[NEIKEv2AuthPayload setAuthenticationData:](v207, v205);

    v415 = v203;
    objc_getProperty(v203, v208, 128LL, 1);
    v209 = (void *)objc_claimAutoreleasedReturnValue();
    LOBYTE(v207) = -[NEIKEv2Payload isValid]((uint64_t)v209);

    if ((v207 & 1) == 0)
    {
      ne_log_obj();
      v234 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v234, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = "+[NEIKEv2IKEAuthPacket(Exchange) createEAPForInitiatorIKESA:lastResponderPacket:]";
        _os_log_fault_impl( &dword_1876B1000,  v234,  OS_LOG_TYPE_FAULT,  "%s called with null responsePacket.auth.isValid",  buf,  0xCu);
      }

LABEL_178:
      uint64_t v68 = 0LL;
      unint64_t v10 = v420;
      unint64_t v22 = self;
LABEL_179:
      v117 = v415;
      goto LABEL_180;
    }

    unint64_t v22 = self;
    v117 = v203;
    if ((v410[24] & 1) == 0)
    {
LABEL_158:
      uint64_t v68 = v117;
      unint64_t v10 = v420;
      goto LABEL_180;
    }

    v211 = objc_getProperty(v410, v210, 88LL, 1);
    v212 = [v211 ppkIDType];
    v213 = v212;

    v437 = v212;
    if (v212)
    {
      v215 = objc_getProperty(v410, v214, 88LL, 1);
      [v215 ppkID];
      v216 = (void *)objc_claimAutoreleasedReturnValue();

      v117 = v415;
      if (v213 != 2 || v216)
      {
        v217 = v216;
        v218 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FB8]),  "initWithCapacity:",  objc_msgSend(v216, "length") + 1);
        [v218 appendBytes:&v437 length:1];
        v413 = v217;
        [v218 appendData:v217];
        unint64_t v33 = 0LL;
        if (-[NEIKEv2Packet addNotification:data:](v415, 0x4034uLL, v218))
        {
          v220 = objc_getProperty(v410, v219, 88LL, 1);
          v221 = [v220 ppkMandatory];

          if ((v221 & 1) != 0)
          {
LABEL_156:

            unint64_t v22 = self;
            goto LABEL_157;
          }

          v222 = -[NEIKEv2IKESA createInitiatorEAPAuthenticationDataUsingPrimeKey:]((os_log_s *)v410, (const char *)1);
          v117 = v415;
          if (-[NEIKEv2Packet addNotification:data:](v415, 0x4035uLL, v222))
          {

            goto LABEL_156;
          }

          v411 = v222;
          ne_log_obj();
          v304 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          unint64_t v10 = v420;
          if (os_log_type_enabled(v304, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl( &dword_1876B1000,  v304,  OS_LOG_TYPE_FAULT,  "[responsePacket addNotification:NEIKEv2NotifyTypeNoPPKAuth] failed",  buf,  2u);
          }

          v312 = (void *)NEIKEv2CreateErrorInternal( @"[responsePacket addNotification:NEIKEv2NotifyTypeNoPPKAuth] failed",  v305,  v306,  v307,  v308,  v309,  v310,  v311,  v409);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v410, 3uLL, v312);

          unint64_t v22 = self;
          v280 = v411;
        }

        else
        {
          ne_log_obj();
          v272 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          unint64_t v10 = v420;
          if (os_log_type_enabled(v272, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl( &dword_1876B1000,  v272,  OS_LOG_TYPE_FAULT,  "[responsePacket addNotification:NEIKEv2NotifyTypePPKIdentity] failed",  buf,  2u);
          }

          v280 = (void *)NEIKEv2CreateErrorInternal( @"[responsePacket addNotification:NEIKEv2NotifyTypePPKIdentity] failed",  v273,  v274,  v275,  v276,  v277,  v278,  v279,  v409);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v410, 3uLL, v280);
          unint64_t v22 = self;
        }

LABEL_143:
        uint64_t v68 = 0LL;
LABEL_180:

        goto LABEL_181;
      }

      v404 = v420;
      ne_log_obj();
      v405 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v405, OS_LOG_TYPE_FAULT))
      {
LABEL_282:

        uint64_t v68 = 0LL;
        v408 = v404;
        unint64_t v22 = self;
        unint64_t v33 = 0LL;
        unint64_t v10 = v408;
        goto LABEL_179;
      }

      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = "+[NEIKEv2IKEAuthPacket(Exchange) createEAPForInitiatorIKESA:lastResponderPacket:]";
      v406 = "%s called with null ppkID";
    }

    else
    {
      v404 = v420;
      ne_log_obj();
      v405 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v405, OS_LOG_TYPE_FAULT)) {
        goto LABEL_282;
      }
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = "+[NEIKEv2IKEAuthPacket(Exchange) createEAPForInitiatorIKESA:lastResponderPacket:]";
      v406 = "%s called with null ppkIDType";
    }

    _os_log_fault_impl(&dword_1876B1000, (os_log_t)v405, OS_LOG_TYPE_FAULT, v406, buf, 0xCu);
    goto LABEL_282;
  }

  unint64_t v22 = self;
  if ((_BYTE)v438) {
    ErrorAuthentication = (void *)NEIKEv2CreateError(10LL);
  }
  else {
    ErrorAuthentication = (void *)NEIKEv2CreateErrorAuthentication( @"EAP error",  v82,  v83,  v84,  v85,  v86,  v87,  v88,  v409);
  }
  v188 = ErrorAuthentication;
  -[NEIKEv2IKESA setState:error:]((uint64_t)v410, 3uLL, ErrorAuthentication);

  uint64_t v68 = 0LL;
LABEL_181:

  uint64_t v21 = v410;
LABEL_182:

LABEL_183:
  if (v68)
  {
    uint64_t v69 = "EAP";
LABEL_185:
    if (v7 && (v7[9] & 1) != 0)
    {
      v433[0] = MEMORY[0x1895F87A8];
      v433[1] = 3221225472LL;
      v433[2] = __72__NEIKEv2Session_Exchange__handleEAPAndGSPMForIKESA_authPacket_handler___block_invoke;
      v433[3] = &unk_18A08CFB0;
      v433[4] = a1;
      v436 = v69;
      v434 = v7;
      v435 = v10;
      if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v68, v433) == -1)
      {
        v261 = objc_getProperty(a1, v260, 336LL, 1);
        v269 = (void *)NEIKEv2CreateErrorFailedToSend( @"%s response (connect)",  v262,  v263,  v264,  v265,  v266,  v267,  v268,  (uint64_t)v69);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v261, 3uLL, v269);

        -[NEIKEv2Session reportState](a1, v270);
        -[NEIKEv2Session resetAll]((uint64_t)a1, v271);
      }

      v259 = v434;
    }

    else
    {
      v429[0] = MEMORY[0x1895F87A8];
      v429[1] = 3221225472LL;
      v429[2] = __72__NEIKEv2Session_Exchange__handleEAPAndGSPMForIKESA_authPacket_handler___block_invoke_119;
      v429[3] = &unk_18A08CFB0;
      v429[4] = a1;
      v432 = v69;
      v430 = v7;
      v431 = v10;
      if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v68, v429) & 1) == 0)
      {
        v248 = objc_getProperty(a1, v247, 336LL, 1);
        v256 = (void *)NEIKEv2CreateErrorFailedToSend( @"%s response (receive)",  v249,  v250,  v251,  v252,  v253,  v254,  v255,  (uint64_t)v69);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v248, 3uLL, v256);

        -[NEIKEv2Session reportState](a1, v257);
        -[NEIKEv2Session resetAll]((uint64_t)a1, v258);
      }

      v259 = v430;
    }

    goto LABEL_194;
  }

  if (*((void *)v21 + 6) != 3LL) {
    goto LABEL_230;
  }
  v294 = a1;
  v295 = objc_getProperty(v21, v246, 56LL, 1);
  [v295 domain];
  v296 = (void *)objc_claimAutoreleasedReturnValue();
  if (([v296 isEqual:@"NEIKEv2ErrorDomain"] & 1) == 0)
  {

    a1 = v294;
LABEL_230:
    ne_log_obj();
    v330 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v330, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v446 = 138412290;
      v447 = (const char *)a1;
      _os_log_error_impl( &dword_1876B1000,  v330,  OS_LOG_TYPE_ERROR,  "%@ Failed to process IKE Auth (EAP) packet (connect)",  v446,  0xCu);
    }

    v332 = objc_getProperty(a1, v331, 336LL, 1);
    v340 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Failed to process IKE Auth (EAP) packet (connect)",  v333,  v334,  v335,  v336,  v337,  v338,  v339,  v409);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v332, 3uLL, v340);

    -[NEIKEv2Session reportState](a1, v341);
    -[NEIKEv2Session resetAll]((uint64_t)a1, v342);
    goto LABEL_194;
  }

  v298 = objc_getProperty(v21, v297, 56LL, 1);
  v299 = v7;
  v300 = [v298 code];

  v301 = v300 == 5;
  char v7 = v299;
  a1 = v294;
  if (!v301) {
    goto LABEL_230;
  }
  ne_log_obj();
  v302 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v302, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v446 = 138412290;
    v447 = (const char *)v294;
    _os_log_impl( &dword_1876B1000,  v302,  OS_LOG_TYPE_DEFAULT,  "%@ Received server redirect in IKE Auth (EAP) (connect)",  v446,  0xCu);
  }

  -[NEIKEv2Session reportServerRedirect:](v294, self);
  -[NEIKEv2Session resetAll]((uint64_t)v294, v303);
  v10[2](v10, 0LL);
  char v7 = v299;
LABEL_194:
}
}

        BOOL v20 = 0LL;
        goto LABEL_71;
      }

      uint64_t v21 = 0LL;
      if (!v15) {
        goto LABEL_70;
      }
      BOOL v20 = 0LL;
      v15[8] = v8[4];
LABEL_71:
      -[os_log_s addObject:](newValue, "addObject:", v15, v55);
      uint64_t v46 = v15;
      int64_t v47 = *v8;
      v10 -= v14;
      v8 += v14;

      if (v47 != 2) {
        goto LABEL_79;
      }
    }

    unsigned __int16 v17 = -[NEIKEv2IKESPI initWithValue:]( objc_alloc(&OBJC_CLASS___NEIKEv2IKESPI),  "initWithValue:",  *((void *)v8 + 1));
    objc_setProperty_atomic(v2, v18, v17, 32LL);
LABEL_15:

    unint64_t v16 = v8[6];
    goto LABEL_17;
  }

  ne_log_obj();
  size_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315138;
    v70[0] = "-[NEIKEv2IKESAPayload parsePayloadData]";
    _os_log_error_impl( &dword_1876B1000,  v4,  OS_LOG_TYPE_ERROR,  "BACKTRACE %s called with null (self.payloadData.length >= sizeof(ikev2_proposal_t))",  buf,  0xCu);
  }

          unint64_t v2 = v54;

          goto LABEL_10;
        }

        if (v33)
        {
          uint64_t v34 = *(unsigned __int8 *)(v3 + 18);
          *(_DWORD *)buf = v53;
          v60[0] = v20;
          LOWORD(v60[1]) = 1024;
          *(_DWORD *)((char *)&v60[1] + 2) = v34;
          _os_log_error_impl( &dword_1876B1000,  v32,  OS_LOG_TYPE_ERROR,  "Unencrypted payload type %u is not permitted for packet type %u",  buf,  0xEu);
        }

        goto LABEL_44;
      }

      if (v5 && objc_getProperty((id)v5, v29, 80LL, 1))
      {
        objc_msgSend(objc_getProperty((id)v5, v30, 80, 1), "arrayByAddingObject:", v28);
        unint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      }

      else
      {
        unint64_t v57 = v28;
        objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v57, 1, v53);
        unint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!v5)
        {
LABEL_44:

          goto LABEL_45;
        }
      }

      objc_setProperty_atomic((id)v5, v31, v32, 80LL);
      goto LABEL_44;
    }

  [v6 objectForKeyedSubscript:@"local-identifier"];
  unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();

  if (v36)
  {
    [v6 objectForKeyedSubscript:@"local-identifier"];
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    [v7 setLocalIdentifier:v37];
  }

  [v6 objectForKeyedSubscript:@"remote-identifier"];
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();

  if (v38)
  {
    [v6 objectForKeyedSubscript:@"remote-identifier"];
    unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
    [v7 setRemoteIdentifier:v39];
  }

  [v6 objectForKeyedSubscript:@"use-extended-authentication"];
  unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();

  if (v40)
  {
    [v6 objectForKeyedSubscript:@"use-extended-authentication"];
    unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "setUseExtendedAuthentication:", objc_msgSend(v41, "BOOLValue"));
  }

  unint64_t v42 = @"dead-peer-detection-rate";
  [v6 objectForKeyedSubscript:@"dead-peer-detection-rate"];
  int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();

  if (v43)
  {
    if ([v7 type] != 5) {
      goto LABEL_187;
    }
    [v6 objectForKeyedSubscript:@"dead-peer-detection-rate"];
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v17 isEqualToString:@"none"])
    {
      uint64_t v44 = 0LL;
LABEL_89:
      [v7 setDeadPeerDetectionRate:v44];

      goto LABEL_90;
    }

    if ([v17 isEqualToString:@"low"])
    {
      uint64_t v44 = 1LL;
      goto LABEL_89;
    }

    if ([v17 isEqualToString:@"medium"])
    {
      uint64_t v44 = 2LL;
      goto LABEL_89;
    }

    if ([v17 isEqualToString:@"high"])
    {
      uint64_t v44 = 3LL;
      goto LABEL_89;
    }

    [NSString stringWithFormat:@"Invalid %@, valid values are none, low, medium, and high", @"dead-peer-detection-rate", v87, v88, v89, v90, v91, v92, v93];
LABEL_83:
    *a4 = (id)objc_claimAutoreleasedReturnValue();

    goto LABEL_84;
  }

LABEL_27:
  [v6 objectForKeyedSubscript:@"Path"];
  BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v26 = isa_nsstring(v25);

  if (v26)
  {
    [v6 objectForKeyedSubscript:@"Path"];
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEAppRule setMatchPath:](v19, "setMatchPath:", v27);
  }

  if (-[NEAppRule noRestriction](v19, "noRestriction"))
  {
    [v6 objectForKeyedSubscript:@"NoDivertDNS"];
    unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
  }

  uint64_t v74 = v7;
  unint64_t v75 = v6;
  uint64_t v72 = (void *)v17;
  unint64_t v73 = (void *)v8;
  size_t v70 = v21;
  if (v8) {
    uint64_t v29 = (void *)v8;
  }
  else {
    uint64_t v29 = (void *)v17;
  }
  [v29 appRules];
  unint64_t v78 = 0u;
  uint64_t v79 = 0u;
  uint64_t v76 = 0u;
  unint64_t v77 = 0u;
  unint64_t v33 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v34 = [v33 countByEnumeratingWithState:&v76 objects:v80 count:16];
  if (v34)
  {
    uint64_t v35 = v34;
    unint64_t v36 = *(void *)v77;
    while (2)
    {
      for (i = 0LL; i != v35; ++i)
      {
        if (*(void *)v77 != v36) {
          objc_enumerationMutation(v33);
        }
        uint64_t v38 = *(void **)(*((void *)&v76 + 1) + 8 * i);
        [v38 matchSigningIdentifier];
        unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEAppRule matchSigningIdentifier](v19, "matchSigningIdentifier");
        unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v41 = [v39 isEqualToString:v40];

        if (v41)
        {
          [v38 matchDomains];
          int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
          -[NEAppRule matchDomains](v19, "matchDomains");
          uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
          -[NEConfiguration mergeArray:withArray:](self, v43, v44);
          uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
          [v38 setMatchDomains:v45];

          [v38 matchAccountIdentifiers];
          uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
          -[NEAppRule matchAccountIdentifiers](v19, "matchAccountIdentifiers");
          int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
          -[NEConfiguration mergeArray:withArray:](self, v46, v47);
          uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue();
          [v38 setMatchAccountIdentifiers:v48];

          uint64_t v49 = v33;
          char v7 = v74;
          unint64_t v6 = v75;
          unsigned __int16 v17 = (uint64_t)v72;
          unint64_t v8 = (uint64_t)v73;
          uint64_t v21 = v70;
          goto LABEL_65;
        }
      }

      uint64_t v35 = [v33 countByEnumeratingWithState:&v76 objects:v80 count:16];
      if (v35) {
        continue;
      }
      break;
    }
  }

  if (v33) {
    unint64_t v42 = (id)[v33 mutableCopy];
  }
  else {
    unint64_t v42 = objc_alloc_init(MEMORY[0x189603FA8]);
  }
  uint64_t v49 = v42;
  unint64_t v8 = (uint64_t)v73;
  char v7 = v74;
  uint64_t v21 = v70;
  unsigned __int16 v17 = (uint64_t)v72;
  unint64_t v6 = v75;
  if (v42)
  {
    [v42 addObject:v19];
    if (v73) {
      uint64_t v51 = v73;
    }
    else {
      uint64_t v51 = v72;
    }
    [v51 setAppRules:v49];
LABEL_65:

    ne_log_obj();
    uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v56 = (id)objc_opt_class();
      if (v8) {
        unint64_t v57 = (void *)v8;
      }
      else {
        unint64_t v57 = (void *)v17;
      }
      [v57 appRules];
      uint64_t v66 = (__CFString *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412546;
      uint64_t v82 = v56;
      v83 = 2112;
      uint64_t v84 = v66;
      _os_log_debug_impl(&dword_1876B1000, v52, OS_LOG_TYPE_DEBUG, "%@ setPerAppRuleSettings: done with %@", buf, 0x16u);
    }

    unint64_t v22 = 1;
  }

  else
  {
    ne_log_obj();
    uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      uint64_t v67 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412290;
      uint64_t v82 = v67;
      uint64_t v68 = v67;
      _os_log_error_impl( &dword_1876B1000,  v52,  OS_LOG_TYPE_ERROR,  "%@ setPerAppRuleSettings: failed to allocate for app rules",  buf,  0xCu);

      unint64_t v8 = (uint64_t)v73;
      unsigned __int16 v17 = (uint64_t)v72;
      uint64_t v21 = v70;
    }

    unint64_t v22 = 0;
  }

LABEL_68:
  return v22;
}

  return v9;
}

  uint64_t v23 = *(dispatch_queue_s **)(a1 + 64);
  if (v23)
  {
    unint64_t v24 = *(void **)(a1 + 80);
    if (v24)
    {
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 3221225472LL;
      block[2] = __120__NEConfigurationManager_saveConfigurationToDisk_currentSignature_userUUID_isUpgrade_completionQueue_completionHandler___block_invoke_135;
      block[3] = &unk_18A0908C8;
      __int16 v27 = v24;
      unint64_t v26 = v8;
      dispatch_async(v23, block);
    }
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
}

  objc_initWeak((id *)buf, v4);
  unint64_t v36 = MEMORY[0x1895F87A8];
  *(void *)size_t v70 = MEMORY[0x1895F87A8];
  unint64_t v71 = 3221225472LL;
  uint64_t v72 = __38__NEFlowNexus_setupFlowDivertDirector__block_invoke;
  unint64_t v73 = &unk_18A08C598;
  objc_copyWeak(v74, (id *)buf);
  NEFlowDirectorSetNewFlowCallback();
  *(void *)uint64_t v62 = v36;
  uint64_t v63 = 3221225472LL;
  uint64_t v64 = __38__NEFlowNexus_setupFlowDivertDirector__block_invoke_2;
  uint64_t v65 = &unk_18A08C5C0;
  objc_copyWeak(v66, (id *)buf);
  NEFlowDirectorSetMatchRulesCallback();
  NEFlowDirectorStart();
  objc_destroyWeak(v66);
  objc_destroyWeak(v74);
  objc_destroyWeak((id *)buf);
  uint64_t v37 = objc_alloc(&OBJC_CLASS___NEPolicy);
  +[NEPolicyResult divertSocketToControlUnit:]( &OBJC_CLASS___NEPolicyResult,  "divertSocketToControlUnit:",  v4->_flowDivertControlUnit);
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
  -[NENexus interfaceName](v4, "interfaceName");
  unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
  +[NEPolicyCondition scopedInterface:](&OBJC_CLASS___NEPolicyCondition, "scopedInterface:", v39);
  unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
  *(void *)size_t v70 = v40;
  [MEMORY[0x189603F18] arrayWithObjects:v70 count:1];
  unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v42 = -[NEPolicy initWithOrder:result:conditions:](v37, "initWithOrder:result:conditions:", 0LL, v38, v41);

  if (!v42)
  {
    ne_log_obj();
    uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_FAULT)) {
      goto LABEL_38;
    }
    *(_WORD *)uint64_t v62 = 0;
    uint64_t v53 = "[NEPolicy initWithOrder:result:conditions:] failed";
    goto LABEL_37;
  }

  objc_getProperty(v4, v43, 120LL, 1);
  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v45 = [v44 addPolicy:v42] == 0;

  if (v45)
  {
    ne_log_obj();
    uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_FAULT)) {
      goto LABEL_38;
    }
    *(_WORD *)uint64_t v62 = 0;
    uint64_t v53 = "[NEPolicySession addPolicy:] failed";
    goto LABEL_37;
  }

  objc_getProperty(v4, v46, 120LL, 1);
  int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v48 = [v47 apply];

  if ((v48 & 1) == 0)
  {
    ne_log_obj();
    uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_FAULT)) {
      goto LABEL_38;
    }
    *(_WORD *)uint64_t v62 = 0;
    uint64_t v53 = "[NEPolicySession apply] failed";
LABEL_37:
    _os_log_fault_impl(&dword_1876B1000, v52, OS_LOG_TYPE_FAULT, v53, v62, 2u);
LABEL_38:

    ne_log_obj();
    unint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)size_t v70 = 0;
      _os_log_fault_impl(&dword_1876B1000, v33, OS_LOG_TYPE_FAULT, "setupFlowDivertDirector failed", v70, 2u);
    }

LABEL_28:
    BOOL v25 = 0;
    goto LABEL_29;
  }

  BOOL v25 = 1;
LABEL_29:

  return v25;
}

  BOOL v20 = 0LL;
LABEL_28:

  return v20;
}
  }
}
}

  if (CFDataGetLength(v50) > v52)
  {
    uint64_t v53 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT))
    {
      Length = CFDataGetLength(v50);
      *(_DWORD *)buf = 134218240;
      *(void *)uint64_t v63 = v52;
      *(_WORD *)&v63[8] = 2048;
      *(void *)&v63[10] = Length;
      _os_log_fault_impl( &dword_1876B1000,  v53,  OS_LOG_TYPE_FAULT,  "pfkey_send_x1: calculated message length (%lu) is less than final message len (%lu)",  buf,  0x16u);
    }
  }

  myCFDataReleaseReset(&v61);
  return v51;
}

  uint64_t v38 = v22;
LABEL_30:

  return v38;
}

          if (v5 == ++v6) {
            return v2;
          }
        }
      }
    }
  }

  return 0LL;
}
  }

  if (-[NEVPNApp restrictDomains](self, "restrictDomains"))
  {
    -[NEVPN protocol](self, "protocol");
    unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    [v24 serverAddress];
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();

    if (v25)
    {
      unint64_t v26 = (void *)[objc_alloc(MEMORY[0x189604030]) initWithString:v25];
      __int16 v27 = v26;
      if (!v26 || ([v26 host], (unint64_t v28 = (id)objc_claimAutoreleasedReturnValue()) == 0)) {
        unint64_t v28 = v25;
      }
      [MEMORY[0x189607810] characterSetWithCharactersInString:@"."];
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
      [v28 stringByTrimmingCharactersInSet:v29];
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();

      uint64_t v65 = v30;
      [v30 componentsSeparatedByString:@"."];
      unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
      if ((unint64_t)[v31 count] > 1)
      {
        uint64_t v62 = v27;
        uint64_t v63 = v25;
        uint64_t v64 = v5;
        uint64_t v67 = v4;
        uint64_t v61 = v31;
        objc_msgSend(v31, "subarrayWithRange:", objc_msgSend(v31, "count") - 2, 2);
        uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
        [v60 componentsJoinedByString:@"."];
        unint64_t v36 = self;
        uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
        [@"." stringByAppendingString:v34];
        unint64_t v73 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v37 = objc_alloc_init(MEMORY[0x189603FC8]);
        uint64_t v82 = 0u;
        v83 = 0u;
        uint64_t v84 = 0u;
        uint64_t v85 = 0u;
        -[NEVPNApp appRules](v36, "appRules");
        obj = (id)objc_claimAutoreleasedReturnValue();
        uint64_t v69 = [obj countByEnumeratingWithState:&v82 objects:v97 count:16];
        if (v69)
        {
          uint64_t v68 = *(void *)v83;
          do
          {
            uint64_t v38 = 0LL;
            do
            {
              if (*(void *)v83 != v68) {
                objc_enumerationMutation(obj);
              }
              size_t v70 = v38;
              unint64_t v39 = *(void **)(*((void *)&v82 + 1) + 8LL * (void)v38);
              unint64_t v78 = 0u;
              uint64_t v79 = 0u;
              uint64_t v80 = 0u;
              objc_super v81 = 0u;
              [v39 matchDomains];
              unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
              unint64_t v41 = [v40 countByEnumeratingWithState:&v78 objects:v96 count:16];
              if (v41)
              {
                unint64_t v42 = v41;
                int64_t v43 = *(void *)v79;
                do
                {
                  for (k = 0LL; k != v42; ++k)
                  {
                    if (*(void *)v79 != v43) {
                      objc_enumerationMutation(v40);
                    }
                    uint64_t v45 = *(void **)(*((void *)&v78 + 1) + 8 * k);
                    [MEMORY[0x189607810] characterSetWithCharactersInString:@"*."];
                    uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
                    [v45 stringByTrimmingCharactersInSet:v46];
                    int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();

                    uint64_t v48 = [v47 length];
                    if (v48 > [v34 length] && !objc_msgSend(v47, "hasSuffix:", v73)
                      || (uint64_t v49 = [v47 length], v49 == objc_msgSend(v34, "length"))
                      && ![v47 isEqualToString:v34]
                      || (uint64_t v50 = [v47 length], v50 < objc_msgSend(v34, "length")))
                    {
                      [v37 setObject:v47 forKeyedSubscript:v47];
                    }
                  }

                  unint64_t v42 = [v40 countByEnumeratingWithState:&v78 objects:v96 count:16];
                }

                while (v42);
              }

              uint64_t v38 = v70 + 1;
            }

            while (v70 + 1 != (char *)v69);
            uint64_t v69 = [obj countByEnumeratingWithState:&v82 objects:v97 count:16];
          }

          while (v69);
        }

        LOBYTE(v5) = v64;
        if ([v37 count])
        {
          uint64_t v76 = 0u;
          unint64_t v77 = 0u;
          uint64_t v74 = 0u;
          unint64_t v75 = 0u;
          unint64_t v71 = v37;
          uint64_t v51 = [v71 countByEnumeratingWithState:&v74 objects:v95 count:16];
          if (v51)
          {
            uint64_t v52 = v51;
            uint64_t v53 = *(void *)v75;
            do
            {
              for (m = 0LL; m != v52; ++m)
              {
                if (*(void *)v75 != v53) {
                  objc_enumerationMutation(v71);
                }
                BOOL v55 = *(void *)(*((void *)&v74 + 1) + 8 * m);
                unint64_t v56 = objc_alloc(NSString);
                NEResourcesCopyLocalizedNSString( @"APP_VPN_INVALID_MATCH_DOMAIN",  @"APP_VPN_INVALID_MATCH_DOMAIN");
                unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
                unint64_t v58 = (void *)objc_msgSend(v56, "initWithFormat:", v57, v55, v34);
                [v67 addObject:v58];
              }

              uint64_t v52 = [v71 countByEnumeratingWithState:&v74 objects:v95 count:16];
            }

            while (v52);
          }

          LOBYTE(v5) = 0;
        }

        size_t v4 = v67;
        __int16 v27 = v62;
        BOOL v25 = v63;
        unint64_t v33 = v60;
        unint64_t v31 = v61;
      }

      else
      {
        unint64_t v32 = objc_alloc(NSString);
        NEResourcesCopyLocalizedNSString(@"APP_VPN_INVALID_DOMAIN", @"APP_VPN_INVALID_DOMAIN");
        unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v34 = (void *)objc_msgSend(v32, "initWithFormat:", v33, objc_msgSend(v31, "count"));
        [v4 addObject:v34];
        LOBYTE(v5) = 0;
      }

      uint64_t v35 = v65;
    }

    else
    {
      NEResourcesCopyLocalizedNSString(@"APP_VPN_NO_DOMAIN", @"APP_VPN_NO_DOMAIN");
      uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
      [v4 addObject:v35];
      LOBYTE(v5) = 0;
    }
  }

  return v5;
}

    unint64_t v15 = 0LL;
    unint64_t v16 = 0;
    goto LABEL_28;
  }

  if (-[NEVPNConnection status](v7, "status") == NEVPNStatusDisconnected)
  {
    -[NEVPNConnection manager](v7, "manager");
    unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    if (v11)
    {
      -[NEVPNConnection manager](v7, "manager");
      unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
      [v12 configuration];
      unsigned __int16 v13 = (void *)objc_claimAutoreleasedReturnValue();
      [v13 VPN];
      unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
      if ([v14 isEnabled])
      {
      }

      else
      {
        -[NEVPNConnection manager](v7, "manager");
        unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
        [v17 configuration];
        __int16 v18 = (void *)objc_claimAutoreleasedReturnValue();
        [v18 appVPN];
        unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v22 = [v19 isEnabled];

        if ((v22 & 1) == 0)
        {
          if (error)
          {
            unint64_t v9 = 2LL;
            goto LABEL_17;
          }

          goto LABEL_27;
        }
      }
    }
  }

  if (v6
    || (-[NEVPNConnection manager](v7, "manager"),
        unint64_t v6 = (NSDictionary *)objc_claimAutoreleasedReturnValue(),
        v6,
        v6)
    && (-[NEVPNConnection manager](v7, "manager"),
        BOOL v20 = (void *)objc_claimAutoreleasedReturnValue(),
        unint64_t v6 = (NSDictionary *)[v20 copyCurrentUserStartOptions],
        v20,
        v6))
  {
    unint64_t v15 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  }

  else
  {
    unint64_t v15 = 0LL;
  }

  ne_session_start_with_options();
  unint64_t v16 = 1;
LABEL_28:

  objc_sync_exit(v7);
  return v16;
}

LABEL_29:
  return v10;
}

  a1 = (id)[a1 initWithName:v8 grade:v68];
  if (!a1)
  {
    ne_log_obj();
    unint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      goto LABEL_51;
    }
    int64_t v43 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412546;
    unint64_t v78 = v43;
    uint64_t v79 = 2112;
    uint64_t v80 = v8;
    uint64_t v44 = v43;
    uint64_t v45 = "%@ initWithPathControllerPayload: initWithName failed for '%@'";
    goto LABEL_68;
  }

  unint64_t v28 = objc_alloc_init(&OBJC_CLASS___NEPathController);
  [a1 setPathController:v28];

  [a1 pathController];
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v29)
  {
    ne_log_obj();
    unint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      goto LABEL_51;
    }
    uint64_t v59 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412546;
    unint64_t v78 = v59;
    uint64_t v79 = 2112;
    uint64_t v80 = v8;
    uint64_t v44 = v59;
    uint64_t v45 = "%@ initWithPathControllerPayload failed, could not create Path Controller for config '%@'";
LABEL_68:
    _os_log_error_impl(&dword_1876B1000, v42, OS_LOG_TYPE_ERROR, v45, buf, 0x16u);

LABEL_51:
    ne_log_obj();
    uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v46 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412290;
      unint64_t v78 = v46;
      int64_t v47 = v46;
      _os_log_debug_impl( &dword_1876B1000,  v38,  OS_LOG_TYPE_DEBUG,  "%@ initWithPathControllerPayload: failed",  buf,  0xCu);
LABEL_54:

      goto LABEL_39;
    }

    goto LABEL_39;
  }

  [a1 pathController];
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
  [v30 setEnabled:1];

  [a1 pathController];
  unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v33 = v31;
  if (v31) {
    objc_setProperty_atomic_copy(v31, v32, v11, 32LL);
  }

  ne_log_obj();
  uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
  {
    unint64_t v57 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412290;
    unint64_t v78 = v57;
    unint64_t v58 = v57;
    _os_log_debug_impl(&dword_1876B1000, v34, OS_LOG_TYPE_DEBUG, "%@ initWithPathControllerPayload: done", buf, 0xCu);
  }

  a1 = a1;
  uint64_t v35 = a1;
LABEL_46:

LABEL_47:
  return v35;
}

LABEL_50:
            a1 = 0LL;
            goto LABEL_51;
          }

          goto LABEL_38;
        }
      }

      goto LABEL_53;
    }
  }

  else
  {
  }

  if ((v32 & 1) == 0)
  {
    ne_log_obj();
    unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_49;
    }
    *(_WORD *)buf = 0;
    unsigned __int16 v13 = "Failed to match integrity algorithms, none provided";
    goto LABEL_16;
  }

          unint64_t v9 = v7;
LABEL_30:
          char v7 = 0LL;
LABEL_31:

          goto LABEL_5;
        }

        unsigned __int16 v13 = &OBJC_CLASS____TtC16NetworkExtension24NEIKEv2CryptoKitMLKEM768;
      }

      uint64_t v30 = 0LL;
      unint64_t v15 = [[v13 alloc] initWithPublicKeyData:v6 error:&v30];
      unint64_t v9 = (NEIKEv2KeyExchangeHandlerMLKEM *)v30;
      mlkemHandler = v7->_mlkemHandler;
      v7->_mlkemHandler = (_TtC16NetworkExtension19NEIKEv2CryptoKitKEM *)v15;

      unsigned __int16 v17 = v7->_mlkemHandler;
      ne_log_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v19 = v18;
      if (v17)
      {
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v28 = (const char *)v7->super._method;
          *(_DWORD *)buf = 134217984;
          unint64_t v32 = v28;
          _os_log_debug_impl(&dword_1876B1000, v19, OS_LOG_TYPE_DEBUG, "Encapsulated ML-KEM %zu secret", buf, 0xCu);
        }

        BOOL v20 = v7->_mlkemHandler;
        uint64_t v21 = -[NEIKEv2CryptoKitKEM keyExchangeData](v20, "keyExchangeData");
        keyExchangeData = v7->super._keyExchangeData;
        v7->super._keyExchangeData = (NSData *)v21;

        uint64_t v23 = v7->_mlkemHandler;
        unint64_t v24 = -[os_log_s sharedSecret](v23, "sharedSecret");
        sharedSecret = v7->super._sharedSecret;
        v7->super._sharedSecret = (NSData *)v24;

        goto LABEL_31;
      }

      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
      {
        uint64_t v29 = (const char *)v7->super._method;
        *(_DWORD *)buf = 134218242;
        unint64_t v32 = v29;
        unint64_t v33 = 2112;
        uint64_t v34 = v9;
        _os_log_fault_impl( &dword_1876B1000,  v19,  OS_LOG_TYPE_FAULT,  "Failed to encapsulate ML-KEM %zu secret: %@",  buf,  0x16u);
      }

      uint64_t v23 = (os_log_s *)v9;
      goto LABEL_29;
    }
  }

  ne_log_obj();
  unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v32) = a2;
    _os_log_fault_impl(&dword_1876B1000, v14, OS_LOG_TYPE_FAULT, "Unknown KE method %u", buf, 8u);
  }

  char v7 = 0LL;
LABEL_6:

  return v7;
}

            unint64_t v32 = v98;
          }

          unint64_t v31 = [v29 countByEnumeratingWithState:&v112 objects:buf count:16];
          unint64_t v10 = v99;
          if (v31) {
            continue;
          }
          break;
        }
      }

      ne_log_obj();
      unint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        if (v8) {
          v94 = objc_getProperty(v8, v41, 144LL, 1);
        }
        else {
          v94 = 0LL;
        }
        v95 = v94;
        v96 = [v95 method];
        *(_DWORD *)buf = 138412546;
        *(void *)&buf[4] = v5;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v96;
        _os_log_error_impl( &dword_1876B1000,  v40,  OS_LOG_TYPE_ERROR,  "%@ Received KE method preference %tu is not in config (connect retry KE)",  buf,  0x16u);
      }

      uint64_t v44 = objc_getProperty(v5, v42, 336LL, 1);
      if (v8) {
        uint64_t v45 = objc_getProperty(v8, v43, 144LL, 1);
      }
      else {
        uint64_t v45 = 0LL;
      }
      ErrorCrypto = v45;
      int64_t v47 = [ErrorCrypto method];
      ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Received KE method preference %tu is not in config (connect retry KE)",  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v47);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v44, 3uLL, ErrorPeerInvalidSyntax);

LABEL_44:
      -[NEIKEv2Session reportState](v5, v79);
      -[NEIKEv2Session resetAll]((uint64_t)v5, v80);
    }
  }
  }
}

          objc_setProperty_atomic(v18, v12, v19, v20);
          goto LABEL_30;
        }

        if (v2) {
          objc_setProperty_atomic(v2, v9, v8, 96LL);
        }
LABEL_31:
        ++v7;
      }

      while (v5 != v7);
      unint64_t v5 = -[NEIKEv2InformationalPacket countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v21,  v28,  16LL);
    }

    while (v5);
  }
}
}

LABEL_5:
  char v7 = 1;
LABEL_10:

  return v7;
}

    return;
  }

  unint64_t v6 = v99;
  if (v99 >= 2049)
  {
    if (v99 >= 102400) {
      unint64_t v8 = 102400LL;
    }
    else {
      unint64_t v8 = v99;
    }
    unint64_t v9 = (uint8_t *)malloc(v8);
    if (!v9)
    {
      ne_log_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v8;
        _os_log_error_impl( &dword_1876B1000,  v29,  OS_LOG_TYPE_ERROR,  "Failed to alloc large receive buffer of size %d",  buf,  8u);
      }

      return;
    }

    char v7 = v9;
    if (v6 > 0x19000)
    {
      while (1)
      {
        if (v6 >= 102400) {
          unint64_t v10 = 102400LL;
        }
        else {
          unint64_t v10 = v6;
        }
        unint64_t v11 = recv(v4, v7, v10, 0);
        if (!v11)
        {
          ne_log_obj();
          unint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
            goto LABEL_48;
          }
          *(_WORD *)buf = 0;
          uint64_t v34 = "data purge: no data to read";
          uint64_t v35 = v33;
          unint64_t v36 = 2;
          goto LABEL_101;
        }

        if (v11 == -1) {
          break;
        }
        unint64_t v12 = v11 < v6;
        v6 -= v11;
        unint64_t v12 = !v12 || v6 <= 0;
        if (v12) {
          goto LABEL_49;
        }
      }

      ne_log_obj();
      unint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        goto LABEL_48;
      }
      uint64_t v68 = __error();
      uint64_t v69 = strerror(*v68);
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = v69;
      uint64_t v34 = "data purge: recv() failed: %s";
      uint64_t v35 = v33;
      unint64_t v36 = 12;
LABEL_101:
      _os_log_error_impl(&dword_1876B1000, v35, OS_LOG_TYPE_ERROR, v34, buf, v36);
LABEL_48:

LABEL_49:
      ne_log_obj();
      uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v99;
        _os_log_error_impl( &dword_1876B1000,  v37,  OS_LOG_TYPE_ERROR,  "Received data too large, %d bytes from kernel content filter",  buf,  8u);
      }

      goto LABEL_52;
    }
  }

  else
  {
    char v7 = v107;
    LODWORD(v8) = 2048;
  }

  unsigned __int16 v13 = recv(v4, v7, v8, 0);
  if (v13 == -1)
  {
    ne_log_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_43;
    }
    unsigned __int16 v17 = __error();
    __int16 v18 = strerror(*v17);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v18;
    unint64_t v16 = "recv() failed: %s";
    unint64_t v19 = v14;
    BOOL v20 = 12;
    goto LABEL_42;
  }

  if (*(_DWORD *)v7 <= 0x17u)
  {
    ne_log_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_43;
    }
    unint64_t v15 = *(_DWORD *)v7;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v15;
    unint64_t v16 = "Received message of invalid length %d from kernel content filter";
    goto LABEL_41;
  }

  if (*((_DWORD *)v7 + 2) == 1)
  {
    uint64_t v21 = v13;
    unint64_t v22 = *((void *)v7 + 2);
    uint64_t v23 = (void *)MEMORY[0x189607968];
    unint64_t v24 = *(id *)(v3 + 152);
    [v23 numberWithUnsignedLongLong:v22];
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    [v24 objectForKey:v25];
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();

    -[NEFilterDataExtensionProviderContext socketExceptions](v3);
    unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    [MEMORY[0x189607968] numberWithUnsignedLongLong:v22];
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v28 = [v26 containsObject:v27];

    if (v28)
    {
      +[NEFilterSocketFlow writeMessageWithControlSocket:drop:socketID:inboundPassOffset:inboundPeekOffset:outboundPassOffset:outboundPeekOffset:statsReportFrequency:]( (uint64_t)&OBJC_CLASS___NEFilterSocketFlow,  v4,  0,  v22,  -1LL,  0LL,  -1LL,  0LL,  0LL);
      -[NEFilterDataExtensionProviderContext closeSocketFlow:socketID:]((void *)v3, v5, v22);
LABEL_34:
      if (v6 >= 2049) {
        free(v7);
      }
    }

    else
    {
      uint64_t v38 = *((_DWORD *)v7 + 3);
      switch(v38)
      {
        case 1:
          -[NEFilterDataExtensionProviderContext closeSocketFlow:socketID:]((void *)v3, v5, v22);
          unint64_t v42 = -[NEFilterSocketFlow initWithSocketFamily:socketType:socketProtocol:pid:epid:uuid:euuid:socketID:]( objc_alloc(&OBJC_CLASS___NEFilterSocketFlow),  *((_DWORD *)v7 + 6),  *((_DWORD *)v7 + 7),  *((_DWORD *)v7 + 8),  *((unsigned int *)v7 + 10),  *((unsigned int *)v7 + 11),  (uint64_t)(v7 + 52),  (uint64_t)(v7 + 68),  v22);
          [v42 setRpid:*((unsigned int *)v7 + 12)];
          int64_t v43 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:v7 + 84];
          [v42 setRuuid:v43];

          if (v42)
          {
            if (*((_DWORD *)v7 + 39) == 1)
            {
              [v42 setDirection:2];
              -[NEFilterSocketFlow setLocalAddress:](v42, (sockaddr *)(v7 + 100));
              uint64_t v44 = (sockaddr *)(v7 + 128);
            }

            else
            {
              [v42 setDirection:1];
              -[NEFilterSocketFlow setLocalAddress:](v42, (sockaddr *)v7 + 8);
              uint64_t v44 = (sockaddr *)(v7 + 100);
            }

            -[NEFilterSocketFlow setRemoteAddress:](v42, v44);
            size_t v70 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v7 + 160 length:32];
            [v42 setSourceAppAuditToken:v70];

            unint64_t v71 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v7 + 192 length:32];
            [v42 setSourceProcessAuditToken:v71];

            if (v7[260])
            {
              uint64_t v72 = (void *)[objc_alloc(NSString) initWithCString:v7 + 260 encoding:4];
              [v42 setRemoteHostname:v72];
            }

            if (*((_DWORD *)v7 + 64))
            {
              unint64_t v73 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v7 + 224 length:*((unsigned int *)v7 + 64)];
              objc_msgSend(v42, "setCrypto_signature:", v73);
            }

            uint64_t v74 = (void *)MEMORY[0x189607968];
            unint64_t v75 = *(id *)(v3 + 152);
            [v74 numberWithUnsignedLongLong:v22];
            uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue();
            [v75 setObject:v42 forKey:v76];

            -[NEFilterDataExtensionProviderContext handleNewFlow:reply:controlSocket:completionHandler:]( (void *)v3,  v42,  0LL,  v4,  0LL);
          }

          break;
        case 2:
          if (!v5)
          {
            ne_log_obj();
            int64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_106;
            }
            *(_DWORD *)buf = 134217984;
            *(void *)&buf[4] = v22;
            uint64_t v48 = "Closed message rejected, no flow found for sockid %llu";
            goto LABEL_104;
          }

          -[os_log_s setInBytes:](v5, "setInBytes:", *((void *)v7 + 10));
          -[os_log_s setOutBytes:](v5, "setOutBytes:", *((void *)v7 + 11));
          -[NEFilterSocketFlow setLocalAddress:](v5, (sockaddr *)v7 + 6);
          if (*((_DWORD *)v7 + 39))
          {
            uint64_t v45 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v7 + 124 length:*((unsigned int *)v7 + 39)];
            -[os_log_s setCrypto_signature:](v5, "setCrypto_signature:", v45);
          }

          -[NEFilterDataExtensionProviderContext closeSocketFlow:socketID:]((void *)v3, v5, v22);
          break;
        case 3:
        case 4:
          if (!v5)
          {
            ne_log_obj();
            int64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_106;
            }
            *(_DWORD *)buf = 134217984;
            *(void *)&buf[4] = v22;
            uint64_t v48 = "Data message rejected, no flow found for sockid %llu";
LABEL_104:
            uint64_t v50 = v47;
            uint64_t v51 = 12;
            goto LABEL_105;
          }

          if (v38 == 3)
          {
            -[NEFilterSocketFlow setLocalAddress:](v5, (sockaddr *)(v7 + 24));
            unint64_t v39 = (sockaddr *)(v7 + 52);
          }

          else
          {
            -[NEFilterSocketFlow setLocalAddress:](v5, (sockaddr *)(v7 + 52));
            unint64_t v39 = (sockaddr *)(v7 + 24);
          }

          -[NEFilterSocketFlow setRemoteAddress:](v5, v39);
          if (*((_DWORD *)v7 + 32))
          {
            uint64_t v52 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v7 + 96 length:*((unsigned int *)v7 + 32)];
            -[os_log_s setCrypto_signature:](v5, "setCrypto_signature:", v52);
          }

          uint64_t v54 = *((void *)v7 + 10);
          uint64_t v53 = *((void *)v7 + 11);
          BOOL v55 = v53 - v54;
          if (v53 <= v54)
          {
            ne_log_obj();
            uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            {
              if (*((_DWORD *)v7 + 3) == 3) {
                v95 = "OUT";
              }
              else {
                v95 = "IN";
              }
              *(_DWORD *)buf = 136315138;
              *(void *)&buf[4] = v95;
              _os_log_error_impl( &dword_1876B1000,  v59,  OS_LOG_TYPE_ERROR,  "Received invalid DATA %s message",  buf,  0xCu);
            }

            goto LABEL_34;
          }

          unint64_t v56 = v7 + 176;
          if (-[os_log_s socketProtocol](v5, "socketProtocol") != 17
            && -[os_log_s socketProtocol](v5, "socketProtocol") != 6)
          {
            *((_DWORD *)v7 + 43) = *((_DWORD *)v7 + 33) & 1;
            unint64_t v56 = v7 + 172;
            v55 += 4LL;
          }

          unint64_t v57 = objc_alloc(MEMORY[0x189603F48]);
          if (v6 >= 2049)
          {
            *(void *)buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 3221225472LL;
            *(void *)&buf[16] = __74__NEFilterDataExtensionProviderContext_handleSocketSourceEventWithSocket___block_invoke;
            v105 = &__block_descriptor_40_e12_v24__0_v8Q16l;
            v106 = v7;
            unint64_t v58 = [v57 initWithBytesNoCopy:v56 length:v55 deallocator:buf];
          }

          else
          {
            unint64_t v58 = [v57 initWithBytes:v56 length:v55];
          }

          unint64_t v77 = (void *)v58;
          if (*((_DWORD *)v7 + 3) == 3) {
            unint64_t v78 = 1LL;
          }
          else {
            unint64_t v78 = 2LL;
          }
          uint64_t v79 = *((void *)v7 + 10);
          if (-[os_log_s epid](v5, "epid") != *((_DWORD *)v7 + 34))
          {
            -[os_log_s setEpid:](v5, "setEpid:");
            -[os_log_s setPid:](v5, "setPid:", *((unsigned int *)v7 + 34));
            uint64_t v80 = +[NEProcessInfo copyUUIDsForPID:]( &OBJC_CLASS___NEProcessInfo,  "copyUUIDsForPID:",  -[os_log_s epid](v5, "epid"));
            objc_super v81 = v80;
            if (v80 && [v80 count])
            {
              [v81 firstObject];
              uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
              -[os_log_s setUuid:](v5, "setUuid:", v82);
              -[os_log_s setEuuid:](v5, "setEuuid:", v82);
            }

            -[os_log_s pid](v5, "pid");
            v83 = (void *)NECopySigningIdentifierForPIDwithAuditToken();
            if (v83)
            {
              -[os_log_s setSourceAppIdentifier:](v5, "setSourceAppIdentifier:", v83);
              ne_log_obj();
              uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
              {
                v97 = -[os_log_s sourceAppIdentifier](v5, "sourceAppIdentifier");
                v96 = -[os_log_s pid](v5, "pid");
                *(_DWORD *)v100 = 138412546;
                v101 = v97;
                v102 = 1024;
                v103 = v96;
                _os_log_debug_impl( &dword_1876B1000,  v84,  OS_LOG_TYPE_DEBUG,  "Updating bundleID %@ for pid %d",  v100,  0x12u);
              }
            }

            uint64_t v85 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v7 + 140 length:32];
            -[os_log_s setSourceAppAuditToken:](v5, "setSourceAppAuditToken:", v85);
          }

          -[NEFilterDataExtensionProviderContext handleData:offset:forFlow:direction:reply:controlSocket:completionHandler:]( (void *)v3,  v77,  v79,  v5,  v78,  0LL,  v4,  0LL);

          break;
        case 5:
        case 6:
          if (!v5)
          {
            ne_log_obj();
            int64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v49 = "Inbound";
              if (v38 == 5) {
                uint64_t v49 = "Outbound";
              }
              *(_DWORD *)buf = 136315394;
              *(void *)&buf[4] = v49;
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v22;
              uint64_t v48 = "%s disconnect message rejected, no flow found for sockid %llu";
              uint64_t v50 = v47;
              uint64_t v51 = 22;
LABEL_105:
              _os_log_debug_impl(&dword_1876B1000, v50, OS_LOG_TYPE_DEBUG, v48, buf, v51);
            }

            goto LABEL_106;
          }

          if (v38 == 5) {
            unint64_t v40 = 1LL;
          }
          else {
            unint64_t v40 = 2LL;
          }
          -[NEFilterDataExtensionProviderContext handleDataCompleteForFlow:direction:reply:controlSocket:completionHandler:]( (void *)v3,  v5,  v40,  0LL,  v4,  0LL);
          break;
        case 7:
          ne_log_obj();
          uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 134217984;
            *(void *)&buf[4] = v21;
            _os_log_debug_impl( &dword_1876B1000,  v46,  OS_LOG_TYPE_DEBUG,  "Socket Stats Report - Received stats report size %zd",  buf,  0xCu);
          }

          if (v21 > 31)
          {
            uint64_t v60 = *((unsigned int *)v7 + 6);
            ne_log_obj();
            uint64_t v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v62 = v61;
            if ((_DWORD)v60)
            {
              if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)&buf[4] = v60;
                _os_log_debug_impl( &dword_1876B1000,  v62,  OS_LOG_TYPE_DEBUG,  "Socket Stats Report - Received stats report for %d flows",  buf,  8u);
              }

              uint64_t v63 = 56 * v60 + 32;
              if (v63 > v21 || *(_DWORD *)v7 < v63)
              {
                ne_log_obj();
                unint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_63;
                }
                uint64_t v64 = *(_DWORD *)v7;
                *(_DWORD *)buf = 134218496;
                *(void *)&buf[4] = v21;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v64;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = 56 * v60 + 32;
                uint64_t v65 = "Socket Stats Report - Received wrong msg size in stats report: bytesRead %zd msg_len %d - expected size %d";
                uint64_t v66 = v41;
                uint64_t v67 = 24;
                goto LABEL_147;
              }

              if ((int)v60 >= 1)
              {
                v86 = (sockaddr *)(v7 + 56);
                do
                {
                  v87 = *(void *)&v86[-2].sa_data[6];
                  if (v87)
                  {
                    unint64_t v88 = (void *)MEMORY[0x189607968];
                    v89 = *(id *)(v3 + 152);
                    [v88 numberWithUnsignedLongLong:v87];
                    CFErrorRef v90 = (void *)objc_claimAutoreleasedReturnValue();
                    [v89 objectForKey:v90];
                    unint64_t v91 = (void *)objc_claimAutoreleasedReturnValue();

                    if (v91)
                    {
                      [v91 setInBytes:*(void *)&v86[-1].sa_len];
                      [v91 setOutBytes:*(void *)&v86[-1].sa_data[6]];
                      -[NEFilterSocketFlow setLocalAddress:](v91, v86);
                      if (nelog_is_debug_logging_enabled())
                      {
                        ne_log_obj();
                        v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
                        {
                          *(_DWORD *)buf = 138412290;
                          *(void *)&buf[4] = v91;
                          _os_log_debug_impl( &dword_1876B1000,  v92,  OS_LOG_TYPE_DEBUG,  "Socket Stats Report - flow stats updated for %@",  buf,  0xCu);
                        }
                      }

                      -[NEFilterDataExtensionProviderContext reportFlowStats:]((void *)v3, v91);
                    }

                    else
                    {
                      ne_log_obj();
                      v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v93, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(void *)&buf[4] = v87;
                        _os_log_debug_impl( &dword_1876B1000,  v93,  OS_LOG_TYPE_DEBUG,  "Socket Stats Report - No flow found for sockID %llu",  buf,  0xCu);
                      }
                    }
                  }

                  v86 = (sockaddr *)((char *)v86 + 56);
                  --v60;
                }

                while (v60);
              }
            }

            else
            {
              if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_error_impl( &dword_1876B1000,  v62,  OS_LOG_TYPE_ERROR,  "Socket Stats Report - Received 0 flow stats in stats report",  buf,  2u);
              }
            }
          }

          else
          {
            ne_log_obj();
            int64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134217984;
              *(void *)&buf[4] = v21;
              _os_log_error_impl( &dword_1876B1000,  v47,  OS_LOG_TYPE_ERROR,  "Socket Stats Report - Received msg size is too small (%zd) for stats report",  buf,  0xCu);
            }

    goto LABEL_6;
  }

  unint64_t v6 = xpc_dictionary_get_BOOL(v4, "verdict-drop");
  ne_log_obj();
  char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    unint64_t v31 = a1[5];
    unint64_t v32 = 138412546;
    unint64_t v33 = v31;
    uint64_t v34 = 2112;
    uint64_t v35 = v4;
    _os_log_debug_impl( &dword_1876B1000,  v7,  OS_LOG_TYPE_DEBUG,  "NEFilterSource got new-flow reply %@: %@",  (uint8_t *)&v32,  0x16u);
  }

  if (v6)
  {
    *(void *)(a1[4] + 24LL) = 2LL;
    string = xpc_dictionary_get_string(v4, "remediation-url");
    if (string)
    {
      [NSString stringWithUTF8String:string];
      unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v11 = (void *)a1[4];
      if (v11) {
        objc_setProperty_atomic(v11, v9, v10, 160LL);
      }

      Property = (id)a1[4];
      if (Property) {
        Property = objc_getProperty(Property, v12, 160LL, 1);
      }
      if ([Property isEqualToString:@"x-apple-content-filter://nefilter-unblock"])
      {
        unint64_t v14 = a1[4];
        if (v14) {
          *(_BYTE *)(v14 + 9) = 1;
        }
      }
    }

    unint64_t v15 = xpc_dictionary_get_string(v4, "remediation-button-text");
    if (v15)
    {
      [NSString stringWithUTF8String:v15];
      unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
      __int16 v18 = (void *)a1[4];
      if (v18) {
        objc_setProperty_atomic(v18, v16, v17, 168LL);
      }
    }

    unint64_t v19 = xpc_dictionary_get_string(v4, "organization");
    if (v19)
    {
      [NSString stringWithUTF8String:v19];
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v22 = (void *)a1[4];
      if (v22) {
        objc_setProperty_atomic(v22, v20, v21, 176LL);
      }
    }
  }

  else
  {
    uint64 = xpc_dictionary_get_uint64(v4, "verdict-peek");
    unint64_t v24 = a1[4];
    if (v24) {
      *(void *)(v24 + 112) = uint64;
    }
    *(void *)(a1[4] + 120LL) = xpc_dictionary_get_uint64(v4, "verdict-pass");
    BOOL v25 = a1[4];
    if (*(void *)(v25 + 120) == -1LL) {
      unint64_t v26 = 1LL;
    }
    else {
      unint64_t v26 = 3LL;
    }
    *(void *)(v25 + 24) = v26;
  }

  __int16 v27 = a1[4];
  if (v27) {
    *(_BYTE *)(v27 + 8) = 1;
  }
  unint64_t v28 = xpc_dictionary_get_string(v4, "url-append-string");
  if (v28)
  {
    [NSString stringWithUTF8String:v28];
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v30 = (void *)a1[4];
    if (v30) {
      objc_setProperty_atomic(v30, v29, v5, 152LL);
    }
    goto LABEL_5;
  }
}

  unint64_t v36 = 0u;
  memset(v37, 0, sizeof(v37));
  uint64_t v34 = 0u;
  uint64_t v35 = 0u;
  unint64_t v32 = 0u;
  unint64_t v33 = 0u;
  uint64_t v30 = 0u;
  unint64_t v31 = 0u;
  if (self)
  {
    objc_msgSend(objc_getProperty(self, v5, 40, 1), "getUUIDBytes:", &v30);
    unint64_t v6 = self->super._internalSessionType;
  }

  else
  {
    [0 getUUIDBytes:&v30];
    unint64_t v6 = 0;
  }

  LODWORD(v31) = v6;
  -[NEPathControllerNetworkAgent advisoryInterfaceArray]( self,  "advisoryInterfaceArray",  v30,  v31,  v32,  v33,  (void)v34);
  char v7 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v8 = [v7 count];

  if (v8 >= 4) {
    unint64_t v9 = 4LL;
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9)
  {
    for (i = 0LL; i != v9; ++i)
    {
      -[NEPathControllerNetworkAgent advisoryInterfaceArray](self, "advisoryInterfaceArray");
      unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
      [v11 objectAtIndexedSubscript:i];
      unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
      unsigned __int16 v13 = [v12 unsignedIntegerValue];

      if (v13)
      {
        -[NEPathControllerNetworkAgent advisoryInterfaceArray](self, "advisoryInterfaceArray");
        unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
        [v14 objectAtIndexedSubscript:i];
        unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v16 = (char *)&v30 + 4 * i;
        *((_DWORD *)v16 + 10) = [v15 unsignedIntegerValue];

        -[NEPathControllerNetworkAgent predictedInterfaceArray](self, "predictedInterfaceArray");
        unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
        [v17 objectAtIndexedSubscript:i];
        __int16 v18 = (void *)objc_claimAutoreleasedReturnValue();
        *((_DWORD *)v16 + 14) = [v18 unsignedIntegerValue];
      }
    }
  }

  unint64_t v19 = -[NEPathControllerNetworkAgent weakAdvisory](self, "weakAdvisory");
  BYTE8(v34) = BYTE8(v34) & 0xFE | v19;
  if (-[NEPathControllerNetworkAgent noAdvisoryTimer](self, "noAdvisoryTimer")) {
    BOOL v20 = 2;
  }
  else {
    BOOL v20 = 0;
  }
  BYTE8(v34) = BYTE8(v34) & 0xFD | v20;
  if (-[NEPathControllerNetworkAgent preferAdvisory](self, "preferAdvisory")) {
    uint64_t v21 = 8;
  }
  else {
    uint64_t v21 = 0;
  }
  BYTE8(v34) = BYTE8(v34) & 0xF7 | v21;
  if (-[NEPathControllerNetworkAgent isForcedAdvisory](self, "isForcedAdvisory")) {
    unint64_t v22 = 4;
  }
  else {
    unint64_t v22 = 0;
  }
  BYTE8(v34) = BYTE8(v34) & 0xFB | v22;
  -[NEPathControllerNetworkAgent advisoryAgentDomain](self, "advisoryAgentDomain");
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEPathControllerNetworkAgent advisoryAgentType](self, "advisoryAgentType");
  unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  if (v23 && (unint64_t)[v23 length] <= 0x1F)
  {
    [v23 UTF8String];
    __strlcpy_chk();
  }

  if (v24 && (unint64_t)[v24 length] <= 0x1F)
  {
    [v24 UTF8String];
    __strlcpy_chk();
  }

  [MEMORY[0x189603F48] dataWithBytes:&v30 length:140];
  BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();

  return v25;
}

  unint64_t v8 = 0LL;
LABEL_11:
  -[NEAgentFilterExtension handleExtensionExit:](self, v8);
}

LABEL_60:
      a1 = 0LL;
      goto LABEL_61;
    }

    char v7 = v5;
    [a1 alwaysOnVPN];
    unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v8 = v16;
    if (v16)
    {
      [v16 interfaceProtocolMapping];
      a1 = (void *)objc_claimAutoreleasedReturnValue();

      if (a1)
      {
        [v8 interfaceProtocolMapping];
        unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
        [v17 objectForKeyedSubscript:@"AlwaysOnVPNInterfaceCellular"];
        __int16 v18 = (void *)objc_claimAutoreleasedReturnValue();

        if (v18
          && ([v7 pendingCertificates], (unint64_t v19 = objc_claimAutoreleasedReturnValue()) != 0)
          && (BOOL v20 = (void *)v19,
              [v18 identityReferenceInternal],
              uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(),
              v21,
              v20,
              !v21))
        {
          uint64_t v23 = v18;
        }

        else
        {
          [v8 interfaceProtocolMapping];
          unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
          [v22 objectForKeyedSubscript:@"AlwaysOnVPNInterfaceWiFi"];
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v23) {
            goto LABEL_25;
          }
          [v7 pendingCertificates];
          a1 = (void *)objc_claimAutoreleasedReturnValue();
          if (!a1)
          {
LABEL_41:

LABEL_61:
            goto LABEL_62;
          }

          [v23 identityReferenceInternal];
          unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();

          if (v24)
          {
LABEL_25:
            a1 = 0LL;
            goto LABEL_41;
          }
        }

        [v7 pendingCertificates];
        a1 = (void *)objc_claimAutoreleasedReturnValue();
        goto LABEL_41;
      }
    }

    else
    {
      a1 = 0LL;
    }

    uint64_t v23 = 0LL;
    goto LABEL_41;
  }

          v359 = 0;
          objc_super v81 = 7LL;
          goto LABEL_123;
        }

        ne_log_obj();
        unsigned __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
        {
LABEL_68:

          goto LABEL_69;
        }

        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = "-[NEIKEv2Session(Exchange) receiveRekeyChildSA:packet:]";
        uint64_t v79 = "%s called with null childSA.chosenProposal";
      }

      else
      {
        ne_log_obj();
        unsigned __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
          goto LABEL_68;
        }
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = "-[NEIKEv2Session(Exchange) receiveRekeyChildSA:packet:]";
        uint64_t v79 = "%s called with null childSA";
      }
    }

    else
    {
      ne_log_obj();
      unsigned __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
        goto LABEL_68;
      }
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = "-[NEIKEv2Session(Exchange) receiveRekeyChildSA:packet:]";
      uint64_t v79 = "%s called with null ikeSA";
    }

    _os_log_fault_impl(&dword_1876B1000, v13, OS_LOG_TYPE_FAULT, v79, buf, 0xCu);
    goto LABEL_68;
  }

LABEL_100:
              goto LABEL_101;
            }

            if (v97 < (int)v158)
            {
              v98 = objc_getProperty(self, v94, 232LL, 1);
              v99 = (void *)MEMORY[0x189607968];
              v100 = v98;
              [v99 numberWithInt:v158];
              v101 = (void *)objc_claimAutoreleasedReturnValue();
              [v100 setObject:v95 forKeyedSubscript:v101];

              v103 = objc_getProperty(self, v102, 232LL, 1);
              +[NEIKEv2Session removeItemsFromDictionary:lowerEdge:]((uint64_t)&OBJC_CLASS___NEIKEv2Session, v103, v97);
              v105 = objc_getProperty(self, v104, 224LL, 1);
              +[NEIKEv2Session removeItemsFromDictionary:lowerEdge:]((uint64_t)&OBJC_CLASS___NEIKEv2Session, v105, v97);
              v107 = objc_getProperty(self, v106, 248LL, 1);
              +[NEIKEv2Session removeItemsFromDictionary:lowerEdge:]((uint64_t)&OBJC_CLASS___NEIKEv2Session, v107, v97);
              goto LABEL_116;
            }
          }

          ne_log_obj();
          uint64_t v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412290;
            v160 = self;
            _os_log_impl(&dword_1876B1000, v62, OS_LOG_TYPE_INFO, "%@ Discarding stale request", buf, 0xCu);
          }

  [a1 authenticationKey];
  __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 setObject:v27 forKeyedSubscript:@"AuthKey"];

  if ([a1 replayWindowSize])
  {
    objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedInt:", objc_msgSend(a1, "replayWindowSize"));
    unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    [v2 setObject:v28 forKeyedSubscript:@"ReplayWindowSize"];
  }

  if ([a1 lifetimeSeconds])
  {
    objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedLongLong:", objc_msgSend(a1, "lifetimeSeconds"));
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    [v2 setObject:v29 forKeyedSubscript:@"LifeTimeinSeconds"];
  }

  uint64_t v30 = [a1 natTraversalEnabled];
  unint64_t v31 = *MEMORY[0x189604DE8];
  unint64_t v32 = *MEMORY[0x189604DE0];
  if (v30) {
    unint64_t v33 = *MEMORY[0x189604DE8];
  }
  else {
    unint64_t v33 = *MEMORY[0x189604DE0];
  }
  [v2 setObject:v33 forKeyedSubscript:@"NATTraversal"];
  else {
    uint64_t v34 = v32;
  }
  [v2 setObject:v34 forKeyedSubscript:@"NATTDetectedPeer"];
  else {
    uint64_t v35 = v32;
  }
  [v2 setObject:v35 forKeyedSubscript:@"NATTKeepAlive"];
  else {
    unint64_t v36 = v32;
  }
  [v2 setObject:v36 forKeyedSubscript:@"NATTKeepAliveOffload"];
  if ([a1 natTraversalPort])
  {
    objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedShort:", objc_msgSend(a1, "natTraversalPort"));
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    [v2 setObject:v37 forKeyedSubscript:@"NATTPort"];
  }

  if ([a1 natTraversalSrcPort])
  {
    objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedShort:", objc_msgSend(a1, "natTraversalSrcPort"));
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
    [v2 setObject:v38 forKeyedSubscript:@"NATTSourcePort"];
  }

  if ([a1 natKeepaliveIntervalSeconds])
  {
    objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedLongLong:", objc_msgSend(a1, "natKeepaliveIntervalSeconds"));
    unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
    [v2 setObject:v39 forKeyedSubscript:@"NATTKeepAliveInterval"];
  }

  if ([a1 natKeepaliveOffloadIntervalSeconds])
  {
    objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedLongLong:",  objc_msgSend(a1, "natKeepaliveOffloadIntervalSeconds"));
    unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    [v2 setObject:v40 forKeyedSubscript:@"NATTKeepAliveOffloadInterval"];
  }

  if ([a1 sequencePerTrafficClass])
  {
    else {
      unint64_t v41 = MEMORY[0x189604A80];
    }
    [v2 setObject:v41 forKeyedSubscript:@"sequencePerTrafficClass"];
  }

  return v2;
}

      uint64_t v72 = 0LL;
      BOOL v20 = v84;
      goto LABEL_50;
    }
  }

  uint64_t v37 = objc_alloc_init(MEMORY[0x189603FC8]);
  flowManager = self->_flowManager;
  if (flowManager) {
    objc_setProperty_atomic(flowManager, v36, v37, 32LL);
  }

  unint64_t v39 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x189603FC8]);
  userNexusInstances = self->_userNexusInstances;
  self->_userNexusInstances = v39;

  unint64_t v41 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x189603FC8]);
  userNexusClientCount = self->_userNexusClientCount;
  self->_userNexusClientCount = v41;

  int64_t v43 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x189603FC8]);
  userNexusClientFlows = self->_userNexusClientFlows;
  self->_userNexusClientFlows = v43;

  uint64_t v45 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x189603FC8]);
  kernelNexusClientFlows = self->_kernelNexusClientFlows;
  self->_kernelNexusClientFlows = v45;

  int64_t v47 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x189603FC8]);
  assertions = self->_assertions;
  self->_assertions = v47;

  uint64_t v49 = objc_alloc_init(&OBJC_CLASS___NENexusAgent);
  agent = self->_agent;
  self->_agent = v49;

  uint64_t v51 = self->_agent;
  if (!v51)
  {
    ne_log_obj();
    uint64_t v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uu = 0;
      uint64_t v80 = "[NENexusAgent init] failed";
LABEL_73:
      _os_log_fault_impl(&dword_1876B1000, v79, OS_LOG_TYPE_FAULT, v80, uu, 2u);
      goto LABEL_60;
    }

    goto LABEL_60;
  }

  -[NENexusAgent setActive:](v51, "setActive:", 0LL);
  [MEMORY[0x189607AB8] UUID];
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
  -[NENexusAgent setAgentUUID:](self->_agent, "setAgentUUID:", v52);

  -[NENexusAgent setAgentDescription:](self->_agent, "setAgentDescription:", v18);
  uint64_t v53 = self->_agent;
  if (v53 && (v53->_frameType = v22, (uint64_t v54 = self->_agent) != 0LL))
  {
    objc_storeWeak((id *)&v54->_delegate, self);
    BOOL v55 = self->_agent;
  }

  else
  {
    BOOL v55 = 0LL;
  }

  -[NENexusAgent setNexusProvider:](v55, "setNexusProvider:", a3 == 4);
  unint64_t v57 = (void *)[objc_alloc(MEMORY[0x189608E08]) initWithNetworkAgentClass:objc_opt_class()];
  unint64_t v58 = self->_agent;
  if (v58) {
    objc_setProperty_atomic(v58, v56, v57, 32LL);
  }

  uint64_t v60 = self->_agent;
  BOOL v20 = v84;
  if (!v60 || !objc_getProperty(v60, v59, 32LL, 1))
  {
    ne_log_obj();
    unint64_t v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uu = 0;
      unint64_t v78 = "[NWNetworkAgentRegistration initWithNetworkAgentClass] failed";
LABEL_64:
      objc_super v81 = uu;
LABEL_65:
      uint64_t v82 = v73;
      v83 = 2;
LABEL_66:
      _os_log_fault_impl(&dword_1876B1000, v82, OS_LOG_TYPE_FAULT, v78, v81, v83);
    }

          uint64_t v35 = 0LL;
LABEL_61:

          goto LABEL_62;
        }
}

  if (v37 == -1) {
    goto LABEL_63;
  }
  uint64_t v44 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v45 = *((void *)v18 + 61);
    *(_DWORD *)applier = 136315394;
    *(void *)&applier[4] = (char *)v18 + 265;
    *(_WORD *)&applier[12] = 2112;
    *(void *)&applier[14] = v45;
    _os_log_impl( &dword_1876B1000,  v44,  OS_LOG_TYPE_DEFAULT,  "Created a new NEVirtualInterface %s (%@)",  applier,  0x16u);
  }

  return v18;
}

  return v53;
}

LABEL_63:
  return a1;
}

          break;
      }
    }

    goto LABEL_5;
  }

  ne_log_obj();
  unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    uint64_t v30 = *((_DWORD *)v7 + 2);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v30;
    unint64_t v16 = "Received unexpected message of type %d from kernel content filter";
LABEL_41:
    unint64_t v19 = v14;
    BOOL v20 = 8;
LABEL_42:
    _os_log_error_impl(&dword_1876B1000, v19, OS_LOG_TYPE_ERROR, v16, buf, v20);
  }

          goto LABEL_100;
        }

  return v14;
}

  return v5;
}

LABEL_77:
LABEL_78:
    v102 = 0;
    goto LABEL_79;
  }

  [v9 pluginUpgradeInfo];
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();

  v100 = v12;
  if (!v29)
  {
    unint64_t v31 = (uint64_t)v10;
    goto LABEL_31;
  }

  [v9 pluginUpgradeInfo];
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v31 = [v30 objectForKeyedSubscript:@"PluginType"];

  [v9 pluginUpgradeInfo];
  unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
  [v32 objectForKeyedSubscript:@"HasAppProxy"];
  unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
  if ((isa_nsnumber(v33) & 1) == 0)
  {

    goto LABEL_30;
  }

  [v9 pluginUpgradeInfo];
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
  [v34 objectForKeyedSubscript:@"HasAppProxy"];
  uint64_t v35 = v31;
  unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
  v98 = [v36 BOOLValue];

  unint64_t v31 = v35;
  if ((v98 & 1) == 0)
  {
LABEL_30:
    [a1 appVPN];
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    [v37 setTunnelType:1];
  }

    goto LABEL_78;
  }

  unint64_t v15 = -[NEIKEv2Packet hasNotification:](v3, (const char *)0x4007);

  if ((v15 & 1) != 0) {
    goto LABEL_24;
  }
  ne_log_obj();
  unint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    unsigned __int16 v17 = (os_log_s *)[v3 copyShortDescription];
    *(_DWORD *)buf = 138412546;
    v210 = v6;
    v211 = 2112;
    v212 = (uint64_t)v17;
    _os_log_error_impl( &dword_1876B1000,  v8,  OS_LOG_TYPE_ERROR,  "%@ %@ Transport mode Child SA was not accepted",  buf,  0x16u);
    goto LABEL_78;
  }

    v130 = objc_getProperty(v4, v86, 88LL, 1);
    v131 = [v130 initialContactDisabled];

    if ((v131 & 1) != 0 || -[NEIKEv2Packet addNotification:data:](v9, 0x4000uLL, 0LL))
    {
      v133 = objc_getProperty(v4, v132, 88LL, 1);
      v134 = [v133 negotiateMOBIKE];

      if (!v134 || -[NEIKEv2Packet addNotification:data:](v9, 0x400CuLL, 0LL))
      {
        v268 = v5;
        v136 = -[NEIKEv2IKESA remoteAuthentication](v4, v135);
        if ([v136 method])
        {
          if ([v136 isSignature])
          {
            v139 = objc_getProperty(v4, v138, 88LL, 1);
            if (!v139 || (v140 = v139, v141 = [v139 remotePublicKeyRef], v140, !v141))
            {
              v142 = -[NEIKEv2IKESA copyRemoteCertificateAuthorityHashData](v4);
              if (v142)
              {
                v143 = objc_alloc_init(&OBJC_CLASS___NEIKEv2CertificateRequestPayload);
                if (!v143)
                {
                  ne_log_obj();
                  v267 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v267, OS_LOG_TYPE_FAULT))
                  {
                    buf = 136315138;
                    v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
                    _os_log_fault_impl( &dword_1876B1000,  v267,  OS_LOG_TYPE_FAULT,  "%s called with null certReq",  (uint8_t *)&buf,  0xCu);
                  }

                  goto LABEL_208;
                }

                v145 = v143;
                objc_setProperty_atomic(v143, v144, v142, 32LL);
                v145->_encoding = 4LL;
                v294 = v145;
                [MEMORY[0x189603F18] arrayWithObjects:&v294 count:1];
                v146 = (void *)objc_claimAutoreleasedReturnValue();
                objc_setProperty_atomic(v9, v147, v146, 120LL);
              }
            }
          }

          if ([v136 isSecurePassword])
          {
            v149 = -[NEIKEv2GSPM initWithIKESA:]((id *)objc_alloc(&OBJC_CLASS___NEIKEv2GSPM), v4);
            if (v149)
            {
              v150 = (NEIKEv2CertificatePayload *)v149;
              v151 = objc_alloc_init(&OBJC_CLASS___NEIKEv2GSPMPayload);
              objc_setProperty_atomic(v9, v152, v151, 144LL);

              v153 = v150->super._payloadData;
              v155 = objc_getProperty(v9, v154, 144LL, 1);
              -[NEIKEv2GSPMPayload setGspmData:]((uint64_t)v155, v153);

              objc_setProperty_atomic(v4, v156, v150, 456LL);
LABEL_92:

LABEL_102:
              v282 = 0u;
              v283 = 0u;
              v280 = 0u;
              v281 = 0u;
              v165 = objc_getProperty(v4, v157, 88LL, 1);
              [v165 customIKEAuthPrivateNotifies];
              v166 = (void *)objc_claimAutoreleasedReturnValue();

              v167 = [v166 countByEnumeratingWithState:&v280 objects:v292 count:16];
              if (v167)
              {
                v168 = v167;
                v169 = *(void *)v281;
                while (2)
                {
                  v170 = 0LL;
                  do
                  {
                    if (*(void *)v281 != v169) {
                      objc_enumerationMutation(v166);
                    }
                    v171 = *(void **)(*((void *)&v280 + 1) + 8 * v170);
                    v172 = objc_alloc_init(&OBJC_CLASS___NEIKEv2NotifyPayload);
                    v173 = [v171 notifyStatus];
                    if (v172)
                    {
                      v172->_notifyType = v173;
                      [v171 notifyData];
                      v174 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_setProperty_atomic(v172, v175, v174, 32LL);
                    }

                    else
                    {
                      [v171 notifyData];
                      v174 = (void *)objc_claimAutoreleasedReturnValue();
                    }

                    if (!-[NEIKEv2Packet addNotifyPayload:](self, v172))
                    {
                      ne_log_obj();
                      v222 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      size_t v4 = v269;
                      if (os_log_type_enabled(v222, OS_LOG_TYPE_FAULT))
                      {
                        LOWORD(buf) = 0;
                        _os_log_fault_impl( &dword_1876B1000,  v222,  OS_LOG_TYPE_FAULT,  "[packet addNotifyPayload:notifyPayload] failed",  (uint8_t *)&buf,  2u);
                      }

                      v129 = 0LL;
                      unint64_t v5 = v268;
                      goto LABEL_147;
                    }

                    ++v170;
                    size_t v4 = v269;
                  }

                  while (v168 != v170);
                  v176 = [v166 countByEnumeratingWithState:&v280 objects:v292 count:16];
                  v168 = v176;
                  if (v176) {
                    continue;
                  }
                  break;
                }
              }

              v278 = 0u;
              v279 = 0u;
              v276 = 0u;
              v277 = 0u;
              v178 = objc_getProperty(v4, v177, 88LL, 1);
              [v178 customIKEAuthVendorPayloads];
              v179 = (void *)objc_claimAutoreleasedReturnValue();

              v180 = [v179 countByEnumeratingWithState:&v276 objects:v291 count:16];
              unint64_t v9 = self;
              if (v180)
              {
                v181 = v180;
                v182 = *(void *)v277;
                do
                {
                  for (i = 0LL; i != v181; ++i)
                  {
                    if (*(void *)v277 != v182) {
                      objc_enumerationMutation(v179);
                    }
                    v184 = *(void **)(*((void *)&v276 + 1) + 8 * i);
                    v185 = objc_alloc_init(&OBJC_CLASS___NEIKEv2VendorIDPayload);
                    [v184 vendorData];
                    v187 = (void *)objc_claimAutoreleasedReturnValue();
                    if (v185) {
                      objc_setProperty_atomic(v185, v186, v187, 24LL);
                    }

                    objc_getProperty(v9, v188, 176LL, 1);
                    v189 = (void *)objc_claimAutoreleasedReturnValue();

                    if (v189)
                    {
                      objc_getProperty(v9, v190, 176LL, 1);
                      v191 = (void *)objc_claimAutoreleasedReturnValue();
                      [v191 arrayByAddingObject:v185];
                      v192 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_setProperty_atomic(self, v193, v192, 176LL);

                      unint64_t v9 = self;
                    }

                    else
                    {
                      v290 = v185;
                      [MEMORY[0x189603F18] arrayWithObjects:&v290 count:1];
                      v191 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_setProperty_atomic(v9, v194, v191, 176LL);
                    }
                  }

                  v181 = [v179 countByEnumeratingWithState:&v276 objects:v291 count:16];
                }

                while (v181);
              }

              v274 = 0u;
              v275 = 0u;
              v272 = 0u;
              v273 = 0u;
              v196 = objc_getProperty(v269, v195, 88LL, 1);
              [v196 customIKEAuthPayloads];
              v197 = (void *)objc_claimAutoreleasedReturnValue();

              v198 = [v197 countByEnumeratingWithState:&v272 objects:v289 count:16];
              if (v198)
              {
                v199 = v198;
                v200 = *(void *)v273;
                do
                {
                  v201 = 0LL;
                  do
                  {
                    if (*(void *)v273 != v200) {
                      objc_enumerationMutation(v197);
                    }
                    v202 = *(void **)(*((void *)&v272 + 1) + 8 * v201);
                    v203 = objc_alloc_init(&OBJC_CLASS___NEIKEv2CustomPayload);
                    v204 = [v202 customType];
                    if (v203)
                    {
                      v203->_customType = v204;
                      [v202 customData];
                      v205 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_setProperty_atomic(v203, v206, v205, 32LL);
                    }

                    else
                    {
                      [v202 customData];
                      v205 = (void *)objc_claimAutoreleasedReturnValue();
                    }

                    objc_getProperty(v9, v207, 56LL, 1);
                    v208 = (void *)objc_claimAutoreleasedReturnValue();

                    if (v208)
                    {
                      objc_getProperty(v9, v209, 56LL, 1);
                      v210 = (void *)objc_claimAutoreleasedReturnValue();
                      [v210 arrayByAddingObject:v203];
                      v211 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_setProperty_atomic(self, v212, v211, 56LL);

                      unint64_t v9 = self;
                    }

                    else
                    {
                      v288 = v203;
                      [MEMORY[0x189603F18] arrayWithObjects:&v288 count:1];
                      v210 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_setProperty_atomic(v9, v213, v210, 56LL);
                    }

                    ++v201;
                  }

                  while (v199 != v201);
                  v214 = [v197 countByEnumeratingWithState:&v272 objects:v289 count:16];
                  v199 = v214;
                }

                while (v214);
              }

              size_t v4 = v269;
              v216 = objc_getProperty(v269, v215, 88LL, 1);
              [v216 pduSessionID];
              v217 = (void *)objc_claimAutoreleasedReturnValue();

              if (!v217) {
                goto LABEL_143;
              }
              v219 = objc_getProperty(v269, v218, 88LL, 1);
              [v219 pduSessionID];
              v220 = (void *)objc_claimAutoreleasedReturnValue();
              v221 = [v220 unsignedCharValue];

              LOBYTE(v284) = v221;
              v271 = 1;
              v150 = (NEIKEv2CertificatePayload *)objc_alloc_init(MEMORY[0x189603FB8]);
              -[NEIKEv2CertificatePayload appendBytes:length:](v150, "appendBytes:length:", &v271, 1LL);
              -[NEIKEv2CertificatePayload appendBytes:length:](v150, "appendBytes:length:", &v284, 1LL);
              if (-[NEIKEv2Packet addNotification:data:](v9, 0xC747uLL, v150))
              {

LABEL_143:
                v129 = v9;
LABEL_201:
                unint64_t v5 = v268;
LABEL_202:

                goto LABEL_154;
              }

              ne_log_obj();
              v236 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v236, OS_LOG_TYPE_FAULT)) {
                goto LABEL_199;
              }
              LOWORD(buf) = 0;
              v257 = "[packet addNotification:NEIKEv2NotifyTypeMOBIKESupported] failed";
              v258 = v236;
              v259 = 2;
LABEL_179:
              _os_log_fault_impl(&dword_1876B1000, v258, OS_LOG_TYPE_FAULT, v257, (uint8_t *)&buf, v259);
LABEL_199:

              goto LABEL_200;
            }

            ne_log_obj();
            v142 = (void *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled((os_log_t)v142, OS_LOG_TYPE_FAULT))
            {
LABEL_208:

              v129 = 0LL;
              unint64_t v5 = v268;
LABEL_147:
              unint64_t v9 = self;
              goto LABEL_202;
            }

            LOWORD(buf) = 0;
            v264 = "[NEIKEv2GSPM initWithIKESA:] failed";
            v265 = (os_log_s *)v142;
            v266 = 2;
LABEL_215:
            _os_log_fault_impl(&dword_1876B1000, v265, OS_LOG_TYPE_FAULT, v264, (uint8_t *)&buf, v266);
            goto LABEL_208;
          }

          v163 = objc_getProperty(v4, v148, 96LL, 1);
          v164 = -[NEIKEv2IKESAProposal hasEAPMethods](v163);

          if ((v164 & 1) != 0) {
            goto LABEL_102;
          }
          v226 = -[NEIKEv2IKESA copyAuthenticationPayloadUsingPrimeKey:](v4, 0LL);
          objc_setProperty_atomic(v9, v227, v226, 128LL);

          objc_getProperty(v9, v228, 128LL, 1);
          v229 = (void *)objc_claimAutoreleasedReturnValue();
          v230 = -[NEIKEv2Payload isValid]((uint64_t)v229);

          if ((v230 & 1) != 0)
          {
            if (((_BYTE)v4[3] & 1) == 0) {
              goto LABEL_168;
            }
            v232 = objc_getProperty(v4, v231, 88LL, 1);
            v233 = [v232 ppkIDType];

            LOBYTE(v284) = v233;
            if (v233)
            {
              v235 = objc_getProperty(v4, v234, 88LL, 1);
              [v235 ppkID];
              v150 = (NEIKEv2CertificatePayload *)objc_claimAutoreleasedReturnValue();

              if (v284 != 2 || v150)
              {
                v236 = (os_log_s *)objc_msgSend( objc_alloc(MEMORY[0x189603FB8]),  "initWithCapacity:",  -[NEIKEv2CertificatePayload length](v150, "length") + 1);
                -[os_log_s appendBytes:length:](v236, "appendBytes:length:", &v284, 1LL);
                -[os_log_s appendData:](v236, "appendData:", v150);
                if (!-[NEIKEv2Packet addNotification:data:](v9, 0x4034uLL, v236))
                {
                  ne_log_obj();
                  v240 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v240, OS_LOG_TYPE_FAULT))
                  {
                    LOWORD(buf) = 0;
                    _os_log_fault_impl( &dword_1876B1000,  v240,  OS_LOG_TYPE_FAULT,  "[packet addNotification:NEIKEv2NotifyTypePPKIdentity] failed",  (uint8_t *)&buf,  2u);
                  }

                  goto LABEL_198;
                }

                v238 = objc_getProperty(v4, v237, 88LL, 1);
                v239 = [v238 ppkMandatory];

                if ((v239 & 1) != 0)
                {
LABEL_167:

                  size_t v4 = v269;
LABEL_168:
                  -[NEIKEv2IKESA authenticationProtocol](v4, v231);
                  v150 = (NEIKEv2CertificatePayload *)objc_claimAutoreleasedReturnValue();
                  if (-[NEIKEv2CertificatePayload isSignature](v150, "isSignature"))
                  {
                    v245 = objc_getProperty(v4, v244, 88LL, 1);
                    if (v245)
                    {
                      v246 = v245;
                      v247 = [v245 localPrivateKeyRef];

                      if (v247) {
                        goto LABEL_102;
                      }
                    }

                    else
                    {
                    }

                    v150 = objc_alloc_init(&OBJC_CLASS___NEIKEv2CertificatePayload);
                    v249 = -[NEIKEv2IKESA copyLocalCertificateData](v4, v248);
                    v251 = v249;
                    if (v150)
                    {
                      objc_setProperty_atomic(v150, v250, v249, 32LL);

                      v150->_encoding = 4LL;
                      v253 = objc_getProperty(v150, v252, 32LL, 1);
                    }

                    else
                    {

                      v253 = 0LL;
                    }

                    v254 = v253;

                    if (!v254)
                    {
                      ne_log_obj();
                      v236 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v236, OS_LOG_TYPE_FAULT)) {
                        goto LABEL_199;
                      }
                      buf = 136315138;
                      v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
                      v257 = "%s called with null cert.certificateData";
                      v258 = v236;
                      v259 = 12;
                      goto LABEL_179;
                    }

                    v293 = v150;
                    [MEMORY[0x189603F18] arrayWithObjects:&v293 count:1];
                    v255 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_setProperty_atomic(v9, v256, v255, 112LL);
                  }

                  goto LABEL_92;
                }

                v240 = (os_log_s *)-[NEIKEv2IKESA copyAuthenticationPayloadUsingPrimeKey:](v269, (const char *)1);
                if ((-[NEIKEv2Payload isValid]((uint64_t)v240) & 1) != 0)
                {
                  if (v240) {
                    v241 = (void *)*((void *)v240 + 4);
                  }
                  else {
                    v241 = 0LL;
                  }
                  v242 = v241;
                  v243 = -[NEIKEv2Packet addNotification:data:](v9, 0x4035uLL, v242);

                  if (v243)
                  {

                    unint64_t v9 = self;
                    goto LABEL_167;
                  }

                  ne_log_obj();
                  v260 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (!os_log_type_enabled(v260, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_197;
                  }
                  LOWORD(buf) = 0;
                  v261 = "[packet addNotification:NEIKEv2NotifyTypeNoPPKAuth] failed";
                  v262 = v260;
                  v263 = 2;
                }

                else
                {
                  ne_log_obj();
                  v260 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (!os_log_type_enabled(v260, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_197;
                  }
                  buf = 136315138;
                  v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
                  v261 = "%s called with null primeAuth.isValid";
                  v262 = v260;
                  v263 = 12;
                }

                _os_log_fault_impl(&dword_1876B1000, v262, OS_LOG_TYPE_FAULT, v261, (uint8_t *)&buf, v263);
LABEL_197:
                unint64_t v9 = self;

                size_t v4 = v269;
LABEL_198:

                goto LABEL_199;
              }

              ne_log_obj();
              v142 = (void *)objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled((os_log_t)v142, OS_LOG_TYPE_FAULT)) {
                goto LABEL_208;
              }
              buf = 136315138;
              v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
              v264 = "%s called with null ppkID";
            }

            else
            {
              ne_log_obj();
              v142 = (void *)objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled((os_log_t)v142, OS_LOG_TYPE_FAULT)) {
                goto LABEL_208;
              }
              buf = 136315138;
              v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
              v264 = "%s called with null ppkIDType";
            }

            v265 = (os_log_s *)v142;
            v266 = 12;
            goto LABEL_215;
          }

          ne_log_obj();
          v150 = (NEIKEv2CertificatePayload *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled((os_log_t)v150, OS_LOG_TYPE_FAULT))
          {
            buf = 136315138;
            v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
            v160 = "%s called with null packet.auth.isValid";
            v161 = (os_log_s *)v150;
            v162 = 12;
            goto LABEL_182;
          }
        }

        else
        {
          v158 = objc_getProperty(v4, v137, 96LL, 1);
          v159 = -[NEIKEv2IKESAProposal hasEAPMethods](v158);

          if (!v159 || -[NEIKEv2Packet addNotification:data:](v9, 0x4021uLL, 0LL)) {
            goto LABEL_102;
          }
          ne_log_obj();
          v150 = (NEIKEv2CertificatePayload *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled((os_log_t)v150, OS_LOG_TYPE_FAULT))
          {
            LOWORD(buf) = 0;
            v160 = "[packet addNotification:NEIKEv2NotifyTypeEAPOnlyAuthentication] failed";
            v161 = (os_log_s *)v150;
            v162 = 2;
LABEL_182:
            _os_log_fault_impl(&dword_1876B1000, v161, OS_LOG_TYPE_FAULT, v160, (uint8_t *)&buf, v162);
          }
        }

LABEL_95:
          v102 = 0;
          unint64_t v12 = v101;
          goto LABEL_79;
        }

        uint64_t v64 = 1LL;
        goto LABEL_52;
      }

      unint64_t v56 = v14;
    }

    [v56 objectForKeyedSubscript:@"PayloadCertificateUUID"];
    uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
    if (v45) {
      Property = objc_getProperty(v45, v58, 88LL, 1);
    }
    else {
      Property = 0LL;
    }
    uint64_t v61 = Property;
    [v9 addCertificatePending:v59 certificateTag:@"_PayloadCertificateRef" accessGroup:v61];
    goto LABEL_47;
  }

  ne_log_obj();
  v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  unint64_t v12 = v100;
  if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    v104 = @"com.apple.vpn.managed.applayer";
    _os_log_error_impl( &dword_1876B1000,  v89,  OS_LOG_TYPE_ERROR,  "configurePluginWithPayload: failed to allocate for %@ protocol",  buf,  0xCu);
  }

  v102 = 0;
  unint64_t v10 = (id)v31;
LABEL_79:

  return v102;
}

id setLocalCertificate(void *a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  unint64_t v2 = v1;
  if (!v1)
  {
LABEL_7:
    id v3 = 0LL;
    goto LABEL_8;
  }

  if (!isa_nsdata(v1))
  {
    ne_log_obj();
    size_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v7 = 138412290;
      id v8 = (id)objc_opt_class();
      id v6 = v8;
      _os_log_error_impl( &dword_1876B1000,  v4,  OS_LOG_TYPE_ERROR,  "setLocalCertificate: unsupported data type %@.",  (uint8_t *)&v7,  0xCu);
    }

    goto LABEL_7;
  }

  id v3 = v2;
LABEL_8:

  return v3;
}

LABEL_25:
          goto LABEL_26;
        }

        ne_log_obj();
        unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_INFO))
        {
          uint64_t v21 = 138412290;
          unint64_t v22 = @"VPN";
          _os_log_impl( &dword_1876B1000,  (os_log_t)v17,  OS_LOG_TYPE_INFO,  "configurePPPWithVPNOptions: invalid %@ dictionary",  (uint8_t *)&v21,  0xCu);
        }
      }

      else
      {
        ne_log_obj();
        unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v21 = 138412290;
          unint64_t v22 = @"VPN";
          _os_log_debug_impl( &dword_1876B1000,  (os_log_t)v17,  OS_LOG_TYPE_DEBUG,  "configurePPPWithVPNOptions: nothing to do, empty %@ dictionary",  (uint8_t *)&v21,  0xCu);
        }
      }
    }

    else
    {
      ne_log_obj();
      unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v21) = 0;
        _os_log_error_impl( &dword_1876B1000,  (os_log_t)v17,  OS_LOG_TYPE_ERROR,  "configurePPPWithVPNOptions: L2TP not initialized",  (uint8_t *)&v21,  2u);
      }
    }

    unint64_t v10 = 0LL;
    goto LABEL_25;
  }

  unint64_t v10 = 0LL;
LABEL_5:
  unint64_t v11 = 1LL;
LABEL_26:

  return v11;
}

  __int16 v18 = *(void **)(v122 + 32);
  if (!v18) {
    goto LABEL_84;
  }
  objc_setProperty_atomic(v18, v5, 0LL, 56LL);
  unint64_t v19 = *(void *)(v122 + 32);
  if (!v19 || (*(_BYTE *)(v19 + 21) & 1) != 0) {
    goto LABEL_84;
  }
  self = *(id *)(v122 + 32);
  [MEMORY[0x1896078A8] defaultManager];
  BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v21 = [v20 isReadableFileAtPath:@"/Library/Preferences/com.apple.networkextension.plist"];

  if (v21)
  {
    v143 = 0LL;
    [MEMORY[0x189603F48] dataWithContentsOfFile:@"/Library/Preferences/com.apple.networkextension.plist" options:0 error:&v143];
    obj = (id)objc_claimAutoreleasedReturnValue();
    v128 = v143;
    *((_BYTE *)self + 20) = 1;
    if (obj)
    {
      unint64_t v22 = (void *)[objc_alloc(MEMORY[0x189607908]) initForReadingFromData:obj error:0];
      [v22 setClass:objc_opt_class() forClassName:@"NEVPNAppRule"];
      [v22 setClass:objc_opt_class() forClassName:@"NEVPNProtocolPlugin"];
      v123 = [v22 decodeInt64ForKey:@"Generation"];
      v125 = [v22 decodeInt64ForKey:@"Version"];
      uint64_t v23 = (void *)MEMORY[0x189604010];
      unint64_t v24 = objc_opt_class();
      BOOL v25 = objc_opt_class();
      unint64_t v26 = objc_opt_class();
      __int16 v27 = objc_opt_class();
      objc_msgSend(v23, "setWithObjects:", v24, v25, v26, v27, objc_opt_class(), 0);
      unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
      [v22 decodeObjectOfClasses:v28 forKey:@"Index"];
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v29 || v125)
      {
        uint64_t v46 = v29;
LABEL_73:
        if (v125)
        {
          [v22 decodeObjectOfClass:objc_opt_class() forKey:@"SCPreferencesSignature2"];
          uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
        }

        else
        {
          uint64_t v50 = (void *)MEMORY[0x189604010];
          uint64_t v51 = objc_opt_class();
          uint64_t v52 = objc_opt_class();
          objc_msgSend(v50, "setWithObjects:", v51, v52, objc_opt_class(), 0);
          uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
          [v22 decodeObjectOfClasses:v53 forKey:@"SCPreferencesSignature"];
          uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();

          memset(v138, 0, sizeof(v138));
          BOOL v55 = v54;
          if ([v55 countByEnumeratingWithState:v138 objects:state64 count:16])
          {
            [v55 objectForKeyedSubscript:**((void **)&v138[0] + 1)];
            uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
          }

          else
          {
            uint64_t v45 = 0LL;
          }
        }

        goto LABEL_80;
      }

      v141 = 0u;
      v142 = 0u;
      v139 = 0u;
      v140 = 0u;
      uint64_t v30 = v29;
      unint64_t v31 = [v30 countByEnumeratingWithState:&v139 objects:buf count:16];
      if (v31)
      {
        unint64_t v32 = 0LL;
        unint64_t v33 = 0LL;
        uint64_t v34 = *(void *)v140;
        do
        {
          for (i = 0LL; i != v31; ++i)
          {
            if (*(void *)v140 != v34) {
              objc_enumerationMutation(v30);
            }
            unint64_t v36 = *(void *)(*((void *)&v139 + 1) + 8 * i);
            if (!v32)
            {
              [v30 objectForKeyedSubscript:*(void *)(*((void *)&v139 + 1) + 8 * i)];
              unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
            }

            [v32 allKeys];
            uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
            if (!v33) {
              unint64_t v33 = objc_alloc_init(MEMORY[0x189603FC8]);
            }
            [v33 setObject:v37 forKeyedSubscript:v36];
          }

          unint64_t v31 = [v30 countByEnumeratingWithState:&v139 objects:buf count:16];
        }

        while (v31);

        if (!v32 || !v33)
        {
          uint64_t v38 = (uint64_t)v30;
          goto LABEL_72;
        }

        v148[0] = @"ConfigurationProperties";
        v148[1] = @"UserMap";
        v149[0] = v32;
        v149[1] = v33;
        uint64_t v38 = [MEMORY[0x189603F68] dictionaryWithObjects:v149 forKeys:v148 count:2];
      }

      else
      {
        unint64_t v33 = 0LL;
        unint64_t v32 = 0LL;
        uint64_t v38 = (uint64_t)v30;
      }

LABEL_72:
      uint64_t v46 = (void *)v38;
      goto LABEL_73;
    }

    ne_log_obj();
    int64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      v151 = (const char *)self;
      v152 = 2112;
      *(void *)v153 = @"/Library/Preferences/com.apple.networkextension.plist";
      _os_log_error_impl(&dword_1876B1000, v43, OS_LOG_TYPE_ERROR, "%@ Failed to read data from %@", buf, 0x16u);
    }

    uint64_t v44 = -[NEConfigurationManager errorWithCode:specifics:]((uint64_t)self, 1LL, 0LL);

    unint64_t v22 = 0LL;
    v128 = (id)v44;

LABEL_57:
    uint64_t v45 = 0LL;
    uint64_t v46 = 0LL;
    goto LABEL_81;
  }

  unint64_t v39 = geteuid() == 0;
  [MEMORY[0x1896078A8] defaultManager];
  unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v41 = [v40 fileExistsAtPath:@"/Library/Preferences/com.apple.networkextension.plist"];

  if (!v39)
  {
    if ((v41 & 1) != 0) {
      -[NEConfigurationManager errorWithCode:specifics:]((uint64_t)self, 10LL, 0LL);
    }
    else {
      -[NEConfigurationManager errorWithCode:specifics:]((uint64_t)self, 18LL, 0LL);
    }
    v128 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_56;
  }

  if (v41)
  {
    -[NEConfigurationManager errorWithCode:specifics:]((uint64_t)self, 19LL, 0LL);
    v128 = (id)objc_claimAutoreleasedReturnValue();
LABEL_56:
    unint64_t v22 = 0LL;
    goto LABEL_57;
  }

  unint64_t v22 = 0LL;
  v123 = 0LL;
  uint64_t v45 = 0LL;
  uint64_t v46 = 0LL;
  v128 = 0LL;
LABEL_80:
  objc_setProperty_atomic(self, v42, v22, 96LL);
  *((void *)self + 13) = v123;
  objc_setProperty_atomic(self, v56, v45, 120LL);
LABEL_81:
  unint64_t v57 = v128;
  newValue = v46;

  uint64_t v59 = (char *)v57;
  uint64_t v60 = self;
  if ((*((_BYTE *)self + 20) & 1) != 0)
  {
    v120 = v59;
    if (v59)
    {
      ne_log_obj();
      uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v151 = v120;
        _os_log_error_impl(&dword_1876B1000, v65, OS_LOG_TYPE_ERROR, "Failed to read the index: %@", buf, 0xCu);
      }

      uint64_t v60 = self;
    }

    if (!newValue)
    {
      ne_log_obj();
      v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v151 = (const char *)self;
        _os_log_impl(&dword_1876B1000, v113, OS_LOG_TYPE_DEFAULT, "%@ No configurations exist", buf, 0xCu);
      }

      objc_setProperty_atomic(self, v114, 0LL, 96LL);
      goto LABEL_135;
    }

    objc_setProperty_atomic(v60, v58, newValue, 56LL);
    [self userUUID];
    uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v67 = v66 == 0LL;

    if (!v67)
    {
      v145 = @"user-uuid";
      [self userUUID];
      uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();
      v146 = v69;
      [MEMORY[0x189603F68] dictionaryWithObjects:&v146 forKeys:&v145 count:1];
      size_t v70 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEConfigurationManager filterIndexWithFilter:](self, v70);
      unint64_t v71 = (void *)objc_claimAutoreleasedReturnValue();
      objc_setProperty_atomic(self, v72, v71, 56LL);
    }

    -[NEConfigurationManager notifyChanges](self, v68);
    if (objc_getProperty(self, v73, 80LL, 1))
    {
      objc_msgSend(objc_getProperty(self, v74, 80, 1), "allKeys");
      unint64_t v75 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEConfigurationManager clearLoadedConfigurationsWithIDs:](self, v75);
    }

    if (objc_getProperty(self, v74, 56LL, 1))
    {
      v136 = 0u;
      v137 = 0u;
      v134 = 0u;
      v135 = 0u;
      objc_msgSend(objc_getProperty(self, v76, 56, 1), "objectForKeyedSubscript:", @"ConfigurationProperties");
      obja = (id)objc_claimAutoreleasedReturnValue();
      unint64_t v77 = [obja countByEnumeratingWithState:&v134 objects:v144 count:16];
      if (v77)
      {
        v124 = 0LL;
        unint64_t v78 = 0LL;
        v129 = *(id *)v135;
        while (1)
        {
          for (j = 0LL; j != v77; ++j)
          {
            if (*(id *)v135 != v129) {
              objc_enumerationMutation(obja);
            }
            uint64_t v80 = *(char **)(*((void *)&v134 + 1) + 8 * j);
            ne_log_obj();
            objc_super v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v81, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 138412290;
              v151 = v80;
              _os_log_impl(&dword_1876B1000, v81, OS_LOG_TYPE_INFO, "Decoding %@", buf, 0xCu);
            }

            uint64_t v82 = v80;
            uint64_t v84 = objc_getProperty(self, v83, 96LL, 1);
            uint64_t v85 = objc_opt_class();
            [v82 UUIDString];
            v86 = (void *)objc_claimAutoreleasedReturnValue();
            [v84 decodeObjectOfClass:v85 forKey:v86];
            v87 = (void *)objc_claimAutoreleasedReturnValue();

            if (v87)
            {
              [v87 VPN];
              unint64_t v88 = (void *)objc_claimAutoreleasedReturnValue();
              [v88 protocol];
              v89 = (void *)objc_claimAutoreleasedReturnValue();
              CFErrorRef v90 = [v89 type] == 3;

              if (!v90)
              {
                -[NEConfigurationManager didLoadConfiguration:](self, v87);
                [v87 applicationIdentifier];
                unint64_t v91 = (void *)objc_claimAutoreleasedReturnValue();
                v92 = v91 == 0LL;

                if (!v92)
                {
                  objc_msgSend( objc_getProperty(self, v93, 56, 1),  "objectForKeyedSubscript:",  @"ConfigurationProperties");
                  v94 = (void *)objc_claimAutoreleasedReturnValue();
                  [v94 objectForKeyedSubscript:v82];
                  v95 = (void *)objc_claimAutoreleasedReturnValue();

                  [v95 objectForKeyedSubscript:@"ApplicationID"];
                  v96 = (void *)objc_claimAutoreleasedReturnValue();
                  [v87 applicationIdentifier];
                  v97 = (void *)objc_claimAutoreleasedReturnValue();
                  [v95 objectForKeyedSubscript:@"ApplicationID"];
                  v98 = (void *)objc_claimAutoreleasedReturnValue();
                  v99 = [v97 isEqualToString:v98];

                  if ((v99 & 1) == 0)
                  {
                    v96 = (void *)[v95 mutableCopy];
                    [v87 applicationIdentifier];
                    v100 = (void *)objc_claimAutoreleasedReturnValue();
                    [v96 setObject:v100 forKeyedSubscript:@"ApplicationID"];

                    if (!v124)
                    {
                      objc_msgSend( objc_getProperty(self, v101, 56, 1),  "objectForKeyedSubscript:",  @"ConfigurationProperties");
                      v102 = (void *)objc_claimAutoreleasedReturnValue();
                      v124 = (void *)[v102 mutableCopy];
                    }

                    [MEMORY[0x189603F68] dictionaryWithDictionary:v96];
                    v103 = (void *)objc_claimAutoreleasedReturnValue();
                    [v124 setObject:v103 forKeyedSubscript:v82];

LABEL_110:
                  }
                }
              }
            }

            else
            {
              ne_log_obj();
              v104 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v104, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 138412290;
                v151 = v82;
                _os_log_fault_impl(&dword_1876B1000, v104, OS_LOG_TYPE_FAULT, "Failed to decode %@", buf, 0xCu);
              }

              v105 = v78;
              if (!v78) {
                v105 = objc_alloc_init(MEMORY[0x189603FA8]);
              }
              unint64_t v78 = v105;
              [v105 addObject:v82];
              v87 = 0LL;
            }
          }

          unint64_t v77 = [obja countByEnumeratingWithState:&v134 objects:v144 count:16];
          if (!v77)
          {

            if (v124)
            {
              v107 = (void *)objc_msgSend(objc_getProperty(self, v106, 56, 1), "mutableCopy");
              [MEMORY[0x189603F68] dictionaryWithDictionary:v124];
              v108 = (void *)objc_claimAutoreleasedReturnValue();
              [v107 setObject:v108 forKeyedSubscript:@"ConfigurationProperties"];

              [MEMORY[0x189603F68] dictionaryWithDictionary:v107];
              v109 = (void *)objc_claimAutoreleasedReturnValue();
              objc_setProperty_atomic(self, v110, v109, 56LL);
            }

            v111 = self;
            if (v78)
            {
              obja = (id)[self copyCurrentIndexWithConfigurationIDsExpunged:v78];
              objc_setProperty_atomic(self, v112, obja, 56LL);
              goto LABEL_127;
            }

            goto LABEL_128;
          }
        }
      }

      v124 = 0LL;
      unint64_t v78 = 0LL;
LABEL_127:

      v111 = self;
LABEL_128:
      objc_msgSend(objc_getProperty(v111, v106, 56, 1), "objectForKeyedSubscript:", @"AppGroupMap");
      v115 = (void *)objc_claimAutoreleasedReturnValue();
      os_unfair_lock_lock((os_unfair_lock_t)self + 4);
      if (v115) {
        v116 = (id)[objc_alloc(MEMORY[0x189603FC8]) initWithDictionary:v115];
      }
      else {
        v116 = objc_alloc_init(MEMORY[0x189603FC8]);
      }
      v117 = v116;
      -[NEConfigurationManager setAppGroupMap:]((uint64_t)self, v116);

      [self setAppGroupsChanged:0];
      os_unfair_lock_unlock((os_unfair_lock_t)self + 4);
    }

    objc_setProperty_atomic(self, v76, 0LL, 96LL);
    ne_log_obj();
    v118 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1876B1000, v118, OS_LOG_TYPE_DEFAULT, "Reload from disk complete", buf, 2u);
    }

    goto LABEL_135;
  }

  uint64_t v61 = v59;

  uint64_t v62 = *(void *)(v122 + 32);
  if (!v62 || (*(_BYTE *)(v62 + 23) & 1) == 0)
  {
LABEL_84:
    uint64_t v63 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_int64(v63, "config-operation", 1LL);
    v131[0] = MEMORY[0x1895F87A8];
    v131[1] = 3221225472LL;
    v131[2] = __63__NEConfigurationManager_getCurrentIndexWithCompletionHandler___block_invoke_88;
    v131[3] = &unk_18A08C790;
    uint64_t v64 = *(void **)(v122 + 40);
    v132 = *(void **)(v122 + 32);
    v133 = v64;
    -[NEConfigurationManager sendRequest:responseHandler:](v132, v63, v131);

    return;
  }

  if (v62)
  {
    unint64_t v33 = 0LL;
    uint64_t v34 = 0;
    while (1)
    {
      uint64_t v35 = -[NEDNSResourceRecord initFromByteParser:](objc_alloc(&OBJC_CLASS___NEDNSResourceRecord), v9);
      if (!v35) {
        break;
      }
      unint64_t v36 = v35;
      if (!v33) {
        unint64_t v33 = (void *)[objc_alloc(MEMORY[0x189603FA8]) initWithCapacity:v62];
      }
      [v33 addObject:v36];

      if (++v34 >= v62) {
        goto LABEL_60;
      }
    }

    ne_log_obj();
    uint64_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      uint64_t v66 = v34;
      _os_log_error_impl(&dword_1876B1000, v50, OS_LOG_TYPE_ERROR, "Failed to parse authority %u", buf, 8u);
    }

LABEL_77:
    uint64_t v37 = 0LL;
    goto LABEL_33;
  }

  unint64_t v33 = 0LL;
LABEL_60:
  if (v61)
  {
    uint64_t v37 = 0LL;
    uint64_t v46 = 0;
    while (1)
    {
      int64_t v47 = -[NEDNSResourceRecord initFromByteParser:](objc_alloc(&OBJC_CLASS___NEDNSResourceRecord), v9);
      if (!v47) {
        break;
      }
      uint64_t v48 = v47;
      if (!v37) {
        uint64_t v37 = (void *)[objc_alloc(MEMORY[0x189603FA8]) initWithCapacity:v61];
      }
      [v37 addObject:v48];

      if (++v46 >= v61) {
        goto LABEL_79;
      }
    }

    ne_log_obj();
    uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      uint64_t v66 = v46;
      _os_log_error_impl(&dword_1876B1000, v59, OS_LOG_TYPE_ERROR, "Failed to parse additional record %u", buf, 8u);
    }

    goto LABEL_33;
  }

  uint64_t v37 = 0LL;
LABEL_79:
  uint64_t v51 = [objc_alloc(MEMORY[0x189603F18]) initWithArray:v19];
  queries = v6->_queries;
  v6->_queries = (NSArray *)v51;

  uint64_t v53 = [objc_alloc(MEMORY[0x189603F18]) initWithArray:v29];
  answers = v6->_answers;
  v6->_answers = (NSArray *)v53;

  BOOL v55 = [objc_alloc(MEMORY[0x189603F18]) initWithArray:v33];
  authorities = v6->_authorities;
  v6->_authorities = (NSArray *)v55;

  unint64_t v57 = [objc_alloc(MEMORY[0x189603F18]) initWithArray:v37];
  additionalRecords = v6->_additionalRecords;
  v6->_additionalRecords = (NSArray *)v57;

  if (!v64) {
    goto LABEL_49;
  }
  uint64_t v38 = v6;
LABEL_50:

  return v38;
}

  return v9;
}

LABEL_26:
    unint64_t v19 = 0LL;
    goto LABEL_10;
  }

  -[os_log_s mutableBytes](v15, "mutableBytes");
  unsigned __int16 v17 = ccgcm_update();
  if (v17)
  {
    __int16 v27 = v17;
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67109120;
      unint64_t v31 = v27;
      unint64_t v26 = "ccgcm_update failed: %d";
      goto LABEL_28;
    }

    goto LABEL_25;
  }

  __int16 v18 = ccgcm_finalize();
  if (v18)
  {
    unint64_t v28 = v18;
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
      goto LABEL_25;
    }
    *(_DWORD *)buf = 67109120;
    unint64_t v31 = v28;
    unint64_t v26 = "ccgcm_finalize failed: %d";
LABEL_28:
    _os_log_fault_impl(&dword_1876B1000, v25, OS_LOG_TYPE_FAULT, v26, buf, 8u);
    goto LABEL_25;
  }

  unint64_t v19 = v15;
LABEL_10:

LABEL_11:
  return v19;
}

                goto LABEL_26;
              }

  uint64_t v76 = 0LL;
LABEL_65:

  return v76;
}

  if (self)
  {
    if (!necp_session_action())
    {
      self->_internalPriority = v5;
      self->_convertToLegacyPriority = v7 < 0xA;
      return;
    }
  }

  else if (!necp_session_action())
  {
    return;
  }

  uint64_t v9 = *__error();
  if (strerror_r(v9, __strerrbuf, 0x80uLL)) {
    __strerrbuf[0] = 0;
  }
  ne_log_obj();
  unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109378;
    unint64_t v12 = v9;
    unsigned __int16 v13 = 2080;
    unint64_t v14 = __strerrbuf;
    _os_log_fault_impl(&dword_1876B1000, v10, OS_LOG_TYPE_FAULT, "Failed to set priority: [%d] %s", buf, 0x12u);
  }
}

  unint64_t v26 = *(_DWORD *)(a1 + 64);
  switch(v26)
  {
    case 1:
      __int16 v27 = *(void **)(a1 + 40);
      unint64_t v28 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v157 = (void *)v159[5];
      [v27 createConfigurationWithParameters:v28 errorStr:&v157];
      uint64_t v30 = v157;
      goto LABEL_64;
    case 2:
      uint64_t v37 = *(void **)(a1 + 40);
      uint64_t v38 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v152 = (void *)v159[5];
      [v37 setProtocolWithParameters:v38 errorStr:&v152];
      uint64_t v30 = v152;
      goto LABEL_64;
    case 3:
      unint64_t v39 = *(void **)(a1 + 40);
      unint64_t v40 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v151 = (void *)v159[5];
      [v39 setFilterPluginWithParameters:v40 errorStr:&v151];
      uint64_t v30 = v151;
      goto LABEL_64;
    case 4:
      unint64_t v41 = *(void **)(a1 + 40);
      unint64_t v42 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v150 = (void *)v159[5];
      [v41 unsetFilterPluginParameters:v42 errorStr:&v150];
      uint64_t v30 = v150;
      goto LABEL_64;
    case 5:
      int64_t v43 = *(void **)(a1 + 40);
      uint64_t v44 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v149 = (void *)v159[5];
      [v43 setDNSProxyWithParameters:v44 errorStr:&v149];
      uint64_t v30 = v149;
      goto LABEL_64;
    case 6:
      uint64_t v45 = *(void **)(a1 + 40);
      uint64_t v46 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v148 = (void *)v159[5];
      [v45 unsetDNSProxyWithParameters:v46 errorStr:&v148];
      uint64_t v30 = v148;
      goto LABEL_64;
    case 7:
      int64_t v47 = *(void **)(a1 + 40);
      uint64_t v48 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v147 = (void *)v159[5];
      [v47 setCommonParameters:v48 errorStr:&v147];
      uint64_t v30 = v147;
      goto LABEL_64;
    case 8:
      uint64_t v49 = *(void **)(a1 + 40);
      uint64_t v50 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v146 = (void *)v159[5];
      [v49 unsetCommonParameters:v50 errorStr:&v146];
      uint64_t v30 = v146;
      goto LABEL_64;
    case 9:
      uint64_t v51 = *(void **)(a1 + 40);
      uint64_t v52 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v145 = (void *)v159[5];
      [v51 setIPSecParameters:v52 errorStr:&v145];
      uint64_t v30 = v145;
      goto LABEL_64;
    case 10:
      uint64_t v53 = *(void **)(a1 + 40);
      uint64_t v54 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v144 = (void *)v159[5];
      [v53 unsetIPSecParameters:v54 errorStr:&v144];
      uint64_t v30 = v144;
      goto LABEL_64;
    case 11:
    case 12:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 31:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
LABEL_81:
      v103 = [NSString stringWithFormat:@"Unknown command"];
      unint64_t v71 = (id)v159[5];
      v159[5] = v103;
      goto LABEL_65;
    case 13:
      BOOL v55 = *(void **)(a1 + 40);
      unint64_t v56 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v143 = (void *)v159[5];
      [v55 addOnDemandRuleWithParameters:v56 errorStr:&v143];
      uint64_t v30 = v143;
      goto LABEL_64;
    case 14:
      unint64_t v57 = *(void **)(a1 + 40);
      unint64_t v58 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v142 = (void *)v159[5];
      [v57 removeOnDemandRuleWithParameters:v58 errorStr:&v142];
      uint64_t v30 = v142;
      goto LABEL_64;
    case 15:
      uint64_t v59 = *(void **)(a1 + 40);
      uint64_t v60 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v129 = (void *)v159[5];
      [v59 setProxyParameters:v60 errorStr:&v129];
      uint64_t v30 = v129;
      goto LABEL_64;
    case 16:
      uint64_t v61 = *(void **)(a1 + 40);
      uint64_t v62 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v128 = (void *)v159[5];
      [v61 unsetProxyParameters:v62 errorStr:&v128];
      uint64_t v30 = v128;
      goto LABEL_64;
    case 17:
      uint64_t v63 = *(void **)(a1 + 40);
      uint64_t v64 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v127 = (void *)v159[5];
      [v63 setProxyServer:v64 errorStr:&v127];
      uint64_t v30 = v127;
      goto LABEL_64;
    case 18:
      uint64_t v65 = *(void **)(a1 + 40);
      uint64_t v66 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v126 = (void *)v159[5];
      [v65 unsetProxyServer:v66 errorStr:&v126];
      uint64_t v30 = v126;
      goto LABEL_64;
    case 19:
      uint64_t v67 = *(void **)(a1 + 40);
      uint64_t v68 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v133 = (void *)v159[5];
      [v67 setDNSParameters:v68 errorStr:&v133];
      uint64_t v30 = v133;
      goto LABEL_64;
    case 20:
      uint64_t v69 = *(void **)(a1 + 40);
      size_t v70 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v132 = (void *)v159[5];
      [v69 unsetDNSParameters:v70 errorStr:&v132];
      uint64_t v30 = v132;
      goto LABEL_64;
    case 30:
      [v5 description];
      unint64_t v71 = (id)objc_claimAutoreleasedReturnValue();
      [v8 addObject:v71];
      goto LABEL_65;
    case 32:
      Property = *(id *)(a1 + 40);
      if (!Property) {
        goto LABEL_102;
      }
      if (objc_getProperty(Property, v20, 88LL, 1))
      {
        +[NEFilterManager sharedManager](&OBJC_CLASS___NEFilterManager, "sharedManager");
        uint64_t v74 = (id)objc_claimAutoreleasedReturnValue();
        v137[0] = MEMORY[0x1895F87A8];
        v137[1] = 3221225472LL;
        v137[2] = __101__NEProviderAppConfigurationClient_handleCommand_forConfigWithName_withParameters_completionHandler___block_invoke_5;
        v137[3] = &unk_18A08F990;
        v137[7] = &v158;
        unint64_t v75 = v137;
        uint64_t v76 = *(id *)(a1 + 32);
        unint64_t v77 = *(void *)(a1 + 40);
        v137[4] = v76;
        v137[5] = v77;
        v137[6] = *(id *)(a1 + 56);
        [v74 saveToPreferencesWithCompletionHandler:v137];
        goto LABEL_106;
      }

      Property = *(id *)(a1 + 40);
      if (!Property) {
        goto LABEL_102;
      }
      if (objc_getProperty(Property, v73, 96LL, 1))
      {
        +[NEDNSProxyManager sharedManager](&OBJC_CLASS___NEDNSProxyManager, "sharedManager");
        uint64_t v74 = (id)objc_claimAutoreleasedReturnValue();
        v136[0] = MEMORY[0x1895F87A8];
        v136[1] = 3221225472LL;
        v136[2] = __101__NEProviderAppConfigurationClient_handleCommand_forConfigWithName_withParameters_completionHandler___block_invoke_6;
        v136[3] = &unk_18A08F990;
        v136[7] = &v158;
        unint64_t v75 = v136;
        v105 = *(id *)(a1 + 32);
        v106 = *(void *)(a1 + 40);
        v136[4] = v105;
        v136[5] = v106;
        v136[6] = *(id *)(a1 + 56);
        [v74 saveToPreferencesWithCompletionHandler:v136];
        goto LABEL_106;
      }

      Property = *(id *)(a1 + 40);
      if (!Property) {
        goto LABEL_102;
      }
      if (objc_getProperty(Property, v104, 104LL, 1))
      {
        +[NEDNSSettingsManager sharedManager](&OBJC_CLASS___NEDNSSettingsManager, "sharedManager");
        uint64_t v74 = (id)objc_claimAutoreleasedReturnValue();
        v135[0] = MEMORY[0x1895F87A8];
        v135[1] = 3221225472LL;
        v135[2] = __101__NEProviderAppConfigurationClient_handleCommand_forConfigWithName_withParameters_completionHandler___block_invoke_7;
        v135[3] = &unk_18A08F990;
        v135[7] = &v158;
        unint64_t v75 = v135;
        v116 = *(id *)(a1 + 32);
        v117 = *(void *)(a1 + 40);
        v135[4] = v116;
        v135[5] = v117;
        v135[6] = *(id *)(a1 + 56);
        [v74 saveToPreferencesWithCompletionHandler:v135];
      }

      else
      {
        Property = *(id *)(a1 + 40);
        if (Property) {
          Property = objc_getProperty(Property, v115, 80LL, 1);
        }
LABEL_102:
        uint64_t v74 = Property;
        v134[0] = MEMORY[0x1895F87A8];
        v134[1] = 3221225472LL;
        v134[2] = __101__NEProviderAppConfigurationClient_handleCommand_forConfigWithName_withParameters_completionHandler___block_invoke_8;
        v134[3] = &unk_18A08F990;
        v134[7] = &v158;
        unint64_t v75 = v134;
        v121 = *(id *)(a1 + 32);
        v122 = *(void *)(a1 + 40);
        v134[4] = v121;
        v134[5] = v122;
        v134[6] = *(id *)(a1 + 56);
        [v74 saveToPreferencesWithCompletionHandler:v134];
      }

      goto LABEL_106;
    case 33:
      unint64_t v78 = *(id *)(a1 + 40);
      if (!v78) {
        goto LABEL_105;
      }
      if (objc_getProperty(v78, v20, 88LL, 1))
      {
        +[NEFilterManager sharedManager](&OBJC_CLASS___NEFilterManager, "sharedManager");
        uint64_t v74 = (id)objc_claimAutoreleasedReturnValue();
        v156[0] = MEMORY[0x1895F87A8];
        v156[1] = 3221225472LL;
        v156[2] = __101__NEProviderAppConfigurationClient_handleCommand_forConfigWithName_withParameters_completionHandler___block_invoke_152;
        v156[3] = &unk_18A08F990;
        v156[7] = &v158;
        unint64_t v75 = v156;
        uint64_t v80 = *(id *)(a1 + 32);
        objc_super v81 = *(void *)(a1 + 40);
        v156[4] = v80;
        v156[5] = v81;
        v156[6] = *(id *)(a1 + 56);
        [v74 removeFromPreferencesWithCompletionHandler:v156];
        goto LABEL_106;
      }

      unint64_t v78 = *(id *)(a1 + 40);
      if (!v78) {
        goto LABEL_105;
      }
      if (objc_getProperty(v78, v79, 96LL, 1))
      {
        +[NEDNSProxyManager sharedManager](&OBJC_CLASS___NEDNSProxyManager, "sharedManager");
        uint64_t v74 = (id)objc_claimAutoreleasedReturnValue();
        v155[0] = MEMORY[0x1895F87A8];
        v155[1] = 3221225472LL;
        v155[2] = __101__NEProviderAppConfigurationClient_handleCommand_forConfigWithName_withParameters_completionHandler___block_invoke_2_155;
        v155[3] = &unk_18A08F990;
        v155[7] = &v158;
        unint64_t v75 = v155;
        v108 = *(id *)(a1 + 32);
        v109 = *(void *)(a1 + 40);
        v155[4] = v108;
        v155[5] = v109;
        v155[6] = *(id *)(a1 + 56);
        [v74 removeFromPreferencesWithCompletionHandler:v155];
        goto LABEL_106;
      }

      unint64_t v78 = *(id *)(a1 + 40);
      if (!v78) {
        goto LABEL_105;
      }
      if (objc_getProperty(v78, v107, 104LL, 1))
      {
        +[NEDNSSettingsManager sharedManager](&OBJC_CLASS___NEDNSSettingsManager, "sharedManager");
        uint64_t v74 = (id)objc_claimAutoreleasedReturnValue();
        v154[0] = MEMORY[0x1895F87A8];
        v154[1] = 3221225472LL;
        v154[2] = __101__NEProviderAppConfigurationClient_handleCommand_forConfigWithName_withParameters_completionHandler___block_invoke_3_156;
        v154[3] = &unk_18A08F990;
        v154[7] = &v158;
        unint64_t v75 = v154;
        v119 = *(id *)(a1 + 32);
        v120 = *(void *)(a1 + 40);
        v154[4] = v119;
        v154[5] = v120;
        v154[6] = *(id *)(a1 + 56);
        [v74 removeFromPreferencesWithCompletionHandler:v154];
      }

      else
      {
        unint64_t v78 = *(id *)(a1 + 40);
        if (v78) {
          unint64_t v78 = objc_getProperty(v78, v118, 80LL, 1);
        }
LABEL_105:
        uint64_t v74 = v78;
        v153[0] = MEMORY[0x1895F87A8];
        v153[1] = 3221225472LL;
        v153[2] = __101__NEProviderAppConfigurationClient_handleCommand_forConfigWithName_withParameters_completionHandler___block_invoke_4;
        v153[3] = &unk_18A08F990;
        v153[7] = &v158;
        unint64_t v75 = v153;
        v123 = *(id *)(a1 + 32);
        v124 = *(void *)(a1 + 40);
        v153[4] = v123;
        v153[5] = v124;
        v153[6] = *(id *)(a1 + 56);
        [v74 removeFromPreferencesWithCompletionHandler:v153];
      }

    uint64_t v30 = 0;
    goto LABEL_26;
  }

  objc_opt_self();
  if (sharedWrapperForSession__globals_init != -1) {
    dispatch_once(&sharedWrapperForSession__globals_init, &__block_literal_global_21050);
  }
  ne_session_get_configuration_id();
  unint64_t v12 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:v43];
  unsigned __int16 v13 = (id)wrapperMap;
  objc_sync_enter(v13);
  [(id)wrapperMap objectForKeyedSubscript:v12];
  unint64_t v15 = (NETunnelProviderSession *)objc_claimAutoreleasedReturnValue();
  if (v15) {
    goto LABEL_17;
  }
  unint64_t v16 = objc_alloc(&OBJC_CLASS___NEIPCWrapper);
  unint64_t v32 = v12;
  if (v16)
  {
    v42.receiver = v16;
    v42.super_class = (Class)&OBJC_CLASS___NEIPCWrapper;
    unsigned __int16 v17 = -[NETunnelProviderSession init](&v42, sel_init);
    __int16 v18 = v17;
    if (v17)
    {
      objc_storeStrong((id *)&v17->super._configManager, v12);
      dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      unint64_t v19 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = dispatch_queue_create("NEIPCWrapper IPC queue", v19);
      status = (void *)v18->super._status;
      v18->super._status = (int64_t)v20;

      dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      unint64_t v22 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v23 = dispatch_queue_create("NEIPCWrapper send queue", v22);
      unint64_t v24 = *(void **)&v18->super._installed;
      *(void *)&v18->super._installed = v23;

      dispatch_suspend(*(dispatch_object_t *)&v18->super._installed);
      *(void *)buf = MEMORY[0x1895F87A8];
      uint64_t v38 = 3221225472LL;
      unint64_t v39 = __43__NEIPCWrapper_initWithSession_identifier___block_invoke;
      unint64_t v40 = &unk_18A090220;
      unint64_t v15 = v18;
      unint64_t v41 = v15;
      ne_session_establish_ipc();

LABEL_17:
      BOOL v25 = (void *)wrapperMap;
      unint64_t v26 = objc_getProperty(v15, v14, 32LL, 1);
      [v25 setObject:v15 forKeyedSubscript:v26];

      goto LABEL_18;
    }
  }

  unint64_t v15 = 0LL;
LABEL_18:
  objc_sync_exit(v13);

  if (!v15)
  {
    if (error)
    {
      [MEMORY[0x189607870] errorWithDomain:@"NEVPNErrorDomain" code:1 userInfo:0];
      unint64_t v11 = (NSError *)(id)objc_claimAutoreleasedReturnValue();
      goto LABEL_22;
    }

    goto LABEL_25;
  }

  Property = (dispatch_queue_s *)objc_getProperty(v15, v27, 8LL, 1);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __75__NETunnelProviderSession_sendProviderMessage_returnError_responseHandler___block_invoke;
  block[3] = &unk_18A08FB50;
  uint64_t v34 = v15;
  uint64_t v35 = v8;
  unint64_t v36 = v9;
  uint64_t v29 = v15;
  dispatch_async(Property, block);

  uint64_t v30 = 1;
LABEL_26:

  return v30;
}

      if (v25 == ++v27)
      {
        BOOL v25 = [v23 countByEnumeratingWithState:&v51 objects:v55 count:16];
        if (!v25)
        {
LABEL_27:

          -[NENetworkPropertiesCache saveCacheToDisk:](v46, (uint64_t)v49);
          id v8 = v47;
          id v6 = v48;
          goto LABEL_28;
        }

        goto LABEL_12;
      }
    }
  }

  ne_log_obj();
  unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    if (v5) {
      uint64_t v44 = @"update";
    }
    else {
      uint64_t v44 = @"add";
    }
    uint64_t v45 = (__CFString *)SecCopyErrorMessageString(v16, 0LL);
    *(_DWORD *)dataOutMoved = 138412546;
    *(void *)&dataOutMoved[4] = v44;
    unint64_t v57 = 2112;
    unint64_t v58 = v45;
    _os_log_error_impl( &dword_1876B1000,  v22,  OS_LOG_TYPE_ERROR,  "Failed to %@ the signature key: %@",  dataOutMoved,  0x16u);
  }

LABEL_28:
}

      id v8 = 0LL;
      goto LABEL_26;
    }

    if ((*(_BYTE *)(a1 + 312) & 1) == 0)
    {
      id v8 = *(__CFDictionary **)(a1 + 328);
      unint64_t v16 = CFArrayGetTypeID();
      if (!v8) {
        goto LABEL_26;
      }
      if (CFGetTypeID(v8) != v16 || CFArrayGetCount(*(CFArrayRef *)(a1 + 328)) < 1) {
        goto LABEL_25;
      }
    }

    *(_DWORD *)buf = 128;
    unsigned __int16 v17 = CFDictionaryCreateMutable(v6, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    id v8 = v17;
    if (!v17) {
      goto LABEL_26;
    }
    CFDictionarySetValue(v17, (const void *)*MEMORY[0x18960C600], v7);
    __int16 v18 = *(const void **)(a1 + 328);
    unint64_t v19 = CFArrayGetTypeID();
    BOOL v20 = (const void **)MEMORY[0x18960C788];
    if (v18 && CFGetTypeID(v18) == v19 && CFArrayGetCount(*(CFArrayRef *)(a1 + 328)))
    {
      CFDictionarySetValue(v8, (const void *)*MEMORY[0x18960C730], *(const void **)(a1 + 328));
      uint64_t v21 = *(CFStringRef *)(a1 + 336);
      unint64_t v22 = CFArrayGetTypeID();
      if (!v21)
      {
LABEL_50:
        unint64_t v40 = *(const void **)(a1 + 360);
        unint64_t v41 = CFArrayGetTypeID();
        if (v40 && CFGetTypeID(v40) == v41 && CFArrayGetCount(*(CFArrayRef *)(a1 + 360)) >= 1) {
          CFDictionarySetValue(v8, (const void *)*MEMORY[0x18960C728], *(const void **)(a1 + 360));
        }
        if (a3 && *(void *)(a1 + 472))
        {
          unint64_t v42 = CFNumberCreate(v6, kCFNumberIntType, buf);
          NEVirtualInterfaceAddIPv6Route(a1, *(const __CFString **)(a1 + 472), v42, 0LL, 1);
          CFRelease(v42);
        }

        int64_t v43 = *(const void **)(a1 + 368);
        uint64_t v44 = CFArrayGetTypeID();
        if (v43 && CFGetTypeID(v43) == v44 && CFArrayGetCount(*(CFArrayRef *)(a1 + 368)) >= 1) {
          CFDictionarySetValue(v8, (const void *)*MEMORY[0x18960C740], *(const void **)(a1 + 368));
        }
        uint64_t v45 = *(const void **)(a1 + 464);
        uint64_t v46 = CFStringGetTypeID();
        if (v45 && CFGetTypeID(v45) == v46)
        {
          int64_t v47 = *v20;
          uint64_t v48 = *(CFStringRef *)(a1 + 464);
          uint64_t v49 = v8;
        }

        else
        {
          BOOL v55 = CFStringGetTypeID();
          if (!v21 || CFGetTypeID(v21) != v55) {
            goto LABEL_76;
          }
          int64_t v47 = *v20;
          uint64_t v49 = v8;
          uint64_t v48 = v21;
        }

        CFDictionarySetValue(v49, v47, v48);
LABEL_76:
        unint64_t v56 = *(const void **)(a1 + 472);
        unint64_t v57 = CFStringGetTypeID();
        if (v56 && CFGetTypeID(v56) == v57) {
          CFDictionarySetValue(v8, @"ServerAddress", *(const void **)(a1 + 472));
        }
        if (v21) {
          CFRelease(v21);
        }
        goto LABEL_26;
      }

      if (CFGetTypeID(v21) == v22 && CFArrayGetCount(*(CFArrayRef *)(a1 + 336)) >= 1)
      {
        CFDictionarySetValue(v8, (const void *)*MEMORY[0x18960C760], *(const void **)(a1 + 336));
        valuePtr = 0;
        uint64_t v23 = (const __CFNumber *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), 0LL);
        CFNumberGetValue(v23, kCFNumberIntType, &valuePtr);
        unint64_t v24 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 328), 0LL);
        uint64_t v21 = NECreateIPv6SubnetAddressWithPrefix(v24, valuePtr);
        goto LABEL_50;
      }
    }

    else
    {
      uint64_t v38 = CFArrayCreateMutable(v6, 1LL, MEMORY[0x189605228]);
      if (v38)
      {
        unint64_t v39 = v38;
        CFArrayAppendValue(v38, @"::1");
        CFDictionarySetValue(v8, (const void *)*MEMORY[0x18960C730], v39);
        CFRelease(v39);
      }

      CFDictionarySetValue(v8, @"IsNULL", (const void *)*MEMORY[0x189604DE8]);
      CFDictionarySetValue(v8, *v20, @"::1");
    }

    uint64_t v21 = 0LL;
    goto LABEL_50;
  }

  unint64_t v58 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    uint64_t v61 = "NEVirtualInterfaceCopyIPStateDictionary";
    _os_log_fault_impl(&dword_1876B1000, v58, OS_LOG_TYPE_FAULT, "%s called with null interface", buf, 0xCu);
  }

  return 0LL;
}

LABEL_111:
    goto LABEL_195;
  }

  [v12 protocol];
  v159 = 0LL;
  v160 = (void *)objc_claimAutoreleasedReturnValue();
  v161 = 0LL;
LABEL_27:
  [v9 objectForKeyedSubscript:@"RemoteAddress"];
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
  if (isa_nsstring(v29))
  {
    [v12 protocol];
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
    [v30 setServerAddress:v29];
  }

  [v9 objectForKeyedSubscript:@"EnforceRoutes"];
  unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();

  if (isa_nsnumber(v31))
  {
    unint64_t v32 = [v31 BOOLValue];
    [v12 protocol];
    unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    [v33 setEnforceRoutes:v32];
  }

  [v9 objectForKeyedSubscript:@"ExcludeLocalNetworks"];
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();

  if (isa_nsnumber(v34))
  {
    uint64_t v35 = [v34 BOOLValue];
    [v12 protocol];
    unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
    [v36 setExcludeLocalNetworks:v35];
  }

  [v9 objectForKeyedSubscript:@"ExcludeCellularServices"];
  uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();

  if (isa_nsnumber(v37))
  {
    uint64_t v38 = [v37 BOOLValue];
    [v12 protocol];
    unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
    [v39 setExcludeCellularServices:v38];
  }

  self = v16;
  [v9 objectForKeyedSubscript:@"ExcludeAPNs"];
  unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();

  if (isa_nsnumber(v40))
  {
    unint64_t v41 = [v40 BOOLValue];
    [v12 protocol];
    unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
    [v42 setExcludeAPNs:v41];
  }

  v158 = v12;
  [v9 objectForKeyedSubscript:@"ExcludeDeviceCommunication"];
  int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();

  if (isa_nsnumber(v43))
  {
    uint64_t v44 = [v43 BOOLValue];
    [v12 protocol];
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
    [v45 setExcludeDeviceCommunication:v44];
  }

  [v11 payloadAtom];
  uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
  [v46 objectForKeyedSubscript:@"CellularSliceUUID"];
  int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();

  if (v47)
  {
    [v11 payloadAtom];
    uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue();
    [v48 objectForKeyedSubscript:@"CellularSliceUUID"];
    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
    [v12 protocol];
    uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
    [v50 setSliceUUID:v49];
  }

  if (!v159)
  {
    [v9 objectForKeyedSubscript:@"PasswordReference"];
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();

    if (isa_nsdata(v51))
    {
      [v12 protocol];
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
      [v52 setPasswordReference:v51];
    }

    [v9 objectForKeyedSubscript:@"SharedSecretReference"];
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();

    [v9 objectForKeyedSubscript:@"XAuthPasswordEncryption"];
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();

    [v9 objectForKeyedSubscript:@"IdentityDataPasswordKeyStr"];
    int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();

    if (v43)
    {
      BOOL v55 = objc_alloc(&OBJC_CLASS___NEKeychainItem);
      unint64_t v56 = *((void *)self + 10);
      unint64_t v58 = objc_getProperty(self, v57, 88LL, 1);
      uint64_t v59 = -[NEKeychainItem initWithPassword:domain:accessGroup:]( v55,  "initWithPassword:domain:accessGroup:",  v43,  v56,  v58);
      -[os_log_s setIdentityDataPasswordKeychainItem:](self, "setIdentityDataPasswordKeychainItem:", v59);
    }
  }

  if (!v160)
  {
    if (v161)
    {
      [v9 objectForKeyedSubscript:@"AuthName"];
      uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();

      [v161 pluginType];
      objc_super v81 = (void *)objc_claimAutoreleasedReturnValue();

      if (v81)
      {
        [v161 pluginType];
        uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
        [a1 setApplication:v82];
      }

      goto LABEL_113;
    }

    goto LABEL_122;
  }

  [v9 objectForKeyedSubscript:@"XAuthName"];
  uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();

  [v9 objectForKeyedSubscript:@"ExchangeMode"];
  uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();

  [v9 objectForKeyedSubscript:@"Proposals"];
  uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue();

  uint64_t v63 = v62;
  if (![v63 count]) {
    goto LABEL_99;
  }
  v152 = v62;
  v153 = v11;
  v154 = v10;
  v155 = v9;
  [MEMORY[0x189603FA8] array];
  v162 = (void *)objc_claimAutoreleasedReturnValue();
  v163 = 0u;
  v164 = 0u;
  v165 = 0u;
  v166 = 0u;
  v151 = v63;
  uint64_t v64 = v63;
  uint64_t v65 = [v64 countByEnumeratingWithState:&v163 objects:v171 count:16];
  if (!v65) {
    goto LABEL_96;
  }
  uint64_t v66 = v65;
  uint64_t v67 = *(void *)v164;
  do
  {
    uint64_t v68 = 0LL;
    do
    {
      if (*(void *)v164 != v67) {
        objc_enumerationMutation(v64);
      }
      uint64_t v69 = *(void **)(*((void *)&v163 + 1) + 8 * v68);
      if (isa_nsdictionary(v69))
      {
        size_t v70 = objc_alloc_init(&OBJC_CLASS___NEVPNIKEv1ProposalParameters);
        [v69 objectForKeyedSubscript:@"EncryptionAlgorithm"];
        unint64_t v71 = (void *)objc_claimAutoreleasedReturnValue();
        [v69 objectForKeyedSubscript:@"HashAlgorithm"];
        uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue();
        [v69 objectForKeyedSubscript:@"DHGroup"];
        unint64_t v73 = (void *)objc_claimAutoreleasedReturnValue();
        [v69 objectForKeyedSubscript:@"Lifetime"];
        uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue();
        if ([v71 isEqualToString:@"DES"])
        {
          unint64_t v75 = 1LL;
          goto LABEL_76;
        }

        if ([v71 isEqualToString:@"3DES"])
        {
          unint64_t v75 = 2LL;
          goto LABEL_76;
        }

        if ([v71 isEqualToString:@"AES"])
        {
          unint64_t v75 = 3LL;
          goto LABEL_76;
        }

        if ([v71 isEqualToString:@"AES256"])
        {
          unint64_t v75 = 4LL;
LABEL_76:
          -[NEVPNIKEv1ProposalParameters setEncryptionAlgorithm:](v70, "setEncryptionAlgorithm:", v75, v151);
          uint64_t v76 = 1;
        }

        else
        {
LABEL_77:
          uint64_t v76 = 0;
        }

        if (isa_nsstring(v72))
        {
          if ([v72 isEqualToString:@"SHA1"])
          {
            unint64_t v77 = 1LL;
            goto LABEL_83;
          }

          if ([v72 isEqualToString:@"MD5"])
          {
            unint64_t v77 = 2LL;
LABEL_83:
            -[NEVPNIKEv1ProposalParameters setIntegrityAlgorithm:](v70, "setIntegrityAlgorithm:", v77, v151);
            uint64_t v76 = 1;
          }
        }

        if ((isa_nsnumber(v73) & 1) != 0)
        {
          -[NEVPNIKEv1ProposalParameters setDiffieHellmanGroup:]( v70,  "setDiffieHellmanGroup:",  [v73 intValue]);
          if (!isa_nsnumber(v74))
          {
LABEL_89:
            objc_msgSend(v162, "addObject:", v70, v151);
            goto LABEL_90;
          }
        }

        else if ((isa_nsnumber(v74) & 1) == 0)
        {
          if (v76) {
            goto LABEL_89;
          }
LABEL_90:

          goto LABEL_91;
        }

        -[NEVPNIKEv1ProposalParameters setLifetimeSeconds:]( v70,  "setLifetimeSeconds:",  objc_msgSend(v74, "intValue", v151));
        goto LABEL_89;
      }

LABEL_91:
      ++v68;
    }

    while (v66 != v68);
    unint64_t v78 = [v64 countByEnumeratingWithState:&v163 objects:v171 count:16];
    uint64_t v66 = v78;
  }

  while (v78);
LABEL_96:

  if ([v162 count]) {
    [v160 setLegacyProposals:v162];
  }

  unint64_t v10 = v154;
  uint64_t v9 = v155;
  uint64_t v62 = v152;
  unint64_t v11 = v153;
  uint64_t v63 = v151;
LABEL_99:

LABEL_100:
  objc_msgSend(v9, "objectForKeyedSubscript:", @"XAuthPassword", v151);
  int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();

  if (v43)
  {
    if (isa_nsdata(v43))
    {
      uint64_t v79 = [objc_alloc(NSString) initWithData:v43 encoding:4];

      int64_t v43 = (void *)v79;
      goto LABEL_118;
    }

    if ((isa_nsstring(v43) & 1) != 0)
    {
LABEL_118:
      uint64_t v84 = objc_alloc(&OBJC_CLASS___NEKeychainItem);
      uint64_t v85 = v160;
      v86 = v160[10];
      Property = objc_getProperty(v160, v87, 88LL, 1);
      goto LABEL_121;
    }

    ne_log_obj();
    v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
    {
      v110 = (void *)objc_opt_class();
      v111 = v110;
      v112 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412546;
      v168 = v110;
      v169 = 2112;
      v170 = v112;
      v113 = v112;
      v114 = "%@ configureIKE: unsupported Xauth password data type %@";
      goto LABEL_198;
    }

    goto LABEL_145;
  }

  uint64_t v80 = 0LL;
  if (!v161) {
    goto LABEL_122;
  }
LABEL_113:
  [v9 objectForKeyedSubscript:@"AuthPassword"];
  int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v43)
  {
    [v9 objectForKeyedSubscript:@"XAuthPassword"];
    int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v43) {
      goto LABEL_122;
    }
  }

  if (!isa_nsdata(v43))
  {
    if ((isa_nsstring(v43) & 1) != 0) {
      goto LABEL_120;
    }
    ne_log_obj();
    v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
    {
      v148 = (void *)objc_opt_class();
      v111 = v148;
      v149 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412546;
      v168 = v148;
      v169 = 2112;
      v170 = v149;
      v113 = v149;
      v114 = "%@ configureIKE: unsupported password data type %@";
LABEL_198:
      _os_log_error_impl(&dword_1876B1000, v109, OS_LOG_TYPE_ERROR, v114, buf, 0x16u);
    }

              return 104LL;
            }

            goto LABEL_73;
          }
        }
      }

  objc_setProperty_atomic(v9, v76, v77, 112LL);
  [v8 additionalKEMProtocols];
  unint64_t v78 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v78)
  {
    -[os_log_s additionalKEMProtocols](v9, "additionalKEMProtocols");
    uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();

    if (v80) {
      -[NEIKEv2IKESAProposal setChosenAdditionalKEMProtocols:](v9, MEMORY[0x189604A60]);
    }
    uint64_t v74 = v9;

    goto LABEL_155;
  }

  v114 = v65;
  v112 = v63;
  v113 = v77;
  if (-[NEIKEv2KEMProtocol method](v77, "method")) {
    uint64_t v79 = (id)objc_msgSend(objc_alloc(MEMORY[0x189603FE0]), "initWithObjects:", v77, 0);
  }
  else {
    uint64_t v79 = objc_alloc_init(MEMORY[0x189603FE0]);
  }
  v86 = v79;
  v87 = objc_alloc_init(MEMORY[0x189603FC8]);
  unint64_t v88 = 6LL;
  v115 = v87;
  v116 = v8;
  v117 = a3;
  while (2)
  {
    [MEMORY[0x189607968] numberWithUnsignedInteger:v88];
    v89 = (void *)objc_claimAutoreleasedReturnValue();
    -[os_log_s additionalKEMProtocols](v9, "additionalKEMProtocols");
    CFErrorRef v90 = (void *)objc_claimAutoreleasedReturnValue();
    [v90 objectForKeyedSubscript:v89];
    unint64_t v91 = (void *)objc_claimAutoreleasedReturnValue();

    [v8 additionalKEMProtocols];
    v92 = (void *)objc_claimAutoreleasedReturnValue();
    [v92 objectForKeyedSubscript:v89];
    v93 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v93)
    {
LABEL_123:
      v100 = 0LL;
LABEL_138:

      if (++v88 == 13)
      {
        v107 = (void *)[objc_alloc(MEMORY[0x189603F68]) initWithDictionary:v87];
        -[NEIKEv2IKESAProposal setChosenAdditionalKEMProtocols:](v9, v107);

        uint64_t v74 = v9;
        uint64_t v63 = v112;
        goto LABEL_154;
      }

      continue;
    }

    break;
  }

  if (!v91)
  {
    v101 = -[NEIKEv2KEMProtocol initWithMethod:](objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol), "initWithMethod:", 0LL);
    [v87 setObject:v101 forKeyedSubscript:v89];

    goto LABEL_123;
  }

  v120 = v89;
  if (a3)
  {
    v127 = 0uLL;
    v128 = 0uLL;
    v125 = 0uLL;
    v126 = 0uLL;
    v94 = v93;
    v95 = [v94 countByEnumeratingWithState:&v125 objects:v154 count:16];
    if (v95)
    {
      v96 = v95;
      v97 = *(void *)v126;
      do
      {
        for (ii = 0LL; ii != v96; ++ii)
        {
          if (*(void *)v126 != v97) {
            objc_enumerationMutation(v94);
          }
          v99 = [v91 indexOfObject:*(void *)(*((void *)&v125 + 1) + 8 * ii)];
          if (v99 != 0x7FFFFFFFFFFFFFFFLL)
          {
            [v91 objectAtIndexedSubscript:v99];
            v100 = (id)objc_claimAutoreleasedReturnValue();
          }
        }

        v96 = [v94 countByEnumeratingWithState:&v125 objects:v154 count:16];
      }

      while (v96);
      v93 = v94;
LABEL_147:
      v87 = v115;
    }

    else
    {
      v93 = v94;
    }

    v89 = v120;
LABEL_150:
  }

  else
  {
    v123 = 0uLL;
    v124 = 0uLL;
    v121 = 0uLL;
    v122 = 0uLL;
    v94 = v91;
    v102 = [v94 countByEnumeratingWithState:&v121 objects:v153 count:16];
    if (!v102)
    {
      unint64_t v91 = v94;
      goto LABEL_150;
    }

    v103 = v102;
    v104 = *(void *)v122;
LABEL_126:
    v105 = 0LL;
    while (1)
    {
      if (*(void *)v122 != v104) {
        objc_enumerationMutation(v94);
      }
      v106 = *(void **)(*((void *)&v121 + 1) + 8 * v105);
      if (([v86 containsObject:v106] & 1) == 0)
      {
      }

      if (v103 == ++v105)
      {
        v103 = [v94 countByEnumeratingWithState:&v121 objects:v153 count:16];
        if (v103) {
          goto LABEL_126;
        }
        unint64_t v91 = v94;
        goto LABEL_147;
      }
    }

    v100 = v106;
LABEL_135:

    a3 = v117;
    v87 = v115;
    v89 = v120;
    if (v100)
    {
      [v115 setObject:v100 forKeyedSubscript:v120];
      id v8 = v116;
      if ([v100 method]) {
        [v86 addObject:v100];
      }
      goto LABEL_138;
    }
  }

  id v8 = v116;
  uint64_t v63 = v112;
  ne_log_obj();
  v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1876B1000, v110, OS_LOG_TYPE_ERROR, "No chosen additional KE methods", buf, 2u);
  }

  uint64_t v74 = 0LL;
LABEL_154:

  uint64_t v65 = v114;
LABEL_155:

LABEL_164:
LABEL_165:

  return v74;
}

  uint64_t v9 = v109;
  unint64_t v16 = v110;
  uint64_t v60 = v113;
LABEL_92:

  unsigned __int16 v17 = v114;
LABEL_93:

LABEL_94:
LABEL_95:

  v97 = v123;
LABEL_96:

LABEL_97:
  return v97;
}

                v113 = 0LL;
LABEL_92:

                goto LABEL_93;
              }

              ne_log_obj();
              v126 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v126, OS_LOG_TYPE_ERROR))
              {
                v183 = (char *)[a1 copyShortDescription];
                *(_DWORD *)buf = 138412290;
                v261 = v183;
                _os_log_error_impl( &dword_1876B1000,  v126,  OS_LOG_TYPE_ERROR,  "%@ Did not receive data in KE payload",  buf,  0xCu);
              }

              v122 = @"Did not receive data in KE payload";
            }

            else
            {
              ne_log_obj();
              v125 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
              {
                v146 = (char *)[a1 copyShortDescription];
                *(_DWORD *)buf = 138412290;
                v261 = v146;
                _os_log_error_impl( &dword_1876B1000,  v125,  OS_LOG_TYPE_ERROR,  "%@ Did not receive method in KE payload",  buf,  0xCu);
              }

              v122 = @"Did not receive method in KE payload";
            }
          }

          else
          {
            ne_log_obj();
            v124 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
            {
              v145 = (char *)[a1 copyShortDescription];
              *(_DWORD *)buf = 138412290;
              v261 = v145;
              _os_log_error_impl(&dword_1876B1000, v124, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload", buf, 0xCu);
            }

            v122 = @"Did not receive KE payload";
          }
        }

        else
        {
          ne_log_obj();
          v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
          {
            v142 = (char *)[a1 copyShortDescription];
            *(_DWORD *)buf = 138412290;
            v261 = v142;
            _os_log_error_impl(&dword_1876B1000, v123, OS_LOG_TYPE_ERROR, "%@ No matching proposal found", buf, 0xCu);
          }

          if (a3) {
            *a3 = 14LL;
          }
          v122 = @"No matching proposal found";
        }
      }

      else
      {
        ne_log_obj();
        v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
        {
          v132 = (char *)[a1 copyShortDescription];
          *(_DWORD *)buf = 138412290;
          v261 = v132;
          _os_log_error_impl(&dword_1876B1000, v114, OS_LOG_TYPE_ERROR, "%@ Received no SA proposals", buf, 0xCu);
        }

        v122 = @"Received no SA proposals";
      }

      v127 = (id)NEIKEv2CreateErrorPeerInvalidSyntax(v122, v115, v116, v117, v118, v119, v120, v121, v250);
      -[NEIKEv2IKESA setState:error:](v7, 3uLL, v127);
LABEL_90:

      goto LABEL_91;
    }

    ne_log_obj();
    v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
    {
      v131 = (char *)[a1 copyShortDescription];
      *(_DWORD *)buf = 138412290;
      v261 = v131;
      _os_log_error_impl(&dword_1876B1000, v105, OS_LOG_TYPE_ERROR, "%@ Received no remote SPI on SA_INIT", buf, 0xCu);
    }

    unint64_t v10 = (os_log_s *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Received no remote SPI on SA_INIT",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v250);
    -[NEIKEv2IKESA setState:error:](v7, 3uLL, v10);
  }

LABEL_145:
    v115 = 0LL;
    unint64_t v12 = v158;
    unint64_t v16 = self;
    goto LABEL_196;
  }

  v83 = [objc_alloc(NSString) initWithData:v43 encoding:4];

  int64_t v43 = (void *)v83;
LABEL_120:
  uint64_t v84 = objc_alloc(&OBJC_CLASS___NEKeychainItem);
  uint64_t v85 = v161;
  v86 = v161[10];
  Property = objc_getProperty(v161, v89, 88LL, 1);
LABEL_121:
  CFErrorRef v90 = Property;
  unint64_t v91 = -[NEKeychainItem initWithPassword:domain:accessGroup:]( v84,  "initWithPassword:domain:accessGroup:",  v43,  v86,  v90);
  [v85 setPasswordKeychainItem:v91];

LABEL_122:
  [v9 objectForKeyedSubscript:@"SharedSecret"];
  v92 = (void *)objc_claimAutoreleasedReturnValue();

  unint64_t v12 = v158;
  unint64_t v16 = self;
  if (!v92)
  {
LABEL_130:
    [v9 objectForKeyedSubscript:@"LocalCertificate"];
    v101 = (void *)objc_claimAutoreleasedReturnValue();
    v102 = v101;
    if (v101 && isa_nsdata(v101))
    {
      setLocalCertificate(v102);
      v103 = (__CFString *)objc_claimAutoreleasedReturnValue();
      if (v159) {
        [v159 setMachineIdentityReference:v103];
      }
      else {
        -[os_log_s setIdentityReferenceInternal:](self, "setIdentityReferenceInternal:", v103);
      }
    }

    else
    {
      [v9 objectForKeyedSubscript:@"PayloadCertificateUUID"];
      v104 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v104 || !isa_nsstring(v104))
      {
LABEL_148:
        if (v160
          && (v116 = (const __CFString *)*MEMORY[0x18960C688],
              [v9 objectForKeyedSubscript:*MEMORY[0x18960C688]],
              v117 = (void *)objc_claimAutoreleasedReturnValue(),
              v118 = isa_nsnumber(v117),
              v117,
              v118))
        {
          v119 = v9;
          v120 = v116;
        }

        else
        {
          if (!v161
            || ([v9 objectForKeyedSubscript:@"ExtendedAuthEnabled"],
                v121 = (void *)objc_claimAutoreleasedReturnValue(),
                v122 = isa_nsnumber(v121),
                v121,
                !v122))
          {
LABEL_155:
            [v9 objectForKeyedSubscript:@"LocalIdentifier"];
            v124 = (void *)objc_claimAutoreleasedReturnValue();

            if (v124 && isa_nsstring(v124))
            {
              v125 = (os_log_s *)v159;
              if (!v159) {
                v125 = self;
              }
              -[os_log_s setLocalIdentifier:](v125, "setLocalIdentifier:", v124);
            }

            if (v161)
            {
              [v9 objectForKeyedSubscript:@"RemoteIdentifier"];
              v126 = (void *)objc_claimAutoreleasedReturnValue();
            }

            else
            {
              v126 = v124;
            }

            [v9 objectForKeyedSubscript:@"AuthenticationMethod"];
            v127 = (void *)objc_claimAutoreleasedReturnValue();

            if (isa_nsstring(v127))
            {
              if ([v127 isEqualToString:@"SharedSecret"])
              {
                v128 = v159;
                if (v159)
                {
                  v129 = 1LL;
LABEL_173:
                  [v128 setMachineAuthenticationMethod:v129];
                  goto LABEL_185;
                }

                v135 = self;
                v136 = 2LL;
LABEL_184:
                -[os_log_s setAuthenticationMethod:](v135, "setAuthenticationMethod:", v136);
                goto LABEL_185;
              }

              if ([v127 isEqualToString:@"Certificate"])
              {
                v128 = v159;
                if (v159)
                {
                  v129 = 2LL;
                  goto LABEL_173;
                }

                v135 = self;
                v136 = 1LL;
                goto LABEL_184;
              }

              v133 = [v127 isEqualToString:@"None"];
              v130 = v161;
              if (!v161 || (v133 & 1) == 0)
              {
                ne_log_obj();
                v134 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
                {
                  v150 = (id)objc_opt_class();
                  *(_DWORD *)buf = 138412546;
                  v168 = v150;
                  v169 = 2112;
                  v170 = v127;
                  _os_log_error_impl( &dword_1876B1000,  v134,  OS_LOG_TYPE_ERROR,  "%@ configureIKE: unsupported authentication type %@.",  buf,  0x16u);
                }

LABEL_185:
                if (v161)
                {
LABEL_186:
                  [v9 objectForKeyedSubscript:@"IncludeAllNetworks"];
                  v131 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_188:
                }

          CFRelease((CFTypeRef)a3);
          return;
        }

        if (*(_BYTE *)(v3 + 2))
        {
          unint64_t v16 = (os_log_s *)ne_log_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
          {
            unsigned __int16 v17 = strerror(*(unsigned __int8 *)(v3 + 2));
            __int16 v18 = *(unsigned __int8 *)(v3 + 1);
            *(_DWORD *)buf = 138412802;
            v158 = a3;
            v159 = 2080;
            *(void *)v160 = v17;
            *(_WORD *)&v160[8] = 1024;
            *(_DWORD *)v161 = v18;
            _os_log_impl( &dword_1876B1000,  v16,  OS_LOG_TYPE_INFO,  "%@ Received PFKey Message reporting error: %s (type %d)",  buf,  0x1Cu);
          }

          unint64_t v19 = *(unsigned __int8 *)(v3 + 1);
          switch(*(_BYTE *)(v3 + 1))
          {
            case 1:
            case 3:
              BOOL v20 = *(__CFDictionary **)(a3 + 80);
              goto LABEL_74;
            case 2:
              uint64_t v51 = v156[0];
              uint64_t v52 = *(dispatch_semaphore_s **)(a3 + 96);
              unint64_t v19 = 2;
              goto LABEL_70;
            case 4:
              uint64_t v51 = v156[0];
              uint64_t v52 = *(dispatch_semaphore_s **)(a3 + 96);
              unint64_t v19 = 4;
              goto LABEL_70;
            case 5:
              uint64_t v51 = v156[0];
              uint64_t v52 = *(dispatch_semaphore_s **)(a3 + 96);
              unint64_t v19 = 5;
              goto LABEL_70;
            case 6:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
            case 0xD:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
              goto LABEL_141;
            case 0xE:
              BOOL v20 = *(__CFDictionary **)(a3 + 88);
LABEL_74:
              NERemoveValueFromIntKeyedDictionary(v20, v156[0]);
              uint64_t v54 = *(unsigned __int8 *)(v3 + 1);
              BOOL v55 = v156[0];
              unint64_t v56 = *(dispatch_semaphore_s **)(a3 + 96);
              goto LABEL_76;
            case 0xF:
            case 0x16:
              NEIPSecDBNotifyRequest(*(dispatch_semaphore_s **)(a3 + 96), v19, v156[0], 0, 0LL);
              uint64_t v49 = *(unsigned __int8 *)(v3 + 2);
              if (v49 == 22 || v49 == 2) {
                goto LABEL_62;
              }
              goto LABEL_141;
            case 0x10:
              BOOL v55 = v156[0];
              unint64_t v56 = *(dispatch_semaphore_s **)(a3 + 96);
              uint64_t v54 = 16;
LABEL_76:
              unint64_t v57 = 0;
              goto LABEL_140;
            default:
              if (v19 != 26) {
                goto LABEL_141;
              }
              uint64_t v51 = v156[0];
              uint64_t v52 = *(dispatch_semaphore_s **)(a3 + 96);
LABEL_70:
              NEIPSecDBNotifyRequest(v52, v19, v51, 0, 0LL);
              if (*(_BYTE *)(v3 + 2) != 2) {
                goto LABEL_141;
              }
              uint64_t v50 = *(__CFDictionary **)(a3 + 80);
              break;
          }

LABEL_189:
                if (!-[NEConfiguration ingestDisconnectOptions:](v157, v9))
                {

                  goto LABEL_194;
                }

                ne_log_obj();
                v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v137, OS_LOG_TYPE_DEBUG))
                {
                  v139 = (id)objc_opt_class();
                  [v157 VPN];
                  v140 = (void *)objc_claimAutoreleasedReturnValue();
                  [v140 protocol];
                  v141 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)buf = 138412546;
                  v168 = v139;
                  v169 = 2112;
                  v170 = v141;
                  _os_log_debug_impl( &dword_1876B1000,  v137,  OS_LOG_TYPE_DEBUG,  "%@ configureIKE, done with %@",  buf,  0x16u);
                }

                v115 = 1LL;
                goto LABEL_196;
              }
            }

            else
            {
              v130 = v161;
              if (!v161)
              {
                if (v127)
                {
                  ne_log_obj();
                  v131 = (void *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled((os_log_t)v131, OS_LOG_TYPE_ERROR))
                  {
                    v132 = (id)objc_opt_class();
                    *(_DWORD *)buf = 138412546;
                    v168 = v132;
                    v169 = 2112;
                    v170 = v127;
                    _os_log_error_impl( &dword_1876B1000,  (os_log_t)v131,  OS_LOG_TYPE_ERROR,  "%@ configureIKE: unsupported authentication type %@.",  buf,  0x16u);
                  }

                  goto LABEL_188;
                }

                goto LABEL_189;
              }
            }

            [v130 setAuthenticationMethod:0];
            goto LABEL_186;
          }

          v120 = @"ExtendedAuthEnabled";
          v119 = v9;
        }

        [v119 objectForKeyedSubscript:v120];
        v123 = (void *)objc_claimAutoreleasedReturnValue();
        -[os_log_s setUseExtendedAuthentication:]( self,  "setUseExtendedAuthentication:",  [v123 BOOLValue]);

        goto LABEL_155;
      }

      v105 = @"_PayloadMachineCertificateRef";
      if (!v159) {
        v105 = @"_PayloadCertificateRef";
      }
      v103 = v105;
      v107 = objc_getProperty(self, v106, 88LL, 1);
      [v11 addCertificatePending:v104 certificateTag:v103 accessGroup:v107];

      v102 = v104;
    }

    v104 = v102;
    goto LABEL_148;
  }

  if (isa_nsdata(v92))
  {
    v93 = [objc_alloc(NSString) initWithData:v92 encoding:4];

    v92 = (void *)v93;
    goto LABEL_126;
  }

  if ((isa_nsstring(v92) & 1) != 0)
  {
LABEL_126:
    v95 = objc_alloc(&OBJC_CLASS___NEKeychainItem);
    if (v159)
    {
      v96 = v159[10];
      v97 = objc_getProperty(v159, v94, 88LL, 1);
      v98 = -[NEKeychainItem initWithPassword:domain:accessGroup:]( v95,  "initWithPassword:domain:accessGroup:",  v92,  v96,  v97);
      v99 = (os_log_s *)v159;
    }

    else
    {
      v100 = *((void *)self + 10);
      v97 = objc_getProperty(self, v94, 88LL, 1);
      v98 = -[NEKeychainItem initWithPassword:domain:accessGroup:]( v95,  "initWithPassword:domain:accessGroup:",  v92,  v100,  v97);
      v99 = self;
    }

    -[os_log_s setSharedSecretKeychainItem:](v99, "setSharedSecretKeychainItem:", v98);

    goto LABEL_130;
  }

  ne_log_obj();
  v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
  {
    v144 = (void *)objc_opt_class();
    v145 = v144;
    v146 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412546;
    v168 = v144;
    v169 = 2112;
    v170 = v146;
    v147 = v146;
    _os_log_error_impl( &dword_1876B1000,  v108,  OS_LOG_TYPE_ERROR,  "%@ configureIKE: unsupported shared secret data type %@",  buf,  0x16u);
  }

LABEL_194:
LABEL_195:
  v115 = 0LL;
LABEL_196:

  return v115;
}

LABEL_52:
          if ((-[os_log_s isEqualToString:](v13, "isEqualToString:", @"IPSec") & 1) == 0
            && (-[os_log_s isEqualToString:](v13, "isEqualToString:", @"L2TP") & 1) == 0
            && !-[os_log_s isEqualToString:](v13, "isEqualToString:", @"IKEv2"))
          {
            goto LABEL_178;
          }

          [a1 VPN];
          unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
          int64_t v43 = -[NEConfiguration ingestIPSecDict:vpnType:vpn:](a1, v9, v13, v42);

          if (v43)
          {
            [v10 objectForKeyedSubscript:@"VPNSubType"];
            uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
            [v10 objectForKeyedSubscript:@"IKEv2"];
            uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
            [a1 VPN];
            v147 = v19;
            uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
            [v46 protocol];
            int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
            v150 = ingestIKEv2Dict(v44, v45, v47);

            unint64_t v14 = v153;
            unint64_t v19 = v147;

            if (v150)
            {
LABEL_178:
              if ((-[os_log_s isEqualToString:](v13, "isEqualToString:", @"VPN") & 1) != 0
                || -[os_log_s isEqualToString:](v13, "isEqualToString:", @"TransparentProxy"))
              {
                [v10 objectForKeyedSubscript:@"VPNSubType"];
                uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue();
                if (-[os_log_s isEqualToString:](v13, "isEqualToString:", @"VPN"))
                {
                  v151 = v48;
                  [v10 objectForKeyedSubscript:v13];
                  uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
                  [v49 objectForKeyedSubscript:@"ProviderType"];
                  uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();

                  if (isa_nsstring(v50)
                    && [v50 isEqualToString:@"app-proxy"])
                  {
                    [a1 VPN];
                    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
                    uint64_t v52 = v51;
                    uint64_t v53 = 2LL;
                  }

                  else
                  {
                    [a1 VPN];
                    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
                    uint64_t v52 = v51;
                    uint64_t v53 = 1LL;
                  }

                  [v51 setTunnelType:v53];

                  uint64_t v48 = v151;
                }

                else
                {
                  [a1 VPN];
                  uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
                  [v50 setTunnelType:2];
                }

                uint64_t v60 = -[NEConfiguration configurePluginWithPayload:pluginType:payloadType:vpnType:]( a1,  v9,  v48,  @"com.apple.vpn.managed",  v13);
                if (!v60) {
                  goto LABEL_80;
                }
              }

              if (!-[NEConfiguration configureVpnOnDemand:vpnType:](a1, v10, v13))
              {
LABEL_80:
                unint64_t v14 = v153;
              }

              else
              {
                uint64_t v61 = v19;
                [v10 objectForKeyedSubscript:@"PayloadCertificateHash"];
                uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue();
                uint64_t v63 = isa_nsdata(v62);

                if (v63)
                {
                  [v10 objectForKeyedSubscript:@"PayloadCertificateHash"];
                  uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
                  [a1 VPN];
                  uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue();
                  [v65 protocol];
                  uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue();
                  [v66 setIdentityDataHash:v64];
                }

                unint64_t v14 = v153;
                unint64_t v19 = v61;
                if (-[NEConfiguration ingestDNSOptions:](a1, v10)
                  && -[NEConfiguration ingestProxyOptions:](a1, v10))
                {
                  ne_log_obj();
                  uint64_t v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
                  {
                    v94 = (void *)objc_opt_class();
                    v152 = v94;
                    [a1 VPN];
                    v148 = (void *)objc_claimAutoreleasedReturnValue();
                    [v148 protocol];
                    v145 = (void *)objc_claimAutoreleasedReturnValue();
                    [v145 serverAddress];
                    v95 = (__CFString *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)buf = 138412546;
                    v156 = v94;
                    unint64_t v14 = v153;
                    v157 = 2112;
                    v158 = v95;
                    _os_log_debug_impl( &dword_1876B1000,  v67,  OS_LOG_TYPE_DEBUG,  "%@ initWithVPNPayload: done, serverAddress %@",  buf,  0x16u);

                    unint64_t v19 = v61;
                  }

                  a1 = a1;
                  uint64_t v34 = a1;
LABEL_42:

                  goto LABEL_43;
                }
              }
            }
          }

  ne_log_obj();
  __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)data = 136315138;
    *(void *)&data[4] = a3;
    _os_log_debug_impl(&dword_1876B1000, v27, OS_LOG_TYPE_DEBUG, "Not hashing value with type %s", data, 0xCu);
  }
}

    ne_log_obj();
    unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_53;
    }
    v106 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412290;
    v170 = v106;
    unint64_t v56 = v106;
    unint64_t v57 = "%@ invalid identity reference";
    goto LABEL_89;
  }

  unint64_t v31 = CFGetTypeID(result);
  if (v31 != SecIdentityGetTypeID())
  {
    ne_log_obj();
    uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      v105 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412290;
      v170 = v105;
      v86 = v105;
      v87 = "%@ failed to find valid identity item in the keychain.";
      goto LABEL_87;
    }

    goto LABEL_52;
  }

  if (v19) {
    goto LABEL_23;
  }
  v110 = (__SecIdentity *)result;
  certificateRef[0] = 0LL;
  *(void *)trust = 0LL;
  BasicX509 = SecPolicyCreateBasicX509();
  if (BasicX509)
  {
    v112 = BasicX509;
    if (SecIdentityCopyCertificate(v110, certificateRef) || !certificateRef[0])
    {
      ne_log_obj();
      v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v115, OS_LOG_TYPE_ERROR)) {
        goto LABEL_149;
      }
      v129 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412290;
      v170 = v129;
      v117 = v129;
      v118 = "%@ SecIdentityCopyCertificate() failed";
    }

    else
    {
      v113 = CFArrayCreate(0LL, (const void **)certificateRef, 1LL, MEMORY[0x189605228]);
      CFRelease(certificateRef[0]);
      if (v113)
      {
        v114 = SecTrustCreateWithCertificates(v113, v112, (SecTrustRef *)trust);
        CFRelease(v113);
        if (v114)
        {
          ne_log_obj();
          v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          unint64_t v2 = 0x189604000LL;
          if (!os_log_type_enabled(v115, OS_LOG_TYPE_ERROR)) {
            goto LABEL_149;
          }
          v116 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412290;
          v170 = v116;
          v117 = v116;
          v118 = "%@ SecTrustCreateWithCertificates() failed";
        }

        else if (MEMORY[0x1895AC3C0](*(void *)trust, v161))
        {
          ne_log_obj();
          v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          unint64_t v2 = 0x189604000LL;
          if (!os_log_type_enabled(v115, OS_LOG_TYPE_ERROR)) {
            goto LABEL_149;
          }
          v135 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412290;
          v170 = v135;
          v117 = v135;
          v118 = "%@ SecTrustEvaluate() failed";
        }

        else
        {
          CertificateCount = SecTrustGetCertificateCount(*(SecTrustRef *)trust);
          if (CertificateCount > 1)
          {
            objc_msgSend( MEMORY[0x189603FC8],  "dictionaryWithObjectsAndKeys:",  v28,  *MEMORY[0x18960BE28],  *MEMORY[0x18960BB40],  v29,  0);
            v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v153 = objc_alloc_init(MEMORY[0x189603FA8]);
            v151 = *MEMORY[0x18960BE88];
            v146 = 1LL;
            while (1)
            {
              cf = 0LL;
              -[os_log_s setObject:forKeyedSubscript:]( v115,  "setObject:forKeyedSubscript:",  SecTrustGetCertificateAtIndex(*(SecTrustRef *)trust, v146),  v151);
              if (SecItemCopyMatching(v115, &cf)) {
                break;
              }
              [v153 addObject:cf];
              CFRelease(cf);
              if (CertificateCount == ++v146)
              {
                [(id)v1 eapSettings];
                v147 = (void *)objc_claimAutoreleasedReturnValue();
                [v147 setClientTrustChainReference:v153];
                goto LABEL_147;
              }
            }

            ne_log_obj();
            v147 = (void *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled((os_log_t)v147, OS_LOG_TYPE_ERROR))
            {
              v149 = (void *)objc_opt_class();
              *(_DWORD *)buf = 138412290;
              v170 = v149;
              v150 = v149;
              _os_log_error_impl( &dword_1876B1000,  (os_log_t)v147,  OS_LOG_TYPE_ERROR,  "%@ SecItemCopyMatching() failed",  buf,  0xCu);
            }

LABEL_39:
          ne_log_obj();
          uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            uint64_t v54 = (void *)objc_opt_class();
            *(_DWORD *)buf = 138412290;
            v156 = v54;
            BOOL v55 = v19;
            unint64_t v56 = v14;
            unint64_t v57 = v54;
            _os_log_error_impl(&dword_1876B1000, v35, OS_LOG_TYPE_ERROR, "%@ initWithVPNPayload: failed", buf, 0xCu);

            unint64_t v14 = v56;
            unint64_t v19 = v55;
          }

          uint64_t v34 = 0LL;
          goto LABEL_42;
        }

        v146 = v19;
        unint64_t v22 = v10;
        v149 = v13;
        uint64_t v23 = -[os_log_s objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"PPP");
        ne_log_obj();
        unint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          size_t v70 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412546;
          v156 = v70;
          v157 = 2112;
          v158 = (const __CFString *)v149;
          unint64_t v71 = v70;
          _os_log_debug_impl(&dword_1876B1000, v24, OS_LOG_TYPE_DEBUG, "%@ ingestPPPData for %@", buf, 0x16u);
        }

        v144 = (void *)v23;
        if (!v23) {
          goto LABEL_27;
        }
        if (!-[os_log_s isEqualToString:](v149, "isEqualToString:", @"L2TP"))
        {
LABEL_104:

          unint64_t v14 = v153;
          unint64_t v19 = v146;
          goto LABEL_38;
        }

        v143 = v22;
        -[NEConfiguration getConfigurationProtocol](a1);
        BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
        ne_log_obj();
        unint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_debug_impl(&dword_1876B1000, v26, OS_LOG_TYPE_DEBUG, "configureL2TPwithPPPOptions", buf, 2u);
        }

        [a1 appVPN];
        __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();

        if (v27) {
          goto LABEL_26;
        }
        if (v25)
        {
LABEL_20:
          v142 = v143;
          v141 = -[NEConfiguration getConfigurationProtocol](a1);
          ne_log_obj();
          unint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_debug_impl(&dword_1876B1000, v28, OS_LOG_TYPE_DEBUG, "configurePPPCommon start", buf, 2u);
          }

          [a1 appVPN];
          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();

          if (v29 || [a1 grade] == 2)
          {
            uint64_t v30 = 0LL;
LABEL_25:

LABEL_26:
            goto LABEL_27;
          }

          v140 = v25;
          [a1 VPN];
          v83 = (void *)objc_claimAutoreleasedReturnValue();
          if (v83) {
            uint64_t v84 = v141 == 0LL;
          }
          else {
            uint64_t v84 = 1;
          }
          uint64_t v85 = !v84;

          if ((v85 & 1) == 0)
          {
            ne_log_obj();
            v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl( &dword_1876B1000,  v92,  OS_LOG_TYPE_ERROR,  "configurePPPCommon failed: VPN not initialized",  buf,  2u);
            }

            v93 = 0LL;
            goto LABEL_132;
          }

          v136 = v85;
          -[os_log_s objectForKeyedSubscript:](v142, "objectForKeyedSubscript:", @"PPP");
          v139 = (id)objc_claimAutoreleasedReturnValue();
          self = -[NEConfiguration getConfigurationProtocol](a1);
          ne_log_large_obj();
          v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_debug_impl(&dword_1876B1000, v86, OS_LOG_TYPE_DEBUG, "ingestPPPDict start", buf, 2u);
          }

          [a1 appVPN];
          v87 = (void *)objc_claimAutoreleasedReturnValue();

          if (v87 || [a1 grade] == 2)
          {
LABEL_98:

            unint64_t v88 = v142;
            v89 = -[os_log_s objectForKeyedSubscript:](v142, "objectForKeyedSubscript:", @"IPv4");
            if (isa_nsdictionary(v89))
            {
              CFErrorRef v90 = -[NEIPv4Settings initFromLegacyDictionary:]( objc_alloc(&OBJC_CLASS___NEIPv4Settings),  "initFromLegacyDictionary:",  v89);
              if (v90)
              {
                [v141 setIPv4Settings:v90];
              }

              else
              {
                ne_log_large_obj();
                v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
                {
                  *(_WORD *)buf = 0;
                  _os_log_debug_impl( &dword_1876B1000,  v103,  OS_LOG_TYPE_DEBUG,  "configurePPPCommon: IPv4 settings are Off for payload dictionary",  buf,  2u);
                }
              }

              unint64_t v88 = v142;
            }

            -[os_log_s objectForKeyedSubscript:](v88, "objectForKeyedSubscript:", @"IPv6");
            uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();

            if (!isa_nsdictionary(v30))
            {
              BOOL v25 = v140;
              goto LABEL_25;
            }

            v93 = v30;
            v104 = -[NEIPv6Settings initFromLegacyDictionary:]( objc_alloc(&OBJC_CLASS___NEIPv6Settings),  "initFromLegacyDictionary:",  v30);
            if (v104)
            {
              v92 = v104;
              [v141 setIPv6Settings:v104];
            }

            else
            {
              ne_log_obj();
              v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_error_impl( &dword_1876B1000,  v105,  OS_LOG_TYPE_ERROR,  "configurePPPCommon: invalid IPv6 dictionary",  buf,  2u);
              }

              v92 = 0LL;
            }

            uint64_t v85 = v136;
LABEL_132:

            if ((v85 & 1) == 0) {
              goto LABEL_104;
            }
LABEL_27:

            unint64_t v14 = v153;
            unint64_t v19 = v146;
            if ((-[NEConfiguration configurePPPWithVPNOptions:payloadBase:](a1, v22, v9) & 1) == 0) {
              goto LABEL_39;
            }
            goto LABEL_52;
          }

          [a1 VPN];
          v96 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v96 || !self)
          {
            ne_log_obj();
            log = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl( &dword_1876B1000,  log,  OS_LOG_TYPE_ERROR,  "ingestPPPDict failed: VPN not initialized",  buf,  2u);
            }

            goto LABEL_138;
          }

          if (!v139)
          {
LABEL_139:

            unint64_t v91 = v140;
            objc_super v81 = v142;
            goto LABEL_103;
          }

          [v139 objectForKeyedSubscript:@"CommRemoteAddress"];
          v97 = (void *)objc_claimAutoreleasedReturnValue();
          v98 = v97;
          [v139 objectForKeyedSubscript:@"AuthName"];
          v99 = (void *)objc_claimAutoreleasedReturnValue();

          [v139 objectForKeyedSubscript:@"AuthPassword"];
          v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();

          log = v100;
          if (v100)
          {
            if (isa_nsdata(v100))
            {
              v101 = (void *)[objc_alloc(NSString) initWithData:v100 encoding:4];

              v102 = v101;
LABEL_149:
              v108 = v102;
              loga = objc_alloc(&OBJC_CLASS___NEKeychainItem);
              v109 = self[10];
              v133 = objc_getProperty(self, v110, 88LL, 1);
              v111 = -[NEKeychainItem initWithPassword:domain:accessGroup:]( loga,  "initWithPassword:domain:accessGroup:",  v108,  v109,  v133);
              [self setPasswordKeychainItem:v111];

              [self setAuthenticationMethod:1];
              log = v108;

LABEL_150:
              [v139 objectForKeyedSubscript:@"VerboseLogging"];
              v112 = (void *)objc_claimAutoreleasedReturnValue();
              v113 = isa_nsnumber(v112);

              if (v113)
              {
                [v139 objectForKeyedSubscript:@"VerboseLogging"];
                v114 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(self, "setVerboseLoggingEnabled:", objc_msgSend(v114, "BOOLValue"));
              }

              -[NEConfiguration ingestDisconnectOptions:](a1, v139);
              ne_log_obj();
              v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v115, OS_LOG_TYPE_DEBUG))
              {
                v117 = (void *)objc_opt_class();
                *(_DWORD *)buf = 138412290;
                v156 = v117;
                v118 = v117;
                _os_log_debug_impl(&dword_1876B1000, v115, OS_LOG_TYPE_DEBUG, "%@ ingestPPPDict: done", buf, 0xCu);
              }

              goto LABEL_98;
            }

            if ((isa_nsstring(v100) & 1) != 0)
            {
              v102 = v100;
              goto LABEL_149;
            }

            ne_log_obj();
            v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR))
            {
              v123 = (void *)objc_opt_class();
              v124 = v123;
              v125 = (__CFString *)objc_opt_class();
              *(_DWORD *)buf = 138412546;
              v156 = v123;
              v157 = 2112;
              v158 = v125;
              v126 = v125;
              _os_log_error_impl( &dword_1876B1000,  v116,  OS_LOG_TYPE_ERROR,  "%@ ingestPPPDict: unsupported password data type %@",  buf,  0x16u);
            }

            goto LABEL_138;
          }

          [v139 objectForKeyedSubscript:@"AuthProtocol"];
          log = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (isa_nsarray(log)
            && -[os_log_s containsObject:](log, "containsObject:", @"EAP"))
          {
            [v139 objectForKeyedSubscript:@"AuthEAPPlugins"];
            v106 = (void *)objc_claimAutoreleasedReturnValue();
            [v106 objectAtIndexedSubscript:0];
            v132 = (void *)objc_claimAutoreleasedReturnValue();
            if (!isa_nsstring(v132))
            {
LABEL_169:

LABEL_170:
LABEL_171:
              [v139 objectForKeyedSubscript:@"TokenCard"];
              v127 = (void *)objc_claimAutoreleasedReturnValue();
              v128 = isa_nsnumber(v127);

              if (v128) {
                [self setAuthenticationMethod:5];
              }
              goto LABEL_150;
            }

            if ([v132 isEqualToString:@"EAP-RSA"])
            {
              v107 = 2LL;
LABEL_168:
              [self setAuthenticationMethod:v107];
              goto LABEL_169;
            }

            if ([v132 isEqualToString:@"EAP-TLS"])
            {
              v107 = 3LL;
              goto LABEL_168;
            }

            if ([v132 isEqualToString:@"EAP-KRB"])
            {
              v107 = 4LL;
              goto LABEL_168;
            }

            ne_log_obj();
            v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
            {
              v130 = (void *)objc_opt_class();
              *(_DWORD *)buf = 138412802;
              v156 = v130;
              v157 = 2112;
              v158 = @"AuthEAPPlugins";
              v159 = 2112;
              v160 = v132;
              v131 = v130;
              _os_log_error_impl( &dword_1876B1000,  v129,  OS_LOG_TYPE_ERROR,  "%@ ingestPPPDict: unsupported %@ type %@",  buf,  0x20u);
            }

            v122 = v132;
          }

          else
          {
            if (!log) {
              goto LABEL_171;
            }
            ne_log_obj();
            v106 = (void *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled((os_log_t)v106, OS_LOG_TYPE_ERROR)) {
              goto LABEL_157;
            }
            v119 = (void *)objc_opt_class();
            v137 = v119;
            v120 = (void *)objc_opt_class();
            *(_DWORD *)buf = 138412802;
            v156 = v119;
            v157 = 2112;
            v158 = @"AuthProtocol";
            v159 = 2112;
            v160 = v120;
            v121 = v120;
            _os_log_error_impl( &dword_1876B1000,  (os_log_t)v106,  OS_LOG_TYPE_ERROR,  "%@ ingestPPPDict: invalid %@ type %@",  buf,  0x20u);

            v122 = v137;
          }

LABEL_157:
LABEL_138:

          goto LABEL_139;
        }

        [a1 VPN];
        uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue();

        if (v74)
        {
          [a1 VPN];
          unint64_t v75 = (void *)objc_claimAutoreleasedReturnValue();
          [v75 protocol];
          uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v76)
          {
            unint64_t v77 = objc_alloc_init(&OBJC_CLASS___NEVPNProtocolL2TP);
            [a1 VPN];
            unint64_t v78 = (void *)objc_claimAutoreleasedReturnValue();
            [v78 setProtocol:v77];
          }

          [a1 VPN];
          uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
          [v79 protocol];
          uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();

          if (v80) {
            goto LABEL_20;
          }
          ne_log_obj();
          objc_super v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            uint64_t v82 = "configureL2TPwithPPPOptions failed to allocate for L2TP";
LABEL_135:
            _os_log_error_impl(&dword_1876B1000, v81, OS_LOG_TYPE_ERROR, v82, buf, 2u);
          }
        }

        else
        {
          ne_log_obj();
          objc_super v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            uint64_t v82 = "configureL2TPwithPPPOptions failed: app-layer VPN not supported";
            goto LABEL_135;
          }
        }

        unint64_t v91 = 0LL;
LABEL_103:

        goto LABEL_104;
      }

      ne_log_obj();
      unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        uint64_t v38 = (void *)objc_opt_class();
        *(_DWORD *)buf = 138412546;
        v156 = v38;
        v157 = 2112;
        v158 = v8;
        unint64_t v39 = v38;
        unint64_t v40 = "%@ initWithVPNPayload failed, can't create VPN for config '%@'";
LABEL_67:
        _os_log_error_impl(&dword_1876B1000, v22, OS_LOG_TYPE_ERROR, v40, buf, 0x16u);
      }
    }

    else
    {
      ne_log_obj();
      unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        uint64_t v59 = (void *)objc_opt_class();
        *(_DWORD *)buf = 138412546;
        v156 = v59;
        v157 = 2112;
        v158 = (const __CFString *)v13;
        unint64_t v39 = v59;
        unint64_t v40 = "%@ initWithVPNPayload : VPN type '%@' not supported";
        goto LABEL_67;
      }
    }

    unint64_t v19 = 0LL;
LABEL_38:

    goto LABEL_39;
  }

  ne_log_obj();
  unsigned __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    unint64_t v58 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412290;
    v156 = v58;
    unint64_t v32 = v58;
    unint64_t v33 = "%@ initWithVPNPayload: couldn't extract VPN type from payload";
    goto LABEL_65;
  }

LABEL_45:
    uint64_t v35 = 0LL;
    goto LABEL_46;
  }

  uint64_t v68 = a4;
  unint64_t v75 = 0u;
  uint64_t v76 = 0u;
  unint64_t v73 = 0u;
  uint64_t v74 = 0u;
  unint64_t v11 = v11;
  unint64_t v12 = -[os_log_s countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v73,  v82,  16LL);
  if (!v12) {
    goto LABEL_29;
  }
  unsigned __int16 v13 = v12;
  unint64_t v14 = *(void *)v74;
  uint64_t v66 = v8;
  uint64_t v67 = v7;
  uint64_t v64 = *(void *)v74;
  uint64_t v65 = v9;
  while (2)
  {
    for (i = 0LL; i != v13; ++i)
    {
      if (*(void *)v74 != v14) {
        objc_enumerationMutation(v11);
      }
      unint64_t v16 = *(void **)(*((void *)&v73 + 1) + 8 * i);
      if ((isa_nsdictionary(v16) & 1) == 0)
      {
        ne_log_obj();
        __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v49 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412290;
          unint64_t v78 = v49;
          uint64_t v50 = v49;
          _os_log_error_impl( &dword_1876B1000,  v18,  OS_LOG_TYPE_ERROR,  "%@ initWithPathControllerPayload: ApplicationRules malformed",  buf,  0xCu);
        }

LABEL_40:
      goto LABEL_41;
    }

    if (isa_nsarray(v8))
    {
      uint64_t v9 = v8;
      uint64_t v50 = 0u;
      uint64_t v51 = 0u;
      uint64_t v52 = 0u;
      uint64_t v53 = 0u;
      unint64_t v22 = [v9 countByEnumeratingWithState:&v50 objects:v64 count:16];
      if (v22)
      {
        uint64_t v23 = v22;
        unint64_t v24 = *(void *)v51;
        do
        {
          for (k = 0LL; k != v23; ++k)
          {
            if (*(void *)v51 != v24) {
              objc_enumerationMutation(v9);
            }
            -[NEHasher encodeObject:](v5, "encodeObject:", *(void *)(*((void *)&v50 + 1) + 8 * k));
          }

          uint64_t v23 = [v9 countByEnumeratingWithState:&v50 objects:v64 count:16];
        }

        while (v23);
      }

LABEL_64:
          ne_log_obj();
          uint64_t v44 = (id)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_ERROR)) {
            goto LABEL_77;
          }
          int64_t v43 = (os_log_s *)[v3 copyShortDescription];
          objc_super v81 = objc_getProperty(v6, v80, 48LL, 1);
          [v81 proposals];
          uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138413058;
          v210 = v6;
          v211 = 2112;
          v212 = (uint64_t)v43;
          v213 = 2112;
          v214 = (uint64_t)v17;
          v215 = 2112;
          v216 = (uint64_t)v82;
          _os_log_error_impl( &dword_1876B1000,  (os_log_t)v44,  OS_LOG_TYPE_ERROR,  "%@ %@ Received proposal %@ does not match config %@",  buf,  0x2Au);

LABEL_75:
          goto LABEL_76;
        }

        ne_log_obj();
        uint64_t v44 = (id)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_ERROR))
        {
          int64_t v43 = (os_log_s *)[v3 copyShortDescription];
          *(_DWORD *)buf = 138412546;
          v210 = v6;
          v211 = 2112;
          v212 = (uint64_t)v43;
          uint64_t v45 = "%@ %@ Child SA proposal missing SPI";
          uint64_t v46 = (os_log_s *)v44;
          uint64_t v48 = 22;
LABEL_47:
          _os_log_error_impl(&dword_1876B1000, v46, OS_LOG_TYPE_ERROR, v45, buf, v48);
LABEL_76:
        }
      }

      else
      {
        ne_log_obj();
        uint64_t v44 = (id)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_ERROR))
        {
          int64_t v43 = (os_log_s *)[v3 copyShortDescription];
          *(_DWORD *)buf = 138412802;
          v210 = v6;
          v211 = 2112;
          v212 = (uint64_t)v43;
          v213 = 2112;
          v214 = (uint64_t)v17;
          uint64_t v45 = "%@ %@ Received invalid child proposal %@";
          uint64_t v46 = (os_log_s *)v44;
LABEL_46:
          uint64_t v48 = 32;
          goto LABEL_47;
        }
      }
    }

    else
    {
      ne_log_obj();
      unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        goto LABEL_78;
      }
      uint64_t v44 = (id)[v3 copyShortDescription];
      int64_t v47 = -[os_log_s count](v8, "count");
      *(_DWORD *)buf = 138412802;
      v210 = v6;
      v211 = 2112;
      v212 = (uint64_t)v44;
      v213 = 1024;
      LODWORD(v214) = v47;
      _os_log_error_impl( &dword_1876B1000,  v17,  OS_LOG_TYPE_ERROR,  "%@ %@ Received %u child SA proposals, require 1",  buf,  0x1Cu);
    }

  unint64_t v16 = v4;
  unsigned __int16 v17 = 0LL;
LABEL_40:
  [v16 sendCallbackSuccess:v17 session:a1];
LABEL_68:
}

              goto LABEL_40;
            }

            [v19 matchSigningIdentifier];
            __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
            unint64_t v28 = [v27 isEqualToString:@"com.apple.mobilenotes"];

            if ((v28 & 1) != 0) {
              goto LABEL_14;
            }
            [v19 matchSigningIdentifier];
            uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
            if ([v29 isEqualToString:@"com.apple.mobilecal"]) {
              goto LABEL_22;
            }
            [v19 matchSigningIdentifier];
            uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
            if ([v30 isEqualToString:@"com.apple.calaccessd"])
            {

LABEL_22:
LABEL_23:
              [v19 matchSigningIdentifier];
              uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
              if (([v23 isEqualToString:@"com.apple.mobilecal"] & 1) == 0) {
                goto LABEL_39;
              }
              [v19 matchDomains];
              unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
              unint64_t v32 = [v31 count];

              if (v32)
              {
                [v19 matchDomains];
                unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
                [v59 setCalendarDomains:v26];
LABEL_17:

                goto LABEL_40;
              }

              goto LABEL_40;
            }

            [v19 matchSigningIdentifier];
            unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v34 = [v33 isEqualToString:@"com.apple.reminders"];

            if ((v34 & 1) != 0) {
              goto LABEL_23;
            }
            [v19 matchSigningIdentifier];
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
            if ([v35 isEqualToString:@"com.apple.MobileAddressBook"])
            {

LABEL_30:
              [v19 matchSigningIdentifier];
              uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
              if (([v23 isEqualToString:@"com.apple.MobileAddressBook"] & 1) == 0) {
                goto LABEL_39;
              }
              [v19 matchDomains];
              uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
              unint64_t v39 = [v38 count];

              if (v39)
              {
                [v19 matchDomains];
                unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
                [v59 setContactsDomains:v26];
                goto LABEL_17;
              }

              goto LABEL_40;
            }

            [v19 matchSigningIdentifier];
            unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v37 = [v36 isEqualToString:@"com.apple.dataaccessd"];

            if (v37) {
              goto LABEL_30;
            }
            [v19 matchSigningIdentifier];
            unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
            if ([v40 isEqualToString:@"com.apple.mobilesafari"])
            {
            }

            else
            {
              [v19 matchSigningIdentifier];
              unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
              unint64_t v42 = [v41 isEqualToString:@"com.apple.webapp"];

              if (!v42)
              {
                [v19 matchSigningIdentifier];
                uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
                uint64_t v46 = [v45 isEqualToString:@"com.apple.swcd"];

                if (v46)
                {
                  [v19 matchDomains];
                  int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
                  uint64_t v48 = [v47 count];

                  if (v48)
                  {
                    [v19 matchDomains];
                    unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
                    [v59 setAssociatedDomains:v26];
                    goto LABEL_17;
                  }
                }

                else
                {
                  [v58 addObject:v19];
                }

                goto LABEL_40;
              }
            }

            [v19 matchSigningIdentifier];
            uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
            if (([v23 isEqualToString:@"com.apple.mobilesafari"] & 1) == 0) {
              goto LABEL_39;
            }
            [v19 matchDomains];
            int64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v44 = [v43 count];

            if (v44)
            {
              [v19 matchDomains];
              unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
              [v59 setSafariDomains:v26];
              goto LABEL_17;
            }

uint64_t ingestIKEv2Dict(void *a1, void *a2, void *a3)
{
  uint64_t v89 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  int v7 = a3;
  id v8 = v7;
  if (v6)
  {
    if (v7)
    {
      [v6 objectForKeyedSubscript:@"DeadPeerDetectionRate"];
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
      int v10 = isa_nsstring(v9);

      if (!v10) {
        goto LABEL_19;
      }
      [v6 objectForKeyedSubscript:@"DeadPeerDetectionRate"];
      unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
      if ([v11 isEqualToString:@"None"])
      {
        uint64_t v12 = 0LL;
      }

      else if ([v11 isEqualToString:@"Low"])
      {
        uint64_t v12 = 1LL;
      }

      else if ([v11 isEqualToString:@"Medium"])
      {
        uint64_t v12 = 2LL;
      }

      else
      {
        if (![v11 isEqualToString:@"High"])
        {
LABEL_18:

LABEL_19:
          [v6 objectForKeyedSubscript:@"ServerCertificateIssuerCommonName"];
          unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
          [v8 setServerCertificateIssuerCommonName:v15];

          [v6 objectForKeyedSubscript:@"ServerCertificateCommonName"];
          unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
          [v8 setServerCertificateCommonName:v16];

          [v6 objectForKeyedSubscript:@"IKESecurityAssociationParameters"];
          unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
          int v18 = isa_nsdictionary(v17);

          if (v18)
          {
            [v6 objectForKeyedSubscript:@"IKESecurityAssociationParameters"];
            unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
            [v8 IKESecurityAssociationParameters];
            BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
            ingestIKEv2SAParameters(v19, v20);
          }

          [v6 objectForKeyedSubscript:@"ChildSecurityAssociationParameters"];
          uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
          int v22 = isa_nsdictionary(v21);

          if (v22)
          {
            [v6 objectForKeyedSubscript:@"ChildSecurityAssociationParameters"];
            uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
            [v8 childSecurityAssociationParameters];
            unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
            ingestIKEv2SAParameters(v23, v24);
          }

          [v6 objectForKeyedSubscript:@"CertificateType"];
          BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
          int v26 = isa_nsstring(v25);

          if (!v26)
          {
LABEL_40:
            [v6 objectForKeyedSubscript:@"UseConfigurationAttributeInternalIPSubnet"];
            uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
            int v30 = isa_nsnumber(v29);

            if (v30)
            {
              [v6 objectForKeyedSubscript:@"UseConfigurationAttributeInternalIPSubnet"];
              unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v8, "setUseConfigurationAttributeInternalIPSubnet:", objc_msgSend(v31, "BOOLValue"));
            }

            [v6 objectForKeyedSubscript:@"DisableMOBIKE"];
            unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
            int v33 = isa_nsnumber(v32);

            if (v33)
            {
              [v6 objectForKeyedSubscript:@"DisableMOBIKE"];
              uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v8, "setDisableMOBIKE:", objc_msgSend(v34, "BOOLValue"));
            }

            [v6 objectForKeyedSubscript:@"DisableRedirect"];
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
            int v36 = isa_nsnumber(v35);

            if (v36)
            {
              [v6 objectForKeyedSubscript:@"DisableRedirect"];
              uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v8, "setDisableRedirect:", objc_msgSend(v37, "BOOLValue"));
            }

            [v6 objectForKeyedSubscript:@"EnablePFS"];
            uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
            int v39 = isa_nsnumber(v38);

            if (v39)
            {
              [v6 objectForKeyedSubscript:@"EnablePFS"];
              unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v8, "setEnablePFS:", objc_msgSend(v40, "BOOLValue"));
            }

            [v6 objectForKeyedSubscript:@"NATKeepAliveOffloadEnable"];
            unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
            if ((isa_nsnumber(v41) & 1) != 0)
            {
              [v6 objectForKeyedSubscript:@"NATKeepAliveOffloadEnable"];
              unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
              char v43 = [v42 BOOLValue];

              if ((v43 & 1) == 0) {
                [v8 setNatKeepAliveOffloadEnable:1];
              }
            }

            else
            {
            }

            if ([v8 natKeepAliveOffloadEnable] == 2)
            {
              [v6 objectForKeyedSubscript:@"NATKeepAliveInterval"];
              uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
              if (!isa_nsnumber(v44))
              {
LABEL_56:

                goto LABEL_57;
              }

              [v6 objectForKeyedSubscript:@"NATKeepAliveInterval"];
              uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
              int v46 = [v45 intValue];

              if (v46 >= 20)
              {
                [v6 objectForKeyedSubscript:@"NATKeepAliveInterval"];
                uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v8, "setNatKeepAliveOffloadInterval:", objc_msgSend(v44, "intValue"));
                goto LABEL_56;
              }
            }

LABEL_57:
            [v6 objectForKeyedSubscript:@"EnableCertificateRevocationCheck"];
            int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
            int v48 = isa_nsnumber(v47);

            if (v48)
            {
              [v6 objectForKeyedSubscript:@"EnableCertificateRevocationCheck"];
              uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v8, "setEnableRevocationCheck:", objc_msgSend(v49, "BOOLValue"));

              if ([v8 enableRevocationCheck])
              {
                [v6 objectForKeyedSubscript:@"StrictCertificateRevocationCheck"];
                uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
                int v51 = isa_nsnumber(v50);

                if (v51)
                {
                  [v6 objectForKeyedSubscript:@"StrictCertificateRevocationCheck"];
                  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v8, "setStrictRevocationCheck:", objc_msgSend(v52, "BOOLValue"));
                }
              }
            }

            [v6 objectForKeyedSubscript:@"TLSMinimumVersion"];
            uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
            int v54 = isa_nsstring(v53);

            if (!v54)
            {
LABEL_70:
              [v6 objectForKeyedSubscript:@"TLSMaximumVersion"];
              unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
              int v58 = isa_nsstring(v57);

              if (!v58) {
                goto LABEL_79;
              }
              [v6 objectForKeyedSubscript:@"TLSMaximumVersion"];
              uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
              if ([v59 isEqualToString:@"1.0"])
              {
                uint64_t v60 = 1LL;
              }

              else if ([v59 isEqualToString:@"1.1"])
              {
                uint64_t v60 = 2LL;
              }

              else
              {
                if (![v59 isEqualToString:@"1.2"])
                {
LABEL_78:

LABEL_79:
                  [v6 objectForKeyedSubscript:@"MTU"];
                  uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
                  int v62 = isa_nsnumber(v61);

                  if (v62)
                  {
                    [v6 objectForKeyedSubscript:@"MTU"];
                    unsigned __int16 v13 = (void *)objc_claimAutoreleasedReturnValue();
                    if ((unint64_t)[v13 unsignedIntegerValue] < 0x3E8
                      || (unint64_t)[v13 unsignedIntegerValue] >= 0x5DD)
                    {
                      ne_log_obj();
                      uint64_t v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                      {
                        v84[0] = 67109632;
                        v84[1] = [v13 intValue];
                        __int16 v85 = 1024;
                        int v86 = 1000;
                        __int16 v87 = 1024;
                        int v88 = 1500;
                        _os_log_error_impl( &dword_1876B1000,  v63,  OS_LOG_TYPE_ERROR,  "invalid mtu size %d, should be between %d and %d",  (uint8_t *)v84,  0x14u);
                      }

                      goto LABEL_85;
                    }

                    objc_msgSend(v8, "setMtu:", objc_msgSend(v13, "unsignedIntegerValue"));
                  }

                  [v6 objectForKeyedSubscript:@"ExtensibleSSOProvider"];
                  uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue();
                  int v66 = isa_nsstring(v65);

                  if (v66)
                  {
                    [v6 objectForKeyedSubscript:@"ExtensibleSSOProvider"];
                    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
                    [v8 setExtensibleSSOProvider:v67];
                  }

                  [v6 objectForKeyedSubscript:@"PPKIdentifier"];
                  uint64_t v68 = (NEVPNIKEv2PPKConfiguration *)objc_claimAutoreleasedReturnValue();
                  if ((isa_nsstring(v68) & 1) != 0)
                  {
                    [v6 objectForKeyedSubscript:@"PPK"];
                    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();
                    int v70 = isa_nsdata(v69);

                    if (!v70)
                    {
LABEL_99:
                      uint64_t v64 = 1LL;
                      goto LABEL_100;
                    }

                    uint64_t v68 = objc_alloc_init(&OBJC_CLASS___NEVPNIKEv2PPKConfiguration);
                    unint64_t v71 = objc_alloc(&OBJC_CLASS___NEKeychainItem);
                    [v6 objectForKeyedSubscript:@"PPK"];
                    uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue();
                    uint64_t v73 = v8[10];
                    id v75 = objc_getProperty(v8, v74, 88LL, 1);
                    unint64_t v77 = -[NEKeychainItem initWithData:domain:accessGroup:]( v71,  "initWithData:domain:accessGroup:",  v72,  v73,  v75);
                    if (v68) {
                      objc_setProperty_atomic_copy(v68, v76, v77, 32LL);
                    }

                    [v6 objectForKeyedSubscript:@"PPKIdentifier"];
                    uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
                    if (v68) {
                      objc_setProperty_atomic_copy(v68, v78, v79, 16LL);
                    }

                    [v6 objectForKeyedSubscript:@"PPKMandatory"];
                    uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();
                    int v81 = isa_nsnumber(v80);

                    if (v81)
                    {
                      [v6 objectForKeyedSubscript:@"PPKMandatory"];
                      uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
                      -[NEVPNIKEv2PPKConfiguration setIsMandatory:]( v68,  "setIsMandatory:",  [v82 BOOLValue]);
                    }

                    [v8 setPpkConfiguration:v68];
                  }

                  goto LABEL_99;
                }

                uint64_t v60 = 3LL;
              }

              [v8 setMaximumTLSVersion:v60];
              goto LABEL_78;
            }

            [v6 objectForKeyedSubscript:@"TLSMinimumVersion"];
            BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();
            if ([v55 isEqualToString:@"1.0"])
            {
              uint64_t v56 = 1LL;
            }

            else if ([v55 isEqualToString:@"1.1"])
            {
              uint64_t v56 = 2LL;
            }

            else
            {
              if (![v55 isEqualToString:@"1.2"])
              {
LABEL_69:

                goto LABEL_70;
              }

              uint64_t v56 = 3LL;
            }

            [v8 setMinimumTLSVersion:v56];
            goto LABEL_69;
          }

          [v6 objectForKeyedSubscript:@"CertificateType"];
          __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
          if ([v27 isEqualToString:@"RSA"])
          {
            uint64_t v28 = 1LL;
          }

          else if ([v27 isEqualToString:@"ECDSA256"])
          {
            uint64_t v28 = 2LL;
          }

          else if ([v27 isEqualToString:@"ECDSA384"])
          {
            uint64_t v28 = 3LL;
          }

          else if ([v27 isEqualToString:@"ECDSA521"])
          {
            uint64_t v28 = 4LL;
          }

          else if ([v27 isEqualToString:@"Ed25519"])
          {
            uint64_t v28 = 5LL;
          }

          else if ([v27 isEqualToString:@"Ed448"])
          {
            uint64_t v28 = 7LL;
          }

          else
          {
            if (![v27 isEqualToString:@"RSA-PSS"])
            {
LABEL_39:

              goto LABEL_40;
            }

            uint64_t v28 = 6LL;
          }

          [v8 setCertificateType:v28];
          goto LABEL_39;
        }

        uint64_t v12 = 3LL;
      }

      [v8 setDeadPeerDetectionRate:v12];
      goto LABEL_18;
    }

    ne_log_obj();
    unsigned __int16 v13 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v84[0]) = 0;
      unint64_t v14 = "ingestIKEv2Dict: uninitialized protocol";
      goto LABEL_10;
    }
  }

  else
  {
    ne_log_obj();
    unsigned __int16 v13 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v84[0]) = 0;
      unint64_t v14 = "ingestIKEv2Dict: empty dictionary";
LABEL_10:
      _os_log_error_impl(&dword_1876B1000, (os_log_t)v13, OS_LOG_TYPE_ERROR, v14, (uint8_t *)v84, 2u);
    }
  }

  return a1;
}

LABEL_58:
    unint64_t v91 = 0LL;
    goto LABEL_59;
  }

  unint64_t v19 = v19;
  unint64_t v91 = v19;
LABEL_59:

  if (v91)
  {
    v135[0] = MEMORY[0x1895F87A8];
    v135[1] = 3221225472LL;
    v135[2] = __47__NEIKEv2Session_Exchange__initiateNewChildSA___block_invoke;
    v135[3] = &unk_18A08D140;
    v109 = v4;
    v136 = v109;
    v137 = a1;
    v138 = v16;
    if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v91, v135) == -1)
    {
      [v109 sendCallbackSuccess:0 session:a1];
      v111 = objc_getProperty(a1, v110, 336LL, 1);
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"create child SA",  v112,  v113,  v114,  v115,  v116,  v117,  v118,  (uint64_t)v134);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v111, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](a1, v120);
      -[NEIKEv2Session resetAll]((uint64_t)a1, v121);
    }
  }

  else
  {
    ne_log_obj();
    v122 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1876B1000, v122, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet", buf, 2u);
    }

    [v4 sendCallbackSuccess:0 session:a1];
    ErrorInternal = (void *)NEIKEv2CreateErrorInternal( @"Failed to create Create Child SA packet",  v123,  v124,  v125,  v126,  v127,  v128,  v129,  (uint64_t)v134);
    -[NEIKEv2ChildSA setState:error:]((uint64_t)v16, 3uLL, ErrorInternal);

    -[NEIKEv2Session reportState](a1, v131);
    -[NEIKEv2Session resetChild:](a1, v16);
  }

LABEL_67:
}

  Property = 0LL;
LABEL_10:
  [Property alwaysOnVPN];
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v12)
  {
    if (self) {
      BOOL v25 = objc_getProperty(self, v13, 56LL, 1);
    }
    else {
      BOOL v25 = 0LL;
    }
    [v25 appVPN];
    int v26 = (void *)objc_claimAutoreleasedReturnValue();

    if (v26)
    {
      if (-[NEVPNProtocol type](v10, "type") != 4
        && -[NEVPNProtocol type](v10, "type") != 1
        && -[NEVPNProtocol type](v10, "type") != 5)
      {
        int v33 = @"Only plugin and IKE protocols are supported with App VPN";
        goto LABEL_29;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        if (self) {
          uint64_t v29 = objc_getProperty(self, v28, 56LL, 1);
        }
        else {
          uint64_t v29 = 0LL;
        }
        [v29 appVPN];
        int v30 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v31 = v30;
        unint64_t v32 = 2LL;
      }

      else
      {
        if (self) {
          char v43 = objc_getProperty(self, v28, 56LL, 1);
        }
        else {
          char v43 = 0LL;
        }
        [v43 appVPN];
        int v30 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v31 = v30;
        unint64_t v32 = 1LL;
      }

      [v30 setTunnelType:v32];

      if (self) {
        uint64_t v45 = objc_getProperty(self, v44, 56LL, 1);
      }
      else {
        uint64_t v45 = 0LL;
      }
      [v45 appVPN];
      int v46 = (void *)objc_claimAutoreleasedReturnValue();
    }

    else
    {
      if (self) {
        uint64_t v38 = objc_getProperty(self, v27, 56LL, 1);
      }
      else {
        uint64_t v38 = 0LL;
      }
      [v38 VPN];
      int v39 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v39)
      {
        if (self) {
          uint64_t v52 = objc_getProperty(self, v40, 56LL, 1);
        }
        else {
          uint64_t v52 = 0LL;
        }
        uint64_t v53 = [v52 contentFilter];
        if (v53
          && (BOOL v55 = (void *)v53, objc_opt_class(), v56 = objc_opt_isKindOfClass(), v55, (v56 & 1) != 0))
        {
          unint64_t v57 = objc_alloc_init(&OBJC_CLASS___NEFilterProviderConfiguration);
          -[NETunnelProviderProtocol pluginType](v10, "pluginType");
          int v58 = (void *)objc_claimAutoreleasedReturnValue();
          -[NEFilterProviderConfiguration setPluginType:](v57, "setPluginType:", v58);

          if (self) {
            uint64_t v60 = objc_getProperty(self, v59, 56LL, 1);
          }
          else {
            uint64_t v60 = 0LL;
          }
          [v60 contentFilter];
          uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
          [v61 setProvider:v57];
        }

        else
        {
          if (self) {
            int v62 = objc_getProperty(self, v54, 56LL, 1);
          }
          else {
            int v62 = 0LL;
          }
          uint64_t v63 = [v62 dnsProxy];
          if (!v63
            || (uint64_t v64 = (void *)v63,
                objc_opt_class(),
                isKindOfClass = objc_opt_isKindOfClass(),
                v64,
                (isKindOfClass & 1) == 0))
          {
            int v33 = @"Configuration does not have a VPN type";
            goto LABEL_29;
          }

          unint64_t v57 = objc_alloc_init(&OBJC_CLASS___NEDNSProxyProviderProtocol);
          -[NETunnelProviderProtocol pluginType](v10, "pluginType");
          int v66 = (void *)objc_claimAutoreleasedReturnValue();
          -[NEFilterProviderConfiguration setPluginType:](v57, "setPluginType:", v66);

          if (self) {
            uint64_t v68 = objc_getProperty(self, v67, 56LL, 1);
          }
          else {
            uint64_t v68 = 0LL;
          }
          [v68 dnsProxy];
          uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
          [v61 setProtocol:v57];
        }

LABEL_52:
        uint64_t v34 = 1;
        goto LABEL_53;
      }

      if (self) {
        unint64_t v41 = objc_getProperty(self, v40, 56LL, 1);
      }
      else {
        unint64_t v41 = 0LL;
      }
      if ([v41 grade] == 2 && -[NEVPNProtocol type](v10, "type") == 2)
      {
        int v33 = @"PPP protocols are not supported with Personal VPN";
        goto LABEL_29;
      }

      if (self) {
        int64_t v47 = objc_getProperty(self, v42, 56LL, 1);
      }
      else {
        int64_t v47 = 0LL;
      }
      [v47 VPN];
      int v46 = (void *)objc_claimAutoreleasedReturnValue();
    }

    int v48 = v46;
    [v46 setProtocol:v10];

    goto LABEL_52;
  }

  unint64_t v14 = [v6 objectForKeyedSubscript:@"interface-name"];
  if (v14)
  {
    unint64_t v16 = (void *)v14;
    if (self) {
      unsigned __int16 v17 = objc_getProperty(self, v15, 56LL, 1);
    }
    else {
      unsigned __int16 v17 = 0LL;
    }
    [v17 alwaysOnVPN];
    int v18 = (void *)objc_claimAutoreleasedReturnValue();
    [v18 interfaceProtocolMapping];
    unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();

    if (v19)
    {
      if (self) {
        uint64_t v21 = objc_getProperty(self, v20, 56LL, 1);
      }
      else {
        uint64_t v21 = 0LL;
      }
      [v21 alwaysOnVPN];
      int v22 = (void *)objc_claimAutoreleasedReturnValue();
      [v22 interfaceProtocolMapping];
      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v24 = (void *)[v23 mutableCopy];
    }

    else
    {
      unint64_t v24 = (void *)[objc_alloc(MEMORY[0x189603FC8]) initWithCapacity:1];
    }

    [v24 setObject:v10 forKeyedSubscript:v16];
    if (self) {
      int v36 = objc_getProperty(self, v35, 56LL, 1);
    }
    else {
      int v36 = 0LL;
    }
    [v36 alwaysOnVPN];
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    [v37 setInterfaceProtocolMapping:v24];

    goto LABEL_52;
  }

  int v33 = @"Missing interface name";
LABEL_29:
  *a4 = v33;

  uint64_t v34 = 0;
LABEL_53:

  return v34;
}

            int v54 = obj;
LABEL_59:

            uint64_t v53 = 1;
            int v7 = v60;
            id v8 = v61;
            goto LABEL_60;
          }
        }

        int v58 = [obj countByEnumeratingWithState:&v75 objects:v86 count:16];
        if (v58) {
          continue;
        }
        break;
      }
    }

    uint64_t v69 = 0u;
    int v70 = 0u;
    uint64_t v67 = 0u;
    uint64_t v68 = 0u;
    unint64_t v57 = v8;
    int v39 = [v57 countByEnumeratingWithState:&v67 objects:v84 count:16];
    if (v39)
    {
      unint64_t v40 = v39;
      uint64_t v59 = *(void *)v68;
      while (2)
      {
        for (k = 0LL; k != v40; ++k)
        {
          if (*(void *)v68 != v59) {
            objc_enumerationMutation(v57);
          }
          unint64_t v42 = *(void **)(*((void *)&v67 + 1) + 8 * k);
          [v42 matchDomains];
          char v43 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v44 = [v43 count];

          if (v44)
          {
            uint64_t v65 = 0u;
            int v66 = 0u;
            uint64_t v63 = 0u;
            uint64_t v64 = 0u;
            uint64_t v45 = obj;
            int v46 = [v45 countByEnumeratingWithState:&v63 objects:v83 count:16];
            if (v46)
            {
              int64_t v47 = v46;
              int v48 = *(void *)v64;
              while (2)
              {
                for (m = 0LL; m != v47; ++m)
                {
                  if (*(void *)v64 != v48) {
                    objc_enumerationMutation(v45);
                  }
                  [*(id *)(*((void *)&v63 + 1) + 8 * m) matchSigningIdentifier];
                  uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
                  [v42 matchSigningIdentifier];
                  int v51 = (void *)objc_claimAutoreleasedReturnValue();
                  uint64_t v52 = [v50 isEqualToString:v51];

                  if ((v52 & 1) != 0)
                  {

                    id v8 = v61;
                    goto LABEL_49;
                  }
                }

                int64_t v47 = [v45 countByEnumeratingWithState:&v63 objects:v83 count:16];
                if (v47) {
                  continue;
                }
                break;
              }
            }

            int v54 = v57;
            goto LABEL_59;
          }

void ingestIKEv2SAParameters(void *a1, void *a2)
{
  id v22 = a1;
  id v3 = a2;
  [v22 objectForKeyedSubscript:@"EncryptionAlgorithm"];
  size_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  int v5 = isa_nsstring(v4);

  if (v5)
  {
    [v22 objectForKeyedSubscript:@"EncryptionAlgorithm"];
    id v6 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v6 isEqualToString:@"DES"])
    {
      uint64_t v7 = 1LL;
    }

    else if ([v6 isEqualToString:@"3DES"])
    {
      uint64_t v7 = 2LL;
    }

    else if ([v6 isEqualToString:@"AES-128"])
    {
      uint64_t v7 = 3LL;
    }

    else if ([v6 isEqualToString:@"AES-256"])
    {
      uint64_t v7 = 4LL;
    }

    else if ([v6 isEqualToString:@"AES-128-GCM"])
    {
      uint64_t v7 = 5LL;
    }

    else if ([v6 isEqualToString:@"AES-256-GCM"])
    {
      uint64_t v7 = 6LL;
    }

    else
    {
      if (![v6 isEqualToString:@"ChaCha20Poly1305"])
      {
LABEL_17:

        goto LABEL_18;
      }

      uint64_t v7 = 7LL;
    }

    [v3 setEncryptionAlgorithm:v7];
    goto LABEL_17;
  }

LABEL_18:
  [v22 objectForKeyedSubscript:@"IntegrityAlgorithm"];
  id v8 = (void *)objc_claimAutoreleasedReturnValue();
  int v9 = isa_nsstring(v8);

  if (!v9) {
    goto LABEL_31;
  }
  [v22 objectForKeyedSubscript:@"IntegrityAlgorithm"];
  int v10 = (void *)objc_claimAutoreleasedReturnValue();
  if ([v10 isEqualToString:@"SHA1-96"])
  {
    uint64_t v11 = 1LL;
LABEL_29:
    [v3 setIntegrityAlgorithm:v11];
    goto LABEL_30;
  }

  if ([v10 isEqualToString:@"SHA1-160"])
  {
    uint64_t v11 = 2LL;
    goto LABEL_29;
  }

  if ([v10 isEqualToString:@"SHA2-256"])
  {
    uint64_t v11 = 3LL;
    goto LABEL_29;
  }

  if ([v10 isEqualToString:@"SHA2-384"])
  {
    uint64_t v11 = 4LL;
    goto LABEL_29;
  }

  if ([v10 isEqualToString:@"SHA2-512"])
  {
    uint64_t v11 = 5LL;
    goto LABEL_29;
  }

  uint64_t v28 = 0LL;
LABEL_19:

LABEL_20:
  return v28;
}

  uint64_t v12 = [v8 code];
  ne_log_obj();
  int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  unint64_t v14 = v13;
  if (v12 != 9)
  {
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    int v18 = *(const char **)(a1 + 32);
    [*(id *)(a1 + 40) identifier];
    int v16 = (void *)objc_claimAutoreleasedReturnValue();
    [v16 UUIDString];
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v19 = [v8 code];
    *(_DWORD *)buf = 138412802;
    uint64_t v29 = v18;
    int v30 = 2112;
    unint64_t v31 = v17;
    unint64_t v32 = 2048;
    int v33 = v19;
    _os_log_error_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_ERROR,  "%@ Failed to save configuration %@ to disk: %ld",  buf,  0x20u);
    goto LABEL_21;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    unint64_t v15 = *(const char **)(a1 + 32);
    [*(id *)(a1 + 40) identifier];
    int v16 = (void *)objc_claimAutoreleasedReturnValue();
    [v16 UUIDString];
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412546;
    uint64_t v29 = v15;
    int v30 = 2112;
    unint64_t v31 = v17;
    _os_log_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_INFO,  "%@ Skipped saving configuration %@ to disk, because it is unchanged",  buf,  0x16u);
LABEL_21:
  }

    unsigned __int16 v17 = 0LL;
    goto LABEL_19;
  }

  if (v15 >= [v6 length]) {
    goto LABEL_18;
  }
  objc_msgSend(v6, "subdataWithRange:", v14 - v5, objc_msgSend(v6, "length") - v15);
  unsigned __int16 v17 = (id)objc_claimAutoreleasedReturnValue();
LABEL_19:

LABEL_20:
  if (v17)
  {
    uint64_t v23 = *(void *)(a1 + 48);
    id v22 = *(void **)(a1 + 56);
    if (*(void *)(a1 + 72) == 2LL) {
      [v22 handleInboundDataFromFlow:v23 readBytesStartOffset:v14 readBytes:v17];
    }
    else {
      [v22 handleOutboundDataFromFlow:v23 readBytesStartOffset:v14 readBytes:v17];
    }
    unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  }

  else
  {
    unint64_t v24 = 0LL;
  }

  return v24;
}

      v18[2](v18, 0LL);
      goto LABEL_19;
    }

    [v16 bytes];
    [v17 bytes];
    [v15 UTF8String];
    IKESocket = NEHelperGetIKESocket();
  }

  else
  {
    if (v20)
    {
      __int16 v27 = 138412290;
      uint64_t v28 = self;
      _os_log_debug_impl(&dword_1876B1000, v19, OS_LOG_TYPE_DEBUG, "%@: Getting PFKey Socket", (uint8_t *)&v27, 0xCu);
    }

    IKESocket = NEHelperGetPFKeySocket();
  }

  id v22 = IKESocket;
  ne_log_obj();
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    __int16 v27 = 138412546;
    uint64_t v28 = self;
    uint64_t v29 = 1024;
    int v30 = v22;
    _os_log_debug_impl( &dword_1876B1000,  v23,  OS_LOG_TYPE_DEBUG,  "%@: NEHelper returned socket %d",  (uint8_t *)&v27,  0x12u);
  }

  if ((v22 & 0x80000000) != 0)
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      __int16 v27 = 138412290;
      uint64_t v28 = self;
      int v26 = "%@: Failed to get socket";
LABEL_21:
      _os_log_error_impl(&dword_1876B1000, v25, OS_LOG_TYPE_ERROR, v26, (uint8_t *)&v27, 0xCu);
      goto LABEL_18;
    }

    goto LABEL_18;
  }

  unint64_t v24 = (void *)[objc_alloc(MEMORY[0x189607898]) initWithFileDescriptor:v22 closeOnDealloc:1];
  ((void (**)(id, void *))v18)[2](v18, v24);

LABEL_19:
}

    if ([v6 count]) {
      objc_storeStrong((id *)&self->_trustedServerCertificateReferences, v6);
    }
    uint64_t v7 = 1;
LABEL_27:
  }

  else
  {
    ne_log_obj();
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      int v36 = (id)objc_opt_class();
      unint64_t v19 = v36;
      _os_log_error_impl( &dword_1876B1000,  (os_log_t)v6,  OS_LOG_TYPE_ERROR,  "%@ invalid input data for trusted server certificates",  buf,  0xCu);
    }

    uint64_t v7 = 0;
  }

  return v7;
}
  }

  return v2;
}

      int v33 = *(void **)(a1 + 32);
      unint64_t v32 = *(void **)(a1 + 40);
      v70[0] = MEMORY[0x1895F87A8];
      v70[1] = 3221225472LL;
      v70[2] = (uint64_t)__43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_151;
      v70[3] = (uint64_t)&unk_18A08CFD8;
      uint64_t v34 = v32;
      SEL v74 = *(void *)(a1 + 48);
      uint64_t v35 = *(void *)(a1 + 32);
      unint64_t v71 = v34;
      uint64_t v72 = v35;
      uint64_t v73 = v4;
      -[NEIKEv2Session handleEAPAndGSPMForIKESA:authPacket:handler:](v33, v34, v73, v70);

LABEL_19:
      int v36 = 0LL;
LABEL_20:

      goto LABEL_21;
    }
}
}
}

  if (CFDictionaryContainsKey(v5, @"ReplayWindowSize")
    && !NEGetValueWithType(v5, @"ReplayWindowSize", CFNUMBER_TYPE))
  {
    ne_log_obj();
    unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_198;
    }
    *(_DWORD *)buf = 136315906;
    v147 = "NEIPSecIKEValidateIKEChildDictionary";
    v148 = 1024;
    v149 = 2154;
    v150 = 2112;
    v151 = @"ReplayWindowSize";
    v152 = 2048;
    v153 = CFNUMBER_TYPE;
    v100 = "%s:%d: type of value for key %@ != %lu";
LABEL_138:
    v101 = v15;
    v102 = 38;
LABEL_148:
    _os_log_error_impl(&dword_1876B1000, v101, OS_LOG_TYPE_ERROR, v100, buf, v102);
    goto LABEL_198;
  }

  if (CFDictionaryContainsKey(v5, @"ReplayWindowSize"))
  {
    -[__CFDictionary objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"ReplayWindowSize");
    int v10 = (void *)objc_claimAutoreleasedReturnValue();
    -[os_log_s setReplayWindowSize:](v2, "setReplayWindowSize:", [v10 unsignedIntValue]);
  }

  if (CFDictionaryContainsKey(v5, @"TrafficSelectorsLocal")
    && !NEGetValueWithType(v5, @"TrafficSelectorsLocal", CFARRAY_TYPE))
  {
    ne_log_obj();
    unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_198;
    }
    *(_DWORD *)buf = 136315906;
    v147 = "NEIPSecIKEValidateIKEChildDictionary";
    v148 = 1024;
    v149 = 2159;
    v150 = 2112;
    v151 = @"TrafficSelectorsLocal";
    v152 = 2048;
    v153 = CFARRAY_TYPE;
    v100 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_138;
  }

  if (CFDictionaryContainsKey(v5, @"TrafficSelectorsRemote")
    && !NEGetValueWithType(v5, @"TrafficSelectorsRemote", CFARRAY_TYPE))
  {
    ne_log_obj();
    unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_198;
    }
    *(_DWORD *)buf = 136315906;
    v147 = "NEIPSecIKEValidateIKEChildDictionary";
    v148 = 1024;
    v149 = 2160;
    v150 = 2112;
    v151 = @"TrafficSelectorsRemote";
    v152 = 2048;
    v153 = CFARRAY_TYPE;
    v100 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_138;
  }

  uint64_t v11 = (const __CFArray *)NEGetValueWithType(v5, @"TrafficSelectorsLocal", CFARRAY_TYPE);
  if (v11)
  {
    uint64_t v12 = v11;
    Count = CFArrayGetCount(v11);
    if (!Count)
    {
      ne_log_obj();
      unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_198;
      }
      *(_DWORD *)buf = 136315394;
      v147 = "NEIPSecIKEValidateIKEChildDictionary";
      v148 = 1024;
      v149 = 2167;
      v100 = "%s:%d: IKE Child local traffic selector array is empty";
LABEL_147:
      v101 = v15;
      v102 = 18;
      goto LABEL_148;
    }

    unint64_t v14 = Count;
    v123 = v6;
    unint64_t v15 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
    if (v14 >= 1)
    {
      int v16 = 0LL;
      unsigned __int16 v17 = @"TSProtocol";
      v128 = v12;
      v120 = v14;
      while (1)
      {
        int v18 = v17;
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v12, v16);
        if (!ValueAtIndex) {
          break;
        }
        int v20 = ValueAtIndex;
        uint64_t v21 = CFDICTIONARY_TYPE;
        if (CFGetTypeID(ValueAtIndex) != v21) {
          break;
        }
        id v22 = v20;
        uint64_t v23 = objc_alloc_init(&OBJC_CLASS___NEIKEv2TrafficSelector);
        if (!NEGetValueWithType(v22, @"TSType", CFSTRING_TYPE))
        {
          ne_log_obj();
          v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v6 = v123;
          if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            v147 = "NEIPSecIKEValidateIKEChildDictionary";
            v148 = 1024;
            v149 = 2182;
            v150 = 2112;
            v151 = @"TSType";
            v152 = 2048;
            v153 = CFSTRING_TYPE;
            _os_log_error_impl( &dword_1876B1000,  v103,  OS_LOG_TYPE_ERROR,  "%s:%d: value for key %@ is missing or type != %lu",  buf,  0x26u);
          }

          goto LABEL_196;
        }

        if (!NEGetValueWithType(v22, @"TSStartAddress", CFSTRING_TYPE))
        {
          ne_log_obj();
          v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            v147 = "NEIPSecIKEValidateIKEChildDictionary";
            v148 = 1024;
            v149 = 2183;
            v150 = 2112;
            v151 = @"TSStartAddress";
            v152 = 2048;
            v153 = CFSTRING_TYPE;
            v104 = "%s:%d: value for key %@ is missing or type != %lu";
            goto LABEL_176;
          }

LABEL_19:
  unsigned __int16 v17 = v8;
LABEL_23:

  Property = *(id *)(a1 + 40);
  if (Property) {
    Property = objc_getProperty(Property, v18, 48LL, 1);
  }
  objc_msgSend( Property,  "providerControlSocketFileHandle:",  *(void *)(a1 + 32),  v25,  *(void *)buf,  *(void *)&buf[8],  v27,  v28,  v29,  v30);
}

LABEL_19:
      int v16 = 0LL;
      goto LABEL_20;
    }

    goto LABEL_15;
  }

  id v6 = v5;
  uint64_t v7 = SecTaskCopyValueForEntitlement(v5, @"com.apple.developer.networking.networkextension", 0LL);
  id v8 = v7;
  if (v7) {
    CFRelease(v7);
  }
  int v9 = (void *)SecTaskCopyValueForEntitlement(v6, @"com.apple.private.neagent", 0LL);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0) {
    int v10 = [v9 BOOLValue];
  }
  else {
    int v10 = 0;
  }
  CFRelease(v6);

  if (!v8 && !a3)
  {
LABEL_11:
    ne_log_obj();
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v21 = "com.apple.developer.networking.networkextension";
      uint64_t v12 = "NEProvider creation failed, caller does not have the %s entitlement";
      int v13 = v11;
      unint64_t v14 = 12;
LABEL_24:
      _os_log_error_impl(&dword_1876B1000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
      goto LABEL_18;
    }

    goto LABEL_18;
  }

  if ((v10 & 1) == 0) {
    goto LABEL_14;
  }
LABEL_15:
  v19.receiver = self;
  v19.super_class = (Class)&OBJC_CLASS___NEProvider;
  unint64_t v15 = -[NEProvider init](&v19, sel_init);
  if (!v15)
  {
    ne_log_obj();
    self = (NEProvider *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)self, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1876B1000, (os_log_t)self, OS_LOG_TYPE_INFO, "Failed to init NEProvider", buf, 2u);
    }

    goto LABEL_19;
  }

  int v16 = (NEProvider **)v15;
  unsigned __int16 v17 = [MEMORY[0x189608E20] sharedDefaultEvaluator];
  self = v16[2];
  void v16[2] = (NEProvider *)v17;
LABEL_20:

  return v16;
}

  return v5;
}

  os_unfair_lock_unlock((os_unfair_lock_t)&g_currentNotificationLock);
}

  return v11;
}

  [v4 objectForKeyedSubscript:@"DHGroup"];
  unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  BOOL v25 = isa_nsnumber(v24);

  if (v25)
  {
    [v4 objectForKeyedSubscript:@"DHGroup"];
    int v26 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEVPNIKEv1ProposalParameters setDiffieHellmanGroup:](v5, "setDiffieHellmanGroup:", [v26 intValue]);
  }

  [v4 objectForKeyedSubscript:@"Lifetime"];
  __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v28 = isa_nsnumber(v27);

  if (v28)
  {
    [v4 objectForKeyedSubscript:@"Lifetime"];
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEVPNIKEv1ProposalParameters setLifetimeSeconds:](v5, "setLifetimeSeconds:", [v29 intValue]);
  }

LABEL_30:
LABEL_31:
  [v22 objectForKeyedSubscript:@"DiffieHellmanGroup"];
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  int v13 = isa_nsnumber(v12);

  if (v13)
  {
    [v22 objectForKeyedSubscript:@"DiffieHellmanGroup"];
    unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "setDiffieHellmanGroup:", (int)objc_msgSend(v14, "intValue"));
  }

  [v22 objectForKeyedSubscript:@"AdditionalKeyExchangeMethods"];
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  int v16 = isa_nsarray(v15);

  if (v16)
  {
    [v22 objectForKeyedSubscript:@"AdditionalKeyExchangeMethods"];
    int v18 = (void *)objc_claimAutoreleasedReturnValue();
    if (v3) {
      objc_setProperty_atomic(v3, v17, v18, 40LL);
    }
  }

  [v22 objectForKeyedSubscript:@"LifeTimeInMinutes"];
  unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
  int v20 = isa_nsnumber(v19);

  if (v20)
  {
    [v22 objectForKeyedSubscript:@"LifeTimeInMinutes"];
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "setLifetimeMinutes:", objc_msgSend(v21, "intValue"));
  }
}

            goto LABEL_31;
          }

          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            if (v2 && objc_getProperty(v2, v14, 88LL, 1))
            {
              objc_msgSend(objc_getProperty(v2, v15, 88, 1), "arrayByAddingObject:", v8);
              int v13 = (void *)objc_claimAutoreleasedReturnValue();
            }

            else
            {
              int v26 = v8;
              objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v26, 1, (void)v21);
              int v13 = (void *)objc_claimAutoreleasedReturnValue();
              if (!v2) {
                goto LABEL_30;
              }
            }

            int v20 = 88LL;
            int v18 = v2;
            unint64_t v19 = v13;
          }

          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0) {
              goto LABEL_31;
            }
            if (v2 && objc_getProperty(v2, v16, 56LL, 1))
            {
              objc_msgSend(objc_getProperty(v2, v17, 56, 1), "arrayByAddingObject:", v8);
              int v13 = (void *)objc_claimAutoreleasedReturnValue();
            }

            else
            {
              BOOL v25 = v8;
              objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v25, 1, (void)v21);
              int v13 = (void *)objc_claimAutoreleasedReturnValue();
              if (!v2) {
                goto LABEL_30;
              }
            }

            int v18 = v2;
            unint64_t v19 = v13;
            int v20 = 56LL;
          }

              unint64_t v14 = *v17;

              if (v14)
              {
                int v16 = v15;
                if (v15 + 4 <= v49) {
                  continue;
                }
              }

              break;
            }
          }
        }
      }

      a1[9] = 0;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0
        && (-[NEIKEv2IntermediatePacket authenticatedData](a1, v34),
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(),
            v35,
            !v35))
      {
        ne_log_obj();
        uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v54.receiver) = 0;
          int v39 = "Failed to get authenticated data for IKE_INTERMEDIATE";
          unint64_t v40 = v38;
          unint64_t v41 = 2;
LABEL_54:
          _os_log_error_impl(&dword_1876B1000, v40, OS_LOG_TYPE_ERROR, v39, (uint8_t *)&v54, v41);
        }
  }
}

  uint64_t v34 = 0;
LABEL_38:

  return v34;
}

      int v18 = a1[5];
      if (!v18) {
        return 0LL;
      }
      unint64_t v19 = a1[6];
      if (!v19) {
        return 0LL;
      }
      if (v18[4] != v19[4])
      {
        unint64_t v14 = (os_log_s *)ne_log_obj();
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          return 0xFFFFFFFFLL;
        }
        uint64_t v23 = v18[4];
        unint64_t v24 = v19[4];
        uint64_t v28 = 67109376;
        uint64_t v29 = v23;
        int v30 = 1024;
        unint64_t v31 = v24;
        int v5 = "src address protocol %u != dst address proto %u";
        goto LABEL_46;
      }

      int v20 = v18[9];
      if (v20 != v19[9])
      {
        unint64_t v14 = (os_log_s *)ne_log_obj();
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          return 0xFFFFFFFFLL;
        }
        BOOL v25 = v18[9];
        int v26 = v19[9];
        uint64_t v28 = 67109376;
        uint64_t v29 = v25;
        int v30 = 1024;
        unint64_t v31 = v26;
        int v5 = "src address family %u != dst address family %u";
        goto LABEL_46;
      }

      BOOL result = 0LL;
      if (v20 != 2 && v20 != 30)
      {
        id v3 = (os_log_s *)ne_log_obj();
        if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
          return 0xFFFFFFFFLL;
        }
        id v22 = v18[9];
        uint64_t v28 = 67109120;
        uint64_t v29 = v22;
        int v5 = "invalid address family %u";
        goto LABEL_11;
      }

      return result;
    case 5u:
    case 6u:
    case 7u:
    case 8u:
      id v3 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        return 0xFFFFFFFFLL;
      }
      int v10 = v1[3];
      uint64_t v28 = 67109120;
      uint64_t v29 = v10;
      int v5 = "invalid sa type %u";
      goto LABEL_11;
    default:
LABEL_38:
      id v3 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        return 0xFFFFFFFFLL;
      }
      __int16 v27 = v1[3];
      uint64_t v28 = 67109120;
      uint64_t v29 = v27;
      int v5 = "invalid sa type %u";
      goto LABEL_11;
  }

  uint64_t v35 = 1LL;
LABEL_31:

  return v35;
}

LABEL_188:
    goto LABEL_189;
  }

  int v13 = -[__CFString initWithName:grade:](a1, "initWithName:grade:", v8, a4);
  if (!v13)
  {
    ne_log_obj();
    v164 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
    {
      v183 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412290;
      v262 = v183;
      v184 = v183;
      _os_log_error_impl(&dword_1876B1000, v164, OS_LOG_TYPE_ERROR, "%@ initWithAlwaysOnVPNPayload failed", buf, 0xCu);
    }

    v165 = 0LL;
    a1 = v12;
    goto LABEL_227;
  }

  a1 = (__CFString *)v13;
  unint64_t v14 = objc_alloc_init(&OBJC_CLASS___NEAOVPN);
  -[__CFString setAlwaysOnVPN:](a1, "setAlwaysOnVPN:", v14);

  -[__CFString alwaysOnVPN](a1, "alwaysOnVPN");
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v15)
  {
    ne_log_obj();
    v166 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v166, OS_LOG_TYPE_ERROR))
    {
      v167 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412290;
      v262 = v167;
      v168 = v167;
      v169 = "%@ initWithAlwaysOnVPNPayload failed, can't create VPN";
      v170 = v166;
      v171 = 12;
LABEL_202:
      _os_log_error_impl(&dword_1876B1000, v170, OS_LOG_TYPE_ERROR, v169, buf, v171);

      goto LABEL_188;
    }

    goto LABEL_188;
  }

  -[__CFString alwaysOnVPN](a1, "alwaysOnVPN");
  int v16 = (void *)objc_claimAutoreleasedReturnValue();
  [v16 setEnabled:1];
  -[__CFString objectForKeyedSubscript:](v12, "objectForKeyedSubscript:", @"UIToggleEnabled");
  unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
  -[__CFString objectForKeyedSubscript:](v12, "objectForKeyedSubscript:", @"AllowCaptiveWebSheet");
  int v18 = (void *)objc_claimAutoreleasedReturnValue();

  -[__CFString objectForKeyedSubscript:](v12, "objectForKeyedSubscript:", @"AllowAllCaptiveNetworkPlugins");
  unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();

  v227 = v19;
  -[__CFString objectForKeyedSubscript:](v12, "objectForKeyedSubscript:", @"ServiceExceptions");
  int v20 = (void *)objc_claimAutoreleasedReturnValue();
  v224 = v8;
  v225 = v7;
  v228 = v9;
  v229 = v10;
  v230 = a1;
  v234 = v12;
  if (!isa_nsarray(v20) || ![v20 count])
  {
LABEL_36:
    -[__CFString objectForKeyedSubscript:](v12, "objectForKeyedSubscript:", @"ApplicationExceptions");
    unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();

    int v33 = v32;
    if (isa_nsarray(v32) && [v32 count])
    {
      v216 = v16;
      uint64_t v34 = (void *)[objc_alloc(MEMORY[0x189603FC8]) initWithCapacity:0];
      v248 = 0u;
      v249 = 0u;
      v250 = 0u;
      v251 = 0u;
      v232 = v33;
      uint64_t v35 = v33;
      int v36 = [v35 countByEnumeratingWithState:&v248 objects:v259 count:16];
      if (v36)
      {
        uint64_t v37 = v36;
        uint64_t v38 = *(void *)v249;
        int v39 = &off_18A087000;
        do
        {
          for (i = 0LL; i != v37; ++i)
          {
            if (*(void *)v249 != v38) {
              objc_enumerationMutation(v35);
            }
            unint64_t v41 = *(void **)(*((void *)&v248 + 1) + 8 * i);
            [v41 objectForKeyedSubscript:@"BundleIdentifier"];
            unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
            if (isa_nsstring(v42))
            {
              char v43 = objc_alloc_init((Class)v39[227]);
              uint64_t v44 = v43;
              if (v43)
              {
                [v43 setBundleIdentifier:v42];
                [v41 objectForKeyedSubscript:@"LimitToProtocols"];
                uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
                if (isa_nsarray(v45) && [v45 count])
                {
                  int v46 = v35;
                  int64_t v47 = v39;
                  int v48 = v34;
                  uint64_t v49 = (void *)[v45 copy];
                  [v44 setLimitToProtocols:v49];

                  uint64_t v34 = v48;
                  int v39 = v47;
                  uint64_t v35 = v46;
                }

                [v44 setAction:1];
                [v34 setObject:v44 forKeyedSubscript:v42];
              }
            }
          }

          uint64_t v37 = [v35 countByEnumeratingWithState:&v248 objects:v259 count:16];
        }

        while (v37);
      }

      int v16 = v216;
      if ([v34 count]) {
        [v216 setApplicationExceptions:v34];
      }

      id v8 = v224;
      uint64_t v7 = v225;
      int v9 = v228;
      int v10 = v229;
      a1 = (__CFString *)v230;
      int v33 = v232;
      uint64_t v12 = v234;
    }

    uint64_t v50 = -[__CFString objectForKeyedSubscript:](v12, "objectForKeyedSubscript:", @"AllowedCaptiveNetworkPlugins");
    int v51 = v33;
    uint64_t v52 = (void *)v50;

    v226 = v52;
    if (isa_nsarray(v52) && [v52 count])
    {
      uint64_t v53 = v16;
      int v54 = (void *)[objc_alloc(MEMORY[0x189603FC8]) initWithCapacity:0];
      v244 = 0u;
      v245 = 0u;
      v246 = 0u;
      v247 = 0u;
      BOOL v55 = v52;
      uint64_t v56 = [v55 countByEnumeratingWithState:&v244 objects:v258 count:16];
      if (v56)
      {
        unint64_t v57 = v56;
        int v58 = *(void *)v245;
        do
        {
          for (j = 0LL; j != v57; ++j)
          {
            if (*(void *)v245 != v58) {
              objc_enumerationMutation(v55);
            }
            [*(id *)(*((void *)&v244 + 1) + 8 * j) objectForKeyedSubscript:@"BundleIdentifier"];
            uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
            if (isa_nsstring(v60))
            {
              uint64_t v61 = objc_alloc_init(&OBJC_CLASS___NEAOVPNException);
              int v62 = v61;
              if (v61)
              {
                -[NEAOVPNException setBundleIdentifier:](v61, "setBundleIdentifier:", v60);
                -[NEAOVPNException setAction:](v62, "setAction:", 1LL);
                [v54 setObject:v62 forKeyedSubscript:v60];
              }
            }
          }

          unint64_t v57 = [v55 countByEnumeratingWithState:&v244 objects:v258 count:16];
        }

        while (v57);
      }

      int v16 = v53;
      if ([v54 count]) {
        [v53 setAllowedCaptiveNetworkPlugins:v54];
      }

      id v8 = v224;
      uint64_t v7 = v225;
      int v9 = v228;
      int v10 = v229;
      a1 = (__CFString *)v230;
      uint64_t v12 = v234;
    }

    uint64_t v63 = objc_alloc_init(MEMORY[0x189603FC8]);
    if (v63)
    {
      v222 = v63;
      -[__CFString objectForKeyedSubscript:](v12, "objectForKeyedSubscript:", @"TunnelConfigurations");
      uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
      if ((isa_nsarray(v64) & 1) == 0)
      {
        ne_log_obj();
        v175 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v175, OS_LOG_TYPE_ERROR))
        {
          v196 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412546;
          v262 = v196;
          v263 = 2112;
          v264 = @"TunnelConfigurations";
          v197 = v196;
          _os_log_error_impl( &dword_1876B1000,  v175,  OS_LOG_TYPE_ERROR,  "%@ initWithAlwaysOnVPNPayload: missing %@ array",  buf,  0x16u);
        }

        v165 = 0LL;
        v164 = (os_log_s *)v12;
        goto LABEL_206;
      }

      v217 = v16;
      v242 = 0u;
      v243 = 0u;
      v240 = 0u;
      v241 = 0u;
      obj = v64;
      uint64_t v65 = [obj countByEnumeratingWithState:&v240 objects:v257 count:16];
      if (!v65)
      {
        LOBYTE(v67) = 0;
        LOBYTE(v68) = 0;
        uint64_t v69 = 0LL;
        a1 = (__CFString *)v230;
LABEL_208:

        v180 = v67;
        id v8 = v224;
        uint64_t v7 = v225;
        int v9 = v228;
        int v10 = v229;
        if ((v180 & 1) != 0 || (v68 & 1) != 0)
        {
          v182 = v69;
          uint64_t v73 = (os_log_s *)v234;
LABEL_215:
          [v217 setInterfaceProtocolMapping:v222];
          ne_log_obj();
          v185 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v185, OS_LOG_TYPE_DEBUG))
          {
            v200 = (void *)objc_opt_class();
            v235 = v200;
            v201 = [v217 interfaceProtocolMapping];
            *(_DWORD *)buf = 138412802;
            v262 = v200;
            v263 = 2112;
            v264 = (const __CFString *)v201;
            v202 = (void *)v201;
            v265 = 2112;
            v266 = v230;
            _os_log_debug_impl( &dword_1876B1000,  v185,  OS_LOG_TYPE_DEBUG,  "%@ initWithAlwaysOnVPNPayload: aovpn tunnel configs %@, self %@",  buf,  0x20u);

            a1 = (__CFString *)v230;
          }

          a1 = a1;
          v164 = v73;
          v165 = a1;
        }

        else
        {
          ne_log_obj();
          v181 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v181, OS_LOG_TYPE_ERROR))
          {
            v203 = (void *)objc_opt_class();
            *(_DWORD *)buf = 138412802;
            v262 = v203;
            v263 = 2112;
            v264 = @"Cellular";
            v265 = 2112;
            v266 = @"WiFi";
            v204 = v203;
            _os_log_error_impl( &dword_1876B1000,  v181,  OS_LOG_TYPE_ERROR,  "%@ initWithAlwaysOnVPNPayload: must have one of %@ or %@ configs",  buf,  0x20u);
          }

          v165 = 0LL;
          v164 = (os_log_s *)v234;
        }

        goto LABEL_227;
      }

      int v66 = v65;
      uint64_t v67 = 0;
      uint64_t v68 = 0;
      uint64_t v69 = 0LL;
      int v70 = *(void *)v241;
      a1 = (__CFString *)v230;
      v210 = *(void *)v241;
LABEL_75:
      unint64_t v71 = 0LL;
      uint64_t v72 = v69;
      v211 = v66;
      while (1)
      {
        if (*(void *)v241 != v70) {
          objc_enumerationMutation(obj);
        }
        uint64_t v73 = (os_log_s *)v234;
        if ((v68 & v67 & 1) != 0)
        {
          v182 = v72;

          id v8 = v224;
          uint64_t v7 = v225;
          int v9 = v228;
          int v10 = v229;
          goto LABEL_215;
        }

        v233 = v71;
        SEL v74 = *(void **)(*((void *)&v240 + 1) + 8 * v71);
        uint64_t v69 = v72;
LABEL_158:
        unint64_t v71 = v233 + 1;
        if (v233 + 1 == v66)
        {
          v163 = [obj countByEnumeratingWithState:&v240 objects:v257 count:16];
          int v66 = v163;
          if (!v163) {
            goto LABEL_208;
          }
          goto LABEL_75;
        }
      }

      [v74 objectForKeyedSubscript:@"Interfaces"];
      id v75 = (void *)objc_claimAutoreleasedReturnValue();
      v219 = v75;
      v220 = v72;
      v218 = v68;
      v223 = v67;
      if (isa_nsarray(v75))
      {
        v238 = 0u;
        v239 = 0u;
        v236 = 0u;
        v237 = 0u;
        uint64_t v76 = v75;
        unint64_t v77 = [v76 countByEnumeratingWithState:&v236 objects:v256 count:16];
        if (v77)
        {
          unint64_t v78 = v77;
          uint64_t v79 = 0;
          uint64_t v80 = 0;
          int v81 = *(void *)v237;
          do
          {
            for (k = 0LL; k != v78; ++k)
            {
              if (*(void *)v237 != v81) {
                objc_enumerationMutation(v76);
              }
              v83 = *(void *)(*((void *)&v236 + 1) + 8 * k);
              if ([@"Cellular" isEqualToString:v83])
              {
                uint64_t v79 = 1;
              }

              else if ([@"WiFi" isEqualToString:v83])
              {
                uint64_t v80 = 1;
              }
            }

            unint64_t v78 = [v76 countByEnumeratingWithState:&v236 objects:v256 count:16];
          }

          while (v78);
        }

        else
        {
          uint64_t v79 = 0;
          uint64_t v80 = 0;
        }

        uint64_t v84 = v79 & 1;
        __int16 v85 = v80 & 1;
        a1 = (__CFString *)v230;
        uint64_t v73 = (os_log_s *)v234;
        uint64_t v68 = v218;
        uint64_t v67 = v223;
      }

      else
      {
        uint64_t v84 = 1;
        __int16 v85 = 1;
      }

      if ((v84 & v67) == 1)
      {
        ne_log_obj();
        v186 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v186, OS_LOG_TYPE_ERROR))
        {
          v187 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412546;
          v262 = v187;
          v263 = 2112;
          v264 = @"Cellular";
          v188 = v187;
          v189 = "%@ initWithAlwaysOnVPNPayload: multiple %@ configurations detected";
          goto LABEL_222;
        }

LABEL_224:
        id v8 = v224;
        uint64_t v7 = v225;
        int v9 = v228;
        int v10 = v229;

LABEL_226:
        v165 = 0LL;
        v164 = v73;
        goto LABEL_227;
      }

      if ((v85 & v68) == 1)
      {
        ne_log_obj();
        v186 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v186, OS_LOG_TYPE_ERROR)) {
          goto LABEL_224;
        }
        v190 = (void *)objc_opt_class();
        *(_DWORD *)buf = 138412546;
        v262 = v190;
        v263 = 2112;
        v264 = @"WiFi";
        v188 = v190;
        v189 = "%@ initWithAlwaysOnVPNPayload: multiple %@ configurations detected";
LABEL_222:
        v191 = v186;
        v192 = 22;
LABEL_230:
        _os_log_error_impl(&dword_1876B1000, v191, OS_LOG_TYPE_ERROR, v189, buf, v192);

        goto LABEL_224;
      }

      if (((v84 | v85) & 1) == 0)
      {
        ne_log_obj();
        v186 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v186, OS_LOG_TYPE_ERROR)) {
          goto LABEL_224;
        }
        v205 = (void *)objc_opt_class();
        *(_DWORD *)buf = 138412290;
        v262 = v205;
        v188 = v205;
        v189 = "%@ initWithAlwaysOnVPNPayload: invalid tunnel configuration interfaces";
        v191 = v186;
        v192 = 12;
        goto LABEL_230;
      }

      v212 = v84;
      [v229 objectForKeyedSubscript:@"VPNSubType"];
      int v86 = (void *)objc_claimAutoreleasedReturnValue();
      if (v85) {
        __int16 v87 = @"WiFi";
      }
      else {
        __int16 v87 = @"Cellular";
      }
      v213 = v86;
      int v88 = v74;
      uint64_t v89 = v87;
      CFErrorRef v90 = objc_alloc_init(&OBJC_CLASS___NEVPNProtocolIKEv2);
      ne_log_large_obj();
      unint64_t v91 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl( &dword_1876B1000,  v91,  OS_LOG_TYPE_DEBUG,  "NEConfiguration configureAOVPNTunnelFromTunnelDict called",  buf,  2u);
      }

      if (!v90)
      {
        ne_log_obj();
        v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl( &dword_1876B1000,  v103,  OS_LOG_TYPE_ERROR,  "NEConfiguration configureAOVPNTunnelFromTunnelDict failed to create object",  buf,  2u);
        }

        v99 = 0LL;
        goto LABEL_142;
      }

      [v88 objectForKeyedSubscript:@"RemoteAddress"];
      v92 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEVPNProtocol setServerAddress:](v90, "setServerAddress:", v92);

      [v88 objectForKeyedSubscript:@"AuthName"];
      v93 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEVPNProtocol setUsername:](v90, "setUsername:", v93);

      -[NEVPNProtocol setDisconnectOnIdleTimeout:](v90, "setDisconnectOnIdleTimeout:", 0LL);
      -[NEVPNProtocol setDisconnectOnSleep:](v90, "setDisconnectOnSleep:", 0LL);
      -[NEVPNProtocol setIdentityReferenceInternal:](v90, "setIdentityReferenceInternal:", 0LL);
      v90->_wakeForRekey = 1;
      -[NEVPNProtocolIKEv2 setNatKeepAliveOffloadEnable:](v90, "setNatKeepAliveOffloadEnable:", 2LL);
      else {
        v94 = 110LL;
      }
      -[NEVPNProtocolIKEv2 setNatKeepAliveOffloadInterval:](v90, "setNatKeepAliveOffloadInterval:", v94);
      -[NEVPNProtocol setIncludeAllNetworks:](v90, "setIncludeAllNetworks:", 0LL);
      -[NEVPNProtocol setExcludeLocalNetworks:](v90, "setExcludeLocalNetworks:", 0LL);
      -[NEVPNProtocol setExcludeCellularServices:](v90, "setExcludeCellularServices:", 0LL);
      -[NEVPNProtocol setExcludeAPNs:](v90, "setExcludeAPNs:", 0LL);
      -[NEVPNProtocol setExcludeDeviceCommunication:](v90, "setExcludeDeviceCommunication:", 0LL);
      -[NEVPNProtocol setEnforceRoutes:](v90, "setEnforceRoutes:", 0LL);
      -[NEVPNProtocol setSliceUUID:](v90, "setSliceUUID:", 0LL);
      [v88 objectForKeyedSubscript:@"ExtendedAuthEnabled"];
      v95 = (void *)objc_claimAutoreleasedReturnValue();
      v96 = isa_nsnumber(v95);

      if (v96)
      {
        [v88 objectForKeyedSubscript:@"ExtendedAuthEnabled"];
        v97 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEVPNProtocolIPSec setUseExtendedAuthentication:]( v90,  "setUseExtendedAuthentication:",  [v97 BOOLValue]);
      }

      [v88 objectForKeyedSubscript:@"AuthPassword"];
      v98 = (__CFString *)objc_claimAutoreleasedReturnValue();
      v99 = v98;
      if (v98)
      {
        if (isa_nsdata(v98))
        {
          v209 = v89;
          v100 = v85;
          v101 = v88;
          v102 = [objc_alloc(NSString) initWithData:v99 encoding:4];

          v99 = (__CFString *)v102;
        }

        else
        {
          if ((isa_nsstring(v99) & 1) == 0)
          {
            ne_log_obj();
            v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
            {
              v118 = (void *)objc_opt_class();
              v119 = v88;
              v120 = v118;
              v121 = (__CFString *)objc_opt_class();
              *(_DWORD *)buf = 138412546;
              v262 = v118;
              v263 = 2112;
              v264 = v121;
              v122 = v121;
              _os_log_error_impl( &dword_1876B1000,  v117,  OS_LOG_TYPE_ERROR,  "%@ configureAOVPNTunnelFromTunnelDict: unsupported password data type %@",  buf,  0x16u);

              a1 = (__CFString *)v230;
              int v88 = v119;
            }

            goto LABEL_141;
          }

          v209 = v89;
          v100 = v85;
          v101 = v88;
        }

        v104 = objc_alloc(&OBJC_CLASS___NEKeychainItem);
        keychainDomain = v90->super.super._keychainDomain;
        v107 = objc_getProperty(v90, v106, 88LL, 1);
        v108 = -[NEKeychainItem initWithPassword:domain:accessGroup:]( v104,  "initWithPassword:domain:accessGroup:",  v99,  keychainDomain,  v107);
        -[NEVPNProtocol setPasswordKeychainItem:](v90, "setPasswordKeychainItem:", v108);

        int v88 = v101;
        __int16 v85 = v100;
        uint64_t v89 = v209;
      }

      if (-[NEVPNProtocolIPSec useExtendedAuthentication](v90, "useExtendedAuthentication")
        && (-[NEVPNProtocol username](v90, "username"), (v109 = objc_claimAutoreleasedReturnValue()) != 0)
        && (v110 = (void *)v109,
            -[NEVPNProtocol passwordKeychainItem](v90, "passwordKeychainItem"),
            v111 = (void *)objc_claimAutoreleasedReturnValue(),
            v111,
            v110,
            !v111))
      {
        ne_log_obj();
        v134 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
        {
          v161 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138413058;
          v262 = v161;
          v263 = 2112;
          v264 = @"AuthPassword";
          v265 = 2112;
          v266 = @"AuthName";
          v267 = 2112;
          v268 = (uint64_t)@"ExtendedAuthEnabled";
          v162 = v161;
          _os_log_error_impl( &dword_1876B1000,  v134,  OS_LOG_TYPE_ERROR,  "%@ configureAOVPNTunnelFromTunnelDict: %@ required for %@ with %@ method",  buf,  0x2Au);
        }

        uint64_t v69 = 0LL;
        a1 = (__CFString *)v230;
      }

      else
      {
        [v88 objectForKeyedSubscript:@"LocalIdentifier"];
        v112 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEVPNProtocolIPSec setLocalIdentifier:](v90, "setLocalIdentifier:", v112);

        [v88 objectForKeyedSubscript:@"RemoteIdentifier"];
        v113 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEVPNProtocolIPSec setRemoteIdentifier:](v90, "setRemoteIdentifier:", v113);

        [v88 objectForKeyedSubscript:@"AuthenticationMethod"];
        v114 = (__CFString *)objc_claimAutoreleasedReturnValue();

        a1 = (__CFString *)v230;
        if (!v114) {
          goto LABEL_134;
        }
        if (isa_nsstring(v114))
        {
          if ((-[__CFString isEqualToString:](v114, "isEqualToString:", @"SharedSecret") & 1) != 0) {
            v115 = 2LL;
          }
          else {
            v115 = -[__CFString isEqualToString:](v114, "isEqualToString:", @"Certificate");
          }
          -[NEVPNProtocolIPSec setAuthenticationMethod:](v90, "setAuthenticationMethod:", v115);
LABEL_134:
          [v88 objectForKeyedSubscript:@"ProtocolType"];
          v99 = (__CFString *)objc_claimAutoreleasedReturnValue();

          if (v99
            && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)
            && (-[__CFString isEqualToString:](v99, "isEqualToString:", @"IKEv2") & 1) != 0)
          {
            [v88 objectForKeyedSubscript:@"SharedSecret"];
            v123 = (__CFString *)objc_claimAutoreleasedReturnValue();

            if (v123)
            {
              if (isa_nsdata(v123))
              {
                v124 = [objc_alloc(NSString) initWithData:v123 encoding:4];

                v123 = (__CFString *)v124;
              }

              else if ((isa_nsstring(v123) & 1) == 0)
              {
                v99 = v123;
                ne_log_obj();
                v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_141;
                }
                v158 = (void *)objc_opt_class();
                v136 = v158;
                v159 = (__CFString *)objc_opt_class();
                *(_DWORD *)buf = 138412546;
                v262 = v158;
                v263 = 2112;
                v264 = v159;
                v160 = v159;
                _os_log_error_impl( &dword_1876B1000,  v117,  OS_LOG_TYPE_ERROR,  "%@ configureAOVPNTunnelFromTunnelDict: unsupported shared secret data type %@",  buf,  0x16u);

                goto LABEL_166;
              }

              v140 = objc_alloc(&OBJC_CLASS___NEKeychainItem);
              v141 = v90->super.super._keychainDomain;
              v143 = objc_getProperty(v90, v142, 88LL, 1);
              v144 = -[NEKeychainItem initWithPassword:domain:accessGroup:]( v140,  "initWithPassword:domain:accessGroup:",  v123,  v141,  v143);
              -[NEVPNProtocolIPSec setSharedSecretKeychainItem:](v90, "setSharedSecretKeychainItem:", v144);

              v99 = v123;
              a1 = (__CFString *)v230;
            }

            else
            {
              v99 = 0LL;
            }

            if (-[NEVPNProtocolIPSec authenticationMethod](v90, "authenticationMethod") != NEVPNIKEAuthenticationMethodSharedSecret
              || (-[NEVPNProtocolIPSec sharedSecretKeychainItem](v90, "sharedSecretKeychainItem"),
                  v145 = (void *)objc_claimAutoreleasedReturnValue(),
                  v145,
                  v145))
            {
              v146 = -[NEVPNProtocolIKEv2 IKESecurityAssociationParameters](v90, "IKESecurityAssociationParameters");
              if ([v146 diffieHellmanGroup] <= 13)
              {
              }

              else
              {
                v147 = -[NEVPNProtocolIKEv2 childSecurityAssociationParameters](v90, "childSecurityAssociationParameters");
                v148 = v88;
                v149 = [v147 diffieHellmanGroup];

                a1 = (__CFString *)v230;
                v150 = v149 <= 13;
                int v88 = v148;
                if (!v150)
                {
                  uint64_t v69 = v90;
                  goto LABEL_143;
                }
              }

              ne_log_obj();
              v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
              {
                v151 = (void *)objc_opt_class();
                v207 = v151;
                v206 = -[NEVPNProtocolIKEv2 IKESecurityAssociationParameters](v90, "IKESecurityAssociationParameters");
                v208 = v88;
                v152 = [v206 diffieHellmanGroup];
                v153 = -[NEVPNProtocolIKEv2 childSecurityAssociationParameters](v90, "childSecurityAssociationParameters");
                v154 = [v153 diffieHellmanGroup];
                *(_DWORD *)buf = 138413058;
                v262 = v151;
                a1 = (__CFString *)v230;
                v263 = 2048;
                v264 = (const __CFString *)v152;
                int v88 = v208;
                v265 = 2048;
                v266 = (const __CFString *)v154;
                v267 = 2048;
                v268 = 14LL;
                _os_log_error_impl( &dword_1876B1000,  v117,  OS_LOG_TYPE_ERROR,  "%@ configureAOVPNTunnelFromTunnelDict: Invalid DH group (parent %ld child %ld), mininum allowed is %ld",  buf,  0x2Au);
              }

LABEL_141:
LABEL_142:
              uint64_t v69 = 0LL;
              goto LABEL_143;
            }

            ne_log_obj();
            v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
              goto LABEL_141;
            }
            v157 = (void *)objc_opt_class();
            *(_DWORD *)buf = 138412802;
            v262 = v157;
            v263 = 2112;
            v264 = @"SharedSecret";
            v265 = 2112;
            v266 = @"SharedSecret";
            v136 = v157;
            v137 = v117;
            v138 = "%@ configureAOVPNTunnelFromTunnelDict: %@ required with %@ method";
            v139 = 32;
          }

          else
          {
            ne_log_obj();
            v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
              goto LABEL_141;
            }
            v135 = (void *)objc_opt_class();
            *(_DWORD *)buf = 138412546;
            v262 = v135;
            v263 = 2112;
            v264 = v99;
            v136 = v135;
            v137 = v117;
            v138 = "%@ configureAOVPNTunnelFromTunnelDict: invalid ProtocolType (%@),  IKEv2 expected";
            v139 = 22;
          }

          _os_log_error_impl(&dword_1876B1000, v137, OS_LOG_TYPE_ERROR, v138, buf, v139);
LABEL_166:

          a1 = (__CFString *)v230;
          goto LABEL_141;
        }

        ne_log_obj();
        v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR))
        {
          v155 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412546;
          v262 = v155;
          v263 = 2112;
          v264 = v114;
          v156 = v155;
          _os_log_error_impl( &dword_1876B1000,  v116,  OS_LOG_TYPE_ERROR,  "%@ configureAOVPNTunnelFromTunnelDict: invalid authen type %@.",  buf,  0x16u);

          a1 = (__CFString *)v230;
        }

        uint64_t v69 = 0LL;
        v99 = v114;
      }

                  unint64_t v78 = v75;
                  uint64_t v79 = 22;
                  goto LABEL_142;
                }

                ne_log_obj();
                char v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_76;
                }
                int v81 = (id)[v3 copyShortDescription];
                *(_DWORD *)buf = 138412546;
                v210 = v6;
                v211 = 2112;
                v212 = (uint64_t)v81;
                v83 = "%@ %@ Did not receive NONCE data";
              }

              else
              {
                ne_log_obj();
                char v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_76;
                }
                int v81 = (id)[v3 copyShortDescription];
                *(_DWORD *)buf = 138412546;
                v210 = v6;
                v211 = 2112;
                v212 = (uint64_t)v81;
                v83 = "%@ %@ Did not receive NONCE payload";
              }
            }

            else
            {
              if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
                goto LABEL_76;
              }
              int v81 = (id)[v3 copyShortDescription];
              *(_DWORD *)buf = 138412546;
              v210 = v6;
              v211 = 2112;
              v212 = (uint64_t)v81;
              v83 = "%@ %@ Could not set chosen proposal values";
            }

            _os_log_error_impl(&dword_1876B1000, v43, OS_LOG_TYPE_ERROR, v83, buf, 0x16u);
            goto LABEL_75;
          }

                          v229 = 0LL;
LABEL_142:
                          v161 = v367;
                          goto LABEL_143;
                        }

                        ne_log_obj();
                        v250 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (!os_log_type_enabled(v250, OS_LOG_TYPE_FAULT)) {
                          goto LABEL_141;
                        }
                        *(_DWORD *)buf = 136315138;
                        *(void *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:ikeSA:]";
                        v251 = "%s called with null packet.nonce.isValid";
                      }

                      else
                      {
                        ne_log_obj();
                        v250 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (!os_log_type_enabled(v250, OS_LOG_TYPE_FAULT)) {
                          goto LABEL_141;
                        }
                        *(_DWORD *)buf = 136315138;
                        *(void *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:ikeSA:]";
                        v251 = "%s called with null packet.ikeSA.isValid";
                      }

LABEL_143:
      if (!v69)
      {
        v220 = 0LL;
        id v8 = v224;
        uint64_t v7 = v225;
        int v9 = v228;
        int v10 = v229;
        uint64_t v73 = (os_log_s *)v234;
        goto LABEL_226;
      }

      if (v85)
      {
        v221 = v69;
        [v222 setObject:v69 forKey:@"AlwaysOnVPNInterfaceWiFi"];
        [v88 objectForKeyedSubscript:@"PayloadCertificateUUID"];
        v125 = (void *)objc_claimAutoreleasedReturnValue();

        if (v125)
        {
          [v88 objectForKeyedSubscript:@"PayloadCertificateUUID"];
          v126 = (void *)objc_claimAutoreleasedReturnValue();
          [v228 addCertificatePending:v126 certificateTag:@"_PayloadCertificateRefForWifi"];
        }

        v127 = v88;
        v128 = v219;
        int v66 = v211;
        uint64_t v67 = v223;
        if ((v212 & 1) == 0)
        {
          uint64_t v68 = 1;
LABEL_155:
          uint64_t v69 = v221;
LABEL_157:

          uint64_t v72 = v69;
          int v70 = v210;
          goto LABEL_158;
        }

        v129 = (void *)-[NEVPNProtocolIKEv2 copy](v221, "copy");
        [MEMORY[0x189607AB8] UUID];
        v130 = (void *)objc_claimAutoreleasedReturnValue();
        [v129 setIdentifier:v130];

        [v222 setObject:v129 forKey:@"AlwaysOnVPNInterfaceCellular"];
        uint64_t v68 = 1;
      }

      else
      {
        if ((v212 & 1) == 0)
        {
          v128 = v219;
          int v66 = v211;
          uint64_t v68 = v218;
          uint64_t v67 = v223;
          goto LABEL_157;
        }

        v131 = v69;
        v127 = v88;
        v221 = v131;
        objc_msgSend(v222, "setObject:forKey:");
        v128 = v219;
        int v66 = v211;
        uint64_t v68 = v218;
      }

      [v127 objectForKeyedSubscript:@"PayloadCertificateUUID"];
      v132 = (void *)objc_claimAutoreleasedReturnValue();

      if (v132)
      {
        [v127 objectForKeyedSubscript:@"PayloadCertificateUUID"];
        v133 = (void *)objc_claimAutoreleasedReturnValue();
        [v228 addCertificatePending:v133 certificateTag:@"_PayloadCertificateRefForCellular"];
      }

      uint64_t v67 = 1;
      goto LABEL_155;
    }

    ne_log_obj();
    v174 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v174, OS_LOG_TYPE_ERROR))
    {
      v194 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412290;
      v262 = v194;
      v195 = v194;
      _os_log_error_impl( &dword_1876B1000,  v174,  OS_LOG_TYPE_ERROR,  "%@ initWithAlwaysOnVPNPayload: failed to create tunnel configs",  buf,  0xCu);
    }

LABEL_189:
    v165 = 0LL;
    v164 = (os_log_s *)v12;
    goto LABEL_227;
  }

  v215 = v16;
  uint64_t v21 = (void *)[objc_alloc(MEMORY[0x189603FC8]) initWithCapacity:0];
  v252 = 0u;
  v253 = 0u;
  v254 = 0u;
  v255 = 0u;
  v231 = v20;
  id v22 = v20;
  uint64_t v23 = [v22 countByEnumeratingWithState:&v252 objects:v260 count:16];
  if (!v23) {
    goto LABEL_33;
  }
  unint64_t v24 = v23;
  BOOL v25 = *(void *)v253;
LABEL_18:
  int v26 = 0LL;
  while (1)
  {
    if (*(void *)v253 != v25) {
      objc_enumerationMutation(v22);
    }
    __int16 v27 = *(void **)(*((void *)&v252 + 1) + 8 * v26);
    [v27 objectForKeyedSubscript:@"ServiceName"];
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v29 = objc_alloc_init(&OBJC_CLASS___NEAOVPNException);
    if (v29) {
      break;
    }
LABEL_30:

LABEL_31:
    if (v24 == ++v26)
    {
      unint64_t v24 = [v22 countByEnumeratingWithState:&v252 objects:v260 count:16];
      if (!v24)
      {
LABEL_33:

        int v16 = v215;
        if ([v21 count]) {
          [v215 setServiceExceptions:v21];
        }

        uint64_t v7 = v225;
        int v9 = v228;
        int v10 = v229;
        int v20 = v231;
        uint64_t v12 = v234;
        goto LABEL_36;
      }

      goto LABEL_18;
    }
  }

  [v27 objectForKeyedSubscript:@"Action"];
  int v30 = (void *)objc_claimAutoreleasedReturnValue();
  if (!isa_nsstring(v30))
  {
LABEL_29:
    -[NEAOVPNException setServiceName:](v29, "setServiceName:", v28);
    [v21 setObject:v29 forKeyedSubscript:v28];

    goto LABEL_30;
  }

  if ([v30 isEqualToString:@"Allow"])
  {
    unint64_t v31 = 1LL;
LABEL_28:
    -[NEAOVPNException setAction:](v29, "setAction:", v31);
    goto LABEL_29;
  }

  if ([v30 isEqualToString:@"Drop"])
  {
    unint64_t v31 = 2LL;
    goto LABEL_28;
  }

  ne_log_obj();
  v179 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
  {
    v198 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138413058;
    v262 = v198;
    v263 = 2112;
    v264 = @"ServiceExceptions";
    v265 = 2112;
    v266 = @"Action";
    v267 = 2112;
    v268 = (uint64_t)v30;
    v199 = v198;
    _os_log_error_impl( &dword_1876B1000,  v179,  OS_LOG_TYPE_ERROR,  "%@ initWithAlwaysOnVPNPayload: invalid %@ %@ option '%@'",  buf,  0x2Au);
  }

  v165 = 0LL;
  v164 = (os_log_s *)v234;
  uint64_t v7 = v225;
  int v9 = v228;
  int v10 = v229;
LABEL_206:
  a1 = (__CFString *)v230;
LABEL_227:

LABEL_228:
  return v165;
}

            CFRelease(v24);
            if (!v12) {
              goto LABEL_66;
            }
            goto LABEL_144;
          }

          ne_log_obj();
          uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138412290;
            v113 = (const char *)error[0];
            _os_log_fault_impl( &dword_1876B1000,  v44,  OS_LOG_TYPE_FAULT,  "Failed to sign with private key: %@",  buf,  0xCu);
          }

          if (error[0])
          {
            CFRelease(error[0]);
            error[0] = 0LL;
          }

          unint64_t v40 = 0LL;
LABEL_63:
          uint64_t v12 = 0LL;
          goto LABEL_143;
        }

        ne_log_obj();
        unint64_t v40 = (const __CFData *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
          goto LABEL_63;
        }
        *(_DWORD *)buf = 138412290;
        v113 = (const char *)v9;
        v95 = "Invalid signature protcol %@";
      }

      else
      {
        ne_log_obj();
        unint64_t v40 = (const __CFData *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
          goto LABEL_63;
        }
        *(_DWORD *)buf = 136315138;
        v113 = "+[NEIKEv2Crypto copySignatureForData:authProtocol:privateKey:]";
        v95 = "%s called with null inputData.length";
      }

      _os_log_fault_impl(&dword_1876B1000, v40, OS_LOG_TYPE_FAULT, v95, buf, 0xCu);
      goto LABEL_63;
    }

    uint64_t v45 = objc_alloc(MEMORY[0x189603FE0]);
    int v46 = v3[14];
    int64_t v47 = (void *)[v45 initWithSet:v46];

    int v48 = v29;
    objc_opt_self();
    uint64_t v49 = v48;
    uint64_t v50 = (void *)+[NEIKEv2Crypto copySignHashSetForAuthMethod:]((uint64_t)&OBJC_CLASS___NEIKEv2Crypto, v48);
    v101 = v29;
    v102 = v49;
    if (v49
      && ((int v51 = [v49 method], v51 == 245)
       || v51 == 14 && (unint64_t)([v49 digitalSignatureAlgorithm] - 9) <= 2)
      && (BlockSize = SecKeyGetBlockSize((SecKeyRef)v24), BlockSize <= 0x81))
    {
      unint64_t v57 = BlockSize;
      v98 = v47;
      v99 = v24;
      v97 = v50;
      int v58 = (void *)[v50 mutableCopy];
      *(_OWORD *)error = 0u;
      v105 = 0u;
      v106 = 0u;
      v107 = 0u;
      obj = (id)[v58 copy];
      uint64_t v59 = [obj countByEnumeratingWithState:error objects:buf count:16];
      if (v59)
      {
        uint64_t v60 = v59;
        uint64_t v61 = *(void *)v105;
        v100 = 8 * v57;
        while (2)
        {
          for (i = 0LL; i != v60; ++i)
          {
            if (*(void *)v105 != v61) {
              objc_enumerationMutation(obj);
            }
            uint64_t v63 = (void *)*((void *)error[1] + i);
            uint64_t v64 = [v63 hashType] - 2;
            if (v64 >= 3)
            {
              ne_log_obj();
              uint64_t v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)v108 = 138412290;
                v109 = v63;
                _os_log_fault_impl( &dword_1876B1000,  v72,  OS_LOG_TYPE_FAULT,  "Unexpected hash protocol %@ in RSA-PSS set",  v108,  0xCu);
              }

              BOOL v55 = 0LL;
              goto LABEL_112;
            }

            if (v57 < 32 * v64 + 66)
            {
              uint64_t v65 = v57;
              int v66 = v58;
              ne_log_obj();
              uint64_t v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v67, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)v108 = 138412546;
                v109 = v63;
                v110 = 2048;
                v111 = v100;
                _os_log_impl( &dword_1876B1000,  v67,  OS_LOG_TYPE_INFO,  "Removing too large hash protocol %@ from set for RSA key size %zu",  v108,  0x16u);
              }

              int v58 = v66;
              [v66 removeObject:v63];
              unint64_t v57 = v65;
            }
          }

          uint64_t v60 = [obj countByEnumeratingWithState:error objects:buf count:16];
          if (v60) {
            continue;
          }
          break;
        }
      }

      BOOL v55 = v58;
LABEL_112:
      unint64_t v24 = v99;
      uint64_t v49 = v102;

      int v54 = v97;
      int64_t v47 = v98;
    }

    else
    {
      uint64_t v53 = v50;
      int v54 = v50;
      BOOL v55 = v53;
    }

    ne_log_obj();
    uint64_t v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v91 = v47;
      v92 = (char *)v3[14];
      *(_DWORD *)buf = 138412290;
      v113 = v92;
      _os_log_debug_impl(&dword_1876B1000, v73, OS_LOG_TYPE_DEBUG, "Peer hashes: %@", buf, 0xCu);

      int64_t v47 = v91;
    }

    ne_log_obj();
    SEL v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v113 = v55;
      _os_log_debug_impl(&dword_1876B1000, v74, OS_LOG_TYPE_DEBUG, "Protocol hashes: %@", buf, 0xCu);
    }

    [v47 intersectSet:v55];
    [v47 allObjects];
    id v75 = (void *)objc_claimAutoreleasedReturnValue();
    [v75 sortedArrayUsingSelector:sel_compare_];
    uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue();

    [v76 lastObject];
    unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v102 method] == 245)
    {
      if (!v77)
      {
        ne_log_obj();
        uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl( &dword_1876B1000,  v82,  OS_LOG_TYPE_ERROR,  "Unable to find acceptable hash algorithm for generating RSA-PSS signature",  buf,  2u);
        }

        goto LABEL_156;
      }

      unint64_t v78 = [v77 hashType];
      switch(v78)
      {
        case 4LL:
          uint64_t v79 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
          uint64_t v80 = 11LL;
          goto LABEL_153;
        case 3LL:
          uint64_t v79 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
          uint64_t v80 = 10LL;
          goto LABEL_153;
        case 2LL:
          uint64_t v79 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
          uint64_t v80 = 9LL;
LABEL_153:
          __int16 v85 = -[NEIKEv2AuthenticationProtocol initWithDigitalSignature:](v79, "initWithDigitalSignature:", v80);
LABEL_154:
          uint64_t v34 = v85;
LABEL_157:

          int v30 = &off_18A087000;
          uint64_t v29 = v101;
          goto LABEL_50;
      }

      ne_log_obj();
      uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        v113 = (const char *)v77;
        CFErrorRef v90 = "Unexpected hash protocol %@ when selecting RSA-PSS protocol";
LABEL_167:
        _os_log_fault_impl(&dword_1876B1000, v82, OS_LOG_TYPE_FAULT, v90, buf, 0xCu);
      }
    }

    else
    {
      if (!-[NEIKEv2AuthenticationProtocol isECDSA]((uint64_t)v102))
      {
        ne_log_obj();
        uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
        {
          v83 = v3[14];
          *(_DWORD *)buf = 138412546;
          v113 = (const char *)v102;
          v114 = 2112;
          v115 = v83;
          _os_log_fault_impl( &dword_1876B1000,  v82,  OS_LOG_TYPE_FAULT,  "Unable to determine authentication protocol to use, configured %@ hashes %@",  buf,  0x16u);
        }

        goto LABEL_156;
      }

      if (!v77)
      {
        ne_log_obj();
        uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v84, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( &dword_1876B1000,  v84,  OS_LOG_TYPE_INFO,  "Unable to find acceptable hash algorithm for generating ECDSA signature",  buf,  2u);
        }

        __int16 v85 = v102;
        goto LABEL_154;
      }

      int v81 = [v77 hashType];
      switch(v81)
      {
        case 4LL:
          uint64_t v79 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
          uint64_t v80 = 8LL;
          goto LABEL_153;
        case 3LL:
          uint64_t v79 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
          uint64_t v80 = 7LL;
          goto LABEL_153;
        case 2LL:
          uint64_t v79 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
          uint64_t v80 = 2LL;
          goto LABEL_153;
      }

      ne_log_obj();
      uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        v113 = (const char *)v77;
        CFErrorRef v90 = "Unexpected hash protocol %@ when selecting ECDSA protocol";
        goto LABEL_167;
      }
    }

          v119 = objc_getProperty((id)a1, v93, 160LL, 1);
          uint64_t v64 = v186;
          if (!v119) {
            goto LABEL_219;
          }
          v120 = v119;
          if ([v119 method] == 6)
          {
          }

          else
          {
            v122 = [v120 method];

            v123 = v122 == 7;
            uint64_t v64 = v186;
            if (!v123) {
              goto LABEL_219;
            }
          }

          v124 = -[NEIKEv2IKESA copyLocalSecIdentity](v77, v121);
          *(void *)(a1 + 104) = v124;
          if (!v124)
          {
            ne_log_obj();
            v134 = (id)objc_claimAutoreleasedReturnValue();
            a5 = v184;
            if (os_log_type_enabled((os_log_t)v134, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl( &dword_1876B1000,  (os_log_t)v134,  OS_LOG_TYPE_ERROR,  "EAP plugin data initialization failed, missing identity certificate",  buf,  2u);
            }

            goto LABEL_176;
          }

          [v187 setObject:*MEMORY[0x189604DE8] forKeyedSubscript:@"TLSCertificateIsRequired"];
          v125 = objc_alloc_init(MEMORY[0x189603FA8]);
          v192 = v10;
          if (v125)
          {
            v126 = -[NEIKEv2IKESA copyRemoteCertificateAuthorityArray](self);
            if (v126)
            {
              v212 = 0u;
              v213 = 0u;
              v210 = 0u;
              v211 = 0u;
              v127 = v126;
              v128 = [v127 countByEnumeratingWithState:&v210 objects:buf count:16];
              if (v128)
              {
                v129 = v128;
                v130 = *(void *)v211;
                do
                {
                  for (j = 0LL; j != v129; ++j)
                  {
                    if (*(void *)v211 != v130) {
                      objc_enumerationMutation(v127);
                    }
                    v132 = SecCertificateCopyData(*(SecCertificateRef *)(*((void *)&v210 + 1) + 8 * j));
                    if (v132)
                    {
                      [v125 addObject:v132];
                    }

                    else
                    {
                      ne_log_obj();
                      v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v133, OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)v200 = 0;
                        _os_log_fault_impl( &dword_1876B1000,  v133,  OS_LOG_TYPE_FAULT,  "SecCertificateCopyData failed",  v200,  2u);
                      }
                    }
                  }

                  v129 = [v127 countByEnumeratingWithState:&v210 objects:buf count:16];
                }

                while (v129);
              }

              v134 = v125;
              __int16 v27 = v189;
LABEL_199:

              if ([v134 count])
              {
                [v187 setObject:v134 forKeyedSubscript:@"TLSTrustedCertificates"];
                v140 = 0LL;
                int v10 = v192;
                goto LABEL_209;
              }

              v141 = objc_getProperty(self, v139, 88LL, 1);
              [v141 remoteCertificateHostname];
              v140 = (void *)objc_claimAutoreleasedReturnValue();

              int v10 = v192;
              if (v140)
              {
LABEL_208:
                *(void *)&v210 = v140;
                objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v210, 1, v182);
                v153 = (void *)objc_claimAutoreleasedReturnValue();
                [v187 setObject:v153 forKeyedSubscript:@"TLSTrustedServerNames"];

                goto LABEL_209;
              }

              v183 = v134;
              v143 = objc_getProperty(self, v142, 88LL, 1);
              [v143 remoteIdentifier];
              v144 = (void *)objc_claimAutoreleasedReturnValue();
              if ([v144 identifierType] != 2)
              {
                v146 = objc_getProperty(self, v145, 88LL, 1);
                [v146 remoteIdentifier];
                v147 = (void *)objc_claimAutoreleasedReturnValue();
                if ([v147 identifierType] != 1)
                {
                  v175 = objc_getProperty(self, v148, 88LL, 1);
                  [v175 remoteIdentifier];
                  v176 = (void *)objc_claimAutoreleasedReturnValue();
                  v182 = [v176 identifierType];

                  if (v182 != 5)
                  {
                    v177 = objc_getProperty(self, v149, 80LL, 1);
                    [v177 remoteEndpoint];
                    v178 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_opt_class();
                    isKindOfClass = objc_opt_isKindOfClass();

                    if ((isKindOfClass & 1) == 0)
                    {
                      v140 = 0LL;
                      int v10 = v192;
                      __int16 v27 = v189;
                      v134 = v183;
LABEL_209:
                      v154 = objc_msgSend(v134, "count", v182);
                      if (!v140 && !v154)
                      {
                        ne_log_obj();
                        v156 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        a5 = v184;
                        if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)buf = 0;
                          _os_log_error_impl( &dword_1876B1000,  v156,  OS_LOG_TYPE_ERROR,  "EAP plugin data initialization failed, missing server certificate validation info",  buf,  2u);
                        }

                        uint64_t v64 = v186;
                        goto LABEL_176;
                      }

                      v157 = objc_getProperty(self, v155, 88LL, 1);
                      [v157 tlsMinimumVersion];
                      v158 = (void *)objc_claimAutoreleasedReturnValue();

                      if (v158)
                      {
                        v160 = objc_getProperty(self, v159, 88LL, 1);
                        [v160 tlsMinimumVersion];
                        v161 = (void *)objc_claimAutoreleasedReturnValue();
                        [v187 setObject:v161 forKeyedSubscript:@"TLSMinimumVersion"];
                      }

                      v162 = objc_getProperty(self, v159, 88LL, 1);
                      [v162 tlsMaximumVersion];
                      v163 = (void *)objc_claimAutoreleasedReturnValue();

                      if (v163)
                      {
                        v165 = objc_getProperty(self, v164, 88LL, 1);
                        [v165 tlsMaximumVersion];
                        v166 = (void *)objc_claimAutoreleasedReturnValue();
                        [v187 setObject:v166 forKeyedSubscript:@"TLSMaximumVersion"];
                      }

                      uint64_t v64 = v186;
LABEL_219:
                      v167 = v27;
                      *(_DWORD *)(a1 + 24) = 1024;
                      *(void *)(a1 + 88) = v187;
                      *(void *)v200 = 0LL;
                      v168 = EAPClientModulePluginInit();
                      if (*(void *)v200)
                      {
                        CFRelease(*(CFTypeRef *)v200);
                        *(void *)v200 = 0LL;
                      }

                      a5 = v184;
                      if (v168)
                      {
                        ne_log_obj();
                        v169 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
                        {
                          Property = objc_getProperty((id)a1, v170, 160LL, 1);
                          *(_DWORD *)buf = 138412546;
                          *(void *)&buf[4] = Property;
                          *(_WORD *)&buf[12] = 1024;
                          v209 = v168;
                          _os_log_error_impl( &dword_1876B1000,  v169,  OS_LOG_TYPE_ERROR,  "%@ EAP client module init failed with status %u",  buf,  0x12u);
                        }

                        objc_setProperty_atomic((id)a1, v171, 0LL, 160LL);
                        *(void *)(a1 + 168) = 0LL;
                        uint64_t v11 = (void *)MEMORY[0x189604A58];
                      }

                      else
                      {
                        uint64_t v11 = 0LL;
                      }

                      __int16 v27 = v167;
                      goto LABEL_177;
                    }

                    v150 = objc_getProperty(self, v180, 80LL, 1);
                    [v150 remoteEndpoint];
                    v151 = (void *)objc_claimAutoreleasedReturnValue();
                    v152 = [v151 hostname];
                    goto LABEL_207;
                  }

LABEL_71:
    uint64_t v23 = 0LL;
LABEL_72:

    goto LABEL_19;
  }

  ne_log_obj();
  a1 = (void *)objc_claimAutoreleasedReturnValue();
  if (!os_log_type_enabled((os_log_t)a1, OS_LOG_TYPE_ERROR)) {
    goto LABEL_18;
  }
  BOOL v25 = (void *)objc_opt_class();
  *(_DWORD *)buf = 138412290;
  v106 = v25;
  id v22 = v25;
  _os_log_error_impl( &dword_1876B1000,  (os_log_t)a1,  OS_LOG_TYPE_ERROR,  "%@ initWithContentFilterPayload failed",  buf,  0xCu);
LABEL_17:

LABEL_18:
  uint64_t v23 = 0LL;
LABEL_19:

LABEL_20:
  return v23;
}

    unint64_t v2 = 0x189604000uLL;
LABEL_72:
    [(id)v1 eapSettings];
    unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue();
    [v77 supportedEAPTypes];
    unint64_t v78 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v79 = [v78 containsObject:&unk_18A0CF8B8];

    if ((v79 & 1) != 0) {
      goto LABEL_73;
    }
    [(id)v1 eapSettings];
    int v88 = (void *)objc_claimAutoreleasedReturnValue();
    [v88 username];
    uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v89 length])
    {
      [(id)v1 eapSettings];
      CFErrorRef v90 = (void *)objc_claimAutoreleasedReturnValue();
      [v90 username];
      unint64_t v91 = (void *)objc_claimAutoreleasedReturnValue();
      v92 = [v91 length];

      if (v92 < 0xFE)
      {
        [(id)v1 eapSettings];
        v93 = (void *)objc_claimAutoreleasedReturnValue();
        [v93 password];
        v94 = (void *)objc_claimAutoreleasedReturnValue();
        if ([v94 length])
        {
          [(id)v1 eapSettings];
          v95 = (void *)objc_claimAutoreleasedReturnValue();
          [v95 password];
          v96 = (void *)objc_claimAutoreleasedReturnValue();
          v97 = [v96 length];

          if (v97 < 0x41)
          {
            [(id)v1 eapSettings];
            v98 = (void *)objc_claimAutoreleasedReturnValue();
            [v98 supportedEAPTypes];
            v99 = (void *)objc_claimAutoreleasedReturnValue();
            v100 = [v99 containsObject:&unk_18A0CF8D0];

            if (v100)
            {
              objc_msgSend( *(id *)(v2 + 16),  "setWithObjects:",  &unk_18A0CF918,  &unk_18A0CF930,  &unk_18A0CF948,  &unk_18A0CF960,  &unk_18A0CF978,  0);
              int v5 = (void *)objc_claimAutoreleasedReturnValue();
              v101 = (void *)MEMORY[0x189607968];
              [(id)v1 eapSettings];
              v102 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v101, "numberWithInteger:", objc_msgSend(v102, "ttlsInnerAuthenticationType"));
              v103 = (void *)objc_claimAutoreleasedReturnValue();
              v104 = [v5 containsObject:v103];

              if (!v104)
              {
                ne_log_obj();
                int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
                {
                  v131 = (void *)objc_opt_class();
                  v132 = v131;
                  [(id)v1 eapSettings];
                  v133 = (void *)objc_claimAutoreleasedReturnValue();
                  v134 = [v133 ttlsInnerAuthenticationType];
                  *(_DWORD *)buf = 138412546;
                  v170 = v131;
                  v171 = 2048;
                  v172 = v134;
                  _os_log_error_impl(&dword_1876B1000, v13, OS_LOG_TYPE_ERROR, "%@ invalid EAP type %ld", buf, 0x16u);
                }

  v113 = 0LL;
LABEL_93:

  return v113;
}

LABEL_66:
        id v8 = v66;
        uint64_t v7 = v67;
        int v9 = v65;
LABEL_44:

        goto LABEL_45;
      }

      [v16 objectForKeyedSubscript:@"AppIdentifierMatches"];
      unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v18 = v17;
      if (v17)
      {
        if ((isa_nsarray(v17) & 1) == 0)
        {
          ne_log_obj();
          unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            uint64_t v53 = (void *)objc_opt_class();
            *(_DWORD *)buf = 138412290;
            unint64_t v78 = v53;
            int v54 = v53;
            _os_log_error_impl( &dword_1876B1000,  v19,  OS_LOG_TYPE_ERROR,  "%@ initWithPathControllerPayload: AppIdentifierMatches malformed",  buf,  0xCu);
          }

      ++v12;
    }

    while (v12 != v10);
    uint64_t v63 = [obj countByEnumeratingWithState:&v80 objects:v90 count:16];
    int v10 = v63;
  }

  while (v63);
LABEL_72:

  ne_log_obj();
  uint64_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    __int16 v85 = "-[NEConfigurationManager handleApplicationsRemoved:completionQueue:withCompletionHandler:]_block_invoke";
    int v86 = 1024;
    LODWORD(v87) = 2645;
    _os_log_debug_impl(&dword_1876B1000, v64, OS_LOG_TYPE_DEBUG, "%s:%d: Unlocking SCPreferences", buf, 0x12u);
  }

  SCPreferencesUnlock(prefs);
  CFRelease(prefs);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
  dispatch_async(*(dispatch_queue_t *)(a1 + 56), *(dispatch_block_t *)(a1 + 64));
  size_t v4 = v70;
LABEL_82:

LABEL_83:
}

  _Block_object_dispose(&v77, 8);
LABEL_67:
  ne_log_obj();
  int v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    int v88 = "-[NEConfigurationManager syncConfigurationsWithSC:completionQueue:completionHandler:]_block_invoke";
    uint64_t v89 = 1024;
    LODWORD(v90) = 1985;
    _os_log_debug_impl(&dword_1876B1000, v46, OS_LOG_TYPE_DEBUG, "%s:%d: Unlocking SCPreferences", buf, 0x12u);
  }

  SCPreferencesUnlock(prefs);
  CFRelease(prefs);
  unint64_t v71 = 0u;
  uint64_t v72 = 0u;
  uint64_t v69 = 0u;
  int v70 = 0u;
  int v48 = *(id *)(a1 + 32);
  if (v48) {
    int v48 = objc_getProperty(v48, v47, 88LL, 1);
  }
  uint64_t v49 = v48;
  size_t v4 = 0LL;
  int v51 = [v49 countByEnumeratingWithState:&v69 objects:v86 count:16];
  if (v51)
  {
    uint64_t v52 = *(void *)v70;
    do
    {
      for (k = 0LL; k != v51; ++k)
      {
        if (*(void *)v70 != v52) {
          objc_enumerationMutation(v49);
        }
        int v54 = *(void *)(*((void *)&v69 + 1) + 8 * k);
        BOOL v55 = *(id *)(a1 + 32);
        if (v55) {
          BOOL v55 = objc_getProperty(v55, v50, 88LL, 1);
        }
        objc_msgSend(v55, "objectForKeyedSubscript:", v54, prefs);
        uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
        if (-[NEConfiguration isSupportedBySC](v56))
        {
          if (!v4) {
            size_t v4 = xpc_array_create(0LL, 0LL);
          }
          [v56 identifier];
          unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
          [v57 getUUIDBytes:buf];

          int v58 = xpc_uuid_create(buf);
          xpc_array_append_value(v4, v58);
        }
      }

      int v51 = [v49 countByEnumeratingWithState:&v69 objects:v86 count:16];
    }

    while (v51);
  }

LABEL_6:
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __85__NEConfigurationManager_syncConfigurationsWithSC_completionQueue_completionHandler___block_invoke_144;
  block[3] = &unk_18A0908C8;
  int v5 = *(dispatch_queue_s **)(a1 + 56);
  id v6 = *(id *)(a1 + 64);
  uint64_t v67 = v4;
  uint64_t v68 = v6;
  uint64_t v7 = v4;
  dispatch_async(v5, block);
}

    if (!objc_getProperty(v8, v60, 96LL, 1))
    {
      ne_log_obj();
      unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        int v18 = "No chosen integrity protocol";
        goto LABEL_106;
      }

      goto LABEL_156;
    }
  }

  if (a3)
  {
    v158 = 0uLL;
    v159 = 0uLL;
    v156 = 0uLL;
    v157 = 0uLL;
    [v6 prfProtocols];
    uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
    int v62 = [v61 countByEnumeratingWithState:&v156 objects:v181 count:16];
    if (v62)
    {
      uint64_t v63 = v62;
      uint64_t v64 = *(void *)v157;
      while (2)
      {
        for (k = 0LL; k != v63; ++k)
        {
          if (*(void *)v157 != v64) {
            objc_enumerationMutation(v61);
          }
          int v66 = *(void *)(*((void *)&v156 + 1) + 8 * k);
          -[os_log_s prfProtocols](v8, "prfProtocols");
          uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v68 = [v67 indexOfObject:v66];

          if (v68 != 0x7FFFFFFFFFFFFFFFLL)
          {
            -[os_log_s prfProtocols](v8, "prfProtocols");
            unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue();
            [v77 objectAtIndexedSubscript:v68];
            unint64_t v78 = (void *)objc_claimAutoreleasedReturnValue();
            objc_setProperty_atomic(v8, v79, v78, 104LL);

            goto LABEL_88;
          }
        }

        uint64_t v63 = [v61 countByEnumeratingWithState:&v156 objects:v181 count:16];
        if (v63) {
          continue;
        }
        break;
      }
    }
  }

  else
  {
    v154 = 0uLL;
    v155 = 0uLL;
    v152 = 0uLL;
    v153 = 0uLL;
    -[os_log_s prfProtocols](v8, "prfProtocols");
    uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v69 = [v61 countByEnumeratingWithState:&v152 objects:v180 count:16];
    if (v69)
    {
      int v70 = v69;
      unint64_t v71 = *(void *)v153;
      while (2)
      {
        for (m = 0LL; m != v70; ++m)
        {
          if (*(void *)v153 != v71) {
            objc_enumerationMutation(v61);
          }
          uint64_t v73 = *(void **)(*((void *)&v152 + 1) + 8 * m);
          [v6 prfProtocols];
          SEL v74 = (void *)objc_claimAutoreleasedReturnValue();
          id v75 = [v74 containsObject:v73];

          if (v75)
          {
            objc_setProperty_atomic(v8, v76, v73, 104LL);
            goto LABEL_88;
          }
        }

        int v70 = [v61 countByEnumeratingWithState:&v152 objects:v180 count:16];
        if (v70) {
          continue;
        }
        break;
      }
    }
  }

      unint64_t v71 = (os_log_s *)v52;
      uint64_t v72 = 12;
LABEL_67:
      _os_log_error_impl(&dword_1876B1000, v71, OS_LOG_TYPE_ERROR, v70, buf, v72);

      goto LABEL_118;
    }

    ne_log_obj();
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v52, OS_LOG_TYPE_ERROR))
    {
      uint64_t v67 = [(id)a1 copyShortDescription];
      uint64_t v68 = (char *)v67;
      if (v20) {
        uint64_t v69 = v20[8];
      }
      else {
        uint64_t v69 = 0;
      }
      *(_DWORD *)buf = 138412546;
      v161 = (const char *)v67;
      v162 = 1024;
      LODWORD(v163) = v69;
      int v70 = "%@ SA proposal number %u does not match";
      unint64_t v71 = (os_log_s *)v52;
      uint64_t v72 = 18;
      goto LABEL_67;
    }

    goto LABEL_118;
  }

              v120 = objc_getProperty(a1, v119, 336LL, 1);
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"rekey IKE SA refusal",  v129,  v130,  v131,  v132,  v133,  v134,  v135,  v361);
              goto LABEL_67;
            }

            ne_log_obj();
            v343 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v343, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl( &dword_1876B1000,  v343,  OS_LOG_TYPE_ERROR,  "Failed to create Create Child SA packet (receive rekey)",  buf,  2u);
            }

  uint64_t v79 = 1;
LABEL_67:
  uint64_t v7 = v69;
LABEL_68:

  uint64_t v52 = v79;
LABEL_69:

  return v52;
}

LABEL_43:
          id v8 = v66;
          uint64_t v7 = v67;
          int v9 = v65;

          goto LABEL_44;
        }

        unint64_t v71 = 0u;
        uint64_t v72 = 0u;
        uint64_t v69 = 0u;
        int v70 = 0u;
        unint64_t v19 = v18;
        int v20 = -[os_log_s countByEnumeratingWithState:objects:count:]( v19,  "countByEnumeratingWithState:objects:count:",  &v69,  v81,  16LL);
        if (v20)
        {
          uint64_t v21 = v20;
          id v22 = *(void *)v70;
          while (2)
          {
            for (j = 0LL; j != v21; ++j)
            {
              if (*(void *)v70 != v22) {
                objc_enumerationMutation(v19);
              }
              if ((isa_nsstring(*(void **)(*((void *)&v69 + 1) + 8 * j)) & 1) == 0)
              {
                ne_log_obj();
                int v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                {
                  int v51 = (void *)objc_opt_class();
                  *(_DWORD *)buf = 138412290;
                  unint64_t v78 = v51;
                  uint64_t v52 = v51;
                  _os_log_error_impl( &dword_1876B1000,  v39,  OS_LOG_TYPE_ERROR,  "%@ initWithPathControllerPayload: AppIdentifierMatches malformed",  buf,  0xCu);
                }

                int v18 = v19;
                goto LABEL_43;
              }
            }

            uint64_t v21 = -[os_log_s countByEnumeratingWithState:objects:count:]( v19,  "countByEnumeratingWithState:objects:count:",  &v69,  v81,  16LL);
            if (v21) {
              continue;
            }
            break;
          }
        }

        unint64_t v14 = v64;
      }

      [v16 objectForKeyedSubscript:@"AllowRoamingCellularData"];
      unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = v24;
      if (v24 && (isa_nsnumber(v24) & 1) == 0)
      {
        ne_log_obj();
        BOOL v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
        {
          uint64_t v60 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412290;
          unint64_t v78 = v60;
          uint64_t v61 = v60;
          _os_log_error_impl( &dword_1876B1000,  v55,  OS_LOG_TYPE_ERROR,  "%@ initWithPathControllerPayload: AllowRoamingCellularData malformed",  buf,  0xCu);
        }

LABEL_65:
        goto LABEL_66;
      }

      [v16 objectForKeyedSubscript:@"AllowCellularData"];
      int v26 = (void *)objc_claimAutoreleasedReturnValue();
      __int16 v27 = v26;
      if (v26 && (isa_nsnumber(v26) & 1) == 0)
      {
        ne_log_obj();
        uint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
        {
          int v62 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412290;
          unint64_t v78 = v62;
          uint64_t v63 = v62;
          _os_log_error_impl( &dword_1876B1000,  v56,  OS_LOG_TYPE_ERROR,  "%@ initWithPathControllerPayload: AllowCellularData malformed",  buf,  0xCu);
        }

        goto LABEL_65;
      }
    }

    int v13 = -[os_log_s countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v73,  v82,  16LL);
    id v8 = v66;
    uint64_t v7 = v67;
    int v9 = v65;
    if (v13) {
      continue;
    }
    break;
  }

      objc_msgSend(v25, "encodeObject:forKey:", objc_getProperty(v21, v27, 120, 1), @"SCPreferencesSignature2");
      [v25 finishEncoding];
      [v25 encodedData];
      uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
      int v51 = [v50 writeToFile:@"/Library/Preferences/com.apple.networkextension.plist" atomically:1];

      if ((v51 & 1) != 0)
      {
        v21[13] = v71;
        uint64_t v52 = (void *)[v8 copy];
        objc_setProperty_atomic(v21, v53, v52, 56LL);

        __int16 v85 = v6;
        [MEMORY[0x189603F18] arrayWithObjects:&v85 count:1];
        int v54 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEConfigurationManager clearLoadedConfigurationsWithIDs:](v21, v54);

        -[NEConfigurationManager postChangeNotificationWithGeneration:andFlags:onlyIfChanged:](v21, v71, v84, 0);
        a1 = 0LL;
        goto LABEL_55;
      }

      -[NEConfigurationManager errorWithCode:specifics:]((uint64_t)v21, 6LL, 0LL);
      a1 = (_BYTE *)objc_claimAutoreleasedReturnValue();
      goto LABEL_53;
    }

    BOOL v55 = (void *)NSString;
    uint64_t v56 = SCError();
    [v55 stringWithCString:SCErrorString(v56) encoding:4];
    unint64_t v57 = (char *)objc_claimAutoreleasedReturnValue();
    ne_log_obj();
    int v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
    {
      [v42 UUIDString];
      uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412546;
      uint64_t v89 = v64;
      CFErrorRef v90 = 2112;
      unint64_t v91 = v57;
      _os_log_error_impl( &dword_1876B1000,  v58,  OS_LOG_TYPE_ERROR,  "SCPreferencesCommitChanges failed while removing configuration %@: %@",  buf,  0x16u);
    }

    -[NEConfigurationManager errorWithCode:specifics:](v74, 12LL, v57);
    a1 = (_BYTE *)objc_claimAutoreleasedReturnValue();

LABEL_53:
    goto LABEL_54;
  }

  if (v6 >= 2049) {
LABEL_52:
  }
    free(v7);
}

          goto LABEL_44;
        }
      }

      else
      {
        uint64_t v49 = 0LL;
      }

      uint64_t v50 = 0LL;
      goto LABEL_26;
    }

    if (v9) {
      objc_setProperty_atomic(v9, v20, 0LL, 176LL);
    }
    v12[2](v12);
  }

LABEL_44:
        int v36 = 0LL;
      }

      else
      {
        objc_setProperty_atomic(a1, v34, 0LL, 48LL);
        [a1 filloutPayloads];
        int v36 = 1LL;
      }

      uint64_t v37 = v47;
      goto LABEL_46;
    }

    ne_log_obj();
    uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      LODWORD(v54.receiver) = 136315138;
      *(id *)((char *)&v54.receiver + 4) = "-[NEIKEv2Packet processDecryptedPacketForIKESA:]";
      uint64_t v45 = "%s called with null ikeSA";
      goto LABEL_52;
    }
  }

  else
  {
    ne_log_obj();
    uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      LODWORD(v54.receiver) = 136315138;
      *(id *)((char *)&v54.receiver + 4) = "-[NEIKEv2Packet processDecryptedPacketForIKESA:]";
      uint64_t v45 = "%s called with null self.encryptedPayload.payloadData";
LABEL_52:
      _os_log_fault_impl(&dword_1876B1000, v37, OS_LOG_TYPE_FAULT, v45, (uint8_t *)&v54, 0xCu);
    }
  }
}

  BOOL v55 = 0LL;
LABEL_44:

LABEL_45:
  return v55;
}

            if (!*((void *)v4 + 2)) {
              goto LABEL_46;
            }
            goto LABEL_44;
          }

          unint64_t v19 = next_slot;
          *((void *)v4 + 5) = next_slot;
          packet = os_channel_slot_get_packet();
          if (!packet)
          {
            ne_log_obj();
            uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412802;
              uint64_t v63 = v4;
              uint64_t v64 = 2080;
              *(void *)uint64_t v65 = v60;
              *(_WORD *)&v65[8] = 2112;
              *(void *)&v65[10] = @"Bad ptr";
              unint64_t v24 = buf;
              BOOL v25 = v23;
LABEL_42:
              _os_log_error_impl(&dword_1876B1000, v25, OS_LOG_TYPE_ERROR, "%@: %s - %@", v24, 0x20u);
            }

            goto LABEL_43;
          }

          uint64_t v21 = packet;
          ne_log_obj();
          id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412802;
            uint64_t v63 = v4;
            uint64_t v64 = 2080;
            *(void *)uint64_t v65 = v60;
            *(_WORD *)&v65[8] = 2112;
            *(void *)&v65[10] = @"Bad detach";
            _os_log_error_impl(&dword_1876B1000, v22, OS_LOG_TYPE_ERROR, "%@: %s - %@", buf, 0x20u);
          }

          if (!*((void *)v4 + 2)) {
            goto LABEL_46;
          }
LABEL_63:
          os_channel_packet_free();
LABEL_44:
LABEL_46:
          int v26 = 0;
LABEL_47:

          v6 += v26;
        }

        next_buflet = os_packet_get_next_buflet();
        if (next_buflet)
        {
          uint64_t v28 = next_buflet;
          data_offset = os_buflet_get_data_offset();
          object_address = os_buflet_get_object_address();
          if (object_address)
          {
            int v30 = object_address;
            data_length = (unsigned __int16)os_packet_get_data_length();
            ne_log_obj();
            unint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            int v54 = data_length;
            if (!(_DWORD)data_length)
            {
              uint64_t v38 = v32;
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412802;
                uint64_t v63 = v4;
                uint64_t v64 = 2080;
                *(void *)uint64_t v65 = v60;
                *(_WORD *)&v65[8] = 2112;
                *(void *)&v65[10] = @"Bad frame length";
                _os_log_error_impl(&dword_1876B1000, v38, OS_LOG_TYPE_ERROR, "%@: %s - %@", buf, 0x20u);
              }

              int v5 = (os_unfair_lock_s *)(v4 + 8);
              if (!*((void *)v4 + 2))
              {
LABEL_80:
                int v26 = 0;
                int v9 = v61;
                goto LABEL_47;
              }

              os_channel_packet_free();
              int v9 = v61;
LABEL_45:
              os_unfair_lock_lock(v5);
              -[NEFilterPacketInterpose close_nolock:]((uint64_t)v17, 1);
              os_unfair_lock_unlock(v5);
              goto LABEL_46;
            }

            int v33 = v32;
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 138412802;
              uint64_t v63 = v4;
              uint64_t v64 = 1024;
              *(_DWORD *)uint64_t v65 = v54;
              *(_WORD *)&v65[4] = 2080;
              *(void *)&v65[6] = v60;
              _os_log_debug_impl( &dword_1876B1000,  v33,  OS_LOG_TYPE_DEBUG,  "%@: receiveDatafromRing: read %u bytes on %s rx ring",  buf,  0x1Cu);
            }

            *((void *)v4 + 5) = v19;
            if (!os_channel_advance_slot())
            {
              int v39 = v30 + data_offset;
              v4[48] = v57;
              *((void *)v4 + 7) = v39;
              *((_DWORD *)v4 + 16) = v54;
              *((void *)v4 + 9) = v21;
              *((void *)v4 + 10) = v28;
              *((void *)v4 + 11) = v4 + 48;
              unint64_t v40 = (void *)*((void *)v4 + 18);
              if (v40) {
                objc_setProperty_atomic(v40, v34, v17, 8LL);
              }
              os_unfair_lock_unlock(lock);
              [*((id *)v4 + 16) packetHandler];
              unint64_t v41 = (uint64_t (**)(void, void, void, void, void, void))objc_claimAutoreleasedReturnValue();
              unint64_t v42 = v41[2](v41, *((void *)v4 + 18), *((void *)v4 + 17), v56, v39, v54);

              int v5 = (os_unfair_lock_s *)(v4 + 8);
              os_unfair_lock_lock(lock);
              uint64_t v44 = (void *)*((void *)v4 + 18);
              if (v44) {
                objc_setProperty_atomic(v44, v43, 0LL, 8LL);
              }
              if (!*((void *)v4 + 2)) {
                goto LABEL_80;
              }
              ne_log_obj();
              uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 138412546;
                uint64_t v63 = v4;
                uint64_t v64 = 2048;
                *(void *)uint64_t v65 = v42;
                _os_log_debug_impl( &dword_1876B1000,  v45,  OS_LOG_TYPE_DEBUG,  "%@: receiveDatafromRing: verdict %ld",  buf,  0x16u);
              }

              if (v42 != 2)
              {
                int v9 = v61;
                if (!v42)
                {
                  int v46 = *(void *)&v4[v55];
                  if (v46)
                  {
                    sendDataOnRing(v17, v46, v57);
                    int v26 = 1;
                    goto LABEL_47;
                  }
                }

                goto LABEL_85;
              }

              int v9 = v61;
              if (*((void *)v4 + 11))
              {
                ne_log_obj();
                int64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 138412290;
                  uint64_t v63 = v4;
                  _os_log_error_impl( &dword_1876B1000,  v47,  OS_LOG_TYPE_ERROR,  "%@: receiveDatafromRing: returned Delay verdict but packet hasn't been delayed",  buf,  0xCu);
                }

                *((void *)v4 + 11) = 0LL;
LABEL_85:
                if (*((void *)v4 + 2)) {
                  os_channel_packet_free();
                }
                goto LABEL_46;
              }

              goto LABEL_46;
            }

            ne_log_obj();
            uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412802;
              uint64_t v63 = v4;
              uint64_t v64 = 2080;
              *(void *)uint64_t v65 = v60;
              *(_WORD *)&v65[8] = 2112;
              *(void *)&v65[10] = @"Failed to advance slot";
              _os_log_error_impl(&dword_1876B1000, v35, OS_LOG_TYPE_ERROR, "%@: %s - %@", buf, 0x20u);
            }

            int v5 = (os_unfair_lock_s *)(v4 + 8);
            int v9 = v61;
            if (!*((void *)v4 + 2)) {
              goto LABEL_46;
            }
            goto LABEL_63;
          }

          ne_log_obj();
          int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
            goto LABEL_62;
          }
          *(_DWORD *)buf = 138412802;
          uint64_t v63 = v4;
          uint64_t v64 = 2080;
          *(void *)uint64_t v65 = v60;
          *(_WORD *)&v65[8] = 2112;
          *(void *)&v65[10] = @"Bad address";
          uint64_t v37 = v36;
        }

        else
        {
          ne_log_obj();
          int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
            goto LABEL_62;
          }
          *(_DWORD *)buf = 138412802;
          uint64_t v63 = v4;
          uint64_t v64 = 2080;
          *(void *)uint64_t v65 = v60;
          *(_WORD *)&v65[8] = 2112;
          *(void *)&v65[10] = @"Bad buflet";
          uint64_t v37 = v36;
        }

        _os_log_error_impl(&dword_1876B1000, v37, OS_LOG_TYPE_ERROR, "%@: %s - %@", buf, 0x20u);
LABEL_62:

        int v5 = (os_unfair_lock_s *)(v4 + 8);
        if (!*((void *)v4 + 2)) {
          goto LABEL_46;
        }
        goto LABEL_63;
      }
    }

LABEL_45:
    -[NERelay setIdentityReference:](v107, "setIdentityReference:", 0LL);
    [v18 objectForKeyedSubscript:@"PayloadCertificateUUID"];
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();

    if (v37)
    {
      [NSString stringWithFormat:@"%@%u", @"_PayloadCertificateRef", v104];
      uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
      [v18 objectForKeyedSubscript:@"PayloadCertificateUUID"];
      int v39 = (void *)objc_claimAutoreleasedReturnValue();
      [v9 addCertificatePending:v39 certificateTag:v38];

      [v18 objectForKeyedSubscript:@"PayloadIntermediateCertificateUUIDs"];
      unint64_t v40 = (id)objc_claimAutoreleasedReturnValue();
      if (isa_nsarray(v40) && (unint64_t)[v40 count] <= 4)
      {
        v97 = v38;
        v122 = 0u;
        v123 = 0u;
        v120 = 0u;
        v121 = 0u;
        unint64_t v40 = v40;
        unint64_t v41 = [v40 countByEnumeratingWithState:&v120 objects:v135 count:16];
        if (v41)
        {
          unint64_t v42 = v41;
          char v43 = 0LL;
          uint64_t v44 = *(void *)v121;
          do
          {
            for (k = 0LL; k != v42; ++k)
            {
              if (*(void *)v121 != v44) {
                objc_enumerationMutation(v40);
              }
              int v46 = *(void **)(*((void *)&v120 + 1) + 8 * k);
              if (isa_nsstring(v46))
              {
                [NSString stringWithFormat:@"%@%u-%u", @"_PayloadCertificateRef", v104, v43];
                int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
                [v9 addCertificatePending:v46 certificateTag:v47];
                char v43 = (v43 + 1);
              }
            }

            unint64_t v42 = [v40 countByEnumeratingWithState:&v120 objects:v135 count:16];
          }

          while (v42);
        }

        uint64_t v12 = v93;
        a1 = v94;
        int v16 = v92;
        int v18 = v102;
        unint64_t v19 = v103;
        uint64_t v38 = v97;
      }

      goto LABEL_60;
    }

    [v18 objectForKeyedSubscript:@"LocalCertificate"];
    int v48 = (void *)objc_claimAutoreleasedReturnValue();

    if (v48)
    {
      [v18 objectForKeyedSubscript:@"LocalCertificate"];
      uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
      setLocalCertificate(v38);
      unint64_t v40 = (id)objc_claimAutoreleasedReturnValue();
      -[NERelay setIdentityReference:](v107, "setIdentityReference:", v40);
LABEL_60:
    }

    [v18 objectForKeyedSubscript:@"RawPublicKeys"];
    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
    if (isa_nsarray(v49))
    {
      v118 = 0u;
      v119 = 0u;
      v116 = 0u;
      v117 = 0u;
      uint64_t v50 = v49;
      int v51 = [v50 countByEnumeratingWithState:&v116 objects:v134 count:16];
      if (v51)
      {
        uint64_t v52 = v51;
        uint64_t v53 = *(void *)v117;
LABEL_64:
        int v54 = 0LL;
        while (1)
        {
          if (*(void *)v117 != v53) {
            objc_enumerationMutation(v50);
          }
          if (v52 == ++v54)
          {
            uint64_t v52 = [v50 countByEnumeratingWithState:&v116 objects:v134 count:16];
            if (v52) {
              goto LABEL_64;
            }
            break;
          }
        }
      }

      -[NERelay setRawPublicKeys:](v107, "setRawPublicKeys:", v50);
      int v18 = v102;
      unint64_t v19 = v103;
    }

    -[os_log_s addObject:](v16, "addObject:", v107);

    unsigned __int16 v17 = v104 + 1;
    if (v104 + 1 == v98) {
      goto LABEL_72;
    }
  }

  ne_log_obj();
  v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  v103 = v83;
  if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
  {
    uint64_t v84 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412290;
    v139 = v84;
    __int16 v85 = v84;
    _os_log_error_impl( &dword_1876B1000,  v83,  OS_LOG_TYPE_ERROR,  "%@ initWithRelayPayload failed, relay is not dictionary",  buf,  0xCu);
  }
}
}

        int v20 = *v24;

        if (!v20 || v23 + 4 > v4) {
          goto LABEL_54;
        }
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        uint64_t v35 = v28;
        int v36 = objc_alloc(MEMORY[0x189603FB8]);
        uint64_t v38 = (void *)objc_msgSend( v36,  "initWithCapacity:",  objc_msgSend(objc_getProperty(v35, v37, 24, 1), "length") + 32);
        [v38 appendBytes:v3 length:28];
        [v38 appendBytes:v24 length:4];
        objc_msgSend(v38, "appendData:", objc_getProperty(v35, v39, 24, 1));
        objc_setProperty_atomic(v35, v40, v38, 24LL);
        *((void *)v35 + 4) = *v24;
        if (v5) {
          objc_setProperty_atomic((id)v5, v41, v35, 48LL);
        }
        objc_opt_class();
        isKindOfClass = objc_opt_isKindOfClass();
        if (v5 && (isKindOfClass & 1) != 0)
        {
          *(_BYTE *)(v5 + 9) = 1;
          *(_DWORD *)(v5 + 16) = *((_DWORD *)v35 + 10);
          *(_DWORD *)(v5 + 20) = *((_DWORD *)v35 + 11);
        }

        goto LABEL_54;
      }

      if (!v55)
      {
        ne_log_obj();
        unint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v33 = os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
        if (v26 < 0)
        {
          if (v33)
          {
            int v51 = *(unsigned __int8 *)(v3 + 18);
            *(_DWORD *)buf = v53;
            v60[0] = v20;
            LOWORD(v60[1]) = 1024;
            *(_DWORD *)((char *)&v60[1] + 2) = v51;
            _os_log_error_impl( &dword_1876B1000,  v32,  OS_LOG_TYPE_ERROR,  "Unencrypted critical payload type %u is not permitted for packet type %u",  buf,  0xEu);
          }

LABEL_119:
  SEL v74 = 0LL;
  uint64_t v7 = v96;
  id v8 = v95;
LABEL_120:

LABEL_108:
LABEL_109:

LABEL_110:
  return v74;
}

  objc_setProperty_atomic(v8, v94, v17, 112LL);
  [v6 additionalKEMProtocols];
  v103 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v103)
  {
    v129 = -[os_log_s additionalKEMProtocols](v8, "additionalKEMProtocols");
    if (v129) {
      -[NEIKEv2IKESAProposal setChosenAdditionalKEMProtocols:](v8, MEMORY[0x189604A60]);
    }
    v126 = v8;
    goto LABEL_157;
  }

  v132 = a3;
  v104 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FE0]), "initWithObjects:", v17, 0);
  v105 = objc_alloc_init(MEMORY[0x189603FC8]);
  v106 = 6LL;
  v131 = v105;
  v133 = v6;
  v135 = v8;
  while (1)
  {
    [MEMORY[0x189607968] numberWithUnsignedInteger:v106];
    v107 = (void *)objc_claimAutoreleasedReturnValue();
    v108 = -[os_log_s additionalKEMProtocols](v8, "additionalKEMProtocols");
    [v108 objectForKeyedSubscript:v107];
    v109 = (void *)objc_claimAutoreleasedReturnValue();

    [v6 additionalKEMProtocols];
    v110 = (void *)objc_claimAutoreleasedReturnValue();
    [v110 objectForKeyedSubscript:v107];
    v111 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v111) {
      goto LABEL_136;
    }
    if (v109) {
      break;
    }
    v119 = -[NEIKEv2KEMProtocol initWithMethod:](objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol), "initWithMethod:", 0LL);
    [v105 setObject:v119 forKeyedSubscript:v107];

LABEL_136:
    v118 = 0LL;
LABEL_151:

    ++v106;
    id v8 = v135;
    if (v106 == 13)
    {
      v125 = (void *)[objc_alloc(MEMORY[0x189603F68]) initWithDictionary:v105];
      -[NEIKEv2IKESAProposal setChosenAdditionalKEMProtocols:](v135, v125);

      v126 = v135;
      goto LABEL_170;
    }
  }

  v134 = v107;
  if (v132)
  {
    v142 = 0uLL;
    v143 = 0uLL;
    v140 = 0uLL;
    v141 = 0uLL;
    v112 = v111;
    v113 = [v112 countByEnumeratingWithState:&v140 objects:v177 count:16];
    if (v113)
    {
      v114 = v113;
      v115 = *(void *)v141;
      do
      {
        for (n = 0LL; n != v114; ++n)
        {
          if (*(void *)v141 != v115) {
            objc_enumerationMutation(v112);
          }
          v117 = [v109 indexOfObject:*(void *)(*((void *)&v140 + 1) + 8 * n)];
          if (v117 != 0x7FFFFFFFFFFFFFFFLL)
          {
            [v109 objectAtIndexedSubscript:v117];
            v118 = (id)objc_claimAutoreleasedReturnValue();
          }
        }

        v114 = [v112 countByEnumeratingWithState:&v140 objects:v177 count:16];
      }

      while (v114);
      v111 = v112;
LABEL_163:
      v105 = v131;
      v107 = v134;
    }

    else
    {
      v111 = v112;
    }

LABEL_83:
    goto LABEL_84;
  }

  if (!SCNetworkInterfaceSetConfiguration(v37, v25))
  {
    ne_log_obj();
    uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      [(id)v2 name];
      uint64_t v49 = (const __SCNetworkService *)objc_claimAutoreleasedReturnValue();
      uint64_t v56 = SCError();
      unint64_t v57 = SCErrorString(v56);
      id v75 = 138412546;
      uint64_t v76 = v49;
      unint64_t v77 = 2080;
      unint64_t v78 = (void *)v57;
      uint64_t v50 = "Failed to set the interface configuration for configuration %@: %s";
      int v51 = v44;
      uint64_t v52 = 22;
      goto LABEL_60;
    }

    goto LABEL_83;
  }

  [(id)v2 VPN];
  int v39 = (void *)objc_claimAutoreleasedReturnValue();
  [v39 protocol];
  unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v41 = [v40 setServiceProtocolsInService:v11];

  if (!v41) {
    goto LABEL_84;
  }
  [(id)v2 payloadInfo];
  unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();

  if (v42)
  {
    [(id)v2 payloadInfo];
    char v43 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v44 = (os_log_s *)[v43 copyLegacyDictionary];

    if (v44)
    {
      if ((+[NEConfiguration setConfiguration:forProtocol:inService:]( (uint64_t)&OBJC_CLASS___NEConfiguration,  v44,  @"com.apple.payload",  v11) & 1) != 0)
      {

        goto LABEL_46;
      }

      ne_log_obj();
      int v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
        goto LABEL_82;
      }
      [(id)v2 name];
      uint64_t v67 = (const __SCNetworkService *)objc_claimAutoreleasedReturnValue();
      id v75 = 138412290;
      uint64_t v76 = v67;
      uint64_t v68 = "Failed to set the profile payload info for configuration %@";
    }

    else
    {
      ne_log_obj();
      int v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
      {
LABEL_82:

        goto LABEL_83;
      }

      [(id)v2 name];
      uint64_t v67 = (const __SCNetworkService *)objc_claimAutoreleasedReturnValue();
      id v75 = 138412290;
      uint64_t v76 = v67;
      uint64_t v68 = "Failed to create a legacy profile payload dictionary for configuration %@";
    }

    _os_log_error_impl(&dword_1876B1000, v66, OS_LOG_TYPE_ERROR, v68, (uint8_t *)&v75, 0xCu);

    goto LABEL_82;
  }

LABEL_46:
  unint64_t v2 = 1LL;
LABEL_86:
  if (v11) {
    CFRelease(v11);
  }

  return v2;
}

  +[NEConfiguration addError:toList:]((uint64_t)&OBJC_CLASS___NEConfiguration, v10, v4);
LABEL_47:
  int v48 = 0;
LABEL_48:

  return v48;
}

                if ([v3 ppkMandatory])
                {
                  ne_log_obj();
                  unint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)buf = 0;
                    unint64_t v41 = "Wrong PPK ID received with mandatory PPK auth";
LABEL_76:
                    _os_log_error_impl(&dword_1876B1000, v40, OS_LOG_TYPE_ERROR, v41, buf, 2u);
                    goto LABEL_69;
                  }

                  goto LABEL_69;
                }

                unint64_t v42 = *(id *)(v6 + 384);

                ne_log_obj();
                char v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                unint64_t v40 = v43;
                if (!v42)
                {
                  if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)buf = 0;
                    unint64_t v41 = "Wrong PPK ID received and no non-PPK AUTH data received";
                    goto LABEL_76;
                  }

        goto LABEL_47;
      }
    }

    int v9 = -[os_log_s countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v379,  v390,  16LL);
  }

  while (v9);
LABEL_14:

LABEL_15:
  if (-[NEIKEv2Packet hasNotification:]((void *)a1, (const char *)0x4017))
  {
    ne_log_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v65 = (char *)[(id)a1 copyShortDescription];
      buf = 138412290;
      v384 = v65;
      _os_log_error_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_ERROR,  "%@ Received notify server redirect",  (uint8_t *)&buf,  0xCu);
    }

    Error = (os_log_s *)NEIKEv2CreateError(5LL);
    goto LABEL_19;
  }

  objc_getProperty((id)a1, v13, 88LL, 1);
  int v16 = (void *)objc_claimAutoreleasedReturnValue();

  if (v16)
  {
    objc_getProperty((id)a1, v17, 88LL, 1);
    Property = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v7 = Property;
    if (Property) {
      Property = (os_log_s *)objc_getProperty(Property, v19, 32LL, 1);
    }
    int v20 = Property;
    objc_setProperty_atomic((id)v5, v21, v20, 280LL);
    goto LABEL_46;
  }

  uint64_t v29 = objc_getProperty((id)a1, v17, 40LL, 1);
  int v30 = [v29 value];

  if (!v30)
  {
    ne_log_obj();
    int v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      v159 = (char *)[(id)a1 copyShortDescription];
      buf = 138412290;
      v384 = v159;
      _os_log_error_impl( &dword_1876B1000,  v48,  OS_LOG_TYPE_ERROR,  "%@ Received no remote SPI on SA_INIT",  (uint8_t *)&buf,  0xCu);
    }

    Error = (os_log_s *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Received no remote SPI on SA_INIT",  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v361);
LABEL_19:
    uint64_t v7 = Error;
    -[NEIKEv2IKESA setState:error:](v5, 3uLL, Error);
    goto LABEL_47;
  }

  unint64_t v32 = objc_getProperty((id)a1, v31, 40LL, 1);
  -[NEIKEv2IKESA assignRemoteSPI:]((void *)v5, v32);

  objc_getProperty((id)a1, v33, 96LL, 1);
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
  int v36 = v34;
  if (v34) {
    uint64_t v34 = objc_getProperty(v34, v35, 24LL, 1);
  }
  uint64_t v7 = v34;

  if (-[os_log_s count](v7, "count") != 1)
  {
    ne_log_obj();
    uint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      v160 = (char *)[(id)a1 copyShortDescription];
      v161 = -[os_log_s count](v7, "count");
      buf = 138412546;
      v384 = v160;
      v385 = 1024;
      LODWORD(v386) = v161;
      _os_log_error_impl( &dword_1876B1000,  v56,  OS_LOG_TYPE_ERROR,  "%@ Received %u SA proposals, require 1",  (uint8_t *)&buf,  0x12u);
    }

    unint64_t v57 = -[os_log_s count](v7, "count");
    ErrorPeerInvalidSyntax = (NEIKEv2AuthenticationProtocol *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Invalid SA proposal count %u",  v58,  v59,  v60,  v61,  v62,  v63,  v64,  v57);
    -[NEIKEv2IKESA setState:error:](v5, 3uLL, ErrorPeerInvalidSyntax);
    a1 = 0LL;
    goto LABEL_109;
  }

  -[os_log_s firstObject](v7, "firstObject");
  ErrorPeerInvalidSyntax = (NEIKEv2AuthenticationProtocol *)objc_claimAutoreleasedReturnValue();
  if ((-[NEIKEv2IKESAProposal isAValidResponse](ErrorPeerInvalidSyntax, v38) & 1) == 0)
  {
    ne_log_obj();
    int v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
    {
      v171 = (char *)[(id)a1 copyShortDescription];
      buf = 138412546;
      v384 = v171;
      v385 = 2112;
      v386 = ErrorPeerInvalidSyntax;
      _os_log_error_impl( &dword_1876B1000,  v66,  OS_LOG_TYPE_ERROR,  "%@ Received invalid SA proposal %@",  (uint8_t *)&buf,  0x16u);
    }

    SEL v74 = (id)NEIKEv2CreateErrorPeerInvalidSyntax( @"Received invalid SA proposal",  v67,  v68,  v69,  v70,  v71,  v72,  v73,  v361);
    -[NEIKEv2IKESA setState:error:](v5, 3uLL, v74);
    a1 = 0LL;
    goto LABEL_108;
  }

  v377 = 0u;
  v378 = 0u;
  v375 = 0u;
  v376 = 0u;
  unint64_t v40 = objc_getProperty((id)v5, v39, 80LL, 1);
  [v40 proposals];
  unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();

  unint64_t v42 = [v41 countByEnumeratingWithState:&v375 objects:v389 count:16];
  if (!v42)
  {
LABEL_43:

LABEL_88:
    ne_log_obj();
    v139 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR))
    {
      v173 = (char *)[(id)a1 copyShortDescription];
      v175 = objc_getProperty((id)v5, v174, 80LL, 1);
      [v175 proposals];
      v176 = (void *)objc_claimAutoreleasedReturnValue();
      buf = 138412802;
      v384 = v173;
      v385 = 2112;
      v386 = ErrorPeerInvalidSyntax;
      v387 = 2112;
      v388 = (uint64_t)v176;
      _os_log_error_impl( &dword_1876B1000,  v139,  OS_LOG_TYPE_ERROR,  "%@ Received proposal %@ does not match config %@",  (uint8_t *)&buf,  0x20u);
    }

    SEL v74 = objc_getProperty((id)v5, v140, 80LL, 1);
    [v74 proposals];
    v141 = (id)objc_claimAutoreleasedReturnValue();
    v149 = (id)NEIKEv2CreateErrorPeerInvalidSyntax( @"Received proposal %@ does not match config %@",  v142,  v143,  v144,  v145,  v146,  v147,  v148,  (uint64_t)ErrorPeerInvalidSyntax);
    -[NEIKEv2IKESA setState:error:](v5, 3uLL, v149);
LABEL_91:

LABEL_106:
    a1 = 0LL;
    goto LABEL_107;
  }

  char v43 = v42;
  uint64_t v44 = *(void *)v376;
LABEL_37:
  uint64_t v45 = 0LL;
  while (1)
  {
    if (*(void *)v376 != v44) {
      objc_enumerationMutation(v41);
    }
    int v46 = *(void **)(*((void *)&v375 + 1) + 8 * v45);
    if ((-[NEIKEv2IKESAProposal matchesLocalProposal:preferRemoteProposal:]( v46,  ErrorPeerInvalidSyntax,  0) & 1) != 0) {
      break;
    }
    if (v43 == ++v45)
    {
      char v43 = [v41 countByEnumeratingWithState:&v375 objects:v389 count:16];
      if (v43) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }

  SEL v74 = v46;

  if (!v74) {
    goto LABEL_88;
  }
  uint64_t v76 = -[NEIKEv2IKESAProposal copyFromRemote:preferRemoteProposal:](v74, ErrorPeerInvalidSyntax, 0);
  objc_setProperty_atomic((id)v5, v77, v76, 96LL);

  uint64_t v79 = objc_getProperty((id)v5, v78, 96LL, 1);
  if (!v79)
  {
    ne_log_obj();
    v150 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
    {
      v206 = (char *)[(id)a1 copyShortDescription];
      buf = 138412546;
      v384 = v206;
      v385 = 2112;
      v386 = ErrorPeerInvalidSyntax;
      _os_log_error_impl( &dword_1876B1000,  v150,  OS_LOG_TYPE_ERROR,  "%@ Could not set chosen proposal values %@",  (uint8_t *)&buf,  0x16u);
    }

    v158 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Could not set chosen proposal values %@",  v151,  v152,  v153,  v154,  v155,  v156,  v157,  (uint64_t)ErrorPeerInvalidSyntax);
    goto LABEL_105;
  }

  int v81 = objc_getProperty((id)v5, v80, 96LL, 1);
  v83 = v81;
  if (v81) {
    int v81 = objc_getProperty(v81, v82, 120LL, 1);
  }
  uint64_t v84 = v81;

  if (v84 && (-[NEIKEv2Packet hasNotification:]((void *)a1, (const char *)0x4036) & 1) == 0)
  {
    ne_log_obj();
    v336 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v336, OS_LOG_TYPE_ERROR))
    {
      v346 = (char *)[(id)a1 copyShortDescription];
      buf = 138412546;
      v384 = v346;
      v385 = 2112;
      v386 = ErrorPeerInvalidSyntax;
      _os_log_error_impl( &dword_1876B1000,  v336,  OS_LOG_TYPE_ERROR,  "%@ Chosen proposal requires IKE_INTERMEDIATE but peer does not support it %@ ",  (uint8_t *)&buf,  0x16u);
    }

    v158 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Chosen proposal requires IKE_INTERMEDIATE but peer does not support it %@",  v337,  v338,  v339,  v340,  v341,  v342,  v343,  (uint64_t)ErrorPeerInvalidSyntax);
    goto LABEL_105;
  }

  objc_getProperty((id)a1, v85, 104LL, 1);
  int v86 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v86)
  {
    ne_log_obj();
    v162 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v162, OS_LOG_TYPE_ERROR))
    {
      v208 = (char *)[(id)a1 copyShortDescription];
      buf = 138412290;
      v384 = v208;
      _os_log_error_impl( &dword_1876B1000,  v162,  OS_LOG_TYPE_ERROR,  "%@ Did not receive KE payload",  (uint8_t *)&buf,  0xCu);
    }

    v170 = @"Did not receive KE payload";
    goto LABEL_104;
  }

  objc_getProperty((id)a1, v87, 104LL, 1);
  int v88 = (void *)objc_claimAutoreleasedReturnValue();
  CFErrorRef v90 = v88;
  if (v88) {
    int v88 = objc_getProperty(v88, v89, 24LL, 1);
  }
  unint64_t v91 = v88;

  if (!v91)
  {
    ne_log_obj();
    v172 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v172, OS_LOG_TYPE_ERROR))
    {
      v209 = (char *)[(id)a1 copyShortDescription];
      buf = 138412290;
      v384 = v209;
      _os_log_error_impl( &dword_1876B1000,  v172,  OS_LOG_TYPE_ERROR,  "%@ Did not receive method in KE payload",  (uint8_t *)&buf,  0xCu);
    }

    v170 = @"Did not receive method in KE payload";
    goto LABEL_104;
  }

  objc_getProperty((id)a1, v92, 104LL, 1);
  v93 = (void *)objc_claimAutoreleasedReturnValue();
  v95 = v93;
  if (v93) {
    v93 = objc_getProperty(v93, v94, 32LL, 1);
  }
  v96 = v93;

  if (!v96)
  {
    ne_log_obj();
    v177 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v177, OS_LOG_TYPE_ERROR))
    {
      v294 = (char *)[(id)a1 copyShortDescription];
      buf = 138412290;
      v384 = v294;
      _os_log_error_impl( &dword_1876B1000,  v177,  OS_LOG_TYPE_ERROR,  "%@ Did not receive data in KE payload",  (uint8_t *)&buf,  0xCu);
    }

    v170 = @"Did not receive data in KE payload";
LABEL_104:
    v158 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v170, v163, v164, v165, v166, v167, v168, v169, v361);
LABEL_105:
    v141 = v158;
    -[NEIKEv2IKESA setState:error:](v5, 3uLL, v158);
    goto LABEL_106;
  }

  objc_getProperty((id)a1, v97, 104LL, 1);
  v98 = (void *)objc_claimAutoreleasedReturnValue();
  v100 = v98;
  v373 = v74;
  if (v98) {
    v98 = objc_getProperty(v98, v99, 24LL, 1);
  }
  v101 = v98;
  selfd = (id)[v101 method];
  v103 = objc_getProperty((id)v5, v102, 96LL, 1);
  v105 = -[NEIKEv2IKESAProposal kemProtocol](v103, v104);
  v106 = [v105 method];

  if (selfd != (id)v106)
  {
    ne_log_obj();
    v178 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    SEL v74 = v373;
    v179 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
    if (os_log_type_enabled(v178, OS_LOG_TYPE_ERROR))
    {
      v367 = (char *)[(id)a1 copyShortDescription];
      objc_getProperty((id)a1, v306, 104LL, 1);
      v307 = (void *)objc_claimAutoreleasedReturnValue();
      selfc = v307;
      if (v307) {
        v307 = objc_getProperty(v307, v308, 24LL, 1);
      }
      v364 = v307;
      v309 = [v364 method];
      v311 = objc_getProperty((id)v5, v310, 96LL, 1);
      v313 = -[NEIKEv2IKESAProposal kemProtocol](v311, v312);
      v314 = [v313 method];
      buf = 138412802;
      v384 = v367;
      v385 = 2048;
      v386 = (NEIKEv2AuthenticationProtocol *)v309;
      v387 = 2048;
      v388 = v314;
      _os_log_error_impl( &dword_1876B1000,  v178,  OS_LOG_TYPE_ERROR,  "%@ Did not receive matching method from KE payload (%zu != %zu)",  (uint8_t *)&buf,  0x20u);

      SEL v74 = v373;
      v179 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
    }

    objc_getProperty((id)a1, v180, v179[737], 1);
    v181 = (void *)objc_claimAutoreleasedReturnValue();
    v141 = v181;
    if (v181) {
      v181 = objc_getProperty(v181, v182, 24LL, 1);
    }
    v149 = v181;
    v183 = [v149 method];
    v185 = objc_getProperty((id)v5, v184, 96LL, 1);
    v187 = -[NEIKEv2IKESAProposal kemProtocol](v185, v186);
    [v187 method];
    v195 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Did not receive matching method from KE payload (%zu != %zu)",  v188,  v189,  v190,  v191,  v192,  v193,  v194,  v183);
    -[NEIKEv2IKESA setState:error:](v5, 3uLL, v195);

    goto LABEL_91;
  }

  objc_getProperty((id)a1, v107, 104LL, 1);
  v108 = (void *)objc_claimAutoreleasedReturnValue();
  v110 = v108;
  if (v108) {
    v108 = objc_getProperty(v108, v109, 32LL, 1);
  }
  v111 = v108;
  objc_setProperty_atomic((id)v5, v112, v111, 152LL);

  objc_getProperty((id)a1, v113, 112LL, 1);
  v114 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v114)
  {
    ne_log_obj();
    v197 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v197, OS_LOG_TYPE_ERROR))
    {
      v318 = (char *)[(id)a1 copyShortDescription];
      buf = 138412290;
      v384 = v318;
      _os_log_error_impl( &dword_1876B1000,  v197,  OS_LOG_TYPE_ERROR,  "%@ Did not receive NONCE payload",  (uint8_t *)&buf,  0xCu);
    }

    v205 = @"Did not receive NONCE payload";
    goto LABEL_125;
  }

  objc_getProperty((id)a1, v115, 112LL, 1);
  v116 = (void *)objc_claimAutoreleasedReturnValue();
  v118 = v116;
  if (v116) {
    v116 = objc_getProperty(v116, v117, 24LL, 1);
  }
  v119 = v116;

  if (!v119)
  {
    ne_log_obj();
    v207 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v207, OS_LOG_TYPE_ERROR))
    {
      v321 = (char *)[(id)a1 copyShortDescription];
      buf = 138412290;
      v384 = v321;
      _os_log_error_impl( &dword_1876B1000,  v207,  OS_LOG_TYPE_ERROR,  "%@ Did not receive NONCE data",  (uint8_t *)&buf,  0xCu);
    }

    v205 = @"Did not receive NONCE data";
LABEL_125:
    v138 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v205, v198, v199, v200, v201, v202, v203, v204, v361);
    goto LABEL_126;
  }

  v121 = objc_getProperty((id)v5, v120, 80LL, 1);
  v122 = [v121 strictNonceSizeChecks];

  if (!v122) {
    goto LABEL_133;
  }
  objc_getProperty((id)a1, v123, 112LL, 1);
  v124 = (void *)objc_claimAutoreleasedReturnValue();
  v126 = v124;
  if (v124) {
    v124 = objc_getProperty(v124, v125, 24LL, 1);
  }
  v127 = v124;
  v128 = [v127 length];

  self = (NEIKEv2AuthenticationProtocol *)v128;
  if ((unint64_t)(v128 - 257) > 0xFFFFFFFFFFFFFF0ELL)
  {
    v210 = objc_getProperty((id)v5, v129, 96LL, 1);
    v212 = -[NEIKEv2IKESAProposal prfProtocol](v210, v211);
    v213 = [v212 nonceSize];

    if ((unint64_t)self < v213)
    {
      ne_log_obj();
      v214 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
      {
        v328 = (char *)[(id)a1 copyShortDescription];
        v330 = objc_getProperty((id)v5, v329, 96LL, 1);
        v332 = -[NEIKEv2IKESAProposal prfProtocol](v330, v331);
        buf = 138412802;
        v384 = v328;
        v385 = 2048;
        v386 = self;
        v387 = 2112;
        v388 = (uint64_t)v332;
        _os_log_error_impl( &dword_1876B1000,  v214,  OS_LOG_TYPE_ERROR,  "%@ NONCE data length %zu is shorter than the minimum for PRF protocol %@",  (uint8_t *)&buf,  0x20u);
      }

      v141 = objc_getProperty((id)v5, v215, 96LL, 1);
      v217 = -[NEIKEv2IKESAProposal prfProtocol](v141, v216);
      v225 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"NONCE data length %zu is shorter than the minimum for PRF protocol %@",  v218,  v219,  v220,  v221,  v222,  v223,  v224,  (uint64_t)self);
      -[NEIKEv2IKESA setState:error:](v5, 3uLL, v225);

      goto LABEL_184;
    }
}

    uint64_t v52 = 0;
    goto LABEL_27;
  }

  if (a4 == 9)
  {
    int v51 = 0LL;
    uint64_t v50 = 0LL;
    if (a12)
    {
      uint64_t v60 = a3;
      uint64_t v52 = 0;
      if (a14) {
        goto LABEL_27;
      }
      goto LABEL_36;
    }

    goto LABEL_46;
  }

  if (a4 != 3) {
    goto LABEL_26;
  }
  uint64_t v60 = a3;
  if (!a12) {
    goto LABEL_26;
  }
LABEL_36:
  uint64_t v59 = v37;
  uint64_t v52 = ((*a6 - 1) | 7) + ((a13 - 1) | 7) + ((a15 - 1) | 7) + 236 + ((*a7 - 1) | 7);
  Mutable = CFDataCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  ((*a6 - 1LL) | 7) + ((a13 - 1) | 7) + ((a15 - 1) | 7) + 236 + ((*a7 - 1LL) | 7));
  uint64_t v50 = Mutable;
  uint64_t v61 = Mutable;
  if (Mutable)
  {
    v66.location = CFDataGetLength(Mutable);
    *(_DWORD *)buf = 65539;
    *(_DWORD *)uint64_t v63 = a8;
    *(_WORD *)&v63[4] = a10;
    v63[6] = a14;
    v63[7] = a12;
    *(_DWORD *)&v63[8] = a16;
    *(_WORD *)&v63[18] = __rev16(a23);
    *(_DWORD *)&v63[12] = __PAIR32__(a25, a24);
    *(_WORD *)&v63[16] = a26;
    v66.length = 0LL;
    CFDataReplaceBytes(v50, v66, buf, 24LL);
    v67.location = CFDataGetLength(v50);
    *(_DWORD *)buf = 1245186;
    v63[0] = a5;
    *(_WORD *)&v63[6] = 0;
    *(_DWORD *)&v63[8] = a9;
    v63[1] = a27;
    *(_DWORD *)&v63[2] = a17 | 1;
    v67.length = 0LL;
    CFDataReplaceBytes(v50, v67, buf, 16LL);
    v68.location = CFDataGetLength(v50);
    v68.length = 5LL;
    NEPFKeySetSADBAddr(v50, v68, a6, v59, 255);
    v69.location = CFDataGetLength(v50);
    v69.length = 6LL;
    NEPFKeySetSADBAddr(v50, v69, a7, v59, 255);
    if (a4 != 9 && a12)
    {
      v70.location = CFDataGetLength(v50);
      v70.length = 9LL;
      NEPFKeySetSADBKey(v50, v70, a11, a13);
    }

    if (a14)
    {
      v71.location = CFDataGetLength(v50);
      v71.length = 8LL;
      NEPFKeySetSADBKey(v50, v71, &a11[a13], a15);
    }

    if (a28 != 0)
    {
      v72.location = CFDataGetLength(v50);
      v72.length = 22LL;
      NEPFKeySetSADBIPSecIF(v50, v72, 0LL, *((char **)&a28 + 1), (char *)a28, 0);
    }

    v73.location = CFDataGetLength(v50);
    *(_DWORD *)buf = 196612;
    *(_DWORD *)uint64_t v63 = a18;
    *(void *)&v63[4] = a19;
    *(void *)&v63[12] = a20;
    uint64_t v64 = a21;
    v73.length = 0LL;
    CFDataReplaceBytes(v50, v73, buf, 32LL);
    v74.location = CFDataGetLength(v50);
    *(_DWORD *)buf = 262148;
    *(_DWORD *)uint64_t v63 = 80 * a18 / 0x64u;
    *(void *)&v63[4] = 80 * a19 / 0x64uLL;
    *(void *)&v63[12] = 80 * a20 / 0x64uLL;
    uint64_t v64 = 80 * a21 / 0x64uLL;
    v74.length = 0LL;
    CFDataReplaceBytes(v50, v74, buf, 32LL);
    uint64_t v56 = CFDataGetLength(v50) + 16;
    unint64_t v57 = getpid();
    buf[0] = 2;
    buf[1] = v60;
    buf[2] = 0;
    buf[3] = a4;
    *(_DWORD *)uint64_t v63 = v56 >> 3;
    *(_DWORD *)&v63[4] = a22;
    *(_DWORD *)&v63[8] = v57;
    v75.location = 0LL;
    v75.length = 0LL;
    CFDataReplaceBytes(v50, v75, buf, 16LL);
    int v51 = NEPFKeySend(a1, a2, v50);
  }

  else
  {
    int v51 = 0LL;
  }

  return v33;
}

CFStringRef copyNextName(CFStringRef theString)
{
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, theString, @" ");
  if (ArrayBySeparatingStrings)
  {
    id v3 = ArrayBySeparatingStrings;
    MutableCopy = CFArrayCreateMutableCopy(0LL, 0LL, ArrayBySeparatingStrings);
    CFRelease(v3);
  }

  else
  {
    MutableCopy = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
    CFArrayAppendValue(MutableCopy, theString);
  }

  CFIndex Count = CFArrayGetCount(MutableCopy);
  if (Count < 2
    || (CFIndex v6 = Count - 1,
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, Count - 1),
        SInt32 IntValue = CFStringGetIntValue(ValueAtIndex),
        IntValue < 1))
  {
    uint64_t v9 = 2LL;
  }

  else
  {
    uint64_t v9 = (IntValue + 1);
    CFArrayRemoveValueAtIndex(MutableCopy, v6);
  }

  CFStringRef v10 = CFStringCreateWithFormat(0LL, 0LL, @"%d", v9);
  CFArrayAppendValue(MutableCopy, v10);
  CFRelease(v10);
  CFStringRef v11 = CFStringCreateByCombiningStrings(0LL, MutableCopy, @" ");
  CFRelease(MutableCopy);
  return v11;
}

LABEL_37:
        CFStringRef v11 = 0LL;
LABEL_63:

        return v11;
      }

      int v66 = SCNetworkInterfaceGetInterface(Interface);
      if (!v66) {
        goto LABEL_37;
      }
      uint64_t v67 = SCNetworkInterfaceGetInterfaceType(v66);
      if (CFStringCompare(v67, (CFStringRef)*MEMORY[0x18960C5C8], 0LL)) {
        goto LABEL_37;
      }
      unsigned __int16 v17 = 2LL;
    }

    else
    {
      unsigned __int16 v17 = 1LL;
    }

      uint64_t v28 = 0LL;
      goto LABEL_38;
    }
  }

          goto LABEL_38;
        }

        uint64_t v9 = 256LL;
LABEL_22:
        int v81 = objc_getProperty(a1, v6, v9, 1);
        [MEMORY[0x189607968] numberWithInt:v7];
        int v16 = (void *)objc_claimAutoreleasedReturnValue();
        [v81 objectForKeyedSubscript:v16];
        unsigned __int16 v17 = (NEIKEv2FragmentMap *)objc_claimAutoreleasedReturnValue();

        if (v17 || (unsigned __int16 v17 = objc_alloc_init(&OBJC_CLASS___NEIKEv2FragmentMap)) != 0LL)
        {
          self = v17;
          v83 = objc_getProperty(v17, v18, 16LL, 1);
          unint64_t v19 = 0;
          expectedCFIndex Count = v17->_expectedCount;
        }

        else
        {
          self = 0LL;
          v83 = 0LL;
          expectedCFIndex Count = 0;
          unint64_t v19 = 1;
        }

        uint64_t v21 = *((_DWORD *)v4 + 4);
        id v22 = *((_DWORD *)v4 + 5);
        uint64_t v23 = (unsigned __int16)v22;
        if ((_WORD)v22
          && (unsigned __int16)*((_DWORD *)v4 + 4)
          && (unsigned __int16)v21 <= (unsigned __int16)v22)
        {
          obj = v7;
          if (!expectedCount) {
            goto LABEL_42;
          }
          unint64_t v24 = v19;
          if ((unsigned __int16)v22 == expectedCount)
          {
            [MEMORY[0x189607968] numberWithUnsignedShort:(unsigned __int16)v21];
            BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
            [v83 objectForKeyedSubscript:v25];
            int v26 = (void *)objc_claimAutoreleasedReturnValue();

            if (v26)
            {
              ne_log_obj();
              __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 138412802;
                CFErrorRef v90 = (const char *)a1;
                unint64_t v91 = 1024;
                v92 = (unsigned __int16)v21;
                v93 = 1024;
                v94 = obj;
                _os_log_debug_impl( &dword_1876B1000,  v27,  OS_LOG_TYPE_DEBUG,  "%@ Received duplicate fragment %u for message %d",  buf,  0x18u);
              }

              goto LABEL_34;
            }
          }

          unint64_t v19 = v24;
          if ((unsigned __int16)v22 >= expectedCount)
          {
LABEL_42:
            uint64_t v29 = objc_getProperty(a1, v18, 336LL, 1);
            if ((-[NEIKEv2Packet processReceivedPacketForIKESA:](v4, v29) & 1) != 0)
            {
              unint64_t v14 = (os_log_s *)v81;
              if (expectedCount && (unsigned __int16)v22 > expectedCount)
              {
                ne_log_obj();
                int v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)buf = 138412802;
                  CFErrorRef v90 = (const char *)a1;
                  unint64_t v91 = 1024;
                  v92 = (unsigned __int16)v22;
                  v93 = 1024;
                  v94 = expectedCount;
                  _os_log_impl( &dword_1876B1000,  v30,  OS_LOG_TYPE_INFO,  "%@ Fragment count %u > last received count %u, discarding stored fragments",  buf,  0x18u);
                }

                if ((v19 & 1) != 0) {
                  unint64_t v32 = 0LL;
                }
                else {
                  unint64_t v32 = objc_getProperty(self, v31, 16LL, 1);
                }
                [v32 removeAllObjects];
              }

              [MEMORY[0x189607968] numberWithUnsignedShort:(unsigned __int16)v21];
              int v33 = (void *)objc_claimAutoreleasedReturnValue();
              [v83 setObject:v4 forKeyedSubscript:v33];

              if ([v83 count] == 1)
              {
                if ((v19 & 1) == 0) {
                  self->_expectedCFIndex Count = v22;
                }
                [MEMORY[0x189607968] numberWithInt:obj];
                uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
                [v81 objectForKeyedSubscript:v34];
                uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();

                if (!v35)
                {
                  [MEMORY[0x189607968] numberWithInt:obj];
                  int v36 = (void *)objc_claimAutoreleasedReturnValue();
                  [v81 setObject:self forKeyedSubscript:v36];
                }
              }

              uint64_t v37 = [v83 count];
              uint64_t v38 = v37;
              ne_log_obj();
              int v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 138412546;
                CFErrorRef v90 = (const char *)a1;
                unint64_t v91 = 1024;
                v92 = (unsigned __int16)v22;
                _os_log_impl(&dword_1876B1000, v39, OS_LOG_TYPE_INFO, "%@ Received all %u fragments", buf, 0x12u);
              }

              __int16 v27 = (os_log_s *)[objc_alloc(MEMORY[0x189603FA8]) initWithCapacity:v38];
              unint64_t v40 = 0LL;
              while (1)
              {
                [MEMORY[0x189607968] numberWithUnsignedInteger:++v40];
                unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
                [v83 objectForKeyedSubscript:v41];
                unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();

                if (!v42) {
                  break;
                }
                -[os_log_s addObject:](v27, "addObject:", v42);

                if (v38 == v40)
                {
                  [MEMORY[0x189607968] numberWithInt:obj];
                  char v43 = (void *)objc_claimAutoreleasedReturnValue();
                  [v81 setObject:0 forKeyedSubscript:v43];

                  uint64_t v45 = objc_getProperty(a1, v44, 336LL, 1);
                  __int16 v27 = v27;
                  int v46 = v45;
                  objc_opt_self();
                  if (v27)
                  {
                    if (v46)
                    {
                      -[os_log_s firstObject](v27, "firstObject");
                      int64_t v47 = (_BYTE *)objc_claimAutoreleasedReturnValue();
                      int v48 = objc_alloc_init(MEMORY[0x189603FB8]);
                      __int16 v85 = 0u;
                      int v86 = 0u;
                      __int16 v87 = 0u;
                      int v88 = 0u;
                      obja = v27;
                      uint64_t v49 = -[os_log_s countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v85,  buf,  16LL);
                      if (v49)
                      {
                        int v51 = v49;
                        uint64_t v52 = *(void *)v86;
                        unint64_t v77 = v47;
                        unint64_t v78 = v46;
                        do
                        {
                          uint64_t v53 = 0LL;
                          do
                          {
                            if (*(void *)v86 != v52) {
                              objc_enumerationMutation(obja);
                            }
                            int v54 = *(void **)(*((void *)&v85 + 1) + 8 * v53);
                            if (v54) {
                              BOOL v55 = objc_getProperty(*(id *)(*((void *)&v85 + 1) + 8 * v53), v50, 48LL, 1);
                            }
                            else {
                              BOOL v55 = 0LL;
                            }
                            uint64_t v56 = v55;
                            objc_opt_class();
                            isKindOfClass = objc_opt_isKindOfClass();

                            if ((isKindOfClass & 1) == 0)
                            {
                              ne_log_obj();
                              SEL v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
                              {
                                *(_WORD *)uint64_t v84 = 0;
                                id v75 = "Attempted to process non-fragment payload";
                                goto LABEL_110;
                              }

    unint64_t v24 = vadd_s32(*(int32x2_t *)((char *)v22 + 68), (int32x2_t)0x100000001LL);
    *(uint64_t *)((char *)v22 + 68) = (uint64_t)v24;
    BOOL v25 = v24.i32[0];
    goto LABEL_40;
  }

  if (v22[6] == v23) {
    goto LABEL_37;
  }
  v22[6] = v23;
  *((_BYTE *)v22 + 81) = 1;
LABEL_39:
  BOOL v25 = *((_DWORD *)v22 + 17) + 1;
  *((_DWORD *)v22 + 17) = v25;
LABEL_40:
  if (v25 != *((_DWORD *)v22 + 16)) {
    return 1LL;
  }
  int v26 = *((_DWORD *)v22 + 8);
  if (!v26)
  {
LABEL_49:
    unint64_t v31 = *((_DWORD *)v22 + 9);
    if (v31)
    {
      if (*((_BYTE *)v22 + 80) == 1 && !*((_BYTE *)v22 + 81))
      {
        unint64_t v32 = *((_DWORD *)v22 + 19) + 1;
        *((_DWORD *)v22 + 19) = v32;
        if (*((_DWORD *)v22 + 10) * v32 >= v31)
        {
          int v33 = (os_log_s *)ne_log_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v34 = *((_DWORD *)v22 + 10) * *((_DWORD *)v22 + 19);
            int v36 = 136315394;
            uint64_t v37 = "NEIPSecDBStatsUpdate";
            uint64_t v38 = 1024;
            int v39 = v34;
            _os_log_impl( &dword_1876B1000,  v33,  OS_LOG_TYPE_DEFAULT,  "%s: no incoming traffic on SA for past %d secs",  (uint8_t *)&v36,  0x12u);
          }

          if (a5) {
            *a5 = 1;
          }
          *((_WORD *)v22 + 40) = 0;
          *((_DWORD *)v22 + 19) = 0;
        }
      }

      else
      {
        *((_DWORD *)v22 + 19) = 0;
        *((_WORD *)v22 + 40) = 0;
      }
    }

    return 1LL;
  }

  if (*((_DWORD *)v22 + 18) != v25)
  {
    *((_DWORD *)v22 + 11) = 0;
    goto LABEL_49;
  }

  __int16 v27 = *((_DWORD *)v22 + 10);
  uint64_t v28 = *((_DWORD *)v22 + 11) + 1;
  *((_DWORD *)v22 + 11) = v28;
  if (v27 * v28 < v26) {
    goto LABEL_49;
  }
  uint64_t v29 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
  {
    int v30 = *((_DWORD *)v22 + 10) * *((_DWORD *)v22 + 11);
    int v36 = 136315394;
    uint64_t v37 = "NEIPSecDBStatsUpdate";
    uint64_t v38 = 1024;
    int v39 = v30;
    _os_log_impl(&dword_1876B1000, v29, OS_LOG_TYPE_INFO, "%s: SA is idle for past %d secs", (uint8_t *)&v36, 0x12u);
  }

  BOOL result = 1LL;
  if (a4) {
    *a4 = 1;
  }
  return result;
}

          symptomReporterSuccessfullyLoaded_symbolsLoaded = 0;
          goto LABEL_38;
        }

        CFStringRef v11 = (os_log_s *)ne_log_obj();
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          goto LABEL_37;
        }
        *(_WORD *)__path = 0;
        uint64_t v12 = "Failed to load SymptomReporter symbol symptom_send";
      }

      else
      {
        CFStringRef v11 = (os_log_s *)ne_log_obj();
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          goto LABEL_37;
        }
        *(_WORD *)__path = 0;
        uint64_t v12 = "Failed to load SymptomReporter symbol symptom_set_qualifier";
      }
    }

    else
    {
      CFStringRef v11 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        goto LABEL_37;
      }
      *(_WORD *)__path = 0;
      uint64_t v12 = "Failed to load SymptomReporter symbol symptom_create";
    }

    CFRelease((CFTypeRef)v12);
    return 0LL;
  }

  if (*v14 == 1)
  {
    if ((v24 & 4) != 0) {
      *(_BYTE *)(v12 + 72) = 1;
    }
  }

  else if (!*v14)
  {
    unsigned __int16 v17 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      int v26 = "NEVirtualInterfaceCreateFromSocketAndName";
      __int16 v27 = 1024;
      uint64_t v28 = 1593;
LABEL_36:
      _os_log_error_impl( &dword_1876B1000,  v17,  OS_LOG_TYPE_ERROR,  "NEVirtualInterface Failure in %s at line %d.",  buf,  0x12u);
      goto LABEL_37;
    }

    goto LABEL_37;
  }

  unint64_t v19 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  int v20 = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x189604DB0]);
  if (!v20)
  {
    unsigned __int16 v17 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      int v26 = "NEVirtualInterfaceCreateFromSocketAndName";
      __int16 v27 = 1024;
      uint64_t v28 = 1604;
      goto LABEL_36;
    }

    goto LABEL_37;
  }

  uint64_t v21 = v20;
  *(void *)(v12 + 488) = CFUUIDCreateString(v19, v20);
  CFRelease(v21);
  if (!*(void *)(v12 + 488))
  {
    unsigned __int16 v17 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      int v26 = "NEVirtualInterfaceCreateFromSocketAndName";
      __int16 v27 = 1024;
      uint64_t v28 = 1610;
      goto LABEL_36;
    }

    goto LABEL_37;
  }

  if (a5)
  {
    *int v13 = a5;
    dispatch_retain(a5);
  }

  *(void *)(v12 + 24) = a6;
  id v22 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    int v26 = (const char *)(v12 + 265);
    _os_log_impl( &dword_1876B1000,  v22,  OS_LOG_TYPE_DEFAULT,  "Created a new NEVirtualInterface %s from socket",  buf,  0xCu);
  }

  return v12;
}

LABEL_15:
  return v9;
}

  objc_msgSend( v9,  "appendPrettyBOOL:withName:andIndent:options:",  -[NEVPNProtocolIKEv2 enableFallback](self, "enableFallback"),  @"enableFallback",  v5,  v11);
  objc_msgSend( v9,  "appendPrettyInt:withName:andIndent:options:",  (int)-[NEVPNProtocolIKEv2 tunnelKind](self, "tunnelKind"),  @"tunnelKind",  v5,  v11);
  objc_msgSend( v9,  "appendPrettyBOOL:withName:andIndent:options:",  -[NEVPNProtocolIKEv2 disableInitialContact](self, "disableInitialContact"),  @"disableInitialContact",  v5,  v11);
  objc_msgSend( v9,  "appendPrettyInt:withName:andIndent:options:",  (int)-[NEVPNProtocolIKEv2 mtu](self, "mtu"),  @"MTU",  v5,  v11);
  -[NEVPNProtocolIKEv2 ppkConfiguration](self, "ppkConfiguration");
  int v26 = (void *)objc_claimAutoreleasedReturnValue();
  [v9 appendPrettyObject:v26 withName:@"PPK" andIndent:v5 options:v11];

  return v9;
}

LABEL_16:
    [MEMORY[0x189607968] numberWithInteger:v17];
    int v18 = (void *)objc_claimAutoreleasedReturnValue();
    [v6 setObject:v18 forKeyedSubscript:@"__NEVPNProtocolType"];

    Enabled = SCNetworkServiceGetEnabled(service);
    if (v10)
    {
      [a1 appVPN];
      int v20 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v21 = [v20 protocol];
      if (v21)
      {
        id v22 = (void *)v21;
        [a1 appVPN];
        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
        [v23 protocol];
        unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
        [v24 identifier];
        BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();

        if (!v25)
        {
LABEL_21:
          [a1 appVPN];
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
          [v28 protocol];
          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
          [v29 passwordKeychainItem];
          int v30 = (void *)objc_claimAutoreleasedReturnValue();

          if (v30)
          {
            unint64_t v31 = (void *)MEMORY[0x189607968];
            [a1 appVPN];
            unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
            [v32 protocol];
            int v33 = (void *)objc_claimAutoreleasedReturnValue();
            [v33 passwordKeychainItem];
            uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v31, "numberWithInteger:", objc_msgSend(v34, "domain"));
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
            [v6 setObject:v35 forKeyedSubscript:@"__NEVPNKeychainDomain"];
          }

          [a1 appVPN];
          int v36 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v37 = [v36 isDisconnectOnDemandEnabled];

          uint64_t v38 = -[NEVPNApp initFromLegacyDictionary:]( objc_alloc(&OBJC_CLASS___NEVPNApp),  "initFromLegacyDictionary:",  v6);
          [a1 setAppVPN:v38];

          [a1 appVPN];
          int v39 = (void *)objc_claimAutoreleasedReturnValue();

          if (v39)
          {
            [a1 appVPN];
            unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
            [v40 setEnabled:Enabled != 0];

            [a1 appVPN];
            unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
            goto LABEL_33;
          }

          ne_log_obj();
          unint64_t v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
            goto LABEL_61;
          }
          __int16 v85 = 138412290;
          Name = (void *)SCNetworkServiceGetName(service);
          unint64_t v78 = "Failed to initialize an NEVPNApp object from service %@";
          goto LABEL_60;
        }

        [a1 appVPN];
        int v20 = (void *)objc_claimAutoreleasedReturnValue();
        [v20 protocol];
        int v26 = (void *)objc_claimAutoreleasedReturnValue();
        [v26 identifier];
        __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
        [v6 setObject:v27 forKeyedSubscript:@"__NEVPNProtocolIdentifier"];
      }

      goto LABEL_21;
    }

    [a1 VPN];
    unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
    char v43 = [v42 protocol];
    if (v43)
    {
      uint64_t v44 = (void *)v43;
      [a1 VPN];
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
      [v45 protocol];
      int v46 = (void *)objc_claimAutoreleasedReturnValue();
      [v46 identifier];
      int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v47)
      {
LABEL_29:
        [a1 VPN];
        uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
        [v50 protocol];
        int v51 = (void *)objc_claimAutoreleasedReturnValue();
        [v51 passwordKeychainItem];
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();

        if (v52)
        {
          uint64_t v53 = (void *)MEMORY[0x189607968];
          [a1 VPN];
          int v54 = (void *)objc_claimAutoreleasedReturnValue();
          [v54 protocol];
          BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();
          [v55 passwordKeychainItem];
          uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v53, "numberWithInteger:", objc_msgSend(v56, "domain"));
          unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
          [v6 setObject:v57 forKeyedSubscript:@"__NEVPNKeychainDomain"];
        }

        [a1 VPN];
        int v58 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v37 = [v58 isDisconnectOnDemandEnabled];

        uint64_t v59 = -[NEVPN initFromLegacyDictionary:](objc_alloc(&OBJC_CLASS___NEVPN), "initFromLegacyDictionary:", v6);
        [a1 setVPN:v59];

        [a1 VPN];
        uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();

        if (v60)
        {
          [a1 VPN];
          uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
          [v61 setEnabled:Enabled != 0];

          [a1 VPN];
          unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_33:
          int v62 = v41;
          [v41 setDisconnectOnDemandEnabled:v37];

          [a1 VPN];
          uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
          [v63 protocol];
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();

          if (v64)
          {
            [a1 VPN];
            uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue();
            goto LABEL_40;
          }

          [a1 appVPN];
          uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue();
          [v68 protocol];
          uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();

          if (v69)
          {
            [a1 appVPN];
            uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_40:
            int v70 = v65;
            [v65 protocol];
            unint64_t v71 = (void *)objc_claimAutoreleasedReturnValue();
            [v71 updateWithServiceProtocolsFromService:service];

            uint64_t v72 = SCPreferencesCreateWithAuthorization( (CFAllocatorRef)*MEMORY[0x189604DB0],  @"NE migrate passwords",  0LL,  0LL);
            if (!v72)
            {
              ne_log_obj();
              uint64_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
              {
                uint64_t v84 = SCError();
                __int16 v85 = 136315138;
                Name = (void *)SCErrorString(v84);
                _os_log_error_impl( &dword_1876B1000,  v76,  OS_LOG_TYPE_ERROR,  "Failed to create a SCPreferencesRef for migrating passwords: %s",  (uint8_t *)&v85,  0xCu);
              }

              goto LABEL_54;
            }

            uint64_t v73 = v72;
            [a1 VPN];
            SEL v74 = (void *)objc_claimAutoreleasedReturnValue();

            if (v74)
            {
              [a1 VPN];
              id v75 = (void *)objc_claimAutoreleasedReturnValue();
            }

            else
            {
              [a1 appVPN];
              uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();

              if (!v79)
              {
LABEL_53:
                CFRelease(v73);
LABEL_54:
                unint64_t v77 = +[NEConfiguration copyConfigurationForProtocol:inService:]( (uint64_t)&OBJC_CLASS___NEConfiguration,  @"com.apple.payload",  service);
                if (v77)
                {
                  uint64_t v82 = -[NEProfileIngestionPayloadInfo initFromLegacyDictionary:]( objc_alloc(&OBJC_CLASS___NEProfileIngestionPayloadInfo),  "initFromLegacyDictionary:",  v77);
                  [a1 setPayloadInfo:v82];
                }

                CFStringRef v11 = 1LL;
                goto LABEL_62;
              }

              [a1 appVPN];
              id v75 = (void *)objc_claimAutoreleasedReturnValue();
            }

            uint64_t v80 = v75;
            [v75 protocol];
            int v81 = (void *)objc_claimAutoreleasedReturnValue();
            [v81 migratePasswordsFromPreferences:v73];

            goto LABEL_53;
          }

          ne_log_obj();
          unint64_t v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
          {
            __int16 v85 = 138412290;
            Name = (void *)SCNetworkServiceGetName(service);
            unint64_t v78 = "Failed to initialize the NEVPNProtocol from service %@";
            goto LABEL_60;
          }

  xpc_dictionary_set_BOOL(v20, "has-entitlement", a7);
  v33[0] = v23;
  v33[1] = 3221225472LL;
  v33[2] = __108__NEConfigurationManager_showLocalNetworkAlertForApp_pid_uuid_query_hasEntitlement_completionQueue_handler___block_invoke_196;
  v33[3] = &unk_18A08C790;
  uint64_t v34 = v17;
  uint64_t v35 = v18;
  unint64_t v31 = v18;
  unint64_t v32 = v17;
  -[NEConfigurationManager sendRequest:responseHandler:](self, v20, v33);
}

  return (char)v6;
}

  if (!v11) {
    goto LABEL_19;
  }
  [*(id *)(a1 + 32) setConfiguration:v11];
LABEL_20:
  int v20 = *(void *)(a1 + 32);
  if (v20) {
    *(_BYTE *)(v20 + 8) = 1;
  }

  id v8 = 0LL;
LABEL_23:
  uint64_t v21 = *(void **)(a1 + 40);
  if (v21)
  {
    v22[0] = MEMORY[0x1895F87A8];
    v22[1] = 3221225472LL;
    v22[2] = __60__NEFilterManager_loadFromPreferencesWithCompletionHandler___block_invoke_2;
    v22[3] = &unk_18A0908C8;
    unint64_t v24 = v21;
    uint64_t v23 = v8;
    dispatch_async(MEMORY[0x1895F8AE0], v22);
  }

  objc_sync_exit(v7);
}

    unint64_t v14 = 1LL;
    goto LABEL_17;
  }

  if ([(id)v5 status] == 3)
  {
    id v8 = *(id *)(a1 + 32);
    if (v8) {
      id v8 = objc_getProperty(v8, v7, 80LL, 1);
    }
    [v8 getUUIDBytes:uuid];
    uint64_t v9 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_int64(v9, "command", 4LL);
    xpc_dictionary_set_uuid(v9, "flow-uuid", uuid);
    xpc_dictionary_set_int64(v9, "direction", 2LL);
    CFStringRef v10 = *(void *)(a1 + 32);
    if (v10) {
      CFStringRef v11 = *(void *)(v10 + 200);
    }
    else {
      CFStringRef v11 = 0LL;
    }
    xpc_dictionary_set_int64(v9, "byte-count-inbound", v11);
    uint64_t v12 = *(void *)(a1 + 32);
    if (v12) {
      int v13 = *(void *)(v12 + 208);
    }
    else {
      int v13 = 0LL;
    }
    xpc_dictionary_set_int64(v9, "byte-count-outbound", v13);
    if (-[NEFilterSource generateCryptoSignature:length:](*(void **)(a1 + 32), bytes, &length))
    {
      xpc_dictionary_set_data(v9, "crypto-signature", bytes, length);
    }

    else
    {
      ne_log_obj();
      int v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        int v20 = *(id *)(a1 + 32);
        if (v20) {
          int v20 = objc_getProperty(v20, v19, 80LL, 1);
        }
        *(_DWORD *)buf = 138412290;
        int v26 = v20;
        _os_log_error_impl( &dword_1876B1000,  v18,  OS_LOG_TYPE_ERROR,  "NEFilterSource failed to sign data complete message for %@",  buf,  0xCu);
      }
    }

    uint64_t v21 = *(id *)(a1 + 48);
    ne_filter_send_message();
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  }

    int v13 = 1LL;
    goto LABEL_17;
  }

  if ([(id)v4 status] != 3)
  {
    length_4[0] = MEMORY[0x1895F87A8];
    length_4[1] = 3221225472LL;
    length_4[2] = __68__NEFilterSource_dataCompleteWithCompletionQueue_completionHandler___block_invoke_3;
    length_4[3] = &unk_18A0908C8;
    unint64_t v14 = *(dispatch_queue_s **)(a1 + 40);
    unint64_t v15 = *(id *)(a1 + 48);
    length_4[4] = *(void *)(a1 + 32);
    int v26 = v15;
    dispatch_async(v14, length_4);
    int v16 = v26;
LABEL_18:

    goto LABEL_22;
  }

  Property = *(id *)(a1 + 32);
  if (Property) {
    Property = objc_getProperty(Property, v6, 80LL, 1);
  }
  [Property getUUIDBytes:uuid];
  id v8 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_int64(v8, "command", 4LL);
  xpc_dictionary_set_uuid(v8, "flow-uuid", uuid);
  xpc_dictionary_set_int64(v8, "direction", 2LL);
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9) {
    CFStringRef v10 = *(void *)(v9 + 200);
  }
  else {
    CFStringRef v10 = 0LL;
  }
  xpc_dictionary_set_int64(v8, "byte-count-inbound", v10);
  CFStringRef v11 = *(void *)(a1 + 32);
  if (v11) {
    uint64_t v12 = *(void *)(v11 + 208);
  }
  else {
    uint64_t v12 = 0LL;
  }
  xpc_dictionary_set_int64(v8, "byte-count-outbound", v12);
  if (-[NEFilterSource generateCryptoSignature:length:](*(void **)(a1 + 32), bytes, &length))
  {
    xpc_dictionary_set_data(v8, "crypto-signature", bytes, length);
  }

  else
  {
    ne_log_obj();
    unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = *(id *)(a1 + 32);
      if (v21) {
        uint64_t v21 = objc_getProperty(v21, v20, 80LL, 1);
      }
      *(_DWORD *)buf = 138412290;
      int v30 = v21;
      _os_log_error_impl( &dword_1876B1000,  v19,  OS_LOG_TYPE_ERROR,  "NEFilterSource failed to sign data complete message for %@",  buf,  0xCu);
    }
  }

  id v22 = *(id *)(a1 + 40);
  uint64_t v23 = *(id *)(a1 + 48);
  ne_filter_send_message();

LABEL_22:
}
}

  if (!-[NEHotspotConfiguration securityType](self, "securityType")) {
    goto LABEL_78;
  }
  if (-[NEHotspotConfiguration securityType](self, "securityType") == 2)
  {
    -[NEHotspotConfiguration passphrase](self, "passphrase");
    CFStringRef v11 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v11 length])
    {
      -[NEHotspotConfiguration passphrase](self, "passphrase");
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
      if ((unint64_t)[v12 length] > 7)
      {
        -[NEHotspotConfiguration passphrase](self, "passphrase");
        int v13 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v14 = [v13 length];

        if (v14 < 0x40) {
          goto LABEL_78;
        }
        goto LABEL_59;
      }
    }

LABEL_59:
    ne_log_obj();
    unint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v102 = (id)objc_opt_class();
      unint64_t v57 = v102;
      _os_log_error_impl(&dword_1876B1000, v42, OS_LOG_TYPE_ERROR, "%@ invalid WPA/WPA2 passphrase length.", buf, 0xCu);
    }

    return 102LL;
  }

  if (-[NEHotspotConfiguration securityType](self, "securityType") != 1)
  {
    if (-[NEHotspotConfiguration securityType](self, "securityType") != 3) {
      goto LABEL_78;
    }
    if (-[NEHotspotConfiguration joinOnce](self, "joinOnce"))
    {
      ne_log_obj();
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v102 = (id)objc_opt_class();
        id v22 = v102;
        uint64_t v23 = "%@ JoinOnce is not supported for Enterprise Wi-Fi networks.";
LABEL_85:
        _os_log_error_impl(&dword_1876B1000, v21, OS_LOG_TYPE_ERROR, v23, buf, 0xCu);

        goto LABEL_40;
      }

      goto LABEL_40;
    }

    char v43 = -[NEHotspotConfiguration eapSettings](self, "eapSettings");
    if (v43)
    {
      uint64_t v44 = (void *)v43;
      -[NEHotspotConfiguration eapSettings](self, "eapSettings");
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        int v46 = -[NEHotspotConfiguration validateEAPSettings]((uint64_t)self);

        if ((v46 & 1) != 0) {
          goto LABEL_78;
        }
      }

      else
      {
      }
    }

    ne_log_obj();
    int v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v102 = (id)objc_opt_class();
      uint64_t v59 = v102;
      uint64_t v60 = "%@ invalid EAP settings.";
LABEL_93:
      _os_log_error_impl(&dword_1876B1000, v58, OS_LOG_TYPE_ERROR, v60, buf, 0xCu);

      goto LABEL_91;
    }

    goto LABEL_91;
  }

  -[NEHotspotConfiguration passphrase](self, "passphrase");
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  if ([v15 length] && self)
  {
    [MEMORY[0x189607810] characterSetWithCharactersInString:@"0123456789ABCDEFabcdef"];
    int v16 = (void *)objc_claimAutoreleasedReturnValue();
    [v16 invertedSet];
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();

    -[NEHotspotConfiguration passphrase](self, "passphrase");
    int v18 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v19 = [v18 rangeOfCharacterFromSet:v17];

    if (v19 == 0x7FFFFFFFFFFFFFFFLL)
    {
      -[NEHotspotConfiguration passphrase](self, "passphrase");
      int v20 = (void *)objc_claimAutoreleasedReturnValue();
      if ([v20 length] == 10)
      {

        goto LABEL_78;
      }

      -[NEHotspotConfiguration passphrase](self, "passphrase");
      uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v50 = [v49 length];

      if (v50 == 26)
      {
LABEL_78:
        int v51 = -[NEHotspotConfiguration lifeTimeInDays](self, "lifeTimeInDays");
        if (v51)
        {
          uint64_t v52 = (void *)v51;
          -[NEHotspotConfiguration lifeTimeInDays](self, "lifeTimeInDays");
          uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
          if ((int)[v53 intValue] >= 366)
          {

LABEL_82:
            lifeTimeInDays = self->_lifeTimeInDays;
            self->_lifeTimeInDays = 0LL;

            return 100LL;
          }

          -[NEHotspotConfiguration lifeTimeInDays](self, "lifeTimeInDays");
          int v54 = (void *)objc_claimAutoreleasedReturnValue();
          BOOL v55 = [v54 intValue];

          if (v55 <= 0) {
            goto LABEL_82;
          }
        }

        return 100LL;
      }

      goto LABEL_68;
    }
  }

LABEL_68:
  ne_log_obj();
  int64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    v102 = (id)objc_opt_class();
    int v62 = v102;
    _os_log_error_impl(&dword_1876B1000, v47, OS_LOG_TYPE_ERROR, "%@ invalid WEP passphrase length.", buf, 0xCu);
  }

  return 103LL;
}

        uint64_t v21 = 0LL;
      }

      else
      {
        unint64_t v19 = -[NEIKEv2NULLIdentifier init]( +[NEIKEv2NULLIdentifier allocWithZone:](&OBJC_CLASS___NEIKEv2NULLIdentifier, "allocWithZone:", a5),  "init");
LABEL_23:
        uint64_t v21 = v19;
      }

          id v22 = 0LL;
          goto LABEL_17;
        }

        ne_log_obj();
        uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
          goto LABEL_16;
        }
        *(_WORD *)buf = 0;
        uint64_t v28 = "[NESensitiveData sensitiveDataWithBytes:length:IKEv2_CRYPTO_CHACHAPOLY_SALT_LEN] failed";
      }

      uint64_t v29 = v21;
      int v30 = 2;
    }

    else
    {
      ne_log_obj();
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
        goto LABEL_16;
      }
      *(_DWORD *)buf = 134217984;
      uint64_t v35 = 256LL;
      uint64_t v28 = "[NEMutableSensitiveData mutableSensitiveDataPrefilledWithMaxCapacity:%zu] failed";
      uint64_t v29 = v21;
      int v30 = 12;
    }

    _os_log_fault_impl(&dword_1876B1000, v29, OS_LOG_TYPE_FAULT, v28, buf, v30);
    goto LABEL_16;
  }

  ne_log_obj();
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    BOOL v25 = "[NESensitiveData sensitiveDataWithBytes:length:IKEv2_CRYPTO_CHACHAPOLY_SALT_LEN] failed";
    int v26 = v23;
    __int16 v27 = 2;
LABEL_20:
    _os_log_fault_impl(&dword_1876B1000, v26, OS_LOG_TYPE_FAULT, v25, buf, v27);
  }

    goto LABEL_17;
  }

  ne_log_obj();
  v486 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v486, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v533 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthFinalAsResponderCopyErrorForIKESA:errorCodeToSend:]";
    _os_log_fault_impl(&dword_1876B1000, v486, OS_LOG_TYPE_FAULT, "%s called with null !ikeSA.isInitiator", buf, 0xCu);
  }

  ErrorAuthentication = (void *)NEIKEv2CreateErrorInternal( @"validateAuthFinalAsResponder called as initiator",  v487,  v488,  v489,  v490,  v491,  v492,  v493,  v502);
  v276 = 24LL;
LABEL_197:

  if (ErrorAuthentication)
  {
    ne_log_obj();
    v310 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v310, OS_LOG_TYPE_ERROR))
    {
      v325 = *(const char **)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      v533 = v325;
      _os_log_error_impl( &dword_1876B1000,  v310,  OS_LOG_TYPE_ERROR,  "%@ Failed to process IKE Auth packet (receive final)",  buf,  0xCu);
    }

    v239 = +[NEIKEv2IKEAuthPacket createIKEAuthResponse:refusalError:]( (uint64_t)&OBJC_CLASS___NEIKEv2IKEAuthPacket,  v5,  v276);
    if ((-[NEIKEv2Session sendReply:replyHandler:](*(void *)(a1 + 40), v239, 0LL) & 1) != 0)
    {
      -[NEIKEv2IKESA setState:error:](*(void *)(a1 + 32), 3uLL, ErrorAuthentication);
      -[NEIKEv2Session reportState](*(void **)(a1 + 40), v312);
    }

    else
    {
      v313 = *(id *)(a1 + 40);
      if (v313) {
        v313 = objc_getProperty(v313, v311, 336LL, 1);
      }
      v314 = v313;
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"AUTH refusal final %@",  v315,  v316,  v317,  v318,  v319,  v320,  v321,  (uint64_t)ErrorAuthentication);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v314, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](*(void **)(a1 + 40), v323);
      -[NEIKEv2Session resetAll](*(void *)(a1 + 40), v324);
    }

    goto LABEL_332;
  }

  return a1;
}

    uint64_t v21 = 0LL;
    goto LABEL_6;
  }

  self = (NEIKEv2Listener *) -[NEIKEv2Listener initWithListenerIKEConfig:saSession:kernelSASessionName:listenerUDPPort:listenerInterface:listenerQueue:delegate:delegateQueue:includeP2P:]( self,  v14,  v15,  0LL,  v16,  0LL,  v17,  v18,  v19,  0);
  uint64_t v21 = self;
LABEL_6:

  return v21;
}

    uint64_t v21 = 0LL;
    goto LABEL_6;
  }

  self = (NEIKEv2Listener *) -[NEIKEv2Listener initWithListenerIKEConfig:saSession:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:]( self,  v14,  v15,  0LL,  v16,  v17,  v18,  v19);
  uint64_t v21 = self;
LABEL_6:

  return v21;
}

    uint64_t v21 = 0LL;
    goto LABEL_6;
  }

  self = (NEIKEv2Listener *) -[NEIKEv2Listener initWithListenerIKEConfig:saSession:kernelSASessionName:listenerUDPPort:listenerInterface:listenerQueue:delegate:delegateQueue:includeP2P:]( self,  v14,  0LL,  v15,  v16,  0LL,  v17,  v18,  v19,  0);
  uint64_t v21 = self;
LABEL_6:

  return v21;
}

    id v22 = 0LL;
    goto LABEL_6;
  }

  self = (NEIKEv2Listener *) -[NEIKEv2Listener initWithListenerIKEConfig:saSession:kernelSASessionName:listenerUDPPort:listenerInterface:listenerQueue:delegate:delegateQueue:includeP2P:]( self,  v15,  0LL,  v16,  v17,  0LL,  v18,  v19,  v20,  a9);
  id v22 = self;
LABEL_6:

  return v22;
}

    uint64_t v21 = 0LL;
    goto LABEL_6;
  }

  self = (NEIKEv2Listener *) -[NEIKEv2Listener initWithListenerIKEConfig:saSession:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:]( self,  v14,  0LL,  v15,  v16,  v17,  v18,  v19);
  uint64_t v21 = self;
LABEL_6:

  return v21;
}
  }
}

      free(v9);
    }
  }

  CFIndex v6 = v4;
LABEL_4:
  uint64_t v7 = v6;
LABEL_6:

  return v7;
}

    _os_log_debug_impl(&dword_1876B1000, v8, OS_LOG_TYPE_DEBUG, v9, buf, 2u);
    goto LABEL_17;
  }

  unint64_t v19 = v74;
  int v20 = (const void *)v74[3];
  if (v20)
  {
    CFRelease(v20);
    uint64_t v21 = 0LL;
    v19[3] = 0LL;
  }

  else
  {
    uint64_t v21 = 0LL;
  }

    CFIndex v6 = -[NEIKEv2EncryptionProtocol initWithEncryptionType:](v7, "initWithEncryptionType:", v8);
    goto LABEL_17;
  }

  size_t v4 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol);
  int v5 = 2LL;
LABEL_5:
  CFIndex v6 = (NEIKEv2EncryptionProtocol *)-[NEIKEv2EncryptionProtocol initWithEncryptionWireType:is256Bit:](v4, v5, 0);
LABEL_17:
  uint64_t v9 = v6;
LABEL_18:

  return v9;
}

  return v8;
}

  uint64_t v21 = 0LL;
LABEL_17:

  return v21;
}

    close(v9);
    if (!a4) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_12;
  }

  if (ioctl(KernelControlSocketExtended, 0x8004667EuLL, &v20) == -1)
  {
    CFStringRef v10 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    unsigned __int16 v17 = *__error();
    *(_DWORD *)buf = 67109120;
    id v22 = v17;
    uint64_t v12 = "FIONBIO failed: %d\n";
    goto LABEL_23;
  }

  if (a5)
  {
    int v18 = 0;
    unint64_t v19 = 4;
    if (getsockopt(v9, 2, 1, &v18, &v19))
    {
      CFStringRef v10 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_16;
      }
      CFStringRef v11 = *__error();
      *(_DWORD *)buf = 67109120;
      id v22 = v11;
      uint64_t v12 = "getsockopt flags failed on kernel control socket (errno = %d)\n";
LABEL_23:
      _os_log_error_impl(&dword_1876B1000, v10, OS_LOG_TYPE_ERROR, v12, buf, 8u);
      goto LABEL_16;
    }

    if ((a5 & ~v18) != 0)
    {
      v18 |= a5;
      unint64_t v19 = 4;
      if (setsockopt(v9, 2, 1, &v18, 4u))
      {
        unint64_t v15 = (os_log_s *)ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          int v16 = *__error();
          *(_DWORD *)buf = 67109120;
          id v22 = v16;
          _os_log_impl( &dword_1876B1000,  v15,  OS_LOG_TYPE_INFO,  "setsockopt flags failed on kernel control socket (errno = %d)\n",  buf,  8u);
        }

        goto LABEL_16;
      }
    }
  }

  return v9;
}

    *(_DWORD *)(a1 + 96) = a2;
    if ((_DWORD)v9 == a2) {
      return 1LL;
    }
    if (NEVirtualInterfaceAdjustMetadataBufferSize(a1, v9, a2))
    {
      int v13 = *(unsigned int *)(a1 + 96);
      if (v9 >= v13)
      {
        if (v13 < v9)
        {
          do
            free(*(void **)(*(void *)(a1 + 80) + 8 * v13++));
          while (v9 != v13);
          LODWORD(v13) = *(_DWORD *)(a1 + 96);
        }

        BOOL v25 = *(void **)(a1 + 80);
        if (!(_DWORD)v13)
        {
          free(v25);
          *(void *)(a1 + 80) = 0LL;
          return 1LL;
        }

        int v26 = realloc(v25, 8LL * v13);
        if (v26)
        {
          *(void *)(a1 + 80) = v26;
          return 1LL;
        }

        int v30 = (os_log_s *)ne_log_obj();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          int v36 = "NEVirtualInterfaceAdjustReadBufferSize";
          uint64_t v37 = 1024;
          *(_DWORD *)uint64_t v38 = a2;
          uint64_t v29 = "%s: failed to reduce read buffer (cnt=%d)";
          unint64_t v31 = v30;
          unint64_t v32 = 18;
LABEL_49:
          _os_log_error_impl(&dword_1876B1000, v31, OS_LOG_TYPE_ERROR, v29, buf, v32);
        }
      }

      else
      {
        unint64_t v14 = (char *)realloc(*(void **)(a1 + 80), 8 * v13);
        if (v14)
        {
          unint64_t v15 = v14;
          *(void *)(a1 + 80) = v14;
          int v16 = *(unsigned int *)(a1 + 96);
          bzero(&v14[8 * v9], 8LL * (v16 - v9));
          unsigned __int16 v17 = v9;
          int v18 = *(void *)(a1 + 88);
          while (1)
          {
            *(void *)&v15[8 * v17] = malloc(v18);
            unint64_t v15 = *(char **)(a1 + 80);
            if (!*(void *)&v15[8 * v17]) {
              break;
            }
            ++v17;
            BOOL result = 1LL;
            if (v16 == v17) {
              return result;
            }
          }

          uint64_t v28 = (os_log_s *)ne_log_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            int v36 = "NEVirtualInterfaceAdjustReadBufferSize";
            uint64_t v37 = 1024;
            *(_DWORD *)uint64_t v38 = a2;
            v38[2] = 1024;
            *(_DWORD *)&v38[3] = v9;
            uint64_t v29 = "%s: failed to allocate read buffers (cnt=%d, prev=%d)";
            goto LABEL_48;
          }
        }

        else
        {
          uint64_t v28 = (os_log_s *)ne_log_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            int v36 = "NEVirtualInterfaceAdjustReadBufferSize";
            uint64_t v37 = 1024;
            *(_DWORD *)uint64_t v38 = a2;
            v38[2] = 1024;
            *(_DWORD *)&v38[3] = v9;
            uint64_t v29 = "%s: failed to allocate read buffer (cnt=%d, prev=%d)";
LABEL_48:
            unint64_t v31 = v28;
            unint64_t v32 = 24;
            goto LABEL_49;
          }
        }
      }

      uint64_t v21 = a1;
      int v20 = v9;
LABEL_51:
      NEVirtualInterfaceCleanupBuffersOnFailure(v21, v20);
      return 0LL;
    }

    id v22 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      int v36 = "NEVirtualInterfaceAdjustReadBufferSize";
      uint64_t v37 = 1024;
      *(_DWORD *)uint64_t v38 = a2;
      v38[2] = 1024;
      *(_DWORD *)&v38[3] = v9;
      _os_log_error_impl( &dword_1876B1000,  v22,  OS_LOG_TYPE_ERROR,  "%s: failed to alloc metadata buffer (cnt=%d, prev=%d)",  buf,  0x18u);
      if ((_DWORD)v9)
      {
LABEL_32:
        uint64_t v23 = 0LL;
        unint64_t v24 = 8LL * v9;
        do
        {
          free(*(void **)(*(void *)(a1 + 80) + v23));
          v23 += 8LL;
        }

        while (v24 != v23);
      }
    }

    else if ((_DWORD)v9)
    {
      goto LABEL_32;
    }

    free(*(void **)(a1 + 80));
    BOOL result = 0LL;
    *(void *)(a1 + 80) = 0LL;
    return result;
  }

  unint64_t v2 = (os_log_s *)ne_log_obj();
  BOOL result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136315394;
    int v36 = "NEVirtualInterfaceAdjustReadBufferSize";
    uint64_t v37 = 1024;
    *(_DWORD *)uint64_t v38 = 2047;
    _os_log_error_impl( &dword_1876B1000,  v2,  OS_LOG_TYPE_ERROR,  "NEVirtualInterface Failure in %s at line %d.",  buf,  0x12u);
    return 0LL;
  }

  return result;
}

LABEL_61:
          CFStringRef v11 = 0LL;
LABEL_62:

          goto LABEL_63;
        }

        ne_log_obj();
        unint64_t v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
          goto LABEL_61;
        }
        __int16 v85 = 138412290;
        Name = (void *)SCNetworkServiceGetName(service);
        unint64_t v78 = "Failed to initialize an NEVPN object from service %@";
LABEL_60:
        _os_log_error_impl(&dword_1876B1000, v77, OS_LOG_TYPE_ERROR, v78, (uint8_t *)&v85, 0xCu);
        goto LABEL_61;
      }

      [a1 VPN];
      unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
      [v42 protocol];
      int v48 = (void *)objc_claimAutoreleasedReturnValue();
      [v48 identifier];
      uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
      [v6 setObject:v49 forKeyedSubscript:@"__NEVPNProtocolIdentifier"];
    }

    goto LABEL_29;
  }

  return 1LL;
}

    int v5 = 0LL;
    goto LABEL_59;
  }

  int v5 = ne_log_obj();
  if (os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_ERROR))
  {
    int64_t v47 = *(unsigned __int8 *)(v3 + 17);
    *(_DWORD *)buf = 67109120;
    v60[0] = v47;
    CFIndex v6 = "Cannot parse packet, unknown version (%x)";
LABEL_66:
    uint64_t v7 = (os_log_s *)v5;
    id v8 = 8;
    goto LABEL_67;
  }

LABEL_68:
LABEL_69:
          [MEMORY[0x189607870] errorWithDomain:@"NEVPNErrorDomain" code:4 userInfo:0];
          uint64_t v59 = (__CFError *)objc_claimAutoreleasedReturnValue();
          ne_log_obj();
          uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v94 = v59;
            _os_log_error_impl( &dword_1876B1000,  v60,  OS_LOG_TYPE_ERROR,  "Failed to save the new configuration: %@",  buf,  0xCu);
          }

          if (v4)
          {
            v70[0] = MEMORY[0x1895F87A8];
            v70[1] = 3221225472LL;
            v70[2] = __55__NEVPNManager_saveToPreferencesWithCompletionHandler___block_invoke_39;
            v70[3] = &unk_18A0908C8;
            uint64_t v72 = v4;
            unint64_t v71 = v59;
            dispatch_async(MEMORY[0x1895F8AE0], v70);
          }

          uint64_t v45 = (__CFError *)v61;
          goto LABEL_40;
        }

        [v18 settings];
        int v36 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v37 = (CFErrorRef)[v36 copyLegacyIPSecDictionary];

        if (!v37) {
          uint64_t v37 = (CFErrorRef)objc_alloc_init(MEMORY[0x189603F68]);
        }
        if (!SCUserPreferencesSetInterfaceTypeConfiguration())
        {
          uint64_t v56 = SCCopyLastError();
          ne_log_obj();
          unint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v94 = v56;
            _os_log_error_impl( &dword_1876B1000,  v57,  OS_LOG_TYPE_ERROR,  "Failed to set the IPsec settings in the user preferences: %@",  buf,  0xCu);
          }

          goto LABEL_61;
        }
      }

      [v18 settings];
      Error = (__CFError *)objc_claimAutoreleasedReturnValue();
      if (-[__CFError authenticationMethod](Error, "authenticationMethod") == 3)
      {
        [v18 settings];
        uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
        [v38 identityReference];
        int v39 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v40 = v39 == 0LL;

        if (v40) {
          goto LABEL_32;
        }
        unint64_t v91 = @"TLSIdentityHandle";
        [v18 settings];
        unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
        [v41 identityReference];
        unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
        v92 = v42;
        [MEMORY[0x189603F68] dictionaryWithObjects:&v92 forKeys:&v91 count:1];
        Error = (__CFError *)objc_claimAutoreleasedReturnValue();

        if (!SCUserPreferencesSetInterfaceTypeConfiguration())
        {
          oslog = SCCopyLastError();
          ne_log_obj();
          int v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v94 = oslog;
            _os_log_error_impl( &dword_1876B1000,  v58,  OS_LOG_TYPE_ERROR,  "Failed to set the EAP settings in the user preferences: %@",  buf,  0xCu);
          }

          goto LABEL_68;
        }
      }

LABEL_32:
      v16 |= v66;
    }

    unint64_t v15 = [obj countByEnumeratingWithState:&v73 objects:v86 count:16];
    if (v15) {
      continue;
    }
    break;
  }

  if ((v16 & 1) == 0) {
    goto LABEL_51;
  }
LABEL_52:

LABEL_53:
  uint64_t v50 = +[NEVPNManager loadedManagers]();
  v5->_notificationSent = 0;
  +[NEVPNManager configurationManager]();
  int v51 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEVPNManager configuration](v5, "configuration");
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v53 = MEMORY[0x1895F8AE0];
  int v54 = MEMORY[0x1895F8AE0];
  v68[0] = MEMORY[0x1895F87A8];
  v68[1] = 3221225472LL;
  v68[2] = __55__NEVPNManager_saveToPreferencesWithCompletionHandler___block_invoke_2_41;
  v68[3] = &unk_18A090968;
  v68[4] = v5;
  uint64_t v69 = v4;
  [v51 saveConfiguration:v52 withCompletionQueue:v53 handler:v68];

  uint64_t v45 = (__CFError *)v63;
LABEL_40:

LABEL_41:
  objc_sync_exit(v5);
}

id getWriterSemaphore()
{
  if (getWriterSemaphore_sema_init != -1) {
    dispatch_once(&getWriterSemaphore_sema_init, &__block_literal_global_321);
  }
  return (id)getWriterSemaphore_semaphore;
}

LABEL_135:
  (*(void (**)(void))(*(void *)(v122 + 40) + 16LL))();
}

void sub_1876E0EC4(_Unwind_Exception *a1)
{
}

void sub_1876E0ED4( _Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26)
{
  if (a2 == 1)
  {
    id v27 = objc_begin_catch(a1);
    ne_log_obj();
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
    {
      LODWORD(STACK[0x220]) = 138412290;
      STACK[0x224] = (unint64_t)v27;
      _os_log_fault_impl( &dword_1876B1000,  v28,  OS_LOG_TYPE_FAULT,  "Got an exception while reading the index: %@",  (uint8_t *)&STACK[0x220],  0xCu);
    }

    -[NEConfigurationManager errorWithCode:specifics:](a26, 1LL, 0LL);
    objc_claimAutoreleasedReturnValue();

    objc_end_catch();
    JUMPOUT(0x1876E0268LL);
  }

  _Unwind_Resume(a1);
}

void sub_1876E1160( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

LABEL_26:
  return a1;
}
}

          uint64_t v7 = 0;
          goto LABEL_27;
        }

        if (!result)
        {
          ne_log_obj();
          int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            goto LABEL_26;
          }
          uint64_t v28 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412290;
          int v36 = v28;
          id v22 = v28;
          uint64_t v23 = "%@ found nil persistent reference for trusted server certificate";
LABEL_29:
          int v26 = v20;
          id v27 = 12;
LABEL_30:
          _os_log_error_impl(&dword_1876B1000, v26, OS_LOG_TYPE_ERROR, v23, buf, v27);

          goto LABEL_26;
        }

        objc_msgSend(v6, "addObject:");
        CFRelease(result);
        if (v12 == ++v15)
        {
          uint64_t v12 = -[NSArray countByEnumeratingWithState:objects:count:]( v10,  "countByEnumeratingWithState:objects:count:",  &v30,  v39,  16LL);
          self = v29;
          if (v12) {
            goto LABEL_10;
          }
          goto LABEL_18;
        }
      }

      ne_log_obj();
      int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = (void *)objc_opt_class();
        *(_DWORD *)buf = 138412290;
        int v36 = v21;
        id v22 = v21;
        uint64_t v23 = "%@ invalid certificate data type";
        goto LABEL_29;
      }

      goto LABEL_26;
    }

  id v27 = 0;
LABEL_40:

  if (!v8 || !objc_getProperty(v8, v40, 88LL, 1))
  {
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      goto LABEL_156;
    }
    *(_WORD *)buf = 0;
    int v18 = "No chosen encryption protocol";
    goto LABEL_106;
  }

  if ((v27 & 1) == 0)
  {
    if (a3)
    {
      v166 = 0uLL;
      v167 = 0uLL;
      v164 = 0uLL;
      v165 = 0uLL;
      [v6 integrityProtocols];
      unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v42 = [v41 countByEnumeratingWithState:&v164 objects:v183 count:16];
      if (v42)
      {
        char v43 = v42;
        uint64_t v44 = *(void *)v165;
        while (2)
        {
          for (i = 0LL; i != v43; ++i)
          {
            if (*(void *)v165 != v44) {
              objc_enumerationMutation(v41);
            }
            int v46 = *(void *)(*((void *)&v164 + 1) + 8 * i);
            -[os_log_s integrityProtocols](v8, "integrityProtocols");
            int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
            int v48 = [v47 indexOfObject:v46];

            if (v48 != 0x7FFFFFFFFFFFFFFFLL)
            {
              -[os_log_s integrityProtocols](v8, "integrityProtocols");
              unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
              [v57 objectAtIndexedSubscript:v48];
              int v58 = (void *)objc_claimAutoreleasedReturnValue();
              objc_setProperty_atomic(v8, v59, v58, 96LL);

              goto LABEL_66;
            }
          }

          char v43 = [v41 countByEnumeratingWithState:&v164 objects:v183 count:16];
          if (v43) {
            continue;
          }
          break;
        }
      }
    }

    else
    {
      v162 = 0uLL;
      v163 = 0uLL;
      v160 = 0uLL;
      v161 = 0uLL;
      -[os_log_s integrityProtocols](v8, "integrityProtocols");
      unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v49 = [v41 countByEnumeratingWithState:&v160 objects:v182 count:16];
      if (v49)
      {
        uint64_t v50 = v49;
        int v51 = *(void *)v161;
        while (2)
        {
          for (j = 0LL; j != v50; ++j)
          {
            if (*(void *)v161 != v51) {
              objc_enumerationMutation(v41);
            }
            uint64_t v53 = *(void **)(*((void *)&v160 + 1) + 8 * j);
            [v6 integrityProtocols];
            int v54 = (void *)objc_claimAutoreleasedReturnValue();
            BOOL v55 = [v54 containsObject:v53];

            if (v55)
            {
              objc_setProperty_atomic(v8, v56, v53, 96LL);
              goto LABEL_66;
            }
          }

          uint64_t v50 = [v41 countByEnumeratingWithState:&v160 objects:v182 count:16];
          if (v50) {
            continue;
          }
          break;
        }
      }
    }

    a1 = 0LL;
    goto LABEL_27;
  }

    if (v24) {
      [v38 addObject:v24];
    }

    if (v18 + 8 > v14) {
      goto LABEL_35;
    }
  }

  ne_log_obj();
  unint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v42[0]) = v22;
    _os_log_error_impl(&dword_1876B1000, v32, OS_LOG_TYPE_ERROR, "Invalid traffic selector length (%u)", buf, 8u);
  }

LABEL_35:
  uint64_t v9 = v38;
  unint64_t v15 = objc_msgSend(v38, "count", v36);
  id v8 = v37;
LABEL_36:
  if (v15 == v8)
  {
    objc_setProperty_atomic(self, v16, v9, 24LL);
    uint64_t v7 = -[NEIKEv2TrafficSelectorPayload hasRequiredFields](self, "hasRequiredFields");
  }

  else
  {
    ne_log_obj();
    int v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      uint64_t v35 = [v9 count];
      *(_DWORD *)buf = 67109376;
      LODWORD(v42[0]) = v35;
      WORD2(v42[0]) = 1024;
      *(_DWORD *)((char *)v42 + 6) = v8;
      _os_log_error_impl( &dword_1876B1000,  v33,  OS_LOG_TYPE_ERROR,  "Failed to process all traffic selectors (%u/%u)",  buf,  0xEu);
    }

    uint64_t v7 = 0;
  }

  return v7;
}
}

          ++v10;
        }

        while (v8 != v10);
        int v26 = [v5 countByEnumeratingWithState:&v33 objects:v39 count:16];
        id v8 = v26;
        if (!v26)
        {

          a1 = v30;
          if ((v32 & 1) != 0) {
            goto LABEL_43;
          }
          goto LABEL_35;
        }
      }
    }

LABEL_35:
    id v27 = objc_loadWeakRetained(a1 + 11);
    ne_log_obj();
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v29 = v28;
    if (v27)
    {
      if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v38 = v4;
        _os_log_impl(&dword_1876B1000, v29, OS_LOG_TYPE_INFO, "No matching clients, trying wildcard for %@", buf, 0xCu);
      }

      [v27 receivePacket:v4 transport:a1];
    }

    else
    {
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v38 = v4;
        _os_log_error_impl(&dword_1876B1000, v29, OS_LOG_TYPE_ERROR, "No matching clients, dropping %@", buf, 0xCu);
      }
    }

LABEL_43:
  }
}

    ne_log_obj();
    unint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138413058;
      uint64_t v38 = a1;
      int v39 = 2112;
      unint64_t v40 = v10;
      unint64_t v41 = 1024;
      unint64_t v42 = a3;
      char v43 = 1024;
      uint64_t v44 = a2;
      _os_log_impl( &dword_1876B1000,  v24,  OS_LOG_TYPE_INFO,  "%@ %@ received notification %#x for SAID %u which matches no SA",  buf,  0x22u);
    }

    unint64_t v14 = v30;
  }

LABEL_24:
  return v12;
}

        goto LABEL_27;
      }

    uint64_t v50 = 0LL;
    int v51 = 0LL;
    uint64_t v52 = 0;
    goto LABEL_27;
  }

  if (v31 != 2)
  {
    if (v31 == 30)
    {
      uint64_t v37 = 0x80;
      goto LABEL_16;
    }

    int64_t v47 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      int v48 = "sadb update";
      uint64_t v49 = a6[1];
      if (a3 == 3) {
        int v48 = "sadb add";
      }
      *(_DWORD *)buf = 136315394;
      *(void *)uint64_t v63 = v48;
      *(_WORD *)&v63[8] = 1024;
      *(_DWORD *)&v63[10] = v49;
      unint64_t v40 = "pfkey %s, invalid source IP family %d";
      unint64_t v41 = v47;
      unint64_t v42 = 18;
LABEL_25:
      _os_log_error_impl(&dword_1876B1000, v41, OS_LOG_TYPE_ERROR, v40, buf, v42);
      goto LABEL_26;
    }

    goto LABEL_26;
  }

  uint64_t v37 = 32;
LABEL_16:
  if (a4 == 2)
  {
    int v51 = 0LL;
    uint64_t v50 = 0LL;
    if (!a12)
    {
      uint64_t v60 = a3;
      uint64_t v52 = 0;
      if (!a14) {
        goto LABEL_27;
      }
      goto LABEL_36;
    }

    *a3 = v27;
LABEL_27:
  }
}

          if (v7) {
            CFRelease(v7);
          }
          return v8;
        }
      }

LABEL_20:
    CFStringRef v11 = 1LL;
    goto LABEL_21;
  }

  if (([(id)v8 isEqualToData:v10] & 1) == 0)
  {
    ne_log_obj();
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v14 = os_log_type_enabled(v12, OS_LOG_TYPE_INFO);
    if (v10)
    {
      if (v14)
      {
        int v16 = 138412290;
        unsigned __int16 v17 = v4;
        int v13 = "Configuration %@ has changed";
        goto LABEL_19;
      }
    }

    else if (v14)
    {
      int v16 = 138412290;
      unsigned __int16 v17 = v4;
      int v13 = "Configuration %@ has not been loaded yet";
      goto LABEL_19;
    }

    goto LABEL_20;
  }
  }
}
}

        uint64_t v21 = 0LL;
      }

      goto LABEL_24;
    case 9uLL:
      unint64_t v19 = -[NEIKEv2ASN1DNIdentifier initWithData:]( +[NEIKEv2ASN1DNIdentifier allocWithZone:](&OBJC_CLASS___NEIKEv2ASN1DNIdentifier, "allocWithZone:", a5),  "initWithData:",  v7);
      goto LABEL_23;
    case 0xBuLL:
      unint64_t v19 = -[NEIKEv2KeyIDIdentifier initWithKeyID:]( +[NEIKEv2KeyIDIdentifier allocWithZone:](&OBJC_CLASS___NEIKEv2KeyIDIdentifier, "allocWithZone:", a5),  "initWithKeyID:",  v7);
      goto LABEL_23;
    case 0xDuLL:
      if ([v7 length])
      {
        ne_log_obj();
        unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v23) = 0;
          int v16 = "NULL identifier should not contain data";
          unsigned __int16 v17 = v15;
          int v18 = 2;
LABEL_26:
          _os_log_error_impl(&dword_1876B1000, v17, OS_LOG_TYPE_ERROR, v16, (uint8_t *)&v23, v18);
        }

  return a1;
}

    uint64_t v12 = 0LL;
    goto LABEL_15;
  }

  uint64_t v9 = (os_log_s *)objc_loadWeakRetained(a1 + 6);
  CFStringRef v10 = v9;
  if (!v9)
  {
    ne_log_obj();
    unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl( &dword_1876B1000,  v19,  OS_LOG_TYPE_ERROR,  "Packet delegate is no longer valid, cannot send",  buf,  2u);
    }

    if (v6)
    {
      uint64_t v21 = (dispatch_queue_s *)objc_getProperty(a1, v20, 72LL, 1);
      v31[0] = MEMORY[0x1895F87A8];
      v31[1] = 3221225472LL;
      v31[2] = __51__NEIKEv2Transport_sendData_sendCompletionHandler___block_invoke;
      unint64_t v31[3] = &unk_18A090940;
      unint64_t v14 = &v32;
      unint64_t v32 = v6;
      dispatch_async(v21, v31);
      uint64_t v12 = 0LL;
      goto LABEL_13;
    }

    CFStringRef v10 = 0LL;
LABEL_19:
    uint64_t v12 = 0LL;
    goto LABEL_14;
  }

  uint64_t v12 = -[os_log_s sendPacketData:](v9, "sendPacketData:", v5);
  if (v6)
  {
    int v13 = (dispatch_queue_s *)objc_getProperty(a1, v11, 72LL, 1);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __51__NEIKEv2Transport_sendData_sendCompletionHandler___block_invoke_2;
    block[3] = &unk_18A08FC50;
    unint64_t v14 = &v29;
    uint64_t v29 = v6;
    int v30 = v12;
    dispatch_async(v13, block);
LABEL_13:
  }

  return a1;
}

  int v30 = v16;
LABEL_23:

  return v30;
}
}

    CFStringRef v11 = 0LL;
  }

  return v11;
}

          id v3 = 0LL;
          goto LABEL_27;
        }

        int v16 = *(const __CFArray **)(a1 + 328);
        v28.length = CFArrayGetCount(v16);
        v28.location = 0LL;
        unsigned __int16 v17 = CFArrayGetFirstIndexOfValue(v16, v28, a2);
        if (v17 != -1)
        {
          int v18 = v17;
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 328), v17);
          unint64_t v15 = *(__CFArray **)(a1 + 336);
          unint64_t v14 = v18;
          goto LABEL_25;
        }
      }

      id v3 = 1LL;
      goto LABEL_27;
    }

    CFDataGetTypeID();
    return 0LL;
  }

  return v3;
}

LABEL_11:
  CFStringRef v11 = 0LL;
LABEL_21:

LABEL_22:
  return v11;
}

  v4[2](v4, 0LL);
LABEL_21:
}

    goto LABEL_12;
  }

  uint64_t v9 = 0LL;
LABEL_12:
  int v20 = [a1 epid];
  [a1 sourceAppIdentifier];
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  v30[0] = MEMORY[0x1895F87A8];
  v30[1] = 3221225472LL;
  v30[2] = __63__NEFilterFlow_updateSourceAppInfoWithQueue_completionHandler___block_invoke;
  v30[3] = &unk_18A08C308;
  id v22 = v5;
  unint64_t v31 = v22;
  unint64_t v32 = a1;
  uint64_t v23 = v6;
  int v33 = v23;
  -[NEAppInfoCache appInfoForPid:UUID:bundleID:completionHandler:](v7, v20, v9, v21, v30);
}
}

  return 0LL;
}
  }
}

  return v7;
}

  return v7;
}

        memset(&v32[4], 0, 24);
        *(_DWORD *)unint64_t v32 = 7708;
        if (a4 == 16) {
          *(_OWORD *)&v32[8] = *(_OWORD *)objc_msgSend(v11, "bytes", *(_OWORD *)v32, *(_OWORD *)&v32[16]);
        }
        [MEMORY[0x189608DE8] endpointWithAddress:v32];
        unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v15 = 0LL;
        if (a5 <= 20)
        {
          if (a5 == 10 || a5 == 12) {
            goto LABEL_39;
          }
        }

        else if (a5 == 21 || a5 == 25958 || a5 == 25959)
        {
LABEL_39:
          unint64_t v15 = (objc_class *)objc_opt_class();
        }

        BOOL v25 = objc_alloc(v15);
        if (a6) {
          uint64_t v21 = [v25 initCustomWithAttributeType:a6 attributeName:v12 addressValue:v14];
        }
        else {
          uint64_t v21 = [v25 initWithAddress:v14];
        }
LABEL_46:
        int v18 = (void *)v21;

        break;
    }
  }

  else
  {
LABEL_27:
    int v18 = 0LL;
  }

  return v18;
}

    unint64_t v24 = 0LL;
    goto LABEL_5;
  }

  if (!v21)
  {
    ne_log_obj();
    int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v29 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSe"
            "ssion:packetDelegate:]";
      id v27 = "%s called with null saSession";
      goto LABEL_13;
    }

    goto LABEL_11;
  }

  if (!v19)
  {
    ne_log_obj();
    int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v29 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSess"
          "ion:packetDelegate:]";
    id v27 = "%s called with null queue";
LABEL_13:
    _os_log_fault_impl(&dword_1876B1000, v26, OS_LOG_TYPE_FAULT, v27, buf, 0xCu);
    goto LABEL_11;
  }

  self =  -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]( (os_log_s *)self,  v16,  v17,  v18,  v19,  (id *)a7,  v20,  v21,  0,  v22,  0LL,  0LL);
  unint64_t v24 = self;
LABEL_5:

  return v24;
}

    unint64_t v24 = 0LL;
    goto LABEL_5;
  }

  if (!v21)
  {
    ne_log_obj();
    int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v29 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kern"
            "elSASessionName:packetDelegate:]";
      id v27 = "%s called with null kernelSASessionName";
      goto LABEL_13;
    }

    goto LABEL_11;
  }

  if (!v19)
  {
    ne_log_obj();
    int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v29 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernel"
          "SASessionName:packetDelegate:]";
    id v27 = "%s called with null queue";
LABEL_13:
    _os_log_fault_impl(&dword_1876B1000, v26, OS_LOG_TYPE_FAULT, v27, buf, 0xCu);
    goto LABEL_11;
  }

  uint64_t v23 = -[NEIPSecSAKernelSession initWithName:delegate:]( objc_alloc(&OBJC_CLASS___NEIPSecSAKernelSession),  "initWithName:delegate:",  v21,  0LL);
  self =  -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]( (os_log_s *)self,  v16,  v17,  v18,  v19,  (id *)a7,  v20,  v23,  1,  v22,  0LL,  0LL);

  unint64_t v24 = self;
LABEL_5:

  return v24;
}

  return v6;
}

  return v6;
}

LABEL_12:
  unint64_t v19 = 0LL;
LABEL_38:

  return v19;
}

  return v9;
}

  return v3;
}

  return v3;
}

  uint64_t v7 = (void *)sharedManager_gDNSSettingsManager;
  sharedManager_gDNSSettingsManager = (uint64_t)v1;
}

  return v6;
}

  return v12;
}

  objc_sync_exit(v5);
  return v7;
}

  objc_sync_exit(v5);
  return v7;
}

LABEL_56:
  uint64_t v59 = [v45 appVPN];
  if (v59)
  {
    uint64_t v60 = (void *)v59;
    uint64_t v12 = [v46 appVPN];

    if (!v12)
    {
      [v45 appVPN];
      int v58 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_59:
      uint64_t v61 = v58;
      [v58 protocol];
      int v62 = (void *)objc_claimAutoreleasedReturnValue();

      unsigned __int16 v17 = v424;
      if (v62)
      {
        uint64_t v12 = [v62 passwordKeychainItem];

        if (v12)
        {
          uint64_t v12 = [v62 passwordKeychainItem];
          [(id)v12 setIdentifier:0];
        }

        uint64_t v63 = [v62 type];
        if (v63 != 1 && v63 != 2)
        {
          if (v63 != 5)
          {
LABEL_73:

            goto LABEL_98;
          }

          [v62 ppkConfiguration];
          Property = (void *)objc_claimAutoreleasedReturnValue();
          int v66 = Property;
          if (Property) {
            Property = objc_getProperty(Property, v65, 32LL, 1);
          }
          uint64_t v67 = Property;

          unsigned __int16 v17 = v424;
          if (v67)
          {
            [v62 ppkConfiguration];
            uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue();
            int v70 = v68;
            if (v68) {
              uint64_t v68 = objc_getProperty(v68, v69, 32LL, 1);
            }
            unint64_t v71 = v68;
            [v71 setIdentifier:0];

            unsigned __int16 v17 = v424;
          }
        }

        uint64_t v12 = [v62 sharedSecretKeychainItem];

        if (v12)
        {
          uint64_t v12 = [v62 sharedSecretKeychainItem];
          [(id)v12 setIdentifier:0];
        }

        goto LABEL_73;
      }
    }
  }

  uint64_t v72 = [v45 alwaysOnVPN];
  if (!v72
    || (uint64_t v73 = (void *)v72,
        [v46 alwaysOnVPN],
        uint64_t v12 = objc_claimAutoreleasedReturnValue(),
        (id)v12,
        v73,
        v12))
  {

    goto LABEL_101;
  }

  v454 = 0u;
  v455 = 0u;
  v452 = 0u;
  v453 = 0u;
  [v45 alwaysOnVPN];
  SEL v74 = (void *)objc_claimAutoreleasedReturnValue();
  [v74 interfaceProtocolMapping];
  id v75 = (void *)objc_claimAutoreleasedReturnValue();

  uint64_t v76 = [v75 countByEnumeratingWithState:&v452 objects:v456 count:16];
  if (!v76) {
    goto LABEL_97;
  }
  unint64_t v77 = v76;
  v427 = v46;
  v357 = v16;
  unint64_t v78 = 0LL;
  uint64_t v79 = *(void *)v453;
  do
  {
    uint64_t v80 = 0LL;
    int v81 = v78;
    do
    {
      if (*(void *)v453 != v79) {
        objc_enumerationMutation(v75);
      }
      uint64_t v12 = *(void *)(*((void *)&v452 + 1) + 8 * v80);
      [v45 alwaysOnVPN];
      uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
      [v82 interfaceProtocolMapping];
      v83 = (void *)objc_claimAutoreleasedReturnValue();
      [v83 objectForKeyedSubscript:v12];
      unint64_t v78 = (void *)objc_claimAutoreleasedReturnValue();

      if ([v78 type] != 5)
      {
        ne_log_obj();
        v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
        {
          v93 = [v78 type];
          *(_DWORD *)buf = 136315394;
          *(void *)&buf[4] = "-[NEConfigurationManager resetKeychainItemsAfterProtocolChange:newConfiguration:]";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v93;
          _os_log_error_impl( &dword_1876B1000,  v92,  OS_LOG_TYPE_ERROR,  "%s: unsupported protocol type %d for Always-on VPN",  buf,  0x12u);
        }

        goto LABEL_93;
      }

      [v78 ppkConfiguration];
      uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue();
      int v86 = v84;
      if (v84) {
        uint64_t v84 = objc_getProperty(v84, v85, 32LL, 1);
      }
      __int16 v87 = v84;

      if (v87)
      {
        [v78 ppkConfiguration];
        int v88 = (void *)objc_claimAutoreleasedReturnValue();
        CFErrorRef v90 = v88;
        if (v88) {
          int v88 = objc_getProperty(v88, v89, 32LL, 1);
        }
        unint64_t v91 = v88;
        [v91 setIdentifier:0];
      }

      uint64_t v12 = [v78 sharedSecretKeychainItem];

      if (v12)
      {
        [v78 sharedSecretKeychainItem];
        v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        -[os_log_s setIdentifier:](v92, "setIdentifier:", 0LL);
LABEL_93:
      }

      ++v80;
      int v81 = v78;
    }

    while (v77 != v80);
    unint64_t v77 = [v75 countByEnumeratingWithState:&v452 objects:v456 count:16];
  }

  while (v77);

  unint64_t v15 = v416;
  int v13 = v417;
  int v16 = v357;
  unsigned __int16 v17 = v424;
  int v46 = v427;
LABEL_97:

  a1 = v418;
LABEL_98:

  ne_log_obj();
  v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)v456 = 136315138;
    v457 = "-[NEConfigurationManager saveConfigurationToDisk:updateSCPreferences:currentSignature:userUUID:notifyNow:isUpgrade:]";
    _os_log_debug_impl( &dword_1876B1000,  v94,  OS_LOG_TYPE_DEBUG,  "%s clean up system keychain for reset protocol",  v456,  0xCu);
  }

  -[NEConfiguration syncWithKeychainInDomain:](v45, 0LL);
LABEL_101:
  if (v17) {
    -[NEConfiguration syncWithKeychainInDomain:](v17, 0LL);
  }
  [v17 generateSignature];
  int v39 = (void *)objc_claimAutoreleasedReturnValue();
  v408 = [(id)a1 copyAppGroupMapDidChange:&v444];
  v96 = objc_getProperty((id)a1, v95, 56LL, 1);
  v421 = -[NEConfigurationManager makeMutableCopyOfIndex:]((id)a1, v96);
  [v421 objectForKeyedSubscript:@"ConfigurationProperties"];
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  [v17 identifier];
  v98 = (void *)objc_claimAutoreleasedReturnValue();
  [v97 objectForKeyedSubscript:v98];
  v99 = (void *)objc_claimAutoreleasedReturnValue();

  v410 = v99;
  if (!v99)
  {
    if (v13)
    {
      unint64_t v31 = v16;
      -[NEConfigurationManager errorWithCode:specifics:](a1, 5LL, 0LL);
      unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v34 = 0LL;
      int v36 = 0LL;
      uint64_t v37 = 0LL;
      uint64_t v38 = 0LL;
      unint64_t v40 = 0LL;
      uint64_t v35 = v414;
      unint64_t v41 = v421;
      int v33 = (void *)v408;
      goto LABEL_411;
    }

    goto LABEL_114;
  }

  if (!v13
    || ([v99 objectForKeyedSubscript:@"Signature"],
        v100 = (void *)objc_claimAutoreleasedReturnValue(),
        v101 = [v13 isEqualToData:v100],
        v100,
        (v101 & 1) == 0))
  {
    unint64_t v31 = v16;
    v105 = a1;
    v106 = 5LL;
    goto LABEL_110;
  }

  [v99 objectForKeyedSubscript:@"Signature"];
  v102 = (void *)objc_claimAutoreleasedReturnValue();
  v103 = [v39 isEqualToData:v102];
  v104 = v444;

  if (v103 && !v104)
  {
    unint64_t v31 = v16;
    v105 = a1;
    v106 = 9LL;
LABEL_110:
    -[NEConfigurationManager errorWithCode:specifics:](v105, v106, 0LL);
    unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v34 = 0LL;
    int v36 = 0LL;
    uint64_t v37 = 0LL;
    uint64_t v38 = 0LL;
    uint64_t v35 = v414;
    unint64_t v41 = v421;
    int v33 = (void *)v408;
    unint64_t v40 = v410;
    goto LABEL_411;
  }

  if ((a7 & 1) == 0)
  {
    if (v16)
    {
      v294 = [v410 objectForKeyedSubscript:@"PluginType"];
      if (!v294
        || (v295 = (void *)v294,
            [v410 objectForKeyedSubscript:@"PluginType"],
            v296 = (void *)objc_claimAutoreleasedReturnValue(),
            uint64_t v12 = [v16 isEqualToString:v296],
            v296,
            v295,
            (v12 & 1) == 0))
      {
        unint64_t v31 = v16;
        v105 = a1;
        v106 = 3LL;
        goto LABEL_110;
      }
    }

    v297 = [v424 applicationIdentifier];
    if (v297)
    {
      v298 = (void *)v297;
      [v410 objectForKeyedSubscript:@"ApplicationID"];
      v299 = (void *)objc_claimAutoreleasedReturnValue();
      if (v299)
      {
        uint64_t v12 = [v424 applicationIdentifier];
        a1 = [v410 objectForKeyedSubscript:@"ApplicationID"];
        if ([(id)v12 isEqualToString:a1])
        {

          a1 = v418;
          goto LABEL_114;
        }

        if (!v16) {
          goto LABEL_423;
        }
LABEL_417:
        v331 = v39;
        v332 = [v410 objectForKeyedSubscript:@"PluginType"];
        if (v332)
        {
          v333 = (void *)v332;
          [v410 objectForKeyedSubscript:@"PluginType"];
          v334 = (void *)objc_claimAutoreleasedReturnValue();
          v335 = [v16 isEqualToString:v334];

          if (v299)
          {
          }

          a1 = v418;
          int v39 = v331;
          if ((v335 & 1) == 0) {
            goto LABEL_425;
          }
          goto LABEL_114;
        }

        if (v299)
        {
LABEL_423:
        }
      }

      else if (v16)
      {
        goto LABEL_417;
      }

      a1 = v418;
LABEL_425:
      unint64_t v31 = v16;
      v105 = a1;
      v106 = 4LL;
      goto LABEL_110;
    }
  }

  ne_log_obj();
  int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1876B1000, v26, OS_LOG_TYPE_DEFAULT, "App push is enabled", buf, 2u);
  }

  if ((a3 & 0x20000000000000LL) != 0) {
    goto LABEL_59;
  }
}

            LOBYTE(v15) = 0;
            goto LABEL_33;
          }

          LOBYTE(v15) = 0;
        }

        else
        {
          uint64_t v34 = 0LL;
          LOBYTE(v15) = 0;
          a3 = v23;
        }

        a4 = v118;
        goto LABEL_33;
      }
    }

    unint64_t v15 = [v14 countByEnumeratingWithState:&v145 objects:v159 count:16];
    if (v15) {
      continue;
    }
    break;
  }

  a3 = v23;
  a4 = v118;
LABEL_34:

  if (!v9 || !objc_getProperty(v9, v36, 96LL, 1))
  {
    ne_log_obj();
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_162;
    }
    *(_WORD *)buf = 0;
    id v22 = "No chosen encryption protocol";
    goto LABEL_167;
  }

  if ((v15 & 1) == 0)
  {
    if (a3)
    {
      v143 = 0uLL;
      v144 = 0uLL;
      v141 = 0uLL;
      v142 = 0uLL;
      [v8 integrityProtocols];
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v38 = [v37 countByEnumeratingWithState:&v141 objects:v158 count:16];
      if (v38)
      {
        int v39 = v38;
        v119 = a4;
        unint64_t v40 = a3;
        unint64_t v41 = *(void *)v142;
        while (2)
        {
          for (j = 0LL; j != v39; ++j)
          {
            if (*(void *)v142 != v41) {
              objc_enumerationMutation(v37);
            }
            char v43 = *(void *)(*((void *)&v141 + 1) + 8 * j);
            -[os_log_s integrityProtocols](v9, "integrityProtocols");
            uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v45 = [v44 indexOfObject:v43];

            if (v45 != 0x7FFFFFFFFFFFFFFFLL)
            {
              -[os_log_s integrityProtocols](v9, "integrityProtocols");
              uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
              [v59 objectAtIndexedSubscript:v45];
              uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
              objc_setProperty_atomic(v9, v61, v60, 104LL);

              goto LABEL_68;
            }
          }

          int v39 = [v37 countByEnumeratingWithState:&v141 objects:v158 count:16];
          if (v39) {
            continue;
          }
          goto LABEL_68;
        }
      }
    }

    else
    {
      v139 = 0uLL;
      v140 = 0uLL;
      v137 = 0uLL;
      v138 = 0uLL;
      -[os_log_s integrityProtocols](v9, "integrityProtocols");
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
      int v51 = [v37 countByEnumeratingWithState:&v137 objects:v157 count:16];
      if (v51)
      {
        uint64_t v52 = v51;
        v119 = a4;
        unint64_t v40 = a3;
        uint64_t v53 = *(void *)v138;
        while (2)
        {
          for (k = 0LL; k != v52; ++k)
          {
            if (*(void *)v138 != v53) {
              objc_enumerationMutation(v37);
            }
            BOOL v55 = *(void **)(*((void *)&v137 + 1) + 8 * k);
            [v8 integrityProtocols];
            uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
            unint64_t v57 = [v56 containsObject:v55];

            if (v57)
            {
              objc_setProperty_atomic(v9, v58, v55, 104LL);
              goto LABEL_68;
            }
          }

          uint64_t v52 = [v37 countByEnumeratingWithState:&v137 objects:v157 count:16];
          if (v52) {
            continue;
          }
          break;
        }

LABEL_57:
              uint64_t v82 = 0LL;
              goto LABEL_58;
            }

            ne_log_obj();
            v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
              goto LABEL_56;
            }
            CFErrorRef v90 = 136315138;
            unint64_t v91 = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyRequestChildSA:]";
            uint64_t v84 = "%s called with null packet.nonce.isValid";
          }

          else
          {
            ne_log_obj();
            v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
              goto LABEL_56;
            }
            CFErrorRef v90 = 136315138;
            unint64_t v91 = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyRequestChildSA:]";
            uint64_t v84 = "%s called with null packet.childSA.isValid";
          }
        }

LABEL_57:
LABEL_58:
  int64_t v47 = 0;
LABEL_88:

  return v47;
}

LABEL_114:
  v107 = objc_alloc_init(MEMORY[0x189603FC8]);
  [v107 setObject:v39 forKeyedSubscript:@"Signature"];
  if (v16) {
    [v107 setObject:v16 forKeyedSubscript:@"PluginType"];
  }
  [v424 applicationIdentifier];
  v108 = (void *)objc_claimAutoreleasedReturnValue();

  if (v108)
  {
    [v424 applicationIdentifier];
    v109 = (void *)objc_claimAutoreleasedReturnValue();
    [v107 setObject:v109 forKeyedSubscript:@"ApplicationID"];
  }

  [v421 objectForKeyedSubscript:@"ConfigurationProperties"];
  v110 = (void *)objc_claimAutoreleasedReturnValue();
  [v424 identifier];
  v111 = (void *)objc_claimAutoreleasedReturnValue();
  v412 = v107;
  [v110 setObject:v107 forKeyedSubscript:v111];

  if (v444 && v408)
  {
    [v421 setObject:v408 forKeyedSubscript:@"AppGroupMap"];
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
    [(id)a1 setAppGroupsChanged:0];
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  }

  v112 = 0x189603000uLL;
  v113 = &off_18A087000;
  if (v15 && !-[NEConfiguration isSupportedBySC](v424)
    || (NEGetNullUUID(), v114 = objc_claimAutoreleasedReturnValue(), v15, (unint64_t v15 = (void *)v114) != 0LL))
  {
    [v421 objectForKeyedSubscript:@"UserMap"];
    v115 = (void *)objc_claimAutoreleasedReturnValue();
    [v115 objectForKeyedSubscript:v15];
    v116 = (void *)objc_claimAutoreleasedReturnValue();
    v117 = isa_nsarray(v116);

    if ((v117 & 1) == 0)
    {
      v118 = objc_alloc_init(MEMORY[0x189603FA8]);
      [v421 objectForKeyedSubscript:@"UserMap"];
      v119 = (void *)objc_claimAutoreleasedReturnValue();
      [v119 setObject:v118 forKeyedSubscript:v15];
    }

    [v421 objectForKeyedSubscript:@"UserMap"];
    v120 = (void *)objc_claimAutoreleasedReturnValue();
    [v120 objectForKeyedSubscript:v15];
    v121 = (void *)objc_claimAutoreleasedReturnValue();

    [v424 identifier];
    v122 = (void *)objc_claimAutoreleasedReturnValue();
    v123 = [v121 containsObject:v122];

    if ((v123 & 1) == 0)
    {
      [v424 identifier];
      v124 = (void *)objc_claimAutoreleasedReturnValue();
      [v121 addObject:v124];
    }

    v416 = v15;

    v112 = 0x189603000LL;
  }

  else
  {
    v416 = 0LL;
  }

  v125 = *(void *)(a1 + 104);
  if (v125 <= 0x1FFFFFFFFFFFFELL) {
    v126 = v125 + 1;
  }
  else {
    v126 = 1LL;
  }
  v127 = (void *)[objc_alloc(MEMORY[0x1896078F8]) initRequiringSecureCoding:1];
  v428 = objc_alloc_init(*(Class *)(v112 + 4008));
  v345 = (const char *)v126;
  [v127 encodeInt64:v126 forKey:@"Generation"];
  [v127 encodeInt64:1 forKey:@"Version"];
  v431 = v127;
  if (!objc_getProperty((id)a1, v128, 56LL, 1))
  {
    v293 = 0;
    v134 = v424;
    goto LABEL_374;
  }

  v346 = v39;
  v358 = v16;
  objc_msgSend(objc_getProperty((id)a1, v129, 56, 1), "objectForKeyedSubscript:", @"ConfigurationProperties");
  v440 = 0u;
  v441 = 0u;
  v442 = 0u;
  v443 = 0u;
  obja = (id)objc_claimAutoreleasedReturnValue();
  v130 = [obja countByEnumeratingWithState:&v440 objects:v451 count:16];
  if (!v130)
  {
    v354 = 0;
    v134 = v424;
    goto LABEL_373;
  }

  v132 = v130;
  v344 = 0LL;
  v354 = 0;
  v133 = *(void *)v441;
  *(void *)&v131 = 136315394LL;
  v343 = v131;
  v134 = v424;
  v135 = v432;
  while (2)
  {
    v136 = 0LL;
    while (2)
    {
      if (*(void *)v441 != v133) {
        objc_enumerationMutation(obja);
      }
      v137 = *(void **)(*((void *)&v440 + 1) + 8 * v136);
      objc_msgSend(v134, "identifier", v343);
      v138 = (void *)objc_claimAutoreleasedReturnValue();
      v139 = [v137 isEqual:v138];

      if ((v139 & 1) != 0) {
        goto LABEL_361;
      }
      objc_msgSend(objc_getProperty((id)a1, v140, 88, 1), "objectForKeyedSubscript:", v137);
      v141 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v141) {
        goto LABEL_360;
      }
      if ((v135 & 1) == 0)
      {
        v135 = 0;
        goto LABEL_359;
      }

      v142 = v134;
      v143 = v141;
      objc_opt_self();
      v433 = v143;
      [v143 alwaysOnVPN];
      v144 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v144)
      {
        [v142 alwaysOnVPN];
        v147 = (void *)objc_claimAutoreleasedReturnValue();

        if (v147)
        {
          [v143 contentFilter];
          v148 = (void *)objc_claimAutoreleasedReturnValue();
          v146 = v148 == 0LL;

          goto LABEL_149;
        }

        v149 = [v142 grade];
        if (v149 == [v143 grade])
        {
          v150 = [v142 VPN];
          if (v150)
          {
            v151 = (void *)v150;
            [v142 VPN];
            v152 = (void *)objc_claimAutoreleasedReturnValue();
            if ([v152 isEnabled]
              && ([v143 VPN], (v153 = objc_claimAutoreleasedReturnValue()) != 0))
            {
              v154 = (void *)v153;
              [v143 VPN];
              v155 = (void *)objc_claimAutoreleasedReturnValue();
              v390 = [v155 isEnabled];

              a1 = v418;
              if ((v390 & 1) != 0) {
                goto LABEL_351;
              }
            }

            else
            {

              a1 = v418;
            }
          }
        }

        [v142 VPN];
        v156 = (void *)objc_claimAutoreleasedReturnValue();
        if (v156)
        {
          [v142 VPN];
          v360 = (void *)objc_claimAutoreleasedReturnValue();
          if ([v360 isEnabled])
          {
            v157 = [v433 VPN];
            if (v157)
            {
              v353 = (void *)v157;
              [v433 VPN];
              v158 = (void *)objc_claimAutoreleasedReturnValue();
              if ([v158 isEnabled])
              {

LABEL_350:
                goto LABEL_351;
              }

              v349 = v158;
              v159 = 1;
              v391 = 1;
            }

            else
            {
              v353 = 0LL;
              v391 = 0;
              v159 = 1;
            }
          }

          else
          {
            v159 = 0;
            v391 = 0;
          }
        }

        else
        {
          v159 = 0;
          v391 = 0;
        }

        [v142 relay];
        v380 = (void *)objc_claimAutoreleasedReturnValue();
        if (v380)
        {
          [v142 relay];
          v359 = (void *)objc_claimAutoreleasedReturnValue();
          if ([v359 isEnabled])
          {
            v160 = v159;
            v161 = [v433 VPN];
            if (v161)
            {
              v352 = (void *)v161;
              [v433 VPN];
              v162 = (void *)objc_claimAutoreleasedReturnValue();
              if ([v162 isEnabled])
              {

                v371 = 1;
                v159 = v160;
                goto LABEL_187;
              }

              v347 = v162;
              v361 = 1;
              v364 = 1;
            }

            else
            {
              v352 = 0LL;
              v364 = 0;
              v361 = 1;
            }

            v159 = v160;
          }

          else
          {
            v361 = 0;
            v364 = 0;
          }
        }

        else
        {
          v361 = 0;
          v364 = 0;
        }

        v163 = [v142 VPN];
        if (v163)
        {
          v164 = (void *)v163;
          [v142 VPN];
          v165 = (void *)objc_claimAutoreleasedReturnValue();
          if ([v165 isEnabled])
          {
            v348 = v159;
            v350 = v156;
            v166 = [v433 relay];
            if (v166)
            {
              v167 = (void *)v166;
              [v433 relay];
              v168 = (void *)objc_claimAutoreleasedReturnValue();
              v371 = [v168 isEnabled];
            }

            else
            {

              v371 = 0;
            }

            a1 = v418;
            v156 = v350;
            v159 = v348;
          }

          else
          {

            v371 = 0;
            a1 = v418;
          }

          if ((v364 & 1) != 0)
          {
LABEL_211:

            v169 = v380;
            if ((v361 & 1) == 0) {
              goto LABEL_185;
            }
            goto LABEL_184;
          }
        }

        else
        {
          v371 = 0;
          if (v364) {
            goto LABEL_211;
          }
        }

        v169 = v380;
        if (!v361)
        {
LABEL_185:
          if (!v169)
          {

            if (v391)
            {
LABEL_188:

              if ((v159 & 1) == 0)
              {
LABEL_193:
                if (v156) {

                }
                if ((v371 & 1) != 0) {
                  goto LABEL_351;
                }
                v170 = [v142 grade];
                v171 = v433;
                if (v170 != [v433 grade]) {
                  goto LABEL_215;
                }
                v172 = [v142 contentFilter];
                if (!v172) {
                  goto LABEL_215;
                }
                v173 = (void *)v172;
                [v142 contentFilter];
                v174 = (void *)objc_claimAutoreleasedReturnValue();
                if ([v174 isEnabled])
                {
                  v175 = [v433 contentFilter];
                  if (v175)
                  {
                    v176 = (void *)v175;
                    [v433 contentFilter];
                    v392 = (id)objc_claimAutoreleasedReturnValue();
                    if ([v392 isEnabled])
                    {
                      [v142 contentFilter];
                      v365 = (void *)objc_claimAutoreleasedReturnValue();
                      v381 = [v365 grade];
                      [v433 contentFilter];
                      v177 = (void *)objc_claimAutoreleasedReturnValue();
                      v372 = [v177 grade];

                      if (v381 == v372)
                      {
                        [v433 externalIdentifier];
                        v178 = (void *)objc_claimAutoreleasedReturnValue();

                        a1 = v418;
                        v134 = v424;
                        if (v178)
                        {
                          v179 = v344 + 1;
                          [v142 externalIdentifier];
                          v180 = (void *)objc_claimAutoreleasedReturnValue();
                          ++v344;
                          if (v180)
                          {

                            if (v179 >= 7)
                            {
                              ne_log_obj();
                              v181 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
                              {
                                [v142 name];
                                v182 = (void *)objc_claimAutoreleasedReturnValue();
                                *(_DWORD *)v465 = v343;
                                v466 = "+[NEConfigurationManager configuration:overlapsWithOtherConfiguration:sameTypeCou"
                                       "nt:perAppCount:]";
                                v467 = 2112;
                                v468 = v182;
                                _os_log_impl( &dword_1876B1000,  v181,  OS_LOG_TYPE_DEFAULT,  "%s: Exceeded perApp Content Filter limit, %@ superceded",  v465,  0x16u);

                                v134 = v424;
                              }

            NEIPSecDBNotifyClient(v64, v63, v65);
            goto LABEL_141;
          case 0x1A:
            uint64_t v79 = CFDictionaryGetValue(v8, @"Direction");
            if (v79) {
              uint64_t v80 = CFEqual(v79, @"In");
            }
            else {
              uint64_t v80 = 0;
            }
            __int16 v87 = a1[22];
            if (v87)
            {
              int v88 = (CFAllocatorRef *)MEMORY[0x189604DB0];
              if (*(_BYTE *)(v87 + 52))
              {
                uint64_t v89 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], (const char *)(v87 + 52), 0x600u);
                if (v89)
                {
                  CFErrorRef v90 = v89;
                  CFDictionarySetValue(v8, @"IPSecInterface", v89);
                  CFRelease(v90);
                }
              }

              v92 = *(unsigned __int8 *)(v87 + 28);
              unint64_t v91 = (const char *)(v87 + 28);
              if (v92)
              {
                v93 = CFStringCreateWithCString(*v88, v91, 0x600u);
                if (v93)
                {
                  v94 = v93;
                  CFDictionarySetValue(v8, @"OutgoingInterface", v93);
                  CFRelease(v94);
                }
              }
            }

            v95 = 28LL;
            if (!v80) {
              v95 = 27LL;
            }
            v96 = a1[v95];
            if (v96)
            {
              CFDictionaryRemoveValue(v8, @"LocalAddress");
              CFDictionaryRemoveValue(v8, @"LocalPort");
              CFDictionaryRemoveValue(v8, @"LocalPrefix");
              NEAddAddressToDictionary(v8, @"LocalAddress", (unsigned __int8 *)(v96 + 8));
              NEAddPortToDictionary(v8, @"LocalPort", v96 + 8);
              NEAddIntToDictionary(v8, @"LocalPrefix", *(unsigned __int8 *)(v96 + 5));
            }

            v97 = 27LL;
            if (!v80) {
              v97 = 28LL;
            }
            v98 = a1[v97];
            if (!v98) {
              goto LABEL_137;
            }
            CFDictionaryRemoveValue(v8, @"RemoteAddress");
            CFDictionaryRemoveValue(v8, @"RemotePort");
            CFDictionaryRemoveValue(v8, @"RemotePrefix");
            NEAddAddressToDictionary(v8, @"RemoteAddress", (unsigned __int8 *)(v98 + 8));
            NEAddPortToDictionary(v8, @"RemotePort", v98 + 8);
            uint64_t v82 = *(unsigned __int8 *)(v98 + 5);
            int v86 = v8;
            v83 = @"RemotePrefix";
            goto LABEL_136;
          default:
            goto LABEL_141;
        }
      }
    }
  }

LABEL_246:
                              goto LABEL_337;
                            }
                          }
                        }

                        else
                        {
                          [v142 externalIdentifier];
                          v288 = (void *)objc_claimAutoreleasedReturnValue();

                          if (!v288)
                          {
                            ne_log_obj();
                            v156 = (void *)objc_claimAutoreleasedReturnValue();
                            if (!os_log_type_enabled((os_log_t)v156, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_350;
                            }
                            [v142 name];
                            v268 = (void *)objc_claimAutoreleasedReturnValue();
                            *(_DWORD *)v465 = v343;
                            v466 = "+[NEConfigurationManager configuration:overlapsWithOtherConfiguration:sameTypeCount:perAppCount:]";
                            v467 = 2112;
                            v468 = v268;
                            v269 = (os_log_s *)v156;
                            v270 = "%s: Only one system Content Filter is allowed, %@ supercedes";
                            goto LABEL_349;
                          }
                        }
                      }

                      v171 = v433;
LABEL_215:
                      v183 = [v142 appVPN];
                      if (v183)
                      {
                        v184 = (void *)v183;
                        [v142 appVPN];
                        v185 = (void *)objc_claimAutoreleasedReturnValue();
                        if (![v185 isEnabled]
                          || ([v171 appVPN], (v186 = objc_claimAutoreleasedReturnValue()) == 0))
                        {

LABEL_236:
                          goto LABEL_237;
                        }

                        v187 = (void *)v186;
                        [v171 appVPN];
                        v188 = (void *)objc_claimAutoreleasedReturnValue();
                        v393 = [v188 isEnabled];

                        v171 = v433;
                        if (v393)
                        {
                          v463 = 0u;
                          v464 = 0u;
                          memset(buf, 0, sizeof(buf));
                          [v142 appVPN];
                          v189 = (void *)objc_claimAutoreleasedReturnValue();
                          [v189 appRules];
                          v184 = (void *)objc_claimAutoreleasedReturnValue();

                          v373 = [v184 countByEnumeratingWithState:buf objects:v456 count:16];
                          if (v373)
                          {
                            v190 = **(void **)&buf[16];
                            v351 = v184;
                            v366 = **(void **)&buf[16];
                            do
                            {
                              v191 = 0LL;
                              do
                              {
                                if (**(void **)&buf[16] != v190) {
                                  objc_enumerationMutation(v184);
                                }
                                v382 = v191;
                                v192 = *(void **)(*(void *)&buf[8] + 8 * v191);
                                v446 = 0u;
                                v447 = 0u;
                                v448 = 0u;
                                v449 = 0u;
                                [v171 appVPN];
                                v193 = (void *)objc_claimAutoreleasedReturnValue();
                                [v193 appRules];
                                v194 = (void *)objc_claimAutoreleasedReturnValue();

                                v394 = v194;
                                v195 = [v194 countByEnumeratingWithState:&v446 objects:&v452 count:16];
                                if (v195)
                                {
                                  v196 = v195;
                                  v197 = *(void *)v447;
                                  while (2)
                                  {
                                    for (i = 0LL; i != v196; ++i)
                                    {
                                      if (*(void *)v447 != v197) {
                                        objc_enumerationMutation(v394);
                                      }
                                      if ([v192 overlapsWithRule:*(void *)(*((void *)&v446 + 1) + 8 * i)])
                                      {

                                        a1 = v418;
                                        v156 = v351;
                                        goto LABEL_350;
                                      }
                                    }

                                    v196 = [v394 countByEnumeratingWithState:&v446 objects:&v452 count:16];
                                    if (v196) {
                                      continue;
                                    }
                                    break;
                                  }
                                }

                                v191 = v382 + 1;
                                v171 = v433;
                                v184 = v351;
                                v190 = v366;
                              }

                              while (v382 + 1 != v373);
                              v373 = [v351 countByEnumeratingWithState:buf objects:v456 count:16];
                            }

                            while (v373);
                          }

                          goto LABEL_236;
                        }
                      }

LABEL_237:
                      v199 = [v142 dnsProxy];
                      if (!v199) {
                        goto LABEL_248;
                      }
                      v200 = (void *)v199;
                      [v142 dnsProxy];
                      v201 = (void *)objc_claimAutoreleasedReturnValue();
                      if (![v201 isEnabled]
                        || ([v433 dnsProxy], (v202 = objc_claimAutoreleasedReturnValue()) == 0))
                      {

                        v171 = v433;
                        goto LABEL_248;
                      }

                      v203 = (void *)v202;
                      [v433 dnsProxy];
                      v204 = (void *)objc_claimAutoreleasedReturnValue();
                      v395 = [v204 isEnabled];

                      v171 = v433;
                      if (!v395) {
                        goto LABEL_248;
                      }
                      [v142 externalIdentifier];
                      v205 = (void *)objc_claimAutoreleasedReturnValue();

                      [v433 externalIdentifier];
                      v206 = (void *)objc_claimAutoreleasedReturnValue();

                      if (v205)
                      {
                        v134 = v424;
                        if (!v206)
                        {
                          ne_log_obj();
                          v181 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
                          {
                            [v142 name];
                            v207 = (void *)objc_claimAutoreleasedReturnValue();
                            *(_DWORD *)v465 = v343;
                            v466 = "+[NEConfigurationManager configuration:overlapsWithOtherConfiguration:sameTypeCount:perAppCount:]";
                            v467 = 2112;
                            v468 = v207;
                            _os_log_impl( &dword_1876B1000,  v181,  OS_LOG_TYPE_DEFAULT,  "%s: Concurrent perApp and system DNS Proxy not allowed, %@ superceded",  v465,  0x16u);

                            v134 = v424;
                          }

                          a1 = v418;
                          goto LABEL_246;
                        }

LABEL_248:
                        v208 = [v142 dnsSettings];
                        if (!v208) {
                          goto LABEL_264;
                        }
                        v209 = (void *)v208;
                        [v142 dnsSettings];
                        v210 = (void *)objc_claimAutoreleasedReturnValue();
                        if ([v210 isEnabled])
                        {
                          v211 = [v171 dnsSettings];
                          if (v211)
                          {
                            v212 = (void *)v211;
                            [v171 dnsSettings];
                            v213 = (void *)objc_claimAutoreleasedReturnValue();
                            v396 = [v213 isEnabled];

                            v171 = v433;
                            if (!v396) {
                              goto LABEL_264;
                            }
                            [v142 dnsSettings];
                            v209 = (void *)objc_claimAutoreleasedReturnValue();
                            [v209 settings];
                            v210 = (void *)objc_claimAutoreleasedReturnValue();
                            [v433 dnsSettings];
                            v367 = (void *)objc_claimAutoreleasedReturnValue();
                            [v367 settings];
                            v214 = (id)objc_claimAutoreleasedReturnValue();
                            if (v210)
                            {
                              [v210 matchDomains];
                              v383 = v214;
                              v215 = (void *)objc_claimAutoreleasedReturnValue();
                              v374 = [v215 count];

                              [v383 matchDomains];
                              v397 = (id)objc_claimAutoreleasedReturnValue();
                              v216 = [v397 count];

                              v398 = (char *)v216;
                              v217 = v374 | v216;
                              v214 = v383;
                              if (!v217)
                              {
LABEL_336:

                                v282 = [v171 grade];
                                a1 = v418;
                                v134 = v424;
                                if (v282 < [v142 grade]) {
                                  goto LABEL_337;
                                }
LABEL_351:

                                goto LABEL_352;
                              }

                              if (v374 && v398)
                              {
                                v360 = v210;
                                v362 = 0LL;
                                v359 = v209;
                                while (2)
                                {
                                  [v210 matchDomains];
                                  v218 = (void *)objc_claimAutoreleasedReturnValue();
                                  [v218 objectAtIndexedSubscript:v362];
                                  v384 = (void *)objc_claimAutoreleasedReturnValue();

                                  for (j = 0LL; j != v398; ++j)
                                  {
                                    v220 = v214;
                                    [v214 matchDomains];
                                    v221 = (void *)objc_claimAutoreleasedReturnValue();
                                    [v221 objectAtIndexedSubscript:j];
                                    v222 = (void *)objc_claimAutoreleasedReturnValue();

                                    if (([v384 hasSuffix:v222] & 1) != 0
                                      || ([v222 hasSuffix:v384] & 1) != 0)
                                    {

                                      v171 = v433;
                                      v214 = v220;
                                      v209 = v359;
                                      v210 = v360;
                                      goto LABEL_336;
                                    }

                                    v214 = v220;
                                  }

                                  v210 = v360;
                                  ++v362;
                                  v171 = v433;
                                  v209 = v359;
                                  if (v362 != v374) {
                                    continue;
                                  }
                                  break;
                                }
                              }
                            }
                          }
                        }

LABEL_264:
                        [v142 externalIdentifier];
                        v223 = (void *)objc_claimAutoreleasedReturnValue();
                        if (!v223)
                        {
                          v224 = [v142 dnsProxy];
                          if (!v224) {
                            goto LABEL_272;
                          }
                          v223 = (void *)v224;
                          [v142 dnsProxy];
                          v225 = (void *)objc_claimAutoreleasedReturnValue();
                          if ([v225 isEnabled])
                          {
                            v226 = [v433 dnsSettings];
                            if (v226)
                            {
                              v227 = (void *)v226;
                              [v433 dnsSettings];
                              v228 = (void *)objc_claimAutoreleasedReturnValue();
                              v399 = [v228 isEnabled];

                              v171 = v433;
                              if ((v399 & 1) != 0)
                              {
LABEL_286:
                                a1 = v418;
                                goto LABEL_351;
                              }

LABEL_272:
                              [v171 externalIdentifier];
                              v229 = (void *)objc_claimAutoreleasedReturnValue();
                              if (!v229)
                              {
                                v230 = [v171 dnsProxy];
                                v134 = v424;
                                if (!v230) {
                                  goto LABEL_280;
                                }
                                v229 = (void *)v230;
                                [v171 dnsProxy];
                                v231 = (void *)objc_claimAutoreleasedReturnValue();
                                if ([v231 isEnabled])
                                {
                                  v232 = [v142 dnsSettings];
                                  if (v232)
                                  {
                                    v233 = (void *)v232;
                                    [v142 dnsSettings];
                                    v234 = (void *)objc_claimAutoreleasedReturnValue();
                                    v400 = [v234 isEnabled];

                                    v134 = v424;
                                    if ((v400 & 1) != 0) {
                                      goto LABEL_295;
                                    }
LABEL_280:
                                    v235 = [v142 appPush];
                                    if (!v235) {
                                      goto LABEL_289;
                                    }
                                    v236 = (void *)v235;
                                    [v142 appPush];
                                    v237 = (void *)objc_claimAutoreleasedReturnValue();
                                    if ([v237 isEnabled])
                                    {
                                      v238 = [v433 appPush];
                                      if (v238)
                                      {
                                        v401 = (id)v238;
                                        [v433 appPush];
                                        v239 = (void *)objc_claimAutoreleasedReturnValue();
                                        if ([v239 isEnabled])
                                        {
                                          [v142 appPush];
                                          v385 = (void *)objc_claimAutoreleasedReturnValue();
                                          [v385 pluginType];
                                          v368 = v239;
                                          v240 = (void *)objc_claimAutoreleasedReturnValue();
                                          [v433 appPush];
                                          v363 = (void *)objc_claimAutoreleasedReturnValue();
                                          [v363 pluginType];
                                          v241 = (void *)objc_claimAutoreleasedReturnValue();
                                          v375 = [v240 isEqualToString:v241];

                                          v134 = v424;
                                          if (v375)
                                          {
                                            [v142 appPush];
                                            v242 = (void *)objc_claimAutoreleasedReturnValue();
                                            [v433 appPush];
                                            v243 = (void *)objc_claimAutoreleasedReturnValue();
                                            v244 = [v242 overlapsWithConfiguration:v243];

                                            v134 = v424;
                                            if ((v244 & 1) != 0) {
                                              goto LABEL_286;
                                            }
                                          }

LABEL_289:
                                          v245 = [v142 relay];
                                          if (v245)
                                          {
                                            v246 = (void *)v245;
                                            [v142 relay];
                                            v247 = (void *)objc_claimAutoreleasedReturnValue();
                                            if ([v247 isEnabled]
                                              && ([v433 relay],
                                                  (v248 = objc_claimAutoreleasedReturnValue()) != 0))
                                            {
                                              v249 = (void *)v248;
                                              [v433 relay];
                                              v250 = (void *)objc_claimAutoreleasedReturnValue();
                                              v402 = [v250 isEnabled];

                                              v134 = v424;
                                              if (v402)
                                              {
                                                [v142 relay];
                                                v251 = (void *)objc_claimAutoreleasedReturnValue();
                                                [v433 relay];
                                                v252 = (void *)objc_claimAutoreleasedReturnValue();
                                                v253 = [v251 overlapsWithRelayConfiguration:v252];

                                                v134 = v424;
                                                if (v253)
                                                {
                                                  v254 = [v433 grade];
                                                  if (v254 >= [v142 grade])
                                                  {
                                                    [v433 payloadInfo];
                                                    v156 = (void *)objc_claimAutoreleasedReturnValue();
                                                    a1 = v418;
                                                    if ([v156 profileSource] != 2) {
                                                      goto LABEL_350;
                                                    }
                                                    [v142 payloadInfo];
                                                    v285 = (void *)objc_claimAutoreleasedReturnValue();
                                                    v286 = [v285 profileSource];

                                                    v287 = v286 == 2;
                                                    v134 = v424;
                                                    if (v287) {
                                                      goto LABEL_351;
                                                    }
LABEL_337:

LABEL_338:
                                                    +[NEConfigurationManager disableConfiguration:onDemandOnly:]( (uint64_t)&OBJC_CLASS___NEConfigurationManager,  v142);
                                                    v283 = v142;
                                                    v113 = &off_18A087000;
                                                    [v283 generateSignature];
                                                    v284 = (void *)objc_claimAutoreleasedReturnValue();
                                                    [v412 setObject:v284 forKeyedSubscript:@"Signature"];
                                                    v135 = 0;
                                                    goto LABEL_358;
                                                  }

LABEL_295:
                                                  a1 = v418;
                                                  goto LABEL_337;
                                                }
                                              }
                                            }

                                            else
                                            {

                                              v134 = v424;
                                            }
                                          }

                                          v255 = [v142 grade];
                                          a1 = v418;
                                          if (v255 != [v433 grade])
                                          {
LABEL_334:

LABEL_151:
                                            v135 = 1;
                                            v113 = &off_18A087000;
                                            goto LABEL_359;
                                          }

                                          v256 = [v142 relay];
                                          if (v256)
                                          {
                                            v257 = (void *)v256;
                                            [v142 relay];
                                            v258 = (void *)objc_claimAutoreleasedReturnValue();
                                            if ([v258 isEnabled])
                                            {
                                              v259 = [v433 VPN];
                                              if (v259)
                                              {
                                                v260 = (void *)v259;
                                                [v433 VPN];
                                                v403 = (id)objc_claimAutoreleasedReturnValue();
                                                if ([v403 isEnabled])
                                                {
                                                  [v142 relay];
                                                  v376 = (void *)objc_claimAutoreleasedReturnValue();
                                                  [v433 VPN];
                                                  v369 = (void *)objc_claimAutoreleasedReturnValue();
                                                  v386 = [v376 overlapsWithVPNConfiguration:v369];

                                                  a1 = v418;
                                                  v134 = v424;
                                                  if ((v386 & 1) != 0) {
                                                    goto LABEL_351;
                                                  }
                                                  goto LABEL_307;
                                                }

                                                a1 = v418;
                                              }
                                            }

                                            v134 = v424;
                                          }

LABEL_307:
                                          v261 = [v142 VPN];
                                          if (!v261) {
                                            goto LABEL_318;
                                          }
                                          v262 = (void *)v261;
                                          [v142 VPN];
                                          v263 = (void *)objc_claimAutoreleasedReturnValue();
                                          if ([v263 isEnabled])
                                          {
                                            v264 = [v433 relay];
                                            if (v264)
                                            {
                                              v265 = (void *)v264;
                                              [v433 relay];
                                              v404 = (id)objc_claimAutoreleasedReturnValue();
                                              if ([v404 isEnabled])
                                              {
                                                [v433 relay];
                                                v266 = (void *)objc_claimAutoreleasedReturnValue();
                                                [v142 VPN];
                                                v377 = (void *)objc_claimAutoreleasedReturnValue();
                                                v387 = [v266 overlapsWithVPNConfiguration:v377];

                                                a1 = v418;
                                                v134 = v424;
                                                if ((v387 & 1) != 0) {
                                                  goto LABEL_351;
                                                }
LABEL_318:
                                                v271 = [v142 relay];
                                                if (!v271) {
                                                  goto LABEL_326;
                                                }
                                                v272 = (void *)v271;
                                                [v142 relay];
                                                v273 = (void *)objc_claimAutoreleasedReturnValue();
                                                if ([v273 isEnabled])
                                                {
                                                  v274 = [v433 appVPN];
                                                  if (v274)
                                                  {
                                                    v275 = (void *)v274;
                                                    [v433 appVPN];
                                                    v405 = (id)objc_claimAutoreleasedReturnValue();
                                                    if ([v405 isEnabled])
                                                    {
                                                      [v142 relay];
                                                      v378 = (void *)objc_claimAutoreleasedReturnValue();
                                                      [v433 appVPN];
                                                      v370 = (void *)objc_claimAutoreleasedReturnValue();
                                                      v388 = [v378 overlapsWithAppVPNConfiguration:v370];

                                                      a1 = v418;
                                                      v134 = v424;
                                                      if ((v388 & 1) != 0) {
                                                        goto LABEL_351;
                                                      }
LABEL_326:
                                                      v276 = [v142 appVPN];
                                                      if (!v276) {
                                                        goto LABEL_334;
                                                      }
                                                      v277 = (void *)v276;
                                                      [v142 appVPN];
                                                      v278 = (void *)objc_claimAutoreleasedReturnValue();
                                                      if ([v278 isEnabled])
                                                      {
                                                        v279 = [v433 relay];
                                                        if (v279)
                                                        {
                                                          v280 = (void *)v279;
                                                          [v433 relay];
                                                          v406 = (id)objc_claimAutoreleasedReturnValue();
                                                          if ([v406 isEnabled])
                                                          {
                                                            [v433 relay];
                                                            v281 = (void *)objc_claimAutoreleasedReturnValue();
                                                            [v142 appVPN];
                                                            v379 = (void *)objc_claimAutoreleasedReturnValue();
                                                            v389 = [v281 overlapsWithAppVPNConfiguration:v379];

                                                            a1 = v418;
                                                            v134 = v424;
                                                            if ((v389 & 1) != 0) {
                                                              goto LABEL_351;
                                                            }
                                                            goto LABEL_334;
                                                          }

                                                          a1 = v418;
                                                        }
                                                      }

                                                      v134 = v424;
                                                      goto LABEL_334;
                                                    }

                                                    a1 = v418;
                                                  }
                                                }

                                                v134 = v424;
                                                goto LABEL_326;
                                              }

                                              a1 = v418;
                                            }
                                          }

                                          v134 = v424;
                                          goto LABEL_318;
                                        }

                                        v134 = v424;
                                      }
                                    }

                                    goto LABEL_289;
                                  }
                                }
                              }

                              v134 = v424;
                              goto LABEL_280;
                            }
                          }

                          v171 = v433;
                        }

                        goto LABEL_272;
                      }

                      ne_log_obj();
                      v156 = (void *)objc_claimAutoreleasedReturnValue();
                      v267 = os_log_type_enabled((os_log_t)v156, OS_LOG_TYPE_DEFAULT);
                      if (v206)
                      {
                        a1 = v418;
                        if (!v267) {
                          goto LABEL_350;
                        }
                        [v142 name];
                        v268 = (void *)objc_claimAutoreleasedReturnValue();
                        *(_DWORD *)v465 = v343;
                        v466 = "+[NEConfigurationManager configuration:overlapsWithOtherConfiguration:sameTypeCount:perAppCount:]";
                        v467 = 2112;
                        v468 = v268;
                        v269 = (os_log_s *)v156;
                        v270 = "%s: Concurrent perApp and system DNS Proxy not allowed, %@ supercedes";
                      }

                      else
                      {
                        a1 = v418;
                        if (!v267) {
                          goto LABEL_350;
                        }
                        [v142 name];
                        v268 = (void *)objc_claimAutoreleasedReturnValue();
                        *(_DWORD *)v465 = v343;
                        v466 = "+[NEConfigurationManager configuration:overlapsWithOtherConfiguration:sameTypeCount:perAppCount:]";
                        v467 = 2112;
                        v468 = v268;
                        v269 = (os_log_s *)v156;
                        v270 = "%s: Only one system DNS Proxy is allowed, %@ supercedes";
                      }

LABEL_349:
                      _os_log_impl(&dword_1876B1000, v269, OS_LOG_TYPE_DEFAULT, v270, v465, 0x16u);
                      goto LABEL_350;
                    }
                  }
                }

                goto LABEL_215;
              }

LABEL_192:
              goto LABEL_193;
            }

LABEL_191:
            if (!v159) {
              goto LABEL_193;
            }
            goto LABEL_192;
          }

LABEL_187:
          if ((v391 & 1) != 0) {
            goto LABEL_188;
          }
          goto LABEL_191;
        }

    int v39 = 0LL;
    uint64_t v44 = 0LL;
    v238 = 0;
    goto LABEL_150;
  }

  if (v4) {
    int v16 = objc_getProperty(v4, v13, 216LL, 1);
  }
  else {
    int v16 = 0LL;
  }
  unsigned __int16 v17 = v16;

  if (v17)
  {
    objc_getProperty(a1, v18, 168LL, 1);
    int v20 = (void *)objc_claimAutoreleasedReturnValue();
    if (a1)
    {
      objc_setProperty_atomic(a1, v19, 0LL, 168LL);
      v237 = 0u;
      v235 = 0u;
      v236 = 0u;
      v234 = 0u;
      id v22 = objc_getProperty(a1, v21, 184LL, 1);
    }

    else
    {
      id v22 = 0LL;
      v237 = 0u;
      v235 = 0u;
      v236 = 0u;
      v234 = 0u;
    }

    uint64_t v23 = v22;
    unint64_t v24 = [v23 countByEnumeratingWithState:&v234 objects:v245 count:16];
    if (v24)
    {
      BOOL v25 = v24;
      int v26 = 0LL;
      id v27 = *(void *)v235;
      do
      {
        for (i = 0LL; i != v25; ++i)
        {
          if (*(void *)v235 != v27) {
            objc_enumerationMutation(v23);
          }
          v26 += [*(id *)(*((void *)&v234 + 1) + 8 * i) length];
        }

        BOOL v25 = [v23 countByEnumeratingWithState:&v234 objects:v245 count:16];
      }

      while (v25);
    }

    else
    {
      int v26 = 0LL;
    }

    v169 = [v20 length];
    v171 = -[NEIKEv2IKESA initiatorNonce](a1, v170);
    v172 = [v171 length];
    v174 = -[NEIKEv2IKESA responderNonce](a1, v173);
    v175 = v169 + [v174 length] + v26 + v172;

    v176 = +[NSMutableData mutableSensitiveDataWithMaxCapacity:](MEMORY[0x189603FB8], v175);
    if (v176)
    {
      uint64_t v44 = v176;
      -[__CFData appendData:](v176, "appendData:", v20);
      v178 = -[NEIKEv2IKESA initiatorNonce](a1, v177);
      -[__CFData appendData:](v44, "appendData:", v178);
      v180 = -[NEIKEv2IKESA responderNonce](a1, v179);
      -[__CFData appendData:](v44, "appendData:", v180);

      v232 = 0u;
      v233 = 0u;
      v230 = 0u;
      v231 = 0u;
      if (a1) {
        v182 = objc_getProperty(a1, v181, 184LL, 1);
      }
      else {
        v182 = 0LL;
      }
      v183 = v182;
      v184 = [v183 countByEnumeratingWithState:&v230 objects:v244 count:16];
      if (v184)
      {
        v185 = v184;
        v186 = *(void *)v231;
        do
        {
          for (j = 0LL; j != v185; ++j)
          {
            if (*(void *)v231 != v186) {
              objc_enumerationMutation(v183);
            }
            -[__CFData appendData:](v44, "appendData:", *(void *)(*((void *)&v230 + 1) + 8 * j));
          }

          v185 = [v183 countByEnumeratingWithState:&v230 objects:v244 count:16];
        }

        while (v185);
      }

      if (a1) {
        objc_setProperty_atomic(a1, v188, 0LL, 184LL);
      }
      if (v4) {
        v189 = objc_getProperty(v4, v188, 216LL, 1);
      }
      else {
        v189 = 0LL;
      }
      v219 = (CFMutableDataRef)v20;
      int v39 = (CFMutableDataRef)v189;
LABEL_38:
      -[NEIKEv2IKESA initiatorNonce](a1, v43);
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
      int v46 = [v45 length];
      -[NEIKEv2IKESA responderNonce](a1, v47);
      int v48 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v49 = v46 + [v48 length] + 16;

      uint64_t v50 = +[NSMutableData mutableSensitiveDataWithMaxCapacity:](MEMORY[0x189603FB8], v49);
      if (v50)
      {
        uint64_t v52 = v50;
        -[NEIKEv2IKESA initiatorSPI](a1, v51);
        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
        int v54 = [v53 value];

        v229 = v54;
        -[NEIKEv2IKESA responderSPI](a1, v55);
        uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v57 = [v56 value];

        v228 = v57;
        -[NEIKEv2IKESA initiatorNonce](a1, v58);
        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
        -[__CFData appendData:](v52, "appendData:", v59);

        -[NEIKEv2IKESA responderNonce](a1, v60);
        uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
        -[__CFData appendData:](v52, "appendData:", v61);

        -[__CFData appendBytes:length:](v52, "appendBytes:length:", &v229, 8LL);
        -[__CFData appendBytes:length:](v52, "appendBytes:length:", &v228, 8LL);
        -[__CFData bytes](v39, "bytes");
        -[__CFData length](v39, "length");
        -[__CFData bytes](v52, "bytes");
        -[__CFData length](v52, "length");
        Hkdf = CCKDFParametersCreateHkdf();
        if (!Hkdf)
        {
          if (a1) {
            uint64_t v64 = objc_getProperty(a1, v63, 96LL, 1);
          }
          else {
            uint64_t v64 = 0LL;
          }
          uint64_t v65 = v64;
          -[NEIKEv2IKESAProposal prfProtocol](v65, v66);
          uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
          v224 = -[NEIKEv2PRFProtocol length]((uint64_t)v67);

          if (a1) {
            uint64_t v69 = objc_getProperty(a1, v68, 96LL, 1);
          }
          else {
            uint64_t v69 = 0LL;
          }
          int v70 = v69;
          uint64_t v72 = -[NEIKEv2IKESAProposal encryptionProtocol](v70, v71);
          SEL v74 = (void *)v72;
          if (v72 && (id v75 = *(void *)(v72 + 16), v75 <= 0x1F) && ((0xD01C0000 >> v75) & 1) != 0)
          {
            uint64_t v80 = 0;
          }

          else
          {
            if (a1) {
              uint64_t v76 = objc_getProperty(a1, v73, 96LL, 1);
            }
            else {
              uint64_t v76 = 0LL;
            }
            unint64_t v77 = v76;
            -[NEIKEv2IKESAProposal integrityProtocol](v77, v78);
            uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v80 = -[NEIKEv2IntegrityProtocol keyLength]((uint64_t)v79);
          }

          v226 = v52;
          if (a1) {
            uint64_t v82 = objc_getProperty(a1, v81, 96LL, 1);
          }
          else {
            uint64_t v82 = 0LL;
          }
          v83 = v82;
          -[NEIKEv2IKESAProposal encryptionProtocol](v83, v84);
          __int16 v85 = (void *)objc_claimAutoreleasedReturnValue();
          int v86 = -[NEIKEv2EncryptionProtocol keyLength]((uint64_t)v85);

          if (v222) {
            __int16 v87 = 1;
          }
          else {
            __int16 v87 = 3;
          }
          int v88 = v224 * v87 + 2 * (v80 + v86);
          uint64_t v89 = +[NSMutableData mutableSensitiveDataPrefilledWithMaxCapacity:](MEMORY[0x189603FB8], v88);
          if (!v89)
          {
            ne_log_obj();
            v196 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v196, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 67109120;
              LODWORD(v241) = v88;
              _os_log_fault_impl( &dword_1876B1000,  v196,  OS_LOG_TYPE_FAULT,  "[NEMutableSensitiveData mutableSensitiveDataPrefilledWithMaxCapacity:%u] failed",  buf,  8u);
            }

            unint64_t v91 = 0LL;
            v238 = 0;
            int v20 = v219;
            size_t v4 = v221;
            goto LABEL_148;
          }

          unint64_t v91 = v89;
          v216 = v80;
          v214 = v86;
          if (a1) {
            v92 = objc_getProperty(a1, v90, 96LL, 1);
          }
          else {
            v92 = 0LL;
          }
          v93 = v92;
          v95 = -[NEIKEv2IKESAProposal prfProtocol](v93, v94);
          -[NEIKEv2PRFProtocol ccDigest](v95);
          -[__CFData bytes](v44, "bytes");
          -[__CFData length](v44, "length");
          -[__CFData mutableBytes](v91, "mutableBytes");
          -[__CFData length](v91, "length");
          v96 = CCDeriveKey();

          CCKDFParametersDestroy();
          if (v96)
          {
            ne_log_obj();
            v197 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v197, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 67109120;
              LODWORD(v241) = v96;
              _os_log_fault_impl(&dword_1876B1000, v197, OS_LOG_TYPE_FAULT, "CCDeriveKey failed %d", buf, 8u);
            }

            v238 = 0;
            int v20 = v219;
            size_t v4 = v221;
            goto LABEL_148;
          }

          v97 = (const UInt8 *)-[__CFData bytes](v91, "bytes");
          v98 = +[NSData sensitiveDataWithBytes:length:](MEMORY[0x189603F48], v97, v224);
          objc_setProperty_atomic(a1, v99, v98, 216LL);

          size_t v4 = v221;
          if (a1) {
            v101 = objc_getProperty(a1, v100, 216LL, 1);
          }
          else {
            v101 = 0LL;
          }
          v102 = v101;

          if (!v102)
          {
            ne_log_obj();
            v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v111, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 67109120;
              LODWORD(v241) = v224;
              _os_log_fault_impl( &dword_1876B1000,  v111,  OS_LOG_TYPE_FAULT,  "[NESensitiveData sensitiveDataWithBytes:length:%u] failed",  buf,  8u);
            }

            v226 = 0LL;
            int v39 = 0LL;
            uint64_t v44 = 0LL;
            int v20 = 0LL;
            v238 = 0;
            goto LABEL_148;
          }

          v212 = v91;
          if (v216)
          {
            v103 = +[NSData sensitiveDataWithBytes:length:](MEMORY[0x189603F48], &v97[v224], v216);
            if (!v103)
            {
              ne_log_obj();
              v202 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v202, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 67109120;
                LODWORD(v241) = v216;
                _os_log_fault_impl( &dword_1876B1000,  v202,  OS_LOG_TYPE_FAULT,  "[NESensitiveData sensitiveDataWithBytes:length:%u] failed",  buf,  8u);
              }

              v226 = 0LL;
              int v39 = 0LL;
              uint64_t v44 = 0LL;
              int v20 = 0LL;
              v238 = 0;
              goto LABEL_206;
            }

            v104 = v103;
            v105 = v216 + v224;
            objc_opt_self();
            v106 = (const __CFAllocator *)SecCFAllocatorZeroize();
            v107 = CFDataCreate(v106, &v97[v105], v216);
            if (!v107)
            {
              ne_log_obj();
              v203 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v203, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 67109120;
                LODWORD(v241) = v216;
                _os_log_fault_impl( &dword_1876B1000,  v203,  OS_LOG_TYPE_FAULT,  "[NESensitiveData sensitiveDataWithBytes:length:%u] failed",  buf,  8u);
              }

              v238 = 0;
LABEL_205:

              v226 = 0LL;
              int v39 = 0LL;
              uint64_t v44 = 0LL;
              int v20 = 0LL;
LABEL_206:
              size_t v4 = v221;
              goto LABEL_147;
            }

            v108 = v105 + v216;
            v109 = v105 + v216;
            v110 = v107;
          }

          else
          {
            v110 = 0LL;
            v104 = 0LL;
            v108 = v224;
            v109 = v224;
          }

          v227 = +[NSData sensitiveDataWithBytes:length:](MEMORY[0x189603F48], &v97[v108], v214);
          if (v227)
          {
            v112 = v109 + v214;
            v113 = +[NSData sensitiveDataWithBytes:length:](MEMORY[0x189603F48], &v97[v112], v214);
            if (v113)
            {
              v114 = v113;
              v220 = v113;
              if (v222) {
                goto LABEL_76;
              }
              v115 = v112 + v214;
              v116 = +[NSData sensitiveDataWithBytes:length:]( MEMORY[0x189603F48],  &v97[v112 + v214],  v224);
              objc_setProperty_atomic(a1, v117, v116, 232LL);

              objc_getProperty(a1, v118, 232LL, 1);
              v119 = (void *)objc_claimAutoreleasedReturnValue();

              if (v119)
              {
                v120 = +[NSData sensitiveDataWithBytes:length:](MEMORY[0x189603F48], &v97[v115 + v224], v224);
                objc_setProperty_atomic(a1, v121, v120, 248LL);

                objc_getProperty(a1, v122, 248LL, 1);
                v123 = (void *)objc_claimAutoreleasedReturnValue();

                v114 = v220;
                if (v123)
                {
LABEL_76:

                  ne_log_obj();
                  v124 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v124, OS_LOG_TYPE_DEBUG))
                  {
                    v190 = "SA Init";
                    if (v221) {
                      v190 = "SA Rekey";
                    }
                    if (v221 == a1) {
                      v190 = "Intermediate";
                    }
                    *(_DWORD *)buf = 136315138;
                    v241 = v190;
                    _os_log_debug_impl( &dword_1876B1000,  v124,  OS_LOG_TYPE_DEBUG,  "Calculated sKeySeed derivatives for %s",  buf,  0xCu);
                  }

                  if (a1)
                  {
                    v126 = a1[9] & 1;
                    v127 = objc_getProperty(a1, v125, 96LL, 1);
                  }

                  else
                  {
                    v126 = 0;
                    v127 = 0LL;
                  }

                  v128 = v127;
                  v130 = -[NEIKEv2IKESAProposal encryptionProtocol](v128, v129);
                  v131 = v227;
                  if (v126) {
                    v132 = v114;
                  }
                  else {
                    v132 = v227;
                  }
                  if (!v126) {
                    v131 = v114;
                  }
                  v225 = v131;
                  v223 = v132;
                  v211 = v110;
                  if (!v130 || (v134 = v130[2], v134 > 0x1F) || ((0xD01C0000 >> v134) & 1) == 0)
                  {
                    v135 = v110;
                    if (a1) {
                      v136 = objc_getProperty(a1, v133, 96LL, 1);
                    }
                    else {
                      v136 = 0LL;
                    }
                    v137 = v136;
                    v139 = -[NEIKEv2IKESAProposal integrityProtocol](v137, v138);
                    if (v126) {
                      v140 = v104;
                    }
                    else {
                      v140 = v110;
                    }
                    v215 = v104;
                    if (!v126) {
                      v135 = v104;
                    }
                    v141 = v140;
                    v142 = v135;
                    v143 = objc_alloc(&OBJC_CLASS___NEIKEv2SecurityContextCBCPlusHMAC);
                    v144 = v130;
                    v218 = v225;
                    v217 = v223;
                    v145 = v139;
                    v146 = v141;
                    v147 = v142;
                    v148 = v147;
                    if (!v143) {
                      goto LABEL_230;
                    }
                    if (v130)
                    {
                      if (v145)
                      {
                        if (v146)
                        {
                          if (v147)
                          {
                            v149 = v144[2];
                            if (v149 <= 0x1F && ((0xD01C0000 >> v149) & 1) != 0) {
                              goto LABEL_230;
                            }
                            v150 = +[NEIKEv2SecurityContextCBCPlusHMAC overheadForPlaintextLength:encryptionProtocol:integrityProtocol:]( (uint64_t)&OBJC_CLASS___NEIKEv2SecurityContextCBCPlusHMAC,  0,  v144,  v145);
                            v151 = (NEIKEv2SecurityContextCBCPlusHMAC *)-[NEIKEv2SecurityContext initWithMinimumEncryptedPayloadSize:]( v143,  v150);
                            v143 = v151;
                            if (!v151) {
                              goto LABEL_230;
                            }
                            objc_storeStrong((id *)&v151->_encryptionProtocol, v130);
                            encryptionProtocol = v143->_encryptionProtocol;
                            v213 = v146;
                            if (!encryptionProtocol) {
                              goto LABEL_120;
                            }
                            wireType = encryptionProtocol->_wireType;
                            switch(wireType)
                            {
                              case 2uLL:
                                v154 = v144;
                                v155 = 1;
                                goto LABEL_126;
                              case 0xCuLL:
LABEL_120:
                                v154 = v144;
                                break;
                              case 3uLL:
                                v154 = v144;
                                v155 = 2;
LABEL_126:
                                cryptorRef = 0LL;
                                v163 = CCCryptorCreate( 0,  v155,  0,  (const void *)-[__CFData bytes](v218, "bytes"),  -[__CFData length](v218, "length"),  0LL,  &cryptorRef);
                                if (v163 || !cryptorRef)
                                {
                                  ne_log_obj();
                                  v209 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                  if (!os_log_type_enabled(v209, OS_LOG_TYPE_FAULT)) {
                                    goto LABEL_222;
                                  }
                                  *(_DWORD *)buf = 67109120;
                                  LODWORD(v241) = v163;
                                  v210 = "CCCryptorCreate(kCCEncrypt) failed: %d";
                                }

                                else
                                {
                                  v143->_outgoingEncryptionContext = cryptorRef;
                                  cryptorRef = 0LL;
                                  v164 = CCCryptorCreate( 1u,  v155,  0,  (const void *)-[__CFData bytes](v217, "bytes"),  -[__CFData length](v217, "length"),  0LL,  &cryptorRef);
                                  if (!v164 && cryptorRef)
                                  {
                                    v143->_incomingEncryptionContext = cryptorRef;
                                    objc_storeStrong((id *)&v143->_integrityProtocol, v139);
                                    v165 = [v145 type] - 1;
                                    if (v165 < 0xE && ((0x3863u >> v165) & 1) != 0)
                                    {
                                      v144 = v154;
                                    }

                                    else
                                    {
                                      ne_log_obj();
                                      v166 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                      v144 = v154;
                                      if (os_log_type_enabled(v166, OS_LOG_TYPE_FAULT))
                                      {
                                        v191 = [v145 type];
                                        *(_DWORD *)buf = 67109120;
                                        LODWORD(v241) = v191;
                                        _os_log_fault_impl( &dword_1876B1000,  v166,  OS_LOG_TYPE_FAULT,  "Unknown PRF type %u",  buf,  8u);
                                      }
                                    }

                                    v146 = v213;
                                    -[__CFData bytes](v213, "bytes");
                                    -[__CFData length](v213, "length");
                                    v167 = CCHmacCreate();
                                    if (v167)
                                    {
                                      v143->_outgoingHMACBaseContext = ($1DC23E134A5F43A06C89BE309303CDCF *)v167;
                                      -[__CFData bytes](v148, "bytes");
                                      -[__CFData length](v148, "length");
                                      v168 = CCHmacCreate();
                                      if (v168)
                                      {
                                        v143->_incomingHMACBaseContext = ($1DC23E134A5F43A06C89BE309303CDCF *)v168;
                                        v160 = v143;
LABEL_139:
                                        v114 = v220;
LABEL_140:

                                        if (!v160)
                                        {
                                          ne_log_obj();
                                          v206 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                          if (os_log_type_enabled(v206, OS_LOG_TYPE_ERROR))
                                          {
                                            *(_DWORD *)buf = 138412546;
                                            v241 = (const char *)v144;
                                            v242 = 2112;
                                            v243 = v145;
                                            _os_log_error_impl( &dword_1876B1000,  v206,  OS_LOG_TYPE_ERROR,  "Failed to create security context for %@, %@",  buf,  0x16u);
                                          }

                                          v238 = 0;
                                          v114 = v220;
                                          size_t v4 = v221;
                                          v104 = v215;
                                          goto LABEL_143;
                                        }

                                        size_t v4 = v221;
                                        v104 = v215;
                                        goto LABEL_142;
                                      }

                                      ne_log_obj();
                                      v204 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                      if (!os_log_type_enabled(v204, OS_LOG_TYPE_FAULT)) {
                                        goto LABEL_229;
                                      }
                                      *(_WORD *)buf = 0;
                                      v205 = "CCHmacCreate failed";
                                      goto LABEL_227;
                                    }

                                    ne_log_obj();
                                    v204 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                    if (os_log_type_enabled(v204, OS_LOG_TYPE_FAULT))
                                    {
                                      *(_WORD *)buf = 0;
                                      v205 = "CCHmacCreate failed";
LABEL_227:
                                      v207 = v204;
                                      v208 = 2;
                                      goto LABEL_228;
                                    }

        v319 = objc_getProperty(v366, v293, 32LL, 1);
        objc_setProperty_atomic((id)v5, v320, v319, 496LL);

        v269 = v366;
LABEL_192:

        a1 = 1LL;
        goto LABEL_128;
      }

      ne_log_obj();
      v315 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v315, OS_LOG_TYPE_ERROR))
      {
        v335 = (char *)[(id)a1 copyShortDescription];
        buf = 138412290;
        v384 = v335;
        _os_log_error_impl( &dword_1876B1000,  v315,  OS_LOG_TYPE_ERROR,  "%@ PPK use requested but PPK use is not configured",  (uint8_t *)&buf,  0xCu);
      }

      v267 = @"PPK use requested but PPK use is not configured";
    }

    else
    {
      v257 = objc_getProperty((id)v5, v252, 88LL, 1);
      v258 = [v257 ppkMandatory];

      if (!v258) {
        goto LABEL_161;
      }
      ne_log_obj();
      v259 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v259, OS_LOG_TYPE_ERROR))
      {
        v334 = (char *)[(id)a1 copyShortDescription];
        buf = 138412290;
        v384 = v334;
        _os_log_error_impl( &dword_1876B1000,  v259,  OS_LOG_TYPE_ERROR,  "%@ PPK use not requested but PPK use is mandatory",  (uint8_t *)&buf,  0xCu);
      }

      v267 = @"PPK use not requested but PPK use is mandatory";
    }

LABEL_184:
        goto LABEL_185;
      }

      [v142 contentFilter];
      v145 = (void *)objc_claimAutoreleasedReturnValue();

      if (v145) {
        v146 = 0LL;
      }
      else {
        v146 = -1LL;
      }
LABEL_149:

      if (v146 == -1) {
        goto LABEL_338;
      }
      if (v146 != 1) {
        goto LABEL_151;
      }
LABEL_352:
      v113 = &off_18A087000;
      +[NEConfigurationManager disableConfiguration:onDemandOnly:]((uint64_t)&OBJC_CLASS___NEConfigurationManager, v433);
      [obja objectForKeyedSubscript:v137];
      v289 = (void *)objc_claimAutoreleasedReturnValue();
      v284 = (void *)[v289 mutableCopy];

      [v433 generateSignature];
      v290 = (void *)objc_claimAutoreleasedReturnValue();
      [v284 setObject:v290 forKeyedSubscript:@"Signature"];

      [v421 objectForKeyedSubscript:@"ConfigurationProperties"];
      v291 = (void *)objc_claimAutoreleasedReturnValue();
      [v291 setObject:v284 forKeyedSubscript:v137];

      if (a3)
      {
        v134 = v424;
        if (-[NEConfiguration isSupportedBySC](v433))
        {
          if ((-[NEConfiguration applyChangesToSCServiceInPreferences:](v433, a3) & 1) == 0)
          {
            v326 = (void *)NSString;
            v327 = SCError();
            [v326 stringWithCString:SCErrorString(v327) encoding:4];
            v328 = (void *)objc_claimAutoreleasedReturnValue();
            -[NEConfigurationManager errorWithCode:specifics:](a1, 12LL, v328);
            unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();

            uint64_t v34 = 0LL;
            unint64_t v31 = v358;
            uint64_t v35 = v414;
            int v39 = v346;
            goto LABEL_406;
          }

          v354 = 1;
        }

        v135 = 1;
      }

      else
      {
        v135 = 1;
        v134 = v424;
      }

        goto LABEL_248;
      }

      ne_log_obj();
      v125 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v125, OS_LOG_TYPE_ERROR)) {
        goto LABEL_140;
      }
      LOWORD(applier[0]) = 0;
      v126 = "Reply dictionary is NULL when handling a source remediate message";
      goto LABEL_139;
    case 6LL:
      if (v9)
      {
        CFStringRef v11 = v8;
        uint64_t v12 = v9;
        uint64_t v80 = (void (**)(void))v10;
        if (!self)
        {
LABEL_245:

          goto LABEL_246;
        }

        v217 = v10;
        *(_OWORD *)v226 = 0u;
        v227 = 0u;
        int v81 = xpc_dictionary_get_uuid(v11, "flow-uuid");
        if (!v81)
        {
          ne_log_obj();
          v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v137, OS_LOG_TYPE_DEBUG))
          {
            LOWORD(applier[0]) = 0;
            _os_log_debug_impl( &dword_1876B1000,  v137,  OS_LOG_TYPE_DEBUG,  "channelFlow new channelFlow message rejected, invalid Flow UUID parameter",  (uint8_t *)applier,  2u);
          }

          xpc_dictionary_set_int64(v12, "error", 4LL);
          v80[2](v80);
          goto LABEL_245;
        }

        uint64_t v82 = v81;
        v199 = v80;
        v83 = xpc_dictionary_get_uint64(v11, "ip-protocol");
        uint64_t v84 = xpc_dictionary_get_uint64(v11, "client-pid");
        __int16 v85 = xpc_dictionary_get_uint64(v11, "client-e-pid");
        xdictd = xpc_dictionary_get_uint64(v11, "connection-direction");
        uuid_unparse(v82, (char *)&aBlock);
        v238[0] = 0LL;
        v238[1] = 0LL;
        int v86 = xpc_dictionary_get_uuid(v11, "client-proc-uuid");
        if (v86) {
          uuid_copy((unsigned __int8 *)v238, v86);
        }
        memset(dst, 0, sizeof(dst));
        __int16 v87 = xpc_dictionary_get_uuid(v11, "client-e-proc-uuid");
        if (v87) {
          uuid_copy(dst, v87);
        }
        *(void *)&length.sa_len = 0LL;
        *(void *)&length.sa_data[6] = 0LL;
        v224 = 0;
        v223 = 0LL;
        if (xpc_dictionary_get_data(v11, "local-addr", &v225) && v225 <= 0x1C) {
          __memcpy_chk();
        }
        *(void *)&v219.sa_len = 0LL;
        *(void *)&v219.sa_data[6] = 0LL;
        v221 = 0;
        v220 = 0LL;
        int v88 = 0;
        v204 = v12;
        if (xpc_dictionary_get_data(v11, "remote-addr", &v225) && v225 <= 0x1C)
        {
          __memcpy_chk();
          if (v219.sa_family == 30) {
            uint64_t v89 = 30;
          }
          else {
            uint64_t v89 = 0;
          }
          int v88 = v89;
        }

        if (v83 == 17) {
          CFErrorRef v90 = 2;
        }
        else {
          CFErrorRef v90 = 1;
        }
        newValuea = (id)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:v82];
        unint64_t v91 = -[NEFilterSocketFlow initWithSocketFamily:socketType:socketProtocol:pid:epid:uuid:euuid:socketID:]( objc_alloc(&OBJC_CLASS___NEFilterSocketFlow),  v88,  v90,  v83,  v84,  v85,  (uint64_t)v238,  (uint64_t)dst,  -1LL);
        if (!v91)
        {
          ne_log_obj();
          v141 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v80 = v199;
          uint64_t v12 = v204;
          v97 = newValuea;
          if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
          {
            LODWORD(applier[0]) = 138412290;
            *(size_t *)((char *)applier + 4) = (size_t)newValuea;
            _os_log_error_impl( &dword_1876B1000,  v141,  OS_LOG_TYPE_ERROR,  "New flow %@ rejected because flow creation failed",  (uint8_t *)applier,  0xCu);
          }

          xpc_dictionary_set_int64(v204, "error", 1LL);
          xpc_dictionary_set_uuid(v204, "flow-uuid", v82);
          v199[2](v199);
          CFStringRef v10 = v217;
          v142 = 0LL;
          goto LABEL_244;
        }

        v218 = 0LL;
        v92 = xpc_dictionary_get_data(v11, "crypto-signature", &v218);
        uint64_t v80 = v199;
        if (v92 && v218)
        {
          v94 = v92;
          v95 = objc_alloc(MEMORY[0x189603F48]);
          v96 = (void *)[v95 initWithBytes:v94 length:v218];
          objc_msgSend(v91, "setCrypto_signature:", v96);
        }

        v97 = newValuea;
        objc_setProperty_atomic_copy(v91, v93, newValuea, 128LL);
        if (xdictd) {
          v98 = 2LL;
        }
        else {
          v98 = 1LL;
        }
        [v91 setDirection:v98];
        xpc_dictionary_get_audit_token();
        v99 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v226 length:32];
        [v91 setSourceAppAuditToken:v99];

        [v91 sourceAppAuditToken];
        v100 = (void *)objc_claimAutoreleasedReturnValue();
        [v91 setSourceProcessAuditToken:v100];

        xpc_dictionary_get_remote_connection(v11);
        v101 = (void *)objc_claimAutoreleasedReturnValue();
        objc_setProperty_atomic(v91, v102, v101, 144LL);

        v103 = xpc_dictionary_get_string(v11, "source-app-bundle-id");
        CFStringRef v10 = v217;
        if (v103)
        {
          v104 = (void *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @".%s", v103);
          [v91 setSourceAppIdentifier:v104];

          v91[13] = 1;
        }

        xdicte = v91;
        v105 = xpc_dictionary_get_string(v11, "url");
        if (v105)
        {
          v106 = v105;
          v107 = objc_alloc(MEMORY[0x189604030]);
          [NSString stringWithUTF8String:v106];
          v108 = (void *)objc_claimAutoreleasedReturnValue();
          v109 = (void *)[v107 initWithString:v108];
          [xdicte setURL:v109];
        }

        v110 = xpc_dictionary_get_string(v11, "remote-hostname");
        if (v110)
        {
          v111 = (void *)[objc_alloc(NSString) initWithCString:v110 encoding:4];
          [xdicte setRemoteHostname:v111];
        }

        -[NEFilterSocketFlow setLocalAddress:](xdicte, &length);
        -[NEFilterSocketFlow setRemoteAddress:](xdicte, &v219);
        v112 = self->_channelFlows;
        uint64_t v12 = v204;
        if (!v112)
        {
          [MEMORY[0x189603FC8] dictionary];
          v113 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue();
          v114 = self->_channelFlows;
          self->_channelFlows = v113;

          v112 = self->_channelFlows;
        }

        -[NSMutableDictionary setObject:forKey:](v112, "setObject:forKey:", xdicte, newValuea);
        v192 = newValuea;
        if (!v192)
        {
          ne_log_obj();
          v188 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v188, OS_LOG_TYPE_FAULT))
          {
            LODWORD(applier[0]) = 136315138;
            *(size_t *)((char *)applier + 4) = (size_t)"-[NEFilterDataExtensionProviderContext blessClient:]";
            _os_log_fault_impl( &dword_1876B1000,  v188,  OS_LOG_TYPE_FAULT,  "%s called with null clientUUID",  (uint8_t *)applier,  0xCu);
          }

LABEL_242:
          CFStringRef v10 = v217;
          uint64_t v80 = v199;
          uint64_t v12 = v204;
          v97 = newValuea;
          goto LABEL_243;
        }

        source = self->_source;
        if (source)
        {
          handle = dispatch_source_get_handle((dispatch_source_t)source);
          if ((handle & 0x80000000) == 0)
          {
            *(void *)&v229 = 0LL;
            *(_OWORD *)applier = xmmword_187873200;
            *(_OWORD *)&applier[2] = 0uLL;
            [v192 getUUIDBytes:&applier[3]];
            v117 = 0LL;
            while (1)
            {
              v118 = write(handle, (char *)applier + v117, 40 - v117);
              v119 = __error();
              if (v118 < 1)
              {
                if (v118)
                {
                  v120 = *v119;
                  if (*v119 != 35)
                  {
                    ne_log_obj();
                    v184 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    v185 = v184;
                    if (v120 == 2)
                    {
                      if (os_log_type_enabled(v184, OS_LOG_TYPE_DEBUG))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_debug_impl( &dword_1876B1000,  v185,  OS_LOG_TYPE_DEBUG,  "No socket flow to bless, ignore",  buf,  2u);
                      }
                    }

                    else if (os_log_type_enabled(v184, OS_LOG_TYPE_ERROR))
                    {
                      v186 = strerror(v120);
                      *(_DWORD *)buf = 136315138;
                      v240 = v186;
                      _os_log_error_impl( &dword_1876B1000,  v185,  OS_LOG_TYPE_ERROR,  "Write operation on the control socket failed while blessing the socket (%s)",  buf,  0xCu);
                    }

                    goto LABEL_242;
                  }
                }
              }

              else
              {
                v117 += v118;
              }

              if (v117 >= 0x28) {
                goto LABEL_242;
              }
            }
          }

          ne_log_obj();
          v147 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v147, OS_LOG_TYPE_ERROR)) {
            goto LABEL_230;
          }
          LODWORD(applier[0]) = 138412290;
          *(size_t *)((char *)applier + 4) = (size_t)v192;
          v148 = "Failed to find control socket to bless client %@";
        }

        else
        {
          ne_log_obj();
          v147 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v147, OS_LOG_TYPE_ERROR))
          {
LABEL_230:

LABEL_243:
            v142 = xdicte;
            -[NEFilterDataExtensionProviderContext handleNewFlow:reply:controlSocket:completionHandler:]( self,  xdicte,  v12,  -1,  v80);
LABEL_244:

            goto LABEL_245;
          }

          LODWORD(applier[0]) = 138412290;
          *(size_t *)((char *)applier + 4) = (size_t)v192;
          v148 = "Failed to find control socket source to bless client %@";
        }

        _os_log_error_impl(&dword_1876B1000, v147, OS_LOG_TYPE_ERROR, v148, (uint8_t *)applier, 0xCu);
        goto LABEL_230;
      }

      ne_log_obj();
      v125 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v125, OS_LOG_TYPE_ERROR)) {
        goto LABEL_140;
      }
      LOWORD(applier[0]) = 0;
      v126 = "Reply dictionary is NULL when handling a protocol new flow message";
      goto LABEL_139;
    case 7LL:
    case 8LL:
      if (v9)
      {
        CFStringRef v11 = v8;
        uint64_t v12 = v9;
        int v13 = (void (**)(void))v10;
        unint64_t v14 = v13;
        if (!self) {
          goto LABEL_179;
        }
        if (v11)
        {
          if (v13)
          {
            unint64_t v15 = xpc_dictionary_get_int64(v11, "command");
            int v16 = objc_msgSend( objc_alloc(MEMORY[0x189607AB8]),  "initWithUUIDBytes:",  xpc_dictionary_get_uuid(v11, "flow-uuid"));
            if (v16)
            {
              unsigned __int16 v17 = (os_log_s *)v16;
              v195 = v15;
              if (v15 == 8) {
                int v18 = 2LL;
              }
              else {
                int v18 = 1LL;
              }
              -[NSMutableDictionary objectForKey:](self->_channelFlows, "objectForKey:", v16);
              unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
              if (v19)
              {
                aBlock.receiver = 0LL;
                aBlock.super_class = 0LL;
                LODWORD(v234) = 0;
                v233 = 0LL;
                if (xpc_dictionary_get_data(v11, "local-addr", (size_t *)&length.sa_len)
                  && *(void *)&length.sa_len <= 0x1CuLL)
                {
                  __memcpy_chk();
                  -[NEFilterSocketFlow setLocalAddress:](v19, (sockaddr *)&aBlock);
                }

                v201 = v18;
                v212 = v10;
                v226[0] = 0LL;
                v226[1] = 0LL;
                DWORD2(v227) = 0;
                *(void *)&v227 = 0LL;
                if (xpc_dictionary_get_data(v11, "remote-addr", (size_t *)&length.sa_len)
                  && *(void *)&length.sa_len <= 0x1CuLL)
                {
                  __memcpy_chk();
                  -[NEFilterSocketFlow setRemoteAddress:](v19, (sockaddr *)v226);
                }

                xdict = v12;
                *(void *)&v219.sa_len = 0LL;
                int v20 = xpc_dictionary_get_data(v11, "crypto-signature", (size_t *)&v219.sa_len);
                if (v20 && *(void *)&v219.sa_len)
                {
                  uint64_t v21 = v20;
                  id v22 = objc_alloc(MEMORY[0x189603F48]);
                  uint64_t v23 = (void *)[v22 initWithBytes:v21 length:*(void *)&v219.sa_len];
                  objc_msgSend(v19, "setCrypto_signature:", v23);
                }

                unint64_t v24 = xpc_dictionary_get_uint64(v11, "pending-data-start-offset");
                v238[0] = 0LL;
                BOOL v25 = xpc_dictionary_get_data(v11, "data", v238);
                int v26 = objc_alloc(MEMORY[0x189603F48]);
                id v27 = (void *)[v26 initWithBytes:v25 length:v238[0]];
                ne_log_obj();
                uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
                {
                  v183 = "out";
                  LODWORD(applier[0]) = 136315906;
                  if (v195 == 8) {
                    v183 = "in";
                  }
                  *(size_t *)((char *)applier + 4) = (size_t)v183;
                  WORD2(applier[1]) = 2112;
                  *(size_t *)((char *)&applier[1] + 6) = (size_t)v17;
                  HIWORD(applier[2]) = 2048;
                  applier[3] = v24;
                  LOWORD(v229) = 2048;
                  *(void *)((char *)&v229 + 2) = v238[0];
                  _os_log_debug_impl( &dword_1876B1000,  v28,  OS_LOG_TYPE_DEBUG,  "Received %sbound data for %@ (offset %lld, dataLen %zu)",  (uint8_t *)applier,  0x2Au);
                }

                uint64_t v29 = v24;
                uint64_t v12 = xdict;
                -[NEFilterDataExtensionProviderContext handleData:offset:forFlow:direction:reply:controlSocket:completionHandler:]( self,  v27,  v29,  v19,  v201,  xdict,  -1,  v14);

LABEL_60:
                CFStringRef v10 = v212;
              }

              else
              {
                xpc_dictionary_set_int64(v12, "error", 6LL);
                ne_log_obj();
                v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v129, OS_LOG_TYPE_DEBUG))
                {
                  LODWORD(applier[0]) = 138412290;
                  *(size_t *)((char *)applier + 4) = (size_t)v17;
                  _os_log_debug_impl( &dword_1876B1000,  v129,  OS_LOG_TYPE_DEBUG,  "Add data message rejected, no flow for %@",  (uint8_t *)applier,  0xCu);
                }

LABEL_176:
                v14[2](v14);
              }
            }

            else
            {
              ne_log_obj();
              v127 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
              {
                LOWORD(applier[0]) = 0;
                _os_log_debug_impl( &dword_1876B1000,  v127,  OS_LOG_TYPE_DEBUG,  "New data message rejected, invalid flow UUID",  (uint8_t *)applier,  2u);
              }

              xpc_dictionary_set_int64(v12, "error", 4LL);
              v14[2](v14);
              unsigned __int16 v17 = 0LL;
            }

            goto LABEL_178;
          }

          ne_log_obj();
          unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
          {
            LODWORD(applier[0]) = 136315138;
            *(size_t *)((char *)applier + 4) = (size_t)"-[NEFilterDataExtensionProviderContext handleChannelMessageMoreDa"
                                                       "ta:filloutReply:completionHandler:]";
            v187 = "%s called with null completionHandler";
            goto LABEL_257;
          }
        }

        else
        {
          ne_log_obj();
          unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
          {
            LODWORD(applier[0]) = 136315138;
            *(size_t *)((char *)applier + 4) = (size_t)"-[NEFilterDataExtensionProviderContext handleChannelMessageMoreDa"
                                                       "ta:filloutReply:completionHandler:]";
            v187 = "%s called with null message";
LABEL_257:
            _os_log_fault_impl(&dword_1876B1000, v17, OS_LOG_TYPE_FAULT, v187, (uint8_t *)applier, 0xCu);
          }
        }

LABEL_358:
LABEL_359:
      [v428 addObject:v141];
      [v137 UUIDString];
      v292 = (void *)objc_claimAutoreleasedReturnValue();
      [v431 encodeObject:v141 forKey:v292];

      +[NEConfigurationManager updateFlags:withConfiguration:]((uint64_t)v113[243], (unint64_t *)&v445, v141);
LABEL_360:

LABEL_361:
      if (++v136 != v132) {
        continue;
      }
      break;
    }

    v132 = [obja countByEnumeratingWithState:&v440 objects:v451 count:16];
    if (v132) {
      continue;
    }
    break;
  }

LABEL_373:
  v293 = v354 & 1;
  int v16 = v358;
  int v39 = v346;
  v127 = v431;
LABEL_374:
  [v428 addObject:v134];
  [v134 identifier];
  v300 = (void *)objc_claimAutoreleasedReturnValue();
  [v300 UUIDString];
  v301 = (void *)objc_claimAutoreleasedReturnValue();
  [v127 encodeObject:v134 forKey:v301];

  +[NEConfigurationManager updateFlags:withConfiguration:]( (uint64_t)&OBJC_CLASS___NEConfigurationManager,  (unint64_t *)&v445,  v134);
  [v127 encodeObject:v421 forKey:@"Index"];
  v302 = -[NEConfiguration isSupportedBySC](v134);
  v304 = a3;
  if (!a3 || !v302)
  {
    if (!v293) {
      goto LABEL_386;
    }
    goto LABEL_379;
  }

  if ((-[NEConfiguration applyChangesToSCServiceInPreferences:](v134, a3) & 1) != 0)
  {
LABEL_379:
    if (!SCPreferencesCommitChanges(a3))
    {
      unint64_t v31 = v16;
      v322 = (void *)NSString;
      v323 = SCError();
      [v322 stringWithCString:SCErrorString(v323) encoding:4];
      v324 = (char *)objc_claimAutoreleasedReturnValue();
      ne_log_obj();
      v325 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v325, OS_LOG_TYPE_ERROR))
      {
        [v134 name];
        v338 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)v456 = 138412802;
        v457 = (const char *)a1;
        v458 = 2112;
        v459 = v338;
        v460 = 2112;
        v461 = v324;
        _os_log_error_impl( &dword_1876B1000,  v325,  OS_LOG_TYPE_ERROR,  "%@: SCPreferencesCommitChanges failed with configuration %@: %@",  v456,  0x20u);
      }

      -[NEConfigurationManager errorWithCode:specifics:](a1, 12LL, v324);
      unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();

      uint64_t v34 = 0LL;
      goto LABEL_404;
    }

    if (!SCPreferencesApplyChanges(a3))
    {
      ne_log_obj();
      v309 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v309, OS_LOG_TYPE_ERROR))
      {
        [v134 name];
        v340 = (void *)objc_claimAutoreleasedReturnValue();
        v341 = SCError();
        v342 = SCErrorString(v341);
        *(_DWORD *)v456 = 138412802;
        v457 = (const char *)a1;
        v458 = 2112;
        v459 = v340;
        v460 = 2080;
        v461 = v342;
        _os_log_error_impl( &dword_1876B1000,  v309,  OS_LOG_TYPE_ERROR,  "%@: SCPreferencesApplyChanges failed with configuration %@: %s",  v456,  0x20u);
      }

      v304 = a3;
    }

    if (objc_getProperty((id)a1, v308, 120LL, 1))
    {
      Signature = SCPreferencesGetSignature(v304);
      objc_setProperty_atomic((id)a1, v311, Signature, 120LL);
    }

LABEL_386:
    objc_msgSend( v431,  "encodeObject:forKey:",  objc_getProperty((id)a1, v303, 120, 1),  @"SCPreferencesSignature2");
    [v431 finishEncoding];
    [v431 encodedData];
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    if ((unint64_t)[v34 length] <= 0x200000)
    {
      unint64_t v31 = v16;
      if ([v34 writeToFile:@"/Library/Preferences/com.apple.networkextension.plist" atomically:1])
      {
        objc_setProperty_atomic((id)a1, v313, 0LL, 80LL);
        objc_setProperty_atomic((id)a1, v314, 0LL, 88LL);
        *(void *)(a1 + 104) = v345;
        unint64_t v41 = v421;
        v315 = (void *)[v421 copy];
        objc_setProperty_atomic((id)a1, v316, v315, 56LL);

        v438 = 0u;
        v439 = 0u;
        v436 = 0u;
        v437 = 0u;
        v317 = v428;
        v318 = [v317 countByEnumeratingWithState:&v436 objects:v450 count:16];
        if (v318)
        {
          v319 = v318;
          v320 = *(void *)v437;
          do
          {
            for (k = 0LL; k != v319; ++k)
            {
              if (*(void *)v437 != v320) {
                objc_enumerationMutation(v317);
              }
              -[NEConfigurationManager didLoadConfiguration:]((void *)a1, *(void **)(*((void *)&v436 + 1) + 8 * k));
            }

            v319 = [v317 countByEnumeratingWithState:&v436 objects:v450 count:16];
          }

          while (v319);
        }

        int v36 = v317;

        if (v407) {
          -[NEConfigurationManager postChangeNotificationWithGeneration:andFlags:onlyIfChanged:]( (_DWORD *)a1,  v345,  v445,  0);
        }
        unint64_t v32 = 0LL;
        uint64_t v37 = v412;
        uint64_t v35 = v414;
        int v33 = (void *)v408;
        unint64_t v40 = v410;
        uint64_t v38 = v431;
      }

      else
      {
        ne_log_obj();
        v329 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v329, OS_LOG_TYPE_ERROR))
        {
          [v134 name];
          v339 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)v456 = 138412802;
          v457 = (const char *)a1;
          v458 = 2112;
          v459 = v339;
          v460 = 2080;
          v461 = "/Library/Preferences/com.apple.networkextension.plist";
          _os_log_error_impl( &dword_1876B1000,  v329,  OS_LOG_TYPE_ERROR,  "%@: Cannot save configuration %@, failed to write to %s",  v456,  0x20u);
        }

        -[NEConfigurationManager errorWithCode:specifics:](a1, 6LL, 0LL);
        unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v37 = v412;
        uint64_t v35 = v414;
        unint64_t v41 = v421;
        int v33 = (void *)v408;
        unint64_t v40 = v410;
        int v36 = v428;
        uint64_t v38 = v431;
      }

      goto LABEL_411;
    }

    unint64_t v31 = v16;
    ne_log_obj();
    v312 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v312, OS_LOG_TYPE_ERROR))
    {
      [v134 name];
      v336 = (void *)objc_claimAutoreleasedReturnValue();
      v337 = [v34 length];
      *(_DWORD *)v456 = 138412802;
      v457 = (const char *)a1;
      v458 = 2112;
      v459 = v336;
      v460 = 2048;
      v461 = (const char *)v337;
      _os_log_error_impl( &dword_1876B1000,  v312,  OS_LOG_TYPE_ERROR,  "%@: Cannot save configuration %@, the total size of the NetworkExtension configuration is too large (%lu bytes)",  v456,  0x20u);
    }

    -[NEConfigurationManager errorWithCode:specifics:](a1, 20LL, 0LL);
    unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_404:
    uint64_t v37 = v412;
    uint64_t v35 = v414;
    unint64_t v41 = v421;
    int v33 = (void *)v408;
    unint64_t v40 = v410;
    goto LABEL_407;
  }

  unint64_t v31 = v16;
  v305 = (void *)NSString;
  v306 = SCError();
  [v305 stringWithCString:SCErrorString(v306) encoding:4];
  v307 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEConfigurationManager errorWithCode:specifics:](a1, 12LL, v307);
  unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();

  uint64_t v34 = 0LL;
  uint64_t v35 = v414;
LABEL_406:
  unint64_t v41 = v421;
  int v33 = (void *)v408;
  unint64_t v40 = v410;
  uint64_t v37 = v412;
LABEL_407:
  int v36 = v428;
  uint64_t v38 = v431;
LABEL_411:

LABEL_412:
  return v32;
}

LABEL_13:
  unsigned __int16 v17 = [v6 VPN];
  if (v17)
  {
    int v18 = (void *)v17;
    [v60 VPN];
    unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v19 isEnabled])
    {
      [v60 VPN];
      int v20 = (void *)objc_claimAutoreleasedReturnValue();
      [v20 protocol];
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
      id v22 = [v21 includeAllNetworks];

      if (v22) {
        *a2 |= 0x80000000000000uLL;
      }
    }

    else
    {
    }
  }

  [v60 appVPN];
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v24 = v60;
  if (v23)
  {
    [v60 appVPN];
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v25 isEnabled])
    {
      int v26 = [v60 grade];

      unint64_t v24 = v60;
      if (v26 != 3)
      {
        [v60 appVPN];
        id v27 = (void *)objc_claimAutoreleasedReturnValue();
        if ([v27 isOnDemandEnabled])
        {
        }

        else
        {
          [v60 appVPN];
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v29 = [v28 isDisconnectOnDemandEnabled];

          if ((v29 & 1) == 0)
          {
            int v30 = *a2;
            goto LABEL_27;
          }
        }

        int v30 = *a2 | 0x8000000000000000LL;
LABEL_27:
        unint64_t v24 = v60;
        *a2 = v30 | 0x4000000000000000LL;
      }
    }

    else
    {

      unint64_t v24 = v60;
    }
  }

  unint64_t v31 = [v24 alwaysOnVPN];
  if (v31)
  {
    unint64_t v32 = (void *)v31;
    [v60 alwaysOnVPN];
    int v33 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v34 = [v33 isEnabled];

    if (v34) {
      *a2 |= 0x2000000000000000uLL;
    }
  }

  uint64_t v35 = [v60 dnsProxy];
  if (v35)
  {
    int v36 = (void *)v35;
    [v60 dnsProxy];
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v38 = [v37 isEnabled];

    if (v38) {
      *a2 |= 0x800000000000000uLL;
    }
  }

  int v39 = [v60 contentFilter];
  if (v39)
  {
    unint64_t v40 = (void *)v39;
    [v60 contentFilter];
    unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v42 = [v41 isEnabled];

    if (v42) {
      *a2 |= 0x1000000000000000uLL;
    }
  }

  char v43 = [v60 dnsSettings];
  if (v43)
  {
    uint64_t v44 = (void *)v43;
    [v60 dnsSettings];
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
    int v46 = [v45 isEnabled];

    if (v46) {
      *a2 |= 0x200000000000000uLL;
    }
  }

  int64_t v47 = [v60 pathController];
  if (v47)
  {
    int v48 = (void *)v47;
    [v60 pathController];
    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v49 isEnabled])
    {
      [v60 pathController];
      uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
      int v51 = [v50 hasNonDefaultRules];

      if (v51) {
        *a2 |= 0x400000000000000uLL;
      }
    }

    else
    {
    }
  }

  uint64_t v52 = [v60 appPush];
  if (v52)
  {
    uint64_t v53 = (void *)v52;
    [v60 appPush];
    int v54 = (void *)objc_claimAutoreleasedReturnValue();
    BOOL v55 = [v54 isEnabled];

    if (v55) {
      *a2 |= 0x100000000000000uLL;
    }
  }

  uint64_t v56 = [v60 relay];
  if (v56)
  {
    unint64_t v57 = (void *)v56;
    [v60 relay];
    int v58 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v59 = [v58 isEnabled];

    if (v59) {
      *a2 |= 0x20000000000000uLL;
    }
  }
}

  int v13 = *(void *)(a1 + 32);
  v19[0] = MEMORY[0x1895F87A8];
  v19[1] = 3221225472LL;
  v19[2] = __78__NEConfigurationManager_loadConfigurationWithID_withCompletionQueue_handler___block_invoke_153;
  v19[3] = &unk_18A08FB50;
  unint64_t v14 = *(void **)(a1 + 48);
  unint64_t v15 = *(id *)(a1 + 56);
  uint64_t v21 = v4;
  id v22 = v15;
  int v20 = v8;
  int v16 = v4;
  unsigned __int16 v17 = v8;
  -[NEConfigurationManager executeCallbackOnQueue:callback:](v13, v14, v19);
}

    unint64_t v14 = 1LL;
    goto LABEL_14;
  }

  if ([(id)v4 status] != 3)
  {
    unint64_t v15 = *(dispatch_queue_s **)(a1 + 40);
    v24[0] = MEMORY[0x1895F87A8];
    v24[1] = 3221225472LL;
    v24[2] = __64__NEFilterSource_addData_withCompletionQueue_completionHandler___block_invoke_3;
    v24[3] = &unk_18A0908C8;
    CFStringRef v11 = &v25;
    int v16 = *(id *)(a1 + 56);
    v24[4] = *(void *)(a1 + 32);
    BOOL v25 = v16;
    unsigned __int16 v17 = v24;
LABEL_15:
    dispatch_async(v15, v17);
    goto LABEL_16;
  }

  CFIndex v6 = MEMORY[0x1895F87A8];
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = __64__NEFilterSource_addData_withCompletionQueue_completionHandler___block_invoke_4;
  aBlock[3] = &unk_18A08FB50;
  v22[0] = *(id *)(a1 + 40);
  uint64_t v7 = *(id *)(a1 + 56);
  v22[1] = *(void *)(a1 + 32);
  uint64_t v23 = v7;
  uint64_t v9 = _Block_copy(aBlock);
  Property = *(id *)(a1 + 32);
  if (Property) {
    Property = objc_getProperty(Property, v8, 64LL, 1);
  }
  CFStringRef v11 = (id *)v22;
  [Property appendData:*(void *)(a1 + 48)];
  uint64_t v12 = *(void *)(a1 + 32);
  v19[0] = v6;
  v19[1] = 3221225472LL;
  v19[2] = __64__NEFilterSource_addData_withCompletionQueue_completionHandler___block_invoke_6;
  v19[3] = &unk_18A090940;
  int v13 = v9;
  int v20 = v13;
  if ((-[NEFilterSource sendDataToPluginWithConnection:completionHandler:](v12, v3, v19) & 1) == 0) {
    v13[2](v13);
  }

LABEL_16:
}
    }

    int v13 = objc_getProperty(v5, v6, 48LL, 1);
    if ([v13 mode] == 1)
    {
      unint64_t v14 = -[NEIKEv2Packet hasNotification:]((void *)a1, (const char *)0x4007);

      if ((v14 & 1) == 0)
      {
        ne_log_obj();
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          int v16 = (char *)[(id)a1 copyShortDescription];
          *(_DWORD *)buf = 138412290;
          v161 = v16;
          _os_log_error_impl( &dword_1876B1000,  v7,  OS_LOG_TYPE_ERROR,  "%@ Transport mode Child SA was not accepted",  buf,  0xCu);
LABEL_34:
        }

        goto LABEL_35;
      }
    }

    else
    {
    }

    objc_getProperty((id)a1, v15, 96LL, 1);
    Property = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v19 = Property;
    if (Property) {
      Property = objc_getProperty(Property, v18, 24LL, 1);
    }
    uint64_t v7 = Property;

    if (-[os_log_s count](v7, "count") != 1)
    {
      ne_log_obj();
      int v20 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v20, OS_LOG_TYPE_ERROR))
      {
        id v75 = (char *)[(id)a1 copyShortDescription];
        uint64_t v76 = -[os_log_s count](v7, "count");
        *(_DWORD *)buf = 138412546;
        v161 = v75;
        v162 = 1024;
        LODWORD(v163) = v76;
        _os_log_error_impl( &dword_1876B1000,  (os_log_t)v20,  OS_LOG_TYPE_ERROR,  "%@ Received %u child SA proposals, require 1",  buf,  0x12u);
      }

      a1 = 0LL;
      goto LABEL_121;
    }

    -[os_log_s firstObject](v7, "firstObject");
    int v20 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue();
    uint64_t v23 = objc_getProperty(v5, v21, 176LL, 1);
    if (v20) {
      unint64_t v24 = objc_getProperty(v20, v22, 80LL, 1);
    }
    else {
      unint64_t v24 = 0LL;
    }
    BOOL v25 = v24;

    if (!v25)
    {
      ne_log_obj();
      id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        uint64_t v28 = (char *)[(id)a1 copyShortDescription];
        *(_DWORD *)buf = 138412290;
        v161 = v28;
        uint64_t v29 = "%@ Child SA proposal missing SPI";
        goto LABEL_69;
      }

  return v21;
}

LABEL_14:
  id v22 = 0LL;
LABEL_18:

  return v22;
}
}

          goto LABEL_14;
        }

        unint64_t v14 = v13;
        [v4 setObject:0 forKeyedSubscript:v14];
      }

      uint64_t v9 = [v7 countByEnumeratingWithState:&v15 objects:v21 count:16];
      if (v9) {
        continue;
      }
      break;
    }
  }

    int v20 = 0LL;
    goto LABEL_6;
  }

  if (!v16)
  {
    ne_log_obj();
    id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      BOOL v25 = "-[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:saSession:shouldCopySASession:transport:packetDelegate:]";
      uint64_t v23 = "%s called with null saSession";
      goto LABEL_15;
    }

    goto LABEL_13;
  }

  if (!v15)
  {
    ne_log_obj();
    id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      goto LABEL_13;
    }
    *(_DWORD *)buf = 136315138;
    BOOL v25 = "-[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:saSession:shouldCopySASession:transport:packetDelegate:]";
    uint64_t v23 = "%s called with null queue";
LABEL_15:
    _os_log_fault_impl(&dword_1876B1000, v22, OS_LOG_TYPE_FAULT, v23, buf, 0xCu);
    goto LABEL_13;
  }

  unint64_t v19 = (void *)[v16 copyEmptySASession];
  a1 =  -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]( a1,  v13,  0LL,  0LL,  v15,  0LL,  0LL,  v19,  1,  v18,  v17,  v14);

  int v20 = a1;
LABEL_6:

LABEL_7:
  return v20;
}

    int v20 = 0LL;
    goto LABEL_6;
  }

  if (!v16)
  {
    ne_log_obj();
    id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      BOOL v25 = "-[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:kernelSASessionName:transport:packetDelegate:]";
      uint64_t v23 = "%s called with null kernelSASessionName";
      goto LABEL_15;
    }

    goto LABEL_13;
  }

  if (!v15)
  {
    ne_log_obj();
    id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      goto LABEL_13;
    }
    *(_DWORD *)buf = 136315138;
    BOOL v25 = "-[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:kernelSASessionName:transport:packetDelegate:]";
    uint64_t v23 = "%s called with null queue";
LABEL_15:
    _os_log_fault_impl(&dword_1876B1000, v22, OS_LOG_TYPE_FAULT, v23, buf, 0xCu);
    goto LABEL_13;
  }

  unint64_t v19 = -[NEIPSecSAKernelSession initWithName:delegate:]( objc_alloc(&OBJC_CLASS___NEIPSecSAKernelSession),  "initWithName:delegate:",  v16,  0LL);
  a1 =  -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]( a1,  v13,  0LL,  0LL,  v15,  0LL,  0LL,  v19,  1,  v18,  v17,  v14);

  int v20 = a1;
LABEL_6:

LABEL_7:
  return v20;
}
  }
}

        uint64_t v9 = 0LL;
        goto LABEL_14;
      }

      CFStringRef v10 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_13;
      }
      LOWORD(buf) = 0;
      CFStringRef v11 = "pfkey send delete policy failed";
    }

    else
    {
      CFStringRef v10 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_13;
      }
      LOWORD(buf) = 0;
      CFStringRef v11 = "delete policy, policy data is NULL";
    }

  size_t v4 = -[NEIKEv2AuthenticationProtocol initWithMethod:](v2, "initWithMethod:", v3);
LABEL_14:
  int v5 = v4;
LABEL_15:

  return v5;
}

    CFStringRef v11 = 0;
    goto LABEL_14;
  }

  CFStringRef v11 = 1;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412546;
    unsigned __int16 v17 = self;
    int v18 = 2112;
    unint64_t v19 = v4;
    _os_log_impl(&dword_1876B1000, v10, OS_LOG_TYPE_INFO, "%@ Migrated SA %@", buf, 0x16u);
  }

  id v8 = *MEMORY[0x18960CA70];
  [v4 objectForKeyedSubscript:*MEMORY[0x18960CA70]];
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  CFStringRef v10 = isa_nsarray(v9);

  if (v10)
  {
    [v4 objectForKeyedSubscript:v8];
    CFStringRef v11 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v12 = [v11 copy];
    DNSSearchDomainMatch = v5->_DNSSearchDomainMatch;
    v5->_DNSSearchDomainMatch = (NSArray *)v12;
  }

  unint64_t v14 = *MEMORY[0x18960CA78];
  [v4 objectForKeyedSubscript:*MEMORY[0x18960CA78]];
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  int v16 = isa_nsarray(v15);

  if (v16)
  {
    [v4 objectForKeyedSubscript:v14];
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    int v18 = [v17 copy];
    DNSServerAddressMatch = v5->_DNSServerAddressMatch;
    v5->_DNSServerAddressMatch = (NSArray *)v18;
  }

  [v4 objectForKeyedSubscript:*MEMORY[0x18960CA80]];
  int v20 = (void *)objc_claimAutoreleasedReturnValue();
  if ([v20 isEqualToString:@"Cellular"])
  {
    uint64_t v21 = 3LL;
  }

  else
  {
    if (([v20 isEqualToString:*MEMORY[0x18960CBF8]] & 1) != 0
      || ![v20 isEqualToString:*MEMORY[0x18960CC00]])
    {
      goto LABEL_24;
    }

    uint64_t v21 = 2LL;
  }

  v5->_interfaceTypeMatch = v21;
LABEL_24:
  id v22 = *MEMORY[0x18960CA88];
  [v4 objectForKeyedSubscript:*MEMORY[0x18960CA88]];
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v24 = isa_nsarray(v23);

  if (v24)
  {
    [v4 objectForKeyedSubscript:v22];
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    int v26 = [v25 copy];
    SSIDMatch = v5->_SSIDMatch;
    v5->_SSIDMatch = (NSArray *)v26;
  }

  uint64_t v28 = *MEMORY[0x18960CA90];
  [v4 objectForKeyedSubscript:*MEMORY[0x18960CA90]];
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
  int v30 = isa_nsstring(v29);

  if (v30)
  {
    unint64_t v31 = (void *)MEMORY[0x189604030];
    [v4 objectForKeyedSubscript:v28];
    unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
    int v33 = [v31 URLWithString:v32];
    probeURL = v5->_probeURL;
    v5->_probeURL = (NSURL *)v33;
  }

  uint64_t v35 = v5;

LABEL_29:
  return v5;
}
  }

  else
  {
    CFStringRef v11 = 0LL;
  }

  return v11;
}

          [a1 setPassword:0];

          return;
        }
      }

      else
      {
      }
    }

    if ([a1 authenticationRequired]) {
      goto LABEL_13;
    }
    [MEMORY[0x189607A68] sharedCredentialStorage];
    CFStringRef v10 = (void *)objc_claimAutoreleasedReturnValue();
    [v10 defaultCredentialForProtectionSpace:v11];
    id v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v8) {
      goto LABEL_13;
    }
    [MEMORY[0x189607A68] sharedCredentialStorage];
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    [v9 removeCredential:v8 forProtectionSpace:v11];
    goto LABEL_12;
  }

    goto LABEL_14;
  }

  dataOut = v9;
  CFStringRef v11 = v4;
  uint64_t v12 = (const void *)[v11 bytes];
  int v13 = [v11 length];
  unint64_t v14 = v7;
  unint64_t v15 = (const void *)[v14 bytes];
  int v16 = [v14 length];
  unsigned __int16 v17 = CCCrypt(0, 0, 0, v12, v13, 0LL, v15, v16, dataOut, __size, &__size);
  if (!v17)
  {
    BOOL v25 = objc_alloc(MEMORY[0x189603F48]);
    uint64_t v23 = (void *)[v25 initWithBytesNoCopy:dataOut length:__size];
    goto LABEL_15;
  }

  int v18 = v17;
  ne_log_obj();
  unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    uint64_t v34 = v18;
    _os_log_error_impl(&dword_1876B1000, v19, OS_LOG_TYPE_ERROR, "CCCrypt failed with buffer: %d", buf, 8u);
  }

  free(dataOut);
LABEL_14:
  uint64_t v23 = 0LL;
LABEL_15:

  return v23;
}

  [v6 objectForKeyedSubscript:@"username"];
  unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();

  if (v19)
  {
    if (v7)
    {
      [v6 objectForKeyedSubscript:@"username"];
      int v20 = (void *)objc_claimAutoreleasedReturnValue();
      [v7 setUsername:v20];

      goto LABEL_17;
    }

    if (v8)
    {
      [v6 objectForKeyedSubscript:@"username"];
      unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
      [v8 setUsername:v24];
LABEL_22:
    }

    MEMORY[0x1895AC894](v7);
  }

  return v6;
}

    unint64_t v2 = v1[40];
  }

  if (CFGetTypeID(v8) != v9 || (CFDataGetBytePtr(v8), !NEHelperInterfaceRemoveAddress()))
  {
    CFRelease(v8);
    goto LABEL_13;
  }

  -[NEVPNProtocolL2TP localIdentifier](self, "localIdentifier");
  unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();

  if (v17)
  {
    -[NEVPNProtocolL2TP localIdentifier](self, "localIdentifier");
    int v18 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v18 forKeyedSubscript:*MEMORY[0x18960C660]];

    [v3 setObject:*MEMORY[0x18960CAD8] forKeyedSubscript:*MEMORY[0x18960C668]];
  }

  return v3;
}
  }

LABEL_22:
  int v30 = *MEMORY[0x18960C858];
  [v4 objectForKeyedSubscript:*MEMORY[0x18960C858]];
  unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v32 = isa_nsnumber(v31);

  if (v32)
  {
    [v4 objectForKeyedSubscript:v30];
    int v33 = (void *)objc_claimAutoreleasedReturnValue();
    v8->_verboseLoggingEnabled = [v33 BOOLValue];
  }

  -[NEVPNProtocol initDisconnectOptions:](v8, "initDisconnectOptions:", v4);
LABEL_25:

  return v8;
}

LABEL_38:
  ne_log_obj();
  int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1876B1000, v20, OS_LOG_TYPE_DEFAULT, "App VPN configuration is enabled", buf, 2u);
  }

  if ((a3 & 0x2000000000000000LL) == 0)
  {
LABEL_25:
    if ((a3 & 0x800000000000000LL) == 0) {
      goto LABEL_26;
    }
    goto LABEL_44;
  }

      id v27 = 1;
LABEL_39:

      goto LABEL_40;
    }
  }

  else
  {
    v170 = 0uLL;
    v171 = 0uLL;
    v168 = 0uLL;
    v169 = 0uLL;
    -[os_log_s encryptionProtocols](v7, "encryptionProtocols");
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v19 = [v9 countByEnumeratingWithState:&v168 objects:v184 count:16];
    if (v19)
    {
      int v20 = v19;
      uint64_t v21 = *(void *)v169;
LABEL_20:
      id v22 = 0LL;
      while (1)
      {
        if (*(void *)v169 != v21) {
          objc_enumerationMutation(v9);
        }
        uint64_t v23 = *(void **)(*((void *)&v168 + 1) + 8 * v22);
        [v6 encryptionProtocols];
        unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
        BOOL v25 = [v24 containsObject:v23];

        if (v25) {
          break;
        }
        if (v20 == ++v22)
        {
          int v20 = [v9 countByEnumeratingWithState:&v168 objects:v184 count:16];
          if (v20) {
            goto LABEL_20;
          }
          goto LABEL_26;
        }
      }

      if (!v8)
      {
LABEL_176:
        int v33 = 0LL;
        goto LABEL_177;
      }

      objc_setProperty_atomic(v8, v26, v23, 88LL);
      int v33 = objc_getProperty(v8, v35, 88LL, 1);
      if (!v33) {
        goto LABEL_177;
      }
      int v36 = v33[2];
      uint64_t v37 = v36 > 0x1F;
      uint64_t v38 = (1LL << v36) & 0xD01C0000LL;
      if (v37 || v38 == 0) {
        goto LABEL_177;
      }
      goto LABEL_38;
    }
  }

  objc_getProperty(v3, v24, 96LL, 1);
  int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v49 = v47;
  if (v47) {
    uint64_t v50 = objc_getProperty(v47, v48, 24LL, 1);
  }
  else {
    uint64_t v50 = 0LL;
  }
  int v51 = v50;
  if (v6) {
    objc_storeStrong((id *)(v6 + 344), v50);
  }

  objc_getProperty(v3, v52, 104LL, 1);
  uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
  BOOL v55 = v53;
  if (v53) {
    uint64_t v56 = objc_getProperty(v53, v54, 24LL, 1);
  }
  else {
    uint64_t v56 = 0LL;
  }
  unint64_t v57 = v56;
  if (v6) {
    objc_storeStrong((id *)(v6 + 336), v56);
  }

  int v58 = -[NEIKEv2Packet hasNotification:](v3, (const char *)0x4007);
  if (v6)
  {
    uint64_t v60 = 1LL;
    if (!v58) {
      uint64_t v60 = 2LL;
    }
    *(void *)(v6 + 352) = v60;
  }

  objc_getProperty(v3, v59, 88LL, 1);
  uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v63 = v61;
  if (v61) {
    uint64_t v64 = objc_getProperty(v61, v62, 24LL, 1);
  }
  else {
    uint64_t v64 = 0LL;
  }
  uint64_t v65 = v64;
  if (v6) {
    objc_storeStrong((id *)(v6 + 360), v64);
  }

  uint64_t v67 = objc_getProperty(v3, v66, 152LL, 1);
  uint64_t v69 = v67;
  if (v67) {
    int v70 = objc_getProperty(v67, v68, 24LL, 1);
  }
  else {
    int v70 = 0LL;
  }
  unint64_t v71 = v70;
  if (v6) {
    objc_storeStrong((id *)(v6 + 392), v70);
  }

  objc_getProperty(v3, v72, 160LL, 1);
  uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue();
  id v75 = v73;
  if (v73) {
    uint64_t v76 = objc_getProperty(v73, v74, 24LL, 1);
  }
  else {
    uint64_t v76 = 0LL;
  }
  unint64_t v77 = v76;
  if (v6) {
    objc_storeStrong((id *)(v6 + 400), v76);
  }

  objc_getProperty(v3, v78, 168LL, 1);
  uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
  int v81 = v79;
  if (v79) {
    uint64_t v82 = objc_getProperty(v79, v80, 24LL, 1);
  }
  else {
    uint64_t v82 = 0LL;
  }
  v83 = v82;
  uint64_t v84 = v83;
  if (v6)
  {
    objc_storeStrong((id *)(v6 + 408), v82);

    __int16 v85 = *(void **)(v6 + 104);
  }

  else
  {

    __int16 v85 = 0LL;
  }

  int v86 = v85;

  int v88 = objc_getProperty(v3, v87, 128LL, 1);
  uint64_t v89 = (void *)v88;
  if (v88) {
    CFErrorRef v90 = *(void **)(v88 + 24);
  }
  else {
    CFErrorRef v90 = 0LL;
  }
  unint64_t v91 = v90;
  v92 = v91;
  if (!v86)
  {
    -[NEIKEv2IKESA setAuthProtocolFromPacket:](v6, v91);

    v109 = objc_getProperty(v3, v108, 128LL, 1);
    v110 = (id)v109;
    if (v109) {
      v111 = *(void **)(v109 + 32);
    }
    else {
      v111 = 0LL;
    }
    v112 = v111;
    if (v6) {
      objc_storeStrong((id *)(v6 + 376), v111);
    }

    goto LABEL_86;
  }

  if (v92)
  {
    ne_log_obj();
    v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    {
      v208 = (char *)[v3 copyShortDescription];
      v210 = objc_getProperty(v3, v209, 128LL, 1);
      v211 = (void *)v210;
      if (v210) {
        v212 = *(void **)(v210 + 24);
      }
      else {
        v212 = 0LL;
      }
      v213 = v212;
      if (v6) {
        v214 = *(void **)(v6 + 104);
      }
      else {
        v214 = 0LL;
      }
      v215 = v214;
      *(_DWORD *)v239 = 138412802;
      v240 = v208;
      v241 = 2112;
      v242 = v213;
      v243 = 2112;
      v244 = v215;
      _os_log_error_impl( &dword_1876B1000,  v94,  OS_LOG_TYPE_ERROR,  "%@ Responder packet authentication method %@ is not compatible with configuration %@",  v239,  0x20u);
    }

    v96 = objc_getProperty(v3, v95, 128LL, 1);
    v97 = (void *)v96;
    if (v96) {
      v98 = *(void **)(v96 + 24);
    }
    else {
      v98 = 0LL;
    }
    v99 = v98;
    if (v6) {
      v100 = *(void **)(v6 + 104);
    }
    else {
      v100 = 0LL;
    }
    v227 = v100;
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorAuthentication( @"Responder packet authentication method %@ is not compatible with configuration %@",  v101,  v102,  v103,  v104,  v105,  v106,  v107,  (uint64_t)v99);

    goto LABEL_76;
  }

  v113 = objc_getProperty(v3, v93, 144LL, 1);

  if (!v113)
  {
    ne_log_obj();
    v190 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v190, OS_LOG_TYPE_ERROR))
    {
      v217 = (char *)[v3 copyShortDescription];
      *(_DWORD *)v239 = 138412290;
      v240 = v217;
      _os_log_error_impl(&dword_1876B1000, v190, OS_LOG_TYPE_ERROR, "%@ Packet missing GSPM payload", v239, 0xCu);
    }

    ErrorInternal = NEIKEv2CreateErrorAuthentication( @"Packet missing GSPM payload",  v191,  v192,  v193,  v194,  v195,  v196,  v197,  v226);
LABEL_136:
    ErrorPeerInvalidSyntax = (void *)ErrorInternal;
LABEL_76:
    length = 24LL;
    goto LABEL_102;
  }

  if (v6) {
    v114 = *(void **)(v6 + 104);
  }
  else {
    v114 = 0LL;
  }
  v110 = v114;
  -[NEIKEv2IKESA setAuthProtocolFromPacket:](v6, v110);
LABEL_86:

  if (!v6 || (*(_BYTE *)(v6 + 24) & 1) == 0) {
    goto LABEL_96;
  }
  v115 = -[NEIKEv2Packet copyNotification:](v3, (const char *)0x4034);
  v117 = v115;
  if (!v115)
  {
LABEL_95:

LABEL_96:
    goto LABEL_107;
  }

  v118 = -[NEIKEv2NotifyPayload getPPKIDType](v115, v116);
  v126 = v118;
  if ((unint64_t)(v118 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"PPK ID type %zu is invalid",  (uint64_t)v119,  v120,  v121,  v122,  v123,  v124,  v125,  v118);
  }

  else
  {
    v127 = (void *)-[NEIKEv2NotifyPayload copyPPKID](v117, v119);
    v128 = [v127 length];
    if (v126 != 2 || v128)
    {
      -[NEIKEv2IKESA setPpkIDFromPacket:](v6, v127);
      *(void *)(v6 + 416) = v126;
      v136 = -[NEIKEv2Packet copyNotification:](v3, (const char *)0x4035);
      v138 = v136;
      if (v136) {
        v136 = objc_getProperty(v136, v137, 32LL, 1);
      }
      v139 = v136;
      -[NEIKEv2IKESA setPrimeAuthenticationDataFromPacket:](v6, v139);

      goto LABEL_95;
    }

    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"PPK ID missing from payload",  v129,  v130,  v131,  v132,  v133,  v134,  v135,  v226);
  }

LABEL_101:
  length = 7LL;
LABEL_102:

  if (ErrorPeerInvalidSyntax)
  {
    ne_log_obj();
    v141 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
    {
      v199 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412546;
      *(void *)&buf[4] = v199;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = ErrorPeerInvalidSyntax;
      _os_log_error_impl( &dword_1876B1000,  v141,  OS_LOG_TYPE_ERROR,  "%@ Failed to process IKE Auth packet (receive p1) %@",  buf,  0x16u);
    }

    v142 = +[NEIKEv2IKEAuthPacket createIKEAuthResponse:refusalError:]( (uint64_t)&OBJC_CLASS___NEIKEv2IKEAuthPacket,  v3,  length);
    if ((-[NEIKEv2Session sendReply:replyHandler:](*(void *)(a1 + 40), v142, 0LL) & 1) != 0)
    {
      -[NEIKEv2IKESA setState:error:](*(void *)(a1 + 32), 3uLL, ErrorPeerInvalidSyntax);
      -[NEIKEv2Session reportState](*(void **)(a1 + 40), v144);
    }

    else
    {
      v156 = *(id *)(a1 + 40);
      if (v156) {
        v156 = objc_getProperty(v156, v143, 336LL, 1);
      }
      v157 = v156;
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"AUTH refusal p1 %@",  v158,  v159,  v160,  v161,  v162,  v163,  v164,  (uint64_t)ErrorPeerInvalidSyntax);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v157, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](*(void **)(a1 + 40), v166);
      -[NEIKEv2Session resetAll](*(void *)(a1 + 40), v167);
    }

    goto LABEL_147;
  }
}

LABEL_43:
    unint64_t v19 = 0;
    goto LABEL_44;
  }

LABEL_39:
            unint64_t v32 = &OBJC_IVAR___NEKeychainItem__oldItem;
            goto LABEL_40;
          }

          if (v50)
          {
            *(_DWORD *)buf = 138412290;
            v93 = v27;
            _os_log_debug_impl(&dword_1876B1000, v49, OS_LOG_TYPE_DEBUG, "%@: Establishing channel", buf, 0xCu);
          }

          if (*((void *)v27 + 23) && *((_DWORD *)v27 + 40))
          {
            int v54 = os_channel_attr_create();
            *((void *)v27 + 3) = v54;
            if (v54)
            {
              BOOL v55 = os_channel_attr_set_key();
              if (v55)
              {
                uint64_t v56 = v55;
                ne_log_obj();
                uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 138412546;
                  v93 = v27;
                  v94 = 1024;
                  *(_DWORD *)v95 = v56;
                  unint64_t v57 = "%@: createChannel failed to set key <err %d> ";
LABEL_63:
                  int v58 = v53;
                  uint64_t v59 = 18;
                  goto LABEL_54;
                }

            dlclose(v0);
            return;
          }

          CFStringRef v11 = (os_log_s *)ne_log_obj();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__path = 0;
            uint64_t v12 = "Failed to load SymptomReporter symbol symptom_set_additional_qualifier";
            goto LABEL_36;
          }

  -[NEVPNProtocolIPSec localIdentifier](self, "localIdentifier");
  int v39 = (void *)objc_claimAutoreleasedReturnValue();

  if (v39)
  {
    -[NEVPNProtocolIPSec localIdentifier](self, "localIdentifier");
    unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v40 forKeyedSubscript:*MEMORY[0x18960C660]];

    [v3 setObject:*MEMORY[0x18960CAD8] forKeyedSubscript:*MEMORY[0x18960C668]];
  }

  -[NEVPNProtocolIPSec remoteIdentifier](self, "remoteIdentifier");
  unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();

  if (v41)
  {
    -[NEVPNProtocolIPSec remoteIdentifier](self, "remoteIdentifier");
    unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v42 forKeyedSubscript:@"RemoteIdentifier"];
  }

  if (-[NEVPNProtocolIPSec useExtendedAuthentication](self, "useExtendedAuthentication")) {
    char v43 = &unk_18A0CFB40;
  }
  else {
    char v43 = &unk_18A0CFB58;
  }
  [v3 setObject:v43 forKeyedSubscript:*MEMORY[0x18960C688]];
  -[NEVPNProtocolIPSec legacyExchangeMode](self, "legacyExchangeMode");
  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v45 = isa_nsarray(v44);

  if (v45)
  {
    -[NEVPNProtocolIPSec legacyExchangeMode](self, "legacyExchangeMode");
    int v46 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v46 forKeyedSubscript:@"ExchangeMode"];
  }

  -[NEVPNProtocolIPSec legacyProposals](self, "legacyProposals");
  int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();

  if (v47)
  {
    [MEMORY[0x189603FA8] array];
    int v48 = (void *)objc_claimAutoreleasedReturnValue();
    int v58 = 0u;
    uint64_t v59 = 0u;
    uint64_t v60 = 0u;
    uint64_t v61 = 0u;
    -[NEVPNProtocolIPSec legacyProposals](self, "legacyProposals", 0LL);
    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v50 = [v49 countByEnumeratingWithState:&v58 objects:v62 count:16];
    if (v50)
    {
      int v51 = v50;
      uint64_t v52 = *(void *)v59;
      do
      {
        for (i = 0LL; i != v51; ++i)
        {
          if (*(void *)v59 != v52) {
            objc_enumerationMutation(v49);
          }
          int v54 = (void *)[*(id *)(*((void *)&v58 + 1) + 8 * i) copyLegacyDictionary];
          if (v54) {
            [v48 addObject:v54];
          }
        }

        int v51 = [v49 countByEnumeratingWithState:&v58 objects:v62 count:16];
      }

      while (v51);
    }

    [v3 setObject:v48 forKeyedSubscript:@"Proposals"];
  }

  if (-[NEVPNProtocolIPSec extendedAuthPasswordPrompt](self, "extendedAuthPasswordPrompt")) {
    [v3 setObject:*MEMORY[0x18960CAF0] forKeyedSubscript:*MEMORY[0x18960C6A0]];
  }
  -[NEVPNProtocol addDisconnectOptions:](self, "addDisconnectOptions:", v3);
  return v3;
}

LABEL_41:
  ne_log_obj();
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1876B1000, v21, OS_LOG_TYPE_DEFAULT, "Always On VPN is enabled", buf, 2u);
  }

  if ((a3 & 0x800000000000000LL) == 0)
  {
LABEL_26:
    if ((a3 & 0x200000000000000LL) == 0) {
      goto LABEL_27;
    }
    goto LABEL_47;
  }

    goto LABEL_42;
  }

  uint64_t v23 = *(id *)(a1 + 32);
  if (v23) {
    uint64_t v23 = objc_getProperty(v23, v13, 88LL, 1);
  }
  [v23 objectForKeyedSubscript:v8];
  unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  int v16 = v24;
  if (v24 && -[NEConfiguration isSupportedBySC](v24))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
    {
      [v16 name];
      int v26 = (__CFString *)objc_claimAutoreleasedReturnValue();
      int v39 = 138412290;
      Name = v26;
      _os_log_impl( &dword_1876B1000,  v25,  OS_LOG_TYPE_INFO,  "Configuration %@ no longer has a corresponding SCNetworkService, removing it",  (uint8_t *)&v39,  0xCu);
    }

    -[NEConfigurationManager removeConfigurationFromDisk:updateSCPreferences:](*(_BYTE **)(a1 + 32), v8, 0LL);
    unint64_t v19 = (NEConfiguration *)objc_claimAutoreleasedReturnValue();
    if (v19)
    {
      ne_log_obj();
      id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        [v16 name];
        uint64_t v37 = (__CFString *)objc_claimAutoreleasedReturnValue();
        int v39 = 138412546;
        Name = v37;
        unint64_t v41 = 2112;
        unint64_t v42 = v19;
        _os_log_error_impl( &dword_1876B1000,  v27,  OS_LOG_TYPE_ERROR,  "Failed to remove configuration %@: %@",  (uint8_t *)&v39,  0x16u);
      }
    }

    else
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
    }

    goto LABEL_41;
  }

      goto LABEL_42;
    }

    if (isa_nsdata(v8))
    {
      -[NEHasher encodeDataObject:](v5, "encodeDataObject:", v8);
      goto LABEL_42;
    }

    if (isa_nsstring(v8))
    {
      uint64_t v28 = (const char *)[v8 UTF8String];
      if (v5) {
LABEL_57:
      }
        int v5 = (NEHasher *)v5->_sha1Context;
    }

    else
    {
      if (isa_nsnumber(v8))
      {
        [v8 doubleValue];
        *(void *)data = v32;
        if (v5) {
          sha1Context = v5->_sha1Context;
        }
        else {
          sha1Context = 0LL;
        }
        unint64_t v31 = (const char *)data;
        uint64_t v29 = 8;
        goto LABEL_67;
      }

      if (isa_nsuuid(v8))
      {
        [v8 getUUIDBytes:data];
        if (v5) {
          sha1Context = v5->_sha1Context;
        }
        else {
          sha1Context = 0LL;
        }
        unint64_t v31 = (const char *)data;
        uint64_t v29 = 16;
        goto LABEL_67;
      }

      if (!isa_nsurl(v8))
      {
        if (isa_neclass())
        {
          [v8 encodeWithCoder:v5];
        }

        else
        {
          if (v5) {
            Property = objc_getProperty(v5, v34, 16LL, 1);
          }
          else {
            Property = 0LL;
          }
          if ([Property count])
          {
            int v36 = (objc_class *)objc_opt_class();
            NSStringFromClass(v36);
            uint64_t v9 = (id)objc_claimAutoreleasedReturnValue();
            int v46 = 0u;
            int64_t v47 = 0u;
            int v48 = 0u;
            uint64_t v49 = 0u;
            if (v5) {
              uint64_t v38 = objc_getProperty(v5, v37, 16LL, 1);
            }
            else {
              uint64_t v38 = 0LL;
            }
            CFStringRef v10 = v38;
            int v39 = [v10 countByEnumeratingWithState:&v46 objects:v62 count:16];
            if (v39)
            {
              unint64_t v40 = v39;
              unint64_t v41 = *(void *)v47;
              while (2)
              {
                for (m = 0LL; m != v40; ++m)
                {
                  if (*(void *)v47 != v41) {
                    objc_enumerationMutation(v10);
                  }
                  if (objc_msgSend( v9,  "hasPrefix:",  *(void *)(*((void *)&v46 + 1) + 8 * m),  (void)v46))
                  {
                    [v8 encodeWithCoder:v5];
                    goto LABEL_40;
                  }
                }

                unint64_t v40 = [v10 countByEnumeratingWithState:&v46 objects:v62 count:16];
                if (v40) {
                  continue;
                }
                break;
              }
            }
          }

          ne_log_obj();
          char v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v44 = (objc_class *)objc_opt_class();
            NSStringFromClass(v44);
            uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)data = 138412290;
            *(void *)&data[4] = v45;
            _os_log_debug_impl(&dword_1876B1000, v43, OS_LOG_TYPE_DEBUG, "Not hashing value with class %@", data, 0xCu);
          }
        }

        goto LABEL_42;
      }

      int v33 = [v8 absoluteString];
      uint64_t v28 = (const char *)[v33 UTF8String];

      if (v5) {
        goto LABEL_57;
      }
    }

    uint64_t v29 = strlen(v28);
    sha1Context = (CC_SHA1_CTX *)v5;
    unint64_t v31 = v28;
LABEL_67:
    CC_SHA1_Update(sha1Context, v31, v29);
    goto LABEL_42;
  }

  uint64_t v21 = 1;
  if (v6 > 80)
  {
    switch(v6)
    {
      case 'c':
        goto LABEL_47;
      case 'd':
      case 'l':
        goto LABEL_46;
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
        goto LABEL_52;
      case 'i':
        goto LABEL_27;
      default:
        if (v6 == 81 || v6 == 113) {
          goto LABEL_46;
        }
        goto LABEL_52;
    }
  }

  if (v6 == 73)
  {
LABEL_27:
    uint64_t v21 = 4;
LABEL_47:
    if (self) {
      int v26 = self->_sha1Context;
    }
    else {
      int v26 = 0LL;
    }
    CC_SHA1_Update(v26, a4, v21);
    return;
  }

  if (v6 == 76)
  {
LABEL_46:
    uint64_t v21 = 8;
    goto LABEL_47;
  }

    ne_log_obj();
    int v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)location = 0;
      _os_log_error_impl(&dword_1876B1000, v54, OS_LOG_TYPE_ERROR, "ID payload missing required fields", location, 2u);
    }

    return 0;
  }

  if (([0 hasRequiredFields] & 1) == 0) {
    goto LABEL_41;
  }
  uint64_t v53 = [0 identifierType];
  Property = 0LL;
  unint64_t v57 = v53;
LABEL_7:
  [Property identifierData];
  CFStringRef v10 = (void *)objc_claimAutoreleasedReturnValue();
  if (self) {
    CFStringRef v11 = objc_getProperty(self, v9, 24LL, 1);
  }
  else {
    CFStringRef v11 = 0LL;
  }
  uint64_t v12 = v11;
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  if ((isKindOfClass & 1) == 0)
  {
    unint64_t v42 = v10;
LABEL_31:
    uint64_t v49 = objc_msgSend(v42, "length", v55) + 4;
    uint64_t v50 = (void *)[objc_alloc(MEMORY[0x189603FB8]) initWithCapacity:v49];
    [v50 appendBytes:&v57 length:4];
    [v50 appendData:v42];
    if (!self)
    {

      size_t v4 = 0LL;
      return v4 != 0LL;
    }

    objc_setProperty_atomic(self, v51, v50, 16LL);

LABEL_3:
    size_t v4 = objc_getProperty(self, v3, 16LL, 1);
    return v4 != 0LL;
  }

  if (self)
  {
    unint64_t v15 = objc_getProperty(self, v14, 24LL, 1);
    int v16 = objc_loadWeakRetained((id *)&self->_ikeSA);
    unint64_t v24 = v16;
    if (v15)
    {
      if (v16)
      {
        BOOL v25 = (id *)v15;
        *(void *)location = 0LL;
        [v25 identifierData];
        int v26 = (void *)objc_claimAutoreleasedReturnValue();
        id v27 = [v26 length];

        if (v27)
        {
          uint64_t v35 = -[NEIKEv2IKESA createConcatenatedSPIsAndReturnError:](v24, location);
          if (v35)
          {
            BOOL v55 = (uint64_t)v15;
            uint64_t v56 = v10;
            int v36 = -[NEIKEv2IKESA createConcatedNoncesAndReturnError:](v24, location);
            if (v36)
            {
              uint64_t v37 = v25[2];
              uint64_t v38 = objc_alloc(&OBJC_CLASS____TtC16NetworkExtension20NEIKEv2CryptoKitHPKE);
              [v25 identifierData];
              int v39 = (void *)objc_claimAutoreleasedReturnValue();
              unint64_t v40 = v25[4];
              if (v37)
              {
                unint64_t v41 = -[NEIKEv2CryptoKitHPKE initWithPayload:aad:psk:pskID:keyRef:]( v38,  "initWithPayload:aad:psk:pskID:keyRef:",  v39,  v40,  v36,  v35,  v25[2]);
              }

              else
              {
                uint64_t v44 = v25[3];
                unint64_t v41 = -[NEIKEv2CryptoKitHPKE initWithPayload:aad:psk:pskID:keyData:]( v38,  "initWithPayload:aad:psk:pskID:keyData:",  v39,  v40,  v36,  v35,  v44);
              }

              obj = *(id *)location;
              -[NEIKEv2CryptoKitHPKE performHPKESealAndReturnError:](v41, "performHPKESealAndReturnError:", &obj);
              unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
              objc_storeStrong((id *)location, obj);
            }

            else
            {
              unint64_t v42 = 0LL;
            }

            unint64_t v15 = (id)v55;
            CFStringRef v10 = v56;
          }

          else
          {
            unint64_t v42 = 0LL;
          }

          ErrorInternal = *(void **)location;
        }

        else
        {
          ErrorInternal = (void *)NEIKEv2CreateErrorInternal( @"Missing identifier data",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v55);
          unint64_t v42 = 0LL;
          *(void *)location = ErrorInternal;
        }

        uint64_t v45 = ErrorInternal;
        if (v45)
        {

          unint64_t v42 = 0LL;
          int v46 = *(void **)location;
        }

        else
        {
          int v46 = 0LL;
        }
      }

      else
      {
        uint64_t v45 = (id)NEIKEv2CreateErrorInternal(@"Missing IKE SA", v17, v18, v19, v20, v21, v22, v23, v55);
        unint64_t v42 = 0LL;
      }

      int64_t v47 = v45;

      goto LABEL_29;
    }

    int64_t v47 = 0LL;
  }

  else
  {
    int64_t v47 = 0LL;
    unint64_t v15 = 0LL;
    unint64_t v24 = 0LL;
  }

  unint64_t v42 = 0LL;
LABEL_29:

  int v48 = v47;
  if (v42)
  {

    goto LABEL_31;
  }

  ne_log_obj();
  uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)location = 138412290;
    *(void *)&location[4] = v48;
    _os_log_error_impl( &dword_1876B1000,  v52,  OS_LOG_TYPE_ERROR,  "Failed to generate encrypted identifier payload: %@",  location,  0xCu);
  }

  return 0;
}

      goto LABEL_42;
    }

    int v16 = objc_getProperty(WeakRetained, v13, 128LL, 1);
    if (v16) {
      int v16 = objc_getProperty(v16, v17, 64LL, 1);
    }
    unint64_t v15 = (os_log_s *)v16;
    ne_log_obj();
    int v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      int v58 = WeakRetained;
      _os_log_impl(&dword_1876B1000, v18, OS_LOG_TYPE_DEFAULT, "%@: Stopping tunnel due to Server Redirect", buf, 0xCu);
    }

    -[NEIKEv2PacketTunnelProvider stopIKEv2TunnelWithReason:completionHandler:](WeakRetained, 0LL, 0LL);
    int v20 = objc_getProperty(WeakRetained, v19, 128LL, 1);
    if (v20) {
      int v20 = objc_getProperty(v20, v21, 16LL, 1);
    }
    id v22 = v20;
    unint64_t v24 = objc_getProperty(WeakRetained, v23, 128LL, 1);
    if (v24) {
      objc_setProperty_atomic(v24, v25, v22, 32LL);
    }

    id v27 = objc_getProperty(WeakRetained, v26, 128LL, 1);
    if (v27) {
      id v27 = objc_getProperty(v27, v28, 56LL, 1);
    }
    uint64_t v29 = v27;

    if (v29)
    {
      unint64_t v31 = objc_getProperty(WeakRetained, v30, 128LL, 1);
      if (v31) {
        objc_setProperty_atomic(v31, v32, v15, 32LL);
      }
    }

    -[os_log_s hostname](v10, "hostname");
    int v33 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v35 = objc_getProperty(WeakRetained, v34, 128LL, 1);
    if (v35) {
      objc_setProperty_atomic(v35, v36, v33, 16LL);
    }

    uint64_t v38 = objc_getProperty(WeakRetained, v37, 128LL, 1);
    if (v38) {
      uint64_t v38 = objc_getProperty(v38, v39, 16LL, 1);
    }
    unint64_t v40 = v38;

    if (!v40)
    {
      ne_log_obj();
      uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        int v58 = WeakRetained;
        _os_log_error_impl( &dword_1876B1000,  v53,  OS_LOG_TYPE_ERROR,  "%@: Missing redirect information in notification",  buf,  0xCu);
      }

      goto LABEL_41;
    }

    unint64_t v41 = objc_alloc(&OBJC_CLASS___NEIKEv2MOBIKE);
    char v43 = objc_getProperty(WeakRetained, v42, 264LL, 1);
    uint64_t v44 = -[NEIKEv2MOBIKE initWithQueue:tunnelProvider:]((id *)&v41->super.isa, v43, WeakRetained);
    objc_setProperty_atomic(WeakRetained, v45, v44, 168LL);

    int64_t v47 = objc_getProperty(WeakRetained, v46, 128LL, 1);
    if (v47) {
      objc_setProperty_atomic(v47, v48, 0LL, 24LL);
    }
    *(void *)int v54 = MEMORY[0x1895F87A8];
    *(void *)&v54[8] = 3221225472LL;
    *(void *)&v54[16] = __58__NEIKEv2PacketTunnelProvider_handleRedirectNotification___block_invoke;
    BOOL v55 = &unk_18A08D468;
    uint64_t v56 = WeakRetained;
    -[NEIKEv2PacketTunnelProvider resolveServerAddressIfNeeded:](WeakRetained, v54);
    uint64_t v49 = *((_DWORD *)WeakRetained + 21);
    if ((~v49 & 0xF) == 0)
    {
      [WeakRetained setReasserting:1];
      uint64_t v49 = *((_DWORD *)WeakRetained + 21);
    }

    *((_DWORD *)WeakRetained + 21) = v49 & 0xFFFFFFF0;
    uint64_t v50 = (void *)*((void *)WeakRetained + 11);
    *((void *)WeakRetained + 11) = 0LL;

    int v51 = (void *)*((void *)WeakRetained + 12);
    *((void *)WeakRetained + 12) = 0LL;

    uint64_t v52 = (void *)*((void *)WeakRetained + 13);
    *((void *)WeakRetained + 13) = 0LL;
  }

  -[NEKeychainItem setData:](self, "setData:", 0LL);
  if (self) {
    objc_setProperty_atomic_copy(self, v43, 0LL, 72LL);
  }
}

    size_t v4 = v48;
  }

  else
  {
    ne_log_obj();
    id v27 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v27, OS_LOG_TYPE_ERROR))
    {
      -[NEProfileIngestion ingestedConfiguration](v2, "ingestedConfiguration");
      uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
      [v28 identifier];
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      uint64_t v61 = v29;
      _os_log_error_impl( &dword_1876B1000,  (os_log_t)v27,  OS_LOG_TYPE_ERROR,  "The ingested configuration (%@) has no name, cannot update from the set aside version of the configuration",  buf,  0xCu);
    }
  }

  return v4 != 0LL;
}

  if (-[NEVPNIKEv2SecurityAssociationParameters encryptionAlgorithm](self, "encryptionAlgorithm") == NEVPNIKEv2EncryptionAlgorithmDES
    || -[NEVPNIKEv2SecurityAssociationParameters encryptionAlgorithm](self, "encryptionAlgorithm") == NEVPNIKEv2EncryptionAlgorithm3DES)
  {
    uint64_t v28 = (void *)NSString;
    uint64_t v29 = -[NEVPNIKEv2SecurityAssociationParameters encryptionAlgorithm](self, "encryptionAlgorithm");
    if ((unint64_t)(v29 - 1) >= 7) {
      StringFromIKEv2IntegrityAlgorithm = (__CFString *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"Unknown(%ld)",  v29);
    }
    else {
      StringFromIKEv2IntegrityAlgorithm = off_18A090728[v29 - 1];
    }
    [v28 stringWithFormat:@"Unsupported encryption algorithm (%@)", StringFromIKEv2IntegrityAlgorithm];
  }

  else
  {
    if (-[NEVPNIKEv2SecurityAssociationParameters diffieHellmanGroup](self, "diffieHellmanGroup") <= (NEVPNIKEv2DiffieHellmanGroup5|0x8LL))
    {
      objc_msgSend( NSString,  "stringWithFormat:",  @"Unsupported DH group (%ld), minimum allowed is %ld",  -[NEVPNIKEv2SecurityAssociationParameters diffieHellmanGroup](self, "diffieHellmanGroup"),  14,  v34);
      goto LABEL_4;
    }

    if (-[NEVPNIKEv2SecurityAssociationParameters integrityAlgorithm](self, "integrityAlgorithm") != NEVPNIKEv2IntegrityAlgorithmSHA96
      && -[NEVPNIKEv2SecurityAssociationParameters integrityAlgorithm](self, "integrityAlgorithm") != NEVPNIKEv2IntegrityAlgorithmSHA160)
    {
      CFIndex v6 = 1;
      goto LABEL_7;
    }

    unint64_t v32 = (void *)NSString;
    StringFromIKEv2IntegrityAlgorithm = createStringFromIKEv2IntegrityAlgorithm( -[NEVPNIKEv2SecurityAssociationParameters integrityAlgorithm]( self,  "integrityAlgorithm"));
    [v32 stringWithFormat:@"Unsupported integrity algorithm (%@), minimum allowed is SHA-2", StringFromIKEv2IntegrityAlgorithm];
  }

  int v30 = (void *)objc_claimAutoreleasedReturnValue();
  +[NEConfiguration addError:toList:]((uint64_t)&OBJC_CLASS___NEConfiguration, v30, v4);

LABEL_5:
LABEL_6:
  CFIndex v6 = 0;
LABEL_7:

  return v6;
}

LABEL_44:
  ne_log_obj();
  id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1876B1000, v22, OS_LOG_TYPE_DEFAULT, "DNS proxy is enabled", buf, 2u);
  }

  if ((a3 & 0x200000000000000LL) == 0)
  {
LABEL_27:
    if ((a3 & 0x1000000000000000LL) == 0) {
      goto LABEL_28;
    }
    goto LABEL_50;
  }

    -[NEIKEv2IKESA authenticationProtocol](v3, v25);
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    int v30 = &off_18A087000;
    if ([v29 method] == 1 || (objc_msgSend(v29, "isSignature") & 1) == 0)
    {
      uint64_t v34 = v29;
      goto LABEL_50;
    }

    if ([v29 isDigitalSignature])
    {
      unint64_t v31 = +[NEIKEv2Crypto copySignHashProtocolForAuth:]((uint64_t)&OBJC_CLASS___NEIKEv2Crypto, v29);
      unint64_t v32 = v3[14];
      int v33 = [v32 containsObject:v31];

      if (v33)
      {
        uint64_t v34 = v29;
      }

      else
      {
        ne_log_obj();
        uint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
        {
          v93 = v3[14];
          *(_DWORD *)buf = 138412546;
          v113 = (const char *)v31;
          v114 = 2112;
          v115 = v93;
          _os_log_error_impl( &dword_1876B1000,  v56,  OS_LOG_TYPE_ERROR,  "Digital signature hash protocol %@ is not supported by peer, supports %@",  buf,  0x16u);
        }

        uint64_t v34 = 0LL;
      }

LABEL_50:
      if (!v34)
      {
        ne_log_obj();
        v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl( &dword_1876B1000,  v94,  OS_LOG_TYPE_FAULT,  "Failed to select auth protocol for signature generation",  buf,  2u);
        }

        CFRelease(v24);
        uint64_t v9 = 0LL;
        goto LABEL_66;
      }

      uint64_t v35 = v7;
      uint64_t v9 = v34;
      objc_opt_self();
      if ([v35 length])
      {
        int v36 = +[NEIKEv2Crypto signatureAlgorithmTypeForAuthentication:]((uint64_t)v30[323], v9);
        if (v36)
        {
          uint64_t v37 = (const __CFString *)v36;
          uint64_t v38 = (const __CFData *)v35;
          objc_opt_self();
          error[0] = 0LL;
          Signature = SecKeyCreateSignature((SecKeyRef)v24, v37, v38, error);

          if (Signature && !error[0])
          {
            unint64_t v40 = Signature;

            if (-[os_log_s isDigitalSignature](v9, "isDigitalSignature"))
            {
              LOBYTE(error[0]) = 0;
              unint64_t v41 = v9;
              objc_opt_self();
              switch(-[os_log_s digitalSignatureAlgorithm](v41, "digitalSignatureAlgorithm"))
              {
                case 1LL:
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  char v43 = &NEIKEv2ASN1AlgorithmIdRSAPKCS256;
                  goto LABEL_101;
                case 2LL:
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  char v43 = &NEIKEv2ASN1AlgorithmIdECDSA256;
                  goto LABEL_104;
                case 3LL:
                  int v70 = -[os_log_s isNonStandard](v41, "isNonStandard");
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  if (v70)
                  {
                    char v43 = &NEIKEv2ASN1AlgorithmIdED25519NonStandard;
                    unint64_t v71 = 4LL;
                  }

                  else
                  {
                    char v43 = &NEIKEv2ASN1AlgorithmIdED25519;
LABEL_138:
                    unint64_t v71 = 7LL;
                  }

                  goto LABEL_139;
                case 4LL:
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  char v43 = &NEIKEv2ASN1AlgorithmIdED448;
                  goto LABEL_138;
                case 5LL:
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  char v43 = &NEIKEv2ASN1AlgorithmIdRSAPKCS384;
                  goto LABEL_101;
                case 6LL:
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  char v43 = &NEIKEv2ASN1AlgorithmIdRSAPKCS512;
LABEL_101:
                  unint64_t v71 = 15LL;
                  goto LABEL_139;
                case 7LL:
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  char v43 = &NEIKEv2ASN1AlgorithmIdECDSA384;
                  goto LABEL_104;
                case 8LL:
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  char v43 = &NEIKEv2ASN1AlgorithmIdECDSA512;
LABEL_104:
                  unint64_t v71 = 12LL;
                  goto LABEL_139;
                case 9LL:
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  char v43 = &NEIKEv2ASN1AlgorithmIdRSAPSS256;
                  goto LABEL_108;
                case 10LL:
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  char v43 = &NEIKEv2ASN1AlgorithmIdRSAPSS384;
                  goto LABEL_108;
                case 11LL:
                  unint64_t v42 = objc_alloc(MEMORY[0x189603F48]);
                  char v43 = &NEIKEv2ASN1AlgorithmIdRSAPSS512;
LABEL_108:
                  unint64_t v71 = 67LL;
LABEL_139:
                  uint64_t v69 = (void *)[v42 initWithBytesNoCopy:v43 length:v71 freeWhenDone:0];

                  if (!v69) {
                    goto LABEL_94;
                  }
                  int v86 = [v69 length];
                  __int16 v87 = (const char *)v86;
                  if (v86 >= 0x100)
                  {
                    ne_log_obj();
                    v96 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 134217984;
                      v113 = v87;
                      _os_log_fault_impl( &dword_1876B1000,  v96,  OS_LOG_TYPE_FAULT,  "Encoded signature algorithm data length %zu is too long",  buf,  0xCu);
                    }

LABEL_94:
                    uint64_t v12 = 0LL;
                  }

                  else
                  {
                    LOBYTE(error[0]) = v86;
                    int v88 = v86 + -[__CFData length](v40, "length") + 1;
                    uint64_t v12 = (os_log_s *)[objc_alloc(MEMORY[0x189603FB8]) initWithCapacity:v88];
                    -[os_log_s appendBytes:length:](v12, "appendBytes:length:", error, 1LL);
                    -[os_log_s appendData:](v12, "appendData:", v69);
                    -[os_log_s appendData:](v12, "appendData:", v40);
                  }

                  break;
                default:
                  ne_log_obj();
                  uint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v68, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)buf = 138412290;
                    v113 = (const char *)v41;
                    _os_log_fault_impl( &dword_1876B1000,  v68,  OS_LOG_TYPE_FAULT,  "Cannot create algorithm identifier for authentication protocol %@",  buf,  0xCu);
                  }

                  uint64_t v69 = 0LL;
                  goto LABEL_94;
              }
            }

            else
            {
              unint64_t v40 = v40;
              uint64_t v12 = v40;
            }
}

          goto LABEL_18;
        }

        int v13 = v6;
        unint64_t v14 = v7;
        int v16 = v10;
        if (v2 && objc_getProperty(v2, v15, 64LL, 1))
        {
          objc_msgSend(objc_getProperty(v2, v17, 64, 1), "arrayByAddingObject:", v16);
          unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
        }

        else
        {
          uint64_t v37 = v16;
          objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v37, 1, (void)v31);
          unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
          if (!v2) {
            goto LABEL_34;
          }
        }

        objc_setProperty_atomic(v2, v18, v19, 64LL);
LABEL_34:

        if (v16 && v2 && v16[3] == 16390LL) {
          objc_setProperty_atomic(v2, v26, v16, 88LL);
        }

        uint64_t v7 = v14;
        CFIndex v6 = v13;
LABEL_18:
        ++v9;
      }

      while (v5 != v9);
      int v30 = -[NEIKEv2IKESAInitPacket countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v31,  v38,  16LL);
      int v5 = v30;
    }

    while (v30);
  }
}

LABEL_50:
  ne_log_obj();
  unint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1876B1000, v24, OS_LOG_TYPE_DEFAULT, "Content Filter is enabled", buf, 2u);
  }

  if ((a3 & 0x400000000000000LL) == 0)
  {
LABEL_29:
    if ((a3 & 0x100000000000000LL) == 0) {
      goto LABEL_30;
    }
    goto LABEL_56;
  }

    if (++v19 < v17) {
      continue;
    }
    unint64_t v42 = [v14 countByEnumeratingWithState:&v62 objects:v67 count:16];
    if (!v42) {
      break;
    }
    unsigned __int16 v17 = v42;
    unint64_t v19 = 0LL;
  }

  CFIndex v6 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
LABEL_59:

  *(_DWORD *)buf = 0;
  if (self && (int v46 = objc_getProperty(self, v45, v6[718], 1)) != 0LL) {
    int64_t v47 = v46[1];
  }
  else {
    LOBYTE(v47) = 0;
  }
  buf[0] = v47;
  int v48 = (void *)[objc_alloc(MEMORY[0x189603FB8]) initWithCapacity:v18 + 4];
  [v48 appendBytes:buf length:4];
  uint64_t v59 = 0u;
  uint64_t v60 = 0u;
  unint64_t v57 = 0u;
  int v58 = 0u;
  uint64_t v49 = v10;
  uint64_t v50 = [v49 countByEnumeratingWithState:&v57 objects:v66 count:16];
  if (v50)
  {
    int v51 = v50;
    uint64_t v52 = *(void *)v58;
    do
    {
      for (j = 0LL; j != v51; ++j)
      {
        if (*(void *)v58 != v52) {
          objc_enumerationMutation(v49);
        }
        [v48 appendData:*(void *)(*((void *)&v57 + 1) + 8 * j)];
      }

      int v51 = [v49 countByEnumeratingWithState:&v57 objects:v66 count:16];
    }

    while (v51);
  }

  if (self)
  {
    objc_setProperty_atomic(self, v54, v48, 16LL);

    goto LABEL_71;
  }

  Property = 0LL;
  return Property != 0LL;
}

LABEL_53:
  ne_log_obj();
  BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1876B1000, v25, OS_LOG_TYPE_DEFAULT, "Path Controller is enabled", buf, 2u);
  }

  if ((a3 & 0x100000000000000LL) == 0)
  {
LABEL_30:
    if ((a3 & 0x20000000000000LL) == 0) {
      return;
    }
LABEL_59:
    ne_log_obj();
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    *(_WORD *)buf = 0;
    CFStringRef v10 = "Relay configuration is enabled";
    CFStringRef v11 = (os_log_s *)v9;
    uint64_t v12 = 2;
    goto LABEL_8;
  }

  id v1 = 0LL;
LABEL_54:

  return v1;
}

  if (!a4
    || ([v8 kemProtocols],
        uint64_t v44 = objc_claimAutoreleasedReturnValue(),
        [(id)a1 kemProtocols],
        uint64_t v45 = objc_claimAutoreleasedReturnValue(),
        !(v45 | v44)))
  {
    a1 = 1LL;
    goto LABEL_51;
  }

  int v46 = (void *)v45;
  int64_t v47 = -[NEIKEv2KEMProtocol initWithMethod:](objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol), "initWithMethod:", 0LL);
  v129 = v47;
  [MEMORY[0x189603F18] arrayWithObjects:&v129 count:1];
  v96 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v44 || !v46)
  {
    if (v44) {
      int v46 = v96;
    }
    else {
      uint64_t v44 = (uint64_t)v96;
    }
    int v48 = v96;
  }

  [v46 firstObject];
  uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v50 = [(id)v44 indexOfObject:v49];

  int v51 = v99;
  if (v50 == 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v99)
    {
      v114 = 0uLL;
      v115 = 0uLL;
      v112 = 0uLL;
      v113 = 0uLL;
      uint64_t v52 = v46;
      uint64_t v53 = [v52 countByEnumeratingWithState:&v112 objects:v128 count:16];
      if (v53)
      {
        int v54 = v53;
        BOOL v55 = *(void *)v113;
        while (2)
        {
          for (i = 0LL; i != v54; ++i)
          {
            if (*(void *)v113 != v55) {
              objc_enumerationMutation(v52);
            }
            unint64_t v57 = [(id)v44 indexOfObject:*(void *)(*((void *)&v112 + 1) + 8 * i)];
            if (v57 != 0x7FFFFFFFFFFFFFFFLL)
            {
              [(id)v44 objectAtIndexedSubscript:v57];
              uint64_t v64 = (id)objc_claimAutoreleasedReturnValue();
              goto LABEL_86;
            }
          }

          int v54 = [v52 countByEnumeratingWithState:&v112 objects:v128 count:16];
          if (v54) {
            continue;
          }
          break;
        }

    nw_connection_cancel(v3);
    goto LABEL_54;
  }

  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)&buf[4] = v3;
    _os_log_impl(&dword_1876B1000, v9, OS_LOG_TYPE_DEFAULT, "Received incoming IKE connection %@", buf, 0xCu);
  }

  unint64_t v15 = v3;
  int v16 = v15;
  unsigned __int16 v17 = v15;
  if ((*((_BYTE *)v5 + 8) & 1) != 0)
  {
LABEL_49:

    ne_log_obj();
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_53;
    }
    *(_DWORD *)buf = 138412290;
    *(void *)&buf[4] = v16;
    uint64_t v12 = "IKE listener failed to handle new connection, cancelling %@";
    goto LABEL_51;
  }

  if (!v15)
  {
    ne_log_obj();
    uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = "-[NEIKEv2Listener handleNewConnection:]";
      _os_log_fault_impl(&dword_1876B1000, v53, OS_LOG_TYPE_FAULT, "%s called with null connection", buf, 0xCu);
    }

    unsigned __int16 v17 = 0LL;
    goto LABEL_48;
  }

  int v18 = nw_connection_copy_endpoint(v15);
  unint64_t v19 = v18;
  if (!v18)
  {
    ne_log_obj();
    int v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = "-[NEIKEv2Listener handleNewConnection:]";
      BOOL v55 = "%s called with null remoteEndpoint";
      uint64_t v56 = v54;
      unint64_t v57 = 12;
LABEL_36:
      _os_log_fault_impl(&dword_1876B1000, v56, OS_LOG_TYPE_FAULT, v55, buf, v57);
    }

      v22 += v27 + 4;
    }

    while (v22 < v50);
  }

  return -[NEIKEv2ConfigPayload hasRequiredFields](v15, "hasRequiredFields", v48);
}

    unint64_t v19 = 0;
    goto LABEL_54;
  }

  unint64_t v19 = 1;
LABEL_54:
  int v20 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, @"EncryptionKey");
  uint64_t v21 = v20;
  if (v20) {
    Length = CFDataGetLength(v20);
  }
  else {
    Length = 0LL;
  }
  uint64_t v23 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, @"AuthKey");
  unint64_t v24 = v23;
  if (v23) {
    BOOL v25 = CFDataGetLength(v23);
  }
  else {
    BOOL v25 = 0LL;
  }
  if (Length | v25)
  {
    int v26 = (char *)malloc(v25 + Length);
    if (Length)
    {
      BytePtr = CFDataGetBytePtr(v21);
      memcpy(v26, BytePtr, Length);
    }

    if (v25)
    {
      uint64_t v28 = CFDataGetBytePtr(v24);
      memcpy(&v26[Length], v28, v25);
    }
  }

  else
  {
    int v26 = 0LL;
  }

  uint64_t v29 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTraversal");
  int v5 = MEMORY[0x1895F87A8];
  if (v29 && CFBooleanGetValue(v29)) {
    v11 |= 2u;
  }
  int v30 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAlive");
  if (v30 && CFBooleanGetValue(v30)) {
    v11 |= 4u;
  }
  unint64_t v31 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAliveOffload");
  if (v31 && CFBooleanGetValue(v31)) {
    v11 |= 0x8000u;
  }
  unint64_t v32 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAliveOffloadInterval");
  if (v32) {
    CFNumberGetValue(v32, kCFNumberShortType, &v69);
  }
  int v33 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAliveInterval");
  if (v33) {
    CFNumberGetValue(v33, kCFNumberShortType, (char *)&v69 + 2);
  }
  uint64_t v34 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTDetectedPeer");
  if (v34 && CFBooleanGetValue(v34)) {
    v11 |= 0x1000u;
  }
  uint64_t v35 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"LifeTimeinSeconds");
  if (v35) {
    CFNumberGetValue(v35, kCFNumberLongType, &v72);
  }
  int v36 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTPort");
  if (v36) {
    CFNumberGetValue(v36, kCFNumberShortType, (char *)&v71 + 2);
  }
  uint64_t v37 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTSourcePort");
  if (v37) {
    CFNumberGetValue(v37, kCFNumberShortType, &v71);
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"OutgoingInterface"))
  {
    uint64_t v38 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"OutgoingInterface");
    CFStringGetCString(v38, buffer, 16LL, 0x600u);
  }

  int v39 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"sequencePerTrafficClass");
  if (v39) {
    unint64_t v40 = 2 * (CFBooleanGetValue(v39) != 0);
  }
  else {
    unint64_t v40 = 0;
  }
  unint64_t v41 = _NEIPSecDBGetQueue();
  block[0] = v5;
  block[1] = 0x40000000LL;
  block[2] = __NEIPSecDBAddSA_block_invoke;
  block[3] = &unk_18A08DCD0;
  block[6] = a1;
  block[7] = cf;
  block[4] = &v65;
  block[5] = &v61;
  dispatch_sync(v41, block);
  unint64_t v42 = *(dispatch_source_s **)(a1 + 64);
  char v43 = _NEIPSecDBGetQueue();
  uint64_t v44 = v80;
  if (!v80[0]) {
    uint64_t v44 = 0LL;
  }
  uint64_t v45 = buffer;
  if (!buffer[0]) {
    uint64_t v45 = 0LL;
  }
  *(void *)&uint64_t v59 = v44;
  *((void *)&v59 + 1) = v45;
  if (NEPFKeySendAdd( v42,  (uint64_t)v43,  v75,  v74,  v78,  v77,  v76,  valuePtr,  v73,  (const UInt8 *)v26,  v12,  Length,  v19,  v25,  v11,  v40,  0,  v58,  0,  0,  v72,  SHIDWORD(v72),  0,  0,  0,  v71,  HIWORD(v71),  HIWORD(v69),  v69,  1,  v59))
  {
    int v46 = NEIPSecDBCopyResponseForQueuedRequest(v62[3], 0LL);
    int64_t v47 = (os_log_s *)ne_log_obj();
    int v48 = v47;
    if (!v46)
    {
      CFIndex v6 = (void *)&unk_187871000;
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        *(void *)&buf[4] = a1;
        _os_log_error_impl( &dword_1876B1000,  v48,  OS_LOG_TYPE_ERROR,  "%@ add SA, failed to receive response for pfkey add SA",  buf,  0xCu);
      }

      uint64_t v56 = *((_DWORD *)v66 + 6);
      unint64_t v57 = _NEIPSecDBGetQueue();
      *(void *)buf = v5;
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = __NEIPSecDBRemoveSAIDFromSAs_block_invoke;
      uint64_t v82 = &__block_descriptor_tmp_160;
      v83 = a1;
      uint64_t v84 = v56;
      dispatch_sync(v57, buf);
      *((_DWORD *)v66 + 6) = 0;
      if (!v26) {
        goto LABEL_107;
      }
      goto LABEL_106;
    }

    CFIndex v6 = (void *)&unk_187871000;
    if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
    {
      uint64_t v49 = *((_DWORD *)v66 + 6);
      *(_DWORD *)buf = 138412802;
      *(void *)&buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v49;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = bswap32(v76);
      _os_log_impl(&dword_1876B1000, v48, OS_LOG_TYPE_INFO, "%@ added SAID %u SPI %08X", buf, 0x18u);
      if (!v26) {
        goto LABEL_107;
      }
      goto LABEL_106;
    }
  }

  else
  {
    uint64_t v50 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&buf[4] = a1;
      _os_log_error_impl(&dword_1876B1000, v50, OS_LOG_TYPE_ERROR, "%@ add SA, pfkey add SA failed", buf, 0xCu);
    }

    int v51 = *((_DWORD *)v66 + 6);
    uint64_t v52 = _NEIPSecDBGetQueue();
    *(void *)buf = v5;
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = __NEIPSecDBRemoveSAIDFromSAs_block_invoke;
    uint64_t v82 = &__block_descriptor_tmp_160;
    v83 = a1;
    uint64_t v84 = v51;
    dispatch_sync(v52, buf);
    *((_DWORD *)v66 + 6) = 0;
    CFIndex v6 = &unk_187871000;
  }

  if (v26)
  {
LABEL_106:
    memset_s(v26, v25 + Length, 0, v25 + Length);
    free(v26);
  }

                if (cf) {
                  CFRelease(cf);
                }

                [v50 setUserPreferences:v19];
              }

              [v49 addObject:v58];
              +[NEVPNManager loadedManagers]();
              unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
              [v61 identifier];
              unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
              [v40 setObject:v58 forKeyedSubscript:v41];

              if (v58) {
                v58->_hasLoaded = 1;
              }
              dispatch_group_enter(group);
              -[NEVPNManager connection](v58, "connection");
              unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
              [v61 identifier];
              char v43 = (void *)objc_claimAutoreleasedReturnValue();
              v66[0] = MEMORY[0x1895F87A8];
              v66[1] = 3221225472LL;
              v66[2] = __60__NEVPNManager_loadAllFromPreferencesWithCompletionHandler___block_invoke_62;
              v66[3] = &unk_18A090480;
              v66[4] = v61;
              uint64_t v68 = &v73;
              uint64_t v67 = group;
              if (v42) {
                -[NEVPNConnection createSessionWithConfigurationIdentifier:forceInfoFetch:completionHandler:]( v42,  v43,  0LL,  v66);
              }
            }
          }
        }

        int v54 = [obj countByEnumeratingWithState:&v69 objects:v80 count:16];
      }

      while (v54);
    }

    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __60__NEVPNManager_loadAllFromPreferencesWithCompletionHandler___block_invoke_63;
    block[3] = &unk_18A0904A8;
    uint64_t v65 = &v73;
    uint64_t v63 = v49;
    uint64_t v64 = *(id *)(v45 + 32);
    dispatch_group_notify(group, MEMORY[0x1895F8AE0], block);
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  _Block_object_dispose(&v73, 8);

  objc_sync_exit(v46);
}

void __getWriterSemaphore_block_invoke()
{
  dispatch_semaphore_t v0 = dispatch_semaphore_create(1LL);
  id v1 = (void *)getWriterSemaphore_semaphore;
  getWriterSemaphore_semaphore = (uint64_t)v0;
}

LABEL_36:
    ne_log_obj();
    int v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v55 = *(void *)(a1 + 32);
      [*(id *)(a1 + 40) name];
      uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412546;
      v110 = v55;
      v111 = 2112;
      v112 = v56;
      _os_log_impl(&dword_1876B1000, v54, OS_LOG_TYPE_DEFAULT, "%@ Configuration %@ is unchanged", buf, 0x16u);
    }

    unint64_t v57 = *(void *)(a1 + 32);
    v100[0] = MEMORY[0x1895F87A8];
    v100[1] = 3221225472LL;
    v100[2] = __72__NEConfigurationManager_saveConfiguration_withCompletionQueue_handler___block_invoke_167;
    v100[3] = &unk_18A0908C8;
    int v58 = *(void **)(a1 + 48);
    uint64_t v59 = *(id *)(a1 + 56);
    v100[4] = *(void *)(a1 + 32);
    v101 = v59;
    -[NEConfigurationManager executeCallbackOnQueue:callback:](v57, v58, v100);
    uint64_t v60 = v101;
    goto LABEL_55;
  }

  ne_log_obj();
  unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    uint64_t v61 = *(void *)(a1 + 32);
    [*(id *)(a1 + 40) name];
    int v62 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412546;
    v110 = v61;
    v111 = 2112;
    v112 = v62;
    _os_log_error_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_ERROR,  "%@ Failed to save configuration %@ because the local copy is stale",  buf,  0x16u);
  }

  -[NEConfigurationManager errorWithCode:specifics:](*(void *)(a1 + 32), 5LL, 0LL);
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  int v16 = *(void *)(a1 + 32);
  v102[0] = MEMORY[0x1895F87A8];
  v102[1] = 3221225472LL;
  v102[2] = __72__NEConfigurationManager_saveConfiguration_withCompletionQueue_handler___block_invoke_166;
  v102[3] = &unk_18A0908C8;
  unsigned __int16 v17 = *(void **)(a1 + 48);
  int v18 = *(id *)(a1 + 56);
  v103 = v15;
  v104 = v18;
  uint64_t v9 = v15;
  -[NEConfigurationManager executeCallbackOnQueue:callback:](v16, v17, v102);

  CFStringRef v10 = v104;
LABEL_56:
}

    uint64_t v49 = objc_getProperty(v15, v46, 32LL, 1);
    objc_setProperty_atomic(v5, v50, v49, 496LL);
  }

  int v36 = 1LL;
LABEL_38:

LABEL_39:
  return v36;
}

      LOBYTE(v35) = 0;
LABEL_37:
      int v16 = v128;
      v27 |= v35;
      if (++v28 < v25) {
        continue;
      }
      int v36 = [v128 countByEnumeratingWithState:&v152 objects:v168 count:16];
      if (!v36) {
        break;
      }
      BOOL v25 = v36;
      uint64_t v28 = 0LL;
    }

    uint64_t v37 = selfa;
    if ((v27 & 1) != 0) {
      goto LABEL_61;
    }
LABEL_45:
    [v37 integrityProtocols];
    int v39 = (void *)objc_claimAutoreleasedReturnValue();
    if (v37) {
      unint64_t v40 = objc_getProperty(v37, v38, 104LL, 1);
    }
    else {
      unint64_t v40 = 0LL;
    }
    unint64_t v41 = v40;

    if (v41)
    {
      if (v37) {
        char v43 = objc_getProperty(v37, v42, 104LL, 1);
      }
      else {
        char v43 = 0LL;
      }
      uint64_t v44 = v43;
      v167 = v44;
      uint64_t v45 = [MEMORY[0x189603F18] arrayWithObjects:&v167 count:1];

      int v39 = (void *)v45;
    }

    if (![v39 count])
    {
      ne_log_obj();
      v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl( &dword_1876B1000,  v113,  OS_LOG_TYPE_ERROR,  "Child SA proposal missing integrity protocol",  buf,  2u);
      }

LABEL_135:
      return 0;
    }

    v149 = 0u;
    v150 = 0u;
    v147 = 0u;
    v148 = 0u;
    int v46 = v39;
    int64_t v47 = [v46 countByEnumeratingWithState:&v147 objects:v166 count:16];
    if (v47)
    {
      int v48 = v47;
      uint64_t v49 = 0LL;
      uint64_t v50 = *(void *)v148;
      for (j = *(void *)v148; ; j = *(void *)v148)
      {
        if (j != v50) {
          objc_enumerationMutation(v46);
        }
        uint64_t v52 = *(void **)(*((void *)&v147 + 1) + 8 * v49);
        *(void *)buf = 0LL;
        uint64_t v53 = [v52 type];
        buf[0] = 3;
        buf[4] = 3;
        *(_WORD *)&buf[6] = bswap32(v53) >> 16;
        *(_WORD *)&buf[2] = 2048;
        -[os_log_s appendBytes:length:](v23, "appendBytes:length:", buf, 8LL);
        LOBYTE(v26) = v26 + 1;
        if (++v49 >= v48)
        {
          int v54 = [v46 countByEnumeratingWithState:&v147 objects:v166 count:16];
          if (!v54) {
            break;
          }
          int v48 = v54;
          uint64_t v49 = 0LL;
        }
      }
    }

LABEL_61:
    [v37 additionalKEMProtocols];
    BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v37);
    uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();

    if (v56)
    {
      -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v37);
      unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
      if ([v57 count])
      {
        v123 = v55;
        int v58 = objc_alloc(MEMORY[0x189603FC8]);
        -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v37);
        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v60 = (void *)objc_msgSend(v58, "initWithCapacity:", objc_msgSend(v59, "count"));

        v145 = 0u;
        v146 = 0u;
        v143 = 0u;
        v144 = 0u;
        v126 = v57;
        uint64_t v61 = v57;
        int v62 = [v61 countByEnumeratingWithState:&v143 objects:v165 count:16];
        if (v62)
        {
          uint64_t v63 = v62;
          uint64_t v64 = *(void *)v144;
          do
          {
            for (k = 0LL; k != v63; ++k)
            {
              if (*(void *)v144 != v64) {
                objc_enumerationMutation(v61);
              }
              int v66 = *(void *)(*((void *)&v143 + 1) + 8 * k);
              [v61 objectForKeyedSubscript:v66];
              uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
              v164 = v67;
              [MEMORY[0x189603F18] arrayWithObjects:&v164 count:1];
              uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue();
              [v60 setObject:v68 forKeyedSubscript:v66];
            }

            uint64_t v63 = [v61 countByEnumeratingWithState:&v143 objects:v165 count:16];
          }

          while (v63);
        }

        uint64_t v7 = v115;
        BOOL v55 = v123;
        unint64_t v57 = v126;
      }

      else
      {
        uint64_t v60 = (void *)MEMORY[0x189604A60];
      }

      BOOL v55 = v60;
      uint64_t v37 = selfa;
    }

    if (![v55 count]) {
      goto LABEL_94;
    }
    [v55 allKeys];
    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();
    [v69 sortedArrayUsingSelector:sel_compare_];
    int v70 = (void *)objc_claimAutoreleasedReturnValue();

    v141 = 0u;
    v142 = 0u;
    v139 = 0u;
    v140 = 0u;
    v127 = v70;
    unint64_t v71 = [v127 countByEnumeratingWithState:&v139 objects:v163 count:16];
    if (!v71) {
      goto LABEL_93;
    }
    uint64_t v72 = v71;
    uint64_t v73 = 0LL;
    SEL v74 = *(void *)v140;
    v124 = v55;
    v125 = *(void *)v140;
    while (2)
    {
      if (v74 != v125) {
        objc_enumerationMutation(v127);
      }
      id v75 = *(void **)(*((void *)&v139 + 1) + 8 * v73);
      uint64_t v76 = [v75 unsignedCharValue];
      v135 = 0u;
      v136 = 0u;
      v137 = 0u;
      v138 = 0u;
      [v55 objectForKeyedSubscript:v75];
      unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v78 = [v77 countByEnumeratingWithState:&v135 objects:v162 count:16];
      if (v78)
      {
        uint64_t v79 = v78;
        uint64_t v80 = 0LL;
        int v81 = *(void *)v136;
        for (m = *(void *)v136; ; m = *(void *)v136)
        {
          if (m != v81) {
            objc_enumerationMutation(v77);
          }
          v83 = *(void **)(*((void *)&v135 + 1) + 8 * v80);
          *(void *)buf = 0LL;
          uint64_t v84 = [v83 method];
          buf[0] = 3;
          buf[4] = v76;
          *(_WORD *)&buf[6] = bswap32(v84) >> 16;
          *(_WORD *)&buf[2] = 2048;
          -[os_log_s appendBytes:length:](v23, "appendBytes:length:", buf, 8LL);
          LOBYTE(v26) = v26 + 1;
          if (++v80 >= v79)
          {
            __int16 v85 = [v77 countByEnumeratingWithState:&v135 objects:v162 count:16];
            if (!v85)
            {
              BOOL v55 = v124;
              break;
            }

            uint64_t v79 = v85;
            uint64_t v80 = 0LL;
          }
        }
      }

      if (++v73 < v72)
      {
LABEL_91:
        SEL v74 = *(void *)v140;
        continue;
      }

      break;
    }

    int v86 = [v127 countByEnumeratingWithState:&v139 objects:v163 count:16];
    if (v86)
    {
      uint64_t v72 = v86;
      uint64_t v73 = 0LL;
      goto LABEL_91;
    }

    uint64_t v7 = v115;
    uint64_t v37 = selfa;
LABEL_93:

LABEL_94:
    [v37 kemProtocols];
    int v88 = (void *)objc_claimAutoreleasedReturnValue();
    if (v37) {
      uint64_t v89 = objc_getProperty(v37, v87, 112LL, 1);
    }
    else {
      uint64_t v89 = 0LL;
    }
    CFErrorRef v90 = v89;

    if (v90)
    {
      if (v37) {
        v92 = objc_getProperty(v37, v91, 112LL, 1);
      }
      else {
        v92 = 0LL;
      }
      v93 = v92;
      v161 = v93;
      v94 = [MEMORY[0x189603F18] arrayWithObjects:&v161 count:1];

      int v88 = (void *)v94;
    }

    v133 = 0u;
    v134 = 0u;
    v131 = 0u;
    v132 = 0u;
    v95 = v88;
    v96 = [v95 countByEnumeratingWithState:&v131 objects:v160 count:16];
    if (v96)
    {
      v97 = v96;
      v98 = 0LL;
      v99 = *(void *)v132;
      for (n = *(void *)v132; ; n = *(void *)v132)
      {
        if (n != v99) {
          objc_enumerationMutation(v95);
        }
        v101 = *(void **)(*((void *)&v131 + 1) + 8 * v98);
        *(void *)buf = 0LL;
        v102 = [v101 method];
        buf[0] = 3;
        buf[4] = 4;
        *(_WORD *)&buf[6] = bswap32(v102) >> 16;
        *(_WORD *)&buf[2] = 2048;
        -[os_log_s appendBytes:length:](v23, "appendBytes:length:", buf, 8LL);
        LOBYTE(v26) = v26 + 1;
        if (++v98 >= v97)
        {
          v103 = [v95 countByEnumeratingWithState:&v131 objects:v160 count:16];
          if (!v103) {
            break;
          }
          v97 = v103;
          v98 = 0LL;
        }
      }
    }

    *(void *)buf = 0x508000000LL;
    -[os_log_s appendBytes:length:](v23, "appendBytes:length:", buf, 8LL);
    v130 = (2 * (v116 > v121));
    v105 = selfa;
    if (selfa)
    {
      BYTE4(v130) = selfa[8];
      BYTE5(v130) = 3;
      v105 = objc_getProperty(selfa, v104, 80LL, 1);
    }

    else
    {
      WORD2(v130) = 768;
    }

    v106 = v105;

    if (v106)
    {
      v108 = selfa;
      if (selfa) {
        v108 = objc_getProperty(selfa, v107, 80LL, 1);
      }
      v109 = v108;
      v110 = [v109 value];

      v129 = v110;
      BYTE6(v130) = 4;
      -[os_log_s replaceBytesInRange:withBytes:length:]( v23,  "replaceBytesInRange:withBytes:length:",  0LL,  0LL,  &v129,  4LL);
    }

    else
    {
      BYTE6(v130) = 0;
    }

    HIBYTE(v130) = v26 + 1;
    WORD1(v130) = bswap32(-[os_log_s length](v23, "length") + 8) >> 16;
    [v7 appendBytes:&v130 length:8];
    [v7 appendData:v23];

    uint64_t v12 = v120 + 1;
    if (v120 + 1 < v119)
    {
LABEL_118:
      ++v121;
      int v13 = *(void *)v157;
      continue;
    }

    break;
  }

  v119 = [obj countByEnumeratingWithState:&v156 objects:v170 count:16];
  if (v119)
  {
    uint64_t v12 = 0LL;
    goto LABEL_118;
  }

  int v36 = 0LL;
LABEL_46:

LABEL_47:
  return v36;
}

        goto LABEL_37;
      }

      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        id v22 = 67109120;
        *(_DWORD *)uint64_t v23 = v6;
        int v18 = "[NWInterface initWithInterfaceIndex:%u] failed";
        unint64_t v19 = v9;
        int v20 = 8;
        goto LABEL_34;
      }
    }

    else
    {
      unint64_t v15 = [objc_alloc(MEMORY[0x189608E00]) initWithInterfaceIndex:Index interfaceName:v4];
      ne_log_obj();
      int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v9 = v16;
      if (v15)
      {
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          id v22 = 138412802;
          *(void *)uint64_t v23 = a1;
          *(_WORD *)&v23[8] = 1024;
          *(_DWORD *)&v23[10] = v6;
          *(_WORD *)&v23[14] = 2112;
          *(void *)&v23[16] = v4;
          CFStringRef v10 = "Created interface for %@ from index %u and name %@";
          CFStringRef v11 = v9;
          uint64_t v12 = 28;
          goto LABEL_17;
        }

        goto LABEL_36;
      }

      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
      {
        id v22 = 67109378;
        *(_DWORD *)uint64_t v23 = v6;
        *(_WORD *)&v23[4] = 2112;
        *(void *)&v23[6] = v4;
        int v18 = "[NWInterface initWithInterfaceIndex:%u interfaceName:%@] failed";
        unint64_t v19 = v9;
        int v20 = 18;
LABEL_34:
        _os_log_fault_impl(&dword_1876B1000, v19, OS_LOG_TYPE_FAULT, v18, (uint8_t *)&v22, v20);
      }
    }

  return v18;
}

    _os_log_error_impl(&dword_1876B1000, v11, OS_LOG_TYPE_ERROR, v12, __path, 2u);
    goto LABEL_37;
  }

  CFStringRef v10 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__path = 0;
    _os_log_error_impl(&dword_1876B1000, v10, OS_LOG_TYPE_ERROR, "Failed to load SymptomReporter framework", __path, 2u);
  }

  uint64_t v28 = theDict;
  CFDictionarySetValue(theDict, @"subnet-addresses", Mutable);
  CFDictionarySetValue(theDict, @"subnet-masks", v9);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v9) {
    CFRelease(v9);
  }
  return v28;
}

void sub_1876E9C0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
}

LABEL_42:
  if (v11) {
    CFRelease(v11);
  }

  return 1LL;
}

  return a1;
}
}

  v160 = v15;
  if (v30)
  {
    v156 = objc_getProperty((id)v30, v43, 16LL, 1);
    if (v156)
    {
      v155 = v13;
      uint64_t v52 = objc_getProperty((id)v30, v51, 16LL, 1);
      objc_msgSend(objc_getProperty((id)v30, v53, 32, 1), "interfaceName");
      int v54 = (void *)objc_claimAutoreleasedReturnValue();
      BOOL v55 = v52;
      int v46 = v54;
      objc_opt_self();
      ne_log_obj();
      uint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v57 = v56;
      if (v55)
      {
        if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412546;
          *(void *)&buf[4] = v55;
          v192 = 2112;
          v193 = v46;
          _os_log_impl(&dword_1876B1000, v57, OS_LOG_TYPE_INFO, "check address: address %@ interface %@", buf, 0x16u);
        }

        int v58 = [v55 address];
        if (v58)
        {
          uint64_t v59 = v58;
          *(void *)buf = 0LL;
          if (getifaddrs((ifaddrs **)buf))
          {
            int v13 = v155;
          }

          else
          {
            uint64_t v60 = *(void **)buf;
            if (*(void *)buf)
            {
              while (1)
              {
                if (!v46
                  || (uint64_t v61 = (const char *)v60[1]) != 0LL
                  && !strncmp(v61, (const char *)[v46 UTF8String], 0x10uLL))
                {
                  if (v60[3] || (int v62 = MEMORY[1], [v55 addressFamily] == v62))
                  {
                    if ([v55 addressFamily] == 2)
                    {
                      if (*(_DWORD *)(v60[3] + 4LL) == *(_DWORD *)(v59 + 4)) {
                        goto LABEL_96;
                      }
                    }

                    else if ([v55 addressFamily] == 30)
                    {
                      uint64_t v63 = v60[3];
                      uint64_t v65 = *(void *)(v63 + 8);
                      uint64_t v64 = *(void *)(v63 + 16);
                      if (v65 == *(void *)(v59 + 8) && v64 == *(void *)(v59 + 16))
                      {
LABEL_96:
                        free(*(void **)buf);

                        int v13 = v155;
                        unint64_t v15 = v160;
                        int v18 = 0LL;
                        goto LABEL_97;
                      }
                    }
                  }
                }

                uint64_t v60 = (void *)*v60;
                if (!v60)
                {
                  uint64_t v67 = *(void **)buf;
                  int v13 = v155;
                  unint64_t v15 = v160;
                  goto LABEL_74;
                }
              }
            }

            uint64_t v67 = 0LL;
            int v13 = v155;
LABEL_74:
            int v18 = 0LL;
            free(v67);
          }

          int64_t v47 = v156;
          goto LABEL_76;
        }

        ne_log_obj();
        unint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = "+[NEIKEv2Transport checkAddress:interface:]";
          _os_log_fault_impl(&dword_1876B1000, v57, OS_LOG_TYPE_FAULT, "%s called with null sa_compare", buf, 0xCu);
        }
      }

      else if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = "+[NEIKEv2Transport checkAddress:interface:]";
        _os_log_fault_impl(&dword_1876B1000, v57, OS_LOG_TYPE_FAULT, "%s called with null endpoint", buf, 0xCu);
      }

      int64_t v47 = v156;

      int v13 = v155;
LABEL_76:

      uint64_t v21 = v167;
      goto LABEL_77;
    }
  }

  unsigned __int16 v17 = CFDictionaryGetValue((CFDictionaryRef)cf, @"AuthAlgorithm");
  if (!v17) {
    goto LABEL_53;
  }
  int v18 = v17;
  if (!CFEqual(v17, @"MD5-96"))
  {
    if (CFEqual(v18, @"SHA1-96"))
    {
      unint64_t v19 = 2;
      goto LABEL_54;
    }

    if (CFEqual(v18, @"SHA2-256"))
    {
      unint64_t v19 = 6;
      goto LABEL_54;
    }

    if (CFEqual(v18, @"SHA2-384"))
    {
      unint64_t v19 = 7;
      goto LABEL_54;
    }

    if (CFEqual(v18, @"SHA2-512"))
    {
      unint64_t v19 = 8;
      goto LABEL_54;
    }

    -[os_log_s setLocalTrafficSelectors:](v2, "setLocalTrafficSelectors:", v15);

    CFIndex v6 = v123;
  }

  uint64_t v34 = (const __CFArray *)NEGetValueWithType(v5, @"TrafficSelectorsRemote", CFARRAY_TYPE);
  if (!v34) {
    goto LABEL_60;
  }
  uint64_t v35 = v34;
  int v36 = CFArrayGetCount(v34);
  if (!v36)
  {
    ne_log_obj();
    unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_198;
    }
    *(_DWORD *)buf = 136315394;
    v147 = "NEIPSecIKEValidateIKEChildDictionary";
    v148 = 1024;
    v149 = 2216;
    v100 = "%s:%d: IKE Child remote traffic selector array is empty";
    goto LABEL_147;
  }

  uint64_t v37 = v36;
  v124 = v6;
  unint64_t v15 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
  if (v37 >= 1)
  {
    uint64_t v38 = 0LL;
    theDict = v35;
    v129 = v37;
    while (1)
    {
      int v39 = (void *)CFArrayGetValueAtIndex(v35, v38);
      if (!v39 || (unint64_t v40 = v39, v41 = p_info[28], (__objc2_class_ro *)CFGetTypeID(v39) != v41))
      {
        ne_log_obj();
        id v22 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v147 = "NEIPSecIKEValidateIKEChildDictionary";
          v148 = 1024;
          v149 = 2224;
          _os_log_error_impl( &dword_1876B1000,  v22,  OS_LOG_TYPE_ERROR,  "%s:%d: IKE Child remote traffic selector array is invalid",  buf,  0x12u);
        }

        CFIndex v6 = v124;
        goto LABEL_197;
      }

      unint64_t v42 = p_info;
      id v22 = v40;
      uint64_t v23 = objc_alloc_init(&OBJC_CLASS___NEIKEv2TrafficSelector);
      if (!NEGetValueWithType(v22, @"TSType", CFSTRING_TYPE))
      {
        ne_log_obj();
        v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        CFIndex v6 = v124;
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v147 = "NEIPSecIKEValidateIKEChildDictionary";
          v148 = 1024;
          v149 = 2231;
          v150 = 2112;
          v151 = @"TSType";
          v152 = 2048;
          v153 = CFSTRING_TYPE;
          _os_log_error_impl( &dword_1876B1000,  v103,  OS_LOG_TYPE_ERROR,  "%s:%d: value for key %@ is missing or type != %lu",  buf,  0x26u);
        }

        goto LABEL_196;
      }

      if (!NEGetValueWithType(v22, @"TSStartAddress", CFSTRING_TYPE))
      {
        ne_log_obj();
        v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v147 = "NEIPSecIKEValidateIKEChildDictionary";
          v148 = 1024;
          v149 = 2232;
          v150 = 2112;
          v151 = @"TSStartAddress";
          v152 = 2048;
          v153 = CFSTRING_TYPE;
          v106 = "%s:%d: value for key %@ is missing or type != %lu";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      char v43 = v15;
      -[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"TSStartAddress");
      uint64_t v44 = (__CFString *)objc_claimAutoreleasedReturnValue();
      uint64_t v45 = NECreateAddressStructFromString(v44, 0LL, 0LL);

      [MEMORY[0x189608DE8] endpointWithAddress:v45];
      int v46 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEIKEv2TrafficSelector setStartAddress:](v23, "setStartAddress:", v46);

      free(v45);
      if (!NEGetValueWithType(v22, @"TSEndAddress", CFSTRING_TYPE))
      {
        ne_log_obj();
        v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v15 = v43;
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v147 = "NEIPSecIKEValidateIKEChildDictionary";
          v148 = 1024;
          v149 = 2238;
          v150 = 2112;
          v151 = @"TSEndAddress";
          v152 = 2048;
          v153 = CFSTRING_TYPE;
          v106 = "%s:%d: value for key %@ is missing or type != %lu";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      -[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"TSEndAddress");
      int64_t v47 = (__CFString *)objc_claimAutoreleasedReturnValue();
      int v48 = NECreateAddressStructFromString(v47, 0LL, 0LL);

      [MEMORY[0x189608DE8] endpointWithAddress:v48];
      uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEIKEv2TrafficSelector setEndAddress:](v23, "setEndAddress:", v49);

      free(v48);
      if (!NEGetValueWithType(v22, @"TSStartPort", CFNUMBER_TYPE))
      {
        ne_log_obj();
        v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v15 = v43;
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v147 = "NEIPSecIKEValidateIKEChildDictionary";
          v148 = 1024;
          v149 = 2244;
          v150 = 2112;
          v151 = @"TSStartPort";
          v152 = 2048;
          v153 = CFNUMBER_TYPE;
          v106 = "%s:%d: value for key %@ is missing or type != %lu";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      -[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"TSStartPort");
      uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEIKEv2TrafficSelector setStartPort:](v23, "setStartPort:", [v50 unsignedShortValue]);

      unint64_t v15 = v43;
      if (!NEGetValueWithType(v22, @"TSEndPort", CFNUMBER_TYPE)) {
        break;
      }
      -[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"TSEndPort");
      int v51 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEIKEv2TrafficSelector setEndPort:](v23, "setEndPort:", [v51 unsignedShortValue]);

      if (CFDictionaryContainsKey(v22, @"TSProtocol")
        && !NEGetValueWithType(v22, @"TSProtocol", CFNUMBER_TYPE))
      {
        ne_log_obj();
        v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v147 = "NEIPSecIKEValidateIKEChildDictionary";
          v148 = 1024;
          v149 = 2250;
          v150 = 2112;
          v151 = @"TSProtocol";
          v152 = 2048;
          v153 = CFNUMBER_TYPE;
          v106 = "%s:%d: type of value for key %@ != %lu";
LABEL_194:
          _os_log_error_impl(&dword_1876B1000, v103, OS_LOG_TYPE_ERROR, v106, buf, 0x26u);
        }

        goto LABEL_195;
      }

      if (CFDictionaryContainsKey(v5, @"TSProtocol"))
      {
        -[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"TSProtocol");
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEIKEv2TrafficSelector setIpProtocol:](v23, "setIpProtocol:", [v52 unsignedCharValue]);
      }

      -[os_log_s addObject:](v43, "addObject:", v23);

      ++v38;
      p_info = v42;
      uint64_t v35 = theDict;
      if (v129 == v38) {
        goto LABEL_59;
      }
    }

    ne_log_obj();
    v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v147 = "NEIPSecIKEValidateIKEChildDictionary";
      v148 = 1024;
      v149 = 2247;
      v150 = 2112;
      v151 = @"TSEndPort";
      v152 = 2048;
      v153 = CFNUMBER_TYPE;
      v106 = "%s:%d: value for key %@ is missing or type != %lu";
      goto LABEL_194;
    }

    goto LABEL_43;
  }

    if (a6) {
      int v36 = 4;
    }
    else {
      int v36 = 0;
    }
    uint64_t v37 = NEVirtualInterfaceConnectSocketInner( (uint64_t)"com.apple.net.utun_control",  (uint64_t)v20,  (_BYTE *)v18 + 265,  (unsigned int *)v18 + 73,  v36);
    *((_DWORD *)v18 + 74) = v37;
    *((_BYTE *)v18 + 72) = a6;
    if (v20)
    {
      uint64_t v38 = v20;
LABEL_59:
      xpc_release(v38);
      uint64_t v37 = *((_DWORD *)v18 + 74);
      goto LABEL_60;
    }

    goto LABEL_60;
  }

  if (a8 | a7 | a9 | a10 | a11) {
    unint64_t v24 = 0;
  }
  else {
    unint64_t v24 = a5 == 0;
  }
  if (v24)
  {
    BOOL v25 = 0LL;
  }

  else
  {
    BOOL v25 = xpc_array_create(0LL, 0LL);
    if (a5)
    {
      *(_DWORD *)int v48 = 1;
      int v26 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v26, "interface-option", 0xCuLL);
      xpc_dictionary_set_data(v26, "interface-option-data", v48, 4uLL);
      xpc_array_append_value(v25, v26);
      xpc_release(v26);
    }

    if (a7)
    {
      if (uu && !uuid_is_null(uu))
      {
        id v27 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_uuid(v27, "interface-bind-channel-exec-uuid", uu);
      }

      else
      {
        id v27 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_BOOL(v27, "interface-bind-channel-pid", 1);
      }

      xpc_dictionary_set_uint64(v27, "interface-type", *((void *)v18 + 32));
      xpc_array_append_value(v25, v27);
      xpc_release(v27);
      *(_DWORD *)int v48 = a7;
      int v39 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v39, "interface-option", 8uLL);
      xpc_dictionary_set_data(v39, "interface-option-data", v48, 4uLL);
      xpc_array_append_value(v25, v39);
      xpc_release(v39);
    }

    if (bytes)
    {
      unint64_t v40 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v40, "interface-option", 0xDuLL);
      xpc_dictionary_set_data(v40, "interface-option-data", &bytes, 4uLL);
      xpc_array_append_value(v25, v40);
      xpc_release(v40);
    }

    if (v51)
    {
      unint64_t v41 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v41, "interface-option", 0xEuLL);
      xpc_dictionary_set_data(v41, "interface-option-data", &v51, 4uLL);
      xpc_array_append_value(v25, v41);
      xpc_release(v41);
    }

    if (v50)
    {
      unint64_t v42 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v42, "interface-option", 0x12uLL);
      xpc_dictionary_set_data(v42, "interface-option-data", &v50, 4uLL);
      xpc_array_append_value(v25, v42);
      xpc_release(v42);
    }

    if (v49)
    {
      char v43 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v43, "interface-option", 0x13uLL);
      xpc_dictionary_set_data(v43, "interface-option-data", &v49, 4uLL);
      xpc_array_append_value(v25, v43);
      xpc_release(v43);
    }
  }

  uint64_t v37 = NEVirtualInterfaceConnectSocketInner( (uint64_t)"com.apple.net.ipsec_control",  (uint64_t)v25,  (_BYTE *)v18 + 265,  (unsigned int *)v18 + 73,  0);
  *((_DWORD *)v18 + 74) = v37;
  if (v25)
  {
    uint64_t v38 = v25;
    goto LABEL_59;
  }

void sub_1876EBE58(_Unwind_Exception *a1)
{
}

void sub_1876EC054(_Unwind_Exception *a1)
{
}

void sub_1876EC304(_Unwind_Exception *a1)
{
}

void sub_1876EC38C(_Unwind_Exception *a1)
{
}

void sub_1876EC41C(_Unwind_Exception *a1)
{
}

void sub_1876EC498(_Unwind_Exception *a1)
{
}

void sub_1876EC51C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_1876EC58C(_Unwind_Exception *a1)
{
}

void sub_1876EC604(_Unwind_Exception *a1)
{
}

id NEDNSProxyMapError(void *a1)
{
  v15[1] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  unint64_t v2 = v1;
  if (v1)
  {
    [v1 domain];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    int v4 = [v3 isEqual:@"NEConfigurationErrorDomain"];

    if (v4)
    {
      switch([v2 code])
      {
        case 1LL:
        case 2LL:
        case 3LL:
        case 4LL:
        case 6LL:
        case 7LL:
        case 8LL:
        case 10LL:
        case 11LL:
        case 12LL:
        case 20LL:
        case 21LL:
          [v2 localizedDescription];
          int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          goto LABEL_7;
        case 5LL:
          [v2 localizedDescription];
          int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v7 = 3LL;
          goto LABEL_8;
        case 9LL:
          ne_log_obj();
          int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( &dword_1876B1000,  v5,  OS_LOG_TYPE_DEFAULT,  "The configuration was not saved because it was unchanged from the previously saved version",  buf,  2u);
          }

          CFIndex v6 = 0LL;
          break;
        default:
          CFStringRef v11 = (void *)NSString;
          [v2 localizedDescription];
          uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
          [v11 stringWithFormat:@"Unknown: %@", v12];
          int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();

          goto LABEL_7;
      }
    }

    else
    {
      int v5 = (os_log_s *)@"Unknown.";
LABEL_7:
      uint64_t v7 = 1LL;
LABEL_8:
      id v8 = (void *)MEMORY[0x189607870];
      uint64_t v14 = *MEMORY[0x1896075E0];
      v15[0] = v5;
      [MEMORY[0x189603F68] dictionaryWithObjects:v15 forKeys:&v14 count:1];
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
      [v8 errorWithDomain:@"NEDNSProxyErrorDomain" code:v7 userInfo:v9];
      CFIndex v6 = (void *)objc_claimAutoreleasedReturnValue();
    }
  }

  else
  {
    CFIndex v6 = 0LL;
  }

  return v6;
}

void sub_1876ED264(_Unwind_Exception *a1)
{
}

void sub_1876ED9EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, id location)
{
}

void sub_1876EDE50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1876EDF18(_Unwind_Exception *a1)
{
}

void sub_1876F0570( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_1876F39F8(_Unwind_Exception *a1)
{
}

void sub_1876F3F94(_Unwind_Exception *a1)
{
}

void sub_1876F5C28( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_1876F685C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1876F6D44( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_1876F7740(_Unwind_Exception *a1)
{
}

void sub_1876F7B24( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1876F7D60(_Unwind_Exception *a1)
{
}

void sub_1876F7DBC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_1876F9890(_Unwind_Exception *a1)
{
}

void sub_1876F99F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1876F9C74( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_1876F9E40(_Unwind_Exception *a1)
{
}

void sub_1876F9FEC(_Unwind_Exception *a1)
{
}

void sub_1876FA140(_Unwind_Exception *a1)
{
}

void sub_1876FA35C(_Unwind_Exception *a1)
{
}

void sub_1876FA594(_Unwind_Exception *a1)
{
}

void sub_1876FBF94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location, uint64_t a16, uint64_t a17, id a18)
{
}

void sub_1876FCD64( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

LABEL_178:
        goto LABEL_179;
      }

      ne_log_obj();
      v125 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v125, OS_LOG_TYPE_ERROR)) {
        goto LABEL_140;
      }
      LOWORD(applier[0]) = 0;
      v126 = "Reply dictionary is NULL when handling a protocol data message";
LABEL_139:
      _os_log_error_impl(&dword_1876B1000, v125, OS_LOG_TYPE_ERROR, v126, (uint8_t *)applier, 2u);
LABEL_140:

LABEL_248:
      return;
    case 9LL:
    case 10LL:
      if (v9) {
        goto LABEL_23;
      }
      ne_log_obj();
      v125 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v125, OS_LOG_TYPE_ERROR)) {
        goto LABEL_140;
      }
      LOWORD(applier[0]) = 0;
      v126 = "Reply dictionary is NULL when handling a protocol data finished message";
      goto LABEL_139;
    case 11LL:
LABEL_23:
      -[NEFilterDataExtensionProviderContext handleChannelMessageFlowFinish:filloutReply:completionHandler:]( (id *)&self->super.super.super.super.isa,  v8,  v9,  v10);
      goto LABEL_248;
    case 12LL:
      CFStringRef v11 = v10;
      if (!self) {
        goto LABEL_247;
      }
      xpc_dictionary_get_array(v8, "stats-report-statistics");
      v121 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v12 = v121;
      if (v121 && xpc_array_get_count(v121))
      {
        ne_log_obj();
        v122 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v122, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(applier[0]) = 134217984;
          *(size_t *)((char *)applier + 4) = xpc_array_get_count(v12);
          _os_log_debug_impl( &dword_1876B1000,  v122,  OS_LOG_TYPE_DEBUG,  "Channel Stats Report - stats count %zu",  (uint8_t *)applier,  0xCu);
        }

        applier[0] = MEMORY[0x1895F87A8];
        applier[1] = 3221225472LL;
        applier[2] = (size_t)__103__NEFilterDataExtensionProviderContext_handleChannelMessageStatsReport_filloutReply_completionHandler___block_invoke;
        applier[3] = (size_t)&unk_18A08C1D0;
        v123 = v11;
        *(void *)&v229 = self;
        *((void *)&v229 + 1) = v123;
        xpc_array_apply(v12, applier);
        v124 = (os_log_s *)*((void *)&v229 + 1);
      }

      else
      {
        ne_log_obj();
        v124 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
        {
          LOWORD(applier[0]) = 0;
          _os_log_error_impl( &dword_1876B1000,  v124,  OS_LOG_TYPE_ERROR,  "Channel Stats Report - empty stats",  (uint8_t *)applier,  2u);
        }
      }

      goto LABEL_246;
    default:
      goto LABEL_248;
  }

                            v271 = 0LL;
LABEL_179:
                            uint64_t v7 = self;
LABEL_180:

                            if (v271)
                            {
                              if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v271, 0LL) & 1) != 0)
                              {
                                v289 = objc_getProperty(v195, v282, 56LL, 1);
                                v291 = v289;
                                if (v289) {
                                  v289 = objc_getProperty(v289, v290, 112LL, 1);
                                }
                                v292 = v289;

                                if (v292 && (-[NEIKEv2ChildSA processPrimaryKeyExchange]((uint64_t)v195, v293) & 1) == 0)
                                {
                                  v316 = v11;
                                  ne_log_obj();
                                  v347 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                  if (os_log_type_enabled(v347, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_WORD *)v385 = 0;
                                    _os_log_error_impl( &dword_1876B1000,  v347,  OS_LOG_TYPE_ERROR,  "Failed to process KE data",  v385,  2u);
                                  }

                                  v349 = objc_getProperty(v195, v348, 56LL, 1);
                                  v351 = v349;
                                  if (v349) {
                                    v349 = objc_getProperty(v349, v350, 80LL, 1);
                                  }
                                  v352 = v349;
                                  v354 = objc_getProperty(v195, v353, 56LL, 1);
                                  v356 = v354;
                                  if (v354) {
                                    v354 = objc_getProperty(v354, v355, 88LL, 1);
                                  }
                                  v357 = v354;
                                  v370[0] = MEMORY[0x1895F87A8];
                                  v370[1] = 3221225472LL;
                                  v370[2] = __53__NEIKEv2Session_Exchange__receiveNewChildSA_packet___block_invoke;
                                  v370[3] = &unk_18A08CF10;
                                  v371 = v195;
                                  v372 = a1;
                                  -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:]( a1,  v352,  v357,  v370);

                                  v318 = v371;
                                }

                                else if ((-[NEIKEv2ChildSA generateAllValues]((uint64_t)v195) & 1) != 0)
                                {
                                  if ((-[NEIKEv2Session installChildSA:]((uint64_t)a1, v195) & 1) != 0)
                                  {
                                    -[NEIKEv2ChildSA setState:error:]((uint64_t)v195, 2uLL, 0LL);
                                    -[NEIKEv2Session reportState](a1, v294);
LABEL_209:

                                    goto LABEL_92;
                                  }

                                  ne_log_obj();
                                  v319 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                  if (os_log_type_enabled(v319, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_WORD *)v385 = 0;
                                    _os_log_error_impl( &dword_1876B1000,  v319,  OS_LOG_TYPE_ERROR,  "Failed to install Child SA",  v385,  2u);
                                  }

                                  v321 = objc_getProperty(v195, v320, 56LL, 1);
                                  v323 = v321;
                                  if (v321) {
                                    v321 = objc_getProperty(v321, v322, 80LL, 1);
                                  }
                                  v324 = v321;
                                  v326 = objc_getProperty(v195, v325, 56LL, 1);
                                  v328 = v326;
                                  v316 = v11;
                                  if (v326) {
                                    v326 = objc_getProperty(v326, v327, 88LL, 1);
                                  }
                                  v329 = v326;
                                  v364[0] = MEMORY[0x1895F87A8];
                                  v364[1] = 3221225472LL;
                                  v364[2] = __53__NEIKEv2Session_Exchange__receiveNewChildSA_packet___block_invoke_253;
                                  v364[3] = &unk_18A08CF10;
                                  v365 = v195;
                                  v366 = a1;
                                  -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:]( a1,  v324,  v329,  v364);

                                  v318 = v365;
                                }

                                else
                                {
                                  ne_log_obj();
                                  v306 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                  if (os_log_type_enabled(v306, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_WORD *)v385 = 0;
                                    _os_log_error_impl( &dword_1876B1000,  v306,  OS_LOG_TYPE_ERROR,  "Failed to generate Child SA crypto values",  v385,  2u);
                                  }

                                  v308 = objc_getProperty(v195, v307, 56LL, 1);
                                  v310 = v308;
                                  if (v308) {
                                    v308 = objc_getProperty(v308, v309, 80LL, 1);
                                  }
                                  v311 = v308;
                                  v313 = objc_getProperty(v195, v312, 56LL, 1);
                                  v315 = v313;
                                  v316 = v11;
                                  if (v313) {
                                    v313 = objc_getProperty(v313, v314, 88LL, 1);
                                  }
                                  v317 = v313;
                                  v367[0] = MEMORY[0x1895F87A8];
                                  v367[1] = 3221225472LL;
                                  v367[2] = __53__NEIKEv2Session_Exchange__receiveNewChildSA_packet___block_invoke_252;
                                  v367[3] = &unk_18A08CF10;
                                  v368 = v195;
                                  v369 = a1;
                                  -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:]( a1,  v311,  v317,  v367);

                                  v318 = v368;
                                }

                                CFStringRef v11 = v316;
                                uint64_t v7 = self;
                                goto LABEL_209;
                              }

                              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"create child SA reply",  (uint64_t)v282,  v283,  v284,  v285,  v286,  v287,  v288,  v358);
                            }

                            else
                            {
                              ne_log_obj();
                              v295 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              if (os_log_type_enabled(v295, OS_LOG_TYPE_ERROR))
                              {
                                *(_WORD *)v385 = 0;
                                _os_log_error_impl( &dword_1876B1000,  v295,  OS_LOG_TYPE_ERROR,  "Failed to create Create Child SA packet",  v385,  2u);
                              }

                              ErrorFailedToSend = (void *)NEIKEv2CreateErrorInternal( @"Failed to create Create Child SA packet",  v296,  v297,  v298,  v299,  v300,  v301,  v302,  v358);
                            }

                            v304 = ErrorFailedToSend;
                            -[NEIKEv2ChildSA setState:error:]((uint64_t)v195, 3uLL, ErrorFailedToSend);

                            -[NEIKEv2Session reportState](a1, v305);
                            -[NEIKEv2Session resetChild:]((char *)a1, v195);
                            goto LABEL_209;
                          }

                          ne_log_obj();
                          v276 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          if (!os_log_type_enabled(v276, OS_LOG_TYPE_FAULT)) {
                            goto LABEL_178;
                          }
                          *(_DWORD *)v385 = 136315138;
                          v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                          v277 = "%s called with null packet.nonce.isValid";
                        }

                        else
                        {
                          ne_log_obj();
                          v276 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          CFStringRef v11 = v363;
                          if (!os_log_type_enabled(v276, OS_LOG_TYPE_FAULT)) {
                            goto LABEL_178;
                          }
                          *(_DWORD *)v385 = 136315138;
                          v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                          v277 = "%s called with null packet.childSA.isValid";
                        }

      CFRelease(v6);
      goto LABEL_179;
    }

    if (*(void *)(a1 + 416))
    {
      int v13 = CFDictionaryCreateMutable(v5, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      uint64_t v12 = (unint64_t)v13;
      if (!v13) {
        goto LABEL_178;
      }
      uint64_t v14 = *(const void **)(a1 + 416);
      if (v14) {
        CFDictionarySetValue(v13, (const void *)*MEMORY[0x18960C620], v14);
      }
      unint64_t v15 = *(const void **)(a1 + 432);
      if (v15) {
        CFDictionarySetValue((CFMutableDictionaryRef)v12, (const void *)*MEMORY[0x18960C610], v15);
      }
      int v16 = *(const void **)(a1 + 424);
      if (v16) {
        CFDictionarySetValue((CFMutableDictionaryRef)v12, (const void *)*MEMORY[0x18960C618], v16);
      }
      unsigned __int16 v17 = *(const void **)(a1 + 392);
      if (v17) {
        CFDictionarySetValue((CFMutableDictionaryRef)v12, (const void *)*MEMORY[0x18960C638], v17);
      }
      int v18 = *(const void **)(a1 + 400);
      if (v18) {
        CFDictionarySetValue((CFMutableDictionaryRef)v12, (const void *)*MEMORY[0x18960C648], v18);
      }
      if (*(_DWORD *)(a1 + 408))
      {
        unint64_t v19 = CFNumberCreate(v5, kCFNumberIntType, (const void *)(a1 + 408));
        if (v19)
        {
          int v20 = v19;
          CFDictionarySetValue((CFMutableDictionaryRef)v12, (const void *)*MEMORY[0x18960C640], v19);
          CFRelease(v20);
        }
      }

      uint64_t v21 = *(_DWORD *)(a1 + 444);
      if (v21 >= 1) {
        NEAddIntToDictionary((__CFDictionary *)v12, (const void *)*MEMORY[0x18960C628], v21);
      }
      id v22 = *(_DWORD *)(a1 + 440);
      if (v22)
      {
        NEAddIntToDictionary((__CFDictionary *)v12, (const void *)*MEMORY[0x18960C630], v22);
        CFDictionarySetValue((CFMutableDictionaryRef)v12, (const void *)*MEMORY[0x18960C600], v6);
      }

      if ((*(_BYTE *)(a1 + 312) & 1) != 0) {
        goto LABEL_85;
      }
      uint64_t v23 = *(const __CFArray **)(a1 + 416);
      if (v23
        && CFArrayGetCount(v23) >= 1
        && ((unint64_t v24 = *(const __CFArray **)(a1 + 344)) != 0LL && CFArrayGetCount(v24) > 0
         || (BOOL v25 = *(const __CFArray **)(a1 + 360)) != 0LL && CFArrayGetCount(v25) >= 1))
      {
        int v26 = NEVirtualInterfaceCopyRouteCacheFromRoutes(*(const __CFArray **)(a1 + 344), 0);
        id v27 = (uint64_t)NEVirtualInterfaceCopyRouteCacheFromRoutes(*(const __CFArray **)(a1 + 360), 1);
        cf = v26;
        uint64_t v80 = (CFTypeRef)v27;
        if (v26)
        {
          int v26 = (void *)_CFXPCCreateXPCObjectFromCFObject();
          id v27 = (uint64_t)v80;
        }

        if (v27) {
          id v27 = _CFXPCCreateXPCObjectFromCFObject();
        }
        v83 = (xpc_object_t)v27;
        if (v26)
        {
          uint64_t v28 = xpc_dictionary_create(0LL, 0LL, 0LL);
          if (v28)
          {
            uint64_t v82 = v28;
            xpc_dictionary_set_value(v28, "ipv4-subnets", v26);
          }

          else
          {
            uint64_t v82 = 0LL;
          }

          id v27 = (uint64_t)v83;
        }

        else
        {
          uint64_t v82 = 0LL;
        }

        __int16 v85 = NetworkServiceEntity;
        if (v27 && (unint64_t v31 = xpc_dictionary_create(0LL, 0LL, 0LL)) != 0LL)
        {
          int v81 = v31;
          xpc_dictionary_set_value(v31, "ipv6-subnets", v83);
        }

        else
        {
          int v81 = 0LL;
        }

        object = v26;
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 416));
        if (Count < 1)
        {
          unint64_t v41 = 0;
          goto LABEL_72;
        }

        int v33 = Count;
        unint64_t v77 = v11;
        unint64_t v78 = v6;
        uint64_t v34 = 0LL;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 416), v34);
          if (ValueAtIndex)
          {
            int v36 = (unsigned __int8 *)NECreateAddressStructFromString(ValueAtIndex, 0LL, 0LL);
            if (v36)
            {
              uint64_t v37 = v36;
              uint64_t v38 = v36[1];
              if (object && v38 == 2)
              {
                int v39 = ne_session_address_matches_subnets();
                free(v37);
                if ((v39 & 1) == 0) {
                  goto LABEL_70;
                }
              }

              else
              {
                if (!v83 || v38 != 30)
                {
                  free(v36);
LABEL_70:
                  unint64_t v41 = 1;
LABEL_71:
                  CFStringRef v11 = v77;
                  CFIndex v6 = v78;
LABEL_72:
                  NetworkServiceEntity = v85;
                  if (cf) {
                    CFRelease(cf);
                  }
                  if (v80) {
                    CFRelease(v80);
                  }
                  if (object) {
                    xpc_release(object);
                  }
                  if (v83) {
                    xpc_release(v83);
                  }
                  if (v82) {
                    xpc_release(v82);
                  }
                  if (v81) {
                    xpc_release(v81);
                  }
                  if ((v41 & 1) == 0) {
LABEL_85:
                  }
                    CFDictionarySetValue( (CFMutableDictionaryRef)v12,  (const void *)*MEMORY[0x18960C608],  *(const void **)(a1 + 488));
                  break;
                }

                unint64_t v40 = ne_session_address_matches_subnets();
                free(v37);
                if (!v40) {
                  goto LABEL_70;
                }
              }
            }
          }

          if (v33 == ++v34)
          {
            unint64_t v41 = 0;
            goto LABEL_71;
          }
        }
      }

      if (a2
        && !NEVirtualInterfaceIsStateEqualToDynamicStoreState( *(const __SCDynamicStore **)(a1 + 496),  v12,  value))
      {
        *a2 |= 2uLL;
      }

      NEVirtualInterfaceLogStateDictionaryKeys(a1, (uint64_t)"setting DNS to dictionary with keys", (CFDictionaryRef)v12);
      CFDictionarySetValue(Mutable, value, (const void *)v12);
      CFRelease((CFTypeRef)v12);
      int v30 = a3;
    }

    else
    {
      if (a2
        && !NEVirtualInterfaceIsStateEqualToDynamicStoreState( *(const __SCDynamicStore **)(a1 + 496),  0LL,  value))
      {
        *a2 |= 2uLL;
      }

      uint64_t v29 = (os_log_s *)ne_log_obj();
      int v30 = a3;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v88;
        _os_log_impl(&dword_1876B1000, v29, OS_LOG_TYPE_DEFAULT, "%s: removing DNS", buf, 0xCu);
      }

      CFArrayAppendValue(v8, value);
    }

    unint64_t v42 = NEVirtualInterfaceCopyIPStateDictionary(a1, 2, v30);
    if (a2
      && !NEVirtualInterfaceIsStateEqualToDynamicStoreState( *(const __SCDynamicStore **)(a1 + 496),  (unint64_t)v42,  NetworkServiceEntity))
    {
      *a2 |= 1uLL;
      if (v42) {
        goto LABEL_93;
      }
    }

    else if (v42)
    {
LABEL_93:
      NEVirtualInterfaceLogStateDictionaryKeys(a1, (uint64_t)"setting IPv4 to dictionary with keys", v42);
      CFDictionarySetValue(Mutable, NetworkServiceEntity, v42);
      CFRelease(v42);
      goto LABEL_98;
    }

    char v43 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = v88;
      _os_log_impl(&dword_1876B1000, v43, OS_LOG_TYPE_DEFAULT, "%s: removing IPv4", buf, 0xCu);
    }

    CFArrayAppendValue(v8, NetworkServiceEntity);
LABEL_98:
    uint64_t v44 = NEVirtualInterfaceCopyIPStateDictionary(a1, 30, v30);
    if (a2
      && !NEVirtualInterfaceIsStateEqualToDynamicStoreState( *(const __SCDynamicStore **)(a1 + 496),  (unint64_t)v44,  v11))
    {
      *a2 |= 1uLL;
      if (v44) {
        goto LABEL_101;
      }
    }

    else if (v44)
    {
LABEL_101:
      NEVirtualInterfaceLogStateDictionaryKeys(a1, (uint64_t)"setting IPv6 to dictionary with keys", v44);
      uint64_t v45 = v11;
      CFDictionarySetValue(Mutable, v11, v44);
      CFRelease(v44);
      goto LABEL_106;
    }

    int v46 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = v88;
      _os_log_impl(&dword_1876B1000, v46, OS_LOG_TYPE_DEFAULT, "%s: removing IPv6", buf, 0xCu);
    }

    uint64_t v45 = v11;
    CFArrayAppendValue(v8, v11);
LABEL_106:
    int64_t v47 = *(const void **)(a1 + 448);
    TypeID = CFDictionaryGetTypeID();
    int v86 = NetworkServiceEntity;
    if ((!v47 || CFGetTypeID(v47) != TypeID) && (*(_BYTE *)(a1 + 312) & 1) == 0 && !*(void *)(a1 + 392))
    {
      if (a2
        && !NEVirtualInterfaceIsStateEqualToDynamicStoreState( *(const __SCDynamicStore **)(a1 + 496),  0LL,  key))
      {
        *a2 |= 4uLL;
      }

      uint64_t v56 = (os_log_s *)ne_log_obj();
      CFStringRef v11 = v45;
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v88;
        _os_log_impl(&dword_1876B1000, v56, OS_LOG_TYPE_DEFAULT, "%s: removing proxies", buf, 0xCu);
      }

      CFArrayAppendValue(v8, key);
      if (a2) {
        goto LABEL_124;
      }
      goto LABEL_134;
    }

    uint64_t v49 = *(const void **)(a1 + 448);
    uint64_t v50 = CFDictionaryGetTypeID();
    if (v49 && CFGetTypeID(v49) == v50)
    {
      int v51 = *(const void **)(a1 + 448);
      if (v51) {
        Copy = (const __CFDictionary *)CFRetain(v51);
      }
      else {
        Copy = 0LL;
      }
      if (*(void *)(a1 + 392))
      {
        int v62 = (const void *)*MEMORY[0x18960C960];
        if (!CFDictionaryContainsKey(Copy, (const void *)*MEMORY[0x18960C960]))
        {
          MutableCopy = CFDictionaryCreateMutableCopy(v5, 0LL, Copy);
          CFDictionarySetValue(MutableCopy, v62, *(const void **)(a1 + 392));
          uint64_t v64 = *(const void **)(a1 + 400);
          if (v64) {
            CFDictionarySetValue(MutableCopy, (const void *)*MEMORY[0x18960C968], v64);
          }
          if (Copy) {
            CFRelease(Copy);
          }
          Copy = CFDictionaryCreateCopy(v5, MutableCopy);
          CFStringRef v11 = v45;
          if (MutableCopy) {
            CFRelease(MutableCopy);
          }
LABEL_116:
          if (a2)
          {
            if (!NEVirtualInterfaceIsStateEqualToDynamicStoreState( *(const __SCDynamicStore **)(a1 + 496),  (unint64_t)Copy,  key))
            {
              uint64_t v53 = CFDictionaryContainsKey(Copy, (const void *)*MEMORY[0x18960C960]);
              int v54 = *a2;
              if (v53 || (v54 & 1) != 0) {
                *a2 = v54 | 4;
              }
            }
          }

          NEVirtualInterfaceLogStateDictionaryKeys(a1, (uint64_t)"setting proxies to dictionary with keys", Copy);
          CFDictionarySetValue(Mutable, key, Copy);
          if (Copy) {
            CFRelease(Copy);
          }
          if (a2)
          {
LABEL_124:
            BOOL v55 = *a2;
            if ((*a2 & 2) != 0 && (v55 & 1) == 0 && !*(void *)(a1 + 392)) {
              *a2 = v55 & 0xFFFFFFFFFFFFFFFDLL;
            }
          }

LABEL_35:
}

      a1 = 0LL;
LABEL_122:

      goto LABEL_123;
    }

    if (-[NEIKEv2Packet hasErrors]((void *)a1, v4))
    {
      v158 = 0u;
      v159 = 0u;
      v156 = 0u;
      v157 = 0u;
      uint64_t v7 = (os_log_s *)objc_getProperty((id)a1, v6, 64LL, 1);
      id v8 = -[os_log_s countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v156,  v166,  16LL);
      if (v8)
      {
        uint64_t v9 = v8;
        CFStringRef v10 = *(void *)v157;
LABEL_6:
        CFStringRef v11 = 0LL;
        while (1)
        {
          if (*(void *)v157 != v10) {
            objc_enumerationMutation(v7);
          }
          uint64_t v12 = *(__CFString **)(*((void *)&v156 + 1) + 8 * v11);
          if (v12)
          {
          }

          if (v9 == ++v11)
          {
            uint64_t v9 = -[os_log_s countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v156,  v166,  16LL);
            if (v9) {
              goto LABEL_6;
            }
            goto LABEL_13;
          }
        }

        ne_log_obj();
        int v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          uint64_t v73 = (char *)[(id)a1 copyShortDescription];
          SEL v74 = (__CFString *)-[NEIKEv2NotifyPayload copyError](v12);
          *(_DWORD *)buf = 138412546;
          v161 = v73;
          v162 = 2112;
          v163 = (uint64_t)v74;
          _os_log_error_impl( &dword_1876B1000,  v30,  OS_LOG_TYPE_ERROR,  "%@ Rekey child received notify error %@",  buf,  0x16u);
        }

        if (v12->length == 17)
        {
          unint64_t v32 = (char *)objc_getProperty(v12, v31, 32LL, 1);
          int v16 = v32;
          if (v32)
          {
            *(_WORD *)buf = 0;
            [v32 getBytes:buf length:2];
            int v33 = objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol);
            uint64_t v34 = -[NEIKEv2KEMProtocol initWithMethod:](v33, "initWithMethod:", bswap32(*(unsigned __int16 *)buf) >> 16);
            objc_setProperty_atomic(v5, v35, v34, 96LL);
          }

          goto LABEL_34;
        }

        goto LABEL_35;
      }

    uint64_t v45 = 0LL;
    goto LABEL_36;
  }

  -[NEIKEv2IKESA initiatorNonce](a1, v5);
  CFIndex v6 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v6)
  {
    ne_log_obj();
    CFStringRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
    {
      uint64_t v49 = 136315138;
      uint64_t v50 = "-[NEIKEv2IKESA(Crypto) createResponderSignedOctetsUsingPrimeKey:]";
      CFStringRef v11 = "%s called with null self.initiatorNonce";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  if (v2)
  {
    objc_getProperty(a1, v7, 256LL, 1);
    id v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v8)
    {
      ne_log_obj();
      CFStringRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        uint64_t v49 = 136315138;
        uint64_t v50 = "-[NEIKEv2IKESA(Crypto) createResponderSignedOctetsUsingPrimeKey:]";
        CFStringRef v11 = "%s called with null self.skPrPrime";
LABEL_34:
        _os_log_fault_impl(&dword_1876B1000, v10, OS_LOG_TYPE_FAULT, v11, (uint8_t *)&v49, 0xCu);
        goto LABEL_35;
      }

      goto LABEL_35;
    }
  }

  else
  {
    objc_getProperty(a1, v7, 248LL, 1);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v12)
    {
      ne_log_obj();
      CFStringRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        uint64_t v49 = 136315138;
        uint64_t v50 = "-[NEIKEv2IKESA(Crypto) createResponderSignedOctetsUsingPrimeKey:]";
        CFStringRef v11 = "%s called with null self.skPr";
        goto LABEL_34;
      }

      goto LABEL_35;
    }
  }

  if (a1) {
    Property = objc_getProperty(a1, v9, 96LL, 1);
  }
  else {
    Property = 0LL;
  }
  uint64_t v14 = Property;

  if (!v14)
  {
    ne_log_obj();
    CFStringRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
    {
      uint64_t v49 = 136315138;
      uint64_t v50 = "-[NEIKEv2IKESA(Crypto) createResponderSignedOctetsUsingPrimeKey:]";
      CFStringRef v11 = "%s called with null self.chosenProposal";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  CFStringRef v10 = objc_alloc_init(&OBJC_CLASS___NEIKEv2IdentifierPayload);
  unsigned __int16 v17 = -[NEIKEv2IKESA copyResponderIdentifier](a1, v15);
  if (v10) {
    objc_setProperty_atomic(v10, v16, v17, 24LL);
  }

  unint64_t v19 = -[NEIKEv2Payload copyPayloadData](v10);
  if (!v19)
  {
    ne_log_obj();
    id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
    {
      LOWORD(v49) = 0;
      _os_log_fault_impl( &dword_1876B1000,  v27,  OS_LOG_TYPE_FAULT,  "[idPayload copyPayloadData] failed",  (uint8_t *)&v49,  2u);
    }

    uint64_t v45 = 0LL;
    goto LABEL_29;
  }

  if (v2) {
    int v20 = 256LL;
  }
  else {
    int v20 = 248LL;
  }
  objc_getProperty(a1, v18, v20, 1);
  id v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (a1) {
    uint64_t v23 = objc_getProperty(a1, v21, 96LL, 1);
  }
  else {
    uint64_t v23 = 0LL;
  }
  unint64_t v24 = v23;
  -[NEIKEv2IKESAProposal prfProtocol](v24, v25);
  int v26 = (void *)objc_claimAutoreleasedReturnValue();
  id v27 = +[NEIKEv2Crypto createHMACFromData:key:prfProtocol:]((uint64_t)&OBJC_CLASS___NEIKEv2Crypto, v19, v22, v26);

  if (!v27)
  {
    ne_log_obj();
    int v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
    {
      LOWORD(v49) = 0;
      _os_log_fault_impl( &dword_1876B1000,  v30,  OS_LOG_TYPE_FAULT,  "[NEIKEv2Crypto createHMACFromData:key:prfProtocol:] failed",  (uint8_t *)&v49,  2u);
    }

    uint64_t v45 = 0LL;
    goto LABEL_28;
  }

  int v30 = -[NEIKEv2IKESA createIntAuthOctets]((unsigned int *)a1, v28);
  if (!v30)
  {
    ne_log_obj();
    int64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
    {
      uint64_t v45 = 0LL;
      uint64_t v44 = v47;
      goto LABEL_27;
    }

    LOWORD(v49) = 0;
    _os_log_fault_impl( &dword_1876B1000,  v47,  OS_LOG_TYPE_FAULT,  "[NEIKEv2Crypto createIntAuthOctets] failed",  (uint8_t *)&v49,  2u);
    uint64_t v44 = v47;
LABEL_48:
    uint64_t v45 = 0LL;
    goto LABEL_27;
  }

  -[NEIKEv2IKESA responderFirstMessage](a1, v29);
  unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v32 = [v31 length];
  -[NEIKEv2IKESA initiatorNonce](a1, v33);
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v35 = [v34 length] + v32;
  int v36 = -[os_log_s length](v27, "length");
  uint64_t v37 = v35 + -[os_log_s length](v30, "length") + v36;

  uint64_t v38 = +[NSMutableData mutableSensitiveDataWithMaxCapacity:](MEMORY[0x189603FB8], v37);
  if (!v38)
  {
    ne_log_obj();
    int v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
    {
      uint64_t v49 = 134217984;
      uint64_t v50 = (const char *)v37;
      _os_log_fault_impl( &dword_1876B1000,  v48,  OS_LOG_TYPE_FAULT,  "[NESensitiveData mutableSensitiveDataWithMaxCapacity:%zu] failed",  (uint8_t *)&v49,  0xCu);
    }

    uint64_t v44 = 0LL;
    goto LABEL_48;
  }

  unint64_t v40 = v38;
  -[NEIKEv2IKESA responderFirstMessage](a1, v39);
  unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
  -[__CFData appendData:](v40, "appendData:", v41);

  -[NEIKEv2IKESA initiatorNonce](a1, v42);
  char v43 = (void *)objc_claimAutoreleasedReturnValue();
  -[__CFData appendData:](v40, "appendData:", v43);

  -[__CFData appendData:](v40, "appendData:", v27);
  -[__CFData appendData:](v40, "appendData:", v30);
  uint64_t v44 = v40;
  uint64_t v45 = v44;
LABEL_27:

LABEL_28:
LABEL_29:

LABEL_36:
  return v45;
}

  objc_getProperty(v3, v24, 88LL, 1);
  char v43 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v45 = v43;
  if (v43) {
    char v43 = objc_getProperty(v43, v44, 24LL, 1);
  }
  int v46 = v43;

  if (!v46)
  {
    ne_log_obj();
    v140 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v140, OS_LOG_TYPE_ERROR))
    {
      v216 = (char *)[v3 copyShortDescription];
      *(_DWORD *)v239 = 138412290;
      v240 = v216;
      _os_log_error_impl(&dword_1876B1000, v140, OS_LOG_TYPE_ERROR, "%@ Received no SA proposals", v239, 0xCu);
    }

    unint64_t v42 = @"Received no SA proposals";
LABEL_100:
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v42, v35, v36, v37, v38, v39, v40, v41, v226);
    goto LABEL_101;
  }

LABEL_36:
            goto LABEL_37;
          }

          ne_log_obj();
          id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412802;
            CFErrorRef v90 = (const char *)a1;
            unint64_t v91 = 1024;
            v92 = (unsigned __int16)v22;
            v93 = 1024;
            v94 = expectedCount;
            uint64_t v28 = "%@ Fragment count %u < last received count %u";
LABEL_89:
            _os_log_error_impl(&dword_1876B1000, v27, OS_LOG_TYPE_ERROR, v28, buf, 0x18u);
          }
        }

        else
        {
          ne_log_obj();
          id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412802;
            CFErrorRef v90 = (const char *)a1;
            unint64_t v91 = 1024;
            v92 = (unsigned __int16)v21;
            v93 = 1024;
            v94 = (unsigned __int16)v22;
            uint64_t v28 = "%@ Invalid fragment numbers %u/%u";
            goto LABEL_89;
          }
        }

    unint64_t v15 = 0LL;
    goto LABEL_36;
  }

  ne_log_obj();
  uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  int v4 = v14;
  if ((a2 & 1) != 0)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      id v22 = 138412290;
      *(void *)uint64_t v23 = a1;
      _os_log_debug_impl(&dword_1876B1000, v4, OS_LOG_TYPE_DEBUG, "%@ missing ipsecInterface", (uint8_t *)&v22, 0xCu);
    }
  }

  else if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
  {
    id v22 = 138412290;
    *(void *)uint64_t v23 = a1;
    _os_log_fault_impl(&dword_1876B1000, v4, OS_LOG_TYPE_FAULT, "%@ missing ipsecInterface", (uint8_t *)&v22, 0xCu);
  }

  unint64_t v15 = 0LL;
LABEL_37:

  return v15;
}

    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return;
  }

  if ((v8 & 1) == 0)
  {
    uint64_t v23 = *v2;
    if (*v2) {
      *(void *)(v23 + 8) = v2[1];
    }
    *(void *)v2[1] = v23;
  }

  free(v7);
}

                goto LABEL_36;
              }

              uint64_t v60 = os_channel_attr_set();
              if (v60)
              {
                uint64_t v61 = v60;
                ne_log_obj();
                uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_35;
                }
                *(_DWORD *)buf = 138412546;
                v93 = v27;
                v94 = 1024;
                *(_DWORD *)v95 = v61;
                unint64_t v57 = "%@: createChannel failed to set user-packet-pool attribute <err %d> ";
                goto LABEL_63;
              }

              int v62 = os_channel_attr_set();
              ne_log_obj();
              uint64_t v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v53 = v63;
              if (v62)
              {
                if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_35;
                }
                *(_DWORD *)buf = 138412546;
                v93 = v27;
                v94 = 1024;
                *(_DWORD *)v95 = v62;
                unint64_t v57 = "%@: createChannel failed to set filter attribute <err %d>";
                goto LABEL_63;
              }

              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
              {
                Property = objc_getProperty(v27, v64, 176LL, 1);
                *(_DWORD *)buf = 138412546;
                v93 = v27;
                v94 = 2112;
                *(void *)v95 = Property;
                _os_log_debug_impl( &dword_1876B1000,  v53,  OS_LOG_TYPE_DEBUG,  "%@ createChannel: nexusInstance %@",  buf,  0x16u);
              }

              ne_log_obj();
              uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
              {
                int v86 = *((_DWORD *)v27 + 39);
                *(_DWORD *)buf = 138412546;
                v93 = v27;
                v94 = 1024;
                *(_DWORD *)v95 = v86;
                _os_log_debug_impl( &dword_1876B1000,  v65,  OS_LOG_TYPE_DEBUG,  "%@ createChannel: nexusPort %d",  buf,  0x12u);
              }

              v96[0] = 0LL;
              v96[1] = 0LL;
              objc_msgSend(objc_getProperty(v27, v66, 176, 1), "getUUIDBytes:", v96);
              extended = os_channel_create_extended();
              *((void *)v27 + 2) = extended;
              if (!extended)
              {
                ne_log_obj();
                SEL v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 138412290;
                  v93 = v27;
                  _os_log_error_impl( &dword_1876B1000,  v74,  OS_LOG_TYPE_ERROR,  "%@: createChannel failed to create channel",  buf,  0xCu);
                }

                goto LABEL_36;
              }

              fd = os_channel_get_fd();
              *((_DWORD *)v27 + 8) = fd;
              ne_log_obj();
              uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              int v70 = v69;
              if (fd < 0)
              {
                if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 138412290;
                  v93 = v27;
                  unint64_t v77 = "%@: createChannel failed to get channel fd";
                  unint64_t v78 = v70;
                  uint64_t v79 = 12;
                  goto LABEL_91;
                }
              }

              else
              {
                if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 138412290;
                  v93 = v27;
                  _os_log_debug_impl( &dword_1876B1000,  v70,  OS_LOG_TYPE_DEBUG,  "%@: createChannel: created channel",  buf,  0xCu);
                }

                *((void *)v27 + 12) = os_channel_rx_ring();
                *((void *)v27 + 13) = os_channel_tx_ring();
                *((void *)v27 + 14) = os_channel_rx_ring();
                unint64_t v71 = os_channel_tx_ring();
                *((void *)v27 + 15) = v71;
                if (*((void *)v27 + 12) && *((void *)v27 + 13))
                {
                  if (*((void *)v27 + 14) && v71)
                  {
                    os_channel_read_attr();
                    os_channel_attr_get();
                    *((_WORD *)v27 + 18) = 0;
                    ne_log_obj();
                    uint64_t v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    uint64_t v73 = v72;
                    if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_89;
                    }
                    *(_DWORD *)buf = 138412290;
                    v93 = v27;
                    uint64_t v82 = "%@: createChannel: channel slot size 0, clean up channel";
                    v83 = v73;
                    uint64_t v84 = 12;
                  }

                  else
                  {
                    ne_log_obj();
                    uint64_t v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
                    {
LABEL_89:

                      os_unfair_lock_lock((os_unfair_lock_t)v27 + 2);
                      -[NEFilterPacketInterpose close_nolock:]((uint64_t)v27, 0);
                      os_unfair_lock_unlock((os_unfair_lock_t)v27 + 2);
                      uint64_t v29 = (void *)v89;
                      int v20 = self;
                      uint64_t v45 = v87;
LABEL_36:
                      ne_log_obj();
                      uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)unint64_t v91 = 138412290;
                        *(void *)&v91[4] = v27;
                        _os_log_error_impl( &dword_1876B1000,  v52,  OS_LOG_TYPE_ERROR,  "%@: interposeHandleFlowEvent: failed to create channel",  v91,  0xCu);
                      }

                      goto LABEL_38;
                    }

                    uint64_t v80 = *((void *)v27 + 14);
                    int v81 = *((void *)v27 + 15);
                    *(_DWORD *)buf = 138412802;
                    v93 = v27;
                    v94 = 1024;
                    *(_DWORD *)v95 = v80;
                    *(_WORD *)&v95[4] = 1024;
                    *(_DWORD *)&v95[6] = v81;
                    uint64_t v82 = "%@: createChannel failed to get Egress input / output rings (%X %X)";
                    v83 = v73;
                    uint64_t v84 = 24;
                  }

                  _os_log_error_impl(&dword_1876B1000, v83, OS_LOG_TYPE_ERROR, v82, buf, v84);
                  goto LABEL_89;
                }

                ne_log_obj();
                int v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
                {
                  id v75 = *((void *)v27 + 12);
                  uint64_t v76 = *((void *)v27 + 13);
                  *(_DWORD *)buf = 138412802;
                  v93 = v27;
                  v94 = 1024;
                  *(_DWORD *)v95 = v75;
                  *(_WORD *)&v95[4] = 1024;
                  *(_DWORD *)&v95[6] = v76;
                  unint64_t v77 = "%@: createChannel failed to get Ingress input / output rings (%X %X)";
                  unint64_t v78 = v70;
                  uint64_t v79 = 24;
LABEL_91:
                  _os_log_error_impl(&dword_1876B1000, v78, OS_LOG_TYPE_ERROR, v77, buf, v79);
                }
              }

              os_unfair_lock_lock((os_unfair_lock_t)v27 + 2);
              -[NEFilterPacketInterpose close_nolock:]((uint64_t)v27, 0);
              os_unfair_lock_unlock((os_unfair_lock_t)v27 + 2);
              goto LABEL_36;
            }

            ne_log_obj();
            uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
              goto LABEL_35;
            }
            *(_DWORD *)buf = 138412290;
            v93 = v27;
            unint64_t v57 = "%@: createChannel failed to create channel attributes";
          }

          else
          {
            ne_log_obj();
            uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
              goto LABEL_35;
            }
            *(_DWORD *)buf = 138412290;
            v93 = v27;
            unint64_t v57 = "%@: createChannel no key or 0 key length";
          }
        }

        else
        {
          ne_log_obj();
          uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
            goto LABEL_35;
          }
          *(_DWORD *)buf = 138412290;
          v93 = v27;
          unint64_t v57 = "%@: createChannel: no provider / packetHandler";
        }

        int v58 = v53;
        uint64_t v59 = 12;
LABEL_54:
        _os_log_error_impl(&dword_1876B1000, v58, OS_LOG_TYPE_ERROR, v57, buf, v59);
        goto LABEL_35;
      }

      ne_log_obj();
      unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unint64_t v91 = 138412546;
        *(void *)&v91[4] = v23;
        *(_WORD *)&v91[12] = 1024;
        *(_DWORD *)&v91[14] = a2;
        _os_log_error_impl( &dword_1876B1000,  v31,  OS_LOG_TYPE_ERROR,  "%@: interposeHandleFlowEvent: unsupported event %d",  v91,  0x12u);
      }
    }

    id v27 = v23;
LABEL_19:
    unint64_t v32 = &OBJC_IVAR___NEKeychainItem__oldItem;
    uint64_t v29 = (void *)v89;
LABEL_40:
    os_unfair_lock_unlock((os_unfair_lock_s *)((char *)v20 + v32[206]));

    int v16 = v88;
  }
}

  CFRelease(v3);
  if (v7) {
LABEL_21:
  }
    CFRelease(v7);
LABEL_22:
  if (v10) {
    CFRelease(v10);
  }
  return v4;
}

LABEL_106:
          }

          break;
        default:
          ne_log_obj();
          unint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            v94 = *((_DWORD *)v7 + 3);
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v94;
            uint64_t v65 = "Received unexpected message operation %d from kernel content filter";
            int v66 = v41;
            uint64_t v67 = 8;
LABEL_147:
            _os_log_error_impl(&dword_1876B1000, v66, OS_LOG_TYPE_ERROR, v65, buf, v67);
          }

  v177 = objc_getProperty(v37, v59, 88LL, 1);
  [v177 configurationReply];
  v178 = (void *)objc_claimAutoreleasedReturnValue();

  if (v178)
  {
    v180 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ConfigPayload);
    objc_setProperty_atomic(v43, v181, v180, 152LL);

    v183 = objc_getProperty(v37, v182, 88LL, 1);
    [v183 configurationReply];
    v184 = (void *)objc_claimAutoreleasedReturnValue();
    v186 = objc_getProperty(v43, v185, 152LL, 1);
    v188 = v186;
    if (v186) {
      objc_setProperty_atomic(v186, v187, v184, 24LL);
    }

    v190 = objc_getProperty(v43, v189, 152LL, 1);
    v191 = -[NEIKEv2Payload isValid]((uint64_t)v190);

    if ((v191 & 1) == 0)
    {
      ne_log_obj();
      v238 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v238, OS_LOG_TYPE_FAULT))
      {
LABEL_136:

        v239 = 0LL;
        int v5 = v506;
        goto LABEL_266;
      }

      *(_DWORD *)buf = 136315138;
      v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
      v293 = "%s called with null packet.config.isValid";
      v294 = v238;
      v295 = 12;
LABEL_206:
      _os_log_fault_impl(&dword_1876B1000, v294, OS_LOG_TYPE_FAULT, v293, buf, v295);
      goto LABEL_136;
    }
  }

  int v5 = v506;
  self = v43;
  if ((v37[23] & 1) != 0) {
    goto LABEL_214;
  }
  v192 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ChildSAPayload);
  objc_setProperty_atomic(v43, v193, v192, 88LL);

  if (v38) {
    v195 = objc_getProperty(v38, v194, 56LL, 1);
  }
  else {
    v195 = 0LL;
  }
  v196 = v195;
  v197 = -[NEIKEv2ChildSAProposal copyWithoutKEM](v196);
  v538[0] = v197;
  [MEMORY[0x189603F18] arrayWithObjects:v538 count:1];
  v198 = (void *)objc_claimAutoreleasedReturnValue();
  objc_getProperty(v43, v199, 88LL, 1);
  v200 = (void *)objc_claimAutoreleasedReturnValue();
  v202 = v200;
  if (v200) {
    objc_setProperty_atomic(v200, v201, v198, 24LL);
  }

  objc_getProperty(v43, v203, 88LL, 1);
  v204 = (void *)objc_claimAutoreleasedReturnValue();
  v205 = -[NEIKEv2Payload isValid]((uint64_t)v204);

  if ((v205 & 1) == 0)
  {
    ne_log_obj();
    v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    int v5 = v506;
    if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
      goto LABEL_264;
    }
    *(_DWORD *)buf = 136315138;
    v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
    v98 = "%s called with null packet.sa.isValid";
    goto LABEL_141;
  }

  v206 = objc_alloc_init(&OBJC_CLASS___NEIKEv2InitiatorTrafficSelectorPayload);
  objc_setProperty_atomic(v43, v207, v206, 160LL);
  v209 = -[NEIKEv2ChildSA initiatorTrafficSelectors](v38, v208);
  objc_getProperty(v43, v210, 160LL, 1);
  v211 = (void *)objc_claimAutoreleasedReturnValue();
  v213 = v211;
  int v5 = v506;
  if (v211) {
    objc_setProperty_atomic(v211, v212, v209, 24LL);
  }

  objc_getProperty(v43, v214, 160LL, 1);
  v215 = (void *)objc_claimAutoreleasedReturnValue();
  v216 = -[NEIKEv2Payload isValid]((uint64_t)v215);

  if ((v216 & 1) != 0)
  {
    v217 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ResponderTrafficSelectorPayload);
    objc_setProperty_atomic(v43, v218, v217, 168LL);
    v220 = -[NEIKEv2ChildSA responderTrafficSelectors](v38, v219);
    objc_getProperty(v43, v221, 168LL, 1);
    v222 = (void *)objc_claimAutoreleasedReturnValue();
    v224 = v222;
    if (v222) {
      objc_setProperty_atomic(v222, v223, v220, 24LL);
    }

    objc_getProperty(v43, v225, 168LL, 1);
    v226 = (void *)objc_claimAutoreleasedReturnValue();
    v227 = -[NEIKEv2Payload isValid]((uint64_t)v226);

    if ((v227 & 1) != 0)
    {
      if (v38) {
        v229 = objc_getProperty(v38, v228, 48LL, 1);
      }
      else {
        v229 = 0LL;
      }
      v230 = v229;
      v231 = [v230 mode];

      if (v231 == 1 && !-[NEIKEv2Packet addNotification:data:](v43, 0x4007uLL, 0LL))
      {
        ne_log_obj();
        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
          goto LABEL_264;
        }
        *(_WORD *)buf = 0;
        v98 = "[packet addNotification:NEIKEv2NotifyTypeUseTransportMode] failed";
        goto LABEL_334;
      }

      if (!-[NEIKEv2Packet addNotification:data:](v43, 0x400AuLL, 0LL))
      {
        ne_log_obj();
        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
          goto LABEL_264;
        }
        *(_WORD *)buf = 0;
        v98 = "[packet addNotification:NEIKEv2NotifyTypeESPTFCPaddingNotSupported] failed";
        goto LABEL_334;
      }

      if (!-[NEIKEv2Packet addNotification:data:](v43, 0x400BuLL, 0LL))
      {
        ne_log_obj();
        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
          goto LABEL_264;
        }
        *(_WORD *)buf = 0;
        v98 = "[packet addNotification:NEIKEv2NotifyTypeNonFirstFragmentsAlso] failed";
        goto LABEL_334;
      }

      if (v38) {
        v233 = objc_getProperty(v38, v232, 48LL, 1);
      }
      else {
        v233 = 0LL;
      }
      v234 = v233;
      if ([v234 sequencePerTrafficClass])
      {
        v235 = -[NEIKEv2Packet hasNotification:](v36, (const char *)0xC350);

        if (v235)
        {
          v236 = +[NEIKEv2NotifyPayload createNotifyPayloadType:]();
          v237 = -[NEIKEv2Packet addNotifyPayload:](v43, v236);

          if (!v237)
          {
            ne_log_obj();
            v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              v98 = "[packet addNotifyPayload:notifyPayload] failed";
LABEL_334:
              v240 = v97;
              v241 = 2;
              goto LABEL_142;
            }

      uint64_t v12 = (void *)v75[4];
      break;
    case 44:
      uint64_t v82 = *(void **)(a1 + 40);
      v83 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v131 = (void *)v159[5];
      [v82 setAppPushParameters:v83 errorStr:&v131];
      int v30 = v131;
      goto LABEL_64;
    case 45:
      uint64_t v84 = *(void **)(a1 + 40);
      __int16 v85 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v130 = (void *)v159[5];
      [v84 unsetAppPushParameters:v85 errorStr:&v130];
      int v30 = v130;
      goto LABEL_64;
    case 46:
      int v86 = *(void **)(a1 + 40);
      __int16 v87 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v141 = (void *)v159[5];
      [v86 addRelayWithParameters:v87 errorStr:&v141];
      int v30 = v141;
      goto LABEL_64;
    case 47:
      int v88 = *(void **)(a1 + 40);
      uint64_t v89 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v140 = (void *)v159[5];
      [v88 removeRelayWithParameters:v89 errorStr:&v140];
      int v30 = v140;
      goto LABEL_64;
    case 48:
      CFErrorRef v90 = *(void **)(a1 + 40);
      unint64_t v91 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v139 = (void *)v159[5];
      [v90 setRelayConditionsWithParameters:v91 errorStr:&v139];
      int v30 = v139;
      goto LABEL_64;
    case 49:
      v92 = *(void **)(a1 + 40);
      v93 = *(void *)(a1 + 48);
      uint64_t v29 = v159;
      v138 = (void *)v159[5];
      [v92 unsetRelayConditionsWithParameters:v93 errorStr:&v138];
      int v30 = v138;
LABEL_64:
      v94 = v30;
      unint64_t v71 = (id)v29[5];
      v29[5] = (uint64_t)v94;
      goto LABEL_65;
    default:
      switch(v26)
      {
        case 'e':
          goto LABEL_66;
        case 'g':
        case 'h':
          unint64_t v31 = *(void **)(a1 + 40);
          if (v31 && objc_getProperty(v31, v20, 80LL, 1))
          {
            int v33 = *(id *)(a1 + 40);
            if (v33) {
              int v33 = objc_getProperty(v33, v32, 80LL, 1);
            }
            uint64_t v34 = v33;
            [v34 connection];
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
            int v36 = [v35 status];

            if (v36 <= 5) {
              [v8 addObject:off_18A08F9D8[v36]];
            }
          }

          goto LABEL_66;
        case 'i':
          v95 = *(void **)(a1 + 40);
          if (!v95 || !objc_getProperty(v95, v20, 80LL, 1)) {
            goto LABEL_66;
          }
          [*(id *)(a1 + 48) objectForKeyedSubscript:@"stop-current-session"];
          v96 = (void *)objc_claimAutoreleasedReturnValue();
          if (isa_nsstring(v96))
          {
            else {
              v98 = 0LL;
            }
          }

          else
          {
            v98 = 0LL;
          }

          v110 = *(id *)(a1 + 40);
          if (v110) {
            v110 = objc_getProperty(v110, v97, 80LL, 1);
          }
          v111 = v110;
          [v111 connection];
          v112 = (void *)objc_claimAutoreleasedReturnValue();
          v125 = 0LL;
          [v112 startVPNTunnelWithOptions:v98 andReturnError:&v125];
          unint64_t v71 = v125;

          if (v71)
          {
            v113 = [NSString stringWithFormat:@"Failed to start the tunnel: %@", v71];
            v114 = (void *)v159[5];
            v159[5] = v113;
          }

          break;
        case 'j':
          v99 = *(void **)(a1 + 40);
          if (!v99 || !objc_getProperty(v99, v20, 80LL, 1)) {
            goto LABEL_66;
          }
          v101 = *(id *)(a1 + 40);
          if (v101) {
            v101 = objc_getProperty(v101, v100, 80LL, 1);
          }
          unint64_t v71 = v101;
          [v71 connection];
          v102 = (void *)objc_claimAutoreleasedReturnValue();
          [v102 stopVPNTunnel];

          break;
        default:
          goto LABEL_81;
      }

        [NSString stringWithFormat:@"Invalid %@, VPN type is not L2TP", v80];
        int v58 = (id)objc_claimAutoreleasedReturnValue();
        goto LABEL_107;
      }

      unint64_t v15 = v105;
      if ([v6 type] == 2)
      {
        [v109 objectForKeyedSubscript:@"machine-authentication-method"];
        uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue();
        if ([v76 isEqualToString:@"shared-secret"])
        {
          unint64_t v77 = 1LL;
        }

        else
        {
          if (([v76 isEqualToString:@"certificate"] & 1) == 0)
          {
            [NSString stringWithFormat:@"Invalid %@, valid values are shared-secret and certificate", @"machine-authentication-method"];
            *v106 = (id)objc_claimAutoreleasedReturnValue();

            goto LABEL_86;
          }

          unint64_t v77 = 2LL;
        }

        [v6 setMachineAuthenticationMethod:v77];

        uint64_t v14 = (void *)v108;
        goto LABEL_92;
      }

      [NSString stringWithFormat:@"Invalid %@, VPN type is not L2TP", @"machine-authentication-method"];
      unint64_t v57 = (id)objc_claimAutoreleasedReturnValue();
LABEL_88:
      *v106 = v57;
      goto LABEL_109;
    }

    [v109 objectForKeyedSubscript:@"ipv4-config-method"];
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    [v6 IPv4Settings];
    id v22 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v22)
    {
      uint64_t v23 = -[NEIPv4Settings initWithConfigMethod:]( objc_alloc(&OBJC_CLASS___NEIPv4Settings),  "initWithConfigMethod:",  2LL);
      [v6 setIPv4Settings:v23];
    }

    if ([v21 isEqualToString:@"ppp"])
    {
      [v6 IPv4Settings];
      unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = v24;
      int v26 = 2LL;
LABEL_27:
      [v24 setConfigMethod:v26];

LABEL_28:
      int v20 = v109;
      goto LABEL_29;
    }

    if ([v21 isEqualToString:@"manual"])
    {
      [v6 IPv4Settings];
      unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = v24;
      int v26 = 3LL;
      goto LABEL_27;
    }

    if ([v21 isEqualToString:@"automatic"])
    {
      [v6 IPv4Settings];
      unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = v24;
      int v26 = 1LL;
      goto LABEL_27;
    }

    if ([v21 isEqualToString:@"off"])
    {
      [v6 setIPv4Settings:0];
      goto LABEL_28;
    }

    [NSString stringWithFormat:@"Invalid %@, valid values are ppp, manual, automatic, and off", @"ipv4-config-method"];
    *v106 = (id)objc_claimAutoreleasedReturnValue();

LABEL_115:
    CFStringRef v11 = 0LL;
    uint64_t v12 = 0LL;
    int v13 = 0LL;
    uint64_t v14 = 0LL;
    unint64_t v15 = 0LL;
    int v16 = 0LL;
    goto LABEL_109;
  }

void sub_187705818(_Unwind_Exception *a1)
{
}

void sub_187705904(_Unwind_Exception *a1)
{
}

void sub_18770598C(_Unwind_Exception *a1)
{
}

void sub_187705C78(_Unwind_Exception *a1)
{
}

void sub_187705E0C(_Unwind_Exception *a1)
{
}

void sub_18770B2F8(_Unwind_Exception *a1)
{
}

void sub_18770B4F4(_Unwind_Exception *a1)
{
}

void sub_18770B8CC(_Unwind_Exception *a1)
{
}

void sub_18770B95C(_Unwind_Exception *a1)
{
}

void sub_18770B9EC(_Unwind_Exception *a1)
{
}

void sub_18770BA68(_Unwind_Exception *a1)
{
}

void sub_18770BAEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_18770BB68(_Unwind_Exception *a1)
{
}

void sub_18770BBEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_18770BC5C(_Unwind_Exception *a1)
{
}

void sub_18770BCD4(_Unwind_Exception *a1)
{
}

void sub_18770BE4C(_Unwind_Exception *a1)
{
}

void sub_18770BED0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

id NEFilterMapError(void *a1)
{
  v14[1] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  [v1 domain];
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  int v3 = [v2 isEqual:@"NEConfigurationErrorDomain"];

  if (v3)
  {
    switch([v1 code])
    {
      case 1LL:
      case 2LL:
      case 3LL:
      case 4LL:
      case 7LL:
        [v1 localizedDescription];
        int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v5 = 1LL;
        goto LABEL_7;
      case 5LL:
        [v1 localizedDescription];
        int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v5 = 3LL;
        goto LABEL_7;
      case 6LL:
      case 8LL:
      case 11LL:
      case 12LL:
      case 20LL:
        [v1 localizedDescription];
        int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        goto LABEL_6;
      case 9LL:
        ne_log_obj();
        int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( &dword_1876B1000,  v4,  OS_LOG_TYPE_DEFAULT,  "The configuration was not saved because it was unchanged from the previously saved version",  buf,  2u);
        }

        id v8 = 0LL;
        break;
      case 10LL:
      case 21LL:
        [v1 localizedDescription];
        int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v5 = 5LL;
        goto LABEL_7;
      default:
        CFStringRef v10 = (void *)NSString;
        [v1 localizedDescription];
        CFStringRef v11 = (void *)objc_claimAutoreleasedReturnValue();
        [v10 stringWithFormat:@"Unknown: %@", v11];
        int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();

        goto LABEL_6;
    }
  }

  else
  {
    int v4 = (os_log_s *)@"Unknown.";
LABEL_6:
    uint64_t v5 = 6LL;
LABEL_7:
    CFIndex v6 = (void *)MEMORY[0x189607870];
    uint64_t v13 = *MEMORY[0x1896075E0];
    v14[0] = v4;
    [MEMORY[0x189603F68] dictionaryWithObjects:v14 forKeys:&v13 count:1];
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    [v6 errorWithDomain:@"NEFilterErrorDomain" code:v5 userInfo:v7];
    id v8 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v8;
}

void sub_18770CA28(_Unwind_Exception *a1)
{
}

void sub_18770D488( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_18770DC50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_18770DD18(_Unwind_Exception *a1)
{
}

LABEL_6:
  (*(void (**)(void))(a1[7] + 16LL))();
}

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

  id v8 = 48LL;
  if (*(void *)(*(void *)(a1 + 32) + 24LL) == 1LL) {
    id v8 = 40LL;
  }
  (*(void (**)(void))(*(void *)(a1 + v8) + 16LL))();
}

  v27[0] = MEMORY[0x1895F87A8];
  v27[1] = 3221225472LL;
  v27[2] = __68__NEFilterSource_dataCompleteWithCompletionQueue_completionHandler___block_invoke_68;
  v27[3] = &unk_18A0908C8;
  id v8 = *(dispatch_queue_s **)(a1 + 40);
  uint64_t v9 = *(id *)(a1 + 48);
  v27[4] = *(void *)(a1 + 32);
  uint64_t v28 = v9;
  dispatch_async(v8, v27);
}

        return 0LL;
      }

      return result;
    default:
      ne_log_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        String = NEIKEv2EncryptionTypeCreateString(a3);
        *(_DWORD *)buf = 138412290;
        uint64_t v14 = String;
        _os_log_fault_impl(&dword_1876B1000, v9, OS_LOG_TYPE_FAULT, "Invalid NEIKEv2EncryptionType %@", buf, 0xCu);
      }

      goto LABEL_6;
  }

  aad = self->_aad;
  return -[NSData hash](aad, "hash") ^ v6;
}

  Property = objc_getProperty(self, v11, 16LL, 1);
LABEL_7:
  [v8 appendPrettyObject:Property withName:@"Attributes" andIndent:v5 options:a4];

  return v8;
}

  -[NEIKEv2ChildSA setState:error:](v6, 1uLL, 0LL);
  -[NEIKEv2Session reportState]((void *)a1[4], v8);
LABEL_20:
  if ((-[NEIKEv2IKESA generateAllValuesForSAInit]((_BYTE *)a1[5], v4) & 1) != 0)
  {
    uint64_t v28 = (void *)a1[4];
    id v27 = (void *)a1[5];
    v48[0] = MEMORY[0x1895F87A8];
    v48[1] = 3221225472LL;
    v48[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_143;
    v48[3] = &unk_18A08D028;
    uint64_t v29 = v27;
    int v30 = a1[4];
    uint64_t v49 = v29;
    uint64_t v50 = v30;
    int v51 = a1[6];
    -[NEIKEv2Session handleIKEIntermediateForInitiatorIKESA:iteration:handler:](v28, v29, 0LL, v48);

    return;
  }

  ne_log_obj();
  unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    uint64_t v45 = a1[4];
    *(_DWORD *)buf = 138412290;
    uint64_t v53 = v45;
    _os_log_error_impl( &dword_1876B1000,  v31,  OS_LOG_TYPE_ERROR,  "%@ Failed to generate crypto values (connect)",  buf,  0xCu);
  }

  int v33 = (id)a1[4];
  if (v33) {
    int v33 = objc_getProperty(v33, v32, 336LL, 1);
  }
  unint64_t v19 = v33;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorCrypto( @"Failed to generate crypto values (connect)",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v47);
LABEL_27:
  unint64_t v41 = ErrorPeerInvalidSyntax;
  -[NEIKEv2IKESA setState:error:]((uint64_t)v19, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState]((void *)a1[4], v42);
  -[NEIKEv2Session resetAll](a1[4], v43);
}

    goto LABEL_7;
  }

  ne_log_obj();
  unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    BOOL v55 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v84 = v55;
    _os_log_error_impl( &dword_1876B1000,  v15,  OS_LOG_TYPE_ERROR,  "%@ Failed to receive IKE Auth packet (connect)",  buf,  0xCu);
  }

  unsigned __int16 v17 = *(id *)(a1 + 32);
  if (v17) {
    unsigned __int16 v17 = objc_getProperty(v17, v16, 336LL, 1);
  }
  int v18 = v17;
  int v26 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Failed to receive IKE Auth packet (connect)",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v70[0]);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v18, 3uLL, v26);

  -[NEIKEv2Session reportState](*(void **)(a1 + 32), v27);
  -[NEIKEv2Session resetAll](*(void *)(a1 + 32), v28);
LABEL_21:
}

  return a1;
}

  if (-[NEIPv4Settings overridePrimary](self, "overridePrimary")) {
    [v3 setObject:&unk_18A0CF9C0 forKeyedSubscript:*MEMORY[0x18960C7B8]];
  }
  -[NEIPv4Settings includedRoutes](self, "includedRoutes");
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (v5)
  {
    CFIndex v6 = objc_alloc_init(MEMORY[0x189603FA8]);
    uint64_t v37 = 0u;
    uint64_t v38 = 0u;
    int v39 = 0u;
    unint64_t v40 = 0u;
    -[NEIPv4Settings includedRoutes](self, "includedRoutes");
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    id v8 = [v7 countByEnumeratingWithState:&v37 objects:v42 count:16];
    if (v8)
    {
      uint64_t v9 = v8;
      CFStringRef v10 = *(void *)v38;
      CFStringRef v11 = *MEMORY[0x18960C7B8];
      do
      {
        for (i = 0LL; i != v9; ++i)
        {
          if (*(void *)v38 != v10) {
            objc_enumerationMutation(v7);
          }
          uint64_t v13 = *(void **)(*((void *)&v37 + 1) + 8 * i);
          if ([v13 isDefaultRoute])
          {
            [v3 setObject:&unk_18A0CF9C0 forKeyedSubscript:v11];
          }

          else
          {
            uint64_t v14 = (void *)[v13 copyLegacyDictionary];
            [v6 addObject:v14];
          }
        }

        uint64_t v9 = [v7 countByEnumeratingWithState:&v37 objects:v42 count:16];
      }

      while (v9);
    }
  }

  -[NEIPv4Settings excludedRoutes](self, "excludedRoutes");
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();

  if (v15)
  {
    int v16 = objc_alloc_init(MEMORY[0x189603FA8]);
    int v33 = 0u;
    uint64_t v34 = 0u;
    uint64_t v35 = 0u;
    int v36 = 0u;
    -[NEIPv4Settings excludedRoutes](self, "excludedRoutes", 0LL);
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    int v18 = [v17 countByEnumeratingWithState:&v33 objects:v41 count:16];
    if (v18)
    {
      unint64_t v19 = v18;
      int v20 = *(void *)v34;
      do
      {
        for (j = 0LL; j != v19; ++j)
        {
          if (*(void *)v34 != v20) {
            objc_enumerationMutation(v17);
          }
          id v22 = *(void **)(*((void *)&v33 + 1) + 8 * j);
          if (([v22 isDefaultRoute] & 1) == 0)
          {
            uint64_t v23 = (void *)[v22 copyLegacyDictionary];
            [v16 addObject:v23];
          }
        }

        unint64_t v19 = [v17 countByEnumeratingWithState:&v33 objects:v41 count:16];
      }

      while (v19);
    }
  }

  return v3;
}

  -[NEIPv6Settings includedRoutes](self, "includedRoutes");
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (v5)
  {
    CFIndex v6 = objc_alloc_init(MEMORY[0x189603FA8]);
    uint64_t v37 = 0u;
    uint64_t v38 = 0u;
    int v39 = 0u;
    unint64_t v40 = 0u;
    -[NEIPv6Settings includedRoutes](self, "includedRoutes");
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    id v8 = [v7 countByEnumeratingWithState:&v37 objects:v42 count:16];
    if (v8)
    {
      uint64_t v9 = v8;
      CFStringRef v10 = *(void *)v38;
      CFStringRef v11 = *MEMORY[0x18960C7B8];
      do
      {
        for (i = 0LL; i != v9; ++i)
        {
          if (*(void *)v38 != v10) {
            objc_enumerationMutation(v7);
          }
          uint64_t v13 = *(void **)(*((void *)&v37 + 1) + 8 * i);
          if ([v13 isDefaultRoute])
          {
            [v3 setObject:&unk_18A0CF9F0 forKeyedSubscript:v11];
          }

          else
          {
            uint64_t v14 = (void *)[v13 copyLegacyDictionary];
            [v6 addObject:v14];
          }
        }

        uint64_t v9 = [v7 countByEnumeratingWithState:&v37 objects:v42 count:16];
      }

      while (v9);
    }
  }

  -[NEIPv6Settings excludedRoutes](self, "excludedRoutes");
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();

  if (v15)
  {
    int v16 = objc_alloc_init(MEMORY[0x189603FA8]);
    int v33 = 0u;
    uint64_t v34 = 0u;
    uint64_t v35 = 0u;
    int v36 = 0u;
    -[NEIPv6Settings excludedRoutes](self, "excludedRoutes", 0LL);
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    int v18 = [v17 countByEnumeratingWithState:&v33 objects:v41 count:16];
    if (v18)
    {
      unint64_t v19 = v18;
      int v20 = *(void *)v34;
      do
      {
        for (j = 0LL; j != v19; ++j)
        {
          if (*(void *)v34 != v20) {
            objc_enumerationMutation(v17);
          }
          id v22 = *(void **)(*((void *)&v33 + 1) + 8 * j);
          if (([v22 isDefaultRoute] & 1) == 0)
          {
            uint64_t v23 = (void *)[v22 copyLegacyDictionary];
            [v16 addObject:v23];
          }
        }

        unint64_t v19 = [v17 countByEnumeratingWithState:&v33 objects:v41 count:16];
      }

      while (v19);
    }
  }

  return v3;
}

void sub_187713AD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1877175B0(_Unwind_Exception *a1)
{
}

void sub_187717CE0(_Unwind_Exception *a1)
{
}

void sub_187717E6C(_Unwind_Exception *a1)
{
}

void sub_187718894( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, id location)
{
}

void sub_187719D1C(_Unwind_Exception *a1)
{
}

void sub_18771A178(_Unwind_Exception *a1)
{
}

void sub_18771A228(_Unwind_Exception *a1)
{
}

void sub_18771A2B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_18771A34C(_Unwind_Exception *a1)
{
}

void sub_18771A3F0(_Unwind_Exception *a1)
{
}

void sub_18771A484(_Unwind_Exception *a1)
{
}

void sub_18771A528(_Unwind_Exception *a1)
{
}

void sub_18771A5BC(_Unwind_Exception *a1)
{
}

void sub_18771A660(_Unwind_Exception *a1)
{
}

void sub_18771A6E4(_Unwind_Exception *a1)
{
}

void sub_18771A770(_Unwind_Exception *a1)
{
}

void sub_18771A804(_Unwind_Exception *a1)
{
}

void sub_18771A8A8(_Unwind_Exception *a1)
{
}

void sub_18771ADE8(_Unwind_Exception *a1)
{
}

void sub_18771B0CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

uint64_t __Block_byref_object_copy__6426(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__6427(uint64_t a1)
{
}

void sub_18771B6A4(_Unwind_Exception *a1)
{
}

void sub_18771B918(_Unwind_Exception *a1)
{
}

void sub_18771C244( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id obj, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
}

void sub_18771D1E0(_Unwind_Exception *a1)
{
}

void sub_18771DB2C(_Unwind_Exception *a1)
{
}

LABEL_21:
  objc_msgSend(v19, "setUseSSIDPrefix:", -[NEHotspotConfiguration useSSIDPrefix](self, "useSSIDPrefix"));
  objc_msgSend(v19, "setSecurityType:", -[NEHotspotConfiguration securityType](self, "securityType"));
  -[NEHotspotConfiguration lifeTimeInDays](self, "lifeTimeInDays");
  BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
  [v19 setLifeTimeInDays:v25];

  objc_msgSend(v19, "setJoinOnce:", -[NEHotspotConfiguration joinOnce](self, "joinOnce"));
  objc_msgSend(v19, "setHidden:", -[NEHotspotConfiguration hidden](self, "hidden"));
  return v19;
}

  return v11;
}

    CFIndex v6 = 0LL;
    goto LABEL_22;
  }

  uint64_t v7 = [v5 digitalSignatureAlgorithm];
  if (v7 != [v4 digitalSignatureAlgorithm]
    || ([v5 isNonStandard] & 1) == 0 && (objc_msgSend(v4, "isNonStandard") & 1) == 0)
  {
    goto LABEL_21;
  }

    uint64_t v23 = self->_saSession;
    CFStringRef v10 = WeakRetained;
    goto LABEL_22;
  }

    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1876B1000, v17, OS_LOG_TYPE_ERROR, "Delete payload missing required fields", buf, 2u);
    }

    return 0;
  }

  if (([0 hasRequiredFields] & 1) == 0) {
    goto LABEL_21;
  }
  uint64_t v23 = 0;
LABEL_19:
  ne_log_obj();
  int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    if (self) {
      int v18 = self->_protocol;
    }
    else {
      LODWORD(v1_Block_object_dispose((const void *)(v49 - 176), 8) = 0;
    }
    *(_DWORD *)buf = 67109120;
    BOOL v25 = v18;
    _os_log_error_impl(&dword_1876B1000, v16, OS_LOG_TYPE_ERROR, "Unsupported DELETE protocol type %u", buf, 8u);
  }

  return 0;
}

LABEL_22:
        ++v7;
      }

      while (v5 != v7);
      uint64_t v5 = -[NEIKEv2Packet countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v18,  v24,  16LL);
    }

    while (v5);
  }
}

    _os_log_fault_impl(&dword_1876B1000, v22, OS_LOG_TYPE_FAULT, v23, buf, 0xCu);
    goto LABEL_22;
  }

  return a1;
}
}

    goto LABEL_22;
  }

  unint64_t v19 = (os_log_s *)+[NEIKEv2Packet createPacketFromReceivedData:]((uint64_t)&OBJC_CLASS___NEIKEv2Packet, v13);
  if (v19)
  {
    uint64_t v14 = v19;
    -[NEIKEv2Transport receivePacket:](*(id **)(a1 + 32), v19);
    goto LABEL_21;
  }

  ne_log_obj();
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
  {
    LOWORD(v22[0]) = 0;
    _os_log_fault_impl( &dword_1876B1000,  v21,  OS_LOG_TYPE_FAULT,  "[NEIKEv2Packet createPacketFromReceivedData] failed",  (uint8_t *)v22,  2u);
  }

LABEL_23:
}

  if (v22) {
    free(v22);
  }
  if (v21) {
    free(v21);
  }
  return v15;
}
  }

  BOOL v25 = objc_alloc_init(MEMORY[0x189603FA8]);
  int v46 = 0u;
  int64_t v47 = 0u;
  int v48 = 0u;
  uint64_t v49 = 0u;
  -[NEIPv6Settings includedRoutes](self, "includedRoutes");
  int v26 = (void *)objc_claimAutoreleasedReturnValue();
  id v27 = [v26 countByEnumeratingWithState:&v46 objects:v52 count:16];
  if (v27)
  {
    uint64_t v28 = v27;
    uint64_t v29 = *(void *)v47;
    do
    {
      for (i = 0LL; i != v28; ++i)
      {
        if (*(void *)v47 != v29) {
          objc_enumerationMutation(v26);
        }
        [*(id *)(*((void *)&v46 + 1) + 8 * i) checkValidityAndCollectErrors:v25];
      }

      uint64_t v28 = [v26 countByEnumeratingWithState:&v46 objects:v52 count:16];
    }

    while (v28);
  }

  uint64_t v44 = 0u;
  uint64_t v45 = 0u;
  unint64_t v42 = 0u;
  char v43 = 0u;
  -[NEIPv6Settings excludedRoutes](self, "excludedRoutes", 0LL);
  unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v32 = [v31 countByEnumeratingWithState:&v42 objects:v51 count:16];
  if (v32)
  {
    int v33 = v32;
    uint64_t v34 = *(void *)v43;
    do
    {
      for (j = 0LL; j != v33; ++j)
      {
        if (*(void *)v43 != v34) {
          objc_enumerationMutation(v31);
        }
        [*(id *)(*((void *)&v42 + 1) + 8 * j) checkValidityAndCollectErrors:v25];
      }

      int v33 = [v31 countByEnumeratingWithState:&v42 objects:v51 count:16];
    }

    while (v33);
  }

  if ([v25 count])
  {
    ne_log_obj();
    int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      int v54 = (uint64_t)v25;
      _os_log_error_impl(&dword_1876B1000, v36, OS_LOG_TYPE_ERROR, "IPv6 routes are invalid: %@", buf, 0xCu);
    }
  }

  return 1;
}
  }

  return v6;
}

LABEL_118:
                            return 105LL;
                          }
                        }

                        else if ((v83 & 1) == 0)
                        {
                          ne_log_obj();
                          __int16 v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_126;
                          }
                          goto LABEL_118;
                        }
                      }

                      ++v76;
                      SEL v74 = v78;
                      uint64_t v73 = v94;
                      int v70 = v95;
                      id v75 = v79;
                      if (v76 != v72) {
                        goto LABEL_99;
                      }
                      uint64_t v72 = [v95 countByEnumeratingWithState:&v96 objects:v100 count:16];
                      if (!v72) {
                        goto LABEL_114;
                      }
                    }

                    ne_log_obj();
                    int v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
                    {
                      v92 = (void *)objc_opt_class();
                      *(_DWORD *)buf = 138412290;
                      v102 = v92;
                      v93 = v92;
                      _os_log_error_impl( &dword_1876B1000,  v88,  OS_LOG_TYPE_ERROR,  "%@ invalid HS2.0 configuration.",  buf,  0xCu);
                    }

                    return 105LL;
                  }
                }

                else
                {
                }
              }

              ne_log_obj();
              int v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412290;
                v102 = (id)objc_opt_class();
                uint64_t v59 = v102;
                uint64_t v60 = "%@ invalid HS2.0 EAP settings.";
                goto LABEL_93;
              }

          a1 = 0LL;
          goto LABEL_119;
        }

        ne_log_obj();
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled((os_log_t)v52, OS_LOG_TYPE_ERROR)) {
          goto LABEL_118;
        }
        uint64_t v68 = (char *)[(id)a1 copyShortDescription];
        *(_DWORD *)buf = 138412290;
        v161 = v68;
        int v70 = "%@ Did not receive NONCE payload";
      }

      else
      {
        ne_log_obj();
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled((os_log_t)v52, OS_LOG_TYPE_ERROR)) {
          goto LABEL_118;
        }
        uint64_t v68 = (char *)[(id)a1 copyShortDescription];
        *(_DWORD *)buf = 138412290;
        v161 = v68;
        int v70 = "%@ Could not set chosen proposal values";
      }

                v144 = 0LL;
LABEL_119:

                goto LABEL_120;
              }

              ne_log_obj();
              uint64_t v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v25 = self;
              if (!os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
                goto LABEL_118;
              }
              *(_DWORD *)buf = 136315138;
              v282 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitResponse:ikeSA:]";
              v227 = "%s called with null packet.ke.isValid";
            }

            else
            {
              ne_log_obj();
              uint64_t v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v25 = self;
              if (!os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
                goto LABEL_118;
              }
              *(_DWORD *)buf = 136315138;
              v282 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitResponse:ikeSA:]";
              v227 = "%s called with null packet.sa.isValid";
            }

LABEL_73:
      ne_log_obj();
      int v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v102 = (id)objc_opt_class();
        uint64_t v61 = v102;
        _os_log_error_impl(&dword_1876B1000, v48, OS_LOG_TYPE_ERROR, "%@ invalid HS2.0 domain name.", buf, 0xCu);
      }

      return 106LL;
    }
  }

  else
  {

    if (!v7) {
      goto LABEL_37;
    }
  }

            objc_msgSend(*(id *)(v2 + 16), "setWithObjects:", &unk_18A0CF918, &unk_18A0CF930, &unk_18A0CF948, 0);
            uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v80 = (void *)MEMORY[0x189607968];
            [(id)v1 eapSettings];
            int v81 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v80, "numberWithInteger:", objc_msgSend(v81, "preferredTLSVersion"));
            uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
            v83 = [v5 containsObject:v82];

            if ((v83 & 1) == 0)
            {
              [(id)v1 eapSettings];
              uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue();
              [v84 setPreferredTLSVersion:2];
            }

            id v1 = 1LL;
            goto LABEL_54;
          }
        }

        else
        {
        }

        ne_log_obj();
        uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_ERROR)) {
          goto LABEL_53;
        }
        v127 = (void *)objc_opt_class();
        *(_DWORD *)buf = 138412290;
        v170 = v127;
        uint64_t v56 = v127;
        unint64_t v57 = "%@ invalid password in EAP settings";
LABEL_89:
        _os_log_error_impl(&dword_1876B1000, (os_log_t)v5, OS_LOG_TYPE_ERROR, v57, buf, 0xCu);

        goto LABEL_53;
      }
    }

    else
    {
    }

    ne_log_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_53;
    }
    v109 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412290;
    v170 = v109;
    uint64_t v56 = v109;
    unint64_t v57 = "%@ invalid username in EAP settings";
    goto LABEL_89;
  }

  ne_log_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_ERROR))
  {
    BOOL v55 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412290;
    v170 = v55;
    uint64_t v56 = v55;
    unint64_t v57 = "%@ too many trusted server certificates";
    goto LABEL_89;
  }

LABEL_29:
        a1 = 0LL;
        goto LABEL_30;
      }

      goto LABEL_64;
    }
  }

  [v6 kemProtocols];
  uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
  [a1 kemProtocols];
  int v54 = (void *)objc_claimAutoreleasedReturnValue();
  [v54 firstObject];
  BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v56 = [v53 indexOfObject:v55];

  if (v56 == 0x7FFFFFFFFFFFFFFFLL)
  {
    if (a3)
    {
      v126 = 0uLL;
      v127 = 0uLL;
      v124 = 0uLL;
      v125 = 0uLL;
      [a1 kemProtocols];
      unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
      int v58 = [v57 countByEnumeratingWithState:&v124 objects:v145 count:16];
      if (!v58) {
        goto LABEL_94;
      }
      uint64_t v59 = v58;
      uint64_t v60 = *(void *)v125;
LABEL_78:
      uint64_t v61 = 0LL;
      while (1)
      {
        if (*(void *)v125 != v60) {
          objc_enumerationMutation(v57);
        }
        int v62 = *(void *)(*((void *)&v124 + 1) + 8 * v61);
        [v6 kemProtocols];
        uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v64 = [v63 indexOfObject:v62];

        if (v64 != 0x7FFFFFFFFFFFFFFFLL) {
          break;
        }
        if (v59 == ++v61)
        {
          uint64_t v59 = [v57 countByEnumeratingWithState:&v124 objects:v145 count:16];
          if (!v59)
          {
LABEL_94:

LABEL_101:
            ne_log_large_obj();
            uint64_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
            {
              [a1 kemProtocols];
              unint64_t v77 = (char *)objc_claimAutoreleasedReturnValue();
              [v6 kemProtocols];
              unint64_t v78 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138412546;
              v149 = v77;
              v150 = 2112;
              v151 = v78;
              _os_log_impl( &dword_1876B1000,  v76,  OS_LOG_TYPE_INFO,  "Failed to match Key Exchange methods (%@ vs %@)",  buf,  0x16u);
            }

            SEL v74 = 0LL;
            v140 = 0;
            goto LABEL_152;
          }

          goto LABEL_78;
        }
      }

      [v6 kemProtocols];
      uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue();
      [v73 objectAtIndexedSubscript:v64];
      SEL v74 = (void *)objc_claimAutoreleasedReturnValue();

      goto LABEL_98;
    }

    v122 = 0uLL;
    v123 = 0uLL;
    v120 = 0uLL;
    v121 = 0uLL;
    [v6 kemProtocols];
    unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
    int v66 = [v57 countByEnumeratingWithState:&v120 objects:v144 count:16];
    if (!v66) {
      goto LABEL_94;
    }
    uint64_t v67 = v66;
    uint64_t v68 = *(void *)v121;
LABEL_88:
    uint64_t v69 = 0LL;
    while (1)
    {
      if (*(void *)v121 != v68) {
        objc_enumerationMutation(v57);
      }
      int v70 = *(void **)(*((void *)&v120 + 1) + 8 * v69);
      [a1 kemProtocols];
      unint64_t v71 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v72 = [v71 containsObject:v70];

      if (v72) {
        break;
      }
      if (v67 == ++v69)
      {
        uint64_t v67 = [v57 countByEnumeratingWithState:&v120 objects:v144 count:16];
        if (!v67) {
          goto LABEL_94;
        }
        goto LABEL_88;
      }
    }

    uint64_t v65 = v70;
  }

  else
  {
    [v6 kemProtocols];
    unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
    [v57 objectAtIndexedSubscript:v56];
    uint64_t v65 = (id)objc_claimAutoreleasedReturnValue();
  }

  SEL v74 = v65;
LABEL_98:

  if (!v74) {
    goto LABEL_101;
  }
  [a1 additionalKEMProtocols];
  id v75 = (void *)objc_claimAutoreleasedReturnValue();
  if (v75)
  {
  }

  else
  {
    [v6 additionalKEMProtocols];
    uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v79)
    {
      v140 = 1;
      goto LABEL_152;
    }
  }

  uint64_t v80 = -[NEIKEv2KEMProtocol initWithMethod:](objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol), "initWithMethod:", 0LL);
  v143 = v80;
  [MEMORY[0x189603F18] arrayWithObjects:&v143 count:1];
  v108 = (void *)objc_claimAutoreleasedReturnValue();

  v107 = v74;
  int v81 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FE0]), "initWithObjects:", v74, 0);
  uint64_t v82 = 6LL;
  v83 = 0x189607000uLL;
  v109 = a3;
  while (1)
  {
    [*(id *)(v83 + 2408) numberWithUnsignedInteger:v82];
    uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue();
    [v6 additionalKEMProtocols];
    __int16 v85 = (void *)objc_claimAutoreleasedReturnValue();
    int v86 = [v85 objectForKeyedSubscript:v84];

    [a1 additionalKEMProtocols];
    __int16 v87 = (void *)objc_claimAutoreleasedReturnValue();
    int v88 = [v87 objectForKeyedSubscript:v84];

    if (v86 | v88) {
      break;
    }
LABEL_140:

    if (++v82 == 13)
    {
      v140 = 1;
      goto LABEL_151;
    }
  }

  if (v86) {
    uint64_t v89 = v88 == 0;
  }
  else {
    uint64_t v89 = 1;
  }
  if (v89)
  {
    if (v86) {
      int v88 = (uint64_t)v108;
    }
    else {
      int v86 = (uint64_t)v108;
    }
    CFErrorRef v90 = v108;
  }

  v110 = v82;
  v111 = v84;
  if (a3)
  {
    v118 = 0u;
    v119 = 0u;
    v116 = 0u;
    v117 = 0u;
    unint64_t v91 = (void *)v88;
    v92 = (id)v88;
    v93 = [v92 countByEnumeratingWithState:&v116 objects:v142 count:16];
    if (!v93)
    {
      v103 = v92;
      goto LABEL_148;
    }

    v94 = v93;
    v95 = (void *)v86;
    v96 = *(void *)v117;
LABEL_119:
    v97 = 0LL;
    while (1)
    {
      if (*(void *)v117 != v96) {
        objc_enumerationMutation(v92);
      }
      v98 = *(void **)(*((void *)&v116 + 1) + 8 * v97);
      if (([v81 containsObject:v98] & 1) == 0)
      {
      }

      if (v94 == ++v97)
      {
        v94 = [v92 countByEnumeratingWithState:&v116 objects:v142 count:16];
        if (v94) {
          goto LABEL_119;
        }
        v103 = v92;
        uint64_t v84 = v111;
        int v86 = (uint64_t)v95;
        goto LABEL_148;
      }
    }
  }

  unint64_t v91 = (void *)v88;
  v114 = 0u;
  v115 = 0u;
  v112 = 0u;
  v113 = 0u;
  v92 = (id)v86;
  v99 = [v92 countByEnumeratingWithState:&v112 objects:v141 count:16];
  if (v99)
  {
    v100 = v99;
    v95 = (void *)v86;
    v101 = *(void *)v113;
LABEL_129:
    v102 = 0LL;
    while (1)
    {
      if (*(void *)v113 != v101) {
        objc_enumerationMutation(v92);
      }
      v98 = *(void **)(*((void *)&v112 + 1) + 8 * v102);
      if (([v81 containsObject:v98] & 1) == 0)
      {
      }

      if (v100 == ++v102)
      {
        v100 = [v92 countByEnumeratingWithState:&v112 objects:v141 count:16];
        if (v100) {
          goto LABEL_129;
        }
        int v86 = (uint64_t)v92;
        uint64_t v84 = v111;
        goto LABEL_147;
      }
    }

          goto LABEL_74;
        }

        ne_log_obj();
        CFErrorRef v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v385 = 0;
          _os_log_error_impl( &dword_1876B1000,  v90,  OS_LOG_TYPE_ERROR,  "Failed to generate local Child crypto values",  v385,  2u);
        }

        uint64_t v89 = @"Failed to generate local Child crypto values";
      }

      else
      {
        ne_log_obj();
        int v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v385 = 0;
          _os_log_error_impl(&dword_1876B1000, v81, OS_LOG_TYPE_ERROR, "Failed to generate Child SA SPI", v385, 2u);
        }

        uint64_t v89 = @"Failed to generate Child SA SPI";
      }

      ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(v89, v82, v83, v84, v85, v86, v87, v88, v358);
      -[NEIKEv2ChildSA setState:error:]((uint64_t)v5, 3uLL, ErrorCrypto);

      -[NEIKEv2Session reportState](a1, v92);
      -[NEIKEv2Session resetChild:]((char *)a1, v5);
LABEL_92:

      goto LABEL_93;
    }

    ne_log_obj();
    unint64_t v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)v385 = 0;
      _os_log_debug_impl( &dword_1876B1000,  v71,  OS_LOG_TYPE_DEBUG,  "No eligible configuration for new Child SAs",  v385,  2u);
    }

    +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]( (uint64_t)&OBJC_CLASS___NEIKEv2CreateChildPacket,  v7,  0x23uLL,  0LL);
    uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue();
    if (v72)
    {
      if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v72, 0LL) & 1) != 0)
      {
        uint64_t v80 = 0LL;
LABEL_59:

        -[NEIKEv2Session reportState](a1, v102);
        -[NEIKEv2Session resetChild:]((char *)a1, 0LL);

        goto LABEL_92;
      }

      v101 = (void *)NEIKEv2CreateErrorFailedToSend( @"create child SA refusal (no eligible configuration)",  v73,  v74,  v75,  v76,  v77,  v78,  v79,  v358);
    }

    else
    {
      ne_log_obj();
      v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v385 = 0;
        _os_log_error_impl( &dword_1876B1000,  v93,  OS_LOG_TYPE_ERROR,  "Failed to create Create Child SA packet",  v385,  2u);
      }

      v101 = (void *)NEIKEv2CreateErrorInternal( @"Failed to create Create Child SA packet",  v94,  v95,  v96,  v97,  v98,  v99,  v100,  v358);
    }

    uint64_t v80 = v101;

    goto LABEL_59;
  }

        LOBYTE(v76) = 0;
LABEL_74:
        v68 |= v76;
        if (++v69 >= v66)
        {
          unint64_t v77 = [v64 countByEnumeratingWithState:&v182 objects:v204 count:16];
          if (!v77)
          {
            uint64_t v21 = v158;
            uint64_t v34 = v152;
            goto LABEL_84;
          }

          int v66 = v77;
          uint64_t v69 = 0LL;
        }
      }

      LODWORD(v73) = 0;
LABEL_65:
      buf[0] = 3;
      buf[4] = 1;
      *(_WORD *)&buf[6] = bswap32(v73) >> 16;
      *(_WORD *)&buf[2] = 2048;
      -[os_log_s appendBytes:length:](v63, "appendBytes:length:", buf, 8LL);
      ++v67;
      if (!v72) {
        goto LABEL_73;
      }
      goto LABEL_71;
    }

    ne_log_obj();
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v34, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl( &dword_1876B1000,  (os_log_t)v34,  OS_LOG_TYPE_ERROR,  "IKE SA proposal missing encryption protocol",  buf,  2u);
    }

LABEL_147:
            goto LABEL_148;
          }

          ne_log_obj();
          v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
          {
LABEL_148:
            uint64_t v2 = 0x189604000LL;
LABEL_149:

            CFRelease(v112);
            if (*(void *)trust) {
              CFRelease(*(CFTypeRef *)trust);
            }
            goto LABEL_23;
          }

          v143 = (void *)objc_opt_class();
          *(_DWORD *)buf = 138412290;
          v170 = v143;
          v117 = v143;
          v118 = "%@ failed to find the trust chain for the client certificate";
        }
      }

      else
      {
        ne_log_obj();
        v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v115, OS_LOG_TYPE_ERROR)) {
          goto LABEL_149;
        }
        v130 = (void *)objc_opt_class();
        *(_DWORD *)buf = 138412290;
        v170 = v130;
        v117 = v130;
        v118 = "%@ failed to allocate certificate array";
      }
    }

    _os_log_error_impl(&dword_1876B1000, v115, OS_LOG_TYPE_ERROR, v118, buf, 0xCu);

    goto LABEL_148;
  }

  ne_log_obj();
  v128 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
  {
    v144 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412290;
    v170 = v144;
    v145 = v144;
    _os_log_error_impl(&dword_1876B1000, v128, OS_LOG_TYPE_ERROR, "%@ SecPolicyCreateBasicX509 failed", buf, 0xCu);
  }

LABEL_23:
  if (result) {
    CFRelease(result);
  }

  if (!v19) {
    goto LABEL_41;
  }
  [(id)v1 eapSettings];
  unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
  [v32 clientTrustChainReference];
  int v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {

    goto LABEL_101;
  }

  [(id)v1 eapSettings];
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
  [v34 clientTrustChainReference];
  uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
  int v36 = [v35 count];

  if (!v36)
  {
LABEL_101:
    ne_log_obj();
    uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      v119 = (void *)objc_opt_class();
      *(_DWORD *)trust = 138412290;
      *(void *)&trust[4] = v119;
      v120 = v119;
      _os_log_error_impl(&dword_1876B1000, v37, OS_LOG_TYPE_ERROR, "%@ invalid client trust chain", trust, 0xCu);
    }

LABEL_133:
    ne_log_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_53;
    }
    v141 = (void *)objc_opt_class();
    *(_DWORD *)buf = 138412290;
    v170 = v141;
    uint64_t v56 = v141;
    unint64_t v57 = "%@ invalid client trust chain";
    goto LABEL_89;
  }

  objc_msgSend(MEMORY[0x189603FC8], "dictionaryWithObjectsAndKeys:", v28, v154, *MEMORY[0x18960BB40], v29, 0);
  uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  *(_OWORD *)certificateRef = 0u;
  v164 = 0u;
  v165 = 0u;
  v166 = 0u;
  [(id)v1 eapSettings];
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
  [v38 clientTrustChainReference];
  int v39 = (void *)objc_claimAutoreleasedReturnValue();

  unint64_t v40 = [v39 countByEnumeratingWithState:certificateRef objects:buf count:16];
  if (!v40) {
    goto LABEL_40;
  }
  unint64_t v41 = v40;
  unint64_t v42 = *(void *)v164;
  while (2)
  {
    for (j = 0LL; j != v41; ++j)
    {
      if (*(void *)v164 != v42) {
        objc_enumerationMutation(v39);
      }
      uint64_t v44 = (void *)*((void *)certificateRef[1] + j);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0 || ![v44 length]) {
        goto LABEL_132;
      }
      cf = 0LL;
      -[os_log_s setObject:forKeyedSubscript:](v37, "setObject:forKeyedSubscript:", v44, obj);
      if (SecItemCopyMatching(v37, &cf))
      {
        ne_log_obj();
        v136 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
        {
          v137 = (void *)objc_opt_class();
          *(_DWORD *)trust = 138412290;
          *(void *)&trust[4] = v137;
          v138 = v137;
          v139 = "%@ failed to find the certificate item in the keychain.";
          goto LABEL_152;
        }

          goto LABEL_139;
        }

        v110 = objc_getProperty(self, v109, 152LL, 1);
        v112 = v110;
        if (v110) {
          v110 = objc_getProperty(v110, v111, 24LL, 1);
        }
        v114 = v110;
        if (v37) {
          v115 = objc_getProperty(v37, v113, 88LL, 1);
        }
        else {
          v115 = 0LL;
        }
        v116 = v115;
        [v116 configurationReply];
        v117 = (void *)objc_claimAutoreleasedReturnValue();
        v118 = v114;
        v119 = v117;
        objc_opt_self();
        v251 = v6;
        v254 = v119;
        if (v118 && v118[1] == 1LL)
        {
          if (v119 && v119[1] == 2LL)
          {
            v246 = v116;
            v248 = v112;
            v249 = v37;
            v250 = v40;
            v252 = a1;
            v120 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
            if (v120) {
              v120->_configurationType = 2LL;
            }
            v245 = v120;
            v121 = objc_alloc_init(MEMORY[0x189603FA8]);
            v268 = 0u;
            v269 = 0u;
            v270 = 0u;
            v271 = 0u;
            v247 = v118;
            obj = objc_getProperty(v118, v122, 16LL, 1);
            v123 = [obj countByEnumeratingWithState:&v268 objects:buf count:16];
            if (v123)
            {
              v125 = v123;
              v257 = *(void *)v269;
              do
              {
                for (i = 0LL; i != v125; ++i)
                {
                  if (*(void *)v269 != v257) {
                    objc_enumerationMutation(obj);
                  }
                  v264 = 0u;
                  v265 = 0u;
                  v266 = 0u;
                  v267 = 0u;
                  v127 = v119;
                  v128 = objc_getProperty(v119, v124, 16LL, 1);
                  v129 = [v128 countByEnumeratingWithState:&v264 objects:v272 count:16];
                  if (v129)
                  {
                    v130 = v129;
                    v131 = *(void *)v265;
                    do
                    {
                      for (j = 0LL; j != v130; ++j)
                      {
                        if (*(void *)v265 != v131) {
                          objc_enumerationMutation(v128);
                        }
                        v133 = *(void **)(*((void *)&v264 + 1) + 8 * j);
                      }

                      v130 = [v128 countByEnumeratingWithState:&v264 objects:v272 count:16];
                    }

                    while (v130);
                  }

                  v119 = v127;
                }

                v125 = [obj countByEnumeratingWithState:&v268 objects:buf count:16];
              }

              while (v125);
            }

            v135 = v245;
            if (v245) {
              objc_setProperty_atomic(v245, v134, v121, 16LL);
            }
            a1 = v252;
            uint64_t v37 = v249;
            unint64_t v40 = v250;
            v103 = self;
            v118 = v247;
            v106 = v248;
            v136 = v246;
            goto LABEL_86;
          }

          v136 = v116;
          ne_log_obj();
          v121 = (id)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled((os_log_t)v121, OS_LOG_TYPE_FAULT))
          {
LABEL_153:
            v103 = self;
            v106 = v112;
            v135 = 0LL;
LABEL_86:

            if (v37) {
              objc_setProperty_atomic(v37, v137, v135, 488LL);
            }

            CFIndex v6 = v251;
            goto LABEL_89;
          }

          *(_DWORD *)buf = 136315138;
          v274 = "+[NEIKEv2ConfigurationMessage copyConfigurationForRequest:reply:]";
          v242 = "%s called with null (reply.configurationType == NEIKEv2ConfigurationTypeReply)";
        }

        else
        {
          v136 = v116;
          ne_log_obj();
          v121 = (id)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled((os_log_t)v121, OS_LOG_TYPE_FAULT)) {
            goto LABEL_153;
          }
          *(_DWORD *)buf = 136315138;
          v274 = "+[NEIKEv2ConfigurationMessage copyConfigurationForRequest:reply:]";
          v242 = "%s called with null (request.configurationType == NEIKEv2ConfigurationTypeRequest)";
        }

        _os_log_fault_impl(&dword_1876B1000, (os_log_t)v121, OS_LOG_TYPE_FAULT, v242, buf, 0xCu);
        goto LABEL_153;
      }
    }

    else
    {
      unint64_t v41 = 0;
      if (v38) {
        goto LABEL_27;
      }
    }

    if ((v41 & 1) != 0) {
      goto LABEL_27;
    }
    ne_log_obj();
    v241 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v241, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v274 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthPart2AsResponderCopyErrorForIKESA:childSA:errorCodeToSend:]";
      _os_log_fault_impl(&dword_1876B1000, v241, OS_LOG_TYPE_FAULT, "%s called with null childSA", buf, 0xCu);
    }

    v240 = @"validateAuthPart2AsResponder called with nil childSA";
LABEL_149:
    uint64_t v3 = (id)NEIKEv2CreateErrorInternal(v240, v233, v234, v235, v236, v237, v238, v239, v243);
    goto LABEL_52;
  }

  uint64_t v3 = (id)ErrorInternal;
LABEL_2:
  uint64_t v7 = 24LL;
LABEL_3:
  ne_log_obj();
  id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    v150 = (const char *)a1[4];
    *(_DWORD *)buf = 138412290;
    v274 = v150;
    _os_log_error_impl( &dword_1876B1000,  v8,  OS_LOG_TYPE_ERROR,  "%@ Failed to process IKE Auth packet (receive p2)",  buf,  0xCu);
  }

  uint64_t v9 = +[NEIKEv2IKEAuthPacket createIKEAuthResponse:refusalError:]( (uint64_t)&OBJC_CLASS___NEIKEv2IKEAuthPacket,  a1[6],  v7);
  if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1[4], v9, 0LL) & 1) != 0)
  {
    -[NEIKEv2IKESA setState:error:]((uint64_t)a1[5], 3uLL, v3);
    -[NEIKEv2Session reportState](a1[4], v11);
  }

  else
  {
    uint64_t v12 = a1[4];
    if (v12) {
      uint64_t v12 = objc_getProperty(v12, v10, 336LL, 1);
    }
    uint64_t v13 = v12;
    ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"AUTH refusal p2 %@",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  (uint64_t)v3);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v13, 3uLL, ErrorFailedToSend);

    -[NEIKEv2Session reportState](a1[4], v22);
    -[NEIKEv2Session resetAll]((uint64_t)a1[4], v23);
  }

LABEL_11:
}

    objc_getProperty((id)a1, v123, 112LL, 1);
    v226 = (void *)objc_claimAutoreleasedReturnValue();
    v228 = v226;
    if (v226) {
      v226 = objc_getProperty(v226, v227, 24LL, 1);
    }
    v229 = v226;
    objc_setProperty_atomic((id)v5, v230, v229, 136LL);

    v231 = -[NEIKEv2Packet copyNotification:]((void *)a1, (const char *)0x402F);
    v141 = v231;
    if (v231)
    {
      v233 = objc_getProperty(v231, v232, 32LL, 1);
      v234 = +[NEIKEv2Crypto copySignHashSetForData:]((uint64_t)&OBJC_CLASS___NEIKEv2Crypto, v233);
      objc_storeStrong((id *)(v5 + 112), v234);
    }

    v235 = objc_getProperty((id)v5, v232, 88LL, 1);
    [v235 authenticationProtocol];
    v236 = (void *)objc_claimAutoreleasedReturnValue();
    v237 = [v236 isSecurePassword];

    if (v237)
    {
      v238 = -[NEIKEv2Packet copyNotification:]((void *)a1, (const char *)0x4028);
      if (!v238)
      {
        ne_log_obj();
        v347 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v347, OS_LOG_TYPE_ERROR))
        {
          v358 = (char *)[(id)a1 copyShortDescription];
          buf = 138412290;
          v384 = v358;
          _os_log_error_impl( &dword_1876B1000,  v347,  OS_LOG_TYPE_ERROR,  "%@ Did not receive secure password methods notify",  (uint8_t *)&buf,  0xCu);
        }

        v267 = @"Did not receive secure password methods notify";
        goto LABEL_183;
      }

      selfa = v238;
      v240 = objc_getProperty(v238, v239, 32LL, 1);
      if ([v240 length] == 2)
      {
        v365 = v240;
        [v240 getBytes:&v374 length:2];
        v241 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
        v242 = -[NEIKEv2AuthenticationProtocol initWithSecurePassword:]( v241,  "initWithSecurePassword:",  bswap32(v374) >> 16);
        v244 = objc_getProperty((id)v5, v243, 88LL, 1);
        [v244 authenticationProtocol];
        v245 = (void *)objc_claimAutoreleasedReturnValue();
        v246 = -[NEIKEv2AuthenticationProtocol isEqual:](v242, "isEqual:", v245);

        if (v246)
        {
          objc_storeStrong((id *)(v5 + 104), v242);

          goto LABEL_142;
        }

        ne_log_obj();
        v295 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v295, OS_LOG_TYPE_ERROR))
        {
          v324 = (char *)[(id)a1 copyShortDescription];
          v326 = objc_getProperty((id)v5, v325, 88LL, 1);
          [v326 authenticationProtocol];
          v327 = (void *)objc_claimAutoreleasedReturnValue();
          buf = 138412802;
          v384 = v324;
          v385 = 2112;
          v386 = v242;
          v387 = 2112;
          v388 = (uint64_t)v327;
          _os_log_error_impl( &dword_1876B1000,  v295,  OS_LOG_TYPE_ERROR,  "%@ Secure password method %@ does not match configured %@",  (uint8_t *)&buf,  0x20u);
        }

        v297 = objc_getProperty((id)v5, v296, 88LL, 1);
        [v297 authenticationProtocol];
        v362 = (void *)objc_claimAutoreleasedReturnValue();
        v305 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Secure password method %@ does not match configured %@",  v298,  v299,  v300,  v301,  v302,  v303,  v304,  (uint64_t)v242);
        -[NEIKEv2IKESA setState:error:](v5, 3uLL, v305);
      }

      else
      {
        ne_log_obj();
        v348 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v348, OS_LOG_TYPE_ERROR))
        {
          v359 = (char *)[(id)a1 copyShortDescription];
          v360 = [v240 length];
          buf = 138412546;
          v384 = v359;
          v385 = 2048;
          v386 = (NEIKEv2AuthenticationProtocol *)v360;
          _os_log_error_impl( &dword_1876B1000,  v348,  OS_LOG_TYPE_ERROR,  "%@ Secure password methods notify has incorrect length %zu != sizeof(uint16_t)",  (uint8_t *)&buf,  0x16u);
        }

        v349 = [v240 length];
        v357 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Secure password methods notify has incorrect length %zu != sizeof(uint16_t)",  v350,  v351,  v352,  v353,  v354,  v355,  v356,  v349);
        -[NEIKEv2IKESA setState:error:](v5, 3uLL, v357);
      }

      goto LABEL_127;
    }

LABEL_131:
LABEL_132:
        goto LABEL_133;
      }

      if (!cf)
      {
        ne_log_obj();
        v136 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
        {
          v140 = (void *)objc_opt_class();
          *(_DWORD *)trust = 138412290;
          *(void *)&trust[4] = v140;
          v138 = v140;
          v139 = "%@ found nil certificate item in the keychain.";
          goto LABEL_152;
        }

        goto LABEL_131;
      }

      uint64_t v45 = CFGetTypeID(cf);
      TypeID = SecCertificateGetTypeID();
      CFRelease(cf);
      if (v45 != TypeID)
      {
        ne_log_obj();
        v136 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v136, OS_LOG_TYPE_ERROR)) {
          goto LABEL_131;
        }
        v148 = (void *)objc_opt_class();
        *(_DWORD *)trust = 138412290;
        *(void *)&trust[4] = v148;
        v138 = v148;
        v139 = "%@ failed to find valid certificate item in the keychain.";
LABEL_152:
        _os_log_error_impl(&dword_1876B1000, v136, OS_LOG_TYPE_ERROR, v139, trust, 0xCu);

        goto LABEL_131;
      }
    }

    unint64_t v41 = [v39 countByEnumeratingWithState:certificateRef objects:buf count:16];
    if (v41) {
      continue;
    }
    break;
  }

    if ([v85 method]) {
      [v71 addObject:v85];
    }

    int v51 = v99;
    int v46 = v95;
    uint64_t v72 = v97;
    uint64_t v73 = v98;
    goto LABEL_134;
  }

  id v75 = (uint64_t)v80;
LABEL_143:

  ne_log_large_obj();
  CFErrorRef v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  int v46 = v95;
  if (os_log_type_enabled(v90, OS_LOG_TYPE_INFO))
  {
    [(id)a1 additionalKEMProtocols];
    unint64_t v91 = (char *)objc_claimAutoreleasedReturnValue();
    [v8 additionalKEMProtocols];
    v92 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412546;
    v132 = v91;
    v133 = 2112;
    v134 = v92;
    _os_log_impl( &dword_1876B1000,  v90,  OS_LOG_TYPE_INFO,  "Failed to match Additional Key Exchange methods (%@ vs %@)",  buf,  0x16u);
  }

  v124 = 0;
LABEL_146:

  int v58 = v93;
  uint64_t v44 = v94;
LABEL_147:

  a1 = v124;
LABEL_51:

  return a1;
}

LABEL_108:
          break;
        }

        if (!cf)
        {
          ne_log_obj();
          v121 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
          {
            v125 = (void *)objc_opt_class();
            *(_DWORD *)trust = 138412290;
            *(void *)&trust[4] = v125;
            v123 = v125;
            v124 = "%@ found nil certificate item in the keychain.";
            goto LABEL_136;
          }

          goto LABEL_108;
        }

        id v75 = CFGetTypeID(cf);
        uint64_t v76 = SecCertificateGetTypeID();
        CFRelease(cf);
        if (v75 != v76)
        {
          ne_log_obj();
          v121 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v121, OS_LOG_TYPE_ERROR)) {
            goto LABEL_108;
          }
          v142 = (void *)objc_opt_class();
          *(_DWORD *)trust = 138412290;
          *(void *)&trust[4] = v142;
          v123 = v142;
          v124 = "%@ failed to find valid certificate item in the keychain.";
LABEL_136:
          _os_log_error_impl(&dword_1876B1000, v121, OS_LOG_TYPE_ERROR, v124, trust, 0xCu);

          goto LABEL_108;
        }

        if (v70 == ++v73)
        {
          int v70 = [v68 countByEnumeratingWithState:certificateRef objects:buf count:16];
          if (v70) {
            goto LABEL_61;
          }
          goto LABEL_71;
        }
      }

      ne_log_obj();
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_ERROR)) {
        goto LABEL_53;
      }
      v126 = (void *)objc_opt_class();
      *(_DWORD *)buf = 138412290;
      v170 = v126;
      uint64_t v56 = v126;
      unint64_t v57 = "%@ invalid trusted server certificate references";
      goto LABEL_89;
    }

LABEL_109:
  unint64_t v40 = v400;
LABEL_110:

  -[NEIKEv2Session reportPrivateNotifiesInPacket:]((id *)a1[5], v40);
  v105 = (void *)a1[5];
  if (v105) {
    v105 = (void *)v105[49];
  }
  v106 = v105;
  v107 = [v106 count];

  if (v107)
  {
    v109 = (void *)a1[5];
    if (v109) {
      v110 = (void *)v109[49];
    }
    else {
      v110 = 0LL;
    }
    v111 = v110;
    -[NEIKEv2Session reportPrivateNotifies:](v109, v111);

    -[NEIKEv2Session setPendingPrivateNotifies:](a1[5], 0LL);
  }

  v112 = *(void *)(*(void *)(a1[7] + 8) + 40LL);
  if (v112 && (-[NEIKEv2ChildSA generateAllValues](v112) & 1) == 0)
  {
    ne_log_obj();
    v240 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v240, OS_LOG_TYPE_ERROR))
    {
      v283 = a1[5];
      LODWORD(v441) = 138412290;
      *(void *)((char *)&v441 + 4) = v283;
      _os_log_error_impl( &dword_1876B1000,  v240,  OS_LOG_TYPE_ERROR,  "%@ Failed to generate Child SA crypto values (connect)",  (uint8_t *)&v441,  0xCu);
    }

    __int16 v87 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
    v242 = (id)a1[5];
    if (v242) {
      v242 = objc_getProperty(v242, v241, 368LL, 1);
    }
    uint64_t v89 = v242;
    v415[0] = MEMORY[0x1895F87A8];
    v415[1] = 3221225472LL;
    v415[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_157;
    v415[3] = &unk_18A08D468;
    v415[4] = a1[5];
    CFErrorRef v90 = v415;
    goto LABEL_202;
  }

  -[NEIKEv2Session finishConfigurationEstablishment]((_BYTE *)a1[5], v108);
  -[NEIKEv2Session reportConfiguration]((void *)a1[5], v113);
  v114 = (void *)a1[5];
  if (v114)
  {
    [MEMORY[0x1896079D8] processInfo];
    v115 = (void *)objc_claimAutoreleasedReturnValue();
    [v115 processName];
    v116 = (void *)objc_claimAutoreleasedReturnValue();

    if (([&unk_18A0CFD90 containsObject:v116] & 1) == 0)
    {
      v118 = objc_getProperty(v114, v117, 336LL, 1);
      if (v118)
      {
        v120 = objc_getProperty(v118, v119, 96LL, 1);
        v122 = v120;
        if (v120) {
          v120 = objc_getProperty(v120, v121, 88LL, 1);
        }
      }

      else
      {
        v122 = 0LL;
        v120 = 0LL;
      }

      v123 = v120;
      [v123 description];
      v408 = (void *)objc_claimAutoreleasedReturnValue();

      v125 = objc_getProperty(v114, v124, 336LL, 1);
      if (v125)
      {
        v127 = objc_getProperty(v125, v126, 96LL, 1);
        v129 = v127;
        if (v127) {
          v127 = objc_getProperty(v127, v128, 96LL, 1);
        }
      }

      else
      {
        v129 = 0LL;
        v127 = 0LL;
      }

      v130 = v127;
      [v130 description];
      v407 = (void *)objc_claimAutoreleasedReturnValue();

      v132 = objc_getProperty(v114, v131, 336LL, 1);
      if (v132)
      {
        v134 = objc_getProperty(v132, v133, 96LL, 1);
        v136 = v134;
        if (v134) {
          v134 = objc_getProperty(v134, v135, 104LL, 1);
        }
      }

      else
      {
        v136 = 0LL;
        v134 = 0LL;
      }

      v137 = v134;
      [v137 description];
      v404 = (void *)objc_claimAutoreleasedReturnValue();

      v139 = objc_getProperty(v114, v138, 336LL, 1);
      if (v139)
      {
        v141 = objc_getProperty(v139, v140, 96LL, 1);
        v143 = v141;
        if (v141) {
          v141 = objc_getProperty(v141, v142, 112LL, 1);
        }
      }

      else
      {
        v143 = 0LL;
        v141 = 0LL;
      }

      v144 = v141;
      [v144 description];
      v401 = (void *)objc_claimAutoreleasedReturnValue();

      v146 = objc_getProperty(v114, v145, 336LL, 1);
      v148 = v116;
      if (v146) {
        v146 = objc_getProperty(v146, v147, 144LL, 1);
      }
      v149 = v146;
      v150 = (void *)MEMORY[0x189604A88];
      v151 = (void *)MEMORY[0x189604A80];
      if (v149) {
        v152 = (void *)MEMORY[0x189604A88];
      }
      else {
        v152 = (void *)MEMORY[0x189604A80];
      }
      v399 = v152;

      v154 = objc_getProperty(v114, v153, 336LL, 1);
      if (v154) {
        v154 = objc_getProperty(v154, v155, 280LL, 1);
      }
      v156 = v154;
      if (v156) {
        v157 = v150;
      }
      else {
        v157 = v151;
      }
      v398 = v157;
      v159 = -[NEIKEv2Session firstChildSA](v114, v158);
      v161 = v159;
      if (v159)
      {
        v162 = objc_getProperty(v159, v160, 56LL, 1);
        v164 = v162;
        if (v162) {
          v162 = objc_getProperty(v162, v163, 96LL, 1);
        }
      }

      else
      {
        v164 = 0LL;
        v162 = 0LL;
      }

      v165 = v162;
      [v165 description];
      v396 = (void *)objc_claimAutoreleasedReturnValue();
      v167 = -[NEIKEv2Session firstChildSA](v114, v166);
      v169 = v167;
      if (v167)
      {
        v170 = objc_getProperty(v167, v168, 56LL, 1);
        v172 = v170;
        if (v170) {
          v170 = objc_getProperty(v170, v171, 104LL, 1);
        }
      }

      else
      {
        v172 = 0LL;
        v170 = 0LL;
      }

      v173 = v170;
      [v173 description];
      v394 = (void *)objc_claimAutoreleasedReturnValue();

      v175 = objc_getProperty(v114, v174, 336LL, 1);
      if (v175) {
        v176 = (void *)v175[54];
      }
      else {
        v176 = 0LL;
      }
      v177 = v176;
      [v177 description];
      v392 = (void *)objc_claimAutoreleasedReturnValue();

      v179 = objc_getProperty(v114, v178, 336LL, 1);
      if (v179) {
        v180 = (void *)v179[55];
      }
      else {
        v180 = 0LL;
      }
      v181 = v180;
      [v181 description];
      v391 = (void *)objc_claimAutoreleasedReturnValue();

      v183 = objc_getProperty(v114, v182, 336LL, 1);
      if (v183)
      {
        v185 = objc_getProperty(v183, v184, 448LL, 1);
        v187 = v185;
        if (v185)
        {
          objc_msgSend(objc_getProperty(v185, v186, 160, 1), "description");
          v387 = (void *)objc_claimAutoreleasedReturnValue();
          goto LABEL_155;
        }
      }

      else
      {
        v187 = 0LL;
      }

      v387 = 0LL;
LABEL_155:

      v188 = (void *)MEMORY[0x189607968];
      v190 = objc_getProperty(v114, v189, 336LL, 1);
      if (v190) {
        v190 = objc_getProperty(v190, v191, 128LL, 1);
      }
      v192 = v190;
      objc_msgSend(v188, "numberWithUnsignedInteger:", objc_msgSend(v192, "length"));
      v193 = (void *)objc_claimAutoreleasedReturnValue();

      v194 = (void *)MEMORY[0x189607968];
      v196 = objc_getProperty(v114, v195, 336LL, 1);
      if (v196) {
        v196 = objc_getProperty(v196, v197, 136LL, 1);
      }
      v198 = v196;
      objc_msgSend(v194, "numberWithUnsignedInteger:", objc_msgSend(v198, "length"));
      v199 = (void *)objc_claimAutoreleasedReturnValue();

      *(void *)&v441 = MEMORY[0x1895F87A8];
      *((void *)&v441 + 1) = 3221225472LL;
      v442 = __48__NEIKEv2Session_sendAnalyticsOfChosenProtocols__block_invoke;
      v443 = &unk_18A08D8C0;
      v444 = v408;
      v445 = v407;
      v446 = v404;
      v447 = v401;
      v448 = v399;
      v449 = v398;
      v450 = v396;
      v451 = v394;
      v116 = v148;
      v452 = v392;
      v453 = v391;
      v454 = v387;
      v455 = v193;
      v456 = v199;
      v457 = v148;
      v390 = v199;
      v389 = v193;
      v388 = v387;
      v200 = v391;
      v393 = v392;
      v395 = v394;
      v397 = v396;
      v201 = v398;
      v202 = v399;
      v203 = v401;
      v204 = v404;
      v205 = v407;
      v206 = v408;
      AnalyticsSendEventLazy();

      uint64_t v3 = self;
      a1 = v403;
    }
  }

  -[NEIKEv2IKESA setLocalAuthProtocolUsed:](a1[4], 0LL);
  -[NEIKEv2IKESA setRemoteAuthProtocolUsed:](a1[4], 0LL);
  -[NEIKEv2IKESA clearAuthenticationSecrets]((void *)a1[4], v207);
  v208 = *(void **)(*(void *)(a1[7] + 8) + 40LL);
  if (v208 && (-[NEIKEv2Session installChildSA:](a1[5], v208) & 1) == 0)
  {
    ne_log_obj();
    v243 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v243, OS_LOG_TYPE_ERROR))
    {
      v287 = a1[5];
      LODWORD(v441) = 138412290;
      *(void *)((char *)&v441 + 4) = v287;
      _os_log_error_impl( &dword_1876B1000,  v243,  OS_LOG_TYPE_ERROR,  "%@ Failed to install Child SA (connect)",  (uint8_t *)&v441,  0xCu);
    }

    __int16 v87 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
    v245 = (id)a1[5];
    if (v245) {
      v245 = objc_getProperty(v245, v244, 368LL, 1);
    }
    uint64_t v89 = v245;
    v414[0] = MEMORY[0x1895F87A8];
    v414[1] = 3221225472LL;
    v414[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_160;
    v414[3] = &unk_18A08D468;
    v414[4] = a1[5];
    CFErrorRef v90 = v414;
    goto LABEL_202;
  }

  v209 = a1[5];
  if (!v209) {
    goto LABEL_212;
  }
  WeakRetained = objc_loadWeakRetained((id *)(v209 + 352));

  if (!WeakRetained) {
    goto LABEL_212;
  }
  v412 = 0u;
  v413 = 0u;
  v410 = 0u;
  v411 = 0u;
  v212 = (void *)a1[6];
  if (v212 && (v213 = objc_getProperty(v212, v211, 152LL, 1)) != 0LL)
  {
    v215 = v213;
    v216 = objc_getProperty(v213, v214, 24LL, 1);
    v218 = v216;
    if (v216) {
      v216 = objc_getProperty(v216, v217, 16LL, 1);
    }
  }

  else
  {
    v218 = 0LL;
    v215 = 0LL;
    v216 = 0LL;
  }

  v219 = v216;

  v220 = [v219 countByEnumeratingWithState:&v410 objects:v420 count:16];
  if (!v220)
  {

    goto LABEL_212;
  }

  v221 = v220;
  v222 = 0;
  v223 = *(void *)v411;
  while (2)
  {
    v224 = 0LL;
    while (2)
    {
      if (*(void *)v411 != v223) {
        objc_enumerationMutation(v219);
      }
      v225 = *(void **)(*((void *)&v410 + 1) + 8 * v224);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        [v225 address];
        v227 = (void *)objc_claimAutoreleasedReturnValue();
        v228 = (void *)a1[5];
        if (v228)
        {
          v229 = objc_getProperty(v228, v226, 336LL, 1);
          v231 = v229;
          if (v229)
          {
            v232 = v227;
            v233 = 64LL;
            goto LABEL_182;
          }

          goto LABEL_183;
        }
            }

            else
            {
              ne_log_obj();
              id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v14 = (os_log_s *)v81;
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412290;
                CFErrorRef v90 = (const char *)a1;
                _os_log_error_impl( &dword_1876B1000,  v27,  OS_LOG_TYPE_ERROR,  "%@ Discarding undecrypted fragment",  buf,  0xCu);
              }
            }

id createHotspotNetworkArray(const __CFArray *a1)
{
  id v2 = objc_alloc_init(MEMORY[0x189603FA8]);
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v4 = Count;
    for (CFIndex i = 0LL; i != v4; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      id v7 = -[NEHotspotNetwork initWithNetwork:](objc_alloc(&OBJC_CLASS___NEHotspotNetwork), ValueAtIndex);
      [v2 addObject:v7];
    }
  }

  return v2;
}

__CFString *NEIKEv2DigitalSignatureAlgorithmCreateString(unint64_t a1)
{
  if (a1 >= 0xC) {
    return (__CFString *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"Unknown[%lld]", a1);
  }
  else {
    return off_18A08C9C8[a1];
  }
}

CFStringRef NEIKEv2SecurePasswordMethodCreateString(uint64_t a1)
{
  uint64_t v1 = a1 + 1;
  BOOL result = @"Invalid";
  switch(v1)
  {
    case 0LL:
      BOOL result = @"Placeholder";
      break;
    case 1LL:
      return result;
    case 2LL:
      BOOL result = @"PACE";
      break;
    case 3LL:
      BOOL result = @"AugPAKE";
      break;
    case 4LL:
      BOOL result = @"SecurePSK";
      break;
    default:
      if (@"Invalid" == (__CFString *)11001) {
        BOOL result = @"SPAKE2Plus";
      }
      else {
        BOOL result = (const __CFString *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"Unknown[%lld]",  @"Invalid");
      }
      break;
  }

  return result;
}

CFStringRef NEIKEv2AuthenticationMethodCreateString(uint64_t a1)
{
  BOOL result = @"None";
  switch(a1)
  {
    case 0LL:
      return result;
    case 1LL:
      BOOL result = @"RSASignature";
      break;
    case 2LL:
      BOOL result = @"SharedKey";
      break;
    case 3LL:
    case 4LL:
    case 5LL:
    case 6LL:
    case 7LL:
    case 8LL:
      goto LABEL_5;
    case 9LL:
      BOOL result = @"ECDSA256";
      break;
    case 10LL:
      BOOL result = @"ECDSA384";
      break;
    case 11LL:
      BOOL result = @"ECDSA521";
      break;
    case 12LL:
      BOOL result = @"GenericSecurePassword";
      break;
    case 13LL:
      BOOL result = @"NULL";
      break;
    case 14LL:
      BOOL result = @"DigitalSignature";
      break;
    default:
      if (a1 == 245) {
        BOOL result = @"RSAPSS";
      }
      else {
LABEL_5:
      }
        BOOL result = (const __CFString *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"Unknown[%lld]",  a1);
      break;
  }

  return result;
}

__CFString *NEIKEv2EncryptionTypeCreateString(unint64_t a1)
{
  if (a1 >= 0xA) {
    return (__CFString *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"Unknown[%lld]", a1);
  }
  else {
    return off_18A08CB68[a1];
  }
}

__CFString *NEIKEv2EncryptionWireTypeCreateString(unint64_t a1)
{
  if (a1 >= 0x20) {
    return (__CFString *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"Unknown[%lld]", a1);
  }
  else {
    return off_18A08CA68[a1];
  }
}

LABEL_22:
  objc_msgSend(v4, "setLifetimeSeconds:", -[NEIKEv2ChildSAProposal lifetimeSeconds](self, "lifetimeSeconds"));
  if (self)
  {
    proposalNumber = self->_proposalNumber;
    if (!v4) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  proposalNumber = 0;
  if (v4) {
LABEL_24:
  }
    v4[8] = proposalNumber;
LABEL_25:
  if (self) {
    Property = objc_getProperty(self, v38, 80LL, 1);
  }
  else {
    Property = 0LL;
  }
  unint64_t v42 = (void *)[Property copy];
  if (v4) {
    objc_setProperty_atomic(v4, v41, v42, 80LL);
  }

  if (self) {
    uint64_t v44 = objc_getProperty(self, v43, 88LL, 1);
  }
  else {
    uint64_t v44 = 0LL;
  }
  int v46 = (void *)[v44 copy];
  if (v4) {
    objc_setProperty_atomic(v4, v45, v46, 88LL);
  }

  if (self) {
    int v48 = objc_getProperty(self, v47, 96LL, 1);
  }
  else {
    int v48 = 0LL;
  }
  uint64_t v50 = (void *)[v48 copy];
  if (v4) {
    objc_setProperty_atomic(v4, v49, v50, 96LL);
  }

  if (self) {
    uint64_t v52 = objc_getProperty(self, v51, 104LL, 1);
  }
  else {
    uint64_t v52 = 0LL;
  }
  int v54 = (void *)[v52 copy];
  if (v4) {
    objc_setProperty_atomic(v4, v53, v54, 104LL);
  }

  if (self) {
    uint64_t v56 = objc_getProperty(self, v55, 112LL, 1);
  }
  else {
    uint64_t v56 = 0LL;
  }
  int v58 = (void *)[v56 copy];
  if (v4) {
    objc_setProperty_atomic(v4, v57, v58, 112LL);
  }

  -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](self);
  uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();

  if (v59)
  {
    uint64_t v60 = objc_alloc(MEMORY[0x189603F68]);
    -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](self);
    uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
    int v62 = (void *)[v60 initWithDictionary:v61 copyItems:1];
    -[NEIKEv2IKESAProposal setChosenAdditionalKEMProtocols:](v4, v62);
  }

  return v4;
}

    goto LABEL_23;
  }

  uint64_t v12 = objc_getProperty((id)a1, v11, 96LL, 1);
  -[NEIKEv2IKESAProposal prfProtocol](v12, v13);
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2PRFProtocol ccDigest](v14);
  [v5 bytes];
  [v5 length];
  unint64_t v15 = CCHmacCreate();

  if (!v15)
  {
    ne_log_obj();
    uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
      goto LABEL_22;
    }
    LOWORD(v50) = 0;
    uint64_t v45 = "CCHmacCreate failed";
    int64_t v47 = v44;
    int v48 = 2;
    goto LABEL_21;
  }

  unsigned __int16 v17 = objc_getProperty((id)a1, v16, 216LL, 1);
  objc_setProperty_atomic((id)a1, v18, v17, 224LL);

  objc_getProperty((id)a1, v19, 224LL, 1);
  int v20 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v21 = -[NEIKEv2IKESA deriveKeyFromPrimeKey:hmacContext:]((void *)a1, v20);
  objc_setProperty_atomic((id)a1, v22, v21, 216LL);

  unint64_t v24 = objc_getProperty((id)a1, v23, 216LL, 1);
  if (!v24) {
    goto LABEL_17;
  }
  objc_getProperty((id)a1, v25, 232LL, 1);
  int v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_setProperty_atomic((id)a1, v27, v26, 240LL);

  objc_getProperty((id)a1, v28, 240LL, 1);
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
  int v30 = -[NEIKEv2IKESA deriveKeyFromPrimeKey:hmacContext:]((void *)a1, v29);
  objc_setProperty_atomic((id)a1, v31, v30, 232LL);

  objc_getProperty((id)a1, v32, 232LL, 1);
  int v33 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v33) {
    goto LABEL_17;
  }
  objc_getProperty((id)a1, v34, 248LL, 1);
  uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_setProperty_atomic((id)a1, v36, v35, 256LL);

  objc_getProperty((id)a1, v37, 256LL, 1);
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
  int v39 = -[NEIKEv2IKESA deriveKeyFromPrimeKey:hmacContext:]((void *)a1, v38);
  objc_setProperty_atomic((id)a1, v40, v39, 248LL);

  objc_getProperty((id)a1, v41, 248LL, 1);
  unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v42)
  {
LABEL_17:
    CCHmacDestroy();
    -[NEIKEv2IKESA restorePrimeKeys]((void *)a1, v46);
LABEL_23:
    a1 = 0LL;
    goto LABEL_24;
  }

  ne_log_obj();
  char v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(v50) = 0;
    _os_log_debug_impl(&dword_1876B1000, v43, OS_LOG_TYPE_DEBUG, "Calculated PPK derivatives", (uint8_t *)&v50, 2u);
  }

  CCHmacDestroy();
  a1 = 1LL;
LABEL_24:

  return a1;
}

    int v16 = 0LL;
    goto LABEL_23;
  }

  if ((-[NEIKEv2InformationalPacket validateDeleteChild:]((uint64_t)v10, v8) & 1) == 0)
  {
    ne_log_obj();
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t v31 = 138412290;
      *(void *)&v31[4] = a1;
      uint64_t v14 = "%@ Failed to process Delete packet";
      goto LABEL_11;
    }

    goto LABEL_22;
  }

  if (v7) {
    +[NEIKEv2InformationalPacket createDeleteResponse:child:]( (uint64_t)&OBJC_CLASS___NEIKEv2InformationalPacket,  v10,  v7);
  }
  else {
    +[NEIKEv2InformationalPacket createInformationalResponse:ikeSA:]( (uint64_t)&OBJC_CLASS___NEIKEv2InformationalPacket,  v10,  0LL);
  }
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (!v13)
  {
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t v31 = 138412290;
      *(void *)&v31[4] = a1;
      _os_log_error_impl(&dword_1876B1000, v17, OS_LOG_TYPE_ERROR, "%@ Failed to create Delete packet", v31, 0xCu);
    }

    uint64_t v13 = 0LL;
    goto LABEL_22;
  }

  if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v13, 0LL) & 1) == 0)
  {
    if (a1) {
      int v18 = objc_getProperty(a1, v15, 336LL, 1);
    }
    else {
      int v18 = 0LL;
    }
    unint64_t v19 = v18;
    ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"delete child reply",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  *(uint64_t *)v31);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v19, 3uLL, ErrorFailedToSend);

    -[NEIKEv2Session reportState](a1, v28);
    -[NEIKEv2Session resetAll]((uint64_t)a1, v29);
    goto LABEL_22;
  }

  int v16 = 1LL;
LABEL_23:

  return v16;
}

    int v36 = 0LL;
    goto LABEL_38;
  }

  if (-[NEIKEv2Packet hasErrors](a1, v4))
  {
    BOOL v55 = 0u;
    uint64_t v56 = 0u;
    uint64_t v53 = 0u;
    int v54 = 0u;
    id v7 = (os_log_s *)objc_getProperty(a1, v6, 64LL, 1);
    id v8 = -[os_log_s countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v53,  v61,  16LL);
    if (v8)
    {
      uint64_t v9 = v8;
      CFStringRef v10 = *(void *)v54;
      while (2)
      {
        for (CFIndex i = 0LL; i != v9; ++i)
        {
          if (*(void *)v54 != v10) {
            objc_enumerationMutation(v7);
          }
          uint64_t v12 = *(const __CFString **)(*((void *)&v53 + 1) + 8 * i);
          if (v12 && (unint64_t)(v12->length - 1) <= 0x3FFE)
          {
            uint64_t v34 = (__CFString *)-[NEIKEv2NotifyPayload copyError](v12);
            ne_log_obj();
            uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              uint64_t v52 = (char *)objc_msgSend(a1, "copyShortDescription", (void)v53);
              *(_DWORD *)buf = 138412546;
              int v58 = v52;
              uint64_t v59 = 2112;
              uint64_t v60 = v34;
              _os_log_error_impl( &dword_1876B1000,  v35,  OS_LOG_TYPE_ERROR,  "%@ Update addresses received notify error %@",  buf,  0x16u);
            }

            -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, v34);
            goto LABEL_22;
          }
        }

        uint64_t v9 = -[os_log_s countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v53,  v61,  16LL);
        if (v9) {
          continue;
        }
        break;
      }
    }
  }

  id v7 = (os_log_s *)-[NEIKEv2Packet copyNotification:](a1, (const char *)0x4004);
  uint64_t v13 = -[NEIKEv2Packet copyNotification:](a1, (const char *)0x4005);
  unint64_t v15 = v13;
  if (v7 && v13)
  {
    -[NEIKEv2IKESA initiatorSPI](v5, v14);
    int v16 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESA responderSPI](v5, v17);
    int v18 = (void *)objc_claimAutoreleasedReturnValue();
    int v20 = objc_getProperty(v5, v19, 72LL, 1);
    uint64_t v21 = (void *)+[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  v16,  v18,  v20);

    -[NEIKEv2IKESA initiatorSPI](v5, v22);
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    BOOL v25 = -[NEIKEv2IKESA responderSPI](v5, v24);
    id v27 = objc_getProperty(v5, v26, 64LL, 1);
    uint64_t v28 = (void *)+[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  v23,  (void *)v25,  v27);

    int v30 = objc_getProperty(v7, v29, 32LL, 1);
    LOBYTE(v25) = [v21 isEqualToData:v30];

    if ((v25 & 1) != 0)
    {
      v5[15] = 0;
      ne_log_obj();
      unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_24;
      }
      unint64_t v32 = (char *)[a1 copyShortDescription];
      *(_DWORD *)buf = 138412290;
      int v58 = v32;
      int v33 = "%@ Detected no incoming NAT";
    }

    else
    {
      v5[15] = 1;
      ne_log_obj();
      unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_24;
      }
      unint64_t v32 = (char *)[a1 copyShortDescription];
      *(_DWORD *)buf = 138412290;
      int v58 = v32;
      int v33 = "%@ Detected incoming NAT";
    }

    _os_log_debug_impl(&dword_1876B1000, v31, OS_LOG_TYPE_DEBUG, v33, buf, 0xCu);

LABEL_24:
    uint64_t v38 = objc_getProperty(v15, v37, 32LL, 1);
    int v39 = [v28 isEqualToData:v38];

    if ((v39 & 1) != 0)
    {
      v5[14] = 0;
      ne_log_obj();
      unint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_28;
      }
      unint64_t v41 = (char *)[a1 copyShortDescription];
      *(_DWORD *)buf = 138412290;
      int v58 = v41;
      unint64_t v42 = "%@ Detected no outgoing NAT";
    }

    else
    {
      v5[14] = 1;
      ne_log_obj();
      unint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_28;
      }
      unint64_t v41 = (char *)[a1 copyShortDescription];
      *(_DWORD *)buf = 138412290;
      int v58 = v41;
      unint64_t v42 = "%@ Detected outgoing NAT";
    }

    _os_log_debug_impl(&dword_1876B1000, v40, OS_LOG_TYPE_DEBUG, v42, buf, 0xCu);

LABEL_28:
    uint64_t v44 = objc_getProperty(v5, v43, 80LL, 1);
    if ([v44 disableSwitchToNATTPorts])
    {
    }

    else
    {
      int64_t v47 = objc_getProperty(v5, v45, 88LL, 1);
      if ([v47 negotiateMOBIKE] & 1) != 0 || (v5[15])
      {
      }

      else
      {
        int v48 = v5[14];

        if ((v48 & 1) == 0) {
          goto LABEL_36;
        }
      }

      -[NEIKEv2IKESA switchToNATTraversalPorts]((uint64_t)v5, v46);
    }

        goto LABEL_23;
      }

      ne_log_obj();
      id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136315138;
      int v33 = "-[NEIKEv2IntermediatePacket authenticatedData]";
      uint64_t v23 = "%s called with null self.encryptedPayload.authenticatedHeaders";
    }

    else
    {
      ne_log_obj();
      id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136315138;
      int v33 = "-[NEIKEv2IntermediatePacket authenticatedData]";
      uint64_t v23 = "%s called with null self.encryptedPayload";
    }
}

  unsigned __int16 v17 = NEVirtualInterfaceWriteMultipleIPPackets( (uint64_t)v5->_interface,  (uint64_t)v5->_packetProtocols,  packetDataArray,  (uint64_t)v5->_packetLengths,  -[NSArray count](v4, "count")) != 0;
LABEL_30:
  objc_sync_exit(v5);

  return v17;
}

    uint64_t v9 = @"unknown";
    goto LABEL_23;
  }

  if (!internalPriority)
  {
    uint64_t v9 = @"default";
    goto LABEL_23;
  }

  uint64_t v9 = @"control";
LABEL_23:
  CFStringRef v10 = v9;
  [v7 appendPrettyObject:v10 withName:@"priority" andIndent:v5 options:a4];

  Property = objc_getProperty(self, v11, 32LL, 1);
LABEL_24:
  [v7 appendPrettyObject:Property withName:@"policies" andIndent:v5 options:a4];
  [v7 appendString:@"\n}"];
  return v7;
}

    ne_log_obj();
    id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__strerrbuf = 67109120;
      int v16 = v5;
      _os_log_fault_impl( &dword_1876B1000,  v8,  OS_LOG_TYPE_FAULT,  "Unknown priority level %u",  (uint8_t *)__strerrbuf,  8u);
    }
  }

  else
  {
    switch(a3)
    {
      case 1LL:
        goto LABEL_10;
      case 2LL:
        goto LABEL_16;
      case 3LL:
LABEL_6:
        uint64_t v5 = 300LL;
        break;
      case 4LL:
LABEL_17:
        uint64_t v5 = 301LL;
        break;
      case 5LL:
LABEL_18:
        uint64_t v5 = 302LL;
        break;
      case 6LL:
LABEL_19:
        uint64_t v5 = 303LL;
        break;
      case 7LL:
LABEL_20:
        uint64_t v5 = 304LL;
        break;
      case 8LL:
LABEL_21:
        uint64_t v5 = 400LL;
        break;
      case 9LL:
LABEL_13:
        uint64_t v5 = 500LL;
        break;
      case 10LL:
        uint64_t v5 = 0xFFFFLL;
        goto LABEL_22;
      default:
        goto LABEL_4;
    }
  }

LABEL_23:
    free(v3);
LABEL_24:
    uint64_t v13 = 0LL;
    return v13;
  }

  CFStringRef v11 = *v3;
  if (v11 <= 3)
  {
    ne_log_obj();
    CFIndex v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    *(_WORD *)__strerrbuf = 0;
    id v7 = "Dump TLV size too small, ignoring";
LABEL_20:
    id v8 = __strerrbuf;
    uint64_t v9 = v6;
    CFStringRef v10 = 2;
    goto LABEL_21;
  }

  if (v2 - 4 < v11)
  {
    ne_log_obj();
    CFIndex v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    *(_WORD *)__strerrbuf = 0;
    id v7 = "Dump TLV size too large, ignoring";
    goto LABEL_20;
  }

  unsigned __int16 v17 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v3 + 1 length:v11];
  free(v3);
  *(_OWORD *)buf = xmmword_187872F8C;
  *(_DWORD *)&buf[16] = 20;
  [MEMORY[0x189607940] string];
  int v18 = (void *)objc_claimAutoreleasedReturnValue();
  [v18 appendToStringAtColumnWithContent:buf column:0 content:"PROCESS" appendAsNewLine:0 addNewLine:0];
  [v18 appendToStringAtColumnWithContent:buf column:1 content:"SESSION ORDER" appendAsNewLine:0 addNewLine:0];
  [v18 appendToStringAtColumnWithContent:buf column:2 content:"POLICY ORDER" appendAsNewLine:0 addNewLine:0];
  [v18 appendToStringAtColumnWithContent:buf column:3 content:"CONDITIONS" appendAsNewLine:0 addNewLine:0];
  v119 = v18;
  [v18 appendToStringAtColumnWithContent:buf column:4 content:"RESULTS" appendAsNewLine:0 addNewLine:1];
  unint64_t v19 = &off_18A087000;
  int v20 = v17;
  objc_opt_self();
  [MEMORY[0x189607940] string];
  v125 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v21 = [v20 bytes];
  v118 = v20;
  id v22 = 0;
  v123 = [v20 length];
  v124 = v21;
  uint64_t v23 = v21 + v123;
  unint64_t v24 = (unsigned __int8 *)v21;
  for (i = v21 + v123; ; uint64_t v23 = i)
  {
    objc_opt_self();
    objc_opt_self();
    if (v23 <= (unint64_t)v24)
    {
      ne_log_obj();
      v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v111, OS_LOG_TYPE_INFO)) {
        goto LABEL_216;
      }
      *(_WORD *)__strerrbuf = 0;
      v112 = "Reached end of TLV Buffer";
      v113 = v111;
      v114 = 2;
      goto LABEL_215;
    }

    BOOL v25 = *(unsigned int *)(v24 + 1);
    int v26 = (void *)+[NEPolicySession copyTLVForBytes:messageLength:type:includeHeaderOffset:n:hasFlags:]( (uint64_t)v19[452],  v124,  v123,  101,  v22,  0);
    if (!v26) {
      goto LABEL_217;
    }
    id v27 = v26;
    v128 = v22;
    v129 = v24;
    v127 = [v26 length];
    uint64_t v28 = v27;
    objc_opt_self();
    v126 = objc_alloc_init(MEMORY[0x189607940]);
    uint64_t v29 = objc_alloc_init(MEMORY[0x189603FC8]);
    v131 = v29;
    if ([v28 length])
    {
      int v30 = 0LL;
      unint64_t v31 = 0LL;
      unint64_t v32 = 0;
      while (1)
      {
        int v33 = v31;
        uint64_t v34 = (unsigned __int8 *)([v28 bytes] + v30);
        objc_opt_self();
        if (!v34) {
          goto LABEL_197;
        }
        uint64_t v35 = *v34;
        if (!*v34) {
          goto LABEL_197;
        }
        v130 = *(_DWORD *)(v34 + 1);
        unint64_t v31 = (void *)+[NEPolicySession copyTLVForBytes:messageLength:type:includeHeaderOffset:n:hasFlags:]( (uint64_t)v19[452],  [v28 bytes] + v30,  objc_msgSend(v28, "length"),  v35,  0,  0);

        int v36 = objc_alloc_init(MEMORY[0x189607940]);
        if (v31 && [v31 bytes])
        {
          if ((int)v35 > 99)
          {
            if ((_DWORD)v35 == 100 || (_DWORD)v35 == 102)
            {
              objc_msgSend(v36, "appendFormat:", @"%s", objc_msgSend(v31, "bytes"), v117);
            }

            else if ((_DWORD)v35 == 103)
            {
              uint64_t v38 = *(int *)[v31 bytes];
              int v39 = "unknown";
              objc_msgSend(v36, "appendFormat:", @"%s (%u)", v39, v38);
            }
          }

          else
          {
            switch((_DWORD)v35)
            {
              case 2:
                goto LABEL_45;
              case 3:
                if ([v31 length])
                {
                  unint64_t v40 = 0LL;
                  unint64_t v41 = 0;
                  do
                  {
                    unint64_t v42 = (unsigned __int8 *)([v31 bytes] + v40);
                    objc_opt_self();
                    if (v42)
                    {
                      v41 += *(_DWORD *)(v42 + 1) + 6;
                      char v43 = v42[5];
                      LODWORD(v42) = *v42;
                    }

                    else
                    {
                      char v43 = 0;
                    }

                    uint64_t v44 = (void *)+[NEPolicySession copyTLVForBytes:messageLength:type:includeHeaderOffset:n:hasFlags:]( (uint64_t)v19[452],  [v31 bytes] + v40,  objc_msgSend(v31, "length"),  (int)v42,  0,  1);
                    uint64_t v45 = objc_alloc_init(MEMORY[0x189607940]);
                    [v131 objectForKey:&unk_18A0CFA38];
                    int v46 = (id)objc_claimAutoreleasedReturnValue();
                    if (!v46) {
                      int v46 = objc_alloc_init(MEMORY[0x189603FA8]);
                    }
                    switch((int)v42)
                    {
                      case 0:
                        int64_t v47 = v45;
                        int v48 = @"default ";
                        goto LABEL_125;
                      case 1:
                        uuid_unparse( (const unsigned __int8 *)[v44 bytes], __strerrbuf);
                        uint64_t v49 = "!";
                        if ((v43 & 1) == 0) {
                          uint64_t v49 = "";
                        }
                        v117 = (uint64_t)__strerrbuf;
                        objc_msgSend(v45, "appendFormat:", @"%seffective-application:%s ", v49);
                        break;
                      case 2:
                        uuid_unparse( (const unsigned __int8 *)[v44 bytes], __strerrbuf);
                        uint64_t v50 = "!";
                        if ((v43 & 1) == 0) {
                          uint64_t v50 = "";
                        }
                        v117 = (uint64_t)__strerrbuf;
                        objc_msgSend(v45, "appendFormat:", @"%sreal-application:%s ", v50);
                        break;
                      case 3:
                        if ((v43 & 1) != 0) {
                          int v51 = "!";
                        }
                        else {
                          int v51 = "";
                        }
                        v117 = [v44 bytes];
                        objc_msgSend(v45, "appendFormat:", @"%sdomain:%s ", v51);
                        break;
                      case 4:
                        if ((v43 & 1) != 0) {
                          uint64_t v52 = "!";
                        }
                        else {
                          uint64_t v52 = "";
                        }
                        v117 = [v44 bytes];
                        objc_msgSend(v45, "appendFormat:", @"%saccount-identifier:%s ", v52);
                        break;
                      case 5:
                        if (v44 && [v44 length])
                        {
                          if ((v43 & 1) != 0) {
                            uint64_t v53 = "!";
                          }
                          else {
                            uint64_t v53 = "";
                          }
                          v117 = [v44 bytes];
                          objc_msgSend(v45, "appendFormat:", @"%scustom-entitlement:%s ", v53);
                        }

                        else
                        {
                          uint64_t v72 = "!";
                          if ((v43 & 1) == 0) {
                            uint64_t v72 = "";
                          }
                          v116 = v72;
                          int64_t v47 = v45;
                          int v48 = @"%sentitlement ";
LABEL_125:
                          objc_msgSend(v47, "appendFormat:", v48, v116);
                        }

                        break;
                      case 6:
                        if ((v43 & 1) != 0) {
                          int v54 = "!";
                        }
                        else {
                          int v54 = "";
                        }
                        BOOL v55 = v44;
                        objc_msgSend( v45,  "appendFormat:",  @"%seffective-pid:%u ",  v54,  *(unsigned int *)objc_msgSend(v55, "bytes"));
                        if ((unint64_t)[v55 length] >= 8)
                        {
                          v117 = *(unsigned int *)([v55 bytes] + 4);
                          objc_msgSend(v45, "appendFormat:", @"%sversion:%d ", v54);
                        }

                        break;
                      case 7:
                        if ((v43 & 1) != 0) {
                          uint64_t v56 = "!";
                        }
                        else {
                          uint64_t v56 = "";
                        }
                        v117 = *(unsigned int *)[v44 bytes];
                        objc_msgSend(v45, "appendFormat:", @"%suid:%u ", v56);
                        break;
                      case 8:
                        unint64_t v57 = "!";
                        if ((v43 & 1) == 0) {
                          unint64_t v57 = "";
                        }
                        objc_msgSend(v45, "appendFormat:", @"%sall-interfaces ", v57);
                        break;
                      case 9:
                        if ((v43 & 1) != 0) {
                          int v58 = "!";
                        }
                        else {
                          int v58 = "";
                        }
                        v117 = [v44 bytes];
                        objc_msgSend(v45, "appendFormat:", @"%sscoped-interface:%s ", v58);
                        break;
                      case 10:
                        uint64_t v59 = (unsigned int *)[v44 bytes];
                        uint64_t v60 = "!";
                        if ((v43 & 1) == 0) {
                          uint64_t v60 = "";
                        }
                        v117 = *v59;
                        objc_msgSend(v45, "appendFormat:", @"%straffic-class-range:%u-%u ", v60);
                        break;
                      case 11:
                        if ((v43 & 1) != 0) {
                          uint64_t v61 = "!";
                        }
                        else {
                          uint64_t v61 = "";
                        }
                        v117 = *(unsigned __int8 *)[v44 bytes];
                        objc_msgSend(v45, "appendFormat:", @"%sip-protocol:%u ", v61);
                        break;
                      case 16:
                        uint64_t v67 = (__int128 *)[v44 bytes];
                        uint64_t v68 = v67[3];
                        int v70 = *v67;
                        uint64_t v69 = v67[1];
                        v135 = v67[2];
                        v136 = v68;
                        *(_OWORD *)__strerrbuf = v70;
                        *(_OWORD *)&__strerrbuf[16] = v69;
                        unint64_t v71 = "!";
                        if ((v43 & 1) == 0) {
                          unint64_t v71 = "";
                        }
                        v117 = (uint64_t)__strerrbuf;
                        objc_msgSend(v45, "appendFormat:", @"%sagent-domain:%s/agent-type:%s", v71);
                        break;
                      default:
                        if ((v42 & 0xFE) == 0xE)
                        {
                          v120 = [v44 bytes];
                          v121 = (__CFString *)NECreateAddressString((CFStringRef)v120);
                          uint64_t v73 = NECreateAddressString((CFStringRef)(v120 + 28));
                          SEL v74 = "!";
                          if ((v43 & 1) == 0) {
                            SEL v74 = "";
                          }
                          if (v121) {
                            id v75 = v121;
                          }
                          else {
                            id v75 = @"<nil>";
                          }
                          uint64_t v76 = (__CFString *)v73;
                          if ((_DWORD)v42 == 14) {
                            unint64_t v77 = @"%slocal-address-range:%@-%@";
                          }
                          else {
                            unint64_t v77 = @"%sremote-address-range:%@-%@";
                          }
                          v117 = (uint64_t)v75;
                          objc_msgSend(v45, "appendFormat:", v77, v74);
                        }

                        else if ((v42 & 0xFE) == 0xC)
                        {
                          int v62 = NECreateAddressStringWithPort([v44 bytes] + 1);
                          uint64_t v63 = "!";
                          if ((v43 & 1) == 0) {
                            uint64_t v63 = "";
                          }
                          uint64_t v64 = @"<nil>";
                          if (v62) {
                            uint64_t v64 = v62;
                          }
                          uint64_t v65 = v62;
                          if ((_DWORD)v42 == 12) {
                            int v66 = @"%slocal-address:%@/%u";
                          }
                          else {
                            int v66 = @"%sremote-address:%@/%u";
                          }
                          v117 = (uint64_t)v64;
                          objc_msgSend(v45, "appendFormat:", v66, v63);
                        }

                        else
                        {
                          switch((int)v42)
                          {
                            case 17:
                              unint64_t v78 = "!";
                              if ((v43 & 1) == 0) {
                                unint64_t v78 = "";
                              }
                              objc_msgSend(v45, "appendFormat:", @"%smodern-network-api", v78);
                              break;
                            case 18:
                              if ((v43 & 1) != 0) {
                                uint64_t v79 = "!";
                              }
                              else {
                                uint64_t v79 = "";
                              }
                              v117 = *(unsigned __int8 *)[v44 bytes];
                              objc_msgSend(v45, "appendFormat:", @"%slocal-networks:%u", v79);
                              break;
                            case 24:
                              if ((v43 & 1) != 0) {
                                uint64_t v80 = "!";
                              }
                              else {
                                uint64_t v80 = "";
                              }
                              v117 = *(unsigned int *)[v44 bytes];
                              objc_msgSend(v45, "appendFormat:", @"%sclient-flags:%u", v80);
                              break;
                            case 25:
                              int v81 = "!";
                              if ((v43 & 1) == 0) {
                                int v81 = "";
                              }
                              objc_msgSend(v45, "appendFormat:", @"%slocal-address-empty", v81);
                              break;
                            case 26:
                              uint64_t v82 = "!";
                              if ((v43 & 1) == 0) {
                                uint64_t v82 = "";
                              }
                              objc_msgSend(v45, "appendFormat:", @"%sremote-address-empty", v82);
                              break;
                            case 27:
                              v83 = "!";
                              if ((v43 & 1) == 0) {
                                v83 = "";
                              }
                              objc_msgSend(v45, "appendFormat:", @"%splatform-binary", v83);
                              break;
                            case 28:
                              uint64_t v84 = (unsigned int *)[v44 bytes];
                              __int16 v85 = "!";
                              if ((v43 & 1) == 0) {
                                __int16 v85 = "";
                              }
                              v117 = *v84;
                              objc_msgSend( v45,  "appendFormat:",  @"%splatform:%u/sdk-version:%u/min-sdk-version:%u",  v85);
                              break;
                            case 29:
                              if (v44 && [v44 length])
                              {
                                if ((v43 & 1) != 0) {
                                  int v86 = "!";
                                }
                                else {
                                  int v86 = "";
                                }
                                v117 = [v44 bytes];
                                objc_msgSend(v45, "appendFormat:", @"%ssigning-identifier:%s ", v86);
                              }

                              else
                              {
                                v95 = "!";
                                if ((v43 & 1) == 0) {
                                  v95 = "";
                                }
                                objc_msgSend(v45, "appendFormat:", @"%ssigning-identifier ", v95);
                              }

                              break;
                            case 30:
                              if ((v43 & 1) != 0) {
                                __int16 v87 = "!";
                              }
                              else {
                                __int16 v87 = "";
                              }
                              v117 = *(unsigned int *)[v44 bytes];
                              objc_msgSend(v45, "appendFormat:", @"%spacket-filter-tags:%u", v87);
                              break;
                            case 31:
                              int v88 = "!";
                              if ((v43 & 1) == 0) {
                                int v88 = "";
                              }
                              objc_msgSend(v45, "appendFormat:", @"%sis-loopback", v88);
                              break;
                            case 32:
                              uint64_t v89 = "!";
                              if ((v43 & 1) == 0) {
                                uint64_t v89 = "";
                              }
                              objc_msgSend(v45, "appendFormat:", @"%sdelegate-is-platform-binary", v89);
                              break;
                            case 37:
                              if ((v43 & 1) != 0) {
                                CFErrorRef v90 = "!";
                              }
                              else {
                                CFErrorRef v90 = "";
                              }
                              v117 = bswap32(*(unsigned __int16 *)[v44 bytes]) >> 16;
                              objc_msgSend(v45, "appendFormat:", @"%sscheme-port:%u", v90);
                              break;
                            case 38:
                              if ((v43 & 1) != 0) {
                                unint64_t v91 = "!";
                              }
                              else {
                                unint64_t v91 = "";
                              }
                              v117 = *(unsigned int *)[v44 bytes];
                              objc_msgSend(v45, "appendFormat:", @"%sdomain-filter:%u ", v91);
                              break;
                            case 39:
                              v92 = "!";
                              if ((v43 & 1) == 0) {
                                v92 = "";
                              }
                              objc_msgSend(v45, "appendFormat:", @"%ssigned-result", v92);
                              break;
                            case 43:
                              if ((unint64_t)[v44 length] >= 0xC)
                              {
                                v93 = (unsigned int *)[v44 bytes];
                                v94 = "!";
                                if ((v43 & 1) == 0) {
                                  v94 = "";
                                }
                                v117 = *v93;
                                objc_msgSend( v45,  "appendFormat:",  @"%sscoped-interface-flags: %X, eflags %X, xflags %X",  v94);
                              }

                              break;
                            default:
                              goto LABEL_126;
                          }
                        }

                        break;
                    }
}

  [v6 objectForKeyedSubscript:@"ssid-match"];
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  unint64_t v24 = objc_opt_isKindOfClass();

  BOOL v25 = [v6 objectForKeyedSubscript:@"ssid-match"];
  int v26 = (void *)v25;
  if ((v24 & 1) != 0)
  {
    unint64_t v40 = v25;
    [MEMORY[0x189603F18] arrayWithObjects:&v40 count:1];
    id v27 = (void *)objc_claimAutoreleasedReturnValue();
    [v9 setSSIDMatch:v27];
  }

  else
  {
    [v9 setSSIDMatch:v25];
  }

  [v6 objectForKeyedSubscript:@"probe-url"];
  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
  [v28 stringByRemovingPercentEncoding];
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();

  if (v29)
  {
    int v30 = (void *)[objc_alloc(MEMORY[0x189604030]) initWithString:v29];
    [v9 setProbeURL:v30];
  }

  -[NEUtilConfigurationClient onDemandRules](self, "onDemandRules");
  unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();

  if (v31)
  {
    unint64_t v32 = objc_alloc(MEMORY[0x189603FA8]);
    -[NEUtilConfigurationClient onDemandRules](self, "onDemandRules");
    int v33 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v34 = (id)[v32 initWithArray:v33];
  }

  else
  {
    uint64_t v34 = objc_alloc_init(MEMORY[0x189603FA8]);
  }

  [v6 objectForKeyedSubscript:@"index"];
  uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
  int v36 = [v34 count];
  if (v35) {
    int v36 = [v35 integerValue];
  }
  uint64_t v37 = v36;
  if (v36 >= [v34 count]) {
    [v34 addObject:v9];
  }
  else {
    [v34 insertObject:v9 atIndex:v37];
  }
  uint64_t v38 = 1;
  -[NEUtilConfigurationClient setOnDemandEnabled:](self, "setOnDemandEnabled:", 1LL);
  -[NEUtilConfigurationClient setOnDemandRules:](self, "setOnDemandRules:", v34);

LABEL_36:
  return v38;
}

                id v2 = v2 | 2;
                goto LABEL_27;
              }
            }

            id v2 = v2 | 1;
          }

    CFRelease(v9);
    return 0LL;
  }

  uint64_t v13 = v12;
  *((void *)v9 + 61) = CFUUIDCreateString(v11, v12);
  CFRelease(v13);
  if (!*((void *)v9 + 61))
  {
    int v20 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      id v27 = 136315394;
      uint64_t v28 = "NEVirtualInterfaceCreateBase";
      uint64_t v29 = 1024;
      int v30 = 1248;
      uint64_t v21 = "NEVirtualInterface Failure in %s at line %d.";
      goto LABEL_18;
    }

    goto LABEL_22;
  }

  if (a3)
  {
    void *v10 = a3;
    dispatch_retain(a3);
  }

  *((_DWORD *)v9 + 77) = -1;
  *((_BYTE *)v9 + 73) = 1;
  *((void *)v9 + 3) = a4;
  *((void *)v9 + 32) = a2;
  uint64_t v14 = (const CFArrayCallBacks *)MEMORY[0x189605228];
  *((void *)v9 + 40) = CFArrayCreateMutable(v11, 0LL, MEMORY[0x189605228]);
  *((void *)v9 + 41) = CFArrayCreateMutable(v11, 0LL, v14);
  *((void *)v9 + 42) = CFArrayCreateMutable(v11, 0LL, v14);
  *((void *)v9 + 43) = CFArrayCreateMutable(v11, 0LL, v14);
  *((void *)v9 + 44) = CFArrayCreateMutable(v11, 0LL, v14);
  *((void *)v9 + 45) = CFArrayCreateMutable(v11, 0LL, v14);
  *((void *)v9 + 46) = CFArrayCreateMutable(v11, 0LL, v14);
  *((void *)v9 + 47) = 1LL;
  *((void *)v9 + 4_Block_object_dispose((const void *)(v49 - 176), 8) = 1LL;
  *((_DWORD *)v9 + 76) = 0;
  Mutable = CFDictionaryCreateMutable(v11, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    int v16 = Mutable;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x18960C568], (const void *)*MEMORY[0x189604DE8]);
    *((void *)v9 + 62) = SCDynamicStoreCreateWithOptions( a1,  @"NEVirtualInterface Helper Session",  v16,  0LL,  0LL);
    CFRelease(v16);
    if (*((void *)v9 + 62)) {
      goto LABEL_10;
    }
    goto LABEL_21;
  }

  unint64_t v24 = SCDynamicStoreCreateWithOptions(a1, @"NEVirtualInterface Helper Session", 0LL, 0LL, 0LL);
  *((void *)v9 + 62) = v24;
  if (!v24)
  {
LABEL_21:
    BOOL v25 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    LOWORD(v27) = 0;
    uint64_t v21 = "Failed to open dynamic store session\n";
    id v22 = v25;
    uint64_t v23 = 2;
    goto LABEL_19;
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

  return v5;
}

  if (v3)
  {
    if (-[NEVPNProtocolPPP verboseLoggingEnabled](self, "verboseLoggingEnabled")) {
      uint64_t v23 = &unk_18A0CFB70;
    }
    else {
      uint64_t v23 = &unk_18A0CFB88;
    }
    [v5 setObject:v23 forKeyedSubscript:*MEMORY[0x18960C858]];
    -[NEVPNProtocol addDisconnectOptions:](self, "addDisconnectOptions:", v5);
    [v5 setObject:&unk_18A0CFB70 forKeyedSubscript:*MEMORY[0x18960C7C0]];
    [v5 setObject:&unk_18A0CFB88 forKeyedSubscript:*MEMORY[0x18960C7F0]];
    [v5 setObject:&unk_18A0CFB70 forKeyedSubscript:*MEMORY[0x18960C7F8]];
    [v5 setObject:&unk_18A0CFB88 forKeyedSubscript:*MEMORY[0x18960C800]];
    [v5 setObject:&unk_18A0CFBA0 forKeyedSubscript:*MEMORY[0x18960C808]];
    [v5 setObject:&unk_18A0CFB88 forKeyedSubscript:*MEMORY[0x18960C818]];
    [v5 setObject:&unk_18A0CFB88 forKeyedSubscript:*MEMORY[0x18960C820]];
    [v5 setObject:&unk_18A0CFB88 forKeyedSubscript:*MEMORY[0x18960C828]];
    [v5 setObject:&unk_18A0CFB88 forKeyedSubscript:*MEMORY[0x18960C830]];
    [v5 setObject:&unk_18A0CFBB8 forKeyedSubscript:*MEMORY[0x18960C838]];
    [v5 setObject:&unk_18A0CFB70 forKeyedSubscript:*MEMORY[0x18960C840]];
    [v5 setObject:&unk_18A0CFBD0 forKeyedSubscript:*MEMORY[0x18960C848]];
    [v5 setObject:&unk_18A0CFBE8 forKeyedSubscript:*MEMORY[0x18960C850]];
    [v5 setObject:@"/var/log/ppp.log" forKeyedSubscript:@"Logfile"];
  }

  return v5;
}

__CFString *NEIKEv2CreateChildSAModeString(unint64_t a1)
{
  if (a1 >= 3) {
    return (__CFString *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"Unknown(%lld)", a1);
  }
  else {
    return off_18A08C9B0[a1];
  }
}

uint64_t NEIKEv2CreateErrorInternal( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  buf[3] = *MEMORY[0x1895F89C0];
  id v9 = a1;
  if (v9)
  {
    buf[0] = &a9;
    CFStringRef v10 = (void *)[objc_alloc(NSString) initWithFormat:v9 arguments:&a9];
    CFStringRef v11 = (void *)[objc_alloc(NSString) initWithFormat:@"Internal: %@", v10];
    uint64_t ErrorWithDescription = NEIKEv2CreateErrorWithDescription(1LL, v11);
  }

  else
  {
    ne_log_obj();
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = "NEIKEv2CreateErrorInternal";
      _os_log_fault_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_FAULT,  "%s called with null errorDescriptionFormat",  (uint8_t *)buf,  0xCu);
    }

    uint64_t ErrorWithDescription = 0LL;
  }

  return ErrorWithDescription;
}

uint64_t NEIKEv2CreateErrorWithDescription(uint64_t a1, void *a2)
{
  v9[1] = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id v4 = objc_alloc(MEMORY[0x189607870]);
  uint64_t v8 = *MEMORY[0x1896075E0];
  v9[0] = v3;
  [MEMORY[0x189603F68] dictionaryWithObjects:v9 forKeys:&v8 count:1];
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v6 = [v4 initWithDomain:@"NEIKEv2ErrorDomain" code:a1 userInfo:v5];

  if (!v6) {
    abort();
  }

  return v6;
}

CFStringRef NEIKEv2AttributeTypeCreateString(uint64_t a1)
{
  BOOL result = @"Invalid";
  switch(a1)
  {
    case 0LL:
      return result;
    case 1LL:
      BOOL result = @"InternalIP4Address";
      break;
    case 2LL:
      BOOL result = @"InternalIP4Netmask";
      break;
    case 3LL:
      BOOL result = @"InternalIP4DNS";
      break;
    case 4LL:
      BOOL result = @"InternalIP4NBNS";
      break;
    case 5LL:
      BOOL result = @"InternalAddressExpiry";
      break;
    case 6LL:
      BOOL result = @"InternalIP4DHCP";
      break;
    case 7LL:
      BOOL result = @"ApplicationVersion";
      break;
    case 8LL:
      BOOL result = @"InternalIP6Address";
      break;
    case 9LL:
    case 11LL:
    case 16LL:
    case 17LL:
    case 18LL:
    case 19LL:
    case 22LL:
    case 23LL:
    case 24LL:
      goto LABEL_6;
    case 10LL:
      BOOL result = @"InternalIP6DNS";
      break;
    case 12LL:
      BOOL result = @"InternalIP6DHCP";
      break;
    case 13LL:
      BOOL result = @"InternalIP4Subnet";
      break;
    case 14LL:
      BOOL result = @"SupportedAttributes";
      break;
    case 15LL:
      BOOL result = @"InternalIP6Subnet";
      break;
    case 20LL:
      BOOL result = @"PCSCFIP4Address";
      break;
    case 21LL:
      BOOL result = @"PCSCFIP6Address";
      break;
    case 25LL:
      BOOL result = @"InternalDNSDomain";
      break;
    default:
      if (a1 == 25958)
      {
        BOOL result = @"InitiatorTransportIP6Address";
      }

      else if (a1 == 25959)
      {
        BOOL result = @"ResponderTransportIP6Address";
      }

      else
      {
LABEL_6:
        BOOL result = (const __CFString *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"Unknown(%lld)",  a1);
      }

      break;
  }

  return result;
}

uint64_t NEIKEv2CreateError(uint64_t a1)
{
  if (a1 == 1)
  {
    ne_log_obj();
    uint64_t v1 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)id v7 = 0;
      _os_log_fault_impl( &dword_1876B1000,  v1,  OS_LOG_TYPE_FAULT,  "NEIKEv2CreateError(NEIKEv2ErrorInternal) is not allowed, use NEIKEv2CreateErrorInternal() instead",  v7,  2u);
    }

    String = @"Internal";
    uint64_t v3 = 1LL;
  }

  else
  {
    String = NEIKEv2ErrorCreateString(a1);
    uint64_t v3 = a1;
  }

  uint64_t ErrorWithDescription = NEIKEv2CreateErrorWithDescription(v3, String);

  return ErrorWithDescription;
}

__CFString *NEIKEv2ErrorCreateString(uint64_t a1)
{
  else {
    return off_18A08C938[a1 - 1];
  }
}

uint64_t NEIKEv2CreateErrorFailedToSend( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  buf[3] = *MEMORY[0x1895F89C0];
  id v9 = a1;
  if (v9)
  {
    buf[0] = &a9;
    CFStringRef v10 = (void *)[objc_alloc(NSString) initWithFormat:v9 arguments:&a9];
    CFStringRef v11 = (void *)[objc_alloc(NSString) initWithFormat:@"FailedToSend: %@", v10];
    uint64_t ErrorWithDescription = NEIKEv2CreateErrorWithDescription(2LL, v11);
  }

  else
  {
    ne_log_obj();
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = "NEIKEv2CreateErrorFailedToSend";
      _os_log_fault_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_FAULT,  "%s called with null errorDescriptionFormat",  (uint8_t *)buf,  0xCu);
    }

    uint64_t ErrorWithDescription = 0LL;
  }

  return ErrorWithDescription;
}

uint64_t NEIKEv2CreateErrorCrypto( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  buf[3] = *MEMORY[0x1895F89C0];
  id v9 = a1;
  if (v9)
  {
    buf[0] = &a9;
    CFStringRef v10 = (void *)[objc_alloc(NSString) initWithFormat:v9 arguments:&a9];
    CFStringRef v11 = (void *)[objc_alloc(NSString) initWithFormat:@"Crypto: %@", v10];
    uint64_t ErrorWithDescription = NEIKEv2CreateErrorWithDescription(7LL, v11);
  }

  else
  {
    ne_log_obj();
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = "NEIKEv2CreateErrorCrypto";
      _os_log_fault_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_FAULT,  "%s called with null errorDescriptionFormat",  (uint8_t *)buf,  0xCu);
    }

    uint64_t ErrorWithDescription = 0LL;
  }

  return ErrorWithDescription;
}

uint64_t NEIKEv2CreateErrorPeerInvalidSyntax( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  buf[3] = *MEMORY[0x1895F89C0];
  id v9 = a1;
  if (v9)
  {
    buf[0] = &a9;
    CFStringRef v10 = (void *)[objc_alloc(NSString) initWithFormat:v9 arguments:&a9];
    CFStringRef v11 = (void *)[objc_alloc(NSString) initWithFormat:@"PeerInvalidSyntax: %@", v10];
    uint64_t ErrorWithDescription = NEIKEv2CreateErrorWithDescription(6LL, v11);
  }

  else
  {
    ne_log_obj();
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = "NEIKEv2CreateErrorPeerInvalidSyntax";
      _os_log_fault_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_FAULT,  "%s called with null errorDescriptionFormat",  (uint8_t *)buf,  0xCu);
    }

    uint64_t ErrorWithDescription = 0LL;
  }

  return ErrorWithDescription;
}

uint64_t NEIKEv2CreateErrorAuthentication( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  buf[3] = *MEMORY[0x1895F89C0];
  id v9 = a1;
  if (v9)
  {
    buf[0] = &a9;
    CFStringRef v10 = (void *)[objc_alloc(NSString) initWithFormat:v9 arguments:&a9];
    CFStringRef v11 = (void *)[objc_alloc(NSString) initWithFormat:@"Authentication: %@", v10];
    uint64_t ErrorWithDescription = NEIKEv2CreateErrorWithDescription(8LL, v11);
  }

  else
  {
    ne_log_obj();
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = "NEIKEv2CreateErrorAuthentication";
      _os_log_fault_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_FAULT,  "%s called with null errorDescriptionFormat",  (uint8_t *)buf,  0xCu);
    }

    uint64_t ErrorWithDescription = 0LL;
  }

  return ErrorWithDescription;
}

LABEL_88:
  if (!objc_getProperty(v8, v80, 104LL, 1))
  {
    ne_log_obj();
    unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      int v18 = "No chosen PRF protocol";
      goto LABEL_106;
    }

LABEL_36:
    id v9 = 0LL;
LABEL_53:

    return v9;
  }

  if (((1LL << a2) & 0x180380000LL) == 0)
  {
    if (((1LL << a2) & 0x3000000000LL) != 0)
    {
      uint64_t v13 = objc_alloc(&OBJC_CLASS___NEIKEv2KeyExchangeHandlerMLKEM);
      if (!v13) {
        return 0LL;
      }
      id v9 = (id *)-[NEIKEv2KeyExchangeHandler initWithMethod:](v13, a2);
      if (!v9) {
        return v9;
      }
      ne_log_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v50 = (unint64_t)v9[1];
        *(_DWORD *)buf = 134217984;
        uint64_t v67 = v50;
        _os_log_debug_impl(&dword_1876B1000, v14, OS_LOG_TYPE_DEBUG, "Generate ML-KEM %zu key", buf, 0xCu);
      }

      unint64_t v15 = v9[1];
      if (v15 == (id)37)
      {
        int v16 = &OBJC_CLASS____TtC16NetworkExtension25NEIKEv2CryptoKitMLKEM1024;
      }

      else
      {
        if (v15 != (id)36)
        {
          ne_log_obj();
          unint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT))
          {
            uint64_t v45 = (unint64_t)v9[1];
            *(_DWORD *)buf = 134217984;
            uint64_t v67 = v45;
            _os_log_fault_impl(&dword_1876B1000, v42, OS_LOG_TYPE_FAULT, "Invalid ML-KEM type %zu", buf, 0xCu);
          }

          goto LABEL_75;
        }

        int v16 = &OBJC_CLASS____TtC16NetworkExtension24NEIKEv2CryptoKitMLKEM768;
      }

      uint64_t v65 = 0LL;
      uint64_t v37 = [[v16 alloc] initAndReturnError:&v65];
      id v4 = (id *)v65;
      uint64_t v38 = v9[4];
      v9[4] = (id)v37;

      int v39 = v9[4];
      ne_log_obj();
      unint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v41 = v40;
      if (v39)
      {
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v52 = (unint64_t)v9[1];
          *(_DWORD *)buf = 134217984;
          uint64_t v67 = v52;
          _os_log_debug_impl(&dword_1876B1000, v41, OS_LOG_TYPE_DEBUG, "Generated ML-KEM %zu key", buf, 0xCu);
        }

        unint64_t v42 = (os_log_s *)v9[4];
        char v43 = -[os_log_s keyExchangeData](v42, "keyExchangeData");
        uint64_t v44 = v9[2];
        void v9[2] = (id)v43;

        goto LABEL_76;
      }

      if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
      {
        uint64_t v53 = (unint64_t)v9[1];
        *(_DWORD *)buf = 134218242;
        uint64_t v67 = v53;
        uint64_t v68 = 2112;
        uint64_t v69 = v4;
        _os_log_fault_impl(&dword_1876B1000, v41, OS_LOG_TYPE_FAULT, "Failed to create ML-KEM %zu key: %@", buf, 0x16u);
      }

      unint64_t v42 = (os_log_s *)v4;
LABEL_75:
      id v4 = v9;
      id v9 = 0LL;
LABEL_76:

      goto LABEL_53;
    }

LABEL_156:
    v126 = 0LL;
    goto LABEL_157;
  }

  -[os_log_s kemProtocols](v8, "kemProtocols");
  int v81 = (void *)objc_claimAutoreleasedReturnValue();
  [v6 kemProtocols];
  uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
  [v82 firstObject];
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v84 = [v81 indexOfObject:v83];

  if (v84 == 0x7FFFFFFFFFFFFFFFLL)
  {
    if (a3)
    {
      v150 = 0uLL;
      v151 = 0uLL;
      v148 = 0uLL;
      v149 = 0uLL;
      [v6 kemProtocols];
      __int16 v85 = (void *)objc_claimAutoreleasedReturnValue();
      int v86 = [v85 countByEnumeratingWithState:&v148 objects:v179 count:16];
      if (!v86) {
        goto LABEL_115;
      }
      __int16 v87 = v86;
      int v88 = *(void *)v149;
LABEL_93:
      uint64_t v89 = 0LL;
      while (1)
      {
        if (*(void *)v149 != v88) {
          objc_enumerationMutation(v85);
        }
        CFErrorRef v90 = *(void *)(*((void *)&v148 + 1) + 8 * v89);
        -[os_log_s kemProtocols](v8, "kemProtocols");
        unint64_t v91 = (void *)objc_claimAutoreleasedReturnValue();
        v92 = [v91 indexOfObject:v90];

        if (v92 != 0x7FFFFFFFFFFFFFFFLL) {
          break;
        }
        if (v87 == ++v89)
        {
          __int16 v87 = [v85 countByEnumeratingWithState:&v148 objects:v179 count:16];
          if (!v87)
          {
LABEL_115:

            goto LABEL_153;
          }

          goto LABEL_93;
        }
      }
      v102 = -[os_log_s kemProtocols](v8, "kemProtocols");
      [v102 objectAtIndexedSubscript:v92];
      unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    }

    else
    {
      v146 = 0uLL;
      v147 = 0uLL;
      v144 = 0uLL;
      v145 = 0uLL;
      -[os_log_s kemProtocols](v8, "kemProtocols");
      __int16 v85 = (void *)objc_claimAutoreleasedReturnValue();
      v95 = [v85 countByEnumeratingWithState:&v144 objects:v178 count:16];
      if (!v95) {
        goto LABEL_115;
      }
      v96 = v95;
      v97 = *(void *)v145;
LABEL_109:
      v98 = 0LL;
      while (1)
      {
        if (*(void *)v145 != v97) {
          objc_enumerationMutation(v85);
        }
        v99 = *(void **)(*((void *)&v144 + 1) + 8 * v98);
        [v6 kemProtocols];
        v100 = (void *)objc_claimAutoreleasedReturnValue();
        v101 = [v100 containsObject:v99];

        if (v101) {
          break;
        }
        if (v96 == ++v98)
        {
          v96 = [v85 countByEnumeratingWithState:&v144 objects:v178 count:16];
          if (!v96) {
            goto LABEL_115;
          }
          goto LABEL_109;
        }
      }

      unsigned __int16 v17 = v99;
    }

    if (v17) {
      goto LABEL_119;
    }
    goto LABEL_153;
  }
  v93 = -[os_log_s kemProtocols](v8, "kemProtocols");
  [v93 objectAtIndexedSubscript:v84];
  unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();

  if (!v17)
  {
LABEL_153:
    ne_log_obj();
    v127 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1876B1000, v127, OS_LOG_TYPE_ERROR, "No chosen KE method", buf, 2u);
    }

    unsigned __int16 v17 = 0LL;
    goto LABEL_156;
  }

    uint64_t v34 = 0LL;
    goto LABEL_157;
  }

  ne_log_obj();
  id v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled((os_log_t)v7, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v113 = "-[NEIKEv2IKESA(Crypto) copyAuthenticationPayloadUsingPrimeKey:]";
    _os_log_fault_impl( &dword_1876B1000,  (os_log_t)v7,  OS_LOG_TYPE_FAULT,  "%s called with null self.chosenProposal",  buf,  0xCu);
  }

  uint64_t v8 = 0LL;
LABEL_146:

  return v8;
}

                      v144 = 0LL;
LABEL_157:
                      BOOL v25 = self;
LABEL_158:
                      unint64_t v24 = v264;
                      uint64_t v80 = v260;
LABEL_159:

LABEL_160:
                      goto LABEL_119;
                    }

                    ne_log_obj();
                    v255 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v255, OS_LOG_TYPE_FAULT)) {
                      goto LABEL_156;
                    }
                    *(_WORD *)buf = 0;
                    v256 = "[packet addNotification:NEIKEv2NotifyTypeChildlessIKEv2Supported] failed";
                  }

LABEL_166:
  }

  else
  {
    v138 = 0uLL;
    v139 = 0uLL;
    v136 = 0uLL;
    v137 = 0uLL;
    v112 = v109;
    v120 = [v112 countByEnumeratingWithState:&v136 objects:v176 count:16];
    if (!v120)
    {
      v109 = v112;
      goto LABEL_166;
    }

    v121 = v120;
    v122 = *(void *)v137;
LABEL_139:
    v123 = 0LL;
    while (1)
    {
      if (*(void *)v137 != v122) {
        objc_enumerationMutation(v112);
      }
      v124 = *(void **)(*((void *)&v136 + 1) + 8 * v123);
      if (([v104 containsObject:v124] & 1) == 0)
      {
      }

      if (v121 == ++v123)
      {
        v121 = [v112 countByEnumeratingWithState:&v136 objects:v176 count:16];
        if (v121) {
          goto LABEL_139;
        }
        v109 = v112;
        goto LABEL_163;
      }
    }

    v118 = v124;
LABEL_148:

    v105 = v131;
    v107 = v134;
    if (v118)
    {
      [v131 setObject:v118 forKeyedSubscript:v134];
      uint64_t v6 = v133;
      if ([v118 method]) {
        [v104 addObject:v118];
      }
      goto LABEL_151;
    }
  }

  uint64_t v6 = v133;
  ne_log_obj();
  v130 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1876B1000, v130, OS_LOG_TYPE_ERROR, "No chosen additional KE methods", buf, 2u);
  }

  v126 = 0LL;
  uint64_t v8 = v135;
LABEL_170:

LABEL_157:
LABEL_158:

LABEL_159:
  return v126;
}

LABEL_137:
    if ([v98 method]) {
      [v81 addObject:v98];
    }

    uint64_t v82 = v110;
    uint64_t v84 = v111;
    a3 = v109;
    v83 = 0x189607000LL;
    goto LABEL_140;
  }

  int v86 = (uint64_t)v92;
LABEL_147:
  v103 = v91;
LABEL_148:

  ne_log_large_obj();
  v104 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v104, OS_LOG_TYPE_INFO))
  {
    [a1 additionalKEMProtocols];
    v105 = (char *)objc_claimAutoreleasedReturnValue();
    [v6 additionalKEMProtocols];
    v106 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412546;
    v149 = v105;
    v150 = 2112;
    v151 = v106;
    _os_log_impl( &dword_1876B1000,  v104,  OS_LOG_TYPE_INFO,  "Failed to match Additional Key Exchange methods (%@ vs %@)",  buf,  0x16u);
  }

  v140 = 0;
LABEL_151:

  SEL v74 = v107;
LABEL_152:

  a1 = (void *)v140;
LABEL_30:

  return a1;
}

LABEL_161:
    ne_log_obj();
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      id v22 = "Remote proposal has invalid proposal number 0";
      goto LABEL_167;
    }

    goto LABEL_162;
  }

  if (!v8[8]) {
    goto LABEL_161;
  }
LABEL_7:
  if (a3)
  {
    v151 = 0uLL;
    v152 = 0uLL;
    v149 = 0uLL;
    v150 = 0uLL;
    [v8 encryptionProtocols];
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v15 = [v14 countByEnumeratingWithState:&v149 objects:v160 count:16];
    if (!v15) {
      goto LABEL_34;
    }
    int v16 = *(void *)v150;
LABEL_10:
    unsigned __int16 v17 = 0LL;
    while (1)
    {
      if (*(void *)v150 != v16) {
        objc_enumerationMutation(v14);
      }
      int v18 = *(void *)(*((void *)&v149 + 1) + 8 * v17);
      -[os_log_s encryptionProtocols](v9, "encryptionProtocols");
      unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
      int v20 = [v19 indexOfObject:v18];

      if (v20 != 0x7FFFFFFFFFFFFFFFLL) {
        break;
      }
      if (v15 == ++v17)
      {
        unint64_t v15 = [v14 countByEnumeratingWithState:&v149 objects:v160 count:16];
        if (v15) {
          goto LABEL_10;
        }
        goto LABEL_34;
      }
    }

    unint64_t v15 = -[os_log_s encryptionProtocols](v9, "encryptionProtocols");
    [(id)v15 objectAtIndexedSubscript:v20];
    int v30 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v32 = v30;
    if (!v9)
    {

      uint64_t v34 = 0LL;
      LOBYTE(v15) = 0;
      goto LABEL_33;
    }

    objc_setProperty_atomic(v9, v31, v30, 96LL);

    uint64_t v34 = objc_getProperty(v9, v33, 96LL, 1);
    if (v34)
    {
      uint64_t v35 = v34[2];
      if (v35 <= 0x1F && ((1LL << v35) & 0xD01C0000LL) != 0) {
        goto LABEL_32;
      }
    }

    goto LABEL_56;
  }

  v147 = 0uLL;
  v148 = 0uLL;
  v145 = 0uLL;
  v146 = 0uLL;
  -[os_log_s encryptionProtocols](v9, "encryptionProtocols");
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v15 = [v14 countByEnumeratingWithState:&v145 objects:v159 count:16];
  if (!v15) {
    goto LABEL_34;
  }
  v118 = a4;
  uint64_t v23 = a3;
  unint64_t v24 = *(void *)v146;
  while (2)
  {
    for (CFIndex i = 0LL; i != v15; ++i)
    {
      if (*(void *)v146 != v24) {
        objc_enumerationMutation(v14);
      }
      int v26 = *(void **)(*((void *)&v145 + 1) + 8 * i);
      [v8 encryptionProtocols];
      id v27 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v28 = [v27 containsObject:v26];

      if (v28)
      {
        if (v9)
        {
          objc_setProperty_atomic(v9, v29, v26, 96LL);
          uint64_t v34 = objc_getProperty(v9, v46, 96LL, 1);
          a3 = v23;
          if (v34)
          {
            int64_t v47 = v34[2];
            int v48 = v47 > 0x1F;
            uint64_t v49 = (1LL << v47) & 0xD01C0000LL;
            uint64_t v50 = v48 || v49 == 0;
            a4 = v118;
            if (!v50)
            {
LABEL_32:
              LOBYTE(v15) = 1;
LABEL_33:

              goto LABEL_34;
            }

    CFErrorRef v90 = 0LL;
    goto LABEL_162;
  }

  p_info = &OBJC_METACLASS___NEConfigurationManager.info;
  if (!NEGetValueWithType((const __CFDictionary *)a1, @"IKEVersion", CFNUMBER_TYPE))
  {
    ne_log_obj();
    uint64_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v153 = "NEIPSecIKEValidateIKEDictionary";
      v154 = 1024;
      v155 = 1116;
      v156 = 2112;
      v157 = @"IKEVersion";
      v158 = 2048;
      v159 = CFNUMBER_TYPE;
      v92 = "%s:%d: value for key %@ is missing or type != %lu";
      v93 = v89;
      v94 = 38;
LABEL_169:
      _os_log_error_impl(&dword_1876B1000, v93, OS_LOG_TYPE_ERROR, v92, buf, v94);
      goto LABEL_161;
    }

    goto LABEL_161;
  }

  valuePtr = 0;
  uint64_t v5 = (const __CFNumber *)NEGetValueWithType((const __CFDictionary *)a1, @"IKEVersion", CFNUMBER_TYPE);
  CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
  if (valuePtr != 2)
  {
    ne_log_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v153 = "NEIPSecIKEValidateIKEDictionary";
      v154 = 1024;
      v155 = 1121;
      _os_log_error_impl(&dword_1876B1000, v6, OS_LOG_TYPE_ERROR, "%s:%d: IKE version is not 2", buf, 0x12u);
    }

    CFErrorRef v90 = 0LL;
    goto LABEL_231;
  }

  uint64_t v6 = a1;
  if (CFDictionaryContainsKey(v6, @"OutgoingInterface")
    && !NEGetValueWithType(v6, @"OutgoingInterface", CFSTRING_TYPE))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1127;
    v156 = 2112;
    v157 = @"OutgoingInterface";
    v158 = 2048;
    v159 = CFSTRING_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
LABEL_193:
    v98 = v25;
    v99 = 38;
LABEL_194:
    _os_log_error_impl(&dword_1876B1000, v98, OS_LOG_TYPE_ERROR, v95, buf, v99);
    goto LABEL_229;
  }

  if (CFDictionaryContainsKey(v6, @"OutgoingInterface"))
  {
    -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"OutgoingInterface");
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESAConfiguration setOutgoingInterfaceName:](v2, "setOutgoingInterfaceName:", v7);
  }

  if (CFDictionaryContainsKey(v6, @"LocalAddress")
    && !NEGetValueWithType(v6, @"LocalAddress", CFSTRING_TYPE))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1132;
    v156 = 2112;
    v157 = @"LocalAddress";
    v158 = 2048;
    v159 = CFSTRING_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_193;
  }

  if (CFDictionaryContainsKey(v6, @"LocalPort") && !NEGetValueWithType(v6, @"LocalPort", CFNUMBER_TYPE))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1133;
    v156 = 2112;
    v157 = @"LocalPort";
    v158 = 2048;
    v159 = CFNUMBER_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_193;
  }

  if (CFDictionaryContainsKey(v6, @"LocalAddress"))
  {
    -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"LocalAddress");
    uint64_t v8 = (__CFString *)objc_claimAutoreleasedReturnValue();
    -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"LocalPort");
    id v9 = (void *)objc_claimAutoreleasedReturnValue();
    CFStringRef v10 = NECreateAddressStructFromString(v8, (uint64_t)v9, 0LL);

    if (!v10)
    {
      ne_log_obj();
      BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_229;
      }
      -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"LocalAddress");
      uint64_t v35 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
      v96 = -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"LocalPort");
      *(_DWORD *)buf = 136315906;
      v153 = "NEIPSecIKEValidateIKEDictionary";
      v154 = 1024;
      v155 = 1140;
      v156 = 2112;
      v157 = (const __CFString *)v35;
      v158 = 2112;
      v159 = (uint64_t)v96;
      v97 = "%s:%d: Failed to parse local address %@:%@";
      goto LABEL_182;
    }

    [MEMORY[0x189608DE8] endpointWithAddress:v10];
    CFStringRef v11 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESAConfiguration setLocalEndpoint:](v2, "setLocalEndpoint:", v11);

    free(v10);
  }

  if (!NEGetValueWithType(v6, @"RemoteAddress", CFSTRING_TYPE))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1147;
    v156 = 2112;
    v157 = @"RemoteAddress";
    v158 = 2048;
    v159 = CFSTRING_TYPE;
    v95 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_193;
  }

  if (CFDictionaryContainsKey(v6, @"RemotePort") && !NEGetValueWithType(v6, @"RemotePort", CFNUMBER_TYPE))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1148;
    v156 = 2112;
    v157 = @"RemotePort";
    v158 = 2048;
    v159 = CFNUMBER_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_193;
  }

  -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"RemoteAddress");
  uint64_t v12 = (__CFString *)objc_claimAutoreleasedReturnValue();
  -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"RemotePort");
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v14 = NECreateAddressStructFromString(v12, (uint64_t)v13, 0LL);

  if (!v14)
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"RemoteAddress");
    uint64_t v35 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
    v96 = -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"RemotePort");
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1154;
    v156 = 2112;
    v157 = (const __CFString *)v35;
    v158 = 2112;
    v159 = (uint64_t)v96;
    v97 = "%s:%d: Failed to parse remote address %@:%@";
LABEL_182:
    _os_log_error_impl(&dword_1876B1000, v25, OS_LOG_TYPE_ERROR, v97, buf, 0x26u);

    goto LABEL_228;
  }

  [MEMORY[0x189608DE8] endpointWithAddress:v14];
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2IKESAConfiguration setRemoteEndpoint:](v2, "setRemoteEndpoint:", v15);

  free(v14);
  if (CFDictionaryContainsKey(v6, @"ServerMode") && !NEGetValueWithType(v6, @"ServerMode", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1160;
    v156 = 2112;
    v157 = @"ServerMode";
    v158 = 2048;
    v159 = CFBOOLEAN_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_193;
  }

  if (CFDictionaryContainsKey(v6, @"ServerMode"))
  {
    -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"ServerMode");
    int v16 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESAConfiguration setServerMode:](v2, "setServerMode:", [v16 BOOLValue]);
  }

  if (CFDictionaryContainsKey(v6, @"NonceSize") && !NEGetValueWithType(v6, @"NonceSize", CFNUMBER_TYPE))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1165;
    v156 = 2112;
    v157 = @"NonceSize";
    v158 = 2048;
    v159 = CFNUMBER_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_193;
  }

  if (CFDictionaryContainsKey(v6, @"NonceSize"))
  {
    -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"NonceSize");
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESAConfiguration setNonceSize:](v2, "setNonceSize:", [v17 unsignedIntValue]);
  }

  if (CFDictionaryContainsKey(v6, @"RedirectSupported")
    && !NEGetValueWithType(v6, @"RedirectSupported", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1170;
    v156 = 2112;
    v157 = @"RedirectSupported";
    v158 = 2048;
    v159 = CFBOOLEAN_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_193;
  }

  if (CFDictionaryContainsKey(v6, @"RedirectSupported"))
  {
    -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"RedirectSupported");
    int v18 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESAConfiguration setAllowRedirect:](v2, "setAllowRedirect:", [v18 BOOLValue]);
  }

  if (CFDictionaryContainsKey(v6, @"RedirectedFromServer")
    && !NEGetValueWithType(v6, @"RedirectedFromServer", CFSTRING_TYPE))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1175;
    v156 = 2112;
    v157 = @"RedirectedFromServer";
    v158 = 2048;
    v159 = CFSTRING_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_193;
  }

  if (CFDictionaryContainsKey(v6, @"RedirectedFromServer"))
  {
    -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"RedirectedFromServer");
    unint64_t v19 = (__CFString *)objc_claimAutoreleasedReturnValue();
    int v20 = NECreateAddressStructFromString(v19, 0LL, 0LL);

    if (!v20)
    {
      ne_log_obj();
      BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"RedirectedFromServer");
        uint64_t v35 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136315650;
        v153 = "NEIPSecIKEValidateIKEDictionary";
        v154 = 1024;
        v155 = 1181;
        v156 = 2112;
        v157 = (const __CFString *)v35;
        v100 = "%s:%d: Failed to parse redirect address %@";
        v101 = v25;
        v102 = 28;
        goto LABEL_199;
      }

      goto LABEL_229;
    }

    [MEMORY[0x189608DE8] endpointWithAddress:v20];
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESAConfiguration setRedirectedFromServer:](v2, "setRedirectedFromServer:", v21);

    free(v20);
  }

  id v22 = (const __CFArray *)NEGetValueWithType(v6, @"Proposals", CFARRAY_TYPE);
  if (!v22)
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315394;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1190;
    v95 = "%s:%d: IKE configuration does not contain proposals array";
LABEL_202:
    v98 = v25;
    v99 = 18;
    goto LABEL_194;
  }

  uint64_t v23 = v22;
  CFIndex Count = CFArrayGetCount(v22);
  if (!Count)
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315394;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1195;
    v95 = "%s:%d: IKE configuration proposals array is empty";
    goto LABEL_202;
  }

  if (CFDictionaryContainsKey(v6, @"EAPProperties")
    && !NEGetValueWithType(v6, @"EAPProperties", CFDICTIONARY_TYPE))
  {
    ne_log_obj();
    BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_229;
    }
    *(_DWORD *)buf = 136315906;
    v153 = "NEIPSecIKEValidateIKEDictionary";
    v154 = 1024;
    v155 = 1199;
    v156 = 2112;
    v157 = @"EAPProperties";
    v158 = 2048;
    v159 = CFDICTIONARY_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_193;
  }

  unint64_t v24 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
  BOOL v25 = v24;
  if (Count < 1)
  {
LABEL_203:
    -[NEIKEv2IKESAConfiguration setProposals:](v2, "setProposals:", v25);
    CFErrorRef v90 = v2;
    goto LABEL_230;
  }

  int v26 = 0LL;
  v115 = v23;
  v116 = v24;
  while (1)
  {
    v118 = v26;
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(v23, v26);
    if (!ValueAtIndex) {
      break;
    }
    uint64_t v28 = ValueAtIndex;
    uint64_t v29 = CFDICTIONARY_TYPE;
    if (CFGetTypeID(ValueAtIndex) != v29) {
      break;
    }
    v119 = v28;
    int v30 = objc_alloc_init(&OBJC_CLASS___NEIKEv2IKESAProposal);
    unint64_t v31 = v30;
    if (v30) {
      v30->_proposalNumber = v118 + 1;
    }
    v120 = v30;
    if (!CFDictionaryContainsKey(v6, @"AuthenticationMethod"))
    {
      if (!NEGetValueWithType(v119, @"AuthenticationMethod", CFSTRING_TYPE))
      {
        ne_log_obj();
        unint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v153 = "NEIPSecIKEValidateIKEDictionary";
          v154 = 1024;
          v155 = 1216;
          v156 = 2112;
          v157 = @"AuthenticationMethod";
          v158 = 2048;
          v159 = CFSTRING_TYPE;
          _os_log_error_impl( &dword_1876B1000,  v32,  OS_LOG_TYPE_ERROR,  "%s:%d: value for key %@ is missing or type != %lu",  buf,  0x26u);
        }

        goto LABEL_226;
      }

      -[__CFDictionary objectForKeyedSubscript:](v119, "objectForKeyedSubscript:", @"AuthenticationMethod");
      unint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v33 = (void *)NEIPsecIKEGetAuthProcotol(v32);
      if (!v33)
      {
        ne_log_obj();
        int v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v153 = "NEIPSecIKEValidateIKEDictionary";
          v154 = 1024;
          v155 = 1220;
          v156 = 2112;
          v157 = (const __CFString *)v32;
          _os_log_error_impl( &dword_1876B1000,  v48,  OS_LOG_TYPE_ERROR,  "%s%d: %@ is not a recognized authentication method",  buf,  0x1Cu);
        }

LABEL_162:
LABEL_163:
      SEL v74 = 0LL;
      goto LABEL_164;
    }
  }

  if ((a4 & 1) == 0)
  {
    id v9 = v9;
    SEL v74 = v9;
    goto LABEL_164;
  }

  -[os_log_s kemProtocols](v9, "kemProtocols");
  uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
  [v8 kemProtocols];
  uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v65 = v64;
  if (!v64)
  {
    SEL v74 = v9;
    goto LABEL_155;
  }

  if (!v63)
  {
    id v75 = -[NEIKEv2KEMProtocol initWithMethod:](objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol), "initWithMethod:", 0LL);
    goto LABEL_90;
  }

  [v64 firstObject];
  int v66 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v67 = [v63 indexOfObject:v66];

  if (v67 != 0x7FFFFFFFFFFFFFFFLL)
  {
    [v63 objectAtIndexedSubscript:v67];
    id v75 = (NEIKEv2KEMProtocol *)objc_claimAutoreleasedReturnValue();
LABEL_90:
    unint64_t v77 = v75;
    if (!v75) {
      goto LABEL_144;
    }
    goto LABEL_91;
  }

  if (a3)
  {
    v135 = 0uLL;
    v136 = 0uLL;
    v133 = 0uLL;
    v134 = 0uLL;
    uint64_t v68 = v65;
    uint64_t v69 = [v68 countByEnumeratingWithState:&v133 objects:v156 count:16];
    if (v69)
    {
      int v70 = v69;
      unint64_t v71 = *(void *)v134;
      while (2)
      {
        for (m = 0LL; m != v70; ++m)
        {
          if (*(void *)v134 != v71) {
            objc_enumerationMutation(v68);
          }
          uint64_t v73 = [v63 indexOfObject:*(void *)(*((void *)&v133 + 1) + 8 * m)];
          if (v73 != 0x7FFFFFFFFFFFFFFFLL)
          {
            [v63 objectAtIndexedSubscript:v73];
            v108 = (NEIKEv2KEMProtocol *)objc_claimAutoreleasedReturnValue();
            goto LABEL_142;
          }
        }

        int v70 = [v68 countByEnumeratingWithState:&v133 objects:v156 count:16];
        if (v70) {
          continue;
        }
        break;
      }
    }
  }

  else
  {
    v131 = 0uLL;
    v132 = 0uLL;
    v129 = 0uLL;
    v130 = 0uLL;
    uint64_t v68 = v63;
    int v81 = [v68 countByEnumeratingWithState:&v129 objects:v155 count:16];
    if (v81)
    {
      uint64_t v82 = v81;
      v83 = *(void *)v130;
      while (2)
      {
        for (n = 0LL; n != v82; ++n)
        {
          if (*(void *)v130 != v83) {
            objc_enumerationMutation(v68);
          }
          __int16 v85 = *(void **)(*((void *)&v129 + 1) + 8 * n);
          if ([v65 containsObject:v85])
          {
            v108 = v85;
LABEL_142:
            unint64_t v77 = v108;
            goto LABEL_143;
          }
        }

        uint64_t v82 = [v68 countByEnumeratingWithState:&v129 objects:v155 count:16];
        if (v82) {
          continue;
        }
        break;
      }
    }
  }

  unint64_t v77 = 0LL;
LABEL_143:

  if (!v77)
  {
LABEL_144:
    ne_log_obj();
    v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1876B1000, v109, OS_LOG_TYPE_ERROR, "No chosen KE method", buf, 2u);
    }

    SEL v74 = 0LL;
    goto LABEL_155;
  }

LABEL_82:
        int v58 = 0LL;
LABEL_87:
        int v51 = v99;
        goto LABEL_88;
      }
    }

    else
    {
      v110 = 0uLL;
      v111 = 0uLL;
      v108 = 0uLL;
      v109 = 0uLL;
      uint64_t v52 = (id)v44;
      uint64_t v59 = [v52 countByEnumeratingWithState:&v108 objects:v127 count:16];
      if (v59)
      {
        uint64_t v60 = v59;
        uint64_t v61 = *(void *)v109;
        while (2)
        {
          for (j = 0LL; j != v60; ++j)
          {
            if (*(void *)v109 != v61) {
              objc_enumerationMutation(v52);
            }
            uint64_t v63 = *(void **)(*((void *)&v108 + 1) + 8 * j);
            if ([v46 containsObject:v63])
            {
              uint64_t v64 = v63;
LABEL_86:
              int v58 = v64;
              goto LABEL_87;
            }
          }

          uint64_t v60 = [v52 countByEnumeratingWithState:&v108 objects:v127 count:16];
          if (v60) {
            continue;
          }
          goto LABEL_82;
        }
      }
    }

    int v58 = 0LL;
LABEL_88:

    goto LABEL_89;
  }

  [(id)v44 objectAtIndexedSubscript:v50];
  int v58 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_89:
  if (!v58)
  {
    ne_log_large_obj();
    int v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_INFO))
    {
      [(id)a1 kemProtocols];
      uint64_t v67 = (char *)objc_claimAutoreleasedReturnValue();
      [v8 kemProtocols];
      uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412546;
      v132 = v67;
      v133 = 2112;
      v134 = v68;
      _os_log_impl( &dword_1876B1000,  v66,  OS_LOG_TYPE_INFO,  "Failed to match Key Exchange methods (%@ vs %@)",  buf,  0x16u);
    }

    v124 = 0;
    goto LABEL_147;
  }

  [(id)a1 additionalKEMProtocols];
  uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue();
  if (v65)
  {
  }

  else
  {
    [v8 additionalKEMProtocols];
    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v69)
    {
      v124 = 1;
      goto LABEL_147;
    }
  }

  v94 = v44;
  v93 = v58;
  if ([v58 method]) {
    int v70 = (id)objc_msgSend(objc_alloc(MEMORY[0x189603FE0]), "initWithObjects:", v58, 0);
  }
  else {
    int v70 = objc_alloc_init(MEMORY[0x189603FE0]);
  }
  unint64_t v71 = v70;
  uint64_t v72 = 6LL;
  v95 = v46;
  while (1)
  {
    [MEMORY[0x189607968] numberWithUnsignedInteger:v72];
    uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue();
    [v8 additionalKEMProtocols];
    SEL v74 = (void *)objc_claimAutoreleasedReturnValue();
    id v75 = [v74 objectForKeyedSubscript:v73];

    [(id)a1 additionalKEMProtocols];
    uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v77 = [v76 objectForKeyedSubscript:v73];

    if (v75 | v77) {
      break;
    }
LABEL_134:

    if (++v72 == 13)
    {
      v124 = 1;
      goto LABEL_146;
    }
  }

  if (v75) {
    unint64_t v78 = v77 == 0;
  }
  else {
    unint64_t v78 = 1;
  }
  if (v78)
  {
    if (v75) {
      unint64_t v77 = (uint64_t)v96;
    }
    else {
      id v75 = (uint64_t)v96;
    }
    uint64_t v79 = v96;
  }

  v97 = v72;
  v98 = v73;
  if (v51)
  {
    v106 = 0uLL;
    v107 = 0uLL;
    v104 = 0uLL;
    v105 = 0uLL;
    uint64_t v80 = (id)v77;
    int v81 = [v80 countByEnumeratingWithState:&v104 objects:v126 count:16];
    if (!v81)
    {
      unint64_t v77 = (uint64_t)v80;
      goto LABEL_143;
    }

    uint64_t v82 = v81;
    v83 = *(void *)v105;
LABEL_113:
    uint64_t v84 = 0LL;
    while (1)
    {
      if (*(void *)v105 != v83) {
        objc_enumerationMutation(v80);
      }
      __int16 v85 = *(void **)(*((void *)&v104 + 1) + 8 * v84);
      if (([v71 containsObject:v85] & 1) == 0)
      {
      }

      if (v82 == ++v84)
      {
        uint64_t v82 = [v80 countByEnumeratingWithState:&v104 objects:v126 count:16];
        if (v82) {
          goto LABEL_113;
        }
        unint64_t v77 = (uint64_t)v80;
        goto LABEL_137;
      }
    }
  }

  v102 = 0uLL;
  v103 = 0uLL;
  v100 = 0uLL;
  v101 = 0uLL;
  uint64_t v80 = (id)v75;
  int v86 = [v80 countByEnumeratingWithState:&v100 objects:v125 count:16];
  if (v86)
  {
    __int16 v87 = v86;
    int v88 = *(void *)v101;
LABEL_123:
    uint64_t v89 = 0LL;
    while (1)
    {
      if (*(void *)v101 != v88) {
        objc_enumerationMutation(v80);
      }
      __int16 v85 = *(void **)(*((void *)&v100 + 1) + 8 * v89);
      if (([v71 containsObject:v85] & 1) == 0)
      {
      }

      if (v87 == ++v89)
      {
        __int16 v87 = [v80 countByEnumeratingWithState:&v100 objects:v125 count:16];
        if (v87) {
          goto LABEL_123;
        }
        id v75 = (uint64_t)v80;
LABEL_137:
        uint64_t v73 = v98;
        goto LABEL_143;
      }
    }

            goto LABEL_83;
          }

          *(_DWORD *)buf = 136315138;
          v167 = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyIKESAForInitiator:]";
          v124 = "%s called with null packet.ikeSA.isValid";
        }

        _os_log_fault_impl(&dword_1876B1000, v123, OS_LOG_TYPE_FAULT, v124, buf, 0xCu);
        goto LABEL_69;
      }

      id v22 = objc_alloc_init(&OBJC_CLASS___NEIKEv2IKESAProposal);
      unint64_t v24 = v22;
      if (v22) {
        v22->_proposalNumber = 1;
      }
      int v26 = (void *)objc_msgSend(objc_getProperty(v21, v23, 88, 1), "copy");
      if (v24) {
        objc_setProperty_atomic(v24, v25, v26, 88LL);
      }

      uint64_t v29 = (void *)objc_msgSend(objc_getProperty(v21, v27, 96, 1), "copy");
      if (v24) {
        objc_setProperty_atomic(v24, v28, v29, 96LL);
      }

      unint64_t v32 = (void *)objc_msgSend(objc_getProperty(v21, v30, 104, 1), "copy");
      if (v24) {
        objc_setProperty_atomic(v24, v31, v32, 104LL);
      }

      uint64_t v35 = (void *)objc_msgSend(objc_getProperty(v21, v33, 112, 1), "copy");
      if (v24) {
        objc_setProperty_atomic(v24, v34, v35, 112LL);
      }

      -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v21);
      int v36 = (void *)objc_claimAutoreleasedReturnValue();

      if (v36)
      {
        v149 = v24;
        v150 = v12;
        -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v21);
        uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v38 = [v37 count];
        unint64_t v40 = objc_msgSend(objc_getProperty(v21, v39, 120, 1), "count");

        if (v38 == v40)
        {
          unint64_t v42 = objc_alloc(MEMORY[0x189603F68]);
          -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v21);
          char v43 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v44 = (void *)[v42 initWithDictionary:v43 copyItems:1];
          -[NEIKEv2IKESAProposal setChosenAdditionalKEMProtocols:](v149, v44);

          unint64_t v24 = v149;
LABEL_48:
          uint64_t v12 = v150;
          unsigned __int16 v17 = v152;
          goto LABEL_49;
        }

        unint64_t v24 = v149;
        uint64_t v12 = v150;
        if (objc_getProperty(v21, v41, 120LL, 1))
        {
          v147 = (uint64_t)v9;
          v148 = v4;
          uint64_t v61 = objc_alloc_init(MEMORY[0x189603FC8]);
          v168 = 0u;
          v169 = 0u;
          v170 = 0u;
          v171 = 0u;
          uint64_t v63 = objc_getProperty(v21, v62, 120LL, 1);
          uint64_t v64 = [v63 countByEnumeratingWithState:&v168 objects:buf count:16];
          if (v64)
          {
            uint64_t v65 = v64;
            int v66 = *(void *)v169;
            do
            {
              for (CFIndex i = 0LL; i != v65; ++i)
              {
                if (*(void *)v169 != v66) {
                  objc_enumerationMutation(v63);
                }
                uint64_t v68 = *(void *)(*((void *)&v168 + 1) + 8 * i);
                -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v21);
                uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();
                [v69 objectForKeyedSubscript:v68];
                int v70 = (void *)objc_claimAutoreleasedReturnValue();
                [v61 setObject:v70 forKeyedSubscript:v68];
              }

              uint64_t v65 = [v63 countByEnumeratingWithState:&v168 objects:buf count:16];
            }

            while (v65);
          }

          unint64_t v71 = (void *)[objc_alloc(MEMORY[0x189603F68]) initWithDictionary:v61 copyItems:1];
          -[NEIKEv2IKESAProposal setChosenAdditionalKEMProtocols:](v149, v71);

          unint64_t v24 = v149;
          id v9 = (void *)v147;
          id v4 = v148;
          goto LABEL_48;
        }
      }
      }

      else
      {
        ne_log_obj();
        uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          v153 = @"/usr/libexec/SidecarRelay";
          _os_log_error_impl(&dword_1876B1000, v6, OS_LOG_TYPE_ERROR, "failed to get sidecarrelay UUID %@", buf, 0xCu);
        }

        unint64_t v31 = 0;
      }
    }

    else
    {
      ne_log_obj();
      id v4 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v153 = @"/usr/libexec/rapportd";
        _os_log_error_impl( &dword_1876B1000,  (os_log_t)v4,  OS_LOG_TYPE_ERROR,  "failed to get rapportd UUID %@",  buf,  0xCu);
      }

      unint64_t v31 = 0;
    }
  }

  else
  {
    ne_log_obj();
    uint64_t v3 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v3, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v153 = (const __CFString *)"-[NEAppSidecarPolicySession installPolicies]";
      _os_log_fault_impl( &dword_1876B1000,  (os_log_t)v3,  OS_LOG_TYPE_FAULT,  "%s called with null self.policySession",  buf,  0xCu);
    }

    unint64_t v31 = 0;
  }

  return v31;
}

    [NSString stringWithFormat:@"Invalid %@, valid values are 1.0, 1.1, and 1.2", v32, v87, v88, v89, v90, v91, v92, v93];
    goto LABEL_83;
  }

LABEL_117:
                goto LABEL_118;
              }

              self = (id)v60;
              if (v52) {
                unint64_t v77 = objc_getProperty(v52, v61, 96LL, 1);
              }
              else {
                unint64_t v77 = 0LL;
              }
              unint64_t v78 = v77;
              -[NEIKEv2IKESAProposal prfProtocol](v78, v79);
              uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();
              int v81 = [v80 nonceSize];

              unint64_t v42 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
              if ((unint64_t)self < v81)
              {
                ne_log_obj();
                int v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v63 = (char *)[(id)a1 copyShortDescription];
                  if (v52) {
                    v83 = objc_getProperty(v52, v82, 96LL, 1);
                  }
                  else {
                    v83 = 0LL;
                  }
                  uint64_t v84 = v83;
                  -[NEIKEv2IKESAProposal prfProtocol](v84, v85);
                  int v86 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)buf = 138412802;
                  v161 = v63;
                  v162 = 2048;
                  v163 = (uint64_t)self;
                  v164 = 2112;
                  v165 = (uint64_t)v86;
                  _os_log_error_impl( &dword_1876B1000,  v62,  OS_LOG_TYPE_ERROR,  "%@ NONCE data length %zu is shorter than the minimum for PRF protocol %@",  buf,  0x20u);

                  goto LABEL_113;
                }

                goto LABEL_117;
              }
            }

            objc_getProperty((id)a1, v55, v42[755], 1);
            __int16 v87 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v89 = v87;
            if (v87) {
              __int16 v87 = objc_getProperty(v87, v88, 24LL, 1);
            }
            CFErrorRef v90 = v87;
            objc_setProperty_atomic(v5, v91, v90, 88LL);

            v93 = objc_getProperty(v5, v92, 56LL, 1);
            v95 = -[NEIKEv2IKESAProposal kemProtocol](v93, v94);
            v96 = [v95 method];

            if (v96)
            {
              objc_getProperty((id)a1, v97, 104LL, 1);
              v98 = (void *)objc_claimAutoreleasedReturnValue();

              if (!v98)
              {
                ne_log_obj();
                int v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_117;
                }
                uint64_t v63 = (char *)[(id)a1 copyShortDescription];
                *(_DWORD *)buf = 138412290;
                v161 = v63;
                uint64_t v64 = "%@ Did not receive KE payload";
LABEL_111:
                uint64_t v65 = v62;
                int v66 = 12;
                goto LABEL_112;
              }

              objc_getProperty((id)a1, v99, 104LL, 1);
              v100 = (void *)objc_claimAutoreleasedReturnValue();
              v102 = v100;
              if (v100) {
                v100 = objc_getProperty(v100, v101, 24LL, 1);
              }
              v103 = v100;

              if (!v103)
              {
                ne_log_obj();
                int v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_117;
                }
                uint64_t v63 = (char *)[(id)a1 copyShortDescription];
                *(_DWORD *)buf = 138412290;
                v161 = v63;
                uint64_t v64 = "%@ Did not receive method in KE payload";
                goto LABEL_111;
              }

              objc_getProperty((id)a1, v104, 104LL, 1);
              v105 = (void *)objc_claimAutoreleasedReturnValue();
              v107 = v105;
              if (v105) {
                v105 = objc_getProperty(v105, v106, 32LL, 1);
              }
              v108 = v105;

              if (!v108)
              {
                ne_log_obj();
                int v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_117;
                }
                uint64_t v63 = (char *)[(id)a1 copyShortDescription];
                *(_DWORD *)buf = 138412290;
                v161 = v63;
                uint64_t v64 = "%@ Did not receive data in KE payload";
                goto LABEL_111;
              }

              objc_getProperty((id)a1, v109, 104LL, 1);
              v110 = (void *)objc_claimAutoreleasedReturnValue();
              selfa = v110;
              if (v110) {
                v110 = objc_getProperty(v110, v111, 24LL, 1);
              }
              v149 = v110;
              v151 = [v149 method];
              v113 = objc_getProperty(v5, v112, 56LL, 1);
              v115 = -[NEIKEv2IKESAProposal kemProtocol](v113, v114);
              v116 = [v115 method];

              if (v151 != v116)
              {
                ne_log_obj();
                int v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
                {
                  v152 = (char *)[(id)a1 copyShortDescription];
                  objc_getProperty((id)a1, v140, 104LL, 1);
                  v141 = (void *)objc_claimAutoreleasedReturnValue();
                  selfb = v141;
                  if (v141) {
                    v141 = objc_getProperty(v141, v142, 24LL, 1);
                  }
                  v150 = v141;
                  v148 = [v150 method];
                  v144 = objc_getProperty(v5, v143, 56LL, 1);
                  v146 = -[NEIKEv2IKESAProposal kemProtocol](v144, v145);
                  v147 = [v146 method];
                  *(_DWORD *)buf = 138412802;
                  v161 = v152;
                  v162 = 2048;
                  v163 = v148;
                  v164 = 2048;
                  v165 = v147;
                  _os_log_error_impl( &dword_1876B1000,  v62,  OS_LOG_TYPE_ERROR,  "%@ Did not receive matching method from KE payload (%zu != %zu)",  buf,  0x20u);
                }

                goto LABEL_117;
              }

              objc_getProperty((id)a1, v117, 104LL, 1);
              v118 = (void *)objc_claimAutoreleasedReturnValue();
              v120 = v118;
              if (v118) {
                v118 = objc_getProperty(v118, v119, 32LL, 1);
              }
              v121 = v118;
              objc_setProperty_atomic(v5, v122, v121, 104LL);

              v123 = -[NEIKEv2Packet copyNotification:]((void *)a1, (const char *)0x4039);
              objc_setProperty_atomic(v5, v124, v123, 128LL);
            }

            else
            {
              objc_setProperty_atomic(v5, v97, 0LL, 112LL);
            }

            objc_getProperty((id)a1, v125, 128LL, 1);
            v126 = (void *)objc_claimAutoreleasedReturnValue();
            v128 = v126;
            if (v126) {
              v126 = objc_getProperty(v126, v127, 24LL, 1);
            }
            v129 = v126;
            -[NEIKEv2ChildSA setInitiatorTrafficSelectors:](v5, v129);
            v131 = -[NEIKEv2ChildSA initiatorTrafficSelectors](v5, v130);
            if (v131)
            {
              objc_getProperty((id)a1, v132, 136LL, 1);
              v133 = (void *)objc_claimAutoreleasedReturnValue();
              v135 = v133;
              if (v133) {
                v133 = objc_getProperty(v133, v134, 24LL, 1);
              }
              v136 = v133;
              -[NEIKEv2ChildSA setResponderTrafficSelectors:](v5, v136);
              v138 = -[NEIKEv2ChildSA responderTrafficSelectors](v5, v137);
              if (v138)
              {
                a1 = 1LL;
LABEL_119:

                goto LABEL_120;
              }

              ne_log_obj();
              int v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
                goto LABEL_117;
              }
              uint64_t v63 = (char *)[(id)a1 copyShortDescription];
              *(_DWORD *)buf = 138412290;
              v161 = v63;
              uint64_t v64 = "%@ Could not set responder traffic selectors";
            }

            else
            {
              ne_log_obj();
              int v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
                goto LABEL_117;
              }
              uint64_t v63 = (char *)[(id)a1 copyShortDescription];
              *(_DWORD *)buf = 138412290;
              v161 = v63;
              uint64_t v64 = "%@ Could not set initiator traffic selectors";
            }

            goto LABEL_111;
          }

          ne_log_obj();
          uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled((os_log_t)v52, OS_LOG_TYPE_ERROR))
          {
            uint64_t v68 = (char *)[(id)a1 copyShortDescription];
            *(_DWORD *)buf = 138412290;
            v161 = v68;
            int v70 = "%@ Did not receive NONCE data";
            goto LABEL_66;
          }

            _os_log_fault_impl(&dword_1876B1000, v80, OS_LOG_TYPE_FAULT, v227, buf, 0xCu);
            goto LABEL_118;
          }

          ne_log_obj();
          v179 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v282 = (const char *)a1;
            _os_log_error_impl( &dword_1876B1000,  v179,  OS_LOG_TYPE_ERROR,  "%@ Failed to generate local crypto values (receive)",  buf,  0xCu);
          }

          v147 = objc_getProperty(a1, v180, 336LL, 1);
          ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorCrypto( @"Failed to generate local crypto values (receive)",  v181,  v182,  v183,  v184,  v185,  v186,  v187,  v258);
          goto LABEL_76;
        }

        if (v269 == 17)
        {
          objc_getProperty(v4, v23, 104LL, 1);
          v159 = (void *)objc_claimAutoreleasedReturnValue();
          v161 = v159;
          if (v159) {
            v159 = objc_getProperty(v159, v160, 24LL, 1);
          }
          uint64_t v14 = v159;

          v163 = objc_getProperty(v9, v162, 96LL, 1);
          v165 = -[NEIKEv2IKESAProposal kemProtocol](v163, v164);
          *(_WORD *)v279 = bswap32([v165 method]) >> 16;
          v166 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:v279 length:2];
          v167 = +[NEIKEv2IKESAInitPacket createIKESAInitResponse:errorCode:errorData:]( (uint64_t)&OBJC_CLASS___NEIKEv2IKESAInitPacket,  v4,  0x11uLL,  v166);
          if (v167)
          {
            v168 = -[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v167, 0LL);
            v177 = objc_getProperty(a1, v169, 336LL, 1);
            if ((v168 & 1) != 0) {
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorCrypto( @"KE method received in IKE SA Init packet (%@) doesn't match selected (%@) (receive)",  v170,  v171,  v172,  v173,  v174,  v175,  v176,  (uint64_t)v14);
            }
            else {
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"SA INIT INVALID KE",  v170,  v171,  v172,  v173,  v174,  v175,  v176,  v258);
            }
          }

          else
          {
            ne_log_obj();
            v203 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v203, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v282 = (const char *)a1;
              _os_log_error_impl( &dword_1876B1000,  v203,  OS_LOG_TYPE_ERROR,  "%@ Failed to create IKE SA Init Invalid KE packet",  buf,  0xCu);
            }

            v177 = objc_getProperty(a1, v204, 336LL, 1);
            ErrorFailedToSend = (void *)NEIKEv2CreateErrorInternal( @"Failed to create IKE SA Init Invalid KE packet",  v205,  v206,  v207,  v208,  v209,  v210,  v211,  v258);
          }

          v221 = ErrorFailedToSend;
          -[NEIKEv2IKESA setState:error:]((uint64_t)v177, 3uLL, ErrorFailedToSend);

          -[NEIKEv2Session reportState](a1, v222);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v223);
        }

        else
        {
          ne_log_obj();
          v188 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v282 = (const char *)a1;
            _os_log_error_impl( &dword_1876B1000,  v188,  OS_LOG_TYPE_ERROR,  "%@ Failed to process IKE SA Init packet (receive)",  buf,  0xCu);
          }

          +[NEIKEv2IKESAInitPacket createIKESAInitResponse:errorCode:errorData:]( (uint64_t)&OBJC_CLASS___NEIKEv2IKESAInitPacket,  v4,  v269,  0LL);
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (v14)
          {
            v189 = -[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v14, 0LL);
            v198 = objc_getProperty(a1, v190, 336LL, 1);
            if ((v189 & 1) != 0) {
              ErrorInternal = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Failed to process IKE SA Init packet (receive)",  v191,  v192,  v193,  v194,  v195,  v196,  v197,  v258);
            }
            else {
              ErrorInternal = (void *)NEIKEv2CreateErrorFailedToSend( @"SA INIT refusal",  v191,  v192,  v193,  v194,  v195,  v196,  v197,  v258);
            }
          }

          else
          {
            ne_log_obj();
            v212 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v282 = (const char *)a1;
              _os_log_error_impl( &dword_1876B1000,  v212,  OS_LOG_TYPE_ERROR,  "%@ Failed to create IKE SA Init refusal packet",  buf,  0xCu);
            }

            v198 = objc_getProperty(a1, v213, 336LL, 1);
            ErrorInternal = (void *)NEIKEv2CreateErrorInternal( @"Failed to create IKE SA Init refusal packet",  v214,  v215,  v216,  v217,  v218,  v219,  v220,  v258);
          }

          v224 = ErrorInternal;
          -[NEIKEv2IKESA setState:error:]((uint64_t)v198, 3uLL, ErrorInternal);

          -[NEIKEv2Session reportState](a1, v225);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v226);
        }

LABEL_123:
  return a1;
}

            if ((v359 & 1) != 0)
            {
              id v7 = self;
              if ((-[NEIKEv2ChildSA generateInitialValues](v24) & 1) == 0)
              {
                ne_log_obj();
                v284 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v284, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl( &dword_1876B1000,  v284,  OS_LOG_TYPE_ERROR,  "Failed to generate local Child crypto values",  buf,  2u);
                }

                ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto( @"Failed to generate local Child crypto values",  v285,  v286,  v287,  v288,  v289,  v290,  v291,  v339);
                -[NEIKEv2ChildSA setState:error:]((uint64_t)v24, 3uLL, ErrorCrypto);

                -[NEIKEv2Session reportState](a1, v293);
                -[NEIKEv2Session resetChild:]((char *)a1, v24);
                goto LABEL_67;
              }

              v171 = objc_getProperty(v24, v170, 184LL, 1);
              v173 = v171;
              if (v171) {
                v171 = objc_getProperty(v171, v172, 112LL, 1);
              }
              v174 = v171;
              v175 = [v174 method];

              if (v175 && (-[NEIKEv2ChildSA processCurrentKeyExchange](v24, v176) & 1) == 0)
              {
                ne_log_obj();
                v338 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v338, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl(&dword_1876B1000, v338, OS_LOG_TYPE_ERROR, "Failed to process KE data", buf, 2u);
                }

                v302 = @"ailed to process KE data";
              }

              else
              {
                v177 = objc_getProperty(v24, v176, 184LL, 1);
                v360 = v177;
                [MEMORY[0x189603F18] arrayWithObjects:&v360 count:1];
                v178 = (void *)objc_claimAutoreleasedReturnValue();
                v179 = -[NEIKEv2Session generateSPIForChild:proposals:](a1, v24, v178);

                if ((v179 & 1) != 0)
                {
                  v180 = self;
                  v181 = v24;
                  objc_opt_self();
                  v182 = -[NEIKEv2Packet initResponse:]( (uint64_t)objc_alloc(&OBJC_CLASS___NEIKEv2CreateChildPacket),  v180);
                  if (!v182)
                  {
                    ne_log_obj();
                    v314 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v314, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_fault_impl( &dword_1876B1000,  v314,  OS_LOG_TYPE_FAULT,  "[[NEIKEv2CreateChildPacket alloc] initResponse:] failed",  buf,  2u);
                    }

                    v184 = 0LL;
                    v270 = 0LL;
                    goto LABEL_186;
                  }

                  v184 = (id)v182;
                  v185 = objc_getProperty(v181, v183, 48LL, 1);
                  v186 = [v185 mode];

                  if (v186 == 1 && !-[NEIKEv2Packet addNotification:data:](v184, 0x4007uLL, 0LL))
                  {
                    ne_log_obj();
                    v315 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v315, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      v316 = "[packet addNotification:NEIKEv2NotifyTypeUseTransportMode] failed";
                      v317 = v315;
                      v318 = 2;
LABEL_206:
                      _os_log_fault_impl(&dword_1876B1000, v317, OS_LOG_TYPE_FAULT, v316, buf, v318);
                      goto LABEL_185;
                    }

                    goto LABEL_185;
                  }

                  v187 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ChildSAPayload);
                  objc_setProperty_atomic(v184, v188, v187, 96LL);

                  v190 = objc_getProperty(v181, v189, 184LL, 1);
                  *(void *)v368 = v190;
                  [MEMORY[0x189603F18] arrayWithObjects:v368 count:1];
                  v191 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_getProperty(v184, v192, 96LL, 1);
                  v193 = (void *)objc_claimAutoreleasedReturnValue();
                  v195 = v193;
                  if (v193) {
                    objc_setProperty_atomic(v193, v194, v191, 24LL);
                  }

                  v197 = objc_getProperty(v181, v196, 184LL, 1);
                  v199 = -[NEIKEv2IKESAProposal kemProtocol](v197, v198);
                  v200 = [v199 method];

                  if (v200)
                  {
                    v202 = objc_alloc_init(&OBJC_CLASS___NEIKEv2KeyExchangePayload);
                    objc_setProperty_atomic(v184, v203, v202, 104LL);

                    v205 = objc_getProperty(v181, v204, 184LL, 1);
                    v207 = -[NEIKEv2IKESAProposal kemProtocol](v205, v206);
                    objc_getProperty(v184, v208, 104LL, 1);
                    v209 = (void *)objc_claimAutoreleasedReturnValue();
                    v211 = v209;
                    if (v209) {
                      objc_setProperty_atomic(v209, v210, v207, 24LL);
                    }

                    v213 = objc_getProperty(v181, v212, 112LL, 1);
                    v214 = v213;
                    if (v213) {
                      v215 = (void *)*((void *)v213 + 2);
                    }
                    else {
                      v215 = 0LL;
                    }
                    v216 = v215;
                    objc_getProperty(v184, v217, 104LL, 1);
                    v218 = (void *)objc_claimAutoreleasedReturnValue();
                    v220 = v218;
                    if (v218) {
                      objc_setProperty_atomic(v218, v219, v216, 32LL);
                    }

                    objc_getProperty(v184, v221, 104LL, 1);
                    v222 = (void *)objc_claimAutoreleasedReturnValue();
                    v223 = -[NEIKEv2Payload isValid]((uint64_t)v222);

                    if ((v223 & 1) == 0)
                    {
                      ne_log_obj();
                      v315 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v315, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 136315138;
                        *(void *)&void buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:childSA:]";
                        v316 = "%s called with null packet.ke.isValid";
                        goto LABEL_205;
                      }

                      goto LABEL_185;
                    }
                  }

                  objc_getProperty(v184, v201, 96LL, 1);
                  v224 = (void *)objc_claimAutoreleasedReturnValue();
                  v225 = -[NEIKEv2Payload isValid]((uint64_t)v224);

                  if ((v225 & 1) != 0)
                  {
                    v226 = objc_alloc_init(&OBJC_CLASS___NEIKEv2NoncePayload);
                    objc_setProperty_atomic(v184, v227, v226, 112LL);

                    objc_getProperty(v181, v228, 80LL, 1);
                    v229 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_getProperty(v184, v230, 112LL, 1);
                    v231 = (void *)objc_claimAutoreleasedReturnValue();
                    v233 = v231;
                    if (v231) {
                      objc_setProperty_atomic(v231, v232, v229, 24LL);
                    }

                    objc_getProperty(v184, v234, 112LL, 1);
                    v235 = (void *)objc_claimAutoreleasedReturnValue();
                    v236 = -[NEIKEv2Payload isValid]((uint64_t)v235);

                    if ((v236 & 1) != 0)
                    {
                      v237 = objc_alloc_init(&OBJC_CLASS___NEIKEv2InitiatorTrafficSelectorPayload);
                      objc_setProperty_atomic(v184, v238, v237, 128LL);

                      objc_getProperty(v181, v239, 72LL, 1);
                      v240 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_getProperty(v184, v241, 128LL, 1);
                      v242 = (void *)objc_claimAutoreleasedReturnValue();
                      v244 = v242;
                      if (v242) {
                        objc_setProperty_atomic(v242, v243, v240, 24LL);
                      }

                      objc_getProperty(v184, v245, 128LL, 1);
                      v246 = (void *)objc_claimAutoreleasedReturnValue();
                      v247 = -[NEIKEv2Payload isValid]((uint64_t)v246);

                      if ((v247 & 1) != 0)
                      {
                        v248 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ResponderTrafficSelectorPayload);
                        objc_setProperty_atomic(v184, v249, v248, 136LL);

                        objc_getProperty(v181, v250, 64LL, 1);
                        v251 = (void *)objc_claimAutoreleasedReturnValue();
                        objc_getProperty(v184, v252, 136LL, 1);
                        v253 = (void *)objc_claimAutoreleasedReturnValue();
                        v255 = v253;
                        if (v253) {
                          objc_setProperty_atomic(v253, v254, v251, 24LL);
                        }

                        objc_getProperty(v184, v256, 136LL, 1);
                        v257 = (void *)objc_claimAutoreleasedReturnValue();
                        v258 = -[NEIKEv2Payload isValid]((uint64_t)v257);

                        if ((v258 & 1) != 0)
                        {
                          v260 = objc_getProperty(v181, v259, 184LL, 1);
                          v262 = v260;
                          if (v260) {
                            v260 = objc_getProperty(v260, v261, 120LL, 1);
                          }
                          v263 = v260;

                          if (v263)
                          {
                            [MEMORY[0x189607AB8] UUID];
                            v264 = (void *)objc_claimAutoreleasedReturnValue();
                            *(_OWORD *)buf = 0uLL;
                            [v264 getUUIDBytes:buf];
                            v265 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:buf length:16];
                            v266 = +[NEIKEv2NotifyPayload createNotifyPayloadType:data:]( (uint64_t)&OBJC_CLASS___NEIKEv2NotifyPayload,  0x4039uLL,  v265);
                            objc_setProperty_atomic(v181, v267, v266, 128LL);

                            v269 = objc_getProperty(v181, v268, 128LL, 1);
                            -[NEIKEv2Packet addNotifyPayload:](v184, v269);
                          }

                          v184 = v184;
                          v270 = v184;
                          goto LABEL_186;
                        }

                        ne_log_obj();
                        v315 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v315, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)buf = 136315138;
                          *(void *)&void buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:childSA:]";
                          v316 = "%s called with null packet.tsr.isValid";
                          goto LABEL_205;
                        }

                        goto LABEL_185;
                      }

                      ne_log_obj();
                      v315 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v315, OS_LOG_TYPE_FAULT)) {
                        goto LABEL_185;
                      }
                      *(_DWORD *)buf = 136315138;
                      *(void *)&void buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:childSA:]";
                      v336 = "%s called with null packet.tsi.isValid";
                    }

                    else
                    {
                      ne_log_obj();
                      v315 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v315, OS_LOG_TYPE_FAULT)) {
                        goto LABEL_185;
                      }
                      *(_DWORD *)buf = 136315138;
                      *(void *)&void buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:childSA:]";
                      v336 = "%s called with null packet.nonce.isValid";
                    }

                    _os_log_fault_impl(&dword_1876B1000, v315, OS_LOG_TYPE_FAULT, v336, buf, 0xCu);
                    goto LABEL_185;
                  }

                  ne_log_obj();
                  v315 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v315, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)buf = 136315138;
                    *(void *)&void buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:childSA:]";
                    v316 = "%s called with null packet.childSA.isValid";
LABEL_205:
                    v317 = v315;
                    v318 = 12;
                    goto LABEL_206;
                  }

__CFString *NEIKEv2HashTypeCreateString(unint64_t a1)
{
  if (a1 >= 6) {
    return (__CFString *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"Unknown(%lld)", a1);
  }
  else {
    return off_18A08CDF0[a1];
  }
}

LABEL_19:
    ne_log_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      String = NEIKEv2EncryptionWireTypeCreateString(*(void *)(v1 + 16));
      uint64_t v8 = 138412290;
      id v9 = String;
      _os_log_fault_impl( &dword_1876B1000,  v6,  OS_LOG_TYPE_FAULT,  "Unknown encryption wire type %@",  (uint8_t *)&v8,  0xCu);
    }

    return 24LL;
  }

  return result;
}

              a1 = 1LL;
LABEL_27:

              goto LABEL_28;
            }

            ne_log_obj();
            unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
              goto LABEL_25;
            }
            uint64_t v56 = 134217984;
            unint64_t v57 = (const char *)v38;
            unint64_t v32 = "[NEMutableSensitiveData mutableSensitiveDataWithMaxCapacity:%zu] failed";
LABEL_38:
            int v54 = v31;
            BOOL v55 = 12;
            goto LABEL_33;
          }

          ne_log_obj();
          int v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v51, OS_LOG_TYPE_FAULT)) {
            goto LABEL_23;
          }
          uint64_t v56 = 136315138;
          unint64_t v57 = "-[NEIKEv2IKESA(Crypto) updateIntAuthWithPacket:]";
          uint64_t v52 = "%s called with null self.skPi";
        }

        else
        {
          objc_getProperty((id)a1, v11, 248LL, 1);
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();

          if (v13)
          {
            objc_getProperty((id)a1, v14, 200LL, 1);
            unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
            int v16 = [v15 length];
            unsigned __int16 v17 = [v12 length] + v16;

            unint64_t v19 = +[NSMutableData mutableSensitiveDataWithMaxCapacity:](MEMORY[0x189603FB8], v17);
            if (v19)
            {
              objc_getProperty((id)a1, v18, 200LL, 1);
              int v20 = (void *)objc_claimAutoreleasedReturnValue();
              -[__CFData appendData:](v19, "appendData:", v20);

              -[__CFData appendData:](v19, "appendData:", v12);
              objc_getProperty((id)a1, v21, 248LL, 1);
              id v22 = (void *)objc_claimAutoreleasedReturnValue();
              unint64_t v24 = objc_getProperty((id)a1, v23, 96LL, 1);
              -[NEIKEv2IKESAProposal prfProtocol](v24, v25);
              int v26 = (void *)objc_claimAutoreleasedReturnValue();
              id v27 = +[NEIKEv2Crypto createHMACFromData:key:prfProtocol:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  v19,  v22,  v26);
              objc_setProperty_atomic((id)a1, v28, v27, 200LL);

              objc_getProperty((id)a1, v29, 200LL, 1);
              int v30 = (void *)objc_claimAutoreleasedReturnValue();

              if (!v30)
              {
                ne_log_obj();
                unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
                {
                  LOWORD(v56) = 0;
                  unint64_t v32 = "[NEIKEv2Crypto createHMACFromData:key:prfProtocol:] failed";
LABEL_32:
                  int v54 = v31;
                  BOOL v55 = 2;
LABEL_33:
                  _os_log_fault_impl(&dword_1876B1000, v54, OS_LOG_TYPE_FAULT, v32, (uint8_t *)&v56, v55);
                  goto LABEL_25;
                }

                goto LABEL_25;
              }

              goto LABEL_19;
            }

            ne_log_obj();
            unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
              goto LABEL_25;
            }
            uint64_t v56 = 134217984;
            unint64_t v57 = (const char *)v17;
            unint64_t v32 = "[NEMutableSensitiveData mutableSensitiveDataWithMaxCapacity:%zu] failed";
            goto LABEL_38;
          }

          ne_log_obj();
          int v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v51, OS_LOG_TYPE_FAULT)) {
            goto LABEL_23;
          }
          uint64_t v56 = 136315138;
          unint64_t v57 = "-[NEIKEv2IKESA(Crypto) updateIntAuthWithPacket:]";
          uint64_t v52 = "%s called with null self.skPr";
        }

        _os_log_fault_impl(&dword_1876B1000, v51, OS_LOG_TYPE_FAULT, v52, (uint8_t *)&v56, 0xCu);
LABEL_23:

        goto LABEL_26;
      }

      ne_log_obj();
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_FAULT))
      {
        uint64_t v56 = 136315138;
        unint64_t v57 = "-[NEIKEv2IKESA(Crypto) updateIntAuthWithPacket:]";
        int v33 = "%s called with null packet.authenticatedData";
        goto LABEL_15;
      }
    }

    else
    {
      ne_log_obj();
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_FAULT))
      {
        uint64_t v56 = 136315138;
        unint64_t v57 = "-[NEIKEv2IKESA(Crypto) updateIntAuthWithPacket:]";
        int v33 = "%s called with null self.chosenProposal.prfProtocol";
LABEL_15:
        _os_log_fault_impl(&dword_1876B1000, (os_log_t)v12, OS_LOG_TYPE_FAULT, v33, (uint8_t *)&v56, 0xCu);
      }
    }

    uint64_t v23 = 0LL;
    goto LABEL_7;
  }

  self = (NEIKEv2Listener *) -[NEIKEv2Listener initWithListenerIKEConfig:saSession:kernelSASessionName:listenerUDPPort:listenerInterface:listenerQueue:delegate:delegateQueue:includeP2P:]( self,  v15,  v16,  0LL,  v17,  v18,  v19,  v20,  v21,  0);
  uint64_t v23 = self;
LABEL_7:

  return v23;
}

    uint64_t v23 = 0LL;
    goto LABEL_7;
  }

  self = (NEIKEv2Listener *) -[NEIKEv2Listener initWithListenerIKEConfig:saSession:kernelSASessionName:listenerUDPPort:listenerInterface:listenerQueue:delegate:delegateQueue:includeP2P:]( self,  v15,  0LL,  v16,  v17,  v18,  v19,  v20,  v21,  0);
  uint64_t v23 = self;
LABEL_7:

  return v23;
}

      ++v25;
    }

    while (v23 != v25);
    uint64_t v29 = [v22 countByEnumeratingWithState:&v109 objects:buf count:16];
    uint64_t v23 = v29;
  }

  while (v29);
LABEL_24:

  if ([v21 count])
  {
    int v30 = -[NEDNSSettings initWithServers:](objc_alloc(&OBJC_CLASS___NEDNSSettings), "initWithServers:", v21);
    if ([v98 count]) {
      -[NEDNSSettings setMatchDomains:](v30, "setMatchDomains:", v98);
    }
  }

  else
  {
    int v30 = 0LL;
  }

  -[NETunnelNetworkSettings setDNSSettings:](v96, "setDNSSettings:", v30);
  uint64_t v35 = objc_getProperty(self, v34, 88LL, 1);
  uint64_t v37 = objc_getProperty(self, v36, 96LL, 1);
  int v39 = objc_getProperty(self, v38, 104LL, 1);
  unint64_t v40 = v35;
  unint64_t v41 = v37;
  v99 = v39;
  objc_opt_self();
  v111 = 0u;
  v112 = 0u;
  v109 = 0u;
  v110 = 0u;
  unint64_t v42 = v40;
  char v43 = (NEIPv4Settings *)[v42 countByEnumeratingWithState:&v109 objects:buf count:16];
  if (!v43)
  {
    uint64_t v45 = 0LL;
    uint64_t v44 = 0LL;
    uint64_t v53 = v42;
    goto LABEL_56;
  }

  uint64_t v44 = 0LL;
  uint64_t v45 = 0LL;
  int v46 = *(void *)v110;
  while (2)
  {
    int64_t v47 = 0LL;
    while (2)
    {
      if (*(void *)v110 != v46) {
        objc_enumerationMutation(v42);
      }
      int v48 = *(void **)(*((void *)&v109 + 1) + 8 * v47);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        [v48 address];
        uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v50 = [v49 hostname];
        int v51 = v45;
        uint64_t v45 = (void *)v50;
        goto LABEL_46;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        [v48 address];
        uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v52 = [v49 hostname];
        int v51 = v44;
        uint64_t v44 = (void *)v52;
LABEL_46:
      }

      if (v43 != (NEIPv4Settings *)++v47) {
        continue;
      }
      break;
    }

    char v43 = (NEIPv4Settings *)[v42 countByEnumeratingWithState:&v109 objects:buf count:16];
    if (v43) {
      continue;
    }
    break;
  }

  if (v45)
  {
    uint64_t v53 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603F18]), "initWithObjects:", v45, 0);
    if (v44) {
      int v54 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603F18]), "initWithObjects:", v44, 0);
    }
    else {
      int v54 = 0LL;
    }
    char v43 = -[NEIPv4Settings initWithAddresses:subnetMasks:]( objc_alloc(&OBJC_CLASS___NEIPv4Settings),  "initWithAddresses:subnetMasks:",  v53,  v54);
    +[NEIKEv2Helper createRouteArrayFromTunnelConfig:localTS:remoteTS:gatewayAddress:isIPv4:]( (uint64_t)&OBJC_CLASS___NEIKEv2Helper,  v42,  v41,  v99,  v45,  1);
    BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIPv4Settings setIncludedRoutes:](v43, "setIncludedRoutes:", v55);

LABEL_56:
  }

  else
  {
    char v43 = 0LL;
  }

  -[NEPacketTunnelNetworkSettings setIPv4Settings:](v96, "setIPv4Settings:", v43);
  unint64_t v57 = objc_getProperty(self, v56, 88LL, 1);
  uint64_t v59 = objc_getProperty(self, v58, 96LL, 1);
  uint64_t v61 = objc_getProperty(self, v60, 104LL, 1);
  int v62 = v57;
  uint64_t v63 = v59;
  v100 = v61;
  objc_opt_self();
  v111 = 0u;
  v112 = 0u;
  v109 = 0u;
  v110 = 0u;
  uint64_t v64 = (__CFString *)v62;
  uint64_t v65 = -[__CFString countByEnumeratingWithState:objects:count:]( v64,  "countByEnumeratingWithState:objects:count:",  &v109,  buf,  16LL);
  if (!v65)
  {
    uint64_t v80 = 0LL;
    uint64_t v67 = v64;
    goto LABEL_73;
  }

  int v66 = 0LL;
  uint64_t v67 = 0LL;
  uint64_t v68 = *(void *)v110;
  do
  {
    for (CFIndex i = 0LL; i != v65; ++i)
    {
      if (*(void *)v110 != v68) {
        objc_enumerationMutation(v64);
      }
      int v70 = *(void **)(*((void *)&v109 + 1) + 8 * i);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        [v70 address];
        unint64_t v71 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v72 = [v71 hostname];

        int v66 = [v70 prefix];
        uint64_t v67 = (__CFString *)v72;
      }
    }

    uint64_t v65 = -[__CFString countByEnumeratingWithState:objects:count:]( v64,  "countByEnumeratingWithState:objects:count:",  &v109,  buf,  16LL);
  }

  while (v65);

  if (v67)
  {
    uint64_t v73 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603F18]), "initWithObjects:", v67, 0);
    SEL v74 = objc_alloc(MEMORY[0x189603F18]);
    [MEMORY[0x189607968] numberWithInt:v66];
    id v75 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v76 = (void *)objc_msgSend(v74, "initWithObjects:", v75, 0);

    unint64_t v77 = -[NEIPv6Settings initWithAddresses:networkPrefixLengths:]( objc_alloc(&OBJC_CLASS___NEIPv6Settings),  "initWithAddresses:networkPrefixLengths:",  v73,  v76);
    unint64_t v78 = (__CFString *)NECreateIPv6SubnetAddressWithPrefix(v67, v66);
    if (v78)
    {
      +[NEIKEv2Helper createRouteArrayFromTunnelConfig:localTS:remoteTS:gatewayAddress:isIPv4:]( (uint64_t)&OBJC_CLASS___NEIKEv2Helper,  v64,  v63,  v100,  v78,  0);
      uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEIPv6Settings setIncludedRoutes:](v77, "setIncludedRoutes:", v79);

      uint64_t v80 = v77;
    }

    else
    {
      uint64_t v80 = 0LL;
    }

LABEL_73:
  }

  else
  {
    uint64_t v80 = 0LL;
  }

  -[NEPacketTunnelNetworkSettings setIPv6Settings:](v96, "setIPv6Settings:", v80);
  [MEMORY[0x189607968] numberWithUnsignedInteger:1280];
  int v81 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEPacketTunnelNetworkSettings setMTU:](v96, "setMTU:", v81);

  if (!v96)
  {
LABEL_29:
    ne_log_obj();
    unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&void buf[4] = self;
      _os_log_error_impl( &dword_1876B1000,  v31,  OS_LOG_TYPE_ERROR,  "%@: Stopping tunnel because create tunnel settings failed",  buf,  0xCu);
    }

    unint64_t v32 = v104[5];
    if (v32) {
      *(_BYTE *)(v32 + 77) = 1;
    }
    v102[0] = MEMORY[0x1895F87A8];
    v102[1] = 3221225472LL;
    v102[2] = __NEIKEv2PacketTunnelHandleConnected_block_invoke;
    v102[3] = &unk_18A08D4E0;
    v102[4] = &v103;
    -[NEIKEv2PacketTunnelProvider stopIKEv2TunnelWithReason:completionHandler:](self, 9LL, v102);
    int v33 = 0LL;
    goto LABEL_34;
  }

  *(void *)buf = 0LL;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  v114 = __Block_byref_object_copy__11387;
  v115 = __Block_byref_object_dispose__11388;
  uint64_t v82 = self;
  v116 = v82;
  v101[0] = MEMORY[0x1895F87A8];
  v101[1] = 3221225472LL;
  v101[2] = __NEIKEv2PacketTunnelHandleConnected_block_invoke_2;
  v101[3] = &unk_18A08D508;
  v101[4] = buf;
  [v82 setTunnelNetworkSettings:v96 completionHandler:v101];
  uint64_t v84 = objc_getProperty(v82, v83, 240LL, 1);
  int v86 = v84;
  if (v84)
  {
    __int16 v87 = objc_getProperty(v84, v85, 336LL, 1);
    if (v87)
    {
      int v88 = v87[12] & 1;
      goto LABEL_78;
    }
  }

  else
  {
    __int16 v87 = 0LL;
  }

  int v88 = 0;
LABEL_78:
  v82[76] = v88;

  CFErrorRef v90 = objc_getProperty(v82, v89, 240LL, 1);
  v92 = v90;
  if (v90)
  {
    v93 = objc_getProperty(v90, v91, 336LL, 1);
    if (v93)
    {
      v94 = v93[11] & 1;
      goto LABEL_81;
    }
  }

  else
  {
    v93 = 0LL;
  }

  v94 = 0;
LABEL_81:
  v82[79] = v94;

  _Block_object_dispose(buf, 8);
  int v33 = v96;
LABEL_34:

LABEL_35:
  _Block_object_dispose(&v103, 8);
}

LABEL_20:
  free(v3);
LABEL_26:
  unint64_t v15 = 0LL;
  return v15;
}

LABEL_25:
    ne_log_obj();
    id v27 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v27, OS_LOG_TYPE_DEFAULT))
    {
      -[NEProfileIngestion ingestedConfiguration](v2, "ingestedConfiguration");
      unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
      [v31 name];
      unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      uint64_t v61 = v32;
      _os_log_impl(&dword_1876B1000, (os_log_t)v27, OS_LOG_TYPE_DEFAULT, "%@: No set-aside configuration", buf, 0xCu);
    }
}
    }
  }

  else
  {
    id v4 = 0LL;
  }

  return v4;
}

    CFRelease(v18);
    goto LABEL_20;
  }

    uint64_t v21 = 0;
    goto LABEL_20;
  }

  if (v8) {
    id v9 = (NSString *)v8[7];
  }
  else {
    id v9 = 0LL;
  }
  CFStringRef v10 = NSClassFromString(v9);
  if (!v10)
  {
    ne_log_obj();
    int v16 = (id *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_ERROR))
    {
      if (v8) {
        BOOL v25 = v8[7];
      }
      else {
        BOOL v25 = 0LL;
      }
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v25;
      id v22 = "Failed to create a Class from %@";
      uint64_t v23 = (os_log_s *)v16;
      unint64_t v24 = 12;
      goto LABEL_16;
    }

    goto LABEL_19;
  }

  CFStringRef v11 = objc_alloc(v10);
  uint64_t v12 = v7;
  if (!v11
    || (v29.receiver = v11,
        v29.super_class = (Class)&OBJC_CLASS___NEExtensionProviderContext,
        (uint64_t v13 = -[NEProviderServer init](&v29, sel_init)) == 0LL))
  {

    ne_log_obj();
    int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      if (v8) {
        uint64_t v28 = v8[7];
      }
      else {
        uint64_t v28 = 0LL;
      }
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v28;
      _os_log_error_impl( &dword_1876B1000,  v26,  OS_LOG_TYPE_ERROR,  "Failed to instantiate a %@ object",  (uint8_t *)&buf,  0xCu);
    }

    int v16 = 0LL;
    goto LABEL_19;
  }

  [(id)objc_opt_class() _extensionAuxiliaryHostProtocol];
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
  [v12 setRemoteObjectInterface:v14];

  [(id)objc_opt_class() _extensionAuxiliaryVendorProtocol];
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  [v12 setExportedInterface:v15];

  [v12 setExportedObject:v13];
  *(void *)&buf = MEMORY[0x1895F87A8];
  *((void *)&buf + 1) = 3221225472LL;
  unint64_t v31 = __49__NEExtensionProviderContext_initWithConnection___block_invoke;
  unint64_t v32 = &unk_18A090390;
  int v16 = v13;
  int v33 = v16;
  [v12 setInvalidationHandler:&buf];
  [v12 resume];
  objc_storeStrong(v16 + 8, a4);

  unsigned __int16 v17 = self;
  objc_sync_enter(v17);
  contexts = v17->_contexts;
  if (!contexts)
  {
    unint64_t v19 = (NSMutableArray *)objc_alloc_init(MEMORY[0x189603FA8]);
    int v20 = v17->_contexts;
    v17->_contexts = v19;

    contexts = v17->_contexts;
  }

  -[NSMutableArray addObject:](contexts, "addObject:", v16);
  objc_sync_exit(v17);

  uint64_t v21 = 1;
LABEL_20:

  return v21;
}

    goto LABEL_20;
  }

  id v9 = *(void *)(a1 + 32);
  if (v9) {
    *(_BYTE *)(v9 + _Block_object_dispose((const void *)(v49 - 176), 8) = 1;
  }
  uint64_t v34 = 0u;
  uint64_t v35 = 0u;
  unint64_t v32 = 0u;
  int v33 = 0u;
  uint64_t v8 = (os_log_s *)v31;
  CFStringRef v10 = -[os_log_s countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v32,  v38,  16LL);
  if (!v10)
  {
LABEL_15:

    [*(id *)(a1 + 32) configuration];
    unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    [v17 VPN];
    int v18 = (void *)objc_claimAutoreleasedReturnValue();
    [v18 setEnabled:0];

    +[NEVPNManager loadedManagers]();
    unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    [*(id *)(a1 + 32) configuration];
    int v20 = (void *)objc_claimAutoreleasedReturnValue();
    [v20 identifier];
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    [v19 removeObjectForKey:v21];

    [*(id *)(a1 + 32) connection];
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    -[NEVPNConnection destroySession](v8);
LABEL_18:
    id v7 = 0LL;
    goto LABEL_19;
  }

  CFStringRef v11 = *(void *)v33;
LABEL_9:
  uint64_t v12 = 0LL;
  while (1)
  {
    if (*(void *)v33 != v11) {
      objc_enumerationMutation(v8);
    }
    uint64_t v13 = *(void **)(*((void *)&v32 + 1) + 8 * v12);
    uint64_t v14 = *(void **)(a1 + 32);
    [v13 VPN];
    unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    [v15 protocol];
    int v16 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(v14) = objc_msgSend(v14, "isProtocolTypeValid:", objc_msgSend(v16, "type"));

    if ((_DWORD)v14) {
      break;
    }
    if (v10 == ++v12)
    {
      CFStringRef v10 = -[os_log_s countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v32,  v38,  16LL);
      if (v10) {
        goto LABEL_9;
      }
      goto LABEL_15;
    }
  }

  [*(id *)(a1 + 32) setConfiguration:v13];
  id v22 = *(void *)(a1 + 32);
  +[NEVPNManager loadedManagers]();
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  [*(id *)(a1 + 32) configuration];
  unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  [v24 identifier];
  BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
  [v23 setObject:v22 forKeyedSubscript:v25];

  [*(id *)(a1 + 32) connection];
  int v26 = (void *)objc_claimAutoreleasedReturnValue();
  if (v26)
  {
    id v27 = v26[7] == 0LL;

    if (!v27) {
      goto LABEL_18;
    }
  }

  [*(id *)(a1 + 32) connection];
  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
  [*(id *)(a1 + 32) configuration];
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
  [v29 identifier];
  int v30 = (void *)objc_claimAutoreleasedReturnValue();
  if (v28) {
    -[NEVPNConnection createSessionWithConfigurationIdentifier:forceInfoFetch:completionHandler:]( v28,  v30,  0LL,  *(void **)(a1 + 40));
  }

  id v7 = 0LL;
LABEL_21:
  objc_sync_exit(v6);
}

  -[NEVPNProtocol passwordReference](self, "passwordReference");
  int v20 = (void *)objc_claimAutoreleasedReturnValue();

  if (v20)
  {
    -[NEVPNProtocol passwordReference](self, "passwordReference");
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v21 forKeyedSubscript:@"PasswordReference"];
  }

  -[NEVPNProtocolIPSec sharedSecretReference](self, "sharedSecretReference");
  id v22 = (void *)objc_claimAutoreleasedReturnValue();

  if (v22)
  {
    -[NEVPNProtocolIPSec sharedSecretReference](self, "sharedSecretReference");
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v23 forKeyedSubscript:@"SharedSecretReference"];
  }

  -[NEVPNProtocol identityReferenceInternal](self, "identityReferenceInternal");
  unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();

  if (v24)
  {
    -[NEVPNProtocol identityReferenceInternal](self, "identityReferenceInternal");
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v25 forKeyedSubscript:*MEMORY[0x18960C658]];
  }

  -[NEVPNProtocolIPSec sharedSecretKeychainItem](self, "sharedSecretKeychainItem");
  int v26 = (void *)objc_claimAutoreleasedReturnValue();

  if (v26)
  {
    -[NEVPNProtocolIPSec sharedSecretKeychainItem](self, "sharedSecretKeychainItem");
    id v27 = (void *)objc_claimAutoreleasedReturnValue();
    [v27 password];
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();

    -[NEVPNProtocolIPSec sharedSecretKeychainItem](self, "sharedSecretKeychainItem");
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    int v30 = v29;
    if (v28)
    {
      unint64_t v31 = [v29 password];

      int v30 = (void *)v31;
      if (!v31) {
        goto LABEL_34;
      }
      goto LABEL_28;
    }

    unint64_t v32 = [v29 identifier];
    if (!v32) {
      goto LABEL_33;
    }
    int v33 = (void *)v32;
    -[NEVPNProtocolIPSec sharedSecretKeychainItem](self, "sharedSecretKeychainItem");
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    [v34 persistentReference];
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();

    if (v35)
    {
      -[NEVPNProtocolIPSec sharedSecretKeychainItem](self, "sharedSecretKeychainItem");
      int v36 = (void *)objc_claimAutoreleasedReturnValue();
      [v36 identifier];
      int v30 = (void *)objc_claimAutoreleasedReturnValue();

      [v3 setObject:*MEMORY[0x18960CAE0] forKeyedSubscript:*MEMORY[0x18960C680]];
      if (v30)
      {
LABEL_28:
        [v3 setObject:v30 forKeyedSubscript:*MEMORY[0x18960C678]];
LABEL_33:
      }
    }
  }

uint64_t NEIKEv2ASN1CheckForNULLItem(uint64_t a1, _DWORD *a2)
{
  uint64_t v6 = 0LL;
  __int128 v5 = xmmword_187872CE0;
  if (*(void *)(a1 + 8))
  {
    int v3 = DERDecodeItem(a1, (unint64_t *)&v5);
    *a2 = v3;
    if (v3 || (v5 & 0x1FFFFFFFFFFFFFFFLL) != 5) {
      return 0LL;
    }
  }

  else
  {
    *a2 = 0;
  }

  return 1LL;
}

uint64_t NEIKEv2ASN1DecodeIntegerItem(uint64_t a1, int *a2)
{
  int v3 = DERDecodeItem(a1, &v7);
  if (v3)
  {
    int v4 = v3;
    uint64_t result = 0LL;
  }

  else if (v7 == 2)
  {
    int v4 = DERParseInteger(&v8, &v6);
    if (v4) {
      uint64_t result = 0LL;
    }
    else {
      uint64_t result = v6;
    }
  }

  else
  {
    uint64_t result = 0LL;
    int v4 = 2;
  }

  *a2 = v4;
  return result;
}

LABEL_72:
                          uint64_t v38 = v12;
                          int v39 = 2;
LABEL_73:
                          _os_log_error_impl(&dword_1876B1000, v38, OS_LOG_TYPE_ERROR, v36, (uint8_t *)v37, v39);
                          goto LABEL_64;
                        }

                        ne_log_obj();
                        uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_64;
                        }
                        int v62 = 67109120;
                        uint64_t v63 = v24;
                        int v36 = "Could not parse RSA-PSS HashAlgorithm parameters, error %d";
                      }

                      uint64_t v37 = &v62;
                      goto LABEL_118;
                    }

                    ne_log_obj();
                    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_64;
                    }
                    uint64_t v65 = 67109120;
                    int v66 = v21;
                    int v36 = "Incorrect RSA-PSS trailer field parameter value %u";
                  }
                }
              }

              uint64_t v37 = &v65;
              goto LABEL_118;
            }

            ne_log_obj();
            uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
              goto LABEL_54;
            }
            *(_DWORD *)buf = 67109378;
            *(_DWORD *)uint64_t v69 = v7;
            *(_WORD *)&v69[4] = 2112;
            *(void *)&v69[6] = v4;
            int v33 = "Unexpected NULL parameters for RSA-PSS, payload len %u payload %@";
LABEL_68:
            uint64_t v34 = v12;
            uint64_t v35 = 18;
LABEL_69:
            _os_log_error_impl(&dword_1876B1000, v34, OS_LOG_TYPE_ERROR, v33, buf, v35);
            goto LABEL_54;
          }

          CFStringRef v11 = 8LL;
        }

        uint64_t v14 = -[NEIKEv2AuthenticationProtocol initWithDigitalSignature:]( objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol),  "initWithDigitalSignature:",  v11);
        if (v14)
        {
          uint64_t v12 = (os_log_s *)v14;
          if ((v10 & 1) != 0) {
            goto LABEL_14;
          }
          ne_log_obj();
          unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412802;
            *(void *)uint64_t v69 = v12;
            *(_WORD *)&v69[8] = 1024;
            *(_DWORD *)&v69[10] = v7;
            *(_WORD *)&v69[14] = 2112;
            *(void *)&v69[16] = v4;
            _os_log_error_impl( &dword_1876B1000,  v15,  OS_LOG_TYPE_ERROR,  "Unexpected non-NULL parameters for %@, payload len %u payload %@",  buf,  0x1Cu);
          }

LABEL_54:
          uint64_t v12 = 0LL;
          goto LABEL_14;
        }

        goto LABEL_35;
      }

      unint64_t v41 = v54;
      ne_log_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)uint64_t v69 = v41;
      *(_WORD *)&v69[4] = 1024;
      *(_DWORD *)&v69[6] = v7;
      *(_WORD *)&v69[10] = 2112;
      *(void *)&v69[12] = v4;
      int v33 = "Could not parse AlgorithmIdentifier parameters, error %d payload len %u payload %@";
    }

    uint64_t v34 = v12;
    uint64_t v35 = 24;
    goto LABEL_69;
  }

  __int128 v5 = -[NEIKEv2AuthenticationProtocol initWithNonStandardDigitalSignature:]( objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol),  "initWithNonStandardDigitalSignature:",  3LL);
LABEL_13:
  uint64_t v12 = (os_log_s *)v5;
LABEL_14:

  return v12;
}

      EAPClientModulePluginFreePacket();

      goto LABEL_185;
    }

    ne_log_obj();
    int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v47, OS_LOG_TYPE_ERROR)) {
      goto LABEL_183;
    }
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&void buf[4] = v12;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v25;
    int v48 = "EAP payload could not be processed (code %d type %d)\n";
    uint64_t v49 = (os_log_s *)v47;
    uint64_t v50 = 14;
    goto LABEL_187;
  }

  uint64_t v13 = +[NEIKEv2EAP typeForPayload:]((uint64_t)&OBJC_CLASS___NEIKEv2EAP, v9);
  if (v11)
  {
    unint64_t v15 = objc_alloc_init(MEMORY[0x189603FB8]);
    v196 = 0u;
    v197 = 0u;
    v198 = 0u;
    v199 = 0u;
    int v16 = v11;
    unsigned __int16 v17 = [v16 countByEnumeratingWithState:&v196 objects:v206 count:16];
    if (v17)
    {
      int v18 = v17;
      unint64_t v19 = *(void *)v197;
      do
      {
        for (k = 0LL; k != v18; ++k)
        {
          if (*(void *)v197 != v19) {
            objc_enumerationMutation(v16);
          }
          uint64_t v21 = *(void **)(*((void *)&v196 + 1) + 8 * k);
          if (v21)
          {
            id v22 = [v21 method] - 2;
            if (v22 <= 5)
            {
              buf[0] = 0x190D061A1712uLL >> (8 * v22);
              [v15 appendBytes:buf length:1];
            }
          }
        }

        int v18 = [v16 countByEnumeratingWithState:&v196 objects:v206 count:16];
      }

      while (v18);
    }

    uint64_t v23 = -[NEIKEv2EAP createPayloadResponseForRequest:type:typeData:typeString:](v9, 3, v15, 0LL);
    unint64_t v24 = (void *)v23;
    if (a4) {
      *a4 = v23 != 0;
    }

    goto LABEL_185;
  }

  BOOL v25 = v13;
  if (v13 != 1) {
    goto LABEL_23;
  }
  if (v10) {
    uint64_t v52 = objc_getProperty(v10, v14, 88LL, 1);
  }
  else {
    uint64_t v52 = 0LL;
  }
  uint64_t v53 = v52;
  [v53 username];
  int v54 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v54)
  {
    if (v10) {
      uint64_t v56 = objc_getProperty(v10, v55, 88LL, 1);
    }
    else {
      uint64_t v56 = 0LL;
    }
    unint64_t v57 = v56;
    [v57 localIdentifier];
    int v58 = (void *)objc_claimAutoreleasedReturnValue();
    [v58 stringValue];
    int v54 = (void *)objc_claimAutoreleasedReturnValue();
  }

  uint64_t v59 = -[NEIKEv2EAP createPayloadResponseForRequest:type:typeData:typeString:](v9, 1, 0LL, v54);
  unint64_t v24 = (void *)v59;
  if (a4) {
    *a4 = v59 != 0;
  }

LABEL_185:
  return v24;
}

LABEL_77:
        goto LABEL_78;
      }

      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 138412290;
      v282 = (const char *)a1;
      v200 = "%@ Dropping IKE SA Init sent to non-server session";
      v201 = v14;
      v202 = 12;
    }

    _os_log_error_impl(&dword_1876B1000, v201, OS_LOG_TYPE_ERROR, v200, buf, v202);
    goto LABEL_72;
  }

              unint64_t v7 = self;
              goto LABEL_73;
            }

            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v45 = (void *)[self copyShortDescription];
              int64_t v47 = v11;
              int v48 = objc_getProperty(v16, v46, 56LL, 1);
              *(_DWORD *)buf = 138412802;
              v378 = v16;
              v379 = 2112;
              v380 = v45;
              v381 = 2112;
              v382 = (unint64_t)v48;
              _os_log_impl( &dword_1876B1000,  v44,  OS_LOG_TYPE_DEFAULT,  "%@ %@ Chose initiator new child proposal %@",  buf,  0x20u);

              CFStringRef v11 = v47;
            }

            unint64_t v7 = self;
            objc_getProperty(self, v49, 112LL, 1);
            uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();

            if (v50)
            {
              objc_getProperty(self, v51, 112LL, 1);
              uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
              int v54 = v52;
              if (v52) {
                uint64_t v52 = objc_getProperty(v52, v53, 24LL, 1);
              }
              BOOL v55 = v52;

              if (v55)
              {
                WeakRetained = objc_loadWeakRetained((id *)v16 + 3);
                v360 = WeakRetained;
                int v58 = v11;
                if (WeakRetained) {
                  WeakRetained = objc_getProperty(WeakRetained, v57, 80LL, 1);
                }
                uint64_t v59 = WeakRetained;
                uint64_t v60 = [v59 strictNonceSizeChecks];

                if (v60)
                {
                  objc_getProperty(self, v61, 112LL, 1);
                  int v62 = (void *)objc_claimAutoreleasedReturnValue();
                  uint64_t v64 = v62;
                  if (v62) {
                    int v62 = objc_getProperty(v62, v63, 24LL, 1);
                  }
                  uint64_t v65 = v62;
                  int v66 = [v65 length];

                  v358 = v66;
                  uint64_t v68 = (v66 != 15) & __CFADD__(v66 - 257, 242LL);
                  CFStringRef v11 = v58;
                  if (!v68)
                  {
                    ne_log_obj();
                    uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                    {
                      int v70 = (void *)[self copyShortDescription];
                      *(_DWORD *)buf = 138412802;
                      v378 = v16;
                      v379 = 2112;
                      v380 = v70;
                      v381 = 2048;
                      v382 = v358;
                      _os_log_error_impl( &dword_1876B1000,  v69,  OS_LOG_TYPE_ERROR,  "%@ %@ NONCE data length %zu is out of bounds",  buf,  0x20u);
                    }

                    goto LABEL_165;
                  }

                  v138 = v360;
                  if (v360) {
                    v138 = objc_getProperty(v360, v67, 96LL, 1);
                  }
                  v139 = v138;
                  v141 = -[NEIKEv2IKESAProposal prfProtocol](v139, v140);
                  v142 = [v141 nonceSize];

                  if (v358 < v142)
                  {
                    ne_log_obj();
                    uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                    {
                      v331 = (void *)[self copyShortDescription];
                      if (v360) {
                        v332 = objc_getProperty(v360, v330, 96LL, 1);
                      }
                      else {
                        v332 = 0LL;
                      }
                      v333 = v332;
                      v335 = -[NEIKEv2IKESAProposal prfProtocol](v333, v334);
                      *(_DWORD *)buf = 138413058;
                      v378 = v16;
                      v379 = 2112;
                      v380 = v331;
                      v381 = 2048;
                      v382 = v358;
                      v383 = 2112;
                      v384 = (uint64_t)v335;
                      _os_log_error_impl( &dword_1876B1000,  v69,  OS_LOG_TYPE_ERROR,  "%@ %@ NONCE data length %zu is shorter than the minimum for PRF protocol %@",  buf,  0x2Au);
                    }

                    CFStringRef v11 = v58;
                    goto LABEL_165;
                  }
                }

                objc_getProperty(self, v61, 112LL, 1);
                v143 = (void *)objc_claimAutoreleasedReturnValue();
                v145 = v143;
                if (v143) {
                  v143 = objc_getProperty(v143, v144, 24LL, 1);
                }
                v146 = v143;
                objc_setProperty_atomic(v16, v147, v146, 88LL);

                CFStringRef v11 = v58;
                v359 = v36;
                if (!-[NEIKEv2ChildSA shouldGenerateNewDHKeys](v16, v148))
                {
LABEL_115:
                  objc_getProperty(self, v149, 128LL, 1);
                  v177 = (void *)objc_claimAutoreleasedReturnValue();
                  v363 = v11;
                  if (v177)
                  {
                    v179 = v177;
                    v177 = objc_getProperty(v177, v178, 24LL, 1);
                  }

                  else
                  {
                    v179 = 0LL;
                  }

                  v180 = v177;
                  v182 = objc_getProperty(v16, v181, 48LL, 1);
                  [v182 remoteTrafficSelectors];
                  v183 = (void *)objc_claimAutoreleasedReturnValue();
                  v184 = +[NEIKEv2TrafficSelector copyConstrainedTrafficSelectorsForRequest:reply:]( (uint64_t)&OBJC_CLASS___NEIKEv2TrafficSelector,  (uint64_t)v180,  v183);
                  -[NEIKEv2ChildSA setInitiatorTrafficSelectors:](v16, v184);

                  objc_getProperty(self, v185, 136LL, 1);
                  v186 = (void *)objc_claimAutoreleasedReturnValue();
                  v188 = v186;
                  if (v186) {
                    v186 = objc_getProperty(v186, v187, 24LL, 1);
                  }
                  v189 = v186;
                  v191 = objc_getProperty(v16, v190, 48LL, 1);
                  [v191 localTrafficSelectors];
                  v192 = (void *)objc_claimAutoreleasedReturnValue();
                  v193 = +[NEIKEv2TrafficSelector copyConstrainedTrafficSelectorsForRequest:reply:]( (uint64_t)&OBJC_CLASS___NEIKEv2TrafficSelector,  (uint64_t)v189,  v192);
                  -[NEIKEv2ChildSA setResponderTrafficSelectors:](v16, v193);

                  unint64_t v7 = self;
                  v194 = self;
                  v195 = v16;
                  objc_opt_self();
                  if ((v16[9] & 1) != 0)
                  {
                    ne_log_obj();
                    v200 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v200, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)v385 = 136315138;
                      v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                      _os_log_fault_impl( &dword_1876B1000,  v200,  OS_LOG_TYPE_FAULT,  "%s called with null !childSA.isInitiator",  v385,  0xCu);
                    }

                    v271 = 0LL;
                    CFStringRef v11 = v363;
                    goto LABEL_179;
                  }

                  v197 = objc_getProperty(v195, v196, 56LL, 1);

                  CFStringRef v11 = v363;
                  if (v197)
                  {
                    v198 = -[NEIKEv2Packet initResponse:]( (uint64_t)objc_alloc(&OBJC_CLASS___NEIKEv2CreateChildPacket),  v194);
                    if (v198)
                    {
                      v200 = (os_log_s *)v198;
                      v201 = objc_getProperty(v195, v199, 48LL, 1);
                      v202 = [v201 mode];

                      if (v202 != 1 || -[NEIKEv2Packet addNotification:data:](v200, 0x4007uLL, 0LL))
                      {
                        v203 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ChildSAPayload);
                        objc_setProperty_atomic(v200, v204, v203, 96LL);

                        v206 = objc_getProperty(v195, v205, 48LL, 1);
                        [v206 proposals];
                        v207 = (void *)objc_claimAutoreleasedReturnValue();
                        objc_getProperty(v200, v208, 96LL, 1);
                        v209 = (void *)objc_claimAutoreleasedReturnValue();
                        v211 = v209;
                        if (v209) {
                          objc_setProperty_atomic(v209, v210, v207, 24LL);
                        }

                        objc_getProperty(v200, v212, 96LL, 1);
                        v213 = (void *)objc_claimAutoreleasedReturnValue();
                        v214 = -[NEIKEv2Payload isValid]((uint64_t)v213);

                        if ((v214 & 1) != 0)
                        {
                          if (-[NEIKEv2ChildSA shouldGenerateNewDHKeys](v195, v215))
                          {
                            v216 = objc_alloc_init(&OBJC_CLASS___NEIKEv2KeyExchangePayload);
                            objc_setProperty_atomic(v200, v217, v216, 104LL);

                            v219 = objc_getProperty(v195, v218, 56LL, 1);
                            v221 = -[NEIKEv2IKESAProposal kemProtocol](v219, v220);
                            objc_getProperty(v200, v222, 104LL, 1);
                            v223 = (void *)objc_claimAutoreleasedReturnValue();
                            v225 = v223;
                            if (v223) {
                              objc_setProperty_atomic(v223, v224, v221, 24LL);
                            }

                            v227 = objc_getProperty(v195, v226, 112LL, 1);
                            v228 = v227;
                            if (v227) {
                              v229 = (void *)*((void *)v227 + 2);
                            }
                            else {
                              v229 = 0LL;
                            }
                            v230 = v229;
                            objc_getProperty(v200, v231, 104LL, 1);
                            v232 = (void *)objc_claimAutoreleasedReturnValue();
                            v234 = v232;
                            if (v232) {
                              objc_setProperty_atomic(v232, v233, v230, 32LL);
                            }

                            objc_getProperty(v200, v235, 104LL, 1);
                            v236 = (void *)objc_claimAutoreleasedReturnValue();
                            v237 = -[NEIKEv2Payload isValid]((uint64_t)v236);

                            if ((v237 & 1) == 0)
                            {
                              ne_log_obj();
                              v280 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              if (!os_log_type_enabled(v280, OS_LOG_TYPE_FAULT)) {
                                goto LABEL_216;
                              }
                              *(_DWORD *)v385 = 136315138;
                              v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                              v281 = "%s called with null packet.ke.isValid";
                              goto LABEL_222;
                            }
                          }

                          v238 = objc_alloc_init(&OBJC_CLASS___NEIKEv2NoncePayload);
                          objc_setProperty_atomic(v200, v239, v238, 112LL);

                          objc_getProperty(v195, v240, 80LL, 1);
                          v241 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_getProperty(v200, v242, 112LL, 1);
                          v243 = (void *)objc_claimAutoreleasedReturnValue();
                          v245 = v243;
                          CFStringRef v11 = v363;
                          if (v243) {
                            objc_setProperty_atomic(v243, v244, v241, 24LL);
                          }

                          objc_getProperty(v200, v246, 112LL, 1);
                          v247 = (void *)objc_claimAutoreleasedReturnValue();
                          v248 = -[NEIKEv2Payload isValid]((uint64_t)v247);

                          if ((v248 & 1) != 0)
                          {
                            v249 = objc_alloc_init(&OBJC_CLASS___NEIKEv2InitiatorTrafficSelectorPayload);
                            objc_setProperty_atomic(v200, v250, v249, 128LL);
                            v252 = -[NEIKEv2ChildSA initiatorTrafficSelectors](v195, v251);
                            objc_getProperty(v200, v253, 128LL, 1);
                            v254 = (void *)objc_claimAutoreleasedReturnValue();
                            v256 = v254;
                            if (v254) {
                              objc_setProperty_atomic(v254, v255, v252, 24LL);
                            }

                            objc_getProperty(v200, v257, 128LL, 1);
                            v258 = (void *)objc_claimAutoreleasedReturnValue();
                            v259 = -[NEIKEv2Payload isValid]((uint64_t)v258);

                            if ((v259 & 1) != 0)
                            {
                              v260 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ResponderTrafficSelectorPayload);
                              objc_setProperty_atomic(v200, v261, v260, 136LL);
                              v263 = -[NEIKEv2ChildSA responderTrafficSelectors](v195, v262);
                              objc_getProperty(v200, v264, 136LL, 1);
                              v265 = (void *)objc_claimAutoreleasedReturnValue();
                              v267 = v265;
                              if (v265) {
                                objc_setProperty_atomic(v265, v266, v263, 24LL);
                              }

                              objc_getProperty(v200, v268, 136LL, 1);
                              v269 = (void *)objc_claimAutoreleasedReturnValue();
                              v270 = -[NEIKEv2Payload isValid]((uint64_t)v269);

                              if ((v270 & 1) != 0)
                              {
                                v200 = v200;
                                v271 = v200;
LABEL_217:
                                CFStringRef v11 = v363;
                                goto LABEL_179;
                              }

                              ne_log_obj();
                              v280 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              if (!os_log_type_enabled(v280, OS_LOG_TYPE_FAULT))
                              {
LABEL_216:

                                v271 = 0LL;
                                goto LABEL_217;
                              }

                              *(_DWORD *)v385 = 136315138;
                              v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                              v281 = "%s called with null packet.tsr.isValid";
LABEL_222:
                              _os_log_fault_impl(&dword_1876B1000, v280, OS_LOG_TYPE_FAULT, v281, v385, 0xCu);
                              goto LABEL_216;
                            }

                            ne_log_obj();
                            v276 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v276, OS_LOG_TYPE_FAULT))
                            {
                              *(_DWORD *)v385 = 136315138;
                              v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                              v277 = "%s called with null packet.tsi.isValid";
                              goto LABEL_176;
                            }

          NERemoveValueFromIntKeyedDictionary(v50, v156[0]);
          goto LABEL_141;
        }

        if (v9 != 23 || NEIPSecDBStatsHandleReply(a3, a1, v156, (_BYTE *)&v155 + 1, &v155))
        {
          uint64_t v21 = (os_log_s *)ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
          {
            id v22 = *(unsigned __int8 *)(v3 + 1);
            uint64_t v23 = v156[0];
            unint64_t v24 = *(_DWORD *)(v3 + 12);
            BOOL v25 = NEIPSecDBExtractSPIFromPFKeyMessage(a1);
            *(_DWORD *)buf = 138413314;
            v158 = a3;
            v159 = 1024;
            *(_DWORD *)v160 = v22;
            *(_WORD *)&v160[4] = 1024;
            *(_DWORD *)&v160[6] = v23;
            *(_WORD *)v161 = 1024;
            *(_DWORD *)&v161[2] = v24;
            v162 = 1024;
            v163 = bswap32(v25);
            _os_log_impl( &dword_1876B1000,  v21,  OS_LOG_TYPE_INFO,  "%@ Received PFKey Message associated with DB (type %d, SAID %u, pid %u, SPI %08X",  buf,  0x24u);
          }
        }

        switch(*(_BYTE *)(v3 + 1))
        {
          case 1:
            int v81 = a1[1];
            if (v81)
            {
              uint64_t v82 = bswap32(*(_DWORD *)(v81 + 4));
              v83 = @"SPIValue";
              goto LABEL_117;
            }

            int v54 = 1;
            goto LABEL_138;
          case 2:
            BOOL v55 = v156[0];
            uint64_t v56 = *(dispatch_semaphore_s **)(a3 + 96);
            int v54 = 2;
            goto LABEL_139;
          case 3:
            BOOL v55 = v156[0];
            uint64_t v56 = *(dispatch_semaphore_s **)(a3 + 96);
            int v54 = 3;
            goto LABEL_139;
          case 4:
            NERemoveValueFromIntKeyedDictionary(*(__CFDictionary **)(a3 + 80), v156[0]);
            uint64_t v84 = *(_DWORD *)(v3 + 12);
            if (v84 == getpid()) {
              goto LABEL_137;
            }
            uint64_t v63 = v156[0];
            uint64_t v64 = a3;
            uint64_t v65 = 9216;
            goto LABEL_114;
          case 5:
            int v58 = (const __CFAllocator *)*MEMORY[0x189604DB0];
            Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
            if (!Mutable) {
              goto LABEL_137;
            }
            uint64_t v60 = Mutable;
            uint64_t v61 = *(unsigned __int8 *)(v3 + 3);
            if (v61 == 3)
            {
              int v62 = @"ESP";
            }

            else
            {
              if (v61 != 2) {
                goto LABEL_151;
              }
              int v62 = @"AH";
            }

            CFDictionaryAddValue(Mutable, @"IPSecProtocol", v62);
LABEL_151:
            v99 = a1[9];
            if (v99) {
              NEAddDataToDictionary( v60,  @"EncryptionKey",  (UInt8 *)(v99 + 8),  *(unsigned __int16 *)(v99 + 4) >> 3);
            }
            v100 = a1[8];
            if (v100) {
              NEAddDataToDictionary(v60, @"AuthKey", (UInt8 *)(v100 + 8), *(unsigned __int16 *)(v100 + 4) >> 3);
            }
            v101 = a1[22];
            if (v101)
            {
              if (*(_BYTE *)(v101 + 52))
              {
                v102 = CFStringCreateWithCString(v58, (const char *)(v101 + 52), 0x600u);
                if (v102)
                {
                  v103 = v102;
                  CFDictionaryAddValue(v60, @"IPSecInterface", v102);
                  CFRelease(v103);
                }
              }

              if (*(_BYTE *)(v101 + 28))
              {
                v104 = CFStringCreateWithCString(v58, (const char *)(v101 + 28), 0x600u);
                if (v104)
                {
                  v105 = v104;
                  CFDictionaryAddValue(v60, @"OutgoingInterface", v104);
                  CFRelease(v105);
                }
              }

              if (*(_BYTE *)(v101 + 4))
              {
                v106 = CFStringCreateWithCString(v58, (const char *)(v101 + 4), 0x600u);
                if (v106)
                {
                  v107 = v106;
                  CFDictionaryAddValue(v60, @"InternalInterface", v106);
                  CFRelease(v107);
                }
              }

              if (*(_WORD *)(v101 + 76)) {
                CFDictionaryAddValue(v60, @"IntializeDisabled", (const void *)*MEMORY[0x189604DE8]);
              }
            }

            v108 = a1[2];
            if (v108)
            {
              v110 = (int *)a1[3];
              v109 = (int *)a1[4];
              v111 = time(0LL);
              NEAddDateToDictionary(v60, @"CreateTime", *(void *)(v108 + 16));
              NEAddDateToDictionary(v60, @"CurrentTime", v111);
              NEAddIntToDictionary(v60, @"DiffTime", v111 - *(_DWORD *)(v108 + 16));
              v112 = *(void *)(v108 + 24);
              if (v112) {
                NEAddDateToDictionary(v60, @"LastUseTime", v112);
              }
              NEAddIntToDictionary(v60, @"CurrentBytes", *(_DWORD *)(v108 + 8));
              NEAddIntToDictionary(v60, @"CurrentAllocations", *(_DWORD *)(v108 + 4));
              if (v110)
              {
                NEAddIntToDictionary(v60, @"HardLifetime", v110[4]);
                NEAddIntToDictionary(v60, @"HardUseTime", v110[6]);
                NEAddIntToDictionary(v60, @"HardBytes", v110[2]);
                NEAddIntToDictionary(v60, @"SoftAllocations", v110[1]);
              }

              if (v109)
              {
                NEAddIntToDictionary(v60, @"SoftLifetime", v109[4]);
                NEAddIntToDictionary(v60, @"SoftUseTime", v109[6]);
                NEAddIntToDictionary(v60, @"SoftBytes", v109[2]);
                NEAddIntToDictionary(v60, @"SoftAllocations", v109[1]);
              }
            }

            v113 = a1[1];
            if (!v113) {
              goto LABEL_202;
            }
            v114 = *(unsigned __int8 *)(v113 + 9);
            if (v114 <= 3) {
              CFDictionaryAddValue(v60, @"State", off_18A08E080[v114]);
            }
            NEAddIntToDictionary(v60, @"SPIValue", bswap32(*(_DWORD *)(v113 + 4)));
            NEAddIntToDictionary(v60, @"ReplayWindowSize", *(unsigned __int8 *)(v113 + 8));
            v115 = *(unsigned __int8 *)(v113 + 11);
            switch(v115)
            {
              case 1:
                v116 = @"DES";
                break;
              case 12:
                v116 = @"AES-128";
                break;
              case 2:
                v116 = @"3DES";
                break;
              default:
                goto LABEL_193;
            }

            CFDictionaryAddValue(v60, @"EncryptionAlgorithm", v116);
LABEL_193:
            if ((*(_BYTE *)(v113 + 10) - 1) <= 7u && ((0xE3u >> (*(_BYTE *)(v113 + 10) - 1)) & 1) != 0) {
              CFDictionaryAddValue( v60,  @"AuthAlgorithm",  off_18A08E0A0[(*(_BYTE *)(v113 + 10) - 1)]);
            }
            if ((*(_BYTE *)(v113 + 12) & 2) == 0) {
              goto LABEL_202;
            }
            v120 = (const void *)*MEMORY[0x189604DE8];
            CFDictionaryAddValue(v60, @"NATTraversal", (const void *)*MEMORY[0x189604DE8]);
            v121 = *(_DWORD *)(v113 + 12);
            if ((v121 & 4) != 0)
            {
              CFDictionaryAddValue(v60, @"NATTKeepAlive", v120);
              v121 = *(_DWORD *)(v113 + 12);
              if ((v121 & 0x8000) == 0)
              {
LABEL_199:
                if ((v121 & 0x1000) == 0) {
                  goto LABEL_201;
                }
                goto LABEL_200;
              }
            }

            else if ((v121 & 0x8000) == 0)
            {
              goto LABEL_199;
            }

            CFDictionaryAddValue(v60, @"NATTKeepAliveOffload", v120);
            if ((*(_DWORD *)(v113 + 12) & 0x1000) != 0) {
LABEL_200:
            }
              CFDictionaryAddValue(v60, @"NATTDetectedPeer", v120);
LABEL_201:
            NEAddIntToDictionary(v60, @"ReplayWindowSize", *(unsigned __int16 *)(v113 + 16));
LABEL_202:
            v122 = a1[19];
            if (!v122) {
              goto LABEL_210;
            }
            v123 = *(unsigned __int8 *)(v122 + 4);
            if (v123 == 1)
            {
              v124 = @"Transport";
            }

            else
            {
              if (v123 != 2) {
                goto LABEL_208;
              }
              v124 = @"Tunnel";
            }

            CFDictionaryAddValue(v60, @"Mode", v124);
LABEL_208:
            v125 = *(_DWORD *)(v122 + 12);
            if (v125) {
              NEAddIntToDictionary(v60, @"UniqueID", v125);
            }
LABEL_210:
            v126 = CFDictionaryGetValue(v8, @"Direction");
            if (v126)
            {
              v127 = CFEqual(v126, @"In");
              v128 = v127 == 0;
              if (v127)
              {
                v129 = 6LL;
LABEL_215:
                v130 = (unsigned __int8 *)a1[v129];
                if (v130) {
                  goto LABEL_219;
                }
                v131 = 25LL;
                if (v128) {
                  v131 = 23LL;
                }
                v130 = (unsigned __int8 *)a1[v131];
                if (v130)
                {
LABEL_219:
                  NEAddAddressToDictionary(v60, @"LocalAddress", v130 + 8);
                  NEAddPortToDictionary(v60, @"LocalPort", (uint64_t)(v130 + 8));
                  NEAddIntToDictionary(v60, @"LocalPrefix", v130[5]);
                  v132 = v130[4];
                }

                else
                {
                  v132 = 255;
                }

                v133 = 5LL;
                if (v128) {
                  v133 = 6LL;
                }
                v134 = a1[v133];
                if (v134) {
                  goto LABEL_226;
                }
                v135 = 23LL;
                if (v128) {
                  v135 = 25LL;
                }
                v134 = a1[v135];
                if (v134)
                {
LABEL_226:
                  NEAddAddressToDictionary(v60, @"RemoteAddress", (unsigned __int8 *)(v134 + 8));
                  NEAddPortToDictionary(v60, @"RemotePort", v134 + 8);
                  NEAddIntToDictionary(v60, @"RemotePrefix", *(unsigned __int8 *)(v134 + 5));
                }

                if (v132 != 255) {
                  NEAddIntToDictionary(v60, @"UpperLayerProtocol", v132);
                }
                NEIPSecDBNotifyRequest( *(dispatch_semaphore_s **)(a3 + 96),  *(unsigned __int8 *)(v3 + 1),  v156[0],  1,  v60);
                v136 = v60;
LABEL_270:
                CFRelease(v136);
                goto LABEL_141;
              }
            }

            else
            {
              v128 = 1;
            }

            v129 = 5LL;
            goto LABEL_215;
          case 6:
            uint64_t v63 = v156[0];
            uint64_t v64 = a3;
            uint64_t v65 = 8448;
            goto LABEL_114;
          case 8:
            uint64_t v63 = v156[0];
            uint64_t v64 = a3;
            uint64_t v65 = 8704;
            goto LABEL_114;
          case 0xE:
            __int16 v85 = a1[18];
            if (v85)
            {
              uint64_t v82 = *(_DWORD *)(v85 + 8);
              v83 = @"PolicyID";
LABEL_117:
              int v86 = v8;
LABEL_136:
              NEAddIntToDictionary(v86, v83, v82);
LABEL_137:
              int v54 = *(unsigned __int8 *)(v3 + 1);
            }

            else
            {
              int v54 = 14;
            }

LABEL_2:
  unsigned int v6 = 1LL;
LABEL_22:

  return v6;
}

  certificateRef[0] = 0LL;
  unsigned int v6 = SecIdentityCopyCertificate(a2, certificateRef);
  if (v6)
  {
    unint64_t v7 = v6;
    ne_log_obj();
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      *(void *)&void buf[4] = v5;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v7;
      _os_log_error_impl( &dword_1876B1000,  v8,  OS_LOG_TYPE_ERROR,  "%@: failed to get the certificate from an identity: %d",  buf,  0x12u);
    }

    id v9 = 0LL;
  }

  else
  {
    uint64_t v8 = SecCertificateCopyData(certificateRef[0]);
    CFRelease(certificateRef[0]);
    v24[0] = @"persistent-reference";
    v24[1] = @"certificate-data";
    v25[0] = v4;
    v25[1] = v8;
    id v9 = [MEMORY[0x189603F68] dictionaryWithObjects:v25 forKeys:v24 count:2];
  }

LABEL_23:
  return v9;
}

LABEL_229:
LABEL_230:
                                    v160 = 0LL;
                                    goto LABEL_139;
                                  }

                                  ne_log_obj();
                                  v209 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                  if (!os_log_type_enabled(v209, OS_LOG_TYPE_FAULT))
                                  {
LABEL_222:

                                    v160 = 0LL;
                                    v114 = v220;
                                    v144 = v154;
                                    v146 = v213;
                                    goto LABEL_140;
                                  }

                                  *(_DWORD *)buf = 67109120;
                                  LODWORD(v241) = v164;
                                  v210 = "CCCryptorCreate(kCCDecrypt) failed: %d";
                                }

                                _os_log_fault_impl(&dword_1876B1000, v209, OS_LOG_TYPE_FAULT, v210, buf, 8u);
                                goto LABEL_222;
                              default:
                                ne_log_obj();
                                v162 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                if (os_log_type_enabled(v162, OS_LOG_TYPE_FAULT))
                                {
                                  String = NEIKEv2EncryptionWireTypeCreateString(encryptionProtocol->_wireType);
                                  *(_DWORD *)buf = 138412290;
                                  v241 = (const char *)String;
                                  _os_log_fault_impl( &dword_1876B1000,  v162,  OS_LOG_TYPE_FAULT,  "No CCAlgorithm for encryption wire type %@",  buf,  0xCu);
                                }

                                v154 = v144;

                                break;
                            }

                            v155 = 0;
                            goto LABEL_126;
                          }

                          ne_log_obj();
                          v204 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          if (!os_log_type_enabled(v204, OS_LOG_TYPE_FAULT)) {
                            goto LABEL_229;
                          }
                          *(_DWORD *)buf = 136315138;
                          v241 = "-[NEIKEv2SecurityContextCBCPlusHMAC initWithEncryptionProtocol:outgoingEncryptionKey:in"
                                 "comingEncryptionKey:integrityProtocol:outgoingIntegrityKey:incomingIntegrityKey:]";
                          v205 = "%s called with null incomingIntegrityKey";
                        }

                        else
                        {
                          ne_log_obj();
                          v204 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          if (!os_log_type_enabled(v204, OS_LOG_TYPE_FAULT)) {
                            goto LABEL_229;
                          }
                          *(_DWORD *)buf = 136315138;
                          v241 = "-[NEIKEv2SecurityContextCBCPlusHMAC initWithEncryptionProtocol:outgoingEncryptionKey:in"
                                 "comingEncryptionKey:integrityProtocol:outgoingIntegrityKey:incomingIntegrityKey:]";
                          v205 = "%s called with null outgoingIntegrityKey";
                        }
                      }

                      else
                      {
                        ne_log_obj();
                        v204 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (!os_log_type_enabled(v204, OS_LOG_TYPE_FAULT)) {
                          goto LABEL_229;
                        }
                        *(_DWORD *)buf = 136315138;
                        v241 = "-[NEIKEv2SecurityContextCBCPlusHMAC initWithEncryptionProtocol:outgoingEncryptionKey:inco"
                               "mingEncryptionKey:integrityProtocol:outgoingIntegrityKey:incomingIntegrityKey:]";
                        v205 = "%s called with null integrityProtocol";
                      }
                    }

                    else
                    {
                      ne_log_obj();
                      v204 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v204, OS_LOG_TYPE_FAULT)) {
                        goto LABEL_229;
                      }
                      *(_DWORD *)buf = 136315138;
                      v241 = "-[NEIKEv2SecurityContextCBCPlusHMAC initWithEncryptionProtocol:outgoingEncryptionKey:incomi"
                             "ngEncryptionKey:integrityProtocol:outgoingIntegrityKey:incomingIntegrityKey:]";
                      v205 = "%s called with null encryptionProtocol";
                    }

                    v207 = v204;
                    v208 = 12;
LABEL_228:
                    _os_log_fault_impl(&dword_1876B1000, v207, OS_LOG_TYPE_FAULT, v205, buf, v208);
                    goto LABEL_229;
                  }

                  if (v134 <= 0x1E && ((0x401C0000u >> v134) & 1) != 0)
                  {
                    v160 = -[NEIKEv2SecurityContextAESGCM initWithEncryptionProtocol:outgoingEncryptionKey:incomingEncryptionKey:]( (id *)objc_alloc(&OBJC_CLASS___NEIKEv2SecurityContextAESGCM),  v130,  v225,  v223);
                    if (!v160)
                    {
                      ne_log_obj();
                      v161 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 138412290;
                        v241 = (const char *)v130;
                        goto LABEL_170;
                      }

LABEL_171:
                      v238 = 0;
                      v114 = v220;
                      int v4 = v221;
                      goto LABEL_143;
                    }
                  }

                  else
                  {
                    v160 = -[NEIKEv2SecurityContextChaCha20Poly1305 initWithEncryptionProtocol:outgoingEncryptionKey:incomingEncryptionKey:]( (id *)objc_alloc(&OBJC_CLASS___NEIKEv2SecurityContextChaCha20Poly1305),  v130,  v225,  v223);
                    if (!v160)
                    {
                      ne_log_obj();
                      v161 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 138412290;
                        v241 = (const char *)v130;
LABEL_170:
                        _os_log_error_impl( &dword_1876B1000,  v161,  OS_LOG_TYPE_ERROR,  "Failed to create security context for %@",  buf,  0xCu);
                        goto LABEL_171;
                      }

                      goto LABEL_171;
                    }
                  }

LABEL_142:
                  objc_setProperty_atomic(a1, v159, v160, 208LL);
                  v238 = 1;

LABEL_143:
                  unint64_t v91 = 0LL;
                  v226 = 0LL;
                  int v39 = 0LL;
                  uint64_t v44 = 0LL;
                  int v20 = 0LL;
LABEL_148:

                  uint64_t v52 = v226;
LABEL_149:

LABEL_150:
                  v156 = v238;
                  goto LABEL_111;
                }

                ne_log_obj();
                v158 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v158, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 67109120;
                  LODWORD(v241) = v224;
                  _os_log_fault_impl( &dword_1876B1000,  v158,  OS_LOG_TYPE_FAULT,  "[NESensitiveData sensitiveDataWithBytes:length:%u] failed",  buf,  8u);
                }
              }

              else
              {
                ne_log_obj();
                v158 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v158, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 67109120;
                  LODWORD(v241) = v224;
                  _os_log_fault_impl( &dword_1876B1000,  v158,  OS_LOG_TYPE_FAULT,  "[NESensitiveData sensitiveDataWithBytes:length:%u] failed",  buf,  8u);
                }
              }

              v238 = 0;
              v226 = 0LL;
              int v39 = 0LL;
              uint64_t v44 = 0LL;
              int v20 = 0LL;
LABEL_147:
              unint64_t v91 = v212;
              goto LABEL_148;
            }

            v199 = v110;
            ne_log_obj();
            v201 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v201, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 67109120;
              LODWORD(v241) = v214;
              _os_log_fault_impl( &dword_1876B1000,  v201,  OS_LOG_TYPE_FAULT,  "[NESensitiveData sensitiveDataWithBytes:length:%u] failed",  buf,  8u);
            }

            v238 = 0;
          }

          else
          {
            v199 = v110;
            ne_log_obj();
            v200 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v200, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 67109120;
              LODWORD(v241) = v214;
              _os_log_fault_impl( &dword_1876B1000,  v200,  OS_LOG_TYPE_FAULT,  "[NESensitiveData sensitiveDataWithBytes:length:%u] failed",  buf,  8u);
            }

            v238 = 0;
          }

          goto LABEL_205;
        }

        v194 = Hkdf;
        ne_log_obj();
        v195 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v195, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 67109120;
          LODWORD(v241) = v194;
          _os_log_fault_impl(&dword_1876B1000, v195, OS_LOG_TYPE_FAULT, "CCKDFParametersCreateHkdf failed %d", buf, 8u);
        }
      }

      else
      {
        ne_log_obj();
        v193 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v193, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 134217984;
          v241 = (const char *)v49;
          _os_log_fault_impl( &dword_1876B1000,  v193,  OS_LOG_TYPE_FAULT,  "[NEMutableSensitiveData mutableSensitiveDataWithMaxCapacity:%zu] failed",  buf,  0xCu);
        }

        uint64_t v52 = 0LL;
      }

      v238 = 0;
      int v20 = v219;
      goto LABEL_149;
    }

    ne_log_obj();
    v198 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v198, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134217984;
      v241 = (const char *)v175;
LABEL_234:
      _os_log_fault_impl( &dword_1876B1000,  v198,  OS_LOG_TYPE_FAULT,  "[NEMutableSensitiveData mutableSensitiveDataWithMaxCapacity:%zu] failed",  buf,  0xCu);
      goto LABEL_191;
    }

    goto LABEL_191;
  }

  ne_log_obj();
  uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v241 = "-[NEIKEv2IKESA(Crypto) generateAllValuesUsingSA:]";
    int v30 = "%s called with null ikeSA.skD";
    goto LABEL_109;
  }

                uint64_t v76 = 0LL;
LABEL_143:

LABEL_144:
                goto LABEL_64;
              }

              ne_log_obj();
              uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled((os_log_t)v63, OS_LOG_TYPE_FAULT))
              {
LABEL_63:
                uint64_t v76 = 0LL;
LABEL_64:

                goto LABEL_65;
              }

              *(_WORD *)buf = 0;
              unint64_t v77 = "[packet addNotification:NEIKEv2NotifyTypeRedirectSupported] failed";
              goto LABEL_32;
            }

            ne_log_obj();
            uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled((os_log_t)v63, OS_LOG_TYPE_FAULT)) {
              goto LABEL_63;
            }
            *(_DWORD *)buf = 136315138;
            v215 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitForInitiatorIKESA:]";
            unint64_t v77 = "%s called with null packet.nonce.isValid";
          }

          else
          {
            ne_log_obj();
            uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled((os_log_t)v63, OS_LOG_TYPE_FAULT)) {
              goto LABEL_63;
            }
            *(_DWORD *)buf = 136315138;
            v215 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitForInitiatorIKESA:]";
            unint64_t v77 = "%s called with null packet.ke.isValid";
          }
        }

        else
        {
          ne_log_obj();
          uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled((os_log_t)v63, OS_LOG_TYPE_FAULT)) {
            goto LABEL_63;
          }
          *(_DWORD *)buf = 136315138;
          v215 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitForInitiatorIKESA:]";
          unint64_t v77 = "%s called with null packet.sa.isValid";
        }

        unint64_t v78 = (os_log_s *)v63;
        uint64_t v79 = 12;
        goto LABEL_38;
      }

      ne_log_obj();
      uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v63, OS_LOG_TYPE_FAULT)) {
        goto LABEL_63;
      }
      *(_WORD *)buf = 0;
      unint64_t v77 = "[NEIKEv2NotifyPayload createNotifyPayloadType:NEIKEv2NotifyTypeCookie] failed";
    }

    else
    {
      ne_log_obj();
      uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v63, OS_LOG_TYPE_FAULT)) {
        goto LABEL_63;
      }
      *(_WORD *)buf = 0;
      unint64_t v77 = "[[NEIKEv2IKESAInitPacket alloc] initOutbound:] failed";
    }

    if (-[NEIKEv2Packet hasNotification:]((void *)a1, (const char *)0x402E)
      && (*(_BYTE *)(v5 + 13) & 1) == 0)
    {
      *(_BYTE *)(v5 + 10) = 1;
      ne_log_obj();
      v247 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v247, OS_LOG_TYPE_DEBUG))
      {
        v333 = (char *)[(id)a1 copyShortDescription];
        buf = 138412290;
        v384 = v333;
        _os_log_debug_impl( &dword_1876B1000,  v247,  OS_LOG_TYPE_DEBUG,  "%@ IKEv2 fragmentation supported",  (uint8_t *)&buf,  0xCu);
      }
    }

    if (-[NEIKEv2Packet hasNotification:]((void *)a1, (const char *)0x4022))
    {
      ne_log_obj();
      v248 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v248, OS_LOG_TYPE_DEBUG))
      {
        v323 = (char *)[(id)a1 copyShortDescription];
        buf = 138412290;
        v384 = v323;
        _os_log_debug_impl( &dword_1876B1000,  v248,  OS_LOG_TYPE_DEBUG,  "%@ Childless IKEv2 supported",  (uint8_t *)&buf,  0xCu);
      }

      v250 = objc_getProperty((id)v5, v249, 80LL, 1);
      v251 = [v250 requestChildlessSA];

      if (v251) {
        *(_BYTE *)(v5 + 23) = 1;
      }
    }

    if (-[NEIKEv2Packet hasNotification:]((void *)a1, (const char *)0x4033))
    {
      v253 = objc_getProperty((id)v5, v252, 80LL, 1);
      v254 = [v253 requestPPK];

      if ((v254 & 1) != 0)
      {
        *(_BYTE *)(v5 + 24) = 1;
        ne_log_obj();
        v255 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v255, OS_LOG_TYPE_INFO))
        {
          v256 = (char *)[(id)a1 copyShortDescription];
          buf = 138412290;
          v384 = v256;
          _os_log_impl(&dword_1876B1000, v255, OS_LOG_TYPE_INFO, "%@ PPK use requested", (uint8_t *)&buf, 0xCu);
        }

LABEL_161:
        v268 = -[NEIKEv2Packet copyNotification:]((void *)a1, (const char *)0x4004);
        v269 = -[NEIKEv2Packet copyNotification:]((void *)a1, (const char *)0x4005);
        selfb = v268;
        if (!v268 || !v269) {
          goto LABEL_192;
        }
        v366 = v269;
        v271 = -[NEIKEv2IKESA initiatorSPI]((_BYTE *)v5, v270);
        v273 = -[NEIKEv2IKESA responderSPI]((_BYTE *)v5, v272);
        v275 = objc_getProperty((id)v5, v274, 72LL, 1);
        v363 = (void *)+[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  v271,  v273,  v275);
        v277 = -[NEIKEv2IKESA initiatorSPI]((_BYTE *)v5, v276);
        v279 = -[NEIKEv2IKESA responderSPI]((_BYTE *)v5, v278);
        v281 = objc_getProperty((id)v5, v280, 64LL, 1);
        v282 = (void *)+[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  v277,  v279,  v281);

        v284 = objc_getProperty(selfb, v283, 32LL, 1);
        LOBYTE(v281) = [v363 isEqualToData:v284];

        if ((v281 & 1) == 0)
        {
          *(_BYTE *)(v5 + 15) = 1;
          ne_log_obj();
          v286 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v286, OS_LOG_TYPE_DEBUG))
          {
            v344 = (char *)[(id)a1 copyShortDescription];
            buf = 138412290;
            v384 = v344;
            _os_log_debug_impl( &dword_1876B1000,  v286,  OS_LOG_TYPE_DEBUG,  "%@ Detected incoming NAT",  (uint8_t *)&buf,  0xCu);
          }
        }

        v287 = objc_getProperty(v366, v285, 32LL, 1);
        v288 = [v282 isEqualToData:v287];

        if ((v288 & 1) == 0)
        {
          *(_BYTE *)(v5 + 14) = 1;
          ne_log_obj();
          v290 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v290, OS_LOG_TYPE_DEBUG))
          {
            v345 = (char *)[(id)a1 copyShortDescription];
            buf = 138412290;
            v384 = v345;
            _os_log_debug_impl( &dword_1876B1000,  v290,  OS_LOG_TYPE_DEBUG,  "%@ Detected outgoing NAT",  (uint8_t *)&buf,  0xCu);
          }
        }

        v291 = objc_getProperty((id)v5, v289, 80LL, 1);
        if ([v291 disableSwitchToNATTPorts])
        {
        }

        else
        {
          v316 = objc_getProperty((id)v5, v292, 88LL, 1);
          if ([v316 negotiateMOBIKE] & 1) != 0 || (*(_BYTE *)(v5 + 15))
          {
          }

          else
          {
            v317 = *(_BYTE *)(v5 + 14);

            if ((v317 & 1) == 0) {
              goto LABEL_191;
            }
          }

          -[NEIKEv2IKESA switchToNATTraversalPorts](v5, v293);
        }

LABEL_110:
  v156 = 0LL;
LABEL_111:

  return v156;
}
}

LABEL_76:
            BOOL v25 = v74;
          }

          else
          {
            ne_log_obj();
            uint64_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v25 = v74;
            if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)v100 = 136315138;
              *(void *)&v100[4] = "+[NEIKEv2Crypto copyPersistentDataForCertificate:]";
              _os_log_fault_impl( &dword_1876B1000,  v64,  OS_LOG_TYPE_FAULT,  "%s called with null certificate",  v100,  0xCu);
            }

            uint64_t v63 = 0LL;
          }
        }
      }

      ++v53;
    }

    while (v51 != v53);
    uint64_t v65 = -[os_log_s countByEnumeratingWithState:objects:count:]( v37,  "countByEnumeratingWithState:objects:count:",  &v89,  &buf,  16LL);
    int v51 = v65;
  }

  while (v65);
LABEL_84:

  uint64_t v38 = v66;
  unsigned int v6 = 0LL;
  int v26 = v73;
LABEL_37:

LABEL_38:
  uint64_t v79 = 0u;
  uint64_t v80 = 0u;
  int v81 = 0u;
  uint64_t v82 = 0u;
  int v39 = v38;
  unint64_t v40 = [v39 countByEnumeratingWithState:&v79 objects:v85 count:16];
  if (v40)
  {
    unint64_t v41 = v40;
    unint64_t v42 = *(void *)v80;
    do
    {
      for (j = 0LL; j != v41; ++j)
      {
        if (*(void *)v80 != v42) {
          objc_enumerationMutation(v39);
        }
        uint64_t v44 = +[NEIKEv2Crypto copyCertificateFromPersistentData:isModernSystem:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  *(void **)(*((void *)&v79 + 1) + 8 * j),  0);
        if (v44)
        {
          uint64_t v45 = (const void *)v44;
          [v3 addObject:v44];
          CFRelease(v45);
        }
      }

      unint64_t v41 = [v39 countByEnumeratingWithState:&v79 objects:v85 count:16];
    }

    while (v41);
  }

  if (![v3 count] && v74)
  {
    ne_log_obj();
    int v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v74;
      _os_log_fault_impl( &dword_1876B1000,  v46,  OS_LOG_TYPE_FAULT,  "failed to retrieve remote CA cert data by CN (%@)",  (uint8_t *)&buf,  0xCu);
    }
  }

  unint64_t v15 = (os_log_s *)v74;
LABEL_53:

LABEL_54:
  int64_t v47 = v3;
LABEL_55:

  return v3;
}

LABEL_59:
        ne_log_obj();
        int v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
        {
          int v54 = 136315138;
          BOOL v55 = "-[NEIKEv2IKESA(Crypto) createInitiatorSignedOctetsUsingPrimeKey:]";
          _os_log_fault_impl( &dword_1876B1000,  v18,  OS_LOG_TYPE_FAULT,  "%s called with null idPayload",  (uint8_t *)&v54,  0xCu);
        }

        int v20 = 0LL;
        goto LABEL_43;
      }
    }

    int v18 = objc_alloc_init(&OBJC_CLASS___NEIKEv2IdentifierPayload);
    uint64_t v23 = -[NEIKEv2IKESA copyInitiatorIdentifier]((_BYTE *)a1, v22);
    BOOL v25 = v23;
    if (!v18)
    {

      CFStringRef v10 = 0LL;
      goto LABEL_59;
    }

    objc_setProperty_atomic(v18, v24, v23, 24LL);

LABEL_31:
    CFStringRef v10 = 0LL;
LABEL_32:
    id v27 = -[NEIKEv2Payload copyPayloadData](v18);
    if (!v27)
    {
      ne_log_obj();
      uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
      {
        LOWORD(v54) = 0;
        _os_log_fault_impl( &dword_1876B1000,  v34,  OS_LOG_TYPE_FAULT,  "[idPayload copyPayloadData] failed",  (uint8_t *)&v54,  2u);
      }

      int v20 = 0LL;
      goto LABEL_42;
    }

    if (v2) {
      uint64_t v28 = 240LL;
    }
    else {
      uint64_t v28 = 232LL;
    }
    objc_getProperty((id)a1, v26, v28, 1);
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v31 = objc_getProperty((id)a1, v30, 96LL, 1);
    -[NEIKEv2IKESAProposal prfProtocol](v31, v32);
    int v33 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v34 = +[NEIKEv2Crypto createHMACFromData:key:prfProtocol:]((uint64_t)&OBJC_CLASS___NEIKEv2Crypto, v27, v29, v33);

    if (!v34)
    {
      ne_log_obj();
      uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
      {
        LOWORD(v54) = 0;
        _os_log_fault_impl( &dword_1876B1000,  v37,  OS_LOG_TYPE_FAULT,  "[NEIKEv2Crypto createHMACFromData:key:prfProtocol:] failed",  (uint8_t *)&v54,  2u);
      }

      int v20 = 0LL;
      goto LABEL_41;
    }

    uint64_t v37 = -[NEIKEv2IKESA createIntAuthOctets]((unsigned int *)a1, v35);
    if (v37)
    {
      -[NEIKEv2IKESA initiatorFirstMessage]((_BYTE *)a1, v36);
      uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
      int v39 = [v38 length];
      -[NEIKEv2IKESA responderNonce]((_BYTE *)a1, v40);
      unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v42 = [v41 length] + v39;
      char v43 = -[os_log_s length](v34, "length");
      uint64_t v44 = v42 + -[os_log_s length](v37, "length") + v43;

      uint64_t v45 = +[NSMutableData mutableSensitiveDataWithMaxCapacity:](MEMORY[0x189603FB8], v44);
      if (v45)
      {
        int64_t v47 = v45;
        -[NEIKEv2IKESA initiatorFirstMessage]((_BYTE *)a1, v46);
        int v48 = (void *)objc_claimAutoreleasedReturnValue();
        -[__CFData appendData:](v47, "appendData:", v48);

        -[NEIKEv2IKESA responderNonce]((_BYTE *)a1, v49);
        uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
        -[__CFData appendData:](v47, "appendData:", v50);

        -[__CFData appendData:](v47, "appendData:", v34);
        -[__CFData appendData:](v47, "appendData:", v37);
        int v51 = v47;
        int v20 = v51;
LABEL_40:

LABEL_41:
LABEL_42:

LABEL_43:
        goto LABEL_28;
      }

      ne_log_obj();
      uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT))
      {
        int v54 = 134217984;
        BOOL v55 = (const char *)v44;
        _os_log_fault_impl( &dword_1876B1000,  v53,  OS_LOG_TYPE_FAULT,  "[NEMutableSensitiveData mutableSensitiveDataWithMaxCapacity:%zu] failed",  (uint8_t *)&v54,  0xCu);
      }

      int v51 = 0LL;
    }

    else
    {
      ne_log_obj();
      uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_FAULT))
      {
        int v20 = 0LL;
        int v51 = v52;
        goto LABEL_40;
      }

      LOWORD(v54) = 0;
      _os_log_fault_impl( &dword_1876B1000,  v52,  OS_LOG_TYPE_FAULT,  "[NEIKEv2Crypto createIntAuthOctets] failed",  (uint8_t *)&v54,  2u);
      int v51 = v52;
    }

    int v20 = 0LL;
    goto LABEL_40;
  }

  ne_log_obj();
  CFStringRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
  {
    int v54 = 136315138;
    BOOL v55 = "-[NEIKEv2IKESA(Crypto) createInitiatorSignedOctetsUsingPrimeKey:]";
    CFStringRef v11 = "%s called with null self.initiatorFirstMessage";
    goto LABEL_26;
  }

          a1 = v25;
          BOOL v25 = 0LL;
          uint64_t v21 = v31;
          goto LABEL_60;
        }

        ne_log_obj();
        unint64_t v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v77, OS_LOG_TYPE_FAULT)) {
          goto LABEL_59;
        }
        *(_DWORD *)buf = 136315138;
        v133 = "-[NEIKEv2IKESA initIKESAWithConfiguration:sessionConfiguration:queue:initialTransport:transportDelegate:s"
               "ocketGetBlock:packetDelegate:configurationDelegate:ikeSessionUniqueIndex:]";
        unint64_t v78 = "%s called with null [configuration.localEndpoint isKindOfClass:[NWAddressEndpoint class]]";
      }

      else
      {
        ne_log_obj();
        unint64_t v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v77, OS_LOG_TYPE_FAULT)) {
          goto LABEL_59;
        }
        *(_DWORD *)buf = 136315138;
        v133 = "-[NEIKEv2IKESA initIKESAWithConfiguration:sessionConfiguration:queue:initialTransport:transportDelegate:s"
               "ocketGetBlock:packetDelegate:configurationDelegate:ikeSessionUniqueIndex:]";
        unint64_t v78 = "%s called with null [configuration.remoteEndpoint isKindOfClass:[NWAddressEndpoint class]]";
      }

  -[os_log_s setRemoteTrafficSelectors:](v2, "setRemoteTrafficSelectors:", v15);

  unsigned int v6 = v124;
LABEL_60:
  uint64_t v53 = (const __CFArray *)NEGetValueWithType(v5, @"ChildProposals", CFARRAY_TYPE);
  if (!v53)
  {
    ne_log_obj();
    unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_198;
    }
    *(_DWORD *)buf = 136315394;
    v147 = "NEIPSecIKEValidateIKEChildDictionary";
    v148 = 1024;
    v149 = 2262;
    v100 = "%s:%d: IKE Child configuration proposals array is missing";
    goto LABEL_147;
  }

  int v54 = v53;
  BOOL v55 = CFArrayGetCount(v53);
  if (!v55)
  {
    ne_log_obj();
    unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v147 = "NEIPSecIKEValidateIKEChildDictionary";
      v148 = 1024;
      v149 = 2267;
      v100 = "%s:%d: IKE Child configuration proposals array is empty";
      goto LABEL_147;
    }

  return v28;
}

LABEL_65:
LABEL_66:
        uint64_t v8 = 0LL;
LABEL_145:

        goto LABEL_146;
      }

            ne_log_obj();
            v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf) = 138412290;
              *(void *)((char *)&buf + 4) = value;
              _os_log_error_impl( &dword_1876B1000,  v98,  OS_LOG_TYPE_ERROR,  "failed to fetch persistent reference for Cert %@",  (uint8_t *)&buf,  0xCu);
            }

            goto LABEL_79;
          }
        }

        ne_log_obj();
        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
        {
          LOWORD(v18_Block_object_dispose((const void *)(v49 - 176), 8) = 0;
          _os_log_fault_impl( &dword_1876B1000,  v97,  OS_LOG_TYPE_FAULT,  "ikev2_crypto_copy_all_cert_identities failed",  (uint8_t *)&v188,  2u);
        }

        goto LABEL_65;
      }
    }

    else if (!v14)
    {
      ne_log_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
        goto LABEL_24;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NEIKEv2Session(Exchange) initiateConnect]";
      int v30 = "%s called with null childSA";
      goto LABEL_69;
    }

    unint64_t v15 = objc_getProperty(v14, v13, 48LL, 1);
    int v16 = v15 == 0LL;

    if (v16)
    {
      ne_log_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
        goto LABEL_24;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NEIKEv2Session(Exchange) initiateConnect]";
      int v30 = "%s called with null childSA.configuration";
    }

    else
    {
      -[NEIKEv2ChildSA configProposalsWithoutKEM]((id)v165[5], v17);
      int v18 = (void *)objc_claimAutoreleasedReturnValue();
      unint64_t v19 = v18 == 0LL;

      if (!v19) {
        goto LABEL_11;
      }
      ne_log_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
      {
LABEL_24:

LABEL_83:
        _Block_object_dispose(&v164, 8);

        return;
      }

      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NEIKEv2Session(Exchange) initiateConnect]";
      int v30 = "%s called with null childSA.configProposalsWithoutKEM";
    }

LABEL_66:
      if (v159[5]) {
        objc_msgSend(v8, "addObject:");
      }
      (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
      goto LABEL_69;
  }

LABEL_144:
      uint64_t v8 = objc_alloc_init(&OBJC_CLASS___NEIKEv2AuthPayload);
      -[NEIKEv2AuthPayload setAuthProtocol:]((uint64_t)v8, v9);
      -[NEIKEv2AuthPayload setAuthenticationData:]((uint64_t)v8, v12);

      goto LABEL_145;
    }

    if (-[os_log_s method](v9, "method") == 13)
    {
      if (v3 && (*((_BYTE *)v3 + 9) & 1) != 0)
      {
        int v18 = (_DWORD)a2 == 0;
        unint64_t v19 = 232LL;
        int v20 = 240LL;
      }

      else
      {
        int v18 = (_DWORD)a2 == 0;
        unint64_t v19 = 248LL;
        int v20 = 256LL;
      }

      if (v18) {
        int v26 = v19;
      }
      else {
        int v26 = v20;
      }
      objc_getProperty(v3, v17, v26, 1);
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v27 = -[NEIKEv2IKESA createAuthenticationDataForSharedSecret:octets:](v3, v13, v7);
      if (!v27)
      {
        ne_log_obj();
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl( &dword_1876B1000,  v28,  OS_LOG_TYPE_FAULT,  "createAuthenticationDataForSharedSecret: failed",  buf,  2u);
        }

        goto LABEL_65;
      }

      uint64_t v12 = v27;

      goto LABEL_144;
    }

    if (!-[os_log_s isSignature](v9, "isSignature"))
    {
      ne_log_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        v113 = (const char *)v9;
        uint64_t v14 = "Unknown auth protocol %@";
        unint64_t v15 = v13;
        int v16 = 12;
        goto LABEL_31;
      }

      goto LABEL_65;
    }

    if (v3)
    {
      id v22 = objc_getProperty(v3, v21, 88LL, 1);
      uint64_t v23 = v22;
      if (v22 && [v22 localPrivateKeyRef])
      {
        unint64_t v24 = (void *)[v23 localPrivateKeyRef];
        CFRetain(v24);

        if (v24) {
          goto LABEL_44;
        }
        goto LABEL_43;
      }
    }

    else
    {
      uint64_t v23 = 0LL;
    }

LABEL_43:
    unint64_t v24 = (void *)-[NEIKEv2IKESA copyCertSigningKey](v3, v25);
    if (!v24)
    {
      ne_log_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
        goto LABEL_65;
      }
      *(_WORD *)buf = 0;
      uint64_t v14 = "[self copyCertSigningKey] failed";
      goto LABEL_16;
    }

LABEL_74:
        id v27 = v188;
        CFStringRef v10 = v190;
        a5 = v36;
        if (!objc_getProperty((id)a1, v61, 160LL, 1))
        {
          -[os_log_s eapProtocols](log, "eapProtocols");
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
          CFStringRef v11 = (void *)[v64 copy];
LABEL_178:

          a4 = v193;
LABEL_179:

          goto LABEL_180;
        }
      }
    }

    int v62 = +[NEIKEv2EAP loadModuleForType:]((uint64_t)&OBJC_CLASS___NEIKEv2EAP, v33);
    *(void *)(a1 + 16_Block_object_dispose((const void *)(v49 - 176), 8) = v62;
    if (v33 != 1 && !v62)
    {
      ne_log_obj();
      uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v64, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&void buf[4] = v33;
        _os_log_error_impl( &dword_1876B1000,  (os_log_t)v64,  OS_LOG_TYPE_ERROR,  "error: module is null for type %u",  buf,  8u);
      }

      CFStringRef v11 = (void *)MEMORY[0x189604A58];
      goto LABEL_178;
    }

    switch((char)v33)
    {
      case 18:
        uint64_t v65 = v27;
        objc_msgSend(objc_getProperty((id)a1, v63, 160, 1), "properties");
        int v66 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v67 = v66;
        uint64_t v68 = @"EAPSIMProperties";
        goto LABEL_92;
      case 19:
      case 20:
      case 21:
      case 22:
      case 24:
        goto LABEL_86;
      case 23:
        uint64_t v65 = v27;
        objc_msgSend(objc_getProperty((id)a1, v63, 160, 1), "properties");
        int v66 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v67 = v66;
        uint64_t v68 = @"EAPAKAProperties";
        goto LABEL_92;
      case 25:
        uint64_t v65 = v27;
        objc_msgSend(objc_getProperty((id)a1, v63, 160, 1), "properties");
        int v66 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v67 = v66;
        uint64_t v68 = @"EAPPEAPProperties";
        goto LABEL_92;
      case 26:
        uint64_t v65 = v27;
        objc_msgSend(objc_getProperty((id)a1, v63, 160, 1), "properties");
        int v66 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v67 = v66;
        uint64_t v68 = @"EAPMSCHAPv2Properties";
        goto LABEL_92;
      default:
        if (v33 == 6)
        {
          uint64_t v65 = v27;
          objc_msgSend(objc_getProperty((id)a1, v63, 160, 1), "properties");
          int v66 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v67 = v66;
          uint64_t v68 = @"EAPGTCProperties";
        }

        else
        {
          if (v33 != 13)
          {
LABEL_86:
            if (!v62)
            {
              uint64_t v64 = 0LL;
              CFStringRef v11 = 0LL;
              goto LABEL_178;
            }

            *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v49 - 176), 8) = 0u;
            *(void *)(a1 + 152) = 0LL;
            *(_OWORD *)(a1 + 120) = 0u;
            *(_OWORD *)(a1 + 136) = 0u;
            *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v49 - 176), 8) = 0u;
            *(_OWORD *)(a1 + 104) = 0u;
            *(_OWORD *)(a1 + 56) = 0u;
            *(_OWORD *)(a1 + 72) = 0u;
            *(_OWORD *)(a1 + 24) = 0u;
            *(_OWORD *)(a1 + 40) = 0u;
            goto LABEL_96;
          }

          uint64_t v65 = v27;
          objc_msgSend(objc_getProperty((id)a1, v63, 160, 1), "properties");
          int v66 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v67 = v66;
          uint64_t v68 = @"EAPTLSProperties";
        }

LABEL_92:
        [v66 objectForKeyedSubscript:v68];
        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();

        if (!*(void *)(a1 + 168))
        {
          CFStringRef v11 = 0LL;
          id v27 = v65;
          goto LABEL_178;
        }

        *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v49 - 176), 8) = 0u;
        *(void *)(a1 + 152) = 0LL;
        *(_OWORD *)(a1 + 120) = 0u;
        *(_OWORD *)(a1 + 136) = 0u;
        *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v49 - 176), 8) = 0u;
        *(_OWORD *)(a1 + 104) = 0u;
        *(_OWORD *)(a1 + 56) = 0u;
        *(_OWORD *)(a1 + 72) = 0u;
        *(_OWORD *)(a1 + 24) = 0u;
        *(_OWORD *)(a1 + 40) = 0u;
        id v27 = v65;
        if (v64)
        {
          v191 = v10;
          v187 = (id)[v64 mutableCopy];
          goto LABEL_97;
        }

LABEL_96:
        v191 = v10;
        v187 = objc_alloc_init(MEMORY[0x189603FC8]);
        uint64_t v64 = 0LL;
LABEL_97:
        v186 = v64;
        int v70 = objc_getProperty((id)a1, v69, 160LL, 1);
        uint64_t v72 = v70;
        v184 = a5;
        v189 = v27;
        if (v70
          && ([v70 method] == 4 || objc_msgSend(v72, "method") == 5 || objc_msgSend(v72, "method") == 7))
        {
          uint64_t v73 = 1;
        }

        else
        {
          uint64_t v73 = 0;
        }

        id v27 = objc_getProperty(self, v71, 88LL, 1);
        [v27 username];
        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
        SEL v74 = [v64 length];
        if (v73)
        {
          id v75 = v74;

          unint64_t v77 = self;
          if (v75)
          {
LABEL_104:
            unint64_t v78 = objc_getProperty(v77, v76, 88LL, 1);
            [v78 username];
            uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
            CFStringRef v10 = v191;
            goto LABEL_116;
          }

LABEL_113:
          uint64_t v80 = objc_getProperty(v77, v76, 88LL, 1);
          [v80 localPrivateEAPIdentity];
          int v81 = (void *)objc_claimAutoreleasedReturnValue();

          v83 = objc_getProperty(v77, v82, 88LL, 1);
          unint64_t v78 = v83;
          CFStringRef v10 = v191;
          if (v81)
          {
            [v83 localPrivateEAPIdentity];
            uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
          }

          else
          {
            [v83 localIdentifier];
            uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue();
            [v84 stringValue];
            uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
          }

  if (v86) {
    free(v86);
  }
  if (v85) {
    free(v85);
  }
  uint64_t v60 = v70[3];
  if (v60)
  {
    uint64_t v61 = _NEIPSecDBGetQueue();
    *(void *)buf = v7;
    *(void *)&uint8_t buf[8] = v8[214];
    *(void *)&buf[16] = __NEIPSecDBRemoveQueuedRequest_block_invoke;
    uint64_t v89 = &__block_descriptor_tmp_163;
    CFErrorRef v90 = v60;
    dispatch_sync(v61, buf);
    free((void *)v70[3]);
  }

  _Block_object_dispose(&v69, 8);
  _Block_object_dispose(&v73, 8);
  return v21;
}

LABEL_116:
          if (v79)
          {
            int v86 = [v79 maximumLengthOfBytesUsingEncoding:4];
            __int16 v87 = malloc(v86);
            *(void *)(a1 + 4_Block_object_dispose((const void *)(v49 - 176), 8) = v87;
            [v79 getCString:v87 maxLength:v86 encoding:4];
            *(_DWORD *)(a1 + 56) = strnlen(*(const char **)(a1 + 48), v86);
          }

          v185 = v79;
          int v88 = objc_getProperty(v77, v85, 88LL, 1);
          [v88 localEncryptedEAPIdentity];
          uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue();

          id v27 = v189;
          if (v89)
          {
            unint64_t v91 = objc_getProperty(v77, v90, 88LL, 1);
            *(void *)(a1 + 64) = [v91 localEncryptedEAPIdentity];
          }

          v92 = objc_getProperty((id)a1, v90, 160LL, 1);
          if (v92)
          {
            v94 = v92;
            if ([v92 method] == 4 || objc_msgSend(v94, "method") == 5)
            {

              goto LABEL_124;
            }

            v118 = [v94 method];

            if (v118 == 7)
            {
LABEL_124:
              if (!objc_getProperty(v77, v93, 88LL, 1))
              {
                v115 = v189;
                ne_log_obj();
                v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                a5 = v184;
                if (os_log_type_enabled(v116, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 136315138;
                  *(void *)&void buf[4] = "-[NEIKEv2IKESA password]";
                  _os_log_fault_impl( &dword_1876B1000,  v116,  OS_LOG_TYPE_FAULT,  "%s called with null self.sessionConfiguration",  buf,  0xCu);
                }

                v117 = 0LL;
                goto LABEL_174;
              }

              if (!objc_getProperty(v77, v95, 512LL, 1))
              {
                objc_msgSend(objc_getProperty(v77, v96, 88, 1), "passwordReference");
                v97 = (void *)objc_claimAutoreleasedReturnValue();

                if (v97)
                {
                  objc_msgSend(objc_getProperty(v77, v98, 88, 1), "passwordReference");
                  v99 = (void *)objc_claimAutoreleasedReturnValue();
                  v100 = +[NEIKEv2Crypto copyDataFromPersistentReference:]((uint64_t)&OBJC_CLASS___NEIKEv2Crypto, v99);
                  objc_setProperty_atomic(v77, v101, v100, 512LL);

                  if (!objc_getProperty(v77, v102, 512LL, 1))
                  {
                    ne_log_obj();
                    v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 138412290;
                      *(void *)&void buf[4] = v77;
                      _os_log_error_impl( &dword_1876B1000,  v103,  OS_LOG_TYPE_ERROR,  "%@ Failed to retrieve password by reference",  buf,  0xCu);
                    }
                  }
                }

                v105 = objc_getProperty(v77, v98, 512LL, 1);
                if (v105) {
                  goto LABEL_134;
                }
                objc_msgSend(objc_getProperty(v77, v104, 88, 1), "password");
                v106 = (void *)objc_claimAutoreleasedReturnValue();

                if (v106)
                {
                  v107 = MEMORY[0x189603F48];
                  objc_msgSend(objc_getProperty(v77, v96, 88, 1), "password");
                  v105 = (id)objc_claimAutoreleasedReturnValue();
                  [v105 dataUsingEncoding:4];
                  v108 = (void *)objc_claimAutoreleasedReturnValue();
                  v109 = +[NSData sensitiveDataWithData:](v107, v108);
                  objc_setProperty_atomic(v77, v110, v109, 512LL);

                  id v27 = v189;
LABEL_134:
                }
              }

              v111 = objc_getProperty(v77, v96, 512LL, 1);
              if (v111)
              {
                v112 = v111;
                v113 = malloc([v111 length] + 1);
                if (!v113)
                {
                  v117 = v112;
                  v115 = v27;
                  ne_log_obj();
                  v135 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v135, OS_LOG_TYPE_FAULT))
                  {
                    v173 = [v117 length];
                    *(_DWORD *)buf = 134217984;
                    *(void *)&void buf[4] = v173 + 1;
                    _os_log_fault_impl(&dword_1876B1000, v135, OS_LOG_TYPE_FAULT, "malloc(%zu) failed", buf, 0xCu);
                  }

                  a5 = v184;
                  uint64_t v64 = v186;
                  goto LABEL_175;
                }

                v114 = v113;
                memcpy(v113, (const void *)[v112 bytes], objc_msgSend(v112, "length"));
                v114[[v112 length]] = 0;
                *(void *)(a1 + 72) = v114;
                *(_DWORD *)(a1 + 80) = [v112 length];
                if (v185)
                {

                  goto LABEL_143;
                }

                v117 = v112;
                v115 = v27;
              }

              else
              {
                v115 = v27;
                v117 = 0LL;
              }

              a5 = v184;
LABEL_174:
              uint64_t v64 = v186;
              ne_log_obj();
              v135 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
              {
                v137 = "password";
                if (!v185) {
                  v137 = "username";
                }
                *(_DWORD *)buf = 136315138;
                *(void *)&void buf[4] = v137;
                _os_log_error_impl( &dword_1876B1000,  v135,  OS_LOG_TYPE_ERROR,  "EAP plugin data initialization failed, missing %s",  buf,  0xCu);
              }

LABEL_175:
              id v27 = v115;
              v134 = v117;
LABEL_176:

              CFStringRef v11 = (void *)MEMORY[0x189604A58];
LABEL_177:

              goto LABEL_178;
            }
          }

LABEL_206:
                  v150 = objc_getProperty(self, v149, 88LL, 1);
                  [v150 remoteIdentifier];
                  v151 = (void *)objc_claimAutoreleasedReturnValue();
                  v152 = [v151 stringValue];
LABEL_207:
                  v140 = (void *)v152;
                  CFStringRef v10 = v192;

                  id v27 = v189;
                  v134 = v183;
                  if (!v140) {
                    goto LABEL_209;
                  }
                  goto LABEL_208;
                }
              }

              goto LABEL_206;
            }

            ne_log_obj();
            v138 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v138, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl( &dword_1876B1000,  v138,  OS_LOG_TYPE_FAULT,  "[self copyRemoteCertificateAuthorityArray] failed",  buf,  2u);
            }

            v127 = 0LL;
          }

          else
          {
            ne_log_obj();
            v127 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled((os_log_t)v127, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl( &dword_1876B1000,  (os_log_t)v127,  OS_LOG_TYPE_FAULT,  "[[NSMutableArray alloc] init] failed",  buf,  2u);
            }
          }

          v134 = 0LL;
          goto LABEL_199;
        }

        uint64_t v73 = v74 != 0;
LABEL_106:
        if ((v33 == 23 || v33 == 18)
          && ((v64, v33 == 23) || v33 == 18))
        {

          unint64_t v77 = self;
          if (v73) {
            goto LABEL_104;
          }
        }

        else
        {

          unint64_t v77 = self;
          if (v73) {
            goto LABEL_104;
          }
        }

        goto LABEL_113;
    }
  }

  ne_log_obj();
  v181 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v181, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&void buf[4] = "-[NEIKEv2EAP selectModuleForPayload:ikeSA:]";
    _os_log_fault_impl(&dword_1876B1000, v181, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", buf, 0xCu);
  }

  CFStringRef v11 = (void *)MEMORY[0x189604A58];
LABEL_180:

  if (v11 && ![v11 count])
  {
    ne_log_obj();
    int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v47, OS_LOG_TYPE_ERROR))
    {
LABEL_183:

LABEL_184:
      unint64_t v24 = 0LL;
      goto LABEL_185;
    }

    *(_WORD *)buf = 0;
    int v48 = "Failed to select EAP module";
    uint64_t v49 = (os_log_s *)v47;
    uint64_t v50 = 2;
LABEL_187:
    _os_log_error_impl(&dword_1876B1000, v49, OS_LOG_TYPE_ERROR, v48, buf, v50);
    goto LABEL_183;
  }

LABEL_9:
    [*(id *)(a1 + 40) sendCallbackSuccess:0 session:*(void *)(a1 + 32)];
    Property = *(id *)(a1 + 32);
    if (Property) {
      Property = objc_getProperty(Property, v12, 336LL, 1);
    }
    uint64_t v14 = Property;
    Error = (void *)NEIKEv2CreateError(4LL);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v14, 3uLL, Error);

    -[NEIKEv2Session reportState](*(void **)(a1 + 32), v16);
    -[NEIKEv2Session resetAll](*(void *)(a1 + 32), v17);
    goto LABEL_12;
  }

  if (-[NEIKEv2Packet hasErrors](v3, v4))
  {
    ne_log_large_obj();
    unsigned int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      unint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      int v46 = v7;
      int64_t v47 = 2112;
      int v48 = v3;
      uint64_t v8 = "%@ Failed to process informational packet %@";
LABEL_31:
      CFStringRef v10 = v6;
      CFStringRef v11 = 22;
      goto LABEL_32;
    }

    goto LABEL_9;
  }

  int v18 = *(void **)(a1 + 32);
  if (!v18) {
    goto LABEL_22;
  }
  unint64_t v19 = objc_getProperty(v18, v5, 336LL, 1);
  if (!v19) {
    goto LABEL_22;
  }
  int v20 = v19[11];

  if ((v20 & 1) == 0) {
    goto LABEL_22;
  }
  uint64_t v21 = -[NEIKEv2Packet copyNotification:](v3, (const char *)0x4005);
  uint64_t v23 = v21;
  if (v21) {
    uint64_t v21 = objc_getProperty(v21, v22, 32LL, 1);
  }
  BOOL v25 = v21;
  int v26 = *(void **)(a1 + 32);
  if (v26)
  {
    id v27 = objc_getProperty(v26, v24, 336LL, 1);
    uint64_t v29 = v27;
    if (v27) {
      id v27 = objc_getProperty(v27, v28, 496LL, 1);
    }
  }

  else
  {
    uint64_t v29 = 0LL;
    id v27 = 0LL;
  }

  int v30 = v27;
  unint64_t v31 = [v25 isEqualToData:v30];

  if ((v31 & 1) == 0)
  {
    ne_log_obj();
    uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
    {
      uint64_t v35 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      int v46 = v35;
      _os_log_impl( &dword_1876B1000,  v34,  OS_LOG_TYPE_INFO,  "%@ Successfully received informational packet, need SA update",  buf,  0xCu);
    }

    uint64_t v37 = objc_alloc(&OBJC_CLASS___NEIKEv2MOBIKEContext);
    uint64_t v38 = *(id *)(a1 + 32);
    if (v38) {
      uint64_t v38 = objc_getProperty(v38, v36, 368LL, 1);
    }
    int v39 = v38;
    v43[0] = MEMORY[0x1895F87A8];
    v43[1] = 3221225472LL;
    v43[2] = __50__NEIKEv2Session_Exchange__initiateInformational___block_invoke_22;
    v43[3] = &unk_18A08CF38;
    unint64_t v40 = *(void **)(a1 + 40);
    v43[4] = *(void *)(a1 + 32);
    uint64_t v44 = v40;
    unint64_t v41 = -[NEIKEv2MOBIKEContext initWithMOBIKEInterface:mobikeEndpoint:invalidateTransport:maxRetries:retryIntervalMilliseconds:callbackQueue:callback:]( (id *)&v37->super.super.isa,  0LL,  0LL,  0,  4,  0LL,  v39,  v43);

    -[NEIKEv2Session initiateMOBIKE:](*(_BYTE **)(a1 + 32), v41);
  }

  else
  {
LABEL_22:
    ne_log_obj();
    unint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
    {
      int v33 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      int v46 = v33;
      _os_log_impl(&dword_1876B1000, v32, OS_LOG_TYPE_INFO, "%@ Successfully received informational packet", buf, 0xCu);
    }

    [*(id *)(a1 + 40) sendCallbackSuccess:1 session:*(void *)(a1 + 32)];
  }
  }
}

      goto LABEL_10;
    }

    if (!v4)
    {
      ne_log_obj();
      __int128 v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v59 = a1;
        _os_log_impl(&dword_1876B1000, v5, OS_LOG_TYPE_INFO, "%@: Start IKEv2 Tunnel Skipped, null options", buf, 0xCu);
      }

      goto LABEL_9;
    }

    [(id)a1 protocolConfiguration];
    unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue();

    if (v6)
    {
      [(id)a1 protocolConfiguration];
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
      *(void *)(a1 + 200) = [v8 tunnelKind];
    }

    objc_setProperty_atomic((id)a1, v7, v4, 112LL);
    if (!*(void *)(a1 + 248) || *(void *)(a1 + 256) != 1LL)
    {
      ne_log_obj();
      __int128 v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v24 = *(void **)(a1 + 248);
        BOOL v25 = *(void *)(a1 + 256);
        *(_DWORD *)buf = 138412802;
        uint64_t v59 = a1;
        uint64_t v60 = 2048;
        uint64_t v61 = v24;
        int v62 = 2048;
        uint64_t v63 = v25;
        _os_log_impl( &dword_1876B1000,  v5,  OS_LOG_TYPE_DEFAULT,  "%@: Start IKEv2 Tunnel Skipped, interface not ready (ifindex %lu, Satisfied %lu)",  buf,  0x20u);
      }

      goto LABEL_9;
    }

    ne_log_obj();
    id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v10 = *(void **)(a1 + 248);
      *(_DWORD *)buf = 138412546;
      uint64_t v59 = a1;
      uint64_t v60 = 2048;
      uint64_t v61 = v10;
      _os_log_impl( &dword_1876B1000,  v9,  OS_LOG_TYPE_DEFAULT,  "%@: Starting IKEv2 Tunnel on scoped ifindex %lu",  buf,  0x16u);
    }

    [(id)a1 protocolConfiguration];
    CFStringRef v11 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v11) {
      goto LABEL_33;
    }
    [(id)a1 protocolConfiguration];
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    [v12 serverAddress];
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v14 = v13 == 0LL;

    if (v14)
    {
LABEL_33:
      ne_log_obj();
      int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v59 = a1;
        _os_log_error_impl( &dword_1876B1000,  v26,  OS_LOG_TYPE_ERROR,  "%@: NULL configuration / serverAddress",  buf,  0xCu);
      }

      -[NEIKEv2PacketTunnelProvider invokeCancelTunnel:]((_BYTE *)a1, (const char *)0xA);
    }

    else
    {
      ne_log_obj();
      unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        [(id)a1 protocolConfiguration];
        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412546;
        uint64_t v59 = a1;
        uint64_t v60 = 2112;
        uint64_t v61 = v53;
        _os_log_debug_impl( &dword_1876B1000,  v15,  OS_LOG_TYPE_DEBUG,  "%@: Starting IKEv2 Tunnel with configuration %@",  buf,  0x16u);
      }

      if (ne_session_disable_restrictions()
        && ([(id)a1 protocolConfiguration],
            int v16 = (void *)objc_claimAutoreleasedReturnValue(),
            [v16 serverAddress],
            unsigned __int16 v17 = (void *)objc_claimAutoreleasedReturnValue(),
            int v18 = [v17 isEqualToString:@"0.0.0.0"],
            v17,
            v16,
            v18))
      {
        ne_log_obj();
        unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138412290;
          uint64_t v59 = a1;
          _os_log_debug_impl( &dword_1876B1000,  v19,  OS_LOG_TYPE_DEBUG,  "%@: Starting a tunnel to 0.0.0.0, marking connected immediately",  buf,  0xCu);
        }

        int v20 = -[NETunnelNetworkSettings initWithTunnelRemoteAddress:]( objc_alloc(&OBJC_CLASS___NEPacketTunnelNetworkSettings),  "initWithTunnelRemoteAddress:",  @"0.0.0.0");
        uint64_t v21 = -[NEIPv4Settings initWithAddresses:subnetMasks:]( objc_alloc(&OBJC_CLASS___NEIPv4Settings),  "initWithAddresses:subnetMasks:",  &unk_18A0CFD18,  &unk_18A0CFD30);
        id v22 = objc_alloc_init(MEMORY[0x189603FA8]);
        uint64_t v23 = -[NEIPv4Route initWithDestinationAddress:subnetMask:]( objc_alloc(&OBJC_CLASS___NEIPv4Route),  "initWithDestinationAddress:subnetMask:",  @"0.0.0.0",  @"255.255.255.255");
        [v22 addObject:v23];

        -[NEIPv4Settings setIncludedRoutes:](v21, "setIncludedRoutes:", v22);
        -[NEPacketTunnelNetworkSettings setIPv4Settings:](v20, "setIPv4Settings:", v21);
        objc_initWeak((id *)buf, (id)a1);
        v56[0] = MEMORY[0x1895F87A8];
        v56[1] = 3221225472LL;
        v56[2] = __59__NEIKEv2PacketTunnelProvider_startIKEv2TunnelWithOptions___block_invoke;
        v56[3] = &unk_18A08F268;
        objc_copyWeak(&v57, (id *)buf);
        [(id)a1 setTunnelNetworkSettings:v20 completionHandler:v56];
        objc_destroyWeak(&v57);
        objc_destroyWeak((id *)buf);
      }

      else
      {
        [(id)a1 protocolConfiguration];
        id v27 = (void *)objc_claimAutoreleasedReturnValue();
        [v27 username];
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v29 = [v28 length] == 0;

        if (v29) {
          goto LABEL_40;
        }
        [v4 objectForKeyedSubscript:@"Password"];
        int v30 = (void *)objc_claimAutoreleasedReturnValue();
        unint64_t v31 = v30 == 0LL;

        if (!v31) {
          goto LABEL_40;
        }
        [v27 passwordKeychainItem];
        unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
        [v32 persistentReference];
        int v33 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v34 = v33 == 0LL;

        if (v34)
        {
          if (!-[NEIKEv2PacketTunnelProvider NEIKEv2ProviderAuthenticate:]((_BYTE *)a1, v4))
          {
            ne_log_obj();
            int v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              uint64_t v59 = a1;
              _os_log_error_impl( &dword_1876B1000,  v54,  OS_LOG_TYPE_ERROR,  "%@: Cancel IKEv2 tunnel, popping prompt for password failed",  buf,  0xCu);
            }

            -[NEIKEv2PacketTunnelProvider invokeCancelTunnel:]((_BYTE *)a1, (const char *)0x17);
          }
        }

        else
        {
LABEL_40:
          uint64_t v35 = objc_alloc_init(&OBJC_CLASS___NEIKEv2Server);
          objc_setProperty_atomic((id)a1, v36, v35, 128LL);

          uint64_t v37 = objc_alloc(&OBJC_CLASS___NEIKEv2MOBIKE);
          Property = objc_getProperty((id)a1, v38, 264LL, 1);
          unint64_t v40 = -[NEIKEv2MOBIKE initWithQueue:tunnelProvider:]((id *)&v37->super.isa, Property, (void *)a1);
          objc_setProperty_atomic((id)a1, v41, v40, 168LL);

          [(id)a1 protocolConfiguration];
          unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
          [v42 serverAddress];
          char v43 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v45 = objc_getProperty((id)a1, v44, 128LL, 1);
          if (v45) {
            objc_setProperty_atomic(v45, v46, v43, 16LL);
          }

          objc_msgSend(objc_getProperty((id)a1, v47, 208, 1), "scopedInterface");
          int v48 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v50 = objc_getProperty((id)a1, v49, 208LL, 1);
          if (v48) {
            [v50 scopedInterface];
          }
          else {
            [v50 interface];
          }
          int v51 = (void *)objc_claimAutoreleasedReturnValue();
          *(void *)(a1 + 24_Block_object_dispose((const void *)(v49 - 176), 8) = [v51 interfaceIndex];

          *(void *)(a1 + 256) = objc_msgSend(objc_getProperty((id)a1, v52, 208, 1), "status");
          v55[0] = MEMORY[0x1895F87A8];
          v55[1] = 3221225472LL;
          v55[2] = __59__NEIKEv2PacketTunnelProvider_startIKEv2TunnelWithOptions___block_invoke_93;
          v55[3] = &unk_18A08D468;
          v55[4] = a1;
          -[NEIKEv2PacketTunnelProvider resolveServerAddressIfNeeded:]((void *)a1, v55);
        }
      }
    }
  }

        __int16 v87 = 0LL;
LABEL_10:
        Property = objc_getProperty(WeakRetained, v8, 128LL, 1);
        if (Property) {
          Property = objc_getProperty(Property, v11, 56LL, 1);
        }
        uint64_t v12 = Property;

        if (!v12)
        {
          Socket = NEIKEv2PacketTunnelProviderGetSocket(WeakRetained, 1LL, a3, a4, a5);
          goto LABEL_78;
        }

        if (!v88)
        {
          ne_log_obj();
          unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            *(void *)&void buf[4] = WeakRetained;
            _os_log_error_impl( &dword_1876B1000,  v17,  OS_LOG_TYPE_ERROR,  "%@: No local endpoint for proxy path",  buf,  0xCu);
          }

          Socket = -1;
          goto LABEL_80;
        }

        [v88 port];
        uint64_t v13 = (id)objc_claimAutoreleasedReturnValue();
        unint64_t v15 = objc_getProperty(WeakRetained, v14, 128LL, 1);
        if (!v15 || (v15[8] & 1) == 0)
        {
          Socket = -1;
LABEL_77:

LABEL_78:
          ne_log_obj();
          unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138413314;
            *(void *)&void buf[4] = WeakRetained;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = Socket;
            *(_WORD *)&buf[18] = 2112;
            *(void *)&buf[20] = v88;
            v96 = 2112;
            v97 = v86;
            v98 = 2112;
            v99 = v87;
            _os_log_impl( &dword_1876B1000,  v17,  OS_LOG_TYPE_DEFAULT,  "%@: got socket (%d) for local %@ remote %@ interface %@",  buf,  0x30u);
          }

  [v4 integrityProtocols];
  int v18 = (void *)objc_claimAutoreleasedReturnValue();
  [v18 firstObject];
  unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();

  if (v19)
  {
    uint64_t v21 = v9 ? objc_getProperty(v9, v20, 104LL, 1) : 0LL;
    id v22 = v21;
    uint64_t v23 = -[os_log_s isEqual:](v19, "isEqual:", v22);

    if ((v23 & 1) == 0)
    {
      ne_log_obj();
      unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_ERROR))
      {
LABEL_25:

        goto LABEL_26;
      }

      unint64_t v40 = 0;
      int v33 = "Incorrect integrity algorithm chosen";
      uint64_t v34 = (uint8_t *)&v40;
LABEL_34:
      _os_log_error_impl(&dword_1876B1000, (os_log_t)v32, OS_LOG_TYPE_ERROR, v33, v34, 2u);
      goto LABEL_25;
    }
  }

LABEL_14:
  [v4 kemProtocols];
  unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  [v24 firstObject];
  unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();

  if (v19)
  {
    int v26 = v9 ? objc_getProperty(v9, v25, 112LL, 1) : 0LL;
    id v27 = v26;
    uint64_t v28 = -[os_log_s isEqual:](v19, "isEqual:", v27);

    if ((v28 & 1) == 0)
    {
      ne_log_obj();
      unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      uint64_t v38 = 0;
      int v33 = "Incorrect KE method chosen";
      uint64_t v34 = (uint8_t *)&v38;
      goto LABEL_34;
    }
  }

  uint64_t v29 = 1;
LABEL_27:

  return v29;
}

  CFStringRef v10 = 0LL;
  if (!a4) {
    goto LABEL_10;
  }
LABEL_5:
  CFStringRef v11 = CFStringGetLength(a4);
  if (!Length) {
    return Length;
  }
LABEL_11:
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL, 0LL);
  Length = Mutable;
  if (Mutable)
  {
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x18960BB38], (const void *)*MEMORY[0x18960BB48]);
    CFDictionaryAddValue(Length, (const void *)*MEMORY[0x18960BA88], theString);
    if (v9) {
      CFDictionaryAddValue(Length, (const void *)*MEMORY[0x18960B870], a2);
    }
    if (v10) {
      CFDictionaryAddValue(Length, (const void *)*MEMORY[0x18960B9F8], a3);
    }
    if (v11) {
      CFDictionaryAddValue(Length, (const void *)*MEMORY[0x18960B918], a4);
    }
  }

  return Length;
}

      if (!*(void *)&v4[4]._os_unfair_lock_opaque) {
        goto LABEL_24;
      }
      os_channel_packet_free();
      goto LABEL_11;
    }

    if (!os_channel_get_next_slot())
    {
      ne_log_obj();
      __int128 v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v10 = "EGRESS";
        if (!a3) {
          CFStringRef v10 = "INGRESS";
        }
        *(_DWORD *)buf = 138412802;
        unint64_t v15 = v4;
        int v16 = 2080;
        unsigned __int16 v17 = v10;
        int v18 = 2112;
        unint64_t v19 = @"bad next slot";
        goto LABEL_28;
      }

      goto LABEL_9;
    }
  }

  if (os_channel_slot_attach_packet())
  {
    ne_log_obj();
    __int128 v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      unsigned int v6 = "EGRESS";
      if (!a3) {
        unsigned int v6 = "INGRESS";
      }
      *(_DWORD *)buf = 138412802;
      unint64_t v15 = v4;
      int v16 = 2080;
      unsigned __int16 v17 = v6;
      int v18 = 2112;
      unint64_t v19 = @"bad attach";
LABEL_28:
      _os_log_error_impl(&dword_1876B1000, v5, OS_LOG_TYPE_ERROR, "%@: %s - %@", buf, 0x20u);
      goto LABEL_9;
    }

    goto LABEL_9;
  }

  unint64_t v7 = os_channel_advance_slot();
  ne_log_obj();
  uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  id v9 = v8;
  if (v7)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = "EGRESS";
      if (!a3) {
        uint64_t v12 = "INGRESS";
      }
      *(_DWORD *)buf = 138412802;
      unint64_t v15 = v4;
      int v16 = 2080;
      unsigned __int16 v17 = v12;
      int v18 = 2112;
      unint64_t v19 = @"Failed to advance slot";
      _os_log_error_impl(&dword_1876B1000, v9, OS_LOG_TYPE_ERROR, "%@: %s - %@", buf, 0x20u);
    }

    if (*(void *)&v4[4]._os_unfair_lock_opaque)
    {
LABEL_11:
      if (os_channel_is_defunct())
      {
        os_unfair_lock_lock(v4 + 2);
        -[NEFilterPacketInterpose close_nolock:]((uint64_t)v4, 1);
        os_unfair_lock_unlock(v4 + 2);
      }
    }
  }

  else
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v13 = "EGRESS";
      if (!a3) {
        uint64_t v13 = "INGRESS";
      }
      *(_DWORD *)buf = 138412546;
      unint64_t v15 = v4;
      int v16 = 2080;
      unsigned __int16 v17 = v13;
      _os_log_debug_impl( &dword_1876B1000,  v9,  OS_LOG_TYPE_DEBUG,  "%@ sendDataOnRing: sent packet on %s tx ring",  buf,  0x16u);
    }
  }
}

    CFStringRef v10 = 0LL;
    Property = 0LL;
    goto LABEL_8;
  }

  __int128 v5 = *(void *)(a1 + 48);
  unsigned int v6 = *(void **)(a1 + 32);
  if (v6) {
    unint64_t v7 = objc_getProperty(v6, v4, 104LL, 1);
  }
  else {
    unint64_t v7 = 0LL;
  }
  (*(void (**)(uint64_t, id, void))(v5 + 16))(v5, v7, *(void *)(a1 + 40));
}
}

    myCFDataReleaseReset(a1);
    *a1 = (CFDataRef)MutableCopy;
    return;
  }

  CFStringRef v11 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
  {
    uint64_t v12 = 136315138;
    uint64_t v13 = "myCFDataResetReplaceFromString";
    _os_log_fault_impl(&dword_1876B1000, v11, OS_LOG_TYPE_FAULT, "%s called with null oldP", (uint8_t *)&v12, 0xCu);
  }

    MEMORY[0x1895AC894](v13);
  }

  return p_ifa_next;
}

LABEL_213:
    uint64_t v68 = 0LL;
    goto LABEL_183;
  }

LABEL_226:
          BOOL v25 = v116;
          uint64_t v35 = v119;
          unint64_t v31 = v120;
LABEL_227:

          goto LABEL_228;
        }

        int v39 = v38;
        -[os_log_s addObject:](v32, "addObject:", v38);
LABEL_58:

        unint64_t v31 = v120;
      }

      else
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v143 = 0u;
          v144 = 0u;
          v141 = 0u;
          v142 = 0u;
          int v39 = v37;
          unint64_t v40 = -[NEIKEv2EncryptionProtocol countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v141,  v151,  16LL);
          if (v40)
          {
            unint64_t v41 = v40;
            v110 = v37;
            unint64_t v42 = *(void *)v142;
            while (2)
            {
              for (CFIndex i = 0LL; i != v41; ++i)
              {
                if (*(void *)v142 != v42) {
                  objc_enumerationMutation(v39);
                }
                uint64_t v44 = *(__CFString **)(*((void *)&v141 + 1) + 8 * i);
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  uint64_t v45 = NEIPsecIKEGetEncryptionProtocol(v44, 0);
                  if (!v45)
                  {
                    ne_log_obj();
                    v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136315650;
                      v153 = "NEIPSecIKEValidateIKEDictionary";
                      v154 = 1024;
                      v155 = 1245;
                      v156 = 2112;
                      v157 = v44;
                      _os_log_error_impl( &dword_1876B1000,  v103,  OS_LOG_TYPE_ERROR,  "%s%d: %@ is not a recognized encryption method",  buf,  0x1Cu);
                    }

                    v104 = (os_log_s *)v39;
                    goto LABEL_213;
                  }

                  int v46 = v45;
                  -[os_log_s addObject:](v32, "addObject:", v45);
                }
              }

              unint64_t v41 = -[NEIKEv2EncryptionProtocol countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v141,  v151,  16LL);
              if (v41) {
                continue;
              }
              break;
            }

            BOOL v25 = v116;
            uint64_t v35 = v119;
            uint64_t v37 = v110;
          }

          else
          {
            BOOL v25 = v116;
          }

          goto LABEL_58;
        }
      }

      -[NEIKEv2IKESAProposal setEncryptionProtocols:](v31, "setEncryptionProtocols:", v32);

      p_info = (__objc2_class_ro **)(&OBJC_METACLASS___NEConfigurationManager + 32);
    }

    if (!CFDictionaryContainsKey(v35, @"IntegrityAlgorithm")) {
      goto LABEL_90;
    }
    unint64_t v32 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
    -[__CFDictionary objectForKeyedSubscript:](v35, "objectForKeyedSubscript:", @"IntegrityAlgorithm");
    int64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      int v48 = (os_log_s *)NEIPsecIKEGetIntegrityProtocol(v47);
      if (!v47)
      {
        ne_log_obj();
        v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v153 = "NEIPSecIKEValidateIKEDictionary";
          v154 = 1024;
          v155 = 1261;
          v156 = 2112;
          v157 = 0LL;
          _os_log_error_impl( &dword_1876B1000,  v105,  OS_LOG_TYPE_ERROR,  "%s%d: %@ is not a recognized integrity method",  buf,  0x1Cu);
        }

uint64_t __Block_byref_object_copy__8823(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__8824(uint64_t a1)
{
}

LABEL_298:
    goto LABEL_34;
  }

  if (v7) {
    CFStringRef v10 = 0;
  }
  else {
    CFStringRef v10 = (v6[23] & 1) == 0;
  }
  if (v10)
  {
    ne_log_obj();
    v328 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v328, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v422 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthPart2AsInitiator:childSA:]";
      v329 = "%s called with null childSA";
      goto LABEL_297;
    }

    goto LABEL_298;
  }

  if ((v6[9] & 1) == 0)
  {
    ne_log_obj();
    v328 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v328, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v422 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthPart2AsInitiator:childSA:]";
      v329 = "%s called with null ikeSA.isInitiator";
      goto LABEL_297;
    }

    goto LABEL_298;
  }

  self = v3;
  if (-[NEIKEv2Packet hasErrors](v3, v8))
  {
    v406 = v9;
    v402 = a1;
    v439 = 0u;
    v440 = 0u;
    block = 0u;
    v438 = 0u;
    uint64_t v12 = objc_getProperty(v3, v11, 64LL, 1);
    uint64_t v13 = [v12 countByEnumeratingWithState:&block objects:&v441 count:16];
    if (v13)
    {
      uint64_t v14 = v13;
      unint64_t v15 = 0LL;
      int v16 = *(void *)v438;
      do
      {
        unsigned __int16 v17 = 0LL;
        do
        {
          if (*(void *)v438 != v16) {
            objc_enumerationMutation(v12);
          }
          int v18 = *(void *)(*((void *)&block + 1) + 8 * v17);
          if (v18 && (unint64_t)(*(void *)(v18 + 24) - 1LL) <= 0x3FFE)
          {
            Error = (id)-[NEIKEv2NotifyPayload copyError](*(const __CFString **)(*((void *)&block + 1) + 8 * v17));

            ne_log_obj();
            int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              int v26 = (char *)[self copyShortDescription];
              *(_DWORD *)buf = 138412546;
              v422 = v26;
              v423 = 2112;
              v424 = Error;
              _os_log_error_impl( &dword_1876B1000,  v20,  OS_LOG_TYPE_ERROR,  "%@ Initiator auth received notify error %@",  buf,  0x16u);
            }

            int v3 = self;
            if ((*(void *)(v18 + 24) & 0xFFFFFFFFFFFFE000LL) != 0x2000
              || (v6[18] & 1) != 0
              || ((objc_getProperty(self, v21, 128LL, 1),
                   id v22 = objc_claimAutoreleasedReturnValue(),
                   (uint64_t v23 = (void *)v22) == 0LL)
                ? (unint64_t v24 = 0LL)
                : (unint64_t v24 = *(void **)(v22 + 32)),
                  BOOL v25 = v24,
                  v25,
                  v23,
                  !v25))
            {
              -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, Error);

              a1 = v402;
              id v9 = v406;
              goto LABEL_33;
            }

            unint64_t v15 = Error;
          }

          ++v17;
        }

        while (v14 != v17);
        id v27 = [v12 countByEnumeratingWithState:&block objects:&v441 count:16];
        uint64_t v14 = v27;
      }

      while (v27);
    }

    else
    {
      unint64_t v15 = 0LL;
    }

    uint64_t v28 = v15;
    a1 = v402;
    id v9 = v406;
  }

  else
  {
    uint64_t v28 = 0LL;
  }

  if (-[NEIKEv2IKESA usesEAPOnlyAuthentication](v6, v11) && (v6[20] & 1) == 0)
  {
    ne_log_obj();
    int v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v272 = (char *)[v3 copyShortDescription];
      *(_DWORD *)buf = 138412290;
      v422 = v272;
      _os_log_error_impl(&dword_1876B1000, v30, OS_LOG_TYPE_ERROR, "%@ EAP only authentication incomplete", buf, 0xCu);
    }

    ErrorAuthentication = (void *)NEIKEv2CreateErrorAuthentication( @"EAP only authentication did not complete",  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v386);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, ErrorAuthentication);

    goto LABEL_45;
  }

  if ((-[NEIKEv2IKEAuthPacket validateAuthPayloadAsInitiator:beforeEAP:](v3, v6, 0) & 1) == 0)
  {
LABEL_45:
    v419 = 0;
LABEL_46:

LABEL_79:
    uint64_t v67 = (void *)a1[4];
    if (v67 && v67[6] == 3LL)
    {
      uint64_t v68 = objc_getProperty(v67, v29, 56LL, 1);
      [v68 domain];
      uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();
      if ([v69 isEqual:@"NEIKEv2ErrorDomain"])
      {
        Property = (id)a1[4];
        if (Property) {
          Property = objc_getProperty(Property, v70, 56LL, 1);
        }
        uint64_t v72 = Property;
        uint64_t v73 = [v72 code];

        if (v73 == 5)
        {
          ne_log_obj();
          SEL v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
          {
            id v75 = a1[5];
            LODWORD(v441) = 138412290;
            *(void *)((char *)&v441 + 4) = v75;
            _os_log_impl( &dword_1876B1000,  v74,  OS_LOG_TYPE_DEFAULT,  "%@ Received server redirect in IKE Auth (connect)",  (uint8_t *)&v441,  0xCu);
          }

          unint64_t v77 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
          unint64_t v78 = (id)a1[5];
          if (v78) {
            unint64_t v78 = objc_getProperty(v78, v76, 368LL, 1);
          }
          uint64_t v79 = v78;
          v417[0] = MEMORY[0x1895F87A8];
          v417[1] = 3221225472LL;
          v417[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_153;
          v417[3] = &unk_18A08CF10;
          v417[4] = a1[5];
          v418 = v3;
          uint64_t v80 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]( (id *)&v77->super.super.isa,  0,  v79,  v417);

          -[NEIKEv2Session initiateDelete:]((void *)a1[5], v80);
          goto LABEL_217;
        }
      }

      else
      {
      }
    }

    ne_log_obj();
    int v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      v255 = a1[5];
      LODWORD(v441) = 138412290;
      *(void *)((char *)&v441 + 4) = v255;
      _os_log_error_impl( &dword_1876B1000,  v81,  OS_LOG_TYPE_ERROR,  "%@ Failed to process IKE Auth packet (connect)",  (uint8_t *)&v441,  0xCu);
    }

    v83 = a1[4];
    if (!v83 || *(void *)(v83 + 48) != 1LL)
    {
      unint64_t v91 = (id)a1[5];
      if (v91) {
        unint64_t v91 = objc_getProperty(v91, v82, 336LL, 1);
      }
      v92 = v91;
      ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Failed to process IKE Auth packet (connect)",  v93,  v94,  v95,  v96,  v97,  v98,  v99,  v386);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v92, 3uLL, ErrorPeerInvalidSyntax);

      -[NEIKEv2Session reportState]((void *)a1[5], v101);
      -[NEIKEv2Session resetAll](a1[5], v102);
      goto LABEL_217;
    }

    uint64_t v84 = *(void **)(*(void *)(a1[7] + 8) + 40LL);
    if (v84 && v84[4] == 3LL)
    {
      __int16 v85 = objc_getProperty(v84, v82, 40LL, 1);
      -[NEIKEv2IKESA setState:error:](v83, 3uLL, v85);
    }

    __int16 v87 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
    int v88 = (id)a1[5];
    if (v88) {
      int v88 = objc_getProperty(v88, v86, 368LL, 1);
    }
    uint64_t v89 = v88;
    v416[0] = MEMORY[0x1895F87A8];
    v416[1] = 3221225472LL;
    v416[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_154;
    v416[3] = &unk_18A08D468;
    v416[4] = a1[5];
    CFErrorRef v90 = v416;
LABEL_202:
    v246 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]( (id *)&v87->super.super.isa,  0,  v89,  v90);

    -[NEIKEv2Session initiateDelete:]((void *)a1[5], v246);
    goto LABEL_217;
  }

  if (v28)
  {
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v28);
    goto LABEL_45;
  }

  if (-[NEIKEv2Packet hasNotification:](v3, (const char *)0x4017))
  {
    v104 = 5LL;
LABEL_106:
    Error = (id)NEIKEv2CreateError(v104);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, Error);
LABEL_33:

LABEL_34:
    goto LABEL_79;
  }

  if ((v6[23] & 1) != 0) {
    goto LABEL_281;
  }
  if (v9) {
    v247 = objc_getProperty(v9, v103, 48LL, 1);
  }
  else {
    v247 = 0LL;
  }
  v248 = v247;
  if ([v248 mode] == 1)
  {
    v249 = -[NEIKEv2Packet hasNotification:](v3, (const char *)0x4007);

    if ((v249 & 1) == 0)
    {
      ne_log_obj();
      v251 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v251, OS_LOG_TYPE_ERROR))
      {
        v338 = (char *)[v3 copyShortDescription];
        *(_DWORD *)buf = 138412290;
        v422 = v338;
        _os_log_error_impl( &dword_1876B1000,  v251,  OS_LOG_TYPE_ERROR,  "%@ Transport mode Child SA was not accepted",  buf,  0xCu);
      }

      v104 = 9LL;
      goto LABEL_106;
    }
  }

  else
  {
  }

  objc_getProperty(v3, v250, 88LL, 1);
  v256 = (void *)objc_claimAutoreleasedReturnValue();
  v258 = v256;
  if (v256) {
    v256 = objc_getProperty(v256, v257, 24LL, 1);
  }
  Error = v256;

  if ([Error count] != 1)
  {
    ne_log_obj();
    v273 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v273, OS_LOG_TYPE_ERROR))
    {
      v326 = (char *)[v3 copyShortDescription];
      v327 = [Error count];
      *(_DWORD *)buf = 138412546;
      v422 = v326;
      v423 = 1024;
      LODWORD(v424) = v327;
      _os_log_error_impl( &dword_1876B1000,  v273,  OS_LOG_TYPE_ERROR,  "%@ Received %u child SA proposals, require 1",  buf,  0x12u);
    }

    v274 = [Error count];
    v282 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Received %u child SA proposals",  v275,  v276,  v277,  v278,  v279,  v280,  v281,  v274);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v282);

    goto LABEL_33;
  }

  [Error firstObject];
  v259 = (_BYTE *)objc_claimAutoreleasedReturnValue();
  if ((-[NEIKEv2ChildSAProposal isAValidResponse](v259, v260) & 1) == 0)
  {
    ne_log_obj();
    v284 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v284, OS_LOG_TYPE_ERROR))
    {
      v363 = (void *)[v3 copyShortDescription];
      *(_DWORD *)buf = 138412802;
      v422 = (const char *)v9;
      v423 = 2112;
      v424 = v363;
      v425 = 2112;
      v426 = v259;
      _os_log_error_impl( &dword_1876B1000,  v284,  OS_LOG_TYPE_ERROR,  "%@ %@ Received invalid child proposal %@",  buf,  0x20u);
    }

    v285 = @"Received invalid child proposal %@";
    goto LABEL_265;
  }

  if (v259) {
    v262 = objc_getProperty(v259, v261, 80LL, 1);
  }
  else {
    v262 = 0LL;
  }
  v263 = v262;

  if (!v263)
  {
    ne_log_obj();
    v284 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v284, OS_LOG_TYPE_ERROR))
    {
      v381 = (char *)[v3 copyShortDescription];
      *(_DWORD *)buf = 138412290;
      v422 = v381;
      _os_log_error_impl(&dword_1876B1000, v284, OS_LOG_TYPE_ERROR, "%@ Child SA proposal missing SPI", buf, 0xCu);
    }

    v285 = @"Received child proposal missing SPI %@";
LABEL_265:

    v325 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v285, v318, v319, v320, v321, v322, v323, v324, (uint64_t)v259);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v325);

    goto LABEL_33;
  }

  v409 = Error;
  v435 = 0u;
  v436 = 0u;
  *(_OWORD *)v433 = 0u;
  v434 = 0u;
  v265 = v9;
  v266 = -[NEIKEv2ChildSA configProposalsWithoutKEM](v9, v264);
  v267 = [v266 countByEnumeratingWithState:v433 objects:&v429 count:16];
  if (!v267) {
    goto LABEL_234;
  }
  v268 = v267;
  v269 = *(void *)v434;
LABEL_228:
  v270 = 0LL;
  while (1)
  {
    if (*(void *)v434 != v269) {
      objc_enumerationMutation(v266);
    }
    v271 = *(void **)(*(void *)&v433[8] + 8 * v270);
    if (v268 == ++v270)
    {
      v268 = [v266 countByEnumeratingWithState:v433 objects:&v429 count:16];
      if (!v268)
      {
LABEL_234:

        goto LABEL_259;
      }

      goto LABEL_228;
    }
  }

  v288 = v271;

  if (!v288)
  {
LABEL_259:
    ne_log_obj();
    v309 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    id v9 = v265;
    uint64_t v28 = v409;
    if (os_log_type_enabled(v309, OS_LOG_TYPE_ERROR))
    {
      v375 = a1;
      v377 = (void *)[v3 copyShortDescription];
      if (v265) {
        v378 = objc_getProperty(v265, v376, 48LL, 1);
      }
      else {
        v378 = 0LL;
      }
      v379 = v378;
      [v379 proposals];
      v380 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138413058;
      v422 = v265;
      v423 = 2112;
      v424 = v377;
      v425 = 2112;
      v426 = v259;
      v427 = 2112;
      v428 = v380;
      _os_log_error_impl( &dword_1876B1000,  v309,  OS_LOG_TYPE_ERROR,  "%@ %@ Received child proposal %@ does not match config %@",  buf,  0x2Au);

      int v3 = self;
      a1 = v375;
      uint64_t v28 = v409;
    }

    v317 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Received child proposal does not match config",  v310,  v311,  v312,  v313,  v314,  v315,  v316,  v386);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v317);

    v419 = 0;
    goto LABEL_261;
  }

  v289 = -[NEIKEv2ChildSAProposal copyFromRemote:preferRemoteProposal:checkKEMethod:](v288, v259, 0, 0);
  v291 = v289;
  id v9 = v265;
  if (v265)
  {
    objc_setProperty_atomic(v265, v290, v289, 56LL);

    v293 = objc_getProperty(v265, v292, 56LL, 1);
  }

  else
  {

    v293 = 0LL;
  }

  v294 = v293;

  ne_log_obj();
  v295 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  v296 = v295;
  if (!v294)
  {
    if (os_log_type_enabled(v295, OS_LOG_TYPE_ERROR))
    {
      v382 = (char *)[v3 copyShortDescription];
      *(_DWORD *)buf = 138412290;
      v422 = v382;
      _os_log_error_impl( &dword_1876B1000,  v296,  OS_LOG_TYPE_ERROR,  "%@ Could not set chosen proposal values",  buf,  0xCu);
    }

    v337 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"Could not set chosen proposal values",  v330,  v331,  v332,  v333,  v334,  v335,  v336,  v386);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v337);

    v419 = 0;
    uint64_t v28 = v409;
    goto LABEL_261;
  }

  if (os_log_type_enabled(v295, OS_LOG_TYPE_DEFAULT))
  {
    v298 = (void *)[v3 copyShortDescription];
    v299 = a1;
    if (v265) {
      v300 = objc_getProperty(v265, v297, 56LL, 1);
    }
    else {
      v300 = 0LL;
    }
    v301 = v300;
    *(_DWORD *)buf = 138412802;
    v422 = v265;
    v423 = 2112;
    v424 = v298;
    v425 = 2112;
    v426 = v301;
    _os_log_impl( &dword_1876B1000,  v296,  OS_LOG_TYPE_DEFAULT,  "%@ %@ Chose responder auth child proposal %@",  buf,  0x20u);

    a1 = v299;
  }

  -[NEIKEv2ChildSA setConfigProposalsWithoutKEM:](v265, v302);
  if (v265) {
    v304 = objc_getProperty(v265, v303, 48LL, 1);
  }
  else {
    v304 = 0LL;
  }
  v305 = v304;
  if ([v305 sequencePerTrafficClass])
  {
    v306 = -[NEIKEv2Packet hasNotification:](v3, (const char *)0xC350);

    if (v306)
    {
      ne_log_obj();
      v308 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v308, OS_LOG_TYPE_DEBUG))
      {
        v384 = (char *)[v3 copyShortDescription];
        *(_DWORD *)buf = 138412290;
        v422 = v384;
        _os_log_debug_impl( &dword_1876B1000,  v308,  OS_LOG_TYPE_DEBUG,  "%@ Server Sequence Per Traffic Class supported",  buf,  0xCu);
      }

      if (v265) {
        v265[10] = 1;
      }
    }
  }

  else
  {
  }

  objc_getProperty(v3, v307, 160LL, 1);
  v339 = (void *)objc_claimAutoreleasedReturnValue();
  v341 = v339;
  if (v339) {
    v339 = objc_getProperty(v339, v340, 24LL, 1);
  }
  v342 = v339;
  -[NEIKEv2ChildSA setInitiatorTrafficSelectors:](v265, v342);
  v344 = -[NEIKEv2ChildSA initiatorTrafficSelectors](v265, v343);
  if (!v344)
  {
    ne_log_obj();
    v364 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v28 = v409;
    if (os_log_type_enabled(v364, OS_LOG_TYPE_ERROR))
    {
      v383 = (char *)[v3 copyShortDescription];
      *(_DWORD *)buf = 138412290;
      v422 = v383;
      _os_log_error_impl( &dword_1876B1000,  v364,  OS_LOG_TYPE_ERROR,  "%@ Could not set initiator traffic selectors",  buf,  0xCu);

      uint64_t v28 = v409;
    }

    v372 = @"Could not set initiator traffic selectors";
    goto LABEL_302;
  }

  objc_getProperty(v3, v345, 168LL, 1);
  v346 = (void *)objc_claimAutoreleasedReturnValue();
  v348 = v346;
  if (v346) {
    v346 = objc_getProperty(v346, v347, 24LL, 1);
  }
  v349 = v346;
  -[NEIKEv2ChildSA setResponderTrafficSelectors:](v265, v349);
  v351 = -[NEIKEv2ChildSA responderTrafficSelectors](v265, v350);
  if (!v351)
  {
    ne_log_obj();
    v373 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v28 = v409;
    if (os_log_type_enabled(v373, OS_LOG_TYPE_ERROR))
    {
      v385 = (char *)[v3 copyShortDescription];
      *(_DWORD *)buf = 138412290;
      v422 = v385;
      _os_log_error_impl( &dword_1876B1000,  v373,  OS_LOG_TYPE_ERROR,  "%@ Could not set responder traffic selectors",  buf,  0xCu);

      uint64_t v28 = v409;
    }

    v372 = @"Could not set responder traffic selectors";
LABEL_302:
    v374 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v372, v365, v366, v367, v368, v369, v370, v371, v386);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v374);

    v419 = 0;
LABEL_261:

    goto LABEL_46;
  }

LABEL_281:
  v352 = objc_getProperty(v3, v103, 152LL, 1);

  if (v352)
  {
    v354 = objc_getProperty(v3, v353, 152LL, 1);
    v356 = v354;
    if (v354) {
      v354 = objc_getProperty(v354, v355, 24LL, 1);
    }
    v357 = v354;
    objc_setProperty_atomic(v6, v358, v357, 488LL);
  }

  v359 = objc_getProperty(v6, v353, 88LL, 1);
  if ([v359 negotiateMOBIKE])
  {
    v360 = -[NEIKEv2Packet hasNotification:](v3, (const char *)0x400C);

    if (v360)
    {
      ne_log_obj();
      v361 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v361, OS_LOG_TYPE_DEBUG))
      {
        v362 = (char *)[v3 copyShortDescription];
        *(_DWORD *)buf = 138412290;
        v422 = v362;
        _os_log_debug_impl(&dword_1876B1000, v361, OS_LOG_TYPE_DEBUG, "%@ Server MOBIKE supported", buf, 0xCu);
      }

      v6[11] = 1;
    }
  }

  else
  {
  }

  int v39 = (void *)a1[5];
  unint64_t v40 = v3;
  v403 = a1;
  if (!v39) {
    goto LABEL_110;
  }
  unint64_t v41 = objc_alloc_init(MEMORY[0x189603FA8]);
  v429 = 0u;
  v430 = 0u;
  v431 = 0u;
  v432 = 0u;
  v400 = v40;
  char v43 = objc_getProperty(v40, v42, 64LL, 1);
  uint64_t v44 = [v43 countByEnumeratingWithState:&v429 objects:&v441 count:16];
  if (!v44) {
    goto LABEL_73;
  }
  int v46 = v44;
  int64_t v47 = *(void *)v430;
  do
  {
    int v48 = 0LL;
    do
    {
      if (*(void *)v430 != v47) {
        objc_enumerationMutation(v43);
      }
      uint64_t v49 = *(void **)(*((void *)&v429 + 1) + 8 * v48);
      if (v49)
      {
        uint64_t v50 = v49[3];
        if (v50 != 16398)
        {
          if (v50 != 16397) {
            goto LABEL_68;
          }
          block = 0uLL;
          int v51 = objc_getProperty(v49, v45, 32LL, 1);
          if ([v51 length] == 4)
          {
            LOWORD(block) = 528;
            uint64_t v52 = v51;
            uint64_t v53 = (char *)&block + 4;
            int v54 = 4LL;
            goto LABEL_60;
          }

          ne_log_obj();
          uint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            unint64_t v57 = [v51 length];
            *(_DWORD *)v433 = 134217984;
            *(void *)&v433[4] = v57;
            int v58 = v56;
            uint64_t v59 = "Additional IPv4 address has invalid length %llu";
            goto LABEL_71;
          }

          goto LABEL_64;
        }

        block = 0uLL;
        DWORD2(v43_Block_object_dispose((const void *)(v49 - 176), 8) = 0;
        *(void *)&v438 = 0LL;
        int v51 = objc_getProperty(v49, v45, 32LL, 1);
        if ([v51 length] == 16)
        {
          LOWORD(block) = 7708;
          uint64_t v52 = v51;
          uint64_t v53 = (char *)&block + 8;
          int v54 = 16LL;
LABEL_60:
          [v52 getBytes:v53 length:v54];
          [MEMORY[0x189608DE8] endpointWithAddress:&block];
          BOOL v55 = (void *)objc_claimAutoreleasedReturnValue();
        }

        else
        {
          ne_log_obj();
          uint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            uint64_t v60 = [v51 length];
            *(_DWORD *)v433 = 134217984;
            *(void *)&v433[4] = v60;
            int v58 = v56;
            uint64_t v59 = "Additional IPv6 address has invalid length %llu";
LABEL_71:
            _os_log_error_impl(&dword_1876B1000, v58, OS_LOG_TYPE_ERROR, v59, v433, 0xCu);
          }

LABEL_186:
        v231 = 0LL;
        goto LABEL_183;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        [v225 address];
        v227 = (void *)objc_claimAutoreleasedReturnValue();
        v235 = (void *)a1[5];
        if (!v235) {
          goto LABEL_186;
        }
        v229 = objc_getProperty(v235, v234, 336LL, 1);
        v231 = v229;
        if (v229)
        {
          v232 = v227;
          v233 = 72LL;
LABEL_182:
          objc_setProperty_atomic(v229, v230, v232, v233);
        }

LABEL_183:
        v222 = 1;
      }

      if (v221 != ++v224) {
        continue;
      }
      break;
    }

    v236 = [v219 countByEnumeratingWithState:&v410 objects:v420 count:16];
    v221 = v236;
    if (v236) {
      continue;
    }
    break;
  }

  if ((v222 & 1) != 0)
  {
    ne_log_obj();
    v237 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v237, OS_LOG_TYPE_INFO))
    {
      v238 = a1[5];
      LODWORD(v441) = 138412290;
      *(void *)((char *)&v441 + 4) = v238;
      _os_log_impl( &dword_1876B1000,  v237,  OS_LOG_TYPE_INFO,  "%@ Changing addresses and migrating (connect)",  (uint8_t *)&v441,  0xCu);
    }

    -[NEIKEv2Session migrateAllChildSAs](a1[5], v239);
  }

    v217 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v267, v260, v261, v262, v263, v264, v265, v266, v361);
    -[NEIKEv2IKESA setState:error:](v5, 3uLL, v217);
LABEL_184:

    goto LABEL_127;
  }

  ne_log_obj();
  v130 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
  {
    v322 = (char *)[(id)a1 copyShortDescription];
    buf = 138412546;
    v384 = v322;
    v385 = 2048;
    v386 = (NEIKEv2AuthenticationProtocol *)v128;
    _os_log_error_impl( &dword_1876B1000,  v130,  OS_LOG_TYPE_ERROR,  "%@ NONCE data length %zu is out of bounds",  (uint8_t *)&buf,  0x16u);
  }

  v138 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( @"NONCE data length %zu is out of bounds",  v131,  v132,  v133,  v134,  v135,  v136,  v137,  v128);
LABEL_126:
  v141 = v138;
  -[NEIKEv2IKESA setState:error:](v5, 3uLL, v138);
LABEL_127:
  a1 = 0LL;
LABEL_128:
  SEL v74 = v373;
LABEL_107:

LABEL_108:
LABEL_109:

LABEL_48:
LABEL_49:

  return a1;
}

LABEL_212:
  ne_log_obj();
  v252 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v252, OS_LOG_TYPE_DEFAULT))
  {
    v253 = a1[5];
    LODWORD(v441) = 138412290;
    *(void *)((char *)&v441 + 4) = v253;
    _os_log_impl( &dword_1876B1000,  v252,  OS_LOG_TYPE_DEFAULT,  "%@ Completed connection (connect)",  (uint8_t *)&v441,  0xCu);
  }

  -[NEIKEv2IKESA setState:error:](a1[4], 2uLL, 0LL);
  v254 = *(void **)(*(void *)(a1[7] + 8) + 40LL);
  if (v254)
  {
    -[NEIKEv2Session reportTrafficSelectorsForChildSA:]((void *)a1[5], v254);
    -[NEIKEv2ChildSA setState:error:](*(void *)(*(void *)(a1[7] + 8) + 40LL), 2uLL, 0LL);
  }

  -[NEIKEv2Session reportState]((void *)a1[5], (const char *)v254);
LABEL_217:
}

LABEL_155:
                  _os_log_fault_impl(&dword_1876B1000, v255, OS_LOG_TYPE_FAULT, v256, buf, 2u);
                  goto LABEL_156;
                }

                ne_log_obj();
                uint64_t v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 136315138;
                  v282 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitResponse:ikeSA:]";
                  v227 = "%s called with null packet.nonce.isValid";
                  goto LABEL_117;
                }

LABEL_78:
}

        goto LABEL_79;
      }
    }

    CFStringRef v10 = -[os_log_s countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v205,  v218,  16LL);
  }

  while (v10);
LABEL_15:

LABEL_16:
  uint64_t v14 = objc_getProperty(v6, v7, 48LL, 1);
  if ([v14 mode] != 1)
  {

LABEL_24:
    objc_getProperty(v3, v16, 96LL, 1);
    Property = (void *)objc_claimAutoreleasedReturnValue();
    int v30 = Property;
    if (Property) {
      Property = objc_getProperty(Property, v29, 24LL, 1);
    }
    uint64_t v8 = Property;

    if (-[os_log_s count](v8, "count") == 1)
    {
      -[os_log_s firstObject](v8, "firstObject");
      unsigned __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if ((-[NEIKEv2ChildSAProposal isAValidResponse](v17, v31) & 1) != 0)
      {
        if (v17) {
          int v33 = objc_getProperty(v17, v32, 80LL, 1);
        }
        else {
          int v33 = 0LL;
        }
        uint64_t v34 = v33;

        if (v34)
        {
          v203 = 0u;
          v204 = 0u;
          v201 = 0u;
          v202 = 0u;
          int v36 = objc_getProperty(v6, v35, 48LL, 1);
          [v36 proposals];
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();

          uint64_t v38 = [v37 countByEnumeratingWithState:&v201 objects:v217 count:16];
          if (v38)
          {
            int v39 = v38;
            unint64_t v40 = *(void *)v202;
LABEL_33:
            unint64_t v41 = 0LL;
            while (1)
            {
              if (*(void *)v202 != v40) {
                objc_enumerationMutation(v37);
              }
              unint64_t v42 = *(void **)(*((void *)&v201 + 1) + 8 * v41);
              if ((-[NEIKEv2ChildSAProposal matchesLocalProposal:preferRemoteProposal:checkKEMethod:]( (uint64_t)v42,  v17,  0,  0) & 1) != 0) {
                break;
              }
              if (v39 == ++v41)
              {
                int v39 = [v37 countByEnumeratingWithState:&v201 objects:v217 count:16];
                if (v39) {
                  goto LABEL_33;
                }
                goto LABEL_39;
              }
            }

            uint64_t v44 = v42;

            if (!v44) {
              goto LABEL_64;
            }
            uint64_t v49 = -[NEIKEv2ChildSAProposal copyFromRemote:preferRemoteProposal:checkKEMethod:](v44, v17, 0, 0);
            objc_setProperty_atomic(v6, v50, v49, 56LL);

            uint64_t v52 = objc_getProperty(v6, v51, 56LL, 1);
            ne_log_obj();
            uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            char v43 = v53;
            if (v52)
            {
              if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
              {
                int v54 = (void *)[v3 copyShortDescription];
                uint64_t v56 = objc_getProperty(v6, v55, 56LL, 1);
                *(_DWORD *)buf = 138412802;
                v210 = v6;
                v211 = 2112;
                v212 = (uint64_t)v54;
                v213 = 2112;
                v214 = (uint64_t)v56;
                _os_log_impl( &dword_1876B1000,  v43,  OS_LOG_TYPE_DEFAULT,  "%@ %@ Chose responder new child proposal %@",  buf,  0x20u);
              }

              objc_getProperty(v3, v57, 112LL, 1);
              int v58 = (void *)objc_claimAutoreleasedReturnValue();

              if (v58)
              {
                objc_getProperty(v3, v59, 112LL, 1);
                uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
                int v62 = v60;
                if (v60) {
                  uint64_t v60 = objc_getProperty(v60, v61, 24LL, 1);
                }
                uint64_t v63 = v60;

                if (v63)
                {
                  -[NEIKEv2ChildSA ikeSA]((id *)v6);
                  uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
                  self = v64;
                  if (v64) {
                    uint64_t v64 = objc_getProperty(v64, v65, 80LL, 1);
                  }
                  int v66 = v64;
                  uint64_t v67 = [v66 strictNonceSizeChecks];

                  if (v67)
                  {
                    objc_getProperty(v3, v68, 112LL, 1);
                    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();
                    unint64_t v71 = v69;
                    if (v69) {
                      uint64_t v69 = objc_getProperty(v69, v70, 24LL, 1);
                    }
                    uint64_t v72 = v69;
                    uint64_t v73 = [v72 length];

                    if ((unint64_t)(v73 - 257) <= 0xFFFFFFFFFFFFFF0ELL)
                    {
                      ne_log_obj();
                      id v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v76 = (void *)[v3 copyShortDescription];
                        *(_DWORD *)buf = 138412802;
                        v210 = v6;
                        v211 = 2112;
                        v212 = (uint64_t)v76;
                        v213 = 2048;
                        v214 = v73;
                        unint64_t v77 = "%@ %@ NONCE data length %zu is out of bounds";
                        unint64_t v78 = v75;
                        uint64_t v79 = 32;
LABEL_142:
                        _os_log_error_impl(&dword_1876B1000, v78, OS_LOG_TYPE_ERROR, v77, buf, v79);
                      }

                v170 = 0;

                v100 = v170;
                if ((v100 & 1) == 0)
                {
LABEL_79:
                  ne_log_obj();
                  v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(buf) = 138412290;
                    *(void *)((char *)&buf + 4) = v5;
                    _os_log_error_impl( &dword_1876B1000,  v101,  OS_LOG_TYPE_ERROR,  "%@ Failed to fetch local certificate identity (connect)",  (uint8_t *)&buf,  0xCu);
                  }

                  id v27 = objc_getProperty(v5, v102, 336LL, 1);
                  Error = (id)NEIKEv2CreateErrorInternal( @"Failed to fetch local certificate identity (connect)",  v103,  v104,  v105,  v106,  v107,  v108,  v109,  v156);
                  -[NEIKEv2IKESA setState:error:]((uint64_t)v27, 3uLL, Error);
                  goto LABEL_82;
                }

                goto LABEL_122;
              }

              objc_setProperty_atomic(v8, v63, v58, 264LL);
              objc_setProperty_atomic(v8, v125, v59, 272LL);
              v8[22] = v162;

LABEL_121:
LABEL_122:
              +[NEIKEv2IKESAInitPacket createIKESAInitForInitiatorIKESA:]( (uint64_t)&OBJC_CLASS___NEIKEv2IKESAInitPacket,  v8);
              uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (v29)
              {
                *(void *)&buf = MEMORY[0x1895F87A8];
                *((void *)&buf + 1) = 3221225472LL;
                v178 = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke;
                v179 = &unk_18A08D000;
                v180 = v5;
                v181 = v8;
                v182 = &v164;
                if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)v5, v29, &buf) == -1)
                {
                  v127 = objc_getProperty(v5, v126, 336LL, 1);
                  ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend( @"initiator SA INIT",  v128,  v129,  v130,  v131,  v132,  v133,  v134,  v156);
                  -[NEIKEv2IKESA setState:error:]((uint64_t)v127, 3uLL, ErrorFailedToSend);

                  -[NEIKEv2Session reportState](v5, v136);
                  -[NEIKEv2Session resetAll]((uint64_t)v5, v137);
                }
              }

              else
              {
                ne_log_obj();
                v138 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v138, OS_LOG_TYPE_ERROR))
                {
                  LODWORD(buf) = 138412290;
                  *(void *)((char *)&buf + 4) = v5;
                  _os_log_error_impl( &dword_1876B1000,  v138,  OS_LOG_TYPE_ERROR,  "%@ Failed to create IKE SA Init packet (connect)",  (uint8_t *)&buf,  0xCu);
                }

                v140 = objc_getProperty(v5, v139, 336LL, 1);
                v148 = (void *)NEIKEv2CreateErrorInternal( @"Failed to create IKE SA Init packet (connect)",  v141,  v142,  v143,  v144,  v145,  v146,  v147,  v156);
                -[NEIKEv2IKESA setState:error:]((uint64_t)v140, 3uLL, v148);

                -[NEIKEv2Session reportState](v5, v149);
                -[NEIKEv2Session resetAll]((uint64_t)v5, v150);
                uint64_t v29 = 0LL;
              }

              goto LABEL_24;
            }

            if (certificateRef[0])
            {
              CFRelease(certificateRef[0]);
              certificateRef[0] = 0LL;
            }

            ne_log_obj();
            v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v99, OS_LOG_TYPE_FAULT))
            {
              LOWORD(buf) = 0;
              _os_log_fault_impl( &dword_1876B1000,  v99,  OS_LOG_TYPE_FAULT,  "SecIdentityCopyCertificate failed",  (uint8_t *)&buf,  2u);
            }
          }

          else
          {
            ne_log_obj();
            v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl( &dword_1876B1000,  v99,  OS_LOG_TYPE_ERROR,  "failed to get identity from persistent reference",  (uint8_t *)&buf,  2u);
            }
          }

          goto LABEL_78;
        }

        int v86 = objc_getProperty(v8, v57, 88LL, 1);
        [v86 localCertificateName];
        __int16 v87 = (void *)objc_claimAutoreleasedReturnValue();

        if (!v87) {
          goto LABEL_121;
        }
        value = v87;
        objc_opt_self();
        objc_opt_self();
        int v88 = *MEMORY[0x18960BB50];
        uint64_t v89 = *MEMORY[0x18960BE30];
        v184 = *MEMORY[0x18960BB38];
        v185 = v89;
        CFErrorRef v90 = *MEMORY[0x189604DE8];
        *(void *)&v188 = v88;
        *((void *)&v188 + 1) = v90;
        unint64_t v91 = *MEMORY[0x18960BDA8];
        v92 = *MEMORY[0x18960BE70];
        v186 = *MEMORY[0x18960BDA0];
        v187 = v92;
        v159 = v92;
        v160 = v90;
        v189 = v91;
        v190 = v90;
        [MEMORY[0x189603F68] dictionaryWithObjects:&v188 forKeys:&v184 count:4];
        v93 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
        uint64_t result = 0LL;
        v94 = SecItemCopyMatching(v93, &result);
        v95 = (void *)result;
        if (v94 || ![(id)result count])
        {
          ne_log_obj();
          v96 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
          {
            LODWORD(v183[0]) = 67109120;
            HIDWORD(v183[0]) = v94;
            _os_log_error_impl( &dword_1876B1000,  v96,  OS_LOG_TYPE_ERROR,  "failed to retrieve all certificate identities (%d)",  (uint8_t *)v183,  8u);
          }
        }

        else
        {
          v112 = v95;

          if (v112)
          {
            v173 = 0u;
            v174 = 0u;
            *(_OWORD *)certificateRef = 0u;
            v172 = 0u;
            v113 = v112;
            v114 = [v113 countByEnumeratingWithState:certificateRef objects:&buf count:16];
            if (v114)
            {
              v115 = *(void *)v172;
              v157 = *MEMORY[0x18960BE88];
              v158 = *MEMORY[0x18960BE28];
              v156 = 136315138LL;
              do
              {
                v116 = 0LL;
                do
                {
                  if (*(void *)v172 != v115) {
                    objc_enumerationMutation(v113);
                  }
                  v117 = (__SecIdentity *)*((void *)certificateRef[1] + v116);
                  v183[0] = 0LL;
                  if (SecIdentityCopyCertificate(v117, v183))
                  {
                    if (v183[0]) {
                      CFRelease(v183[0]);
                    }
                  }

                  else
                  {
                    v118 = (const __CFArray *)SecCertificateCopyCommonNames();
                    v119 = v118;
                    if (v118)
                    {
                      v192.length = CFArrayGetCount(v118);
                      v192.location = 0LL;
                      if (CFArrayContainsValue(v119, v192, value))
                      {
                        objc_opt_self();
                        if (v117)
                        {
                          v184 = v158;
                          v185 = v157;
                          *(void *)&v188 = v160;
                          *((void *)&v188 + 1) = v117;
                          v186 = v159;
                          v189 = v160;
                          [MEMORY[0x189603F68] dictionaryWithObjects:&v188 forKeys:&v184 count:3];
                          v120 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
                          uint64_t result = 0LL;
                          v121 = SecItemCopyMatching(v120, &result);
                          v122 = (void *)result;
                          if (v121)
                          {
                            ne_log_obj();
                            v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
                            {
                              *(_WORD *)v175 = 0;
                              _os_log_fault_impl( &dword_1876B1000,  v123,  OS_LOG_TYPE_FAULT,  "SecItemCopyMatching failed",  v175,  2u);
                            }

                            int v51 = 0LL;
                          }

                          else
                          {
                            int v51 = (id)result;
                          }
                        }

                        else
                        {
                          ne_log_obj();
                          v120 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v120, OS_LOG_TYPE_FAULT))
                          {
                            LODWORD(v18_Block_object_dispose((const void *)(v49 - 176), 8) = 136315138;
                            *(void *)((char *)&v188 + 4) = "+[NEIKEv2Crypto copyPersistentDataForIdentity:]";
                            _os_log_fault_impl( &dword_1876B1000,  v120,  OS_LOG_TYPE_FAULT,  "%s called with null identity",  (uint8_t *)&v188,  0xCu);
                          }

                          int v51 = 0LL;
                        }
                      }

                      else
                      {
                        int v51 = 0LL;
                      }

                      CFRelease(v119);
                    }

                    else
                    {
                      int v51 = 0LL;
                    }

                    if (v183[0]) {
                      CFRelease(v183[0]);
                    }
                    if (v51) {
                      goto LABEL_118;
                    }
                  }

                  ++v116;
                }

                while (v114 != v116);
                v124 = [v113 countByEnumeratingWithState:certificateRef objects:&buf count:16];
                v114 = v124;
              }

              while (v124);
            }

            int v51 = 0LL;
LABEL_118:

            if (v51)
            {

              goto LABEL_38;
            }

LABEL_107:
  v145 = MEMORY[0x1895F87A8];
  v229[0] = MEMORY[0x1895F87A8];
  v229[1] = 3221225472LL;
  v230 = __46__NEIKEv2Session_Exchange__receiveConnection___block_invoke_209;
  v231 = &unk_18A08D0C8;
  v146 = *(void **)(a1 + 32);
  v232 = *(void *)(a1 + 40);
  v147 = v232;
  v233 = v146;
  v234 = v3;
  v149 = v229;
  if (v147)
  {
    v150 = (dispatch_queue_s *)objc_getProperty((id)v147, v148, 368LL, 1);
    dispatch_assert_queue_V2(v150);

    WeakRetained = objc_loadWeakRetained((id *)(v147 + 344));
    v153 = -[NEIKEv2Session firstChildSA]((void *)v147, v152);
    if (v153 || !WeakRetained)
    {
      v168 = objc_getProperty((id)v147, v154, 336LL, 1);
      v170 = v168;
      if (v168 && (v168[23] & 1) != 0)
      {
        v172 = -[NEIKEv2Session firstChildSA]((void *)v147, v169);
        if (v172) {
          -[NEIKEv2Session removeFirstChild](v147, v171);
        }
      }

      else
      {
      }

      v155 = (os_log_s *)-[NEIKEv2Session setupReceivedChildCopyError]((void *)v147, v171);
      v230(v149, v155);
    }

    else if (*(_BYTE *)(v147 + 13))
    {
      ne_log_obj();
      v155 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v155, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(void *)&void buf[4] = v147;
        _os_log_fault_impl(&dword_1876B1000, v155, OS_LOG_TYPE_FAULT, "%@ already expecting config block", buf, 0xCu);
      }
    }

    else
    {
      *(_WORD *)(v147 + 13) = 257;
      v173 = (id *)objc_getProperty((id)v147, v154, 336LL, 1);
      v175 = v173;
      if (v173)
      {
        if (objc_getProperty(v173, v174, 88LL, 1))
        {
          v155 = (os_log_s *)objc_msgSend(objc_getProperty(v175, v176, 88, 1), "copy");
        }

        else
        {
          v155 = objc_alloc_init(&OBJC_CLASS___NEIKEv2SessionConfiguration);
          v177 = (void *)[v175[42] copy];
          -[os_log_s setLocalIdentifier:](v155, "setLocalIdentifier:", v177);

          v178 = (void *)[v175[43] copy];
          -[os_log_s setRemoteIdentifier:](v155, "setRemoteIdentifier:", v178);

          v179 = (void *)[v175[46] copy];
          -[os_log_s setRemoteAuthentication:](v155, "setRemoteAuthentication:", v179);

          v180 = (void *)[v175[49] copy];
          -[os_log_s setConfigurationRequest:](v155, "setConfigurationRequest:", v180);

          v181 = (void *)[v175[53] copy];
          -[os_log_s setPpkID:](v155, "setPpkID:", v181);

          -[os_log_s setPpkIDType:](v155, "setPpkIDType:", v175[52]);
        }
      }

      else
      {
        v155 = 0LL;
      }

      v183 = objc_getProperty((id)v147, v182, 336LL, 1);
      v185 = v183;
      if (v183 && (*((_BYTE *)v183 + 23) & 1) != 0)
      {
        v187 = 0LL;
      }

      else
      {
        v186 = objc_getProperty((id)v147, v184, 336LL, 1);
        if (v186)
        {
          v187 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ChildSAConfiguration);
          -[NEIKEv2ChildSAConfiguration setMode:](v187, "setMode:", v186[44]);
          v188 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithArray:v186[45] copyItems:1];
          -[NEIKEv2ChildSAConfiguration setProposals:](v187, "setProposals:", v188);

          if ((*((_BYTE *)v186 + 9) & 1) != 0)
          {
            ne_log_obj();
            v200 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v200, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl( &dword_1876B1000,  v200,  OS_LOG_TYPE_FAULT,  "copyChildConfig called on initiator",  buf,  2u);
            }

            v228 = 50LL;
            v189 = 51LL;
          }

          else
          {
            v228 = 51LL;
            v189 = 50LL;
          }

          v201 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithArray:v186[v189] copyItems:1];
          -[NEIKEv2ChildSAConfiguration setRemoteTrafficSelectors:](v187, "setRemoteTrafficSelectors:", v201);

          v202 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithArray:v186[v228] copyItems:1];
          -[NEIKEv2ChildSAConfiguration setLocalTrafficSelectors:](v187, "setLocalTrafficSelectors:", v202);
        }

        else
        {
          v187 = 0LL;
        }

        v145 = MEMORY[0x1895F87A8];
      }

      v204 = objc_getProperty((id)v147, v203, 336LL, 1);
      if (v204)
      {
        objc_initWeak(location, v204);
        *(void *)buf = v145;
        *(void *)&uint8_t buf[8] = 3221225472LL;
        *(void *)&buf[16] = __45__NEIKEv2IKESA_Crypto__copyValidateAuthBlock__block_invoke;
        v246 = &unk_18A08CDD0;
        objc_copyWeak(v248, location);
        v247 = (uint64_t)v204;
        v205 = _Block_copy(buf);
        objc_destroyWeak(v248);
        objc_destroyWeak(location);
      }

      else
      {
        v205 = 0LL;
      }

      *(void *)buf = v145;
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&buf[16] = __58__NEIKEv2Session_Exchange__setupReceivedChildWithHandler___block_invoke;
      v246 = &unk_18A08D078;
      v247 = v147;
      v248[0] = v149;
      [WeakRetained requestConfigurationForSession:v147 sessionConfig:v155 childConfig:v187 validateAuthBlock:v205 responseBlock:buf];
    }
  }

  ErrorPeerInvalidSyntax = 0LL;
LABEL_147:
}

  if (v78) {
    free(v78);
  }
  if (v77) {
    free(v77);
  }
  uint64_t v53 = v62[3];
  if (v53)
  {
    int v54 = _NEIPSecDBGetQueue();
    *(void *)buf = v5;
    *(void *)&uint8_t buf[8] = v6[214];
    *(void *)&buf[16] = __NEIPSecDBRemoveQueuedRequest_block_invoke;
    uint64_t v82 = &__block_descriptor_tmp_163;
    v83 = v53;
    dispatch_sync(v54, buf);
    free((void *)v62[3]);
  }

  int v16 = *((unsigned int *)v66 + 6);
  _Block_object_dispose(&v61, 8);
  _Block_object_dispose(&v65, 8);
  return v16;
}

LABEL_75:
        goto LABEL_76;
      }

      CFStringRef v11 = *(_BYTE *)(v8 + 18);

      if ((v11 & 1) == 0) {
        goto LABEL_8;
      }
    }

    else
    {
    }

          unint64_t v7 = v69;

          uint64_t v79 = 0;
          goto LABEL_68;
        }
      }

      uint64_t v63 = -[NEIKEv2ESPSPI initWithValue:]( [NEIKEv2ESPSPI alloc],  "initWithValue:",  [v61 spi]);
      if (v60) {
        objc_setProperty_atomic(v60, v62, v63, 80LL);
      }

      if (v57 != ++v59) {
        continue;
      }
      break;
    }

    unint64_t v57 = [v55 countByEnumeratingWithState:&v71 objects:v80 count:16];
    if (v57) {
      continue;
    }
    break;
  }

LABEL_76:
  free(v21);
LABEL_23:
  close(v4);
  ne_log_obj();
  unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    host_info_out[0] = 136315394;
    *(void *)&host_info_out[1] = "+[NEProcessInfo copyUUIDsFromExecutable:]";
    LOWORD(host_info_out[3]) = 2112;
    *(void *)((char *)&host_info_out[3] + 2) = v7;
    _os_log_debug_impl(&dword_1876B1000, v15, OS_LOG_TYPE_DEBUG, "%s: UUIDs %@", (uint8_t *)host_info_out, 0x16u);
  }

  return v7;
}

LABEL_264:
            goto LABEL_265;
          }
        }
      }

      else
      {
      }

LABEL_214:
      v332 = objc_getProperty(v37, v179, 88LL, 1);
      v333 = [v332 initialContactDisabled];

      if ((v333 & 1) != 0 || -[NEIKEv2Packet addNotification:data:](v43, 0x4000uLL, 0LL))
      {
        v335 = objc_getProperty(v37, v334, 88LL, 1);
        v336 = [v335 negotiateMOBIKE];

        if (!v336 || -[NEIKEv2Packet addNotification:data:](v43, 0x400CuLL, 0LL))
        {
          v504 = v36;
          v505 = a1;
          v525 = 0u;
          v526 = 0u;
          v523 = 0u;
          v524 = 0u;
          v338 = objc_getProperty(v37, v337, 88LL, 1);
          [v338 customIKEAuthPrivateNotifies];
          v339 = (void *)objc_claimAutoreleasedReturnValue();

          v340 = [v339 countByEnumeratingWithState:&v523 objects:buf count:16];
          if (v340)
          {
            v341 = v340;
            v342 = *(void *)v524;
            while (2)
            {
              v343 = 0LL;
              do
              {
                if (*(void *)v524 != v342) {
                  objc_enumerationMutation(v339);
                }
                v344 = *(void **)(*((void *)&v523 + 1) + 8 * v343);
                v345 = objc_alloc_init(&OBJC_CLASS___NEIKEv2NotifyPayload);
                v346 = [v344 notifyStatus];
                if (v345)
                {
                  v345->_notifyType = v346;
                  [v344 notifyData];
                  v347 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(v345, v348, v347, 32LL);
                }

                else
                {
                  [v344 notifyData];
                  v347 = (void *)objc_claimAutoreleasedReturnValue();
                }

                if (!-[NEIKEv2Packet addNotifyPayload:](v43, v345))
                {
                  ne_log_obj();
                  v388 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v388, OS_LOG_TYPE_FAULT))
                  {
                    *(_WORD *)v531 = 0;
                    _os_log_fault_impl( &dword_1876B1000,  v388,  OS_LOG_TYPE_FAULT,  "[packet addNotifyPayload:notifyPayload] failed",  v531,  2u);
                  }

                  v239 = 0LL;
                  goto LABEL_260;
                }

                ++v343;
              }

              while (v341 != v343);
              v349 = [v339 countByEnumeratingWithState:&v523 objects:buf count:16];
              v341 = v349;
              if (v349) {
                continue;
              }
              break;
            }
          }

          v521 = 0u;
          v522 = 0u;
          v519 = 0u;
          v520 = 0u;
          v351 = objc_getProperty(v37, v350, 88LL, 1);
          [v351 customIKEAuthVendorPayloads];
          v352 = (void *)objc_claimAutoreleasedReturnValue();

          obj = v352;
          v353 = [v352 countByEnumeratingWithState:&v519 objects:v531 count:16];
          if (v353)
          {
            v354 = v353;
            v355 = *(void *)v520;
            do
            {
              for (CFIndex i = 0LL; i != v354; ++i)
              {
                if (*(void *)v520 != v355) {
                  objc_enumerationMutation(obj);
                }
                v357 = *(void **)(*((void *)&v519 + 1) + 8 * i);
                v358 = objc_alloc_init(&OBJC_CLASS___NEIKEv2VendorIDPayload);
                [v357 vendorData];
                v360 = (void *)objc_claimAutoreleasedReturnValue();
                if (v358) {
                  objc_setProperty_atomic(v358, v359, v360, 24LL);
                }

                objc_getProperty(self, v361, 176LL, 1);
                v362 = (void *)objc_claimAutoreleasedReturnValue();

                if (v362)
                {
                  objc_getProperty(self, v363, 176LL, 1);
                  v364 = (void *)objc_claimAutoreleasedReturnValue();
                  [v364 arrayByAddingObject:v358];
                  v365 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(self, v366, v365, 176LL);
                }

                else
                {
                  v530 = v358;
                  [MEMORY[0x189603F18] arrayWithObjects:&v530 count:1];
                  v364 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(self, v367, v364, 176LL);
                }
              }

              v354 = [obj countByEnumeratingWithState:&v519 objects:v531 count:16];
            }

            while (v354);
          }

          v517 = 0u;
          v518 = 0u;
          v515 = 0u;
          v516 = 0u;
          v369 = objc_getProperty(v37, v368, 88LL, 1);
          [v369 customIKEAuthPayloads];
          v370 = (void *)objc_claimAutoreleasedReturnValue();

          v371 = [v370 countByEnumeratingWithState:&v515 objects:v529 count:16];
          if (v371)
          {
            v372 = v371;
            v373 = *(void *)v516;
            do
            {
              v374 = 0LL;
              do
              {
                if (*(void *)v516 != v373) {
                  objc_enumerationMutation(v370);
                }
                v375 = *(void **)(*((void *)&v515 + 1) + 8 * v374);
                v376 = objc_alloc_init(&OBJC_CLASS___NEIKEv2CustomPayload);
                v377 = [v375 customType];
                if (v376)
                {
                  v376->_customType = v377;
                  [v375 customData];
                  v378 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(v376, v379, v378, 32LL);
                }

                else
                {
                  [v375 customData];
                  v378 = (void *)objc_claimAutoreleasedReturnValue();
                }

                objc_getProperty(self, v380, 56LL, 1);
                v381 = (void *)objc_claimAutoreleasedReturnValue();

                if (v381)
                {
                  objc_getProperty(self, v382, 56LL, 1);
                  v383 = (void *)objc_claimAutoreleasedReturnValue();
                  [v383 arrayByAddingObject:v376];
                  v384 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(self, v385, v384, 56LL);
                }

                else
                {
                  v528 = v376;
                  [MEMORY[0x189603F18] arrayWithObjects:&v528 count:1];
                  v383 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(self, v386, v383, 56LL);
                }

                ++v374;
              }

              while (v372 != v374);
              v387 = [v370 countByEnumeratingWithState:&v515 objects:v529 count:16];
              v372 = v387;
            }

            while (v387);
          }

          char v43 = self;
          v239 = v43;
LABEL_260:
          __int128 v5 = v506;
          int v36 = v504;
          a1 = v505;
          goto LABEL_266;
        }

        ne_log_obj();
        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
          goto LABEL_264;
        }
        *(_WORD *)buf = 0;
        v98 = "[packet addNotification:NEIKEv2NotifyTypeMOBIKESupported] failed";
      }

      else
      {
        ne_log_obj();
        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
          goto LABEL_264;
        }
        *(_WORD *)buf = 0;
        v98 = "[packet addNotification:NEIKEv2NotifyTypeInitialContact] failed";
      }

      goto LABEL_334;
    }

    ne_log_obj();
    v267 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v267, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
      _os_log_fault_impl(&dword_1876B1000, v267, OS_LOG_TYPE_FAULT, "%s called with null packet.tsr.isValid", buf, 0xCu);
    }
  }

  else
  {
    ne_log_obj();
    v267 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v267, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
      _os_log_fault_impl(&dword_1876B1000, v267, OS_LOG_TYPE_FAULT, "%s called with null packet.tsi.isValid", buf, 0xCu);
    }
  }

  v239 = 0LL;
LABEL_266:

  ne_log_obj();
  v389 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  v390 = v389;
  if (v239)
  {
    if (os_log_type_enabled(v389, OS_LOG_TYPE_DEFAULT))
    {
      v391 = *(const char **)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      v533 = v391;
      _os_log_impl(&dword_1876B1000, v390, OS_LOG_TYPE_DEFAULT, "%@ Sending AUTH reply", buf, 0xCu);
    }

    if ((-[NEIKEv2Session sendReply:replyHandler:](*(void *)(a1 + 40), v239, 0LL) & 1) != 0)
    {
      v393 = *(void *)(a1 + 56);
      if (v393 && (-[NEIKEv2ChildSA generateAllValues](v393) & 1) == 0)
      {
        ne_log_obj();
        v456 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v456, OS_LOG_TYPE_ERROR))
        {
          v483 = *(const char **)(a1 + 40);
          *(_DWORD *)buf = 138412290;
          v533 = v483;
          _os_log_error_impl( &dword_1876B1000,  v456,  OS_LOG_TYPE_ERROR,  "%@ Failed to generate Child SA crypto values (receive)",  buf,  0xCu);
        }

        v458 = *(id *)(a1 + 40);
        if (v458) {
          v458 = objc_getProperty(v458, v457, 336LL, 1);
        }
        v447 = v458;
        v455 = (void *)NEIKEv2CreateErrorCrypto( @"Failed to generate Child SA crypto values (receive)",  v459,  v460,  v461,  v462,  v463,  v464,  v465,  v502);
      }

      else
      {
        -[NEIKEv2Session finishConfigurationEstablishment](*(_BYTE **)(a1 + 40), v392);
        -[NEIKEv2Session reportConfiguration](*(void **)(a1 + 40), v394);
        -[NEIKEv2IKESA clearAuthenticationSecrets](*(void **)(a1 + 32), v395);
        v396 = *(void **)(a1 + 56);
        if (!v396 || (-[NEIKEv2Session installChildSA:](*(void *)(a1 + 40), v396) & 1) != 0)
        {
          ne_log_obj();
          v397 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v397, OS_LOG_TYPE_DEFAULT))
          {
            v398 = *(const char **)(a1 + 40);
            v399 = *(void *)(a1 + 56);
            *(_DWORD *)buf = 138412546;
            v533 = v398;
            v534 = 2112;
            v535 = v399;
            _os_log_impl(&dword_1876B1000, v397, OS_LOG_TYPE_DEFAULT, "%@ Installed Child SA %@", buf, 0x16u);
          }

          v400 = *(void *)(a1 + 40);
          if (v400)
          {
            WeakRetained = objc_loadWeakRetained((id *)(v400 + 352));

            if (WeakRetained)
            {
              v513 = 0u;
              v514 = 0u;
              v511 = 0u;
              v512 = 0u;
              v403 = *(void **)(a1 + 40);
              if (v403)
              {
                v404 = objc_getProperty(v403, v402, 336LL, 1);
                v406 = v404;
                v407 = a1;
                if (v404) {
                  v404 = objc_getProperty(v404, v405, 88LL, 1);
                }
              }

              else
              {
                v407 = a1;
                v406 = 0LL;
                v404 = 0LL;
              }

              v408 = v404;
              [v408 configurationReply];
              v409 = (void *)objc_claimAutoreleasedReturnValue();
              v411 = v409;
              if (v409) {
                v409 = objc_getProperty(v409, v410, 16LL, 1);
              }
              v412 = v409;

              v413 = [v412 countByEnumeratingWithState:&v511 objects:v527 count:16];
              if (!v413)
              {

                a1 = v407;
                goto LABEL_326;
              }

              v414 = v413;
              selfa = v239;
              v415 = 0;
              v416 = *(void *)v512;
              while (1)
              {
                v417 = 0LL;
                do
                {
                  if (*(void *)v512 != v416) {
                    objc_enumerationMutation(v412);
                  }
                  v418 = *(void **)(*((void *)&v511 + 1) + 8 * v417);
                  objc_opt_class();
                  if ((objc_opt_isKindOfClass() & 1) != 0)
                  {
                    [v418 address];
                    v420 = (void *)objc_claimAutoreleasedReturnValue();
                    v421 = *(void **)(v407 + 40);
                    if (!v421) {
                      goto LABEL_300;
                    }
                    v422 = objc_getProperty(v421, v419, 336LL, 1);
                    v424 = v422;
                    if (v422)
                    {
                      v425 = v420;
                      v426 = 72LL;
LABEL_296:
                      objc_setProperty_atomic(v422, v423, v425, v426);
                    }
                  }

                  else
                  {
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) == 0) {
                      goto LABEL_298;
                    }
                    [v418 address];
                    v420 = (void *)objc_claimAutoreleasedReturnValue();
                    v428 = *(void **)(v407 + 40);
                    if (!v428)
                    {
LABEL_300:
                      v424 = 0LL;
                      goto LABEL_297;
                    }

                    v422 = objc_getProperty(v428, v427, 336LL, 1);
                    v424 = v422;
                    if (v422)
                    {
                      v425 = v420;
                      v426 = 64LL;
                      goto LABEL_296;
                    }
                  }

LABEL_297:
                  v415 = 1;
LABEL_298:
                  ++v417;
                }

                while (v414 != v417);
                v429 = [v412 countByEnumeratingWithState:&v511 objects:v527 count:16];
                v414 = v429;
                if (!v429)
                {

                  a1 = v407;
                  v239 = selfa;
                  if ((v415 & 1) != 0)
                  {
                    ne_log_obj();
                    v430 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v430, OS_LOG_TYPE_DEFAULT))
                    {
                      v431 = *(const char **)(v407 + 40);
                      *(_DWORD *)buf = 138412290;
                      v533 = v431;
                      _os_log_impl( &dword_1876B1000,  v430,  OS_LOG_TYPE_DEFAULT,  "%@ Changing addresses and migrating (receive)",  buf,  0xCu);
                    }

                    -[NEIKEv2Session migrateAllChildSAs](*(void *)(v407 + 40), v432);
                  }

                  break;
                }
              }
            }
          }

LABEL_326:
          ne_log_obj();
          v479 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v479, OS_LOG_TYPE_DEFAULT))
          {
            v480 = *(const char **)(a1 + 40);
            *(_DWORD *)buf = 138412290;
            v533 = v480;
            _os_log_impl(&dword_1876B1000, v479, OS_LOG_TYPE_DEFAULT, "%@ Completed connection (receive)", buf, 0xCu);
          }

          -[NEIKEv2IKESA setState:error:](*(void *)(a1 + 32), 2uLL, 0LL);
          v481 = *(void **)(a1 + 56);
          if (v481)
          {
            -[NEIKEv2Session reportTrafficSelectorsForChildSA:](*(void **)(a1 + 40), v481);
            -[NEIKEv2ChildSA setState:error:](*(void *)(a1 + 56), 2uLL, 0LL);
          }

          -[NEIKEv2Session reportState](*(void **)(a1 + 40), (const char *)v481);
          goto LABEL_331;
        }

        ne_log_obj();
        v466 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v466, OS_LOG_TYPE_ERROR))
        {
          v484 = *(const char **)(a1 + 40);
          *(_DWORD *)buf = 138412290;
          v533 = v484;
          _os_log_error_impl( &dword_1876B1000,  v466,  OS_LOG_TYPE_ERROR,  "%@ Failed to install Child SA (receive)",  buf,  0xCu);
        }

        v468 = *(id *)(a1 + 40);
        if (v468) {
          v468 = objc_getProperty(v468, v467, 336LL, 1);
        }
        v447 = v468;
        v455 = (void *)NEIKEv2CreateErrorInternal( @"Failed to install Child SA (receive)",  v469,  v470,  v471,  v472,  v473,  v474,  v475,  v502);
      }
    }

    else
    {
      v446 = *(id *)(a1 + 40);
      if (v446) {
        v446 = objc_getProperty(v446, v392, 336LL, 1);
      }
      v447 = v446;
      v455 = (void *)NEIKEv2CreateErrorFailedToSend( @"responder AUTH",  v448,  v449,  v450,  v451,  v452,  v453,  v454,  v502);
    }

    v476 = v455;
    -[NEIKEv2IKESA setState:error:]((uint64_t)v447, 3uLL, v455);

    -[NEIKEv2Session reportState](*(void **)(a1 + 40), v477);
    -[NEIKEv2Session resetAll](*(void *)(a1 + 40), v478);
LABEL_331:
    ErrorAuthentication = 0LL;
    goto LABEL_332;
  }

  if (os_log_type_enabled(v389, OS_LOG_TYPE_ERROR))
  {
    v482 = *(const char **)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    v533 = v482;
    _os_log_error_impl( &dword_1876B1000,  v390,  OS_LOG_TYPE_ERROR,  "%@ Failed to create IKE AUTH packet (receive)",  buf,  0xCu);
  }

  v434 = *(id *)(a1 + 40);
  if (v434) {
    v434 = objc_getProperty(v434, v433, 336LL, 1);
  }
  v435 = v434;
  v443 = (void *)NEIKEv2CreateErrorInternal( @"Failed to create IKE AUTH packet (receive)",  v436,  v437,  v438,  v439,  v440,  v441,  v442,  v502);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v435, 3uLL, v443);

  -[NEIKEv2Session reportState](*(void **)(a1 + 40), v444);
  -[NEIKEv2Session resetAll](*(void *)(a1 + 40), v445);
  ErrorAuthentication = 0LL;
  v239 = 0LL;
LABEL_332:
}

LABEL_148:
                      goto LABEL_77;
                    }

                    int v88 = self;
                    v193 = (id)v73;
                    if (self) {
                      int v88 = objc_getProperty(self, v74, 96LL, 1);
                    }
                    uint64_t v89 = v88;
                    -[NEIKEv2IKESAProposal prfProtocol](v89, v90);
                    unint64_t v91 = (void *)objc_claimAutoreleasedReturnValue();
                    v92 = [v91 nonceSize];

                    if ((unint64_t)v193 < v92)
                    {
                      ne_log_obj();
                      id v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_148;
                      }
                      v94 = (void *)[v3 copyShortDescription];
                      if (self) {
                        v95 = objc_getProperty(self, v93, 96LL, 1);
                      }
                      else {
                        v95 = 0LL;
                      }
                      v96 = v95;
                      v98 = -[NEIKEv2IKESAProposal prfProtocol](v96, v97);
                      *(_DWORD *)buf = 138413058;
                      v210 = v6;
                      v211 = 2112;
                      v212 = (uint64_t)v94;
                      v213 = 2048;
                      v214 = (uint64_t)v193;
                      v215 = 2112;
                      v216 = (uint64_t)v98;
                      _os_log_error_impl( &dword_1876B1000,  v75,  OS_LOG_TYPE_ERROR,  "%@ %@ NONCE data length %zu is shorter than the minimum for PRF protocol %@",  buf,  0x2Au);

LABEL_147:
                      goto LABEL_148;
                    }
                  }

                  objc_getProperty(v3, v68, 112LL, 1);
                  v99 = (void *)objc_claimAutoreleasedReturnValue();
                  v101 = v99;
                  if (v99) {
                    v99 = objc_getProperty(v99, v100, 24LL, 1);
                  }
                  v102 = v99;
                  objc_setProperty_atomic(v6, v103, v102, 88LL);

                  if (-[NEIKEv2ChildSA shouldGenerateNewDHKeys](v6, v104))
                  {
                    objc_getProperty(v3, v105, 104LL, 1);
                    v106 = (void *)objc_claimAutoreleasedReturnValue();

                    if (!v106)
                    {
                      ne_log_obj();
                      id v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_148;
                      }
                      uint64_t v76 = (void *)[v3 copyShortDescription];
                      *(_DWORD *)buf = 138412546;
                      v210 = v6;
                      v211 = 2112;
                      v212 = (uint64_t)v76;
                      unint64_t v77 = "%@ %@ Did not receive KE payload";
                      goto LABEL_141;
                    }

                    objc_getProperty(v3, v107, 104LL, 1);
                    v108 = (void *)objc_claimAutoreleasedReturnValue();
                    v110 = v108;
                    if (v108) {
                      v108 = objc_getProperty(v108, v109, 24LL, 1);
                    }
                    v111 = v108;

                    if (!v111)
                    {
                      ne_log_obj();
                      id v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_148;
                      }
                      uint64_t v76 = (void *)[v3 copyShortDescription];
                      *(_DWORD *)buf = 138412546;
                      v210 = v6;
                      v211 = 2112;
                      v212 = (uint64_t)v76;
                      unint64_t v77 = "%@ %@ Did not receive method in KE payload";
                      goto LABEL_141;
                    }

                    objc_getProperty(v3, v112, 104LL, 1);
                    v113 = (void *)objc_claimAutoreleasedReturnValue();
                    v115 = v113;
                    if (v113) {
                      v113 = objc_getProperty(v113, v114, 32LL, 1);
                    }
                    v116 = v113;

                    if (!v116)
                    {
                      ne_log_obj();
                      id v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_148;
                      }
                      uint64_t v76 = (void *)[v3 copyShortDescription];
                      *(_DWORD *)buf = 138412546;
                      v210 = v6;
                      v211 = 2112;
                      v212 = (uint64_t)v76;
                      unint64_t v77 = "%@ %@ Did not receive data in KE payload";
                      goto LABEL_141;
                    }

                    objc_getProperty(v3, v117, 104LL, 1);
                    v118 = (void *)objc_claimAutoreleasedReturnValue();
                    if (v118)
                    {
                      v120 = v118;
                      v118 = objc_getProperty(v118, v119, 24LL, 1);
                    }

                    else
                    {
                      v120 = 0LL;
                    }

                    v191 = v118;
                    v194 = (id)[v191 method];
                    v122 = objc_getProperty(v6, v121, 56LL, 1);
                    v124 = -[NEIKEv2IKESAProposal kemProtocol](v122, v123);
                    v125 = [v124 method];

                    if (v194 != (id)v125)
                    {
                      ne_log_obj();
                      id v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_148;
                      }
                      v192 = [v3 copyShortDescription];
                      objc_getProperty(v3, v163, 104LL, 1);
                      v164 = (void *)objc_claimAutoreleasedReturnValue();
                      v195 = v164;
                      if (v164) {
                        v164 = objc_getProperty(v164, v165, 24LL, 1);
                      }
                      v190 = v164;
                      v189 = [v190 method];
                      v167 = objc_getProperty(v6, v166, 56LL, 1);
                      v169 = -[NEIKEv2IKESAProposal kemProtocol](v167, v168);
                      v170 = [v169 method];
                      *(_DWORD *)buf = 138413058;
                      v210 = v6;
                      v211 = 2112;
                      v94 = (void *)v192;
                      v212 = v192;
                      v213 = 2048;
                      v214 = v189;
                      v215 = 2048;
                      v216 = v170;
                      _os_log_error_impl( &dword_1876B1000,  v75,  OS_LOG_TYPE_ERROR,  "%@ %@ Did not receive matching method from KE payload (%zu != %zu)",  buf,  0x2Au);

                      goto LABEL_147;
                    }

                    objc_getProperty(v3, v126, 104LL, 1);
                    v127 = (void *)objc_claimAutoreleasedReturnValue();
                    v129 = v127;
                    if (v127) {
                      v127 = objc_getProperty(v127, v128, 32LL, 1);
                    }
                    v130 = v127;
                    objc_setProperty_atomic(v6, v131, v130, 104LL);
                  }

                  objc_getProperty(v3, v105, 128LL, 1);
                  v132 = (void *)objc_claimAutoreleasedReturnValue();
                  v134 = v132;
                  if (v132) {
                    v132 = objc_getProperty(v132, v133, 24LL, 1);
                  }
                  v135 = v132;
                  -[NEIKEv2ChildSA setInitiatorTrafficSelectors:](v6, v135);
                  v137 = -[NEIKEv2ChildSA initiatorTrafficSelectors](v6, v136);
                  if (v137)
                  {
                    objc_getProperty(v3, v138, 136LL, 1);
                    v139 = (void *)objc_claimAutoreleasedReturnValue();
                    v141 = v139;
                    if (v139) {
                      v139 = objc_getProperty(v139, v140, 24LL, 1);
                    }
                    v142 = v139;
                    -[NEIKEv2ChildSA setResponderTrafficSelectors:](v6, v142);
                    v144 = -[NEIKEv2ChildSA responderTrafficSelectors](v6, v143);
                    if (v144)
                    {

                      v146 = a1[6];
                      if (v146)
                      {
                        v147 = objc_getProperty(v146, v145, 56LL, 1);
                        v149 = v147;
                        if (v147) {
                          v147 = objc_getProperty(v147, v148, 112LL, 1);
                        }
                      }

                      else
                      {
                        v149 = 0LL;
                        v147 = 0LL;
                      }

                      v150 = v147;

                      if (v150 && (-[NEIKEv2ChildSA processPrimaryKeyExchange]((uint64_t)a1[6], v151) & 1) == 0)
                      {
                        ne_log_obj();
                        v188 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)v218 = 0;
                          _os_log_error_impl( &dword_1876B1000,  v188,  OS_LOG_TYPE_ERROR,  "Failed to process KE data",  v218,  2u);
                        }

                        [a1[4] sendCallbackSuccess:0 session:a1[5]];
                        int v26 = (uint64_t)a1[6];
                        v162 = @"Failed to process KE data";
                      }

                      else
                      {
                        if ((-[NEIKEv2ChildSA generateAllValues]((uint64_t)a1[6]) & 1) != 0)
                        {
                          if ((-[NEIKEv2Session installChildSA:]((uint64_t)a1[5], a1[6]) & 1) != 0)
                          {
                            -[NEIKEv2Session reportTrafficSelectorsForChildSA:](a1[5], a1[6]);
                            ne_log_obj();
                            v152 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v152, OS_LOG_TYPE_INFO))
                            {
                              *(_WORD *)v218 = 0;
                              _os_log_impl( &dword_1876B1000,  v152,  OS_LOG_TYPE_INFO,  "Completed new child SA connection",  v218,  2u);
                            }

                            -[NEIKEv2ChildSA setState:error:]((uint64_t)a1[6], 2uLL, 0LL);
                            -[NEIKEv2Session reportState](a1[5], v153);
                            [a1[4] sendCallbackSuccess:1 session:a1[5]];
                          }

                          else
                          {
                            ne_log_obj();
                            v171 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
                            {
                              *(_WORD *)v218 = 0;
                              _os_log_error_impl( &dword_1876B1000,  v171,  OS_LOG_TYPE_ERROR,  "Failed to install Child SA",  v218,  2u);
                            }

                            v174 = a1[5];
                            v173 = a1[6];
                            if (v173)
                            {
                              v175 = objc_getProperty(v173, v172, 56LL, 1);
                              v177 = v175;
                              if (v175) {
                                v175 = objc_getProperty(v175, v176, 80LL, 1);
                              }
                            }

                            else
                            {
                              v177 = 0LL;
                              v175 = 0LL;
                            }

                            v179 = v175;
                            v180 = a1[6];
                            if (v180)
                            {
                              v181 = objc_getProperty(v180, v178, 56LL, 1);
                              v183 = v181;
                              if (v181) {
                                v181 = objc_getProperty(v181, v182, 88LL, 1);
                              }
                            }

                            else
                            {
                              v183 = 0LL;
                              v181 = 0LL;
                            }

                            v184 = v181;
                            v197[0] = MEMORY[0x1895F87A8];
                            v197[1] = 3221225472LL;
                            v197[2] = __47__NEIKEv2Session_Exchange__initiateNewChildSA___block_invoke_241;
                            v197[3] = &unk_18A08D118;
                            v185 = a1[4];
                            v186 = a1[5];
                            v187 = a1[6];
                            v198 = v185;
                            v199 = v186;
                            v200 = v187;
                            -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:]( v174,  v179,  v184,  v197);
                          }

                          goto LABEL_85;
                        }

                        ne_log_obj();
                        v154 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)v218 = 0;
                          _os_log_error_impl( &dword_1876B1000,  v154,  OS_LOG_TYPE_ERROR,  "Failed to generate Child SA crypto values",  v218,  2u);
                        }

                        [a1[4] sendCallbackSuccess:0 session:a1[5]];
                        int v26 = (uint64_t)a1[6];
                        v162 = @"Failed to generate Child SA crypto values";
                      }

                      ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto( v162,  v155,  v156,  v157,  v158,  v159,  v160,  v161,  v189);
                      goto LABEL_84;
                    }

                    ne_log_obj();
                    id v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_148;
                    }
                    uint64_t v76 = (void *)[v3 copyShortDescription];
                    *(_DWORD *)buf = 138412546;
                    v210 = v6;
                    v211 = 2112;
                    v212 = (uint64_t)v76;
                    unint64_t v77 = "%@ %@ Could not set responder traffic selectors";
                  }

                  else
                  {
                    ne_log_obj();
                    id v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_148;
                    }
                    uint64_t v76 = (void *)[v3 copyShortDescription];
                    *(_DWORD *)buf = 138412546;
                    v210 = v6;
                    v211 = 2112;
                    v212 = (uint64_t)v76;
                    unint64_t v77 = "%@ %@ Could not set initiator traffic selectors";
                  }

                          if (!v73) {
                            goto LABEL_150;
                          }
LABEL_149:
                          CFRelease(v73);
                          goto LABEL_150;
                        }

                        v114 = +[NEPolicyCondition flowLocalAddressStart:end:]( &OBJC_CLASS___NEPolicyCondition,  "flowLocalAddressStart:end:",  v106,  v107);
                      }

                      else
                      {
                        if (v61 != 12)
                        {
                          int v54 = a3;
                          if (v61 == 14)
                          {
                            v108 = +[NEPolicyCondition remoteAddressStart:end:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddressStart:end:",  v106,  v107);
                            goto LABEL_147;
                          }

                          goto LABEL_148;
                        }

                        v114 = +[NEPolicyCondition localAddressStart:end:]( &OBJC_CLASS___NEPolicyCondition,  "localAddressStart:end:",  v106,  v107);
                      }

                      int v62 = (void *)v114;
                      int v54 = a3;
                      if (v73) {
                        goto LABEL_149;
                      }
LABEL_150:
                      if (v74) {
                        CFRelease(v74);
                      }

                      uint64_t v8 = v124;
                      if (v62)
                      {
LABEL_192:
                        v119 = (const __CFBoolean *)CFDictionaryGetValue(v59, @"IsNegative");
                        if (v119 && CFBooleanGetValue(v119)) {
                          [v62 setNegative:1];
                        }
                        v120 = (const __CFBoolean *)CFDictionaryGetValue(v59, @"ExactMatch");
                        if (v120 && CFBooleanGetValue(v120)) {
                          [v62 setExactMatch:1];
                        }
                        [v8 addObject:v62];
                      }

                      break;
                    case 0xFu:
                      uint64_t v82 = +[NEPolicyCondition entitlement](&OBJC_CLASS___NEPolicyCondition, "entitlement");
                      goto LABEL_191;
                    case 0x10u:
                      uint64_t v89 = CFDictionaryGetValue(v59, @"NetAgentDomain");
                      CFErrorRef v90 = CFDictionaryGetValue(v59, @"NetAgentType");
                      if (!v89 || !v90) {
                        break;
                      }
                      uint64_t v82 = +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  v89,  v90);
                      goto LABEL_191;
                    case 0x11u:
                      uint64_t v82 = +[NEPolicyCondition usesModernNetworkAPI](&OBJC_CLASS___NEPolicyCondition, "usesModernNetworkAPI");
                      goto LABEL_191;
                    case 0x18u:
                      unint64_t v91 = NEGetIntFromDictionary(v59, @"ClientFlags", 0LL);
                      if (!v91) {
                        break;
                      }
                      uint64_t v82 = +[NEPolicyCondition clientFlags:]( &OBJC_CLASS___NEPolicyCondition,  "clientFlags:",  (unsigned __int16)v91);
                      goto LABEL_191;
                    case 0x19u:
                      uint64_t v82 = +[NEPolicyCondition flowLocalAddressEmpty]( &OBJC_CLASS___NEPolicyCondition,  "flowLocalAddressEmpty");
                      goto LABEL_191;
                    case 0x1Au:
                      uint64_t v82 = +[NEPolicyCondition flowRemoteAddressEmpty]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddressEmpty");
                      goto LABEL_191;
                    case 0x1Bu:
                      uint64_t v82 = +[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary");
                      goto LABEL_191;
                    case 0x1Cu:
                      v92 = (const __CFNumber *)CFDictionaryGetValue(v59, @"Platform");
                      if (v92 && (v93 = v92, v94 = CFNUMBER_TYPE, CFGetTypeID(v92) == v94))
                      {
                        HIDWORD(valuePtr) = 0;
                        else {
                          v95 = 0LL;
                        }
                      }

                      else
                      {
                        v95 = 0LL;
                      }

                      v109 = (const __CFNumber *)CFDictionaryGetValue(v59, @"SDKVersion");
                      v110 = v109;
                      if (v109)
                      {
                        v111 = CFNUMBER_TYPE;
                        if (CFGetTypeID(v109) == v111)
                        {
                          HIDWORD(valuePtr) = 0;
                          else {
                            v110 = 0LL;
                          }
                        }

                        else
                        {
                          v110 = 0LL;
                        }
                      }

                      v115 = (const __CFNumber *)CFDictionaryGetValue(v59, @"MinSDKVersion");
                      if (v115 && (v116 = v115, v117 = CFNUMBER_TYPE, CFGetTypeID(v115) == v117))
                      {
                        HIDWORD(valuePtr) = 0;
                        else {
                          v118 = 0LL;
                        }
                      }

                      else
                      {
                        v118 = 0LL;
                      }

                      int v54 = a3;
                      uint64_t v82 = +[NEPolicyCondition sdkVersion:minSDKVersion:platform:]( &OBJC_CLASS___NEPolicyCondition,  "sdkVersion:minSDKVersion:platform:",  v110,  v118,  v95);
                      goto LABEL_191;
                    case 0x1Du:
                      v96 = CFDictionaryGetValue(v59, @"SigningIdentifier");
                      if (!v96) {
                        break;
                      }
                      uint64_t v82 = +[NEPolicyCondition signingIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "signingIdentifier:",  v96);
                      goto LABEL_191;
                    case 0x1Eu:
                      v97 = NEGetIntFromDictionary(v59, @"PacketFilterTags", 0LL);
                      if (!v97) {
                        break;
                      }
                      uint64_t v82 = +[NEPolicyCondition packetFilterTags:](&OBJC_CLASS___NEPolicyCondition, "packetFilterTags:", v97);
                      goto LABEL_191;
                    case 0x25u:
                      v98 = NEGetIntFromDictionary(v59, @"Port", 0LL);
                      if (!v98) {
                        break;
                      }
                      uint64_t v82 = +[NEPolicyCondition schemeUsingPort:](&OBJC_CLASS___NEPolicyCondition, "schemeUsingPort:", v98);
                      goto LABEL_191;
                    case 0x27u:
                      uint64_t v82 = +[NEPolicyCondition hasSignedResult](&OBJC_CLASS___NEPolicyCondition, "hasSignedResult");
                      goto LABEL_191;
                    case 0x28u:
                      HIDWORD(valuePtr) = 0;
                      v99 = (const __CFNumber *)CFDictionaryGetValue(v59, @"UID");
                      uint64_t v82 = +[NEPolicyCondition realUID:](&OBJC_CLASS___NEPolicyCondition, "realUID:", HIDWORD(valuePtr));
                      goto LABEL_191;
                    case 0x2Au:
                      v100 = CFDictionaryGetValue(v59, @"URL");
                      if (!v100) {
                        break;
                      }
                      uint64_t v82 = +[NEPolicyCondition url:](&OBJC_CLASS___NEPolicyCondition, "url:", v100);
                      goto LABEL_191;
                    case 0x2Bu:
                      valuePtr = 0LL;
                      v134 = 0;
                      v101 = (const __CFNumber *)CFDictionaryGetValue(v59, @"InterfaceFlags");
                      v102 = (const __CFNumber *)CFDictionaryGetValue(v59, @"InterfaceEflags");
                      v103 = (const __CFNumber *)CFDictionaryGetValue(v59, @"InterfaceXflags");
                      if (v101) {
                        CFNumberGetValue(v101, kCFNumberSInt32Type, (char *)&valuePtr + 4);
                      }
                      if (v102) {
                        CFNumberGetValue(v102, kCFNumberSInt32Type, &valuePtr);
                      }
                      if (v103)
                      {
                        CFNumberGetValue(v103, kCFNumberSInt32Type, &v134);
                      }

                      else if (!((unint64_t)v101 | (unint64_t)v102))
                      {
LABEL_180:
                        int v62 = 0LL;
LABEL_181:
                        if (v62) {
                          goto LABEL_192;
                        }
                        break;
                      }

                      uint64_t v82 = +[NEPolicyCondition scopedInterfaceFlags:eflags:xflags:]( &OBJC_CLASS___NEPolicyCondition,  "scopedInterfaceFlags:eflags:xflags:",  HIDWORD(valuePtr),  valuePtr,  v134);
LABEL_191:
                      int v62 = (void *)v82;
                      if (!v82) {
                        break;
                      }
                      goto LABEL_192;
                    default:
                      break;
                  }
                }

                ++v57;
              }

              while (v56 != v57);
            }

            v121 = -[NEPolicy initWithOrder:result:conditions:]( objc_alloc(&OBJC_CLASS___NEPolicy),  "initWithOrder:result:conditions:",  v128,  alloca,  v8);
            int v4 = [v130 addPolicy:v121 storeLocally:1];
          }
        }

        else
        {
LABEL_201:
          int v4 = 0LL;
        }

LABEL_79:
LABEL_80:
  ne_log_obj();
  uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v218 = 0;
    _os_log_error_impl(&dword_1876B1000, v84, OS_LOG_TYPE_ERROR, "Failed to process Create Child SA packet", v218, 2u);
  }

  [a1[4] sendCallbackSuccess:0 session:a1[5]];
  int v26 = (uint64_t)a1[6];
  id v27 = @"Failed to process Create Child SA packet";
LABEL_83:
  ErrorCrypto = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v27, v19, v20, v21, v22, v23, v24, v25, v189);
LABEL_84:
  int v86 = ErrorCrypto;
  -[NEIKEv2ChildSA setState:error:](v26, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](a1[5], v87);
  -[NEIKEv2Session resetChild:]((char *)a1[5], a1[6]);
LABEL_85:
}

LABEL_176:
                        v278 = v276;
                        v279 = 12;
                        goto LABEL_177;
                      }

                      ne_log_obj();
                      v276 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v276, OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)v385 = 0;
                        v277 = "[packet addNotification:NEIKEv2NotifyTypeUseTransportMode] failed";
                        v278 = v276;
                        v279 = 2;
LABEL_177:
                        _os_log_fault_impl(&dword_1876B1000, v278, OS_LOG_TYPE_FAULT, v277, v385, v279);
                        goto LABEL_178;
                      }

                      goto LABEL_178;
                    }

                    ne_log_obj();
                    v274 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v274, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)v385 = 0;
                      _os_log_fault_impl( &dword_1876B1000,  v274,  OS_LOG_TYPE_FAULT,  "[[NEIKEv2CreateChildPacket alloc] initResponse:] failed",  v385,  2u);
                    }

                    v200 = 0LL;
                  }

                  else
                  {
                    ne_log_obj();
                    v200 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v200, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)v385 = 136315138;
                      v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                      _os_log_fault_impl( &dword_1876B1000,  v200,  OS_LOG_TYPE_FAULT,  "%s called with null childSA.chosenProposal",  v385,  0xCu);
                    }
                  }

                  v271 = 0LL;
                  goto LABEL_180;
                }

                objc_getProperty(self, v149, 104LL, 1);
                v150 = (void *)objc_claimAutoreleasedReturnValue();

                if (v150)
                {
                  objc_getProperty(self, v151, 104LL, 1);
                  v152 = (void *)objc_claimAutoreleasedReturnValue();
                  v154 = v152;
                  if (v152) {
                    v152 = objc_getProperty(v152, v153, 24LL, 1);
                  }
                  v155 = v152;

                  if (v155)
                  {
                    objc_getProperty(self, v156, 104LL, 1);
                    v157 = (void *)objc_claimAutoreleasedReturnValue();
                    v159 = v157;
                    if (v157) {
                      v157 = objc_getProperty(v157, v158, 32LL, 1);
                    }
                    v160 = v157;

                    if (v160)
                    {
                      objc_getProperty(self, v161, 104LL, 1);
                      v162 = (void *)objc_claimAutoreleasedReturnValue();
                      v164 = v162;
                      v362 = v11;
                      if (v162) {
                        v162 = objc_getProperty(v162, v163, 24LL, 1);
                      }
                      v165 = v162;
                      v358 = [v165 method];
                      v167 = objc_getProperty(v16, v166, 56LL, 1);
                      v169 = -[NEIKEv2IKESAProposal kemProtocol](v167, v168);
                      v170 = [v169 method];

                      if (v358 == v170)
                      {
                        objc_getProperty(self, v171, 104LL, 1);
                        v172 = (void *)objc_claimAutoreleasedReturnValue();
                        v174 = v172;
                        CFStringRef v11 = v362;
                        if (v172) {
                          v172 = objc_getProperty(v172, v173, 32LL, 1);
                        }
                        v175 = v172;
                        objc_setProperty_atomic(v16, v176, v175, 104LL);

                        goto LABEL_115;
                      }

                      ne_log_obj();
                      uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      CFStringRef v11 = v362;
                      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                      {
                        v336 = (void *)[self copyShortDescription];
                        objc_getProperty(self, v337, 104LL, 1);
                        v338 = (void *)objc_claimAutoreleasedReturnValue();
                        v340 = v338;
                        if (v338) {
                          v338 = objc_getProperty(v338, v339, 24LL, 1);
                        }
                        v341 = v338;
                        v358 = [v341 method];
                        v343 = objc_getProperty(v16, v342, 56LL, 1);
                        v345 = -[NEIKEv2IKESAProposal kemProtocol](v343, v344);
                        v346 = [v345 method];
                        *(_DWORD *)buf = 138413058;
                        v378 = v16;
                        v379 = 2112;
                        v380 = v336;
                        v381 = 2048;
                        v382 = v358;
                        v383 = 2048;
                        v384 = v346;
                        _os_log_error_impl( &dword_1876B1000,  v69,  OS_LOG_TYPE_ERROR,  "%@ %@ Did not receive matching method from KE payload (%zu != %zu)",  buf,  0x2Au);

                        CFStringRef v11 = v362;
                      }

                  free(v61);
                  goto LABEL_177;
                }

                uint64_t v67 = (os_log_s *)ne_log_obj();
                if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl(&dword_1876B1000, v67, OS_LOG_TYPE_ERROR, "pfkey send add policy failed", buf, 2u);
                }

                uint64_t v68 = *((_DWORD *)v85 + 6);
                uint64_t v69 = _NEIPSecDBGetQueue();
                *(void *)buf = v55;
                *(void *)&uint8_t buf[8] = 0x40000000LL;
                *(void *)&buf[16] = __NEIPSecDBRemovePolicyIDFromSAs_block_invoke;
                *(void *)&buf[24] = &__block_descriptor_tmp_161;
                *(void *)&buf[32] = a1;
                v95 = v68;
                dispatch_sync(v69, buf);
                *((_DWORD *)v85 + 6) = 0;
LABEL_171:
                uint64_t v61 = (UInt8 *)v78;
                if (!v78) {
                  goto LABEL_177;
                }
                goto LABEL_176;
              }

              WORD2(v75) = 0;
              unint64_t v32 = 2;
              SEL v74 = 2;
            }

            else
            {
              WORD2(v75) = 0;
              SEL v74 = 0;
              unint64_t v32 = 1;
            }

            LOWORD(v75) = v32;
            goto LABEL_128;
          }
        }

        else
        {
          id v27 = 0LL;
        }

        uint64_t v29 = 0LL;
        goto LABEL_124;
      }

      if (CFEqual(v18, @"AH"))
      {
        unint64_t v19 = 51;
        goto LABEL_111;
      }
    }

    int v20 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      unint64_t v24 = "add policy, invalid ipsec protocol";
      goto LABEL_103;
    }

    goto LABEL_98;
  }

  uint64_t v8 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    *(void *)&void buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3855;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"IntializeDisabled";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFBOOLEAN_TYPE;
    id v9 = "%s:%d: type of value for key %@ != %lu";
LABEL_96:
    _os_log_error_impl(&dword_1876B1000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0x26u);
  }

LABEL_164:
                      int v36 = v359;
LABEL_165:

                      unint64_t v7 = self;
LABEL_76:
                      ne_log_obj();
                      v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)v385 = 0;
                        _os_log_error_impl( &dword_1876B1000,  v108,  OS_LOG_TYPE_ERROR,  "Failed to process Create Child SA",  v385,  2u);
                      }

                      v110 = objc_getProperty(v16, v109, 40LL, 1);
                      [v110 domain];
                      v111 = (void *)objc_claimAutoreleasedReturnValue();
                      v112 = [v111 isEqual:@"NEIKEv2ErrorDomain"];

                      if (v112)
                      {
                        v114 = objc_getProperty(v16, v113, 40LL, 1);
                        v115 = [v114 code];

                        if (v115 == 8) {
                          v116 = 24LL;
                        }
                        else {
                          v116 = 7LL;
                        }
                      }

                      else
                      {
                        v116 = 7LL;
                      }
                      v117 = +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]( (uint64_t)&OBJC_CLASS___NEIKEv2CreateChildPacket,  v7,  v116,  0LL);
                      if (v117)
                      {
                        if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v117, 0LL) & 1) != 0)
                        {
                          -[NEIKEv2ChildSA setState:error:]((uint64_t)v16, 3uLL, 0LL);
LABEL_91:
                          -[NEIKEv2Session reportState](a1, v125);
                          -[NEIKEv2Session resetChild:]((char *)a1, v16);

                          goto LABEL_92;
                        }

                        ErrorInternal = (void *)NEIKEv2CreateErrorFailedToSend( @"create child SA refusal (failed to create response packet)",  v118,  v119,  v120,  v121,  v122,  v123,  v124,  v358);
                      }

                      else
                      {
                        ne_log_obj();
                        v126 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v126, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)v385 = 0;
                          _os_log_error_impl( &dword_1876B1000,  v126,  OS_LOG_TYPE_ERROR,  "Failed to create Create Child SA packet",  v385,  2u);
                        }

                        ErrorInternal = (void *)NEIKEv2CreateErrorInternal( @"Failed to create Create Child SA packet",  v127,  v128,  v129,  v130,  v131,  v132,  v133,  v358);
                      }

                      v135 = ErrorInternal;
                      -[NEIKEv2ChildSA setState:error:]((uint64_t)v16, 3uLL, ErrorInternal);

                      goto LABEL_91;
                    }

                    ne_log_obj();
                    uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_164;
                    }
                    v272 = (void *)[self copyShortDescription];
                    *(_DWORD *)buf = 138412546;
                    v378 = v16;
                    v379 = 2112;
                    v380 = v272;
                    v273 = "%@ %@ Did not receive KE data";
                  }

                  else
                  {
                    ne_log_obj();
                    uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_164;
                    }
                    v272 = (void *)[self copyShortDescription];
                    *(_DWORD *)buf = 138412546;
                    v378 = v16;
                    v379 = 2112;
                    v380 = v272;
                    v273 = "%@ %@ Did not receive method in KE payload";
                  }
                }

                else
                {
                  ne_log_obj();
                  uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_164;
                  }
                  v272 = (void *)[self copyShortDescription];
                  *(_DWORD *)buf = 138412546;
                  v378 = v16;
                  v379 = 2112;
                  v380 = v272;
                  v273 = "%@ %@ Did not receive KE payload";
                }

                _os_log_error_impl(&dword_1876B1000, v69, OS_LOG_TYPE_ERROR, v273, buf, 0x16u);

                goto LABEL_164;
              }

              ne_log_obj();
              uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
                goto LABEL_72;
              }
              v104 = self;
              v105 = (void *)[self copyShortDescription];
              *(_DWORD *)buf = 138412546;
              v378 = v16;
              v379 = 2112;
              v380 = v105;
              v106 = "%@ %@ Did not receive NONCE data";
LABEL_167:
              _os_log_error_impl(&dword_1876B1000, v44, OS_LOG_TYPE_ERROR, v106, buf, 0x16u);

              unint64_t v7 = v104;
              goto LABEL_73;
            }

            ne_log_obj();
            uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              v107 = (void *)[self copyShortDescription];
              *(_DWORD *)buf = 138412546;
              v378 = v16;
              v379 = 2112;
              v380 = v107;
              _os_log_error_impl( &dword_1876B1000,  v44,  OS_LOG_TYPE_ERROR,  "%@ %@ Did not receive NONCE payload",  buf,  0x16u);

              goto LABEL_72;
            }
          }

          else
          {
            ne_log_obj();
            uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              v104 = v7;
              v105 = (void *)[v7 copyShortDescription];
              *(_DWORD *)buf = 138412546;
              v378 = v16;
              v379 = 2112;
              v380 = v105;
              v106 = "%@ %@ Received no SA proposals";
              goto LABEL_167;
            }
          }

LABEL_93:
}

LABEL_48:
              uint64_t v29 = v266;
LABEL_49:

              ne_log_obj();
              unint64_t v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
              {
                v250 = a1[5];
                *(_DWORD *)buf = 138412546;
                *(void *)&void buf[4] = v250;
                *(_WORD *)&buf[12] = 2112;
                *(void *)&buf[14] = v73;
                _os_log_error_impl( &dword_1876B1000,  v78,  OS_LOG_TYPE_ERROR,  "%@ Failed to generate values for KEM %@ (responder rekey child followup KE)",  buf,  0x16u);
              }

              uint64_t v79 = a1[4];
              ErrorInternal = (void *)NEIKEv2CreateErrorInternal( @"Failed to generate values for KEM %@ (responder rekey child followup KE)",  v80,  v81,  v82,  v83,  v84,  v85,  v86,  (uint64_t)v73);
              goto LABEL_68;
            }

            v162 = +[NEIKEv2KeyExchangeHandler handlerForKEMethod:peerPayload:]( (uint64_t)NEIKEv2KeyExchangeHandler,  [v73 method],  v75);
            objc_setProperty_atomic(v68, v163, v162, 112LL);

            v165 = objc_getProperty(v68, v164, 112LL, 1);
            if (!v165)
            {
              ne_log_obj();
              unint64_t v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412290;
                *(void *)&void buf[4] = v73;
                _os_log_error_impl( &dword_1876B1000,  v77,  OS_LOG_TYPE_ERROR,  "Failed to get handler for KE method %@",  buf,  0xCu);
              }

              goto LABEL_48;
            }

            v167 = a1[7] + 1;
            v168 = (void *)a1[4];
            if (v168)
            {
              v169 = objc_getProperty(v168, v166, 184LL, 1);
              v171 = v169;
              if (v169) {
                v169 = objc_getProperty(v169, v170, 120LL, 1);
              }
            }

            else
            {
              v171 = 0LL;
              v169 = 0LL;
            }

            v172 = v169;
            v173 = [v172 count];

            if (v167 >= v173)
            {
              v188 = (void *)a1[4];
              uint64_t v29 = v266;
              if (v188) {
                objc_setProperty_atomic(v188, v174, 0LL, 128LL);
              }
            }

            else
            {
              [MEMORY[0x189607AB8] UUID];
              v175 = (void *)objc_claimAutoreleasedReturnValue();
              *(void *)buf = 0LL;
              *(void *)&uint8_t buf[8] = 0LL;
              [v175 getUUIDBytes:buf];
              v176 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:buf length:16];
              v178 = +[NEIKEv2NotifyPayload createNotifyPayloadType:data:]( (uint64_t)&OBJC_CLASS___NEIKEv2NotifyPayload,  0x4039uLL,  v176);
              v179 = (void *)a1[4];
              uint64_t v29 = v266;
              if (v179) {
                objc_setProperty_atomic(v179, v177, v178, 128LL);
              }
            }

            v133 = (void *)-[NEIKEv2Packet initResponse:]( (uint64_t)objc_alloc(&OBJC_CLASS___NEIKEv2FollowupKEPacket),  v23);
            v189 = objc_alloc_init(&OBJC_CLASS___NEIKEv2KeyExchangePayload);
            v191 = v189;
            if (v133)
            {
              objc_setProperty_atomic(v133, v190, v189, 88LL);

              v193 = objc_getProperty(v133, v192, 88LL, 1);
              v195 = v193;
              if (v193) {
                objc_setProperty_atomic(v193, v194, v73, 24LL);
              }
            }

            else
            {

              v195 = 0LL;
            }

            v197 = (void *)a1[4];
            if (v197)
            {
              v198 = objc_getProperty(v197, v196, 112LL, 1);
              v199 = v198;
              if (v198)
              {
                v200 = (void *)*((void *)v198 + 2);
LABEL_114:
                v202 = v200;
                if (v133)
                {
                  v203 = objc_getProperty(v133, v201, 88LL, 1);
                  v205 = v203;
                  if (v203) {
                    objc_setProperty_atomic(v203, v204, v202, 32LL);
                  }
                }

                else
                {
                  v205 = 0LL;
                }

                v207 = (id)a1[4];
                if (v207) {
                  v207 = objc_getProperty(v207, v206, 128LL, 1);
                }
                v208 = v207;
                v210 = v208;
                if (v133)
                {
                  objc_setProperty_atomic(v133, v209, v208, 96LL);

                  v212 = objc_getProperty(v133, v211, 88LL, 1);
                }

                else
                {

                  v212 = 0LL;
                }

                v213 = v212;
                v214 = -[NEIKEv2Payload isValid]((uint64_t)v213);

                if ((v214 & 1) != 0)
                {
                  v216 = (id)a1[4];
                  if (v216) {
                    v216 = objc_getProperty(v216, v215, 136LL, 1);
                  }
                  v218 = v216;
                  v219 = (void *)a1[4];
                  if (v219)
                  {
                    v220 = objc_getProperty(v219, v217, 112LL, 1);
                    v221 = v220;
                    if (v220)
                    {
                      v222 = (void *)*((void *)v220 + 3);
LABEL_127:
                      v223 = v222;
                      [v218 addObject:v223];

                      v225 = (void *)a1[4];
                      if (v225)
                      {
                        objc_setProperty_atomic(v225, v224, 0LL, 112LL);
                        v226 = a1[4];
                      }

                      else
                      {
                        v226 = 0LL;
                      }

                      v227 = a1[5];
                      v228 = a1[7] + 1;
                      v229 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"responder rekey child FOLLOWUP_KE #%zu",  a1[7]);
                      -[NEIKEv2Session handleFollowupKEForRekeyChildSAResponder:iteration:replyPacket:replyPacketDescription:handler:]( v227,  v226,  v228,  v133,  v229,  a1[6]);

                      uint64_t v29 = v266;
                      goto LABEL_91;
                    }
                  }

                  else
                  {
                    v221 = 0LL;
                  }

                  v222 = 0LL;
                  goto LABEL_127;
                }

                ne_log_obj();
                v230 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v230, OS_LOG_TYPE_ERROR))
                {
                  v260 = a1[5];
                  *(_DWORD *)buf = 138412290;
                  *(void *)&void buf[4] = v260;
                  _os_log_error_impl( &dword_1876B1000,  v230,  OS_LOG_TYPE_ERROR,  "%@ Failed to create FOLLOWUP_KE packet (responder rekey child followup KE)",  buf,  0xCu);
                }

                v231 = a1[4];
                ErrorFailedToSend = (void *)NEIKEv2CreateErrorInternal( @"Failed to create FOLLOWUP_KE packet (responder rekey child followup KE)",  v232,  v233,  v234,  v235,  v236,  v237,  v238,  v263);
                v160 = v231;
                goto LABEL_89;
              }
            }

            else
            {
              v199 = 0LL;
            }

            v200 = 0LL;
            goto LABEL_114;
          }

          ne_log_obj();
          v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
          {
            v182 = a1[5];
            *(_DWORD *)buf = 138412290;
            *(void *)&void buf[4] = v182;
            _os_log_error_impl( &dword_1876B1000,  v110,  OS_LOG_TYPE_ERROR,  "%@ Did not receive data in KE payload (responder rekey child followup KE)",  buf,  0xCu);
          }

          uint64_t v79 = a1[4];
          v108 = @"Did not receive data in KE payload (responder rekey child followup KE)";
        }

        else
        {
          ne_log_obj();
          v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
          {
            v181 = a1[5];
            *(_DWORD *)buf = 138412290;
            *(void *)&void buf[4] = v181;
            _os_log_error_impl( &dword_1876B1000,  v109,  OS_LOG_TYPE_ERROR,  "%@ Did not receive method in KE payload (responder rekey child followup KE)",  buf,  0xCu);
          }

          uint64_t v79 = a1[4];
          v108 = @"Did not receive method in KE payload (responder rekey child followup KE)";
        }
      }

      else
      {
        ne_log_obj();
        v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
        {
          v180 = a1[5];
          *(_DWORD *)buf = 138412290;
          *(void *)&void buf[4] = v180;
          _os_log_error_impl( &dword_1876B1000,  v100,  OS_LOG_TYPE_ERROR,  "%@ Did not receive KE payload (responder rekey child followup KE)",  buf,  0xCu);
        }

        uint64_t v79 = a1[4];
        v108 = @"Did not receive KE payload (responder rekey child followup KE)";
      }

      ErrorInternal = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v108, v101, v102, v103, v104, v105, v106, v107, v263);
LABEL_68:
      v111 = ErrorInternal;
      -[NEIKEv2ChildSA setState:error:](v79, 3uLL, ErrorInternal);
LABEL_69:

      -[NEIKEv2Session reportState]((void *)a1[5], v112);
      -[NEIKEv2Session resetChild:]((char *)a1[5], (void *)a1[4]);
LABEL_70:

      goto LABEL_71;
    }

    ne_log_obj();
    v251 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v251, OS_LOG_TYPE_ERROR))
    {
      v261 = a1[5];
      *(_DWORD *)buf = 138412290;
      *(void *)&void buf[4] = v261;
      _os_log_error_impl( &dword_1876B1000,  v251,  OS_LOG_TYPE_ERROR,  "%@ Failed to receive FOLLOWUP_KE packet (responder rekey child followup KE)",  buf,  0xCu);
    }

    v96 = a1[4];
    v97 = @"Failed to receive FOLLOWUP_KE packet (responder rekey child followup KE)";
    goto LABEL_57;
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    int v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl( &dword_1876B1000,  v88,  OS_LOG_TYPE_ERROR,  "Failed to receive Rekey Child SA Delete packet",  buf,  2u);
    }

    v96 = a1[4];
    v97 = @"Failed to receive Rekey Child SA Delete packet";
LABEL_57:
    v98 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v97, v89, v90, v91, v92, v93, v94, v95, v263);
    -[NEIKEv2ChildSA setState:error:](v96, 3uLL, v98);

    -[NEIKEv2Session reportState]((void *)a1[5], v99);
    -[NEIKEv2Session resetChild:]((char *)a1[5], (void *)a1[4]);
    goto LABEL_71;
  }

  (*(void (**)(void))(a1[6] + 16))();
LABEL_71:
}

      if (v28 == ++v30)
      {
        uint64_t v28 = [v26 countByEnumeratingWithState:&v66 objects:v74 count:16];
        if (v28) {
          goto LABEL_24;
        }
        goto LABEL_52;
      }
    }
  }

  uint64_t v59 = 0LL;
  uint64_t v61 = 0LL;
LABEL_52:

  uint64_t v49 = v62;
  if (v12) {
    uint64_t v50 = v62;
  }
  else {
    uint64_t v50 = 0LL;
  }
  int v51 = v50;
  int v39 = v59;
  unint64_t v41 = v61;
LABEL_59:

  return v51;
}
}

LABEL_14:
    unint64_t v7 = 0LL;
    goto LABEL_23;
  }

  unsigned __int16 v17 = v44;
  LODWORD(v1_Block_object_dispose((const void *)(v49 - 176), 8) = bswap32(v44);
  ne_log_obj();
  unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    int v48 = "+[NEProcessInfo copyUUIDsForFatBinary:]";
    uint64_t v49 = 1024;
    LODWORD(v50[0]) = v18;
    _os_log_debug_impl(&dword_1876B1000, v19, OS_LOG_TYPE_DEBUG, "%s: number of arch detected: %d", buf, 0x12u);
  }

  if (!v17)
  {
    ne_log_obj();
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1876B1000, v12, OS_LOG_TYPE_DEFAULT, "Number of architectures is 0", buf, 2u);
    }

    goto LABEL_48;
  }

  else {
    int v18 = v18;
  }
  int v20 = (unsigned int *)malloc(4 * (v18 + 4LL * v18));
  if (!v20) {
    goto LABEL_14;
  }
  uint64_t v21 = v20;
  id v22 = 0LL;
  if (v18 <= 1) {
    uint64_t v23 = 1LL;
  }
  else {
    uint64_t v23 = v18;
  }
  do
  {
    if (read(v4, &v41, 0x14uLL) != 20)
    {
      ne_log_obj();
      int v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315138;
        int v48 = "+[NEProcessInfo copyUUIDsForFatBinary:]";
        _os_log_error_impl(&dword_1876B1000, v30, OS_LOG_TYPE_ERROR, "%s: failed to read arch info", buf, 0xCu);
      }

      unint64_t v7 = 0LL;
      goto LABEL_76;
    }

    LODWORD(v41) = bswap32(v41);
    ne_log_obj();
    unint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315650;
      int v48 = "+[NEProcessInfo copyUUIDsForFatBinary:]";
      uint64_t v49 = 1024;
      LODWORD(v50[0]) = v41;
      WORD2(v50[0]) = 1024;
      *(_DWORD *)((char *)v50 + 6) = v41;
      _os_log_debug_impl(&dword_1876B1000, v24, OS_LOG_TYPE_DEBUG, "%s: cpu type %X (%d)", buf, 0x18u);
    }

    DWORD2(v41) = bswap32(DWORD2(v41));
    BOOL v25 = &v21[v22];
    v25[4] = v42;
    *(_OWORD *)BOOL v25 = v41;
    v22 += 5LL;
  }

  while (5 * v23 != v22);
  unint64_t v7 = 0LL;
  unint64_t v31 = v21 + 2;
  do
  {
    unint64_t v32 = *v31;
    if (!*v31)
    {
      ne_log_obj();
      uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136315138;
      int v48 = "+[NEProcessInfo copyUUIDsForFatBinary:]";
      int v36 = "%s: invalid offset";
      uint64_t v37 = v35;
      uint64_t v38 = 12;
LABEL_67:
      _os_log_error_impl(&dword_1876B1000, v37, OS_LOG_TYPE_ERROR, v36, buf, v38);
      goto LABEL_75;
    }

    int v33 = *(v31 - 2);
    if (lseek(v4, *v31, 0) == -1)
    {
      ne_log_obj();
      uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136315394;
      int v48 = "+[NEProcessInfo copyUUIDsForFatBinary:]";
      uint64_t v49 = 1024;
      LODWORD(v50[0]) = v32;
      int v36 = "%s: failed to seek to offset %u";
      uint64_t v37 = v35;
      uint64_t v38 = 18;
      goto LABEL_67;
    }

    uint64_t v34 = +[NEProcessInfo copyUUIDForSingleArch:]((uint64_t)&OBJC_CLASS___NEProcessInfo, v4);
    if (!v34)
    {
      ne_log_obj();
      int v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        int v48 = "+[NEProcessInfo copyUUIDsForFatBinary:]";
        uint64_t v49 = 1024;
        LODWORD(v50[0]) = v32;
        _os_log_error_impl(&dword_1876B1000, v39, OS_LOG_TYPE_ERROR, "%s: failed to get uuid for offset %u", buf, 0x12u);
      }

      uint64_t v35 = 0LL;
      goto LABEL_74;
    }

    uint64_t v35 = (os_log_s *)v34;
    if (!v7)
    {
      unint64_t v7 = objc_alloc_init(MEMORY[0x189603FA8]);
      if (!v7)
      {
        ne_log_obj();
        int v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          int v48 = "+[NEProcessInfo copyUUIDsForFatBinary:]";
          _os_log_error_impl(&dword_1876B1000, v39, OS_LOG_TYPE_ERROR, "%s: failed allocate UUID array", buf, 0xCu);
        }

        unint64_t v7 = 0LL;
LABEL_74:

        goto LABEL_75;
      }
    }

    if (v33 == host_info_out[3]) {
      [v7 insertObject:v35 atIndex:0];
    }
    else {
      [v7 addObject:v35];
    }
    v31 += 5;

    --v23;
  }

  while (v23);
  ne_log_obj();
  uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    int v48 = "+[NEProcessInfo copyUUIDsForFatBinary:]";
    uint64_t v49 = 2112;
    v50[0] = v7;
    _os_log_debug_impl(&dword_1876B1000, v35, OS_LOG_TYPE_DEBUG, "%s: uuids %@", buf, 0x16u);
  }

        uint64_t v34 = (char *)v34 + 1;
      }

      while (v28 != v34);
      char v43 = [v6 countByEnumeratingWithState:&v47 objects:v55 count:16];
      uint64_t v28 = (void *)v43;
    }

    while (v43);
  }

LABEL_49:
    uint64_t v72 = 0LL;
    goto LABEL_50;
  }

  int v62 = self->_agent;
  if (v62)
  {
    int v62 = objc_getProperty(v62, v61, 32LL, 1);
    uint64_t v63 = self->_agent;
  }

  else
  {
    uint64_t v63 = 0LL;
  }

  if (([v62 registerNetworkAgent:v63] & 1) == 0)
  {
    ne_log_obj();
    uint64_t v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uu = 0;
      unint64_t v78 = "[NWNetworkAgentRegistration registerNetworkAgent] failed";
      goto LABEL_64;
    }

    goto LABEL_48;
  }

  uuid_clear(uu);
  if (v84) {
    [v84 getUUIDBytes:uu];
  }
  uint64_t v64 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  NexusExtendedWithOptions = (NEVirtualInterface_s *)NEVirtualInterfaceCreateNexusExtendedWithOptions( (const __CFAllocator *)*MEMORY[0x189604DB0],  a5,  0LL,  0LL,  1,  0,  a7,  0,  a8,  a9,  a10,  uu,  0LL);
  self->_virtualInterface = NexusExtendedWithOptions;
  if (!NexusExtendedWithOptions)
  {
    ne_log_obj();
    uint64_t v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_FAULT)) {
      goto LABEL_48;
    }
    __int16 v85 = 0;
    unint64_t v78 = "NEVirtualInterfaceCreateNexus failed";
    goto LABEL_71;
  }

  virtualInterface = (char *)NexusExtendedWithOptions;
  uint64_t v68 = self->_agent;
  if (v68)
  {
    uint64_t v69 = objc_getProperty(v68, v66, 32LL, 1);
    virtualInterface = (char *)self->_virtualInterface;
    int v70 = v69;
    if (!virtualInterface) {
      goto LABEL_37;
    }
  }

  else
  {
    int v70 = 0LL;
  }

  virtualInterface = (char *)CFStringCreateWithCString(v64, virtualInterface + 265, 0x600u);
LABEL_37:
  unint64_t v71 = [v70 addNetworkAgentToInterfaceNamed:virtualInterface];

  if ((v71 & 1) == 0)
  {
    ne_log_obj();
    uint64_t v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_FAULT)) {
      goto LABEL_48;
    }
    __int16 v85 = 0;
    unint64_t v78 = "[NWNetworkAgentRegistration addNetworkAgentToInterfaceNamed] failed";
LABEL_71:
    int v81 = (unsigned __int8 *)&v85;
    goto LABEL_65;
  }

  uint64_t v72 = self;
LABEL_50:

  return v72;
}

  unint64_t v41 = objc_msgSend(v34, "installed", v43);
  if ((_DWORD)v43 == v41) {
    goto LABEL_51;
  }
LABEL_49:
  objc_msgSend(*(id *)(a1 + 32), "setInstalled:", v43, v43);
  unint64_t v42 = [*(id *)(a1 + 32) installNotify];
  if (v28 != int64 || v42)
  {
LABEL_51:
    if (*(_BYTE *)(a1 + 56)) {
      -[NEVPNConnection notifyStatusChanged](*(void *)(a1 + 32));
    }
  }

LABEL_115:
                      v359 = 0;
                      int v81 = 7LL;
                      goto LABEL_122;
                    }

                    v108 = v350;
                    if (v350) {
                      v108 = objc_getProperty(v350, v73, 96LL, 1);
                    }
                    uint64_t v56 = &OBJC_IVAR___NEConfigurationManager__hasVPNAPIEntitlement;
                    v109 = v108;
                    v111 = -[NEIKEv2IKESAProposal prfProtocol](v109, v110);
                    v343 = [v111 nonceSize];

                    if (v346 < v343)
                    {
                      ne_log_obj();
                      SEL v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                      {
                        id v75 = (void *)[self copyShortDescription];
                        v113 = v350;
                        if (v350) {
                          v113 = objc_getProperty(v350, v112, 96LL, 1);
                        }
                        v340 = v113;
                        v115 = -[NEIKEv2IKESAProposal prfProtocol](v340, v114);
                        *(_DWORD *)v361 = 138412802;
                        v362 = v75;
                        v363 = 2048;
                        v364 = v346;
                        v365 = 2112;
                        v366 = (uint64_t)v115;
                        _os_log_error_impl( &dword_1876B1000,  v74,  OS_LOG_TYPE_ERROR,  "%@ NONCE data length %zu is shorter than the minimum for PRF protocol %@",  v361,  0x20u);

                        goto LABEL_114;
                      }

                      goto LABEL_115;
                    }
                  }

                  objc_getProperty(self, v67, v56[755], 1);
                  v116 = (void *)objc_claimAutoreleasedReturnValue();
                  v118 = v116;
                  if (v116) {
                    v116 = objc_getProperty(v116, v117, 24LL, 1);
                  }
                  v119 = v116;
                  objc_setProperty_atomic(v24, v120, v119, 88LL);

                  v122 = objc_getProperty(v24, v121, 184LL, 1);
                  v124 = v122;
                  if (v122) {
                    v122 = objc_getProperty(v122, v123, 112LL, 1);
                  }
                  v125 = v122;
                  v126 = [v125 method];

                  if (!v126)
                  {
LABEL_102:
                    v359 = 1;
                    int v81 = 7LL;
                    int v33 = v351;
LABEL_122:

                    goto LABEL_123;
                  }

                  objc_getProperty(self, v127, 104LL, 1);
                  v128 = (void *)objc_claimAutoreleasedReturnValue();

                  if (v128)
                  {
                    objc_getProperty(self, v129, 104LL, 1);
                    v130 = (void *)objc_claimAutoreleasedReturnValue();
                    v132 = v130;
                    if (v130) {
                      v130 = objc_getProperty(v130, v131, 24LL, 1);
                    }
                    int v33 = v351;
                    v133 = v130;

                    if (v133)
                    {
                      objc_getProperty(self, v134, 104LL, 1);
                      v135 = (void *)objc_claimAutoreleasedReturnValue();
                      v137 = v135;
                      if (v135) {
                        v135 = objc_getProperty(v135, v136, 32LL, 1);
                      }
                      v138 = v135;

                      if (v138)
                      {
                        objc_getProperty(self, v139, 104LL, 1);
                        v140 = (void *)objc_claimAutoreleasedReturnValue();
                        v347 = v140;
                        if (v140) {
                          v140 = objc_getProperty(v140, v141, 24LL, 1);
                        }
                        v142 = v140;
                        v143 = [v142 method];
                        v145 = objc_getProperty(v24, v144, 184LL, 1);
                        v147 = v145;
                        v341 = v142;
                        v344 = v143;
                        if (v145) {
                          v145 = objc_getProperty(v145, v146, 112LL, 1);
                        }
                        v148 = v145;
                        v149 = [v148 method];

                        if (v344 == v149)
                        {
                          objc_getProperty(self, v150, 104LL, 1);
                          v151 = (void *)objc_claimAutoreleasedReturnValue();
                          v153 = v151;
                          if (v151) {
                            v151 = objc_getProperty(v151, v152, 32LL, 1);
                          }
                          v154 = v151;
                          objc_setProperty_atomic(v24, v155, v154, 104LL);

                          goto LABEL_102;
                        }

                        ne_log_obj();
                        v159 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v159, OS_LOG_TYPE_INFO))
                        {
                          v160 = [self copyShortDescription];
                          objc_getProperty(self, v161, 104LL, 1);
                          v162 = (void *)objc_claimAutoreleasedReturnValue();
                          v348 = v162;
                          v164 = (void *)v160;
                          if (v162) {
                            v162 = objc_getProperty(v162, v163, 24LL, 1);
                          }
                          v345 = v162;
                          v342 = [v345 method];
                          v166 = objc_getProperty(v24, v165, 184LL, 1);
                          v168 = -[NEIKEv2IKESAProposal kemProtocol](v166, v167);
                          *(_DWORD *)v361 = 138412802;
                          v362 = v164;
                          v363 = 2048;
                          v364 = v342;
                          v365 = 2048;
                          v366 = [v168 method];
                          _os_log_impl( &dword_1876B1000,  v159,  OS_LOG_TYPE_INFO,  "%@ Received KE method %zu does not match KE method %zu in CHILD SA rekey proposal",  v361,  0x20u);

                          int v33 = v351;
                        }

LABEL_121:
                        v359 = 0;
                        int v81 = 17LL;
                        goto LABEL_122;
                      }

                      ne_log_obj();
                      SEL v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_115;
                      }
                      id v75 = (void *)[self copyShortDescription];
                      *(_DWORD *)v361 = 138412290;
                      v362 = v75;
                      uint64_t v76 = "%@ Did not receive data in KE payload";
                    }

                    else
                    {
                      ne_log_obj();
                      SEL v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_115;
                      }
                      id v75 = (void *)[self copyShortDescription];
                      *(_DWORD *)v361 = 138412290;
                      v362 = v75;
                      uint64_t v76 = "%@ Did not receive method in KE payload";
                    }

                    unint64_t v77 = v74;
                    unint64_t v78 = 12;
                    goto LABEL_113;
                  }

                  ne_log_obj();
                  v156 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  int v33 = v351;
                  if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
                  {
                    v337 = (void *)[self copyShortDescription];
                    *(_DWORD *)v361 = 138412290;
                    v362 = v337;
                    _os_log_error_impl( &dword_1876B1000,  v156,  OS_LOG_TYPE_ERROR,  "%@ Did not receive KE payload",  v361,  0xCu);
                  }

                  goto LABEL_121;
                }

                ne_log_obj();
                v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
                {
                  v105 = (void *)[self copyShortDescription];
                  *(_DWORD *)v361 = 138412290;
                  v362 = v105;
                  v106 = "%@ Did not receive NONCE data";
LABEL_107:
                  _os_log_error_impl(&dword_1876B1000, v100, OS_LOG_TYPE_ERROR, v106, v361, 0xCu);

                  goto LABEL_60;
                }

                goto LABEL_60;
              }

              ne_log_obj();
              v104 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
              {
                v158 = (void *)[self copyShortDescription];
                *(_DWORD *)v361 = 138412290;
                v362 = v158;
                _os_log_error_impl( &dword_1876B1000,  v104,  OS_LOG_TYPE_ERROR,  "%@ Did not receive NONCE payload",  v361,  0xCu);
              }

              v359 = 0;
              int v81 = 7LL;
              int v33 = v351;
            }

            else
            {
              ne_log_obj();
              v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
              {
                v157 = (void *)[self copyShortDescription];
                *(_DWORD *)v361 = 138412290;
                v362 = v157;
                _os_log_error_impl( &dword_1876B1000,  v101,  OS_LOG_TYPE_ERROR,  "%@ No matching rekey proposal found",  v361,  0xCu);
              }

              v359 = 0;
              int v81 = 14LL;
            }

LABEL_185:
                  v270 = 0LL;
LABEL_186:

                  if (v270)
                  {
                    v320 = objc_getProperty(v181, v319, 112LL, 1);
                    v321 = v320;
                    unint64_t v7 = self;
                    if (v320) {
                      v322 = (void *)*((void *)v320 + 3);
                    }
                    else {
                      v322 = 0LL;
                    }
                    v323 = v322;
                    objc_setProperty_atomic(v181, v324, v323, 120LL);

                    objc_setProperty_atomic(v181, v325, 0LL, 112LL);
                    v354[0] = MEMORY[0x1895F87A8];
                    v354[1] = 3221225472LL;
                    v354[2] = __55__NEIKEv2Session_Exchange__receiveRekeyChildSA_packet___block_invoke;
                    v354[3] = &unk_18A08D258;
                    v355 = v353;
                    v356 = v181;
                    v357 = a1;
                    v358 = v13;
                    -[NEIKEv2Session handleFollowupKEForRekeyChildSAResponder:iteration:replyPacket:replyPacketDescription:handler:]( a1,  v356,  0LL,  v270,  @"responder rekey child SA reply",  v354);
                  }

                  else
                  {
                    ne_log_obj();
                    v326 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    unint64_t v7 = self;
                    if (os_log_type_enabled(v326, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_error_impl( &dword_1876B1000,  v326,  OS_LOG_TYPE_ERROR,  "Failed to create Create Child SA packet",  buf,  2u);
                    }

                    ErrorInternal = (void *)NEIKEv2CreateErrorInternal( @"Failed to create Create Child SA packet",  v327,  v328,  v329,  v330,  v331,  v332,  v333,  v339);
                    -[NEIKEv2ChildSA setState:error:]((uint64_t)v181, 3uLL, ErrorInternal);

                    -[NEIKEv2Session reportState](a1, v335);
                    -[NEIKEv2Session resetChild:]((char *)a1, v181);
                  }

                  goto LABEL_67;
                }

                ne_log_obj();
                v294 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v294, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl( &dword_1876B1000,  v294,  OS_LOG_TYPE_ERROR,  "Failed to generate Child SA SPI",  buf,  2u);
                }

                v302 = @"Failed to generate Child SA SPI";
              }

              v303 = (void *)NEIKEv2CreateErrorCrypto(v302, v295, v296, v297, v298, v299, v300, v301, v339);
              -[NEIKEv2ChildSA setState:error:]((uint64_t)v24, 3uLL, v303);

              -[NEIKEv2Session reportState](a1, v304);
              -[NEIKEv2Session resetChild:]((char *)a1, v24);
              unint64_t v7 = self;
LABEL_67:

              goto LABEL_68;
            }

            unint64_t v7 = self;
            if (v81 == 17)
            {
              v271 = objc_getProperty(v24, v169, 184LL, 1);
              v273 = v271;
              if (v271) {
                v271 = objc_getProperty(v271, v272, 112LL, 1);
              }
              v274 = v271;
              v275 = bswap32([v274 method]) >> 16;

              *(_WORD *)buf = v275;
              v276 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:buf length:2];
              +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]( (uint64_t)&OBJC_CLASS___NEIKEv2CreateChildPacket,  self,  0x11uLL,  v276);
              uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();

              if (v82)
              {
                if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v82, 0LL) & 1) != 0)
                {

                  unint64_t v7 = self;
                  goto LABEL_164;
                }

                ErrorFailedToSend = NEIKEv2CreateErrorFailedToSend( @"rekey child SA refusal",  v277,  v278,  v279,  v280,  v281,  v282,  v283,  v339);
              }

              else
              {
                ne_log_obj();
                v305 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v305, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v368 = 0;
                  _os_log_error_impl( &dword_1876B1000,  v305,  OS_LOG_TYPE_ERROR,  "Failed to create Create Child SA packet",  v368,  2u);
                }

                ErrorFailedToSend = NEIKEv2CreateErrorInternal( @"Failed to create Create Child SA packet",  v306,  v307,  v308,  v309,  v310,  v311,  v312,  v339);
              }

              v102 = (void *)ErrorFailedToSend;
              unint64_t v7 = self;
              goto LABEL_66;
            }

LABEL_51:
            +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]( (uint64_t)&OBJC_CLASS___NEIKEv2CreateChildPacket,  v7,  v81,  0LL);
            uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
            if (v82)
            {
              if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v82, 0LL) & 1) != 0)
              {
                if (v81 == 14)
                {

LABEL_164:
                  objc_setProperty_atomic(v24, v90, 0LL, 184LL);
                  goto LABEL_67;
                }

                ErrorPeerInvalidSyntax = NEIKEv2CreateErrorPeerInvalidSyntax( @"Failed to process Create Child SA packet",  v83,  v84,  v85,  v86,  v87,  v88,  v89,  v339);
              }

              else
              {
                ErrorPeerInvalidSyntax = NEIKEv2CreateErrorFailedToSend( @"rekey child SA refusal",  v83,  v84,  v85,  v86,  v87,  v88,  v89,  v339);
              }
            }

            else
            {
              ne_log_obj();
              unint64_t v91 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_error_impl( &dword_1876B1000,  v91,  OS_LOG_TYPE_ERROR,  "Failed to create Create Child SA packet",  buf,  2u);
              }

              ErrorPeerInvalidSyntax = NEIKEv2CreateErrorInternal( @"Failed to create Create Child SA packet",  v92,  v93,  v94,  v95,  v96,  v97,  v98,  v339);
            }

            v102 = (void *)ErrorPeerInvalidSyntax;
LABEL_66:
            -[NEIKEv2ChildSA setState:error:]((uint64_t)v24, 3uLL, v102);

            -[NEIKEv2Session reportState](a1, v103);
            -[NEIKEv2Session resetChild:]((char *)a1, v24);

            goto LABEL_67;
          }

          ne_log_obj();
          v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
          {
            v105 = (void *)[self copyShortDescription];
            *(_DWORD *)v361 = 138412290;
            v362 = v105;
            v106 = "%@ Received no SA proposals";
            goto LABEL_107;
          }

LABEL_30:
        ++v7;
      }

      while (v5 != v7);
      id v22 = -[NEIKEv2CreateChildPacket countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v23,  v30,  16LL);
      __int128 v5 = v22;
    }

    while (v22);
  }
}

LABEL_84:
              goto LABEL_77;
            }

            ne_log_obj();
            v104 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
            {
              v194 = *(void *)(a1 + 40);
              *(_DWORD *)buf = 138412290;
              *(void *)&void buf[4] = v194;
              _os_log_error_impl( &dword_1876B1000,  v104,  OS_LOG_TYPE_ERROR,  "%@ Did not receive data in KE payload (responder rekey followup KE)",  buf,  0xCu);
            }

            v97 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
            v106 = *(id *)(a1 + 40);
            if (v106) {
              v106 = objc_getProperty(v106, v105, 368LL, 1);
            }
            v99 = v106;
            v238[0] = MEMORY[0x1895F87A8];
            v238[1] = 3221225472LL;
            v238[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_377;
            v238[3] = &unk_18A08D468;
            v238[4] = *(void *)(a1 + 40);
            v100 = v238;
          }

          else
          {
            ne_log_obj();
            v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
            {
              v193 = *(void *)(a1 + 40);
              *(_DWORD *)buf = 138412290;
              *(void *)&void buf[4] = v193;
              _os_log_error_impl( &dword_1876B1000,  v101,  OS_LOG_TYPE_ERROR,  "%@ Did not receive method in KE payload (responder rekey followup KE)",  buf,  0xCu);
            }

            v97 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
            v103 = *(id *)(a1 + 40);
            if (v103) {
              v103 = objc_getProperty(v103, v102, 368LL, 1);
            }
            v99 = v103;
            v239[0] = MEMORY[0x1895F87A8];
            v239[1] = 3221225472LL;
            v239[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_374;
            v239[3] = &unk_18A08D468;
            v239[4] = *(void *)(a1 + 40);
            v100 = v239;
          }
        }

        else
        {
          ne_log_obj();
          v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
          {
            v143 = *(void *)(a1 + 40);
            *(_DWORD *)buf = 138412290;
            *(void *)&void buf[4] = v143;
            _os_log_error_impl( &dword_1876B1000,  v95,  OS_LOG_TYPE_ERROR,  "%@ Did not receive KE payload (responder rekey followup KE)",  buf,  0xCu);
          }

          v97 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
          v98 = *(id *)(a1 + 40);
          if (v98) {
            v98 = objc_getProperty(v98, v96, 368LL, 1);
          }
          v99 = v98;
          v240[0] = MEMORY[0x1895F87A8];
          v240[1] = 3221225472LL;
          v240[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_371;
          v240[3] = &unk_18A08D468;
          v240[4] = *(void *)(a1 + 40);
          v100 = v240;
        }

        v107 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]( (id *)&v97->super.super.isa,  0,  v99,  v100);

        -[NEIKEv2Session initiateDelete:](*(void **)(a1 + 40), v107);
LABEL_76:

LABEL_77:
        goto LABEL_78;
      }

      ne_log_obj();
      v216 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v216, OS_LOG_TYPE_ERROR))
      {
        v223 = *(void *)(a1 + 40);
        *(_DWORD *)buf = 138412546;
        *(void *)&void buf[4] = v223;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v29;
        _os_log_error_impl( &dword_1876B1000,  v216,  OS_LOG_TYPE_ERROR,  "%@ No chosen KEM found for transform type %@ (responder rekey followup KE)",  buf,  0x16u);
      }

      v218 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
      v219 = *(id *)(a1 + 40);
      if (v219) {
        v219 = objc_getProperty(v219, v217, 368LL, 1);
      }
      v220 = v219;
      v241[0] = MEMORY[0x1895F87A8];
      v241[1] = 3221225472LL;
      v241[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_368;
      v241[3] = &unk_18A08CF10;
      v241[4] = *(void *)(a1 + 40);
      v242 = v29;
      v221 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]( (id *)&v218->super.super.isa,  0,  v220,  v241);

      -[NEIKEv2Session initiateDelete:](*(void **)(a1 + 40), v221);
      v115 = v242;
      goto LABEL_84;
    }

    ne_log_obj();
    v213 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v213, OS_LOG_TYPE_ERROR))
    {
      v222 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      *(void *)&void buf[4] = v222;
      _os_log_error_impl( &dword_1876B1000,  v213,  OS_LOG_TYPE_ERROR,  "%@ Failed to receive FOLLOWUP_KE packet (responder rekey followup KE)",  buf,  0xCu);
    }

    unint64_t v91 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
    v215 = *(id *)(a1 + 40);
    if (v215) {
      v215 = objc_getProperty(v215, v214, 368LL, 1);
    }
    v93 = v215;
    v243[0] = MEMORY[0x1895F87A8];
    v243[1] = 3221225472LL;
    v243[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_365;
    v243[3] = &unk_18A08D468;
    v243[4] = *(void *)(a1 + 40);
    v94 = v243;
LABEL_59:
    uint64_t v23 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]( (id *)&v91->super.super.isa,  0,  v93,  v94);

    -[NEIKEv2Session initiateDelete:](*(void **)(a1 + 40), v23);
LABEL_78:

    goto LABEL_79;
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    uint64_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl( &dword_1876B1000,  v89,  OS_LOG_TYPE_ERROR,  "Failed to receive Rekey IKE Delete packet (receive rekey)",  buf,  2u);
    }

    unint64_t v91 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
    v92 = *(id *)(a1 + 40);
    if (v92) {
      v92 = objc_getProperty(v92, v90, 368LL, 1);
    }
    v93 = v92;
    v228[0] = MEMORY[0x1895F87A8];
    v228[1] = 3221225472LL;
    v228[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_396;
    v228[3] = &unk_18A08D468;
    v228[4] = *(void *)(a1 + 40);
    v94 = v228;
    goto LABEL_59;
  }

  (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
LABEL_79:
}

                    if (v111 && !-[NEIKEv2Packet addNotification:data:](v6, 0x402FuLL, v111))
                    {
                      ne_log_obj();
                      v107 = (id)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled((os_log_t)v107, OS_LOG_TYPE_FAULT))
                      {
LABEL_141:

                        goto LABEL_142;
                      }

                      *(_WORD *)buf = 0;
                      v181 = "[packet addNotification:NEIKEv2NotifyTypeSignatureHashAlgorithms] failed";
                    }

                    else
                    {
                      v133 = objc_getProperty(v2, v132, 80LL, 1);
                      v134 = [v133 requestPPK];

                      if (!v134 || -[NEIKEv2Packet addNotification:data:](v6, 0x4033uLL, 0LL))
                      {
                        v186 = v111;
                        v188 = v101;
                        v201 = 0u;
                        v202 = 0u;
                        v199 = 0u;
                        v200 = 0u;
                        v136 = objc_getProperty(v2, v135, 80LL, 1);
                        [v136 proposals];
                        v137 = (void *)objc_claimAutoreleasedReturnValue();

                        v138 = [v137 countByEnumeratingWithState:&v199 objects:v212 count:16];
                        if (v138)
                        {
                          v139 = v138;
                          v140 = *(void *)v200;
                          while (2)
                          {
                            for (j = 0LL; j != v139; ++j)
                            {
                              if (*(void *)v200 != v140) {
                                objc_enumerationMutation(v137);
                              }
                              [*(id *)(*((void *)&v199 + 1) + 8 * j) additionalKEMProtocols];
                              v142 = (void *)objc_claimAutoreleasedReturnValue();

                              if (v142 && !-[NEIKEv2Packet addNotification:data:](v6, 0x4036uLL, 0LL))
                              {
                                ne_log_obj();
                                v182 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                if (os_log_type_enabled(v182, OS_LOG_TYPE_FAULT))
                                {
                                  *(_WORD *)buf = 0;
                                  _os_log_fault_impl( &dword_1876B1000,  v182,  OS_LOG_TYPE_FAULT,  "[packet addNotification:NEIKEv2NotifyTypeIntermediateExchangeSupported] failed",  buf,  2u);
                                }

                                uint64_t v76 = 0LL;
                                goto LABEL_129;
                              }
                            }

                            v139 = [v137 countByEnumeratingWithState:&v199 objects:v212 count:16];
                            if (v139) {
                              continue;
                            }
                            break;
                          }
                        }

                        v197 = 0u;
                        v198 = 0u;
                        v195 = 0u;
                        v196 = 0u;
                        v144 = objc_getProperty(v2, v143, 80LL, 1);
                        [v144 customIKESAInitVendorPayloads];
                        v145 = (void *)objc_claimAutoreleasedReturnValue();

                        obj = v145;
                        v146 = [v145 countByEnumeratingWithState:&v195 objects:v211 count:16];
                        if (v146)
                        {
                          v147 = v146;
                          v148 = *(void *)v196;
                          do
                          {
                            for (k = 0LL; k != v147; ++k)
                            {
                              if (*(void *)v196 != v148) {
                                objc_enumerationMutation(obj);
                              }
                              v150 = *(void **)(*((void *)&v195 + 1) + 8 * k);
                              v151 = objc_alloc_init(&OBJC_CLASS___NEIKEv2VendorIDPayload);
                              [v150 vendorData];
                              v153 = (void *)objc_claimAutoreleasedReturnValue();
                              if (v151) {
                                objc_setProperty_atomic(v151, v152, v153, 24LL);
                              }

                              objc_getProperty(v6, v154, 120LL, 1);
                              v155 = (void *)objc_claimAutoreleasedReturnValue();

                              if (v155)
                              {
                                objc_getProperty(v6, v156, 120LL, 1);
                                v157 = (void *)objc_claimAutoreleasedReturnValue();
                                [v157 arrayByAddingObject:v151];
                                v158 = (void *)objc_claimAutoreleasedReturnValue();
                                objc_setProperty_atomic(v6, v159, v158, 120LL);
                              }

                              else
                              {
                                v210 = v151;
                                [MEMORY[0x189603F18] arrayWithObjects:&v210 count:1];
                                v157 = (void *)objc_claimAutoreleasedReturnValue();
                                objc_setProperty_atomic(v6, v160, v157, 120LL);
                              }
                            }

                            v147 = [obj countByEnumeratingWithState:&v195 objects:v211 count:16];
                          }

                          while (v147);
                        }

                        v193 = 0u;
                        v194 = 0u;
                        v191 = 0u;
                        v192 = 0u;
                        v162 = objc_getProperty(v2, v161, 80LL, 1);
                        [v162 customIKESAInitPayloads];
                        v163 = (void *)objc_claimAutoreleasedReturnValue();

                        obja = v163;
                        v164 = [v163 countByEnumeratingWithState:&v191 objects:v209 count:16];
                        if (v164)
                        {
                          v165 = v164;
                          v166 = *(void *)v192;
                          do
                          {
                            v167 = 0LL;
                            do
                            {
                              if (*(void *)v192 != v166) {
                                objc_enumerationMutation(obja);
                              }
                              v168 = *(void **)(*((void *)&v191 + 1) + 8 * v167);
                              v169 = objc_alloc_init(&OBJC_CLASS___NEIKEv2CustomPayload);
                              v170 = [v168 customType];
                              if (v169)
                              {
                                v169->_customType = v170;
                                [v168 customData];
                                v171 = (void *)objc_claimAutoreleasedReturnValue();
                                objc_setProperty_atomic(v169, v172, v171, 32LL);
                              }

                              else
                              {
                                [v168 customData];
                                v171 = (void *)objc_claimAutoreleasedReturnValue();
                              }

                              objc_getProperty(v6, v173, 56LL, 1);
                              v174 = (void *)objc_claimAutoreleasedReturnValue();

                              if (v174)
                              {
                                objc_getProperty(v6, v175, 56LL, 1);
                                v176 = (void *)objc_claimAutoreleasedReturnValue();
                                [v176 arrayByAddingObject:v169];
                                v177 = (void *)objc_claimAutoreleasedReturnValue();
                                objc_setProperty_atomic(v6, v178, v177, 56LL);
                              }

                              else
                              {
                                v208 = v169;
                                [MEMORY[0x189603F18] arrayWithObjects:&v208 count:1];
                                v176 = (void *)objc_claimAutoreleasedReturnValue();
                                objc_setProperty_atomic(v6, v179, v176, 56LL);
                              }

                              ++v167;
                            }

                            while (v165 != v167);
                            v180 = [obja countByEnumeratingWithState:&v191 objects:v209 count:16];
                            v165 = v180;
                          }

                          while (v180);
                        }

                        uint64_t v76 = v6;
LABEL_129:
                        v111 = v186;
                        v101 = v188;
                        goto LABEL_143;
                      }

                      ne_log_obj();
                      v107 = (id)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled((os_log_t)v107, OS_LOG_TYPE_FAULT)) {
                        goto LABEL_141;
                      }
                      *(_WORD *)buf = 0;
                      v181 = "[packet addNotification:NEIKEv2NotifyTypeUsePPK] failed";
                    }

                    _os_log_fault_impl(&dword_1876B1000, (os_log_t)v107, OS_LOG_TYPE_FAULT, v181, buf, 2u);
                    goto LABEL_141;
                  }

                  ne_log_obj();
                  v111 = (void *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled((os_log_t)v111, OS_LOG_TYPE_FAULT))
                  {
                    *(_WORD *)buf = 0;
                    v119 = "[packet addNotification:NEIKEv2NotifyTypeIKEv2FragmentationSupported] failed";
                    goto LABEL_73;
                  }
                }

                else
                {
                  ne_log_obj();
                  v111 = (void *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled((os_log_t)v111, OS_LOG_TYPE_FAULT))
                  {
                    *(_WORD *)buf = 0;
                    v119 = "[packet addNotification:NEIKEv2NotifyTypeNATDetectionDestinationIP] failed";
LABEL_73:
                    _os_log_fault_impl(&dword_1876B1000, (os_log_t)v111, OS_LOG_TYPE_FAULT, v119, buf, 2u);
                  }
                }

LABEL_99:
  objc_getProperty(v3, v119, v107[755], 1);
  v193 = (void *)objc_claimAutoreleasedReturnValue();
  v195 = v193;
  if (v193) {
    v193 = objc_getProperty(v193, v194, v114[702], 1);
  }
  v196 = v193;
  objc_setProperty_atomic(v6, v197, v196, 136LL);

  if ((-[NEIKEv2IKESA processPrimaryKeyExchange](*(void *)(a1 + 48), v198) & 1) != 0)
  {
    v200 = *(void **)(a1 + 40);
    v199 = *(void **)(a1 + 48);
    v201 = *(void **)(a1 + 32);
    v257[0] = MEMORY[0x1895F87A8];
    v257[1] = 3221225472LL;
    v257[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_2_416;
    v257[3] = &unk_18A08E790;
    char v43 = &v258;
    v202 = v199;
    v258 = v202;
    v203 = *(id *)(a1 + 56);
    v204 = *(void *)(a1 + 32);
    v205 = *(void **)(a1 + 40);
    v259 = v203;
    v260 = v204;
    v261 = v205;
    -[NEIKEv2Session handleFollowupKEForRekeyIKESAInitiator:rekeyIKEContext:iteration:handler:]( v201,  v202,  v200,  0LL,  v257);

    goto LABEL_118;
  }

  ne_log_obj();
  v233 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v233, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1876B1000, v233, OS_LOG_TYPE_ERROR, "Failed to process KE data (initiate rekey)", buf, 2u);
  }

  unint64_t v40 = objc_alloc(&OBJC_CLASS___NEIKEv2DeleteIKEContext);
  v235 = *(id *)(a1 + 32);
  if (v235) {
    v235 = objc_getProperty(v235, v234, 368LL, 1);
  }
  unint64_t v42 = v235;
  v262[0] = MEMORY[0x1895F87A8];
  v262[1] = 3221225472LL;
  v262[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_413;
  v262[3] = &unk_18A08CF10;
  char v43 = (id *)v263;
  v236 = *(id *)(a1 + 40);
  v237 = *(void *)(a1 + 32);
  v263[0] = v236;
  v263[1] = v237;
  int v46 = v262;
LABEL_117:
  v214 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]( (id *)&v40->super.super.isa,  0,  v42,  v46);

  -[NEIKEv2Session initiateDelete:](*(void **)(a1 + 32), v214);
LABEL_118:
}

        -[NEIKEv2Session processFragment:](self, v7);
        goto LABEL_100;
      }
    }

    ne_log_large_obj();
    uint64_t v60 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v60, OS_LOG_TYPE_ERROR))
    {
      if (self)
      {
        v108 = objc_getProperty(self, v61, 336LL, 1);
        if (v108) {
          v108 = objc_getProperty(v108, v109, 80LL, 1);
        }
      }

      else
      {
        v108 = 0LL;
      }

      v110 = v108;
      else {
        v112 = "Initiator";
      }
      if (self)
      {
        v113 = objc_getProperty(self, v111, 336LL, 1);
        if (v113) {
          v113 = objc_getProperty(v113, v114, 32LL, 1);
        }
        v115 = v12;
        v116 = v113;
        v118 = objc_getProperty(self, v117, 336LL, 1);
        if (v118) {
          v118 = objc_getProperty(v118, v119, 40LL, 1);
        }
        v120 = v116;
      }

      else
      {
        v115 = v12;
        v116 = 0LL;
        v120 = 0LL;
        v118 = 0LL;
      }

      v121 = (char *)v118;
      *(_DWORD *)buf = 138413314;
      v160 = self;
      v161 = 2080;
      *(void *)v162 = v112;
      *(_WORD *)&v162[8] = 2112;
      *(void *)v163 = v120;
      *(_WORD *)&v163[8] = 2112;
      v164 = v121;
      v165 = 2112;
      *(void *)v166 = v7;
      _os_log_error_impl( &dword_1876B1000,  (os_log_t)v60,  OS_LOG_TYPE_ERROR,  "%@ %s ignoring received packet: (Local %@, Remote %@): %@",  buf,  0x34u);

      uint64_t v12 = v115;
    }

    goto LABEL_60;
  }

  ne_log_obj();
  uint64_t v12 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v160 = (NEIKEv2Session *)"-[NEIKEv2Session receivePacket:]";
    _os_log_fault_impl(&dword_1876B1000, (os_log_t)v12, OS_LOG_TYPE_FAULT, "%s called with null packet", buf, 0xCu);
  }

LABEL_100:
        int v3 = 0LL;
        goto LABEL_101;
      }

      int v16 = objc_getProperty((id)a1, v15, 336LL, 1);
      if (v16) {
        int v16 = objc_getProperty(v16, v17, 72LL, 1);
      }
      int v18 = v16;

      if (!v18)
      {
        ne_log_obj();
        id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
          goto LABEL_99;
        }
        *(_DWORD *)buf = 136315138;
        v149 = "-[NEIKEv2Session migrateChildSA:]";
        v118 = "%s called with null self.ikeSA.remoteAddress";
LABEL_90:
        _os_log_fault_impl(&dword_1876B1000, v22, OS_LOG_TYPE_FAULT, v118, buf, 0xCu);
        goto LABEL_99;
      }

      int v20 = objc_getProperty(v9, v19, 56LL, 1);

      ne_log_obj();
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v22 = v21;
      if (!v20)
      {
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
          goto LABEL_99;
        }
        *(_DWORD *)buf = 136315138;
        v149 = "-[NEIKEv2Session migrateChildSA:]";
        v118 = "%s called with null childSA.chosenProposal";
        goto LABEL_90;
      }

      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        unint64_t v24 = objc_getProperty((id)a1, v23, 176LL, 1);
        *(_DWORD *)buf = 138412802;
        v149 = (const char *)a1;
        v150 = 2112;
        v151 = v24;
        v152 = 2112;
        v153 = (os_log_s *)v9;
        _os_log_impl(&dword_1876B1000, v22, OS_LOG_TYPE_INFO, "%@ %@ Migrating childSA %@", buf, 0x20u);
      }

      int v26 = objc_getProperty((id)a1, v25, 192LL, 1);
      uint64_t v28 = objc_getProperty(v9, v27, 56LL, 1);
      int v30 = v28;
      if (v28) {
        uint64_t v28 = objc_getProperty(v28, v29, 80LL, 1);
      }
      unint64_t v31 = v28;
      id v22 = (os_log_s *)-[NEIKEv2Session copySAFromDictionary:forSPI:](v26, v31);

      if (!v22)
      {
        ne_log_obj();
        int v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
        {
          v124 = objc_getProperty(v9, v119, 56LL, 1);
          v126 = v124;
          if (v124) {
            v124 = objc_getProperty(v124, v125, 80LL, 1);
          }
          v127 = (char *)v124;
          v129 = objc_getProperty((id)a1, v128, 192LL, 1);
          v131 = (os_log_s *)objc_getProperty((id)a1, v130, 184LL, 1);
          *(_DWORD *)buf = 138412802;
          v149 = v127;
          v150 = 2112;
          v151 = v129;
          v152 = 2112;
          v153 = v131;
          _os_log_fault_impl( &dword_1876B1000,  v39,  OS_LOG_TYPE_FAULT,  "copySAFromDictionary incoming %@ databaseSAs %@ databaseLarvalSAs %@ failed",  buf,  0x20u);
        }

        id v22 = 0LL;
        goto LABEL_98;
      }

      int v33 = objc_getProperty((id)a1, v32, 192LL, 1);
      uint64_t v35 = objc_getProperty(v9, v34, 56LL, 1);
      uint64_t v37 = v35;
      if (v35) {
        uint64_t v35 = objc_getProperty(v35, v36, 88LL, 1);
      }
      uint64_t v38 = v35;
      int v39 = (os_log_s *)-[NEIKEv2Session copySAFromDictionary:forSPI:](v33, v38);

      if (!v39)
      {
        ne_log_obj();
        v120 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v120, OS_LOG_TYPE_FAULT))
        {
          v132 = objc_getProperty(v9, v121, 56LL, 1);
          v134 = v132;
          if (v132) {
            v132 = objc_getProperty(v132, v133, 88LL, 1);
          }
          v135 = (char *)v132;
          v137 = objc_getProperty((id)a1, v136, 192LL, 1);
          v139 = (os_log_s *)objc_getProperty((id)a1, v138, 184LL, 1);
          *(_DWORD *)buf = 138412802;
          v149 = v135;
          v150 = 2112;
          v151 = v137;
          v152 = 2112;
          v153 = v139;
          _os_log_fault_impl( &dword_1876B1000,  v120,  OS_LOG_TYPE_FAULT,  "copySAFromDictionary outgoing %@ databaseSAs %@ databaseLarvalSAs %@ failed",  buf,  0x20u);
        }

        int v39 = 0LL;
        goto LABEL_97;
      }

      unint64_t v41 = objc_getProperty((id)a1, v40, 336LL, 1);
      if (v41) {
        unint64_t v41 = objc_getProperty(v41, v42, 64LL, 1);
      }
      char v43 = v41;
      -[os_log_s setLocalAddress:](v22, "setLocalAddress:", v43);

      uint64_t v45 = objc_getProperty((id)a1, v44, 336LL, 1);
      if (v45) {
        uint64_t v45 = objc_getProperty(v45, v46, 72LL, 1);
      }
      int64_t v47 = v45;
      -[os_log_s setRemoteAddress:](v22, "setRemoteAddress:", v47);

      uint64_t v49 = objc_getProperty((id)a1, v48, 336LL, 1);
      if (v49) {
        uint64_t v49 = objc_getProperty(v49, v50, 64LL, 1);
      }
      int v51 = v49;
      -[os_log_s setLocalAddress:](v39, "setLocalAddress:", v51);

      uint64_t v53 = objc_getProperty((id)a1, v52, 336LL, 1);
      if (v53) {
        uint64_t v53 = objc_getProperty(v53, v54, 72LL, 1);
      }
      BOOL v55 = v53;
      -[os_log_s setRemoteAddress:](v39, "setRemoteAddress:", v55);

      if (!*(void *)(a1 + 328)) {
        -[NEIKEv2Session addEmptyInterface](a1);
      }
      uint64_t v56 = (void *)-[NEIKEv2Session copyIPsecInterfaceWithMissingAllowed:](a1, 0);
      [v56 interfaceName];
      unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
      -[os_log_s setTunnelInterfaceName:](v39, "setTunnelInterfaceName:", v57);

      -[os_log_s tunnelInterfaceName](v39, "tunnelInterfaceName");
      int v58 = (void *)objc_claimAutoreleasedReturnValue();
      -[os_log_s setTunnelInterfaceName:](v22, "setTunnelInterfaceName:", v58);

      uint64_t v60 = objc_getProperty((id)a1, v59, 336LL, 1);
      if (v60) {
        uint64_t v60 = objc_getProperty(v60, v61, 304LL, 1);
      }
      int v62 = v60;
      -[os_log_s setBoundInterfaceName:](v39, "setBoundInterfaceName:", v62);

      -[os_log_s boundInterfaceName](v39, "boundInterfaceName");
      uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
      -[os_log_s setBoundInterfaceName:](v22, "setBoundInterfaceName:", v63);

      uint64_t v65 = objc_getProperty((id)a1, v64, 336LL, 1);
      if (v65 && (v65[14] & 1) != 0 || (uint64_t v67 = objc_getProperty((id)a1, v66, 336LL, 1)) != 0LL && (v67[15] & 1) != 0)
      {
        if (objc_msgSend(*(id *)(a1 + 384), "disableSwitchToNATTPorts", v141))
        {
          ne_log_obj();
          uint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412290;
            v149 = (const char *)a1;
            uint64_t v69 = v68;
            int v70 = "%@ Not enabling NAT traversal (migrate) because disabled";
            goto LABEL_55;
          }
        }

        else
        {
          -[os_log_s setNatTraversalEnabled:](v22, "setNatTraversalEnabled:", 1LL);
          -[os_log_s setNatTraversalEnabled:](v39, "setNatTraversalEnabled:", 1LL);
          uint64_t v72 = objc_getProperty((id)a1, v71, 336LL, 1);
          if (v72) {
            uint64_t v72 = objc_getProperty(v72, v73, 64LL, 1);
          }
          SEL v74 = v72;
          [v74 port];
          id v75 = (void *)objc_claimAutoreleasedReturnValue();
          -[os_log_s setNatTraversalPort:](v22, "setNatTraversalPort:", (unsigned __int16)[v75 intValue]);

          unint64_t v77 = objc_getProperty((id)a1, v76, 336LL, 1);
          if (v77) {
            unint64_t v77 = objc_getProperty(v77, v78, 72LL, 1);
          }
          uint64_t v79 = v77;
          [v79 port];
          uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();
          -[os_log_s setNatTraversalSrcPort:]( v22,  "setNatTraversalSrcPort:",  (unsigned __int16)[v80 intValue]);

          uint64_t v82 = objc_getProperty((id)a1, v81, 336LL, 1);
          if (v82) {
            uint64_t v82 = objc_getProperty(v82, v83, 72LL, 1);
          }
          uint64_t v84 = v82;
          [v84 port];
          __int16 v85 = (void *)objc_claimAutoreleasedReturnValue();
          -[os_log_s setNatTraversalPort:](v39, "setNatTraversalPort:", (unsigned __int16)[v85 intValue]);

          __int16 v87 = objc_getProperty((id)a1, v86, 336LL, 1);
          if (v87) {
            __int16 v87 = objc_getProperty(v87, v88, 64LL, 1);
          }
          uint64_t v89 = v87;
          [v89 port];
          CFErrorRef v90 = (void *)objc_claimAutoreleasedReturnValue();
          -[os_log_s setNatTraversalSrcPort:]( v39,  "setNatTraversalSrcPort:",  (unsigned __int16)[v90 intValue]);

          ne_log_obj();
          uint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412290;
            v149 = (const char *)a1;
            uint64_t v69 = v68;
            int v70 = "%@ Enabling NAT traversal (migrate)";
            goto LABEL_55;
          }
        }
      }

      else
      {
        -[os_log_s setNatTraversalEnabled:](v22, "setNatTraversalEnabled:", 0LL, v141);
        -[os_log_s setNatTraversalEnabled:](v39, "setNatTraversalEnabled:", 0LL);
        -[os_log_s setNatTraversalPort:](v22, "setNatTraversalPort:", 0LL);
        -[os_log_s setNatTraversalSrcPort:](v22, "setNatTraversalSrcPort:", 0LL);
        -[os_log_s setNatTraversalPort:](v39, "setNatTraversalPort:", 0LL);
        -[os_log_s setNatTraversalSrcPort:](v39, "setNatTraversalSrcPort:", 0LL);
        ne_log_obj();
        uint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412290;
          v149 = (const char *)a1;
          uint64_t v69 = v68;
          int v70 = "%@ Disabling NAT traversal (migrate)";
LABEL_55:
          _os_log_impl(&dword_1876B1000, v69, OS_LOG_TYPE_INFO, v70, buf, 0xCu);
        }
      }

      v92 = objc_getProperty((id)a1, v91, 336LL, 1);
      if (v92 && (v92[14] & 1) != 0)
      {
        v94 = objc_getProperty((id)a1, v93, 336LL, 1);
        if (v94) {
          v94 = objc_getProperty(v94, v95, 88LL, 1);
        }
        v96 = v94;
        v97 = [v96 natTraversalKeepaliveDisabled];

        if ((v97 & 1) == 0)
        {
          -[os_log_s setNatKeepaliveEnabled:](v39, "setNatKeepaliveEnabled:", 1LL);
          v99 = objc_getProperty((id)a1, v98, 336LL, 1);
          if (v99) {
            v99 = objc_getProperty(v99, v100, 88LL, 1);
          }
          v101 = v99;
          v102 = [v101 natTraversalKeepaliveOffloadEnabled];

          if (v102)
          {
            -[os_log_s setNatKeepaliveOffloadEnabled:](v39, "setNatKeepaliveOffloadEnabled:", 1LL);
            v105 = objc_getProperty((id)a1, v104, 336LL, 1);
            if (v105) {
              v105 = objc_getProperty(v105, v106, 88LL, 1);
            }
            v107 = v105;
            -[os_log_s setNatKeepaliveOffloadIntervalSeconds:]( v39,  "setNatKeepaliveOffloadIntervalSeconds:",  [v107 natTraversalKeepaliveOffloadInterval]);
          }

          v108 = objc_getProperty((id)a1, v103, 336LL, 1);
          if (v108) {
            v108 = objc_getProperty(v108, v109, 88LL, 1);
          }
          v110 = v108;
          -[os_log_s setNatKeepaliveIntervalSeconds:]( v39,  "setNatKeepaliveIntervalSeconds:",  [v110 natTraversalKeepaliveInterval]);
        }
      }

      v111 = objc_getProperty((id)a1, v93, 336LL, 1);
      if (v111 && (v111[15] & 1) != 0) {
        -[os_log_s setNatDetectedOnPeer:](v22, "setNatDetectedOnPeer:", 1LL);
      }
      v114 = objc_msgSend(objc_getProperty((id)a1, v112, 176, 1), "migrateSA:", v22);
      if ((v114 & 1) == 0)
      {
        ne_log_large_obj();
        v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
        {
          v117 = objc_getProperty((id)a1, v116, 176LL, 1);
          *(_DWORD *)buf = v141;
          v149 = (const char *)a1;
          v150 = 2112;
          v151 = v117;
          v152 = 2112;
          v153 = v22;
          v154 = 2112;
          v155 = v9;
          _os_log_error_impl( &dword_1876B1000,  v115,  OS_LOG_TYPE_ERROR,  "%@ %@ Failed to migrate incoming SA %@ for %@",  buf,  0x2Au);
        }
      }

      if ((objc_msgSend(objc_getProperty((id)a1, v113, 176, 1), "migrateSA:", v39) & 1) == 0)
      {
        ne_log_large_obj();
        v120 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
        {
          v140 = objc_getProperty((id)a1, v122, 176LL, 1);
          *(_DWORD *)buf = v141;
          v149 = (const char *)a1;
          v150 = 2112;
          v151 = v140;
          v152 = 2112;
          v153 = v39;
          v154 = 2112;
          v155 = v9;
          _os_log_error_impl( &dword_1876B1000,  v120,  OS_LOG_TYPE_ERROR,  "%@ %@ Failed to migrate outgoing SA %@ for %@",  buf,  0x2Au);
        }

LABEL_140:
                      _os_log_fault_impl(&dword_1876B1000, v250, OS_LOG_TYPE_FAULT, v251, buf, 0xCu);
                      goto LABEL_141;
                    }

                    ne_log_obj();
                    v249 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v249, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_fault_impl( &dword_1876B1000,  v249,  OS_LOG_TYPE_FAULT,  "[[NEIKEv2CreateChildPacket alloc] initResponse:] failed",  buf,  2u);
                    }

                    v165 = 0LL;
                  }

                  else
                  {
                    ne_log_obj();
                    v165 = (id)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled((os_log_t)v165, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136315138;
                      *(void *)&void buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:ikeSA:]";
                      _os_log_fault_impl( &dword_1876B1000,  (os_log_t)v165,  OS_LOG_TYPE_FAULT,  "%s called with null ikeSA.chosenProposal",  buf,  0xCu);
                    }
                  }

                  v229 = 0LL;
LABEL_143:

                  if (v229)
                  {
                    v284 = objc_getProperty(v10, v283, 160LL, 1);
                    v285 = v284;
                    if (v284) {
                      v286 = (void *)*((void *)v284 + 3);
                    }
                    else {
                      v286 = 0LL;
                    }
                    v287 = v286;
                    objc_setProperty_atomic(v10, v288, v287, 168LL);

                    objc_setProperty_atomic(v10, v289, 0LL, 160LL);
                    v368[0] = MEMORY[0x1895F87A8];
                    v368[1] = 3221225472LL;
                    v368[2] = __46__NEIKEv2Session_Exchange__receiveRekeyIKESA___block_invoke_439;
                    v368[3] = &unk_18A08D2A8;
                    v369 = v10;
                    v370 = v8;
                    v371 = a1;
                    -[NEIKEv2Session handleFollowupKEForRekeyIKESAResponder:iteration:replyPacket:replyPacketDescription:handler:]( a1,  v369,  0LL,  v229,  @"rekey IKE SA reply",  v368);
                  }

                  else
                  {
                    ne_log_obj();
                    v290 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v290, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_error_impl( &dword_1876B1000,  v290,  OS_LOG_TYPE_ERROR,  "Failed to create Create Child SA packet (receive rekey)",  buf,  2u);
                    }

                    v292 = objc_getProperty(a1, v291, 336LL, 1);
                    ErrorInternal = (void *)NEIKEv2CreateErrorInternal( @"Failed to create Create Child SA packet (receive rekey)",  v293,  v294,  v295,  v296,  v297,  v298,  v299,  v361);
                    -[NEIKEv2IKESA setState:error:]((uint64_t)v292, 3uLL, ErrorInternal);

                    -[NEIKEv2Session reportState](a1, v301);
                    -[NEIKEv2Session resetAll]((uint64_t)a1, v302);
                  }

                  goto LABEL_69;
                }

                ne_log_obj();
                v359 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v359, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl( &dword_1876B1000,  v359,  OS_LOG_TYPE_ERROR,  "Failed to process KE data (receive rekey)",  buf,  2u);
                }

                v244 = objc_getProperty(a1, v360, 336LL, 1);
                v245 = @"Failed to process KE data (receive rekey)";
              }

              else
              {
                ne_log_obj();
                v235 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v235, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl( &dword_1876B1000,  v235,  OS_LOG_TYPE_ERROR,  "Failed to generate local IKE crypto values (receive rekey)",  buf,  2u);
                }

                v244 = objc_getProperty(a1, v236, 336LL, 1);
                v245 = @"Failed to generate local IKE crypto values (receive rekey)";
              }

              ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(v245, v237, v238, v239, v240, v241, v242, v243, v361);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v244, 3uLL, ErrorCrypto);

              -[NEIKEv2Session reportState](a1, v247);
              -[NEIKEv2Session resetAll]((uint64_t)a1, v248);
LABEL_69:

              goto LABEL_70;
            }

            v8[16] = 0;
            if (v102 == 17)
            {
              v230 = objc_getProperty(v10, v159, 96LL, 1);
              v232 = -[NEIKEv2IKESAProposal kemProtocol](v230, v231);
              v233 = bswap32([v232 method]) >> 16;

              *(_WORD *)buf = v233;
              v234 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:buf length:2];
              v118 = +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]( (uint64_t)&OBJC_CLASS___NEIKEv2CreateChildPacket,  v4,  0x11uLL,  v234);
              if (v118)
              {
                goto LABEL_66;
              }

              ne_log_obj();
              v343 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v343, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)v380 = 0;
                _os_log_error_impl( &dword_1876B1000,  v343,  OS_LOG_TYPE_ERROR,  "Failed to create Create Child SA packet (receive rekey)",  v380,  2u);
              }

              goto LABEL_170;
            }

LABEL_170:
            v120 = objc_getProperty(a1, v344, 336LL, 1);
            ErrorFailedToSend = (void *)NEIKEv2CreateErrorInternal( @"Failed to create Create Child SA packet (receive rekey)",  v345,  v346,  v347,  v348,  v349,  v350,  v351,  v361);
            goto LABEL_67;
          }

          ne_log_obj();
          v158 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v158, OS_LOG_TYPE_ERROR))
          {
            v332 = (void *)[v4 copyShortDescription];
            *(_DWORD *)v373 = 138412290;
            v374 = v332;
            _os_log_error_impl( &dword_1876B1000,  v158,  OS_LOG_TYPE_ERROR,  "%@ Did not receive data in KE payload",  v373,  0xCu);
          }

          v147 = @"Did not receive data in KE payload";
        }

        else
        {
          ne_log_obj();
          v157 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
          {
            v312 = (void *)[v4 copyShortDescription];
            *(_DWORD *)v373 = 138412290;
            v374 = v312;
            _os_log_error_impl( &dword_1876B1000,  v157,  OS_LOG_TYPE_ERROR,  "%@ Did not receive method in KE payload",  v373,  0xCu);
          }

          v147 = @"Did not receive method in KE payload";
        }
      }

      else
      {
        ne_log_obj();
        v156 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
        {
          v311 = (void *)[v4 copyShortDescription];
          *(_DWORD *)v373 = 138412290;
          v374 = v311;
          _os_log_error_impl(&dword_1876B1000, v156, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload", v373, 0xCu);
        }

        v147 = @"Did not receive KE payload";
      }
    }

    else
    {
      ne_log_obj();
      v139 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR))
      {
        v273 = (void *)[v4 copyShortDescription];
        *(_DWORD *)v373 = 138412290;
        v374 = v273;
        _os_log_error_impl(&dword_1876B1000, v139, OS_LOG_TYPE_ERROR, "%@ Received no SA proposals", v373, 0xCu);
      }

      v147 = @"Received no SA proposals";
    }

    v100 = (id)NEIKEv2CreateErrorPeerInvalidSyntax(v147, v140, v141, v142, v143, v144, v145, v146, v361);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, v100);
    v101 = 0;
    v102 = 7LL;
    goto LABEL_87;
  }

LABEL_152:
    goto LABEL_153;
  }

  objc_getProperty(v9, v24, 96LL, 1);
  BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_storeWeak(v4 + 41, v25);

  id v27 = -[NEIKEv2IKESA copyResponderIdentifier](v4, v26);
  if (v27)
  {
    uint64_t v29 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ResponderIdentifierPayload);
    objc_setProperty_atomic(v9, v30, v29, 104LL);

    unint64_t v32 = -[NEIKEv2IKESA copyResponderIdentifier](v4, v31);
    objc_getProperty(v9, v33, 104LL, 1);
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    int v36 = v34;
    if (v34) {
      objc_setProperty_atomic(v34, v35, v32, 24LL);
    }

    objc_getProperty(v9, v37, 104LL, 1);
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
    int v39 = -[NEIKEv2Payload isValid]((uint64_t)v38);

    if ((v39 & 1) == 0)
    {
      ne_log_obj();
      v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT))
      {
        buf = 136315138;
        v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
        v101 = "%s called with null packet.idr.isValid";
        goto LABEL_150;
      }

      goto LABEL_152;
    }
  }

  v269 = v4;
  self = v9;
  if ((*((_BYTE *)v4 + 23) & 1) == 0)
  {
    unint64_t v40 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ChildSAPayload);
    objc_setProperty_atomic(v9, v41, v40, 88LL);

    -[NEIKEv2ChildSA configProposalsWithoutKEM](v5, v42);
    char v43 = (void *)objc_claimAutoreleasedReturnValue();
    objc_getProperty(v9, v44, 88LL, 1);
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
    int64_t v47 = v45;
    if (v45) {
      objc_setProperty_atomic(v45, v46, v43, 24LL);
    }

    objc_getProperty(v9, v48, 88LL, 1);
    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v50 = -[NEIKEv2Payload isValid]((uint64_t)v49);

    if ((v50 & 1) == 0)
    {
      ne_log_obj();
      v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT))
      {
        buf = 136315138;
        v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
        v101 = "%s called with null packet.sa.isValid";
        goto LABEL_150;
      }

      goto LABEL_152;
    }

    int v51 = objc_alloc_init(&OBJC_CLASS___NEIKEv2InitiatorTrafficSelectorPayload);
    objc_setProperty_atomic(v9, v52, v51, 160LL);

    -[NEIKEv2ChildSA configuredInitiatorTrafficSelectors](v5, v53);
    int v54 = (void *)objc_claimAutoreleasedReturnValue();
    objc_getProperty(v9, v55, 160LL, 1);
    uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
    int v58 = v56;
    if (v56) {
      objc_setProperty_atomic(v56, v57, v54, 24LL);
    }

    objc_getProperty(v9, v59, 160LL, 1);
    uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v61 = -[NEIKEv2Payload isValid]((uint64_t)v60);

    if ((v61 & 1) == 0)
    {
      ne_log_obj();
      v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT))
      {
        buf = 136315138;
        v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
        v101 = "%s called with null packet.tsi.isValid";
        goto LABEL_150;
      }

      goto LABEL_152;
    }

    int v62 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ResponderTrafficSelectorPayload);
    objc_setProperty_atomic(v9, v63, v62, 168LL);

    -[NEIKEv2ChildSA configuredResponderTrafficSelectors](v5, v64);
    uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue();
    objc_getProperty(v9, v66, 168LL, 1);
    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v69 = v67;
    if (v67) {
      objc_setProperty_atomic(v67, v68, v65, 24LL);
    }

    objc_getProperty(v9, v70, 168LL, 1);
    unint64_t v71 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v72 = -[NEIKEv2Payload isValid]((uint64_t)v71);

    if ((v72 & 1) == 0)
    {
      ne_log_obj();
      v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT))
      {
        buf = 136315138;
        v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
        v101 = "%s called with null packet.tsr.isValid";
        goto LABEL_150;
      }

      goto LABEL_152;
    }

    if (v5) {
      Property = objc_getProperty(v5, v73, 48LL, 1);
    }
    else {
      Property = 0LL;
    }
    id v75 = Property;
    uint64_t v76 = [v75 mode];

    if (v76 == 1 && !-[NEIKEv2Packet addNotification:data:](v9, 0x4007uLL, 0LL))
    {
      ne_log_obj();
      v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
        goto LABEL_152;
      }
      LOWORD(buf) = 0;
      v101 = "[packet addNotification:NEIKEv2NotifyTypeUseTransportMode] failed";
      goto LABEL_187;
    }

    if (!-[NEIKEv2Packet addNotification:data:](v9, 0x400AuLL, 0LL))
    {
      ne_log_obj();
      v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
        goto LABEL_152;
      }
      LOWORD(buf) = 0;
      v101 = "[packet addNotification:NEIKEv2NotifyTypeESPTFCPaddingNotSupported] failed";
      goto LABEL_187;
    }

    if (!-[NEIKEv2Packet addNotification:data:](v9, 0x400BuLL, 0LL))
    {
      ne_log_obj();
      v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
        goto LABEL_152;
      }
      LOWORD(buf) = 0;
      v101 = "[packet addNotification:NEIKEv2NotifyTypeNonFirstFragmentsAlso] failed";
      goto LABEL_187;
    }

    if (v5) {
      unint64_t v78 = objc_getProperty(v5, v77, 48LL, 1);
    }
    else {
      unint64_t v78 = 0LL;
    }
    uint64_t v79 = v78;
    uint64_t v80 = [v79 sequencePerTrafficClass];

    if (v80)
    {
      uint64_t v82 = +[NEIKEv2NotifyPayload createNotifyPayloadType:]();
      v83 = -[NEIKEv2Packet addNotifyPayload:](v9, v82);

      if (!v83)
      {
        ne_log_obj();
        v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
          goto LABEL_152;
        }
        LOWORD(buf) = 0;
        v101 = "[packet addNotifyPayload:notifyPayload] failed";
        goto LABEL_187;
      }
    }

    uint64_t v84 = objc_getProperty(v4, v81, 88LL, 1);
    [v84 configurationRequest];
    __int16 v85 = (void *)objc_claimAutoreleasedReturnValue();

    if (v85)
    {
      __int16 v87 = v5;
      int v88 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ConfigPayload);
      objc_setProperty_atomic(v9, v89, v88, 152LL);

      unint64_t v91 = objc_getProperty(v4, v90, 88LL, 1);
      [v91 configurationRequest];
      v92 = (void *)objc_claimAutoreleasedReturnValue();
      v94 = objc_getProperty(v9, v93, 152LL, 1);
      v96 = v94;
      if (v94) {
        objc_setProperty_atomic(v94, v95, v92, 24LL);
      }

      v98 = objc_getProperty(v9, v97, 152LL, 1);
      v99 = -[NEIKEv2Payload isValid]((uint64_t)v98);

      __int128 v5 = v87;
      if ((v99 & 1) == 0)
      {
        ne_log_obj();
        v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT))
        {
          buf = 136315138;
          v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
          v101 = "%s called with null packet.config.isValid";
LABEL_150:
          v223 = v100;
          v224 = 12;
LABEL_151:
          _os_log_fault_impl(&dword_1876B1000, v223, OS_LOG_TYPE_FAULT, v101, (uint8_t *)&buf, v224);
          goto LABEL_152;
        }

        goto LABEL_152;
      }
    }

LABEL_200:
        v129 = 0LL;
        goto LABEL_201;
      }

      ne_log_obj();
      v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
        goto LABEL_152;
      }
      LOWORD(buf) = 0;
      v101 = "[packet addNotification:NEIKEv2NotifyTypeMOBIKESupported] failed";
    }

    else
    {
      ne_log_obj();
      v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
        goto LABEL_152;
      }
      LOWORD(buf) = 0;
      v101 = "[packet addNotification:NEIKEv2NotifyTypeInitialContact] failed";
    }

LABEL_187:
    v223 = v100;
    v224 = 2;
    goto LABEL_151;
  }

  v104 = objc_getProperty(v4, v28, 88LL, 1);
  [v104 configurationRequest];
  v105 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v105) {
    goto LABEL_77;
  }
  v106 = v5;
  v107 = objc_getProperty(v4, v86, 88LL, 1);
  v108 = [v107 configurationRequest];
  if (!v108)
  {

    v118 = 0LL;
LABEL_76:

    __int128 v5 = v106;
    goto LABEL_77;
  }

  v109 = (void *)v108;
  v110 = objc_alloc_init(MEMORY[0x189603FA8]);
  v284 = 0u;
  v285 = 0u;
  v286 = 0u;
  v287 = 0u;
  v112 = objc_getProperty(v109, v111, 16LL, 1);
  v113 = [v112 countByEnumeratingWithState:&v284 objects:&buf count:16];
  if (v113)
  {
    v114 = v113;
    v115 = *(void *)v285;
    do
    {
      for (j = 0LL; j != v114; ++j)
      {
        if (*(void *)v285 != v115) {
          objc_enumerationMutation(v112);
        }
        v117 = *(void **)(*((void *)&v284 + 1) + 8 * j);
      }

      v114 = [v112 countByEnumeratingWithState:&v284 objects:&buf count:16];
    }

    while (v114);
  }

  if ([v110 count]) {
    v118 = -[NEIKEv2ConfigurationMessage initWithWithAttributes:]( objc_alloc(&OBJC_CLASS___NEIKEv2ConfigurationMessage),  "initWithWithAttributes:",  v110);
  }
  else {
    v118 = 0LL;
  }
  int v4 = v269;
  id v9 = self;

  if (!v118) {
    goto LABEL_76;
  }
  v119 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ConfigPayload);
  objc_setProperty_atomic(self, v120, v119, 152LL);

  v122 = objc_getProperty(self, v121, 152LL, 1);
  v124 = v122;
  if (v122) {
    objc_setProperty_atomic(v122, v123, v118, 24LL);
  }

  v126 = objc_getProperty(self, v125, 152LL, 1);
  v127 = -[NEIKEv2Payload isValid]((uint64_t)v126);

  if ((v127 & 1) != 0) {
    goto LABEL_76;
  }
  ne_log_obj();
  v128 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v128, OS_LOG_TYPE_FAULT))
  {
    buf = 136315138;
    v296 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthForInitiatorIKESA:childSA:]";
    _os_log_fault_impl( &dword_1876B1000,  v128,  OS_LOG_TYPE_FAULT,  "%s called with null packet.config.isValid",  (uint8_t *)&buf,  0xCu);
  }

  v129 = 0LL;
  __int128 v5 = v106;
LABEL_154:

  return v129;
}

    [NSString stringWithFormat:@"%@ is only available for the IKEv2 protocol", v42, v87, v88];
    goto LABEL_188;
  }

LABEL_139:
        goto LABEL_140;
      }

      ne_log_obj();
      uint64_t v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
      {
        v161 = (char *)[a1 copyShortDescription];
        *(_DWORD *)buf = 138412290;
        v259 = v161;
        _os_log_error_impl( &dword_1876B1000,  v80,  OS_LOG_TYPE_ERROR,  "%@ Authentication method for EAP was not shared key",  buf,  0xCu);
      }

      int v88 = (void *)NEIKEv2CreateErrorAuthentication( @"Authentication method for EAP was not shared key",  v81,  v82,  v83,  v84,  v85,  v86,  v87,  v245);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, v88);
LABEL_94:

LABEL_144:
      int v33 = 0LL;
      goto LABEL_145;
    }

    if (v5) {
      uint64_t v67 = objc_getProperty(v5, v44, 456LL, 1);
    }
    else {
      uint64_t v67 = 0LL;
    }
    uint64_t v68 = v67;

    if (v68)
    {
      if ([v40 method] == 12)
      {
        int v70 = -[NEIKEv2IKESA createResponderGSPMAuthenticationDataUsingPrimeKey:]((os_log_s *)v5, (const char *)v19);
        uint64_t v72 = v70;
        if (!v70) {
          goto LABEL_84;
        }
        v252 = v70;
        uint64_t v73 = v20;
        SEL v74 = objc_getProperty(a1, v71, 128LL, 1);
        id v75 = (void *)v74;
        uint64_t v60 = v19;
        uint64_t v76 = v74 ? *(void **)(v74 + 32) : 0LL;
        unint64_t v77 = v76;
        unint64_t v78 = +[NEIKEv2Crypto validateCalculatedSharedKeyAuthData:remoteAuthData:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  v252,  v77);

        int v66 = v73;
        uint64_t v72 = v252;
        if (!v78)
        {
LABEL_84:
          ne_log_obj();
          v132 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR))
          {
            v208 = (char *)[a1 copyShortDescription];
            *(_DWORD *)buf = 138412290;
            v259 = v208;
            _os_log_error_impl( &dword_1876B1000,  v132,  OS_LOG_TYPE_ERROR,  "%@ GSPM authentication data could not be verified",  buf,  0xCu);
          }

          v140 = (void *)NEIKEv2CreateErrorAuthentication( @"GSPM authentication data could not be verified",  v133,  v134,  v135,  v136,  v137,  v138,  v139,  v245);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, v140);

          goto LABEL_144;
        }

        ne_log_obj();
        uint64_t v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_debug_impl(&dword_1876B1000, v79, OS_LOG_TYPE_DEBUG, "Peer GSPM MAC is valid", buf, 2u);
        }

LABEL_104:
        if (!v5)
        {
LABEL_106:
          if ((v66 & 1) == 0)
          {
            if (!v60)
            {
              int v33 = 1LL;
              if (v5) {
                v5[19] = 1;
              }
              goto LABEL_145;
            }

            -[NEIKEv2IKESA restorePrimeKeys](v5, v65);
          }

          int v33 = 1LL;
LABEL_145:
          unint64_t v32 = (os_log_s *)v40;
          goto LABEL_146;
        }

LABEL_105:
        v5[18] = 1;
        goto LABEL_106;
      }

      ne_log_obj();
      v120 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
      {
        v197 = (char *)[a1 copyShortDescription];
        objc_getProperty(a1, v198, 128LL, 1);
        v199 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412546;
        v259 = v197;
        v260 = 2112;
        v261 = v199;
        _os_log_error_impl( &dword_1876B1000,  v120,  OS_LOG_TYPE_ERROR,  "%@ Wrong authentication method %@ for GSPM",  buf,  0x16u);
      }

      objc_getProperty(a1, v121, 128LL, 1);
      int v88 = (void *)objc_claimAutoreleasedReturnValue();
      v129 = (void *)NEIKEv2CreateErrorAuthentication( @"Wrong authentication method %@ for GSPM",  v122,  v123,  v124,  v125,  v126,  v127,  v128,  (uint64_t)v88);
LABEL_93:
      v150 = v129;
      -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, v129);

      goto LABEL_94;
    }

    v251 = v20;
    -[NEIKEv2IKESA remoteAuthentication](v5, v69);
    uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue();
    CFErrorRef v90 = +[NEIKEv2Crypto isRemoteAuthenticationPacketProtocol:compatibleWithConfiguredProtocol:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  v40,  v89);

    if ((v90 & 1) == 0)
    {
      ne_log_obj();
      v141 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
      {
        v209 = (char *)[a1 copyShortDescription];
        v211 = -[NEIKEv2IKESA remoteAuthentication](v5, v210);
        *(_DWORD *)buf = 138412802;
        v259 = v209;
        v260 = 2112;
        v261 = (os_log_s *)v40;
        v262 = 2112;
        v263 = v211;
        _os_log_error_impl( &dword_1876B1000,  v141,  OS_LOG_TYPE_ERROR,  "%@ Initiator packet authentication method %@ is not compatible with configuration %@",  buf,  0x20u);
      }

      -[NEIKEv2IKESA remoteAuthentication](v5, v142);
      int v88 = (void *)objc_claimAutoreleasedReturnValue();
      v129 = (void *)NEIKEv2CreateErrorAuthentication( @"Packet authentication method %@ is not compatible with configuration %@",  v143,  v144,  v145,  v146,  v147,  v148,  v149,  (uint64_t)v40);
      goto LABEL_93;
    }

    unint64_t v32 = (os_log_s *)v40;
    v92 = -[NEIKEv2IKESA remoteAuthentication](v5, v91);
    v93 = [v92 isNonStandard];

    v95 = v32;
    if (v93)
    {
      -[NEIKEv2IKESA remoteAuthentication](v5, v94);
      v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    }

    v252 = v95;
    v249 = v19;
    if (!-[os_log_s isSignature](v95, "isSignature"))
    {
      v154 = objc_getProperty(a1, v96, 128LL, 1);
      v155 = (void *)v154;
      if (v154) {
        v156 = *(void **)(v154 + 32);
      }
      else {
        v156 = 0LL;
      }
      v157 = v156;
      v158 = -[NEIKEv2IKESA checkSharedKeyAuthData:usingPrimeKey:]((uint64_t)v5, v157, (const char *)v249);

      ne_log_obj();
      v159 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v79 = v159;
      if ((v158 & 1) == 0)
      {
        if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
        {
          v230 = (char *)[a1 copyShortDescription];
          *(_DWORD *)buf = 138412546;
          v259 = v230;
          v260 = 2112;
          v261 = v252;
          _os_log_error_impl( &dword_1876B1000,  v79,  OS_LOG_TYPE_ERROR,  "%@ Initiator failed to validate remote authentication data %@",  buf,  0x16u);
        }

        v162 = v252;
        uint64_t v79 = (os_log_s *)NEIKEv2CreateErrorAuthentication( @"Failed to validate remote authentication data %@",  v163,  v164,  v165,  v166,  v167,  v168,  v169,  (uint64_t)v252);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, v79);
        int v33 = 0LL;
        goto LABEL_159;
      }

      if (os_log_type_enabled(v159, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl(&dword_1876B1000, v79, OS_LOG_TYPE_DEBUG, "Peer PSK MAC is valid", buf, 2u);
      }

      goto LABEL_103;
    }

    if (v5) {
      v97 = objc_getProperty(v5, v96, 88LL, 1);
    }
    else {
      v97 = 0LL;
    }
    v98 = v97;
    v99 = (__SecKey *)-[NEIKEv2SessionConfiguration copyRemoteAuthKey](v98);

    if (v99)
    {
LABEL_70:
      uint64_t v79 = (os_log_s *)-[NEIKEv2IKESA createRemoteSignedOctetsUsingPrimeKey:]((uint64_t)v5, (const char *)v249);
      v102 = objc_getProperty(a1, v101, 128LL, 1);
      v103 = (void *)v102;
      if (v102) {
        v104 = *(void **)(v102 + 32);
      }
      else {
        v104 = 0LL;
      }
      v105 = v104;
      v106 = +[NEIKEv2Crypto validateSignature:signedData:authProtocol:publicKey:]( (uint64_t)&OBJC_CLASS___NEIKEv2Crypto,  v105,  v79,  v252,  v99);

      CFRelease(v99);
      if ((v106 & 1) == 0)
      {
        if (v5) {
          v108 = objc_getProperty(v5, v107, 88LL, 1);
        }
        else {
          v108 = 0LL;
        }
        v109 = v108;
        int v33 = [v109 disableRemoteCertificateValidation];

        if ((_DWORD)v33)
        {
          ne_log_obj();
          v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v117, OS_LOG_TYPE_INFO))
          {
            v118 = (char *)[a1 copyShortDescription];
            *(_DWORD *)buf = 138412290;
            v259 = v118;
            _os_log_impl( &dword_1876B1000,  v117,  OS_LOG_TYPE_INFO,  "%@ Passing authentication because configuration does not require remote signature validation",  buf,  0xCu);
          }

          v119 = v252;
        }

        else
        {
          v119 = v252;
          v117 = (os_log_s *)NEIKEv2CreateErrorAuthentication( @"Authentication data could not be verified %@",  v110,  v111,  v112,  v113,  v114,  v115,  v116,  (uint64_t)v252);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, v117);
        }

        v162 = v119;
        goto LABEL_159;
      }

                              uint64_t v14 = (os_log_s *)v81;
                              int64_t v47 = v77;
                              int v46 = v78;

                              uint64_t v73 = 0LL;
                              goto LABEL_106;
                            }

                            if (!v54
                              || (uint64_t v59 = objc_getProperty(v54, v58, 48LL, 1)) == 0LL
                              || (uint64_t v61 = v59, v62 = objc_getProperty(v59, v60, 16LL, 1), v61, !v62))
                            {
                              ne_log_obj();
                              SEL v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
                              {
                                *(_WORD *)uint64_t v84 = 0;
                                id v75 = "Fragment missing decrypted data";
LABEL_110:
                                _os_log_fault_impl(&dword_1876B1000, v74, OS_LOG_TYPE_FAULT, v75, v84, 2u);
                              }

                              goto LABEL_105;
                            }

                            uint64_t v64 = objc_getProperty(v54, v63, 48LL, 1);
                            int v66 = v64;
                            if (v64) {
                              uint64_t v67 = objc_getProperty(v64, v65, 16LL, 1);
                            }
                            else {
                              uint64_t v67 = 0LL;
                            }
                            objc_msgSend(v48, "appendData:", v67, v77, v78);

                            ++v53;
                          }

                          while (v51 != v53);
                          uint64_t v68 = -[os_log_s countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v85,  buf,  16LL);
                          int v51 = v68;
                          int64_t v47 = v77;
                          int v46 = v78;
                        }

                        while (v68);
                      }

                      if (v47)
                      {
                        int v70 = objc_getProperty(v47, v69, 48LL, 1);
                        if (v70)
                        {
                          uint64_t v72 = v70;
                          objc_setProperty_atomic(v70, v71, v48, 16LL);
                        }
                      }

                      else {
                        uint64_t v73 = 0LL;
                      }
                      uint64_t v14 = (os_log_s *)v81;
LABEL_106:

                      goto LABEL_107;
                    }

                    ne_log_obj();
                    int64_t v47 = (_BYTE *)objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled((os_log_t)v47, OS_LOG_TYPE_FAULT))
                    {
LABEL_101:
                      uint64_t v73 = 0LL;
                      uint64_t v14 = (os_log_s *)v81;
LABEL_107:

                      [a1 receivePacket:v73];
                      goto LABEL_108;
                    }

                    *(_DWORD *)buf = 136315138;
                    CFErrorRef v90 = "+[NEIKEv2Packet createPacketFromReceivedFragments:ikeSA:]";
                    uint64_t v76 = "%s called with null ikeSA";
                  }

                  else
                  {
                    ne_log_obj();
                    int64_t v47 = (_BYTE *)objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled((os_log_t)v47, OS_LOG_TYPE_FAULT)) {
                      goto LABEL_101;
                    }
                    *(_DWORD *)buf = 136315138;
                    CFErrorRef v90 = "+[NEIKEv2Packet createPacketFromReceivedFragments:ikeSA:]";
                    uint64_t v76 = "%s called with null receivedFragments";
                  }

                  _os_log_fault_impl(&dword_1876B1000, (os_log_t)v47, OS_LOG_TYPE_FAULT, v76, buf, 0xCu);
                  goto LABEL_101;
                }
              }

              ne_log_obj();
              uint64_t v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 138412802;
                CFErrorRef v90 = (const char *)a1;
                unint64_t v91 = 1024;
                v92 = (unsigned __int16)v40;
                v93 = 1024;
                v94 = v23;
                _os_log_fault_impl( &dword_1876B1000,  v73,  OS_LOG_TYPE_FAULT,  "%@ Missing fragment %u/%u, skipping reassembly",  buf,  0x18u);
              }

LABEL_103:
      uint64_t v60 = v249;
      int v66 = v251;
      goto LABEL_104;
    }

    objc_getProperty(a1, v100, 112LL, 1);
    v170 = (void *)objc_claimAutoreleasedReturnValue();
    v171 = [v170 count];

    if (!v171)
    {
      ne_log_obj();
      v200 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v200, OS_LOG_TYPE_ERROR))
      {
        v243 = (char *)[a1 copyShortDescription];
        *(_DWORD *)buf = 138412290;
        v259 = v243;
        _os_log_error_impl(&dword_1876B1000, v200, OS_LOG_TYPE_ERROR, "%@ No certificate payload received", buf, 0xCu);
      }

      uint64_t v79 = (os_log_s *)NEIKEv2CreateErrorAuthentication( @"No certificate payload received",  v201,  v202,  v203,  v204,  v205,  v206,  v207,  v245);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, v79);
      int v33 = 0LL;
      v162 = v252;
      goto LABEL_159;
    }

    v248 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
    if (v248)
    {
      v255 = 0u;
      v256 = 0u;
      v253 = 0u;
      v254 = 0u;
      objc_getProperty(a1, v172, 112LL, 1);
      obj = (id)objc_claimAutoreleasedReturnValue();
      v173 = [obj countByEnumeratingWithState:&v253 objects:v257 count:16];
      if (v173)
      {
        v175 = v173;
        v247 = *(void *)v254;
        while (2)
        {
          v176 = 0LL;
          do
          {
            if (*(void *)v254 != v247) {
              objc_enumerationMutation(obj);
            }
            v177 = *(void **)(*((void *)&v253 + 1) + 8 * v176);
            if (v177) {
              v178 = objc_getProperty(*(id *)(*((void *)&v253 + 1) + 8 * v176), v174, 32LL, 1);
            }
            else {
              v178 = 0LL;
            }
            v179 = v178;

            if (!v179)
            {
              ne_log_obj();
              v212 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR))
              {
                v244 = (char *)[a1 copyShortDescription];
                *(_DWORD *)buf = 138412290;
                v259 = v244;
                _os_log_error_impl(&dword_1876B1000, v212, OS_LOG_TYPE_ERROR, "%@ Certificate missing data", buf, 0xCu);
              }

              v220 = (void *)NEIKEv2CreateErrorAuthentication( @"Certificate missing data",  v213,  v214,  v215,  v216,  v217,  v218,  v219,  v245);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, v220);

              int v33 = 0LL;
              v162 = v252;
              uint64_t v79 = v248;
              ErrorInternal = (os_log_s *)obj;
              goto LABEL_158;
            }

            if (v177) {
              v181 = objc_getProperty(v177, v180, 32LL, 1);
            }
            else {
              v181 = 0LL;
            }
            v182 = v181;
            -[os_log_s addObject:](v248, "addObject:", v182);

            ++v176;
          }

          while (v175 != v176);
          v183 = [obj countByEnumeratingWithState:&v253 objects:v257 count:16];
          v175 = v183;
          if (v183) {
            continue;
          }
          break;
        }
      }

      uint64_t v79 = v248;
      v184 = -[NEIKEv2IKESA checkValidityOfCertificates:](v5, v248);
      if (v184)
      {
        v99 = v184;

        goto LABEL_70;
      }

      ne_log_obj();
      v231 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v162 = v252;
      if (os_log_type_enabled(v231, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl( &dword_1876B1000,  v231,  OS_LOG_TYPE_ERROR,  "Certificate chain could not be verified",  buf,  2u);
      }

      if (v5) {
        v233 = objc_getProperty(v5, v232, 88LL, 1);
      }
      else {
        v233 = 0LL;
      }
      v234 = v233;
      int v33 = [v234 disableRemoteCertificateValidation];

      if ((_DWORD)v33)
      {
        ne_log_obj();
        ErrorInternal = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v33 = 1LL;
        if (os_log_type_enabled(ErrorInternal, OS_LOG_TYPE_INFO))
        {
          v242 = (char *)[a1 copyShortDescription];
          *(_DWORD *)buf = 138412290;
          v259 = v242;
          _os_log_impl( &dword_1876B1000,  ErrorInternal,  OS_LOG_TYPE_INFO,  "%@ Passing authentication because configuration does not require certificate validation",  buf,  0xCu);
        }
      }

      else
      {
        ErrorInternal = (os_log_s *)NEIKEv2CreateErrorAuthentication( @"Certificate chain could not be verified",  v235,  v236,  v237,  v238,  v239,  v240,  v241,  v245);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, ErrorInternal);
      }
    }

    else
    {
      ne_log_obj();
      v222 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v162 = v95;
      if (os_log_type_enabled(v222, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_1876B1000, v222, OS_LOG_TYPE_FAULT, "[[NSMutableArray alloc] init] failed", buf, 2u);
      }

      ErrorInternal = (os_log_s *)NEIKEv2CreateErrorInternal( @"[[NSMutableArray alloc] init] failed",  v223,  v224,  v225,  v226,  v227,  v228,  v229,  v245);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, ErrorInternal);
      int v33 = 0LL;
      uint64_t v79 = 0LL;
    }

LABEL_104:
              v147 = objc_getProperty((id)a1, v121, 336LL, 1);
              if (v147 && (v147[14] & 1) != 0)
              {
                v149 = objc_getProperty((id)a1, v148, 336LL, 1);
                if (v149) {
                  v149 = objc_getProperty(v149, v150, 88LL, 1);
                }
                v151 = v149;
                v152 = [v151 natTraversalKeepaliveDisabled];

                if ((v152 & 1) == 0)
                {
                  -[os_log_s setNatKeepaliveEnabled:](v24, "setNatKeepaliveEnabled:", 1LL);
                  v154 = objc_getProperty((id)a1, v153, 336LL, 1);
                  if (v154) {
                    v154 = objc_getProperty(v154, v155, 88LL, 1);
                  }
                  v156 = v154;
                  v157 = [v156 natTraversalKeepaliveOffloadEnabled];

                  if (v157)
                  {
                    -[os_log_s setNatKeepaliveOffloadEnabled:](v24, "setNatKeepaliveOffloadEnabled:", 1LL);
                    v160 = objc_getProperty((id)a1, v159, 336LL, 1);
                    if (v160) {
                      v160 = objc_getProperty(v160, v161, 88LL, 1);
                    }
                    v162 = v160;
                    -[os_log_s setNatKeepaliveOffloadIntervalSeconds:]( v24,  "setNatKeepaliveOffloadIntervalSeconds:",  [v162 natTraversalKeepaliveOffloadInterval]);
                  }

                  v163 = objc_getProperty((id)a1, v158, 336LL, 1);
                  if (v163) {
                    v163 = objc_getProperty(v163, v164, 88LL, 1);
                  }
                  v165 = v163;
                  -[os_log_s setNatKeepaliveIntervalSeconds:]( v24,  "setNatKeepaliveIntervalSeconds:",  [v165 natTraversalKeepaliveInterval]);
                }
              }

              v166 = objc_getProperty((id)a1, v148, 336LL, 1);
              if (v166 && (v166[15] & 1) != 0) {
                -[os_log_s setNatDetectedOnPeer:](v22, "setNatDetectedOnPeer:", 1LL);
              }
              v168 = objc_getProperty((id)a1, v167, 336LL, 1);
              if (v168) {
                v168 = objc_getProperty(v168, v169, 304LL, 1);
              }
              v170 = v168;
              -[os_log_s setBoundInterfaceName:](v24, "setBoundInterfaceName:", v170);

              if (!*(void *)(a1 + 328)) {
                -[NEIKEv2Session addEmptyInterface](a1);
              }
              v171 = (void *)-[NEIKEv2Session copyIPsecInterfaceWithMissingAllowed:](a1, 0);
              [v171 interfaceName];
              v172 = (void *)objc_claimAutoreleasedReturnValue();
              -[os_log_s setTunnelInterfaceName:](v24, "setTunnelInterfaceName:", v172);

              objc_setProperty_atomic(v4, v174, 0LL, 160LL);
              objc_setProperty_atomic(v4, v175, 0LL, 168LL);
              -[os_log_s setEncryptionKey:](v24, "setEncryptionKey:", 0LL);
              -[os_log_s setAuthenticationKey:](v24, "setAuthenticationKey:", 0LL);
              objc_msgSend(objc_getProperty((id)a1, v176, 192, 1), "setObject:forKeyedSubscript:", v4, v24);
              objc_setProperty_atomic(v4, v178, 0LL, 144LL);
              objc_setProperty_atomic(v4, v179, 0LL, 152LL);
              -[os_log_s setEncryptionKey:](v22, "setEncryptionKey:", 0LL);
              -[os_log_s setAuthenticationKey:](v22, "setAuthenticationKey:", 0LL);
              objc_msgSend(objc_getProperty((id)a1, v180, 192, 1), "setObject:forKeyedSubscript:", v4, v22);
              objc_msgSend(objc_getProperty((id)a1, v181, 184, 1), "setObject:forKeyedSubscript:", 0, v22);
              v183 = objc_getProperty((id)a1, v182, 336LL, 1);
              if (v183) {
                v183 = objc_getProperty(v183, v184, 88LL, 1);
              }
              v185 = v183;
              v186 = [v185 idleTimeoutEnabled];

              if (v186)
              {
                v188 = objc_getProperty((id)a1, v187, 176LL, 1);
                v190 = objc_getProperty((id)a1, v189, 336LL, 1);
                if (v190) {
                  v190 = objc_getProperty(v190, v191, 88LL, 1);
                }
                v192 = v190;
                objc_msgSend( v188,  "startIdleTimeout:incomingSA:outgoingSA:",  objc_msgSend(v192, "idleTimeoutSeconds"),  v22,  v24);
              }

              v193 = objc_getProperty((id)a1, v187, 336LL, 1);
              if (v193) {
                v193 = objc_getProperty(v193, v194, 88LL, 1);
              }
              v195 = v193;
              v196 = [v195 blackholeDetectionEnabled];

              BOOL v55 = 1LL;
              if (v196) {
                objc_msgSend( objc_getProperty((id)a1, v197, 176, 1),  "startBlackholeDetection:incomingSA:outgoingSA:",  20,  v22,  v24);
              }
              break;
            default:
              ne_log_obj();
              uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled((os_log_t)v60, OS_LOG_TYPE_ERROR)) {
                goto LABEL_147;
              }
              uint64_t v61 = (char *)objc_getProperty(v4, v101, 56LL, 1);
              v103 = -[NEIKEv2ChildSAProposal integrityProtocol](v61, v102);
              v104 = [v103 type];
              v206 = 138412546;
              v207 = (const char *)a1;
              v208 = 1024;
              LODWORD(v209) = v104;
              v105 = "%@ Unsupported integrity type %u";
              v106 = (os_log_s *)v60;
              v107 = 18;
LABEL_140:
              _os_log_error_impl(&dword_1876B1000, v106, OS_LOG_TYPE_ERROR, v105, (uint8_t *)&v206, v107);

              goto LABEL_141;
          }

          goto LABEL_149;
        }

        if (v52 == 12)
        {
          uint64_t v64 = objc_getProperty(v4, v53, 56LL, 1);
          -[NEIKEv2ChildSAProposal encryptionProtocol](v64, v65);
          int v66 = (_BYTE *)objc_claimAutoreleasedReturnValue();
          if (!v66)
          {

            uint64_t v52 = 4LL;
            goto LABEL_65;
          }

          uint64_t v67 = v66[8];

          uint64_t v68 = (v67 & 1) == 0;
          uint64_t v69 = 4;
LABEL_62:
          if (v68) {
            uint64_t v52 = v69;
          }
          else {
            uint64_t v52 = v69 + 1;
          }
          goto LABEL_65;
        }
      }

      else
      {
        if (v52 <= 29)
        {
          if (v52 != 20)
          {
            if (v52 == 28)
            {
              uint64_t v52 = 8LL;
              goto LABEL_65;
            }

            goto LABEL_146;
          }

          int v70 = objc_getProperty(v4, v53, 56LL, 1);
          -[NEIKEv2ChildSAProposal encryptionProtocol](v70, v71);
          uint64_t v72 = (_BYTE *)objc_claimAutoreleasedReturnValue();
          if (!v72)
          {

            uint64_t v52 = 6LL;
            goto LABEL_65;
          }

          uint64_t v73 = v72[8];

          uint64_t v68 = (v73 & 1) == 0;
          uint64_t v69 = 6;
          goto LABEL_62;
        }

        if (v52 == 30)
        {
          SEL v74 = objc_getProperty(v4, v53, 56LL, 1);
          -[NEIKEv2ChildSAProposal encryptionProtocol](v74, v75);
          uint64_t v76 = (_BYTE *)objc_claimAutoreleasedReturnValue();
          if (!v76)
          {

            uint64_t v52 = 10LL;
            goto LABEL_65;
          }

          unint64_t v77 = v76[8];

          uint64_t v68 = (v77 & 1) == 0;
          uint64_t v69 = 10;
          goto LABEL_62;
        }

        if (v52 == 31)
        {
          uint64_t v52 = 9LL;
          goto LABEL_65;
        }
      }
    }

    else
    {
    }

LABEL_158:
LABEL_159:
    goto LABEL_146;
  }

  unint64_t v19 = v5[24] & 1;
  int v20 = 1;
  if ((v5[24] & 1) == 0 || (a3 & 1) != 0) {
    goto LABEL_28;
  }
  if ((-[NEIKEv2Packet hasNotification:](a1, (const char *)0x4034) & 1) != 0)
  {
    int v20 = 0;
    unint64_t v19 = 0LL;
    goto LABEL_28;
  }

  unint64_t v19 = 1LL;
  uint64_t v34 = objc_getProperty(v5, v18, 88LL, 1);
  uint64_t v35 = [v34 ppkMandatory];

  if (!v35)
  {
    int v20 = 0;
    goto LABEL_28;
  }

  ne_log_obj();
  int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    v196 = (char *)[a1 copyShortDescription];
    *(_DWORD *)buf = 138412290;
    v259 = v196;
    _os_log_error_impl( &dword_1876B1000,  v36,  OS_LOG_TYPE_ERROR,  "%@ No PPK ID notify received with mandatory PPK auth",  buf,  0xCu);
  }

  uint64_t v29 = @"No PPK ID received with mandatory PPK auth";
LABEL_22:
  unint64_t v32 = (os_log_s *)NEIKEv2CreateErrorAuthentication(v29, v22, v23, v24, v25, v26, v27, v28, v245);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, v32);
  int v33 = 0LL;
LABEL_146:

  return v33;
}

LABEL_153:
                        v174 = v254;
                        id v27 = v255;
LABEL_154:

                        v113 = 1LL;
                        goto LABEL_92;
                      }

                      v178 = objc_getProperty((id)v7, v177, 80LL, 1);
                      v179 = [v178 requestPPK];

                      if ((v179 & 1) != 0)
                      {
                        *(_BYTE *)(v7 + 24) = 1;
                        ne_log_obj();
                        v180 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v180, OS_LOG_TYPE_INFO))
                        {
                          v181 = (char *)[a1 copyShortDescription];
                          *(_DWORD *)buf = 138412290;
                          v261 = v181;
                          v182 = "%@ PPK use requested";
LABEL_128:
                          _os_log_impl(&dword_1876B1000, v180, OS_LOG_TYPE_INFO, v182, buf, 0xCu);
                        }
                      }

                      else
                      {
                        ne_log_obj();
                        v180 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v180, OS_LOG_TYPE_INFO))
                        {
                          v181 = (char *)[a1 copyShortDescription];
                          *(_DWORD *)buf = 138412290;
                          v261 = v181;
                          v182 = "%@ PPK use requested but PPK use is not configured";
                          goto LABEL_128;
                        }
                      }

                      goto LABEL_130;
                    }

                    ne_log_obj();
                    v143 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR))
                    {
                      v224 = (char *)[a1 copyShortDescription];
                      *(_DWORD *)buf = 138412290;
                      v261 = v224;
                      _os_log_error_impl( &dword_1876B1000,  v143,  OS_LOG_TYPE_ERROR,  "%@ Did not receive NONCE data",  buf,  0xCu);
                    }

                    v141 = @"Did not receive NONCE data";
                  }

                  else
                  {
                    ne_log_obj();
                    v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
                    {
                      v223 = (char *)[a1 copyShortDescription];
                      *(_DWORD *)buf = 138412290;
                      v261 = v223;
                      _os_log_error_impl( &dword_1876B1000,  v133,  OS_LOG_TYPE_ERROR,  "%@ Did not receive NONCE payload",  buf,  0xCu);
                    }

                    v141 = @"Did not receive NONCE payload";
                  }

                  v102 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax( v141,  v134,  v135,  v136,  v137,  v138,  v139,  v140,  v250);
LABEL_104:
                  v144 = v102;
                  -[NEIKEv2IKESA setState:error:](v7, 3uLL, v102);
LABEL_105:

                  goto LABEL_91;
                }

                ne_log_obj();
                v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                id v27 = v255;
                if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
                {
                  v210 = (char *)[a1 copyShortDescription];
                  objc_getProperty(a1, v211, 104LL, 1);
                  v212 = (void *)objc_claimAutoreleasedReturnValue();
                  v214 = v212;
                  if (v212) {
                    v212 = objc_getProperty(v212, v213, 24LL, 1);
                  }
                  v215 = v212;
                  v217 = [v215 method];
                  if (v7) {
                    v218 = objc_getProperty((id)v7, v216, 96LL, 1);
                  }
                  else {
                    v218 = 0LL;
                  }
                  v219 = v218;
                  v221 = -[NEIKEv2IKESAProposal kemProtocol](v219, v220);
                  v222 = [v221 method];
                  *(_DWORD *)buf = 138412802;
                  v261 = v210;
                  v262 = 2048;
                  v263 = v217;
                  v264 = 2048;
                  v265 = v222;
                  _os_log_error_impl( &dword_1876B1000,  v129,  OS_LOG_TYPE_ERROR,  "%@ Received KE method %zu does not match KE method %zu in SA proposal",  buf,  0x20u);

                  id v27 = v255;
                }

                if (a3)
                {
                  v113 = 0LL;
                  *a3 = 17LL;
                  goto LABEL_92;
                }

void sub_18777F324(_Unwind_Exception *a1)
{
}

LABEL_167:
LABEL_168:
  }

  else
  {
    ne_log_obj();
    v141 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1876B1000, v141, OS_LOG_TYPE_ERROR, "IKE SA payload missing required fields", buf, 2u);
    }
  }

  return 0;
}

LABEL_128:
  id v2 = v114;
  if (v114)
  {
    objc_setProperty_atomic(v114, v112, v7, 16LL);

    goto LABEL_3;
  }

  Property = 0LL;
  return Property != 0LL;
}

LABEL_81:
            int v4 = v92;
            goto LABEL_75;
          }

          v98 = 0LL;
LABEL_62:
          a1 = v100;
          objc_setProperty_atomic(v100, v66, v60, 72LL);
          int v4 = v92;
          int v51 = v98;
          goto LABEL_63;
        }
      }

      BOOL v55 = [v17 length];
      unint64_t v57 = objc_getProperty(v4, v56, 208LL, 1);
    }

    else
    {
      BOOL v55 = [v17 length];
      unint64_t v57 = 0LL;
    }

    int v58 = v57;
    int v30 = -[NEIKEv2Packet constructHeadersForNextPayloadType:payloadsLength:fragmentNumber:totalFragments:securityContext:]( (uint64_t)a1,  v16,  v55,  0,  0,  v58);

    if (!v30)
    {
LABEL_70:

      goto LABEL_71;
    }

    uint64_t v60 = v30;
    if (v4) {
      uint64_t v61 = objc_getProperty(v4, v59, 208LL, 1);
    }
    else {
      uint64_t v61 = 0LL;
    }
    int v62 = v61;
    [v62 constructEncryptedPacketFromPayloadData:v17 authenticatedHeaders:v60];
    uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v63)
    {

      int v51 = (os_log_s *)v60;
      goto LABEL_75;
    }

    v107 = v63;
    [MEMORY[0x189603F18] arrayWithObjects:&v107 count:1];
    uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
    objc_setProperty_atomic(a1, v65, v64, 72LL);

    int v51 = (os_log_s *)v60;
LABEL_63:

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
LABEL_69:

      int v30 = objc_getProperty(a1, v88, 72LL, 1);
      goto LABEL_70;
    }

    uint64_t v82 = objc_alloc_init(&OBJC_CLASS___NEIKEv2EncryptedPayload);
    uint64_t v52 = v82;
    if (v82)
    {
      objc_setProperty_atomic(v82, v83, v17, 16LL);
      objc_setProperty_atomic(v52, v84, v51, 24LL);
      v52->_nextPayload = v16;
    }

    objc_setProperty_atomic(a1, v83, v52, 48LL);
    -[NEIKEv2IntermediatePacket authenticatedData](a1, v85);
    int v86 = (void *)objc_claimAutoreleasedReturnValue();

    if (v86)
    {
      objc_setProperty_atomic(a1, v87, 0LL, 48LL);
LABEL_68:

      goto LABEL_69;
    }

    ne_log_obj();
    CFErrorRef v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl( &dword_1876B1000,  v90,  OS_LOG_TYPE_ERROR,  "Failed to get authenticated data for IKE_INTERMEDIATE",  buf,  2u);
    }

LABEL_75:
    goto LABEL_76;
  }

  int v30 = objc_getProperty(a1, v3, 72LL, 1);
LABEL_71:

  return v30;
}

          unint64_t v31 = 0;
        }

void sub_187790E0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t __Block_byref_object_copy__11387(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__11388(uint64_t a1)
{
}

void sub_1877917A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
}

void sub_18779395C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
}

void sub_187793E8C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_187796C54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id *a12, id *a13, id *location, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,id a58)
{
}

uint64_t NEIKEv2PacketTunnelProviderGetSocket( void *a1, uint64_t a2, unsigned __int8 *a3, unsigned __int8 *a4, void *a5)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  id v9 = a1;
  uint64_t v30 = 0LL;
  unint64_t v31 = &v30;
  uint64_t v32 = 0x2020000000LL;
  int v33 = -1;
  if (objc_getProperty(v9, v10, 160LL, 1))
  {
    ne_log_obj();
    CFStringRef v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v35 = "NEIKEv2PacketTunnelProviderGetSocket";
      _os_log_error_impl( &dword_1876B1000,  v11,  OS_LOG_TYPE_ERROR,  "%s: A previous call is in progress, ignore",  buf,  0xCu);
    }

void sub_187797108( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_80:
          goto LABEL_81;
        }

        id v18 = objc_getProperty(WeakRetained, v16, 128LL, 1);
        if (v18) {
          id v18 = objc_getProperty(v18, v19, 16LL, 1);
        }
        uint64_t v82 = v13;
        v83 = v18;
        objc_msgSend(MEMORY[0x189608DF8], "endpointWithHostname:port:");
        int v20 = (void *)objc_claimAutoreleasedReturnValue();
        dispatch_time_t v21 = dispatch_semaphore_create(0LL);
        ne_log_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          *(void *)&uint8_t buf[4] = WeakRetained;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v20;
          _os_log_impl( &dword_1876B1000,  v22,  OS_LOG_TYPE_DEFAULT,  "%@: setting up companion proxy datapath to %@",  buf,  0x16u);
        }

        -[NEIKEv2PacketTunnelProvider invalidateCompanionProxyDatapath](WeakRetained, v23);
        unint64_t v24 = objc_alloc(&OBJC_CLASS___NEIKEv2CompanionDatapath);
        uint64_t v84 = v20;
        dsema = v21;
        objc_initWeak(location, WeakRetained);
        if (v24)
        {
          *(void *)buf = v24;
          *(void *)&uint8_t buf[8] = &OBJC_CLASS___NEIKEv2CompanionDatapath;
          BOOL v25 = (id *)objc_msgSendSuper2((objc_super *)buf, sel_init);
          if (v25)
          {
            if (NEIKEv2CompanionDatapathCopyQueue_onceToken != -1) {
              dispatch_once(&NEIKEv2CompanionDatapathCopyQueue_onceToken, &__block_literal_global_268);
            }
            objc_storeStrong(v25 + 9, (id)NEIKEv2CompanionDatapathCopyQueue_queue);
            do
              int v26 = __ldxr(&initWithRemoteEndpoint_completionSemaphore_provider__sNEIKEv2CmpnDatapathID);
            while (__stxr(v26 + 1, &initWithRemoteEndpoint_completionSemaphore_provider__sNEIKEv2CmpnDatapathID));
            v25[2] = (id)v26;
            *((_DWORD *)v25 + 3) = 0;
            objc_storeStrong(v25 + 7, v20);
            id v27 = (void *)MEMORY[0x189608DF8];
            uint64_t v28 = v25[7];
            [v28 port];
            char v29 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v30 = [v27 endpointWithHostname:@"::" port:v29];
            unint64_t v31 = v25[8];
            v25[8] = (id)v30;

            objc_storeStrong(v25 + 10, v21);
            uint64_t v32 = objc_loadWeakRetained(location);
            objc_storeWeak(v25 + 11, v32);
          }

          else
          {
            ne_log_obj();
            uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)v94 = 0;
              _os_log_fault_impl(&dword_1876B1000, (os_log_t)v32, OS_LOG_TYPE_FAULT, "[super init] failed", v94, 2u);
            }

            BOOL v25 = 0LL;
          }
        }

        else
        {
          BOOL v25 = 0LL;
        }

        objc_destroyWeak(location);

        objc_setProperty_atomic(WeakRetained, v33, v25, 232LL);
        uint64_t v35 = (os_unfair_lock_s *)objc_getProperty(WeakRetained, v34, 232LL, 1);
        __int16 v36 = (uint64_t)v35;
        if (v35)
        {
          id v37 = v35 + 3;
          os_unfair_lock_lock(v35 + 3);
          if (*(void *)(v36 + 56))
          {
            if (!*(_BYTE *)(v36 + 9))
            {
              *(_BYTE *)(v36 + 9) = 1;
              -[NEIKEv2CompanionDatapath setupConnectionLocked](v36);
            }
          }

          else
          {
            ne_log_obj();
            __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_1876B1000, v38, OS_LOG_TYPE_FAULT, "invalid remote endpoint", buf, 2u);
            }
          }

          os_unfair_lock_unlock(v37);
        }

        int v39 = dispatch_time(0x8000000000000000LL, 10000000000LL);
        if (dispatch_semaphore_wait(dsema, v39))
        {
          ne_log_obj();
          unint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            uint64_t v80 = objc_getProperty(WeakRetained, v42, 232LL, 1);
            *(_DWORD *)buf = 138412546;
            *(void *)&uint8_t buf[4] = WeakRetained;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v80;
            _os_log_error_impl( &dword_1876B1000,  v41,  OS_LOG_TYPE_ERROR,  "%@: timed out waiting for socket from %@",  buf,  0x16u);
          }

          Socket = -1;
LABEL_76:

          uint64_t v13 = v82;
          goto LABEL_77;
        }

        char v43 = (os_unfair_lock_s *)objc_getProperty(WeakRetained, v40, 232LL, 1);
        uint64_t v45 = v43;
        if (v43)
        {
          os_unfair_lock_lock(v43 + 3);
          if (BYTE1(v45[2]._os_unfair_lock_opaque) == 2)
          {
            connected_socket = nw_connection_get_connected_socket();
            Socket = dup(connected_socket);
            os_unfair_lock_unlock(v45 + 3);
            if ((Socket & 0x80000000) == 0)
            {
LABEL_48:
              int64_t v47 = (os_unfair_lock_s *)objc_getProperty(WeakRetained, v44, 232LL, 1);
              uint64_t v49 = v47;
              if (v47)
              {
                os_unfair_lock_lock(v47 + 3);
                uint64_t v50 = *(id *)&v49[10]._os_unfair_lock_opaque;
                int v51 = v50;
                if (BYTE1(v49[2]._os_unfair_lock_opaque) == 3)
                {

                  int v51 = 0LL;
                }

                os_unfair_lock_unlock(v49 + 3);
              }

              else
              {
                int v51 = 0LL;
              }

              uint64_t v52 = objc_getProperty(WeakRetained, v48, 128LL, 1);
              if (v52) {
                objc_setProperty_atomic(v52, v53, v51, 64LL);
              }

              BOOL v55 = objc_getProperty(WeakRetained, v54, 128LL, 1);
              unint64_t v57 = objc_getProperty(WeakRetained, v56, 128LL, 1);
              if (v57) {
                unint64_t v57 = objc_getProperty(v57, v58, 64LL, 1);
              }
              uint64_t v59 = v57;
              uint64_t v61 = objc_getProperty(WeakRetained, v60, 208LL, 1);
              -[NEIKEv2Server setServerResolvedAddress:path:](v55, v59, v61);

              uint64_t v63 = (os_unfair_lock_s *)objc_getProperty(WeakRetained, v62, 232LL, 1);
              uint64_t v64 = v63;
              if (v63)
              {
                os_unfair_lock_lock(v63 + 3);
                uint64_t v65 = (os_log_s *)*(id *)&v64[12]._os_unfair_lock_opaque;
                unint64_t v41 = v65;
                if (BYTE1(v64[2]._os_unfair_lock_opaque) == 3)
                {

                  unint64_t v41 = 0LL;
                }

                os_unfair_lock_unlock(v64 + 3);
              }

              else
              {
                unint64_t v41 = 0LL;
              }

              if (-[os_log_s count](v41, "count"))
              {
                v92 = 0u;
                v93 = 0u;
                *(_OWORD *)location = 0u;
                unint64_t v91 = 0u;
                unint64_t v41 = v41;
                uint64_t v67 = -[os_log_s countByEnumeratingWithState:objects:count:]( v41,  "countByEnumeratingWithState:objects:count:",  location,  buf,  16LL);
                if (v67)
                {
                  uint64_t v68 = *(void *)v91;
                  do
                  {
                    for (CFIndex i = 0LL; i != v67; ++i)
                    {
                      if (*(void *)v91 != v68) {
                        objc_enumerationMutation(v41);
                      }
                      int v70 = (void *)*((void *)location[1] + i);
                      unint64_t v71 = objc_getProperty(WeakRetained, v66, 128LL, 1);
                      if (v71) {
                        unint64_t v71 = objc_getProperty(v71, v72, 64LL, 1);
                      }
                      uint64_t v73 = v71;
                      SEL v74 = [v70 isEqualToString:v73];

                      if ((v74 & 1) == 0)
                      {
                        id v75 = objc_getProperty(WeakRetained, v66, 128LL, 1);
                        unint64_t v77 = objc_getProperty(WeakRetained, v76, 208LL, 1);
                        -[NEIKEv2Server setServerResolvedAddress:path:](v75, v70, v77);
                      }
                    }

                    uint64_t v67 = -[os_log_s countByEnumeratingWithState:objects:count:]( v41,  "countByEnumeratingWithState:objects:count:",  location,  buf,  16LL);
                  }

                  while (v67);
                }
              }

              goto LABEL_76;
            }
          }

          else
          {
            os_unfair_lock_unlock(v45 + 3);
            Socket = -1;
          }

          ne_log_obj();
          unint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            int v81 = objc_getProperty(WeakRetained, v78, 232LL, 1);
            *(_DWORD *)buf = 138412546;
            *(void *)&uint8_t buf[4] = WeakRetained;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v81;
            _os_log_error_impl(&dword_1876B1000, v41, OS_LOG_TYPE_ERROR, "%@: invalid socket from %@", buf, 0x16u);
          }

          goto LABEL_76;
        }

        Socket = 0;
        goto LABEL_48;
      }
    }

    int v86 = 0LL;
    if (a5) {
      goto LABEL_5;
    }
    goto LABEL_9;
  }

  Socket = -1;
LABEL_81:

  return Socket;
}

void sub_187797AB4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void NEIKEv2PacketTunnelHandleConnected(void *a1)
{
  uint64_t v117 = *MEMORY[0x1895F89C0];
  uint64_t v103 = 0LL;
  v104 = &v103;
  uint64_t v105 = 0x3032000000LL;
  v106 = __Block_byref_object_copy__11387;
  v107 = __Block_byref_object_dispose__11388;
  self = a1;
  id v108 = self;
  ne_log_obj();
  uint64_t v1 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = self[21];
    uint64_t v3 = &stru_18A0915E8;
    *(_DWORD *)buf = 138412802;
    if ((~v2 & 0xF) == 0) {
      uint64_t v3 = @"Connected with Config";
    }
    *(void *)&uint8_t buf[4] = self;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v3;
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v114) = v2;
    _os_log_impl(&dword_1876B1000, v1, OS_LOG_TYPE_DEFAULT, "%@: Tunnel flags - %@ <%X>", buf, 0x1Cu);
  }

  if ((~self[21] & 0xF) != 0) {
    goto LABEL_35;
  }
  id v5 = objc_getProperty(self, v4, 88LL, 1);
  if (!v5) {
    goto LABEL_29;
  }
  unint64_t v7 = v5;
  id v8 = objc_getProperty(self, v6, 96LL, 1);
  if (!v8)
  {
LABEL_28:

    goto LABEL_29;
  }

  SEL v10 = v8;
  id v11 = objc_getProperty(self, v9, 104LL, 1);
  if (!v11)
  {

    goto LABEL_28;
  }

  uint64_t v12 = v11;
  [self protocolConfiguration];
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  BOOL v14 = v13 == 0LL;

  if (v14) {
    goto LABEL_29;
  }
  id v16 = objc_getProperty(self, v15, 128LL, 1);
  id Property = objc_getProperty(self, v17, 208LL, 1);
  v95 = -[NEIKEv2Server getViableServerAddressForPath:](v16, Property);
  v96 = -[NETunnelNetworkSettings initWithTunnelRemoteAddress:]( objc_alloc(&OBJC_CLASS___NEPacketTunnelNetworkSettings),  "initWithTunnelRemoteAddress:",  v95);
  id v20 = objc_getProperty(self, v19, 88LL, 1);
  objc_opt_self();
  id v21 = objc_alloc_init(MEMORY[0x189603FA8]);
  id v98 = objc_alloc_init(MEMORY[0x189603FA8]);
  __int128 v111 = 0u;
  __int128 v112 = 0u;
  __int128 v109 = 0u;
  __int128 v110 = 0u;
  id v22 = v20;
  uint64_t v23 = [v22 countByEnumeratingWithState:&v109 objects:buf count:16];
  if (!v23) {
    goto LABEL_24;
  }
  uint64_t v24 = *(void *)v110;
  do
  {
    uint64_t v25 = 0LL;
    do
    {
      if (*(void *)v110 != v24) {
        objc_enumerationMutation(v22);
      }
      int v26 = *(void **)(*((void *)&v109 + 1) + 8 * v25);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        [v26 address];
        id v27 = (void *)objc_claimAutoreleasedReturnValue();
        [v27 hostname];
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
        [v21 addObject:v28];

LABEL_18:
        goto LABEL_19;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        [v26 stringValue];
        id v27 = (void *)objc_claimAutoreleasedReturnValue();
        [v98 addObject:v27];
        goto LABEL_18;
      }

void sub_18779AC50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
}

void __NEIKEv2PacketTunnelHandleConnected_block_invoke(uint64_t a1)
{
}

void __NEIKEv2PacketTunnelHandleConnected_block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v4 = a2;
  uint64_t v5 = *(void *)(a1 + 32);
  id Property = *(dispatch_queue_s **)(*(void *)(v5 + 8) + 40LL);
  if (v4)
  {
    if (Property)
    {
      id Property = (dispatch_queue_s *)objc_getProperty(Property, v3, 264LL, 1);
      uint64_t v5 = *(void *)(a1 + 32);
    }

    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __NEIKEv2PacketTunnelHandleConnected_block_invoke_3;
    block[3] = &unk_18A08D4E0;
    block[4] = v5;
    dispatch_async(Property, block);
  }

  else
  {
    -[dispatch_queue_s setReasserting:](Property, "setReasserting:", 0LL);
    -[NEIKEv2PacketTunnelProvider invokeStartTunnelCompletionHandler:]( *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL),  0LL);
    ne_log_obj();
    unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8LL);
      uint64_t v10 = *(void *)(v9 + 40);
      if (v10) {
        id v11 = objc_getProperty(*(id *)(v9 + 40), v8, 208LL, 1);
      }
      else {
        id v11 = 0LL;
      }
      [v11 scopedInterface];
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
      id v14 = *(id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
      if (v13)
      {
        if (v14) {
          id v14 = objc_getProperty(v14, v12, 208LL, 1);
        }
        id v15 = v14;
        [v15 scopedInterface];
        id v16 = (void *)objc_claimAutoreleasedReturnValue();
      }

      else
      {
        if (v14) {
          id v14 = objc_getProperty(v14, v12, 208LL, 1);
        }
        id v15 = v14;
        [v15 interface];
        id v16 = (void *)objc_claimAutoreleasedReturnValue();
      }

      SEL v17 = v16;
      [v16 interfaceName];
      id v18 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412546;
      uint64_t v21 = v10;
      __int16 v22 = 2112;
      uint64_t v23 = v18;
      _os_log_impl(&dword_1876B1000, v7, OS_LOG_TYPE_DEFAULT, "%@: Tunnel Status: UP - (scoped to %@)", buf, 0x16u);
    }
  }
}

void __NEIKEv2PacketTunnelHandleConnected_block_invoke_3(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  ne_log_obj();
  int v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
    *(_DWORD *)buf = 138412290;
    uint64_t v9 = v6;
    _os_log_error_impl( &dword_1876B1000,  v2,  OS_LOG_TYPE_ERROR,  "%@: Stopping tunnel due to set tunnel network settings failed",  buf,  0xCu);
  }

  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(*(void *)(v3 + 8) + 40LL);
  if (v4)
  {
    *(_BYTE *)(v4 + 77) = 1;
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v5 = *(_BYTE **)(*(void *)(v3 + 8) + 40LL);
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  CFErrorRef v7[2] = __NEIKEv2PacketTunnelHandleConnected_block_invoke_300;
  v7[3] = &unk_18A08D4E0;
  v7[4] = v3;
  -[NEIKEv2PacketTunnelProvider stopIKEv2TunnelWithReason:completionHandler:](v5, 9LL, v7);
}

void __NEIKEv2PacketTunnelHandleConnected_block_invoke_300(uint64_t a1)
{
}

void sub_18779B93C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_18779BE24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void __NEIKEv2CompanionDatapathCopyQueue_block_invoke()
{
  int v2 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
  dispatch_queue_t v0 = dispatch_queue_create("Companion proxy datapath queue", v2);
  uint64_t v1 = (void *)NEIKEv2CompanionDatapathCopyQueue_queue;
  NEIKEv2CompanionDatapathCopyQueue_queue = (uint64_t)v0;
}

void __NEIKEv2PacketTunnelProviderGetSocket_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  ne_log_obj();
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (*(_BYTE *)(a1 + 48)) {
      uint64_t v6 = "IKE";
    }
    else {
      uint64_t v6 = "PFKEY";
    }
    int v14 = 136315650;
    id v15 = "NEIKEv2PacketTunnelProviderGetSocket_block_invoke";
    __int16 v16 = 2112;
    uint64_t v17 = v5;
    __int16 v18 = 2080;
    SEL v19 = v6;
    _os_log_impl( &dword_1876B1000,  v4,  OS_LOG_TYPE_INFO,  "%s: %@: completion handler invoked for %s socket request",  (uint8_t *)&v14,  0x20u);
  }

  if (v3)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = dup([v3 fileDescriptor]);
    ne_log_obj();
    id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      int v10 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      int v14 = 136315650;
      id v15 = "NEIKEv2PacketTunnelProviderGetSocket_block_invoke";
      __int16 v16 = 2112;
      uint64_t v17 = v9;
      __int16 v18 = 1024;
      LODWORD(v19) = v10;
      _os_log_impl(&dword_1876B1000, v8, OS_LOG_TYPE_INFO, "%s: %@: Got socket %d", (uint8_t *)&v14, 0x1Cu);
    }

    close([v3 fileDescriptor]);
  }

  id v11 = *(void **)(a1 + 32);
  if (v11 && objc_getProperty(v11, v7, 160LL, 1))
  {
    id Property = *(dispatch_semaphore_s **)(a1 + 32);
    if (Property) {
      id Property = (dispatch_semaphore_s *)objc_getProperty(Property, v12, 160LL, 1);
    }
    dispatch_semaphore_signal(Property);
  }
}

void __NEIKEv2PacketTunnelProviderCopyQueue_block_invoke()
{
  int v2 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
  dispatch_queue_t v0 = dispatch_queue_create("NEIKEv2PacketTunnelProvider Queue", v2);
  uint64_t v1 = (void *)NEIKEv2PacketTunnelProviderCopyQueue_queue;
  NEIKEv2PacketTunnelProviderCopyQueue_queue = (uint64_t)v0;
}

void sub_18779E378( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id location)
{
}

void sub_18779E954( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id location)
{
}

__int128 *ne_loopback_protocol_get_id()
{
  if (ne_loopback_protocol_get_id_protocolOnce != -1) {
    dispatch_once(&ne_loopback_protocol_get_id_protocolOnce, &__block_literal_global_12009);
  }
  return &g_identifier;
}

void __ne_loopback_protocol_get_id_block_invoke()
{
  xmmword_18C6E3B48 = 0u;
  unk_18C6E3B58 = 0u;
  xmmword_18C6E3B28 = 0u;
  unk_18C6E3B38 = 0u;
  xmmword_18C6E3B08 = 0u;
  *(_OWORD *)&qword_18C6E3B18 = 0u;
  xmmword_18C6E3AE8 = 0u;
  unk_18C6E3AF8 = 0u;
  xmmword_18C6E3AC8 = 0u;
  unk_18C6E3AD8 = 0u;
  xmmword_18C6E3AA8 = 0u;
  *(_OWORD *)&qword_18C6E3AB8 = 0u;
  xmmword_18C6E3A88 = 0u;
  unk_18C6E3A98 = 0u;
  xmmword_18C6E3A68 = 0u;
  unk_18C6E3A78 = 0u;
  g_callbacks = 0u;
  qword_18C6E3B88 = 0LL;
  g_identifier = 0u;
  unk_18C6E3B78 = 0u;
  __strlcpy_chk();
  qword_18C6E3B88 = 0x100000004LL;
  nw_protocol_set_default_one_to_one_callbacks();
  *(void *)&g_callbacks = ne_loopback_add_input_handler;
  *((void *)&g_callbacks + 1) = ne_loopback_remove_input_handler;
  *(void *)&xmmword_18C6E3AA8 = ne_loopback_get_input_frames;
  *((void *)&xmmword_18C6E3AA8 + 1) = ne_loopback_get_output_frames;
  qword_18C6E3AB8 = (uint64_t)ne_loopback_finalize_output_frames;
  *(void *)&xmmword_18C6E3B08 = ne_loopback_supports_external_data;
  qword_18C6E3B18 = (uint64_t)ne_loopback_output_finished;
  qword_18C6E3A80 = (uint64_t)ne_loopback_connected;
  *((void *)&xmmword_18C6E3A88 + 1) = ne_loopback_error;
  *((void *)&xmmword_18C6E3A68 + 1) = ne_loopback_connect;
  unk_18C6E3A78 = ne_loopback_disconnect;
  if ((nw_protocol_register_extended() & 1) == 0)
  {
    ne_log_obj();
    dispatch_queue_t v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v1 = 0;
      _os_log_error_impl( &dword_1876B1000,  v0,  OS_LOG_TYPE_ERROR,  "Failed to register the np_tunnel_flow protocol",  v1,  2u);
    }
  }

uint64_t ne_loopback_add_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  *(void *)(a2 + 32) = a1;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = a2;
  if (v2) {
    id v3 = (unsigned __int8 *)(v2 + 40);
  }
  else {
    id v3 = 0LL;
  }
  uuid_copy(v3, (const unsigned __int8 *)a2);
  return 1LL;
}

BOOL ne_loopback_remove_input_handler(void *a1, uint64_t a2, int a3)
{
  *(void *)(a2 + 32) = 0LL;
  uint64_t v4 = a1[6];
  if (v4 == a2)
  {
    a1[6] = 0LL;
    uint64_t v7 = a1[4];
    if (v7) {
      (*(void (**)(void))(*(void *)(v7 + 24) + 8LL))();
    }
    if (a3)
    {
      id v8 = (void *)a1[5];
      a1[5] = 0LL;
    }
  }

  return v4 == a2;
}

uint64_t ne_loopback_get_input_frames( uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!*(void *)(a1 + 40)) {
    return 0LL;
  }
  uint64_t v24 = 0LL;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2020000000LL;
  int v27 = 0;
  nw_frame_array_init();
  if (!a4 || !a5)
  {
    ne_log_obj();
    id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = a5;
      LOWORD(v29) = 1024;
      *(_DWORD *)((char *)&v29 + 2) = a4;
      uint64_t v9 = "Maximum frame count (%u) and/or maximum byte count (%u) is 0";
      int v10 = buf;
      uint64_t v13 = v8;
      uint32_t v14 = 14;
      goto LABEL_28;
    }

    goto LABEL_8;
  }

  if (nw_frame_array_is_empty())
  {
    ne_log_obj();
    id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      uint64_t v9 = "No input data currently available";
      int v10 = buf;
LABEL_15:
      uint64_t v13 = v8;
      uint32_t v14 = 2;
LABEL_28:
      _os_log_debug_impl(&dword_1876B1000, v13, OS_LOG_TYPE_DEBUG, v9, v10, v14);
      goto LABEL_8;
    }

    goto LABEL_8;
  }

  *(void *)buf = MEMORY[0x1895F87A8];
  uint64_t v29 = 3221225472LL;
  uint64_t v30 = __90__NELoopbackConnection_addInputFramesToArray_maximumBytes_minimumBytes_maximumFrameCount___block_invoke;
  unint64_t v31 = &unk_18A08D760;
  uint64_t v32 = &v24;
  nw_frame_array_foreach();
  if (*((_DWORD *)v25 + 6) < a3)
  {
    ne_log_obj();
    id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      __int16 v23 = 0;
      uint64_t v9 = "Not enough data available to meet the required minimum";
      int v10 = (uint8_t *)&v23;
      goto LABEL_15;
    }

void sub_1877A1A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t ne_loopback_get_output_frames(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5) {
    return 0LL;
  }
  nw_frame_array_init();
  uint64_t result = 0LL;
  if (a4 && a5)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = *(void *)(v5 + 128);
    while (1)
    {
      unint64_t v11 = *(void *)(v5 + 8 + 8 * v10);
      size_t v12 = v11 >= a4 ? a4 : v11;
      if (!malloc(v12)) {
        break;
      }
      nw_frame_create();
      nw_frame_array_append();
      uint64_t v13 = *(void *)(v5 + 128);
      if (v13 == 3) {
        uint64_t v10 = 0LL;
      }
      else {
        uint64_t v10 = v13 + 1;
      }
      *(void *)(v5 + 12_Block_object_dispose(va, 8) = v10;
      a4 -= v12;
      uint64_t result = (v9 + 1);
      if (a4) {
        BOOL v14 = a5 - 1 == (_DWORD)v9;
      }
      else {
        BOOL v14 = 1;
      }
      uint64_t v9 = (v9 + 1);
      if (v14) {
        return result;
      }
    }

    return v9;
  }

  return result;
}

uint64_t ne_loopback_finalize_output_frames(uint64_t a1)
{
  id v1 = *(id *)(a1 + 40);
  nw_frame_array_foreach();
  -[NELoopbackConnection notifyInputHandler](v1, v2);

  return 1LL;
}

uint64_t ne_loopback_supports_external_data(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 48) + 24LL) + 176LL))();
}

void ne_loopback_output_finished(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  id v1 = *(id *)(a1 + 40);
  uint64_t v6 = v1;
  if (v1)
  {
    ne_log_obj();
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = v6[17];
      *(_DWORD *)buf = 134218240;
      uint64_t v8 = v3;
      __int16 v9 = 1024;
      int v10 = nw_frame_array_unclaimed_length();
      _os_log_impl( &dword_1876B1000,  v2,  OS_LOG_TYPE_DEFAULT,  "Loopback received output finished with %llu bytes received, current input bytes %u",  buf,  0x12u);
    }

    id v1 = v6;
    uint64_t v4 = v6[11];
    if (v4)
    {
      uint64_t v5 = *(void (**)(void))(*(void *)(v4 + 24) + 184LL);
      if (v5)
      {
        v5();
        id v1 = v6;
      }
    }
  }

  -[NELoopbackConnection notifyInputHandler](v1, (const char *)v1);
}

uint64_t ne_loopback_connected(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 32) == a2) {
    return (*(uint64_t (**)(void))(*(void *)(*(void *)(result + 48) + 24LL) + 40LL))();
  }
  return result;
}

uint64_t ne_loopback_error(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 48);
    if (result) {
      return (*(uint64_t (**)(void))(*(void *)(result + 24) + 56LL))();
    }
  }

  return result;
}

uint64_t ne_loopback_connect(uint64_t a1)
{
  id v1 = *(id *)(a1 + 40);
  uint64_t v3 = v1;
  if (v1) {
    objc_getProperty(v1, v2, 120LL, 1);
  }
  uint64_t v6 = v3;
  id v4 = v3;
  nw_queue_context_async();

  return 1LL;
}

void ne_loopback_disconnect(uint64_t a1)
{
  id v1 = *(id *)(a1 + 40);
  uint64_t v3 = v1;
  if (v1) {
    objc_getProperty(v1, v2, 120LL, 1);
  }
  uint64_t v5 = v3;
  id v4 = v3;
  nw_queue_context_async();
}

char *ne_loopback_protocol_create(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  if (ne_loopback_protocol_get_id_protocolOnce != -1) {
    dispatch_once(&ne_loopback_protocol_get_id_protocolOnce, &__block_literal_global_12009);
  }
  if (nw_protocols_are_equal())
  {
    uint64_t v6 = (void *)nw_parameters_copy_context();
    uint64_t v7 = objc_alloc(&OBJC_CLASS___NELoopbackConnection);
    id v8 = v6;
    if (v7
      && (v13.receiver = v7,
          v13.super_class = (Class)&OBJC_CLASS___NELoopbackConnection,
          (__int16 v9 = (char *)objc_msgSendSuper2(&v13, sel_init)) != 0))
    {
      int v10 = v9;
      *(_OWORD *)(v9 + _Block_object_dispose(va, 8) = xmmword_187873240;
      *(_OWORD *)(v9 + 24) = xmmword_187873250;
      *(_OWORD *)(v9 + 40) = 0u;
      uint64_t v11 = v9 + 40;
      *(_OWORD *)(v9 + 56) = 0u;
      *(_OWORD *)(v9 + 72) = 0u;
      *(_OWORD *)(v9 + 8_Block_object_dispose(va, 8) = 0u;
      *((void *)v9 + 7) = &g_identifier;
      *((void *)v9 + _Block_object_dispose(va, 8) = &g_callbacks;
      objc_storeStrong((id *)v9 + 15, v6);
      nw_frame_array_init();

      *((void *)v10 + 10) = v10;
    }

    else
    {

      uint64_t v11 = 0LL;
    }
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  return v11;
}

uint64_t __ne_loopback_disconnect_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    uint64_t v2 = v1 + 40;
  }
  else {
    uint64_t v2 = 0LL;
  }
  uint64_t result = *(void *)(v2 + 48);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 24) + 48LL))();
  }
  return result;
}

uint64_t __ne_loopback_connect_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    uint64_t v2 = v1 + 40;
  }
  else {
    uint64_t v2 = 0LL;
  }
  uint64_t result = *(void *)(v2 + 48);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 24) + 40LL))();
  }
  return result;
}

uint64_t __ne_loopback_finalize_output_frames_block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1LL;
}

void ne_loopback_output_frame_finalizer(void *a1, int a2, uint64_t a3)
{
  if (a2)
  {
    if (a3)
    {
      id v4 = a1;
      *(void *)(a3 + 136) += nw_frame_unclaimed_length();
      nw_frame_get_buffer();
      nw_frame_reset();
      nw_frame_array_append();
    }
  }

  else
  {
    ne_loopback_input_frame_finalizer(a1);
  }

void ne_loopback_input_frame_finalizer(void *a1)
{
  id v1 = a1;
  buffer = (void *)nw_frame_get_buffer();
  nw_frame_reset();

  free(buffer);
}

LABEL_101:
}

  return v3;
}

void sub_1877A5DD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

__CFString *NEIKEv2RequestContextTypeString(unsigned int a1)
{
  if (a1 >= 8) {
    return (__CFString *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"Unknown(%lld)", a1);
  }
  else {
    return off_18A08D958[a1];
  }
}

void sub_1877A95E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id location)
{
}

void sub_1877A9B28( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

__CFString *NEIKEv2CreateSessionStateString(unint64_t a1)
{
  if (a1 >= 5) {
    return (__CFString *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"Unknown(%lld)", a1);
  }
  else {
    return off_18A08D930[a1];
  }
}

void sub_1877AB4F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void sub_1877AC0B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id *location)
{
  if (v13) {
    objc_destroyWeak(location);
  }
  objc_destroyWeak((id *)(v14 - 136));
  _Unwind_Resume(a1);
}

void sub_1877AD0E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_1877AD424(_Unwind_Exception *a1)
{
}

void sub_1877AD538(_Unwind_Exception *a1)
{
}

LABEL_146:
    ne_log_obj();
    SEL v60 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v60, OS_LOG_TYPE_ERROR))
    {
      v201 = objc_getProperty(v4, v200, 56LL, 1);
      v203 = -[NEIKEv2ChildSAProposal encryptionProtocol](v201, v202);
      v204 = (void *)v203;
      if (v203) {
        v203 = *(void *)(v203 + 16);
      }
      String = NEIKEv2EncryptionWireTypeCreateString(v203);
      v206 = 138412546;
      v207 = (const char *)a1;
      v208 = 2112;
      v209 = String;
      _os_log_error_impl( &dword_1876B1000,  (os_log_t)v60,  OS_LOG_TYPE_ERROR,  "%@ Unsupported encryption wire type %@",  (uint8_t *)&v206,  0x16u);
    }

    goto LABEL_147;
  }

  ne_log_obj();
  __int16 v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
  {
    v206 = 136315138;
    v207 = "-[NEIKEv2Session installChildSA:]";
    int v54 = "%s called with null childSA.chosenProposal";
    goto LABEL_42;
  }

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionReceiveIntervalTriggerReporting")
    && !NEGetValueWithType(v5, @"DeadPeerDetectionReceiveIntervalTriggerReporting", CFNUMBER_TYPE))
  {
    ne_log_obj();
    id v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    v251 = 1024;
    v252 = 1554;
    v253 = 2112;
    v254 = @"DeadPeerDetectionReceiveIntervalTriggerReporting";
    v255 = 2048;
    v256 = CFNUMBER_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionReceiveIntervalTriggerReporting"))
  {
    -[os_log_s objectForKeyedSubscript:]( v5,  "objectForKeyedSubscript:",  @"DeadPeerDetectionReceiveIntervalTriggerReporting");
    uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setDeadPeerDetectionReceiveIntervalTriggerReporting:]( v2,  "setDeadPeerDetectionReceiveIntervalTriggerReporting:",  [v72 unsignedLongValue]);
  }

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionReceiveMaxShortDPDBeforeReporting")
    && !NEGetValueWithType(v5, @"DeadPeerDetectionReceiveMaxShortDPDBeforeReporting", CFNUMBER_TYPE))
  {
    ne_log_obj();
    id v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    v251 = 1024;
    v252 = 1559;
    v253 = 2112;
    v254 = @"DeadPeerDetectionReceiveMaxShortDPDBeforeReporting";
    v255 = 2048;
    v256 = CFNUMBER_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionReceiveMaxShortDPDBeforeReporting"))
  {
    -[os_log_s objectForKeyedSubscript:]( v5,  "objectForKeyedSubscript:",  @"DeadPeerDetectionReceiveMaxShortDPDBeforeReporting");
    uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setDeadPeerDetectionReceiveMaxShortDPDBeforeReporting:]( v2,  "setDeadPeerDetectionReceiveMaxShortDPDBeforeReporting:",  [v73 unsignedIntValue]);
  }

  if (CFDictionaryContainsKey(v5, @"IdleTimeoutEnabled")
    && !NEGetValueWithType(v5, @"IdleTimeoutEnabled", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    id v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    v251 = 1024;
    v252 = 1564;
    v253 = 2112;
    v254 = @"IdleTimeoutEnabled";
    v255 = 2048;
    v256 = CFBOOLEAN_TYPE;
    v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (!CFDictionaryContainsKey(v5, @"IdleTimeoutEnabled")) {
    goto LABEL_160;
  }
  -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"IdleTimeoutEnabled");
  id v74 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2SessionConfiguration setIdleTimeoutEnabled:](v2, "setIdleTimeoutEnabled:", [v74 BOOLValue]);

  if (!NEGetValueWithType(v5, @"IdleTimeoutSeconds", CFNUMBER_TYPE))
  {
    ne_log_obj();
    id v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    v251 = 1024;
    v252 = 1567;
    v253 = 2112;
    v254 = @"IdleTimeoutSeconds";
    v255 = 2048;
    v256 = CFNUMBER_TYPE;
    v95 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"IdleTimeoutSeconds"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"IdleTimeoutSeconds");
    id v75 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setIdleTimeoutSeconds:]( v2,  "setIdleTimeoutSeconds:",  [v75 unsignedLongValue]);
  }

LABEL_97:
LABEL_98:
        goto LABEL_99;
      }

      if (!v114) {
        goto LABEL_100;
      }
    }

    uint64_t v6 = [obj countByEnumeratingWithState:&v143 objects:v147 count:16];
    uint64_t v3 = 1LL;
    if (v6) {
      continue;
    }
    break;
  }

  uint64_t v21 = v167;
LABEL_98:
  __int16 v23 = (id)v30;

LABEL_99:
  size_t v16 = v157;
  uint64_t v14 = v158;
LABEL_100:

  os_unfair_lock_unlock((os_unfair_lock_t)&g_transport_lock);
  uint64_t v17 = v165;
  __int16 v22 = v177;
LABEL_101:

  if (v23)
  {
    ne_log_obj();
    int v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v187 = 138412290;
      *(void *)v188 = v23;
      _os_log_debug_impl(&dword_1876B1000, v70, OS_LOG_TYPE_DEBUG, "Found existing transport %@", v187, 0xCu);
    }

    unint64_t v71 = (id *)v23;
    goto LABEL_169;
  }

  v178 = v22;
  uint64_t v72 = objc_alloc_init(&OBJC_CLASS___NEIKEv2Transport);
  p_isa = (id *)&v72->super.isa;
  if (!v72)
  {
LABEL_132:
    id v98 = 0LL;
    goto LABEL_170;
  }

  v72->_transportType = a2;
  objc_setProperty_atomic(v72, v73, v175, 24LL);
  if (v21)
  {
    objc_setProperty_atomic(p_isa, v74, v21, 16LL);
    goto LABEL_113;
  }

  if ([v175 addressFamily] != 2)
  {
    if ([v175 addressFamily] == 30)
    {
      memset(v188, 0, 24);
      uint64_t v76 = 7708;
      goto LABEL_112;
    }

    ne_log_obj();
    v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
    {
      v152 = [v175 addressFamily];
      *(_DWORD *)v187 = 67109120;
      *(_DWORD *)v188 = v152;
      _os_log_error_impl(&dword_1876B1000, v97, OS_LOG_TYPE_ERROR, "Invalid address family %u", v187, 8u);
    }

    goto LABEL_132;
  }

  *(_DWORD *)&v188[8] = 0;
  *(void *)v188 = 0LL;
  uint64_t v76 = 528;
LABEL_112:
  *(_WORD *)v187 = v76;
  *(_WORD *)&v187[2] = __rev16(a5);
  [MEMORY[0x189608DE8] endpointWithAddress:v187];
  unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue();
  objc_setProperty_atomic(p_isa, v78, v77, 16LL);

LABEL_113:
  if (v178)
  {
    uint64_t v79 = (void *)[objc_alloc(MEMORY[0x189608E00]) initWithInterfaceName:v178];
    objc_setProperty_atomic(p_isa, v80, v79, 32LL);
  }

  objc_setProperty_atomic(p_isa, v75, v16, 72LL);
  if (!v18)
  {
    v166 = v17;
    if (a2 <= 1)
    {
      secure_tcp = (nw_parameters_t)v175;
      v171 = (nw_protocol_stack *)v21;
      int v81 = (void (**)(void))v17;
      IKESocket = -1;
      objc_msgSend(objc_getProperty(p_isa, v82, 32, 1), "interfaceName");
      id v84 = (void *)objc_claimAutoreleasedReturnValue();
      v180 = v81;
      v169 = v84;
      if (v81)
      {
        v176 = objc_msgSend(objc_getProperty(p_isa, v83, 16, 1), "address");
        v164 = objc_msgSend(objc_getProperty(p_isa, v85, 24, 1), "address");
        ((void (*)(void (**)(void), uint64_t, uint64_t, uint64_t, int *))v81[2])( v81,  v176,  v164,  [v84 UTF8String],  &IKESocket);
      }

      else
      {
        objc_msgSend(objc_getProperty(p_isa, v83, 16, 1), "address");
        objc_msgSend(objc_getProperty(p_isa, v99, 24, 1), "address");
        [v84 UTF8String];
        getpid();
        IKESocket = NEHelperGetIKESocket();
      }

      id v100 = -[nw_parameters addressFamily](secure_tcp, "addressFamily");
      v102 = IKESocket;
      if (v21)
      {
        uint64_t v17 = v166;
      }

      else
      {
        uint64_t v17 = v166;
        if (v100 == 2 && IKESocket < 0)
        {
          v185 = objc_msgSend(objc_getProperty(p_isa, v101, 32, 1), "interfaceIndex");
          *(void *)buf = 0LL;
          uint64_t v103 = nw_nat64_copy_prefixes();
          if (v103 >= 1 && *(void *)buf)
          {
            v104 = v103;
            v159 = v14;
            v161 = v15;
            ne_log_obj();
            uint64_t v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
            {
              if (v104 == 1) {
                v153 = "";
              }
              else {
                v153 = "es";
              }
              v154 = objc_getProperty(p_isa, v106, 32LL, 1);
              *(_DWORD *)v187 = 67109634;
              *(_DWORD *)v188 = v104;
              *(_WORD *)&v188[4] = 2080;
              *(void *)&v188[6] = v153;
              *(_WORD *)&v188[14] = 2112;
              *(void *)&v188[16] = v154;
              _os_log_debug_impl( &dword_1876B1000,  v105,  OS_LOG_TYPE_DEBUG,  "IKEv2 found %u NAT64 prefix%s on interface %@",  v187,  0x1Cu);
            }

            memset(v188, 0, 24);
            *(_WORD *)v187 = 7708;
            id v108 = 0LL;
            *(_WORD *)&v187[2] = *(_WORD *)(objc_msgSend(objc_getProperty(p_isa, v107, 24, 1), "address") + 2);
            memset((char *)v183 + 4, 0, 24);
            LOWORD(v183[0]) = 7708;
            WORD1(v183[0]) = __rev16(a5);
            while (1)
            {
              objc_msgSend(objc_getProperty(p_isa, v109, 24, 1), "address");
              if ((nw_nat64_synthesize_v6() & 1) != 0)
              {
                __int128 v110 = v13;
                [MEMORY[0x189608DE8] endpointWithAddress:v187];
                __int128 v111 = (void *)objc_claimAutoreleasedReturnValue();
                objc_setProperty_atomic(p_isa, v112, v111, 24LL);

                [MEMORY[0x189608DE8] endpointWithAddress:v183];
                v113 = (void *)objc_claimAutoreleasedReturnValue();
                objc_setProperty_atomic(p_isa, v114, v113, 16LL);

                objc_msgSend(objc_getProperty(p_isa, v115, 32, 1), "interfaceName");
                id v116 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(objc_getProperty(p_isa, v117, 16, 1), "address");
                objc_msgSend(objc_getProperty(p_isa, v118, 24, 1), "address");
                [v116 UTF8String];
                if (v180)
                {
                  v180[2]();
                  v119 = IKESocket;
                }

                else
                {
                  getpid();
                  v119 = NEHelperGetIKESocket();
                  IKESocket = v119;
                }

                uint64_t v13 = v110;
                if ((v119 & 0x80000000) == 0)
                {
LABEL_154:
                  free(*(void **)buf);
                  uint64_t v14 = v159;
                  unsigned int v15 = v161;
                  uint64_t v17 = v166;
                  break;
                }
              }

              else
              {
                ne_log_obj();
                v120 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v184 = 0;
                  _os_log_error_impl( &dword_1876B1000,  v120,  OS_LOG_TYPE_ERROR,  "nw_nat64_synthesize_v6 failed",  v184,  2u);
                }
              }
            }
          }

          v102 = IKESocket;
        }
      }

      if (v102 < 0)
      {
        ne_log_obj();
        v148 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v148, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v187 = 0;
          _os_log_error_impl( &dword_1876B1000,  v148,  OS_LOG_TYPE_ERROR,  "Failed to get IKE socket from NEHelper",  v187,  2u);
        }

        id v98 = 0LL;
      }

      else
      {
        v122 = v15;
        secure_udp = nw_parameters_create_secure_udp( (nw_parameters_configure_protocol_block_t)*MEMORY[0x189608EB0],  (nw_parameters_configure_protocol_block_t)*MEMORY[0x189608EA8]);
        v124 = nw_parameters_copy_default_protocol_stack(secure_udp);
        if (p_isa[5] == (id)1)
        {
          v125 = (nw_protocol_definition *)NEIKEv2TransportCopyNATTFramerDefinition();
          v126 = v14;
          options = nw_framer_create_options(v125);
          nw_protocol_stack_prepend_application_protocol(v124, options);

          uint64_t v14 = v126;
        }

        nw_parameters_set_indefinite();
        if (objc_getProperty(p_isa, v128, 32LL, 1))
        {
          objc_msgSend(objc_getProperty(p_isa, v129, 32, 1), "interfaceName");
          v130 = (void *)objc_claimAutoreleasedReturnValue();
          [v130 UTF8String];
          v131 = v14;
          v132 = (nw_interface *)nw_interface_create_with_name();
          nw_parameters_require_interface(secure_udp, v132);

          uint64_t v14 = v131;
        }

        v133 = (void *)nw_connection_create_with_connected_socket_and_parameters();
        objc_setProperty_atomic(p_isa, v134, v133, 56LL);

        if (objc_getProperty(p_isa, v135, 56LL, 1))
        {

          unsigned int v15 = v122;
          uint64_t v17 = v166;
          __int16 v18 = 0LL;
          goto LABEL_164;
        }

        v150 = v14;
        ne_log_obj();
        v151 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v17 = v166;
        if (os_log_type_enabled(v151, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)v187 = 0;
          _os_log_fault_impl( &dword_1876B1000,  v151,  OS_LOG_TYPE_FAULT,  "nw_connection_create_with_connected_socket failed",  v187,  2u);
        }

        id v98 = 0LL;
        uint64_t v14 = v150;
        unsigned int v15 = v122;
      }

      __int16 v18 = 0LL;
      goto LABEL_170;
    }

    if (a2 == 3) {
      int v86 = (void *)*MEMORY[0x189608EA8];
    }
    else {
      int v86 = (void *)*MEMORY[0x189608EB0];
    }
    secure_tcp = nw_parameters_create_secure_tcp(v86, (nw_parameters_configure_protocol_block_t)*MEMORY[0x189608EA8]);
    __int16 v87 = nw_parameters_copy_default_protocol_stack(secure_tcp);
    char v88 = (nw_protocol_definition *)NEIKEv2TransportCopyTCPFramerDefinition();
    SEL v89 = nw_framer_create_options(v88);
    nw_protocol_stack_prepend_application_protocol(v87, v89);

    v171 = v87;
    id v90 = nw_protocol_stack_copy_internet_protocol(v87);
    unint64_t v91 = (void (**)(void))v90;
    if (v90) {
      nw_ip_options_set_local_address_preference(v90, nw_ip_local_address_preference_stable);
    }
    v180 = v91;
    nw_parameters_set_indefinite();
    if (v178)
    {
      [v178 UTF8String];
      v92 = (nw_interface *)nw_interface_create_with_name();
      nw_parameters_require_interface(secure_tcp, v92);
    }

    v93 = (nw_endpoint *)[v175 copyCEndpoint];
    char v94 = nw_connection_create(v93, secure_tcp);
    objc_setProperty_atomic(p_isa, v95, v94, 56LL);

    if (!objc_getProperty(p_isa, v96, 56LL, 1))
    {
      ne_log_obj();
      v121 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v187 = 0;
        _os_log_fault_impl(&dword_1876B1000, v121, OS_LOG_TYPE_FAULT, "nw_connection_create failed", v187, 2u);
      }

      id v98 = 0LL;
      uint64_t v17 = v166;
      goto LABEL_170;
    }

    uint64_t v17 = v166;
LABEL_164:

    v137 = (nw_connection *)objc_getProperty(p_isa, v136, 56LL, 1);
    nw_connection_set_queue(v137, v16);
    v139 = objc_getProperty(p_isa, v138, 56LL, 1);
    v181[0] = MEMORY[0x1895F87A8];
    v181[1] = 3221225472LL;
    v181[2] = __110__NEIKEv2Transport_createTransport_remote_local_localPort_boundInterface_queue_socketGetBlock_packetDelegate___block_invoke;
    v181[3] = &unk_18A08DBA0;
    v140 = p_isa;
    v182 = v140;
    MEMORY[0x1895ACCFC](v139, v181);
    v142 = (nw_connection *)objc_getProperty(v140, v141, 56LL, 1);
    nw_connection_start(v142);

    goto LABEL_165;
  }

  [v179 setPacketReceiver:p_isa];
  objc_storeWeak(p_isa + 6, v179);
  *((_BYTE *)p_isa + _Block_object_dispose(va, 8) = 1;
LABEL_165:
  ne_log_obj();
  v143 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
  {
    v149 = "";
    *(_DWORD *)v187 = 138412802;
    *(void *)v188 = p_isa;
    if (!v21) {
      v149 = "out";
    }
    *(_WORD *)&v188[8] = 2112;
    *(void *)&v188[10] = v178;
    *(_WORD *)&v188[18] = 2080;
    *(void *)&v188[20] = v149;
    _os_log_debug_impl( &dword_1876B1000,  v143,  OS_LOG_TYPE_DEBUG,  "NEIKEv2Transport: Created %@ on interface %@ with%s local address",  v187,  0x20u);
  }

  os_unfair_lock_lock((os_unfair_lock_t)&g_transport_lock);
  v144 = (void *)g_transports;
  if (!g_transports)
  {
    v145 = objc_alloc_init(MEMORY[0x189603FE0]);
    v146 = (void *)g_transports;
    g_transports = (uint64_t)v145;

    v144 = (void *)g_transports;
  }

  [v144 addObject:p_isa];
  os_unfair_lock_unlock((os_unfair_lock_t)&g_transport_lock);
  unint64_t v71 = p_isa;
LABEL_169:
  p_isa = v71;
  id v98 = v71;
LABEL_170:

  return v98;
}

  uint64_t v20 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    uint64_t v24 = "add policy dictionary validation failed";
LABEL_103:
    _os_log_error_impl(&dword_1876B1000, v20, OS_LOG_TYPE_ERROR, v24, buf, 2u);
  }

void sub_1877B16DC(_Unwind_Exception *a1)
{
}

id NEIKEv2TransportCopyNATTFramerDefinition()
{
  if (NEIKEv2TransportCopyNATTFramerDefinition_onceToken != -1) {
    dispatch_once(&NEIKEv2TransportCopyNATTFramerDefinition_onceToken, &__block_literal_global_12833);
  }
  return (id)NEIKEv2TransportCopyNATTFramerDefinition_definition;
}

void __NEIKEv2TransportCopyNATTFramerDefinition_block_invoke()
{
  nw_protocol_definition_t definition = nw_framer_create_definition("UDP-NAT-T", 0, &__block_literal_global_3_12835);
  uint64_t v1 = (void *)NEIKEv2TransportCopyNATTFramerDefinition_definition;
  NEIKEv2TransportCopyNATTFramerDefinition_nw_protocol_definition_t definition = (uint64_t)definition;
}

uint64_t __NEIKEv2TransportCopyNATTFramerDefinition_block_invoke_2(uint64_t a1, void *a2)
{
  id v2 = a2;
  nw_framer_set_input_handler(v2, &__block_literal_global_5_12837);
  nw_framer_set_output_handler(v2, &__block_literal_global_9_12838);

  return 1LL;
}

void __NEIKEv2TransportCopyNATTFramerDefinition_block_invoke_7(uint64_t a1, void *a2, uint64_t a3, size_t a4)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  nw_framer_write_output(v5, _block_invoke_nonESPMarker, 4uLL);
  ne_log_obj();
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    int v7 = 134217984;
    size_t v8 = a4;
    _os_log_debug_impl( &dword_1876B1000,  v6,  OS_LOG_TYPE_DEBUG,  "UDP-NAT-T: Writing frame length %zu for NAT-T",  (uint8_t *)&v7,  0xCu);
  }

  nw_framer_write_output_no_copy(v5, a4);
}

uint64_t __NEIKEv2TransportCopyNATTFramerDefinition_block_invoke_3(uint64_t a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v2 = a2;
  uint64_t v3 = MEMORY[0x1895F87A8];
  while (1)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = &v16;
    uint64_t v18 = 0x2020000000LL;
    int v19 = 0;
    uint64_t v12 = 0LL;
    uint64_t v13 = &v12;
    uint64_t v14 = 0x2020000000LL;
    uint64_t v15 = 0LL;
    parse[0] = v3;
    parse[1] = 3221225472LL;
    parse[2] = __NEIKEv2TransportCopyNATTFramerDefinition_block_invoke_4;
    parse[3] = &unk_18A08DA40;
    parse[4] = &v16;
    parse[5] = &v12;
    if (!nw_framer_parse_input(v2, 1uLL, 0xFFFFFFFFuLL, 0LL, parse)) {
      break;
    }
    if (v13[3])
    {
      if (*((_DWORD *)v17 + 6))
      {
        ne_log_obj();
        id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          uint64_t v8 = v13[3];
          unsigned int v9 = bswap32(*((_DWORD *)v17 + 6));
          *(_DWORD *)buf = 134218240;
          uint64_t v21 = v8;
          __int16 v22 = 1024;
          unsigned int v23 = v9;
          _os_log_error_impl( &dword_1876B1000,  v4,  OS_LOG_TYPE_ERROR,  "UDP-NAT-T: Reading frame length %zu for NAT-T, unexpected non-zero marker %04X",  buf,  0x12u);
        }
      }

      else
      {
        ne_log_obj();
        id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v7 = v13[3];
          *(_DWORD *)buf = 134217984;
          uint64_t v21 = v7;
          _os_log_debug_impl( &dword_1876B1000,  v4,  OS_LOG_TYPE_DEBUG,  "UDP-NAT-T: Reading frame length %zu for NAT-T",  buf,  0xCu);
        }
      }

      id v5 = nw_framer_message_create(v2);
      BOOL v6 = nw_framer_deliver_input_no_copy(v2, v13[3], v5, 1);

      if (!v6) {
        break;
      }
    }

    _Block_object_dispose(&v12, 8);
    _Block_object_dispose(&v16, 8);
  }

  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);

  return 0LL;
}

void sub_1877B4730( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __NEIKEv2TransportCopyNATTFramerDefinition_block_invoke_4( uint64_t a1, _DWORD *a2, unint64_t a3, int a4)
{
  unint64_t v4 = 0LL;
  if (a2)
  {
    if (a4)
    {
      unint64_t v4 = a3;
      if (a3 >= 4)
      {
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *a2;
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a3 - 4;
        return 4LL;
      }
    }
  }

  return v4;
}

id NEIKEv2TransportCopyTCPFramerDefinition()
{
  if (NEIKEv2TransportCopyTCPFramerDefinition_onceToken != -1) {
    dispatch_once(&NEIKEv2TransportCopyTCPFramerDefinition_onceToken, &__block_literal_global_10);
  }
  return (id)NEIKEv2TransportCopyTCPFramerDefinition_definition;
}

void __NEIKEv2TransportCopyTCPFramerDefinition_block_invoke()
{
  nw_protocol_definition_t definition = nw_framer_create_definition("IKE-TCP", 0, &__block_literal_global_12);
  uint64_t v1 = (void *)NEIKEv2TransportCopyTCPFramerDefinition_definition;
  NEIKEv2TransportCopyTCPFramerDefinition_nw_protocol_definition_t definition = (uint64_t)definition;
}

uint64_t __NEIKEv2TransportCopyTCPFramerDefinition_block_invoke_2(uint64_t a1, void *a2)
{
  id v2 = a2;
  nw_framer_set_input_handler(v2, &__block_literal_global_13);
  nw_framer_set_output_handler(v2, &__block_literal_global_15_12846);
  nw_framer_write_output(v2, (const uint8_t *)"IKETCP", 6uLL);

  return 1LL;
}

void __NEIKEv2TransportCopyTCPFramerDefinition_block_invoke_14(uint64_t a1, void *a2, uint64_t a3, size_t a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  unsigned __int16 v5 = a4 + 6;
  *(_WORD *)output_buffer = bswap32(a4 + 6) >> 16;
  int v9 = 0;
  BOOL v6 = a2;
  nw_framer_write_output(v6, output_buffer, 6uLL);
  ne_log_obj();
  uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67109376;
    int v11 = v5;
    __int16 v12 = 1024;
    int v13 = v9;
    _os_log_debug_impl( &dword_1876B1000,  v7,  OS_LOG_TYPE_DEBUG,  "IKE-TCP: Writing frame of length %u for SPI %04X",  buf,  0xEu);
  }

  nw_framer_write_output_no_copy(v6, a4);
}

uint64_t __NEIKEv2TransportCopyTCPFramerDefinition_block_invoke_3(uint64_t a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  uint64_t v4 = MEMORY[0x1895F87A8];
  do
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = &v16;
    uint64_t v18 = 0x2020000000LL;
    int v19 = 0;
    __int16 v15 = 0;
    *(_DWORD *)temp_buffer = 0;
    parse[0] = v4;
    parse[1] = 3221225472LL;
    parse[2] = __NEIKEv2TransportCopyTCPFramerDefinition_block_invoke_4;
    parse[3] = &unk_18A08DB08;
    int v13 = &v16;
    id v5 = v3;
    id v12 = v5;
    if (nw_framer_parse_input((nw_framer_t)v5, 6uLL, 6uLL, temp_buffer, parse))
    {
      if (*((_DWORD *)v17 + 6))
      {
        ne_log_obj();
        BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          int v9 = *((_DWORD *)v17 + 6);
          *(_DWORD *)buf = 67109376;
          int v21 = v9;
          __int16 v22 = 1024;
          int v23 = 0;
          _os_log_debug_impl( &dword_1876B1000,  v6,  OS_LOG_TYPE_DEBUG,  "IKE-TCP: Reading frame of length %u for SPI %04X",  buf,  0xEu);
        }

        uint64_t v7 = nw_framer_message_create((nw_framer_t)v5);
        BOOL v8 = nw_framer_deliver_input_no_copy((nw_framer_t)v5, *((unsigned int *)v17 + 6), v7, 1);

        if (!v8) {
          uint64_t v2 = 0LL;
        }
      }

      else
      {
        LOBYTE(v_Block_object_dispose((const void *)(v1 - 176), 8) = 0;
        uint64_t v2 = 0LL;
      }
    }

    else
    {
      LOBYTE(v_Block_object_dispose((const void *)(v1 - 176), 8) = 0;
      uint64_t v2 = 6LL;
    }

    _Block_object_dispose(&v16, 8);
  }

  while (v8);

  return v2;
}

void sub_1877B4B4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t __NEIKEv2TransportCopyTCPFramerDefinition_block_invoke_4( uint64_t a1, unsigned __int16 *a2, unint64_t a3)
{
  uint64_t result = 0LL;
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (a2 && a3 >= 6)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = bswap32(*a2) >> 16;
    uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
    unsigned int v6 = *(_DWORD *)(v5 + 24);
    if (v6 > 5)
    {
      if (*(_DWORD *)(a2 + 1))
      {
        *(_DWORD *)(v5 + 24) = v6 - 2;
        return 2LL;
      }

      else
      {
        *(_DWORD *)(v5 + 24) = v6 - 6;
        return 6LL;
      }
    }

    else
    {
      ne_log_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
        v9[0] = 67109120;
        v9[1] = v8;
        _os_log_error_impl( &dword_1876B1000,  v7,  OS_LOG_TYPE_ERROR,  "IKE-TCP: Received invalid frame length %u",  (uint8_t *)v9,  8u);
      }

      nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 40);
      return 0LL;
    }
  }

  return result;
}

void sub_1877B4E30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1877B8350( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_1877B864C(_Unwind_Exception *a1)
{
}

void sub_1877B8798(_Unwind_Exception *a1)
{
}

void *NEIPSecDBCreateSessionWithSocket( uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (__NEIPSecDBInitialize_onceToken != -1) {
    dispatch_once(&__NEIPSecDBInitialize_onceToken, &__block_literal_global_12995);
  }
  if (!g_IPSecDBSessions) {
    return 0LL;
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v10 = (void *)Instance;
  if (!Instance) {
    return v10;
  }
  *(void *)(Instance + 104) = 0LL;
  *(_OWORD *)(Instance + 8_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(Instance + 72) = 0u;
  *(_OWORD *)(Instance + 56) = 0u;
  *(_OWORD *)(Instance + 40) = 0u;
  *(_OWORD *)(Instance + 24) = 0u;
  do
    unint64_t v11 = __ldxr(&sNEIPSecDBIndex);
  while (__stxr(v11 + 1, &sNEIPSecDBIndex));
  *(void *)(Instance + 16) = v11;
  if (a2) {
    CFTypeRef v12 = CFRetain(a2);
  }
  else {
    CFTypeRef v12 = 0LL;
  }
  void v10[3] = v12;
  v10[4] = a3;
  v10[5] = a4;
  int v13 = _NEIPSecDBGetQueue();
  dispatch_source_t v14 = NEPFKeyOpen(v13, NEIPSecDBReceivePFKeyMessage, (uint64_t)v10, a5);
  v10[8] = v14;
  if (!v14) {
    goto LABEL_15;
  }
  __int16 v15 = v14;
  dispatch_queue_t v16 = _NEIPSecDBGetQueue();
  NEPFKeySendRegister(v15, (uint64_t)v16, 2u);
  uint64_t v17 = (dispatch_source_s *)v10[8];
  dispatch_queue_t v18 = _NEIPSecDBGetQueue();
  NEPFKeySendRegister(v17, (uint64_t)v18, 3u);
  v10[9] = 0x100000001LL;
  int v19 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v20 = (const CFDictionaryKeyCallBacks *)MEMORY[0x189605240];
  int v21 = (const CFDictionaryValueCallBacks *)MEMORY[0x189605250];
  v10[10] = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v19, 0LL, v20, v21);
  v10[11] = Mutable;
  if (!v10[10] || !Mutable)
  {
LABEL_15:
    CFRelease(v10);
    return 0LL;
  }

  int v23 = _NEIPSecDBGetQueue();
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __NEIPSecDBCreateSessionWithSocket_block_invoke;
  block[3] = &__block_descriptor_tmp;
  block[4] = v10;
  dispatch_sync(v23, block);
  uint64_t v24 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412290;
    uint64_t v28 = v10;
    _os_log_impl(&dword_1876B1000, v24, OS_LOG_TYPE_INFO, "Created a new NEIPSecDB session %@", buf, 0xCu);
  }

  return v10;
}

dispatch_queue_t _NEIPSecDBGetQueue()
{
  dispatch_queue_t result = (dispatch_queue_t)_NEIPSecDBGetQueue_db_queue;
  if (!_NEIPSecDBGetQueue_db_queue)
  {
    uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    dispatch_queue_t result = dispatch_queue_create("NEIPSecDB PFKey IO Queue", v1);
    _NEIPSecDBGetQueue_db_queue = (uint64_t)result;
  }

  return result;
}

void NEIPSecDBReceivePFKeyMessage(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v164 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *a1;
  *(void *)v156 = 0LL;
  __int16 v155 = 0;
  if (a3)
  {
    uint64_t v4 = (const __CFArray *)g_IPSecDBSessions;
    if (g_IPSecDBSessions)
    {
      v165.length = CFArrayGetCount((CFArrayRef)g_IPSecDBSessions);
      v165.location = 0LL;
      if (CFArrayContainsValue(v4, v165, (const void *)a3))
      {
        CFRetain((CFTypeRef)a3);
        if (!*(void *)(a3 + 80) || !*(void *)(a3 + 88)) {
          goto LABEL_145;
        }
        switch(*(_BYTE *)(v3 + 1))
        {
          case 1:
          case 2:
          case 3:
          case 5:
          case 7:
          case 9:
          case 0xA:
          case 0x1A:
            int v7 = *(_DWORD *)(v3 + 12);
            if (v7 == getpid()) {
              goto LABEL_8;
            }
            goto LABEL_145;
          case 4:
          case 8:
LABEL_8:
            int v8 = NEIPSecDBGetSAWithMessage(a3, a1, v156);
            goto LABEL_9;
          case 0xD:
          case 0xE:
          case 0xF:
          case 0x10:
          case 0x12:
          case 0x13:
          case 0x14:
          case 0x16:
            int v13 = *(_DWORD *)(v3 + 12);
            if (v13 != getpid()) {
              goto LABEL_145;
            }
            *(void *)v156 = -1LL;
            uint64_t v14 = a1[5];
            if (v14)
            {
              uint64_t v15 = v14 + 8;
            }

            else
            {
              uint64_t v26 = a1[23];
              if (v26) {
                uint64_t v15 = v26 + 8;
              }
              else {
                uint64_t v15 = 0LL;
              }
            }

            uint64_t v154 = v15;
            uint64_t v27 = a1[6];
            if (v27)
            {
              uint64_t v28 = v27 + 8;
            }

            else
            {
              uint64_t v29 = a1[25];
              if (v29) {
                uint64_t v28 = v29 + 8;
              }
              else {
                uint64_t v28 = 0LL;
              }
            }

            uint64_t v153 = v28;
            int v8 = 0LL;
            if (!*a1) {
              goto LABEL_9;
            }
            uint64_t v30 = a1[18];
            if (!v30) {
              goto LABEL_9;
            }
            CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a3 + 88));
            if (Count < 1)
            {
LABEL_59:
              int v8 = 0LL;
              goto LABEL_9;
            }

            size_t v32 = Count;
            uint64_t v33 = (const void **)calloc(Count, 8uLL);
            SEL v34 = (const void **)calloc(v32, 8uLL);
            v152 = v33;
            CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a3 + 88), v33, v34);
            uint64_t v35 = 0LL;
            break;
          case 0x17:
            int v48 = *(_DWORD *)(v3 + 12);
            if (v48 == getpid()) {
              goto LABEL_59;
            }
            goto LABEL_145;
          default:
            goto LABEL_145;
        }

        do
        {
          int v8 = (const __CFDictionary *)v34[v35];
          int v36 = NEGetIntFromDictionary(v8, @"PolicyID", 0LL);
          if (v36)
          {
            if (v36 == *(_DWORD *)(v30 + 8))
            {
              *(_DWORD *)buf = 0;
              uint64_t v53 = v152;
              CFNumberGetValue((CFNumberRef)v152[v35], kCFNumberIntType, buf);
              *(void *)v156 = *(int *)buf;
              goto LABEL_65;
            }
          }

          else
          {
            Value = (void *)CFDictionaryGetValue(v8, @"Direction");
            SEL v38 = Value;
            if (Value)
            {
              if (CFEqual(Value, @"In"))
              {
                id v39 = (const __CFString *)CFDictionaryGetValue(v8, @"LocalAddress");
                id v40 = CFDictionaryGetValue(v8, @"LocalPort");
                SEL v38 = NECreateAddressStructFromString(v39, (uint64_t)v40, 0LL);
                id v41 = (const __CFString *)CFDictionaryGetValue(v8, @"RemoteAddress");
                id v42 = CFDictionaryGetValue(v8, @"RemotePort");
                char v43 = NECreateAddressStructFromString(v41, (uint64_t)v42, 0LL);
              }

              else if (CFEqual(v38, @"Out"))
              {
                uint64_t v44 = (const __CFString *)CFDictionaryGetValue(v8, @"LocalAddress");
                uint64_t v45 = CFDictionaryGetValue(v8, @"LocalPort");
                char v43 = NECreateAddressStructFromString(v44, (uint64_t)v45, 0LL);
                uint64_t v46 = (const __CFString *)CFDictionaryGetValue(v8, @"RemoteAddress");
                uint64_t v47 = CFDictionaryGetValue(v8, @"RemotePort");
                SEL v38 = NECreateAddressStructFromString(v46, (uint64_t)v47, 0LL);
              }

              else
              {
                char v43 = 0LL;
                SEL v38 = 0LL;
              }
            }

            else
            {
              char v43 = 0LL;
            }

            if (NEIPSecDBAddressesMatch((uint64_t)v43, v154) && NEIPSecDBAddressesMatch((uint64_t)v38, v153))
            {
              *(_DWORD *)buf = 0;
              uint64_t v53 = v152;
              CFNumberGetValue((CFNumberRef)v152[v35], kCFNumberIntType, buf);
              *(void *)v156 = *(int *)buf;
              if (v43) {
                free(v43);
              }
              if (v38) {
                free(v38);
              }
              goto LABEL_65;
            }

            if (v43) {
              free(v43);
            }
            if (v38) {
              free(v38);
            }
          }

          ++v35;
        }

        while (v32 != v35);
        int v8 = 0LL;
        uint64_t v53 = v152;
        if (!v152) {
          goto LABEL_66;
        }
LABEL_65:
        free(v53);
LABEL_66:
        free(v34);
LABEL_9:
        int v9 = *(unsigned __int8 *)(v3 + 1);
        if (v9 != 23 && !v8)
        {
          uint64_t v10 = (os_log_s *)ne_log_obj();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
          {
            int v11 = *(unsigned __int8 *)(v3 + 1);
            unsigned int v12 = NEIPSecDBExtractSPIFromPFKeyMessage(a1);
            *(_DWORD *)buf = 138412802;
            uint64_t v158 = a3;
            __int16 v159 = 1024;
            *(_DWORD *)v160 = v11;
            *(_WORD *)&v160[4] = 1024;
            *(_DWORD *)&v160[6] = bswap32(v12);
            _os_log_impl( &dword_1876B1000,  v10,  OS_LOG_TYPE_INFO,  "%@ Received PFKey SA Message that could not be matched (type %d, SPI %08X)",  buf,  0x18u);
          }

LABEL_138:
            int v55 = v156[0];
            SEL v56 = *(dispatch_semaphore_s **)(a3 + 96);
LABEL_139:
            char v57 = 1;
LABEL_140:
            NEIPSecDBNotifyRequest(v56, v54, v55, v57, 0LL);
            goto LABEL_141;
          case 0xF:
          case 0x16:
            NEIPSecDBNotifyRequest(*(dispatch_semaphore_s **)(a3 + 96), *(unsigned __int8 *)(v3 + 1), v156[0], 1, 0LL);
LABEL_62:
            uint64_t v50 = *(__CFDictionary **)(a3 + 88);
            goto LABEL_72;
          case 0x10:
            uint64_t v66 = (const __CFAllocator *)*MEMORY[0x189604DB0];
            CFMutableDictionaryRef v67 = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
            if (!v67) {
              goto LABEL_137;
            }
            uint64_t v68 = v67;
            uint64_t v69 = a1[22];
            if (v69)
            {
              if (*(_BYTE *)(v69 + 52))
              {
                CFStringRef v70 = CFStringCreateWithCString(v66, (const char *)(v69 + 52), 0x600u);
                if (v70)
                {
                  CFStringRef v71 = v70;
                  CFDictionaryAddValue(0LL, @"IPSecInterface", v70);
                  CFRelease(v71);
                }
              }

              if (*(_BYTE *)(v69 + 28))
              {
                CFStringRef v72 = CFStringCreateWithCString(v66, (const char *)(v69 + 28), 0x600u);
                if (v72)
                {
                  CFStringRef v73 = v72;
                  CFDictionaryAddValue(0LL, @"OutgoingInterface", v72);
                  CFRelease(v73);
                }
              }

              if (*(_BYTE *)(v69 + 4))
              {
                CFStringRef v74 = CFStringCreateWithCString(v66, (const char *)(v69 + 4), 0x600u);
                if (v74)
                {
                  CFStringRef v75 = v74;
                  CFDictionaryAddValue(0LL, @"InternalInterface", v74);
                  CFRelease(v75);
                }
              }

              if (*(_WORD *)(v69 + 76)) {
                CFDictionaryAddValue(0LL, @"IntializeDisabled", (const void *)*MEMORY[0x189604DE8]);
              }
            }

            uint64_t v76 = (unsigned __int16 *)a1[18];
            if (!v76) {
              goto LABEL_254;
            }
            int v77 = *((unsigned __int8 *)v76 + 6);
            if (v77 == 1)
            {
              unint64_t v78 = @"In";
            }

            else
            {
              if (v77 != 2) {
                goto LABEL_183;
              }
              unint64_t v78 = @"Out";
            }

            CFDictionaryAddValue(v68, @"Direction", v78);
LABEL_183:
            NEAddIntToDictionary(v68, @"PolicyID", *((_DWORD *)v76 + 2));
            unint64_t v117 = v76[2];
            if (v117 <= 5) {
              CFDictionaryAddValue(v68, @"PolicyType", off_18A08E0E0[v117]);
            }
            if (*v76 < 3u) {
              goto LABEL_252;
            }
            int v118 = *((unsigned __int8 *)v76 + 21);
            if (*((_BYTE *)v76 + 21))
            {
              if (v118 == 3)
              {
                v119 = @"Unique";
              }

              else
              {
                if (v118 != 2) {
                  goto LABEL_237;
                }
                v119 = @"Require";
              }
            }

            else
            {
              v119 = @"None";
            }

            CFDictionaryAddValue(v68, @"Level", v119);
LABEL_237:
            int v137 = *((unsigned __int8 *)v76 + 20);
            if (v137 == 1)
            {
              v138 = @"Transport";
            }

            else
            {
              if (v137 != 2) {
                goto LABEL_242;
              }
              v138 = @"Tunnel";
            }

            CFDictionaryAddValue(v68, @"Mode", v138);
LABEL_242:
            int v139 = v76[9];
            if (v139 == 50)
            {
              v140 = @"ESP";
            }

            else
            {
              if (v139 != 51) {
                goto LABEL_247;
              }
              v140 = @"AH";
            }

            CFDictionaryAddValue(v68, @"IPSecProtocol", v140);
LABEL_247:
            if (v76[11]) {
              NEAddIntToDictionary(v68, @"UniqueID", v76[11]);
            }
            unint64_t v141 = v76[8];
            if (v141 >= 9)
            {
              uint64_t v142 = *((unsigned __int8 *)v76 + 24);
              v143 = (unsigned __int8 *)v76 + v142 + 24;
              if (v142 + *v143 + 8 == v141)
              {
                NEAddAddressToDictionary(v68, @"OuterLocalAddress", (unsigned __int8 *)v76 + 24);
                NEAddAddressToDictionary(v68, @"OuterRemoteAddress", v143);
              }
            }

LABEL_252:
            if (*((_BYTE *)v76 + 6) == 1)
            {
              int v144 = 0;
              uint64_t v145 = 6LL;
            }

            else
            {
LABEL_254:
              int v144 = 1;
              uint64_t v145 = 5LL;
            }

            v146 = (unsigned __int8 *)a1[v145];
            if (v146) {
              goto LABEL_259;
            }
            uint64_t v147 = 25LL;
            if (v144) {
              uint64_t v147 = 23LL;
            }
            v146 = (unsigned __int8 *)a1[v147];
            if (v146)
            {
LABEL_259:
              NEAddAddressToDictionary(v68, @"LocalAddress", v146 + 8);
              NEAddPortToDictionary(v68, @"LocalPort", (uint64_t)(v146 + 8));
              NEAddIntToDictionary(v68, @"LocalPrefix", v146[5]);
              int v148 = v146[4];
            }

            else
            {
              int v148 = 255;
            }

            uint64_t v149 = 5LL;
            if (v144) {
              uint64_t v149 = 6LL;
            }
            uint64_t v150 = a1[v149];
            if (v150) {
              goto LABEL_266;
            }
            uint64_t v151 = 23LL;
            if (v144) {
              uint64_t v151 = 25LL;
            }
            uint64_t v150 = a1[v151];
            if (v150)
            {
LABEL_266:
              NEAddAddressToDictionary(v68, @"RemoteAddress", (unsigned __int8 *)(v150 + 8));
              NEAddPortToDictionary(v68, @"RemotePort", v150 + 8);
              NEAddIntToDictionary(v68, @"RemotePrefix", *(unsigned __int8 *)(v150 + 5));
            }

            if (v148 != 255) {
              NEAddIntToDictionary(v68, @"UpperLayerProtocol", v148);
            }
            NEIPSecDBNotifyRequest(*(dispatch_semaphore_s **)(a3 + 96), *(unsigned __int8 *)(v3 + 1), v156[0], 1, v68);
            v136 = v68;
            goto LABEL_270;
          case 0x17:
            if (HIBYTE(v155))
            {
              int v63 = v156[0];
              uint64_t v64 = a3;
              int v65 = 10240;
            }

            else
            {
              if (!(_BYTE)v155)
              {
LABEL_141:
                if (!CFDictionaryGetCount(*(CFDictionaryRef *)(a3 + 80))) {
                  NEIPSecDBNotifyRequest(*(dispatch_semaphore_s **)(a3 + 96), 9, 0, 1, 0LL);
                }
                if (!CFDictionaryGetCount(*(CFDictionaryRef *)(a3 + 88))) {
                  NEIPSecDBNotifyRequest(*(dispatch_semaphore_s **)(a3 + 96), 19, 0, 1, 0LL);
                }
                goto LABEL_145;
              }

              int v63 = v156[0];
              uint64_t v64 = a3;
              int v65 = 8208;
            }

void __NEIPSecDBCreateSessionWithSocket_block_invoke(uint64_t a1)
{
}

CFDictionaryRef NEIPSecDBGetSAWithMessage(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    uint64_t v20 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_DWORD *)buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    int v21 = "%@ pfkey received message is NULL";
LABEL_35:
    _os_log_error_impl(&dword_1876B1000, v20, OS_LOG_TYPE_ERROR, v21, buf, 0xCu);
    return 0LL;
  }

  if (a3) {
    *a3 = -1LL;
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[6];
  if (v6) {
    uint64_t v7 = v6 + 8;
  }
  else {
    uint64_t v7 = 0LL;
  }
  uint64_t v27 = v7;
  if (!v5)
  {
    uint64_t v20 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_DWORD *)buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    int v21 = "%@ pfkey received msg is NULL";
    goto LABEL_35;
  }

  uint64_t v8 = a2[1];
  if (!v8)
  {
    int v22 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      _os_log_impl(&dword_1876B1000, v22, OS_LOG_TYPE_INFO, "%@ pfkey received SA is NULL", buf, 0xCu);
    }

    return 0LL;
  }

  int v9 = *(const __CFDictionary **)(a1 + 80);
  if (!v9) {
    return 0LL;
  }
  CFIndex Count = CFDictionaryGetCount(v9);
  if (Count < 1) {
    return 0LL;
  }
  size_t v11 = Count;
  unsigned int v12 = (const void **)calloc(Count, 8uLL);
  int v13 = (const void **)calloc(v11, 8uLL);
  uint64_t v26 = v12;
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 80), v12, v13);
  for (uint64_t i = 0LL; i != v11; ++i)
  {
    *(void *)buf = 0LL;
    int v31 = 0;
    char v30 = 0;
    int v29 = 0;
    uint64_t v15 = (const __CFDictionary *)v13[i];
    Value = CFDictionaryGetValue(v15, @"Direction");
    if (Value) {
      LODWORD(Value) = CFEqual(Value, @"In");
    }
    if ((_DWORD)Value) {
      uint64_t v17 = (void **)buf;
    }
    else {
      uint64_t v17 = 0LL;
    }
    if ((_DWORD)Value) {
      int v18 = 0LL;
    }
    else {
      int v18 = (void **)buf;
    }
    if (NEIPSecDBFilloutBasicSAInfo(v15, &v30, &v29, &v31, v17, v18, 0LL))
    {
      if ((!v31 || v31 == *(_DWORD *)(v8 + 4)) && v30 == *(_BYTE *)(v5 + 3))
      {
        int v19 = *(void **)buf;
        if (NEIPSecDBAddressesMatch(*(uint64_t *)buf, v27))
        {
          int valuePtr = 0;
          unsigned int v25 = v26;
          CFNumberGetValue((CFNumberRef)v26[i], kCFNumberIntType, &valuePtr);
          if (*(void *)buf) {
            free(*(void **)buf);
          }
          if (a3) {
            *a3 = valuePtr;
          }
          goto LABEL_41;
        }

        if (v19)
        {
LABEL_26:
          free(v19);
          continue;
        }
      }

      else
      {
        int v19 = *(void **)buf;
        if (*(void *)buf) {
          goto LABEL_26;
        }
      }
    }
  }

  uint64_t v15 = 0LL;
  int v23 = 0LL;
  unsigned int v25 = v26;
  if (!v26) {
    goto LABEL_42;
  }
LABEL_41:
  free(v25);
  int v23 = v15;
LABEL_42:
  free(v13);
  return v23;
}

BOOL NEIPSecDBAddressesMatch(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0LL;
  if (a1 && a2)
  {
    int v3 = *(unsigned __int8 *)(a1 + 1);
    if (v3 == *(unsigned __int8 *)(a2 + 1))
    {
      if (v3 == 30) {
        return *(void *)(a1 + 8) == *(void *)(a2 + 8) && *(void *)(a1 + 16) == *(void *)(a2 + 16);
      }
      if (v3 == 2) {
        return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
      }
    }

    return 0LL;
  }

  return v2;
}

uint64_t NEIPSecDBExtractSPIFromPFKeyMessage(void *a1)
{
  uint64_t result = 0LL;
  unsigned int v3 = *(unsigned __int8 *)(*a1 + 1LL);
  if (v3 <= 0x1A)
  {
    int v4 = 1 << v3;
    if ((v4 & 0x40006AE) != 0)
    {
      int v5 = *(_DWORD *)(*a1 + 12LL);
      if (v5 != getpid() || !*a1) {
        return 0LL;
      }
    }

    else if ((v4 & 0x110) == 0)
    {
      return result;
    }

    uint64_t v6 = a1[1];
    if (v6) {
      return *(unsigned int *)(v6 + 4);
    }
    return 0LL;
  }

  return result;
}

dispatch_semaphore_s *NEIPSecDBNotifyRequest( dispatch_semaphore_s *result, int a2, int a3, char a4, CFTypeRef cf)
{
  if (result)
  {
    int v5 = result;
    while (1)
    {
      uint64_t v6 = *(dispatch_semaphore_s **)v5;
      if (*((_DWORD *)v5 + 6) == a2 && *((_DWORD *)v5 + 7) == a3) {
        break;
      }
      int v5 = *(dispatch_semaphore_s **)v5;
      if (!v6) {
        return result;
      }
    }

    *((_BYTE *)v5 + 32) = a4;
    if (cf) {
      CFTypeRef v7 = CFRetain(cf);
    }
    else {
      CFTypeRef v7 = 0LL;
    }
    *((void *)v5 + 5) = v7;
    uint64_t result = (dispatch_semaphore_s *)*((void *)v5 + 2);
    if (result) {
      return (dispatch_semaphore_s *)dispatch_semaphore_signal(result);
    }
  }

  return result;
}

BOOL NEIPSecDBStatsHandleReply(uint64_t a1, uint64_t *a2, void *a3, _BYTE *a4, _BYTE *a5)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *a2;
  if (!*a2 || (uint64_t v6 = a2[20]) == 0 || (v7 = a2[21]) == 0)
  {
    dispatch_queue_t v16 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v36 = 136315138;
    id v37 = "NEIPSecDBStatsHandleReply";
    int v13 = "%s: Bad sadb getsastat response";
    uint64_t v14 = v16;
    uint32_t v15 = 12;
    goto LABEL_31;
  }

  uint64_t v8 = *(void *)(v6 + 8);
  if (!v8)
  {
    uint64_t v17 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v18 = *(unsigned __int8 *)(v5 + 1);
    int v36 = 136315394;
    id v37 = "NEIPSecDBStatsHandleReply";
    __int16 v38 = 1024;
    int v39 = v18;
    int v13 = "%s: msg type %d: session-id[0] is invalid.";
LABEL_20:
    uint64_t v14 = v17;
    uint32_t v15 = 18;
LABEL_31:
    _os_log_error_impl(&dword_1876B1000, v14, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v36, v15);
    return 0LL;
  }

  *a3 = v8;
  if (!*(_DWORD *)(v7 + 12))
  {
    uint64_t v17 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v19 = *(unsigned __int8 *)(v5 + 1);
    int v36 = 136315394;
    id v37 = "NEIPSecDBStatsHandleReply";
    __int16 v38 = 1024;
    int v39 = v19;
    int v13 = "%s: msg type %d: sastats is invalid.";
    goto LABEL_20;
  }

  if (!a1)
  {
    uint64_t v35 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v35, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    int v36 = 136315138;
    id v37 = "NEIPSecDBStatsUpdate";
    _os_log_fault_impl(&dword_1876B1000, v35, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&v36, 0xCu);
    return 0LL;
  }

  int v9 = *(_DWORD *)(v7 + 4);
  if ((_DWORD)v8) {
    BOOL v10 = (v9 - 1) >= 2;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    size_t v11 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v36) = 0;
    int v13 = "invalid arguments";
    uint64_t v14 = v11;
    uint32_t v15 = 2;
    goto LABEL_31;
  }

  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  int v22 = *(uint64_t **)(a1 + 104);
  if (!v22) {
    return 0LL;
  }
  while (*((_DWORD *)v22 + 4) != (_DWORD)v8 && *((_DWORD *)v22 + 5) != (_DWORD)v8)
  {
    BOOL result = 0LL;
    int v22 = (uint64_t *)*v22;
    if (!v22) {
      return result;
    }
  }

  uint64_t v23 = *(void *)(v7 + 32);
  if (v9 != 1)
  {
    if (v22[7] != v23)
    {
      v22[7] = v23;
      *((_BYTE *)v22 + 80) = 1;
      goto LABEL_39;
    }

void NEIPSecDBNotifyClient(uint64_t a1, int a2, int a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1 && *(void *)(a1 + 32) && !*(_BYTE *)(a1 + 56) && *(void *)(a1 + 48))
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412802;
      uint64_t v12 = a1;
      __int16 v13 = 1024;
      int v14 = a3;
      __int16 v15 = 1024;
      int v16 = a2;
      _os_log_impl(&dword_1876B1000, v6, OS_LOG_TYPE_INFO, "%@ received notification %#x for SAID %u", buf, 0x18u);
    }

    CFRetain((CFTypeRef)a1);
    uint64_t v7 = *(dispatch_queue_s **)(a1 + 48);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __NEIPSecDBNotifyClient_block_invoke;
    block[3] = &__block_descriptor_tmp_215;
    int v9 = a2;
    int v10 = a3;
    block[4] = a1;
    void block[5] = 0LL;
    dispatch_async(v7, block);
  }

void __NEIPSecDBNotifyClient_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 56)) {
    (*(void (**)(uint64_t, void, void, void, void))(v2 + 32))( v2,  *(unsigned int *)(a1 + 48),  *(unsigned int *)(a1 + 52),  *(void *)(a1 + 40),  *(void *)(v2 + 40));
  }
  unsigned int v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  int v4 = *(const void **)(a1 + 32);
  if (v4) {
    CFRelease(v4);
  }
}

BOOL NEIPSecDBFilloutBasicSAInfo( CFDictionaryRef theDict, char *a2, int *a3, _DWORD *a4, void **a5, void **a6, char *a7)
{
  if (theDict)
  {
    if (a3)
    {
      Value = CFDictionaryGetValue(theDict, @"Mode");
      if (Value)
      {
        if (CFEqual(Value, @"Transport")) {
          int v15 = 1;
        }
        else {
          int v15 = 2;
        }
      }

      else
      {
        int v15 = 2;
      }

      *a3 = v15;
    }

    if (a2)
    {
      int v18 = CFDictionaryGetValue(theDict, @"IPSecProtocol");
      if (v18)
      {
        if (CFEqual(v18, @"AH")) {
          char v19 = 2;
        }
        else {
          char v19 = 3;
        }
      }

      else
      {
        char v19 = 3;
      }

      *a2 = v19;
    }

    if (a4)
    {
      unsigned int valuePtr = 0;
      uint64_t v20 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"SPIValue");
      if (v20)
      {
        CFNumberGetValue(v20, kCFNumberIntType, &valuePtr);
        unsigned int v21 = valuePtr;
      }

      else
      {
        unsigned int v21 = 0;
      }

      *a4 = bswap32(v21);
    }

    if (a5)
    {
      int v22 = (const __CFString *)CFDictionaryGetValue(theDict, @"LocalAddress");
      uint64_t v23 = CFDictionaryGetValue(theDict, @"LocalPort");
      *a5 = NECreateAddressStructFromString(v22, (uint64_t)v23, 0LL);
    }

    if (a6)
    {
      int32x2_t v24 = (const __CFString *)CFDictionaryGetValue(theDict, @"RemoteAddress");
      int v25 = CFDictionaryGetValue(theDict, @"RemotePort");
      *a6 = NECreateAddressStructFromString(v24, (uint64_t)v25, 0LL);
    }

    if (a7)
    {
      if (CFDictionaryContainsKey(theDict, @"IPSecInterface"))
      {
        unsigned int v26 = (const __CFString *)CFDictionaryGetValue(theDict, @"IPSecInterface");
        CFStringGetCString(v26, a7, 24LL, 0x600u);
      }
    }

    return 1LL;
  }

  else
  {
    int v16 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1876B1000, v16, OS_LOG_TYPE_ERROR, "saData is NULL", buf, 2u);
      return 0LL;
    }
  }

  return result;
}

void __NEIPSecDBDeallocate(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (dispatch_source_s *)a1[8];
    if (v2)
    {
      NEPFKeyClose(v2);
      a1[8] = 0LL;
    }

    unsigned int v3 = (dispatch_object_s *)a1[6];
    if (v3)
    {
      dispatch_release(v3);
      a1[6] = 0LL;
    }

    int v4 = (const void *)a1[10];
    if (v4)
    {
      CFRelease(v4);
      a1[10] = 0LL;
    }

    uint64_t v5 = (const void *)a1[11];
    if (v5)
    {
      CFRelease(v5);
      a1[11] = 0LL;
    }

    uint64_t v6 = (const void *)a1[3];
    if (v6)
    {
      CFRelease(v6);
      a1[3] = 0LL;
    }
  }

__CFString *__NEIPSecDBCopyDescription(void *a1)
{
  uint64_t v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0LL);
  CFStringAppendFormat(Mutable, 0LL, @"<NEIPSecDB %p [%p]> {", a1, v2);
  if (a1) {
    CFStringAppendFormat(Mutable, 0LL, @"UniqueIndex = %llu", a1[2]);
  }
  CFStringAppendFormat(Mutable, 0LL, @"}");
  return Mutable;
}

void *NEIPSecDBCreateSession(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return NEIPSecDBCreateSessionWithSocket(a1, a2, a3, a4, 0xFFFFFFFF);
}

BOOL NEIPSecDBSetDispatchQueue(uint64_t a1, dispatch_object_t object)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v4 = *(dispatch_object_s **)(a1 + 48);
    if (v4)
    {
      dispatch_release(v4);
      *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
    }

    if (object)
    {
      *(void *)(a1 + 4_Block_object_dispose(va, 8) = object;
      dispatch_retain(object);
    }

    return 1LL;
  }

  else
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_FAULT);
    if (result)
    {
      int v7 = 136315138;
      uint64_t v8 = "NEIPSecDBSetDispatchQueue";
      _os_log_fault_impl(&dword_1876B1000, v6, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&v7, 0xCu);
      return 0LL;
    }
  }

  return result;
}

uint64_t NEIPSecDBAddLarvalSA(uint64_t a1, CFTypeRef cf, unsigned int *a3)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    int v32 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBAddLarvalSA";
    uint64_t v33 = "%s called with null session";
LABEL_46:
    _os_log_fault_impl(&dword_1876B1000, v32, OS_LOG_TYPE_FAULT, v33, buf, 0xCu);
    return 0LL;
  }

  if (!*(void *)(a1 + 80))
  {
    int v32 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBAddLarvalSA";
    uint64_t v33 = "%s called with null session->sas";
    goto LABEL_46;
  }

  *(_WORD *)buffer = 0;
  int v49 = 0;
  uint64_t v47 = 0LL;
  int v48 = 0LL;
  int valuePtr = 0;
  uint64_t v45 = 0LL;
  unsigned int v44 = 0;
  v51[0] = 0;
  uint64_t v40 = 0LL;
  id v41 = &v40;
  uint64_t v42 = 0x2000000000LL;
  int v43 = 0;
  uint64_t v36 = 0LL;
  id v37 = &v36;
  uint64_t v38 = 0x2000000000LL;
  uint64_t v39 = 0LL;
  BOOL v6 = NEIPSecDBValidateSADictionary(cf, 1, 0);
  uint64_t v7 = MEMORY[0x1895F87A8];
  if (!v6)
  {
    uint64_t v23 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      _os_log_error_impl( &dword_1876B1000,  v23,  OS_LOG_TYPE_ERROR,  "%@ add larval SA dictionary validation failed",  buf,  0xCu);
    }

    goto LABEL_31;
  }

  if (NEIPSecDBFilloutBasicSAInfo((CFDictionaryRef)cf, (char *)buffer, &v49, &v44, &v48, &v47, v51))
  {
    Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"UniqueID");
    if (Value) {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    }
    uint64_t v9 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"LifeTimeinSeconds");
    int v10 = v9;
    if (v9) {
      CFNumberGetValue(v9, kCFNumberLongType, &v45);
    }
    if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"OutgoingInterface"))
    {
      size_t v11 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"OutgoingInterface");
      CFStringGetCString(v11, (char *)&buffer[1], 16LL, 0x600u);
    }

    BOOL v12 = v10 != 0LL;
    __int16 v13 = _NEIPSecDBGetQueue();
    block[0] = v7;
    block[1] = 0x40000000LL;
    block[2] = __NEIPSecDBAddLarvalSA_block_invoke;
    block[3] = &unk_18A08DC80;
    void block[6] = a1;
    block[7] = cf;
    block[4] = &v40;
    void block[5] = &v36;
    dispatch_sync(v13, block);
    int v14 = *(dispatch_source_s **)(a1 + 64);
    dispatch_queue_t v15 = _NEIPSecDBGetQueue();
    unsigned int v16 = bswap32(v44);
    uint64_t v17 = v51;
    if (!v51[0]) {
      uint64_t v17 = 0LL;
    }
    int v18 = (char *)&buffer[1];
    if (!buffer[1]) {
      int v18 = 0LL;
    }
    *(void *)&__int128 v34 = v17;
    *((void *)&v34 + 1) = v18;
    if (NEPFKeySendGetSPI( v14,  (uint64_t)v15,  buffer[0],  v49,  (uint64_t)v47,  (uint64_t)v48,  v16,  v16,  valuePtr,  v12,  v45,  SHIDWORD(v45),  0,  1u,  v34))
    {
      if (NEIPSecDBCopyResponseForQueuedRequest(v37[3], 0LL))
      {
        if (a3)
        {
          char v19 = NEGetValueFromIntKeyedDictionary(*(const __CFDictionary **)(a1 + 80), *((_DWORD *)v41 + 6));
          if (v19) {
            *a3 = NEGetIntFromDictionary(v19, @"SPIValue", 0LL);
          }
        }

        uint64_t v20 = (os_log_s *)ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
        {
          int v21 = *((_DWORD *)v41 + 6);
          if (a3) {
            unsigned int v22 = bswap32(*a3);
          }
          else {
            unsigned int v22 = 0;
          }
          *(_DWORD *)buf = 138412802;
          *(void *)&uint8_t buf[4] = a1;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v21;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v22;
          _os_log_impl(&dword_1876B1000, v20, OS_LOG_TYPE_INFO, "%@ added larval SAID %u SPI %08X", buf, 0x18u);
        }

        goto LABEL_31;
      }

      int32x2_t v24 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        goto LABEL_28;
      }
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      int v25 = "%@ add larval SA, failed to receive response for pfkey get spi";
    }

    else
    {
      int32x2_t v24 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
LABEL_28:
        int v26 = *((_DWORD *)v41 + 6);
        int v27 = _NEIPSecDBGetQueue();
        *(void *)buf = v7;
        *(void *)&uint8_t buf[8] = 0x40000000LL;
        *(void *)&uint8_t buf[16] = __NEIPSecDBRemoveSAIDFromSAs_block_invoke;
        uint64_t v53 = &__block_descriptor_tmp_160;
        uint64_t v54 = a1;
        int v55 = v26;
        dispatch_sync(v27, buf);
        *((_DWORD *)v41 + 6) = 0;
        goto LABEL_31;
      }

      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      int v25 = "%@ add larval SA, pfkey send get spi failed";
    }

    _os_log_error_impl(&dword_1876B1000, v24, OS_LOG_TYPE_ERROR, v25, buf, 0xCu);
    goto LABEL_28;
  }

BOOL NEIPSecDBValidateSADictionary(CFTypeRef cf, int a2, int a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (NEInitCFTypes_onceToken == -1)
  {
    if (!cf) {
      return 0LL;
    }
  }

  else
  {
    dispatch_once(&NEInitCFTypes_onceToken, &__block_literal_global_22164);
    if (!cf) {
      return 0LL;
    }
  }

  uint64_t v6 = CFDICTIONARY_TYPE;
  if (CFGetTypeID(cf) != v6) {
    return 0LL;
  }
  if (!NEGetValueWithType((const __CFDictionary *)cf, @"LocalAddress", CFSTRING_TYPE))
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v12 = 136315906;
    __int16 v13 = "NEIPSecDBValidateSADictionary";
    __int16 v14 = 1024;
    int v15 = 3790;
    __int16 v16 = 2112;
    uint64_t v17 = @"LocalAddress";
    __int16 v18 = 2048;
    CFTypeID TypeID = CFSTRING_TYPE;
    uint64_t v9 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_68;
  }

  if (!NEGetValueWithType((const __CFDictionary *)cf, @"RemoteAddress", CFSTRING_TYPE))
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v12 = 136315906;
    __int16 v13 = "NEIPSecDBValidateSADictionary";
    __int16 v14 = 1024;
    int v15 = 3791;
    __int16 v16 = 2112;
    uint64_t v17 = @"RemoteAddress";
    __int16 v18 = 2048;
    CFTypeID TypeID = CFSTRING_TYPE;
    uint64_t v9 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_68;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"LocalPrefix")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"LocalPrefix", CFNUMBER_TYPE))
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v12 = 136315906;
    __int16 v13 = "NEIPSecDBValidateSADictionary";
    __int16 v14 = 1024;
    int v15 = 3792;
    __int16 v16 = 2112;
    uint64_t v17 = @"LocalPrefix";
    __int16 v18 = 2048;
    CFTypeID TypeID = CFNUMBER_TYPE;
    uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_68;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"RemotePrefix")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"RemotePrefix", CFNUMBER_TYPE))
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v12 = 136315906;
    __int16 v13 = "NEIPSecDBValidateSADictionary";
    __int16 v14 = 1024;
    int v15 = 3793;
    __int16 v16 = 2112;
    uint64_t v17 = @"RemotePrefix";
    __int16 v18 = 2048;
    CFTypeID TypeID = CFNUMBER_TYPE;
    uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_68;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"LocalPort")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"LocalPort", CFNUMBER_TYPE))
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v12 = 136315906;
    __int16 v13 = "NEIPSecDBValidateSADictionary";
    __int16 v14 = 1024;
    int v15 = 3794;
    __int16 v16 = 2112;
    uint64_t v17 = @"LocalPort";
    __int16 v18 = 2048;
    CFTypeID TypeID = CFNUMBER_TYPE;
    uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_68;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"RemotePort")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"RemotePort", CFNUMBER_TYPE))
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v12 = 136315906;
    __int16 v13 = "NEIPSecDBValidateSADictionary";
    __int16 v14 = 1024;
    int v15 = 3795;
    __int16 v16 = 2112;
    uint64_t v17 = @"RemotePort";
    __int16 v18 = 2048;
    CFTypeID TypeID = CFNUMBER_TYPE;
    uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_68;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"IPSecInterface")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"IPSecInterface", CFSTRING_TYPE))
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v12 = 136315906;
    __int16 v13 = "NEIPSecDBValidateSADictionary";
    __int16 v14 = 1024;
    int v15 = 3796;
    __int16 v16 = 2112;
    uint64_t v17 = @"IPSecInterface";
    __int16 v18 = 2048;
    CFTypeID TypeID = CFSTRING_TYPE;
    uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_68;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"OutgoingInterface")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"OutgoingInterface", CFSTRING_TYPE))
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v12 = 136315906;
    __int16 v13 = "NEIPSecDBValidateSADictionary";
    __int16 v14 = 1024;
    int v15 = 3797;
    __int16 v16 = 2112;
    uint64_t v17 = @"OutgoingInterface";
    __int16 v18 = 2048;
    CFTypeID TypeID = CFSTRING_TYPE;
    uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_68;
  }

  if (a3) {
    return 1LL;
  }
  if (!NEGetValueWithType((const __CFDictionary *)cf, @"Mode", CFSTRING_TYPE))
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v12 = 136315906;
    __int16 v13 = "NEIPSecDBValidateSADictionary";
    __int16 v14 = 1024;
    int v15 = 3799;
    __int16 v16 = 2112;
    uint64_t v17 = @"Mode";
    __int16 v18 = 2048;
    CFTypeID TypeID = CFSTRING_TYPE;
    uint64_t v9 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_68;
  }

  if (!NEGetValueWithType((const __CFDictionary *)cf, @"IPSecProtocol", CFSTRING_TYPE))
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v12 = 136315906;
    __int16 v13 = "NEIPSecDBValidateSADictionary";
    __int16 v14 = 1024;
    int v15 = 3800;
    __int16 v16 = 2112;
    uint64_t v17 = @"IPSecProtocol";
    __int16 v18 = 2048;
    CFTypeID TypeID = CFSTRING_TYPE;
    uint64_t v9 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_68;
  }

  if (a2) {
    return 1LL;
  }
  if (NEGetValueWithType((const __CFDictionary *)cf, @"SPIValue", CFNUMBER_TYPE))
  {
    if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"ReplayWindowSize")
      && !NEGetValueWithType((const __CFDictionary *)cf, @"ReplayWindowSize", CFNUMBER_TYPE))
    {
      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3804;
        __int16 v16 = 2112;
        uint64_t v17 = @"ReplayWindowSize";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFNUMBER_TYPE;
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
        goto LABEL_68;
      }
    }

    else if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"LifeTimeinSeconds") {
           && !NEGetValueWithType((const __CFDictionary *)cf, @"LifeTimeinSeconds", CFNUMBER_TYPE))
    }
    {
      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3805;
        __int16 v16 = 2112;
        uint64_t v17 = @"LifeTimeinSeconds";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFNUMBER_TYPE;
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
        goto LABEL_68;
      }
    }

    else if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"EncryptionAlgorithm") {
           && !NEGetValueWithType((const __CFDictionary *)cf, @"EncryptionAlgorithm", CFSTRING_TYPE))
    }
    {
      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3807;
        __int16 v16 = 2112;
        uint64_t v17 = @"EncryptionAlgorithm";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFSTRING_TYPE;
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
        goto LABEL_68;
      }
    }

    else if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"EncryptionKey") {
           && (CFTypeID v10 = CFDataGetTypeID(), !NEGetValueWithType((const __CFDictionary *)cf, @"EncryptionKey", v10)))
    }
    {
      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3808;
        __int16 v16 = 2112;
        uint64_t v17 = @"EncryptionKey";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFDataGetTypeID();
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
        goto LABEL_68;
      }
    }

    else if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"AuthAlgorithm") {
           && !NEGetValueWithType((const __CFDictionary *)cf, @"AuthAlgorithm", CFSTRING_TYPE))
    }
    {
      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3810;
        __int16 v16 = 2112;
        uint64_t v17 = @"AuthAlgorithm";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFSTRING_TYPE;
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
        goto LABEL_68;
      }
    }

    else if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"AuthKey") {
           && (CFTypeID v11 = CFDataGetTypeID(), !NEGetValueWithType((const __CFDictionary *)cf, @"AuthKey", v11)))
    }
    {
      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3811;
        __int16 v16 = 2112;
        uint64_t v17 = @"AuthKey";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFDataGetTypeID();
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
        goto LABEL_68;
      }
    }

    else if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"NATTraversal") {
           && !NEGetValueWithType((const __CFDictionary *)cf, @"NATTraversal", CFBOOLEAN_TYPE))
    }
    {
      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3813;
        __int16 v16 = 2112;
        uint64_t v17 = @"NATTraversal";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFBOOLEAN_TYPE;
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
        goto LABEL_68;
      }
    }

    else if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"NATTKeepAlive") {
           && !NEGetValueWithType((const __CFDictionary *)cf, @"NATTKeepAlive", CFBOOLEAN_TYPE))
    }
    {
      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3814;
        __int16 v16 = 2112;
        uint64_t v17 = @"NATTKeepAlive";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFBOOLEAN_TYPE;
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
        goto LABEL_68;
      }
    }

    else if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"NATTDetectedPeer") {
           && !NEGetValueWithType((const __CFDictionary *)cf, @"NATTDetectedPeer", CFBOOLEAN_TYPE))
    }
    {
      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3815;
        __int16 v16 = 2112;
        uint64_t v17 = @"NATTDetectedPeer";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFBOOLEAN_TYPE;
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
        goto LABEL_68;
      }
    }

    else if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"NATTPort") {
           && !NEGetValueWithType((const __CFDictionary *)cf, @"NATTPort", CFNUMBER_TYPE))
    }
    {
      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3816;
        __int16 v16 = 2112;
        uint64_t v17 = @"NATTPort";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFNUMBER_TYPE;
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
        goto LABEL_68;
      }
    }

    else
    {
      if (!CFDictionaryContainsKey((CFDictionaryRef)cf, @"NATTSourcePort")
        || NEGetValueWithType((const __CFDictionary *)cf, @"NATTSourcePort", CFNUMBER_TYPE))
      {
        return 1LL;
      }

      uint64_t v8 = (os_log_s *)ne_log_obj();
      BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v12 = 136315906;
        __int16 v13 = "NEIPSecDBValidateSADictionary";
        __int16 v14 = 1024;
        int v15 = 3817;
        __int16 v16 = 2112;
        uint64_t v17 = @"NATTSourcePort";
        __int16 v18 = 2048;
        CFTypeID TypeID = CFNUMBER_TYPE;
        uint64_t v9 = "%s:%d: type of value for key %@ != %lu";
LABEL_68:
        _os_log_error_impl(&dword_1876B1000, v8, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v12, 0x26u);
        return 0LL;
      }
    }
  }

  else
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v12 = 136315906;
      __int16 v13 = "NEIPSecDBValidateSADictionary";
      __int16 v14 = 1024;
      int v15 = 3803;
      __int16 v16 = 2112;
      uint64_t v17 = @"SPIValue";
      __int16 v18 = 2048;
      CFTypeID TypeID = CFNUMBER_TYPE;
      uint64_t v9 = "%s:%d: value for key %@ is missing or type != %lu";
      goto LABEL_68;
    }
  }

  return result;
}

void *__NEIPSecDBAddLarvalSA_block_invoke(void *a1)
{
  uint64_t v3 = a1[6];
  uint64_t v2 = (const __CFDictionary *)a1[7];
  int v4 = *(_DWORD *)(v3 + 72);
  else {
    int v5 = 1;
  }
  *(_DWORD *)(v3 + 72) = v5;
  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = v4;
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v2);
  if (MutableCopy)
  {
    uint64_t v7 = MutableCopy;
    CFDictionaryAddValue(MutableCopy, @"Direction", @"In");
    NEAddValueToIntKeyedDictionary(*(__CFDictionary **)(a1[6] + 80LL), *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL), v7);
    CFRelease(v7);
  }

  BOOL result = NEIPSecDBCreateQueuedRequest(a1[6], 1, *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL));
  *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = result;
  return result;
}

void __NEIPSecDBRemoveSAIDFromSAs_block_invoke(uint64_t a1)
{
}

uint64_t NEIPSecDBCopyResponseForQueuedRequest(uint64_t result, void *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    unsigned int v4 = *(_DWORD *)(result + 24);
    BOOL v5 = v4 > 0x1A;
    int v6 = (1 << v4) & 0x400000E;
    if (v5 || v6 == 0) {
      int64_t v8 = 2000000000LL;
    }
    else {
      int64_t v8 = 4000000000LL;
    }
    uint64_t v9 = *(dispatch_semaphore_s **)(result + 16);
    dispatch_time_t v10 = dispatch_time(0LL, v8);
    dispatch_semaphore_wait(v9, v10);
    CFTypeID v11 = _NEIPSecDBGetQueue();
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __NEIPSecDBCopyResponseForQueuedRequest_block_invoke;
    block[3] = &__block_descriptor_tmp_162;
    block[4] = v3;
    dispatch_sync(v11, block);
    BOOL result = *(unsigned __int8 *)(v3 + 32);
    if (a2)
    {
      if (*(_BYTE *)(v3 + 32)) {
        *a2 = *(void *)(v3 + 40);
      }
    }
  }

  return result;
}

void __NEIPSecDBRemoveQueuedRequest_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  if (*v2)
  {
    *(void *)(v3 + _Block_object_dispose(va, 8) = v2[1];
    uint64_t v2 = *(uint64_t **)(a1 + 32);
    uint64_t v3 = *v2;
  }

  *(void *)v2[1] = v3;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    BOOL v5 = *(dispatch_object_s **)(v4 + 16);
    if (v5)
    {
      dispatch_release(v5);
      *(void *)(*(void *)(a1 + 32) + 16LL) = 0LL;
    }
  }

void __NEIPSecDBCopyResponseForQueuedRequest_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 32) + 16LL) = 0LL;
}

void *NEIPSecDBCreateQueuedRequest(uint64_t a1, int a2, int a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v6 = malloc(0x30uLL);
    v6[4] = 0LL;
    v6[5] = 0LL;
    *((_DWORD *)v6 + 6) = a2;
    *((_DWORD *)v6 + 7) = a3;
    v6[2] = dispatch_semaphore_create(0LL);
    uint64_t v9 = *(void *)(a1 + 96);
    int64_t v8 = (void *)(a1 + 96);
    uint64_t v7 = v9;
    *int v6 = v9;
    if (v9) {
      *(void *)(v7 + _Block_object_dispose(va, 8) = v6;
    }
    *int64_t v8 = v6;
    v6[1] = v8;
  }

  else
  {
    CFTypeID v11 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
    {
      int v12 = 136315138;
      __int16 v13 = "NEIPSecDBCreateQueuedRequest";
      _os_log_fault_impl(&dword_1876B1000, v11, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&v12, 0xCu);
    }

    return 0LL;
  }

  return v6;
}

uint64_t NEIPSecDBGetSPIForSA(uint64_t a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    dispatch_time_t v10 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "NEIPSecDBGetSPIForSA";
    CFTypeID v11 = "%s called with null session";
LABEL_14:
    _os_log_fault_impl(&dword_1876B1000, v10, OS_LOG_TYPE_FAULT, v11, (uint8_t *)&buf, 0xCu);
    return 0LL;
  }

  if (!*(void *)(a1 + 80))
  {
    dispatch_time_t v10 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "NEIPSecDBGetSPIForSA";
    CFTypeID v11 = "%s called with null session->sas";
    goto LABEL_14;
  }

  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v15 = 0x2000000000LL;
  uint64_t v16 = 0LL;
  uint64_t v4 = _NEIPSecDBGetQueue();
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __NEIPSecDBGetSPIForSA_block_invoke;
  block[3] = &unk_18A08DCA8;
  block[4] = &buf;
  void block[5] = a1;
  int v13 = a2;
  dispatch_sync(v4, block);
  BOOL v5 = *(const __CFDictionary **)(*((void *)&buf + 1) + 24LL);
  if (v5)
  {
    uint64_t v6 = NEGetIntFromDictionary(v5, @"SPIValue", 0LL);
    uint64_t v7 = *((void *)&buf + 1);
    int64_t v8 = *(const void **)(*((void *)&buf + 1) + 24LL);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(v7 + 24) = 0LL;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  _Block_object_dispose(&buf, 8);
  return v6;
}

const void *__NEIPSecDBGetSPIForSA_block_invoke(uint64_t a1)
{
  BOOL result = NEGetValueFromIntKeyedDictionary( *(const __CFDictionary **)(*(void *)(a1 + 40) + 80LL),  *(_DWORD *)(a1 + 48));
  if (result) {
    BOOL result = CFRetain(result);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t NEIPSecDBAddSA(uint64_t a1, CFTypeRef cf)
{
  uint64_t v85 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    uint64_t v14 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBAddSA";
    uint64_t v15 = "%s called with null session";
LABEL_35:
    _os_log_fault_impl(&dword_1876B1000, v14, OS_LOG_TYPE_FAULT, v15, buf, 0xCu);
    return 0LL;
  }

  if (!*(void *)(a1 + 80))
  {
    uint64_t v14 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBAddSA";
    uint64_t v15 = "%s called with null session->sas";
    goto LABEL_35;
  }

  int v77 = 0LL;
  unint64_t v78 = 0LL;
  unsigned int v76 = 0;
  unsigned __int8 v75 = 0;
  int v74 = 0;
  unsigned __int8 v73 = 1;
  uint64_t v72 = 0LL;
  int valuePtr = 0;
  int v71 = 0;
  v80[0] = 0;
  buffer[0] = 0;
  int v69 = 0;
  uint64_t v65 = 0LL;
  uint64_t v66 = &v65;
  uint64_t v67 = 0x2000000000LL;
  int v68 = 0;
  uint64_t v61 = 0LL;
  id v62 = &v61;
  uint64_t v63 = 0x2000000000LL;
  uint64_t v64 = 0LL;
  BOOL v4 = NEIPSecDBValidateSADictionary(cf, 0, 0);
  uint64_t v5 = MEMORY[0x1895F87A8];
  uint64_t v6 = (void *)&unk_187871000;
  if (!v4)
  {
    int v13 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      _os_log_error_impl(&dword_1876B1000, v13, OS_LOG_TYPE_ERROR, "%@ add SA dictionary validation failed", buf, 0xCu);
    }

    goto LABEL_107;
  }

  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"UniqueID");
  if (Value) {
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  }
  int64_t v8 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"ReplayWindowSize");
  if (v8) {
    CFNumberGetValue(v8, kCFNumberCharType, &v73);
  }
  uint64_t v9 = CFDictionaryGetValue((CFDictionaryRef)cf, @"EncryptionAlgorithm");
  if (!v9) {
    goto LABEL_41;
  }
  dispatch_time_t v10 = v9;
  if (CFEqual(v9, @"DES"))
  {
    int v11 = 0;
    char v12 = 1;
    goto LABEL_42;
  }

  if (CFEqual(v10, @"3DES"))
  {
    int v11 = 0;
    char v12 = 2;
    goto LABEL_42;
  }

  if (CFEqual(v10, @"AES-128") || CFEqual(v10, @"AES-256"))
  {
    int v11 = 0;
    char v12 = 12;
    goto LABEL_42;
  }

  if (CFEqual(v10, @"AES-128-GCM") || CFEqual(v10, @"AES-256-GCM"))
  {
    int v11 = 0;
    char v12 = 13;
    goto LABEL_42;
  }

  if (CFEqual(v10, @"ChaCha20-Poly1305"))
  {
    int v11 = 0;
    char v12 = 14;
    goto LABEL_42;
  }

  if (CFEqual(v10, @"ChaCha20-Poly1305-IIV"))
  {
    char v12 = 14;
LABEL_33:
    int v11 = 1024;
    goto LABEL_42;
  }

  if (CFEqual(v10, @"AES-128-GCM-IIV") || CFEqual(v10, @"AES-256-GCM-IIV"))
  {
    char v12 = 13;
    goto LABEL_33;
  }

  if (CFEqual(v10, @"NULL-With-AES-128-GMAC") || CFEqual(v10, @"NULL-With-AES-256-GMAC"))
  {
    int v11 = 0;
    char v12 = 15;
    goto LABEL_42;
  }

  if (CFEqual(v10, @"NULL"))
  {
    int v11 = 0;
    char v12 = 3;
  }

  else
  {
LABEL_41:
    int v11 = 0;
    char v12 = 0;
  }

void *__NEIPSecDBAddSA_block_invoke(void *a1)
{
  uint64_t v3 = a1[6];
  uint64_t v2 = (const __CFDictionary *)a1[7];
  int v4 = *(_DWORD *)(v3 + 72);
  else {
    int v5 = 1;
  }
  *(_DWORD *)(v3 + 72) = v5;
  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = v4;
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v2);
  if (MutableCopy)
  {
    uint64_t v7 = MutableCopy;
    CFDictionaryAddValue(MutableCopy, @"Direction", @"Out");
    NEAddValueToIntKeyedDictionary(*(__CFDictionary **)(a1[6] + 80LL), *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL), v7);
    CFRelease(v7);
  }

  BOOL result = NEIPSecDBCreateQueuedRequest(a1[6], 3, *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL));
  *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = result;
  return result;
}

uint64_t NEIPSecDBUpdateSA(uint64_t a1, int a2, CFTypeRef cf)
{
  uint64_t v91 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    unsigned int v22 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBUpdateSA";
    uint64_t v23 = "%s called with null session";
LABEL_43:
    _os_log_fault_impl(&dword_1876B1000, v22, OS_LOG_TYPE_FAULT, v23, buf, 0xCu);
    return 0LL;
  }

  if (!*(void *)(a1 + 80))
  {
    unsigned int v22 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBUpdateSA";
    uint64_t v23 = "%s called with null session->sas";
    goto LABEL_43;
  }

  uint64_t v85 = 0LL;
  int v86 = 0LL;
  unsigned int v84 = 0;
  unsigned __int8 v83 = 0;
  int v82 = 0;
  v87[0] = 0;
  unsigned __int8 v81 = 1;
  uint64_t v80 = 0LL;
  int valuePtr = 0;
  int v79 = 0;
  int v77 = 0;
  uint64_t v73 = 0LL;
  int v74 = &v73;
  uint64_t v75 = 0x2000000000LL;
  uint64_t v76 = 0LL;
  uint64_t v69 = 0LL;
  CFStringRef v70 = &v69;
  uint64_t v71 = 0x2000000000LL;
  uint64_t v72 = 0LL;
  BOOL v6 = NEIPSecDBValidateSADictionary(cf, 0, 0);
  uint64_t v7 = MEMORY[0x1895F87A8];
  int64_t v8 = &unk_187871000;
  if (!v6)
  {
    uint64_t v17 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    __int16 v18 = "%@ update SA dictionary validation failed";
LABEL_26:
    _os_log_error_impl(&dword_1876B1000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0xCu);
    goto LABEL_16;
  }

  uint64_t v9 = _NEIPSecDBGetQueue();
  block[0] = v7;
  block[1] = 0x40000000LL;
  block[2] = __NEIPSecDBUpdateSA_block_invoke;
  block[3] = &unk_18A08DCF8;
  block[4] = &v73;
  void block[5] = a1;
  int v68 = a2;
  dispatch_sync(v9, block);
  dispatch_time_t v10 = (const __CFDictionary *)v74[3];
  if (!v10)
  {
    uint64_t v17 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    __int16 v18 = "%@ update SA, failed to find existing SA";
    goto LABEL_26;
  }

  if (NEIPSecDBFilloutBasicSAInfo(v10, (char *)&v83, &v82, &v84, (void **)&v86, (void **)&v85, v87))
  {
    Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"UniqueID");
    if (Value) {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    }
    char v12 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"ReplayWindowSize");
    if (v12) {
      CFNumberGetValue(v12, kCFNumberCharType, &v81);
    }
    int v13 = CFDictionaryGetValue((CFDictionaryRef)cf, @"EncryptionAlgorithm");
    if (v13)
    {
      uint64_t v14 = v13;
      if (CFEqual(v13, @"DES"))
      {
        int v15 = 0;
        char v16 = 1;
LABEL_24:
        char v64 = v16;
LABEL_50:
        CFIndex v25 = CFDictionaryGetValue((CFDictionaryRef)cf, @"AuthAlgorithm");
        if (!v25) {
          goto LABEL_61;
        }
        int v26 = v25;
        if (CFEqual(v25, @"MD5-96"))
        {
          char v27 = 1;
          goto LABEL_62;
        }

        if (CFEqual(v26, @"SHA1-96"))
        {
          char v27 = 2;
          goto LABEL_62;
        }

        if (CFEqual(v26, @"SHA2-256"))
        {
          char v27 = 6;
          goto LABEL_62;
        }

        if (CFEqual(v26, @"SHA2-384"))
        {
          char v27 = 7;
          goto LABEL_62;
        }

        if (CFEqual(v26, @"SHA2-512")) {
          char v27 = 8;
        }
        else {
LABEL_61:
        }
          char v27 = 0;
LABEL_62:
        uint64_t v28 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, @"EncryptionKey");
        int v29 = v28;
        if (v28) {
          CFIndex Length = CFDataGetLength(v28);
        }
        else {
          CFIndex Length = 0LL;
        }
        unsigned int v31 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, @"AuthKey");
        int v32 = v31;
        if (v31) {
          CFIndex v33 = CFDataGetLength(v31);
        }
        else {
          CFIndex v33 = 0LL;
        }
        if (Length | v33)
        {
          __int128 v34 = (char *)malloc(v33 + Length);
          if (Length)
          {
            BytePtr = CFDataGetBytePtr(v29);
            memcpy(v34, BytePtr, Length);
          }

          if (v33)
          {
            uint64_t v36 = CFDataGetBytePtr(v32);
            memcpy(&v34[Length], v36, v33);
          }
        }

        else
        {
          __int128 v34 = 0LL;
        }

        id v37 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTraversal");
        uint64_t v7 = MEMORY[0x1895F87A8];
        if (v37 && CFBooleanGetValue(v37)) {
          v15 |= 2u;
        }
        uint64_t v38 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAlive");
        if (v38 && CFBooleanGetValue(v38)) {
          v15 |= 4u;
        }
        uint64_t v39 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAliveOffload");
        if (v39 && CFBooleanGetValue(v39)) {
          v15 |= 0x8000u;
        }
        unsigned __int16 v40 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAliveOffloadInterval");
        if (v40) {
          CFNumberGetValue(v40, kCFNumberShortType, &v77);
        }
        id v41 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAliveInterval");
        if (v41) {
          CFNumberGetValue(v41, kCFNumberShortType, (char *)&v77 + 2);
        }
        uint64_t v42 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTDetectedPeer");
        if (v42 && CFBooleanGetValue(v42)) {
          v15 |= 0x1000u;
        }
        dispatch_queue_t v43 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"LifeTimeinSeconds");
        if (v43) {
          CFNumberGetValue(v43, kCFNumberLongType, &v80);
        }
        unsigned int v44 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTPort");
        if (v44) {
          CFNumberGetValue(v44, kCFNumberShortType, &v79);
        }
        uint64_t v45 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTSourcePort");
        if (v45) {
          CFNumberGetValue(v45, kCFNumberShortType, (char *)&v79 + 2);
        }
        int v46 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"sequencePerTrafficClass");
        if (v46) {
          unsigned __int16 v47 = 2 * (CFBooleanGetValue(v46) != 0);
        }
        else {
          unsigned __int16 v47 = 0;
        }
        int v48 = _NEIPSecDBGetQueue();
        v65[0] = v7;
        v65[1] = 0x40000000LL;
        v65[2] = __NEIPSecDBUpdateSA_block_invoke_82;
        v65[3] = &unk_18A08DD20;
        v65[4] = &v69;
        v65[5] = a1;
        int v66 = a2;
        dispatch_sync(v48, v65);
        int v49 = *(dispatch_source_s **)(a1 + 64);
        dispatch_queue_t v50 = _NEIPSecDBGetQueue();
        int v51 = v87;
        if (!v87[0]) {
          int v51 = 0LL;
        }
        if (NEPFKeySendUpdate( v49,  (uint64_t)v50,  v83,  v82,  v85,  v86,  v84,  valuePtr,  v81,  (const UInt8 *)v34,  v64,  Length,  v27,  v33,  v15,  v47,  0,  v63,  0,  0,  v80,  SHIDWORD(v80),  0,  0,  0,  HIWORD(v79),  v79,  HIWORD(v77),  v77,  1,  (unint64_t)v51))
        {
          int v52 = NEIPSecDBCopyResponseForQueuedRequest(v70[3], 0LL);
          uint64_t v53 = (os_log_s *)ne_log_obj();
          uint64_t v54 = v53;
          int64_t v8 = &unk_187871000;
          if (v52)
          {
            uint64_t v21 = 1LL;
            if (os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)__int128 buf = 138412802;
              *(void *)&uint8_t buf[4] = a1;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = a2;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = bswap32(v84);
              _os_log_impl(&dword_1876B1000, v54, OS_LOG_TYPE_INFO, "%@ updated SAID %u SPI %08X", buf, 0x18u);
            }

            goto LABEL_109;
          }

          if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          {
LABEL_108:
            uint64_t v21 = 0LL;
LABEL_109:
            int v58 = v74;
            __int128 v59 = (const void *)v74[3];
            if (v59)
            {
              CFRelease(v59);
              v58[3] = 0LL;
            }

            if (v34)
            {
              memset_s(v34, v33 + Length, 0, v33 + Length);
              free(v34);
            }

            goto LABEL_113;
          }

          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = a1;
          int v56 = "%@ failed to receive response for pfkey update SA";
          char v57 = v54;
        }

        else
        {
          int v55 = (os_log_s *)ne_log_obj();
          int64_t v8 = (void *)&unk_187871000;
          if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
            goto LABEL_108;
          }
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = a1;
          int v56 = "%@ pfkey send update SA failed";
          char v57 = v55;
        }

        _os_log_error_impl(&dword_1876B1000, v57, OS_LOG_TYPE_ERROR, v56, buf, 0xCu);
        goto LABEL_108;
      }

      if (CFEqual(v14, @"3DES"))
      {
        int v15 = 0;
        char v16 = 2;
        goto LABEL_24;
      }

      if (CFEqual(v14, @"AES-128") || CFEqual(v14, @"AES-256"))
      {
        int v15 = 0;
        char v16 = 12;
        goto LABEL_24;
      }

      if (CFEqual(v14, @"AES-128-GCM") || CFEqual(v14, @"AES-256-GCM"))
      {
        int v15 = 0;
        char v16 = 13;
        goto LABEL_24;
      }

      if (CFEqual(v14, @"ChaCha20-Poly1305"))
      {
        int v15 = 0;
        char v16 = 14;
        goto LABEL_24;
      }

      if (CFEqual(v14, @"ChaCha20-Poly1305-IIV"))
      {
        char v24 = 14;
LABEL_41:
        char v64 = v24;
        int v15 = 1024;
        goto LABEL_50;
      }

      if (CFEqual(v14, @"AES-128-GCM-IIV") || CFEqual(v14, @"AES-256-GCM-IIV"))
      {
        char v24 = 13;
        goto LABEL_41;
      }

      if (CFEqual(v14, @"NULL-With-AES-128-GMAC") || CFEqual(v14, @"NULL-With-AES-256-GMAC"))
      {
        int v15 = 0;
        char v16 = 15;
        goto LABEL_24;
      }

      if (CFEqual(v14, @"NULL"))
      {
        int v15 = 0;
        char v16 = 3;
        goto LABEL_24;
      }
    }

    int v15 = 0;
    char v64 = 0;
    goto LABEL_50;
  }

const void *__NEIPSecDBUpdateSA_block_invoke(uint64_t a1)
{
  BOOL result = NEGetValueFromIntKeyedDictionary( *(const __CFDictionary **)(*(void *)(a1 + 40) + 80LL),  *(_DWORD *)(a1 + 48));
  if (result) {
    BOOL result = CFRetain(result);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

void *__NEIPSecDBUpdateSA_block_invoke_82(uint64_t a1)
{
  BOOL result = NEIPSecDBCreateQueuedRequest(*(void *)(a1 + 40), 2, *(_DWORD *)(a1 + 48));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t NEIPSecDBMigrateSA(uint64_t a1, int a2, CFTypeRef cf)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    uint64_t v45 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBMigrateSA";
    int v46 = "%s called with null session";
LABEL_89:
    _os_log_fault_impl(&dword_1876B1000, v45, OS_LOG_TYPE_FAULT, v46, buf, 0xCu);
    return 0LL;
  }

  if (!*(void *)(a1 + 80))
  {
    uint64_t v45 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBMigrateSA";
    int v46 = "%s called with null session->sas";
    goto LABEL_89;
  }

  int v66 = 0LL;
  uint64_t v67 = 0LL;
  char v64 = 0LL;
  uint64_t v65 = 0LL;
  unsigned int v63 = 0;
  unsigned __int16 v62 = 0;
  __int16 v61 = 0;
  int valuePtr = 0;
  uint8_t v59 = 0;
  v70[0] = 0;
  v69[0] = 0;
  buffer[0] = 0;
  uint64_t v55 = 0LL;
  int v56 = &v55;
  uint64_t v57 = 0x2000000000LL;
  uint64_t v58 = 0LL;
  uint64_t v51 = 0LL;
  int v52 = &v51;
  uint64_t v53 = 0x2000000000LL;
  uint64_t v54 = 0LL;
  BOOL v6 = NEIPSecDBValidateSADictionary(cf, 0, 1);
  uint64_t v7 = MEMORY[0x1895F87A8];
  if (!v6)
  {
    char v12 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_67;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    int v13 = "%@ migrate SA dictionary validation failed";
    goto LABEL_11;
  }

  int64_t v8 = _NEIPSecDBGetQueue();
  block[0] = v7;
  block[1] = 0x40000000LL;
  block[2] = __NEIPSecDBMigrateSA_block_invoke;
  block[3] = &unk_18A08DD48;
  block[4] = &v55;
  void block[5] = a1;
  int v50 = a2;
  dispatch_sync(v8, block);
  uint64_t v9 = (const __CFDictionary *)v56[3];
  if (!v9)
  {
    char v12 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_67;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    int v13 = "%@ migrate SA, failed to find existing SA";
    goto LABEL_11;
  }

  Value = CFDictionaryGetValue(v9, @"Direction");
  if (Value) {
    int v11 = CFEqual(Value, @"In");
  }
  else {
    int v11 = 0;
  }
  if (!NEIPSecDBFilloutBasicSAInfo((CFDictionaryRef)v56[3], (char *)&v59, 0LL, &v63, &v67, &v66, v70)
    || !NEIPSecDBFilloutBasicSAInfo((CFDictionaryRef)cf, 0LL, 0LL, 0LL, &v65, &v64, v69))
  {
    goto LABEL_67;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"OutgoingInterface"))
  {
    int v15 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"OutgoingInterface");
    CFStringGetCString(v15, buffer, 16LL, 0x600u);
  }

  char v16 = CFDictionaryGetValue((CFDictionaryRef)cf, @"EncryptionAlgorithm");
  uint64_t v17 = v16;
  if (v16)
  {
    if (CFEqual(v16, @"ChaCha20-Poly1305-IIV")
      || CFEqual(v17, @"AES-128-GCM-IIV")
      || CFEqual(v17, @"AES-256-GCM-IIV"))
    {
      LODWORD(v17) = 1024;
    }

    else
    {
      LODWORD(v17) = 0;
    }
  }

  __int16 v18 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTraversal");
  if (v18 && CFBooleanGetValue(v18)) {
    LODWORD(v17) = v17 | 2;
  }
  char v19 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAlive");
  if (v19 && CFBooleanGetValue(v19)) {
    LODWORD(v17) = v17 | 4;
  }
  uint64_t v20 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAliveOffload");
  if (v20 && CFBooleanGetValue(v20)) {
    LODWORD(v17) = v17 | 0x8000;
  }
  uint64_t v21 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAliveOffloadInterval");
  if (v21) {
    CFNumberGetValue(v21, kCFNumberShortType, &valuePtr);
  }
  unsigned int v22 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTKeepAliveInterval");
  if (v22) {
    CFNumberGetValue(v22, kCFNumberShortType, (char *)&valuePtr + 2);
  }
  uint64_t v23 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTDetectedPeer");
  if (v23 && CFBooleanGetValue(v23)) {
    LODWORD(v17) = v17 | 0x1000;
  }
  char v24 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTPort");
  if (v24) {
    CFNumberGetValue(v24, kCFNumberShortType, &v61);
  }
  CFIndex v25 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NATTSourcePort");
  if (v25) {
    CFNumberGetValue(v25, kCFNumberShortType, &v62);
  }
  int v26 = _NEIPSecDBGetQueue();
  v47[0] = v7;
  v47[1] = 0x40000000LL;
  v47[2] = __NEIPSecDBMigrateSA_block_invoke_85;
  v47[3] = &unk_18A08DD70;
  v47[4] = &v51;
  v47[5] = a1;
  int v48 = a2;
  dispatch_sync(v26, v47);
  if (!v52[3]) {
    goto LABEL_67;
  }
  char v27 = *(dispatch_source_s **)(a1 + 64);
  dispatch_queue_t v28 = _NEIPSecDBGetQueue();
  uint64_t v29 = (uint64_t)v66;
  uint64_t v30 = v70;
  if (!v70[0]) {
    uint64_t v30 = 0LL;
  }
  if (v11) {
    uint64_t v31 = (uint64_t)v66;
  }
  else {
    uint64_t v31 = (uint64_t)v67;
  }
  if (v11) {
    uint64_t v29 = (uint64_t)v67;
  }
  uint64_t v32 = (uint64_t)v64;
  if (v11) {
    uint64_t v33 = (uint64_t)v64;
  }
  else {
    uint64_t v33 = (uint64_t)v65;
  }
  if (v11) {
    uint64_t v32 = (uint64_t)v65;
  }
  __int128 v34 = v69;
  if (!v69[0]) {
    __int128 v34 = 0LL;
  }
  uint64_t v35 = buffer;
  if (!buffer[0]) {
    uint64_t v35 = 0LL;
  }
  if (!NEPFKeySendMigrate( v27,  (uint64_t)v28,  v59,  v63,  (pid_t)v17,  v62,  v61,  SHIWORD(valuePtr),  valuePtr,  v31,  v29,  v30,  v33,  v32,  v34,  v35))
  {
    char v12 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_67;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    int v13 = "%@ pfkey send migrate SA failed";
LABEL_11:
    uint64_t v14 = v12;
LABEL_12:
    _os_log_error_impl(&dword_1876B1000, v14, OS_LOG_TYPE_ERROR, v13, buf, 0xCu);
    goto LABEL_67;
  }

  int v36 = NEIPSecDBCopyResponseForQueuedRequest(v52[3], 0LL);
  id v37 = (os_log_s *)ne_log_obj();
  uint64_t v38 = v37;
  if (v36)
  {
    uint64_t v39 = 1LL;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 138412802;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = bswap32(v63);
      _os_log_impl(&dword_1876B1000, v38, OS_LOG_TYPE_INFO, "%@ migrated SAID %u SPI %08X", buf, 0x18u);
    }

    goto LABEL_68;
  }

  if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    int v13 = "%@ failed to receive response for pfkey migrate SA";
    uint64_t v14 = v38;
    goto LABEL_12;
  }

LABEL_67:
  uint64_t v39 = 0LL;
LABEL_68:
  unsigned __int16 v40 = v56;
  id v41 = (const void *)v56[3];
  if (v41)
  {
    CFRelease(v41);
    v40[3] = 0LL;
  }

  if (v67) {
    free(v67);
  }
  if (v66) {
    free(v66);
  }
  if (v65) {
    free(v65);
  }
  if (v64) {
    free(v64);
  }
  uint64_t v42 = v52[3];
  if (v42)
  {
    dispatch_queue_t v43 = _NEIPSecDBGetQueue();
    *(void *)__int128 buf = v7;
    *(void *)&uint8_t buf[8] = 0x40000000LL;
    *(void *)&uint8_t buf[16] = __NEIPSecDBRemoveQueuedRequest_block_invoke;
    uint64_t v72 = &__block_descriptor_tmp_163;
    uint64_t v73 = v42;
    dispatch_sync(v43, buf);
    free((void *)v52[3]);
  }

  _Block_object_dispose(&v51, 8);
  _Block_object_dispose(&v55, 8);
  return v39;
}

const void *__NEIPSecDBMigrateSA_block_invoke(uint64_t a1)
{
  BOOL result = NEGetValueFromIntKeyedDictionary( *(const __CFDictionary **)(*(void *)(a1 + 40) + 80LL),  *(_DWORD *)(a1 + 48));
  if (result) {
    BOOL result = CFRetain(result);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

void *__NEIPSecDBMigrateSA_block_invoke_85(uint64_t a1)
{
  BOOL result = NEIPSecDBCreateQueuedRequest(*(void *)(a1 + 40), 26, *(_DWORD *)(a1 + 48));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t NEIPSecDBDeleteSA(uint64_t a1, int a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  int v4 = (os_log_s *)ne_log_obj();
  int v5 = v4;
  if (a1)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      _os_log_impl(&dword_1876B1000, v5, OS_LOG_TYPE_INFO, "%@ deleting SAID %u", buf, 0x12u);
    }

    uint64_t v24 = 0LL;
    CFIndex v25 = &v24;
    uint64_t v26 = 0x2000000000LL;
    uint64_t v27 = 0LL;
    uint64_t v20 = 0LL;
    uint64_t v21 = &v20;
    uint64_t v22 = 0x2000000000LL;
    uint64_t v23 = 0LL;
    BOOL v6 = _NEIPSecDBGetQueue();
    uint64_t v7 = MEMORY[0x1895F87A8];
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 0x40000000LL;
    v18[2] = __NEIPSecDBDeleteSA_block_invoke;
    v18[3] = &unk_18A08DD98;
    v18[5] = &v20;
    v18[6] = a1;
    int v19 = a2;
    v18[4] = &v24;
    dispatch_sync(v6, v18);
    int64_t v8 = (const __CFDictionary *)v25[3];
    if (v8)
    {
      if (!_NEIPSecDBDeleteSA(a1, v8)
        || !NEIPSecDBCopyResponseForQueuedRequest(v21[3], 0LL))
      {
        char v12 = (os_log_s *)ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412546;
          *(void *)&uint8_t buf[4] = a1;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = a2;
          _os_log_error_impl( &dword_1876B1000,  v12,  OS_LOG_TYPE_ERROR,  "%@ failed to receive response for pfkey delete SAID %u",  buf,  0x12u);
        }

        uint64_t v10 = 0LL;
        goto LABEL_15;
      }

      uint64_t v9 = (os_log_s *)ne_log_obj();
      uint64_t v10 = 1LL;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = a1;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a2;
        int v11 = "%@ deleted SAID %u";
LABEL_14:
        _os_log_impl(&dword_1876B1000, v9, OS_LOG_TYPE_INFO, v11, buf, 0x12u);
      }
    }

    else
    {
      uint64_t v9 = (os_log_s *)ne_log_obj();
      uint64_t v10 = 1LL;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = a1;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a2;
        int v11 = "%@ delete SA, saData is NULL for SAID %u, may already be removed";
        goto LABEL_14;
      }
    }

void __NEIPSecDBDeleteSA_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (*(void *)(v2 + 80))
  {
    uint64_t v3 = NEGetValueFromIntKeyedDictionary(*(const __CFDictionary **)(v2 + 80), *(_DWORD *)(a1 + 56));
    if (v3) {
      uint64_t v3 = CFRetain(v3);
    }
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
    uint64_t v2 = *(void *)(a1 + 48);
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = NEIPSecDBCreateQueuedRequest( v2,  4,  *(_DWORD *)(a1 + 56));
      uint64_t v2 = *(void *)(a1 + 48);
    }
  }

  int v4 = *(void **)(v2 + 104);
  if (v4)
  {
    int v5 = *(_DWORD *)(a1 + 56);
    do
    {
      BOOL v6 = *(void **)v4;
      int v7 = *((_DWORD *)v4 + 4);
      if (v7) {
        BOOL v8 = v7 == v5;
      }
      else {
        BOOL v8 = 0;
      }
      if (v8)
      {
        *((_DWORD *)v4 + 4) = 0;
        if (!*((_DWORD *)v4 + 5)) {
          goto LABEL_24;
        }
      }

      else
      {
        int v9 = *((_DWORD *)v4 + 5);
        if (v9) {
          BOOL v10 = v9 == v5;
        }
        else {
          BOOL v10 = 0;
        }
        if (v10)
        {
          int v9 = 0;
          *((_DWORD *)v4 + 5) = 0;
        }

        if (!v7 && !v9)
        {
LABEL_24:
          int v11 = (dispatch_source_s *)*((void *)v4 + 3);
          if (v11)
          {
            if (!dispatch_source_testcancel(*((dispatch_source_t *)v4 + 3)))
            {
              dispatch_source_cancel(v11);
              BOOL v6 = *(void **)v4;
            }

            *((void *)v4 + 3) = 0LL;
          }

          if (v6) {
            v6[1] = *((void *)v4 + 1);
          }
          **((void **)v4 + 1) = v6;
          free(v4);
          return;
        }
      }

      int v4 = v6;
    }

    while (v6);
  }

uint64_t _NEIPSecDBDeleteSA(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  unsigned int v20 = 0;
  char v19 = 0;
  int v18 = 0;
  v27[0] = 0;
  Value = CFDictionaryGetValue(theDict, @"Direction");
  if (Value) {
    int v5 = CFEqual(Value, @"In");
  }
  else {
    int v5 = 0;
  }
  if (!NEIPSecDBFilloutBasicSAInfo(theDict, &v19, &v18, &v20, &v22, &v21, v27))
  {
    uint64_t v14 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
LABEL_20:
      uint64_t v15 = 0LL;
      goto LABEL_21;
    }

    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v24 = a1;
    __int16 v25 = 1024;
    unsigned int v26 = bswap32(v20);
    char v16 = "%@ NEIPSecDBFilloutBasicSAInfo error for SPI %08X";
LABEL_27:
    _os_log_error_impl(&dword_1876B1000, v14, OS_LOG_TYPE_ERROR, v16, buf, 0x12u);
    goto LABEL_20;
  }

  BOOL v6 = *(dispatch_source_s **)(a1 + 64);
  dispatch_queue_t v7 = _NEIPSecDBGetQueue();
  if (v5) {
    int v9 = v21;
  }
  else {
    int v9 = v22;
  }
  if (v5) {
    BOOL v10 = v22;
  }
  else {
    BOOL v10 = v21;
  }
  if (v27[0]) {
    int v11 = v27;
  }
  else {
    int v11 = 0LL;
  }
  BOOL v12 = NEPFKeySendDelete(v6, (uint64_t)v7, v19, v8, (uint64_t)v9, (uint64_t)v10, v20, v11);
  int v13 = (os_log_s *)ne_log_obj();
  uint64_t v14 = v13;
  if (!v12)
  {
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v24 = a1;
    __int16 v25 = 1024;
    unsigned int v26 = bswap32(v20);
    char v16 = "%@ pfkey send delete failed for SPI %08X";
    goto LABEL_27;
  }

  uint64_t v15 = 1LL;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v24 = a1;
    __int16 v25 = 1024;
    unsigned int v26 = bswap32(v20);
    _os_log_impl(&dword_1876B1000, v14, OS_LOG_TYPE_INFO, "%@ deleted SA SPI %08X", buf, 0x12u);
  }

uint64_t NEIPSecDBCopySA(uint64_t a1, int a2)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v42 = 0LL;
    dispatch_queue_t v43 = 0LL;
    unsigned int v41 = 0;
    char v40 = 0;
    int v39 = 0;
    v44[0] = 0;
    uint64_t v35 = 0LL;
    int v36 = &v35;
    uint64_t v37 = 0x2000000000LL;
    uint64_t v38 = 0LL;
    uint64_t v31 = 0LL;
    uint64_t v32 = &v31;
    uint64_t v33 = 0x2000000000LL;
    uint64_t v34 = 0LL;
    uint64_t v30 = 0LL;
    int v4 = _NEIPSecDBGetQueue();
    uint64_t v5 = MEMORY[0x1895F87A8];
    v28[0] = MEMORY[0x1895F87A8];
    v28[1] = 0x40000000LL;
    v28[2] = __NEIPSecDBCopySA_block_invoke;
    v28[3] = &unk_18A08DDC0;
    v28[5] = &v31;
    v28[6] = a1;
    int v29 = a2;
    v28[4] = &v35;
    dispatch_sync(v4, v28);
    BOOL v6 = (const __CFDictionary *)v36[3];
    if (v6)
    {
      Value = CFDictionaryGetValue(v6, @"Direction");
      if (Value) {
        int v8 = CFEqual(Value, @"In");
      }
      else {
        int v8 = 0;
      }
      if (!NEIPSecDBFilloutBasicSAInfo((CFDictionaryRef)v36[3], &v40, &v39, &v41, &v43, &v42, v44)) {
        goto LABEL_27;
      }
      int v11 = *(dispatch_source_s **)(a1 + 64);
      dispatch_queue_t v12 = _NEIPSecDBGetQueue();
      if (v8) {
        uint64_t v14 = v42;
      }
      else {
        uint64_t v14 = v43;
      }
      if (v8) {
        uint64_t v15 = v43;
      }
      else {
        uint64_t v15 = v42;
      }
      if (v44[0]) {
        char v16 = v44;
      }
      else {
        char v16 = 0LL;
      }
      if (NEPFKeySendGet(v11, (uint64_t)v12, v40, v13, (uint64_t)v14, (uint64_t)v15, v41, v16))
      {
        int v17 = NEIPSecDBCopyResponseForQueuedRequest(v32[3], &v30);
        int v18 = (os_log_s *)ne_log_obj();
        char v19 = v18;
        if (v17)
        {
          if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)__int128 buf = 138412802;
            *(void *)&uint8_t buf[4] = a1;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = a2;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = bswap32(v41);
            _os_log_impl(&dword_1876B1000, v19, OS_LOG_TYPE_INFO, "%@ copied SAID %u cSPI %08X", buf, 0x18u);
          }

          goto LABEL_27;
        }

        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
LABEL_27:
          uint64_t v21 = v36;
          uint64_t v22 = (const void *)v36[3];
          if (v22)
          {
            CFRelease(v22);
            v21[3] = 0LL;
          }

          if (v43) {
            free(v43);
          }
          if (v42) {
            free(v42);
          }
          uint64_t v23 = v32[3];
          if (v23)
          {
            uint64_t v24 = _NEIPSecDBGetQueue();
            *(void *)__int128 buf = v5;
            *(void *)&uint8_t buf[8] = 0x40000000LL;
            *(void *)&uint8_t buf[16] = __NEIPSecDBRemoveQueuedRequest_block_invoke;
            int v46 = &__block_descriptor_tmp_163;
            uint64_t v47 = v23;
            dispatch_sync(v24, buf);
            free((void *)v32[3]);
          }

          uint64_t v25 = v30;
          _Block_object_dispose(&v31, 8);
          _Block_object_dispose(&v35, 8);
          return v25;
        }

        *(_DWORD *)__int128 buf = 138412290;
        *(void *)&uint8_t buf[4] = a1;
        BOOL v10 = "%@ failed to receive response for pfkey get SA";
        unsigned int v20 = v19;
LABEL_25:
        _os_log_error_impl(&dword_1876B1000, v20, OS_LOG_TYPE_ERROR, v10, buf, 0xCu);
        goto LABEL_27;
      }

      int v9 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      BOOL v10 = "%@ pfkey send get SA failed";
    }

    else
    {
      int v9 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      BOOL v10 = "%@ copy SA, saData is NULL";
    }

    unsigned int v20 = v9;
    goto LABEL_25;
  }

  uint64_t v27 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBCopySA";
    _os_log_fault_impl(&dword_1876B1000, v27, OS_LOG_TYPE_FAULT, "%s called with null session", buf, 0xCu);
  }

  return 0LL;
}

__CFArray *NEIPSecDBCopySAIDs(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)&__int128 buf = 0LL;
    *((void *)&buf + 1) = &buf;
    uint64_t v16 = 0x2000000000LL;
    uint64_t v17 = 0LL;
    uint64_t v2 = _NEIPSecDBGetQueue();
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 0x40000000LL;
    void v14[2] = __NEIPSecDBCopySAIDs_block_invoke;
    v14[3] = &unk_18A08DDE8;
    v14[4] = &buf;
    v14[5] = a1;
    dispatch_sync(v2, v14);
    uint64_t v3 = *(const __CFDictionary **)(*((void *)&buf + 1) + 24LL);
    if (v3) {
      CFIndex Count = CFDictionaryGetCount(v3);
    }
    else {
      CFIndex Count = 0LL;
    }
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], Count, MEMORY[0x189605228]);
    BOOL v6 = Mutable;
    if (Count >= 1 && Mutable)
    {
      dispatch_queue_t v7 = (const void **)calloc(Count, 8uLL);
      int v8 = (const void **)calloc(Count, 8uLL);
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(*((void *)&buf + 1) + 24LL), v7, v8);
      for (uint64_t i = 0LL; i != Count; ++i)
        CFArrayAppendValue(v6, v7[i]);
      free(v7);
      free(v8);
    }

    uint64_t v10 = *((void *)&buf + 1);
    int v11 = *(const void **)(*((void *)&buf + 1) + 24LL);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(v10 + 24) = 0LL;
    }

    _Block_object_dispose(&buf, 8);
  }

  else
  {
    uint64_t v13 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "NEIPSecDBCopySAIDs";
      _os_log_fault_impl(&dword_1876B1000, v13, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&buf, 0xCu);
    }

    return 0LL;
  }

  return v6;
}

CFDictionaryRef __NEIPSecDBCopySAIDs_block_invoke(CFDictionaryRef result)
{
  uint64_t v1 = *(const __CFDictionary **)(*((void *)result + 5) + 80LL);
  if (v1)
  {
    CFDictionaryRef v2 = result;
    BOOL result = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v1);
    *(void *)(*(void *)(*((void *)v2 + 4) + 8LL) + 24LL) = result;
  }

  return result;
}

uint64_t NEIPSecDBFlushSAs(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  CFDictionaryRef v2 = (os_log_s *)ne_log_obj();
  uint64_t v3 = v2;
  if (a1)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = a1;
      _os_log_impl(&dword_1876B1000, v3, OS_LOG_TYPE_INFO, "%@ flush all SAs", (uint8_t *)&buf, 0xCu);
    }

    uint64_t v23 = 0LL;
    uint64_t v24 = &v23;
    uint64_t v25 = 0x2000000000LL;
    uint64_t v26 = 0LL;
    uint64_t v19 = 0LL;
    unsigned int v20 = &v19;
    uint64_t v21 = 0x2000000000LL;
    uint64_t v22 = 0LL;
    int v4 = _NEIPSecDBGetQueue();
    uint64_t v5 = MEMORY[0x1895F87A8];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __NEIPSecDBFlushSAs_block_invoke;
    block[3] = &unk_18A08DE10;
    void block[5] = &v19;
    void block[6] = a1;
    block[4] = &v23;
    dispatch_sync(v4, block);
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v24[3]);
    if (Count < 1) {
      goto LABEL_8;
    }
    size_t v7 = Count;
    int v8 = (const void **)calloc(Count, 8uLL);
    int v9 = (const void **)calloc(v7, 8uLL);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)v24[3], v8, v9);
    for (uint64_t i = 0LL; i != v7; _NEIPSecDBDeleteSA(a1, (CFDictionaryRef)v9[i++]))
      ;
    free(v8);
    free(v9);
    if (NEIPSecDBCopyResponseForQueuedRequest(v20[3], 0LL))
    {
LABEL_8:
      uint64_t v11 = 1LL;
    }

    else
    {
      dispatch_queue_t v12 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl( &dword_1876B1000,  v12,  OS_LOG_TYPE_ERROR,  "failed to receive response for pfkey flush SA",  (uint8_t *)&buf,  2u);
      }

      uint64_t v11 = 0LL;
    }

    uint64_t v13 = v24;
    uint64_t v14 = (const void *)v24[3];
    if (v14)
    {
      CFRelease(v14);
      v13[3] = 0LL;
    }

    uint64_t v15 = v20[3];
    if (v15)
    {
      uint64_t v16 = _NEIPSecDBGetQueue();
      *(void *)&__int128 buf = v5;
      *((void *)&buf + 1) = 0x40000000LL;
      uint64_t v28 = __NEIPSecDBRemoveQueuedRequest_block_invoke;
      int v29 = &__block_descriptor_tmp_163;
      uint64_t v30 = v15;
      dispatch_sync(v16, &buf);
      free((void *)v20[3]);
    }

    _Block_object_dispose(&v19, 8);
    _Block_object_dispose(&v23, 8);
  }

  else
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "NEIPSecDBFlushSAs";
      _os_log_fault_impl(&dword_1876B1000, v3, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&buf, 0xCu);
    }

    return 0LL;
  }

  return v11;
}

void *__NEIPSecDBFlushSAs_block_invoke(void *result)
{
  uint64_t v1 = *(const __CFDictionary **)(result[6] + 80LL);
  if (v1)
  {
    CFDictionaryRef v2 = result;
    *(void *)(*(void *)(result[4] + 8LL) + 24LL) = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v1);
    BOOL result = NEIPSecDBCreateQueuedRequest(v2[6], 9, 0);
    *(void *)(*(void *)(v2[5] + 8LL) + 24LL) = result;
  }

  return result;
}

uint64_t NEIPSecDBAddPolicy(uint64_t a1, CFTypeRef cf)
{
  uint64_t v96 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    uint64_t v10 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBAddPolicy";
    uint64_t v11 = "%s called with null session";
LABEL_192:
    _os_log_fault_impl(&dword_1876B1000, v10, OS_LOG_TYPE_FAULT, v11, buf, 0xCu);
    return 0LL;
  }

  if (!*(void *)(a1 + 88))
  {
    uint64_t v10 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEIPSecDBAddPolicy";
    uint64_t v11 = "%s called with null session->policies";
    goto LABEL_192;
  }

  int valuePtr = 255;
  buffer[0] = 0;
  v92[0] = 0;
  v91[0] = 0;
  uint64_t v84 = 0LL;
  uint64_t v85 = &v84;
  uint64_t v86 = 0x2000000000LL;
  int v87 = 0;
  uint64_t v80 = 0LL;
  unsigned __int8 v81 = &v80;
  uint64_t v82 = 0x2000000000LL;
  uint64_t v83 = 0LL;
  if (NEInitCFTypes_onceToken == -1)
  {
    if (!cf) {
      goto LABEL_97;
    }
  }

  else
  {
    dispatch_once(&NEInitCFTypes_onceToken, &__block_literal_global_22164);
    if (!cf) {
      goto LABEL_97;
    }
  }

  uint64_t v4 = CFDICTIONARY_TYPE;
  if (CFGetTypeID(cf) != v4) {
    goto LABEL_97;
  }
  if (!NEGetValueWithType((const __CFDictionary *)cf, @"Mode", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3833;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"Mode";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_96;
  }

  if (!NEGetValueWithType((const __CFDictionary *)cf, @"IPSecProtocol", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3834;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"IPSecProtocol";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_96;
  }

  if (!NEGetValueWithType((const __CFDictionary *)cf, @"LocalAddress", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3835;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"LocalAddress";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_96;
  }

  if (!NEGetValueWithType((const __CFDictionary *)cf, @"RemoteAddress", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3836;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"RemoteAddress";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"LocalPrefix")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"LocalPrefix", CFNUMBER_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3837;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"LocalPrefix";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFNUMBER_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"RemotePrefix")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"RemotePrefix", CFNUMBER_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3838;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"RemotePrefix";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFNUMBER_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"LocalPort")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"LocalPort", CFNUMBER_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3839;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"LocalPort";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFNUMBER_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"RemotePort")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"RemotePort", CFNUMBER_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3840;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"RemotePort";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFNUMBER_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"UpperLayerProtocol")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"UpperLayerProtocol", CFNUMBER_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3842;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"UpperLayerProtocol";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFNUMBER_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"UniqueID")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"UniqueID", CFNUMBER_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3843;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"UniqueID";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFNUMBER_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"Direction")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"Direction", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3844;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"Direction";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"Level")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"Level", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3846;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"Level";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"OuterLocalAddress")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"OuterLocalAddress", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3848;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"OuterLocalAddress";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"OuterRemoteAddress")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"OuterRemoteAddress", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3849;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"OuterRemoteAddress";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"IPSecInterface")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"IPSecInterface", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3851;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"IPSecInterface";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"InternalInterface")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"InternalInterface", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3852;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"InternalInterface";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"OutgoingInterface")
    && !NEGetValueWithType((const __CFDictionary *)cf, @"OutgoingInterface", CFSTRING_TYPE))
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    *(_DWORD *)__int128 buf = 136315906;
    *(void *)&uint8_t buf[4] = "NEIPSecDBValidatePolicyDictionary";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3853;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = @"OutgoingInterface";
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = CFSTRING_TYPE;
    int v9 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_96;
  }

  if (!CFDictionaryContainsKey((CFDictionaryRef)cf, @"IntializeDisabled")
    || NEGetValueWithType((const __CFDictionary *)cf, @"IntializeDisabled", CFBOOLEAN_TYPE))
  {
    if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"Mode"))
    {
      Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"Mode");
      if (Value) {
        LODWORD(Value) = CFEqual(Value, @"Transport");
      }
      BOOL v6 = (_DWORD)Value == 0;
      if ((_DWORD)Value) {
        char v7 = 1;
      }
      else {
        char v7 = 2;
      }
    }

    else
    {
      BOOL v6 = 1;
      char v7 = 2;
    }

    if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"Direction"))
    {
      uint64_t v13 = CFDictionaryGetValue((CFDictionaryRef)cf, @"Direction");
      if (!v13) {
        goto LABEL_107;
      }
      uint64_t v14 = v13;
      if (CFEqual(v13, @"In"))
      {
        char v15 = 0;
        char v16 = 1;
        goto LABEL_90;
      }

      if (!CFEqual(v14, @"Out"))
      {
LABEL_107:
        unsigned int v20 = (os_log_s *)ne_log_obj();
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          goto LABEL_98;
        }
        *(_WORD *)__int128 buf = 0;
        uint64_t v24 = "add policy, invalid direction";
        goto LABEL_103;
      }

      char v16 = 0;
      char v15 = 1;
    }

    else
    {
      char v16 = 0;
      char v15 = 0;
    }

LABEL_90:
    if (!CFDictionaryContainsKey((CFDictionaryRef)cf, @"IPSecProtocol"))
    {
      __int16 v76 = 0;
      goto LABEL_112;
    }

    uint64_t v17 = CFDictionaryGetValue((CFDictionaryRef)cf, @"IPSecProtocol");
    if (v17)
    {
      uint64_t v18 = v17;
      if (CFEqual(v17, @"ESP"))
      {
        __int16 v19 = 50;
LABEL_111:
        __int16 v76 = v19;
LABEL_112:
        if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"UpperLayerProtocol"))
        {
          uint64_t v25 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"UpperLayerProtocol");
          CFNumberGetValue(v25, kCFNumberIntType, &valuePtr);
        }

        char v77 = v7;
        char v73 = v15;
        if (v6)
        {
          if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"OuterLocalAddress"))
          {
            uint64_t v26 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"OuterLocalAddress");
            uint64_t v27 = (const UInt8 *)NECreateAddressStructFromString(v26, 0LL, 0LL);
          }

          else
          {
            uint64_t v27 = 0LL;
          }

          if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"OuterRemoteAddress"))
          {
            uint64_t v28 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"OuterRemoteAddress");
            int v29 = (UInt8 *)NECreateAddressStructFromString(v28, 0LL, 0LL);
LABEL_124:
            uint64_t v30 = CFDictionaryGetValue((CFDictionaryRef)cf, @"Level");
            unint64_t v78 = v27;
            if (v30 && (uint64_t v31 = v30, !CFEqual(v30, @"None")))
            {
              if (CFEqual(v31, @"Unique"))
              {
                if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"UniqueID"))
                {
                  *(_DWORD *)__int128 buf = 0;
                  int v66 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"UniqueID");
                  CFNumberGetValue(v66, kCFNumberIntType, buf);
                  WORD2(v75) = *(_WORD *)buf;
                }

                else
                {
                  WORD2(v75) = 0;
                }

                char v74 = 3;
                LOWORD(v75) = 2;
                goto LABEL_128;
              }

              if (!CFEqual(v31, @"Require"))
              {
                if (!CFEqual(v31, @"Discard"))
                {
                  uint64_t v72 = (os_log_s *)ne_log_obj();
                  if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)__int128 buf = 0;
                    _os_log_error_impl( &dword_1876B1000,  v72,  OS_LOG_TYPE_ERROR,  "add policy, invalid policy level",  buf,  2u);
                  }

                  uint64_t v47 = 0LL;
                  unsigned int v44 = 0LL;
                  int v39 = 0LL;
                  int v36 = 0LL;
                  goto LABEL_171;
                }

                uint64_t v75 = 0LL;
                char v74 = 0;
LABEL_128:
                char v33 = v16;
                uint64_t v34 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"LocalAddress");
                uint64_t v35 = CFDictionaryGetValue((CFDictionaryRef)cf, @"LocalPort");
                int v36 = NECreateAddressStructFromString(v34, (uint64_t)v35, 0LL);
                if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"LocalRangeEndAddress"))
                {
                  uint64_t v37 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"LocalRangeEndAddress");
                  uint64_t v38 = CFDictionaryGetValue((CFDictionaryRef)cf, @"LocalRangeEndPort");
                  int v39 = (UInt8 *)NECreateAddressStructFromString(v37, (uint64_t)v38, 0LL);
                }

                else
                {
                  int v39 = 0LL;
                }

                if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"LocalPrefix"))
                {
                  char v40 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"LocalPrefix");
                  CFNumberGetValue(v40, kCFNumberIntType, &v90);
                }

                else
                {
                  if (v6) {
                    int v41 = 24;
                  }
                  else {
                    int v41 = 32;
                  }
                  int v90 = v41;
                }

                uint64_t v42 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"RemoteAddress");
                dispatch_queue_t v43 = CFDictionaryGetValue((CFDictionaryRef)cf, @"RemotePort");
                unsigned int v44 = NECreateAddressStructFromString(v42, (uint64_t)v43, 0LL);
                if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"RemoteRangeEndAddress"))
                {
                  uint64_t v45 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"RemoteRangeEndAddress");
                  int v46 = CFDictionaryGetValue((CFDictionaryRef)cf, @"RemoteRangeEndPort");
                  uint64_t v47 = (UInt8 *)NECreateAddressStructFromString(v45, (uint64_t)v46, 0LL);
                }

                else
                {
                  uint64_t v47 = 0LL;
                }

                if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"RemotePrefix"))
                {
                  uint64_t v48 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"RemotePrefix");
                  CFNumberGetValue(v48, kCFNumberIntType, &v89);
                }

                else
                {
                  if (v6) {
                    int v49 = 24;
                  }
                  else {
                    int v49 = 32;
                  }
                  int v89 = v49;
                }

                if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"IPSecInterface"))
                {
                  int v50 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"IPSecInterface");
                  CFStringGetCString(v50, buffer, 16LL, 0x600u);
                }

                if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"InternalInterface"))
                {
                  uint64_t v51 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"InternalInterface");
                  CFStringGetCString(v51, v92, 16LL, 0x600u);
                }

                if (CFDictionaryContainsKey((CFDictionaryRef)cf, @"OutgoingInterface"))
                {
                  int v52 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"OutgoingInterface");
                  CFStringGetCString(v52, v91, 16LL, 0x600u);
                }

                __int16 v53 = NEGetIntFromDictionary((const __CFDictionary *)cf, @"IntializeDisabled", 0LL);
                uint64_t v54 = _NEIPSecDBGetQueue();
                uint64_t v55 = MEMORY[0x1895F87A8];
                block[0] = MEMORY[0x1895F87A8];
                block[1] = 0x40000000LL;
                block[2] = __NEIPSecDBAddPolicy_block_invoke;
                block[3] = &unk_18A08DE38;
                void block[6] = a1;
                void block[7] = cf;
                block[4] = &v84;
                void block[5] = &v80;
                dispatch_sync(v54, block);
                if ((v33 & 1) != 0) {
                  goto LABEL_160;
                }
                int v56 = *(dispatch_source_s **)(a1 + 64);
                dispatch_queue_t v57 = _NEIPSecDBGetQueue();
                uint64_t v58 = buffer;
                if (!buffer[0]) {
                  uint64_t v58 = 0LL;
                }
                uint8_t v59 = v92;
                if (!v92[0]) {
                  uint8_t v59 = 0LL;
                }
                uint64_t v60 = v91;
                if (!v91[0]) {
                  uint64_t v60 = 0LL;
                }
                if (NEPFKeySendSPDAdd( v56,  (uint64_t)v57,  (uint64_t)v36,  v39,  v90,  (uint64_t)v44,  v47,  v89,  valuePtr,  SHIWORD(valuePtr),  v75,  2,  v76,  v77,  v74,  SWORD2(v75),  v78,  v29,  0,  v58,  v59,  v60,  v53))
                {
LABEL_160:
                  __int16 v61 = (UInt8 *)v78;
                  if ((v73 & 1) != 0
                    || (unsigned __int16 v62 = *(dispatch_source_s **)(a1 + 64),
                        dispatch_queue_t v63 = _NEIPSecDBGetQueue(),
                        NEPFKeySendSPDAdd( v62,  (uint64_t)v63,  (uint64_t)v44,  v47,  v89,  (uint64_t)v36,  v39,  v90,  valuePtr,  SHIWORD(valuePtr),  v75,  1,  v76,  v77,  v74,  SWORD2(v75),  v29,  v78,  0,  0LL,  0LL,  0LL,  v53)))
                  {
                    char v64 = (os_log_s *)ne_log_obj();
                    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)__int128 buf = 0;
                      uint64_t v65 = "failed to receive response for pfkey add policy";
LABEL_199:
                      _os_log_error_impl(&dword_1876B1000, v64, OS_LOG_TYPE_ERROR, v65, buf, 2u);
                    }
                  }

                  else
                  {
                    char v64 = (os_log_s *)ne_log_obj();
                    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)__int128 buf = 0;
                      uint64_t v65 = "pfkey send add policy failed";
                      goto LABEL_199;
                    }
                  }

                  int v70 = *((_DWORD *)v85 + 6);
                  uint64_t v71 = _NEIPSecDBGetQueue();
                  *(void *)__int128 buf = v55;
                  *(void *)&uint8_t buf[8] = 0x40000000LL;
                  *(void *)&uint8_t buf[16] = __NEIPSecDBRemovePolicyIDFromSAs_block_invoke;
                  *(void *)&_BYTE buf[24] = &__block_descriptor_tmp_161;
                  *(void *)&buf[32] = a1;
                  int v95 = v70;
                  dispatch_sync(v71, buf);
                  *((_DWORD *)v85 + 6) = 0;
LABEL_175:
                  if (!v78)
                  {
LABEL_177:
                    if (v29) {
                      free(v29);
                    }
                    if (v44) {
                      free(v44);
                    }
                    if (v36) {
                      free(v36);
                    }
                    if (v47) {
                      free(v47);
                    }
                    if (v39) {
                      free(v39);
                    }
                    goto LABEL_98;
                  }

  [v6 objectForKeyedSubscript:@"server-CA-name"];
  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();

  if (v45 && [v7 type] == 5)
  {
    [v6 objectForKeyedSubscript:@"server-CA-name"];
    int v46 = (void *)objc_claimAutoreleasedReturnValue();
    [v7 setServerCertificateIssuerCommonName:v46];
  }

  [v6 objectForKeyedSubscript:@"server-cert-name"];
  uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue();

  if (v47 && [v7 type] == 5)
  {
    [v6 objectForKeyedSubscript:@"server-cert-name"];
    uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue();
    [v7 setServerCertificateCommonName:v48];
  }

  uint64_t v42 = @"encryption-algorithm";
  [v6 objectForKeyedSubscript:@"encryption-algorithm"];
  int v49 = (void *)objc_claimAutoreleasedReturnValue();

  if (v49)
  {
    if ([v7 type] != 5) {
      goto LABEL_187;
    }
    int v50 = @"encryption-algorithm";
    [v6 objectForKeyedSubscript:@"encryption-algorithm"];
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v17 isEqualToString:@"DES"])
    {
      [v7 IKESecurityAssociationParameters];
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      int v52 = v51;
      __int16 v53 = 1LL;
    }

    else if ([v17 isEqualToString:@"3DES"])
    {
      [v7 IKESecurityAssociationParameters];
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      int v52 = v51;
      __int16 v53 = 2LL;
    }

    else if ([v17 isEqualToString:@"AES-128"])
    {
      [v7 IKESecurityAssociationParameters];
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      int v52 = v51;
      __int16 v53 = 3LL;
    }

    else if ([v17 isEqualToString:@"AES-256"])
    {
      [v7 IKESecurityAssociationParameters];
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      int v52 = v51;
      __int16 v53 = 4LL;
    }

    else if ([v17 isEqualToString:@"AES-128-GCM"])
    {
      [v7 IKESecurityAssociationParameters];
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      int v52 = v51;
      __int16 v53 = 5LL;
    }

    else if ([v17 isEqualToString:@"AES-256-GCM"])
    {
      [v7 IKESecurityAssociationParameters];
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      int v52 = v51;
      __int16 v53 = 6LL;
    }

    else
    {
      if (![v17 isEqualToString:@"ChaCha20Poly1305"])
      {
LABEL_167:
        [NSString stringWithFormat:@"Invalid %@, valid values are %@, %@, %@, %@, %@, %@, and %@", v50, @"DES", @"3DES", @"AES-128", @"AES-256", @"AES-128-GCM", @"AES-256-GCM", @"ChaCha20Poly1305"];
        goto LABEL_83;
      }

      [v7 IKESecurityAssociationParameters];
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      int v52 = v51;
      __int16 v53 = 7LL;
    }

    [v51 setEncryptionAlgorithm:v53];
  }

  uint64_t v42 = @"integrity-algorithm";
  [v6 objectForKeyedSubscript:@"integrity-algorithm"];
  uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();

  if (v54)
  {
    if ([v7 type] != 5) {
      goto LABEL_187;
    }
    uint64_t v55 = @"integrity-algorithm";
    [v6 objectForKeyedSubscript:@"integrity-algorithm"];
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v17 isEqualToString:@"SHA1-96"])
    {
      [v7 IKESecurityAssociationParameters];
      int v56 = (void *)objc_claimAutoreleasedReturnValue();
      dispatch_queue_t v57 = v56;
      uint64_t v58 = 1LL;
    }

    else if ([v17 isEqualToString:@"SHA1-160"])
    {
      [v7 IKESecurityAssociationParameters];
      int v56 = (void *)objc_claimAutoreleasedReturnValue();
      dispatch_queue_t v57 = v56;
      uint64_t v58 = 2LL;
    }

    else if ([v17 isEqualToString:@"SHA2-256"])
    {
      [v7 IKESecurityAssociationParameters];
      int v56 = (void *)objc_claimAutoreleasedReturnValue();
      dispatch_queue_t v57 = v56;
      uint64_t v58 = 3LL;
    }

    else if ([v17 isEqualToString:@"SHA2-384"])
    {
      [v7 IKESecurityAssociationParameters];
      int v56 = (void *)objc_claimAutoreleasedReturnValue();
      dispatch_queue_t v57 = v56;
      uint64_t v58 = 4LL;
    }

    else
    {
      if (![v17 isEqualToString:@"SHA2-512"])
      {
LABEL_190:
        [NSString stringWithFormat:@"Invalid %@, valid values are %@ and %@", v55, @"SHA1-96", @"SHA1-160", v89, v90, v91, v92, v93];
        goto LABEL_83;
      }

      [v7 IKESecurityAssociationParameters];
      int v56 = (void *)objc_claimAutoreleasedReturnValue();
      dispatch_queue_t v57 = v56;
      uint64_t v58 = 5LL;
    }

    [v56 setIntegrityAlgorithm:v58];
  }

  uint64_t v42 = @"diffie-hellman-group";
  [v6 objectForKeyedSubscript:@"diffie-hellman-group"];
  uint8_t v59 = (void *)objc_claimAutoreleasedReturnValue();

  if (v59)
  {
    if ([v7 type] != 5) {
      goto LABEL_187;
    }
    [v6 objectForKeyedSubscript:@"diffie-hellman-group"];
    uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
    __int16 v61 = [v60 intValue];

    if ((v61 > 0x20 || ((1LL << v61) & 0x180000026LL) == 0) && v61 - 22 <= 0xFFFFFFF7) {
      goto LABEL_145;
    }
    [v7 IKESecurityAssociationParameters];
    unsigned __int16 v62 = (void *)objc_claimAutoreleasedReturnValue();
    [v62 setDiffieHellmanGroup:v61];
  }

  uint64_t v42 = @"life-time";
  [v6 objectForKeyedSubscript:@"life-time"];
  dispatch_queue_t v63 = (void *)objc_claimAutoreleasedReturnValue();

  if (v63)
  {
    if ([v7 type] != 5) {
      goto LABEL_187;
    }
    [v6 objectForKeyedSubscript:@"life-time"];
    char v64 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v65 = [v64 intValue];

    if ((v65 - 10) > 0x596)
    {
      [NSString stringWithFormat:@"Invalid %@, valid values are in the range %d - %d minutes (24 hours)", @"life-time", 10, 1440];
LABEL_188:
      uint64_t v13 = 0;
      *a4 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_11;
    }

    [v7 IKESecurityAssociationParameters];
    int v66 = (void *)objc_claimAutoreleasedReturnValue();
    [v66 setLifetimeMinutes:v65];
  }

  uint64_t v42 = @"child-encryption-algorithm";
  [v6 objectForKeyedSubscript:@"child-encryption-algorithm"];
  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();

  if (v67)
  {
    if ([v7 type] != 5) {
      goto LABEL_187;
    }
    int v50 = @"child-encryption-algorithm";
    [v6 objectForKeyedSubscript:@"child-encryption-algorithm"];
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v17 isEqualToString:@"DES"])
    {
      [v7 childSecurityAssociationParameters];
      int v68 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v69 = v68;
      int v70 = 1LL;
LABEL_156:
      [v68 setEncryptionAlgorithm:v70];

      goto LABEL_157;
    }

    if ([v17 isEqualToString:@"3DES"])
    {
      [v7 childSecurityAssociationParameters];
      int v68 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v69 = v68;
      int v70 = 2LL;
      goto LABEL_156;
    }

    if ([v17 isEqualToString:@"AES-128"])
    {
      [v7 childSecurityAssociationParameters];
      int v68 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v69 = v68;
      int v70 = 3LL;
      goto LABEL_156;
    }

    if ([v17 isEqualToString:@"AES-256"])
    {
      [v7 childSecurityAssociationParameters];
      int v68 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v69 = v68;
      int v70 = 4LL;
      goto LABEL_156;
    }

    if ([v17 isEqualToString:@"AES-128-GCM"])
    {
      [v7 childSecurityAssociationParameters];
      int v68 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v69 = v68;
      int v70 = 5LL;
      goto LABEL_156;
    }

    if ([v17 isEqualToString:@"AES-256-GCM"])
    {
      [v7 childSecurityAssociationParameters];
      int v68 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v69 = v68;
      int v70 = 6LL;
      goto LABEL_156;
    }

    if ([v17 isEqualToString:@"ChaCha20Poly1305"])
    {
      [v7 childSecurityAssociationParameters];
      int v68 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v69 = v68;
      int v70 = 7LL;
      goto LABEL_156;
    }

    goto LABEL_167;
  }

LABEL_98:
  uint64_t v21 = v81[3];
  if (v21)
  {
    uint64_t v22 = _NEIPSecDBGetQueue();
    *(void *)__int128 buf = MEMORY[0x1895F87A8];
    *(void *)&uint8_t buf[8] = 0x40000000LL;
    *(void *)&uint8_t buf[16] = __NEIPSecDBRemoveQueuedRequest_block_invoke;
    *(void *)&_BYTE buf[24] = &__block_descriptor_tmp_163;
    *(void *)&buf[32] = v21;
    dispatch_sync(v22, buf);
    free((void *)v81[3]);
  }

  uint64_t v12 = *((unsigned int *)v85 + 6);
  _Block_object_dispose(&v80, 8);
  _Block_object_dispose(&v84, 8);
  return v12;
}

void *__NEIPSecDBAddPolicy_block_invoke(void *a1)
{
  uint64_t v3 = a1[6];
  CFDictionaryRef v2 = (const __CFDictionary *)a1[7];
  int v4 = *(_DWORD *)(v3 + 76);
  else {
    int v5 = 1;
  }
  *(_DWORD *)(v3 + 76) = v5;
  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = v4;
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v2);
  if (MutableCopy)
  {
    CFMutableDictionaryRef v7 = MutableCopy;
    NEAddValueToIntKeyedDictionary( *(__CFDictionary **)(a1[6] + 88LL),  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL),  MutableCopy);
    CFRelease(v7);
  }

  BOOL result = NEIPSecDBCreateQueuedRequest(a1[6], 14, *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL));
  *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = result;
  return result;
}

void __NEIPSecDBRemovePolicyIDFromSAs_block_invoke(uint64_t a1)
{
}

uint64_t NEIPSecDBDeletePolicy(uint64_t a1, int a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v24 = 0LL;
    uint64_t v25 = &v24;
    uint64_t v26 = 0x2000000000LL;
    uint64_t v27 = 0LL;
    uint64_t v20 = 0LL;
    uint64_t v21 = &v20;
    uint64_t v22 = 0x2000000000LL;
    uint64_t v23 = 0LL;
    int v4 = _NEIPSecDBGetQueue();
    uint64_t v5 = MEMORY[0x1895F87A8];
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 0x40000000LL;
    v18[2] = __NEIPSecDBDeletePolicy_block_invoke;
    v18[3] = &unk_18A08DE60;
    v18[5] = &v20;
    v18[6] = a1;
    int v19 = a2;
    v18[4] = &v24;
    dispatch_sync(v4, v18);
    if (v25[3])
    {
      BOOL v6 = *(dispatch_source_s **)(a1 + 64);
      dispatch_queue_t v7 = _NEIPSecDBGetQueue();
      int v8 = NEGetIntFromDictionary((const __CFDictionary *)v25[3], @"PolicyID", 0LL);
      if (pfkey_send_x5(v6, (uint64_t)v7, 0x16u, v8))
      {
        if (NEIPSecDBCopyResponseForQueuedRequest(v21[3], 0LL))
        {
          uint64_t v9 = 1LL;
LABEL_14:
          uint64_t v12 = v25;
          uint64_t v13 = (const void *)v25[3];
          if (v13)
          {
            CFRelease(v13);
            v12[3] = 0LL;
          }

          uint64_t v14 = v21[3];
          if (v14)
          {
            char v15 = _NEIPSecDBGetQueue();
            *(void *)&__int128 buf = v5;
            *((void *)&buf + 1) = 0x40000000LL;
            int v29 = __NEIPSecDBRemoveQueuedRequest_block_invoke;
            uint64_t v30 = &__block_descriptor_tmp_163;
            uint64_t v31 = v14;
            dispatch_sync(v15, &buf);
            free((void *)v21[3]);
          }

          _Block_object_dispose(&v20, 8);
          _Block_object_dispose(&v24, 8);
          return v9;
        }

        uint64_t v10 = (os_log_s *)ne_log_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          uint64_t v11 = "failed to receive response for pfkey delete policy";
          goto LABEL_12;
        }

uint64_t NEIPSecDBCopyPolicy(uint64_t a1, int a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v25 = 0LL;
    uint64_t v26 = &v25;
    uint64_t v27 = 0x2000000000LL;
    uint64_t v28 = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v22 = &v21;
    uint64_t v23 = 0x2000000000LL;
    uint64_t v24 = 0LL;
    uint64_t v20 = 0LL;
    int v4 = _NEIPSecDBGetQueue();
    uint64_t v5 = MEMORY[0x1895F87A8];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __NEIPSecDBCopyPolicy_block_invoke;
    block[3] = &unk_18A08DE88;
    void block[5] = &v21;
    void block[6] = a1;
    int v19 = a2;
    block[4] = &v25;
    dispatch_sync(v4, block);
    if (v26[3])
    {
      BOOL v6 = *(dispatch_source_s **)(a1 + 64);
      dispatch_queue_t v7 = _NEIPSecDBGetQueue();
      int v8 = NEGetIntFromDictionary((const __CFDictionary *)v26[3], @"PolicyID", 0LL);
      if (pfkey_send_x5(v6, (uint64_t)v7, 0x10u, v8))
      {
        uint64_t v9 = (os_log_s *)ne_log_obj();
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        LOWORD(buf) = 0;
        uint64_t v10 = "failed to receive response for pfkey spd get";
        goto LABEL_17;
      }

      uint64_t v9 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
LABEL_10:
        uint64_t v11 = v26;
        uint64_t v12 = (const void *)v26[3];
        if (v12)
        {
          CFRelease(v12);
          v11[3] = 0LL;
        }

        uint64_t v13 = v22[3];
        if (v13)
        {
          uint64_t v14 = _NEIPSecDBGetQueue();
          *(void *)&__int128 buf = v5;
          *((void *)&buf + 1) = 0x40000000LL;
          uint64_t v30 = __NEIPSecDBRemoveQueuedRequest_block_invoke;
          uint64_t v31 = &__block_descriptor_tmp_163;
          uint64_t v32 = v13;
          dispatch_sync(v14, &buf);
          free((void *)v22[3]);
        }

        uint64_t v15 = v20;
        _Block_object_dispose(&v21, 8);
        _Block_object_dispose(&v25, 8);
        return v15;
      }

      LOWORD(buf) = 0;
      uint64_t v10 = "pfkey send spd get failed";
    }

    else
    {
      uint64_t v9 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        goto LABEL_10;
      }
      LOWORD(buf) = 0;
      uint64_t v10 = "copy policy, policy data is NULL";
    }

__CFArray *NEIPSecDBCopyPolicyIDs(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    uint64_t v13 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "NEIPSecDBCopyPolicyIDs";
    uint64_t v14 = "%s called with null session";
LABEL_19:
    _os_log_fault_impl(&dword_1876B1000, v13, OS_LOG_TYPE_FAULT, v14, (uint8_t *)&buf, 0xCu);
    return 0LL;
  }

  if (!*(void *)(a1 + 88))
  {
    uint64_t v13 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "NEIPSecDBCopyPolicyIDs";
    uint64_t v14 = "%s called with null session->policies";
    goto LABEL_19;
  }

  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v17 = 0x2000000000LL;
  uint64_t v18 = 0LL;
  CFDictionaryRef v2 = _NEIPSecDBGetQueue();
  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 0x40000000LL;
  void v15[2] = __NEIPSecDBCopyPolicyIDs_block_invoke;
  v15[3] = &unk_18A08DEB0;
  v15[4] = &buf;
  v15[5] = a1;
  dispatch_sync(v2, v15);
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(*((void *)&buf + 1) + 24LL));
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], Count, MEMORY[0x189605228]);
  uint64_t v5 = Mutable;
  if (Count >= 1 && Mutable != 0LL)
  {
    dispatch_queue_t v7 = (const void **)calloc(Count, 8uLL);
    int v8 = (const void **)calloc(Count, 8uLL);
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(*((void *)&buf + 1) + 24LL), v7, v8);
    uint64_t v9 = 0LL;
    do
      CFArrayAppendValue(v5, v7[v9++]);
    while (Count != v9);
    free(v7);
    free(v8);
  }

  uint64_t v10 = *((void *)&buf + 1);
  uint64_t v11 = *(const void **)(*((void *)&buf + 1) + 24LL);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(v10 + 24) = 0LL;
  }

  _Block_object_dispose(&buf, 8);
  return v5;
}

CFDictionaryRef __NEIPSecDBCopyPolicyIDs_block_invoke(CFDictionaryRef result)
{
  uint64_t v1 = *(const __CFDictionary **)(*((void *)result + 5) + 88LL);
  if (v1)
  {
    CFDictionaryRef v2 = result;
    BOOL result = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v1);
    *(void *)(*(void *)(*((void *)v2 + 4) + 8LL) + 24LL) = result;
  }

  return result;
}

uint64_t NEIPSecDBFlushPolicies(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v25 = 0LL;
    uint64_t v26 = &v25;
    uint64_t v27 = 0x2000000000LL;
    uint64_t v28 = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v22 = &v21;
    uint64_t v23 = 0x2000000000LL;
    uint64_t v24 = 0LL;
    CFDictionaryRef v2 = _NEIPSecDBGetQueue();
    uint64_t v3 = MEMORY[0x1895F87A8];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __NEIPSecDBFlushPolicies_block_invoke;
    block[3] = &unk_18A08DED8;
    void block[5] = &v21;
    void block[6] = a1;
    block[4] = &v25;
    dispatch_sync(v2, block);
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v26[3]);
    if (Count < 1) {
      goto LABEL_6;
    }
    size_t v5 = Count;
    BOOL v6 = (const void **)calloc(Count, 8uLL);
    dispatch_queue_t v7 = (const void **)calloc(v5, 8uLL);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)v26[3], v6, v7);
    for (uint64_t i = 0LL; i != v5; ++i)
    {
      uint64_t v9 = *(dispatch_source_s **)(a1 + 64);
      dispatch_queue_t v10 = _NEIPSecDBGetQueue();
      int v11 = NEGetIntFromDictionary((const __CFDictionary *)v7[i], @"PolicyID", 0LL);
      pfkey_send_x5(v9, (uint64_t)v10, 0x16u, v11);
    }

    free(v6);
    free(v7);
    if (NEIPSecDBCopyResponseForQueuedRequest(v22[3], 0LL))
    {
LABEL_6:
      uint64_t v12 = 1LL;
    }

    else
    {
      uint64_t v13 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl( &dword_1876B1000,  v13,  OS_LOG_TYPE_ERROR,  "failed to receive response for pfkey flush policies",  (uint8_t *)&buf,  2u);
      }

      uint64_t v12 = 0LL;
    }

    uint64_t v14 = v26;
    uint64_t v15 = (const void *)v26[3];
    if (v15)
    {
      CFRelease(v15);
      v14[3] = 0LL;
    }

    uint64_t v16 = v22[3];
    if (v16)
    {
      uint64_t v17 = _NEIPSecDBGetQueue();
      *(void *)&__int128 buf = v3;
      *((void *)&buf + 1) = 0x40000000LL;
      uint64_t v30 = __NEIPSecDBRemoveQueuedRequest_block_invoke;
      uint64_t v31 = &__block_descriptor_tmp_163;
      uint64_t v32 = v16;
      dispatch_sync(v17, &buf);
      free((void *)v22[3]);
    }

    _Block_object_dispose(&v21, 8);
    _Block_object_dispose(&v25, 8);
  }

  else
  {
    uint64_t v19 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "NEIPSecDBFlushPolicies";
      _os_log_fault_impl(&dword_1876B1000, v19, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&buf, 0xCu);
    }

    return 0LL;
  }

  return v12;
}

void *__NEIPSecDBFlushPolicies_block_invoke(void *result)
{
  uint64_t v1 = *(const __CFDictionary **)(result[6] + 88LL);
  if (v1)
  {
    CFDictionaryRef v2 = result;
    *(void *)(*(void *)(result[4] + 8LL) + 24LL) = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v1);
    BOOL result = NEIPSecDBCreateQueuedRequest(v2[6], 19, 0);
    *(void *)(*(void *)(v2[5] + 8LL) + 24LL) = result;
  }

  return result;
}

uint64_t NEIPSecDBFlushAll(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t result = NEIPSecDBFlushSAs(a1);
    if ((_DWORD)result) {
      return NEIPSecDBFlushPolicies(a1) != 0;
    }
  }

  else
  {
    uint64_t v3 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v3, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result)
    {
      int v4 = 136315138;
      size_t v5 = "NEIPSecDBFlushAll";
      _os_log_fault_impl(&dword_1876B1000, v3, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&v4, 0xCu);
      return 0LL;
    }
  }

  return result;
}

BOOL NEIPSecDBInvalidateSession(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  CFDictionaryRef v2 = (os_log_s *)ne_log_obj();
  uint64_t v3 = v2;
  if (a1)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      int v8 = (const char *)a1;
      _os_log_impl(&dword_1876B1000, v3, OS_LOG_TYPE_DEFAULT, "%@ invalidating", buf, 0xCu);
    }

    BOOL result = 1LL;
    *(_BYTE *)(a1 + 56) = 1;
    if (*(void *)(a1 + 64))
    {
      size_t v5 = _NEIPSecDBGetQueue();
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 0x40000000LL;
      block[2] = __NEIPSecDBInvalidateSession_block_invoke;
      block[3] = &__block_descriptor_tmp_150;
      block[4] = a1;
      dispatch_sync(v5, block);
      *(void *)(a1 + 64) = 0LL;
      return 1LL;
    }
  }

  else
  {
    BOOL result = os_log_type_enabled(v2, OS_LOG_TYPE_FAULT);
    if (result)
    {
      *(_DWORD *)__int128 buf = 136315138;
      int v8 = "NEIPSecDBInvalidateSession";
      _os_log_fault_impl(&dword_1876B1000, v3, OS_LOG_TYPE_FAULT, "%s called with null session", buf, 0xCu);
      return 0LL;
    }
  }

  return result;
}

void __NEIPSecDBInvalidateSession_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 104);
  if (!v3) {
    goto LABEL_10;
  }
  do
  {
    int v4 = *(void **)v3;
    size_t v5 = (dispatch_source_s *)*((void *)v3 + 3);
    uint64_t v6 = *(void **)v3;
    if (!v5 || (v7 = dispatch_source_testcancel(*((dispatch_source_t *)v3 + 3)), uint64_t v6 = v4, v7))
    {
      if (!v6) {
        goto LABEL_6;
      }
LABEL_5:
      v6[1] = *((void *)v3 + 1);
      goto LABEL_6;
    }

    dispatch_source_cancel(v5);
    uint64_t v6 = *(void **)v3;
    if (*(void *)v3) {
      goto LABEL_5;
    }
LABEL_6:
    **((void **)v3 + 1) = v6;
    free(v3);
    uint64_t v3 = v4;
  }

  while (v4);
  uint64_t v2 = *(void *)(a1 + 32);
LABEL_10:
  NEPFKeyClose(*(dispatch_source_s **)(v2 + 64));
  int v8 = (const __CFArray *)g_IPSecDBSessions;
  v10.length = CFArrayGetCount((CFArrayRef)g_IPSecDBSessions);
  v10.location = 0LL;
  CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v8, v10, *(const void **)(a1 + 32));
  if (FirstIndexOfValue != -1) {
    CFArrayRemoveValueAtIndex((CFMutableArrayRef)g_IPSecDBSessions, FirstIndexOfValue);
  }
}

uint64_t NEIPSecDBStartIdleTimeout(uint64_t a1, int a2, int a3, int a4)
{
  return NEIPSecDBCreateStatsTimer(a1, 0, a2, a3, a4);
}

uint64_t NEIPSecDBCreateStatsTimer(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v6 = 0LL;
    *(void *)&__int128 buf = 0LL;
    *((void *)&buf + 1) = &buf;
    uint64_t v20 = 0x2000000000LL;
    char v21 = 0;
    if (a3 && a4 && a5)
    {
      int v11 = _NEIPSecDBGetQueue();
      v14[0] = MEMORY[0x1895F87A8];
      v14[1] = 0x40000000LL;
      void v14[2] = __NEIPSecDBCreateStatsTimer_block_invoke;
      v14[3] = &unk_18A08E040;
      int v15 = a4;
      int v16 = a5;
      int v17 = a3;
      int v18 = a2;
      v14[4] = &buf;
      v14[5] = a1;
      dispatch_sync(v11, v14);
      uint64_t v6 = *(unsigned __int8 *)(*((void *)&buf + 1) + 24LL);
    }

    _Block_object_dispose(&buf, 8);
  }

  else
  {
    uint64_t v13 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "NEIPSecDBCreateStatsTimer";
      _os_log_fault_impl(&dword_1876B1000, v13, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&buf, 0xCu);
    }

    return 0LL;
  }

  return v6;
}

void __NEIPSecDBCreateStatsTimer_block_invoke(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void **)(*(void *)(a1 + 40) + 104LL);
  if (v2)
  {
    int v3 = *(_DWORD *)(a1 + 48);
    int v4 = *(_DWORD *)(a1 + 52);
    while (1)
    {
      uint64_t v5 = *v2;
      if (v3)
      {
        if (*((_DWORD *)v2 + 4) == v3) {
          break;
        }
      }

      if (v4 && *((_DWORD *)v2 + 5) == v4) {
        break;
      }
      uint64_t v2 = (void *)*v2;
      if (!v5) {
        goto LABEL_8;
      }
    }

    int v8 = 0;
    uint64_t v7 = (unsigned int *)v2;
  }

  else
  {
LABEL_8:
    uint64_t v6 = (unsigned int *)calloc(1uLL, 0x58uLL);
    if (!v6) {
      return;
    }
    uint64_t v7 = v6;
    uint64_t v2 = 0LL;
    v6[4] = *(_DWORD *)(a1 + 48);
    v6[5] = *(_DWORD *)(a1 + 52);
    int v8 = 1;
  }

  unsigned int v9 = *(_DWORD *)(a1 + 56) / 0x14u;
  if (v9 <= 2) {
    unsigned int v9 = 2;
  }
  unsigned int v10 = v7[10];
  unsigned int v11 = v10 - 1;
  if (v10 - 1 >= v9)
  {
    v7[10] = v9;
    unsigned int v10 = v9;
  }

  int v12 = *(_DWORD *)(a1 + 60);
  if (v12 == 1)
  {
    if (*(_DWORD *)(a1 + 56) > v10) {
      unsigned int v10 = *(_DWORD *)(a1 + 56);
    }
    v7[9] = v10;
  }

  else if (!v12)
  {
    if (*(_DWORD *)(a1 + 56) > v10) {
      unsigned int v10 = *(_DWORD *)(a1 + 56);
    }
    v7[8] = v10;
  }

  if (v11 < v9) {
    goto LABEL_35;
  }
  uint64_t v13 = (dispatch_source_s *)*((void *)v7 + 3);
  if (v13)
  {
    if (!dispatch_source_testcancel(*((dispatch_source_t *)v7 + 3))) {
      dispatch_source_cancel(v13);
    }
    *((void *)v7 + 3) = 0LL;
  }

  uint64_t v14 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = *(_DWORD *)(a1 + 48);
    int v16 = *(_DWORD *)(a1 + 52);
    unsigned int v17 = v7[10];
    *(_DWORD *)__int128 buf = 136315906;
    uint64_t v26 = "NEIPSecDBCreateStatsTimer_block_invoke";
    __int16 v27 = 1024;
    int v28 = v15;
    __int16 v29 = 1024;
    int v30 = v16;
    __int16 v31 = 1024;
    unsigned int v32 = v17;
    _os_log_impl( &dword_1876B1000,  v14,  OS_LOG_TYPE_DEFAULT,  "%s: Starting stat timeout (SAs in:%d out:%d) Polling: every %d",  buf,  0x1Eu);
  }

  int v18 = _NEIPSecDBGetQueue();
  uint64_t v19 = 1000LL * v7[10];
  v24[0] = MEMORY[0x1895F87A8];
  v24[1] = 0x40000000LL;
  v24[2] = __NEIPSecDBCreateStatsTimer_block_invoke_164;
  v24[3] = &__block_descriptor_tmp_165;
  uint64_t v20 = *(void *)(a1 + 40);
  v24[4] = v7;
  v24[5] = v20;
  v24[6] = *(void *)(a1 + 48);
  char v21 = NERepeatingEventCreate(v18, 0LL, 0LL, v19, 0LL, 0, v24, 0LL);
  *((void *)v7 + 3) = v21;
  if (v21)
  {
    if (v8)
    {
      uint64_t v22 = *(void *)(*(void *)(a1 + 40) + 104LL);
      *(void *)uint64_t v7 = v22;
      if (v22) {
        *(void *)(*(void *)(*(void *)(a1 + 40) + 104LL) + 8LL) = v7;
      }
      *(void *)(*(void *)(a1 + 40) + 104LL) = v7;
      *((void *)v7 + 1) = *(void *)(a1 + 40) + 104LL;
    }

void __NEIPSecDBCreateStatsTimer_block_invoke_164(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  *(_DWORD *)(v1 + 72) = 0;
  *(void *)(v1 + 64) = 0LL;
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    int v5 = *(_DWORD *)(a1 + 48);
    int v4 = *(_DWORD *)(a1 + 52);
    *(_DWORD *)__int128 buf = 0;
    uint64_t v6 = calloc(1uLL, 0x28uLL);
    if (!v6) {
      return;
    }
    uint64_t v7 = v6;
    int v8 = (UInt8 *)calloc(1uLL, 0x28uLL);
    if (!v8)
    {
      free(v7);
      return;
    }

    unsigned int v9 = v8;
    *((void *)v7 + 4) = 0LL;
    *uint64_t v7 = 0u;
    v7[1] = 0u;
    *((void *)v8 + 4) = 0LL;
    *(_OWORD *)int v8 = 0u;
    *((_OWORD *)v8 + 1) = 0u;
    unsigned int v10 = NEGetValueFromIntKeyedDictionary(*(const __CFDictionary **)(v2 + 80), v5);
    unsigned int v11 = v10;
    if (v10)
    {
      if (!NEIPSecDBFilloutBasicSAInfo(v10, 0LL, 0LL, buf, 0LL, 0LL, 0LL))
      {
        int v14 = 0;
        int v15 = 0LL;
        int v12 = 0LL;
        goto LABEL_17;
      }

      *(_DWORD *)uint64_t v7 = *(_DWORD *)buf;
      int v12 = (UInt8 *)v7;
    }

    else
    {
      int v12 = 0LL;
    }

    uint64_t v13 = NEGetValueFromIntKeyedDictionary(*(const __CFDictionary **)(v2 + 80), v4);
    if (v13 && NEIPSecDBFilloutBasicSAInfo(v13, 0LL, 0LL, buf, 0LL, 0LL, 0LL))
    {
      *(_DWORD *)unsigned int v9 = *(_DWORD *)buf;
      int v14 = 1;
      int v15 = v9;
      if (!v11)
      {
LABEL_17:
        free(v7);
        int v16 = 0;
        if (v14) {
          goto LABEL_18;
        }
        goto LABEL_15;
      }
    }

    else
    {
      int v15 = 0LL;
      int v14 = 0;
      if (!v11) {
        goto LABEL_17;
      }
    }

    int v16 = 1;
    if (v14)
    {
LABEL_18:
      int v17 = 1;
      goto LABEL_19;
    }

uint64_t NEIPSecDBStartBlackHoleDetection(uint64_t a1, int a2, int a3, int a4)
{
  return NEIPSecDBCreateStatsTimer(a1, 1, a2, a3, a4);
}

uint64_t NEIPSecDBScheduleWithRunLoop(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    uint64_t v2 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
    {
      int v3 = 136315138;
      int v4 = "NEIPSecDBScheduleWithRunLoop";
      _os_log_fault_impl(&dword_1876B1000, v2, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&v3, 0xCu);
    }
  }

  return 0LL;
}

uint64_t NEIPSecDBUnScheduleWithRunLoop(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    uint64_t v2 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
    {
      int v3 = 136315138;
      int v4 = "NEIPSecDBUnScheduleWithRunLoop";
      _os_log_fault_impl(&dword_1876B1000, v2, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&v3, 0xCu);
    }
  }

  return 0LL;
}

CFStringRef NEIPSecNotifyCodeCopyString(int a1)
{
  if (a1 <= 39)
  {
    if (a1 > 23)
    {
      switch(a1)
      {
        case 24:
          return @"ServerRejectedAuth";
        case 36:
          return @"ServerInternalAddressFailure";
        case 38:
          return @"ServerRejectedTS";
      }
    }

    else
    {
      switch(a1)
      {
        case 4:
          return @"ServerRejectedSPI";
        case 7:
          return @"ServerRejectedSyntax";
        case 14:
          return @"ServerRejectedProposal";
      }
    }

    return (const __CFString *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"Unknown(%lld)",  a1);
  }

  else
  {
    switch(a1)
    {
      case 70000:
        return @"Unknown";
      case 70001:
        return @"InternalError";
      case 70002:
        return @"CouldNotSend";
      case 70003:
        return @"InvalidArgs";
      case 70004:
        return @"UserRequested";
      case 70005:
        return @"PeerRequested";
      case 70006:
        return @"ServerDidNotRespond";
      case 70007:
        return @"ServerStoppedResponding";
      case 70008:
        return @"ReceivedInvalidSyntax";
      case 70009:
        return @"ReceivedInvalidProposal";
      case 70010:
        return @"ReceivedInvalidSPI";
      case 70011:
        return @"ReceivedInvalidTS";
      case 70012:
        return @"IKESocketFailure";
      case 70013:
        return @"IKELocalAddressMissing";
      case 70014:
        return @"IKERemoteAddressMissing";
      case 70015:
        return @"IKERemotePortMissing";
      case 70016:
        return @"PacketCreateFailed";
      case 70017:
        return @"PacketProcessingFailed";
      case 70018:
        return @"SAMigrationFailed";
      case 70019:
        return @"InvalidConfiguration";
      case 70020:
        return @"FailedToGenerateSPI";
      case 70021:
        return @"CryptoFailed";
      case 70022:
        return @"ConfigurationEstablishmentFailed";
      case 70023:
        return @"ChildInstallSAFailed";
      case 70024:
        return @"NoIKESA";
      case 70025:
        return @"NoChildSA";
      case 70026:
        return @"ChildUninstallSAFailed";
      case 70027:
        return @"AuthFailed";
      case 70028:
        return @"ReceivedInvalidVendorID";
      case 70029:
        return @"EAPIdentityDecryptionFailure";
      case 70030:
        return @"ClientCertNotYetValid";
      case 70031:
        return @"ClientCertExpired";
      case 70032:
        return @"ClientCertMissing";
      case 70033:
        return (const __CFString *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"Unknown(%lld)",  a1);
      case 70034:
        return @"ClientCertInvalid";
      case 70035:
        return @"ServerCertNotYetValid";
      case 70036:
        return @"ServerCertExpired";
      case 70037:
        return @"ServerCertMissing";
      case 70038:
        return @"ServerCertInvalid";
      case 70039:
        return @"ReceivedPrivateError";
      case 70040:
        return @"IKESADelete";
      default:
        if (a1 == 40)
        {
          BOOL result = @"ServerRejectedAddress";
        }

        else
        {
          if (a1 != 16407) {
            return (const __CFString *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"Unknown(%lld)",  a1);
          }
          BOOL result = @"IKEStatusServerRedirect";
        }

        break;
    }
  }

  return result;
}

CFStringRef NEIPSecNotifyReasonCopyString(int a1)
{
  if (a1 <= 1999)
  {
    BOOL result = @"Unknown";
    switch(a1)
    {
      case 0:
        return result;
      case 1:
        BOOL result = @"InternalError";
        break;
      case 2:
        BOOL result = @"CouldNotSend";
        break;
      case 3:
        BOOL result = @"InvalidArgs";
        break;
      default:
        if (a1 == 1000)
        {
          BOOL result = @"UserRequested";
        }

        else if (a1 == 1001)
        {
          BOOL result = @"PeerRequested";
        }

        else
        {
LABEL_17:
          BOOL result = (const __CFString *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"Unknown(%lld)",  a1);
        }

        break;
    }
  }

  else
  {
    switch(a1)
    {
      case 2000:
        BOOL result = @"ServerDidNotRespond";
        break;
      case 2001:
        BOOL result = @"ServerStoppedResponding";
        break;
      case 2002:
      case 2003:
      case 2004:
      case 2005:
      case 2006:
      case 2007:
      case 2008:
      case 2009:
        goto LABEL_17;
      case 2010:
        BOOL result = @"ServerRejectedSyntax";
        break;
      case 2011:
        BOOL result = @"ServerRejectedProposal";
        break;
      case 2012:
        BOOL result = @"ServerRejectedSPI";
        break;
      case 2013:
        BOOL result = @"ServerRejectedTS";
        break;
      case 2014:
        BOOL result = @"ServerRejectedAuth";
        break;
      case 2015:
        BOOL result = @"ServerRejectedAddress";
        break;
      case 2016:
        BOOL result = @"ServerRedirect";
        break;
      default:
        switch(a1)
        {
          case 2100:
            BOOL result = @"ReceivedInvalidSyntax";
            break;
          case 2101:
            BOOL result = @"ReceivedInvalidProposal";
            break;
          case 2102:
            BOOL result = @"ReceivedInvalidSPI";
            break;
          case 2103:
            BOOL result = @"ReceivedInvalidTS";
            break;
          case 2104:
          case 2105:
          case 2106:
          case 2107:
          case 2108:
          case 2109:
            goto LABEL_17;
          case 2110:
            BOOL result = @"AuthFailedPSK";
            break;
          case 2111:
            BOOL result = @"AuthFailedCert";
            break;
          case 2112:
            BOOL result = @"AuthFailedEAP";
            break;
          case 2113:
            BOOL result = @"ReceivedInvalidVendorID";
            break;
          default:
            switch(a1)
            {
              case 3000:
                BOOL result = @"InternalIKESessionMissing";
                break;
              case 3001:
                BOOL result = @"InternalIKESocketFailure";
                break;
              case 3002:
                BOOL result = @"InternalIKELocalAddressMissing";
                break;
              case 3003:
                BOOL result = @"InternalIKERemoteAddressMissing";
                break;
              case 3004:
                BOOL result = @"InternalIKERemotePortMissing";
                break;
              case 3005:
                BOOL result = @"InternalPacketCreateFailed";
                break;
              case 3006:
                BOOL result = @"InternalPacketProcessingFailed";
                break;
              case 3007:
                BOOL result = @"InternalSAMigrationFailed";
                break;
              default:
                goto LABEL_17;
            }

            break;
        }

        break;
    }
  }

  return result;
}

uint64_t NEIPSecIKENotificationTypeCopyString(unsigned int a1)
{
  uint64_t v2 = (unsigned __int16)a1 & 0xF000;
  if ((_DWORD)v2 == 4096) {
    int v3 = @"IKE";
  }
  else {
    int v3 = (__CFString *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"Unknown(%d)", v2);
  }
  if ((a1 & 0xF00) < 0x900 && ((0x1BFu >> (BYTE1(a1) & 0xF)) & 1) != 0) {
    int v4 = off_18A08E360[(a1 >> 8) & 0xF];
  }
  else {
    int v4 = (__CFString *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"Unknown(%lld)",  a1 & 0xF00);
  }
  if (a1 >= 6u) {
    uint64_t v5 = (__CFString *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"Unknown(%lld)",  a1);
  }
  else {
    uint64_t v5 = off_18A08E3A8[a1];
  }
  uint64_t v6 = [objc_alloc(NSString) initWithFormat:@"mode=%@,type=%@,status=%@", v3, v4, v5];

  return v6;
}

CFStringRef NEIPSecIKECreateSessionWithInterfaceAndSocketHandlers( const __CFAllocator *a1, uint64_t a2, const __CFDictionary *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t))
{
  return NEIPSecIKECreateSessionWithInterfaceAndSASession(a1, a3, a4, a5, a6, a7, a8, a9, 0LL);
}

CFStringRef NEIPSecIKECreateSessionWithInterfaceAndSASession( const __CFAllocator *a1, const __CFDictionary *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t (*a8)(uint64_t), void *a9)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  uint64_t v54 = a9;
  int valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"IKEVersion");
  if (!Value || (CFNumberGetValue(Value, kCFNumberIntType, &valuePtr), valuePtr != 1))
  {
    uint64_t v24 = NEIPSecIKEValidateIKEDictionary(a2);
    uint64_t v25 = NEIPSecIKEValidateIKEChildDictionary(a3);
    int v26 = NEIPSecIKEValidateSessionDictionary(a2);
    __int16 v27 = v26;
    if (v24)
    {
      if (v25)
      {
        if (v26)
        {
          if (v54
            || (!a8 ? (uint64_t v28 = 0xFFFFFFFFLL) : (uint64_t v28 = a8(a6)),
                (uint64_t v54 = -[NEIPSecSAKernelSession initWithName:delegate:pfkeySocket:]( objc_alloc(&OBJC_CLASS___NEIPSecSAKernelSession),  "initWithName:delegate:pfkeySocket:",  @"IKEv2 Session Database",  0LL,  v28)) != 0LL))
          {
            if (a7)
            {
              aBlock[0] = MEMORY[0x1895F87A8];
              aBlock[1] = 3221225472LL;
              aBlock[2] = __NEIPSecIKECreateSessionWithInterfaceAndSASession_block_invoke;
              aBlock[3] = &__block_descriptor_40_e57_i40__0_v8r__sockaddr_CC_14c__16r__sockaddr_CC_14c__24r_32l;
              aBlock[4] = a7;
              uint64_t v38 = _Block_copy(aBlock);
            }

            else
            {
              uint64_t v38 = 0LL;
            }

            *(void *)__int128 buf = 0LL;
            *(void *)&uint8_t buf[8] = buf;
            *(void *)&uint8_t buf[16] = 0x3032000000LL;
            uint64_t v69 = __Block_byref_object_copy__13520;
            int v70 = __Block_byref_object_dispose__13521;
            id v71 = 0LL;
            int v39 = (dispatch_queue_s *)NEIPSecIKECopyDefaultSessionQueue();
            block[0] = MEMORY[0x1895F87A8];
            block[1] = 3221225472LL;
            block[2] = __NEIPSecIKECreateSessionWithInterfaceAndSASession_block_invoke_238;
            block[3] = &unk_18A08E2D8;
            __int16 v61 = buf;
            int v56 = v24;
            dispatch_queue_t v57 = v25;
            uint64_t v62 = a4;
            uint64_t v58 = v27;
            id v60 = v38;
            uint64_t v54 = v54;
            uint8_t v59 = v54;
            uint64_t v63 = a5;
            uint64_t v64 = a6;
            id v40 = v38;
            dispatch_sync(v39, block);

            CFStringRef v18 = (CFStringRef)*(id *)(*(void *)&buf[8] + 40LL);
            _Block_object_dispose(buf, 8);

            goto LABEL_35;
          }

          ne_log_obj();
          uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v28;
            _os_log_fault_impl( &dword_1876B1000,  v42,  OS_LOG_TYPE_FAULT,  "[NEIPSecSAKernelSession init pfkeySocket=%d] failed",  buf,  8u);
          }

          uint64_t v54 = 0LL;
LABEL_40:
          CFStringRef v18 = 0LL;
LABEL_35:

          goto LABEL_36;
        }

        ne_log_obj();
        int v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__int128 buf = 136315138;
          *(void *)&uint8_t buf[4] = "NEIPSecIKECreateSessionWithInterfaceAndSASession";
          _os_log_fault_impl(&dword_1876B1000, v50, OS_LOG_TYPE_FAULT, "%s called with null sessionConfig", buf, 0xCu);
        }
      }

      else
      {
        ne_log_obj();
        int v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__int128 buf = 136315138;
          *(void *)&uint8_t buf[4] = "NEIPSecIKECreateSessionWithInterfaceAndSASession";
          _os_log_fault_impl(&dword_1876B1000, v50, OS_LOG_TYPE_FAULT, "%s called with null childConfig", buf, 0xCu);
        }
      }
    }

    else
    {
      ne_log_obj();
      int v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        *(void *)&uint8_t buf[4] = "NEIPSecIKECreateSessionWithInterfaceAndSASession";
        _os_log_fault_impl(&dword_1876B1000, v50, OS_LOG_TYPE_FAULT, "%s called with null ikeConfig", buf, 0xCu);
      }
    }

    goto LABEL_40;
  }

  CFStringRef v18 = CFStringCreateWithCString(a1, "DummyIPSecObject", 0x8000100u);
  *(void *)__int128 buf = 0LL;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x3032000000LL;
  uint64_t v69 = __Block_byref_object_copy__13520;
  int v70 = __Block_byref_object_dispose__13521;
  id v71 = 0LL;
  if (xpc_client_queue_once != -1) {
    dispatch_once(&xpc_client_queue_once, &__block_literal_global_13522);
  }
  uint64_t v19 = (dispatch_queue_s *)(id)xpc_client_queue_q;
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.SecureNetworking.IPSec", v19, 2uLL);
  char v21 = *(void **)(*(void *)&buf[8] + 40LL);
  *(void *)(*(void *)&buf[8] + 40LL) = mach_service;

  uint64_t v22 = *(_xpc_connection_s **)(*(void *)&buf[8] + 40LL);
  if (v22)
  {
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 3221225472LL;
    handler[2] = __create_xpc_connection_block_invoke;
    handler[3] = &unk_18A08E300;
    handler[4] = buf;
    xpc_connection_set_event_handler(v22, handler);
    xpc_connection_resume(*(xpc_connection_t *)(*(void *)&buf[8] + 40LL));
    dispatch_queue_t v23 = (_xpc_connection_s *)*(id *)(*(void *)&buf[8] + 40LL);
  }

  else
  {
    ne_log_obj();
    uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      LOWORD(handler[0]) = 0;
      _os_log_error_impl( &dword_1876B1000,  v29,  OS_LOG_TYPE_ERROR,  "NEIPSec:create_xpc_connection, xpc_connection_create_mach_service fails\n",  (uint8_t *)handler,  2u);
    }

    dispatch_queue_t v23 = 0LL;
  }

  _Block_object_dispose(buf, 8);
  if (!v23) {
    goto LABEL_64;
  }
  xpc_object_t v30 = xpc_dictionary_create(0LL, 0LL, 0LL);
  __int16 v31 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  if (a3) {
    a3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  }
  BOOL v32 = 0;
  if (!v30 || !v31) {
    goto LABEL_61;
  }
  xpc_dictionary_set_int64(v30, "ipsecobjectref", (int64_t)v18);
  xpc_dictionary_set_int64(v30, "ipsecopcode", 1LL);
  xpc_dictionary_set_value(v30, "ipsecikedict", v31);
  if (a3) {
    xpc_dictionary_set_value(v30, "ipsecchilddict", a3);
  }
  xpc_object_t v33 = xpc_connection_send_message_with_reply_sync(v23, v30);
  if (!v33)
  {
    BOOL v32 = 0;
    goto LABEL_61;
  }

  uint64_t v34 = v23;
  id v35 = v33;
  uint64_t v36 = MEMORY[0x1895ADD58]();
  if (v36 != MEMORY[0x1895F9250])
  {
    if (v36 == MEMORY[0x1895F9268])
    {
      handle_connection_error(v34, (uint64_t)v35);
    }

    else
    {
      ne_log_obj();
      uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_error_impl( &dword_1876B1000,  v37,  OS_LOG_TYPE_ERROR,  "NEIPSec: connection returns unknown type\n",  buf,  2u);
      }
    }

    BOOL v32 = 0;
    goto LABEL_60;
  }

  xpc_object_t xdict = v35;
  int64_t int64 = xpc_dictionary_get_int64(xdict, "ipsecopcode");
  int64_t v51 = xpc_dictionary_get_int64(xdict, "ipsecobjectref");
  int64_t v52 = int64 - 4096;
  BOOL v44 = int64 <= 4096;
  ne_log_obj();
  uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  BOOL v46 = os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG);
  if (v44)
  {
    if (v46)
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = v52;
      _os_log_debug_impl( &dword_1876B1000,  v45,  OS_LOG_TYPE_DEBUG,  "process_response invalid reply, opcode = 0x%llx\n",  buf,  0xCu);
    }
  }

  else
  {
    if (v46)
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = v52;
      _os_log_debug_impl(&dword_1876B1000, v45, OS_LOG_TYPE_DEBUG, "process_response: op 0x%llx\n", buf, 0xCu);
    }

    if (v52 == 1)
    {
      BOOL v47 = xpc_dictionary_get_BOOL(xdict, "reply");
      BOOL v32 = v18 == (CFStringRef)v51 && v47;
      ne_log_obj();
      uint64_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v45 = v48;
      if (v32)
      {
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 134217984;
          *(void *)&uint8_t buf[4] = v51;
          _os_log_debug_impl( &dword_1876B1000,  v45,  OS_LOG_TYPE_DEBUG,  "get_response_BOOLean response: ref %p",  buf,  0xCu);
        }
      }

      else if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 134218240;
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v51;
        _os_log_error_impl( &dword_1876B1000,  v45,  OS_LOG_TYPE_ERROR,  "get_response_BOOLean response ERROR: requestref %p, returned ref %p",  buf,  0x16u);
      }

      goto LABEL_59;
    }

    ne_log_obj();
    uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = v52;
      _os_log_error_impl( &dword_1876B1000,  v45,  OS_LOG_TYPE_ERROR,  "process_response unknown reply, opcode = 0x%llx\n",  buf,  0xCu);
    }
  }

  BOOL v32 = 0;
LABEL_59:

LABEL_60:
LABEL_61:
  ne_log_obj();
  int v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v32;
    _os_log_debug_impl(&dword_1876B1000, v49, OS_LOG_TYPE_DEBUG, "send_xpc_ike_create result %d\n", buf, 8u);
  }

  if (!v32)
  {
LABEL_64:
    if (v18)
    {
      CFRelease(v18);
      CFStringRef v18 = 0LL;
    }
  }

void sub_1877C3AF0(_Unwind_Exception *a1)
{
}

uint64_t __Block_byref_object_copy__13520(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__13521(uint64_t a1)
{
}

void __create_xpc_connection_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (MEMORY[0x1895ADD58]() == MEMORY[0x1895F9268])
  {
    handle_connection_error(*(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), (uint64_t)v3);
  }

  else
  {
    ne_log_obj();
    int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl(&dword_1876B1000, v4, OS_LOG_TYPE_ERROR, "NEIPSec: connection returns unknown type\n", v5, 2u);
    }
  }
}

void handle_connection_error(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = MEMORY[0x1895F9198];
  ne_log_obj();
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  if (a2 == v4)
  {
    if (v6)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_error_impl(&dword_1876B1000, v5, OS_LOG_TYPE_ERROR, "NEIPSec: connection interrupted\n", buf, 2u);
    }

    xpc_connection_cancel(v3);
  }

  else
  {
    if (v6)
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_error_impl(&dword_1876B1000, v5, OS_LOG_TYPE_ERROR, "NEIPSec: connection error\n", v7, 2u);
    }
  }
}

NEIKEv2IKESAConfiguration *NEIPSecIKEValidateIKEDictionary(void *a1)
{
  uint64_t v160 = *MEMORY[0x1895F89C0];
  if (NEInitCFTypes_onceToken != -1) {
    dispatch_once(&NEInitCFTypes_onceToken, &__block_literal_global_22164);
  }
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NEIKEv2IKESAConfiguration);
  if (!a1 || (uint64_t v3 = CFDICTIONARY_TYPE, CFGetTypeID(a1) != v3))
  {
    ne_log_obj();
    int v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136315394;
      uint64_t v153 = "NEIPSecIKEValidateIKEDictionary";
      __int16 v154 = 1024;
      int v155 = 1112;
      int v92 = "%s:%d: IKE configuration is not a dictionary";
      CFStringRef v93 = v89;
      uint32_t v94 = 18;
      goto LABEL_169;
    }

LABEL_218:
        goto LABEL_226;
      }

      uint64_t v34 = v33;
      -[NEConfigurationManager setAppGroupMap:]((uint64_t)v31, v33);

      p_info = &OBJC_METACLASS___NEConfigurationManager.info;
    }

    id v35 = v119;
    if (!NEGetValueWithType(v119, @"Lifetime", (uint64_t)p_info[29]))
    {
      ne_log_obj();
      BOOL v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136315906;
        uint64_t v153 = "NEIPSecIKEValidateIKEDictionary";
        __int16 v154 = 1024;
        int v155 = 1226;
        __int16 v156 = 2112;
        v157 = @"Lifetime";
        __int16 v158 = 2048;
        uint64_t v159 = CFNUMBER_TYPE;
        _os_log_error_impl( &dword_1876B1000,  v32,  OS_LOG_TYPE_ERROR,  "%s:%d: value for key %@ is missing or type != %lu",  buf,  0x26u);
      }

      goto LABEL_227;
    }

    -[__CFDictionary objectForKeyedSubscript:](v119, "objectForKeyedSubscript:", @"Lifetime");
    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESAProposal setLifetimeSeconds:](v31, "setLifetimeSeconds:", [v36 unsignedLongValue]);

    if (CFDictionaryContainsKey(v119, @"EncryptionAlgorithm"))
    {
      BOOL v32 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
      -[__CFDictionary objectForKeyedSubscript:](v119, "objectForKeyedSubscript:", @"EncryptionAlgorithm");
      uint64_t v37 = (NEIKEv2EncryptionProtocol *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        uint64_t v38 = NEIPsecIKEGetEncryptionProtocol(v37, 0);
        if (!v38)
        {
          int v39 = v37;
          ne_log_obj();
          CFStringRef v104 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136315650;
            uint64_t v153 = "NEIPSecIKEValidateIKEDictionary";
            __int16 v154 = 1024;
            int v155 = 1235;
            __int16 v156 = 2112;
            v157 = (const __CFString *)v39;
            _os_log_error_impl( &dword_1876B1000,  v104,  OS_LOG_TYPE_ERROR,  "%s%d: %@ is not a recognized encryption method",  buf,  0x1Cu);
          }

LABEL_217:
        goto LABEL_218;
      }

      -[os_log_s addObject:](v32, "addObject:", v48);
    }

    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_89;
      }
      __int128 v139 = 0u;
      __int128 v140 = 0u;
      __int128 v137 = 0u;
      __int128 v138 = 0u;
      uint64_t v48 = v47;
      uint64_t v49 = -[os_log_s countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v137,  v150,  16LL);
      if (v49)
      {
        uint64_t v50 = v49;
        time_t v111 = v47;
        uint64_t v51 = *(void *)v138;
        while (2)
        {
          for (uint64_t j = 0LL; j != v50; ++j)
          {
            if (*(void *)v138 != v51) {
              objc_enumerationMutation(v48);
            }
            __int16 v53 = *(__CFString **)(*((void *)&v137 + 1) + 8 * j);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              uint64_t v54 = NEIPsecIKEGetIntegrityProtocol(v53);
              if (!v48)
              {
                ne_log_obj();
                CFStringRef v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)__int128 buf = 136315650;
                  uint64_t v153 = "NEIPSecIKEValidateIKEDictionary";
                  __int16 v154 = 1024;
                  int v155 = 1270;
                  __int16 v156 = 2112;
                  v157 = v53;
                  _os_log_error_impl( &dword_1876B1000,  v105,  OS_LOG_TYPE_ERROR,  "%s%d: %@ is not a recognized integrity method",  buf,  0x1Cu);
                }

                uint64_t v48 = (os_log_s *)v54;
                goto LABEL_217;
              }

              -[os_log_s addObject:](v32, "addObject:", v54);
            }
          }

          uint64_t v50 = -[os_log_s countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v137,  v150,  16LL);
          if (v50) {
            continue;
          }
          break;
        }

        uint64_t v25 = v116;
        id v35 = v119;
        __int16 v31 = v120;
        BOOL v47 = v111;
      }

      else
      {
        uint64_t v25 = v116;
      }
    }

LABEL_89:
    -[NEIKEv2IKESAProposal setIntegrityProtocols:](v31, "setIntegrityProtocols:", v32);

    p_info = (__objc2_class_ro **)(&OBJC_METACLASS___NEConfigurationManager + 32);
LABEL_90:
    if (!CFDictionaryContainsKey(v35, @"PRFAlgorithm")) {
      goto LABEL_108;
    }
    BOOL v32 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
    -[__CFDictionary objectForKeyedSubscript:](v35, "objectForKeyedSubscript:", @"PRFAlgorithm");
    uint64_t v55 = (__CFString *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      int v56 = NEIPsecIKEGetPRFProtocol(v55);
      if (!v56)
      {
        dispatch_queue_t v57 = v55;
        ne_log_obj();
        uint64_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136315650;
          uint64_t v153 = "NEIPSecIKEValidateIKEDictionary";
          __int16 v154 = 1024;
          int v155 = 1286;
          __int16 v156 = 2112;
          v157 = v57;
          __int128 v109 = "%s%d: %@ is not a recognized PRF protocol";
          goto LABEL_244;
        }

LABEL_223:
        goto LABEL_226;
      }

      dispatch_queue_t v57 = (__CFString *)v56;
      -[os_log_s addObject:](v32, "addObject:", v56);
    }

    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_107;
      }
      __int128 v135 = 0u;
      __int128 v136 = 0u;
      __int128 v133 = 0u;
      __int128 v134 = 0u;
      dispatch_queue_t v57 = v55;
      uint64_t v58 = -[__CFString countByEnumeratingWithState:objects:count:]( v57,  "countByEnumeratingWithState:objects:count:",  &v133,  v149,  16LL);
      if (v58)
      {
        uint64_t v59 = v58;
        uint64_t v112 = v55;
        uint64_t v60 = *(void *)v134;
        while (2)
        {
          for (uint64_t k = 0LL; k != v59; ++k)
          {
            if (*(void *)v134 != v60) {
              objc_enumerationMutation(v57);
            }
            uint64_t v62 = *(__CFString **)(*((void *)&v133 + 1) + 8 * k);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              uint64_t v63 = NEIPsecIKEGetPRFProtocol(v62);
              if (!v63)
              {
                ne_log_obj();
                CFStringRef v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)__int128 buf = 136315650;
                  uint64_t v153 = "NEIPSecIKEValidateIKEDictionary";
                  __int16 v154 = 1024;
                  int v155 = 1295;
                  __int16 v156 = 2112;
                  v157 = v62;
                  CFStringRef v107 = "%s%d: %@ is not a recognized PRF protocol";
                  goto LABEL_233;
                }

LABEL_222:
                uint64_t v108 = (os_log_s *)v57;
                goto LABEL_223;
              }

              uint64_t v64 = v63;
              -[os_log_s addObject:](v32, "addObject:", v63);
            }
          }

          uint64_t v59 = -[__CFString countByEnumeratingWithState:objects:count:]( v57,  "countByEnumeratingWithState:objects:count:",  &v133,  v149,  16LL);
          if (v59) {
            continue;
          }
          break;
        }

        uint64_t v25 = v116;
        id v35 = v119;
        __int16 v31 = v120;
        uint64_t v55 = v112;
      }

      else
      {
        uint64_t v25 = v116;
      }
    }

LABEL_107:
    -[NEIKEv2IKESAProposal setPrfProtocols:](v31, "setPrfProtocols:", v32);

    p_info = (__objc2_class_ro **)(&OBJC_METACLASS___NEConfigurationManager + 32);
LABEL_108:
    if (!CFDictionaryContainsKey(v35, @"DHGroup")) {
      goto LABEL_128;
    }
    id v65 = objc_alloc_init(MEMORY[0x189603FA8]);
    -[__CFDictionary objectForKeyedSubscript:](v35, "objectForKeyedSubscript:", @"DHGroup");
    int v66 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      uint64_t v67 = -[NEIKEv2KEMProtocol initWithMethod:]( [NEIKEv2KEMProtocol alloc],  "initWithMethod:",  [v66 unsignedIntValue]);
      [v65 addObject:v67];
LABEL_126:

      goto LABEL_127;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      __int128 v131 = 0u;
      __int128 v132 = 0u;
      __int128 v129 = 0u;
      __int128 v130 = 0u;
      uint64_t v67 = v66;
      uint64_t v68 = -[NEIKEv2KEMProtocol countByEnumeratingWithState:objects:count:]( v67,  "countByEnumeratingWithState:objects:count:",  &v129,  v148,  16LL);
      if (v68)
      {
        uint64_t v69 = v68;
        uint64_t v70 = *(void *)v130;
        do
        {
          for (uint64_t m = 0LL; m != v69; ++m)
          {
            if (*(void *)v130 != v70) {
              objc_enumerationMutation(v67);
            }
            uint64_t v72 = *(void **)(*((void *)&v129 + 1) + 8 * m);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              char v73 = -[NEIKEv2KEMProtocol initWithMethod:]( [NEIKEv2KEMProtocol alloc],  "initWithMethod:",  [v72 unsignedIntValue]);
              [v65 addObject:v73];
            }
          }

          uint64_t v69 = -[NEIKEv2KEMProtocol countByEnumeratingWithState:objects:count:]( v67,  "countByEnumeratingWithState:objects:count:",  &v129,  v148,  16LL);
        }

        while (v69);
        uint64_t v25 = v116;
        id v35 = v119;
      }

      else
      {
        uint64_t v25 = v116;
      }

      goto LABEL_126;
    }

LABEL_127:
    -[NEIKEv2IKESAProposal setKemProtocols:](v120, "setKemProtocols:", v65);
    p_info = (__objc2_class_ro **)(&OBJC_METACLASS___NEConfigurationManager + 32);
LABEL_128:
    if (CFDictionaryContainsKey(v35, @"EAPMethod"))
    {
      BOOL v32 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
      -[__CFDictionary objectForKeyedSubscript:](v35, "objectForKeyedSubscript:", @"EAPMethod");
      char v74 = (__CFString *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        uint64_t v75 = NEIPsecIKEGetEAPProtocol(v74);
        if (!v75)
        {
          dispatch_queue_t v57 = v74;
          ne_log_obj();
          uint64_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136315650;
            uint64_t v153 = "NEIPSecIKEValidateIKEDictionary";
            __int16 v154 = 1024;
            int v155 = 1328;
            __int16 v156 = 2112;
            v157 = v57;
            __int128 v109 = "%s%d: %@ is not a recognized EAP method";
LABEL_244:
            _os_log_error_impl(&dword_1876B1000, v108, OS_LOG_TYPE_ERROR, v109, buf, 0x1Cu);
          }

          goto LABEL_223;
        }

        dispatch_queue_t v57 = (__CFString *)v75;
        -[os_log_s addObject:](v32, "addObject:", v75);
LABEL_132:
      }

      else
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          __int128 v127 = 0u;
          __int128 v128 = 0u;
          __int128 v125 = 0u;
          __int128 v126 = 0u;
          dispatch_queue_t v57 = v74;
          uint64_t v76 = -[__CFString countByEnumeratingWithState:objects:count:]( v57,  "countByEnumeratingWithState:objects:count:",  &v125,  v147,  16LL);
          if (v76)
          {
            uint64_t v77 = v76;
            uint64_t v113 = v74;
            uint64_t v78 = *(void *)v126;
LABEL_136:
            uint64_t v79 = 0LL;
            while (1)
            {
              if (*(void *)v126 != v78) {
                objc_enumerationMutation(v57);
              }
              uint64_t v80 = *(__CFString **)(*((void *)&v125 + 1) + 8 * v79);
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                unsigned __int8 v81 = NEIPsecIKEGetEAPProtocol(v80);
                if (!v81)
                {
                  ne_log_obj();
                  CFStringRef v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (!os_log_type_enabled(v106, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_222;
                  }
                  *(_DWORD *)__int128 buf = 136315650;
                  uint64_t v153 = "NEIPSecIKEValidateIKEDictionary";
                  __int16 v154 = 1024;
                  int v155 = 1337;
                  __int16 v156 = 2112;
                  v157 = v80;
                  CFStringRef v107 = "%s%d: %@ is not a recognized EAP method";
LABEL_233:
                  _os_log_error_impl(&dword_1876B1000, v106, OS_LOG_TYPE_ERROR, v107, buf, 0x1Cu);
                  goto LABEL_222;
                }

                uint64_t v82 = v81;
                -[os_log_s addObject:](v32, "addObject:", v81);
              }

              if (v77 == ++v79)
              {
                uint64_t v77 = -[__CFString countByEnumeratingWithState:objects:count:]( v57,  "countByEnumeratingWithState:objects:count:",  &v125,  v147,  16LL);
                if (v77) {
                  goto LABEL_136;
                }
                uint64_t v25 = v116;
                id v35 = v119;
                char v74 = v113;
                goto LABEL_132;
              }
            }
          }

          uint64_t v25 = v116;
          goto LABEL_132;
        }
      }

      if (CFDictionaryContainsKey(v6, @"EAPProperties"))
      {
        -[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", @"EAPProperties");
        uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue();
        if (v83)
        {
          unint64_t v114 = v74;
          __int128 v123 = 0u;
          __int128 v124 = 0u;
          __int128 v121 = 0u;
          __int128 v122 = 0u;
          uint64_t v84 = v32;
          uint64_t v85 = -[os_log_s countByEnumeratingWithState:objects:count:]( v84,  "countByEnumeratingWithState:objects:count:",  &v121,  v146,  16LL);
          if (v85)
          {
            uint64_t v86 = v85;
            uint64_t v87 = *(void *)v122;
            do
            {
              for (uint64_t n = 0LL; n != v86; ++n)
              {
                if (*(void *)v122 != v87) {
                  objc_enumerationMutation(v84);
                }
                [*(id *)(*((void *)&v121 + 1) + 8 * n) setProperties:v83];
              }

              uint64_t v86 = -[os_log_s countByEnumeratingWithState:objects:count:]( v84,  "countByEnumeratingWithState:objects:count:",  &v121,  v146,  16LL);
            }

            while (v86);
          }

          uint64_t v25 = v116;
          id v35 = v119;
          char v74 = v114;
        }
      }

      -[NEIKEv2IKESAProposal setEapProtocols:](v120, "setEapProtocols:", v32);

      p_info = (__objc2_class_ro **)(&OBJC_METACLASS___NEConfigurationManager + 32);
    }

    -[os_log_s addObject:](v25, "addObject:", v120);

    CFIndex v26 = v118 + 1;
    dispatch_queue_t v23 = v115;
    if (v118 + 1 == Count) {
      goto LABEL_203;
    }
  }

  ne_log_obj();
  id v35 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
  if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
    goto LABEL_228;
  }
  *(_DWORD *)__int128 buf = 136315394;
  uint64_t v153 = "NEIPSecIKEValidateIKEDictionary";
  __int16 v154 = 1024;
  int v155 = 1205;
  uint64_t v100 = "%s:%d: IKE configuration proposals array is invalid";
  uint64_t v101 = v35;
  uint32_t v102 = 18;
LABEL_199:
  _os_log_error_impl(&dword_1876B1000, v101, OS_LOG_TYPE_ERROR, v100, buf, v102);
LABEL_228:

LABEL_229:
  int v90 = 0LL;
LABEL_230:

LABEL_231:
LABEL_162:

  return v90;
}

os_log_s *NEIPSecIKEValidateIKEChildDictionary(void *a1)
{
  uint64_t v154 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    ne_log_obj();
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
      _os_log_fault_impl(&dword_1876B1000, v2, OS_LOG_TYPE_FAULT, "%s called with null ikeChildDict", buf, 0xCu);
    }

    goto LABEL_11;
  }

  if (NEInitCFTypes_onceToken != -1) {
    dispatch_once(&NEInitCFTypes_onceToken, &__block_literal_global_22164);
  }
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ChildSAConfiguration);
  p_info = &OBJC_METACLASS___NEConfigurationManager.info;
  uint64_t v4 = CFDICTIONARY_TYPE;
  if (CFGetTypeID(a1) != v4)
  {
    ne_log_obj();
    int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136315394;
      uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
      __int16 v148 = 1024;
      int v149 = 2140;
      _os_log_error_impl( &dword_1876B1000,  v8,  OS_LOG_TYPE_ERROR,  "%s:%d: IKE Child configuration is not a dictionary",  buf,  0x12u);
    }

LABEL_11:
    unsigned int v9 = 0LL;
    goto LABEL_201;
  }

  uint64_t v5 = a1;
  if (!NEGetValueWithType(v5, @"Mode", CFSTRING_TYPE))
  {
    ne_log_obj();
    BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136315906;
      uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
      __int16 v148 = 1024;
      int v149 = 2146;
      __int16 v150 = 2112;
      uint64_t v151 = @"Mode";
      __int16 v152 = 2048;
      uint64_t v153 = CFSTRING_TYPE;
      _os_log_error_impl( &dword_1876B1000,  v6,  OS_LOG_TYPE_ERROR,  "%s:%d: value for key %@ is missing or type != %lu",  buf,  0x26u);
    }

    unsigned int v9 = 0LL;
    goto LABEL_200;
  }

  -[__CFDictionary objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"Mode");
  BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if ((-[os_log_s isEqualToString:](v6, "isEqualToString:", @"Transport") & 1) != 0)
  {
    uint64_t v7 = 1LL;
LABEL_17:
    -[os_log_s setMode:](v2, "setMode:", v7);
    goto LABEL_18;
  }

  if (-[os_log_s isEqualToString:](v6, "isEqualToString:", @"Tunnel"))
  {
    uint64_t v7 = 2LL;
    goto LABEL_17;
  }

LABEL_177:
          BOOL v6 = v123;
          goto LABEL_196;
        }

        uint64_t v24 = v15;
        -[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"TSStartAddress");
        uint64_t v25 = (__CFString *)objc_claimAutoreleasedReturnValue();
        CFIndex v26 = NECreateAddressStructFromString(v25, 0LL, 0LL);

        [MEMORY[0x189608DE8] endpointWithAddress:v26];
        __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEIKEv2TrafficSelector setStartAddress:](v23, "setStartAddress:", v27);

        free(v26);
        if (!NEGetValueWithType(v22, @"TSEndAddress", CFSTRING_TYPE))
        {
          ne_log_obj();
          CFStringRef v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v15 = v24;
          if (!os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
            goto LABEL_177;
          }
          *(_DWORD *)__int128 buf = 136315906;
          uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
          __int16 v148 = 1024;
          int v149 = 2189;
          __int16 v150 = 2112;
          uint64_t v151 = @"TSEndAddress";
          __int16 v152 = 2048;
          uint64_t v153 = CFSTRING_TYPE;
          CFStringRef v104 = "%s:%d: value for key %@ is missing or type != %lu";
LABEL_176:
          _os_log_error_impl(&dword_1876B1000, v103, OS_LOG_TYPE_ERROR, v104, buf, 0x26u);
          goto LABEL_177;
        }

        -[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"TSEndAddress");
        uint64_t v28 = (__CFString *)objc_claimAutoreleasedReturnValue();
        uint64_t v29 = NECreateAddressStructFromString(v28, 0LL, 0LL);

        [MEMORY[0x189608DE8] endpointWithAddress:v29];
        xpc_object_t v30 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEIKEv2TrafficSelector setEndAddress:](v23, "setEndAddress:", v30);

        free(v29);
        if (!NEGetValueWithType(v22, @"TSStartPort", CFNUMBER_TYPE))
        {
          ne_log_obj();
          CFStringRef v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v15 = v24;
          if (!os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
            goto LABEL_177;
          }
          *(_DWORD *)__int128 buf = 136315906;
          uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
          __int16 v148 = 1024;
          int v149 = 2195;
          __int16 v150 = 2112;
          uint64_t v151 = @"TSStartPort";
          __int16 v152 = 2048;
          uint64_t v153 = CFNUMBER_TYPE;
          CFStringRef v104 = "%s:%d: value for key %@ is missing or type != %lu";
          goto LABEL_176;
        }

        -[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"TSStartPort");
        __int16 v31 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEIKEv2TrafficSelector setStartPort:](v23, "setStartPort:", [v31 unsignedShortValue]);

        int v15 = v24;
        if (!NEGetValueWithType(v22, @"TSEndPort", CFNUMBER_TYPE))
        {
          ne_log_obj();
          CFStringRef v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
            goto LABEL_177;
          }
          *(_DWORD *)__int128 buf = 136315906;
          uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
          __int16 v148 = 1024;
          int v149 = 2198;
          __int16 v150 = 2112;
          uint64_t v151 = @"TSEndPort";
          __int16 v152 = 2048;
          uint64_t v153 = CFNUMBER_TYPE;
          CFStringRef v104 = "%s:%d: value for key %@ is missing or type != %lu";
          goto LABEL_176;
        }

        -[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"TSEndPort");
        BOOL v32 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEIKEv2TrafficSelector setEndPort:](v23, "setEndPort:", [v32 unsignedShortValue]);

        int v17 = v18;
        if (CFDictionaryContainsKey(v22, v18) && !NEGetValueWithType(v22, v18, CFNUMBER_TYPE))
        {
          ne_log_obj();
          CFStringRef v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
            goto LABEL_177;
          }
          *(_DWORD *)__int128 buf = 136315906;
          uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
          __int16 v148 = 1024;
          int v149 = 2201;
          __int16 v150 = 2112;
          uint64_t v151 = v18;
          __int16 v152 = 2048;
          uint64_t v153 = CFNUMBER_TYPE;
          CFStringRef v104 = "%s:%d: type of value for key %@ != %lu";
          goto LABEL_176;
        }

        if (CFDictionaryContainsKey(v5, v18))
        {
          -[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", v18);
          xpc_object_t v33 = (void *)objc_claimAutoreleasedReturnValue();
          -[NEIKEv2TrafficSelector setIpProtocol:](v23, "setIpProtocol:", [v33 unsignedCharValue]);
        }

        -[os_log_s addObject:](v15, "addObject:", v23);

        ++v16;
        p_info = &OBJC_METACLASS___NEConfigurationManager.info;
        int v12 = v128;
        if (v120 == v16) {
          goto LABEL_42;
        }
      }

      ne_log_obj();
      uint64_t v22 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136315394;
        uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
        __int16 v148 = 1024;
        int v149 = 2175;
        _os_log_error_impl( &dword_1876B1000,  v22,  OS_LOG_TYPE_ERROR,  "%s:%d: IKE Child local traffic selector array is invalid",  buf,  0x12u);
      }

      BOOL v6 = v123;
      goto LABEL_197;
    }

LABEL_195:
    BOOL v6 = v124;
LABEL_196:

LABEL_197:
    goto LABEL_198;
  }

LABEL_198:
    unsigned int v9 = 0LL;
    goto LABEL_199;
  }

  uint64_t v56 = v55;
  CFDictionaryRef theDicta = v5;
  CFIndex v118 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
  if (v56 < 1)
  {
LABEL_152:
    int v15 = v118;
    -[os_log_s setProposals:](v2, "setProposals:", v118);
    unsigned int v9 = v2;
    goto LABEL_153;
  }

  CFIndex v57 = 0LL;
  uint64_t v58 = @"Lifetime";
  __int128 v122 = v2;
  __int128 v125 = v6;
  uint64_t v116 = v56;
  unint64_t v117 = v54;
  while (1)
  {
    uint64_t v59 = v58;
    CFIndex v121 = v57;
    uint64_t v60 = (void *)CFArrayGetValueAtIndex(v54, v57);
    if (!v60 || (__int16 v61 = v60, v62 = p_info[28], (__objc2_class_ro *)CFGetTypeID(v60) != v62))
    {
      ne_log_obj();
      CFStringRef v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v5 = theDicta;
      if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136315394;
        uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
        __int16 v148 = 1024;
        int v149 = 2275;
        _os_log_error_impl( &dword_1876B1000,  v105,  OS_LOG_TYPE_ERROR,  "%s:%d: IKE Child configuration proposals array is invalid",  buf,  0x12u);
      }

      unsigned int v9 = 0LL;
      int v15 = v118;
      goto LABEL_199;
    }

    uint64_t v63 = v61;
    uint64_t v64 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ChildSAProposal);
    if (v64) {
      v64->_proposalNumber = v121 + 1;
    }
    __int128 v130 = v64;
    if (!NEGetValueWithType(v63, @"ChildProtocol", CFSTRING_TYPE)) {
      break;
    }
    -[__CFDictionary objectForKeyedSubscript:](v63, "objectForKeyedSubscript:", @"ChildProtocol");
    id v65 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v65 isEqualToString:@"ESP"])
    {
      uint64_t v66 = 3LL;
      uint64_t v58 = v59;
    }

    else
    {
      uint64_t v58 = v59;
      uint64_t v66 = 2LL;
    }

    -[NEIKEv2ChildSAProposal setProtocol:](v130, "setProtocol:", v66);
LABEL_74:
    if (!NEGetValueWithType(v63, v58, CFNUMBER_TYPE))
    {
      ne_log_obj();
      uint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136315906;
        uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
        __int16 v148 = 1024;
        int v149 = 2292;
        __int16 v150 = 2112;
        uint64_t v151 = v58;
        __int16 v152 = 2048;
        uint64_t v153 = CFNUMBER_TYPE;
        _os_log_error_impl( &dword_1876B1000,  v68,  OS_LOG_TYPE_ERROR,  "%s:%d: value for key %@ is missing or type != %lu",  buf,  0x26u);
      }

      int v15 = v118;
      uint64_t v5 = theDicta;
LABEL_210:

      unsigned int v9 = 0LL;
      BOOL v6 = v125;
      goto LABEL_199;
    }

    v119 = v65;
    -[__CFDictionary objectForKeyedSubscript:](v63, "objectForKeyedSubscript:", v58);
    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2ChildSAProposal setLifetimeSeconds:](v130, "setLifetimeSeconds:", [v67 unsignedLongValue]);

    if (CFDictionaryContainsKey(v63, @"EncryptionAlgorithm"))
    {
      uint64_t v68 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
      -[__CFDictionary objectForKeyedSubscript:](v63, "objectForKeyedSubscript:", @"EncryptionAlgorithm");
      uint64_t v69 = (__CFString *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        uint64_t v70 = NEIPsecIKEGetEncryptionProtocol(v69, 1);
        if (!v70)
        {
          ne_log_obj();
          __int128 v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136315650;
            uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
            __int16 v148 = 1024;
            int v149 = 2301;
            __int16 v150 = 2112;
            uint64_t v151 = v69;
            _os_log_error_impl( &dword_1876B1000,  v110,  OS_LOG_TYPE_ERROR,  "%s%d: %@ is not a recognized encryption method",  buf,  0x1Cu);
          }

          id v71 = (NEIKEv2EncryptionProtocol *)v69;
          int v15 = v118;
LABEL_205:
          id v65 = v119;
          uint64_t v5 = theDicta;

          goto LABEL_210;
        }

        id v71 = v70;
        -[os_log_s addObject:](v68, "addObject:", v70);
LABEL_79:

        uint64_t v58 = v59;
      }

      else
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          uint64_t v113 = v63;
          __int128 v141 = 0u;
          __int128 v142 = 0u;
          __int128 v139 = 0u;
          __int128 v140 = 0u;
          id v71 = v69;
          uint64_t v72 = -[NEIKEv2EncryptionProtocol countByEnumeratingWithState:objects:count:]( v71,  "countByEnumeratingWithState:objects:count:",  &v139,  v145,  16LL);
          if (v72)
          {
            uint64_t v73 = v72;
            uint64_t v112 = v69;
            uint64_t v74 = *(void *)v140;
            while (2)
            {
              for (uint64_t i = 0LL; i != v73; ++i)
              {
                if (*(void *)v140 != v74) {
                  objc_enumerationMutation(v71);
                }
                uint64_t v76 = *(__CFString **)(*((void *)&v139 + 1) + 8 * i);
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  uint64_t v77 = NEIPsecIKEGetEncryptionProtocol(v76, 1);
                  if (!v77)
                  {
                    ne_log_obj();
                    __int128 v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)__int128 buf = 136315650;
                      uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
                      __int16 v148 = 1024;
                      int v149 = 2310;
                      __int16 v150 = 2112;
                      uint64_t v151 = v76;
                      _os_log_error_impl( &dword_1876B1000,  v109,  OS_LOG_TYPE_ERROR,  "%s%d: %@ is not a recognized encryption method",  buf,  0x1Cu);
                    }

                    __int128 v110 = (os_log_s *)v71;
                    uint64_t v2 = v122;
                    int v15 = v118;
                    uint64_t v63 = v113;
                    goto LABEL_205;
                  }

                  uint64_t v78 = v77;
                  -[os_log_s addObject:](v68, "addObject:", v77);
                }
              }

              uint64_t v73 = -[NEIKEv2EncryptionProtocol countByEnumeratingWithState:objects:count:]( v71,  "countByEnumeratingWithState:objects:count:",  &v139,  v145,  16LL);
              if (v73) {
                continue;
              }
              break;
            }

            uint64_t v2 = v122;
            p_info = (__objc2_class_ro **)(&OBJC_METACLASS___NEConfigurationManager + 32);
            uint64_t v69 = v112;
            uint64_t v63 = v113;
          }

          goto LABEL_79;
        }
      }

      -[NEIKEv2ChildSAProposal setEncryptionProtocols:](v130, "setEncryptionProtocols:", v68);

      BOOL v6 = v125;
    }

    if (!CFDictionaryContainsKey(v63, @"IntegrityAlgorithm")) {
      goto LABEL_112;
    }
    uint64_t v68 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
    -[__CFDictionary objectForKeyedSubscript:](v63, "objectForKeyedSubscript:", @"IntegrityAlgorithm");
    uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      uint64_t v80 = NEIPsecIKEGetIntegrityProtocol(v79);
      if (!v79)
      {
        ne_log_obj();
        time_t v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136315650;
          uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
          __int16 v148 = 1024;
          int v149 = 2326;
          __int16 v150 = 2112;
          uint64_t v151 = 0LL;
          _os_log_error_impl( &dword_1876B1000,  v111,  OS_LOG_TYPE_ERROR,  "%s%d: %@ is not a recognized integrity method",  buf,  0x1Cu);
        }

        int v15 = v118;
LABEL_209:
        id v65 = v119;
        uint64_t v5 = theDicta;

        uint64_t v2 = v122;
        goto LABEL_210;
      }

      -[os_log_s addObject:](v68, "addObject:", v80);
      goto LABEL_110;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      unint64_t v114 = v63;
      __int128 v137 = 0u;
      __int128 v138 = 0u;
      __int128 v135 = 0u;
      __int128 v136 = 0u;
      uint64_t v80 = v79;
      uint64_t v81 = -[NEIKEv2IntegrityProtocol countByEnumeratingWithState:objects:count:]( v80,  "countByEnumeratingWithState:objects:count:",  &v135,  v144,  16LL);
      if (v81)
      {
        uint64_t v82 = v81;
        uint64_t v83 = *(void *)v136;
        while (2)
        {
          for (uint64_t j = 0LL; j != v82; ++j)
          {
            if (*(void *)v136 != v83) {
              objc_enumerationMutation(v80);
            }
            uint64_t v85 = *(__CFString **)(*((void *)&v135 + 1) + 8 * j);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              uint64_t v86 = NEIPsecIKEGetIntegrityProtocol(v85);
              if (!v80)
              {
                ne_log_obj();
                time_t v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)__int128 buf = 136315650;
                  uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
                  __int16 v148 = 1024;
                  int v149 = 2335;
                  __int16 v150 = 2112;
                  uint64_t v151 = v85;
                  _os_log_error_impl( &dword_1876B1000,  v111,  OS_LOG_TYPE_ERROR,  "%s%d: %@ is not a recognized integrity method",  buf,  0x1Cu);
                }

                uint64_t v80 = v86;
                int v15 = v118;
                uint64_t v63 = v114;
                goto LABEL_209;
              }

              -[os_log_s addObject:](v68, "addObject:", v86);

              uint64_t v58 = v59;
            }
          }

          uint64_t v82 = -[NEIKEv2IntegrityProtocol countByEnumeratingWithState:objects:count:]( v80,  "countByEnumeratingWithState:objects:count:",  &v135,  v144,  16LL);
          if (v82) {
            continue;
          }
          break;
        }

        uint64_t v2 = v122;
      }

      uint64_t v63 = v114;
LABEL_110:

      p_info = (__objc2_class_ro **)(&OBJC_METACLASS___NEConfigurationManager + 32);
    }

    -[NEIKEv2ChildSAProposal setIntegrityProtocols:](v130, "setIntegrityProtocols:", v68);

    BOOL v6 = v125;
LABEL_112:
    if (CFDictionaryContainsKey(v63, @"DHGroup"))
    {
      id v87 = objc_alloc_init(MEMORY[0x189603FA8]);
      -[__CFDictionary objectForKeyedSubscript:](v63, "objectForKeyedSubscript:", @"DHGroup");
      char v88 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      int v89 = v88;
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        unsigned int v90 = [v88 unsignedIntValue];
        uint64_t v91 = objc_alloc(&OBJC_CLASS___NEIKEv2KEMProtocol);
        uint64_t v92 = v90;
        char v88 = v89;
        CFStringRef v93 = -[NEIKEv2KEMProtocol initWithMethod:](v91, "initWithMethod:", v92);
        [v87 addObject:v93];
        goto LABEL_127;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        int v115 = v63;
        __int128 v133 = 0u;
        __int128 v134 = 0u;
        __int128 v131 = 0u;
        __int128 v132 = 0u;
        CFStringRef v93 = v88;
        uint64_t v94 = -[NEIKEv2KEMProtocol countByEnumeratingWithState:objects:count:]( v93,  "countByEnumeratingWithState:objects:count:",  &v131,  v143,  16LL);
        if (v94)
        {
          uint64_t v95 = v94;
          uint64_t v96 = *(void *)v132;
          do
          {
            for (uint64_t k = 0LL; k != v95; ++k)
            {
              if (*(void *)v132 != v96) {
                objc_enumerationMutation(v93);
              }
              uint64_t v98 = *(void **)(*((void *)&v131 + 1) + 8 * k);
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                uint32_t v99 = -[NEIKEv2KEMProtocol initWithMethod:]( [NEIKEv2KEMProtocol alloc],  "initWithMethod:",  [v98 unsignedIntValue]);
                [v87 addObject:v99];

                char v88 = v89;
              }
            }

            uint64_t v95 = -[NEIKEv2KEMProtocol countByEnumeratingWithState:objects:count:]( v93,  "countByEnumeratingWithState:objects:count:",  &v131,  v143,  16LL);
          }

          while (v95);
          BOOL v6 = v125;
          p_info = (__objc2_class_ro **)(&OBJC_METACLASS___NEConfigurationManager + 32);
        }

        uint64_t v63 = v115;
LABEL_127:

        uint64_t v2 = v122;
      }

      -[NEIKEv2ChildSAProposal setKemProtocols:](v130, "setKemProtocols:", v87);

      uint64_t v58 = v59;
    }

    -[os_log_s addObject:](v118, "addObject:", v130);

    CFIndex v57 = v121 + 1;
    uint64_t v54 = v117;
    if (v121 + 1 == v116) {
      goto LABEL_152;
    }
  }

  ne_log_obj();
  CFStringRef v107 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 136315906;
    uint64_t v147 = "NEIPSecIKEValidateIKEChildDictionary";
    __int16 v148 = 1024;
    int v149 = 2284;
    __int16 v150 = 2112;
    uint64_t v151 = @"ChildProtocol";
    __int16 v152 = 2048;
    uint64_t v153 = CFSTRING_TYPE;
    _os_log_error_impl( &dword_1876B1000,  v107,  OS_LOG_TYPE_ERROR,  "%s:%d: value for key %@ is missing or type != %lu",  buf,  0x26u);
  }

  unsigned int v9 = 0LL;
  int v15 = v118;
LABEL_153:
  uint64_t v5 = theDicta;
LABEL_199:

LABEL_200:
LABEL_201:

  return v9;
}

NEIKEv2SessionConfiguration *NEIPSecIKEValidateSessionDictionary(void *a1)
{
  uint64_t v257 = *MEMORY[0x1895F89C0];
  if (NEInitCFTypes_onceToken != -1) {
    dispatch_once(&NEInitCFTypes_onceToken, &__block_literal_global_22164);
  }
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NEIKEv2SessionConfiguration);
  if (!a1 || (uint64_t v3 = CFDICTIONARY_TYPE, CFGetTypeID(a1) != v3))
  {
    ne_log_obj();
    unsigned int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136315394;
      v250 = "NEIPSecIKEValidateSessionDictionary";
      __int16 v251 = 1024;
      int v252 = 1371;
      uint64_t v14 = "%s:%d: Session configuration is not a dictionary";
      int v15 = v11;
      uint32_t v16 = 18;
      goto LABEL_22;
    }

LABEL_567:
    int v12 = 0LL;
    goto LABEL_568;
  }

  -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteIdentifier");
  BOOL v32 = (void *)objc_claimAutoreleasedReturnValue();
  [v32 dataUsingEncoding:4];
  int v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();

  -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteIdentifierType");
  xpc_object_t v33 = (void *)objc_claimAutoreleasedReturnValue();
  char v34 = [v33 isEqualToString:@"IDFQDN"];

  if ((v34 & 1) == 0)
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteIdentifierType");
    CFIndex v36 = (void *)objc_claimAutoreleasedReturnValue();
    char v37 = [v36 isEqualToString:@"IDUserFQDN"];

    if ((v37 & 1) != 0)
    {
      uint64_t v35 = 3LL;
      goto LABEL_69;
    }

    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteIdentifierType");
    CFIndex v38 = (void *)objc_claimAutoreleasedReturnValue();
    char v39 = [v38 isEqualToString:@"ADASN1DN"];

    if ((v39 & 1) != 0)
    {
      uint64_t v35 = 9LL;
      goto LABEL_69;
    }

    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteIdentifierType");
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    char v41 = [v40 isEqualToString:@"KeyID"];

    if ((v41 & 1) != 0)
    {
      uint64_t v35 = 11LL;
      goto LABEL_69;
    }

    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteIdentifierType");
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
    int v43 = [v42 isEqualToString:@"IDAddress"];

    if (!v43
      || (-[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteIdentifier"),
          BOOL v44 = (__CFString *)objc_claimAutoreleasedReturnValue(),
          uint64_t v45 = (unsigned __int8 *)NECreateAddressStructFromString(v44, 0LL, 0LL),
          v44,
          !v45))
    {
      uint64_t v35 = 0LL;
      goto LABEL_69;
    }

    int v46 = v45[1];
    if (v46 == 30)
    {
      uint64_t v47 = [MEMORY[0x189603F48] dataWithBytes:v45 + 8 length:16];
      uint64_t v35 = 5LL;
    }

    else
    {
      if (v46 != 2)
      {
        uint64_t v35 = 0LL;
        goto LABEL_68;
      }

      uint64_t v47 = [MEMORY[0x189603F48] dataWithBytes:v45 + 4 length:4];
      uint64_t v35 = 1LL;
    }

    int v17 = (os_log_s *)v47;
LABEL_68:
    free(v45);
    goto LABEL_69;
  }

  uint64_t v35 = 2LL;
LABEL_69:
  id v48 = +[NEIKEv2Identifier createIdentifierWithType:data:]( &OBJC_CLASS___NEIKEv2Identifier,  "createIdentifierWithType:data:",  v35,  v17);
  -[NEIKEv2SessionConfiguration setRemoteIdentifier:](v2, "setRemoteIdentifier:", v48);

  if (CFDictionaryContainsKey(v5, @"LocalPrivateEAPIdentity")
    && !NEGetValueWithType(v5, @"LocalPrivateEAPIdentity", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1453;
    __int16 v253 = 2112;
    v254 = @"LocalPrivateEAPIdentity";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
LABEL_565:
    _os_log_error_impl(&dword_1876B1000, v90, OS_LOG_TYPE_ERROR, v95, buf, 0x26u);
    goto LABEL_566;
  }

  if (CFDictionaryContainsKey(v5, @"LocalPrivateEAPIdentity"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalPrivateEAPIdentity");
    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setLocalPrivateEAPIdentity:](v2, "setLocalPrivateEAPIdentity:", v49);
  }

  if (CFDictionaryContainsKey(v5, @"LocalEncryptedEAPIdentity")
    && !NEGetValueWithType(v5, @"LocalEncryptedEAPIdentity", CFDATA_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1458;
    __int16 v253 = 2112;
    v254 = @"LocalEncryptedEAPIdentity";
    __int16 v255 = 2048;
    uint64_t v256 = CFDATA_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"LocalEncryptedEAPIdentity"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalEncryptedEAPIdentity");
    uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setLocalEncryptedEAPIdentity:](v2, "setLocalEncryptedEAPIdentity:", v50);
  }

  if (CFDictionaryContainsKey(v5, @"SharedSecretKey")
    && !NEGetValueWithType(v5, @"SharedSecretKey", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1463;
    __int16 v253 = 2112;
    v254 = @"SharedSecretKey";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"SharedSecretKey"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"SharedSecretKey");
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setSharedSecret:](v2, "setSharedSecret:", v51);
  }

  if (CFDictionaryContainsKey(v5, @"SharedSecretReference")
    && !NEGetValueWithType(v5, @"SharedSecretReference", CFDATA_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1468;
    __int16 v253 = 2112;
    v254 = @"SharedSecretReference";
    __int16 v255 = 2048;
    uint64_t v256 = CFDATA_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"SharedSecretReference"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"SharedSecretReference");
    int64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setSharedSecretReference:](v2, "setSharedSecretReference:", v52);
  }

  if (CFDictionaryContainsKey(v5, @"LocalCertificate")
    && !NEGetValueWithType(v5, @"LocalCertificate", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1473;
    __int16 v253 = 2112;
    v254 = @"LocalCertificate";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"LocalCertificate"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalCertificate");
    __int16 v53 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setLocalCertificateName:](v2, "setLocalCertificateName:", v53);
  }

  if (CFDictionaryContainsKey(v5, @"LocalCertificateReference")
    && !NEGetValueWithType(v5, @"LocalCertificateReference", CFDATA_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1478;
    __int16 v253 = 2112;
    v254 = @"LocalCertificateReference";
    __int16 v255 = 2048;
    uint64_t v256 = CFDATA_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"LocalCertificateReference"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalCertificateReference");
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setLocalCertificateReference:](v2, "setLocalCertificateReference:", v54);
  }

  if (CFDictionaryContainsKey(v5, @"NATTKeepAliveEnabled")
    && !NEGetValueWithType(v5, @"NATTKeepAliveEnabled", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1483;
    __int16 v253 = 2112;
    v254 = @"NATTKeepAliveEnabled";
    __int16 v255 = 2048;
    uint64_t v256 = CFBOOLEAN_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"NATTKeepAliveEnabled"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"NATTKeepAliveEnabled");
    CFIndex v55 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setNatTraversalKeepaliveDisabled:]( v2,  "setNatTraversalKeepaliveDisabled:",  [v55 BOOLValue] ^ 1);
  }

  if (CFDictionaryContainsKey(v5, @"NATTKeepAliveInterval")
    && !NEGetValueWithType(v5, @"NATTKeepAliveInterval", CFNUMBER_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1488;
    __int16 v253 = 2112;
    v254 = @"NATTKeepAliveInterval";
    __int16 v255 = 2048;
    uint64_t v256 = CFNUMBER_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"NATTKeepAliveInterval"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"NATTKeepAliveInterval");
    uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setNatTraversalKeepaliveInterval:]( v2,  "setNatTraversalKeepaliveInterval:",  [v56 unsignedLongValue]);
  }

  if (CFDictionaryContainsKey(v5, @"NATTKeepAliveOffload")
    && !NEGetValueWithType(v5, @"NATTKeepAliveOffload", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1493;
    __int16 v253 = 2112;
    v254 = @"NATTKeepAliveOffload";
    __int16 v255 = 2048;
    uint64_t v256 = CFBOOLEAN_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"NATTKeepAliveOffload"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"NATTKeepAliveOffload");
    CFIndex v57 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setNatTraversalKeepaliveOffloadEnabled:]( v2,  "setNatTraversalKeepaliveOffloadEnabled:",  [v57 BOOLValue]);
  }

  if (CFDictionaryContainsKey(v5, @"NATTKeepAliveOffloadInterval")
    && !NEGetValueWithType(v5, @"NATTKeepAliveOffloadInterval", CFNUMBER_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1498;
    __int16 v253 = 2112;
    v254 = @"NATTKeepAliveOffloadInterval";
    __int16 v255 = 2048;
    uint64_t v256 = CFNUMBER_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"NATTKeepAliveOffloadInterval"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"NATTKeepAliveOffloadInterval");
    uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setNatTraversalKeepaliveOffloadInterval:]( v2,  "setNatTraversalKeepaliveOffloadInterval:",  [v58 unsignedLongValue]);
  }

  if (CFDictionaryContainsKey(v5, @"RemoteCertificateAuthorityHash")
    && !NEGetValueWithType(v5, @"RemoteCertificateAuthorityHash", CFDATA_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1503;
    __int16 v253 = 2112;
    v254 = @"RemoteCertificateAuthorityHash";
    __int16 v255 = 2048;
    uint64_t v256 = CFDATA_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"RemoteCertificateAuthorityHash"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteCertificateAuthorityHash");
    uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setRemoteCertificateAuthorityHash:](v2, "setRemoteCertificateAuthorityHash:", v59);
  }

  if (CFDictionaryContainsKey(v5, @"LocalPrivateKeyRef"))
  {
    CFTypeID TypeID = SecKeyGetTypeID();
    if (!NEGetValueWithType(v5, @"LocalPrivateKeyRef", TypeID))
    {
      ne_log_obj();
      unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
        goto LABEL_566;
      }
      CFTypeID v96 = SecKeyGetTypeID();
      *(_DWORD *)__int128 buf = 136315906;
      v250 = "NEIPSecIKEValidateSessionDictionary";
      __int16 v251 = 1024;
      int v252 = 1508;
      __int16 v253 = 2112;
      v254 = @"LocalPrivateKeyRef";
      __int16 v255 = 2048;
      uint64_t v256 = v96;
      uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
      goto LABEL_565;
    }
  }

  if (CFDictionaryContainsKey(v5, @"LocalPrivateKeyRef"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"LocalPrivateKeyRef");
    __int16 v61 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setLocalPrivateKeyRef:](v2, "setLocalPrivateKeyRef:", v61);
  }

  if (CFDictionaryContainsKey(v5, @"RemotePublicKeyRef"))
  {
    CFTypeID v62 = SecKeyGetTypeID();
    if (!NEGetValueWithType(v5, @"RemotePublicKeyRef", v62))
    {
      ne_log_obj();
      unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
        goto LABEL_566;
      }
      CFTypeID v97 = SecKeyGetTypeID();
      *(_DWORD *)__int128 buf = 136315906;
      v250 = "NEIPSecIKEValidateSessionDictionary";
      __int16 v251 = 1024;
      int v252 = 1513;
      __int16 v253 = 2112;
      v254 = @"RemotePublicKeyRef";
      __int16 v255 = 2048;
      uint64_t v256 = v97;
      uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
      goto LABEL_565;
    }
  }

  if (CFDictionaryContainsKey(v5, @"RemotePublicKeyRef"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemotePublicKeyRef");
    uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setRemotePublicKeyRef:](v2, "setRemotePublicKeyRef:", v63);
  }

  if (CFDictionaryContainsKey(v5, @"TLSMinimumVersion")
    && !NEGetValueWithType(v5, @"TLSMinimumVersion", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1518;
    __int16 v253 = 2112;
    v254 = @"TLSMinimumVersion";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"TLSMinimumVersion"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"TLSMinimumVersion");
    uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setTlsMinimumVersion:](v2, "setTlsMinimumVersion:", v64);
  }

  if (CFDictionaryContainsKey(v5, @"TLSMaximumVersion")
    && !NEGetValueWithType(v5, @"TLSMaximumVersion", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1523;
    __int16 v253 = 2112;
    v254 = @"TLSMaximumVersion";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"TLSMaximumVersion"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"TLSMaximumVersion");
    id v65 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setTlsMaximumVersion:](v2, "setTlsMaximumVersion:", v65);
  }

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionEnabled")
    && !NEGetValueWithType(v5, @"DeadPeerDetectionEnabled", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1528;
    __int16 v253 = 2112;
    v254 = @"DeadPeerDetectionEnabled";
    __int16 v255 = 2048;
    uint64_t v256 = CFBOOLEAN_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (!CFDictionaryContainsKey(v5, @"DeadPeerDetectionEnabled")) {
    goto LABEL_146;
  }
  -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"DeadPeerDetectionEnabled");
  uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2SessionConfiguration setDeadPeerDetectionEnabled:]( v2,  "setDeadPeerDetectionEnabled:",  [v66 BOOLValue]);

  if (!NEGetValueWithType(v5, @"DeadPeerDetectionInterval", CFNUMBER_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1532;
    __int16 v253 = 2112;
    v254 = @"DeadPeerDetectionInterval";
    __int16 v255 = 2048;
    uint64_t v256 = CFNUMBER_TYPE;
    uint64_t v95 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_565;
  }

  -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"DeadPeerDetectionInterval");
  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2SessionConfiguration setDeadPeerDetectionInterval:]( v2,  "setDeadPeerDetectionInterval:",  [v67 unsignedLongValue]);

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionRetryInterval")
    && !NEGetValueWithType(v5, @"DeadPeerDetectionRetryInterval", CFNUMBER_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1535;
    __int16 v253 = 2112;
    v254 = @"DeadPeerDetectionRetryInterval";
    __int16 v255 = 2048;
    uint64_t v256 = CFNUMBER_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionRetryInterval"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"DeadPeerDetectionRetryInterval");
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setDeadPeerDetectionRetryIntervalMilliseconds:]( v2,  "setDeadPeerDetectionRetryIntervalMilliseconds:",  1000 * [v68 unsignedLongValue]);
  }

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionRetryIntervalMilliseconds")
    && !NEGetValueWithType(v5, @"DeadPeerDetectionRetryIntervalMilliseconds", CFNUMBER_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1540;
    __int16 v253 = 2112;
    v254 = @"DeadPeerDetectionRetryIntervalMilliseconds";
    __int16 v255 = 2048;
    uint64_t v256 = CFNUMBER_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionRetryIntervalMilliseconds"))
  {
    -[os_log_s objectForKeyedSubscript:]( v5,  "objectForKeyedSubscript:",  @"DeadPeerDetectionRetryIntervalMilliseconds");
    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setDeadPeerDetectionRetryIntervalMilliseconds:]( v2,  "setDeadPeerDetectionRetryIntervalMilliseconds:",  [v69 unsignedLongValue]);
  }

  if (!NEGetValueWithType(v5, @"DeadPeerDetectionMaxRetries", CFNUMBER_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1545;
    __int16 v253 = 2112;
    v254 = @"DeadPeerDetectionMaxRetries";
    __int16 v255 = 2048;
    uint64_t v256 = CFNUMBER_TYPE;
    uint64_t v95 = "%s:%d: value for key %@ is missing or type != %lu";
    goto LABEL_565;
  }

  -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"DeadPeerDetectionMaxRetries");
  uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2SessionConfiguration setDeadPeerDetectionMaxRetryCount:]( v2,  "setDeadPeerDetectionMaxRetryCount:",  [v70 unsignedIntValue]);

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionMaxRetriesBeforeReporting")
    && !NEGetValueWithType(v5, @"DeadPeerDetectionMaxRetriesBeforeReporting", CFNUMBER_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1548;
    __int16 v253 = 2112;
    v254 = @"DeadPeerDetectionMaxRetriesBeforeReporting";
    __int16 v255 = 2048;
    uint64_t v256 = CFNUMBER_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"DeadPeerDetectionMaxRetriesBeforeReporting"))
  {
    -[os_log_s objectForKeyedSubscript:]( v5,  "objectForKeyedSubscript:",  @"DeadPeerDetectionMaxRetriesBeforeReporting");
    id v71 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setDeadPeerDetectionMaxRetryCountBeforeReporting:]( v2,  "setDeadPeerDetectionMaxRetryCountBeforeReporting:",  [v71 unsignedIntValue]);
  }

LABEL_160:
  if (CFDictionaryContainsKey(v5, @"InitialContact")
    && !NEGetValueWithType(v5, @"InitialContact", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1573;
    __int16 v253 = 2112;
    v254 = @"InitialContact";
    __int16 v255 = 2048;
    uint64_t v256 = CFBOOLEAN_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"InitialContact"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"InitialContact");
    uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setInitialContactDisabled:]( v2,  "setInitialContactDisabled:",  [v76 BOOLValue] ^ 1);
  }

  if (CFDictionaryContainsKey(v5, @"MOBIKESupported")
    && !NEGetValueWithType(v5, @"MOBIKESupported", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1578;
    __int16 v253 = 2112;
    v254 = @"MOBIKESupported";
    __int16 v255 = 2048;
    uint64_t v256 = CFBOOLEAN_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"MOBIKESupported"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"MOBIKESupported");
    uint64_t v77 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setNegotiateMOBIKE:](v2, "setNegotiateMOBIKE:", [v77 BOOLValue]);
  }

  if (CFDictionaryContainsKey(v5, @"CertificateRevocationCheckEnable")
    && !NEGetValueWithType(v5, @"CertificateRevocationCheckEnable", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1583;
    __int16 v253 = 2112;
    v254 = @"CertificateRevocationCheckEnable";
    __int16 v255 = 2048;
    uint64_t v256 = CFBOOLEAN_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"CertificateRevocationCheckEnable"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"CertificateRevocationCheckEnable");
    uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setEnableCertificateRevocationCheck:]( v2,  "setEnableCertificateRevocationCheck:",  [v78 BOOLValue]);
  }

  if (CFDictionaryContainsKey(v5, @"CertificateStrictRevocationCheck")
    && !NEGetValueWithType(v5, @"CertificateStrictRevocationCheck", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1588;
    __int16 v253 = 2112;
    v254 = @"CertificateStrictRevocationCheck";
    __int16 v255 = 2048;
    uint64_t v256 = CFBOOLEAN_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"CertificateStrictRevocationCheck"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"CertificateStrictRevocationCheck");
    uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setStrictCertificateRevocationCheck:]( v2,  "setStrictCertificateRevocationCheck:",  [v79 BOOLValue]);
  }

  if (CFDictionaryContainsKey(v5, @"ValidateRemoteCertificate")
    && !NEGetValueWithType(v5, @"ValidateRemoteCertificate", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1593;
    __int16 v253 = 2112;
    v254 = @"ValidateRemoteCertificate";
    __int16 v255 = 2048;
    uint64_t v256 = CFBOOLEAN_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"ValidateRemoteCertificate"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"ValidateRemoteCertificate");
    uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setDisableRemoteCertificateValidation:]( v2,  "setDisableRemoteCertificateValidation:",  [v80 BOOLValue] ^ 1);
  }

  if (CFDictionaryContainsKey(v5, @"BlackHoleDetectionEnabled")
    && !NEGetValueWithType(v5, @"BlackHoleDetectionEnabled", CFBOOLEAN_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1598;
    __int16 v253 = 2112;
    v254 = @"BlackHoleDetectionEnabled";
    __int16 v255 = 2048;
    uint64_t v256 = CFBOOLEAN_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"BlackHoleDetectionEnabled"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"BlackHoleDetectionEnabled");
    uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setBlackholeDetectionEnabled:]( v2,  "setBlackholeDetectionEnabled:",  [v81 BOOLValue]);
  }

  if (CFDictionaryContainsKey(v5, @"Username") && !NEGetValueWithType(v5, @"Username", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1603;
    __int16 v253 = 2112;
    v254 = @"Username";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"Username"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"Username");
    uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setUsername:](v2, "setUsername:", v82);
  }

  if (CFDictionaryContainsKey(v5, @"Password") && !NEGetValueWithType(v5, @"Password", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1608;
    __int16 v253 = 2112;
    v254 = @"Password";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"Password"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"Password");
    uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setPassword:](v2, "setPassword:", v83);
  }

  if (CFDictionaryContainsKey(v5, @"PasswordReference")
    && !NEGetValueWithType(v5, @"PasswordReference", CFDATA_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1613;
    __int16 v253 = 2112;
    v254 = @"PasswordReference";
    __int16 v255 = 2048;
    uint64_t v256 = CFDATA_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"PasswordReference"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"PasswordReference");
    uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setPasswordReference:](v2, "setPasswordReference:", v84);
  }

  if (CFDictionaryContainsKey(v5, @"RemoteCertificateHostname")
    && !NEGetValueWithType(v5, @"RemoteCertificateHostname", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1618;
    __int16 v253 = 2112;
    v254 = @"RemoteCertificateHostname";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"RemoteCertificateHostname"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteCertificateHostname");
    uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setRemoteCertificateHostname:](v2, "setRemoteCertificateHostname:", v85);
  }

  if (CFDictionaryContainsKey(v5, @"RemoteCertificateAuthorityName")
    && !NEGetValueWithType(v5, @"RemoteCertificateAuthorityName", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1623;
    __int16 v253 = 2112;
    v254 = @"RemoteCertificateAuthorityName";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"RemoteCertificateAuthorityName"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteCertificateAuthorityName");
    uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setRemoteCertificateAuthorityName:](v2, "setRemoteCertificateAuthorityName:", v86);
  }

  if (CFDictionaryContainsKey(v5, @"RemoteCertificateAuthorityReferences")
    && !NEGetValueWithType(v5, @"RemoteCertificateAuthorityReferences", CFARRAY_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1628;
    __int16 v253 = 2112;
    v254 = @"RemoteCertificateAuthorityReferences";
    __int16 v255 = 2048;
    uint64_t v256 = CFARRAY_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"RemoteCertificateAuthorityReferences"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteCertificateAuthorityReferences");
    id v87 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setRemoteCertificateAuthorityReferences:]( v2,  "setRemoteCertificateAuthorityReferences:",  v87);
  }

  if (CFDictionaryContainsKey(v5, @"IMEI") && !NEGetValueWithType(v5, @"IMEI", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1633;
    __int16 v253 = 2112;
    v254 = @"IMEI";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"IMEI"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"IMEI");
    char v88 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setIMEI:](v2, "setIMEI:", v88);
  }

  if (CFDictionaryContainsKey(v5, @"IMEISV") && !NEGetValueWithType(v5, @"IMEISV", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1638;
    __int16 v253 = 2112;
    v254 = @"IMEISV";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"IMEISV"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"IMEISV");
    int v89 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setIMEISV:](v2, "setIMEISV:", v89);
  }

  if (CFDictionaryContainsKey(v5, @"AuthenticationMethod")
    && !NEGetValueWithType(v5, @"AuthenticationMethod", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1643;
    __int16 v253 = 2112;
    v254 = @"AuthenticationMethod";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"AuthenticationMethod"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"AuthenticationMethod");
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v91 = NEIPsecIKEGetAuthProcotol(v90);
    if (!v91)
    {
      ne_log_obj();
      uint64_t v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136315650;
        v250 = "NEIPSecIKEValidateSessionDictionary";
        __int16 v251 = 1024;
        int v252 = 1648;
        __int16 v253 = 2112;
        v254 = (const __CFString *)v90;
        goto LABEL_656;
      }

LABEL_654:
      goto LABEL_566;
    }

    uint64_t v92 = (void *)v91;
    -[NEIKEv2SessionConfiguration setAuthenticationProtocol:](v2, "setAuthenticationProtocol:", v91);
  }

  if (CFDictionaryContainsKey(v5, @"RemoteAuthenticationMethod")
    && !NEGetValueWithType(v5, @"RemoteAuthenticationMethod", CFSTRING_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1654;
    __int16 v253 = 2112;
    v254 = @"RemoteAuthenticationMethod";
    __int16 v255 = 2048;
    uint64_t v256 = CFSTRING_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"RemoteAuthenticationMethod"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"RemoteAuthenticationMethod");
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v93 = NEIPsecIKEGetAuthProcotol(v90);
    if (!v93)
    {
      ne_log_obj();
      uint64_t v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136315650;
        v250 = "NEIPSecIKEValidateSessionDictionary";
        __int16 v251 = 1024;
        int v252 = 1659;
        __int16 v253 = 2112;
        v254 = (const __CFString *)v90;
LABEL_656:
        _os_log_error_impl( &dword_1876B1000,  v94,  OS_LOG_TYPE_ERROR,  "%s%d: %@ is not a recognized authentication method",  buf,  0x1Cu);
        goto LABEL_654;
      }

      goto LABEL_654;
    }

    goto LABEL_309;
  }

  -[NEIKEv2SessionConfiguration authenticationProtocol](v2, "authenticationProtocol");
  uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue();

  if (v98)
  {
    -[NEIKEv2SessionConfiguration authenticationProtocol](v2, "authenticationProtocol");
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v93 = -[os_log_s copy](v90, "copy");
LABEL_309:
    uint32_t v99 = (void *)v93;
    -[NEIKEv2SessionConfiguration setRemoteAuthentication:](v2, "setRemoteAuthentication:", v93);
  }

  if (CFDictionaryContainsKey(v5, @"PDUSessionID")
    && !NEGetValueWithType(v5, @"PDUSessionID", CFNUMBER_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_566;
    }
    *(_DWORD *)__int128 buf = 136315906;
    v250 = "NEIPSecIKEValidateSessionDictionary";
    __int16 v251 = 1024;
    int v252 = 1667;
    __int16 v253 = 2112;
    v254 = @"PDUSessionID";
    __int16 v255 = 2048;
    uint64_t v256 = CFNUMBER_TYPE;
    uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
    goto LABEL_565;
  }

  if (CFDictionaryContainsKey(v5, @"PDUSessionID"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"PDUSessionID");
    uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2SessionConfiguration setPduSessionID:](v2, "setPduSessionID:", v100);
  }

  if (CFDictionaryContainsKey(v5, @"ConfigurationRequest"))
  {
    -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"ConfigurationRequest");
    uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();

    if ((isKindOfClass & 1) != 0)
    {
      id newValue = objc_alloc_init(MEMORY[0x189603FA8]);
      -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"ConfigurationRequest");
      CFStringRef v103 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      obuint64_t j = v103;
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        __int128 v239 = 0u;
        __int128 v240 = 0u;
        __int128 v241 = 0u;
        __int128 v242 = 0u;
        id v104 = v103;
        uint64_t v105 = [v104 countByEnumeratingWithState:&v239 objects:v248 count:16];
        if (v105)
        {
          uint64_t v106 = v105;
          uint64_t v107 = *(void *)v240;
          do
          {
            for (uint64_t i = 0LL; i != v106; ++i)
            {
              if (*(void *)v240 != v107) {
                objc_enumerationMutation(v104);
              }
              __int128 v109 = *(void **)(*((void *)&v239 + 1) + 8 * i);
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                char v110 = [v109 isEqualToString:@"AssignedIPv4Address"];
                time_t v111 = off_18A087AF0;
                if ((v110 & 1) != 0) {
                  goto LABEL_338;
                }
                char v112 = [v109 isEqualToString:@"AssignedIPv4DNS"];
                time_t v111 = off_18A087B00;
                if ((v112 & 1) != 0) {
                  goto LABEL_338;
                }
                char v113 = [v109 isEqualToString:@"AssignedIPv4DHCP"];
                time_t v111 = off_18A087AF8;
                if ((v113 & 1) != 0) {
                  goto LABEL_338;
                }
                char v114 = [v109 isEqualToString:@"AssignedIPv4NetMask"];
                time_t v111 = off_18A087B08;
                if ((v114 & 1) != 0) {
                  goto LABEL_338;
                }
                char v115 = [v109 isEqualToString:@"AssignedIPv4Subnet"];
                time_t v111 = off_18A087B18;
                if ((v115 & 1) != 0) {
                  goto LABEL_338;
                }
                char v116 = [v109 isEqualToString:@"AssignedIPv6Address"];
                time_t v111 = off_18A087B20;
                if ((v116 & 1) != 0) {
                  goto LABEL_338;
                }
                char v117 = [v109 isEqualToString:@"AssignedIPv6DNS"];
                time_t v111 = off_18A087B30;
                if ((v117 & 1) != 0) {
                  goto LABEL_338;
                }
                char v118 = [v109 isEqualToString:@"AssignedIPv6DHCP"];
                time_t v111 = off_18A087B28;
                if ((v118 & 1) != 0) {
                  goto LABEL_338;
                }
                char v119 = [v109 isEqualToString:@"AssignedIPv6Subnet"];
                time_t v111 = off_18A087B40;
                if ((v119 & 1) != 0) {
                  goto LABEL_338;
                }
                char v120 = [v109 isEqualToString:@"AssignedAppVersion"];
                time_t v111 = off_18A0879B0;
                if ((v120 & 1) != 0) {
                  goto LABEL_338;
                }
                char v121 = [v109 isEqualToString:@"AssignedIPv6PCSCF"];
                time_t v111 = off_18A087B38;
                if ((v121 & 1) != 0) {
                  goto LABEL_338;
                }
                char v122 = [v109 isEqualToString:@"AssignedIPv6PCSCF_STD"];
                time_t v111 = off_18A087B38;
                if ((v122 & 1) != 0
                  || (char v123 = [v109 isEqualToString:@"AssignedIPv4PCSCF_STD"],
                      time_t v111 = off_18A087B10,
                      (v123 & 1) != 0)
                  || (char v124 = [v109 isEqualToString:@"AssignedDNSDomain"],
                      time_t v111 = off_18A087A28,
                      (v124 & 1) != 0)
                  || (int v125 = [v109 isEqualToString:@"AssignedAttributes"],
                      time_t v111 = off_18A087CB0,
                      v125))
                {
LABEL_338:
                  __int128 v126 = (void *)[objc_alloc(*v111) initEmptyRequest];
                  [newValue addObject:v126];
                }
              }
            }

            uint64_t v106 = [v104 countByEnumeratingWithState:&v239 objects:v248 count:16];
          }

          while (v106);
        }

LABEL_424:
        goto LABEL_425;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
LABEL_425:
        __int128 v140 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
        __int128 v142 = v140;
        if (v140)
        {
          v140->_configurationType = 1LL;
          objc_setProperty_atomic(v140, v141, newValue, 16LL);
        }

        -[NEIKEv2SessionConfiguration setConfigurationRequest:](v2, "setConfigurationRequest:", v142);

        goto LABEL_428;
      }

      __int128 v235 = 0u;
      __int128 v236 = 0u;
      __int128 v237 = 0u;
      __int128 v238 = 0u;
      id v127 = v103;
      uint64_t v128 = [v127 countByEnumeratingWithState:&v235 objects:v247 count:16];
      if (!v128) {
        goto LABEL_424;
      }
      uint64_t v129 = v128;
      uint64_t v217 = *(void *)v236;
LABEL_349:
      uint64_t v130 = 0LL;
      while (1)
      {
        if (*(void *)v236 != v217) {
          objc_enumerationMutation(v127);
        }
        __int128 v131 = *(void **)(*((void *)&v235 + 1) + 8 * v130);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          goto LABEL_394;
        }
        [v127 objectForKeyedSubscript:v131];
        __int128 v132 = (void *)objc_claimAutoreleasedReturnValue();
        if ([v131 isEqualToString:@"AssignedIPv4Address"])
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0 || ![v132 length])
          {
            __int128 v135 = &OBJC_CLASS___NEIKEv2IPv4AddressAttribute;
            goto LABEL_390;
          }

          [MEMORY[0x189608DE8] endpointWithHostname:v132 port:@"0"];
          __int128 v133 = (void *)objc_claimAutoreleasedReturnValue();
          __int128 v134 = &OBJC_CLASS___NEIKEv2IPv4AddressAttribute;
        }

        else if ([v131 isEqualToString:@"AssignedIPv4DNS"])
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0 || ![v132 length])
          {
            __int128 v135 = &OBJC_CLASS___NEIKEv2IPv4DNSAttribute;
            goto LABEL_390;
          }

          [MEMORY[0x189608DE8] endpointWithHostname:v132 port:@"0"];
          __int128 v133 = (void *)objc_claimAutoreleasedReturnValue();
          __int128 v134 = &OBJC_CLASS___NEIKEv2IPv4DNSAttribute;
        }

        else if ([v131 isEqualToString:@"AssignedIPv4DHCP"])
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0 || ![v132 length])
          {
            __int128 v135 = &OBJC_CLASS___NEIKEv2IPv4DHCPAttribute;
            goto LABEL_390;
          }

          [MEMORY[0x189608DE8] endpointWithHostname:v132 port:@"0"];
          __int128 v133 = (void *)objc_claimAutoreleasedReturnValue();
          __int128 v134 = &OBJC_CLASS___NEIKEv2IPv4DHCPAttribute;
        }

        else if ([v131 isEqualToString:@"AssignedIPv4NetMask"])
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0 || ![v132 length])
          {
            __int128 v135 = &OBJC_CLASS___NEIKEv2IPv4NetmaskAttribute;
            goto LABEL_390;
          }

          [MEMORY[0x189608DE8] endpointWithHostname:v132 port:@"0"];
          __int128 v133 = (void *)objc_claimAutoreleasedReturnValue();
          __int128 v134 = &OBJC_CLASS___NEIKEv2IPv4NetmaskAttribute;
        }

        else
        {
          if ([v131 isEqualToString:@"AssignedIPv4Subnet"])
          {
            __int128 v135 = &OBJC_CLASS___NEIKEv2IPv4SubnetAttribute;
            goto LABEL_390;
          }

          if ([v131 isEqualToString:@"AssignedIPv6Address"])
          {
            __int128 v135 = &OBJC_CLASS___NEIKEv2IPv6AddressAttribute;
            goto LABEL_390;
          }

          if ([v131 isEqualToString:@"AssignedIPv6DNS"])
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0 || ![v132 length])
            {
              __int128 v135 = &OBJC_CLASS___NEIKEv2IPv6DNSAttribute;
              goto LABEL_390;
            }

            [MEMORY[0x189608DE8] endpointWithHostname:v132 port:@"0"];
            __int128 v133 = (void *)objc_claimAutoreleasedReturnValue();
            __int128 v134 = &OBJC_CLASS___NEIKEv2IPv6DNSAttribute;
          }

          else if ([v131 isEqualToString:@"AssignedIPv6DHCP"])
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0 || ![v132 length])
            {
              __int128 v135 = &OBJC_CLASS___NEIKEv2IPv6DHCPAttribute;
              goto LABEL_390;
            }

            [MEMORY[0x189608DE8] endpointWithHostname:v132 port:@"0"];
            __int128 v133 = (void *)objc_claimAutoreleasedReturnValue();
            __int128 v134 = &OBJC_CLASS___NEIKEv2IPv6DHCPAttribute;
          }

          else
          {
            if ([v131 isEqualToString:@"AssignedIPv6Subnet"])
            {
              __int128 v135 = &OBJC_CLASS___NEIKEv2IPv6SubnetAttribute;
              goto LABEL_390;
            }

            if ([v131 isEqualToString:@"AssignedAppVersion"])
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0 && [v132 length])
              {
                __int128 v138 = &OBJC_CLASS___NEIKEv2AppVersionAttribute;
                goto LABEL_400;
              }

              __int128 v135 = &OBJC_CLASS___NEIKEv2AppVersionAttribute;
LABEL_390:
              uint64_t v137 = [[v135 alloc] initEmptyRequest];
              goto LABEL_391;
            }

            if (([v131 isEqualToString:@"AssignedIPv6PCSCF"] & 1) != 0
              || [v131 isEqualToString:@"AssignedIPv6PCSCF_STD"])
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0 || ![v132 length])
              {
                __int128 v135 = &OBJC_CLASS___NEIKEv2IPv6PCSCFAttribute;
                goto LABEL_390;
              }

              [MEMORY[0x189608DE8] endpointWithHostname:v132 port:@"0"];
              __int128 v133 = (void *)objc_claimAutoreleasedReturnValue();
              __int128 v134 = &OBJC_CLASS___NEIKEv2IPv6PCSCFAttribute;
            }

            else
            {
              if (![v131 isEqualToString:@"AssignedIPv4PCSCF_STD"])
              {
                if ([v131 isEqualToString:@"AssignedDNSDomain"])
                {
                  objc_opt_class();
                  if ((objc_opt_isKindOfClass() & 1) == 0 || ![v132 length])
                  {
                    __int128 v135 = &OBJC_CLASS___NEIKEv2DNSDomainAttribute;
                    goto LABEL_390;
                  }

                  __int128 v138 = &OBJC_CLASS___NEIKEv2DNSDomainAttribute;
                }

                else
                {
                  objc_opt_class();
                  if ((objc_opt_isKindOfClass() & 1) == 0 || ![v132 length])
                  {
                    __int128 v135 = &OBJC_CLASS___NEIKEv2SupportedAttribute;
                    goto LABEL_390;
                  }

                  __int128 v138 = &OBJC_CLASS___NEIKEv2SupportedAttribute;
                }

LABEL_400:
                uint64_t v137 = [[v138 alloc] initWithStringValue:v132];
LABEL_391:
                __int128 v133 = (void *)v137;
                [newValue addObject:v137];
                goto LABEL_392;
              }

              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0 || ![v132 length])
              {
                __int128 v135 = &OBJC_CLASS___NEIKEv2IPv4PCSCFAttribute;
                goto LABEL_390;
              }

              [MEMORY[0x189608DE8] endpointWithHostname:v132 port:@"0"];
              __int128 v133 = (void *)objc_claimAutoreleasedReturnValue();
              __int128 v134 = &OBJC_CLASS___NEIKEv2IPv4PCSCFAttribute;
            }
          }
        }

        __int128 v136 = (void *)[[v134 alloc] initWithAddress:v133];
        [newValue addObject:v136];

LABEL_392:
LABEL_393:

LABEL_394:
        if (v129 == ++v130)
        {
          uint64_t v139 = [v127 countByEnumeratingWithState:&v235 objects:v247 count:16];
          uint64_t v129 = v139;
          if (!v139) {
            goto LABEL_424;
          }
          goto LABEL_349;
        }
      }
    }
  }

LABEL_428:
  if (CFDictionaryContainsKey(v5, @"ConfigurationAttributeRequest")
    && !NEGetValueWithType(v5, @"ConfigurationAttributeRequest", CFARRAY_TYPE))
  {
    ne_log_obj();
    unsigned int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136315906;
      v250 = "NEIPSecIKEValidateSessionDictionary";
      __int16 v251 = 1024;
      int v252 = 1808;
      __int16 v253 = 2112;
      v254 = @"ConfigurationAttributeRequest";
      __int16 v255 = 2048;
      uint64_t v256 = CFARRAY_TYPE;
      uint64_t v95 = "%s:%d: type of value for key %@ != %lu";
      goto LABEL_565;
    }

LABEL_566:
    goto LABEL_567;
  }

  if (!CFDictionaryContainsKey(v5, @"ConfigurationAttributeRequest")) {
    goto LABEL_535;
  }
  id v214 = objc_alloc_init(MEMORY[0x189603FA8]);
  -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"ConfigurationAttributeRequest");
  __int128 v231 = 0u;
  __int128 v232 = 0u;
  __int128 v233 = 0u;
  __int128 v234 = 0u;
  id obja = (id)objc_claimAutoreleasedReturnValue();
  id newValuea = (id)[obja countByEnumeratingWithState:&v231 objects:v246 count:16];
  if (!newValuea) {
    goto LABEL_532;
  }
  uint64_t v218 = *(void *)v232;
  do
  {
    __int128 v143 = 0LL;
    do
    {
      if (*(void *)v232 != v218) {
        objc_enumerationMutation(obja);
      }
      __int128 v144 = *(void **)(*((void *)&v231 + 1) + 8LL * (void)v143);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        [v144 objectForKeyedSubscript:@"Name"];
        uint64_t v145 = (void *)objc_claimAutoreleasedReturnValue();
        [v144 objectForKeyedSubscript:@"Identifier"];
        v146 = (void *)objc_claimAutoreleasedReturnValue();
        [v144 objectForKeyedSubscript:@"Type"];
        uint64_t v147 = (void *)objc_claimAutoreleasedReturnValue();
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            if ([v147 isEqualToString:@"String"])
            {
              [v144 objectForKeyedSubscript:@"String"];
              __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
              int v149 = -[NEIKEv2StringAttribute initCustomWithAttributeType:attributeName:stringValue:]( [NEIKEv2StringAttribute alloc],  "initCustomWithAttributeType:attributeName:stringValue:",  [v146 integerValue],  v145,  v148);
              goto LABEL_477;
            }

            if ([v147 isEqualToString:@"IPv4Address"])
            {
              [v144 objectForKeyedSubscript:@"Address"];
              __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
                __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
              }

              else
              {
                __int16 v150 = 0LL;
              }

              id v153 = -[NEIKEv2AddressAttribute initCustomWithAttributeType:attributeName:addressValue:]( [NEIKEv2IPv4AddressAttribute alloc],  "initCustomWithAttributeType:attributeName:addressValue:",  [v146 integerValue],  v145,  v150);
              goto LABEL_459;
            }

            if ([v147 isEqualToString:@"IPv6Address"])
            {
              [v144 objectForKeyedSubscript:@"Address"];
              __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
                __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
              }

              else
              {
                __int16 v150 = 0LL;
              }

              id v153 = -[NEIKEv2SubnetAttribute initCustomWithAttributeType:attributeName:addressValue:prefix:]( [NEIKEv2IPv6AddressAttribute alloc],  "initCustomWithAttributeType:attributeName:addressValue:prefix:",  [v146 integerValue],  v145,  v150,  0);
LABEL_459:
              uint64_t v154 = v153;
              [v214 addObject:v153];
LABEL_460:

LABEL_478:
LABEL_479:

              goto LABEL_480;
            }

            if ([v147 isEqualToString:@"IPv4Subnet"])
            {
              [v144 objectForKeyedSubscript:@"Address"];
              __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
              [v144 objectForKeyedSubscript:@"Netmask"];
              __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
                v212 = (void *)objc_claimAutoreleasedReturnValue();
              }

              else
              {
                v212 = 0LL;
              }

              v210 = objc_alloc(&OBJC_CLASS___NEIKEv2IPv4SubnetAttribute);
              uint64_t v159 = [v146 integerValue];
              unsigned __int8 v160 = NEGetPrefixForIPv4NetmaskString(v150);
            }

            else
            {
              [v144 objectForKeyedSubscript:@"Address"];
              __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
              [v144 objectForKeyedSubscript:@"Netmask"];
              __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
                v212 = (void *)objc_claimAutoreleasedReturnValue();
              }

              else
              {
                v212 = 0LL;
              }

              v210 = objc_alloc(&OBJC_CLASS___NEIKEv2IPv6SubnetAttribute);
              uint64_t v159 = [v146 integerValue];
              unsigned __int8 v160 = NEGetPrefixForIPv6NetmaskString(v150);
            }

            id v161 = -[NEIKEv2SubnetAttribute initCustomWithAttributeType:attributeName:addressValue:prefix:]( v210,  "initCustomWithAttributeType:attributeName:addressValue:prefix:",  v159,  v145,  v212,  v160);
            [v214 addObject:v161];

            goto LABEL_478;
          }
        }

        if ([v145 isEqualToString:@"AssignedIPv4Address"])
        {
          [v144 objectForKeyedSubscript:@"Address"];
          __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
            __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
            uint64_t v151 = &OBJC_CLASS___NEIKEv2IPv4AddressAttribute;
LABEL_458:
            id v153 = (id)[[v151 alloc] initWithAddress:v150];
            goto LABEL_459;
          }

          __int16 v152 = &OBJC_CLASS___NEIKEv2IPv4AddressAttribute;
          goto LABEL_475;
        }

        if ([v145 isEqualToString:@"AssignedIPv4DNS"])
        {
          [v144 objectForKeyedSubscript:@"Address"];
          __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
            __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
            uint64_t v151 = &OBJC_CLASS___NEIKEv2IPv4DNSAttribute;
            goto LABEL_458;
          }

          __int16 v152 = &OBJC_CLASS___NEIKEv2IPv4DNSAttribute;
LABEL_475:
          id v156 = objc_alloc(v152);
LABEL_476:
          int v149 = (__CFString *)[v156 initEmptyRequest];
          goto LABEL_477;
        }

        if ([v145 isEqualToString:@"AssignedIPv4DHCP"])
        {
          [v144 objectForKeyedSubscript:@"Address"];
          __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
            __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
            uint64_t v151 = &OBJC_CLASS___NEIKEv2IPv4DHCPAttribute;
            goto LABEL_458;
          }

          __int16 v152 = &OBJC_CLASS___NEIKEv2IPv4DHCPAttribute;
          goto LABEL_475;
        }

        if ([v145 isEqualToString:@"AssignedIPv4NetMask"])
        {
          [v144 objectForKeyedSubscript:@"Address"];
          __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
            __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
            uint64_t v151 = &OBJC_CLASS___NEIKEv2IPv4NetmaskAttribute;
            goto LABEL_458;
          }

          __int16 v152 = &OBJC_CLASS___NEIKEv2IPv4NetmaskAttribute;
          goto LABEL_475;
        }

        if ([v145 isEqualToString:@"AssignedIPv4Subnet"])
        {
          [v144 objectForKeyedSubscript:@"Address"];
          __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
          [v144 objectForKeyedSubscript:@"Netmask"];
          __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
              uint64_t v154 = (void *)objc_claimAutoreleasedReturnValue();
              v211 = objc_alloc(&OBJC_CLASS___NEIKEv2IPv4SubnetAttribute);
              unsigned __int8 v155 = NEGetPrefixForIPv4NetmaskString(v150);
LABEL_487:
              v213 = -[NEIKEv2SubnetAttribute initWithAddress:prefix:](v211, "initWithAddress:prefix:", v154, v155);
              [v214 addObject:v213];

              goto LABEL_460;
            }
          }

          __int16 v158 = &OBJC_CLASS___NEIKEv2IPv4SubnetAttribute;
LABEL_498:
          id v153 = (id)[[v158 alloc] initEmptyRequest];
          goto LABEL_459;
        }

        if ([v145 isEqualToString:@"AssignedIPv6Address"])
        {
          [v144 objectForKeyedSubscript:@"Address"];
          __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
          [v144 objectForKeyedSubscript:@"Netmask"];
          __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
          {
            __int16 v158 = &OBJC_CLASS___NEIKEv2IPv6AddressAttribute;
            goto LABEL_498;
          }

          [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
          uint64_t v154 = (void *)objc_claimAutoreleasedReturnValue();
          v157 = &OBJC_CLASS___NEIKEv2IPv6AddressAttribute;
        }

        else
        {
          if ([v145 isEqualToString:@"AssignedIPv6DNS"])
          {
            [v144 objectForKeyedSubscript:@"Address"];
            __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
              __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
              uint64_t v151 = &OBJC_CLASS___NEIKEv2IPv6DNSAttribute;
              goto LABEL_458;
            }

            __int16 v152 = &OBJC_CLASS___NEIKEv2IPv6DNSAttribute;
            goto LABEL_475;
          }

          if ([v145 isEqualToString:@"AssignedIPv6DHCP"])
          {
            [v144 objectForKeyedSubscript:@"Address"];
            __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
              __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
              uint64_t v151 = &OBJC_CLASS___NEIKEv2IPv6DHCPAttribute;
              goto LABEL_458;
            }

            __int16 v152 = &OBJC_CLASS___NEIKEv2IPv6DHCPAttribute;
            goto LABEL_475;
          }

          if (![v145 isEqualToString:@"AssignedIPv6Subnet"])
          {
            if ([v145 isEqualToString:@"AssignedAppVersion"])
            {
              [v144 objectForKeyedSubscript:@"String"];
              __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
              objc_opt_class();
              char v162 = objc_opt_isKindOfClass();
              unsigned int v163 = &OBJC_CLASS___NEIKEv2AppVersionAttribute;
            }

            else
            {
              if (([v145 isEqualToString:@"AssignedIPv6PCSCF"] & 1) != 0
                || [v145 isEqualToString:@"AssignedIPv6PCSCF_STD"])
              {
                [v144 objectForKeyedSubscript:@"Address"];
                __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
                  __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
                  uint64_t v151 = &OBJC_CLASS___NEIKEv2IPv6PCSCFAttribute;
                  goto LABEL_458;
                }

                __int16 v152 = &OBJC_CLASS___NEIKEv2IPv6PCSCFAttribute;
                goto LABEL_475;
              }

              if ([v145 isEqualToString:@"AssignedIPv4PCSCF_STD"])
              {
                [v144 objectForKeyedSubscript:@"Address"];
                __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
                  __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
                  uint64_t v151 = &OBJC_CLASS___NEIKEv2IPv4PCSCFAttribute;
                  goto LABEL_458;
                }

                __int16 v152 = &OBJC_CLASS___NEIKEv2IPv4PCSCFAttribute;
                goto LABEL_475;
              }

              if ([v145 isEqualToString:@"AssignedDNSDomain"])
              {
                [v144 objectForKeyedSubscript:@"String"];
                __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
                objc_opt_class();
                char v162 = objc_opt_isKindOfClass();
                unsigned int v163 = &OBJC_CLASS___NEIKEv2DNSDomainAttribute;
              }

              else
              {
                [v144 objectForKeyedSubscript:@"String"];
                __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
                objc_opt_class();
                char v162 = objc_opt_isKindOfClass();
                unsigned int v163 = &OBJC_CLASS___NEIKEv2SupportedAttribute;
              }
            }

            id v156 = objc_alloc(v163);
            if ((v162 & 1) == 0) {
              goto LABEL_476;
            }
            int v149 = (__CFString *)[v156 initWithStringValue:v148];
LABEL_477:
            __int16 v150 = v149;
            [v214 addObject:v149];
            goto LABEL_478;
          }

          [v144 objectForKeyedSubscript:@"Address"];
          __int16 v148 = (void *)objc_claimAutoreleasedReturnValue();
          [v144 objectForKeyedSubscript:@"Netmask"];
          __int16 v150 = (__CFString *)objc_claimAutoreleasedReturnValue();
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
          {
            __int16 v158 = &OBJC_CLASS___NEIKEv2IPv6SubnetAttribute;
            goto LABEL_498;
          }

          [MEMORY[0x189608DE8] endpointWithHostname:v148 port:@"0"];
          uint64_t v154 = (void *)objc_claimAutoreleasedReturnValue();
          v157 = &OBJC_CLASS___NEIKEv2IPv6SubnetAttribute;
        }

        v211 = (NEIKEv2IPv4SubnetAttribute *)objc_alloc(v157);
        unsigned __int8 v155 = NEGetPrefixForIPv6NetmaskString(v150);
        goto LABEL_487;
      }

LABEL_480:
      __int128 v143 = (char *)v143 + 1;
    }

    while (newValuea != v143);
    uint64_t v164 = [obja countByEnumeratingWithState:&v231 objects:v246 count:16];
    id newValuea = (id)v164;
  }

  while (v164);
LABEL_532:

  CFRange v165 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
  v167 = v165;
  if (v165)
  {
    v165->_configurationType = 1LL;
    objc_setProperty_atomic(v165, v166, v214, 16LL);
  }

  -[NEIKEv2SessionConfiguration setConfigurationRequest:](v2, "setConfigurationRequest:", v167);

LABEL_535:
  if (!CFDictionaryContainsKey(v5, @"ConfigurationReply")) {
    goto LABEL_652;
  }
  v168 = -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"ConfigurationReply");
  objc_opt_class();
  char v169 = objc_opt_isKindOfClass();

  if ((v169 & 1) == 0) {
    goto LABEL_652;
  }
  id newValueb = objc_alloc_init(MEMORY[0x189603FA8]);
  v170 = -[os_log_s objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"ConfigurationReply");
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      goto LABEL_649;
    }
    __int128 v223 = 0u;
    __int128 v224 = 0u;
    __int128 v225 = 0u;
    __int128 v226 = 0u;
    id v194 = v170;
    uint64_t v195 = [v194 countByEnumeratingWithState:&v223 objects:v244 count:16];
    if (!v195) {
      goto LABEL_648;
    }
    uint64_t v196 = v195;
    uint64_t v219 = *(void *)v224;
LABEL_573:
    uint64_t v197 = 0LL;
    while (1)
    {
      if (*(void *)v224 != v219) {
        objc_enumerationMutation(v194);
      }
      v198 = *(void **)(*((void *)&v223 + 1) + 8 * v197);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_618;
      }
      [v194 objectForKeyedSubscript:v198];
      v199 = (void *)objc_claimAutoreleasedReturnValue();
      if ([v198 isEqualToString:@"AssignedIPv4Address"])
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0 || ![v199 length])
        {
          v202 = &OBJC_CLASS___NEIKEv2IPv4AddressAttribute;
          goto LABEL_614;
        }

        [MEMORY[0x189608DE8] endpointWithHostname:v199 port:@"0"];
        v200 = (void *)objc_claimAutoreleasedReturnValue();
        v201 = &OBJC_CLASS___NEIKEv2IPv4AddressAttribute;
      }

      else if ([v198 isEqualToString:@"AssignedIPv4DNS"])
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0 || ![v199 length])
        {
          v202 = &OBJC_CLASS___NEIKEv2IPv4DNSAttribute;
          goto LABEL_614;
        }

        [MEMORY[0x189608DE8] endpointWithHostname:v199 port:@"0"];
        v200 = (void *)objc_claimAutoreleasedReturnValue();
        v201 = &OBJC_CLASS___NEIKEv2IPv4DNSAttribute;
      }

      else if ([v198 isEqualToString:@"AssignedIPv4DHCP"])
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0 || ![v199 length])
        {
          v202 = &OBJC_CLASS___NEIKEv2IPv4DHCPAttribute;
          goto LABEL_614;
        }

        [MEMORY[0x189608DE8] endpointWithHostname:v199 port:@"0"];
        v200 = (void *)objc_claimAutoreleasedReturnValue();
        v201 = &OBJC_CLASS___NEIKEv2IPv4DHCPAttribute;
      }

      else if ([v198 isEqualToString:@"AssignedIPv4NetMask"])
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0 || ![v199 length])
        {
          v202 = &OBJC_CLASS___NEIKEv2IPv4NetmaskAttribute;
          goto LABEL_614;
        }

        [MEMORY[0x189608DE8] endpointWithHostname:v199 port:@"0"];
        v200 = (void *)objc_claimAutoreleasedReturnValue();
        v201 = &OBJC_CLASS___NEIKEv2IPv4NetmaskAttribute;
      }

      else
      {
        if ([v198 isEqualToString:@"AssignedIPv4Subnet"])
        {
          v202 = &OBJC_CLASS___NEIKEv2IPv4SubnetAttribute;
          goto LABEL_614;
        }

        if ([v198 isEqualToString:@"AssignedIPv6Address"])
        {
          v202 = &OBJC_CLASS___NEIKEv2IPv6AddressAttribute;
          goto LABEL_614;
        }

        if ([v198 isEqualToString:@"AssignedIPv6DNS"])
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0 || ![v199 length])
          {
            v202 = &OBJC_CLASS___NEIKEv2IPv6DNSAttribute;
            goto LABEL_614;
          }

          [MEMORY[0x189608DE8] endpointWithHostname:v199 port:@"0"];
          v200 = (void *)objc_claimAutoreleasedReturnValue();
          v201 = &OBJC_CLASS___NEIKEv2IPv6DNSAttribute;
        }

        else if ([v198 isEqualToString:@"AssignedIPv6DHCP"])
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0 || ![v199 length])
          {
            v202 = &OBJC_CLASS___NEIKEv2IPv6DHCPAttribute;
            goto LABEL_614;
          }

          [MEMORY[0x189608DE8] endpointWithHostname:v199 port:@"0"];
          v200 = (void *)objc_claimAutoreleasedReturnValue();
          v201 = &OBJC_CLASS___NEIKEv2IPv6DHCPAttribute;
        }

        else
        {
          if ([v198 isEqualToString:@"AssignedIPv6Subnet"])
          {
            v202 = &OBJC_CLASS___NEIKEv2IPv6SubnetAttribute;
            goto LABEL_614;
          }

          if ([v198 isEqualToString:@"AssignedAppVersion"])
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0 && [v199 length])
            {
              v205 = &OBJC_CLASS___NEIKEv2AppVersionAttribute;
              goto LABEL_624;
            }

            v202 = &OBJC_CLASS___NEIKEv2AppVersionAttribute;
LABEL_614:
            uint64_t v204 = [[v202 alloc] initEmptyRequest];
            goto LABEL_615;
          }

          if (([v198 isEqualToString:@"AssignedIPv6PCSCF"] & 1) != 0
            || [v198 isEqualToString:@"AssignedIPv6PCSCF_STD"])
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0 || ![v199 length])
            {
              v202 = &OBJC_CLASS___NEIKEv2IPv6PCSCFAttribute;
              goto LABEL_614;
            }

            [MEMORY[0x189608DE8] endpointWithHostname:v199 port:@"0"];
            v200 = (void *)objc_claimAutoreleasedReturnValue();
            v201 = &OBJC_CLASS___NEIKEv2IPv6PCSCFAttribute;
          }

          else
          {
            if (![v198 isEqualToString:@"AssignedIPv4PCSCF_STD"])
            {
              if ([v198 isEqualToString:@"AssignedDNSDomain"])
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) == 0 || ![v199 length])
                {
                  v202 = &OBJC_CLASS___NEIKEv2DNSDomainAttribute;
                  goto LABEL_614;
                }

                v205 = &OBJC_CLASS___NEIKEv2DNSDomainAttribute;
              }

              else
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) == 0 || ![v199 length])
                {
                  v202 = &OBJC_CLASS___NEIKEv2SupportedAttribute;
                  goto LABEL_614;
                }

                v205 = &OBJC_CLASS___NEIKEv2SupportedAttribute;
              }

LABEL_624:
              uint64_t v204 = [[v205 alloc] initWithStringValue:v199];
LABEL_615:
              v200 = (void *)v204;
              [newValueb addObject:v204];
              goto LABEL_616;
            }

            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0 || ![v199 length])
            {
              v202 = &OBJC_CLASS___NEIKEv2IPv4PCSCFAttribute;
              goto LABEL_614;
            }

            [MEMORY[0x189608DE8] endpointWithHostname:v199 port:@"0"];
            v200 = (void *)objc_claimAutoreleasedReturnValue();
            v201 = &OBJC_CLASS___NEIKEv2IPv4PCSCFAttribute;
          }
        }
      }

      v203 = (void *)[[v201 alloc] initWithAddress:v200];
      [newValueb addObject:v203];

LABEL_616:
LABEL_617:

LABEL_618:
      if (v196 == ++v197)
      {
        uint64_t v206 = [v194 countByEnumeratingWithState:&v223 objects:v244 count:16];
        uint64_t v196 = v206;
        if (!v206) {
          goto LABEL_648;
        }
        goto LABEL_573;
      }
    }
  }

  __int128 v227 = 0u;
  __int128 v228 = 0u;
  __int128 v229 = 0u;
  __int128 v230 = 0u;
  id v171 = v170;
  uint64_t v172 = [v171 countByEnumeratingWithState:&v227 objects:v245 count:16];
  if (v172)
  {
    uint64_t v173 = v172;
    uint64_t v174 = *(void *)v228;
    do
    {
      for (uint64_t j = 0LL; j != v173; ++j)
      {
        if (*(void *)v228 != v174) {
          objc_enumerationMutation(v171);
        }
        v176 = *(void **)(*((void *)&v227 + 1) + 8 * j);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          char v177 = [v176 isEqualToString:@"AssignedIPv4Address"];
          v178 = off_18A087AF0;
          if ((v177 & 1) != 0) {
            goto LABEL_559;
          }
          char v179 = [v176 isEqualToString:@"AssignedIPv4DNS"];
          v178 = off_18A087B00;
          if ((v179 & 1) != 0) {
            goto LABEL_559;
          }
          char v180 = [v176 isEqualToString:@"AssignedIPv4DHCP"];
          v178 = off_18A087AF8;
          if ((v180 & 1) != 0) {
            goto LABEL_559;
          }
          char v181 = [v176 isEqualToString:@"AssignedIPv4NetMask"];
          v178 = off_18A087B08;
          if ((v181 & 1) != 0) {
            goto LABEL_559;
          }
          char v182 = [v176 isEqualToString:@"AssignedIPv4Subnet"];
          v178 = off_18A087B18;
          if ((v182 & 1) != 0) {
            goto LABEL_559;
          }
          char v183 = [v176 isEqualToString:@"AssignedIPv6Address"];
          v178 = off_18A087B20;
          if ((v183 & 1) != 0) {
            goto LABEL_559;
          }
          char v184 = [v176 isEqualToString:@"AssignedIPv6DNS"];
          v178 = off_18A087B30;
          if ((v184 & 1) != 0) {
            goto LABEL_559;
          }
          char v185 = [v176 isEqualToString:@"AssignedIPv6DHCP"];
          v178 = off_18A087B28;
          if ((v185 & 1) != 0) {
            goto LABEL_559;
          }
          char v186 = [v176 isEqualToString:@"AssignedIPv6Subnet"];
          v178 = off_18A087B40;
          if ((v186 & 1) != 0) {
            goto LABEL_559;
          }
          char v187 = [v176 isEqualToString:@"AssignedAppVersion"];
          v178 = off_18A0879B0;
          if ((v187 & 1) != 0) {
            goto LABEL_559;
          }
          char v188 = [v176 isEqualToString:@"AssignedIPv6PCSCF"];
          v178 = off_18A087B38;
          if ((v188 & 1) != 0) {
            goto LABEL_559;
          }
          char v189 = [v176 isEqualToString:@"AssignedIPv6PCSCF_STD"];
          v178 = off_18A087B38;
          if ((v189 & 1) != 0
            || (char v190 = [v176 isEqualToString:@"AssignedIPv4PCSCF_STD"],
                v178 = off_18A087B10,
                (v190 & 1) != 0)
            || (char v191 = [v176 isEqualToString:@"AssignedDNSDomain"],
                v178 = off_18A087A28,
                (v191 & 1) != 0)
            || (int v192 = [v176 isEqualToString:@"AssignedAttributes"], v178 = off_18A087CB0, v192))
          {
LABEL_559:
            v193 = (void *)[objc_alloc(*v178) initEmptyRequest];
            [newValueb addObject:v193];
          }
        }
      }

      uint64_t v173 = [v171 countByEnumeratingWithState:&v227 objects:v245 count:16];
    }

    while (v173);
  }

LABEL_648:
LABEL_649:
  v207 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
  v209 = v207;
  if (v207)
  {
    v207->_configurationType = 2LL;
    objc_setProperty_atomic(v207, v208, newValueb, 16LL);
  }

  -[NEIKEv2SessionConfiguration setConfigurationReply:](v2, "setConfigurationReply:", v209);

LABEL_652:
  int v12 = v2;
LABEL_568:

LABEL_569:
LABEL_15:

  return v12;
}

uint64_t __NEIPSecIKECreateSessionWithInterfaceAndSASession_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 32))(a2, a3, a4, a5);
}

id NEIPSecIKECopyDefaultSessionQueue()
{
  if (NEIPSecIKECopyDefaultSessionQueue_onceToken != -1) {
    dispatch_once(&NEIPSecIKECopyDefaultSessionQueue_onceToken, &__block_literal_global_516);
  }
  return (id)NEIPSecIKECopyDefaultSessionQueue_queue;
}

uint64_t __NEIPSecIKECreateSessionWithInterfaceAndSASession_block_invoke_238(void *a1)
{
  uint64_t v2 = objc_alloc(&OBJC_CLASS___NEIKEv2Session);
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];
  id v6 = NEIPSecIKECopyDefaultSessionQueue();
  uint64_t v7 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSession:packetDelegate:]( v2,  "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSession:packetDelegate:",  v3,  v4,  v5,  v6,  a1[10],  a1[8],  a1[7],  0LL);
  uint64_t v8 = *(void *)(a1[9] + 8LL);
  char v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = v7;

  [*(id *)(*(void *)(a1[9] + 8) + 40) setClientCallback:a1[11]];
  return [*(id *)(*(void *)(a1[9] + 8) + 40) setClientCallbackInfo:a1[12]];
}

void __NEIPSecIKECopyDefaultSessionQueue_block_invoke()
{
  uint64_t v2 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
  dispatch_queue_t v0 = dispatch_queue_create("IKEv2 Session Queue", v2);
  uint64_t v1 = (void *)NEIPSecIKECopyDefaultSessionQueue_queue;
  NEIPSecIKECopyDefaultSessionQueue_queue = (uint64_t)v0;
}

uint64_t NEIPsecIKEGetAuthProcotol(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"SharedSecret"])
  {
    uint64_t v2 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
    uint64_t v3 = 2LL;
  }

  else if ([v1 isEqualToString:@"Certificate"])
  {
    uint64_t v2 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
    uint64_t v3 = 1LL;
  }

  else if ([v1 isEqualToString:@"ECDSA256"])
  {
    uint64_t v2 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
    uint64_t v3 = 9LL;
  }

  else if ([v1 isEqualToString:@"ECDSA384"])
  {
    uint64_t v2 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
    uint64_t v3 = 10LL;
  }

  else if ([v1 isEqualToString:@"ECDSA521"])
  {
    uint64_t v2 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
    uint64_t v3 = 11LL;
  }

  else
  {
    if (![v1 isEqualToString:@"None"])
    {
      if ([v1 isEqualToString:@"Ed25519"])
      {
        uint64_t v7 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
        uint64_t v8 = 3LL;
      }

      else
      {
        if (![v1 isEqualToString:@"Ed448"])
        {
          if (![v1 isEqualToString:@"RSA-PSS"])
          {
            uint64_t v5 = 0LL;
            goto LABEL_15;
          }

          uint64_t v2 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
          uint64_t v3 = 245LL;
          goto LABEL_13;
        }

        uint64_t v7 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
        uint64_t v8 = 4LL;
      }

      uint64_t v4 = -[NEIKEv2AuthenticationProtocol initWithDigitalSignature:](v7, "initWithDigitalSignature:", v8);
      goto LABEL_14;
    }

    uint64_t v2 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
    uint64_t v3 = 0LL;
  }

NEIKEv2EncryptionProtocol *NEIPsecIKEGetEncryptionProtocol(void *a1, int a2)
{
  id v3 = a1;
  if (![v3 isEqualToString:@"DES"])
  {
    if ([v3 isEqualToString:@"3DES"])
    {
      uint64_t v4 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol);
      uint64_t v5 = 3LL;
      goto LABEL_5;
    }

    if ([v3 isEqualToString:@"AES-128"])
    {
      uint64_t v7 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol);
      uint64_t v8 = 2LL;
    }

    else if ([v3 isEqualToString:@"AES-256"])
    {
      uint64_t v7 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol);
      uint64_t v8 = 3LL;
    }

    else if ([v3 isEqualToString:@"AES-128-GCM"])
    {
      uint64_t v7 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol);
      uint64_t v8 = 4LL;
    }

    else if ([v3 isEqualToString:@"AES-256-GCM"])
    {
      uint64_t v7 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol);
      uint64_t v8 = 5LL;
    }

    else
    {
      if (![v3 isEqualToString:@"ChaCha20-Poly1305"])
      {
        if (a2)
        {
          if ([v3 isEqualToString:@"ChaCha20-Poly1305-IIV"])
          {
            uint64_t v7 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol);
            uint64_t v8 = 7LL;
            goto LABEL_16;
          }

          if ([v3 isEqualToString:@"AES-128-GCM-IIV"])
          {
            uint64_t v7 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol);
            uint64_t v8 = 8LL;
            goto LABEL_16;
          }

          if ([v3 isEqualToString:@"AES-256-GCM-IIV"])
          {
            uint64_t v7 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol);
            uint64_t v8 = 9LL;
            goto LABEL_16;
          }
        }

        char v9 = 0LL;
        goto LABEL_18;
      }

      uint64_t v7 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptionProtocol);
      uint64_t v8 = 6LL;
    }

NEIKEv2IntegrityProtocol *NEIPsecIKEGetIntegrityProtocol(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"MD5-96"])
  {
    uint64_t v2 = 1LL;
  }

  else if ([v1 isEqualToString:@"MD5-128"])
  {
    uint64_t v2 = 6LL;
  }

  else if ([v1 isEqualToString:@"SHA1-96"])
  {
    uint64_t v2 = 2LL;
  }

  else if ([v1 isEqualToString:@"SHA1-160"])
  {
    uint64_t v2 = 7LL;
  }

  else if ([v1 isEqualToString:@"SHA2-256"])
  {
    uint64_t v2 = 12LL;
  }

  else if ([v1 isEqualToString:@"SHA2-384"])
  {
    uint64_t v2 = 13LL;
  }

  else
  {
    if (![v1 isEqualToString:@"SHA2-512"])
    {
      id v3 = 0LL;
      goto LABEL_16;
    }

    uint64_t v2 = 14LL;
  }

  id v3 = -[NEIKEv2IntegrityProtocol initWithType:]( objc_alloc(&OBJC_CLASS___NEIKEv2IntegrityProtocol),  "initWithType:",  v2);
LABEL_16:

  return v3;
}

NEIKEv2PRFProtocol *NEIPsecIKEGetPRFProtocol(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"MD5-128"])
  {
    uint64_t v2 = 1LL;
  }

  else if ([v1 isEqualToString:@"SHA1-160"])
  {
    uint64_t v2 = 2LL;
  }

  else if ([v1 isEqualToString:@"SHA2-256"])
  {
    uint64_t v2 = 5LL;
  }

  else if ([v1 isEqualToString:@"SHA2-384"])
  {
    uint64_t v2 = 6LL;
  }

  else
  {
    if (![v1 isEqualToString:@"SHA2-512"])
    {
      id v3 = 0LL;
      goto LABEL_12;
    }

    uint64_t v2 = 7LL;
  }

  id v3 = -[NEIKEv2PRFProtocol initWithType:](objc_alloc(&OBJC_CLASS___NEIKEv2PRFProtocol), "initWithType:", v2);
LABEL_12:

  return v3;
}

NEIKEv2EAPProtocol *NEIPsecIKEGetEAPProtocol(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"EAP-SIM"])
  {
    uint64_t v2 = 2LL;
LABEL_16:
    id v3 = -[NEIKEv2EAPProtocol initWithMethod:](objc_alloc(&OBJC_CLASS___NEIKEv2EAPProtocol), "initWithMethod:", v2);
    goto LABEL_17;
  }

  if ([v1 isEqualToString:@"EAP-AKA"])
  {
    uint64_t v2 = 3LL;
    goto LABEL_16;
  }

  if ([v1 isEqualToString:@"EAP-MSCHAPv2"])
  {
    uint64_t v2 = 4LL;
    goto LABEL_16;
  }

  if ([v1 isEqualToString:@"EAP-GTC"])
  {
    uint64_t v2 = 5LL;
    goto LABEL_16;
  }

  if ([v1 isEqualToString:@"EAP-TLS"])
  {
    uint64_t v2 = 6LL;
    goto LABEL_16;
  }

  if ([v1 isEqualToString:@"EAP-PEAP"])
  {
    uint64_t v2 = 7LL;
    goto LABEL_16;
  }

  if ([v1 isEqualToString:@"Any"])
  {
    uint64_t v2 = 1LL;
    goto LABEL_16;
  }

  uint64_t v2 = 0LL;
  id v3 = 0LL;
LABEL_17:

  return v3;
}

void __xpc_client_queue_block_invoke()
{
  uint64_t v2 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
  dispatch_queue_t v0 = dispatch_queue_create("com.apple.SecureNetworking.IPSec.xpc", v2);
  id v1 = (void *)xpc_client_queue_q;
  xpc_client_queue_q = (uint64_t)v0;
}

CFStringRef NEIPSecIKECreateSessionWithInterface( const __CFAllocator *a1, uint64_t a2, const __CFDictionary *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return NEIPSecIKECreateSessionWithInterfaceAndSASession(a1, a3, a4, a5, a6, a7, 0LL, 0LL, 0LL);
}

CFStringRef NEIPSecIKECreateUserspaceSession( const __CFAllocator *a1, uint64_t a2, const __CFDictionary *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  return NEIPSecIKECreateSessionWithInterfaceAndSASession(a1, a3, a4, a5, a6, a7, 0LL, 0LL, a8);
}

CFStringRef NEIPSecIKECreateSession( const __CFAllocator *a1, uint64_t a2, const __CFDictionary *a3, void *a4, uint64_t a5, uint64_t a6)
{
  return NEIPSecIKECreateSessionWithInterfaceAndSASession(a1, a3, a4, 0LL, a5, a6, 0LL, 0LL, 0LL);
}

uint64_t NEIPSecIKEUpdateIKESettings(void *a1)
{
  return 1LL;
}

uint64_t NEIPSecIKESetDispatchQueue(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  [v4 setClientQueue:v3];
  objc_initWeak(&location, v4);
  uint64_t v5 = MEMORY[0x1895F87A8];
  v19[0] = MEMORY[0x1895F87A8];
  v19[1] = 3221225472LL;
  v19[2] = __NEIPSecIKESetDispatchQueue_block_invoke;
  v19[3] = &unk_18A08E1C8;
  objc_copyWeak(&v20, &location);
  [v4 setStateUpdateBlock:v19];
  v17[0] = v5;
  v17[1] = 3221225472LL;
  __int128 v17[2] = __NEIPSecIKESetDispatchQueue_block_invoke_132;
  v17[3] = &unk_18A08E1F0;
  objc_copyWeak(&v18, &location);
  [v4 setChildStateUpdateBlock:v17];
  v15[0] = v5;
  v15[1] = 3221225472LL;
  void v15[2] = __NEIPSecIKESetDispatchQueue_block_invoke_134;
  v15[3] = &unk_18A08E218;
  objc_copyWeak(&v16, &location);
  [v4 setConfigurationUpdateBlock:v15];
  v13[0] = v5;
  v13[1] = 3221225472LL;
  v13[2] = __NEIPSecIKESetDispatchQueue_block_invoke_155;
  v13[3] = &unk_18A08E240;
  objc_copyWeak(&v14, &location);
  [v4 setTrafficSelectorUpdateBlock:v13];
  v11[0] = v5;
  v11[1] = 3221225472LL;
  v11[2] = __NEIPSecIKESetDispatchQueue_block_invoke_177;
  v11[3] = &unk_18A08FAC8;
  objc_copyWeak(&v12, &location);
  [v4 setShortDPDEventBlock:v11];
  v9[0] = v5;
  v9[1] = 3221225472LL;
  _DWORD v9[2] = __NEIPSecIKESetDispatchQueue_block_invoke_179;
  unint64_t v9[3] = &unk_18A08E268;
  objc_copyWeak(&v10, &location);
  [v4 setRedirectEventBlock:v9];
  v7[0] = v5;
  v7[1] = 3221225472LL;
  CFErrorRef v7[2] = __NEIPSecIKESetDispatchQueue_block_invoke_193;
  v7[3] = &unk_18A08FD30;
  objc_copyWeak(&v8, &location);
  [v4 setPrivateNotifyStatusEvent:v7];
  objc_destroyWeak(&v8);
  objc_destroyWeak(&v10);
  objc_destroyWeak(&v12);
  objc_destroyWeak(&v14);
  objc_destroyWeak(&v16);
  objc_destroyWeak(&v18);
  objc_destroyWeak(&v20);
  objc_destroyWeak(&location);

  return 1LL;
}

void sub_1877CD2C4(_Unwind_Exception *a1)
{
}

void sub_1877CD330()
{
}

void sub_1877CD338()
{
}

void __NEIPSecIKESetDispatchQueue_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (![WeakRetained clientCallback]) {
    goto LABEL_18;
  }
  if ((unint64_t)(a2 - 1) > 3)
  {
    int v7 = 0;
    if (v5) {
      goto LABEL_4;
    }
  }

  else
  {
    int v7 = dword_1878732F0[a2 - 1];
    if (v5)
    {
LABEL_4:
      uint64_t v8 = 70001LL;
      id v9 = objc_alloc_init(MEMORY[0x189603FC8]);
      [v5 domain];
      id v10 = (void *)objc_claimAutoreleasedReturnValue();
      int v11 = [v10 isEqual:@"NEIKEv2ErrorDomain"];

      if (v11)
      {
        uint64_t v12 = [v5 code];
      }

      else
      {
        [v5 domain];
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
        int v14 = [v13 isEqual:@"NEIKEv2ProtocolErrorDomain"];

        if (v14)
        {
          if ([v5 code] < 0x2000
            || [v5 code] >= 0x4000
            || [WeakRetained peerAuthenticated])
          {
            uint64_t v8 = [v5 code];
          }

          else
          {
            uint64_t v8 = 70039LL;
          }
        }
      }

      [MEMORY[0x189607968] numberWithUnsignedInt:v8];
      int v15 = (void *)objc_claimAutoreleasedReturnValue();
      [v9 setObject:v15 forKeyedSubscript:@"NotifyCode"];

      goto LABEL_15;
    }
  }

  id v9 = 0LL;
LABEL_15:
  ne_log_obj();
  id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    v17[0] = 67109378;
    v17[1] = v7;
    __int16 v18 = 2112;
    id v19 = v9;
    _os_log_debug_impl(&dword_1876B1000, v16, OS_LOG_TYPE_DEBUG, "Updating IKE status %u, %@", (uint8_t *)v17, 0x12u);
  }

  ((void (*)(id, void, void, id, uint64_t))[WeakRetained clientCallback])( WeakRetained,  0,  v7 | 0x1100u,  v9,  objc_msgSend(WeakRetained, "clientCallbackInfo"));
LABEL_18:
}

void __NEIPSecIKESetDispatchQueue_block_invoke_132(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (![WeakRetained clientCallback]) {
    goto LABEL_16;
  }
  if ((unint64_t)(a3 - 1) > 3)
  {
    int v9 = 0;
    if (v7)
    {
LABEL_4:
      id v10 = objc_alloc_init(MEMORY[0x189603FC8]);
      [v7 domain];
      int v11 = (void *)objc_claimAutoreleasedReturnValue();
      int v12 = [v11 isEqual:@"NEIKEv2ErrorDomain"];

      if (v12)
      {
        uint64_t v13 = [v7 code];
        if ((unint64_t)(v13 - 2) < 0xD)
        {
          uint64_t v14 = dword_187872EF0[v13 - 2];
LABEL_12:
          [MEMORY[0x189607968] numberWithUnsignedInt:v14];
          int v17 = (void *)objc_claimAutoreleasedReturnValue();
          [v10 setObject:v17 forKeyedSubscript:@"NotifyCode"];

          goto LABEL_13;
        }
      }

      else
      {
        [v7 domain];
        int v15 = (void *)objc_claimAutoreleasedReturnValue();
        int v16 = [v15 isEqual:@"NEIKEv2ProtocolErrorDomain"];

        if (v16)
        {
          uint64_t v14 = [v7 code];
          goto LABEL_12;
        }
      }

      uint64_t v14 = 70001LL;
      goto LABEL_12;
    }
  }

  else
  {
    int v9 = dword_1878732F0[a3 - 1];
    if (v7) {
      goto LABEL_4;
    }
  }

  id v10 = 0LL;
LABEL_13:
  ne_log_obj();
  __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    v19[0] = 67109634;
    v19[1] = a2;
    __int16 v20 = 1024;
    int v21 = v9;
    __int16 v22 = 2112;
    id v23 = v10;
    _os_log_debug_impl( &dword_1876B1000,  v18,  OS_LOG_TYPE_DEBUG,  "Updating Child %u status %u, %@",  (uint8_t *)v19,  0x18u);
  }

  ((void (*)(id, uint64_t, void, id, uint64_t))[WeakRetained clientCallback])( WeakRetained,  a2,  v9 | 0x1100u,  v10,  objc_msgSend(WeakRetained, "clientCallbackInfo"));
LABEL_16:
}

void __NEIPSecIKESetDispatchQueue_block_invoke_134(uint64_t a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (![WeakRetained clientCallback]) {
    goto LABEL_30;
  }
  id v6 = objc_alloc_init(MEMORY[0x189603FA8]);
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  uint64_t v25 = WeakRetained;
  id v26 = v3;
  if (v3) {
    id Property = objc_getProperty(v3, v5, 16LL, 1);
  }
  else {
    id Property = 0LL;
  }
  id v8 = Property;
  uint64_t v9 = [v8 countByEnumeratingWithState:&v27 objects:v33 count:16];
  if (!v9) {
    goto LABEL_27;
  }
  uint64_t v10 = v9;
  uint64_t v11 = *(void *)v28;
  do
  {
    uint64_t v12 = 0LL;
    do
    {
      if (*(void *)v28 != v11) {
        objc_enumerationMutation(v8);
      }
      uint64_t v13 = *(void **)(*((void *)&v27 + 1) + 8 * v12);
      id v14 = objc_alloc_init(MEMORY[0x189603FC8]);
      [v13 attributeName];
      int v15 = (void *)objc_claimAutoreleasedReturnValue();
      [v14 setObject:v15 forKeyedSubscript:@"Name"];

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0) {
        goto LABEL_11;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0) {
        goto LABEL_11;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0) {
        goto LABEL_17;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
LABEL_11:
        objc_msgSend(v13, "address", v25);
        int v16 = (void *)objc_claimAutoreleasedReturnValue();
        [v16 hostname];
        int v17 = (void *)objc_claimAutoreleasedReturnValue();
        __int16 v18 = v14;
        id v19 = v17;
        __int16 v20 = @"Address";
LABEL_12:
        [v18 setObject:v19 forKeyedSubscript:v20];

LABEL_13:
        goto LABEL_14;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
LABEL_17:
        objc_msgSend(v13, "address", v25);
        int v21 = (void *)objc_claimAutoreleasedReturnValue();
        [v21 hostname];
        __int16 v22 = (void *)objc_claimAutoreleasedReturnValue();
        [v14 setObject:v22 forKeyedSubscript:@"Address"];

        [v13 subnetMaskAddress];
        int v16 = (void *)objc_claimAutoreleasedReturnValue();
        [v16 hostname];
        int v17 = (void *)objc_claimAutoreleasedReturnValue();
        __int16 v18 = v14;
        id v19 = v17;
        __int16 v20 = @"Netmask";
        goto LABEL_12;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0) {
        goto LABEL_11;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0) {
        goto LABEL_11;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        [v13 stringValue];
        int v16 = (void *)objc_claimAutoreleasedReturnValue();
        [v14 setObject:v16 forKeyedSubscript:@"String"];
        goto LABEL_13;
      }

void __NEIPSecIKESetDispatchQueue_block_invoke_155(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  id v7 = a3;
  id v8 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if ([WeakRetained clientCallback])
  {
    id v10 = objc_alloc_init(MEMORY[0x189603FC8]);
    id v47 = v8;
    id v48 = v7;
    int v46 = v10;
    if (v7)
    {
      id v11 = objc_alloc_init(MEMORY[0x189603FA8]);
      __int128 v55 = 0u;
      __int128 v56 = 0u;
      __int128 v57 = 0u;
      __int128 v58 = 0u;
      obuint64_t j = v7;
      uint64_t v12 = [obj countByEnumeratingWithState:&v55 objects:v62 count:16];
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = *(void *)v56;
        do
        {
          for (uint64_t i = 0LL; i != v13; ++i)
          {
            if (*(void *)v56 != v14) {
              objc_enumerationMutation(obj);
            }
            int v16 = *(void **)(*((void *)&v55 + 1) + 8 * i);
            id v17 = objc_alloc_init(MEMORY[0x189603FC8]);
            uint64_t v18 = -[NEIKEv2TrafficSelector type]((uint64_t)v16);
            id v19 = @"IPv4";
            objc_msgSend(v16, "startAddress", v19, v46);
            int v21 = (void *)objc_claimAutoreleasedReturnValue();
            [v21 hostname];
            __int16 v22 = (void *)objc_claimAutoreleasedReturnValue();
            [v17 setObject:v22 forKeyedSubscript:@"TSStartAddress"];

            objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedShort:", objc_msgSend(v16, "startPort"));
            uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
            [v17 setObject:v23 forKeyedSubscript:@"TSStartPort"];

            [v16 endAddress];
            uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
            [v24 hostname];
            uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue();
            [v17 setObject:v25 forKeyedSubscript:@"TSEndAddress"];

            objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedShort:", objc_msgSend(v16, "endPort"));
            id v26 = (void *)objc_claimAutoreleasedReturnValue();
            [v17 setObject:v26 forKeyedSubscript:@"TSEndPort"];

            objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedChar:", objc_msgSend(v16, "ipProtocol"));
            __int128 v27 = (void *)objc_claimAutoreleasedReturnValue();
            [v17 setObject:v27 forKeyedSubscript:@"TSProtocol"];

            [v11 addObject:v17];
          }

          uint64_t v13 = [obj countByEnumeratingWithState:&v55 objects:v62 count:16];
        }

        while (v13);
      }

      id v10 = v46;
      [v46 setObject:v11 forKeyedSubscript:@"TrafficSelectorsLocal"];

      id v8 = v47;
      id v7 = v48;
      a2 = a2;
    }

    if (v8)
    {
      id v28 = objc_alloc_init(MEMORY[0x189603FA8]);
      __int128 v51 = 0u;
      __int128 v52 = 0u;
      __int128 v53 = 0u;
      __int128 v54 = 0u;
      id obja = v8;
      uint64_t v29 = [obja countByEnumeratingWithState:&v51 objects:v61 count:16];
      if (v29)
      {
        uint64_t v30 = v29;
        uint64_t v31 = *(void *)v52;
        do
        {
          for (uint64_t j = 0LL; j != v30; ++j)
          {
            if (*(void *)v52 != v31) {
              objc_enumerationMutation(obja);
            }
            xpc_object_t v33 = *(void **)(*((void *)&v51 + 1) + 8 * j);
            id v34 = objc_alloc_init(MEMORY[0x189603FC8]);
            uint64_t v35 = -[NEIKEv2TrafficSelector type]((uint64_t)v33);
            CFIndex v36 = @"IPv4";
            objc_msgSend(v33, "startAddress", v36, v46);
            CFIndex v38 = (void *)objc_claimAutoreleasedReturnValue();
            [v38 hostname];
            char v39 = (void *)objc_claimAutoreleasedReturnValue();
            [v34 setObject:v39 forKeyedSubscript:@"TSStartAddress"];

            objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedShort:", objc_msgSend(v33, "startPort"));
            uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
            [v34 setObject:v40 forKeyedSubscript:@"TSStartPort"];

            [v33 endAddress];
            char v41 = (void *)objc_claimAutoreleasedReturnValue();
            [v41 hostname];
            uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
            [v34 setObject:v42 forKeyedSubscript:@"TSEndAddress"];

            objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedShort:", objc_msgSend(v33, "endPort"));
            int v43 = (void *)objc_claimAutoreleasedReturnValue();
            [v34 setObject:v43 forKeyedSubscript:@"TSEndPort"];

            objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedChar:", objc_msgSend(v33, "ipProtocol"));
            BOOL v44 = (void *)objc_claimAutoreleasedReturnValue();
            [v34 setObject:v44 forKeyedSubscript:@"TSProtocol"];

            [v28 addObject:v34];
          }

          uint64_t v30 = [obja countByEnumeratingWithState:&v51 objects:v61 count:16];
        }

        while (v30);
      }

      id v10 = v46;
      [v46 setObject:v28 forKeyedSubscript:@"TrafficSelectorsRemote"];

      id v8 = v47;
      id v7 = v48;
      a2 = a2;
    }

    ne_log_obj();
    uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v60 = v10;
      _os_log_debug_impl(&dword_1876B1000, v45, OS_LOG_TYPE_DEBUG, "Updating traffic selectors with %@", buf, 0xCu);
    }

    ((void (*)(id, uint64_t, uint64_t, id, uint64_t))[WeakRetained clientCallback])( WeakRetained,  a2,  4608,  v10,  objc_msgSend(WeakRetained, "clientCallbackInfo"));
  }
}

void __NEIPSecIKESetDispatchQueue_block_invoke_177(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if ([WeakRetained clientCallback])
  {
    ne_log_obj();
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)id v3 = 0;
      _os_log_debug_impl(&dword_1876B1000, v2, OS_LOG_TYPE_DEBUG, "Firing short DPD event", v3, 2u);
    }

    ((void (*)(id, void, uint64_t, void, uint64_t))[WeakRetained clientCallback])( WeakRetained,  0,  5888,  0,  objc_msgSend(WeakRetained, "clientCallbackInfo"));
  }
}

void __NEIPSecIKESetDispatchQueue_block_invoke_179(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if ([WeakRetained clientCallback])
  {
    ne_log_obj();
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_debug_impl(&dword_1876B1000, v5, OS_LOG_TYPE_DEBUG, "Firing redirect event", v9, 2u);
    }

    id v6 = objc_alloc_init(MEMORY[0x189603FC8]);
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      if ([v3 addressFamily] == 2)
      {
        id v7 = @"RedirectedToServerTypeIPAddress";
      }

      else
      {
        if ([v3 addressFamily] != 30)
        {
LABEL_12:
          [v3 hostname];
          id v8 = (void *)objc_claimAutoreleasedReturnValue();
          [v6 setObject:v8 forKeyedSubscript:@"RedirectedToServer"];

          goto LABEL_13;
        }

        id v7 = @"RedirectedToServerTypeIPv6Address";
      }
    }

    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
LABEL_13:
        ((void (*)(id, void, uint64_t, id, uint64_t))[WeakRetained clientCallback])( WeakRetained,  0,  5120,  v6,  objc_msgSend(WeakRetained, "clientCallbackInfo"));

        goto LABEL_14;
      }

      id v7 = @"RedirectToServerTypeFQDN";
    }

    [v6 setObject:v7 forKeyedSubscript:@"RedirectedToServerType"];
    goto LABEL_12;
  }

void __NEIPSecIKESetDispatchQueue_block_invoke_193(uint64_t a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if ([WeakRetained clientCallback])
  {
    ne_log_obj();
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_debug_impl(&dword_1876B1000, v5, OS_LOG_TYPE_DEBUG, "Firing private notify status event", buf, 2u);
    }

    id v6 = objc_alloc_init(MEMORY[0x189603FC8]);
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    id v7 = v3;
    uint64_t v8 = [v7 countByEnumeratingWithState:&v21 objects:v26 count:16];
    if (v8)
    {
      uint64_t v9 = v8;
      id v20 = v3;
      id v19 = WeakRetained;
      id v10 = 0LL;
      unsigned __int8 v11 = 0;
      uint64_t v12 = *(void *)v22;
      do
      {
        uint64_t v13 = v7;
        for (uint64_t i = 0LL; i != v9; ++i)
        {
          if (*(void *)v22 != v12) {
            objc_enumerationMutation(v13);
          }
          int v15 = *(void **)(*((void *)&v21 + 1) + 8 * i);
          if ([v15 notifyStatus] == 51115)
          {
            [v15 notifyData];
            int v16 = (void *)objc_claimAutoreleasedReturnValue();
            [v6 setObject:v16 forKeyedSubscript:@"N1ModeInformation"];
          }

          BOOL v17 = [v15 notifyStatus] == 10500;
          if ([v15 notifyStatus] == 41041)
          {
            uint64_t v18 = [v15 notifyData];

            id v10 = (void *)v18;
          }

          v11 |= v17;
        }

        id v7 = v13;
        uint64_t v9 = [v13 countByEnumeratingWithState:&v21 objects:v26 count:16];
      }

      while (v9);

      id WeakRetained = v19;
      if ((v11 & (v10 != 0LL)) == 1) {
        [v6 setObject:v10 forKeyedSubscript:@"NetworkFailureBackoffTimer"];
      }
      id v3 = v20;
    }

    else
    {

      id v10 = 0LL;
    }

    if ([v6 count]) {
      ((void (*)(id, void, uint64_t, id, uint64_t))[WeakRetained clientCallback])( WeakRetained,  0,  6144,  v6,  objc_msgSend(WeakRetained, "clientCallbackInfo"));
    }
  }
}

void NEIPSecIKESendDeadPeerDetectionPacket(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v9 = a5;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  v11[2] = __NEIPSecIKESendDeadPeerDetectionPacket_block_invoke;
  v11[3] = &unk_18A08F020;
  id v12 = v9;
  id v10 = v9;
  [a1 sendKeepaliveWithRetries:a2 retryIntervalInMilliseconds:a3 callbackQueue:a4 callback:v11];
}

uint64_t __NEIPSecIKESendDeadPeerDetectionPacket_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

uint64_t NEIPSecIKEForceChildSARekey(void *a1, const char *a2)
{
  return [a1 forceRekeyChild:a2];
}

uint64_t NEIPSecIKEStartConnection(void *a1)
{
  id v1 = a1;
  [v1 connect];
  -[NEIKEv2Session firstChildSA](v1, v2);
  id v3 = (unsigned int *)objc_claimAutoreleasedReturnValue();

  if (v3) {
    uint64_t v4 = v3[4];
  }
  else {
    uint64_t v4 = 0LL;
  }

  return v4;
}

uint64_t NEIPSecIKEConnectionIsMobile(void *a1, const char *a2)
{
  if (!a1)
  {
    uint64_t v2 = 0LL;
    goto LABEL_6;
  }

  uint64_t v2 = objc_getProperty(a1, a2, 336LL, 1);
  if (!v2)
  {
LABEL_6:
    uint64_t v3 = 0LL;
    goto LABEL_4;
  }

  uint64_t v3 = v2[11] & 1;
LABEL_4:

  return v3;
}

uint64_t NEIPSecIKEStartMOBIKE(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6, void *a7)
{
  return NEIPSecIKEStartMOBIKEReuseSocket(a1, a2, a3, a4, a5, 0, a6, a7);
}

uint64_t NEIPSecIKEStartMOBIKEReuseSocket( void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, int a6, void *a7, void *a8)
{
  id v15 = a7;
  id v16 = a8;
  if (a1)
  {
    id v17 = a1;
    if (a3)
    {
      [MEMORY[0x189608DF8] endpointWithHostname:a3 port:@"0"];
      a3 = (void *)objc_claimAutoreleasedReturnValue();
    }

    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __NEIPSecIKEStartMOBIKEReuseSocket_block_invoke;
    void v20[3] = &unk_18A08E290;
    id v21 = v16;
    [v17 sendMOBIKEWithRetries:a4 retryInterval:a5 interfaceName:a2 invalidateTransport:a6 == 0 resetEndpoint:a3 callbackQueue:v15 callback:v20];

    uint64_t v18 = 1000LL;
  }

  else
  {
    uint64_t v18 = 3LL;
  }

  return v18;
}

void __NEIPSecIKEStartMOBIKEReuseSocket_block_invoke(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v17 = a2;
  id v7 = a4;
  uint64_t v8 = *(void *)(a1 + 32);
  if (v8)
  {
    if (v7)
    {
      uint64_t v9 = 70001LL;
      id v10 = objc_alloc_init(MEMORY[0x189603FC8]);
      [v7 domain];
      unsigned __int8 v11 = (void *)objc_claimAutoreleasedReturnValue();
      int v12 = [v11 isEqual:@"NEIKEv2ErrorDomain"];

      if (v12)
      {
        uint64_t v13 = [v7 code];
      }

      else
      {
        [v7 domain];
        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
        int v15 = [v14 isEqual:@"NEIKEv2ProtocolErrorDomain"];

        if (v15) {
          uint64_t v9 = [v7 code];
        }
      }

      [MEMORY[0x189607968] numberWithUnsignedInt:v9];
      id v16 = (void *)objc_claimAutoreleasedReturnValue();
      [v10 setObject:v16 forKeyedSubscript:@"NotifyCode"];

      uint64_t v8 = *(void *)(a1 + 32);
    }

    else
    {
      id v10 = 0LL;
    }

    (*(void (**)(uint64_t, id, uint64_t, id))(v8 + 16))(v8, v17, a3, v10);
  }
}

uint64_t NEIPSecIKEStopConnection(void *a1)
{
  return 1LL;
}

uint64_t NEIPSecIKEInvalidateSession(uint64_t result)
{
  if (result)
  {
    id v1 = (void *)result;
    CFTypeID v2 = CFGetTypeID((CFTypeRef)result);
    if (v2 != CFStringGetTypeID()) {
      [v1 invalidate];
    }
    return 1LL;
  }

  return result;
}

uint64_t NEIPSecIKEStartChildSA(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v4 = NEIPSecIKEValidateIKEChildDictionary(a2);
  uint64_t v5 = [v3 addChild:v4];

  return v5;
}

uint64_t NEIPSecIKEStopChildSA(void *a1, uint64_t a2)
{
  return 1LL;
}

uint64_t NEIPSecIKEGetLocalAddress(void *a1, char *a2)
{
  if (a1)
  {
    id Property = objc_getProperty(a1, a2, 336LL, 1);
    uint64_t v5 = Property;
    if (Property) {
      id Property = objc_getProperty(Property, v4, 64LL, 1);
    }
  }

  else
  {
    uint64_t v5 = 0LL;
    id Property = 0LL;
  }

  id v6 = Property;

  id v7 = (unsigned __int8 *)[v6 address];
  if (v7)
  {
    memcpy(a2, v7, *v7);
    uint64_t v8 = 1LL;
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  return v8;
}

uint64_t NEIPSecIKEGetRemoteAddress(void *a1, char *a2)
{
  if (a1)
  {
    id Property = objc_getProperty(a1, a2, 336LL, 1);
    uint64_t v5 = Property;
    if (Property) {
      id Property = objc_getProperty(Property, v4, 72LL, 1);
    }
  }

  else
  {
    uint64_t v5 = 0LL;
    id Property = 0LL;
  }

  id v6 = Property;

  id v7 = (unsigned __int8 *)[v6 address];
  if (v7)
  {
    memcpy(a2, v7, *v7);
    uint64_t v8 = 1LL;
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  return v8;
}

void NEIPSecIKESendPrivateNotifyStatus(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v5 = a1;
    id v6 = -[NEIKEv2PrivateNotify initWithNotifyStatus:notifyData:]( objc_alloc(&OBJC_CLASS___NEIKEv2PrivateNotify),  "initWithNotifyStatus:notifyData:",  a2,  a3);
    id v7 = v6;
    if (v6)
    {
      uint64_t v9 = v6;
      [MEMORY[0x189603F18] arrayWithObjects:&v9 count:1];
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      [v5 sendPrivateNotifies:v8 maxRetries:10 retryIntervalInMilliseconds:1000 callbackQueue:0 callback:0];
    }

    else
    {
      ne_log_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 136315138;
        unsigned __int8 v11 = "NEIPSecIKESendPrivateNotifyStatus";
        _os_log_fault_impl(&dword_1876B1000, v8, OS_LOG_TYPE_FAULT, "%s called with null privateNotify", buf, 0xCu);
      }
    }
  }

  else
  {
    ne_log_obj();
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      unsigned __int8 v11 = "NEIPSecIKESendPrivateNotifyStatus";
      _os_log_fault_impl(&dword_1876B1000, (os_log_t)v5, OS_LOG_TYPE_FAULT, "%s called with null session", buf, 0xCu);
    }
  }
}

void NEIPSecSAKernelSessionReceiveMessage(uint64_t a1, int a2, int a3, uint64_t a4, void *a5)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  id v8 = a5;
  id v10 = v8;
  if (v8)
  {
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    id v11 = objc_getProperty(v8, v9, 24LL, 1);
    uint64_t v12 = [v11 countByEnumeratingWithState:&v33 objects:v48 count:16];
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = *(void *)v34;
      while (2)
      {
        uint64_t v15 = 0LL;
        do
        {
          if (*(void *)v34 != v14) {
            objc_enumerationMutation(v11);
          }
          id v16 = *(_DWORD **)(*((void *)&v33 + 1) + 8 * v15);
          if (v16)
          {
            if (v16[12] == a2)
            {
LABEL_28:
              __int128 v24 = v16;

              ne_log_large_obj();
              uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)__int128 buf = 138413314;
                uint64_t v38 = a1;
                __int16 v39 = 2112;
                uint64_t v40 = v10;
                __int16 v41 = 1024;
                int v42 = a3;
                __int16 v43 = 1024;
                int v44 = a2;
                __int16 v45 = 2112;
                int v46 = v24;
                _os_log_impl( &dword_1876B1000,  v25,  OS_LOG_TYPE_INFO,  "%@ %@ received notification %#x for SAID %u which matches SA %@",  buf,  0x2Cu);
              }

              [v10 delegate];
              id v26 = (void *)objc_claimAutoreleasedReturnValue();
              uint64_t v27 = v26;
              if (v26)
              {
                int v28 = a3 & 0xF00;
                switch(v28)
                {
                  case 2048:
                    [v26 idleTimeoutSA:v24];
                    break;
                  case 1024:
                    [v26 deleteSA:v24];
                    break;
                  case 512:
                    [v26 expireSA:v24];
                    break;
                }

                if ((a3 & 0xF0) == 0x10) {
                  [v27 blackholeDetectedSA:v24];
                }
              }

              goto LABEL_40;
            }
          }

          else if (!a2)
          {
            goto LABEL_14;
          }

          ++v15;
        }

        while (v13 != v15);
        uint64_t v17 = [v11 countByEnumeratingWithState:&v33 objects:v48 count:16];
        uint64_t v13 = v17;
        if (v17) {
          continue;
        }
        break;
      }
    }

void sub_1877D8E18(_Unwind_Exception *a1)
{
}

void sub_1877D8F50(_Unwind_Exception *a1)
{
}

void sub_1877D9024(_Unwind_Exception *a1)
{
}

void sub_1877D90B0(_Unwind_Exception *a1)
{
}

void sub_1877D9134(_Unwind_Exception *a1)
{
}

void sub_1877D9F28(_Unwind_Exception *a1)
{
}

CFDictionaryRef NEKeychainCopyValue( const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  CFTypeRef result = 0LL;
  Query = __NEKeychainCreateQuery(a1, a2, a3, a4);
  id v5 = Query;
  if (Query)
  {
    CFDictionaryAddValue(Query, (const void *)*MEMORY[0x18960BE20], (const void *)*MEMORY[0x189604DE8]);
    OSStatus v6 = SecItemCopyMatching(v5, &result);
    CFRelease(v5);
    CFTypeRef v7 = result;
    if (result)
    {
      if (v6)
      {
        id v5 = 0LL;
      }

      else
      {
        id v5 = (const __CFDictionary *)CFStringCreateFromExternalRepresentation( (CFAllocatorRef)*MEMORY[0x189604DB0],  (CFDataRef)result,  0x8000100u);
        CFTypeRef v7 = result;
      }

      CFRelease(v7);
    }

    else
    {
      return 0LL;
    }
  }

  return v5;
}

__CFDictionary *__NEKeychainCreateQuery( CFStringRef theString, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  if (theString)
  {
    CFIndex Length = (__CFDictionary *)CFStringGetLength(theString);
    if (a2) {
      goto LABEL_3;
    }
  }

  else
  {
    CFIndex Length = 0LL;
    if (a2)
    {
LABEL_3:
      CFIndex v9 = CFStringGetLength(a2);
      if (a3) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }

  CFIndex v9 = 0LL;
  if (a3)
  {
LABEL_4:
    CFIndex v10 = CFStringGetLength(a3);
    if (a4) {
      goto LABEL_5;
    }
LABEL_10:
    CFIndex v11 = 0LL;
    if (!Length) {
      return Length;
    }
    goto LABEL_11;
  }

__CFDictionary *NEKeychainCopyPersistentRef( const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  CFTypeRef result = 0LL;
  Query = __NEKeychainCreateQuery(a1, a2, a3, a4);
  if (Query)
  {
    id v5 = Query;
    CFDictionaryAddValue(Query, (const void *)*MEMORY[0x18960BE28], (const void *)*MEMORY[0x189604DE8]);
    OSStatus v6 = SecItemCopyMatching(v5, &result);
    CFRelease(v5);
    if (v6) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = result == 0LL;
    }
    if (v7) {
      return 0LL;
    }
    else {
      return (__CFDictionary *)result;
    }
  }

  return Query;
}

CFDictionaryRef NEKeychainSetValue( const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, CFStringRef theString)
{
  CFTypeRef result = 0LL;
  if (!theString) {
    return 0LL;
  }
  CFIndex Length = (const __CFDictionary *)CFStringGetLength(theString);
  if (Length)
  {
    CFIndex Length = __NEKeychainCreateQuery(a1, a2, a3, a4);
    if (Length)
    {
      CFIndex v11 = Length;
      uint64_t v12 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      ExternalRepresentatiouint64_t n = CFStringCreateExternalRepresentation( (CFAllocatorRef)*MEMORY[0x189604DB0],  theString,  0x8000100u,  0);
      uint64_t v14 = (const __CFString *)NEKeychainCopyValue(a1, a2, a3, a4);
      if (v14)
      {
        uint64_t v15 = v14;
        if (CFStringCompare(theString, v14, 0LL))
        {
          CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v12, 0LL, 0LL, 0LL);
          CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x18960BE78], ExternalRepresentation);
          SecItemUpdate(v11, Mutable);
          CFRelease(Mutable);
        }

        CFRelease(v11);
        uint64_t v17 = (const __CFDictionary *)v15;
      }

      else
      {
        CFDictionaryAddValue(v11, (const void *)*MEMORY[0x18960B828], (const void *)*MEMORY[0x18960B830]);
        CFDictionaryAddValue(v11, (const void *)*MEMORY[0x18960BE78], ExternalRepresentation);
        if (SecItemAdd(v11, &result)) {
          CFTypeRef result = 0LL;
        }
        uint64_t v17 = v11;
      }

      CFRelease(v17);
      if (ExternalRepresentation) {
        CFRelease(ExternalRepresentation);
      }
      return (const __CFDictionary *)result;
    }
  }

  return Length;
}

void NEKeychainRemoveValue( const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  Query = __NEKeychainCreateQuery(a1, a2, a3, a4);
  if (Query)
  {
    id v5 = Query;
    SecItemDelete(Query);
    CFRelease(v5);
  }

CFDictionaryRef NEKeychainSetPKCS12Container(const __CFData *a1, void *a2)
{
  values = a2;
  if (!a2) {
    return 0LL;
  }
  CFArrayRef items = 0LL;
  CFIndex Count = CFDictionaryCreate( 0LL,  MEMORY[0x18960BBF0],  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Count) {
    return Count;
  }
  uint64_t v4 = Count;
  if (SecPKCS12Import(a1, Count, &items)) {
    return 0LL;
  }
  id v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFMutableArrayRef v7 = CFArrayCreateMutable(v5, 0LL, MEMORY[0x189605228]);
  CFIndex Count = 0LL;
  theArray = v7;
  if (Mutable) {
    BOOL v8 = v7 == 0LL;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    CFIndex Count = (const __CFDictionary *)CFArrayGetCount(items);
    if (Count)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(items, 0LL);
      Value = (__SecCertificate *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x18960BBF8]);
      trust = (__SecTrust *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x18960BC00]);
      CertificateCFIndex Count = SecTrustGetCertificateCount(trust);
      if (CertificateCount >= 1)
      {
        CFIndex v12 = CertificateCount;
        CFIndex v13 = 0LL;
        uint64_t v14 = (const void *)*MEMORY[0x18960BE88];
        uint64_t v15 = (const void *)*MEMORY[0x18960BE28];
        id v16 = (const void *)*MEMORY[0x189604DE8];
        uint64_t v17 = (const void *)*MEMORY[0x18960B828];
        SEL v18 = (const void *)*MEMORY[0x18960B830];
        do
        {
          CFTypeRef result = 0LL;
          SecCertificateRef CertificateAtIndex = Value;
          if (v13) {
            SecCertificateRef CertificateAtIndex = SecTrustGetCertificateAtIndex(trust, v13);
          }
          CFDictionarySetValue(Mutable, v14, CertificateAtIndex);
          CFDictionarySetValue(Mutable, v15, v16);
          CFDictionarySetValue(Mutable, v17, v18);
          OSStatus v20 = SecItemAdd(Mutable, &result);
          if (v20 == -25299)
          {
            CFDictionaryRemoveValue(Mutable, v17);
            OSStatus v20 = SecItemCopyMatching(Mutable, &result);
          }

          if (!v20)
          {
            CFArrayAppendValue(theArray, result);
            CFRelease(result);
          }

          ++v13;
        }

        while (v12 != v13);
      }

      CFRelease(Mutable);
      CFRelease(items);
      CFRelease(v4);
      return theArray;
    }
  }

  return Count;
}

BOOL NEKeychainRemoveWithPersistentID(void *a1)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  id v1 = (void *)*MEMORY[0x18960BE80];
  values = a1;
  keys[0] = v1;
  CFTypeID v2 = CFDictionaryCreate(0LL, (const void **)keys, (const void **)&values, 1LL, 0LL, 0LL);
  if (!v2) {
    return 0LL;
  }
  id v3 = v2;
  BOOL v4 = SecItemDelete(v2) == 0;
  CFRelease(v3);
  return v4;
}

void sub_1877DDE4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, id location)
{
}

void sub_1877E2D28( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_1877E3A50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
}

void sub_1877E5148( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_1877E54E8(_Unwind_Exception *a1)
{
}

void sub_1877E56E8(_Unwind_Exception *a1)
{
}

void sub_1877E585C(_Unwind_Exception *a1)
{
}

void sub_1877E58EC(_Unwind_Exception *a1)
{
}

void sub_1877E597C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_1877E5A10(_Unwind_Exception *a1)
{
}

void sub_1877E5AB4(_Unwind_Exception *a1)
{
}

void sub_1877E5B48(_Unwind_Exception *a1)
{
}

void sub_1877E5BEC(_Unwind_Exception *a1)
{
}

void sub_1877E5C70(_Unwind_Exception *a1)
{
}

void sub_1877E5CFC(_Unwind_Exception *a1)
{
}

void sub_1877E6670(_Unwind_Exception *a1)
{
}

void sub_1877E6D88( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, id location)
{
}

void sub_1877E724C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
}

void sub_1877E7328(_Unwind_Exception *a1)
{
}

void sub_1877E8AA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1877E94AC(_Unwind_Exception *a1)
{
}

void sub_1877E9664(_Unwind_Exception *a1)
{
}

BOOL nw_nexus_flow_add_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (!v2)
  {
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = a2;
    *(void *)(a2 + 32) = a1;
  }

  return v2 == 0;
}

uint64_t nw_nexus_flow_input_available(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 24) + 64LL))();
  }
  return result;
}

uint64_t nw_nexus_flow_output_available(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 24) + 72LL))();
  }
  return result;
}

uint64_t nw_nexus_flow_get_input_frames(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 24) + 80LL))();
  }
  return result;
}

uint64_t nw_nexus_flow_get_output_frames(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 24) + 88LL))();
  }
  return result;
}

uint64_t nw_nexus_flow_finalize_output_frames(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 24) + 96LL))();
  }
  return result;
}

void sub_1877EDD98(_Unwind_Exception *a1)
{
}

void sub_1877EDF40(_Unwind_Exception *a1)
{
}

void sub_1877EE448(_Unwind_Exception *a1)
{
}

void sub_1877EE820(_Unwind_Exception *a1)
{
}

void sub_1877EEB44(_Unwind_Exception *a1)
{
}

void sub_1877EEE28(_Unwind_Exception *a1)
{
}

void sub_1877EEF0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

LABEL_89:
    BOOL v8 = 0;
    CFMutableArrayRef v7 = 1;
  }

  while ((v9 & 1) != 0);
  if (v6 && os_channel_sync())
  {
    ne_log_obj();
    uint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v66 = 138412290;
      uint64_t v67 = v4;
      _os_log_error_impl( &dword_1876B1000,  v49,  OS_LOG_TYPE_ERROR,  "%@: receiveFramesfromRings: failed to sync channel TX",  v66,  0xCu);
    }
  }

  os_unfair_lock_unlock(v5);

  a1 = v53;
LABEL_100:
  uint64_t v50 = *(void *)(a1 + 32);
  if (v50 && (*(_BYTE *)(v50 + 152) & 1) != 0)
  {
    *(_BYTE *)(v50 + 152) = 0;
    nw_queue_resume_source();
    uint64_t v50 = *(void *)(a1 + 32);
  }

  os_unfair_lock_lock((os_unfair_lock_t)(v50 + 8));
  __int128 v51 = *(void *)(a1 + 32);
  if (v51 && *(_BYTE *)(v51 + 153))
  {
    -[NEFilterPacketInterpose close_nolock:](v51, 1);
    __int128 v51 = *(void *)(a1 + 32);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(v51 + 8));
}

void sendDataOnRing(void *a1, uint64_t a2, int a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  BOOL v4 = a1;
  if (!os_channel_get_next_slot())
  {
    if (os_channel_sync())
    {
      ne_log_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        CFIndex v11 = "EGRESS";
        if (!a3) {
          CFIndex v11 = "INGRESS";
        }
        *(_DWORD *)__int128 buf = 138412802;
        uint64_t v15 = v4;
        __int16 v16 = 2080;
        uint64_t v17 = v11;
        __int16 v18 = 2112;
        uint64_t v19 = @"failed to sync channel TX";
        goto LABEL_28;
      }

void sub_1877F2A5C(_Unwind_Exception *a1)
{
}

uint64_t _NE_DNSMessageExtractDomainNameString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (_NE_DNSMessageExtractDomainNameString_onceToken != -1) {
    dispatch_once(&_NE_DNSMessageExtractDomainNameString_onceToken, &__block_literal_global_17419);
  }
  if (_NE_DNSMessageExtractDomainNameString__mdns_DNSMessageExtractDomainNameString) {
    return _NE_DNSMessageExtractDomainNameString__mdns_DNSMessageExtractDomainNameString(a1, a2, a3, a4, a5);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ipsec_check_keylen(int a1, int a2, unsigned int a3)
{
  if (a1 == 14)
  {
    int v3 = 2;
    return ipsec_check_keylen2(v3, a2, a3);
  }

  if (a1 == 15)
  {
    int v3 = 3;
    return ipsec_check_keylen2(v3, a2, a3);
  }

  return 0xFFFFFFFFLL;
}

uint64_t ipsec_check_keylen2(int a1, int a2, unsigned int a3)
{
  uint64_t v4 = findsupportedalg(a1, a2);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = *((unsigned __int16 *)v4 + 1);
  unsigned int v6 = *((unsigned __int16 *)v4 + 2);
  if (v5 > a3 || v6 < a3)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "%d %d %d\n", a3, v5, v6);
    return 0xFFFFFFFFLL;
  }

  return 0LL;
}

unsigned __int8 *findsupportedalg(int a1, int a2)
{
  uint64_t v2 = 0LL;
  while (supported_map[v2] != a1)
  {
    if (++v2 == 3) {
      return 0LL;
    }
  }

  int v3 = (unsigned __int16 *)ipsec_supported[v2];
  if (!v3) {
    return 0LL;
  }
  unsigned int v4 = *v3;
  if (v4 < 0x10) {
    return 0LL;
  }
  uint64_t result = (unsigned __int8 *)(v3 + 4);
  int v6 = v4 + 8;
  while (*result != a2)
  {
    result += 8;
    v6 -= 8;
    if (v6 <= 23) {
      return 0LL;
    }
  }

  return result;
}

uint64_t ipsec_get_keylen(int a1, int a2, void *a3)
{
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  if (a1 == 14)
  {
    int v4 = 2;
  }

  else
  {
    if (a1 != 15) {
      return 0xFFFFFFFFLL;
    }
    int v4 = 3;
  }

  int v6 = findsupportedalg(v4, a2);
  if (v6)
  {
    int v7 = v6;
    uint64_t result = 0LL;
    *a3 = *(void *)v7;
    return result;
  }

  return 0xFFFFFFFFLL;
}

BOOL NEPFKeySendGetSPI( dispatch_source_s *a1, uint64_t a2, uint8_t a3, uint8_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9, int a10, unsigned int a11, int a12, unsigned int a13, uint8_t a14, __int128 a15)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (!a5 || !a6)
  {
    id v26 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      uint64_t v27 = "pfkey get spi, source/destination is NULL";
      int v28 = v26;
      uint32_t v29 = 2;
LABEL_34:
      _os_log_error_impl(&dword_1876B1000, v28, OS_LOG_TYPE_ERROR, v27, buf, v29);
    }

    return 0LL;
  }

  int v17 = *(unsigned __int8 *)(a5 + 1);
  if (v17 != *(unsigned __int8 *)(a6 + 1))
  {
    __int128 v30 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      int v41 = *(unsigned __int8 *)(a5 + 1);
      int v42 = *(unsigned __int8 *)(a6 + 1);
      *(_DWORD *)__int128 buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v41;
      LOWORD(v46) = 1024;
      *(_DWORD *)((char *)&v46 + 2) = v42;
      uint64_t v27 = "pfkey get spi, source IP family(%d) does not match destination IP family(%d)";
      int v28 = v30;
      uint32_t v29 = 14;
      goto LABEL_34;
    }

    return 0LL;
  }

  BOOL v20 = 0LL;
  if (a7 > a8 || a7 - 1 < 0xFF) {
    return v20;
  }
  if (v17 != 2)
  {
    if (v17 == 30)
    {
      char v25 = 0x80;
      goto LABEL_15;
    }

    __int16 v39 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      int v40 = *(unsigned __int8 *)(a5 + 1);
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v40;
      uint64_t v27 = "pfkey get spi, invalid source IP family %d";
      int v28 = v39;
      uint32_t v29 = 8;
      goto LABEL_34;
    }

    return 0LL;
  }

  char v25 = 32;
LABEL_15:
  char v44 = v25;
  BOOL v33 = a7 < 0x100 || a8 == -1;
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (!Mutable) {
    return 0LL;
  }
  __int128 v35 = Mutable;
  BOOL v43 = v33;
  __int128 v36 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1876B1000, v36, OS_LOG_TYPE_INFO, "Sending PFKey get new SPI", buf, 2u);
  }

  v50.locatiouint64_t n = CFDataGetLength(v35);
  *(_DWORD *)__int128 buf = 1245186;
  uint8_t buf[4] = a4;
  LODWORD(v46) = 0;
  HIDWORD(v46) = a9;
  buf[5] = a14;
  *(_WORD *)&buf[6] = 1;
  v50.length = 0LL;
  CFDataReplaceBytes(v35, v50, buf, 16LL);
  v51.locatiouint64_t n = CFDataGetLength(v35);
  v51.length = 5LL;
  NEPFKeySetSADBAddr(v35, v51, (const UInt8 *)a5, v44, 255);
  v52.locatiouint64_t n = CFDataGetLength(v35);
  v52.length = 6LL;
  NEPFKeySetSADBAddr(v35, v52, (const UInt8 *)a6, v44, 255);
  if (a15 != 0)
  {
    v53.locatiouint64_t n = CFDataGetLength(v35);
    v53.length = 22LL;
    NEPFKeySetSADBIPSecIF(v35, v53, 0LL, *((char **)&a15 + 1), (char *)a15, 0);
  }

  if (a10)
  {
    v54.locatiouint64_t n = CFDataGetLength(v35);
    *(void *)__int128 buf = 196612LL;
    unint64_t v46 = 0LL;
    uint64_t v47 = a11;
    uint64_t v48 = 0LL;
    v54.length = 0LL;
    CFDataReplaceBytes(v35, v54, buf, 32LL);
  }

  if (!v43)
  {
    *(_DWORD *)__int128 buf = 1048578;
    *(_DWORD *)&uint8_t buf[4] = a7;
    unint64_t v46 = a8;
    v55.locatiouint64_t n = CFDataGetLength(v35);
    v55.length = 0LL;
    CFDataReplaceBytes(v35, v55, buf, 16LL);
  }

  unsigned __int16 v37 = CFDataGetLength(v35) + 16;
  pid_t v38 = getpid();
  *(_WORD *)__int128 buf = 258;
  buf[2] = 0;
  buf[3] = a3;
  *(_WORD *)&uint8_t buf[4] = v37 >> 3;
  *(_WORD *)&buf[6] = 0;
  unint64_t v46 = __PAIR64__(v38, a13);
  v56.locatiouint64_t n = 0LL;
  v56.length = 0LL;
  CFDataReplaceBytes(v35, v56, buf, 16LL);
  BOOL v20 = NEPFKeySend(a1, a2, v35);
  CFRelease(v35);
  return v20;
}

void NEPFKeySetSADBAddr(__CFData *a1, CFRange a2, const UInt8 *a3, char a4, char a5)
{
  locatiouint64_t n = a2.location;
  *(_WORD *)newBytes = (unsigned __int16)(((*a3 - 1) | 7) + 9) >> 3;
  __int16 length = a2.length;
  char v15 = a5;
  char v16 = a4;
  __int16 v17 = 0;
  a2.__int16 length = 0LL;
  CFDataReplaceBytes(a1, a2, newBytes, 8LL);
  CFIndex v8 = location + 8;
  v18.locatiouint64_t n = v8;
  v18.__int16 length = 0LL;
  CFDataReplaceBytes(a1, v18, a3, *a3);
  int v9 = ((*a3 - 1) | 7) - *a3;
  if (v9 >= 0)
  {
    CFIndex v10 = (const UInt8 *)calloc(1uLL, (v9 + 1));
    if (v10)
    {
      CFIndex v11 = (UInt8 *)v10;
      uint64_t v12 = *a3;
      v19.locatiouint64_t n = v8 + v12;
      v19.__int16 length = 0LL;
      CFDataReplaceBytes(a1, v19, v10, ((v12 - 1) | 7) - v12 + 1);
      free(v11);
    }
  }

void NEPFKeySetSADBIPSecIF( CFMutableDataRef theData, CFRange range, char *__s, char *a4, char *a5, __int16 a6)
{
  locatiouint64_t n = range.location;
  uint64_t v17 = *MEMORY[0x1895F89C0];
  memset(v16, 0, sizeof(v16));
  __int128 v15 = 0u;
  __int128 v14 = 0u;
  __int128 v13 = 0u;
  strcpy((char *)newBytes, "\n");
  __int16 length = range.length;
  if (__s)
  {
    strlen(__s);
    __strncpy_chk();
  }

  if (a4)
  {
    strlen(a4);
    __strncpy_chk();
  }

  if (a5)
  {
    strlen(a5);
    __strncpy_chk();
  }

  LOWORD(v16[6]) = a6;
  v18.locatiouint64_t n = location;
  v18.__int16 length = 0LL;
  CFDataReplaceBytes(theData, v18, newBytes, 80LL);
}

BOOL NEPFKeySend(dispatch_source_s *a1, uint64_t a2, const __CFData *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a1 || !a2 || !a3)
  {
    __int128 v13 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v17.msg_name) = 0;
    int v9 = "pfkey send invalid args";
    CFIndex v10 = (uint8_t *)&v17;
    CFIndex v11 = v13;
    uint32_t v12 = 2;
    goto LABEL_12;
  }

  int handle = dispatch_source_get_handle(a1);
  BytePtr = CFDataGetBytePtr(a3);
  unint64_t Length = CFDataGetLength(a3);
  *(_OWORD *)&v17.msg_control = 0u;
  *(_OWORD *)&v17.msg_name = 0u;
  v17.msg_iov = (iovec *)&BytePtr;
  *(void *)&v17.msg_iovleuint64_t n = 1LL;
  unint64_t v5 = sendmsg(handle, &v17, 0);
  if ((v5 & 0x8000000000000000LL) != 0)
  {
    __int128 v14 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int128 v15 = __error();
    char v16 = strerror(*v15);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v21 = v16;
    int v9 = "PFKey write error: %s";
    CFIndex v10 = buf;
    CFIndex v11 = v14;
    uint32_t v12 = 12;
    goto LABEL_12;
  }

  unint64_t v6 = v5;
  if (v5 < Length)
  {
    int v7 = (os_log_s *)ne_log_obj();
    BOOL result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)__int128 buf = 134218240;
    uint64_t v21 = (char *)v6;
    __int16 v22 = 2048;
    unint64_t v23 = Length;
    int v9 = "PFKey failed to write an entire message (%zd < %zu)";
    CFIndex v10 = buf;
    CFIndex v11 = v7;
    uint32_t v12 = 22;
LABEL_12:
    _os_log_error_impl(&dword_1876B1000, v11, OS_LOG_TYPE_ERROR, v9, v10, v12);
    return 0LL;
  }

  return 1LL;
}

BOOL NEPFKeySendUpdate( dispatch_source_s *a1, uint64_t a2, int a3, char a4, const UInt8 *a5, const UInt8 *a6, unsigned int a7, int a8, unsigned __int8 a9, const UInt8 *a10, char a11, unsigned __int16 a12, char a13, unsigned __int16 a14, int a15, unsigned __int16 a16, int a17, int a18, unsigned int a19, int a20, unsigned int a21, int a22, unsigned int a23, int a24, int a25, unsigned __int16 a26, unsigned __int16 a27, unsigned __int16 a28, __int16 a29, char a30, unint64_t a31)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  __int128 v31 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    unsigned int v42 = bswap32(a7);
    _os_log_impl(&dword_1876B1000, v31, OS_LOG_TYPE_INFO, "Sending PFKey update SPI %04X", buf, 8u);
  }

  return pfkey_send_x1( a1,  a2,  2,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  a10,  a11,  a12,  a13,  a14,  a15,  a16,  a17,  a19,  a21,  a23,  a25,  a26,  a27,  a28,  a29,  a30,  a31);
}

BOOL pfkey_send_x1( dispatch_source_s *a1, uint64_t a2, int a3, int a4, char a5, const UInt8 *a6, const UInt8 *a7, int a8, int a9, unsigned __int8 a10, const UInt8 *a11, char a12, unsigned __int16 a13, char a14, unsigned __int16 a15, int a16, unsigned __int16 a17, int a18, unsigned int a19, unsigned int a20, unsigned int a21, int a22, unsigned __int16 a23, unsigned __int16 a24, unsigned __int16 a25, __int16 a26, char a27, __int128 a28)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  CFDataRef v61 = 0LL;
  if (!a6 || !a7)
  {
    pid_t v38 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      __int16 v39 = "sadb update";
      if (a3 == 3) {
        __int16 v39 = "sadb add";
      }
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)uint64_t v63 = v39;
      int v40 = "pfkey %s, source/destination is NULL";
      int v41 = v38;
      uint32_t v42 = 12;
      goto LABEL_25;
    }

    goto LABEL_26;
  }

  int v31 = a6[1];
  if (v31 != a7[1])
  {
    uint64_t v43 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      char v44 = "sadb update";
      int v45 = a6[1];
      int v46 = a7[1];
      if (a3 == 3) {
        char v44 = "sadb add";
      }
      *(_DWORD *)__int128 buf = 136315650;
      *(void *)uint64_t v63 = v44;
      *(_WORD *)&v63[8] = 1024;
      *(_DWORD *)&v63[10] = v45;
      *(_WORD *)&v63[14] = 1024;
      *(_DWORD *)&v63[16] = v46;
      int v40 = "pfkey %s, source IP family(%d) does not match destination IP family(%d)";
      int v41 = v43;
      uint32_t v42 = 24;
      goto LABEL_25;
    }

void NEPFKeySetSADBKey(__CFData *a1, CFRange a2, const UInt8 *a3, unsigned int a4)
{
  locatiouint64_t n = a2.location;
  int v8 = (a4 - 1) | 7;
  *(_WORD *)newBytes = (unsigned __int16)(((a4 - 1) | 7) + 9) >> 3;
  __int16 length = a2.length;
  __int16 v16 = 8 * a4;
  __int16 v17 = 0;
  a2.__int16 length = 0LL;
  CFDataReplaceBytes(a1, a2, newBytes, 8LL);
  CFIndex v9 = location + 8;
  uint64_t v10 = a4;
  v18.locatiouint64_t n = v9;
  v18.__int16 length = 0LL;
  CFDataReplaceBytes(a1, v18, a3, a4);
  if ((int)(v8 - a4) >= 0)
  {
    size_t v11 = v8 - a4 + 1;
    uint32_t v12 = (const UInt8 *)calloc(1uLL, v11);
    if (v12)
    {
      __int128 v13 = (UInt8 *)v12;
      v19.locatiouint64_t n = v9 + v10;
      v19.__int16 length = 0LL;
      CFDataReplaceBytes(a1, v19, v12, v11);
      free(v13);
    }
  }

BOOL NEPFKeySendAdd( dispatch_source_s *a1, uint64_t a2, int a3, char a4, const UInt8 *a5, const UInt8 *a6, unsigned int a7, int a8, unsigned __int8 a9, const UInt8 *a10, char a11, unsigned __int16 a12, char a13, unsigned __int16 a14, int a15, unsigned __int16 a16, int a17, int a18, unsigned int a19, int a20, unsigned int a21, int a22, unsigned int a23, int a24, int a25, unsigned __int16 a26, unsigned __int16 a27, unsigned __int16 a28, __int16 a29, char a30, __int128 a31)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  int v31 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    unsigned int v42 = bswap32(a7);
    _os_log_impl(&dword_1876B1000, v31, OS_LOG_TYPE_INFO, "Sending PFKey add SPI %04X", buf, 8u);
  }

  return pfkey_send_x1( a1,  a2,  3,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  a10,  a11,  a12,  a13,  a14,  a15,  a16,  a17,  a19,  a21,  a23,  a25,  a26,  a27,  a28,  a29,  a30,  a31);
}

BOOL NEPFKeySendMigrate( dispatch_source_s *a1, uint64_t a2, uint8_t a3, unsigned int a4, pid_t a5, unsigned int a6, __int16 a7, __int16 a8, __int16 a9, uint64_t a10, uint64_t a11, char *a12, uint64_t a13, uint64_t a14, char *a15, char *a16)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  unint64_t v23 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v39 = bswap32(a4);
    _os_log_impl(&dword_1876B1000, v23, OS_LOG_TYPE_INFO, "Sending PFKey migrate SPI %04X", buf, 8u);
  }

  BOOL v24 = 0LL;
  if (a10 && a11 && a13 && a14)
  {
    int v25 = *(unsigned __int8 *)(a10 + 1);
    int v26 = *(unsigned __int8 *)(a13 + 1);
    if (v25 == 2)
    {
      char v27 = 32;
    }

    else
    {
      if (v25 != 30) {
        return 0LL;
      }
      char v27 = 0x80;
    }

    if (v26 == 2)
    {
      char v35 = v27;
      char v28 = 32;
LABEL_19:
      char v36 = v28;
      CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
      BOOL v24 = (BOOL)Mutable;
      if (Mutable)
      {
        *(void *)&__int128 v34 = a16;
        *((void *)&v34 + 1) = a15;
        v47.locatiouint64_t n = CFDataGetLength(Mutable);
        *(_DWORD *)__int128 buf = 65539;
        int v39 = a4;
        int v40 = 0;
        pid_t v41 = a5;
        __int16 v45 = __rev16(a6);
        __int16 v42 = a7;
        __int16 v43 = a8;
        __int16 v44 = a9;
        v47.__int16 length = 0LL;
        CFDataReplaceBytes((CFMutableDataRef)v24, v47, buf, 24LL);
        v48.locatiouint64_t n = CFDataGetLength((CFDataRef)v24);
        v48.__int16 length = 5LL;
        NEPFKeySetSADBAddr((__CFData *)v24, v48, (const UInt8 *)a10, v35, 255);
        v49.locatiouint64_t n = CFDataGetLength((CFDataRef)v24);
        v49.__int16 length = 6LL;
        NEPFKeySetSADBAddr((__CFData *)v24, v49, (const UInt8 *)a11, v35, 255);
        v50.locatiouint64_t n = CFDataGetLength((CFDataRef)v24);
        v50.__int16 length = 27LL;
        NEPFKeySetSADBAddr((__CFData *)v24, v50, (const UInt8 *)a13, v36, 255);
        v51.locatiouint64_t n = CFDataGetLength((CFDataRef)v24);
        v51.__int16 length = 28LL;
        NEPFKeySetSADBAddr((__CFData *)v24, v51, (const UInt8 *)a14, v36, 255);
        int v31 = (const void *)v24;
        if (a12)
        {
          v52.locatiouint64_t n = CFDataGetLength((CFDataRef)v24);
          v52.__int16 length = 22LL;
          NEPFKeySetSADBIPSecIF((CFMutableDataRef)v24, v52, 0LL, 0LL, a12, 0);
        }

        if (v34 != 0)
        {
          v53.locatiouint64_t n = CFDataGetLength((CFDataRef)v24);
          v53.__int16 length = 29LL;
          NEPFKeySetSADBIPSecIF((CFMutableDataRef)v24, v53, 0LL, a16, a15, 0);
        }

        unsigned __int16 v32 = CFDataGetLength((CFDataRef)v24) + 16;
        pid_t v33 = getpid();
        *(_WORD *)__int128 buf = 6658;
        buf[2] = 0;
        buf[3] = a3;
        int v39 = v32 >> 3;
        int v40 = 0;
        pid_t v41 = v33;
        v54.locatiouint64_t n = 0LL;
        v54.__int16 length = 0LL;
        CFDataReplaceBytes((CFMutableDataRef)v24, v54, buf, 16LL);
        BOOL v24 = NEPFKeySend(a1, a2, (const __CFData *)v24);
        CFRelease(v31);
      }

      return v24;
    }

    if (v26 == 30)
    {
      char v35 = v27;
      char v28 = 0x80;
      goto LABEL_19;
    }

    return 0LL;
  }

  return v24;
}

BOOL NEPFKeySendDelete( dispatch_source_s *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, char *a8)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  __int128 v15 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
  {
    v17[0] = 67109120;
    v17[1] = bswap32(a7);
    _os_log_impl(&dword_1876B1000, v15, OS_LOG_TYPE_INFO, "Sending PFKey delete SPI %04X", (uint8_t *)v17, 8u);
  }

  return pfkey_send_x2(a1, a2, 4, a3, a5, a6, a7, a8);
}

BOOL pfkey_send_x2( dispatch_source_s *a1, uint64_t a2, int a3, char a4, uint64_t a5, uint64_t a6, int a7, char *a8)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  if (!a5 || !a6)
  {
    uint64_t v18 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      CFRange v19 = "sadb get";
      if (a3 == 4) {
        CFRange v19 = "sadb delete";
      }
      int v36 = 136315138;
      *(void *)char v37 = v19;
      BOOL v20 = "pfkey %s, source/destination is NULL";
      uint64_t v21 = v18;
      uint32_t v22 = 12;
      goto LABEL_24;
    }

    return 0LL;
  }

  int v11 = *(unsigned __int8 *)(a5 + 1);
  if (v11 != *(unsigned __int8 *)(a6 + 1))
  {
    unint64_t v23 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      BOOL v24 = "sadb get";
      int v25 = *(unsigned __int8 *)(a5 + 1);
      int v26 = *(unsigned __int8 *)(a6 + 1);
      if (a3 == 4) {
        BOOL v24 = "sadb delete";
      }
      int v36 = 136315650;
      *(void *)char v37 = v24;
      *(_WORD *)&v37[8] = 1024;
      *(_DWORD *)&v37[10] = v25;
      *(_WORD *)&v37[14] = 1024;
      *(_DWORD *)&v37[16] = v26;
      BOOL v20 = "pfkey %s, source IP family(%d) does not match destination IP family(%d)";
      uint64_t v21 = v23;
      uint32_t v22 = 24;
      goto LABEL_24;
    }

    return 0LL;
  }

  if (v11 != 2)
  {
    if (v11 == 30)
    {
      char v17 = 0x80;
      goto LABEL_16;
    }

    unsigned __int16 v32 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    pid_t v33 = "sadb get";
    int v34 = *(unsigned __int8 *)(a5 + 1);
    if (a3 == 4) {
      pid_t v33 = "sadb delete";
    }
    int v36 = 136315394;
    *(void *)char v37 = v33;
    *(_WORD *)&v37[8] = 1024;
    *(_DWORD *)&v37[10] = v34;
    BOOL v20 = "pfkey %s, invalid source IP family %d";
    uint64_t v21 = v32;
    uint32_t v22 = 18;
LABEL_24:
    _os_log_error_impl(&dword_1876B1000, v21, OS_LOG_TYPE_ERROR, v20, (uint8_t *)&v36, v22);
    return 0LL;
  }

  char v17 = 32;
LABEL_16:
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (!Mutable) {
    return 0LL;
  }
  char v28 = Mutable;
  v39.locatiouint64_t n = CFDataGetLength(Mutable);
  int v36 = 65539;
  *(_DWORD *)char v37 = a7;
  *(void *)&v37[4] = 0LL;
  *(void *)&v37[12] = 0LL;
  v39.__int16 length = 0LL;
  CFDataReplaceBytes(v28, v39, (const UInt8 *)&v36, 24LL);
  v40.locatiouint64_t n = CFDataGetLength(v28);
  v40.__int16 length = 5LL;
  NEPFKeySetSADBAddr(v28, v40, (const UInt8 *)a5, v17, 255);
  v41.locatiouint64_t n = CFDataGetLength(v28);
  v41.__int16 length = 6LL;
  NEPFKeySetSADBAddr(v28, v41, (const UInt8 *)a6, v17, 255);
  if (a8)
  {
    v42.locatiouint64_t n = CFDataGetLength(v28);
    v42.__int16 length = 22LL;
    NEPFKeySetSADBIPSecIF(v28, v42, 0LL, 0LL, a8, 0);
  }

  unsigned __int16 v29 = CFDataGetLength(v28) + 16;
  pid_t v30 = getpid();
  LOBYTE(v36) = 2;
  *(_WORD *)((char *)&v36 + 1) = a3;
  HIBYTE(v36) = a4;
  *(void *)char v37 = v29 >> 3;
  *(_DWORD *)&v37[8] = v30;
  v43.locatiouint64_t n = 0LL;
  v43.__int16 length = 0LL;
  CFDataReplaceBytes(v28, v43, (const UInt8 *)&v36, 16LL);
  BOOL v31 = NEPFKeySend(a1, a2, v28);
  CFRelease(v28);
  return v31;
}

BOOL NEPFKeySendDeleteAll(dispatch_source_s *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a5 || !a6)
  {
    __int128 v13 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v29) = 0;
      __int128 v14 = "pfkey delete all, source/destination is NULL";
      __int128 v15 = v13;
      uint32_t v16 = 2;
      goto LABEL_18;
    }

    return 0LL;
  }

  int v8 = *(unsigned __int8 *)(a5 + 1);
  if (v8 != *(unsigned __int8 *)(a6 + 1))
  {
    char v17 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      int v18 = *(unsigned __int8 *)(a5 + 1);
      int v19 = *(unsigned __int8 *)(a6 + 1);
      int v29 = 67109376;
      int v30 = v18;
      LOWORD(v31) = 1024;
      *(_DWORD *)((char *)&v31 + 2) = v19;
      __int128 v14 = "pfkey delete all, source IP family(%d) does not match destination IP family(%d)";
      __int128 v15 = v17;
      uint32_t v16 = 14;
      goto LABEL_18;
    }

    return 0LL;
  }

  if (v8 != 2)
  {
    if (v8 == 30)
    {
      char v12 = 0x80;
      goto LABEL_12;
    }

    int v26 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    int v27 = *(unsigned __int8 *)(a5 + 1);
    int v29 = 67109120;
    int v30 = v27;
    __int128 v14 = "pfkey delete all, invalid source IP family %d";
    __int128 v15 = v26;
    uint32_t v16 = 8;
LABEL_18:
    _os_log_error_impl(&dword_1876B1000, v15, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v29, v16);
    return 0LL;
  }

  char v12 = 32;
LABEL_12:
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (!Mutable) {
    return 0LL;
  }
  uint64_t v21 = Mutable;
  uint32_t v22 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
  {
    LOWORD(v29) = 0;
    _os_log_impl(&dword_1876B1000, v22, OS_LOG_TYPE_INFO, "Sending PFKey delete all", (uint8_t *)&v29, 2u);
  }

  v33.locatiouint64_t n = CFDataGetLength(v21);
  v33.__int16 length = 5LL;
  NEPFKeySetSADBAddr(v21, v33, (const UInt8 *)a5, v12, 255);
  v34.locatiouint64_t n = CFDataGetLength(v21);
  v34.__int16 length = 6LL;
  NEPFKeySetSADBAddr(v21, v34, (const UInt8 *)a6, v12, 255);
  unsigned __int16 v23 = CFDataGetLength(v21) + 16;
  pid_t v24 = getpid();
  LOWORD(v29) = 1026;
  BYTE2(v29) = 0;
  HIBYTE(v29) = a3;
  int v30 = v23 >> 3;
  LODWORD(v31) = 0;
  HIDWORD(v31) = v24;
  v35.locatiouint64_t n = 0LL;
  v35.__int16 length = 0LL;
  CFDataReplaceBytes(v21, v35, (const UInt8 *)&v29, 16LL);
  BOOL v25 = NEPFKeySend(a1, a2, v21);
  CFRelease(v21);
  return v25;
}

BOOL NEPFKeySendGet( dispatch_source_s *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, char *a8)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  __int128 v15 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
  {
    v17[0] = 67109120;
    v17[1] = bswap32(a7);
    _os_log_impl(&dword_1876B1000, v15, OS_LOG_TYPE_INFO, "Sending PFKey get for SPI %04X", (uint8_t *)v17, 8u);
  }

  return pfkey_send_x2(a1, a2, 5, a3, a5, a6, a7, a8);
}

BOOL NEPFKeySendRegister(dispatch_source_s *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = 0LL;
  if (a3)
  {
    while (supported_map[v6] != a3)
    {
      if (++v6 == 3) {
        return 0LL;
      }
    }

    CFIndex v9 = (void *)ipsec_supported[v6];
    if (v9)
    {
      free(v9);
      ipsec_supported[v6] = 0LL;
    }
  }

  else
  {
    do
    {
      int v8 = *(void **)((char *)ipsec_supported + v6);
      if (v8)
      {
        free(v8);
        *(uint64_t *)((char *)ipsec_supported + v6) = 0LL;
      }

      v6 += 8LL;
    }

    while (v6 != 24);
  }

  return pfkey_send_x3(a1, a2, 7, a3);
}

BOOL pfkey_send_x3(dispatch_source_s *a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a3 == 11)
  {
    if (a4 >= 2)
    {
      int v8 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        int v17 = 67109120;
        int v18 = a4;
        CFIndex v9 = "pfkey sadb promisc failed, satype %u";
        uint64_t v10 = v8;
        uint32_t v11 = 8;
LABEL_13:
        _os_log_error_impl(&dword_1876B1000, v10, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v17, v11);
        return 0LL;
      }

      return 0LL;
    }
  }

  else if (a4 > 9 || ((1 << a4) & 0x20D) == 0)
  {
    __int128 v15 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      int v17 = 67109376;
      int v18 = a3;
      LOWORD(v19) = 1024;
      *(_DWORD *)((char *)&v19 + 2) = a4;
      CFIndex v9 = "pfkey %d, sa type %u";
      uint64_t v10 = v15;
      uint32_t v11 = 14;
      goto LABEL_13;
    }

    return 0LL;
  }

  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (!Mutable) {
    return 0LL;
  }
  __int128 v13 = Mutable;
  LOBYTE(v17) = 2;
  *(_WORD *)((char *)&v17 + 1) = a3;
  HIBYTE(v17) = a4;
  int v18 = (unsigned __int16)(CFDataGetLength(Mutable) + 16) >> 3;
  LODWORD(v19) = 0;
  HIDWORD(v19) = getpid();
  v21.locatiouint64_t n = 0LL;
  v21.__int16 length = 0LL;
  CFDataReplaceBytes(v13, v21, (const UInt8 *)&v17, 16LL);
  BOOL v14 = NEPFKeySend(a1, a2, v13);
  CFRelease(v13);
  return v14;
}

uint64_t pfkey_recv_register(int a1)
{
  pid_t v2 = getpid();
  while (1)
  {
    int v3 = pfkey_recv(a1);
    if (!v3) {
      return 0xFFFFFFFFLL;
    }
    int v4 = v3;
    if (*((_BYTE *)v3 + 1) == 7 && *((_DWORD *)v3 + 3) == v2) {
      break;
    }
    free(v3);
  }

  unsigned __int16 v6 = 8 * v3[2];
  v3[2] = v6;
  uint64_t v7 = pfkey_set_supported((uint64_t)v3, v6 & 0xFFF8);
  free(v4);
  return v7;
}

unsigned __int16 *pfkey_recv(int a1)
{
  while (1)
  {
    unint64_t v2 = recv(a1, v7, 0x10uLL, 2);
    if ((v2 & 0x8000000000000000LL) == 0) {
      break;
    }
    if (*__error() != 4) {
      return 0LL;
    }
  }

  if (v2 <= 0xF)
  {
    recv(a1, v7, 0x10uLL, 0);
    return 0LL;
  }

  size_t v3 = 8LL * v7[2];
  int v4 = (unsigned __int16 *)calloc(1uLL, v3);
  if (v4)
  {
    while (1)
    {
      ssize_t v5 = recv(a1, v4, v3, 0);
      if ((v5 & 0x8000000000000000LL) == 0) {
        break;
      }
      if (*__error() != 4) {
        goto LABEL_12;
      }
    }

    if (v5 != v3 || v3 != 8LL * v4[2])
    {
LABEL_12:
      free(v4);
      return 0LL;
    }
  }

  return v4;
}

uint64_t pfkey_set_supported(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = a1 + a2;
  size_t v3 = (unsigned __int16 *)(a1 + 16);
  if (a2 >= 0x18)
  {
    do
    {
      uint64_t v5 = *v3;
      int v7 = v3[1];
      if ((v7 & 0xFFFE) != 0xE) {
        return 0xFFFFFFFFLL;
      }
      unsigned __int16 v8 = 8 * v5;
      *size_t v3 = v8;
      if (v7 == 14)
      {
        uint64_t v9 = 0LL;
      }

      else
      {
        if (v7 != 15) {
          return 0xFFFFFFFFLL;
        }
        uint64_t v9 = 1LL;
      }

      uint64_t v10 = (void *)ipsec_supported[v9];
      if (v10)
      {
        free(v10);
        unsigned __int16 v8 = *v3;
      }

      size_t v11 = v8;
      char v12 = malloc(v8);
      ipsec_supported[v9] = (uint64_t)v12;
      if (!v12) {
        return 0xFFFFFFFFLL;
      }
      memcpy(v12, v3, v11);
      size_t v3 = (unsigned __int16 *)((char *)v3 + v11);
    }

    while ((unint64_t)v3 < v2 && v2 >= (unint64_t)(v3 + 4));
  }

  else {
    return 0xFFFFFFFFLL;
  }
}

BOOL NEPFKeySendFlush(dispatch_source_s *a1, uint64_t a2, unsigned int a3)
{
  return pfkey_send_x3(a1, a2, 9, a3);
}

BOOL NEPFKeySendDump(dispatch_source_s *a1, uint64_t a2, unsigned int a3)
{
  return pfkey_send_x3(a1, a2, 10, a3);
}

BOOL NEPFKeySendPromiscToggle(dispatch_source_s *a1, uint64_t a2, int a3)
{
  return pfkey_send_x3(a1, a2, 11, a3 != 0);
}

BOOL NEPFKeySendSPDAdd( dispatch_source_s *a1, uint64_t a2, uint64_t a3, const UInt8 *a4, unsigned int a5, uint64_t a6, const UInt8 *a7, unsigned int a8, char a9, __int16 a10, unsigned __int16 a11, char a12, __int16 a13, char a14, char a15, __int16 a16, const UInt8 *a17, const UInt8 *a18, unsigned int a19, char *a20, char *a21, char *a22, __int16 a23)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  if (!a3 || !a6)
  {
    CFRange v33 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_WORD *)__int128 buf = 0;
    CFRange v34 = "pfkey spd add, source/destination is NULL";
    CFRange v35 = v33;
    uint32_t v36 = 2;
LABEL_27:
    _os_log_error_impl(&dword_1876B1000, v35, OS_LOG_TYPE_ERROR, v34, buf, v36);
    return 0LL;
  }

  int v25 = *(unsigned __int8 *)(a3 + 1);
  if (v25 != *(unsigned __int8 *)(a6 + 1))
  {
    char v37 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    int v38 = *(unsigned __int8 *)(a3 + 1);
    int v39 = *(unsigned __int8 *)(a6 + 1);
    *(_DWORD *)__int128 buf = 67109376;
    LODWORD(v67) = v38;
    WORD2(v67) = 1024;
    *(_DWORD *)((char *)&v67 + 6) = v39;
    CFRange v34 = "pfkey spd add, source IP family(%d) does not match destination IP family(%d)";
    CFRange v35 = v37;
    uint32_t v36 = 14;
    goto LABEL_27;
  }

  if (v25 == 2)
  {
    unsigned int v32 = 32;
    goto LABEL_12;
  }

  if (v25 != 30)
  {
    CFRange v47 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    int v48 = *(unsigned __int8 *)(a3 + 1);
    *(_DWORD *)__int128 buf = 67109120;
    LODWORD(v67) = v48;
    CFRange v34 = "pfkey spd add, invalid source IP family %d";
    CFRange v35 = v47;
    uint32_t v36 = 8;
    goto LABEL_27;
  }

  unsigned int v32 = 128;
LABEL_12:
  if (v32 < a5 || v32 < a8)
  {
    CFRange v49 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 67109632;
      LODWORD(v67) = v32;
      WORD2(v67) = 1024;
      *(_DWORD *)((char *)&v67 + 6) = a5;
      WORD5(v67) = 1024;
      HIDWORD(v67) = a8;
      CFRange v34 = "pfkey spd add, plen %u prefs len %u prefd len %u";
      CFRange v35 = v49;
      uint32_t v36 = 20;
      goto LABEL_27;
    }

    return 0LL;
  }

  else {
    BOOL v40 = a23 == 0;
  }
  int v41 = !v40;
  int v60 = v41;
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (!Mutable) {
    return 0LL;
  }
  CFRange v43 = Mutable;
  v44.locatiouint64_t n = CFDataGetLength(Mutable);
  __int16 v45 = v43;
  if (a4)
  {
    v44.__int16 length = 23LL;
    NEPFKeySetSADBAddr(v43, v44, (const UInt8 *)a3, a5, a9);
    v44.locatiouint64_t n = CFDataGetLength(v43);
    __int16 v45 = v43;
    v44.__int16 length = 24LL;
    uint64_t v46 = a4;
  }

  else
  {
    v44.__int16 length = 5LL;
    uint64_t v46 = (const UInt8 *)a3;
  }

  NEPFKeySetSADBAddr(v45, v44, v46, a5, a9);
  v52.locatiouint64_t n = CFDataGetLength(v43);
  CFRange v53 = v43;
  if (a7)
  {
    v52.__int16 length = 25LL;
    NEPFKeySetSADBAddr(v43, v52, (const UInt8 *)a6, a8, a9);
    v52.locatiouint64_t n = CFDataGetLength(v43);
    CFRange v53 = v43;
    v52.__int16 length = 26LL;
    CFRange v54 = a7;
  }

  else
  {
    v52.__int16 length = 6LL;
    CFRange v54 = (const UInt8 *)a6;
  }

  NEPFKeySetSADBAddr(v53, v52, v54, a8, a9);
  if (v60)
  {
    v71.locatiouint64_t n = CFDataGetLength(v43);
    v71.__int16 length = 22LL;
    NEPFKeySetSADBIPSecIF(v43, v71, a21, a22, a20, a23);
  }

  v72.locatiouint64_t n = CFDataGetLength(v43);
  *(_DWORD *)__int128 buf = 196612;
  __int128 v67 = 0uLL;
  uint64_t v68 = 0LL;
  int v69 = 0;
  v72.__int16 length = 0LL;
  CFDataReplaceBytes(v43, v72, buf, 32LL);
  CFIndex Length = CFDataGetLength(v43);
  int v56 = 0;
  if (a11 == 2)
  {
    int v56 = 8;
    if (a17)
    {
      if (a18) {
        int v56 = *a17 + *a18 + 8;
      }
    }
  }

  DWORD2(v67) = 0;
  *(_WORD *)__int128 buf = (v56 + 16) >> 3;
  *(_WORD *)&buf[2] = 18;
  *(void *)&__int128 v67 = a11;
  BYTE2(v67) = a12;
  v73.locatiouint64_t n = Length;
  v73.__int16 length = 0LL;
  CFDataReplaceBytes(v43, v73, buf, 16LL);
  if (a11 == 2)
  {
    *(_WORD *)newBytes = v56;
    __int16 v62 = a13;
    char v63 = a14;
    char v64 = a15;
    __int16 v65 = a16;
    v74.locatiouint64_t n = Length + 16;
    v74.__int16 length = 0LL;
    CFDataReplaceBytes(v43, v74, newBytes, 8LL);
    if (a17)
    {
      if (a18)
      {
        CFIndex v57 = Length + 24;
        v75.locatiouint64_t n = v57;
        v75.__int16 length = 0LL;
        CFDataReplaceBytes(v43, v75, a17, *a17);
        v76.locatiouint64_t n = v57 + *a17;
        v76.__int16 length = 0LL;
        CFDataReplaceBytes(v43, v76, a18, *a18);
      }
    }
  }

  unsigned __int16 v58 = CFDataGetLength(v43) + 16;
  pid_t v59 = getpid();
  *(_DWORD *)__int128 buf = 3586;
  LODWORD(v67) = v58 >> 3;
  *(void *)((char *)&v67 + 4) = __PAIR64__(v59, a19);
  v77.locatiouint64_t n = 0LL;
  v77.__int16 length = 0LL;
  CFDataReplaceBytes(v43, v77, buf, 16LL);
  BOOL v50 = NEPFKeySend(a1, a2, v43);
  CFRelease(v43);
  return v50;
}

BOOL NEPFKeySendSPDDelete(dispatch_source_s *a1, uint64_t a2, int a3)
{
  return pfkey_send_x5(a1, a2, 0x16u, a3);
}

BOOL pfkey_send_x5(dispatch_source_s *a1, uint64_t a2, UInt8 a3, int a4)
{
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (!Mutable) {
    return 0LL;
  }
  uint64_t v9 = Mutable;
  v14[1] = 0;
  v14[0] = 1179650;
  void v14[2] = a4;
  v14[3] = 0;
  CFDataAppendBytes(Mutable, (const UInt8 *)v14, 16LL);
  unsigned __int16 v10 = CFDataGetLength(v9) + 16;
  pid_t v11 = getpid();
  newBytes[0] = 2;
  newBytes[1] = a3;
  __int16 v16 = 0;
  __int16 v17 = v10 >> 3;
  __int16 v18 = 0;
  int v19 = 0;
  pid_t v20 = v11;
  v21.locatiouint64_t n = 0LL;
  v21.__int16 length = 0LL;
  CFDataReplaceBytes(v9, v21, newBytes, 16LL);
  BOOL v12 = NEPFKeySend(a1, a2, v9);
  CFRelease(v9);
  return v12;
}

BOOL NEPFKeySendSPDEnable(dispatch_source_s *a1, uint64_t a2, int a3)
{
  return pfkey_send_x5(a1, a2, 0x18u, a3);
}

BOOL NEPFKeySendSPDDisable(dispatch_source_s *a1, uint64_t a2, int a3)
{
  return pfkey_send_x5(a1, a2, 0x19u, a3);
}

BOOL NEPFKeySendSPDGet(dispatch_source_s *a1, uint64_t a2, int a3)
{
  return pfkey_send_x5(a1, a2, 0x10u, a3);
}

BOOL NEPFKeySendSPDFlush(dispatch_source_s *a1, uint64_t a2)
{
  return pfkey_send_x3(a1, a2, 19, 0);
}

BOOL NEPFKeySendSPDDump(dispatch_source_s *a1, uint64_t a2)
{
  return pfkey_send_x3(a1, a2, 19, 0);
}

dispatch_source_t NEPFKeyOpen(dispatch_queue_s *a1, void *a2, uint64_t a3, unsigned int a4)
{
  unsigned int PFKeySocket = a4;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  size_t v19 = 8LL;
  uint64_t v18 = 1769472LL;
  if ((a4 & 0x80000000) != 0)
  {
    unsigned int PFKeySocket = NEHelperGetPFKeySocket();
    if ((PFKeySocket & 0x80000000) != 0) {
      return 0LL;
    }
  }

  if (sysctlbyname("kern.ipc.maxsockbuf", v20, &v19, &v18, 8uLL)) {
    int v8 = 233016;
  }
  else {
    int v8 = 1572864;
  }
  int v21 = v8;
  int v17 = 1;
  if (ioctl(PFKeySocket, 0x8004667EuLL, &v17) == -1)
  {
    pid_t v11 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 67109120;
      unsigned int v23 = PFKeySocket;
      _os_log_error_impl( &dword_1876B1000,  v11,  OS_LOG_TYPE_ERROR,  "Failed to set socket %d to non-blocking mode",  buf,  8u);
    }

    return 0LL;
  }

  setsockopt(PFKeySocket, 0xFFFF, 4097, &v21, 4u);
  setsockopt(PFKeySocket, 0xFFFF, 4098, &v21, 4u);
  if (v21 == 1572864) {
    sysctlbyname("kern.ipc.maxsockbuf", 0LL, 0LL, v20, v19);
  }
  dispatch_source_t v9 = dispatch_source_create(MEMORY[0x1895F8B60], PFKeySocket, 0LL, a1);
  dispatch_set_context(v9, a2);
  uint64_t v10 = MEMORY[0x1895F87A8];
  handler[0] = MEMORY[0x1895F87A8];
  handler[1] = 0x40000000LL;
  handler[2] = __NEPFKeyOpen_block_invoke;
  handler[3] = &__block_descriptor_tmp_17492;
  unsigned int v16 = PFKeySocket;
  dispatch_source_set_cancel_handler(v9, handler);
  v13[0] = v10;
  v13[1] = 0x40000000LL;
  v13[2] = __NEPFKeyOpen_block_invoke_2;
  v13[3] = &__block_descriptor_tmp_3;
  unsigned int v14 = PFKeySocket;
  void v13[4] = a2;
  v13[5] = a3;
  dispatch_source_set_event_handler(v9, v13);
  dispatch_resume(v9);
  return v9;
}

uint64_t __NEPFKeyOpen_block_invoke(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

void __NEPFKeyOpen_block_invoke_2(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  v14[0] = v15;
  v14[1] = 0x2000LL;
  *(_OWORD *)&v11.msg_control = 0u;
  *(_OWORD *)&v11.msg_name = 0u;
  v11.msg_iov = (iovec *)v14;
  *(void *)&v11.msg_iovleuint64_t n = 1LL;
  while (1)
  {
    bzero(v15, 0x2000uLL);
    ssize_t v2 = recvmsg(*(_DWORD *)(a1 + 48), &v11, 0);
    ssize_t v3 = v2;
    if (v2 < 1) {
      break;
    }
    if ((unint64_t)v2 <= 0xF)
    {
      int v8 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)__int128 buf = 134217984;
      __int128 v13 = (char *)v3;
      uint64_t v5 = "Invalid PFKey message size: %zu";
LABEL_16:
      unsigned __int16 v6 = v8;
      uint32_t v7 = 12;
LABEL_17:
      _os_log_error_impl(&dword_1876B1000, v6, OS_LOG_TYPE_ERROR, v5, buf, v7);
      return;
    }
  }

  if ((v2 & 0x8000000000000000LL) == 0)
  {
    int v4 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)__int128 buf = 0;
    uint64_t v5 = "PFKey socket received EOF";
    unsigned __int16 v6 = v4;
    uint32_t v7 = 2;
    goto LABEL_17;
  }

  int v9 = *__error();
  if (v9 != 35)
  {
    int v8 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = strerror(v9);
      *(_DWORD *)__int128 buf = 136315138;
      __int128 v13 = v10;
      uint64_t v5 = "PFKey socket received error: %s";
      goto LABEL_16;
    }
  }

uint64_t pfkey_align(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a1 && a2)
  {
    *(void *)(a2 + 232) = 0LL;
    *(_OWORD *)(a2 + 216) = 0u;
    *(_OWORD *)(a2 + 200) = 0u;
    *(_OWORD *)(a2 + 184) = 0u;
    *(_OWORD *)(a2 + 16_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a2 + 152) = 0u;
    *(_OWORD *)(a2 + 136) = 0u;
    *(_OWORD *)(a2 + 120) = 0u;
    *(_OWORD *)(a2 + 104) = 0u;
    *(_OWORD *)(a2 + 8_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + _Block_object_dispose(va, 8) = 0u;
    *(void *)a2 = a1;
    unint64_t v2 = *(unsigned __int16 *)(a1 + 4);
    unint64_t v3 = a1 + 8 * v2;
    int v4 = (unsigned __int16 *)(a1 + 16);
    if (v2 >= 3)
    {
      while (1)
      {
        uint64_t v5 = &v4[4 * *v4];
        if (*v4) {
          BOOL v12 = v3 >= (unint64_t)v5;
        }
        else {
          BOOL v12 = 0;
        }
        if (!v12) {
          goto LABEL_4;
        }
        uint64_t v13 = v4[1];
        if (*(void *)(a2 + 8 * v13))
        {
          uint64_t v16 = (os_log_s *)ne_log_obj();
          if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            return 0xFFFFFFFFLL;
          }
          int v17 = v4[1];
          int v19 = 67109120;
          LODWORD(v20) = v17;
          uint32_t v7 = "duplicate extension type %u";
          goto LABEL_29;
        }

        *(void *)(a2 + 8 * v13) = v4;
        BOOL v15 = (unint64_t)v5 < v3 && v3 >= (unint64_t)(v5 + 2);
        int v4 = v5;
        if (!v15) {
          goto LABEL_5;
        }
      }

      uint64_t v16 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        int v18 = v4[1];
        int v19 = 67109120;
        LODWORD(v20) = v18;
        uint32_t v7 = "bad extension type %u";
LABEL_29:
        int v8 = v16;
        uint32_t v9 = 8;
        goto LABEL_31;
      }

      return 0xFFFFFFFFLL;
    }

uint64_t pfkey_check(unsigned __int8 **a1)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1 || (id v1 = *a1) == 0LL)
  {
    unsigned __int16 v6 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v2_Block_object_dispose(va, 8) = 0;
      uint64_t v5 = "msg/mhp is NULL";
      uint32_t v7 = v6;
      uint32_t v8 = 2;
LABEL_12:
      _os_log_error_impl(&dword_1876B1000, v7, OS_LOG_TYPE_ERROR, v5, (uint8_t *)&v28, v8);
      return 0xFFFFFFFFLL;
    }

    return 0xFFFFFFFFLL;
  }

  if (*v1 != 2)
  {
    unint64_t v3 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v9 = *v1;
      int v28 = 67109120;
      int v29 = v9;
      uint64_t v5 = "invalid sadb version %u";
      goto LABEL_11;
    }

    return 0xFFFFFFFFLL;
  }

  unsigned int v2 = v1[1];
  if (v2 >= 0x1B)
  {
    unint64_t v3 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = v1[1];
      int v28 = 67109120;
      int v29 = v4;
      uint64_t v5 = "invalid message type %u";
LABEL_11:
      uint32_t v7 = v3;
      uint32_t v8 = 8;
      goto LABEL_12;
    }

    return 0xFFFFFFFFLL;
  }

  switch(v1[3])
  {
    case 0u:
      if (v2 - 1 >= 6 && v2 != 8) {
        goto LABEL_30;
      }
      unsigned int v14 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        goto LABEL_21;
      }
      return 0xFFFFFFFFLL;
    case 1u:
      if (v2 == 11) {
        goto LABEL_30;
      }
      goto LABEL_38;
    case 2u:
    case 3u:
    case 9u:
      BOOL v11 = v2 > 0x13;
      int v12 = (1 << v2) & 0xDC000;
      if (!v11 && v12 != 0)
      {
        unsigned int v14 = (os_log_s *)ne_log_obj();
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          return 0xFFFFFFFFLL;
        }
LABEL_21:
        int v15 = v1[3];
        int v16 = v1[1];
        int v28 = 67109376;
        int v29 = v15;
        __int16 v30 = 1024;
        int v31 = v16;
        uint64_t v5 = "invalid sa type %u for message type %u";
LABEL_46:
        uint32_t v7 = v14;
        uint32_t v8 = 14;
        goto LABEL_12;
      }

void NEPFKeyClose(dispatch_source_s *a1)
{
  if (a1)
  {
    dispatch_set_context(a1, 0LL);
    dispatch_source_cancel(a1);
    dispatch_release(a1);
  }

BOOL NEPFKeySendGetStats( dispatch_source_s *a1, uint64_t a2, unsigned int a3, unint64_t *a4, int a5, int a6, const UInt8 *a7, int a8)
{
  BOOL v8 = 0LL;
  if (a4 && a7 && a8)
  {
    CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
    if (Mutable)
    {
      int v18 = Mutable;
      CFIndex Length = CFDataGetLength(Mutable);
      if (a5)
      {
        v20.locatiouint64_t n = Length;
        unint64_t v21 = *a4;
        *(_DWORD *)&newBytes[4] = 0;
        *(_DWORD *)newBytes = 1310723;
        unint64_t v27 = v21;
        unint64_t v28 = 0LL;
        if (a5 != 1) {
          unint64_t v28 = a4[1];
        }
        v20.__int16 length = 0LL;
        CFDataReplaceBytes(v18, v20, newBytes, 24LL);
      }

      CFIndex v22 = CFDataGetLength(v18);
      LODWORD(v27) = 0;
      *(_WORD *)newBytes = (unsigned __int16)(40 * a8 + 16) >> 3;
      *(_WORD *)&UInt8 newBytes[2] = 21;
      *(_DWORD *)&newBytes[4] = a6;
      HIDWORD(v27) = a8;
      v29.locatiouint64_t n = v22;
      v29.__int16 length = 0LL;
      CFDataReplaceBytes(v18, v29, newBytes, 16LL);
      v30.locatiouint64_t n = v22 + 16;
      v30.__int16 length = 0LL;
      CFDataReplaceBytes(v18, v30, a7, 8LL * ((5 * (_WORD)a8) & 0x1FFF));
      unsigned __int16 v23 = CFDataGetLength(v18) + 16;
      pid_t v24 = getpid();
      *(_DWORD *)newBytes = 5890;
      *(_WORD *)&newBytes[4] = v23 >> 3;
      *(_WORD *)&newBytes[6] = 0;
      unint64_t v27 = __PAIR64__(v24, a3);
      v31.locatiouint64_t n = 0LL;
      v31.__int16 length = 0LL;
      CFDataReplaceBytes(v18, v31, newBytes, 16LL);
      BOOL v8 = NEPFKeySend(a1, a2, v18);
      CFRelease(v18);
    }

    else
    {
      return 0LL;
    }
  }

  return v8;
}

CFStringRef NEPolicyGetStringForLegacyNECPLevel(unsigned int a1)
{
  if (a1 > 0xA) {
    return @"Unknown";
  }
  else {
    return kNEPolicySessionNECPLegacyLevelsMapping[a1];
  }
}

NEPolicySession *NEPolicyCreateSession()
{
  return objc_alloc_init(&OBJC_CLASS___NEPolicySession);
}

NEPolicySession *NEPolicyCreateSessionWithSocket(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return -[NEPolicySession initWithSocket:](objc_alloc(&OBJC_CLASS___NEPolicySession), "initWithSocket:", a3);
}

const void **NEPolicySetSessionPriority(void *a1, const void *a2)
{
  uint64_t result = NEMapStringToInteger((const void **)&kNEPolicySessionPrioritiesMapping, a2);
  if ((_DWORD)result)
  {
    int v4 = (int)result;
    uint64_t v5 = result;
    id v6 = a1;
    [v6 setPriority:v5];
    uint64_t v7 = [v6 priority];

    return (const void **)(v7 == v4);
  }

  return result;
}

uint64_t NEPolicySetDropPriorityLevel(CFTypeRef cf1, int a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  int v18 = 0;
  if (cf1)
  {
    int v4 = &kNEPolicySessionNECPPrioritiesMapping;
    uint64_t v5 = @"Unknown";
    while (!CFEqual(cf1, v5))
    {
      id v6 = v4[2];
      v4 += 2;
      uint64_t v5 = v6;
      if (!v6)
      {
        int v18 = 0;
        goto LABEL_7;
      }
    }

    int v18 = *((_DWORD *)v4 + 2);
    if (v18) {
      goto LABEL_8;
    }
LABEL_7:
    if (!CFEqual(cf1, @"Unknown")) {
      return 0LL;
    }
  }

uint64_t NEPolicyPersistDropAllFeature(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  [MEMORY[0x189604030] fileURLWithPath:@"/Library/Preferences/com.apple.networkextension.necp.plist" isDirectory:1];
  int v4 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v5 = (void *)[objc_alloc(MEMORY[0x189603F68]) initWithContentsOfURL:v4];
  id v6 = (void *)[v5 mutableCopy];
  uint64_t v7 = v6;
  if ((_DWORD)a2)
  {
    [MEMORY[0x189607968] numberWithUnsignedChar:a2];
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    [v7 setObject:v8 forKeyedSubscript:a1];
  }

  else
  {
    [v6 removeObjectForKey:a1];
  }

  char v9 = [v7 writeToURL:v4 atomically:1];
  ne_log_obj();
  int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  id v11 = v10;
  if ((v9 & 1) != 0)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      int v14 = 138412290;
      int v15 = v4;
      _os_log_debug_impl( &dword_1876B1000,  v11,  OS_LOG_TYPE_DEBUG,  "Saved drop-all feature to <%@>",  (uint8_t *)&v14,  0xCu);
    }

    uint64_t v12 = 1LL;
  }

  else
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v14 = 138412290;
      int v15 = v4;
      _os_log_error_impl( &dword_1876B1000,  v11,  OS_LOG_TYPE_ERROR,  "Failed to save drop-all feature to <%@>",  (uint8_t *)&v14,  0xCu);
    }

    uint64_t v12 = 0LL;
  }

  return v12;
}

BOOL NEPolicySetLayer2DefaultDrop(int a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  BOOL v7 = a1 != 0;
  int v1 = sysctlbyname("kern.skywalk.netif.default_drop", 0LL, 0LL, &v7, 4uLL);
  if (v1)
  {
    ne_log_obj();
    unsigned int v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      BOOL v4 = v7;
      uint64_t v5 = __error();
      id v6 = strerror(*v5);
      *(_DWORD *)__int128 buf = 136315650;
      char v9 = "kern.skywalk.netif.default_drop";
      __int16 v10 = 1024;
      BOOL v11 = v4;
      __int16 v12 = 2080;
      uint64_t v13 = v6;
      _os_log_error_impl(&dword_1876B1000, v2, OS_LOG_TYPE_ERROR, "Failed to set %s to %d: %s", buf, 0x1Cu);
    }
  }

  return v1 == 0;
}

uint64_t NEPolicyLockSessionToProcess(void *a1)
{
  return [a1 lockSessionToCurrentProcess];
}

uint64_t NEPolicyRegisterService(void *a1, uint64_t a2)
{
  unint64_t v3 = (objc_class *)MEMORY[0x189607AB8];
  id v4 = a1;
  uint64_t v5 = (void *)[[v3 alloc] initWithUUIDBytes:a2];
  uint64_t v6 = [v4 registerServiceUUID:v5];

  return v6;
}

uint64_t NEPolicyUnregisterService(void *a1, uint64_t a2)
{
  unint64_t v3 = (objc_class *)MEMORY[0x189607AB8];
  id v4 = a1;
  uint64_t v5 = (void *)[[v3 alloc] initWithUUIDBytes:a2];
  uint64_t v6 = [v4 unregisterServiceUUID:v5];

  return v6;
}

uint64_t NEPolicyAdd(void *a1, unsigned int a2, const __CFArray *a3, const __CFDictionary *a4)
{
  uint64_t v4 = 0LL;
  if (a1 && a3 && a4)
  {
    BOOL v7 = a1;
    [MEMORY[0x189603FA8] array];
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    Value = CFDictionaryGetValue(a4, @"Result");
    uint64_t v4 = 0LL;
    switch(NEMapStringToInteger((const void **)&kNEPolicyResultsMapping, Value))
    {
      case 1u:
        uint64_t v10 = +[NEPolicyResult pass](&OBJC_CLASS___NEPolicyResult, "pass");
        goto LABEL_56;
      case 2u:
        HIDWORD(valuePtr) = 0;
        BOOL v11 = (const __CFNumber *)CFDictionaryGetValue(a4, @"SkipOrder");
        if (v11)
        {
          CFNumberGetValue(v11, kCFNumberIntType, (char *)&valuePtr + 4);
          uint64_t v12 = HIDWORD(valuePtr);
        }

        else
        {
          uint64_t v12 = 0LL;
        }

        uint64_t v10 = +[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", v12);
        goto LABEL_56;
      case 3u:
        uint64_t v10 = +[NEPolicyResult drop](&OBJC_CLASS___NEPolicyResult, "drop");
        goto LABEL_56;
      case 4u:
        uint64_t v13 = (const __CFNumber *)CFDictionaryGetValue(a4, @"FlowDivertControlUnit");
        if (!v13) {
          goto LABEL_201;
        }
        HIDWORD(valuePtr) = 0;
        uint64_t v10 = +[NEPolicyResult divertSocketToControlUnit:]( &OBJC_CLASS___NEPolicyResult,  "divertSocketToControlUnit:",  HIDWORD(valuePtr));
        goto LABEL_56;
      case 5u:
        uint64_t v14 = CFDictionaryGetValue(a4, @"ScopedInterface");
        if (!v14) {
          goto LABEL_201;
        }
        uint64_t v10 = +[NEPolicyResult scopeSocketToInterfaceName:](&OBJC_CLASS___NEPolicyResult, "scopeSocketToInterfaceName:", v14);
        goto LABEL_56;
      case 6u:
        int v15 = CFDictionaryGetValue(a4, @"TunnelSecondaryResult");
        if (v15)
        {
          uint64_t v16 = v15;
          int v17 = &kNEPolicySecondaryResultsMapping;
          int v18 = @"Pass";
          while (!CFEqual(v16, v18))
          {
            int v19 = v17[2];
            v17 += 2;
            int v18 = v19;
            if (!v19)
            {
              uint64_t v20 = 0LL;
              goto LABEL_54;
            }
          }

          uint64_t v20 = *((unsigned int *)v17 + 2);
        }

        else
        {
          uint64_t v20 = 2LL;
        }

LABEL_202:
        break;
      case 7u:
        __int16 v21 = (const __CFNumber *)CFDictionaryGetValue(a4, @"FilterControlUnit");
        if (!v21) {
          goto LABEL_201;
        }
        HIDWORD(valuePtr) = 0;
        if (CFNumberGetValue(v21, kCFNumberIntType, (char *)&valuePtr + 4))
        {
          uint64_t v10 = +[NEPolicyResult filterWithControlUnit:]( &OBJC_CLASS___NEPolicyResult,  "filterWithControlUnit:",  HIDWORD(valuePtr));
          goto LABEL_56;
        }

uint64_t NEPolicyCopy()
{
  return 0LL;
}

uint64_t NEPolicyDelete(void *a1, unsigned int a2)
{
  return [a1 removePolicyWithID:a2];
}

uint64_t NEPolicyDeleteAll(void *a1)
{
  return [a1 removeAllPolicies];
}

uint64_t NEPolicyCopyIDs()
{
  return 0LL;
}

uint64_t NEPolicyApply(void *a1)
{
  return [a1 apply];
}

uint64_t NEPolicySetDispatchQueue()
{
  return 0LL;
}

void sub_1877FC318( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1877FCC3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1877FF71C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1877FFBA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_187800B48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_187801B98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, id location)
{
}

void sub_187802230( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_187802600( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, id location)
{
}

void sub_187805248( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

LABEL_124:
      __int16 v65 = *(void **)(v52 + 40);
      if (*(void *)(v52 + 32))
      {
        if (v65)
        {
          __int128 v136 = 0LL;
          uint64_t v137 = 0LL;
          [v65 getUUIDBytes:&v136];
          [v56 appendBytes:&v136 length:16];
          [*(id *)(v52 + 32) dataUsingEncoding:1];
          unsigned __int8 v66 = (void *)objc_claimAutoreleasedReturnValue();
          [v56 appendData:v66];
          __int128 v126 = 0;
          CFStringRef v67 = (uint64_t *)&v126;
        }

        else
        {
          [*(id *)(v52 + 32) dataUsingEncoding:1];
          unsigned __int8 v66 = (void *)objc_claimAutoreleasedReturnValue();
          [v56 appendData:v66];
          LOBYTE(v136) = 0;
          CFStringRef v67 = &v136;
        }

        [v56 appendBytes:v67 length:1];
      }

      else if (v65)
      {
        __int128 v136 = 0LL;
        uint64_t v137 = 0LL;
        [v65 getUUIDBytes:&v136];
        [v56 appendBytes:&v136 length:16];
      }

      uint64_t v68 = (uint64_t)v19[452];
      int v69 = v19;
      uint64_t v70 = objc_msgSend(v56, "length", v61);
      CFRange v71 = [v56 bytes];
      CFRange v72 = v70;
      int v19 = v69;
      +[NEPolicySession addTLVToMessage:type:length:value:](v68, v54, 10, v72, v71);

LABEL_132:
      if (v49 != ++v51) {
        continue;
      }
      break;
    }

    CFRange v49 = [v47 countByEnumeratingWithState:&v121 objects:__strerrbuf count:16];
    if (v49) {
      continue;
    }
    break;
  }

LABEL_134:
  BOOL v7 = v112;
  uint64_t v4 = v110;
  pid_t v24 = v115;
  int v22 = v116;
LABEL_139:
  +[NEPolicySession addTLVToMessage:type:length:value:]( (uint64_t)v19[452],  v22,  4,  [v24 length],  objc_msgSend(v24, "bytes"));

  char v119 = 0u;
  char v120 = 0u;
  uint64_t v117 = 0u;
  uint64_t v118 = 0u;
  CFStringRef v73 = v7[3];
  CFStringRef v74 = [v73 countByEnumeratingWithState:&v117 objects:buf count:16];
  if (v74)
  {
    CFRange v75 = v74;
    uint64_t v111 = v17;
    uint64_t v113 = v7;
    CFRange v76 = *(void *)v118;
    while (2)
    {
      for (uint64_t j = 0LL; j != v75; ++j)
      {
        if (*(void *)v118 != v76) {
          objc_enumerationMutation(v73);
        }
        uint64_t v78 = *(void *)(*((void *)&v117 + 1) + 8 * j);
        if (!v78)
        {

          goto LABEL_209;
        }

        uint64_t v79 = (objc_class *)MEMORY[0x189603FB8];
        uint64_t v80 = v22;
        uint64_t v81 = objc_alloc_init(v79);
        uint64_t v82 = v81;
        uint64_t v83 = *(void *)(v78 + 72) - 1LL;
        if (v83 > 0x2A) {
          uint64_t v84 = 0;
        }
        else {
          uint64_t v84 = byte_187872FB8[v83];
        }
        LOBYTE(v121) = v84;
        [v81 appendBytes:&v121 length:1];
        uint64_t v85 = *(_BYTE *)(v78 + 8);
        LOBYTE(v136) = v85;
        if (*(_BYTE *)(v78 + 9)) {
          LOBYTE(v136) = v85 | 2;
        }
        [v82 appendBytes:&v136 length:1];
        switch(*(void *)(v78 + 72))
        {
          case 1LL:
          case 2LL:
            [*(id *)(v78 + 80) getUUIDBytes:__strerrbuf];
            unsigned int v90 = __strerrbuf;
            int v91 = v82;
            uint64_t v92 = 16LL;
            goto LABEL_183;
          case 3LL:
            CFTypeID v96 = *(void *)(v78 + 20);
            goto LABEL_175;
          case 4LL:
          case 0x28LL:
            unsigned int v90 = (char *)(v78 + 28);
            goto LABEL_182;
          case 5LL:
            uint64_t v95 = *(void **)(v78 + 88);
            goto LABEL_180;
          case 6LL:
            uint64_t v95 = *(void **)(v78 + 96);
            goto LABEL_180;
          case 8LL:
            uint64_t v95 = *(void **)(v78 + 112);
            goto LABEL_180;
          case 9LL:
            CFTypeID v96 = *(void *)(v78 + 48);
LABEL_175:
            *(void *)__strerr__int128 buf = v96;
            unsigned int v90 = __strerrbuf;
            int v91 = v82;
            uint64_t v92 = 8LL;
            goto LABEL_183;
          case 0xALL:
          case 0x13LL:
            unsigned int v90 = (char *)(v78 + 12);
            goto LABEL_177;
          case 0xBLL:
          case 0xDLL:
          case 0x14LL:
          case 0x16LL:
            memset(&__strerrbuf[1], 0, 28);
            __strerrbuf[0] = *(_BYTE *)(v78 + 10);
            [*(id *)(v78 + 120) addressData];
            uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue();
            [v86 getBytes:&__strerrbuf[1] length:28];

            uint64_t v87 = [*(id *)(v78 + 120) addressFamily];
            if (v87 == 30)
            {
            }

            else if (v87 == 2 && __strerrbuf[0] >= 0x21u)
            {
              __strerrbuf[0] = 32;
            }

            unsigned int v90 = __strerrbuf;
            int v91 = v82;
            uint64_t v92 = 29LL;
            goto LABEL_183;
          case 0xCLL:
          case 0xELL:
          case 0x15LL:
          case 0x17LL:
            *(void *)&__int128 v135 = 0LL;
            unsigned int v134 = 0u;
            memset(__strerrbuf, 0, sizeof(__strerrbuf));
            [*(id *)(v78 + 120) addressData];
            uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue();
            [v88 getBytes:__strerrbuf length:28];

            [*(id *)(v78 + 128) addressData];
            int v89 = (void *)objc_claimAutoreleasedReturnValue();
            [v89 getBytes:&__strerrbuf[28] length:28];

            unsigned int v90 = __strerrbuf;
            int v91 = v82;
            uint64_t v92 = 56LL;
            goto LABEL_183;
          case 0xFLL:
            uint64_t v95 = *(void **)(v78 + 136);
            if (v95) {
              goto LABEL_180;
            }
            break;
          case 0x10LL:
            unsigned int v134 = 0u;
            __int128 v135 = 0u;
            memset(__strerrbuf, 0, sizeof(__strerrbuf));
            [*(id *)(v78 + 144) getCString:__strerrbuf maxLength:32 encoding:4];
            [*(id *)(v78 + 152) getCString:&v134 maxLength:32 encoding:4];
            unsigned int v90 = __strerrbuf;
            int v91 = v82;
            uint64_t v92 = 64LL;
            goto LABEL_183;
          case 0x12LL:
            unsigned int v90 = (char *)(v78 + 11);
            int v91 = v82;
            uint64_t v92 = 1LL;
            goto LABEL_183;
          case 0x18LL:
            unsigned int v90 = (char *)(v78 + 56);
            goto LABEL_182;
          case 0x1CLL:
            uint64_t v94 = *(_DWORD *)(v78 + 64);
            uint64_t v93 = *(_DWORD *)(v78 + 68);
            *(_DWORD *)__strerr__int128 buf = *(_DWORD *)(v78 + 60);
            *(_DWORD *)&__strerruint8_t buf[4] = v93;
            *(_DWORD *)&__strerruint8_t buf[8] = v94;
            unsigned int v90 = __strerrbuf;
            int v91 = v82;
            uint64_t v92 = 12LL;
            goto LABEL_183;
          case 0x1DLL:
            uint64_t v95 = *(void **)(v78 + 160);
            if (!v95) {
              break;
            }
            goto LABEL_180;
          case 0x1ELL:
            unsigned int v90 = (char *)(v78 + 14);
            goto LABEL_177;
          case 0x25LL:
            unsigned int v90 = (char *)(v78 + 16);
LABEL_177:
            int v91 = v82;
            uint64_t v92 = 2LL;
            goto LABEL_183;
          case 0x26LL:
            unsigned int v90 = (char *)(v78 + 32);
            goto LABEL_182;
          case 0x2ALL:
            uint64_t v95 = *(void **)(v78 + 104);
LABEL_180:
            [v95 dataUsingEncoding:1];
            unsigned __int16 v97 = (void *)objc_claimAutoreleasedReturnValue();
            [v82 appendData:v97];
            __strerrbuf[0] = 0;
            [v82 appendBytes:__strerrbuf length:1];

            break;
          case 0x2BLL:
            [v82 appendBytes:v78 + 36 length:4];
            [v82 appendBytes:v78 + 40 length:4];
            unsigned int v90 = (char *)(v78 + 44);
LABEL_182:
            int v91 = v82;
            uint64_t v92 = 4LL;
LABEL_183:
            [v91 appendBytes:v90 length:v92];
            break;
          default:
            break;
        }

        +[NEPolicySession addTLVToMessage:type:length:value:]( (uint64_t)v19[452],  v80,  3,  [v82 length],  objc_msgSend(v82, "bytes"));

        int v22 = v116;
      }

      CFRange v75 = [v73 countByEnumeratingWithState:&v117 objects:buf count:16];
      if (v75) {
        continue;
      }
      break;
    }

    int v17 = v111;
    BOOL v7 = v113;
  }

  else
  {

    *(_WORD *)__strerr__int128 buf = 0;
    +[NEPolicySession addTLVToMessage:type:length:value:]((uint64_t)v19[452], v22, 3, 2LL, (uint64_t)__strerrbuf);
  }

  [v22 bytes];
  [v22 length];
  LODWORD(v121) = 0;
  if (necp_session_action())
  {
    unsigned __int16 v98 = *__error();
    if (strerror_r(v98, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    ne_log_obj();
    uint32_t v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v99, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 67109378;
      uint64_t v130 = v98;
      CFAllocatorRef v131 = 2080;
      __int128 v132 = __strerrbuf;
      _os_log_fault_impl(&dword_1876B1000, v99, OS_LOG_TYPE_FAULT, "Failed to add policy: [%d] %s", buf, 0x12u);
    }

    ne_log_obj();
    uint64_t v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v107 = [v116 length];
      *(_DWORD *)__strerr__int128 buf = 134217984;
      *(void *)&__strerruint8_t buf[4] = v107;
      _os_log_debug_impl( &dword_1876B1000,  v100,  OS_LOG_TYPE_DEBUG,  "Failed to add policy with tlv message of length %zu",  (uint8_t *)__strerrbuf,  0xCu);
    }

    unint64_t v28 = 0LL;
LABEL_202:
  }

  else
  {
    ne_log_obj();
    uint64_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v108 = [v116 length];
      *(_DWORD *)__strerr__int128 buf = 134217984;
      *(void *)&__strerruint8_t buf[4] = v108;
      _os_log_debug_impl( &dword_1876B1000,  v101,  OS_LOG_TYPE_DEBUG,  "Added policy with tlv message of length %zu",  (uint8_t *)__strerrbuf,  0xCu);
    }

    unint64_t v28 = v121;
    if (v4)
    {
      if (v114) {
        id Property = objc_getProperty(v114, v102, 32LL, 1);
      }
      else {
        id Property = 0LL;
      }
      id v104 = (void *)MEMORY[0x189607968];
      uint64_t v105 = Property;
      [v104 numberWithUnsignedInteger:v28];
      uint64_t v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      [v105 setObject:v7 forKeyedSubscript:v100];

      goto LABEL_202;
    }
  }

          CFIndex v57 = *(_BYTE *)(a1 + 312);
          unsigned __int16 v58 = CFDictionaryCreateMutable(v5, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
          pid_t v59 = v58;
          if ((v57 & 1) != 0)
          {
            if (v58)
            {
              CFDictionarySetValue(v58, (const void *)*MEMORY[0x18960C978], (const void *)*MEMORY[0x18960CB60]);
              unsigned __int8 v61 = (os_log_s *)ne_log_obj();
              if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 136315394;
                *(void *)&uint8_t buf[4] = v88;
                uint64_t v95 = 2112;
                CFTypeID v96 = v59;
                _os_log_impl( &dword_1876B1000,  v61,  OS_LOG_TYPE_DEFAULT,  "%s: setting primary service dictionary to %@",  buf,  0x16u);
              }

              CFDictionarySetValue(Mutable, v90, v59);
              goto LABEL_167;
            }
          }

          else if (v58)
          {
            if ((*(_BYTE *)(a1 + 312) & 8) != 0)
            {
              int v60 = (const void **)MEMORY[0x18960CB78];
            }

            else if ((*(_BYTE *)(a1 + 312) & 4) != 0)
            {
              int v60 = (const void **)MEMORY[0x18960CB70];
            }

            else
            {
              if ((*(_BYTE *)(a1 + 312) & 2) == 0)
              {
LABEL_157:
                __int16 v65 = v11;
                unsigned __int8 v66 = v6;
                CFStringRef v67 = *(_DWORD *)(a1 + 316);
                if (v67) {
                  NEAddIntToDictionary(v59, (const void *)*MEMORY[0x18960C980], v67);
                }
                uint64_t v68 = CFDictionaryGetCount(v59);
                int v69 = (os_log_s *)ne_log_obj();
                uint64_t v70 = os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT);
                if (v68 < 1)
                {
                  uint64_t v6 = v66;
                  if (v70)
                  {
                    *(_DWORD *)__int128 buf = 136315138;
                    *(void *)&uint8_t buf[4] = v88;
                    _os_log_impl( &dword_1876B1000,  v69,  OS_LOG_TYPE_DEFAULT,  "%s: removing service dictionary",  buf,  0xCu);
                  }

                  CFArrayAppendValue(v8, v90);
                }

                else
                {
                  uint64_t v6 = v66;
                  if (v70)
                  {
                    *(_DWORD *)__int128 buf = 136315394;
                    *(void *)&uint8_t buf[4] = v88;
                    uint64_t v95 = 2112;
                    CFTypeID v96 = v59;
                    _os_log_impl( &dword_1876B1000,  v69,  OS_LOG_TYPE_DEFAULT,  "%s: setting non-primary service dictionary to %@",  buf,  0x16u);
                  }

                  CFDictionarySetValue(Mutable, v90, v59);
                }

                BOOL v11 = v65;
LABEL_167:
                CFRelease(v59);
                if (*(void *)(a1 + 472))
                {
                  CFRange v71 = CFDictionaryCreateMutable(v5, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
                  NetworkServiceEntity = v86;
                  if (!v71)
                  {
                    uint64_t v12 = 0LL;
                    goto LABEL_178;
                  }

                  CFRange v72 = v71;
                  NEAddIntToDictionary(v71, (const void *)*MEMORY[0x18960CAB8], 7);
                  CFDictionarySetValue(Mutable, v89, v72);
                  CFRelease(v72);
                }

                else
                {
                  CFArrayAppendValue(v8, v89);
                  NetworkServiceEntity = v86;
                }

                CFStringRef v73 = (os_log_s *)ne_log_large_obj();
                if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)__int128 buf = 136315394;
                  *(void *)&uint8_t buf[4] = v88;
                  uint64_t v95 = 2112;
                  CFTypeID v96 = Mutable;
                  _os_log_debug_impl(&dword_1876B1000, v73, OS_LOG_TYPE_DEBUG, "%s: Setting keys: %@", buf, 0x16u);
                }

                CFStringRef v74 = (os_log_s *)ne_log_large_obj();
                if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)__int128 buf = 136315394;
                  *(void *)&uint8_t buf[4] = v88;
                  uint64_t v95 = 2112;
                  CFTypeID v96 = v8;
                  _os_log_debug_impl(&dword_1876B1000, v74, OS_LOG_TYPE_DEBUG, "%s: Removing keys: %@", buf, 0x16u);
                }

                uint64_t v12 = SCDynamicStoreSetMultiple(*(SCDynamicStoreRef *)(a1 + 496), Mutable, v8, 0LL);
                if ((_DWORD)v12) {
                  *(_BYTE *)(a1 + 312) |= 0x40u;
                }
                goto LABEL_177;
              }

              int v60 = (const void **)MEMORY[0x18960CB68];
            }

            CFDictionarySetValue(v58, (const void *)*MEMORY[0x18960C978], *v60);
            goto LABEL_157;
          }

          uint64_t v12 = 0LL;
          NetworkServiceEntity = v86;
          goto LABEL_178;
        }
      }
    }

    else
    {
      *(void *)__int128 buf = *MEMORY[0x18960C878];
      uint64_t valuePtr = 1;
      values[0] = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
      Copy = CFDictionaryCreate( v5,  (const void **)buf,  (const void **)values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      CFRelease(values[0]);
    }

    BOOL v11 = v45;
    goto LABEL_116;
  }

  CFRange v76 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = "NEVirtualInterfaceUpdateAdHocServiceReturnChanges";
    _os_log_fault_impl(&dword_1876B1000, v76, OS_LOG_TYPE_FAULT, "%s called with null interface", buf, 0xCu);
  }

  return 0LL;
}

LABEL_203:
LABEL_204:
  return v28;
}

LABEL_126:
                    [v46 addObject:v45];
                    CFIndex v29 = v131;
                    [v131 setObject:v46 forKey:&unk_18A0CFA38];

                    BOOL v40 = v41;
                    int v19 = &off_18A087000;
                  }

                  while ([v31 length] > (unint64_t)v41);
                }

                goto LABEL_48;
              case 5:
LABEL_45:
                objc_msgSend(v36, "appendFormat:", @"%u", *(unsigned int *)objc_msgSend(v31, "bytes"), v117);
                break;
            }
          }
        }

        else
        {
          objc_msgSend(v36, "appendFormat:", @"N/A", v116, v117);
        }

        [MEMORY[0x189607968] numberWithUnsignedChar:v35];
        char v37 = (void *)objc_claimAutoreleasedReturnValue();
        [v29 setObject:v36 forKey:v37];

LABEL_48:
        CFIndex v30 = (v32 + v130 + 5);

        uint64_t v32 = v30;
      }
    }

    CFIndex v31 = 0LL;
LABEL_197:
    if ([v29 count])
    {
      *(_DWORD *)&__strerruint8_t buf[16] = 20;
      *(_OWORD *)__strerr__int128 buf = xmmword_187872F8C;
      CFTypeID v96 = [v29 objectForKey:&unk_18A0CFA50];
      unsigned __int16 v97 = v29;
      unsigned __int16 v98 = v126;
      objc_msgSend( v126,  "appendToStringAtColumnWithContent:column:content:appendAsNewLine:addNewLine:",  __strerrbuf,  0,  objc_msgSend(v96, "UTF8String"),  0,  0);

      uint32_t v99 = [v97 objectForKey:&unk_18A0CFA68];
      objc_msgSend( v126,  "appendToStringAtColumnWithContent:column:content:appendAsNewLine:addNewLine:",  __strerrbuf,  1,  objc_msgSend(v99, "UTF8String"),  0,  0);

      uint64_t v100 = [v97 objectForKey:&unk_18A0CFA80];
      objc_msgSend( v126,  "appendToStringAtColumnWithContent:column:content:appendAsNewLine:addNewLine:",  __strerrbuf,  2,  objc_msgSend(v100, "UTF8String"),  0,  0);

      [v97 objectForKey:&unk_18A0CFA38];
      uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue();
      if (v101 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0) && (uint32_t v102 = [v101 count]) != 0)
      {
        CFStringRef v103 = v102;
        id v104 = 0LL;
        uint64_t v105 = v102 - 1;
        do
        {
          uint64_t v106 = [v101 objectAtIndex:v104];
          objc_msgSend( v126,  "appendToStringAtColumnWithContent:column:content:appendAsNewLine:addNewLine:",  __strerrbuf,  3,  objc_msgSend(v106, "UTF8String"),  v104 != 0,  v105 != v104);

          ++v104;
        }

        while (v103 != v104);
      }

      else
      {
        [v126 appendToStringAtColumnWithContent:__strerrbuf column:3 content:"--" appendAsNewLine:0 addNewLine:0];
      }

      uint64_t v107 = v131;
      uint64_t v108 = [v131 objectForKey:&unk_18A0CFA98];
      objc_msgSend( v126,  "appendToStringAtColumnWithContent:column:content:appendAsNewLine:addNewLine:",  __strerrbuf,  4,  objc_msgSend(v108, "UTF8String"),  0,  1);

      __int128 v109 = (__CFString *)v126;
    }

    else
    {
      [NSString stringWithFormat:@"NO DATA"];
      __int128 v109 = (__CFString *)objc_claimAutoreleasedReturnValue();
      uint64_t v107 = v29;
      unsigned __int16 v98 = v126;
    }

    pid_t v24 = &v129[v127 + 5];
    int v22 = v128 + 1;

    if (v109) {
      char v110 = v109;
    }
    else {
      char v110 = @"nil";
    }
    [v125 appendString:v110];
  }

  char v115 = *v24;
  ne_log_obj();
  uint64_t v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (!os_log_type_enabled(v111, OS_LOG_TYPE_INFO)) {
    goto LABEL_216;
  }
  *(_DWORD *)__strerr__int128 buf = 134218496;
  *(void *)&__strerruint8_t buf[4] = &v24[-v124];
  *(_WORD *)&__strerrbuf[12] = 1024;
  *(_DWORD *)&__strerrbuf[14] = v115;
  *(_WORD *)&__strerrbuf[18] = 1024;
  *(_DWORD *)&__strerrbuf[20] = v25;
  int v112 = "TLV buffer truncated: cursor - start: %zu, type: %d, length: %u";
  uint64_t v113 = v111;
  uint64_t v114 = 24;
LABEL_215:
  _os_log_impl(&dword_1876B1000, v113, OS_LOG_TYPE_INFO, v112, __strerrbuf, v114);
LABEL_216:

LABEL_217:
  uint64_t v13 = v119;
  [v119 appendString:v125];

  return v13;
}

      goto LABEL_127;
    }
  }

LABEL_3:
  uint64_t v6 = *__error();
  if (strerror_r(v6, __strerrbuf, 0x80uLL)) {
    __strerrbuf[0] = 0;
  }
  ne_log_obj();
  BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 67109634;
    int v15 = v13;
    uint64_t v16 = 1024;
    int v17 = v6;
    int v18 = 2080;
    int v19 = __strerrbuf;
    _os_log_fault_impl(&dword_1876B1000, v7, OS_LOG_TYPE_FAULT, "Failed to delete policy %u: [%d] %s", buf, 0x18u);
  }

  return 0;
}

  uint64_t v4 = *__error();
  if (strerror_r(v4, __strerrbuf, 0x80uLL)) {
    __strerrbuf[0] = 0;
  }
  ne_log_obj();
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
  {
    v8[0] = 67109378;
    v8[1] = v4;
    char v9 = 2080;
    uint64_t v10 = __strerrbuf;
    _os_log_fault_impl( &dword_1876B1000,  v5,  OS_LOG_TYPE_FAULT,  "Failed to delete all policies: [%d] %s",  (uint8_t *)v8,  0x12u);
  }

  return 0;
}

LABEL_69:
  _Block_object_dispose(&v158, 8);
}

  (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
}

void sub_18780AACC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

LABEL_112:
      -[NEProfileIngestion ingestedConfiguration](self, "ingestedConfiguration");
      __int128 v109 = (void *)objc_claimAutoreleasedReturnValue();
      BOOL v40 = v109 != 0LL;

      ne_log_obj();
      char v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
      {
        int v112 = (void *)objc_opt_class();
        uint64_t v113 = "no";
        if (v109) {
          uint64_t v113 = "yes";
        }
        *(_DWORD *)__int128 buf = 138412546;
        v157 = v112;
        __int16 v158 = 2080;
        uint64_t v159 = v113;
        uint64_t v114 = v112;
        _os_log_debug_impl( &dword_1876B1000,  v110,  OS_LOG_TYPE_DEBUG,  "%@ createConfigurationFromPayload: configuration created (%s)",  buf,  0x16u);
      }

LABEL_114:
      uint64_t v6 = v127;
      goto LABEL_115;
    }

    if ([v7 isEqualToString:@"com.apple.webcontent-filter"])
    {
      char v123 = v15;
      __int128 v126 = v10;
      char v120 = v8;
      CFIndex v56 = objc_alloc_init(MEMORY[0x189603FA8]);
      -[NEProfileIngestion currentConfigurations](self, "currentConfigurations");
      CFIndex v57 = (void *)objc_claimAutoreleasedReturnValue();

      if (v57)
      {
        unsigned __int16 v58 = self;
        pid_t v59 = v7;
        __int128 v143 = 0u;
        __int128 v144 = 0u;
        __int128 v141 = 0u;
        __int128 v142 = 0u;
        -[NEProfileIngestion currentConfigurations](v58, "currentConfigurations");
        int v60 = (void *)objc_claimAutoreleasedReturnValue();
        unsigned __int8 v61 = [v60 countByEnumeratingWithState:&v141 objects:v154 count:16];
        if (v61)
        {
          __int16 v62 = v61;
          char v63 = *(void *)v142;
          do
          {
            for (uint64_t j = 0LL; j != v62; ++j)
            {
              if (*(void *)v142 != v63) {
                objc_enumerationMutation(v60);
              }
              __int16 v65 = *(void **)(*((void *)&v141 + 1) + 8 * j);
              [v65 contentFilter];
              unsigned __int8 v66 = (void *)objc_claimAutoreleasedReturnValue();

              if (v66)
              {
                [v65 payloadInfo];
                CFStringRef v67 = (void *)objc_claimAutoreleasedReturnValue();

                if (!v67) {
                  [v56 addObject:v65];
                }
              }
            }

            __int16 v62 = [v60 countByEnumeratingWithState:&v141 objects:v154 count:16];
          }

          while (v62);
        }

        BOOL v7 = v59;
        self = v128;
      }

      uint64_t v68 = -[NEConfiguration initWithContentFilterPayload:configurationName:grade:]( objc_alloc(&OBJC_CLASS___NEConfiguration),  v6,  v9,  1LL);
      -[NEProfileIngestion setIngestedConfiguration:](self, "setIngestedConfiguration:", v68);

      -[NEProfileIngestion ingestedConfiguration](self, "ingestedConfiguration");
      int v69 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v69)
      {
        uint64_t v10 = v126;
        CFRange v55 = (os_log_s *)v56;
        uint64_t v8 = v120;
        int v15 = v123;
        goto LABEL_112;
      }

      uint64_t v118 = v7;
      -[NEProfileIngestion ingestedConfiguration](self, "ingestedConfiguration");
      uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue();
      [v70 setName:v9];

      uint64_t v139 = 0u;
      __int128 v140 = 0u;
      uint64_t v137 = 0u;
      __int128 v138 = 0u;
      CFRange v71 = v56;
      CFRange v72 = [v71 countByEnumeratingWithState:&v137 objects:v153 count:16];
      if (v72)
      {
        CFStringRef v73 = v72;
        CFStringRef v74 = *(void *)v138;
        do
        {
          for (uint64_t k = 0LL; k != v73; ++k)
          {
            if (*(void *)v138 != v74) {
              objc_enumerationMutation(v71);
            }
            CFRange v76 = *(void **)(*((void *)&v137 + 1) + 8 * k);
            ne_log_obj();
            CFRange v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v78 = (void *)objc_opt_class();
              uint64_t v79 = v78;
              [v76 identifier];
              uint64_t v80 = (char *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)__int128 buf = 138412546;
              v157 = v78;
              __int16 v158 = 2112;
              uint64_t v159 = v80;
              _os_log_impl( &dword_1876B1000,  v77,  OS_LOG_TYPE_DEFAULT,  "%@ createConfigurationFromPayload: Removing overridden content filter configuration %@.",  buf,  0x16u);

              self = v128;
            }

            -[NEProfileIngestion removeConfiguration:](self, "removeConfiguration:", v76);
          }

          CFStringRef v73 = [v71 countByEnumeratingWithState:&v137 objects:v153 count:16];
        }

        while (v73);
      }

      CFRange v55 = (os_log_s *)v71;
    }

    else
    {
      if ([v7 isEqualToString:@"com.apple.networkusagerules"])
      {
        CFRange v54 = (os_log_s *)-[NEConfiguration initWithPathControllerPayload:configurationName:grade:]( objc_alloc(&OBJC_CLASS___NEConfiguration),  v6,  v9,  1LL);
LABEL_52:
        CFRange v55 = v54;
        -[NEProfileIngestion setIngestedConfiguration:](self, "setIngestedConfiguration:", v54);
        goto LABEL_112;
      }

      if (![v7 isEqualToString:@"com.apple.dnsProxy.managed"])
      {
        if ([v7 isEqualToString:@"com.apple.dnsSettings.managed"])
        {
          CFRange v54 = (os_log_s *)-[NEConfiguration initWithDNSSettingsPayload:configurationName:grade:]( objc_alloc(&OBJC_CLASS___NEConfiguration),  v6,  v9,  2LL);
        }

        else
        {
          if (![v7 isEqualToString:@"com.apple.relay.managed"])
          {
            ne_log_obj();
            uint64_t v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 138412290;
              v157 = v7;
              _os_log_error_impl( &dword_1876B1000,  v117,  OS_LOG_TYPE_ERROR,  "NEProfileIngestion createConfigurationFromPayload: unsupported payload type '%@'",  buf,  0xCu);
            }

            BOOL v40 = 0;
            goto LABEL_115;
          }

          CFRange v54 = (os_log_s *)-[NEConfiguration initWithRelayPayload:configurationName:grade:]( objc_alloc(&OBJC_CLASS___NEConfiguration),  v6,  v9,  1LL);
        }

        goto LABEL_52;
      }

      char v123 = v15;
      __int128 v126 = v10;
      char v120 = v8;
      uint64_t v84 = v6;
      CFRange v55 = (os_log_s *)objc_alloc_init(MEMORY[0x189603FA8]);
      -[NEProfileIngestion currentConfigurations](self, "currentConfigurations");
      uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue();

      uint64_t v118 = v7;
      if (v85)
      {
        uint64_t v86 = self;
        uint64_t v87 = v84;
        __int128 v135 = 0u;
        __int128 v136 = 0u;
        __int128 v133 = 0u;
        unsigned int v134 = 0u;
        -[NEProfileIngestion currentConfigurations](v86, "currentConfigurations");
        uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue();
        int v89 = [v88 countByEnumeratingWithState:&v133 objects:v152 count:16];
        if (v89)
        {
          unsigned int v90 = v89;
          int v91 = *(void *)v134;
          do
          {
            for (uint64_t m = 0LL; m != v90; ++m)
            {
              if (*(void *)v134 != v91) {
                objc_enumerationMutation(v88);
              }
              uint64_t v93 = *(void **)(*((void *)&v133 + 1) + 8 * m);
              uint64_t v94 = [v93 dnsProxy];
              if (v94)
              {
                uint64_t v95 = (void *)v94;
                [v93 payloadInfo];
                CFTypeID v96 = (void *)objc_claimAutoreleasedReturnValue();

                if (!v96) {
                  -[os_log_s addObject:](v55, "addObject:", v93);
                }
              }
            }

            unsigned int v90 = [v88 countByEnumeratingWithState:&v133 objects:v152 count:16];
          }

          while (v90);
        }

        uint64_t v84 = v87;
        BOOL v7 = v118;
        self = v128;
      }

      unsigned __int16 v97 = -[NEConfiguration initWithDNSProxyPayload:configurationName:grade:]( objc_alloc(&OBJC_CLASS___NEConfiguration),  v84,  v9);
      -[NEProfileIngestion setIngestedConfiguration:](self, "setIngestedConfiguration:", v97);

      -[NEProfileIngestion ingestedConfiguration](self, "ingestedConfiguration");
      unsigned __int16 v98 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v98) {
        goto LABEL_81;
      }
      -[NEProfileIngestion ingestedConfiguration](self, "ingestedConfiguration");
      uint32_t v99 = (void *)objc_claimAutoreleasedReturnValue();
      [v99 setName:v9];

      CFAllocatorRef v131 = 0u;
      __int128 v132 = 0u;
      uint64_t v129 = 0u;
      uint64_t v130 = 0u;
      CFRange v55 = v55;
      uint64_t v100 = -[os_log_s countByEnumeratingWithState:objects:count:]( v55,  "countByEnumeratingWithState:objects:count:",  &v129,  v151,  16LL);
      if (v100)
      {
        uint64_t v101 = v100;
        uint32_t v102 = *(void *)v130;
        do
        {
          for (uint64_t n = 0LL; n != v101; ++n)
          {
            if (*(void *)v130 != v102) {
              objc_enumerationMutation(v55);
            }
            id v104 = *(void **)(*((void *)&v129 + 1) + 8 * n);
            ne_log_obj();
            uint64_t v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v105, OS_LOG_TYPE_INFO))
            {
              uint64_t v106 = (void *)objc_opt_class();
              uint64_t v107 = v106;
              [v104 identifier];
              uint64_t v108 = (char *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)__int128 buf = 138412546;
              v157 = v106;
              __int16 v158 = 2112;
              uint64_t v159 = v108;
              _os_log_impl( &dword_1876B1000,  v105,  OS_LOG_TYPE_INFO,  "%@ createConfigurationFromPayload: Removing overridden DNS proxy configuration %@.",  buf,  0x16u);

              self = v128;
            }

            -[NEProfileIngestion removeConfiguration:](self, "removeConfiguration:", v104);
          }

          uint64_t v101 = -[os_log_s countByEnumeratingWithState:objects:count:]( v55,  "countByEnumeratingWithState:objects:count:",  &v129,  v151,  16LL);
        }

        while (v101);
      }
    }

    BOOL v7 = v118;
LABEL_81:
    uint64_t v8 = v120;
    int v15 = v123;
    uint64_t v10 = v126;
    goto LABEL_112;
  }

  BOOL v40 = 0;
LABEL_116:

  return v40;
}

void sub_18780CC10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_18780F6A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__18969(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__18970(uint64_t a1)
{
}

__CFString *convert_error_to_string(void *a1)
{
  id v1 = a1;
  [v1 domain];
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue();
  int v3 = [v2 isEqualToString:@"NEConfigurationErrorDomain"];

  if (v3)
  {
    uint64_t v4 = @"configuration is corrupted";
    switch([v1 code])
    {
      case 1LL:
        break;
      case 2LL:
        uint64_t v5 = (void *)NSString;
        [v1 localizedDescription];
        uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
        [v5 stringWithFormat:@"configuration is invalid: %@", v6];
        uint64_t v4 = (__CFString *)objc_claimAutoreleasedReturnValue();

        break;
      case 3LL:
        uint64_t v4 = @"configuration type is wrong";
        break;
      case 4LL:
        uint64_t v4 = @"configuration owner application is wrong";
        break;
      case 5LL:
        uint64_t v4 = @"configuration is stale";
        break;
      case 6LL:
        uint64_t v4 = @"failed to write configuration to disk";
        break;
      case 7LL:
        uint64_t v4 = @"configuration does not exist";
        break;
      case 8LL:
        uint64_t v4 = @"invalid configuration operation request";
        break;
      case 9LL:
        uint64_t v4 = @"configuration is unchanged";
        break;
      case 10LL:
        uint64_t v4 = @"permission denied";
        break;
      case 11LL:
        uint64_t v4 = @"IPC failed";
        break;
      case 18LL:
        uint64_t v4 = @"file not found";
        break;
      case 21LL:
        uint64_t v4 = @"MDM required";
        break;
      default:
        uint64_t v4 = @"<unknown>";
        break;
    }
  }

  else
  {
    [v1 localizedDescription];
    uint64_t v4 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }

  return v4;
}

LABEL_136:
  return v6;
}

void sub_187815A3C(_Unwind_Exception *a1)
{
}

void sub_187816EA0(_Unwind_Exception *a1)
{
}

void sub_187818654(_Unwind_Exception *a1)
{
}

uint64_t __Block_byref_object_copy__19891(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__19892(uint64_t a1)
{
}

void sub_18781C9F0(_Unwind_Exception *a1)
{
}

void sub_18781CAAC(_Unwind_Exception *a1)
{
}

void NEResourcesSetPreferredLanguages(void *a1)
{
  id v1 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&languageLock);
  uint64_t v2 = (void *)g_preferredLanguages;
  g_preferredLanguages = (uint64_t)v1;

  os_unfair_lock_unlock((os_unfair_lock_t)&languageLock);
}

id NEResourcesCopyPreferredLanguages()
{
  dispatch_queue_t v0 = (void *)[(id)g_preferredLanguages copy];
  os_unfair_lock_unlock((os_unfair_lock_t)&languageLock);
  return v0;
}

id NEResourcesCopyDevicePreferredLocalizations()
{
  dispatch_queue_t v0 = (void *)objc_claimAutoreleasedReturnValue();
  if (v0)
  {
    get_nsbundle();
    id v1 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v2 = (void *)MEMORY[0x1896077F8];
    [v1 localizations];
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
    [v2 preferredLocalizationsFromArray:v3 forPreferences:v0];
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  return v4;
}

id get_nsbundle()
{
  if (get_nsbundle_onceToken != -1) {
    dispatch_once(&get_nsbundle_onceToken, &__block_literal_global_20396);
  }
  return (id)get_nsbundle_bundle;
}

void __get_nsbundle_block_invoke()
{
  uint64_t v0 = [objc_alloc(MEMORY[0x1896077F8]) initWithPath:@"/System/Library/Frameworks/NetworkExtension.framework"];
  id v1 = (void *)get_nsbundle_bundle;
  get_nsbundle_bundle = v0;
}

CFTypeRef NEResourcesCopyTrustedApplicationPaths()
{
  if (get_bundle_initialized != -1) {
    dispatch_once(&get_bundle_initialized, &__block_literal_global_20_20399);
  }
  CFTypeRef result = CFBundleGetValueForInfoDictionaryKey((CFBundleRef)get_bundle_bundle, @"TrustedExecutables");
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void __get_bundle_block_invoke()
{
  uint64_t v0 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  id v1 = CFURLCreateFromFileSystemRepresentation( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const UInt8 *)"/System/Library/Frameworks/NetworkExtension.framework",  53LL,  0);
  get_bundle_bundle = (uint64_t)CFBundleCreate(v0, v1);
  CFRelease(v1);
}

CFURLRef NEResourcesCopyVPNIconURL()
{
  if (get_bundle_initialized != -1) {
    dispatch_once(&get_bundle_initialized, &__block_literal_global_20_20399);
  }
  return CFBundleCopyResourceURL((CFBundleRef)get_bundle_bundle, @"NetworkConnect.icns", 0LL, 0LL);
}

CFURLRef NEResourcesCopyNetworkPrivacyIconURL()
{
  if (get_bundle_initialized != -1) {
    dispatch_once(&get_bundle_initialized, &__block_literal_global_20_20399);
  }
  return CFBundleCopyResourceURL((CFBundleRef)get_bundle_bundle, @"LocalNetworkPrivacy.png", 0LL, 0LL);
}

CFTypeRef NEResourcesCopyContentFilterExclusionList()
{
  if (get_bundle_initialized != -1) {
    dispatch_once(&get_bundle_initialized, &__block_literal_global_20_20399);
  }
  CFTypeRef result = CFBundleGetValueForInfoDictionaryKey((CFBundleRef)get_bundle_bundle, @"ContentFilterExclusionList");
  if (result) {
    return CFRetain(result);
  }
  return result;
}

CFTypeRef NEResourcesCopyContentFilterDefaultDropExclusionList()
{
  if (get_bundle_initialized != -1) {
    dispatch_once(&get_bundle_initialized, &__block_literal_global_20_20399);
  }
  CFTypeRef result = CFBundleGetValueForInfoDictionaryKey( (CFBundleRef)get_bundle_bundle,  @"ContentFilterDefaultDropExclusionList");
  if (result) {
    return CFRetain(result);
  }
  return result;
}

id NEResourcesCopyLocalizedNSString(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  get_nsbundle();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  NEResourcesCopyPreferredLanguages();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  BOOL v7 = (void *)MEMORY[0x1896077F8];
  [v5 localizations];
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  [v7 preferredLocalizationsFromArray:v8 forPreferences:v6];
  char v9 = (void *)objc_claimAutoreleasedReturnValue();

  [v9 firstObject];
  if (get_bundle_initialized != -1) {
    dispatch_once(&get_bundle_initialized, &__block_literal_global_20_20399);
  }
  uint64_t v10 = (void *)CFBundleCopyLocalizedStringForLocalization();

  return v10;
}

id NEResourcesCopyLocalizedFormatString(uint64_t a1, void *a2)
{
  return NEResourcesCopyLocalizedNSString(a2, a2);
}

id NEResourcesCopyDeviceLocalizedNSString(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  get_nsbundle();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v6 = (void *)CFPreferencesCopyValue( @"AppleLanguages",  (CFStringRef)*MEMORY[0x189605170],  @"mobile",  (CFStringRef)*MEMORY[0x189605178]);
  BOOL v7 = (void *)MEMORY[0x1896077F8];
  [v5 localizations];
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  [v7 preferredLocalizationsFromArray:v8 forPreferences:v6];
  char v9 = (void *)objc_claimAutoreleasedReturnValue();

  [v9 firstObject];
  if (get_bundle_initialized != -1) {
    dispatch_once(&get_bundle_initialized, &__block_literal_global_20_20399);
  }
  uint64_t v10 = (void *)CFBundleCopyLocalizedStringForLocalization();

  return v10;
}

id NEResourcesCopyDeviceLocalizedFormatString(uint64_t a1, void *a2)
{
  return NEResourcesCopyDeviceLocalizedNSString(a2, a2);
}

CFURLRef NEResourcesCopyAppTrackingDomainsPath()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  if (get_bundle_initialized != -1) {
    dispatch_once(&get_bundle_initialized, &__block_literal_global_20_20399);
  }
  CFTypeRef result = CFBundleCopyResourceURL((CFBundleRef)get_bundle_bundle, @"apptrackingdomains.json", 0LL, 0LL);
  if (result)
  {
    id v1 = result;
    int v2 = CFURLGetFileSystemRepresentation(result, 1u, buffer, 1024LL);
    CFRelease(v1);
    if (v2) {
      return (const __CFURL *)CFStringCreateWithCString( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const char *)buffer,  0x600u);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

CFURLRef NEResourcesCopyTestAppTrackingDomainsPath()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  if (get_bundle_initialized != -1) {
    dispatch_once(&get_bundle_initialized, &__block_literal_global_20_20399);
  }
  CFTypeRef result = CFBundleCopyResourceURL((CFBundleRef)get_bundle_bundle, @"testapptrackingdomains.json", 0LL, 0LL);
  if (result)
  {
    id v1 = result;
    int v2 = CFURLGetFileSystemRepresentation(result, 1u, buffer, 1024LL);
    CFRelease(v1);
    if (v2) {
      return (const __CFURL *)CFStringCreateWithCString( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const char *)buffer,  0x600u);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void sub_18781E02C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_18781E804( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

uint64_t symptomReporterSuccessfullyLoaded()
{
  if (symptomReporterSuccessfullyLoaded_symbolLoadOnce != -1) {
    dispatch_once(&symptomReporterSuccessfullyLoaded_symbolLoadOnce, &__block_literal_global_20465);
  }
  return symptomReporterSuccessfullyLoaded_symbolsLoaded;
}

void __symptomReporterSuccessfullyLoaded_block_invoke()
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v0 = dlopen("/System/Library/PrivateFrameworks/SymptomReporter.framework/SymptomReporter", 6);
  id v1 = getenv("DYLD_IMAGE_SUFFIX");
  int v2 = v1;
  id v3 = "out";
  if (v0 || !v1) {
    goto LABEL_16;
  }
  *(void *)__path = 0LL;
  BOOL v4 = asprintf( (char **)__path,  "%s%s",  "/System/Library/PrivateFrameworks/SymptomReporter.framework/SymptomReporter",  v1) <= 0;
  uint64_t v5 = *(void **)__path;
  BOOL v6 = v4 || *(void *)__path == 0LL;
  int v7 = !v6;
  if (v6)
  {
    uint64_t v0 = 0LL;
    if (!*(void *)__path) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }

  uint64_t v0 = dlopen(*(const char **)__path, 6);
  uint64_t v5 = *(void **)__path;
  if (*(void *)__path) {
LABEL_13:
  }
    free(v5);
LABEL_14:
  if (v7) {
    id v3 = "";
  }
LABEL_16:
  if (v0)
  {
    symptomReporterSuccessfullyLoaded_symbolsLoaded = 1;
    symptom_create = (uint64_t)dlsym(v0, "symptom_create");
    if (symptom_create)
    {
      symptom_set_qualifier = (uint64_t)dlsym(v0, "symptom_set_qualifier");
      if (symptom_set_qualifier)
      {
        symptom_send = (uint64_t)dlsym(v0, "symptom_send");
        if (symptom_send)
        {
          symptom_set_additional_qualifier = (uint64_t)dlsym(v0, "symptom_set_additional_qualifier");
          if (symptom_set_additional_qualifier)
          {
            if (symptomReporterSuccessfullyLoaded_symbolsLoaded == 1)
            {
              uint64_t v8 = (os_log_s *)ne_log_obj();
              if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
              {
                char v9 = "[null]";
                if (v2) {
                  char v9 = v2;
                }
                *(_DWORD *)__path = 136315394;
                *(void *)&__path[4] = v3;
                __int16 v14 = 2080;
                uint64_t v15 = v9;
                _os_log_debug_impl( &dword_1876B1000,  v8,  OS_LOG_TYPE_DEBUG,  "Successfully loaded SymptomReporter framework with%s suffix %s",  __path,  0x16u);
              }

              return;
            }

void sub_18781FD80(_Unwind_Exception *a1)
{
}

void sub_1878202B0(_Unwind_Exception *a1)
{
}

void sub_18782040C(_Unwind_Exception *a1)
{
}

void sub_187820878(_Unwind_Exception *a1)
{
}

void sub_1878214E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id obj, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

uint64_t __Block_byref_object_copy__20871(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__20872(uint64_t a1)
{
}

void sub_187822DF4(_Unwind_Exception *a1)
{
}

void sub_187823244(_Unwind_Exception *a1)
{
}

void sub_1878234FC(_Unwind_Exception *a1)
{
}

void sub_1878236E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_187823810(_Unwind_Exception *a1)
{
}

void sub_187826688( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void authCallback(__CFUserNotification *a1, char a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)&g_currentNotificationLock);
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  id v4 = (id)g_currentNotifications;
  BOOL v6 = (id *)[v4 countByEnumeratingWithState:&v25 objects:v29 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v26;
    do
    {
      uint64_t v8 = 0LL;
      do
      {
        if (*(void *)v26 != v7) {
          objc_enumerationMutation(v4);
        }
        char v9 = *(void **)(*((void *)&v25 + 1) + 8LL * (void)v8);
        if (v9) {
          id Property = (__CFUserNotification *)objc_getProperty( *(id *)(*((void *)&v25 + 1) + 8LL * (void)v8),  v5,  16LL,  1);
        }
        else {
          id Property = 0LL;
        }
        if (Property == a1)
        {
          BOOL v6 = v9;
          goto LABEL_15;
        }

        uint64_t v8 = (id *)((char *)v8 + 1);
      }

      while (v6 != v8);
      uint64_t v11 = [v4 countByEnumeratingWithState:&v25 objects:v29 count:16];
      BOOL v6 = (id *)v11;
    }

    while (v11);
  }

void alertCallback(id a1, char a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)&g_currentNotificationLock);
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  id v4 = (id)g_currentNotifications;
  uint64_t v5 = [v4 countByEnumeratingWithState:&v22 objects:v26 count:16];
  if (v5)
  {
    uint64_t v7 = v5;
    uint64_t v8 = *(void *)v23;
    do
    {
      uint64_t v9 = 0LL;
      do
      {
        if (*(void *)v23 != v8) {
          objc_enumerationMutation(v4);
        }
        uint64_t v10 = *(void **)(*((void *)&v22 + 1) + 8 * v9);
        if (v10) {
          id Property = objc_getProperty(*(id *)(*((void *)&v22 + 1) + 8 * v9), v6, 16LL, 1);
        }
        else {
          id Property = 0LL;
        }
        if (Property == a1)
        {
          uint64_t v13 = v10;
          goto LABEL_15;
        }

        ++v9;
      }

      while (v7 != v9);
      uint64_t v12 = [v4 countByEnumeratingWithState:&v22 objects:v26 count:16];
      uint64_t v7 = v12;
    }

    while (v12);
  }

  uint64_t v13 = 0LL;
LABEL_15:

  os_unfair_lock_unlock((os_unfair_lock_t)&g_currentNotificationLock);
  if (v13)
  {
    CFIndex v15 = (dispatch_queue_s *)objc_getProperty(v13, v14, 32LL, 1);
    id v16 = v13[5];
    [v13 cancel];
    if (v15 && v16)
    {
      if ((a2 & 3) == 1) {
        uint64_t v17 = 1LL;
      }
      else {
        uint64_t v17 = 2LL * ((a2 & 3) == 3);
      }
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 3221225472LL;
      block[2] = __alertCallback_block_invoke;
      block[3] = &unk_18A08FC28;
      id v20 = v16;
      uint64_t v21 = v17;
      dispatch_async(v15, block);
    }
  }

  else
  {
    ne_log_obj();
    CFIndex v15 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_ERROR))
    {
      v18[0] = 0;
      _os_log_error_impl( &dword_1876B1000,  (os_log_t)v15,  OS_LOG_TYPE_ERROR,  "Failed to find current notification on alert callback",  (uint8_t *)v18,  2u);
    }
  }
}

uint64_t __alertCallback_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(void *)(a1 + 40),  0LL);
}

uint64_t __authCallback_block_invoke(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[5] + 16LL))(a1[5], a1[6], a1[4]);
}

void sub_18782781C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

LABEL_157:
  CFIndex v42 = @"child-integrity-algorithm";
  [v6 objectForKeyedSubscript:@"child-integrity-algorithm"];
  CFRange v71 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v71) {
    goto LABEL_171;
  }
  if ([v7 type] != 5) {
    goto LABEL_187;
  }
  CFRange v55 = @"child-integrity-algorithm";
  [v6 objectForKeyedSubscript:@"child-integrity-algorithm"];
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (![v17 isEqualToString:@"SHA1-96"])
  {
    if ([v17 isEqualToString:@"SHA1-160"])
    {
      [v7 childSecurityAssociationParameters];
      CFRange v72 = (void *)objc_claimAutoreleasedReturnValue();
      CFStringRef v73 = v72;
      CFStringRef v74 = 2LL;
      goto LABEL_170;
    }

    if ([v17 isEqualToString:@"SHA2-256"])
    {
      [v7 childSecurityAssociationParameters];
      CFRange v72 = (void *)objc_claimAutoreleasedReturnValue();
      CFStringRef v73 = v72;
      CFStringRef v74 = 3LL;
      goto LABEL_170;
    }

    if ([v17 isEqualToString:@"SHA2-384"])
    {
      [v7 childSecurityAssociationParameters];
      CFRange v72 = (void *)objc_claimAutoreleasedReturnValue();
      CFStringRef v73 = v72;
      CFStringRef v74 = 4LL;
      goto LABEL_170;
    }

    if ([v17 isEqualToString:@"SHA2-512"])
    {
      [v7 childSecurityAssociationParameters];
      CFRange v72 = (void *)objc_claimAutoreleasedReturnValue();
      CFStringRef v73 = v72;
      CFStringRef v74 = 5LL;
      goto LABEL_170;
    }

    goto LABEL_190;
  }

  [v7 childSecurityAssociationParameters];
  CFRange v72 = (void *)objc_claimAutoreleasedReturnValue();
  CFStringRef v73 = v72;
  CFStringRef v74 = 1LL;
LABEL_170:
  [v72 setIntegrityAlgorithm:v74];

LABEL_171:
  CFIndex v42 = @"child-diffie-hellman-group";
  [v6 objectForKeyedSubscript:@"child-diffie-hellman-group"];
  CFRange v75 = (void *)objc_claimAutoreleasedReturnValue();

  if (v75)
  {
    if ([v7 type] != 5) {
      goto LABEL_187;
    }
    [v6 objectForKeyedSubscript:@"child-diffie-hellman-group"];
    CFRange v76 = (void *)objc_claimAutoreleasedReturnValue();
    CFRange v77 = [v76 intValue];

    if ((v77 > 0x20 || ((1LL << v77) & 0x180000026LL) == 0) && v77 - 22 <= 0xFFFFFFF7)
    {
LABEL_145:
      [NSString stringWithFormat:@"Invalid %@, valid values are 1, 2, 5, 14-21, 31, 32", v42, v87, v88];
      goto LABEL_188;
    }

    [v7 childSecurityAssociationParameters];
    uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue();
    [v78 setDiffieHellmanGroup:v77];
  }

  CFIndex v42 = @"child-life-time";
  [v6 objectForKeyedSubscript:@"child-life-time"];
  uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue();

  if (v79)
  {
    if ([v7 type] == 5)
    {
      [v6 objectForKeyedSubscript:@"child-life-time"];
      uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v81 = [v80 intValue];

      if ((v81 - 10) > 0x596)
      {
        [NSString stringWithFormat:@"Invalid %@, valid values are in the range 10 - 1440 minutes (24 hours)", @"child-life-time", v87, v88];
        goto LABEL_188;
      }

      [v7 childSecurityAssociationParameters];
      uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
      [v82 setLifetimeMinutes:v81];

      goto LABEL_180;
    }

LABEL_180:
  [v6 objectForKeyedSubscript:@"enable-fallback"];
  uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue();

  if (v83 && [v7 type] == 5)
  {
    [v6 objectForKeyedSubscript:@"enable-fallback"];
    uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "setEnableFallback:", objc_msgSend(v84, "BOOLValue"));
  }

  [v6 objectForKeyedSubscript:@"mtu"];
  uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue();

  if (v85 && [v7 type] == 5)
  {
    [v6 objectForKeyedSubscript:@"mtu"];
    uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "setMtu:", (int)objc_msgSend(v86, "intValue"));
  }

  uint64_t v13 = 1;
LABEL_11:

  return v13;
}

void sub_18782F0B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint8_t buf)
{
}

void sub_187831164(_Unwind_Exception *a1)
{
}

__CFString *convert_error_to_string_21512(void *a1)
{
  id v1 = a1;
  [v1 domain];
  int v2 = (void *)objc_claimAutoreleasedReturnValue();
  int v3 = [v2 isEqualToString:@"NEConfigurationErrorDomain"];

  if (v3)
  {
    id v4 = @"configuration is corrupted";
    switch([v1 code])
    {
      case 1LL:
        break;
      case 2LL:
        uint64_t v5 = (void *)NSString;
        [v1 localizedDescription];
        BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
        [v5 stringWithFormat:@"configuration is invalid: %@", v6];
        id v4 = (__CFString *)objc_claimAutoreleasedReturnValue();

        break;
      case 3LL:
        id v4 = @"configuration type is wrong";
        break;
      case 4LL:
        id v4 = @"configuration owner application is wrong";
        break;
      case 5LL:
        id v4 = @"configuration is stale";
        break;
      case 6LL:
        id v4 = @"failed to write configuration to disk";
        break;
      case 7LL:
        id v4 = @"configuration does not exist";
        break;
      case 8LL:
        id v4 = @"invalid configuration operation request";
        break;
      case 9LL:
        id v4 = @"configuration is unchanged";
        break;
      case 10LL:
        id v4 = @"permission denied";
        break;
      case 11LL:
        id v4 = @"IPC failed";
        break;
      case 12LL:
        id v4 = @"failed to make the change in SCPreferences";
        break;
      case 13LL:
        id v4 = @"failed to copy keychain items";
        break;
      case 14LL:
        id v4 = @"failed into import certificates into keychain";
        break;
      case 15LL:
        id v4 = @"unknown certificate format";
        break;
      case 16LL:
        id v4 = @"failed to import certificate";
        break;
      case 17LL:
        id v4 = @"internal failure with certificate installation";
        break;
      case 18LL:
        id v4 = @"file not found";
        break;
      case 21LL:
        id v4 = @"MDM required";
        break;
      default:
        id v4 = @"<unknown>";
        break;
    }
  }

  else
  {
    [v1 localizedDescription];
    id v4 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }

  return v4;
}

id find_config_by_name(void *a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    id v5 = v3;
    id v6 = (id)[v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v6)
    {
      uint64_t v7 = *(void *)v14;
      while (2)
      {
        for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v14 != v7) {
            objc_enumerationMutation(v5);
          }
          uint64_t v9 = *(void **)(*((void *)&v13 + 1) + 8LL * (void)i);
          objc_msgSend(v9, "name", (void)v13);
          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
          int v11 = [v10 isEqualToString:v4];

          if (v11)
          {
            id v6 = v9;
            goto LABEL_12;
          }
        }

        id v6 = (id)[v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
        if (v6) {
          continue;
        }
        break;
      }
    }

uint64_t __Block_byref_object_copy__21516(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__21517(uint64_t a1)
{
}

void myCFRelease(const void **a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2)
    {
      CFRelease(v2);
      *a1 = 0LL;
    }
  }

CFTypeRef myCFRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void myCFReplace(CFTypeRef *a1, CFTypeRef cf)
{
  if (a1)
  {
    if (cf) {
      CFTypeRef v3 = CFRetain(cf);
    }
    else {
      CFTypeRef v3 = 0LL;
    }
    if (*a1) {
      CFRelease(*a1);
    }
    *a1 = v3;
  }

uint64_t myCFEqual(unint64_t cf1, unint64_t a2)
{
  if (!(cf1 | a2)) {
    return 1LL;
  }
  uint64_t result = 0LL;
  if (cf1)
  {
    if (a2) {
      return CFEqual((CFTypeRef)cf1, (CFTypeRef)a2);
    }
  }

  return result;
}

void myCFDataReleaseReset(CFDataRef *a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(v2);
      if (MutableBytePtr)
      {
        id v4 = MutableBytePtr;
        rsize_t Length = CFDataGetLength(*a1);
        rsize_t v6 = CFDataGetLength(*a1);
        memset_s(v4, Length, 0, v6);
      }

      CFRelease(*a1);
      *a1 = 0LL;
    }
  }

__CFData *myCFDataCreateMutableCopy(const __CFAllocator *a1, const UInt8 *a2, CFIndex a3)
{
  CFTypeRef v3 = 0LL;
  if (a2)
  {
    if (a3)
    {
      CFMutableDataRef Mutable = CFDataCreateMutable(a1, 0LL);
      CFTypeRef v3 = Mutable;
      if (Mutable) {
        CFDataAppendBytes(Mutable, a2, a3);
      }
    }
  }

  return v3;
}

CFDataRef myCFDataCreateMutableCopyOfData(const __CFData *theData)
{
  if (theData)
  {
    theData = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, theData);
    if (!theData)
    {
      id v1 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)int v2 = 0;
        _os_log_fault_impl(&dword_1876B1000, v1, OS_LOG_TYPE_FAULT, "CFDataCreateMutableCopy failed", v2, 2u);
      }

      return 0LL;
    }
  }

  return theData;
}

void myCFDataResetReplace(CFDataRef *a1, CFDataRef theData)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    MutableCopyOfData = myCFDataCreateMutableCopyOfData(theData);
    myCFDataReleaseReset(a1);
    *a1 = MutableCopyOfData;
  }

  else
  {
    id v4 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      int v5 = 136315138;
      rsize_t v6 = "myCFDataResetReplace";
      _os_log_fault_impl(&dword_1876B1000, v4, OS_LOG_TYPE_FAULT, "%s called with null oldP", (uint8_t *)&v5, 0xCu);
    }
  }

__CFData *myCFDataCreateMutableFromString(const __CFString *a1)
{
  if (!a1) {
    return 0LL;
  }
  if (!CFStringGetLength(a1)) {
    return 0LL;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  id v4 = (char *)malloc(v3);
  if (!v4) {
    return 0LL;
  }
  int v5 = (UInt8 *)v4;
  CFStringGetCString(a1, v4, v3, 0x8000100u);
  rsize_t v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex v7 = CFStringGetLength(a1);
  CFMutableDictionaryRef MutableCopy = myCFDataCreateMutableCopy(v6, v5, v7);
  memset_s(v5, v3, 0, v3);
  free(v5);
  return MutableCopy;
}

void myCFDataResetReplaceFromString(CFDataRef *a1, CFStringRef theString)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    CFMutableDictionaryRef MutableCopy = theString;
    if (theString)
    {
      if (CFStringGetLength(theString) >= 1)
      {
        CFIndex Length = CFStringGetLength(MutableCopy);
        CFIndex v5 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
        rsize_t v6 = (char *)malloc(v5);
        if (v6)
        {
          CFIndex v7 = (UInt8 *)v6;
          CFStringGetCString(MutableCopy, v6, v5, 0x8000100u);
          uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
          CFIndex v9 = CFStringGetLength(MutableCopy);
          CFMutableDictionaryRef MutableCopy = (const __CFString *)myCFDataCreateMutableCopy(v8, v7, v9);
          memset_s(v7, v5, 0, v5);
          free(v7);
          goto LABEL_9;
        }

        uint64_t v10 = (os_log_s *)ne_log_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        {
          int v12 = 67109120;
          LODWORD(v13) = v5;
          _os_log_fault_impl(&dword_1876B1000, v10, OS_LOG_TYPE_FAULT, "malloc(%u) failed", (uint8_t *)&v12, 8u);
        }
      }

      CFMutableDictionaryRef MutableCopy = 0LL;
    }

const void *NEIsValidCFType(const void *result, uint64_t a2)
{
  if (result) {
    return (const void *)(CFGetTypeID(result) == a2);
  }
  return result;
}

const void *NEGetValueWithType(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  CFIndex v3 = 0LL;
  if (a1)
  {
    if (a2)
    {
      Value = CFDictionaryGetValue(a1, a2);
      if (!Value) {
        return 0LL;
      }
      CFIndex v3 = Value;
      if (CFGetTypeID(Value) != a3) {
        return 0LL;
      }
    }
  }

  return v3;
}

void NEInitCFTypes()
{
  if (NEInitCFTypes_onceToken != -1) {
    dispatch_once(&NEInitCFTypes_onceToken, &__block_literal_global_22164);
  }
}

CFTypeID __NEInitCFTypes_block_invoke()
{
  CFSTRING_TYPE = CFStringGetTypeID();
  CFNUMBER_TYPE = CFNumberGetTypeID();
  CFBOOLEAN_TYPE = CFBooleanGetTypeID();
  CFARRAY_TYPE = CFArrayGetTypeID();
  CFDICTIONARY_TYPE = CFDictionaryGetTypeID();
  CFTypeID result = CFDataGetTypeID();
  CFDATA_TYPE = result;
  return result;
}

void *NEMapIntegerToString(void *result, int a2)
{
  if (result)
  {
    int v2 = result;
    CFTypeID result = (void *)*result;
    if (result)
    {
      CFIndex v3 = v2 + 2;
      do
      {
        if (*((_DWORD *)v3 - 2) == a2) {
          break;
        }
        id v4 = (void *)*v3;
        v3 += 2;
        CFTypeID result = v4;
      }

      while (v4);
    }
  }

  return result;
}

const void **NEMapStringToInteger(const void **result, CFTypeRef cf1)
{
  if (result)
  {
    CFIndex v3 = result;
    id v4 = *result;
    if (*result)
    {
      while (!cf1 || !CFEqual(cf1, v4))
      {
        CFIndex v5 = v3[2];
        v3 += 2;
        id v4 = v5;
        if (!v5) {
          return 0LL;
        }
      }

      return (const void **)*((unsigned int *)v3 + 2);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t NEInChecksum(unsigned __int16 *a1, int a2)
{
  if (a2 < 2)
  {
    unsigned int v2 = 0;
  }

  else
  {
    unsigned int v2 = 0;
    unsigned int v3 = a2;
    do
    {
      int v4 = *a1++;
      v2 += v4;
      a2 = v3 - 2;
      BOOL v5 = v3 > 3;
      v3 -= 2;
    }

    while (v5);
  }

  if (a2 == 1) {
    v2 += *(unsigned __int8 *)a1;
  }
  return (unsigned __int16)~(HIWORD(v2) + v2 + ((HIWORD(v2) + (unsigned __int16)v2) >> 16));
}

void *NECreateAddressStructFromString(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  __int128 v16 = 0LL;
  if (!a1) {
    return 0LL;
  }
  CFIndex v6 = CFStringGetLength(a1) + 1;
  CFIndex v7 = (char *)malloc(v6);
  CFStringGetCString(a1, v7, v6, 0x600u);
  uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (a2) {
    CFIndex v9 = CFStringCreateWithFormat(v8, 0LL, @"%@", a2);
  }
  else {
    CFIndex v9 = CFStringCreateWithFormat(v8, 0LL, @"%d", a3);
  }
  int v11 = v9;
  CFIndex v12 = CFStringGetLength(v9) + 1;
  __int128 v13 = (char *)malloc(v12);
  CFStringGetCString(v11, v13, v12, 0x600u);
  CFRelease(v11);
  memset(&v17, 0, sizeof(v17));
  v17.ai_socktype = 2;
  v17.ai_flags = 4;
  if (getaddrinfo(v7, v13, &v17, &v16))
  {
    uint64_t v10 = 0LL;
    if (!v7) {
      goto LABEL_9;
    }
  }

  else
  {
    uint64_t v10 = malloc(0x80uLL);
    __int128 v15 = v16;
    if (v10) {
      __memcpy_chk();
    }
    freeaddrinfo(v15);
    if (!v7) {
      goto LABEL_9;
    }
  }

  free(v7);
LABEL_9:
  if (v13) {
    free(v13);
  }
  return v10;
}

CFStringRef NEGetAddressFamilyFromString(CFStringRef theString)
{
  id v1 = theString;
  uint64_t v16 = *MEMORY[0x1895F89C0];
  CFIndex v6 = 0LL;
  if (theString)
  {
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v13 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    __int128 v9 = 0u;
    __int128 v10 = 0u;
    __int128 v8 = 0u;
    CFIndex v2 = CFStringGetLength(theString) + 1;
    unsigned int v3 = (char *)malloc(v2);
    CFStringGetCString(v1, v3, v2, 0x600u);
    memset(&v7, 0, sizeof(v7));
    v7.ai_socktype = 2;
    v7.ai_flags = 4;
    if (!getaddrinfo(v3, 0LL, &v7, &v6))
    {
      BOOL v5 = v6;
      __memcpy_chk();
      freeaddrinfo(v5);
      id v1 = (const __CFString *)BYTE1(v8);
      if (!v3) {
        return v1;
      }
      goto LABEL_4;
    }

    id v1 = 0LL;
    if (v3) {
LABEL_4:
    }
      free(v3);
  }

  return v1;
}

CFDataRef NECreateAddressDataFromString(const __CFString *a1, const __CFString *a2, int *a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  __int128 v14 = 0LL;
  if (!a1) {
    return 0LL;
  }
  memset(v16, 0, sizeof(v16));
  CFIndex v6 = CFStringGetLength(a1) + 1;
  addrinfo v7 = (char *)malloc(v6);
  CFStringGetCString(a1, v7, v6, 0x600u);
  if (a2)
  {
    CFIndex v8 = CFStringGetLength(a2) + 1;
    __int128 v9 = (char *)malloc(v8);
    CFStringGetCString(a2, v9, v8, 0x600u);
  }

  else
  {
    __int128 v9 = 0LL;
  }

  memset(&v15, 0, sizeof(v15));
  v15.ai_socktype = 2;
  v15.ai_flags = 4;
  if (getaddrinfo(v7, v9, &v15, &v14)) {
    goto LABEL_7;
  }
  __int128 v12 = v14;
  __memcpy_chk();
  freeaddrinfo(v12);
  if (BYTE1(v16[0]) == 30)
  {
    CFDataRef v10 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)v16 + 8, 16LL);
    if (!a3) {
      goto LABEL_8;
    }
    int v13 = 30;
    goto LABEL_19;
  }

  if (BYTE1(v16[0]) == 2)
  {
    CFDataRef v10 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)v16 + 4, 4LL);
    if (!a3) {
      goto LABEL_8;
    }
    int v13 = 2;
LABEL_19:
    *a3 = v13;
    goto LABEL_8;
  }

CFDataRef NECreateAddressStructDataFromString(const __CFString *a1, const __CFString *a2, int *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  __int128 v14 = 0LL;
  if (!a1) {
    return 0LL;
  }
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v21 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  *(_OWORD *)bytes = 0u;
  CFIndex v6 = CFStringGetLength(a1) + 1;
  addrinfo v7 = (char *)malloc(v6);
  CFStringGetCString(a1, v7, v6, 0x600u);
  if (a2)
  {
    CFIndex v8 = CFStringGetLength(a2) + 1;
    __int128 v9 = (char *)malloc(v8);
    CFStringGetCString(a2, v9, v8, 0x600u);
  }

  else
  {
    __int128 v9 = 0LL;
  }

  memset(&v15, 0, sizeof(v15));
  v15.ai_socktype = 2;
  v15.ai_flags = 4;
  if (!getaddrinfo(v7, v9, &v15, &v14))
  {
    __int128 v11 = v14;
    __memcpy_chk();
    freeaddrinfo(v11);
    CFDataRef v10 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], bytes, 128LL);
    int v12 = bytes[1];
    if (bytes[1] == 2)
    {
      if (!a3) {
        goto LABEL_14;
      }
      int v12 = 2;
    }

    else if (!a3 || bytes[1] != 30)
    {
      goto LABEL_14;
    }

    *a3 = v12;
    goto LABEL_14;
  }

  CFDataRef v10 = 0LL;
LABEL_14:
  if (v7) {
    free(v7);
  }
  if (v9) {
    free(v9);
  }
  return v10;
}

CFStringRef NECreateAddressString(CFStringRef result)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  if (result)
  {
    int v1 = BYTE1(result->isa);
    if (v1 == 30)
    {
      if (LOBYTE(result->isa) >= 0x1Cu)
      {
        p_info = &result->info;
        int v3 = 30;
        goto LABEL_8;
      }
    }

    else if (v1 == 2 && LOBYTE(result->isa) >= 0x10u)
    {
      p_info = (uint64_t *)((char *)&result->isa + 4);
      int v3 = 2;
LABEL_8:
      inet_ntop(v3, p_info, cStr, 0x40u);
      return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x600u);
    }

    return 0LL;
  }

  return result;
}

__CFString *NECreateAddressStringWithPort(uint64_t a1)
{
  CFIndex v2 = NECreateAddressString((CFStringRef)a1);
  if (!v2) {
    return 0LL;
  }
  int v3 = v2;
  CFMutableDictionaryRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v2);
  CFRelease(v3);
  int v5 = *(unsigned __int8 *)(a1 + 1);
  if (v5 == 30)
  {
    CFIndex v6 = @".%u";
    goto LABEL_7;
  }

  if (v5 == 2)
  {
    CFIndex v6 = @":%u";
LABEL_7:
    CFStringAppendFormat(MutableCopy, 0LL, v6, bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16);
  }

  return MutableCopy;
}

uint64_t NEGetPortFromAddress(uint64_t result)
{
  if (result)
  {
    int v1 = *(unsigned __int8 *)(result + 1);
    if (v1 == 30 || v1 == 2) {
      unsigned int v2 = *(unsigned __int16 *)(result + 2);
    }
    else {
      unsigned int v2 = 0;
    }
    return __rev16(v2);
  }

  return result;
}

CFStringRef NECreateAddressStringFromBuffer(CFStringRef result, unint64_t a2, int a3)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (result)
  {
    CFStringRef v3 = result;
    if (a2 >= 4 && a3 == 2)
    {
      int v4 = 2;
LABEL_8:
      inet_ntop(v4, v3, cStr, 0x40u);
      return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x600u);
    }

    CFTypeID result = 0LL;
    if (a2 >= 0x10 && a3 == 30)
    {
      int v4 = 30;
      goto LABEL_8;
    }
  }

  return result;
}

CFStringRef NECreateIPv4AddressMaskStringFromPrefix(int a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1 > 32) {
    return 0LL;
  }
  int __b = 0;
  if (a1 < 8)
  {
    size_t v3 = 0LL;
  }

  else
  {
    size_t v3 = (a1 >> 3) - 1 + 1LL;
    memset(&__b, 255, v3);
  }

  if (a1 <= 0) {
    int v4 = -(-a1 & 7);
  }
  else {
    int v4 = a1 & 7;
  }
  if (v4) {
    cStr[v3 - 4] = 0xFF00u >> v4;
  }
  inet_ntop(2, &__b, cStr, 0x40u);
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x600u);
}

CFStringRef NECreateIPv6AddressMaskStringFromPrefix(int a1)
{
  size_t v2 = 0LL;
  uint64_t v7 = *MEMORY[0x1895F89C0];
  __b[0] = 0LL;
  __b[1] = 0LL;
  if (a1 >= 8)
  {
    size_t v2 = (a1 >> 3) - 1 + 1LL;
    memset(__b, 255, v2);
  }

  if (a1 <= 0) {
    int v3 = -(-a1 & 7);
  }
  else {
    int v3 = a1 & 7;
  }
  if (v3) {
    *((_BYTE *)__b + v2) = 0xFF00u >> v3;
  }
  inet_ntop(30, __b, cStr, 0x40u);
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x600u);
}

CFStringRef NECreateIPv6SubnetAddressWithPrefix(const __CFString *a1, int a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  int v3 = NECreateIPv6AddressMaskStringFromPrefix(a2);
  int v4 = NECreateAddressStructFromString(v3, 0LL, 0LL);
  int v5 = NECreateAddressStructFromString(a1, 0LL, 0LL);
  uint64_t v6 = v5;
  if (v4 && v5)
  {
    if (v4[1] == 30 && *((_BYTE *)v5 + 1) == 30)
    {
      uint64_t v7 = 0LL;
      v10[0] = 0LL;
      v10[1] = 0LL;
      do
      {
        *((_BYTE *)v10 + v7) = v4[v7 + 8] & *((_BYTE *)v5 + v7 + 8);
        ++v7;
      }

      while (v7 != 16);
      inet_ntop(30, v10, cStr, 0x40u);
      CFStringRef v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x600u);
    }

    else
    {
      CFStringRef v8 = 0LL;
    }
  }

  else
  {
    CFStringRef v8 = 0LL;
    if (!v4)
    {
      if (!v5) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }

  free(v4);
  if (v6) {
LABEL_10:
  }
    free(v6);
LABEL_11:
  if (v3) {
    CFRelease(v3);
  }
  return v8;
}

void NESetValueIfPresent(const __CFDictionary *a1, __CFDictionary *a2, void *key)
{
  if (a1 && a2 && key)
  {
    if (CFDictionaryContainsKey(a1, key))
    {
      Value = CFDictionaryGetValue(a1, key);
      CFDictionarySetValue(a2, key, Value);
    }
  }

void NEAddDateToDictionary(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  if (a1 && a2)
  {
    CFDateRef v5 = CFDateCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (double)a3 - *MEMORY[0x189604DA8]);
    if (v5)
    {
      CFDateRef v6 = v5;
      CFDictionaryAddValue(a1, a2, v5);
      CFRelease(v6);
    }
  }

void NEAddIntToDictionary(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  if (a1 && a2)
  {
    CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
    if (v5)
    {
      CFNumberRef v6 = v5;
      CFDictionaryAddValue(a1, a2, v5);
      CFRelease(v6);
    }
  }

void NEAddInt64ToDictionary(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  if (a1 && a2)
  {
    CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberSInt64Type, &valuePtr);
    if (v5)
    {
      CFNumberRef v6 = v5;
      CFDictionaryAddValue(a1, a2, v5);
      CFRelease(v6);
    }
  }

void NEAddIntToArray(__CFArray *a1, int a2)
{
  int valuePtr = a2;
  if (a1)
  {
    CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
    if (v3)
    {
      CFNumberRef v4 = v3;
      CFArrayAppendValue(a1, v3);
      CFRelease(v4);
    }
  }

uint64_t NEGetIntFromDictionary(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  unsigned int valuePtr = a3;
  if (a1)
  {
    if (a2)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
        return valuePtr;
      }
    }
  }

  return v3;
}

uint64_t NEGetIntFromArray(const __CFArray *a1, CFIndex a2, uint64_t a3)
{
  uint64_t v3 = a3;
  unsigned int valuePtr = a3;
  if (a1)
  {
    ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, a2);
    if (ValueAtIndex)
    {
      CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr);
      return valuePtr;
    }
  }

  return v3;
}

void NEAddAddressToDictionary(__CFDictionary *a1, const void *a2, unsigned __int8 *a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a1 && a2 && a3)
  {
    int v5 = a3[1];
    if (v5 == 30)
    {
      CFNumberRef v6 = a3 + 8;
      int v7 = 30;
    }

    else
    {
      if (v5 != 2) {
        return;
      }
      CFNumberRef v6 = a3 + 4;
      int v7 = 2;
    }

    inet_ntop(v7, v6, cStr, 0x40u);
    CFStringRef v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x600u);
    if (v8)
    {
      CFStringRef v9 = v8;
      CFDictionaryAddValue(a1, a2, v8);
      CFRelease(v9);
    }
  }

void NEAddPortToDictionary(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        int v3 = *(unsigned __int8 *)(a3 + 1);
        if (v3 == 30 || v3 == 2) {
          NEAddIntToDictionary(a1, a2, bswap32(*(unsigned __int16 *)(a3 + 2)) >> 16);
        }
      }
    }
  }

uint64_t NEGetPrefixForAddressRange(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || !a2) {
    return result;
  }
  int v4 = *(unsigned __int8 *)(a1 + 1);
  if (v4 == 30)
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = (__int128 *)(a1 + 8);
    __int128 v13 = *(_OWORD *)(a1 + 8);
    __int128 v53 = *(_OWORD *)(a2 + 8);
    __int128 v54 = v13;
    uint64_t result = 32LL;
    while (1)
    {
      unsigned int v14 = *(_DWORD *)((char *)&v54 + v11);
      unsigned int v15 = *(_DWORD *)((char *)&v53 + v11);
      if (v14 != v15) {
        break;
      }
      v11 += 4LL;
      result += 32LL;
      if (v11 == 16)
      {
        uint64_t result = 128LL;
        goto LABEL_20;
      }
    }

    unsigned int v21 = bswap32(v15);
    unsigned int v22 = bswap32(v14);
    do
    {
      v22 >>= 1;
      BOOL v20 = v22 == v21 >> 1;
      v21 >>= 1;
      --result;
    }

    while (!v20);
LABEL_20:
    uint64_t v23 = 0LL;
    __int128 v24 = *v12;
    __int128 v53 = *(_OWORD *)(a2 + 8);
    __int128 v54 = v24;
    unint64_t v25 = 32 - result;
    for (unint64_t i = result; ; i -= 32LL)
    {
      if (!i)
      {
        return result;
      }

      if (i <= 0x1F) {
        break;
      }
      ++v23;
      v25 += 32LL;
      if (v23 == 4) {
        return result;
      }
    }

    if (v25 <= 1) {
      unint64_t v25 = 1LL;
    }
    uint64_t v27 = v25 - 1;
    unint64_t v28 = (v25 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    int64x2_t v29 = (int64x2_t)xmmword_187873290;
    int64x2_t v30 = (int64x2_t)xmmword_1878732A0;
    int32x4_t v31 = (int32x4_t)xmmword_1878732B0;
    int32x4_t v32 = 0uLL;
    v33.i64[0] = 0x100000001LL;
    v33.i64[1] = 0x100000001LL;
    int64x2_t v34 = vdupq_n_s64(4uLL);
    v35.i64[0] = 0x400000004LL;
    v35.i64[1] = 0x400000004LL;
    do
    {
      int8x16_t v36 = (int8x16_t)v32;
      uint64x2_t v37 = (uint64x2_t)v29;
      uint64x2_t v38 = (uint64x2_t)v30;
      int32x4_t v32 = vaddq_s32((int32x4_t)vshlq_u32(v33, (uint32x4_t)v31), v32);
      int64x2_t v29 = vaddq_s64(v29, v34);
      int64x2_t v30 = vaddq_s64(v30, v34);
      int32x4_t v31 = vaddq_s32(v31, v35);
      v28 -= 4LL;
    }

    while (v28);
    uint64x2_t v39 = (uint64x2_t)vdupq_lane_s64(v27, 0);
    int v40 = vaddvq_s32((int32x4_t)vbslq_s8( (int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v38, v39), (int32x4_t)vcgtq_u64(v37, v39)),  v36,  (int8x16_t)v32));
    if ((bswap32(*((_DWORD *)&v54 + v23)) & v40) == 0
      && (v40 & ~bswap32(*((_DWORD *)&v53 + v23))) == 0)
    {
      return result;
    }

    return 0xFFFFFFFFLL;
  }

  if (v4 != 2) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 4);
  unsigned int v6 = bswap32(v5);
  unsigned int v7 = *(_DWORD *)(a2 + 4);
  unsigned int v8 = bswap32(v7);
  if (v5 == v7)
  {
    int v9 = 0;
    unsigned int v10 = 32;
  }

  else
  {
    uint64_t v16 = -3LL;
    unsigned int v17 = v8;
    unsigned int v18 = v6;
    do
    {
      uint64_t v19 = v16;
      v18 >>= 1;
      BOOL v20 = v18 == v17 >> 1;
      v17 >>= 1;
      --v16;
    }

    while (!v20);
    unsigned int v10 = v19 + 34;
    if (v19 == -2)
    {
      int v9 = 0;
    }

    else
    {
      int64x2_t v41 = (int64x2_t)xmmword_187873290;
      int64x2_t v42 = (int64x2_t)xmmword_1878732A0;
      int32x4_t v43 = (int32x4_t)xmmword_1878732B0;
      unint64_t v44 = -v16 & 0xFFFFFFFFFFFFFFFCLL;
      int32x4_t v45 = 0uLL;
      v46.i64[0] = 0x100000001LL;
      v46.i64[1] = 0x100000001LL;
      int64x2_t v47 = vdupq_n_s64(4uLL);
      v48.i64[0] = 0x400000004LL;
      v48.i64[1] = 0x400000004LL;
      do
      {
        int8x16_t v49 = (int8x16_t)v45;
        uint64x2_t v50 = (uint64x2_t)v41;
        uint64x2_t v51 = (uint64x2_t)v42;
        int32x4_t v45 = vaddq_s32((int32x4_t)vshlq_u32(v46, (uint32x4_t)v43), v45);
        int64x2_t v41 = vaddq_s64(v41, v47);
        int64x2_t v42 = vaddq_s64(v42, v47);
        int32x4_t v43 = vaddq_s32(v43, v48);
        v44 -= 4LL;
      }

      while (v44);
      uint64x2_t v52 = (uint64x2_t)vdupq_lane_s64(-3 - v19, 0);
      int v9 = vaddvq_s32((int32x4_t)vbslq_s8( (int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v51, v52), (int32x4_t)vcgtq_u64(v50, v52)),  v49,  (int8x16_t)v45));
    }
  }

  if (((v6 | ~v8) & v9) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v10;
  }
}

uint64_t NEGetPrefixForAddressRangeStrings(const __CFString *a1, const __CFString *a2)
{
  int v3 = NECreateAddressStructFromString(a1, 0LL, 0LL);
  int v4 = NECreateAddressStructFromString(a2, 0LL, 0LL);
  uint64_t v5 = NEGetPrefixForAddressRange((uint64_t)v3, (uint64_t)v4);
  if (v3) {
    free(v3);
  }
  if (v4) {
    free(v4);
  }
  return v5;
}

uint64_t NEGetPrefixForIPv4NetmaskString(const __CFString *a1)
{
  int v1 = NECreateAddressStructFromString(a1, 0LL, 0LL);
  size_t v2 = NECreateAddressStructFromString(@"255.255.255.255", 0LL, 0LL);
  uint64_t v3 = NEGetPrefixForAddressRange((uint64_t)v1, (uint64_t)v2);
  if (v1) {
    free(v1);
  }
  if (v2) {
    free(v2);
  }
  return v3;
}

uint64_t NEGetPrefixForIPv6NetmaskString(const __CFString *a1)
{
  int v1 = NECreateAddressStructFromString(a1, 0LL, 0LL);
  size_t v2 = NECreateAddressStructFromString(@"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff", 0LL, 0LL);
  uint64_t v3 = NEGetPrefixForAddressRange((uint64_t)v1, (uint64_t)v2);
  if (v1) {
    free(v1);
  }
  if (v2) {
    free(v2);
  }
  return v3;
}

uint64_t NECompareAddresses(const __CFString *a1, const __CFString *a2)
{
  uint64_t v2 = 4294967294LL;
  if (a1 && a2)
  {
    uint64_t v13 = 0LL;
    CFDataRef v4 = NECreateAddressDataFromString(a1, 0LL, (int *)&v13 + 1);
    uint64_t v5 = v4;
    if (v4 && HIDWORD(v13))
    {
      CFDataRef v6 = NECreateAddressDataFromString(a2, 0LL, (int *)&v13);
      if (v6)
      {
        unsigned int v7 = v6;
        if ((_DWORD)v13 == HIDWORD(v13))
        {
          BytePtr = CFDataGetBytePtr(v5);
          int v9 = CFDataGetBytePtr(v7);
          CFIndex Length = CFDataGetLength(v5);
          int v11 = memcmp(BytePtr, v9, Length);
          if (v11 >= 0) {
            uint64_t v2 = v11 != 0;
          }
          else {
            uint64_t v2 = 0xFFFFFFFFLL;
          }
        }

        CFRelease(v5);
        uint64_t v5 = v7;
      }

      goto LABEL_12;
    }

    if (v4) {
LABEL_12:
    }
      CFRelease(v5);
  }

  return v2;
}

BOOL NEAddressRangeIsContainedInAddressRange( const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  int v6 = NECompareAddresses(a1, a3);
  unsigned int v7 = NECompareAddresses(a2, a4);
  return (v6 + 1) < 2 && v7 < 2;
}

void NEAddDataToDictionary(__CFDictionary *a1, const void *a2, UInt8 *bytes, int a4)
{
  if (a1 && a2 && bytes)
  {
    CFDataRef v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], bytes, a4);
    if (v6)
    {
      CFDataRef v7 = v6;
      CFDictionaryAddValue(a1, a2, v6);
      CFRelease(v7);
    }
  }

void NEAppendIntToArray(__CFArray *a1, int a2)
{
  int valuePtr = a2;
  if (a1)
  {
    CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
    if (v3)
    {
      CFNumberRef v4 = v3;
      CFArrayAppendValue(a1, v3);
      CFRelease(v4);
    }
  }

CFNumberRef NEGetValueFromIntArray(const __CFNumber *result, CFIndex a2)
{
  unsigned int valuePtr = 0;
  if (result)
  {
    CFNumberRef v3 = result;
    if (CFArrayGetCount(result) <= a2)
    {
      return 0LL;
    }

    else
    {
      uint64_t result = (const __CFNumber *)CFArrayGetValueAtIndex(v3, a2);
      if (result)
      {
        CFNumberGetValue(result, kCFNumberIntType, &valuePtr);
        return (const __CFNumber *)valuePtr;
      }
    }
  }

  return result;
}

CFDataRef NECreateDataFromString(const __CFString *a1, int a2)
{
  if (!a1) {
    return 0LL;
  }
  CFIndex Length = CFStringGetLength(a1);
  if (!Length) {
    return 0LL;
  }
  CFIndex v5 = Length;
  CFIndex v6 = Length + 1;
  CFDataRef v7 = (char *)malloc(Length + 1);
  if (!v7) {
    return 0LL;
  }
  unsigned int v8 = (UInt8 *)v7;
  if (CFStringGetCString(a1, v7, v6, 0x600u))
  {
    if (a2) {
      CFIndex v9 = v5 + 1;
    }
    else {
      CFIndex v9 = v5;
    }
    CFDataRef v10 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v8, v9);
  }

  else
  {
    CFDataRef v10 = 0LL;
  }

  free(v8);
  return v10;
}

CFStringRef NECreateStringFromData(CFStringRef result)
{
  if (result)
  {
    int v1 = (const __CFData *)result;
    CFIndex Length = CFDataGetLength((CFDataRef)result);
    BytePtr = CFDataGetBytePtr(v1);
    UInt8 bytes = 0;
    CFNumberRef v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFIndex v5 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], &bytes, 1LL);
    if (!v5
      || (CFIndex v6 = v5,
          v10.locatiouint64_t n = 0LL,
          v10.__int16 length = Length,
          locatiouint64_t n = CFDataFind(v1, v5, v10, 0LL).location,
          CFRelease(v6),
          location == -1))
    {
      CFIndex v8 = CFDataGetLength(v1);
      return CFStringCreateWithBytes(v4, BytePtr, v8, 0x600u, 0);
    }

    else
    {
      return CFStringCreateWithCString(v4, (const char *)BytePtr, 0x600u);
    }
  }

  return result;
}

void *NECreateCStringFromCFString(const __CFString *a1)
{
  if (!a1) {
    return 0LL;
  }
  CFIndex Length = CFStringGetLength(a1);
  if (!Length) {
    return 0LL;
  }
  CFIndex v3 = Length + 1;
  CFNumberRef v4 = calloc(1uLL, Length + 1);
  if (v4 && !CFStringGetCString(a1, (char *)v4, v3, 0x600u))
  {
    free(v4);
    return 0LL;
  }

  return v4;
}

void NEAddValueToIntKeyedDictionary(__CFDictionary *a1, int a2, const void *a3)
{
  int valuePtr = a2;
  if (a1 && a3)
  {
    CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
    if (v5)
    {
      CFNumberRef v6 = v5;
      CFDictionaryAddValue(a1, v5, a3);
      CFRelease(v6);
    }
  }

CFDictionaryRef NEGetValueFromIntKeyedDictionary(const __CFDictionary *a1, int a2)
{
  Value = a1;
  int valuePtr = a2;
  if (a1)
  {
    CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
    if (v3)
    {
      CFNumberRef v4 = v3;
      Value = (const __CFDictionary *)CFDictionaryGetValue(Value, v3);
      CFRelease(v4);
    }

    else
    {
      return 0LL;
    }
  }

  return Value;
}

void NERemoveValueFromIntKeyedDictionary(__CFDictionary *a1, int a2)
{
  int valuePtr = a2;
  if (a1)
  {
    CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
    if (v3)
    {
      CFNumberRef v4 = v3;
      CFDictionaryRemoveValue(a1, v3);
      CFRelease(v4);
    }
  }

dispatch_source_s *NERepeatingEventCreate( dispatch_queue_s *a1, dispatch_time_t a2, unint64_t a3, uint64_t a4, uint64_t a5, int a6, const void *a7, const void *a8)
{
  uint64_t v16 = calloc(1uLL, 0x20uLL);
  *(void *)uint64_t v16 = a4;
  void v16[2] = a6;
  if (a7) {
    *((void *)v16 + 2) = _Block_copy(a7);
  }
  if (a8) {
    *((void *)v16 + 3) = _Block_copy(a8);
  }
  v16[3] = 0;
  dispatch_source_t v17 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, a3, a1);
  unsigned int v18 = v17;
  if (v17)
  {
    dispatch_set_context(v17, v16);
    dispatch_set_finalizer_f(v18, (dispatch_function_t)repeatingEventFinalizer);
    dispatch_source_set_timer(v18, a2, 1000000 * a4, 1000000 * a5);
    uint64_t v19 = MEMORY[0x1895F87A8];
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 0x40000000LL;
    handler[2] = __NERepeatingEventCreate_block_invoke;
    handler[3] = &__block_descriptor_tmp_12;
    void handler[4] = v18;
    dispatch_source_set_event_handler(v18, handler);
    v21[0] = v19;
    v21[1] = 0x40000000LL;
    v21[2] = __NERepeatingEventCreate_block_invoke_2;
    v21[3] = &__block_descriptor_tmp_13_22223;
    v21[4] = v18;
    dispatch_source_set_cancel_handler(v18, v21);
    dispatch_resume(v18);
  }

  else
  {
    free(v16);
  }

  return v18;
}

void repeatingEventFinalizer(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[2];
    if (v2) {
      _Block_release(v2);
    }
    CFNumberRef v3 = (const void *)a1[3];
    if (v3) {
      _Block_release(v3);
    }
    free(a1);
  }

uint64_t __NERepeatingEventCreate_block_invoke(uint64_t a1)
{
  int v1 = *(dispatch_source_s **)(a1 + 32);
  context = (uint64_t *)dispatch_get_context(v1);
  CFNumberRef v3 = context;
  int v5 = *((_DWORD *)context + 2);
  int v4 = *((_DWORD *)context + 3);
  *((_DWORD *)context + 3) = v4 + 1;
  if (v5) {
    BOOL v6 = v4 < v5;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    uint64_t result = context[2];
    if (!result) {
      return result;
    }
    return (*(uint64_t (**)(void))(result + 16))();
  }

  dispatch_source_cancel(v1);
  uint64_t result = v3[3];
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void __NERepeatingEventCreate_block_invoke_2(uint64_t a1)
{
  int v1 = *(dispatch_object_s **)(a1 + 32);
  if (v1) {
    dispatch_release(v1);
  }
}

uint64_t NERepeatingEventGetTimesFired(dispatch_object_s *a1)
{
  if (a1) {
    return *((unsigned int *)dispatch_get_context(a1) + 3);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

dispatch_object_s *NERepeatingEventGetIntervalInMilliseconds(dispatch_object_s *result)
{
  if (result) {
    return *(dispatch_object_s **)dispatch_get_context(result);
  }
  return result;
}

void NERepeatingEventRelease(dispatch_source_s *a1)
{
  if (a1)
  {
    if (!dispatch_source_testcancel(a1)) {
      dispatch_source_cancel(a1);
    }
  }

dispatch_source_s *NECreateTimerSource(dispatch_queue_t queue, uint64_t a2, void *a3)
{
  int v5 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, queue);
  if (v5)
  {
    dispatch_time_t v6 = dispatch_time(0LL, 1000000000 * a2);
    dispatch_source_set_timer(v5, v6, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_source_set_event_handler(v5, a3);
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 0x40000000LL;
    handler[2] = __NECreateTimerSource_block_invoke;
    handler[3] = &__block_descriptor_tmp_14;
    void handler[4] = v5;
    dispatch_source_set_cancel_handler(v5, handler);
    dispatch_resume(v5);
  }

  return v5;
}

void __NECreateTimerSource_block_invoke(uint64_t a1)
{
  int v1 = *(dispatch_object_s **)(a1 + 32);
  if (v1) {
    dispatch_release(v1);
  }
}

CFDataRef NECreateDataWithEncodedCString(_BYTE *a1, int a2)
{
  LOBYTE(v2) = *a1;
  if (!*a1) {
    return 0LL;
  }
  unint64_t v5 = 0LL;
  uint64_t v6 = 1LL;
  uint64_t v7 = MEMORY[0x1895F8770];
  do
  {
    if ((v2 & 0x80) != 0)
    {
    }

    else
    {
      int v8 = *(_DWORD *)(v7 + 4LL * (char)v2 + 60);
      if ((v8 & 0x10000) != 0)
      {
        ++v5;
      }

      else if ((v8 & 0x4000) == 0)
      {
        return 0LL;
      }
    }

    int v2 = a1[v6++];
  }

  while (v2);
  if (!v5) {
    return 0LL;
  }
  if ((v5 & 1) != 0) {
    return 0LL;
  }
  CFIndex v9 = (UInt8 *)malloc(v5 >> 1);
  if (!v9) {
    return 0LL;
  }
  CFRange v10 = v9;
  unsigned int v11 = *a1;
  if (*a1)
  {
    int v12 = 0;
    CFIndex v13 = 0LL;
    unsigned int v14 = a1 + 1;
    unsigned int v15 = v9;
    do
    {
      if ((v11 & 0x80) == 0 && (*(_DWORD *)(v7 + 4LL * v11 + 60) & 0x10000) != 0)
      {
        if (v12)
        {
          __str[1] = v11;
          __str[2] = 0;
          UInt8 v16 = strtol(__str, 0LL, a2);
          int v12 = 0;
          *v15++ = v16;
          ++v13;
        }

        else
        {
          __str[0] = v11;
          int v12 = 1;
        }
      }

      unsigned int v17 = *v14++;
      unsigned int v11 = v17;
    }

    while (v17);
  }

  else
  {
    CFIndex v13 = 0LL;
  }

  CFDataRef v19 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v10, v13);
  free(v10);
  return v19;
}

const char *NECertificateStatusToString(int a1)
{
  else {
    return off_18A08FF38[a1 - 1];
  }
}

uint64_t NECertificateDateIsValid(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 4LL;
  }
  SecCertificateNotValidBefore();
  CFAbsoluteTime v2 = v1;
  if (v1 == 0.0) {
    CFNumberRef v3 = 0LL;
  }
  else {
    CFNumberRef v3 = CFDateCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v1);
  }
  SecCertificateNotValidAfter();
  CFAbsoluteTime v6 = v5;
  if (v5 == 0.0) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = CFDateCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v5);
  }
  double Current = CFAbsoluteTimeGetCurrent();
  if (Current == 0.0)
  {
    CFRange v10 = 0LL;
    goto LABEL_19;
  }

  CFIndex v9 = CFDateCreate(0LL, Current);
  CFRange v10 = v9;
  if (!v3 || !v9)
  {
LABEL_19:
    uint64_t v4 = 1LL;
    if (!v3)
    {
      if (!v7) {
        goto LABEL_22;
      }
      goto LABEL_21;
    }

    goto LABEL_35;
  }

  if (CFDateCompare(v9, v3, 0LL) == kCFCompareLessThan)
  {
    CFIndex v13 = (os_log_s *)ne_log_obj();
    uint64_t v4 = 2LL;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_debug_impl(&dword_1876B1000, v13, OS_LOG_TYPE_DEBUG, "Current time before valid time", buf, 2u);
    }
  }

  else
  {
    if (!v7 || CFDateCompare(v10, v7, 0LL) != kCFCompareGreaterThan)
    {
      uint64_t v4 = 1LL;
      goto LABEL_35;
    }

    unsigned int v11 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_debug_impl(&dword_1876B1000, v11, OS_LOG_TYPE_DEBUG, "Current time after valid time", buf, 2u);
    }

    uint64_t v4 = 3LL;
  }

  if (nelog_is_info_logging_enabled())
  {
    uint64_t v19 = 0LL;
    uint64_t v20 = 0LL;
    int v18 = 0;
    unsigned int v14 = CFCalendarCreateWithIdentifier( (CFAllocatorRef)*MEMORY[0x189604DB0],  (CFCalendarIdentifier)*MEMORY[0x189604F90]);
    if (v14)
    {
      unsigned int v15 = v14;
      CFCalendarDecomposeAbsoluteTime(v14, v2, "yMdHm", (char *)&v20 + 4, &v20, (char *)&v19 + 4, &v19, &v18);
      UInt8 v16 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 67110144;
        int v22 = HIDWORD(v20);
        __int16 v23 = 1024;
        int v24 = v20;
        __int16 v25 = 1024;
        int v26 = HIDWORD(v19);
        __int16 v27 = 1024;
        int v28 = v19;
        __int16 v29 = 1024;
        int v30 = v18;
        _os_log_impl( &dword_1876B1000,  v16,  OS_LOG_TYPE_INFO,  "Certificate not valid before yr %d, mon %d, days %d, hours %d, min %d\n",  buf,  0x20u);
      }

      CFCalendarDecomposeAbsoluteTime(v15, v6, "yMdHm", (char *)&v20 + 4, &v20, (char *)&v19 + 4, &v19, &v18);
      unsigned int v17 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 67110144;
        int v22 = HIDWORD(v20);
        __int16 v23 = 1024;
        int v24 = v20;
        __int16 v25 = 1024;
        int v26 = HIDWORD(v19);
        __int16 v27 = 1024;
        int v28 = v19;
        __int16 v29 = 1024;
        int v30 = v18;
        _os_log_impl( &dword_1876B1000,  v17,  OS_LOG_TYPE_INFO,  "Certificate not valid after yr %d, mon %d, days %d, hours %d, min %d\n",  buf,  0x20u);
      }

      CFRelease(v15);
    }
  }

BOOL NEIsInterfaceWIFI()
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  int v0 = socket(2, 2, 0);
  if (v0 < 0)
  {
    CFAbsoluteTime v2 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    LODWORD(v7[0]) = 136315138;
    *(void *)((char *)v7 + 4) = "NEIsInterfaceWIFI";
    CFNumberRef v3 = "%s: Failed to open socket";
    uint64_t v4 = (uint8_t *)v7;
LABEL_10:
    _os_log_error_impl(&dword_1876B1000, v2, OS_LOG_TYPE_ERROR, v3, v4, 0xCu);
    goto LABEL_7;
  }

  memset(v7, 0, 44);
  __strlcpy_chk();
  if (ioctl(v0, 0xC02C6938uLL, v7) != -1)
  {
    close(v0);
    return (v7[1] & 0xE0) == 128;
  }

  CFAbsoluteTime v2 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 136315138;
    CFAbsoluteTime v6 = "NEIsInterfaceWIFI";
    CFNumberRef v3 = "%s: Failed to get media";
    uint64_t v4 = buf;
    goto LABEL_10;
  }

ifaddrs *NEGetInterfaceType(const char *a1, _BYTE *a2, BOOL *a3)
{
  CFRange v10 = 0LL;
  *a2 = 0;
  *a3 = 0;
  CFAbsoluteTime v6 = 0LL;
  if (!getifaddrs(&v10))
  {
    uint64_t v7 = v10;
    if (v10)
    {
      CFAbsoluteTime v6 = v10;
      while (1)
      {
        ifa_name = v6->ifa_name;
        if (ifa_name)
        {
          if (!strcmp(ifa_name, a1)) {
            break;
          }
        }

        CFAbsoluteTime v6 = v6->ifa_next;
        if (!v6) {
          goto LABEL_13;
        }
      }

      CFAbsoluteTime v6 = (ifaddrs *)v6->ifa_addr->sa_data[2];
      if ((_DWORD)v6 == 255)
      {
        *a2 = 0;
      }

      else if ((_DWORD)v6 == 6)
      {
        *a2 = 1;
        *a3 = NEIsInterfaceWIFI();
        uint64_t v7 = v10;
      }
    }

    else
    {
      CFAbsoluteTime v6 = 0LL;
    }

BOOL NEIsInterfaceCellular(const char *a1)
{
  return NEGetInterfaceType(a1, &v3, &v2) == 255;
}

void *NECopyInterfaceAddress(const char *a1, int a2)
{
  CFIndex v13 = 0LL;
  p_ifa_next = 0LL;
  if (!getifaddrs(&v13))
  {
    p_ifa_next = &v13->ifa_next;
    if (v13)
    {
      while (1)
      {
        CFAbsoluteTime v5 = (const char *)p_ifa_next[1];
        if (v5)
        {
          if (!strcmp(v5, a1))
          {
            CFAbsoluteTime v6 = (unsigned __int8 *)p_ifa_next[3];
            if (v6[1] == a2)
            {
              if (a2 == 30)
              {
                unsigned int v10 = *v6;
                uint64_t v8 = (const __CFString *)(v6 + 8);
                unint64_t v9 = v10;
                int v11 = 30;
                goto LABEL_13;
              }

              if (a2 == 2) {
                break;
              }
            }
          }
        }

        p_ifa_next = (void *)*p_ifa_next;
        if (!p_ifa_next) {
          goto LABEL_9;
        }
      }

      unsigned int v12 = *v6;
      uint64_t v8 = (const __CFString *)(v6 + 4);
      unint64_t v9 = v12;
      int v11 = 2;
LABEL_13:
      p_ifa_next = NECreateAddressStringFromBuffer(v8, v9, v11);
    }

uint64_t NEGetInterfaceForAddress(unsigned __int8 *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  int v2 = a1[1];
  if (v2 == 30)
  {
    if (*a1 > 0x1Bu) {
      goto LABEL_4;
    }
LABEL_21:
    unsigned int v10 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_error_impl( &dword_1876B1000,  v10,  OS_LOG_TYPE_ERROR,  "Address passed to NEGetInterfaceForAddress is too short",  buf,  2u);
    }

    return 0LL;
  }

  if (v2 == 2 && *a1 < 0x10u) {
    goto LABEL_21;
  }
LABEL_4:
  unsigned int v17 = 0LL;
  if (getifaddrs(&v17) < 0)
  {
    int v11 = *__error();
    unsigned int v12 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int v18 = 67109378;
      *(_DWORD *)uint64_t v19 = v11;
      *(_WORD *)&void v19[4] = 2080;
      *(void *)&v19[6] = buf;
      _os_log_fault_impl(&dword_1876B1000, v12, OS_LOG_TYPE_FAULT, "getifaddrs failed: [%d] %s", v18, 0x12u);
    }

    return 0LL;
  }

  char v3 = v17;
  if (!v17) {
    return 0LL;
  }
  int v4 = a1[1];
  while (1)
  {
    ifa_addr = v3->ifa_addr;
    if (v4 != ifa_addr->sa_family) {
      goto LABEL_16;
    }
    if (v4 == 30) {
      break;
    }
    if (v4 == 2 && *((_DWORD *)a1 + 1) == *(_DWORD *)&ifa_addr->sa_data[2]) {
      goto LABEL_29;
    }
LABEL_16:
    char v3 = v3->ifa_next;
    if (!v3) {
      goto LABEL_17;
    }
  }

  uint64_t v7 = *(void *)&ifa_addr->sa_data[6];
  uint64_t v6 = *(void *)&ifa_addr[1].sa_len;
  if (*((void *)a1 + 1) != v7 || *((void *)a1 + 2) != v6) {
    goto LABEL_16;
  }
LABEL_29:
  uint64_t v9 = if_nametoindex(v3->ifa_name);
  if (!(_DWORD)v9)
  {
    int v14 = *__error();
    unsigned int v15 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
    {
      ifa_name = v3->ifa_name;
      *(_DWORD *)int v18 = 136315650;
      *(void *)uint64_t v19 = ifa_name;
      *(_WORD *)&v19[8] = 1024;
      *(_DWORD *)&v19[10] = v14;
      __int16 v20 = 2080;
      unsigned int v21 = buf;
      _os_log_fault_impl( &dword_1876B1000,  v15,  OS_LOG_TYPE_FAULT,  "Failed to get an interface index for interface %s: [%d] %s",  v18,  0x1Cu);
    }

uint64_t NEIsValidInterface(const char *a1)
{
  uint64_t v7 = 0LL;
  if (getifaddrs(&v7)) {
    return 0LL;
  }
  char v3 = v7;
  if (v7)
  {
    int v4 = v7;
    while (1)
    {
      ifa_name = v4->ifa_name;
      if (ifa_name)
      {
        if (!strcmp(ifa_name, a1)) {
          break;
        }
      }

      int v4 = v4->ifa_next;
      if (!v4) {
        goto LABEL_8;
      }
    }

    uint64_t v2 = 1LL;
  }

  else
  {
LABEL_8:
    uint64_t v2 = 0LL;
  }

  MEMORY[0x1895AC894](v3);
  return v2;
}

BOOL NEIsWildcardAddress(unsigned __int8 *a1)
{
  int v1 = a1[1];
  if (v1 == 30)
  {
    if (*a1 >= 0x1Cu && !*((_DWORD *)a1 + 2) && !*((_DWORD *)a1 + 3) && !*((_DWORD *)a1 + 4))
    {
      uint64_t v2 = a1 + 20;
      return *v2 == 0;
    }
  }

  else if (v1 == 2 && *a1 >= 0x10u)
  {
    uint64_t v2 = a1 + 4;
    return *v2 == 0;
  }

  return 0LL;
}

BOOL NEIsLoopbackAddress(unsigned __int8 *a1)
{
  int v1 = a1[1];
  if (v1 == 30)
  {
    if (*a1 >= 0x1Cu && !*((_DWORD *)a1 + 2) && !*((_DWORD *)a1 + 3) && !*((_DWORD *)a1 + 4))
    {
      uint64_t v2 = a1 + 20;
      int v3 = 0x1000000;
      return *v2 == v3;
    }
  }

  else if (v1 == 2 && *a1 >= 0x10u)
  {
    uint64_t v2 = a1 + 4;
    int v3 = 16777343;
    return *v2 == v3;
  }

  return 0LL;
}

uint64_t NEGetEntitlement(void *a1)
{
  if (a1)
  {
    if (MEMORY[0x1895ADD58]() == MEMORY[0x1895F9220])
    {
      size_t count = xpc_array_get_count(a1);
      if (count)
      {
        size_t v5 = count;
        uint64_t v2 = 0LL;
        size_t v6 = 0LL;
        while (1)
        {
          string = xpc_array_get_string(a1, v6);
          if (string)
          {
            uint64_t v8 = string;
            size_t v9 = strlen(string);
            if (strncmp(v8, "packet-tunnel-provider", v9))
            {
              if (!strncmp(v8, "app-proxy-provider", v9)) {
                goto LABEL_22;
              }
              if (!strncmp(v8, "content-filter-provider", v9)) {
                goto LABEL_23;
              }
              if (!strncmp(v8, "dns-proxy", v9)) {
                goto LABEL_24;
              }
              if (!strncmp(v8, "dns-settings", v9))
              {
                uint64_t v2 = v2 | 0x40;
                goto LABEL_27;
              }

              if (!strncmp(v8, "relay", v9))
              {
                uint64_t v2 = v2 | 0x80;
                goto LABEL_27;
              }

              if (strncmp(v8, "packet-tunnel-provider-systemextension", v9))
              {
                if (strncmp(v8, "app-proxy-provider-systemextension", v9))
                {
                  if (strncmp(v8, "content-filter-provider-systemextension", v9))
                  {
                    if (strncmp(v8, "dns-proxy-systemextension", v9))
                    {
                      if (!strncmp(v8, "app-push-provider", v9)) {
                        uint64_t v2 = v2 | 0x20;
                      }
                      else {
                        uint64_t v2 = v2;
                      }
                      goto LABEL_27;
                    }

CFStringRef NECopySynthesizedIPv6Address(const __CFString *a1, int a2)
{
  CFIndex v13 = 0LL;
  CFStringRef v4 = 0LL;
  if (NEGetAddressFamilyFromString(a1) != 30)
  {
    int v12 = a2;
    int v5 = nw_nat64_copy_prefixes();
    if (v5 < 1)
    {
      CFStringRef v4 = 0LL;
      uint64_t v7 = 0LL;
    }

    else
    {
      unsigned int v6 = v5;
      uint64_t v7 = NECreateAddressStructFromString(a1, 0LL, 0LL);
      if (v7)
      {
        uint64_t v8 = 0LL;
        uint64_t v9 = 16LL * v6;
        while (1)
        {
          *(_OWORD *)&v11.isa = xmmword_187873010;
          *(_OWORD *)((char *)&v11.info + 4) = *(__int128 *)((char *)&xmmword_187873010 + 12);
          v8 += 16LL;
          if (v9 == v8) {
            goto LABEL_7;
          }
        }

        CFStringRef v4 = NECreateAddressString(&v11);
      }

      else
      {
LABEL_7:
        CFStringRef v4 = 0LL;
      }
    }

    if (v13)
    {
      free(v13);
      CFIndex v13 = 0LL;
    }

    if (v7) {
      free(v7);
    }
  }

  return v4;
}

const char *inputNotification2String(int a1)
{
  else {
    return off_18A08FF60[a1 - 1];
  }
}

uint64_t isa_nsstring(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (v1) {
    char isKindOfClass = objc_opt_isKindOfClass();
  }
  else {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

uint64_t isa_nsarray(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (v1) {
    char isKindOfClass = objc_opt_isKindOfClass();
  }
  else {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

uint64_t isa_nsset(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (v1) {
    char isKindOfClass = objc_opt_isKindOfClass();
  }
  else {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

uint64_t isa_nsdictionary(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (v1) {
    char isKindOfClass = objc_opt_isKindOfClass();
  }
  else {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

uint64_t isa_nsdata(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (v1) {
    char isKindOfClass = objc_opt_isKindOfClass();
  }
  else {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

uint64_t isa_nsnumber(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (v1) {
    char isKindOfClass = objc_opt_isKindOfClass();
  }
  else {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

uint64_t isa_nsnull(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (v1) {
    char isKindOfClass = objc_opt_isKindOfClass();
  }
  else {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

uint64_t isa_nsuuid(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (v1) {
    char isKindOfClass = objc_opt_isKindOfClass();
  }
  else {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

uint64_t isa_nsurl(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (v1) {
    char isKindOfClass = objc_opt_isKindOfClass();
  }
  else {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

uint64_t isa_neclass()
{
  int v0 = (objc_class *)objc_opt_class();
  NSStringFromClass(v0);
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v2 = [v1 hasPrefix:@"NE"];

  return v2;
}

id NECopyUserUUIDFromEUID()
{
  uid_t v0 = geteuid();
  return NECopyUserUUIDSimple(v0);
}

id NECopyUserUUIDSimple(uid_t a1)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  mbr_uid_to_uuid(a1, uu);
  return (id)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:uu];
}

id NECopyUserUUIDFromXPCEUID(_xpc_connection_s *a1)
{
  uid_t euid = xpc_connection_get_euid(a1);
  return NECopyUserUUIDSimple(euid);
}

uint64_t NEGetConsoleUserUID()
{
  uid_t v0 = getpwnam("mobile");
  if (v0) {
    return v0->pw_uid;
  }
  else {
    return 501LL;
  }
}

id NECopyConsoleUserUUID()
{
  uid_t v0 = getpwnam("mobile");
  if (v0) {
    return NECopyUserUUIDSimple(v0->pw_uid);
  }
  else {
    return NECopyUserUUIDSimple(0x1F5u);
  }
}

BOOL NEUserUUIDIsSynthesized(void *a1)
{
  if (!a1) {
    return 0LL;
  }
  [a1 UUIDString];
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  BOOL v2 = objc_msgSend( v1,  "compare:options:range:",  @"FFFFEEEE-DDDD-CCCC-BBBB-AAAA",  1,  0,  objc_msgSend(@"FFFFEEEE-DDDD-CCCC-BBBB-AAAA", "length")) == 0;

  return v2;
}

uint64_t NECheckConfigurationUserUUID(void *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  NECopyConsoleUserUUID();
  BOOL v2 = (void *)objc_claimAutoreleasedReturnValue();
  NEGetRootUUID();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v1)
  {
    uint64_t v4 = 0LL;
    if ([v1 count] && v2 && v3)
    {
      __int128 v14 = 0u;
      __int128 v15 = 0u;
      __int128 v12 = 0u;
      __int128 v13 = 0u;
      id v5 = v1;
      uint64_t v6 = [v5 countByEnumeratingWithState:&v12 objects:v17 count:16];
      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = *(void *)v13;
        while (2)
        {
          for (uint64_t i = 0LL; i != v7; ++i)
          {
            if (*(void *)v13 != v8) {
              objc_enumerationMutation(v5);
            }
            unsigned int v10 = *(void **)(*((void *)&v12 + 1) + 8 * i);
            if ((objc_msgSend(v10, "isEqual:", v2, (void)v12) & 1) == 0
              && ([v10 isEqual:v3] & 1) == 0)
            {
              [v10 getUUIDBytes:uu];
              if (!uuid_is_null(uu)) {
                continue;
              }
            }

            uint64_t v4 = 1LL;
            goto LABEL_19;
          }

          uint64_t v7 = [v5 countByEnumeratingWithState:&v12 objects:v17 count:16];
          uint64_t v4 = 0LL;
          if (v7) {
            continue;
          }
          break;
        }
      }

      else
      {
        uint64_t v4 = 0LL;
      }

id NEGetRootUUID()
{
  if (NEGetRootUUID_onceToken != -1) {
    dispatch_once(&NEGetRootUUID_onceToken, &__block_literal_global_13_22378);
  }
  return (id)NEGetRootUUID_rootUUID;
}

void __NEGetRootUUID_block_invoke()
{
  uint64_t v0 = NECopyUserUUIDSimple(0);
  id v1 = (void *)NEGetRootUUID_rootUUID;
  NEGetRootUUID_rootUUID = v0;
}

id NEGetNullUUID()
{
  if (NEGetNullUUID_onceToken != -1) {
    dispatch_once(&NEGetNullUUID_onceToken, &__block_literal_global_22381);
  }
  return (id)NEGetNullUUID_nullUUID;
}

void __NEGetNullUUID_block_invoke()
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  uuid_clear(uu);
  uint64_t v0 = [objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:uu];
  id v1 = (void *)NEGetNullUUID_nullUUID;
  NEGetNullUUID_nullUUID = v0;
}

id NEGetBundleIdentifierFromAppID(void *a1)
{
  id v1 = a1;
  if ((unint64_t)[v1 length] < 0xC)
  {
    BOOL v2 = 0LL;
  }

  else
  {
    objc_msgSend(v1, "substringWithRange:", 11, objc_msgSend(v1, "length") - 11);
    BOOL v2 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v2;
}

uint64_t NEGetSystemWakeTime()
{
  return objc_msgSend(objc_alloc(MEMORY[0x189603F50]), "initWithTimeIntervalSinceReferenceDate:", 0.0, 0);
}

void neZeroOutNSData(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    id v3 = v1;
    rsize_t v2 = [v1 length];
    id v1 = v3;
    if (v2)
    {
      memset_s((void *)[v3 bytes], v2, 0, v2);
      id v1 = v3;
    }
  }
}

id trimURL(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    rsize_t v2 = v1;
    [v1 port];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();

    if (v3)
    {
      uint64_t v4 = (void *)NSString;
      [v2 port];
      id v5 = (void *)objc_claimAutoreleasedReturnValue();
      [v4 stringWithFormat:@":%@", v5];
      uint64_t v6 = (__CFString *)objc_claimAutoreleasedReturnValue();
    }

    else
    {
      uint64_t v6 = &stru_18A0915E8;
    }

    [v2 host];
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    [MEMORY[0x189608DF8] endpointWithHostname:v8 port:@"0"];
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0 && [v9 addressFamily] == 30)
    {
      uint64_t v10 = [objc_alloc(NSString) initWithFormat:@"[%@]", v8];

      uint64_t v8 = (void *)v10;
    }

    __CFString v11 = (void *)MEMORY[0x189604030];
    __int128 v12 = (void *)NSString;
    [v2 scheme];
    __int128 v13 = (void *)objc_claimAutoreleasedReturnValue();
    [v2 path];
    __int128 v14 = (void *)objc_claimAutoreleasedReturnValue();
    if (v14)
    {
      [v2 path];
      __int128 v15 = (__CFString *)objc_claimAutoreleasedReturnValue();
    }

    else
    {
      __int128 v15 = &stru_18A0915E8;
    }

    [v12 stringWithFormat:@"%@://%@%@%@", v13, v8, v6, v15];
    UInt8 v16 = (void *)objc_claimAutoreleasedReturnValue();
    [v11 URLWithString:v16];
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();

    if (v14) {
  }
    }

  else
  {
    uint64_t v7 = 0LL;
  }

  return v7;
}

id createEthernetAddressFromString(void *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  [v1 componentsSeparatedByString:@":"];
  rsize_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  if ([v2 count] == 6)
  {
    id v3 = objc_alloc_init(MEMORY[0x189603FB8]);
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    id v4 = v2;
    uint64_t v5 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)v17;
      while (2)
      {
        for (uint64_t i = 0LL; i != v6; ++i)
        {
          if (*(void *)v17 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v9 = *(void **)(*((void *)&v16 + 1) + 8 * i);
          if (![v9 length])
          {
            ne_log_obj();
            __int128 v12 = (void *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_ERROR))
            {
LABEL_19:

              goto LABEL_20;
            }

            *(_DWORD *)__int128 buf = 138412290;
            id v22 = v1;
            __int128 v13 = "Ethernet address string %@ is missing a byte";
LABEL_23:
            _os_log_error_impl(&dword_1876B1000, (os_log_t)v12, OS_LOG_TYPE_ERROR, v13, buf, 0xCu);
            goto LABEL_19;
          }

          __endptr = 0LL;
          uint64_t v10 = strtol((const char *)[v9 UTF8String], &__endptr, 16);
          if (*__endptr || v10 > 255 || v10 < 0)
          {
            ne_log_obj();
            __int128 v12 = (void *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_ERROR)) {
              goto LABEL_19;
            }
            *(_DWORD *)__int128 buf = 138412290;
            id v22 = v1;
            __int128 v13 = "Ethernet address string %@ has an invalid byte";
            goto LABEL_23;
          }

          buf[0] = v10;
          [v3 appendBytes:buf length:1];
        }

        uint64_t v6 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
        if (v6) {
          continue;
        }
        break;
      }
    }

    __CFString v11 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithData:v3];
  }

  else
  {
    ne_log_obj();
    id v3 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412546;
      id v22 = v1;
      __int16 v23 = 1024;
      int v24 = 6;
      _os_log_error_impl( &dword_1876B1000,  (os_log_t)v3,  OS_LOG_TYPE_ERROR,  "Ethernet address string %@ does not have %d bytes",  buf,  0x12u);
    }

id NECopyETLDPlusOne(void *a1)
{
  id v1 = (void *)MEMORY[0x189607810];
  id v2 = a1;
  [v1 characterSetWithCharactersInString:@"."];
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 stringByTrimmingCharactersInSet:v3];
  id v4 = (void *)objc_claimAutoreleasedReturnValue();

  [v4 componentsSeparatedByString:@"."];
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  if ((unint64_t)[v5 count] >= 2)
  {
    objc_msgSend(v5, "subarrayWithRange:", objc_msgSend(v5, "count") - 2, 2);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    [v7 componentsJoinedByString:@"."];
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  return v6;
}

uint64_t NEPIDByName(const char *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  *(void *)__int128 v19 = 0x600000001LL;
  int v14 = 0;
  size_t v13 = 4LL;
  if (sysctl(v19, 2u, &v14, &v13, 0LL, 0LL) < 0)
  {
    uint64_t v9 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      __CFString v11 = __error();
      __int128 v12 = strerror(*v11);
      int buffer = 136315394;
      __int128 v16 = "NEKernMaxProc";
      __int16 v17 = 2080;
      __int128 v18 = v12;
      _os_log_error_impl( &dword_1876B1000,  v9,  OS_LOG_TYPE_ERROR,  "%s: Failed to get max proc count (%s)",  (uint8_t *)&buffer,  0x16u);
    }

    return 0LL;
  }

  if (!v14) {
    return 0LL;
  }
  int v2 = 4 * v14;
  id v3 = malloc(4LL * v14);
  if (!v3) {
    return 0LL;
  }
  id v4 = v3;
  int v5 = proc_listallpids(v3, v2);
  if (v5 < 1)
  {
LABEL_9:
    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = v5;
    while (!proc_name(v4[v6], &buffer, 0x64u) || strcmp((const char *)&buffer, a1))
    {
      if (v7 == ++v6) {
        goto LABEL_9;
      }
    }

    uint64_t v8 = v4[v6];
  }

  free(v4);
  return v8;
}

uint64_t NECopySigningIdentifierForPIDwithAuditToken()
{
  uint64_t result = ne_copy_signing_identifier_for_pid_with_audit_token();
  if (result)
  {
    id v1 = (void *)result;
    uint64_t v2 = _CFXPCCreateCFObjectFromXPCObject();
    xpc_release(v1);
    return v2;
  }

  return result;
}

uint64_t NECopySigningIdentifierForPID()
{
  return NECopySigningIdentifierForPIDwithAuditToken();
}

CFStringRef NECopySigningIdentifierForXPCMessage(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1 || MEMORY[0x1895ADD58]() != MEMORY[0x1895F9250])
  {
    uint64_t v2 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    buf.val[0] = 136315138;
    *(void *)&buf.val[1] = "NECopySigningIdentifierForXPCMessage";
    uint64_t v10 = "XPC object passed to %s is NULL or is not a dictionary";
    p_audit_token_t buf = &buf;
    __int128 v12 = v2;
    uint32_t v13 = 12;
LABEL_15:
    _os_log_error_impl(&dword_1876B1000, v12, OS_LOG_TYPE_ERROR, v10, (uint8_t *)p_buf, v13);
    return 0LL;
  }

  xpc_dictionary_get_audit_token();
  int v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  audit_token_t cf = buf;
  uint64_t v6 = SecTaskCreateWithAuditToken(v5, &cf);
  if (!v6)
  {
    uint64_t v9 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    LOWORD(cf.val[0]) = 0;
    uint64_t v10 = "Failed to create a task from audit token";
    p_audit_token_t buf = &cf;
    __int128 v12 = v9;
    uint32_t v13 = 2;
    goto LABEL_15;
  }

  uint64_t v7 = v6;
  *(void *)cf.val = 0LL;
  CFStringRef v3 = SecTaskCopySigningIdentifier(v6, (CFErrorRef *)&cf);
  if (*(void *)cf.val)
  {
    uint64_t v8 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      remote_connectiouint64_t n = xpc_dictionary_get_remote_connection(a1);
      pid_t pid = xpc_connection_get_pid(remote_connection);
      *(_DWORD *)__int16 v17 = 67109120;
      pid_t v18 = pid;
      _os_log_error_impl( &dword_1876B1000,  v8,  OS_LOG_TYPE_ERROR,  "Failed to get the signing identifier of process %d",  v17,  8u);
    }

    CFRelease(*(CFTypeRef *)cf.val);
  }

  CFRelease(v7);
  return v3;
}

BOOL NEAuditTokenForPID(int pid, integer_t *a2)
{
  kern_return_t v4;
  mach_error_t v5;
  os_log_s *v6;
  BOOL result;
  char *v8;
  const char *v9;
  kern_return_t v10;
  mach_error_t v11;
  char *v12;
  mach_msg_type_number_t task_info_outCnt;
  mach_port_name_t target_task;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  mach_error_t v18;
  __int16 v19;
  char *v20;
  uint64_t v21;
  unsigned int v21 = *MEMORY[0x1895F89C0];
  task_info_outCnt = 8;
  id v4 = task_for_pid(*MEMORY[0x1895FBBE0], pid, &target_task);
  if (v4)
  {
    int v5 = v4;
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    uint64_t v8 = mach_error_string(v5);
    *(_DWORD *)audit_token_t buf = 67109634;
    __int128 v16 = pid;
    __int16 v17 = 1024;
    pid_t v18 = v5;
    __int128 v19 = 2080;
    uint64_t v20 = v8;
    uint64_t v9 = "task_for_pid(mach_task_self(), %d, &task) => %d (%s)\n";
LABEL_7:
    _os_log_debug_impl(&dword_1876B1000, v6, OS_LOG_TYPE_DEBUG, v9, buf, 0x18u);
    return 0LL;
  }

  uint64_t v10 = task_info(target_task, 0xFu, a2, &task_info_outCnt);
  if (v10)
  {
    __CFString v11 = v10;
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    __int128 v12 = mach_error_string(v11);
    *(_DWORD *)audit_token_t buf = 67109634;
    __int128 v16 = pid;
    __int16 v17 = 1024;
    pid_t v18 = v11;
    __int128 v19 = 2080;
    uint64_t v20 = v12;
    uint64_t v9 = "task_info(mach_task_self(), %d, TASK_AUDIT_TOKEN) => %d (%s)\n";
    goto LABEL_7;
  }

  return 1LL;
}

uint64_t NEGIDForAuditToken()
{
  return 0LL;
}

uint64_t NEUIDForAuditToken()
{
  return 0LL;
}

uint64_t NECopyBootstrapPortForPID()
{
  return 0LL;
}

uint64_t NECopyAuditPortForAuditToken()
{
  return 0LL;
}

__CFDictionary *NEVirtualInterfaceCopyIPStateDictionary(uint64_t a1, int a2, int a3)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFStringRef v7 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], (const char *)(a1 + 265), 0x600u);
    if (a2 != 30)
    {
      if (a2 == 2)
      {
        if ((*(_BYTE *)(a1 + 312) & 1) != 0) {
          goto LABEL_8;
        }
        uint64_t v8 = *(__CFDictionary **)(a1 + 320);
        CFTypeID TypeID = CFArrayGetTypeID();
        if (!v8) {
          goto LABEL_26;
        }
        if (CFGetTypeID(v8) == TypeID && CFArrayGetCount(*(CFArrayRef *)(a1 + 320)) >= 1)
        {
LABEL_8:
          CFMutableDataRef Mutable = CFDictionaryCreateMutable(v6, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
          uint64_t v8 = Mutable;
          if (Mutable)
          {
            CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960C600], v7);
            __CFString v11 = *(const void **)(a1 + 320);
            CFTypeID v12 = CFArrayGetTypeID();
            uint32_t v13 = (const void **)MEMORY[0x18960C718];
            if (v11 && CFGetTypeID(v11) == v12 && CFArrayGetCount(*(CFArrayRef *)(a1 + 320)))
            {
              int v14 = (const void *)*MEMORY[0x18960C6C0];
              __int128 v15 = *(const __CFString **)(a1 + 320);
            }

            else
            {
              int v26 = CFArrayCreateMutable(v6, 1LL, MEMORY[0x189605228]);
              if (v26)
              {
                __int16 v27 = v26;
                CFArrayAppendValue(v26, @"127.0.0.1");
                CFDictionarySetValue(v8, (const void *)*MEMORY[0x18960C6C0], v27);
                CFRelease(v27);
              }

              CFDictionarySetValue(v8, @"IsNULL", (const void *)*MEMORY[0x189604DE8]);
              int v14 = *v13;
              __int128 v15 = @"127.0.0.1";
            }

            CFDictionarySetValue(v8, v14, v15);
            int v28 = *(const void **)(a1 + 344);
            CFTypeID v29 = CFArrayGetTypeID();
            if (v28 && CFGetTypeID(v28) == v29 && CFArrayGetCount(*(CFArrayRef *)(a1 + 344)) >= 1) {
              CFDictionarySetValue(v8, (const void *)*MEMORY[0x18960C6B8], *(const void **)(a1 + 344));
            }
            if (a3)
            {
              int v30 = *(const __CFString **)(a1 + 472);
              if (v30) {
                NEVirtualInterfaceAddIPv4Route(a1, v30, @"255.255.255.255", 0LL, 1);
              }
            }

            uint64_t v31 = *(const void **)(a1 + 352);
            CFTypeID v32 = CFArrayGetTypeID();
            if (v31 && CFGetTypeID(v31) == v32 && CFArrayGetCount(*(CFArrayRef *)(a1 + 352)) >= 1) {
              CFDictionarySetValue(v8, (const void *)*MEMORY[0x18960C6E8], *(const void **)(a1 + 352));
            }
            uint32x4_t v33 = *(const void **)(a1 + 456);
            CFTypeID v34 = CFStringGetTypeID();
            if (v33 && CFGetTypeID(v33) == v34)
            {
              int32x4_t v35 = *v13;
              ValueAtIndex = *(const void **)(a1 + 456);
              uint64x2_t v37 = v8;
            }

            else
            {
              uint64x2_t v50 = *(const void **)(a1 + 320);
              CFTypeID v51 = CFArrayGetTypeID();
              if (!v50 || CFGetTypeID(v50) != v51 || CFArrayGetCount(*(CFArrayRef *)(a1 + 320)) < 1)
              {
LABEL_69:
                __int128 v53 = *(const void **)(a1 + 472);
                CFTypeID v54 = CFStringGetTypeID();
                if (v53 && CFGetTypeID(v53) == v54) {
                  CFDictionarySetValue(v8, @"ServerAddress", *(const void **)(a1 + 472));
                }
                goto LABEL_26;
              }

              uint64x2_t v52 = *v13;
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 320), 0LL);
              uint64x2_t v37 = v8;
              int32x4_t v35 = v52;
            }

            CFDictionarySetValue(v37, v35, ValueAtIndex);
            goto LABEL_69;
          }

uint64_t NEVirtualInterfaceAddIPv4Route( uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, int a5)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  int v25 = 0;
  if (!a1)
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)audit_token_t buf = 0;
    uint64_t v8 = "interface is NULL";
    goto LABEL_16;
  }

  if (*(_BYTE *)(a1 + 264))
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)audit_token_t buf = 0;
    uint64_t v8 = "interface created from socket";
LABEL_16:
    _os_log_error_impl(&dword_1876B1000, v6, OS_LOG_TYPE_ERROR, v8, buf, 2u);
    return 0LL;
  }

  CFTypeID TypeID = CFStringGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)audit_token_t buf = 0;
    uint64_t v8 = "address is not a CFString";
    goto LABEL_16;
  }

  CFDataRef v14 = NECreateAddressDataFromString(a2, 0LL, &v25);
  if (!v14)
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)audit_token_t buf = 0;
    uint64_t v8 = "NECreateAddressDataFromString failed";
    goto LABEL_16;
  }

  CFDataRef v15 = v14;
  if (v25 != 2)
  {
    CFRelease(v14);
    return 0LL;
  }

  int v16 = *CFDataGetBytePtr(v14);
  CFRelease(v15);
  if (v16 == 127)
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)audit_token_t buf = 0;
    uint64_t v8 = "address is loopback";
    goto LABEL_16;
  }

  uint64_t v17 = 352LL;
  if (!a5) {
    uint64_t v17 = 344LL;
  }
  pid_t v18 = *(void **)(a1 + v17);
  CFTypeID v19 = CFArrayGetTypeID();
  if (!v18) {
    return 0LL;
  }
  if (CFGetTypeID(v18) != v19) {
    return 0LL;
  }
  if (isA_CFString(a3))
  {
    int v20 = v25;
  }

  if (isA_CFString(a4))
  {
    int v21 = v25;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  uint64_t result = (uint64_t)isA_CFDictionary(Mutable);
  if (result)
  {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960C6F8], a2);
    if (isA_CFString(a3)) {
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960C710], a3);
    }
    if (isA_CFString(a4)) {
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960C700], a4);
    }
    if (nelog_is_extra_vpn_logging_enabled())
    {
      __int16 v23 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)audit_token_t buf = 136316162;
        uint64_t v27 = a1 + 265;
        int v24 = "";
        __int16 v28 = 2080;
        if (a5) {
          int v24 = "excluded ";
        }
        CFTypeID v29 = v24;
        __int16 v30 = 2112;
        uint64_t v31 = a2;
        __int16 v32 = 2112;
        uint32x4_t v33 = a3;
        __int16 v34 = 2112;
        int32x4_t v35 = a4;
        _os_log_debug_impl( &dword_1876B1000,  v23,  OS_LOG_TYPE_DEBUG,  "%s: added %sIPv4 route to %@ netmask %@ gateway %@",  buf,  0x34u);
      }
    }

    CFArrayAppendValue((CFMutableArrayRef)v18, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 1LL;
  }

  return result;
}

uint64_t NEVirtualInterfaceAddIPv6Route( uint64_t a1, const __CFString *a2, const void *a3, const __CFString *a4, int a5)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  int v23 = 0;
  if (!a1)
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)audit_token_t buf = 0;
    uint64_t v8 = "interface is NULL";
    goto LABEL_16;
  }

  if (*(_BYTE *)(a1 + 264))
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)audit_token_t buf = 0;
    uint64_t v8 = "interface created from socket";
    goto LABEL_16;
  }

  CFTypeID TypeID = CFStringGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)audit_token_t buf = 0;
    uint64_t v8 = "address is not a CFString";
    goto LABEL_16;
  }

  CFDataRef v14 = NECreateAddressDataFromString(a2, 0LL, &v23);
  if (!v14)
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)audit_token_t buf = 0;
    uint64_t v8 = "NECreateAddressDataFromString failed";
    goto LABEL_16;
  }

  CFDataRef v15 = v14;
  if (v23 != 30)
  {
    CFRelease(v14);
    return 0LL;
  }

  if (CFDataGetLength(v14) <= 15)
  {
    CFRelease(v15);
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)audit_token_t buf = 0;
    uint64_t v8 = "NECreateAddressDataFromString result too short";
    goto LABEL_16;
  }

  v35.locatiouint64_t n = 0LL;
  v35.__int16 length = 16LL;
  CFDataGetBytes(v15, v35, (UInt8 *)&v22);
  CFRelease(v15);
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v22, (int32x4_t)xmmword_187873260)))) & 1) != 0)
  {
    uint64_t v16 = 368LL;
    if (!a5) {
      uint64_t v16 = 360LL;
    }
    uint64_t v17 = *(void **)(a1 + v16);
    uint64_t result = (uint64_t)isA_CFArray(v17);
    if (result)
    {
      if (isA_CFString(a4))
      {
        int v18 = v23;
      }

      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      uint64_t result = (uint64_t)isA_CFDictionary(Mutable);
      if (result)
      {
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960C768], a2);
        if (isA_CFNumber(a3)) {
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960C780], a3);
        }
        if (isA_CFString(a4)) {
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960C770], a4);
        }
        if (nelog_is_extra_vpn_logging_enabled())
        {
          int v20 = (os_log_s *)ne_log_obj();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)audit_token_t buf = 136316162;
            uint64_t v25 = a1 + 265;
            int v21 = "";
            __int16 v26 = 2080;
            if (a5) {
              int v21 = "excluded ";
            }
            uint64_t v27 = v21;
            __int16 v28 = 2112;
            CFTypeID v29 = a2;
            __int16 v30 = 2112;
            uint64_t v31 = a3;
            __int16 v32 = 2112;
            uint32x4_t v33 = a4;
            _os_log_debug_impl( &dword_1876B1000,  v20,  OS_LOG_TYPE_DEBUG,  "%s: added %sIPv6 route to %@ plen %@ gateway %@",  buf,  0x34u);
          }
        }

        CFArrayAppendValue((CFMutableArrayRef)v17, Mutable);
        if (Mutable) {
          CFRelease(Mutable);
        }
        return 1LL;
      }
    }
  }

  else
  {
    uint64_t v6 = (os_log_s *)ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      *(_WORD *)audit_token_t buf = 0;
      uint64_t v8 = "address is loopback";
LABEL_16:
      _os_log_error_impl(&dword_1876B1000, v6, OS_LOG_TYPE_ERROR, v8, buf, 2u);
      return 0LL;
    }
  }

  return result;
}

const void *isA_CFArray(const void *a1)
{
  CFTypeID TypeID = CFArrayGetTypeID();
  if (!a1) {
    return 0LL;
  }
  if (CFGetTypeID(a1) == TypeID) {
    return a1;
  }
  return 0LL;
}

const void *isA_CFString(const void *a1)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (!a1) {
    return 0LL;
  }
  if (CFGetTypeID(a1) == TypeID) {
    return a1;
  }
  return 0LL;
}

const void *isA_CFDictionary(const void *a1)
{
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!a1) {
    return 0LL;
  }
  if (CFGetTypeID(a1) == TypeID) {
    return a1;
  }
  return 0LL;
}

const void *isA_CFNumber(const void *a1)
{
  CFTypeID TypeID = CFNumberGetTypeID();
  if (!a1) {
    return 0LL;
  }
  if (CFGetTypeID(a1) == TypeID) {
    return a1;
  }
  return 0LL;
}

CFStringRef NEVirtualInterfaceCopyName(CFStringRef result)
{
  if (result) {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], (const char *)&result[8].info + 1, 0x600u);
  }
  return result;
}

__CFDictionary *NEVirtualInterfaceCopyRouteCacheFromRoutes(const __CFArray *a1, int a2)
{
  if (!a1) {
    return 0LL;
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    return 0LL;
  }
  uint64_t v5 = Count;
  uint64_t v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFDictionaryRef theDict = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFStringRef v7 = (const CFArrayCallBacks *)MEMORY[0x189605228];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v6, 0LL, MEMORY[0x189605228]);
  uint64_t v9 = CFArrayCreateMutable(v6, 0LL, v7);
  if (v5 >= 1)
  {
    CFIndex v10 = 0LL;
    CFRange v35 = (const void *)*MEMORY[0x18960C780];
    key = (void *)*MEMORY[0x18960C768];
    uint32x4_t v33 = (void *)*MEMORY[0x18960C710];
    uint64_t v34 = (void *)*MEMORY[0x18960C6F8];
    uint64_t v31 = Mutable;
    uint64_t v32 = v5;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v10);
      if (!ValueAtIndex) {
        goto LABEL_35;
      }
      CFTypeID v12 = ValueAtIndex;
      if (a2) {
        break;
      }
      Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, v34);
      int v20 = (const __CFString *)CFDictionaryGetValue(v12, v33);
      *(_DWORD *)UInt8 bytes = 2;
      int v40 = 2;
      CFDataRef v21 = NECreateAddressDataFromString(Value, 0LL, (int *)bytes);
      CFDataRef v22 = NECreateAddressDataFromString(v20, 0LL, &v40);
      CFDataRef v23 = v22;
      if (*(_DWORD *)bytes == 2 && v21)
      {
        CFArrayAppendValue(Mutable, v21);
        if (v40 == 2 && v23)
        {
          CFArrayAppendValue(v9, v23);
        }

        else
        {
          *(_DWORD *)uint64x2_t v39 = -1;
          CFDataRef v27 = CFDataCreate(v6, v39, 4LL);
          CFArrayAppendValue(v9, v27);
          if (v27) {
            CFRelease(v27);
          }
        }
      }

      else if (!v21)
      {
        if (!v22) {
          goto LABEL_35;
        }
LABEL_33:
        int v24 = (const __CFString *)v23;
LABEL_34:
        CFRelease(v24);
        goto LABEL_35;
      }

      CFRelease(v21);
      if (v23) {
        goto LABEL_33;
      }
LABEL_35:
      if (v5 == ++v10) {
        goto LABEL_36;
      }
    }

    uint32_t v13 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, key);
    int v14 = NEGetIntFromDictionary(v12, v35, 0LL);
    CFDataRef v15 = NECreateIPv6AddressMaskStringFromPrefix(v14);
    *(_DWORD *)uint64x2_t v39 = 30;
    int v40 = 30;
    CFDataRef v16 = NECreateAddressDataFromString(v13, 0LL, &v40);
    CFDataRef v17 = NECreateAddressDataFromString(v15, 0LL, (int *)v39);
    CFDataRef v18 = v17;
    if (v40 == 30 && v16)
    {
      CFArrayAppendValue(Mutable, v16);
      if (*(_DWORD *)v39 == 30 && v18)
      {
        CFArrayAppendValue(v9, v18);
      }

      else
      {
        *(void *)UInt8 bytes = -1LL;
        uint64_t v38 = -1LL;
        uint64_t v25 = v6;
        CFDataRef v26 = CFDataCreate(v6, bytes, 16LL);
        CFArrayAppendValue(v9, v26);
        if (v26) {
          CFRelease(v26);
        }
        uint64_t v6 = v25;
        CFMutableDictionaryRef Mutable = v31;
        uint64_t v5 = v32;
      }
    }

    else if (!v16)
    {
      if (!v17) {
        goto LABEL_20;
      }
      goto LABEL_19;
    }

    CFRelease(v16);
    if (!v18)
    {
LABEL_20:
      if (v15)
      {
        int v24 = v15;
        goto LABEL_34;
      }

      goto LABEL_35;
    }

unint64_t NEVirtualInterfaceUpdateAdHocService(uint64_t a1)
{
  return NEVirtualInterfaceUpdateAdHocServiceReturnChanges(a1, 0LL, 1);
}

unint64_t NEVirtualInterfaceUpdateAdHocServiceReturnChanges(uint64_t a1, uint64_t *a2, int a3)
{
  values[1] = *(void **)MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    uint64_t v88 = a1 + 265;
    CFStringRef v6 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], (const char *)(a1 + 265), 0x600u);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v5, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    CFMutableArrayRef v8 = CFArrayCreateMutable(v5, 0LL, MEMORY[0x189605228]);
    uint64_t v9 = (const __CFString *)*MEMORY[0x18960C548];
    CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity( v5,  (CFStringRef)*MEMORY[0x18960C548],  *(CFStringRef *)(a1 + 488),  (CFStringRef)*MEMORY[0x18960C588]);
    CFStringRef v11 = SCDynamicStoreKeyCreateNetworkServiceEntity( v5,  v9,  *(CFStringRef *)(a1 + 488),  (CFStringRef)*MEMORY[0x18960C590]);
    CFStringRef value = SCDynamicStoreKeyCreateNetworkServiceEntity( v5,  v9,  *(CFStringRef *)(a1 + 488),  (CFStringRef)*MEMORY[0x18960C580]);
    CFStringRef key = SCDynamicStoreKeyCreateNetworkServiceEntity( v5,  v9,  *(CFStringRef *)(a1 + 488),  (CFStringRef)*MEMORY[0x18960C5A8]);
    CFStringRef v89 = SCDynamicStoreKeyCreateNetworkServiceEntity( v5,  v9,  *(CFStringRef *)(a1 + 488),  (CFStringRef)*MEMORY[0x18960C5B0]);
    CFStringRef v90 = SCDynamicStoreKeyCreateNetworkServiceEntity(v5, v9, *(CFStringRef *)(a1 + 488), 0LL);
    if (a2) {
      *a2 = 0LL;
    }
    unint64_t v12 = 0LL;
    if (!v6 || !Mutable || !v8 || !NetworkServiceEntity || !v11)
    {
LABEL_177:
      if (!v6)
      {
LABEL_179:
        if (Mutable) {
          CFRelease(Mutable);
        }
        if (v8) {
          CFRelease(v8);
        }
        if (NetworkServiceEntity) {
          CFRelease(NetworkServiceEntity);
        }
        if (v11) {
          CFRelease(v11);
        }
        if (value) {
          CFRelease(value);
        }
        if (key) {
          CFRelease(key);
        }
        if (v90) {
          CFRelease(v90);
        }
        if (v89) {
          CFRelease(v89);
        }
        return v12;
      }

uint64_t NEVirtualInterfaceIsStateEqualToDynamicStoreState( const __SCDynamicStore *a1, unint64_t a2, CFStringRef key)
{
  unint64_t v4 = (unint64_t)SCDynamicStoreCopyValue(a1, key);
  if (!(v4 | a2)) {
    return 1LL;
  }
  CFStringRef v6 = (const void *)v4;
  if (v4 && a2)
  {
    uint64_t v7 = CFEqual((CFTypeRef)v4, (CFTypeRef)a2);
  }

  else
  {
    uint64_t v7 = 0LL;
    uint64_t result = 0LL;
    if (!v6) {
      return result;
    }
  }

  CFRelease(v6);
  return v7;
}

void NEVirtualInterfaceLogStateDictionaryKeys(uint64_t a1, uint64_t a2, CFDictionaryRef theDict)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!theDict)
  {
    unint64_t v12 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v14 = 136315394;
    uint64_t v15 = a1 + 265;
    __int16 v16 = 2080;
    uint64_t v17 = a2;
    uint32_t v13 = "%s: %s: NULL";
LABEL_10:
    _os_log_impl(&dword_1876B1000, v12, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v14, 0x16u);
    return;
  }

  CFIndex Count = CFDictionaryGetCount(theDict);
  if (!Count)
  {
    unint64_t v12 = (os_log_s *)ne_log_obj();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v14 = 136315394;
    uint64_t v15 = a1 + 265;
    __int16 v16 = 2080;
    uint64_t v17 = a2;
    uint32_t v13 = "%s: %s: empty";
    goto LABEL_10;
  }

  CFIndex v7 = Count;
  CFMutableArrayRef v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v9 = (const void **)MEMORY[0x1895AB6E8](*MEMORY[0x189604DB0], 8 * Count, 0LL);
  CFDictionaryGetKeysAndValues(theDict, v9, 0LL);
  CFArrayRef v10 = CFArrayCreate(v8, v9, v7, MEMORY[0x189605228]);
  CFAllocatorDeallocate(v8, v9);
  CFStringRef v11 = (os_log_s *)ne_log_large_obj();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 136315650;
    uint64_t v15 = a1 + 265;
    __int16 v16 = 2080;
    uint64_t v17 = a2;
    __int16 v18 = 2112;
    CFArrayRef v19 = v10;
    _os_log_impl(&dword_1876B1000, v11, OS_LOG_TYPE_DEFAULT, "%s: %s: %@", (uint8_t *)&v14, 0x20u);
  }

  CFRelease(v10);
}

_OWORD *NEVirtualInterfaceCreateNexusExtendedWithOptions( const __CFAllocator *a1, uint64_t a2, dispatch_object_s *a3, uint64_t a4, int a5, int a6, unsigned int a7, int a8, int a9, int a10, int a11, unsigned __int8 *uu, const void *a13)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  Base = NEVirtualInterfaceCreateBase(a1, a2, a3, a4);
  __int16 v18 = Base;
  if (!Base) {
    return v18;
  }
  int v51 = a9;
  int bytes = a8;
  int v49 = a11;
  int v50 = a10;
  uint64_t v19 = *((void *)Base + 32);
  if (v19 != 2)
  {
    if (v19 != 1)
    {
LABEL_63:
      CFTypeID v46 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)applier = 0;
        _os_log_error_impl( &dword_1876B1000,  v46,  OS_LOG_TYPE_ERROR,  "Failed to open interface control socket\n",  applier,  2u);
      }

      CFRelease(v18);
      return 0LL;
    }

    if ((a5 & 1) != 0)
    {
      xpc_object_t v20 = xpc_array_create(0LL, 0LL);
      *(_DWORD *)CFStringRef v48 = 1;
      xpc_object_t v21 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v21, "interface-option", 0x14uLL);
      xpc_dictionary_set_data(v21, "interface-option-data", v48, 4uLL);
      xpc_array_append_value(v20, v21);
      xpc_release(v21);
      if (a6)
      {
LABEL_6:
        *(_DWORD *)CFStringRef v48 = 4;
        xpc_object_t v22 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_uint64(v22, "interface-option", 1uLL);
        xpc_dictionary_set_data(v22, "interface-option-data", v48, 4uLL);
        xpc_array_append_value(v20, v22);
        xpc_release(v22);
      }
    }

    else
    {
      if (a8 | a7 | a9 | a10 | a11) {
        BOOL v28 = 0;
      }
      else {
        BOOL v28 = a13 == 0LL;
      }
      if (v28 && a6 == 0)
      {
        xpc_object_t v20 = 0LL;
        goto LABEL_42;
      }

      xpc_object_t v20 = xpc_array_create(0LL, 0LL);
      if (a6) {
        goto LABEL_6;
      }
    }

    if (a7 >= 2)
    {
      CFDataRef v23 = (os_log_s *)ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CFStringRef v48 = 0;
        _os_log_error_impl( &dword_1876B1000,  v23,  OS_LOG_TYPE_ERROR,  "Multiple channels unsupported on UserTunnel interfaces",  v48,  2u);
      }

      goto LABEL_63;
    }

    if (bytes)
    {
      xpc_object_t v30 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v30, "interface-option", 0x15uLL);
      xpc_dictionary_set_data(v30, "interface-option-data", &bytes, 4uLL);
      xpc_array_append_value(v20, v30);
      xpc_release(v30);
    }

    if (v51)
    {
      xpc_object_t v31 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v31, "interface-option", 0x16uLL);
      xpc_dictionary_set_data(v31, "interface-option-data", &v51, 4uLL);
      xpc_array_append_value(v20, v31);
      xpc_release(v31);
    }

    if (v50)
    {
      xpc_object_t v32 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v32, "interface-option", 0x19uLL);
      xpc_dictionary_set_data(v32, "interface-option-data", &v50, 4uLL);
      xpc_array_append_value(v20, v32);
      xpc_release(v32);
    }

    if (v49)
    {
      xpc_object_t v33 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v33, "interface-option", 0x1AuLL);
      xpc_dictionary_set_data(v33, "interface-option-data", &v49, 4uLL);
      xpc_array_append_value(v20, v33);
      xpc_release(v33);
    }

    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (a13 && CFGetTypeID(a13) == TypeID)
    {
      CFRange v35 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __NEVirtualInterfaceConnectSocket_block_invoke;
      uint64_t v54 = &__block_descriptor_tmp_43;
      xpc_object_t v55 = v20;
      xpc_dictionary_apply(v35, applier);
      xpc_release(v35);
    }

_OWORD *NEVirtualInterfaceCreateBase(const __CFAllocator *a1, uint64_t a2, dispatch_object_s *a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (__NEVirtualInterfaceInitialize_onceToken != -1) {
    dispatch_once(&__NEVirtualInterfaceInitialize_onceToken, &__block_literal_global_50);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v19 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      int v27 = 136315394;
      BOOL v28 = "NEVirtualInterfaceCreateBase";
      __int16 v29 = 1024;
      int v30 = 1234;
      _os_log_error_impl( &dword_1876B1000,  v19,  OS_LOG_TYPE_ERROR,  "NEVirtualInterface Failure in %s at line %d.",  (uint8_t *)&v27,  0x12u);
    }

    return 0LL;
  }

  uint64_t v9 = Instance;
  Instance[1] = 0u;
  CFArrayRef v10 = (dispatch_object_s **)(Instance + 1);
  Instance[30] = 0u;
  Instance[31] = 0u;
  Instance[28] = 0u;
  Instance[29] = 0u;
  Instance[26] = 0u;
  Instance[27] = 0u;
  Instance[24] = 0u;
  Instance[25] = 0u;
  Instance[22] = 0u;
  Instance[23] = 0u;
  Instance[20] = 0u;
  Instance[21] = 0u;
  Instance[18] = 0u;
  Instance[19] = 0u;
  Instance[16] = 0u;
  Instance[17] = 0u;
  Instance[14] = 0u;
  Instance[15] = 0u;
  Instance[12] = 0u;
  Instance[13] = 0u;
  Instance[10] = 0u;
  Instance[11] = 0u;
  Instance[8] = 0u;
  Instance[9] = 0u;
  Instance[6] = 0u;
  Instance[7] = 0u;
  Instance[4] = 0u;
  Instance[5] = 0u;
  Instance[2] = 0u;
  Instance[3] = 0u;
  CFStringRef v11 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  unint64_t v12 = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x189604DB0]);
  if (!v12)
  {
    xpc_object_t v20 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      int v27 = 136315394;
      BOOL v28 = "NEVirtualInterfaceCreateBase";
      __int16 v29 = 1024;
      int v30 = 1242;
      xpc_object_t v21 = "NEVirtualInterface Failure in %s at line %d.";
LABEL_18:
      xpc_object_t v22 = v20;
      uint32_t v23 = 18;
LABEL_19:
      _os_log_error_impl(&dword_1876B1000, v22, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&v27, v23);
    }

uint64_t __NEVirtualInterfaceConnectSocket_block_invoke(uint64_t a1, const char *a2, void *a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_value(v6, a2, a3);
  xpc_array_append_value(*(xpc_object_t *)(a1 + 32), v6);
  xpc_release(v6);
  return 1LL;
}

uint64_t NEVirtualInterfaceConnectSocketInner(uint64_t a1, uint64_t a2, _BYTE *a3, unsigned int *a4, int a5)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  int v20 = 1;
  uint64_t KernelControlSocketExtended = NEHelperGetKernelControlSocketExtended();
  uint64_t v9 = KernelControlSocketExtended;
  if ((KernelControlSocketExtended & 0x80000000) != 0)
  {
    uint32_t v13 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)audit_token_t buf = 0;
      _os_log_error_impl( &dword_1876B1000,  v13,  OS_LOG_TYPE_ERROR,  "Cannot get kernel control socket from NEHelper\n",  buf,  2u);
    }

    if ((_DWORD)v9 == -1)
    {
      if (!a4) {
        return 0xFFFFFFFFLL;
      }
LABEL_12:
      *a4 = 0;
      return 0xFFFFFFFFLL;
    }

uint64_t virtual_interface_get_properties(int a1, _BYTE *a2, unsigned int *a3, uint64_t *a4, void *a5)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  socklen_t v22 = 24;
  if (a2)
  {
    if (*a2)
    {
      CFArrayRef v10 = (os_log_s *)ne_log_obj();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_8;
      }
      *(_DWORD *)audit_token_t buf = 136315138;
      SCDynamicStoreRef v24 = a2;
      int v11 = "Using interface name %s";
      goto LABEL_5;
    }

    int v15 = getsockopt(a1, 2, 2, a2, &v22);
    int v16 = (os_log_s *)ne_log_obj();
    CFArrayRef v10 = v16;
    if (v15)
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        int v20 = *__error();
        *(_DWORD *)audit_token_t buf = 67109120;
        LODWORD(v24) = v20;
        _os_log_error_impl( &dword_1876B1000,  v10,  OS_LOG_TYPE_ERROR,  "getsockopt ifname failed on kernel control socket (errno = %d)\n",  buf,  8u);
        if (!a3)
        {
LABEL_20:
          if (a4)
          {
            uint64_t result = 0LL;
            *a4 = 0LL;
            return result;
          }

          return 0LL;
        }
      }

      else if (!a3)
      {
        goto LABEL_20;
      }

      *a3 = 0;
      goto LABEL_20;
    }

    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)audit_token_t buf = 136315138;
      SCDynamicStoreRef v24 = a2;
      int v11 = "getsockopt(UTUN_OPT_IFNAME) returned virtual interface name %s";
LABEL_5:
      _os_log_impl(&dword_1876B1000, v10, OS_LOG_TYPE_DEFAULT, v11, buf, 0xCu);
    }
  }

  else
  {
    unint64_t v12 = (os_log_s *)ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)audit_token_t buf = 134218240;
      SCDynamicStoreRef v24 = 0LL;
      __int16 v25 = 1024;
      int v26 = 24;
      _os_log_error_impl( &dword_1876B1000,  v12,  OS_LOG_TYPE_ERROR,  "Provider name buffer is invalid (%p, %u)",  buf,  0x12u);
    }
  }

__CFString *__NEVirtualInterfaceCopyDescription(const void *a1)
{
  uint64_t v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0LL);
  CFStringAppendFormat(Mutable, 0LL, @"<NEVirtualInterface, %p [%p]> {", a1, v2);
  CFStringAppendFormat(Mutable, 0LL, @"}");
  return Mutable;
}

void NEVirtualInterfaceTearDown(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (os_log_s *)ne_log_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v29 = 136315138;
    uint64_t v30 = a1 + 265;
    _os_log_impl(&dword_1876B1000, v2, OS_LOG_TYPE_DEFAULT, "Tearing down %s", (uint8_t *)&v29, 0xCu);
  }

  if (a1)
  {
    CFStringRef v3 = *(const void **)(a1 + 488);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 48_Block_object_dispose(&STACK[0x2A0], 8) = 0LL;
    }

    unint64_t v4 = *(const void **)(a1 + 496);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(a1 + 496) = 0LL;
    }

    uint64_t v5 = *(const void **)(a1 + 320);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a1 + 320) = 0LL;
    }

    xpc_object_t v6 = *(const void **)(a1 + 328);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(a1 + 32_Block_object_dispose(&STACK[0x2A0], 8) = 0LL;
    }

    CFIndex v7 = *(const void **)(a1 + 336);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(a1 + 336) = 0LL;
    }

    CFMutableArrayRef v8 = *(const void **)(a1 + 344);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(a1 + 344) = 0LL;
    }

    uint64_t v9 = *(const void **)(a1 + 352);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 352) = 0LL;
    }

    CFArrayRef v10 = *(const void **)(a1 + 360);
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a1 + 360) = 0LL;
    }

    int v11 = *(const void **)(a1 + 368);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(a1 + 36_Block_object_dispose(&STACK[0x2A0], 8) = 0LL;
    }

    unint64_t v12 = *(const void **)(a1 + 416);
    if (v12)
    {
      CFRelease(v12);
      *(void *)(a1 + 416) = 0LL;
    }

    int v13 = *(const void **)(a1 + 432);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(a1 + 432) = 0LL;
    }

    uint64_t v14 = *(const void **)(a1 + 424);
    if (v14)
    {
      CFRelease(v14);
      *(void *)(a1 + 424) = 0LL;
    }

    int v15 = *(const void **)(a1 + 392);
    if (v15)
    {
      CFRelease(v15);
      *(void *)(a1 + 392) = 0LL;
    }

    int v16 = *(const void **)(a1 + 400);
    if (v16)
    {
      CFRelease(v16);
      *(void *)(a1 + 400) = 0LL;
    }

    int v17 = *(const void **)(a1 + 448);
    if (v17)
    {
      CFRelease(v17);
      *(void *)(a1 + 44_Block_object_dispose(&STACK[0x2A0], 8) = 0LL;
    }

    int v18 = *(const void **)(a1 + 456);
    if (v18)
    {
      CFRelease(v18);
      *(void *)(a1 + 456) = 0LL;
    }

    int v19 = *(const void **)(a1 + 464);
    if (v19)
    {
      CFRelease(v19);
      *(void *)(a1 + 464) = 0LL;
    }

    int v20 = *(const void **)(a1 + 472);
    if (v20)
    {
      CFRelease(v20);
      *(void *)(a1 + 472) = 0LL;
    }

    socklen_t v21 = *(const void **)(a1 + 480);
    if (v21)
    {
      CFRelease(v21);
      *(void *)(a1 + 480) = 0LL;
    }

    NEVirtualInterfaceDisableChannel(a1);
    if (*(void *)(a1 + 256) != 2LL)
    {
      NEVirtualInterfaceAdjustReadBufferSize(a1, 0);
      NEVirtualInterfaceAdjustSendCount(a1, 0);
    }

    int v22 = *(_DWORD *)(a1 + 308);
    if (v22 != -1)
    {
      close(v22);
      *(_DWORD *)(a1 + 30_Block_object_dispose(&STACK[0x2A0], 8) = -1;
    }

    uint64_t v23 = *(const void **)(a1 + 32);
    if (v23)
    {
      _Block_release(v23);
      *(void *)(a1 + 32) = 0LL;
    }

    SCDynamicStoreRef v24 = *(const void **)(a1 + 48);
    if (v24)
    {
      _Block_release(v24);
      *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2A0], 8) = 0LL;
    }

    __int16 v25 = *(const void **)(a1 + 40);
    if (v25)
    {
      _Block_release(v25);
      *(void *)(a1 + 40) = 0LL;
    }

    int v26 = *(dispatch_object_s **)(a1 + 16);
    if (v26)
    {
      dispatch_release(v26);
      *(void *)(a1 + 16) = 0LL;
    }

    int v27 = *(_DWORD *)(a1 + 296);
    if (v27 != -1)
    {
      close(v27);
      *(_DWORD *)(a1 + 296) = -1;
    }

    BOOL v28 = *(const void **)(a1 + 504);
    if (v28)
    {
      CFRelease(v28);
      *(void *)(a1 + 504) = 0LL;
    }

    if (*(void *)(a1 + 256) == 4LL) {
      NEHelperInterfaceDestroy();
    }
  }