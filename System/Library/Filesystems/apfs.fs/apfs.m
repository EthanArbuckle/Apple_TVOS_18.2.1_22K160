char *sub_100001050()
{
  char *result;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  byte_100070EC8 = 1;
  byte_100070EC9 = 0;
  if (!sub_100034B44( (uint64_t)&unk_100070ED0,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  16,  25,  0,  0LL,  (uint64_t)sub_10002D3D0)) {
    sub_100036C00((uint64_t)&unk_100070ED0, 0LL, 0);
  }
  result = (char *)sub_10001A7FC((uint64_t)&unk_100070ED0, (uint64_t)"clone mapping", (uint64_t)sub_100001118);
  if ((_DWORD)result)
  {
    sub_100040C68( "failed to register the clone mapping tree in the fsck memory storage\n",  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8);
    return sub_100044E7C((char *)0x581, 12);
  }

  return result;
}

uint64_t sub_100001118()
{
  if (qword_100070F08) {
    uint64_t result = sub_100036CD8((uint64_t)&unk_100070ED0, 0LL);
  }
  byte_100070EC8 = 0;
  return result;
}

uint64_t sub_10000114C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(void *)&__int128 v59 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v59 + 1) = 0xAAAAAAAAAAAAAAAALL;
  memset(v58, 170, 25);
  if (byte_100070EC8 != 1) {
    return 0LL;
  }
  if ((*(_BYTE *)(*(void *)(a2 + 40) + 48LL) & 4) == 0)
  {
    uint64_t v3 = 0LL;
    goto LABEL_9;
  }

  unsigned int v56 = 25;
  int v57 = 16;
  unsigned int v5 = sub_10003510C((uint64_t)dword_100070ED0, 0LL, &v59, &v57, v58, &v56);
  if (!v5)
  {
    while (1)
    {
      char v14 = v58[3];
      if ((v58[3] & 3) == 1) {
        break;
      }
      if ((v58[3] & 2) != 0)
      {
        uint64_t v28 = v59;
        v64[0] = v59;
        v64[1] = 0LL;
        memset(v55, 170, 25);
        unsigned int v62 = 25;
        unsigned int v63 = 16;
        if (sub_100034BB4((uint64_t)dword_100070ED0, 0LL, 1LL, v64, &v63, 0x10u, v55, &v62)
          || v64[0] != v28)
        {
LABEL_22:
          if ((v14 & 1) != 0)
          {
            sub_100040C68( "clone mapping (private_id %llu, file_id %llu) is orphan\n",  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v59);
            sub_100044E7C((char *)0x559, 92);
            *(void *)v55 = 0xE000000000000009LL;
            *(_DWORD *)&v55[8] = 19;
            *(_OWORD *)&v55[12] = v59;
            uint64_t v40 = sub_1000014A0(a3, (__int128 *)v55, 0LL, 0LL, 0LL, v37, v38, v39);
            if ((_DWORD)v40)
            {
              uint64_t v3 = v40;
              char v41 = v59;
              strerror(v40);
              sub_100040B90( "can't remove orphan clone mapping (private_id %llu, file_id %llu): %s (%d)\n",  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v41);
              sub_100044E7C((char *)0x548, v3);
              goto LABEL_30;
            }

            if ((v58[3] & 4) == 0)
            {
LABEL_28:
              uint64_t v51 = sub_1000014E4((uint64_t *)&v59, v58);
              goto LABEL_29;
            }

LABEL_14:
            uint64_t v3 = 0LL;
            goto LABEL_30;
          }
        }

        else
        {
          unsigned int v36 = 0;
          while (1)
          {
            v36 += (v55[24] >> 1) & 1;
            if (v36 > 1) {
              break;
            }
            unsigned int v60 = 25;
            unsigned int v61 = 16;
            if (sub_100034BB4((uint64_t)dword_100070ED0, 0LL, 2LL, v64, &v61, 0x10u, v55, &v60)
              || v64[0] != v28)
            {
              goto LABEL_22;
            }
          }

          if ((v14 & 1) == 0)
          {
            sub_100040C68( "clone mapping (private_id %llu, file_id %llu) is missing\n",  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v59);
            sub_100044E7C((char *)0x55A, 92);
            v49 = a3;
            int v50 = 0;
            goto LABEL_35;
          }

          if ((v58[3] & 4) != 0)
          {
            v49 = a3;
            int v50 = 1;
LABEL_35:
            uint64_t v52 = sub_1000015B8(v49, &v59, v58, v50);
            if ((_DWORD)v52)
            {
              uint64_t v3 = v52;
              goto LABEL_9;
            }

            uint64_t v51 = sub_1000017E4((uint64_t *)&v59, v58);
LABEL_29:
            uint64_t v3 = v51;
LABEL_30:
            if ((_DWORD)v3) {
              goto LABEL_9;
            }
          }
        }
      }

      unsigned int v53 = 25;
      unsigned int v54 = 16;
      unsigned int v5 = sub_100034BB4((uint64_t)dword_100070ED0, 0LL, 2LL, &v59, &v54, 0x10u, v58, &v53);
      if (v5) {
        goto LABEL_6;
      }
    }

    sub_100040C68("found an orphan clone mapping (private_id %llu, file_id %llu)\n", v6, v7, v8, v9, v10, v11, v12, v59);
    sub_100044E7C((char *)0x545, 92);
    *(void *)v55 = 0xE000000000000009LL;
    *(_DWORD *)&v55[8] = 19;
    *(_OWORD *)&v55[12] = v59;
    int v18 = sub_1000014A0(a3, (__int128 *)v55, 0LL, 0LL, 0LL, v15, v16, v17);
    if (!v18) {
      goto LABEL_28;
    }
    int v19 = v18;
    char v20 = v59;
    strerror(v18);
    sub_100040C68( "can't add orphan clone mapping (private_id %llu, file_id %llu) to the fsck repairs: %s (%d)\n",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v20);
    sub_100044E7C((char *)0x546, v19);
    goto LABEL_14;
  }

  sub_100036CD8((uint64_t)&unk_100070F30, 0LL);
  byte_100070F28 = 0;
  return v5;
}

  free(v14);
  free(v23);
  return v13;
}

    free(v18);
    if (!v20) {
      return v22;
    }
    goto LABEL_8;
  }

  uint64_t v22 = 12LL;
  sub_100044E7C((char *)0x3F0, 12);
  if (v18) {
    goto LABEL_14;
  }
  if (v20) {
LABEL_8:
  }
    free(v20);
  return v22;
}

  if (v12 - 0x1000000000000000LL > 0xF000000000000001LL)
  {
    if (v12 <= 0xF)
    {
      sub_100040B90("pfkur_key : object (oid 0x%llx): invalid oid (0x%llx)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v12);
      sub_100044E7C((char *)0x3C5, -2);
    }

    if (*(_DWORD *)a5)
    {
      sub_100040C68("pfk_val : object (oid 0x%llx): unknown version (%u)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
      sub_100044E7C((char *)0x3C6, -6);
    }

    if (*(_DWORD *)(a5 + 4) >= 0x10u)
    {
      sub_100040C68("pfk_val : object (oid 0x%llx): unknown flags (%u)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
      sub_100044E7C((char *)0x3C7, -3);
    }

    if (HIBYTE(*(void *)(a5 + 8)))
    {
      sub_100040B90( "pfk_val : object (oid 0x%llx): invalid current_offset (%llu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *a3);
      uint64_t v11 = 968LL;
    }

    else
    {
      if (!HIBYTE(*(void *)(a5 + 16))) {
        return 0LL;
      }
      sub_100040B90( "pfk_val : object (oid 0x%llx): invalid current_ns_offset (%llu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *a3);
      uint64_t v11 = 969LL;
    }
  }

  else
  {
    sub_100040B90("pfkur_key : object (oid 0x%llx): invalid oid (0x%llx)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v12);
    uint64_t v11 = 964LL;
  }

  memmove(v22 + 2, v22, (unsigned __int16)v16);
  uint64_t v29 = *a1;
  uint64_t v30 = &v15[2 * v29];
  *(_BYTE *)uint64_t v30 = v11;
  *((_BYTE *)v30 + 1) = v8;
  v30[1] = v9;
  *a1 = v29 + 1;
  memcpy((char *)v22 + a1[1] + 4, a4, v9);
  if (v9 != v13) {
    bzero((char *)v22 + v9 + a1[1] + 4, (v13 - v9));
  }
  uint64_t v21 = 0LL;
  a1[1] += v13;
  return v21;
}

  if (a4)
  {
    for (i = 0LL; i != 200; i += 2LL)
    {
      char v41 = qword_10008CA08[i];
      if (!v41) {
        break;
      }
      if (v41 == a4)
      {
        if (i != 0x1FFFFFFFELL)
        {
          qword_10008CA08[i + 1] += a3;
          return sub_10000CACC(a3, a4 != 0, v27, v28, v29, v30, v31, v32);
        }

        break;
      }
    }

    if ((a10 & 4) == 0) {
      sub_100040C68("unable to mark allocated blocks for volume oid %llu\n", v26, v27, v28, v29, v30, v31, v32, a4);
    }
  }

  return sub_10000CACC(a3, a4 != 0, v27, v28, v29, v30, v31, v32);
}

LABEL_6:
  if (v5 == 2) {
    uint64_t v3 = 0LL;
  }
  else {
    uint64_t v3 = v5;
  }
LABEL_9:
  sub_100036CD8((uint64_t)dword_100070ED0, 0LL);
  return v3;
}

uint64_t sub_1000014A0( _DWORD *a1, __int128 *a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_1000251C0(a1, 8u, a5, 0, 0, a2, 0x1Cu, a3, a4);
  }
  else {
    return sub_100024E94(0LL, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1000014E4(uint64_t *a1, uint64_t *a2)
{
  if (*a2 && (sub_100017148(*a2, a2[2]), (_DWORD)v4))
  {
    uint64_t v5 = v4;
    uint64_t v6 = *a1;
    strerror(v4);
    sub_100040B90( "clone mapping (private_id %llu, file_id %llu): failed to update dir stats %llu: %s (%d)\n",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v6);
    sub_100044E7C((char *)0x58B, v5);
  }

  else
  {
    uint64_t v14 = a2[1];
    if (v14)
    {
      sub_100006148(v14, a2[2]);
      uint64_t v5 = v15;
      if ((_DWORD)v15)
      {
        uint64_t v16 = *a1;
        strerror(v15);
        sub_100040B90( "clone mapping (private_id %llu, file_id %llu): failed to update attribution tag %llu: %s (%d)\n",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v16);
        sub_100044E7C((char *)0x58C, v5);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return v5;
}

uint64_t sub_1000015B8(_DWORD *a1, __int128 *a2, void *a3, int a4)
{
  unint64_t v52 = 0xE000000000000009LL;
  int v53 = 19;
  __int128 v54 = *a2;
  uint64_t v9 = a3 + 1;
  uint64_t v8 = a3[1];
  if (*a3)
  {
    unsigned int v10 = 16;
  }

  else
  {
    if (!v8)
    {
      uint64_t v11 = 0LL;
      goto LABEL_8;
    }

    unsigned int v10 = 4;
  }

  if (v8) {
    uint64_t v11 = v10 + 12;
  }
  else {
    uint64_t v11 = v10;
  }
LABEL_8:
  uint64_t v12 = (unsigned __int16 *)calloc(1uLL, v11 + 8LL);
  uint64_t v20 = v12;
  if (!v12)
  {
    sub_100040B90("can't allocate memory to insert a new clone mapping value\n", v13, v14, v15, v16, v17, v18, v19, v51);
    uint64_t v31 = 12LL;
    sub_100044E7C((char *)0x53E, 12);
    goto LABEL_17;
  }

  if ((_DWORD)v11)
  {
    if (*a3)
    {
      uint64_t v21 = sub_10003B77C(v12 + 4, v11, 2LL, a3, 8LL, 16LL, v18, v19);
      if ((_DWORD)v21)
      {
        uint64_t v22 = v21;
        char v23 = strerror(v21);
        sub_100040B90("can't add dir stats key for clone mapping: %s (%d)\n", v24, v25, v26, v27, v28, v29, v30, v23);
        sub_100044E7C((char *)0x53F, v22);
        uint64_t v31 = v22;
LABEL_17:
        free(v20);
        uint64_t v20 = 0LL;
        goto LABEL_22;
      }
    }

    if (*v9)
    {
      uint64_t v32 = sub_10003B77C(v20 + 4, v11, 1LL, v9, 8LL, 16LL, v18, v19);
      if ((_DWORD)v32)
      {
        uint64_t v33 = v32;
        char v34 = strerror(v32);
        sub_100040B90("can't add attribution tag for clone mapping: %s (%d)\n", v35, v36, v37, v38, v39, v40, v41, v34);
        sub_100044E7C((char *)0x540, v33);
        uint64_t v31 = v33;
        goto LABEL_17;
      }
    }
  }

  *(void *)uint64_t v20 = a3[2] & 0xFFFFFFFFFFFFFFLL | ((((unint64_t)(a3[3] & 8) >> 3) & 1) << 56);
  if (a4 && (uint64_t v31 = sub_1000014A0(a1, (__int128 *)&v52, 0LL, 0LL, 0LL, v17, v18, v19), (_DWORD)v31)
    || (uint64_t v31 = sub_1000014A0(a1, (__int128 *)&v52, v20, v11 + 8LL, 2LL, v17, v18, v19), (_DWORD)v31))
  {
    uint64_t v42 = *((void *)a2 + 1);
    strerror(v31);
    sub_100040B90( "can't add clone mapping (private_id %llu, file_id %llu) for repairs: %s (%d)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v42);
    sub_100044E7C((char *)0x544, v31);
  }

LABEL_22:
  free(v20);
  return v31;
}

              *((void *)&v24 + 1) = *(void *)(*(void *)(a1 + 8) + 16LL);
              LODWORD(v22) = 1;
              LODWORD(result) = sub_1000364F0(v25, 0LL, &v24, 16LL, &v22, 16LL);
              uint64_t v16 = result == 0;
              if (!v14)
              {
                uint64_t v17 = 17;
LABEL_26:
                if (v16) {
                  return v17;
                }
                else {
                  return result;
                }
              }

    uint64_t v9 = 0LL;
    goto LABEL_23;
  }

  uint64_t v8 = 0LL;
  if (a2 < 0xD) {
    goto LABEL_22;
  }
  uint64_t v9 = 0LL;
  if (a4 < 0xD) {
    goto LABEL_23;
  }
LABEL_12:
  unsigned int v10 = *(void *)((char *)a1 + 5) >> 60;
  uint64_t v11 = *(void *)((char *)a3 + 5) >> 60;
  if (a4 >= 0x11 && a2 >= 0x11 && (_DWORD)v10 == 14 && (_DWORD)v11 == 14)
  {
    LODWORD(v10) = *((unsigned __int8 *)a1 + 13);
    LODWORD(v11) = *((unsigned __int8 *)a3 + 13);
  }

  uint64_t v8 = a1;
  uint64_t v9 = a3;
  else {
    uint64_t result = 1LL;
  }
  if ((_DWORD)v10 == (_DWORD)v11)
  {
LABEL_23:
    uint64_t v12 = (v4 >> 4) & 3;
    uint64_t v13 = (v6 >> 4) & 3;
    if (v12 >= v13)
    {
      if (v12 > v13) {
        return 1LL;
      }
      if (v12 != 1) {
        return 0LL;
      }
      uint64_t v14 = (v4 >> 6) & 0x1F;
      uint64_t v15 = (v6 >> 6) & 0x1F;
      if (v14 >= v15)
      {
        if (v14 > v15) {
          return 1LL;
        }
        if (!v8 || !v9) {
          return 0LL;
        }
        uint64_t v16 = *((unsigned __int8 *)v8 + 4);
        uint64_t v17 = *((unsigned __int8 *)v9 + 4);
        if (v16 >= v17) {
          return v16 > v17;
        }
      }
    }

    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t sub_1000017E4(uint64_t *a1, void *a2)
{
  if (*a2 && (uint64_t v4 = sub_1000170CC(*a2, a2[2]), (_DWORD)v4))
  {
    uint64_t v5 = v4;
    uint64_t v6 = *a1;
    strerror(v4);
    sub_100040B90( "clone mapping (private_id %llu, file_id %llu): failed to update dir stats %llu: %s (%d)\n",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v6);
    sub_100044E7C((char *)0x58B, v5);
  }

  else
  {
    uint64_t v14 = a2[1];
    if (v14)
    {
      uint64_t v15 = sub_1000060B8(v14, a2[2]);
      uint64_t v5 = v15;
      if ((_DWORD)v15)
      {
        uint64_t v16 = *a1;
        strerror(v15);
        sub_100040B90( "clone mapping (private_id %llu, file_id %llu): failed to update attribution tag %llu: %s (%d)\n",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v16);
        sub_100044E7C((char *)0x58C, v5);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return v5;
}

uint64_t sub_1000018B8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3 & 0xFFFFFFFFFFFFFFLL;
  if ((*a3 & 0x100000000000000LL) != 0) {
    int v6 = 9;
  }
  else {
    int v6 = 1;
  }
  return sub_1000018D0(a1, a2, v6, a4, a5, v5);
}

uint64_t sub_1000018D0(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (byte_100070EC8 != 1) {
    return 0LL;
  }
  char v10 = a1;
  memset(v44, 0, 25);
  v43[0] = a1;
  v43[1] = a2;
  unsigned int v41 = 25;
  unsigned int v42 = 16;
  uint64_t v11 = sub_100034BB4((uint64_t)dword_100070ED0, 0LL, 0LL, v43, &v42, 0x10u, v44, &v41);
  if ((_DWORD)v11 != 2)
  {
    uint64_t v19 = v11;
    if ((_DWORD)v11)
    {
      strerror(v11);
      sub_100040B90( "failed to search for clone mapping (private_id %llu,  file_id %llu): %s (%d)\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v10);
      sub_100044E7C((char *)0x54B, v19);
      return v19;
    }

    v40[24] = -86;
    if ((a3 & 2) != 0)
    {
      *(_OWORD *)uint64_t v40 = v44[0];
      *(_OWORD *)&v40[9] = *(_OWORD *)((char *)v44 + 9);
    }

    else
    {
      *(void *)&v40[8] = a4;
      *(void *)&v40[16] = a6;
      *(void *)uint64_t v40 = a5;
    }

    if (*(void *)&v44[0] != a5)
    {
      sub_100040C68( "clone mapping (private_id %llu, file_id %llu): dir stats key (%llu) != inode (id %llu) dir stats key (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v10);
      sub_100044E7C((char *)0x55B, -11);
      BYTE8(v44[1]) |= 4u;
      if ((a3 & 2) != 0) {
        *(void *)&v44[0] = a5;
      }
    }

    if (*((void *)&v44[0] + 1) == a4)
    {
      char v27 = BYTE8(v44[1]);
      if (((a3 | BYTE8(v44[1])) & 0x10) != 0)
      {
        if ((a3 & 2) != 0) {
          goto LABEL_25;
        }
        goto LABEL_19;
      }
    }

    else
    {
      sub_100040C68( "clone mapping (private_id %llu, file_id %llu): attribution tag (%llu) != inode (id %llu) attribution tag (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v10);
      sub_100044E7C((char *)0x55C, -11);
      int v28 = BYTE8(v44[1]);
      char v27 = BYTE8(v44[1]) | 4;
      BYTE8(v44[1]) |= 4u;
      if ((a3 & 2) != 0)
      {
        *((void *)&v44[0] + 1) = a4;
        if (((a3 | v28) & 0x10) != 0) {
          goto LABEL_25;
        }
      }

      else if (((a3 | v28) & 0x10) != 0)
      {
LABEL_19:
        if (*(void *)&v44[1] != a6)
        {
          sub_100040C68( "clone mapping (private_id %llu, file_id %llu): compressed physical size (%llu) != inode (id %llu) compressed physical size (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v10);
          sub_100044E7C((char *)0x56E, -11);
          char v27 = BYTE8(v44[1]) | 4;
          BYTE8(v44[1]) |= 4u;
        }

        goto LABEL_25;
      }
    }

    if (*(void *)&v44[1] != a6)
    {
      sub_100040C68( "clone mapping (private_id %llu, file_id %llu): physical size (%llu) != inode (id %llu) physical size (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v10);
      sub_100044E7C((char *)0x55D, -11);
      char v27 = BYTE8(v44[1]) | 4;
      BYTE8(v44[1]) |= 4u;
      if ((a3 & 2) != 0) {
        *(void *)&v44[1] = a6;
      }
    }

LABEL_25:
    if ((a3 & 8) != (v27 & 8))
    {
      sub_100040C68( "clone mapping (private_id %llu, file_id %llu): purgeable status is different than inode (id %llu) purgeable status\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v10);
      sub_100044E7C((char *)0x55E, -3);
      char v27 = BYTE8(v44[1]) | 4;
      if ((a3 & 2) != 0) {
        char v27 = BYTE8(v44[1]) & 0xF3 | 4 | a3 & 8;
      }
    }

    BYTE8(v44[1]) = v27 | a3 & 0xF7;
    if (v27 & 4 | a3 & 4)
    {
      byte_100070EC9 = 1;
      uint64_t v29 = sub_1000014E4(v43, (uint64_t *)v40);
      if ((_DWORD)v29) {
        return v29;
      }
    }

    goto LABEL_31;
  }

  *(void *)&v44[0] = a5;
  *((void *)&v44[0] + 1) = a4;
  *(void *)&v44[1] = a6;
  BYTE8(v44[1]) |= a3;
LABEL_31:
  uint64_t v30 = sub_1000364F0(dword_100070ED0, 0LL, v43, 16LL, v44, 25LL);
  uint64_t v19 = v30;
  if ((_DWORD)v30)
  {
    char v31 = v43[0];
    strerror(v30);
    sub_100040B90( "failed to insert clone mapping (private_id %llu,  file_id %llu, flags 0x%x): %s (%d)\n",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v31);
    sub_100044E7C((char *)0x54C, v19);
  }

  return v19;
}

    v100 = *(unsigned int *)(*(void *)(a1 + 8) + 36LL);
    if (*(void *)(a5 + 8) % v100)
    {
      v101 = sub_10003A294(*a3 >> 60);
      sub_100040C68( "%s (id %llu): invalid physical size (%llu) for hash (%llu)\n",  v102,  v103,  v104,  v105,  v106,  v107,  v108,  v101);
      sub_100044E7C((char *)0x52B, -11);
      v100 = *(unsigned int *)(*(void *)(a1 + 8) + 36LL);
    }

    v109 = *(void *)(a5 + 16);
    if (v109 % v100)
    {
      v110 = sub_10003A294(*a3 >> 60);
      sub_100040C68( "%s (id %llu): invalid full clone size (%llu) for hash (%llu)\n",  v111,  v112,  v113,  v114,  v115,  v116,  v117,  v110);
      sub_100044E7C((char *)0x53C, -11);
      v109 = *(void *)(a5 + 16);
    }

    if (*(void *)(a5 + 8) < v109)
    {
      v118 = sub_10003A294(*a3 >> 60);
      sub_100040C68( "%s (id %llu): physical size (%llu) is less than full clone size (%llu) for hash (%llu)\n",  v119,  v120,  v121,  v122,  v123,  v124,  v125,  v118);
      sub_100044E7C((char *)0x53D, -11);
    }

    if (*(unsigned __int16 *)(a5 + 24) >= 2u)
    {
      v126 = sub_10003A294(*a3 >> 60);
      sub_100040C68( "%s (id %llu): unknown flags (0x%x / valid-flags: 0x%x)\n",  v127,  v128,  v129,  v130,  v131,  v132,  v133,  v126);
      sub_100044E7C((char *)0x52C, -3);
    }

    memset(v192, 0, sizeof(v192));
    v134 = sub_1000134C8( a1,  a2,  (uint64_t)a3,  (unsigned __int16 *)(a5 + 26),  (a6 - 26),  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_1000162E4,  a7,  a8,  (uint64_t)v192);
    if ((_DWORD)v134)
    {
      uint64_t v37 = v134;
      v188 = sub_10003A294(*a3 >> 60);
      sub_100040B90("%s (id %llu): invalid xfields\n", v135, v136, v137, v138, v139, v140, v141, v188);
      goto LABEL_59;
    }

    if (LOBYTE(v192[0]))
    {
      v159 = strlen((const char *)v192 + 1);
      v160 = sub_10004A9FC((char *)v192 + 1, v159);
      if (v160 == v67)
      {
        v67 = 0LL;
      }

      else
      {
        v190 = sub_10003A294(*a3 >> 60);
        strlen((const char *)v192 + 1);
        sub_100040C68( "%s (id %llu): signing id hash (%llu) for signing id (%s) with length (%zu) does not match attribution tag hash (%llu)\n",  v171,  v172,  v173,  v174,  v175,  v176,  v177,  v190);
        sub_100044E7C((char *)0x52E, 92);
      }

      if (*(void *)(a7 + 56)) {
        v178 = 0LL;
      }
      else {
        v178 = (_DWORD *)(a2 + 704);
      }
      sub_100005E04( v178,  v160,  *(void *)a5,  *(void *)(a5 + 8),  *(void *)(a5 + 16),  *(_WORD *)(a5 + 24),  v191,  v67);
      uint64_t v37 = v179;
      if ((_DWORD)v179)
      {
        v189 = sub_10003A294(*a3 >> 60);
        sub_100040B90( "%s (id %llu): failed to register file info (hash %llu): %d\n",  v180,  v181,  v182,  v183,  v184,  v185,  v186,  v189);
      }

  int v57 = sub_10003B000(a1, a2, *(void *)(v146 + 56), *a5 & 0xFFFFFFFFFFFFFFFLL, &v147);
  if ((_DWORD)v57)
  {
    uint64_t v47 = v57;
    v58 = 1333LL;
    __int128 v59 = v47;
LABEL_27:
    sub_100044E7C((char *)v58, v59);
    return v47;
  }

  if (!v147)
  {
    v114 = sub_10003A294(*a5 >> 60);
    sub_100040B90( "%s (id %llu): number of sparse bytes (%llu) is larger than alloced_size (%llu)\n",  v115,  v116,  v117,  v118,  v119,  v120,  v121,  v114);
    uint64_t v47 = 92LL;
    v58 = 1259LL;
    __int128 v59 = 92;
    goto LABEL_27;
  }

  if (v40 || (*(_BYTE *)(v12 + 51) & 0x10) != 0)
  {
    v99 = sub_10003A294(*a5 >> 60);
    sub_100040C68( "%s (id %llu): sparse bytes mismatch for a file in the purgatory\n",  v100,  v101,  v102,  v103,  v104,  v105,  v106,  v99);
    v107 = *(void *)(v12 + 48) & 0xFFFFFFFFEFFFFFFDLL;
    unsigned int v60 = 1;
    if (sub_1000428C4( qword_10008DB70,  "Set internal_flags to 0x%llx? ",  v108,  v109,  v110,  v111,  v112,  v113,  *(_BYTE *)(v12 + 48) & 0xFD))
    {
      *(void *)(v12 + 48) = v107;
      a6 = v37;
      *uint64_t v37 = 1;
      goto LABEL_41;
    }
  }

  else
  {
    unsigned int v60 = 1;
  }

  a6 = v37;
LABEL_41:
  v71 = *(_DWORD *)(v12 + 68);
  if ((v71 & 0x40) != 0 && !*(_BYTE *)a4)
  {
    v72 = v71 & 0xFFFFFFBF;
    v73 = sub_10003A294(*a5 >> 60);
    sub_100040B90( "%s (id %llu): doc_id xf does not exist, despite bsd_flags (0x%x)\n",  v74,  v75,  v76,  v77,  v78,  v79,  v80,  v73);
    uint64_t v47 = 92LL;
    sub_100044E7C((char *)0x44E, 92);
    *(_DWORD *)(v12 + 68) = v72;
    *a6 = 1;
  }

  if ((*(_WORD *)(v12 + 80) & 0xB000 | 0x4000) == 0x6000 && !*(_BYTE *)(a4 + 1))
  {
    v87 = sub_10003A294(*a5 >> 60);
    sub_100040C68("%s (id %llu): no rdev xf on char/block device (mode %u)\n", v88, v89, v90, v91, v92, v93, v94, v87);
  }

  v95 = *(void *)(v12 + 48);
  if (*(_BYTE *)(a4 + 5) == ((v95 >> 28) & 1)) {
    return 0LL;
  }
  if (!*(_BYTE *)(a4 + 5) || (v95 & 0x10000000) != 0)
  {
    v96 = v95 & 0xFFFFFFFFEFFFFFFFLL;
    v97 = 1318LL;
    v98 = "%s (id %llu): attribution tag xf does not exist, despite internal_flags (0x%llx)\n";
    goto LABEL_69;
  }

  if ((v60 & 1) != 0)
  {
    if (v147) {
      return 0LL;
    }
    goto LABEL_68;
  }

  uint64_t v47 = sub_10003B000(a1, a2, *(void *)(v146 + 56), *a5 & 0xFFFFFFFFFFFFFFFLL, &v147);
  if (!(_DWORD)v47 && !v147)
  {
    v95 = *(void *)(v12 + 48);
LABEL_68:
    v96 = v95 | 0x10000000;
    v97 = 1317LL;
    v98 = "%s (id %llu): attribution tag xf exists, despite internal_flags (0x%llx)\n";
LABEL_69:
    v131 = sub_10003A294(*a5 >> 60);
    sub_100040C68(v98, v132, v133, v134, v135, v136, v137, v138, v131);
    sub_100044E7C((char *)v97, -3);
    if (sub_1000428C4( qword_10008DB70,  "Set internal_flags to 0x%llx? ",  v139,  v140,  v141,  v142,  v143,  v144,  v96))
    {
      uint64_t v47 = 0LL;
      *(void *)(v12 + 48) = v96;
      *a6 = 1;
      return v47;
    }

    return 0LL;
  }

  return v47;
}

    uint64_t v22 = v14 - v10;
    if (v14 >= (uint64_t)v10)
    {
      uint64_t v23 = v22 < v13 - v10 && v13 - v10 >= (*(void *)v26 & 0xFFFFFFFFFFFFFFFuLL);
      if (v23 && v22 <= v13 - v10 - (*(void *)v26 & 0xFFFFFFFFFFFFFFFLL))
      {
        a5(v26, a6);
        if ((a4 & 1) != 0 || *(_DWORD *)&v26[16]) {
          uint64_t result = sub_10001F658(&xmmword_10008C858, (uint64_t *)&v27, v26);
        }
        else {
          uint64_t result = sub_10001F5EC((uint64_t)&xmmword_10008C858, (uint64_t *)&v27);
        }
        if ((_DWORD)result) {
          goto LABEL_59;
        }
        uint64_t v14 = v27;
      }
    }

    if (v29
      && (*(void *)v28 & 0xFFFFFFFFFFFFFFFLL) + v29 == v14
      && *(_DWORD *)&v28[16] == *(_DWORD *)&v26[16]
      && v28[20] == v26[20])
    {
      *(void *)int v28 = ((*(void *)v26 & 0xFFFFFFFFFFFFFFFLL) + (*(void *)v28 & 0xFFFFFFFFFFFFFFFLL)) | *(void *)v28 & 0xF000000000000000LL;
      if (*(_DWORD *)&v28[16])
      {
        uint64_t result = sub_10001F658(&xmmword_10008C858, &v29, v28);
        if ((_DWORD)result) {
          goto LABEL_59;
        }
        uint64_t v14 = v27;
      }
    }

    else
    {
      uint64_t v29 = v14;
      *(_OWORD *)int v28 = *(_OWORD *)v26;
      *(void *)&v28[13] = *(void *)&v26[13];
    }

    uint64_t v25 = (*(void *)v26 & 0xFFFFFFFFFFFFFFFLL) + v14;
    if (v25 > v10) {
      char v10 = v25;
    }
    uint64_t result = sub_10001F548((uint64_t *)&v27, v26, 2LL);
    if ((_DWORD)result != 2 || (a4 & 1) == 0) {
      break;
    }
    char v27 = -1LL;
LABEL_54:
    if (v10 > v13) {
      return 0LL;
    }
  }

  if (!(_DWORD)result) {
    goto LABEL_54;
  }
  if ((_DWORD)result != 2) {
    goto LABEL_59;
  }
  return 0LL;
}

        uint64_t v46 = ((uint64_t (*)(uint64_t *, void *, unsigned __int16 *, uint64_t, uint64_t, uint64_t, uint64_t))v94)( v11,  v10,  a1,  a2,  a3,  a4,  v40);
        unsigned int v41 = v46;
        *(_BYTE *)(a5 + 40) = (_DWORD)v46 != 89;
        if ((_DWORD)v46)
        {
          if ((_DWORD)v46 == 89)
          {
            uint64_t v47 = 0;
            unsigned int v41 = (*a1 << 20 >> 31) & 0x5C;
          }

          else
          {
            ++*(void *)(a5 + 88);
            ++*(void *)(a5 + 56);
            uint64_t v47 = 1;
          }
        }

        else
        {
          ++*(void *)(a5 + 80);
          sub_100044E2C();
          uint64_t v47 = 0;
        }

        if ((*a1 & 0x800) != 0) {
          ++*(void *)(a5 + 72);
        }
        if (!(_DWORD)v38) {
          goto LABEL_98;
        }
        uint64_t v48 = *v11;
        if (v47)
        {
          uint64_t v49 = sub_10001BC40(v48);
          if (!v49) {
            uint64_t v49 = sub_100029790(v11);
          }
          if (v10)
          {
            int v50 = v12;
            char v51 = 0LL;
            unint64_t v52 = 0;
            int v53 = 1;
            do
            {
              __int128 v54 = v53;
              v55 = v10[v51 + 3];
              if (v55)
              {
                unsigned int v56 = sub_10001BC40(v55);
                if (!v52) {
                  unint64_t v52 = v56;
                }
              }

              int v53 = 0;
              char v51 = 1LL;
            }

            while ((v54 & 1) != 0);
            uint64_t v12 = v50;
            if (!v52) {
              unint64_t v52 = sub_100029A30(v11, (uint64_t)v10);
            }
          }

          else
          {
            unint64_t v52 = 0;
          }

          if (!v49) {
            uint64_t v49 = v52;
          }
          if (v49)
          {
            v67 = strerror(v49);
            sub_100040B90("error aborting transaction: %s\n", v68, v69, v70, v71, v72, v73, v74, v67);
            sub_100044E7C((char *)0x385, v49);
          }

          goto LABEL_95;
        }

        v93 = v12;
        int v57 = sub_10001BC30(v48);
        v58 = v57 == 84;
        if (v10)
        {
          v95 = v57;
          __int128 v59 = 0LL;
          unsigned int v60 = 0;
          unsigned int v61 = 1;
          do
          {
            unsigned int v62 = v61;
            unsigned int v63 = v10[v59 + 3];
            if (v63)
            {
              v64 = sub_10001BC30(v63);
              if (v64)
              {
                if (v64 == 84) {
                  v58 = 1;
                }
                if (v60 == 84 || !v60) {
                  unsigned int v60 = v64;
                }
              }
            }

            unsigned int v61 = 0;
            __int128 v59 = 1LL;
          }

          while ((v62 & 1) != 0);
          if (v95 == 84) {
            uint64_t v49 = 0;
          }
          else {
            uint64_t v49 = v95;
          }
          if (v60 == 84) {
            v65 = 0;
          }
          else {
            v65 = v60;
          }
          if (v49) {
            goto LABEL_86;
          }
        }

        else
        {
          v65 = 0;
          if (v57 == 84) {
            uint64_t v49 = 0;
          }
          else {
            uint64_t v49 = v57;
          }
          if (v49) {
            goto LABEL_86;
          }
        }

        if (v58 && !v65)
        {
          v75 = sub_10001BC38(*v11);
          uint64_t v49 = v75;
          if (!v10 || v75)
          {
            if (!v75) {
              goto LABEL_94;
            }
          }

          else
          {
            v76 = 0LL;
            v77 = 1;
            while (1)
            {
              v78 = v77;
              v79 = v10[v76 + 3];
              if (v79)
              {
                v80 = sub_10001BC38(v79);
                if (v80) {
                  break;
                }
              }

              v77 = 0;
              v76 = 1LL;
              if ((v78 & 1) == 0)
              {
                uint64_t v49 = 0;
                goto LABEL_94;
              }
            }

            uint64_t v49 = v80;
          }

uint64_t sub_100001C24(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a1 < 0x10) {
    return 0LL;
  }
  if ((*(_DWORD *)(a2 + 68) & 0x20) != 0) {
    a4 = 0LL;
  }
  if ((*(_DWORD *)(a2 + 68) & 0x20) != 0) {
    int v8 = 18;
  }
  else {
    int v8 = 2;
  }
  uint64_t v9 = *(void *)(a2 + 48);
  if ((v9 & 0x180000) == 0x80000 && *(_DWORD *)(a2 + 56) == 1) {
    v8 |= 8u;
  }
  return sub_1000018D0(*(void *)(a2 + 8), a1, (v9 >> 9) & 0x20 | v8, a5, a6, a4);
}

uint64_t sub_100001C90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (byte_100070EC8 != 1) {
    return 0LL;
  }
  char v4 = a1;
  v33[0] = 0LL;
  v33[1] = 0LL;
  char v35 = 0;
  uint64_t v34 = 0LL;
  v32[0] = a1;
  v32[1] = a2;
  unsigned int v30 = 25;
  unsigned int v31 = 16;
  uint64_t v5 = sub_100034BB4((uint64_t)dword_100070ED0, 0LL, 0LL, v32, &v31, 0x10u, v33, &v30);
  if ((_DWORD)v5)
  {
    uint64_t v13 = v5;
    strerror(v5);
    sub_100040B90( "failed to search for clone mapping (private_id %llu,  file_id %llu) to update compressed clone size: %s (%d)\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v4);
    sub_100044E7C((char *)0x56F, v13);
    return v13;
  }

  if ((v35 & 1) != 0)
  {
    if (v34 != a3)
    {
      sub_100040C68( "clone mapping (private_id %llu, file_id %llu): compressed physical size (%llu) != inode (id %llu) compressed phy sical size (%llu)\n",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v4);
      sub_100044E7C((char *)0x570, -11);
      uint64_t v13 = sub_1000014E4(v32, v33);
      if ((_DWORD)v13) {
        return v13;
      }
      v35 |= 4u;
      goto LABEL_5;
    }

    return 0LL;
  }

LABEL_5:
  uint64_t v34 = a3;
  uint64_t v21 = sub_1000364F0(dword_100070ED0, 0LL, v32, 16LL, v33, 25LL);
  uint64_t v13 = v21;
  if ((_DWORD)v21)
  {
    strerror(v21);
    sub_100040B90( "failed to update clone mapping (private_id %llu,  file_id %llu) with compressed clone size: %s (%d)\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v4);
    sub_100044E7C((char *)0x571, v13);
  }

  return v13;
}

    uint64_t v20 = *(unsigned int *)(v13 + 36);
    uint64_t v21 = v19;
    if (v19 != v20)
    {
      sub_100040B90( "om: om_snap_count (%u) is not equal to the number of snapshots found (%llu)\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(v13 + 36));
      if (!sub_1000428C4( qword_10008DB70,  "Fix om_snap_count (oid 0x%llx)? ",  v22,  v23,  v24,  v25,  v26,  v27,  *(void *)(v13 + 8)))
      {
        uint64_t v18 = 92LL;
        unsigned int v30 = 376LL;
        goto LABEL_28;
      }

      uint64_t v21 = v41;
      *(_DWORD *)(v13 + 36) = v41;
    }

    if (v21) {
      uint64_t v28 = *(void *)(a3 + 56);
    }
    else {
      uint64_t v28 = 0LL;
    }
    if (*(_BYTE *)(qword_10008DB78 + 42) || *(void *)(v13 + 64) == v28)
    {
      if (v19 == v20) {
        return 0LL;
      }
    }

    else
    {
      sub_100040B90( "om: om_most_recent_snap (%llu) is not equal to the largest snapshot xid (%llu)\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(v13 + 64));
      if (!sub_1000428C4( qword_10008DB70,  "Fix om_most_recent_snap (oid 0x%llx)? ",  v31,  v32,  v33,  v34,  v35,  v36,  *(void *)(v13 + 8)))
      {
        uint64_t v18 = 92LL;
        unsigned int v30 = 671LL;
        goto LABEL_28;
      }

      *(void *)(v13 + 64) = v28;
    }

    v40[0] = v14;
    v40[1] = v15;
    v40[2] = v16;
    uint64_t v18 = sub_100023FA8(a1, (uint64_t)a2, v13, (uint64_t)v40, a9, a10);
    if (!(_DWORD)v18)
    {
      sub_100044E2C();
      return v18;
    }

    unsigned int v30 = 377LL;
    uint64_t v37 = v18;
LABEL_29:
    sub_100044E7C((char *)v30, v37);
  }

  return v18;
}

    sub_100044E7C((char *)v12, 92);
    return v9;
  }

  return 0LL;
}

  if (v30) {
    free(v30);
  }
  return v16;
}

uint64_t sub_100001E04(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v24 = a1;
  uint64_t v25 = 0LL;
  memset(v23, 170, 25);
  if ((byte_100070EC8 & 1) != 0)
  {
    unsigned int v21 = 25;
    unsigned int v22 = 16;
    unsigned int v8 = sub_100034BB4((uint64_t)dword_100070ED0, 0LL, 1LL, &v24, &v22, 0x10u, v23, &v21);
    unsigned int v16 = 0;
    if (v8)
    {
LABEL_9:
      if (v8 == 2) {
        uint64_t v17 = 0LL;
      }
      else {
        uint64_t v17 = v8;
      }
    }

    else
    {
      while (v24 == a1)
      {
        if ((v23[3] & 2) != 0)
        {
          if (v16 < a3) {
            *(void *)(a2 + 8LL * (int)v16) = v25;
          }
          ++v16;
        }

        unsigned int v19 = 25;
        unsigned int v20 = 16;
        unsigned int v8 = sub_100034BB4((uint64_t)dword_100070ED0, 0LL, 2LL, &v24, &v20, 0x10u, v23, &v19);
        if (v8) {
          goto LABEL_9;
        }
      }

      uint64_t v17 = 0LL;
    }

    if (v16 != a3)
    {
      sub_100040B50( "number of files in the clone mapping (%u) != dstream reference count (%u)\n",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16);
      sub_100044E7C((char *)0x54E, 92);
    }

    if (a4) {
      *a4 = v16;
    }
  }

  else
  {
    uint64_t v17 = 12LL;
    sub_100044E7C((char *)0x54D, 12);
  }

  return v17;
}

uint64_t sub_100001F58()
{
  return byte_100070EC9 & ~byte_100070EC8 & 1;
}

void sub_100001F74()
{
  v0 = (char *)off_10008D690;
  if (!off_10008D690)
  {
    do
    {
      unsigned int v1 = 0;
      for (int i = 0; i != 8; ++i)
      {
        unsigned int v3 = (v0 >> i) ^ v1;
        unsigned int v4 = v1 >> 1;
        unsigned int v1 = (v1 >> 1) ^ 0x82F63B78;
        if ((v3 & 1) == 0) {
          unsigned int v1 = v4;
        }
      }

      dword_10008D698[(void)v0++] = v1;
    }

    while (v0 != (char *)256);
    off_10008D690 = (uint64_t (*)(void, void, void))sub_100001FE0;
  }
}

uint64_t sub_100001FE0(uint64_t result, char *a2, uint64_t a3)
{
  {
    char v3 = *a2++;
    uint64_t result = dword_10008D698[(v3 ^ result)] ^ (result >> 8);
  }

  return result;
}

uint64_t sub_10000200C(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }

      else
      {
        uint64_t v8 = a2[1];
        uint64_t v9 = a4[1];
        if (v8 >= v9) {
          int v7 = v9 < v8;
        }
        else {
          int v7 = -1;
        }
      }
    }

    else
    {
      int v7 = -1;
    }

    uint64_t result = 0LL;
    *a6 = v7;
  }

  return result;
}

uint64_t sub_10000206C( unint64_t a1, unsigned int a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v8 = 0LL;
  uint64_t v9 = (char *)&unk_10008DA98 + 104 * a2;
  while (1)
  {
    sub_1000033C0(a1);
    uint64_t v10 = &v9[v8];
    if (v9[v8 + 24])
    {
      uint64_t v11 = *(void *)v10;
      uint64_t v12 = *((void *)v10 + 1);
      uint64_t v13 = v12 - v11;
      if (v12 != v11)
      {
        if (a2 == 1) {
          v11 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36LL)));
        }
        uint64_t result = a3(v11, v13, a4);
        if ((_DWORD)result) {
          break;
        }
      }
    }

    v8 += 32LL;
    if (v8 == 96) {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100002120(unint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, uint64_t), uint64_t a3)
{
  unsigned int v6 = 0;
  char v7 = 1;
  do
  {
    char v8 = v7;
    uint64_t result = sub_10000206C(a1, v6, a2, a3);
    if ((_DWORD)result) {
      break;
    }
    char v7 = 0;
    unsigned int v6 = 1;
  }

  while ((v8 & 1) != 0);
  return result;
}

uint64_t sub_100002178( uint64_t a1, unsigned int a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if ((*(_BYTE *)(v4 + 144) & 1) == 0 || !*(_DWORD *)(v4 + 336)) {
    return 0LL;
  }
  uint64_t v9 = 0LL;
  uint64_t v10 = v4 + 1088LL * a2;
  while (1)
  {
    uint64_t v11 = *(void *)(v10 + v9 + 344);
    uint64_t v12 = *(void *)(v10 + v9 + 352);
    uint64_t v13 = v12 - v11;
    if (v12 != v11)
    {
      if (a2 == 1) {
        v11 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36LL)));
      }
      uint64_t result = a3(v11, v13, a4);
      if ((_DWORD)result) {
        break;
      }
    }

    v9 += 136LL;
    if (v9 == 1088) {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100002228(uint64_t *a1, int8x16_t *a2, unsigned int a3, unint64_t a4, uint64_t *a5)
{
  uint64_t v9 = a1;
  unsigned int v212 = 0;
  uint64_t v210 = 0LL;
  uint64_t v211 = 0xAAAAAAAAAAAAAAAALL;
  int64_t v209 = 0LL;
  uint64_t v10 = a1[3];
  size_t v11 = *(unsigned int *)(v10 + 32);
  v207 = (_DWORD *)v10;
  if (*(void *)(v10 + 96)) {
    int v12 = 2;
  }
  else {
    int v12 = 1;
  }
  uint64_t v13 = (char *)malloc(v11);
  uint64_t v14 = (char *)malloc(v11);
  v213[0] = v14;
  uint64_t v15 = malloc(v11);
  uint64_t v23 = v15;
  if (v13) {
    BOOL v24 = v14 == 0LL;
  }
  else {
    BOOL v24 = 1;
  }
  if (v24 || v15 == 0LL)
  {
    sub_100040B90("Space Allocation: failed to allocate memory\n", v16, v17, v18, v19, v20, v21, v22, v182);
    uint64_t v26 = 12LL;
    uint64_t v27 = 510LL;
    int v28 = 12;
    goto LABEL_82;
  }

  v193 = a5;
  v189 = a2;
  int v29 = 0;
  int v30 = v12;
  unint64_t v31 = 0LL;
  uint64_t v32 = 0LL;
  int v186 = v30;
  int v33 = v30 - 1;
  unsigned int v34 = a3 - 1;
  uint64_t v187 = a3;
  LOBYTE(v30) = __clz(__rbit64(v11));
  uint64_t v35 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v30;
  unint64_t v194 = 0x4000000000000000uLL >> v30;
  int v203 = -1;
  uint64_t v205 = (uint64_t)v15;
  v206 = v9;
  int v192 = v11;
  v198 = v13;
  unsigned int v190 = a3;
  unsigned int v184 = a3 - 1;
  int v185 = v33;
  uint64_t v183 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v30;
  do
  {
    int v191 = v29;
    uint64_t v36 = (dword_100070F20 + v29) & v33;
    uint64_t v37 = v207;
    if (v34 > 2)
    {
LABEL_29:
      int v188 = 0;
      unint64_t v46 = qword_100070F10[v36] & v35;
      goto LABEL_30;
    }

    if (a3 == 3)
    {
      if (a4 - 5 < 0xFFFFFFFFFFFFFFFCLL) {
        goto LABEL_29;
      }
      uint64_t v38 = v9[3];
      if ((*(_BYTE *)(v38 + 144) & 1) == 0 || !*(_DWORD *)(v38 + 336)) {
        goto LABEL_29;
      }
      uint64_t v39 = v38 + 344;
      uint64_t v40 = 8LL;
      char v41 = a4 + 7;
      while (1)
      {
        unsigned int v42 = v41 & 7;
        char v41 = v42 + 1;
        if (!--v40) {
          goto LABEL_29;
        }
      }

      uint64_t v45 = (char *)(v39 + 1088LL * v36 + 136LL * v42);
    }

    else
    {
      sub_1000033C0((unint64_t)v9);
      uint64_t v37 = v207;
      uint64_t v43 = (char *)&unk_10008DA98 + 104 * v36;
      uint64_t v44 = v187;
      if (!v43[32 * v187 + 24])
      {
        if (a3 != 2 || !v43[56]) {
          goto LABEL_29;
        }
        uint64_t v44 = 1LL;
      }

      uint64_t v45 = &v43[32 * v44 + 16];
    }

    unint64_t v46 = *(void *)v45;
    int v188 = 1;
LABEL_30:
    unsigned int v47 = 0;
    unint64_t v48 = (unint64_t)&v37[12 * v36];
    v202 = (unint64_t *)(v48 + 48);
    v199 = (char *)v37 + *(unsigned int *)(v48 + 80);
    v204 = (unsigned int *)(v48 + 64);
    uint64_t v200 = v36;
    v201 = (_DWORD *)(v48 + 68);
    LODWORD(v48) = v37[9];
    unint64_t v49 = v194;
    if ((_DWORD)v36 != 1) {
      unint64_t v49 = 0LL;
    }
    unint64_t v208 = v49;
    unint64_t v195 = v46;
    do
    {
      if (v46 >= *v202) {
        unint64_t v46 = 0LL;
      }
      unint64_t v50 = v46 / v48 / v37[10];
      if (*v201)
      {
        unsigned int v51 = v37[11];
        unsigned int v52 = v50 / v51;
        int v53 = v203;
        if (v50 / v51 != v203)
        {
          int v54 = sub_10002BE74(*v206, *(void *)&v199[8 * v52]);
          if (v54)
          {
            sub_100040B90("error (%d) getting cab %u @ %lld on device %d\n", v55, v56, v57, v58, v59, v60, v61, v54);
            uint64_t v37 = v207;
            LODWORD(v48) = v207[9];
            unint64_t v46 = (v37[11] + v37[11] * v52) * v207[10] * v48;
            int v203 = v52;
            uint64_t v9 = v206;
            goto LABEL_76;
          }

          unsigned int v51 = v207[11];
          int v53 = v52;
        }

        int v203 = v53;
        v64 = (uint64_t *)&v13[8 * (v50 - v51 * v53) + 40];
        uint64_t v9 = v206;
      }

      else
      {
        v64 = (uint64_t *)&v199[8 * v50];
      }

      int v65 = sub_10002BE74(*v9, *v64);
      if (v65)
      {
        sub_100040B90("error (%d) getting cib %u @ %lld on device %d\n", v66, v67, v68, v69, v70, v71, v72, v65);
        uint64_t v37 = v207;
        LODWORD(v48) = v207[9];
        unint64_t v46 = ((v37[10] + v37[10] * v50) * v48);
        goto LABEL_76;
      }

      uint64_t v37 = v207;
      unint64_t v48 = v207[9];
      int v73 = v207[10] * *((_DWORD *)v213[0] + 8);
      if (v47 == *v204) {
        unsigned int v74 = v195 / v48 - v73 + 1;
      }
      else {
        unsigned int v74 = *((_DWORD *)v213[0] + 9);
      }
      unsigned int v75 = v46 / v48 - v73;
      unsigned int v212 = v75;
      if (v75 < v74)
      {
        unsigned int v196 = v74 - 1;
        unsigned int v197 = v74;
        do
        {
          v76 = v213[0];
          uint64_t v77 = v75;
          v78 = &v213[0][32 * v75];
          v80 = v78 + 64;
          uint64_t v79 = *((void *)v78 + 8);
          if (v79)
          {
            int v81 = sub_10002BE74(*v206, v79);
            unsigned int v75 = v212;
            if (v81)
            {
              sub_100040B90( "error (%d) getting cib bitmap %d @ %lld on device %d\n",  v82,  v83,  v84,  v85,  v86,  v87,  v88,  v81);
              unsigned int v75 = v212 + 1;
              uint64_t v37 = v207;
              LODWORD(v48) = v207[9];
              unint64_t v46 = (v212 + 1 + v207[10] * (_DWORD)v50) * v48;
              uint64_t v13 = v198;
              uint64_t v23 = (void *)v205;
              goto LABEL_75;
            }

            uint64_t v37 = v207;
          }

          if (v47 == *v204 && v75 == v196) {
            uint64_t v90 = v195 - *(void *)&v76[32 * v77 + 48];
          }
          else {
            uint64_t v90 = *((_DWORD *)v78 + 14) & 0xFFFFFLL;
          }
          int64_t v91 = v46 % v37[9];
          v92 = &v76[32 * v77 + 48];
          uint64_t v23 = (void *)v205;
          while (v90 > v91)
          {
            if (!*v80)
            {
              uint64_t v210 = 0LL;
LABEL_66:
              int64_t v209 = v90;
              goto LABEL_67;
            }

LABEL_67:
            int64_t v91 = v209;
            if (v31 + v32 == ((*(void *)v92 + v210) | v208))
            {
              unint64_t v93 = v31;
            }

            else
            {
              uint64_t v32 = (*(void *)v92 + v210) | v208;
              unint64_t v93 = 0LL;
            }

            unint64_t v94 = v209 - v210;
            if (v209 - v210 >= a4 - v93) {
              unint64_t v94 = a4 - v93;
            }
            unint64_t v31 = v94 + v93;
            if (v94 + v93 >= a4)
            {
              uint64_t *v193 = v32;
              uint64_t v13 = v198;
              uint64_t v9 = v206;
              goto LABEL_80;
            }
          }

          uint64_t v37 = v207;
          unint64_t v48 = v207[9];
          unint64_t v46 = v90 + v46 / v48 * v48;
          unsigned int v75 = v212 + 1;
          uint64_t v13 = v198;
LABEL_75:
          uint64_t v9 = v206;
          unsigned int v212 = v75;
        }

        while (v75 < v197);
      }

  unsigned int v51 = (void *)v35[1];
  if (v51) {
    free(v51);
  }
  free(v35);
  return v22;
}

LABEL_76:
      ++v47;
    }

    while (v47 <= *v204);
    a3 = v190;
    int v29 = v191 + 1;
    int v33 = v185;
    unsigned int v34 = v184;
    uint64_t v35 = v183;
  }

  while (v191 + 1 != v186);
LABEL_80:
  if (v31 >= a4)
  {
    uint64_t v96 = v31 + v32;
    if (v32 >= (uint64_t)(v31 + v32))
    {
LABEL_100:
      uint64_t v123 = sub_100002C60((uint64_t)v9, v189, (uint64_t)v207, v200, v31, v62, v63);
      if (!(_DWORD)v123)
      {
        if (sub_10003D370(v32, v31, 0, 0LL, 0)) {
          sub_100040C68( "fsck may bail out with overallocation - could not mark space allocated in fsck's version of the bitmap (%lld + %lld)\n",  v134,  v135,  v136,  v137,  v138,  v139,  v140,  v32);
        }
        uint64_t v141 = v96 - 1;
        if (v188)
        {
          if (v190 == 3)
          {
            uint64_t v26 = 0LL;
          }

          else
          {
            if (v190 == 2)
            {
              uint64_t v181 = 1LL;
              uint64_t v187 = v181;
            }

            uint64_t v26 = 0LL;
            *((void *)&unk_10008DA98 + 13 * v200 + 4 * v187 + 2) = v141;
          }
        }

        else
        {
          uint64_t v26 = 0LL;
          qword_100070F10[v200] = v141;
          dword_100070F20 = v200;
        }

        goto LABEL_83;
      }

      uint64_t v26 = v123;
      char v124 = strerror(v123);
      sub_100040B90("failed to update allocation counts: %s\n", v125, v126, v127, v128, v129, v130, v131, v124);
      sub_100044E7C((char *)0x1F1, v26);
      sub_100002C60((uint64_t)v9, v189, (uint64_t)v207, v200, -(uint64_t)v31, v132, v133);
      uint64_t v97 = v31 + v32;
    }

    else
    {
      uint64_t v97 = v32;
      while (1)
      {
        uint64_t v98 = v207[9];
        uint64_t v99 = v97 % v98;
        uint64_t v100 = v98 - v97 % v98;
        uint64_t v101 = v100 >= v96 - v97 ? v96 - v97 : v100;
        uint64_t v102 = sub_10000A838(v9, v97, (uint64_t)v23, &v211, v213, &v212, 1);
        uint64_t v26 = v102;
        if (!v211 || (_DWORD)v102) {
          break;
        }
        sub_100007FF8((uint64_t)v23, v99, v101);
        uint64_t v103 = sub_10002BFDC(*v9, v211);
        if ((_DWORD)v103)
        {
          uint64_t v26 = v103;
          sub_100040B90("error (%d) writing bitmap @ %lld\n", v104, v105, v106, v107, v108, v109, v110, v103);
          sub_100044E7C((char *)0x1FF, v26);
          break;
        }

        v113 = v213[0];
        *(_DWORD *)&v213[0][32 * v212 + 60] -= v101;
        uint64_t v114 = *((void *)v113 + 1);
        sub_10003A1B8((unint64_t *)v113, (uint32x4_t *)(v113 + 8), (v192 - 8), 0LL, v111, v112);
        uint64_t v115 = sub_10002BFDC(*v9, v114);
        if ((_DWORD)v115)
        {
          uint64_t v26 = v115;
          sub_100040B90("error (%d) writing cib %u @ %lld\n", v116, v117, v118, v119, v120, v121, v122, v115);
          sub_100044E7C((char *)0x200, v26);
          uint64_t v23 = (void *)v205;
          sub_1000080E0(v205, v99, v101);
          uint64_t v142 = sub_10002BFDC(*v9, v211);
          if ((_DWORD)v142)
          {
            uint64_t v150 = v142;
            sub_100040B90("error (%d) writing bitmap @ %lld\n", v143, v144, v145, v146, v147, v148, v149, v142);
            sub_100044E7C((char *)0x1F0, v150);
            uint64_t v26 = v150;
          }

          break;
        }

        v97 += v101;
        uint64_t v23 = (void *)v205;
        if (v97 >= v96) {
          goto LABEL_100;
        }
      }
    }

    if (v32 >= v97) {
      goto LABEL_83;
    }
    while (1)
    {
      int v151 = sub_10000A838(v9, v32, (uint64_t)v23, &v211, v213, &v212, 0);
      if (v211) {
        BOOL v152 = v151 == 0;
      }
      else {
        BOOL v152 = 0;
      }
      if (!v152) {
        goto LABEL_83;
      }
      uint64_t v153 = v207[9];
      uint64_t v154 = v32 % v153;
      uint64_t v155 = v153 - v32 % v153;
      uint64_t v156 = v155 >= v97 - v32 ? v97 - v32 : v155;
      sub_1000080E0((uint64_t)v23, v154, v156);
      int v157 = sub_10002BFDC(*v9, v211);
      if (v157) {
        break;
      }
      v170 = v213[0];
      *(_DWORD *)&v213[0][32 * v212 + 60] += v156;
      uint64_t v171 = *((void *)v170 + 1);
      sub_10003A1B8((unint64_t *)v170, (uint32x4_t *)(v170 + 8), (v192 - 8), 0LL, v165, v166);
      int v172 = sub_10002BFDC(*v9, v171);
      if (v172)
      {
        int v180 = v172;
        sub_100040B90("error (%d) writing cib %u @ %lld\n", v173, v174, v175, v176, v177, v178, v179, v172);
        uint64_t v168 = 514LL;
        int v169 = v180;
        goto LABEL_123;
      }

        unsigned int v190 = 0LL;
        if (!sub_10003B6C4(v152 + 26, v192 - 52, 3, &v190, 0LL, 0LL, 0LL))
        {
          WORD6(v174) |= 0x20u;
          *((void *)&v171 + 1) = *v190;
          sub_100016E74((char *)&v172, *v190, *(uint64_t *)v194, (uint64_t)"purgeable size", v55, v56, v57, v58);
        }

        int v65 = WORD4(v174);
        if ((BYTE8(v174) & 0x40) != 0) {
          WORD6(v174) |= 0x10u;
        }
        goto LABEL_80;
      }
    }

    else if ((BYTE8(v174) & 4) == 0)
    {
      goto LABEL_70;
    }

    unsigned int v190 = 0LL;
    if (!sub_10003B6C4(v152 + 26, v192 - 52, 1, &v190, 0LL, 0LL, 0LL))
    {
      WORD6(v174) |= 8u;
      *((void *)&v170 + 1) = *v190;
      sub_100016E74((char *)&v171, *v190, *(uint64_t *)v194, (uint64_t)"clone size", v55, v56, v57, v58);
    }

    int v65 = WORD4(v174);
    if ((BYTE8(v174) & 8) == 0) {
      goto LABEL_80;
    }
    goto LABEL_76;
  }

  sub_100040B90("failed to allocate memory for dir-stats lookup\n", v47, v48, v49, v13, v14, v15, v16, v147);
  size_t v11 = 12LL;
  sub_100044E7C((char *)0x560, 12);
  uint64_t v59 = 0LL;
LABEL_289:
  free(v59);
LABEL_290:
  sub_100016ADC();
  return v11;
}

LABEL_124:
      v32 += v156;
      uint64_t v23 = (void *)v205;
      if (v32 >= v97) {
        goto LABEL_83;
      }
    }

    int v167 = v157;
    sub_100040B90("error (%d) writing bitmap @ %lld\n", v158, v159, v160, v161, v162, v163, v164, v157);
    uint64_t v168 = 513LL;
    int v169 = v167;
LABEL_123:
    sub_100044E7C((char *)v168, v169);
    goto LABEL_124;
  }

  uint64_t v26 = 28LL;
  uint64_t v27 = 495LL;
  int v28 = 28;
LABEL_82:
  sub_100044E7C((char *)v27, v28);
LABEL_83:
  if (v23) {
    free(v23);
  }
  if (v213[0]) {
    free(v213[0]);
  }
  if (v13) {
    free(v13);
  }
  return v26;
}

uint64_t sub_100002C60( uint64_t a1, int8x16_t *a2, uint64_t a3, unsigned int a4, uint64_t a5, double a6, int8x16_t a7)
{
  *(void *)(a3 + 48LL * a4 + 72) -= a5;
  if (!a2) {
    goto LABEL_11;
  }
  uint64_t v8 = a2[2].i64[1];
  unint64_t v9 = *(void *)(v8 + 72);
  unint64_t v10 = *(void *)(v8 + 88);
  uint64_t v11 = v9 >= v10 ? *(void *)(v8 + 88) : *(void *)(v8 + 72);
  unint64_t v12 = v10 + a5;
  *(void *)(v8 + 88) = v12;
  uint64_t v13 = v9 >= v12 ? v12 : v9;
  uint64_t v14 = v13 - v11;
  if (v14) {
    *(void *)(a3 + 192) += v14;
  }
  uint64_t result = sub_10004227C((uint64_t *)a1, a2);
  if (!(_DWORD)result)
  {
LABEL_11:
    uint64_t v16 = *(void *)(a1 + 24);
    int8x16_t v17 = *(int8x16_t *)(a1 + 88);
    uint64_t v18 = *(void *)(a1 + 104);
    return sub_100023FA8((uint64_t *)a1, 0LL, v16, (uint64_t)&v17, v17, a7);
  }

  return result;
}

uint64_t sub_100002D04( uint64_t *a1, int8x16_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, char a9, char a10)
{
  uint64_t v129 = a5;
  unint64_t v10 = (unsigned int *)a1[3];
  unint64_t v12 = v10[8];
  uint64_t v11 = v10[9];
  char v13 = __clz(__rbit64(v12));
  uint64_t v14 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v13) & a3;
  uint64_t v127 = 0LL;
  uint64_t v128 = a7;
  uint64_t v15 = v14 % v11;
  if (v14 % v11 + a4 > (unint64_t)(8 * v12))
  {
    sub_100040B90( "Spaceman Repair: Cannot modify more than a block's worth of bitmap\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  v118);
    uint64_t v16 = 45LL;
    sub_100044E7C((char *)0x277, 45);
    return v16;
  }

  int v124 = a8;
  uint64_t v20 = a6;
  uint64_t v125 = (uint64_t)a7;
  uint64_t v126 = a6;
  if (!a6)
  {
    uint64_t v21 = malloc(v12);
    a7 = (void *)v125;
    a6 = 0LL;
    uint64_t v20 = (uint64_t)v21;
    if (!v21)
    {
      sub_100040B90( "Spaceman Repair: failed to allocate memory for the bitmap block\n",  v22,  v23,  v24,  v25,  0LL,  v125,  v26,  v118);
      uint64_t v16 = 12LL;
      sub_100044E7C((char *)0x278, 12);
      uint64_t v56 = 0LL;
      uint64_t v35 = 0LL;
      if (!v125) {
        goto LABEL_44;
      }
      goto LABEL_46;
    }
  }

  if (a7)
  {
    if (a5)
    {
      uint64_t v27 = a7;
      if (a6) {
        goto LABEL_13;
      }
    }
  }

  else
  {
    uint64_t v128 = malloc(v12);
    if (!v128)
    {
      sub_100040B90( "Spaceman Repair: failed to allocate memory for the bitmap block\n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v118);
      uint64_t v16 = 12LL;
      uint64_t v46 = 633LL;
      int v47 = 12;
      goto LABEL_28;
    }
  }

  uint64_t v35 = (void *)v20;
  uint64_t v36 = sub_10000A838(a1, a3, v20, &v129, (char **)&v128, 0LL, 1);
  if ((_DWORD)v36)
  {
    uint64_t v16 = v36;
    goto LABEL_43;
  }

  uint64_t v11 = v10[9];
  uint64_t v27 = v128;
LABEL_13:
  int v37 = v27[8];
  unsigned int v120 = v10[10];
  if ((a10 & 1) == 0 && sub_1000081A8(v124 == 1, v20, v15, a4, &v127))
  {
    if (v124 == 1) {
      uint64_t v45 = "bitmap was not entirely unset, stopping allocation\n";
    }
    else {
      uint64_t v45 = "bitmap was not entirely set, stopping deallocation\n";
    }
    sub_100040B90(v45, v38, v39, v40, v41, v42, v43, v44, v118);
    uint64_t v16 = 22LL;
    uint64_t v46 = 634LL;
    int v47 = 22;
LABEL_28:
    sub_100044E7C((char *)v46, v47);
    uint64_t v56 = v126;
    uint64_t v35 = (void *)v20;
    if (!v125) {
      goto LABEL_44;
    }
    goto LABEL_46;
  }

  if (v124 == 1)
  {
    sub_100007FF8(v20, v15, a4);
  }

  else if (v124 == 2)
  {
    sub_1000080E0(v20, v15, a4);
  }

  uint64_t v48 = sub_10002BFDC(*a1, v129);
  if ((_DWORD)v48)
  {
    uint64_t v16 = v48;
    sub_100040B90("error (%d) writing bitmap @ %lld\n", v49, v50, v51, v52, v53, v54, v55, v48);
    uint64_t v46 = 635LL;
    int v47 = v16;
    goto LABEL_28;
  }

  uint64_t v57 = v14 / v11 - v120 * v37;
  uint64_t v58 = *((void *)v128 + 1);
  unint64_t v59 = sub_10000822C(v20, 0, 0LL, *((_DWORD *)v128 + 8 * v57 + 14) & 0xFFFFF);
  uint64_t v62 = 0LL;
  int8x16_t v63 = (char *)v128;
  uint64_t v119 = v57;
  v64 = (char *)v128 + 32 * v57;
  unsigned int v66 = *((_DWORD *)v64 + 15);
  int v65 = v64 + 60;
  unint64_t v67 = v59 - v66;
  uint64_t v35 = (void *)v20;
  if (v59 != v66)
  {
    *int v65 = v59;
    uint64_t v62 = v67;
  }

  uint64_t v121 = v62;
  unint64_t v68 = (v12 - 8);
  sub_10003A1B8((unint64_t *)v63, (uint32x4_t *)(v63 + 8), v68, 0LL, v60, v61);
  uint64_t v69 = sub_10002BFDC(*a1, v58);
  uint64_t v79 = a4;
  if ((_DWORD)v69)
  {
    uint64_t v16 = v69;
    sub_100040B90("error (%d) writing cib during deallocation\n", v70, v71, v72, v73, v74, v75, v76, v69);
    sub_100044E7C((char *)0x27C, v16);
LABEL_36:
    if (v124 == 1)
    {
      sub_1000080E0(v20, v15, v79);
      sub_100007FF8(v20, v15, v79);
    }

    int v92 = sub_10002BFDC(*a1, v129);
    if (v92)
    {
      int v102 = v92;
      sub_100040B90("error (%d) writing bitmap @ %lld\n", v93, v94, v95, v96, v97, v98, v99, v92);
      uint64_t v103 = 638LL;
      int v104 = v102;
    }

    else
    {
      uint64_t v105 = (char *)v128;
      *((_DWORD *)v128 + 8 * v119 + 15) -= v121;
      uint64_t v106 = *((void *)v105 + 1);
      sub_10003A1B8((unint64_t *)v105, (uint32x4_t *)(v105 + 8), v68, 0LL, v100, v101);
      int v107 = sub_10002BFDC(*a1, v106);
      if (!v107) {
        goto LABEL_43;
      }
      int v115 = v107;
      sub_100040B90("error (%d) writing cib\n", v108, v109, v110, v111, v112, v113, v114, v107);
      uint64_t v103 = 639LL;
      int v104 = v115;
    }

    sub_100044E7C((char *)v103, v104);
LABEL_43:
    uint64_t v56 = v126;
    if (!v125) {
      goto LABEL_44;
    }
    goto LABEL_46;
  }

  uint64_t v80 = ((unint64_t)(a3 << v13) >> 62) & 1;
  uint64_t v81 = sub_100002C60((uint64_t)a1, a2, (uint64_t)v10, v80, -v121, v77, v78);
  if ((_DWORD)v81)
  {
    uint64_t v16 = v81;
    char v82 = strerror(v81);
    sub_100040B90("failed to update allocation counts: %s\n", v83, v84, v85, v86, v87, v88, v89, v82);
    sub_100044E7C((char *)0x27D, v16);
    sub_100002C60((uint64_t)a1, a2, (uint64_t)v10, v80, v121, v90, v91);
    uint64_t v79 = a4;
    goto LABEL_36;
  }

  if (!a9)
  {
    uint64_t v16 = 0LL;
    goto LABEL_43;
  }

  uint64_t v117 = v125;
  uint64_t v56 = v126;
  if (v124 == 2)
  {
    sub_10003D4C8(a3, a4, 0);
  }

  else
  {
    if (v124 != 1) {
      goto LABEL_57;
    }
    sub_10003D370(a3, a4, 0, 0LL, 0);
  }

  uint64_t v117 = v125;
  uint64_t v56 = v126;
LABEL_57:
  uint64_t v16 = 0LL;
  if (!v117)
  {
LABEL_44:
    if (v128)
    {
      free(v128);
      uint64_t v56 = v126;
    }
  }

LABEL_46:
  if (!v56 && v35) {
    free(v35);
  }
  return v16;
}

      v5 += 16;
      v6 += 16;
      char v3 = v10;
    }

    while (!*v12)
    {
      if (++v12 >= v11) {
        goto LABEL_19;
      }
    }

    if (!*a5) {
      goto LABEL_48;
    }
LABEL_47:
    if (*v38 == v6)
    {
LABEL_48:
      uint64_t v27 = 0LL;
      goto LABEL_51;
    }

    uint64_t v27 = 0LL;
    *a5 = 0;
LABEL_51:
    free(v29);
    if (v38) {
      goto LABEL_15;
    }
LABEL_16:
    if ((_DWORD)v27) {
      goto LABEL_55;
    }
    if (*a5) {
      goto LABEL_54;
    }
    uint64_t v109 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v113 = 0u;
    uint64_t v114 = 0u;
    uint64_t v111 = 0u;
    uint64_t v112 = 0u;
    *(_OWORD *)__str = 0u;
    int v107 = 0x9000000000000003LL;
    uint64_t v108 = 0;
    *a5 = 0;
    uint64_t v50 = sub_10002A1E0(a1, a2, &v109);
    if ((_DWORD)v50)
    {
      uint64_t v27 = v50;
      sub_100040B90("failed to init fsroot tree for file lookup in directory\n", v51, v52, v53, v54, v55, v56, v57, v98);
      uint64_t v58 = 810LL;
LABEL_22:
      sub_100044E7C((char *)v58, v27);
      goto LABEL_23;
    }

    unint64_t v59 = sub_100035838((uint64_t)__str, v109, a3, &v107, 0xCu);
    if ((_DWORD)v59)
    {
      uint64_t v27 = v59;
      int8x16_t v60 = strerror(v59);
      sub_100040B90( "unable to initialize fsroot tree iterator for file lookup in directory: %s\n",  v61,  v62,  v63,  v64,  v65,  v66,  v67,  v60);
      uint64_t v58 = 803LL;
      goto LABEL_22;
    }

    while (1)
    {
      if (BYTE8(v112) || *(void *)v111 != 0x9000000000000003LL)
      {
        uint64_t v27 = 0LL;
        goto LABEL_23;
      }

      if (**((void **)&v111 + 1) == v6) {
        break;
      }
      uint64_t v70 = (*(uint64_t (**)(char *))&__str[8])(__str);
      if ((_DWORD)v70)
      {
        uint64_t v27 = v70;
        uint64_t v71 = strerror(v70);
        sub_100040B90( "error iterating fsroot tree for file lookup in directory: %s\n",  v72,  v73,  v74,  v75,  v76,  v77,  v78,  v71);
        uint64_t v58 = 804LL;
        goto LABEL_22;
      }
    }

    uint64_t v27 = 0LL;
    *a5 = 1;
LABEL_23:
    if (*(void *)__str) {
      (*(void (**)(char *))__str)(__str);
    }
    if ((_DWORD)v27) {
      goto LABEL_55;
    }
    if (*a5) {
      goto LABEL_54;
    }
    uint64_t v103 = v6 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
    int8x16_t v101 = 3808;
    unint64_t v68 = sub_100034BB4(v104, a3, 0LL, &v103, &v102, v102, v18, &v101);
    if ((_DWORD)v68) {
      break;
    }
    uint64_t v27 = 0LL;
    unsigned int v6 = *v18;
    goto LABEL_55;
  }

  double v90 = v68;
  uint64_t v27 = 0LL;
  if ((_DWORD)v68 != 2)
  {
    strerror(v68);
    sub_100040B90( "unable to load inode (oid 0x%llx) for file lookup in purgatory directory: %s\n",  v91,  v92,  v93,  v94,  v95,  v96,  v97,  v6);
    sub_100044E7C((char *)0x322, v90);
    uint64_t v27 = v90;
  }

uint64_t sub_1000031FC(uint64_t *a1, int8x16_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a4 + a3;
  if (a4 + a3 <= a3) {
    return 0LL;
  }
  uint64_t v7 = a3;
  unint64_t v10 = *(unsigned int *)(a1[3] + 36);
  uint64_t v11 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(a1[3] + 32)));
  while (1)
  {
    unint64_t v12 = (v7 & (unint64_t)v11) / v10;
    uint64_t v13 = v5 - v7 >= v10 + v12 * v10 - (v7 & v11) ? v10 + v12 * v10 - (v7 & v11) : v5 - v7;
    uint64_t result = sub_100002D04(a1, a2, v7, v13, 0LL, 0LL, 0LL, a5, 1, 0);
    if ((_DWORD)result) {
      break;
    }
    v7 += v13;
    if (v7 >= v5) {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1000032D0(uint64_t *a1, int8x16_t *a2, uint64_t a3, uint64_t a4)
{
  return sub_1000031FC(a1, a2, a3, a4, 2LL);
}

uint64_t sub_1000032D8( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, _BYTE *a5, uint64_t (*a6)(unint64_t, uint64_t, uint64_t, uint64_t), uint64_t a7)
{
  if (a2 + a1 > a3 && a4 + a3 > a1)
  {
    *a5 = 1;
    if (a1 <= a3) {
      unint64_t v14 = a3;
    }
    else {
      unint64_t v14 = a1;
    }
    unint64_t v15 = v14 - a1;
    if (a2 - (v14 - a1) >= a3 - v14 + a4) {
      uint64_t v16 = a3 - v14 + a4;
    }
    else {
      uint64_t v16 = a2 - (v14 - a1);
    }
    uint64_t result = a6(v14, v16, 1LL, a7);
    if (!(_DWORD)result)
    {
      if (a1 >= a3 || (uint64_t result = a6(a1, v15, 0LL, a7), !(_DWORD)result))
      {
        if (a2 - v16 <= v15) {
          return 0LL;
        }
        uint64_t result = a6(v16 + v14, a2 - v16 - v15, 0LL, a7);
        if (!(_DWORD)result) {
          return 0LL;
        }
      }
    }
  }

  else
  {
    uint64_t result = 0LL;
    *a5 = 0;
  }

  return result;
}

unint64_t sub_1000033C0(unint64_t result)
{
  if (!(byte_10008DAF8 | byte_10008DB60))
  {
    uint64_t v1 = 0LL;
    uint64_t v2 = *(void *)(result + 24);
    char v3 = 1;
    do
    {
      char v4 = v3;
      unint64_t v5 = *(unsigned int *)(v2 + 32);
      unint64_t v6 = *(void *)(v2 + 48 * v1 + 48);
      memset(v12, 170, sizeof(v12));
      if (is_mul_ok(v6, v5)) {
        unint64_t v7 = v6 * v5;
      }
      else {
        unint64_t v7 = 0x40000000000LL;
      }
      uint64_t result = sub_100028D78(0LL, v5, v6, v7, &v12[2], &v12[1]);
      if (!(_DWORD)result)
      {
        uint64_t v8 = v12[2] / v5 + v12[1];
        uint64_t result = sub_100028E80(v5, v12[2], v12[1], v8, v12, 0LL);
        uint64_t v10 = v12[0];
        uint64_t v9 = v12[1];
        uint64_t v11 = (char *)&unk_10008DA98 + 104 * v1;
        *((void *)v11 + 1) = v12[0];
        *((void *)v11 + 2) = v9;
        *(void *)uint64_t v11 = v9;
        v11[24] = 1;
        *((void *)v11 + 5) = v8;
        *((void *)v11 + 6) = v10;
        *((void *)v11 + 4) = v10;
        v11[56] = 1;
      }

      char v3 = 0;
      *((_BYTE *)&unk_10008DA98 + 104 * v1 + 96) = 1;
      uint64_t v1 = 1LL;
    }

    while ((v4 & 1) != 0);
  }

  return result;
}

uint64_t sub_1000034D8( unint64_t a1, uint64_t a2, int a3, void (*a4)(_OWORD *, uint64_t, uint64_t), uint64_t a5)
{
  unint64_t v19 = a1;
  v22[0] = 0xAAAAAAAAAAAAAAAALL;
  v22[1] = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v8 = a1 + a2;
  int v17 = 0;
  int v18 = -1431655766;
  int v16 = 0;
  char v15 = 1;
  do
  {
    *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v21[6] = v9;
    v21[7] = v9;
    v21[5] = v9;
    v21[3] = v9;
    v21[4] = v9;
    v21[1] = v9;
    v21[2] = v9;
    v20[1] = v9;
    v21[0] = v9;
    v20[0] = v9;
    unsigned int v14 = 0;
    char v13 = 0;
    uint64_t v10 = sub_100003630( &v19,  v8,  a3,  (unsigned int *)v22,  (uint64_t)&v18,  &v17,  &v16,  (uint64_t)v21,  (uint64_t)v20,  (int *)&v14,  &v13,  &v15);
    if ((_DWORD)v10) {
      break;
    }
    uint64_t v11 = v14;
    if ((int)v14 >= 1)
    {
      if (v13) {
        sub_100003DE8((uint64_t)v21, (uint64_t)v20, v14);
      }
      a4(v21, 4 * v11, a5);
    }
  }

  while (v19 < v8 || v17 > 0);
  return v10;
}

uint64_t sub_100003630( unint64_t *a1, unint64_t a2, int a3, unsigned int *a4, uint64_t a5, int *a6, int *a7, uint64_t a8, uint64_t a9, int *a10, _BYTE *a11, _BYTE *a12)
{
  int v18 = *a6;
  int v19 = *a7;
  if (*a6 >= 1 && v19 < v18)
  {
    int v22 = 0;
    *a11 = 0;
    *a10 = 0;
    int v19 = *a7;
    while (1)
    {
      if (v22 >= 1
        && *(_BYTE *)(a5 + v19)
        && *(unsigned __int8 *)(a5 + v19) < *(unsigned __int8 *)(a9 + (v22 - 1)))
      {
        *a11 = 1;
      }

      *(_DWORD *)(a8 + 4LL * v22) = a4[v19];
      uint64_t v23 = *a7;
      *a7 = v23 + 1;
      LOBYTE(v23) = *(_BYTE *)(a5 + v23);
      uint64_t v24 = *a10;
      *a10 = v24 + 1;
      *(_BYTE *)(a9 + v24) = v23;
      int v19 = *a7;
      int v18 = *a6;
      if (*a7 >= *a6 || !*(_BYTE *)(a5 + v19)) {
        break;
      }
      int v22 = *a10;
    }
  }

  if (v19 < v18) {
    return 0LL;
  }
  uint64_t result = 0LL;
  *a6 = 0;
  *a7 = 0;
  uint64_t v25 = (unsigned __int8 *)*a1;
  if (*a1 < a2)
  {
    while (1)
    {
      uint64_t v27 = v25 + 1;
      *a1 = (unint64_t)(v25 + 1);
      unsigned int v28 = *v25;
      uint64_t result = 92LL;
      if (!*v25 || v28 == 47) {
        return result;
      }
      if ((v28 & 0x80) == 0)
      {
        uint64_t result = 0LL;
        if (v28 - 91 < 0xFFFFFFE6) {
          int v66 = 1;
        }
        else {
          int v66 = a3;
        }
        if (v66) {
          unsigned int v67 = *v25;
        }
        else {
          unsigned int v67 = v28 + 32;
        }
        *a4 = v67;
        *a6 = 1;
        *(_BYTE *)a5 = 0;
        goto LABEL_136;
      }

      if (v28 - 225 > 0xB)
      {
        if (v28 - 194 <= 0x1D && (unint64_t)v27 < a2)
        {
          unsigned int v33 = *v27 ^ 0x80;
          if (v33 <= 0x3F)
          {
            unsigned int v31 = ((v28 & 0x1F) << 6) | v33;
            uint64_t v27 = v25 + 2;
            goto LABEL_52;
          }
        }
      }

      else if ((unint64_t)(v25 + 2) < a2)
      {
        unsigned int v29 = *v27 ^ 0x80;
        if (v29 <= 0x3F)
        {
          unsigned int v30 = v25[2] ^ 0x80;
          if (v30 <= 0x3F)
          {
            unsigned int v31 = ((v28 & 0xF) << 12) | (v29 << 6) | v30;
            uint64_t v27 = v25 + 3;
            goto LABEL_52;
          }
        }
      }

      if (v28 > 0xEF)
      {
        if (v28 > 0xFD)
        {
          unsigned __int8 v36 = 0;
          goto LABEL_41;
        }

        if (v28 <= 0xF7) {
          char v34 = 3;
        }
        else {
          char v34 = 4;
        }
        BOOL v35 = v28 > 0xFB;
      }

      else
      {
        char v34 = v28 > 0xDF;
        BOOL v35 = v28 > 0xBF;
      }

      if (v35) {
        unsigned __int8 v36 = v34 + 1;
      }
      else {
        unsigned __int8 v36 = v34;
      }
LABEL_41:
      unsigned int v31 = -1;
      if ((unint64_t)&v27[v36] <= a2)
      {
        unsigned int v37 = v28 & ~(-1 << (6 - v36));
        if (v36 == 1) {
          goto LABEL_49;
        }
        if (v36 == 2
          || v36 == 3
          && (uint64_t v27 = v25 + 2, v38 = v25[1] ^ 0x80, v31 = -1, v38 <= 0x3F)
          && (unsigned int v37 = v38 | (v37 << 6), v37 <= 0x10F))
        {
          int v39 = *v27++;
          int v40 = v39 ^ 0x80;
          unsigned int v31 = -1;
          if ((v39 ^ 0x80u) <= 0x3F)
          {
            unsigned int v37 = v40 | (v37 << 6);
            if ((v37 & 0xFFE0) != 0x360)
            {
LABEL_49:
              int v41 = *v27++;
              int v42 = v41 ^ 0x80;
            }
          }
        }
      }

LABEL_52:
      *a1 = (unint64_t)v27;
      *(_BYTE *)a5 = 0;
      if (v31 >= 0xF0000)
      {
        if ((~v31 & 0xFFFE) == 0) {
          goto LABEL_137;
        }
LABEL_55:
        *a4 = v31;
        goto LABEL_63;
      }

      int v43 = v31;
      if (v31 >> 10 >= 0xC9)
      {
        if (v31 - 918016 < 0xFFFFFE00) {
          goto LABEL_137;
        }
        int v43 = v31 - 711680;
      }

      int v44 = (unsigned __int16)word_1000633C8[v43 >> 8];
      if (!word_1000633C8[v43 >> 8]) {
        goto LABEL_62;
      }
      if (v44 == 0xFFFF) {
        goto LABEL_137;
      }
      if ((v44 & 0xFF00) == 0xAD00)
      {
LABEL_62:
        *a4 = v31;
        *(_BYTE *)a5 = v44;
        goto LABEL_63;
      }

      int v52 = word_100065DD0[16 * (v44 & 0xFFF) + (v43 >> 4)];
      if (!v52)
      {
LABEL_83:
        *a4 = v31;
        *(_BYTE *)a5 = v52;
        goto LABEL_84;
      }

      if (v52 == 0xFFFF) {
        goto LABEL_137;
      }
      if ((v52 & 0xFF00) == 0xAE00)
      {
        *a4 = v31;
        int v45 = 1;
        if (v31 <= 0x4FF && (a3 & 1) == 0) {
          *a4 = word_100067030[v31];
        }
        goto LABEL_64;
      }

      if ((v52 & 0xFF00) == 0xAD00) {
        goto LABEL_83;
      }
      if (v52 == 44032 || (unsigned int v54 = (unsigned __int16)word_100067A30[16 * (v52 & 0xFFF) + (v43 & 0xF)], v54 == 44032))
      {
LABEL_77:
        signed int v48 = v31 - 44032;
        int v49 = v48 / 28;
        int v50 = v48 / 588;
        *(_WORD *)(a5 + 1) = 0;
        int v51 = v48 % 28;
        *a4 = v50 + 4352;
        a4[1] = (unsigned __int16)(v49
                                 - 21
                                 * (((__int16)((49933 * (__int16)v49) >> 16) >> 4)
        if (v51)
        {
          a4[2] = v51 + 4519;
          int v45 = 3;
        }

        else
        {
          int v45 = 2;
        }

        goto LABEL_64;
      }

      if (v54 == 0xFFFF)
      {
LABEL_137:
        int v68 = -1;
        goto LABEL_138;
      }

      if (((unsigned __int16)(v54 + 1792) >> 8) <= 0xB6u)
      {
        if (!v54 || (v54 & 0xFF00) == 0xAD00)
        {
          *a4 = v31;
          *(_BYTE *)a5 = v54;
        }

        else
        {
          *a4 = v54;
        }

            unsigned int v33 = a2 + 28;
            if ((a2[16] & 4) != 0) {
              v33[2 * a3 + 1] = -1;
            }
            else {
              *(_DWORD *)&v33[4 * a3 + 2] = 0xFFFF;
            }
            goto LABEL_55;
          }

          *(_DWORD *)&v32[4 * a3] = 0xFFFF;
        }

        if (!v30) {
          goto LABEL_55;
        }
        goto LABEL_52;
      }

      unsigned int v29 = v28;
    }

    else
    {
      unsigned int v29 = 0LL;
    }

    unsigned int v30 = a6;
    goto LABEL_45;
  }

  return v15 <= v25;
}

LABEL_84:
        if ((a3 & 1) == 0)
        {
          uint64_t v53 = (int)*a4;
          if ((int)v53 <= 1279)
          {
            unsigned int v31 = word_100067030[v53];
            goto LABEL_55;
          }
        }

      LOBYTE(v73) = 0;
LABEL_85:
      v77[0] = v23 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000LL;
      int v50 = v18[1];
      uint64_t v74 = v25 & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v72 << 60);
      uint64_t v75 = v50;
      uint64_t v76 = *((_DWORD *)v18 + 4);
      if (v37) {
        int v51 = &v74;
      }
      else {
        int v51 = 0LL;
      }
      int v52 = sub_10001F270(v69, v77, v51, *(void *)(a2 + 56), v37, BYTE4(v73) & 1);
      int v22 = &off_100070000;
      if ((_DWORD)v52) {
        return v52;
      }
LABEL_89:
      if (!v20) {
        break;
      }
LABEL_94:
      if (!v13) {
        goto LABEL_111;
      }
    }

    if (*((_BYTE *)v22 + 112)) {
      goto LABEL_93;
    }
    uint64_t v53 = (*((uint64_t (**)(__int128 *))&xmmword_100070048 + 1))(&xmmword_100070048);
    if ((_DWORD)v53)
    {
      char v15 = v53;
      unsigned int v57 = strerror(v53);
      sub_100040B90("error iterating physical extent tree: %s\n", v58, v59, v60, v61, v62, v63, v64, v57);
      sub_100044E7C((char *)0x466, v15);
      return v15;
    }

    if (*((_BYTE *)v22 + 112))
    {
LABEL_93:
      uint64_t v20 = 0LL;
      goto LABEL_94;
    }

    int v18 = qword_100070060;
    unsigned int v67 = (unint64_t *)qword_100070058;
    int v19 = *(void *)qword_100070058;
    uint64_t v20 = *qword_100070060 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v55 = *qword_100070060 >> 60;
    sub_10001EB70(v66, a2, *(void *)qword_100070058, v20, v55);
    uint64_t v72 = v55;
    int v22 = &off_100070000;
  }

  while (v13);
LABEL_111:
  if ((v73 & 1) == 0) {
    goto LABEL_113;
  }
  v77[0] = *v70;
  char v15 = sub_10001F270(v69, v77, 0LL, *(void *)(a2 + 56), 0, BYTE4(v73) & 1);
LABEL_114:
  *unsigned int v67 = v19;
  *int v18 = v20 & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v72 << 60);
  return v15;
}

LABEL_63:
        int v45 = 1;
LABEL_64:
        *a6 = v45;
        goto LABEL_65;
      }

      switch(((v54 & 0xF000) - 45056) >> 12)
      {
        case 0u:
          if ((v54 & 0x800) != 0 && a3) {
            goto LABEL_55;
          }
          uint64_t v69 = 0LL;
          uint64_t v55 = (char *)&unk_100063B22 + 4 * (v54 & 0x7FF);
          int v45 = 2;
          goto LABEL_113;
        case 1u:
          if ((v54 & 0x800) != 0 && a3) {
            goto LABEL_55;
          }
          uint64_t v69 = 0LL;
          uint64_t v55 = (char *)&unk_100064736 + 6 * (v54 & 0x7FF);
          int v45 = 3;
          goto LABEL_113;
        case 2u:
          uint64_t v69 = 0LL;
          uint64_t v56 = (unsigned __int16 *)((char *)&unk_100064C6A + 2 * (v54 & 0x3FF));
          unsigned int v58 = *v56;
          uint64_t v55 = (char *)(v56 + 1);
          unsigned int v57 = v58;
          goto LABEL_112;
        case 3u:
          if ((v54 & 0x800) != 0 && a3) {
            goto LABEL_55;
          }
          uint64_t v55 = 0LL;
          uint64_t v69 = (int *)((char *)&unk_100064DF8 + 4 * (v54 & 0x7FF));
          int v45 = 1;
          goto LABEL_113;
        case 4u:
          uint64_t v55 = 0LL;
          unint64_t v59 = (_DWORD *)((char *)&unk_100065C74 + 4 * (v54 & 0x3FF));
          unsigned int v57 = *v59;
          uint64_t v69 = v59 + 1;
LABEL_112:
          int v45 = v57 & 0xF;
          *(_BYTE *)a5 = v57 >> 4;
          if ((v45 - 5) < 0xFFFFFFFC)
          {
            int v68 = 0;
LABEL_138:
            *a6 = v68;
            return result;
          }

  uint64_t v139 = (uint64_t *)(a2 + 48);
  uint64_t v55 = v144;
  uint64_t v143 = sub_100004940(v102, *((unsigned __int16 *)v144 + 24));
  if (v140 && !v143)
  {
    if (*(_BYTE *)(a2 + 9)) {
      goto LABEL_69;
    }
    uint64_t v103 = *v139;
    if (!*v139) {
      uint64_t v103 = *(void *)(a2 + 40);
    }
    if ((*(_BYTE *)(v103 + 56) & 0x20) != 0) {
LABEL_69:
    }
      sub_10001E358((char *)a2);
  }

  if (*(_BYTE *)(a2 + 9))
  {
    *(void *)&int v104 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v104 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v152[32] = v104;
    *(_OWORD *)&v152[48] = v104;
    *(_OWORD *)BOOL v152 = v104;
    *(_OWORD *)&v152[16] = v104;
    sub_1000132EC(0LL, *a3);
    sub_1000050C0((uint64_t)a1, a2, *a3);
    uint64_t v20 = sub_1000057F4(a1, (int8x16_t *)a2, *a3);
    if ((_DWORD)v20) {
      goto LABEL_102;
    }
    sub_10000DE7C( (uint64_t)v152,  (uint64_t)a1,  a2,  *(_DWORD *)(*(void *)(a2 + 40) + 116LL),  14,  *(void *)(*(void *)(a2 + 48) + 136LL));
    uint64_t v20 = sub_100031CD0( (uint64_t)v152,  *a3,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10000E49C,  a7,  0LL,  0);
    if ((_DWORD)v20) {
      goto LABEL_102;
    }
    if (*(void *)(*(void *)(a2 + 40) + 1096LL))
    {
      uint64_t v20 = sub_100013374((uint64_t)a1, a2, 0LL, v105, v106, v107, v108, v109);
      if ((_DWORD)v20) {
        goto LABEL_102;
      }
      sub_10000DE7C( (uint64_t)v152,  (uint64_t)a1,  a2,  *(_DWORD *)(*(void *)(a2 + 40) + 1104LL),  36,  *(void *)(*(void *)(a2 + 48) + 1096LL));
      uint64_t v20 = sub_100031CD0( (uint64_t)v152,  *a3,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10000E49C,  a7,  0LL,  0);
      if ((_DWORD)v20) {
        goto LABEL_102;
      }
    }

    uint64_t v20 = sub_10002B08C((uint64_t)a1, a2);
    if ((_DWORD)v20) {
      goto LABEL_102;
    }
    uint64_t v20 = sub_1000133C4(a1, (void *)a2, *a3, 0LL, v110, v111, v112, v113);
    if ((_DWORD)v20) {
      goto LABEL_102;
    }
    uint64_t v20 = sub_100005648((uint64_t)a1, a2, *a3);
    if ((_DWORD)v20) {
      goto LABEL_102;
    }
  }

  uint64_t v114 = *v139;
  int v115 = *v139;
  if (!*v139) {
    int v115 = *(void *)(a2 + 40);
  }
  if ((*(_BYTE *)(v115 + 56) & 0x20) != 0)
  {
    *(void *)&uint64_t v116 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v116 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v152[32] = v116;
    *(_OWORD *)&v152[48] = v116;
    *(_OWORD *)BOOL v152 = v116;
    *(_OWORD *)&v152[16] = v116;
    sub_10000DF04((uint64_t)v152, (uint64_t)a1, a2, *(_DWORD *)(*(void *)(a2 + 40) + 1040LL), *(void *)(v114 + 1032));
    uint64_t v117 = sub_100031CD0( (uint64_t)v152,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10001320C,  a7,  0LL,  1);
    if ((_DWORD)v117)
    {
LABEL_101:
      uint64_t v20 = v117;
      goto LABEL_102;
    }
  }

  if (!v140) {
    goto LABEL_100;
  }
  *(void *)&char v118 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v118 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v152[32] = v118;
  *(_OWORD *)&v152[48] = v118;
  *(_OWORD *)BOOL v152 = v118;
  *(_OWORD *)&v152[16] = v118;
  sub_10000DF58((uint64_t)v152, (uint64_t)a1, a2, v141, v140);
  uint64_t v119 = sub_100031CD0( (uint64_t)v152,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10000E49C,  a7,  0LL,  1);
  if (!(_DWORD)v119)
  {
LABEL_100:
    uint64_t v117 = sub_10001F304(a2, *a3);
    if (!(_DWORD)v117)
    {
      uint64_t v129 = *(void *)(a2 + 40);
      if ((*(_BYTE *)(v129 + 56) & 0x40) != 0)
      {
        *(void *)&uint64_t v130 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v130 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v152[32] = v130;
        *(_OWORD *)&v152[48] = v130;
        *(_OWORD *)BOOL v152 = v130;
        *(_OWORD *)&v152[16] = v130;
        sub_10000DFA8( (uint64_t)v152,  (uint64_t)a1,  a2,  *(_DWORD *)(v129 + 1044),  *(void *)(*(void *)(a2 + 48) + 1048LL));
        uint64_t v131 = sub_100031CD0( (uint64_t)v152,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100030818,  a7,  0LL,  1);
        uint64_t v137 = sub_1000306CC((uint64_t)a1, a2, 0LL, v132, v133, v134, v135, v136);
        if (v131) {
          uint64_t v20 = v131;
        }
        else {
          uint64_t v20 = v137;
        }
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      goto LABEL_102;
    }

    goto LABEL_101;
  }

  uint64_t v20 = v119;
  uint64_t v21 = 0;
LABEL_102:
  uint64_t v73 = v143;
LABEL_103:
  free(v55);
  free(v47);
  if (!v73) {
    goto LABEL_20;
  }
  int v22 = 1;
LABEL_21:
  sub_100029754(a2, v22);
  if ((_DWORD)v20 == 92)
  {
    sub_10001CDE4(1);
    sub_100013338(a2);
    sub_1000051F4();
    uint64_t v20 = 0LL;
    *(_BYTE *)(a2 + 11) = 1;
    *(_BYTE *)(a2 + 13) = 1;
  }

  uint64_t v23 = 0LL;
  uint64_t v24 = 1;
  do
  {
    uint64_t v25 = v24;
    uint64_t v26 = *(void *)(a2 + 8 * v23 + 24);
    if (v26) {
      sub_10001BC18(v26);
    }
    uint64_t v24 = 0;
    uint64_t v23 = 1LL;
  }

  while ((v25 & 1) != 0);
  sub_10001BC18(*a1);
  return v20;
}

LABEL_113:
          uint64_t v60 = 0LL;
          uint64_t v70 = a12;
          int v71 = a3;
          do
          {
            if (v55)
            {
              int v62 = *(unsigned __int16 *)v55;
              v55 += 2;
              int v61 = v62;
            }

            else
            {
              int v61 = *v69++;
            }

            a4[v60] = v61;
            if (v60)
            {
              uint64_t v72 = v60;
              uint64_t v73 = v55;
              char v63 = sub_100003E6C(v61);
              uint64_t v60 = v72;
              uint64_t v55 = v73;
              *(_BYTE *)(a5 + v72) = v63;
            }

            ++v60;
            a12 = v70;
            a3 = v71;
          }

          while (v45 != v60);
          if ((v71 & 1) != 0) {
            goto LABEL_126;
          }
          uint64_t v64 = (int)*a4;
          uint64_t v65 = (v45 - 1);
LABEL_126:
          *a6 = v45;
          if (v45 < 1) {
            return 92LL;
          }
          break;
        default:
          goto LABEL_137;
      }

    int v104 = sub_100029834(&v175, 0LL);
    if (!v104)
    {
      int v104 = sub_1000298D0(&v175, 0LL);
      if (!v104)
      {
        int v104 = sub_10002996C(&v175, 0LL, 0LL);
        if (!v104)
        {
          v212[0] = 0LL;
          int v104 = sub_100029B94(&v175, 0LL, v212);
          if (!v104)
          {
            int v104 = sub_100031CD0(v212[0], 0LL, 0LL, 0LL, 0LL, 0);
            if (!v104)
            {
              v211[0] = 0LL;
              int v115 = v176;
              if (!*(_DWORD *)(v176 + 180))
              {
                int v104 = 0;
                goto LABEL_118;
              }

              for (int i = 0LL; i < *(unsigned int *)(v115 + 180); ++i)
              {
                uint64_t v117 = *(void *)(v115 + 8 * i + 184);
                if (v117)
                {
                  char v118 = sub_100022BD0(&v175, 0LL, 0, v117, 0LL, 0, 13, 0, v211, 0LL, 0);
                  if (v118)
                  {
                    int v104 = v118;
                    break;
                  }

                  free(v211[0]);
                  v211[0] = 0LL;
                  int v115 = v176;
                }

                int v104 = 0;
              }
            }
          }
        }
      }
    }

LABEL_65:
      if (!*(_BYTE *)a5 || *a12)
      {
        uint64_t result = 0LL;
LABEL_136:
        *a12 = 0;
        return result;
      }

      int v46 = *a10;
      if (v45 + *a10 > 32) {
        return 92LL;
      }
      uint64_t v47 = 0LL;
      do
      {
        if (v46 >= 1
          && *(_BYTE *)(a5 + v47)
          && *(unsigned __int8 *)(a5 + v47) < *(unsigned __int8 *)(a9 + (v46 - 1)))
        {
          *a11 = 1;
        }

        *(_DWORD *)(a8 + 4LL * v46) = a4[v47];
        *(_BYTE *)(a9 + *a10) = *(_BYTE *)(a5 + v47++);
        int v46 = *a10 + 1;
        *a10 = v46;
      }

      while (v47 < *a6);
      *a6 = 0;
      uint64_t v25 = (unsigned __int8 *)*a1;
      if (*a1 >= a2) {
        return 0LL;
      }
    }
  }

  return result;
}

    if ((void)v94)
    {
      free((void *)v94);
      uint64_t v27 = v81;
    }

    if ((_DWORD)v54) {
      return v54;
    }
    if (!v49)
    {
      *(void *)&uint64_t v94 = v76;
      *((void *)&v94 + 1) = v42;
      uint64_t v95 = 0LL;
      if (!v48) {
        signed int v48 = &v94;
      }
      while (1)
      {
        uint64_t v65 = (__int128 *)*((void *)v48 + 2);
        if (a10 && *((void *)v48 + 1)) {
          *a10 = 1;
        }
        if (!a8) {
          goto LABEL_83;
        }
        unsigned int v67 = *(void *)v48;
        int v66 = *((void *)v48 + 1);
        if (!v27) {
          goto LABEL_82;
        }
        if (v27 + v26 != v67) {
          break;
        }
        v27 += v66;
LABEL_83:
        if (v48 != &v94)
        {
          int v68 = v27;
          free(v48);
          uint64_t v27 = v68;
        }

        signed int v48 = v65;
        if (!v65) {
          goto LABEL_86;
        }
      }

      ((void (*)(uint64_t, uint64_t))a8)(a1, v26);
LABEL_82:
      uint64_t v26 = v67;
      uint64_t v27 = v66;
      goto LABEL_83;
    }

    if ((v88 & 1) == 0 && byte_10008CA04[v73]) {
      *((void *)&xmmword_10008D048 + 1) += v42;
    }
LABEL_86:
    if (v91 >= a7)
    {
LABEL_93:
      uint64_t v24 = v89;
      goto LABEL_96;
    }
  }

uint64_t sub_100003DE8(uint64_t result, uint64_t a2, unsigned int a3)
{
  if ((int)a3 >= 2)
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = result + 4LL * a3 - 4;
    do
    {
      uint64_t v5 = *(unsigned __int8 *)(a2 + a3 - 1LL);
      unint64_t v6 = (int *)v4;
      uint64_t v7 = a3 - 2LL;
      do
      {
        uint64_t v8 = *(unsigned __int8 *)(a2 + v7);
        if (v5 < v8)
        {
          __int128 v9 = (_BYTE *)(a2 + v7);
          int v10 = *v6;
          *unint64_t v6 = *(v6 - 1);
          uint64_t result = *(unsigned __int8 *)(a2 + v7);
          v9[1] = result;
          *(v6 - 1) = v10;
          *__int128 v9 = v5;
          uint64_t v8 = v5;
        }

        --v6;
        uint64_t v5 = v8;
      }

      while (v7-- > v3);
      ++v3;
    }

    while (v3 != a3 - 1);
  }

  return result;
}

uint64_t sub_100003E6C(int a1)
{
  if (a1 >= 983040) {
    return 0LL;
  }
  if (a1 == 953) {
    return 240LL;
  }
  int v2 = a1 - 711680;
  if (a1 <= 205823) {
    int v2 = a1;
  }
  LOWORD(v3) = word_1000633C8[v2 >> 8];
  if ((_WORD)v3) {
    BOOL v4 = (v3 & 0xFF00) == 44288;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return v3;
  }
  int v3 = word_100065DD0[16 * (v3 & 0xFFF) + (v2 >> 4)];
  if (!v3) {
    return v3;
  }
  if ((v3 & 0xFF00) == 0xAE00) {
    return 0LL;
  }
  if ((v3 & 0xFF00) == 0xAD00) {
    return v3;
  }
  __int16 v5 = word_100067A30[16 * (v3 & 0xFFF) + (v2 & 0xF)];
  if ((v5 & 0xFF00) == 0xAD00) {
    return v5;
  }
  else {
    return 0LL;
  }
}

const char *sub_100003F34()
{
  return "2317.60.23.0.1";
}

uint64_t sub_100003F40( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    vars0g);
  sub_10004096C( "       -b <num>      set default cache block size to <num> KiB\n",  v58,  v59,  v60,  v61,  v62,  v63,  v64,  vars0h);
  sub_10004096C("       -c            enable cache statistics\n", v65, v66, v67, v68, v69, v70, v71, vars0i);
  sub_10004096C( "       -C            force a sync prior to freezing for live fsck\n",  v72,  v73,  v74,  v75,  v76,  v77,  v78,  vars0j);
  sub_10004096C("       -d            print extra debugging information\n", v79, v80, v81, v82, v83, v84, v85, vars0k);
  sub_10004096C( "       -E <path>     write warning/error information to <path>; Use - for stdout\n",
    v86,
    v87,
    v88,
    v89,
    v90,
    v91,
    v92,
    vars0l);
  sub_10004096C("       -F            force checking of encrypted volumes\n", v93, v94, v95, v96, v97, v98, v99, vars0m);
  sub_10004096C( "       -M            skip checks which require encrypted volumes to be unlocked\n",  v100,  v101,  v102,  v103,  v104,  v105,  v106,  vars0n);
  sub_10004096C( "       -g            print output in form suitable for automatic parsing\n",  v107,  v108,  v109,  v110,  v111,  v112,  v113,  vars0o);
  sub_10004096C("       -x            print output in XML\n", v114, v115, v116, v117, v118, v119, v120, vars0p);
  sub_10004096C("       -W            treat warnings as errors\n", v121, v122, v123, v124, v125, v126, v127, vars0q);
  sub_10004096C("       -T            tree node repair\n", v128, v129, v130, v131, v132, v133, v134, vars0r);
  return sub_10004096C("       -D            scavenge disk\n", v135, v136, v137, v138, v139, v140, v141, a9);
}

char *sub_10000403C(const char *a1, _DWORD *a2)
{
  CFMutableDictionaryRef properties = 0LL;
  *a2 = -1;
  if (!strncmp(a1, "/dev/", 5uLL)) {
    uint64_t v4 = 5LL;
  }
  else {
    uint64_t v4 = 0LL;
  }
  __int16 v5 = &a1[v4];
  if (*v5 == 114) {
    unint64_t v6 = v5 + 1;
  }
  else {
    unint64_t v6 = v5;
  }
  if (strncmp(v6, "disk", 4uLL))
  {
    sub_100040C68("%s: not a valid disk name/path\n", v7, v8, v9, v10, v11, v12, v13, (char)a1);
    return 0LL;
  }

  uint64_t v14 = IOBSDNameMatching(kIOMasterPortDefault, 0, v6);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v14);
  if (!MatchingService)
  {
    sub_100040C68("%s: couldn't find APFS container\n", v16, v17, v18, v19, v20, v21, v22, (char)v6);
    int v31 = 0;
    goto LABEL_35;
  }

  io_object_t v23 = MatchingService;
  if (IOObjectConformsTo(MatchingService, "AppleAPFSSnapshot"))
  {
    parent[0] = -1431655766;
    if (IORegistryEntryGetParentEntry(v23, "IOService", parent))
    {
      sub_100040C68("%s: error %d from IORegistryEntryGetParentEntry\n", v24, v25, v26, v27, v28, v29, v30, (char)v6);
      int v31 = 0;
LABEL_34:
      IOObjectRelease(v23);
      goto LABEL_35;
    }

    IOObjectRelease(v23);
    io_object_t v23 = parent[0];
  }

  if (IOObjectConformsTo(v23, "AppleAPFSVolume"))
  {
    *(void *)&__int128 v32 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v84 = v32;
    __int128 v85 = v32;
    __int128 v82 = v32;
    __int128 v83 = v32;
    __int128 v80 = v32;
    __int128 v81 = v32;
    *(_OWORD *)parent = v32;
    __int128 v79 = v32;
    io_registry_entry_t entry = -1431655766;
    if (IORegistryEntryGetLocationInPlane(v23, "IOService", (char *)parent))
    {
      sub_100040C68( "%s: error %d from IORegistryEntryGetLocationInPlane\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  (char)v6);
      goto LABEL_33;
    }

    *a2 = atoi((const char *)parent) - 1;
    if (IORegistryEntryGetParentEntry(v23, "IOService", &entry)
      || (IOObjectRelease(v23), io_object_t v23 = entry, IORegistryEntryGetParentEntry(entry, "IOService", &entry)))
    {
      sub_100040C68("%s: error %d from IORegistryEntryGetParentEntry\n", v43, v44, v45, v46, v47, v48, v49, (char)v6);
      goto LABEL_33;
    }

    IOObjectRelease(v23);
    io_object_t v23 = entry;
  }

  else if (!IOObjectConformsTo(v23, "AppleAPFSMedia"))
  {
    parent[0] = -1431655766;
    if (!IORegistryEntryCreateIterator(v23, "IOService", 1u, parent))
    {
      io_object_t v40 = IOIteratorNext(parent[0]);
      if (v40)
      {
        io_object_t v41 = v40;
        while (!IOObjectConformsTo(v41, "AppleAPFSMedia"))
        {
          IOObjectRelease(v41);
          io_object_t v41 = IOIteratorNext(parent[0]);
          if (!v41) {
            goto LABEL_24;
          }
        }

        IOObjectRelease(parent[0]);
        io_object_t v42 = v23;
        io_object_t v23 = v41;
      }

      else
      {
LABEL_24:
        io_object_t v42 = parent[0];
      }

      IOObjectRelease(v42);
    }
  }

  if (IORegistryEntryCreateCFProperties(v23, &properties, kCFAllocatorDefault, 0))
  {
    sub_100040C68("%s: error %d from IORegistryEntryCreateCFProperties\n", v50, v51, v52, v53, v54, v55, v56, (char)v6);
    goto LABEL_33;
  }

  Value = (const __CFString *)CFDictionaryGetValue(properties, @"BSD Name");
  if (!Value)
  {
    sub_100040C68("%s: can't get BSD name of container\n", v59, v60, v61, v62, v63, v64, v65, (char)v6);
    goto LABEL_33;
  }

  memset(v77, 170, sizeof(v77));
  unint64_t v76 = 0xAAAAAAAAAAAAAAAALL;
  strcpy(__s1, "/dev/r");
  if (!CFStringGetCString(Value, &__s1[6], 26LL, 0x8000100u))
  {
    sub_100040C68("%s: can't create path to container\n", v66, v67, v68, v69, v70, v71, v72, (char)v6);
LABEL_33:
    int v31 = 0;
    if (!v23) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }

  int v31 = 1;
  if (v23) {
    goto LABEL_34;
  }
LABEL_35:
  if (properties) {
    CFRelease(properties);
  }
  if (v31) {
    return strdup(__s1);
  }
  return 0LL;
}

uint64_t start(int a1, char *const *a2)
{
  uint64_t v58 = 0LL;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  LODWORD(v55) = -1;
  LODWORD(v56) = 1;
  srandomdev();
  sub_100044DB0();
  uint64_t v50 = 0LL;
  uint64_t v51 = 0LL;
  uint64_t v4 = 0LL;
  int v5 = 0;
  char v49 = 0;
  unint64_t v6 = (const char **)&optarg;
  while (2)
  {
    int v53 = 0;
    uint64_t v7 = getopt_long(a1, a2, "b:cCdE:fFglnMopqsSWxyZTD", (const option *)&off_100070000, &v53);
    uint64_t v15 = 1LL;
    switch((int)v7)
    {
      case 'C':
        BYTE13(v56) = 1;
        goto LABEL_33;
      case 'D':
        v5 |= 0x100u;
        LOBYTE(v57) = 1;
        goto LABEL_33;
      case 'E':
        uint64_t v25 = v6;
        uint64_t v26 = *v6;
        if (v26)
        {
          if (!strcmp(v26, "-")) {
            uint64_t v27 = __stdoutp;
          }
          else {
            uint64_t v27 = fopen(v26, "w");
          }
          unint64_t v6 = v25;
          uint64_t v58 = v27;
          BYTE4(v51) |= v27 == 0LL;
          uint64_t v15 = v4;
        }

        else
        {
          uint64_t v15 = v4;
          unint64_t v6 = v25;
        }

        goto LABEL_34;
      case 'F':
        BYTE12(v56) = 1;
        goto LABEL_33;
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'U':
      case 'V':
      case 'X':
      case 'Y':
      case '[':
      case '\\':
      case ']':
      case '^':
      case '_':
      case 'a':
      case 'e':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'm':
      case 'r':
      case 't':
      case 'u':
      case 'v':
      case 'w':
        goto LABEL_45;
      case 'M':
        BYTE11(v56) = 1;
        goto LABEL_33;
      case 'S':
        v5 |= 0x10u;
        BYTE10(v56) = 1;
        goto LABEL_33;
      case 'T':
        v5 |= 0x80u;
        HIBYTE(v56) = 1;
        goto LABEL_33;
      case 'W':
        BYTE14(v56) = 1;
        goto LABEL_33;
      case 'Z':
        LOBYTE(v51) = 1;
        goto LABEL_33;
      case 'b':
        dword_100070044 = strtoul(*v6, 0LL, 10) << 10;
        goto LABEL_33;
      case 'c':
        byte_10008DB68 = 1;
        goto LABEL_33;
      case 'd':
        DWORD2(v55) = 1;
        goto LABEL_33;
      case 'f':
        goto LABEL_34;
      case 'g':
        LODWORD(v56) = 2;
        goto LABEL_33;
      case 'l':
        v5 |= 1u;
        LOBYTE(v50) = 1;
        BYTE6(v56) = 1;
        goto LABEL_33;
      case 'n':
        v5 |= 4u;
        HIDWORD(v55) = 1;
        BYTE5(v56) = 1;
        goto LABEL_33;
      case 'o':
        v5 |= 0x20u;
        BYTE9(v56) = 1;
        goto LABEL_33;
      case 'p':
        BYTE4(v50) = 1;
        goto LABEL_33;
      case 'q':
        BYTE4(v56) = 1;
        if ((v5 & 2) == 0)
        {
          HIDWORD(v55) = 1;
          BYTE5(v56) = 1;
        }

        uint64_t v15 = v4;
        v5 |= 8u;
        goto LABEL_34;
      case 's':
        v5 |= 0x40u;
        BYTE7(v56) = 1;
        goto LABEL_33;
      case 'x':
        LODWORD(v56) = 3;
        goto LABEL_33;
      case 'y':
        v5 |= 2u;
        HIDWORD(v55) = 2;
        BYTE5(v56) = 0;
        uint64_t v15 = v4;
        BYTE10(v56) = 0;
        goto LABEL_34;
      default:
        if (!(_DWORD)v7)
        {
          uint64_t v16 = *v6;
          if (*v6)
          {
            __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
            uint64_t v17 = strtol(v16, &__endptr, 0);
            if (*__endptr || v17 < 0 || v17 >= 101)
            {
              uint64_t v29 = "Invalid volume index passed\n";
              goto LABEL_47;
            }

            DWORD1(v55) = v17;
            char v49 = 1;
          }

LABEL_33:
          uint64_t v15 = v4;
LABEL_34:
          uint64_t v4 = v15;
          continue;
        }

        if ((_DWORD)v7 != -1 || (uint64_t v28 = optind, a1 - optind != 1))
        {
LABEL_45:
          sub_100003F40(v7, v8, v9, v10, v11, v12, v13, v14, v48);
          return 64LL;
        }

        if ((v5 & 2) != 0 && (v5 & 5) != 0)
        {
          sub_100003F40(v7, v8, v9, v10, v11, v12, v13, v14, v48);
          uint64_t v29 = "Conflicting options: [ -y ] option cannot be run with the [ -n | -l ] options\n";
          goto LABEL_47;
        }

        if ((v5 & 0xD) == 1)
        {
          sub_100003F40(v7, v8, v9, v10, v11, v12, v13, v14, v48);
          uint64_t v29 = "Missing required option: [ -l ] option requires the [ -n ] or [ -q ] option\n";
          goto LABEL_47;
        }

        if ((v5 & 0x14) == 0x10)
        {
          sub_100003F40(v7, v8, v9, v10, v11, v12, v13, v14, v48);
          uint64_t v29 = "Missing required option: [ -S ] option requires the [ -n ] option\n";
          goto LABEL_47;
        }

        if ((v5 & 0x20) != 0 && (v5 & 0xC) != 0)
        {
          sub_100003F40(v7, v8, v9, v10, v11, v12, v13, v14, v48);
          uint64_t v29 = "Conflicting options: [ -o ] option cannot be run with the [ -n | -q ] options\n";
          goto LABEL_47;
        }

        if ((v5 & 0x80) != 0 && (v5 & 0xC) != 0)
        {
          sub_100003F40(v7, v8, v9, v10, v11, v12, v13, v14, v48);
          uint64_t v29 = "Conflicting options: [ -T ] option cannot be run with the [ -n | -q ] options\n";
          goto LABEL_47;
        }

        if ((v5 & 0x180) == 0x100)
        {
          sub_100003F40(v7, v8, v9, v10, v11, v12, v13, v14, v48);
          uint64_t v29 = "Missing required option: [ -D ] option requires the [ -T ] option\n";
          goto LABEL_47;
        }

        if ((~v5 & 0x48) == 0)
        {
          sub_100003F40(v7, v8, v9, v10, v11, v12, v13, v14, v48);
          uint64_t v29 = "Conflicting options: [ -s ] option cannot be run with the [ -q ] option\n";
          goto LABEL_47;
        }

        qword_10008E138 = (uint64_t)a2[optind];
        byte_10008E140 = v50;
        sub_100001F74();
        sub_10001CCA4();
        atexit(sub_10001CB80);
        if ((v49 & 1) == 0) {
          sub_100040480();
        }
        if ((v4 & 1) != 0) {
          sub_100040C68("option -f is not implemented, ignoring\n", v31, v32, v33, v34, v35, v36, v37, v48);
        }
        if ((v51 & 0x100000000LL) != 0) {
          sub_100040C68("Could not open error file: %s\n", v31, v32, v33, v34, v35, v36, v37, (char)*v6);
        }
        if ((v50 & 0x100000000LL) != 0) {
          sub_100040C68("option -p is not implemented, ignoring\n", v31, v32, v33, v34, v35, v36, v37, v48);
        }
        if ((v51 & 1) != 0) {
          sub_100040C68("option -Z is deprecated, ignoring\n", v31, v32, v33, v34, v35, v36, v37, v48);
        }
        uint64_t v38 = a2[v28];
        if ((v49 & 1) != 0)
        {
          __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
          if (strnlen(v38, 9uLL) < 9 || strncmp(v38, "/dev/fd/", 8uLL))
          {
            uint64_t v29 = "Invalid disk file-descriptor path\n";
            goto LABEL_47;
          }

          uint64_t v47 = strtol(v38 + 8, &__endptr, 0);
          uint64_t v29 = "Invalid disk file-descriptor passed\n";
          if (!*__endptr && v47 < 0x80000000LL)
          {
            LODWORD(v55) = v47;
            *(void *)&__int128 v54 = v38;
            *((void *)&v54 + 1) = strdup(v38);
            return sub_10004751C((uint64_t)&v54);
          }

    if (!v17) {
      goto LABEL_2;
    }
    goto LABEL_34;
  }

  uint64_t v10 = 22LL;
LABEL_6:
  if (*(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v11);
  }
  return v10;
}

  if (a4) {
    *a4 = v8;
  }
  if (v8 + v10 <= a3) {
    return 0LL;
  }
  else {
    return 92LL;
  }
}

LABEL_47:
          sub_10004096C(v29, v18, v19, v20, v21, v22, v23, v24, v48);
          return 64LL;
        }

        else if (access(v38, 0))
        {
          uint64_t v39 = __error();
          strerror(*v39);
          sub_100040B90("unable to access %s: %s\n", v40, v41, v42, v43, v44, v45, v46, (char)v38);
          return 66LL;
        }

        else
        {
          *(void *)&__int128 v54 = v38;
          *((void *)&v54 + 1) = sub_10000403C(v38, (_DWORD *)&v55 + 1);
          if (!*((void *)&v54 + 1))
          {
            *((void *)&v54 + 1) = strdup(v38);
            DWORD1(v55) = -1;
          }

          return sub_10004751C((uint64_t)&v54);
        }
    }
  }

            sub_10003D570((uint64_t)a1, v22, 1LL, 0LL, 0x40000000, v22, 0LL, 8u, 0, 8u);
            goto LABEL_27;
          }

          uint64_t v41 = sub_10002DD38( (uint64_t)a1,  v38,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000452FC,  (uint64_t)&v78);
          uint64_t v22 = *v34;
          if (v41 != -1) {
            goto LABEL_26;
          }
          if (v22) {
            goto LABEL_47;
          }
        }

BOOL sub_100004940(uint64_t a1, unsigned int a2)
{
  if (a2 < 0x19) {
    return 0LL;
  }
  if (*(void *)a1 != 0x6C7070612E6D6F63LL || *(void *)(a1 + 7) != 0x2E736670612E656CLL) {
    return 0LL;
  }
  return *(void *)(a1 + 15) == 0x726F746167727570LL && *(_WORD *)(a1 + 23) == 11897;
}

uint64_t sub_1000049B0(int8x16_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  int v7 = a4;
  char v8 = a3;
  v48[0] = a4;
  v48[1] = a5;
  uint64_t v46 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v47 = a3;
  uint64_t v18 = sub_100029C7C(a1->i64, a2, (uint64_t *)&v46);
  if (!(_DWORD)v18)
  {
    sub_100040B90( "no snap_meta tree entry found for omap_snap entry with xid %llu\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v8);
    if ((a6 & 1) == 0
      && !sub_1000428C4(qword_10008DB70, "Delete omap_snap entries? ", v19, v20, v21, v22, v23, v24, v45))
    {
      return 89LL;
    }

    LODWORD(v48[0]) = v7 | 1;
    uint64_t v25 = sub_1000364F0(v46, 0LL, &v47, 8LL, v48, 16LL);
    if ((_DWORD)v25)
    {
      uint64_t v18 = v25;
      char v26 = strerror(v25);
      sub_100040B90("error updating omap_snap entry: %s\n", v27, v28, v29, v30, v31, v32, v33, v26);
      uint64_t v34 = 657LL;
LABEL_8:
      sub_100044E7C((char *)v34, v18);
      return v18;
    }

    uint64_t v35 = sub_10002DE10( a1,  *(_DWORD *)(*(void *)(a2 + 72) + 24LL),  *(_DWORD *)(a2 + 112),  *(void *)(*(void *)(a2 + 40) + 8LL),  *(void *)(*(void *)(a2 + 72) + 8LL),  *(void *)(a1->i64[1] + 16),  2);
    uint64_t v18 = v35;
    if ((_DWORD)v35)
    {
      char v36 = strerror(v35);
      sub_100040B90("error updating the reap list: %s\n", v37, v38, v39, v40, v41, v42, v43, v36);
      uint64_t v34 = 658LL;
      goto LABEL_8;
    }
  }

  return v18;
}

uint64_t sub_100004AEC(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, char a5)
{
  uint64_t v73 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v15 = sub_100029FA4(a1, a2, (uint64_t *)&v73);
  if (!(_DWORD)v15)
  {
    sub_100040B90( "no omap_snap tree entry found for snap_meta entry with xid %llu\n",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  *a3);
    if ((a5 & 1) == 0
      && !sub_1000428C4(qword_10008DB70, "Delete snap_meta entries? ", v16, v17, v18, v19, v20, v21, v71))
    {
      return 89LL;
    }

    uint64_t v22 = sub_10002830C((uint64_t)v73, *(unsigned __int16 *)(a4 + 48), (const void *)(a4 + 50));
    if ((_DWORD)v22)
    {
      uint64_t v15 = v22;
      if ((_DWORD)v22 != 2)
      {
        char v52 = strerror(v22);
        sub_100040B90("failed to remove snap_name entry: %s\n", v53, v54, v55, v56, v57, v58, v59, v52);
        uint64_t v60 = 660LL;
        goto LABEL_15;
      }

      sub_100040C68("tried to remove snap_name entry but it's not there!\n", v23, v24, v25, v26, v27, v28, v29, v71);
    }

    *(void *)&__int128 v30 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v75[10] = v30;
    *(_OWORD *)__str = v30;
    *(_OWORD *)uint64_t v75 = v30;
    int v31 = snprintf(__str, 0x2AuLL, "%s%s%llx", "com.apple.apfs.", "purgatory.", *(void *)a3 & 0xFFFFFFFFFFFFFFFLL);
    uint64_t v32 = (unsigned __int16 *)malloc(v31 + 51LL);
    if (!v32)
    {
      sub_100040B90("failed to allocate memory for repair\n", v33, v34, v35, v36, v37, v38, v39, v72);
      uint64_t v15 = 12LL;
      uint64_t v60 = 704LL;
      int v61 = 12;
LABEL_16:
      sub_100044E7C((char *)v60, v61);
      return v15;
    }

    uint64_t v40 = v32;
    unsigned __int16 v41 = v31 + 1;
    v32[24] = v41;
    uint64_t v42 = v32 + 25;
    memcpy(v32 + 25, __str, v41);
    uint64_t v43 = sub_1000364F0(v73, 0LL, a3, 8LL, v40, v41 + 50);
    if ((_DWORD)v43)
    {
      uint64_t v15 = v43;
      char v44 = strerror(v43);
      sub_100040B90("error updating snap_meta entry: %s\n", v45, v46, v47, v48, v49, v50, v51, v44);
      sub_100044E7C((char *)0x295, v15);
      free(v40);
      return v15;
    }

    uint64_t v15 = sub_1000281F8(v73, v40[24], v42, *(void *)a3 & 0xFFFFFFFFFFFFFFFLL);
    free(v40);
    if (!(_DWORD)v15) {
      return v15;
    }
    char v62 = strerror(v15);
    sub_100040B90("failed to insert snap_name entry: %s\n", v63, v64, v65, v66, v67, v68, v69, v62);
    uint64_t v60 = 662LL;
LABEL_15:
    int v61 = v15;
    goto LABEL_16;
  }

  return v15;
}

uint64_t sub_100004D24(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v62 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v59 = 0u;
  __int128 v57 = 0u;
  memset(v58, 0, sizeof(v58));
  BYTE8(v59) = 1;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  memset(v54, 0, sizeof(v54));
  BYTE8(v55) = 1;
  if (*(void *)(*(void *)(a2 + 72) + 56LL))
  {
    uint64_t v6 = sub_100029C7C(a1, a2, &v63);
    if ((_DWORD)v6)
    {
      uint64_t v14 = v6;
      sub_100040B90("unable to init omap_snap tree for snapshot repair\n", v7, v8, v9, v10, v11, v12, v13, v53);
      uint64_t v15 = 663LL;
LABEL_15:
      sub_100044E7C((char *)v15, v14);
      return v14;
    }

    uint64_t v16 = sub_100035838((uint64_t)v58, v63, 0LL, 0LL, 0);
    if ((_DWORD)v16)
    {
      uint64_t v14 = v16;
      char v17 = strerror(v16);
      sub_100040B90( "unable to init omap_snap tree iterator for snapshot repair: %s\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v17);
      uint64_t v15 = 664LL;
      goto LABEL_15;
    }
  }

  if (*(void *)(*(void *)(a2 + 40) + 152LL))
  {
    uint64_t v25 = sub_100029FA4((uint64_t)a1, a2, &v62);
    if ((_DWORD)v25)
    {
      uint64_t v14 = v25;
      sub_100040B90("unable to init snap_meta tree for snapshot repair\n", v26, v27, v28, v29, v30, v31, v32, v53);
      uint64_t v33 = 665LL;
      goto LABEL_11;
    }

    uint64_t v34 = sub_100035838((uint64_t)v54, v62, 0LL, 0LL, 0);
    if ((_DWORD)v34)
    {
      uint64_t v14 = v34;
      char v35 = strerror(v34);
      sub_100040B90( "unable to init snap_meta tree iterator for snapshot repair: %s\n",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v35);
      uint64_t v33 = 666LL;
LABEL_11:
      sub_100044E7C((char *)v33, v14);
      if (*(void *)&v58[0]) {
        (*(void (**)(_OWORD *))&v58[0])(v58);
      }
      return v14;
    }
  }

  uint64_t v43 = sub_1000293A8( (uint64_t)v58,  (uint64_t)v54,  (uint64_t (*)(__int128 *, __int128 *, int *, uint64_t))sub_100004ECC,  a3);
  uint64_t v14 = v43;
  if ((_DWORD)v43)
  {
    char v44 = strerror(v43);
    sub_100040B90("error iterating trees during snapshot repair: %s\n", v45, v46, v47, v48, v49, v50, v51, v44);
    uint64_t v15 = 667LL;
    goto LABEL_15;
  }

  return v14;
}

uint64_t sub_100004ECC( uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(uint64_t **)a1;
  uint64_t v9 = *(uint64_t **)(a1 + 8);
  uint64_t v11 = *(char **)a2;
  uint64_t v12 = *(void *)(a2 + 8);
  if (*(void *)a1 && (*(_DWORD *)(a1 + 16) < 8u || *(_DWORD *)(a1 + 20) < 0x10u)) {
    return 22LL;
  }
  if (!v11) {
    return sub_100004F90(a4, *v10, *v9, v9[1], a5, a6, a7, a8);
  }
  if (*(_DWORD *)(a2 + 16) < 8u) {
    return 22LL;
  }
  if (*(void *)v11 >> 60 != 1LL)
  {
    uint64_t result = 0LL;
    *a3 = 2;
    return result;
  }

  if (*(_DWORD *)(a2 + 20) < 0x32u) {
    return 22LL;
  }
  if (!v10) {
    return sub_100005010(a4, v11, v12);
  }
  unint64_t v14 = *(void *)v11 & 0xFFFFFFFFFFFFFFFLL;
  if (*v10 < v14)
  {
    *a3 = 1;
    return sub_100004F90(a4, *v10, *v9, v9[1], a5, a6, a7, a8);
  }

  if (v14 < *v10)
  {
    *a3 = 2;
    return sub_100005010(a4, v11, v12);
  }

  return 0LL;
}

uint64_t sub_100004F90( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *((void *)&v10 + 1) = a3;
  uint64_t v11 = a4;
  *(void *)&__int128 v10 = a2;
  if ((a3 & 1) != 0) {
    return 0LL;
  }
  sub_100040B90("no snap_meta tree entry found for omap_snap entry with xid %llu\n", a2, a3, a4, a5, a6, a7, a8, a2);
  sub_100044E7C((char *)0x290, 92);
  return sub_1000251C0(a1, 4u, 0, 0, 1, &v10, 8u, (_BYTE *)&v10 + 8, 0x10u);
}

uint64_t sub_100005010(_DWORD *a1, char *a2, uint64_t a3)
{
  if (sub_100004940(a3 + 50, *(unsigned __int16 *)(a3 + 48)))
  {
    sub_100040C68( "found a snapshot in the purgatory (xid %llu) with no corresponding omap entry\n",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  *a2);
    return 0LL;
  }

  else
  {
    sub_100040B90( "no omap_snap tree entry found for snap_meta entry with xid %llu\n",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  *a2);
    sub_100044E7C((char *)0x293, 92);
    return sub_1000251C0( a1,  5u,  0,  0,  1,  (__int128 *)a2,  8u,  (_BYTE *)a3,  *(unsigned __int16 *)(a3 + 48) + 50);
  }

void sub_1000050C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 48LL;
  if (!a3) {
    uint64_t v3 = 40LL;
  }
  uint64_t v4 = *(void *)(a2 + v3);
  byte_100070F28 = 0;
  unsigned int v5 = *(unsigned __int16 *)(v4 + 964);
  if (v5 > 0x3F)
  {
    if (v5 != 576 && v5 != 64) {
      return;
    }
  }

  else
  {
    if (*(_WORD *)(v4 + 964)) {
      BOOL v6 = v5 == 2;
    }
    else {
      BOOL v6 = 1;
    }
    if (!v6) {
      return;
    }
  }

  if (*(void *)(v4 + 1056) == *(void *)(v4 + 16) && (a3 || (*(_BYTE *)(*(void *)(a2 + 40) + 1064LL) & 2) == 0))
  {
    if (*(void *)(v4 + 1072))
    {
      if (!sub_100034B44( (uint64_t)&unk_100070F30,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  4,  8,  0,  0LL,  (uint64_t)sub_10002D368)) {
        sub_100036C00((uint64_t)&unk_100070F30, 0LL, 0);
      }
      if (sub_10001A7FC((uint64_t)&unk_100070F30, (uint64_t)"doc id", (uint64_t)sub_1000051F4))
      {
        sub_100040C68( "failed to register the doc id tree in the fsck memory storage\n",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14);
        sub_100044E7C((char *)0x584, 12);
      }
    }

    dword_100070F70 = 0;
    byte_100070F28 = 1;
  }

uint64_t sub_1000051F4()
{
  uint64_t result = sub_100036CD8((uint64_t)&unk_100070F30, 0LL);
  byte_100070F28 = 0;
  return result;
}

uint64_t sub_10000521C(uint64_t *a1, int8x16_t *a2, unint64_t a3, _DWORD *a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v6 = a2[3].i64[1];
  LODWORD(v90) = *a4;
  if (byte_100070F28 != 1) {
    return 0LL;
  }
  unint64_t v89 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v11 = v6;
  if (qword_100070F68)
  {
    unsigned int v87 = 8;
    unsigned int v88 = 4;
    uint64_t v14 = sub_100034BB4((uint64_t)dword_100070F30, 0LL, 0LL, &v90, &v88, 4u, &v89, &v87);
    if (!(_DWORD)v14)
    {
      if (v89)
      {
        if (v89 == a3) {
          goto LABEL_24;
        }
        sub_100040B90( "inode with file-id %llu has doc-id %u but doc-id tree record has file-id %llu\n",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  a3);
        uint64_t v32 = sub_100044E7C((char *)0x3FB, 92);
        if (v6) {
          goto LABEL_17;
        }
      }

      else
      {
        sub_100040B90( "inode with file-id %llu has doc-id %u but doc-id is already in use\n",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  a3);
        uint64_t v32 = sub_100044E7C((char *)0x3FC, 92);
        if (v6) {
          goto LABEL_17;
        }
        if (!sub_1000428C4( qword_10008DB70,  "Allocate new doc-id %u for file-id %llu? ",  v34,  v35,  v36,  v37,  v38,  v39,  *(_DWORD *)(a5 + 48))) {
          return 92LL;
        }
        int v75 = *(_DWORD *)(a5 + 48);
        *(_DWORD *)(a5 + 48) = v75 + 1;
        *a4 = v75;
        uint64_t v76 = sub_10004227C(a1, a2);
        if ((_DWORD)v76)
        {
          uint64_t v22 = v76;
          char v77 = strerror(v76);
          sub_100040B90("failed to write apfs superblock : %s\n", v78, v79, v80, v81, v82, v83, v84, v77);
          uint64_t v57 = 1021LL;
          goto LABEL_27;
        }

        *a6 = 1;
        LODWORD(v90) = *a4;
      }

      unint64_t v89 = a3;
LABEL_22:
      uint64_t v48 = sub_1000251C0((int8x16_t *)a2[44].i32, 0xAu, 2, 0, 1, &v90, 4u, &v89, 8u);
      if ((_DWORD)v48)
      {
        uint64_t v22 = v48;
        char v49 = v90;
        strerror(v48);
        sub_100040B90( "failed to insert doc-id tree repair for doc-id %u, file-id %llu : %s\n",  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v49);
        uint64_t v57 = 1025LL;
LABEL_27:
        sub_100044E7C((char *)v57, v22);
        return v22;
      }

      goto LABEL_24;
    }

    uint64_t v22 = v14;
    if ((_DWORD)v14 != 2)
    {
      int v40 = *a4;
      strerror(v14);
      sub_100040B90("failed to lookup doc-id %u error : %s\n", v41, v42, v43, v44, v45, v46, v47, v40);
      sub_100044E7C((char *)0x400, v22);
LABEL_19:
      int v31 = 0;
      goto LABEL_20;
    }

    uint64_t v11 = a2[3].i64[1];
  }

  char v86 = -86;
  uint64_t v23 = sub_10003B000((uint64_t)a1, (uint64_t)a2, v11, a3, &v86);
  if ((_DWORD)v23)
  {
LABEL_18:
    uint64_t v22 = v23;
    goto LABEL_19;
  }

  if (v86)
  {
LABEL_8:
    int v31 = 0;
    uint64_t v22 = 0LL;
    goto LABEL_20;
  }

  if (v6)
  {
    sub_100040B90( "inode with file-id %llu has doc-id %u but doc-id tree record is missing\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  a3);
    uint64_t v32 = sub_100044E7C((char *)0x3FF, 92);
LABEL_17:
    uint64_t v23 = sub_100024E94((uint64_t)v32, v33, v34, v35, v36, v37, v38, v39);
    goto LABEL_18;
  }

  uint64_t v68 = a2[2].i64[1];
  if ((*(_BYTE *)(v68 + 1064) & 1) != 0 && *(void *)(v68 + 1088) < a3) {
    goto LABEL_8;
  }
  sub_100040B90( "inode with file-id %llu has doc-id %u but doc-id tree record is missing\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  a3);
  sub_100044E7C((char *)0x3FE, 92);
  if (*(void *)(a2[2].i64[1] + 1072))
  {
    uint64_t v22 = 0LL;
    unint64_t v89 = a3;
    int v31 = 1;
  }

  else
  {
    if (sub_1000428C4( qword_10008DB70,  "Mark volume for doc-id tree building on next mount? ",  v69,  v70,  v71,  v72,  v73,  v74,  v85))
    {
      uint64_t v23 = sub_1000055D4(a1, a2);
      goto LABEL_18;
    }

    int v31 = 0;
    uint64_t v22 = 92LL;
  }

LABEL_20:
  if (!(_DWORD)v22)
  {
    if (v31) {
      goto LABEL_22;
    }
LABEL_24:
    if (qword_100070F68)
    {
      unint64_t v89 = 0LL;
      uint64_t v58 = sub_1000364F0(dword_100070F30, 0LL, &v90, 4LL, &v89, 8LL);
      uint64_t v22 = v58;
      if (!(_DWORD)v58)
      {
        ++dword_100070F70;
        return v22;
      }

      char v59 = v90;
      strerror(v58);
      sub_100040B90( "failed to mark cached doc-id tree record %d as verified error : %s\n",  v60,  v61,  v62,  v63,  v64,  v65,  v66,  v59);
      uint64_t v57 = 1026LL;
      goto LABEL_27;
    }

    return 0LL;
  }

  return v22;
}

    unsigned int v5 = v16[4];
    if (v5 != *(void *)v56)
    {
      *(void *)uint64_t v56 = v16[4];
      if (v5) {
        continue;
      }
    }

    goto LABEL_24;
  }

  uint64_t v25 = v31;
  if ((_DWORD)v31 != 2) {
    goto LABEL_8;
  }
  uint64_t v52 = 3808;
  uint64_t v32 = sub_100034BB4(v55, qword_100074C80, 0LL, &v54, &v53, v53, v16, &v52);
  if (!(_DWORD)v32)
  {
    uint64_t v33 = *((_DWORD *)v16 + 12);
    uint64_t v51 = v33 | 0x100;
    if ((v33 & 0x100) != 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  uint64_t v37 = v32;
  uint64_t v25 = 0LL;
  if ((_DWORD)v32 != 2)
  {
    uint64_t v38 = v56[0];
    strerror(v32);
    sub_100040B90("failed to look up dir-stats object (id %llu): %s\n", v39, v40, v41, v42, v43, v44, v45, v38);
    sub_100044E7C((char *)0x595, v37);
    uint64_t v25 = v37;
  }

uint64_t sub_1000055D4(uint64_t *a1, int8x16_t *a2)
{
  *(_DWORD *)(a2[2].i64[1] + 1064) = *(_DWORD *)(a2[2].i64[1] + 1064) & 0xFFFFFFFC | 2;
  uint64_t v2 = sub_10004227C(a1, a2);
  uint64_t v3 = v2;
  if ((_DWORD)v2)
  {
    char v4 = strerror(v2);
    sub_100040B90("failed to write apfs superblock : %s\n", v5, v6, v7, v8, v9, v10, v11, v4);
    sub_100044E7C((char *)0x3FA, v3);
  }

  else
  {
    byte_100070F28 = 0;
  }

  return v3;
}

uint64_t sub_100005648(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v39) = -1431655766;
  unint64_t v38 = 0xAAAAAAAAAAAAAAAALL;
  if (qword_100070F68 && (uint64_t v37 = 0LL, sub_100036AE0((uint64_t)&unk_100070F30, 0LL, &v37), v37 != dword_100070F70))
  {
    unsigned int v35 = 8;
    int v36 = 4;
    unsigned int v6 = sub_10003510C((uint64_t)&unk_100070F30, 0LL, &v39, &v36, &v38, &v35);
    if (!v6)
    {
      uint64_t v14 = (_DWORD *)(a2 + 704);
      do
      {
        if (v38)
        {
          sub_100040B90( "doc-id tree: record exists for doc-id %u, file-id %llu but no inode references this doc-id\n",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v39);
          uint64_t v15 = sub_100044E7C((char *)0x403, 92);
          if (a3)
          {
            sub_100024E94((uint64_t)v15, v16, v17, v18, v19, v20, v21, v22);
          }

          else
          {
            uint64_t v23 = sub_1000251C0(v14, 0xAu, 0, 0, 0, &v39, 4u, 0LL, 0);
            if ((_DWORD)v23)
            {
              uint64_t v5 = v23;
              char v25 = v39;
              strerror(v23);
              sub_100040B90( "failed to add doc-id tree repair record, doc-id %u : %s\n",  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v25);
              sub_100044E7C((char *)0x404, v5);
              goto LABEL_14;
            }
          }
        }

        unsigned int v33 = 8;
        unsigned int v34 = 4;
        unsigned int v6 = sub_100034BB4((uint64_t)&unk_100070F30, 0LL, 2LL, &v39, &v34, 4u, &v38, &v33);
      }

      while (!v6);
    }

    if (v6 == 2) {
      uint64_t v5 = 0LL;
    }
    else {
      uint64_t v5 = v6;
    }
  }

  else
  {
    uint64_t v5 = 0LL;
  }

uint64_t sub_1000057F4(uint64_t *a1, int8x16_t *a2, uint64_t a3)
{
  uint64_t v6 = 6LL;
  if (!a3) {
    uint64_t v6 = 5LL;
  }
  uint64_t v7 = a2->i64[v6];
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v92[2] = v8;
  v92[3] = v8;
  v92[0] = v8;
  v92[1] = v8;
  uint64_t v9 = sub_100034B44( (uint64_t)v92,  (uint64_t)a1,  (uint64_t)a2,  *(_DWORD *)(v7 + 1068) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(v7 + 1068),  34,  0,  *(_DWORD *)(a1[1] + 36),  4,  8,  0,  *(void *)(v7 + 1072),  (uint64_t)sub_10002D368);
  if ((_DWORD)v9)
  {
    uint64_t v10 = v9;
    char v11 = strerror(v9);
    sub_100040B90("failed to initialize the doc-id tree: %s\n", v12, v13, v14, v15, v16, v17, v18, v11);
    uint64_t v19 = 1031LL;
LABEL_5:
    sub_100044E7C((char *)v19, v10);
    return v10;
  }

  if (*(void *)(v7 + 1072))
  {
    if (byte_100070F28 == 1)
    {
      LODWORD(v91[0]) = 0;
      if (qword_100070F68)
      {
        uint64_t v21 = sub_100031CD0( (uint64_t)v92,  a3,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100005B58,  (uint64_t)v91,  0LL,  0);
        uint64_t v10 = v21;
        if (!(_DWORD)v21) {
          goto LABEL_23;
        }
        char v22 = strerror(v21);
        sub_100040B90("failed to populate cached doc-id tree : %s\n", v23, v24, v25, v26, v27, v28, v29, v22);
        uint64_t v30 = sub_100044E7C((char *)0x406, v10);
        byte_100070F28 = 0;
        if (LODWORD(v91[0]))
        {
LABEL_24:
          sub_100036CD8((uint64_t)dword_100070F30, 0LL);
LABEL_25:
          if ((_DWORD)v10) {
            return v10;
          }
          goto LABEL_26;
        }

        if (a3)
        {
          uint64_t v38 = sub_100024E94((uint64_t)v30, v31, v32, v33, v34, v35, v36, v37);
        }

        else
        {
          if (!sub_1000428C4( qword_10008DB70,  "Mark volume for doc-id tree building on next mount? ",  v32,  v33,  v34,  v35,  v36,  v37,  v88)) {
            goto LABEL_23;
          }
          uint64_t v38 = sub_1000055D4(a1, a2);
        }

        uint64_t v10 = v38;
LABEL_23:
        if ((byte_100070F28 & 1) != 0) {
          goto LABEL_25;
        }
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v39 = sub_100031CD0((uint64_t)v92, a3, 0LL, 0LL, 0LL, 0);
      if ((_DWORD)v39)
      {
        uint64_t v10 = v39;
        char v40 = strerror(v39);
        sub_100040B90("failed to traverse doc-id tree : %s\n", v41, v42, v43, v44, v45, v46, v47, v40);
        uint64_t v48 = sub_100044E7C((char *)0x40A, v10);
        if (a3)
        {
          uint64_t v56 = sub_100024E94((uint64_t)v48, v49, v50, v51, v52, v53, v54, v55);
        }

        else
        {
          if (!sub_1000428C4( qword_10008DB70,  "Mark volume for doc-id tree building on next mount? ",  v50,  v51,  v52,  v53,  v54,  v55,  v89)) {
            return v10;
          }
          uint64_t v56 = sub_1000055D4(a1, a2);
        }

        uint64_t v10 = v56;
        goto LABEL_25;
      }
    }
  }

LABEL_26:
  uint64_t v57 = *(void *)(v7 + 1080);
  if (!v57) {
    return 0LL;
  }
  *(void *)&__int128 v58 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v58 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v91[2] = v58;
  v91[3] = v58;
  v91[0] = v58;
  v91[1] = v58;
  uint64_t v59 = sub_100034B44( (uint64_t)v91,  (uint64_t)a1,  (uint64_t)a2,  *(_DWORD *)(v7 + 1068) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(v7 + 1068),  34,  0,  *(_DWORD *)(a1[1] + 36),  4,  8,  0,  v57,  (uint64_t)sub_10002D368);
  if ((_DWORD)v59)
  {
    uint64_t v10 = v59;
    char v60 = strerror(v59);
    sub_100040B90("failed to initialize the prev doc-id tree: %s\n", v61, v62, v63, v64, v65, v66, v67, v60);
    uint64_t v19 = 1035LL;
    goto LABEL_5;
  }

  uint64_t v68 = sub_100031CD0((uint64_t)v91, a3, 0LL, 0LL, 0LL, 0);
  if (!(_DWORD)v68) {
    return 0LL;
  }
  uint64_t v69 = v68;
  char v70 = strerror(v68);
  sub_100040B90("failed to traverse prev doc-id tree : %s\n", v71, v72, v73, v74, v75, v76, v77, v70);
  uint64_t v78 = sub_100044E7C((char *)0x40E, v69);
  if (a3) {
    return sub_100024E94((uint64_t)v78, v79, v80, v81, v82, v83, v84, v85);
  }
  uint64_t v10 = 0LL;
  unsigned int v87 = *(unsigned __int16 *)(v7 + 964);
  if (v87 > 0x3F)
  {
    if (v87 != 64 && v87 != 576) {
      goto LABEL_40;
    }
  }

  else if (*(_WORD *)(v7 + 964) && v87 != 2)
  {
LABEL_40:
    uint64_t v10 = v69;
    if (!sub_1000428C4( qword_10008DB70,  "Mark volume for doc-id tree cleanup on next mount? ",  v80,  v81,  v82,  v83,  v84,  v85,  v90)) {
      return v10;
    }
    return sub_1000055D4(a1, a2);
  }

  return v10;
}

  uint64_t v18 = 92LL;
  sub_100044E7C((char *)v11, 92);
  sub_100040DA8(a2, a3, a5, v19, v20, v21, v22, v23);
  return v18;
}

uint64_t sub_100005B58( uint64_t a1, uint64_t a2, int *a3, uint64_t a4, void *a5, uint64_t a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a2 + 56);
  if (a7) {
    *a7 = 0;
  }
  if (byte_100070F28 != 1) {
    return 0LL;
  }
  if (*a5)
  {
    uint64_t v12 = sub_1000364F0(dword_100070F30, 0LL, a3, 4LL, a5, 8LL);
    uint64_t v13 = v12;
    if ((_DWORD)v12)
    {
      int v14 = *a3;
      strerror(v12);
      sub_100040B90( "failed to insert cached doc-id record, doc-id %u,file-id %llu : %s\n",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v14);
    }
  }

  else
  {
    sub_100040B90( "invalid doc-id record, file-id is 0 for doc-id %u\n",  a2,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  *a3);
    char v22 = sub_100044E7C((char *)0x3F9, 92);
    if (v11)
    {
      uint64_t v13 = sub_100024E94((uint64_t)v22, v23, v24, v25, v26, v27, v28, v29);
    }

    else
    {
      uint64_t v31 = sub_1000251C0((_DWORD *)(a2 + 704), 0xAu, 0, 0, 1, (__int128 *)a3, 4u, 0LL, 0);
      uint64_t v13 = v31;
      if ((_DWORD)v31)
      {
        int v32 = *a3;
        strerror(v31);
        sub_100040B90( "failed to add doc-id repair (deletion), doc-id %u : %s\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v32);
      }
    }
  }

  if (a7) {
    *a7 = v13;
  }
  return v13;
}

char *sub_100005C98()
{
  if (!sub_100034B44( (uint64_t)&unk_100070F78,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  8,  80,  0,  0LL,  (uint64_t)sub_10002D39C)) {
    sub_100036C00((uint64_t)&unk_100070F78, 0LL, 0);
  }
  uint64_t result = (char *)sub_10001A7FC((uint64_t)&unk_100070F78, (uint64_t)"file info", (uint64_t)sub_100005D4C);
  if ((_DWORD)result)
  {
    sub_100040C68("failed to register the file info tree in the fsck memory storage\n", v1, v2, v3, v4, v5, v6, v7, v8);
    return sub_100044E7C((char *)0x586, 12);
  }

  return result;
}

uint64_t sub_100005D4C()
{
  if (qword_100070FB0) {
    uint64_t result = sub_100036CD8((uint64_t)&unk_100070F78, 0LL);
  }
  qword_100071008 = 0LL;
  return result;
}

uint64_t sub_100005D80(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100005D9C(a1, 0LL, 0LL, a4, a2, a3, 0LL, 0LL);
}

uint64_t sub_100005D9C( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _BYTE *a7, uint64_t a8)
{
  *(void *)&__int128 v9 = a5 & 0xFFFFFFFFFFFFFFFLL | 0xD000000000000000LL;
  *((void *)&v9 + 1) = a6 & 0xFFFFFFFFFFFFFFLL | 0x200000000000000LL;
  if (a1) {
    return sub_1000251C0(a1, 8u, a2, a3, a4, &v9, 0x10u, a7, a8);
  }
  else {
    return sub_100024E94(0LL, a2, a3, a4, a5, a6, (uint64_t)a7, a8);
  }
}

void sub_100005E04( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 a6, uint64_t a7, uint64_t a8)
{
  if (qword_100070FB0)
  {
    sub_100005F18(a2);
    if (!v23)
    {
      if (byte_100071002)
      {
        if (!a8) {
          a8 = a2;
        }
        sub_100040C68( "file info: found more than one attribution tag with matching computed hash, invalid entry (hash %llu)\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  a8);
        sub_100044E7C((char *)0x557, 92);
        if (a7) {
          uint64_t v24 = a7;
        }
        else {
          uint64_t v24 = 9LL;
        }
        sub_100005D9C(a1, 0LL, 0LL, 1LL, v24, a8, 0LL, 0LL);
      }

      else
      {
        *(void *)&xmmword_100070FB8 = a3;
        qword_100070FC8 = a4;
        *(void *)&xmmword_100070FD8 = a5;
        byte_100071002 = 1;
        *(void *)&xmmword_100070FF0 = a7;
        *((void *)&xmmword_100070FF0 + 1) = a8;
        word_100071000 = a6;
      }
    }
  }

double sub_100005F18(uint64_t a1)
{
  uint64_t v9 = a1;
  if (!sub_100006798(a1) && !qword_100071008)
  {
    __int128 v7 = 0u;
    __int128 v8 = 0u;
    __int128 v5 = 0u;
    __int128 v6 = 0u;
    __int128 v4 = 0u;
    unsigned int v2 = 80;
    unsigned int v3 = 8;
    if ((sub_100034BB4((uint64_t)dword_100070F78, 0LL, 0LL, &v9, &v3, 8u, &v4, &v2) & 0xFFFFFFFD) == 0)
    {
      qword_100071008 = v9;
      xmmword_100070FD8 = v6;
      *(_OWORD *)&qword_100070FE8 = v7;
      *(__int128 *)((char *)&xmmword_100070FF0 + 8) = v8;
      double result = *(double *)&v5;
      xmmword_100070FB8 = v4;
      *(_OWORD *)&qword_100070FC8 = v5;
    }
  }

  return result;
}

void sub_100005FD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_100070FB0)
  {
    char v4 = a2;
    sub_100005F18(a2);
    if (!v13)
    {
      uint64_t v14 = *((void *)&xmmword_100070FB8 + 1) == -1LL;
      uint64_t v15 = v14 << 63 >> 63;
      ++*((void *)&xmmword_100070FB8 + 1);
      if (v15 != v14 || v15 < 0)
      {
        sub_100040C68("file info: computed count overflow for hash (%llu)\n", v6, v7, v8, v9, v10, v11, v12, v4);
        *((void *)&xmmword_100070FB8 + 1) = -1LL;
        sub_100044E7C((char *)0x51A, 84);
      }

      BOOL v16 = __CFADD__(qword_100070FD0, a3);
      qword_100070FD0 += a3;
      if (v16)
      {
        sub_100040C68("file info: computed size overflow for hash (%llu)\n", v6, v7, v8, v9, v10, v11, v12, v4);
        qword_100070FD0 = -1LL;
        sub_100044E7C((char *)0x51B, 84);
      }

      if (!qword_100070FE8) {
        qword_100070FE8 = a1;
      }
    }
  }

void sub_1000060BC(uint64_t a1, uint64_t a2)
{
  char v2 = a1;
  if (a2)
  {
    if (qword_100070FB0)
    {
      sub_100005F18(a1);
      if (!v11)
      {
        BOOL v12 = __OFADD__(*((void *)&xmmword_100070FD8 + 1), a2);
        *((void *)&xmmword_100070FD8 + 1) += a2;
        if (v12)
        {
          sub_100040C68("file info: clone size overflow for hash (%llu)\n", v4, v5, v6, v7, v8, v9, v10, v2);
          *((void *)&xmmword_100070FD8 + 1) = 0x7FFFFFFFFFFFFFFFLL;
          sub_100044E7C((char *)0x555, 84);
        }
      }
    }
  }

void sub_100006148(uint64_t a1, uint64_t a2)
{
}

void sub_100006150(uint64_t a1, uint64_t a2)
{
  if (qword_100070FB0)
  {
    char v3 = a1;
    sub_100005F18(a1);
    if (!v11)
    {
      BOOL v12 = __CFADD__(qword_100070FD0, a2);
      qword_100070FD0 += a2;
      if (v12)
      {
        sub_100040C68("file info: computed size overflow for hash (%llu)\n", v4, v5, v6, v7, v8, v9, v10, v3);
        qword_100070FD0 = -1LL;
        sub_100044E7C((char *)0x567, 84);
      }
    }
  }

uint64_t sub_1000061D0(uint64_t a1, void *a2, uint64_t a3)
{
  if (!qword_100070FB0) {
    return 0LL;
  }
  uint64_t v6 = sub_100006798(0LL);
  if ((_DWORD)v6)
  {
    uint64_t v7 = v6;
    if (qword_100070FB0) {
      sub_100036CD8((uint64_t)dword_100070F78, 0LL);
    }
    qword_100071008 = 0LL;
    return v7;
  }

  v70[0] = 0LL;
  __int128 v68 = 0u;
  __int128 v69 = 0u;
  __int128 v66 = 0u;
  __int128 v67 = 0u;
  __int128 v65 = 0u;
  if (a3) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = a2 + 88;
  }
  v64[0] = 0LL;
  v64[1] = 0LL;
  v64[2] = v8;
  uint64_t v9 = malloc(0xEE0uLL);
  int v10 = sub_100001F58();
  if (!v9)
  {
    sub_100040C68("file info: failed to allocate memory\n", v11, v12, v13, v14, v15, v16, v17, v49);
    uint64_t v7 = 12LL;
    sub_100044E7C((char *)0x51D, 12);
    goto LABEL_17;
  }

  int v18 = v10;
  unsigned int v62 = 80;
  unsigned int v63 = 8;
  unsigned int v19 = sub_100034BB4((uint64_t)dword_100070F78, 0LL, 1LL, v70, &v63, 8u, &v65, &v62);
  if (v19)
  {
    BOOL v27 = v19 == 2;
LABEL_13:
    if (v27) {
      uint64_t v7 = 0LL;
    }
    else {
      uint64_t v7 = v19;
    }
    goto LABEL_17;
  }

  char v50 = 0;
  uint64_t v51 = 0LL;
  unint64_t v52 = -1LL;
  do
  {
    uint64_t v29 = v69;
    if ((void)v69) {
      uint64_t v30 = v69;
    }
    else {
      uint64_t v30 = v70[0];
    }
    if ((void)v68) {
      BOOL v31 = 1;
    }
    else {
      BOOL v31 = BYTE10(v69) == 0;
    }
    if (v31)
    {
      if (*((void *)&v68 + 1))
      {
        sub_100044E7C((char *)0x537, 92);
        uint64_t v32 = sub_100005D9C(v8, 1LL, 26LL, 1LL, *((uint64_t *)&v68 + 1), v30, 0LL, 0LL);
        if ((_DWORD)v32) {
          return v32;
        }
        uint64_t v29 = v69;
      }

      if (v29)
      {
        uint64_t v32 = sub_100005D9C(v8, 1LL, 27LL, 1LL, 9LL, v30, v70, 8LL);
        if ((_DWORD)v32) {
          return v32;
        }
      }

      if (!BYTE10(v69))
      {
        uint64_t v61 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v55 = 0xD000000000000009LL;
        uint64_t v56 = v70[0] & 0xFFFFFFFFFFFFFFLL | 0x200000000000000LL;
        unsigned int v60 = 16;
        int v59 = 3808;
        uint64_t v41 = sub_10003AB6C(a1, a2, 13, &v61, v23, v24, v25, v26);
        if ((_DWORD)v41) {
          goto LABEL_70;
        }
        uint64_t v42 = sub_100034BB4(v61, a3, 0LL, &v55, &v60, v60, v9, (unsigned int *)&v59);
        uint64_t v7 = v42;
        if ((v42 & 0xFFFFFFFD) != 0) {
          goto LABEL_17;
        }
        if ((_DWORD)v42 == 2 || sub_100006884((uint64_t)&v55, (uint64_t)v9, v59))
        {
          v64[0] = v51 + *((void *)&v65 + 1);
          unint64_t v43 = v52;
          v51 += *((void *)&v65 + 1);
          unint64_t v52 = v43;
          char v50 = 1;
          goto LABEL_63;
        }

        uint64_t v44 = v9[1];
        uint64_t v45 = *((void *)&v65 + 1) + *v9;
        *(void *)&__int128 v65 = *v9;
        *((void *)&v65 + 1) = v45;
        BYTE10(v69) = 1;
        *(void *)&__int128 v66 = v44;
        *((void *)&v66 + 1) += v44;
        uint64_t v46 = *((void *)&v67 + 1) + v9[2];
        *(void *)&__int128 v67 = v9[2];
        *((void *)&v67 + 1) = v46;
        WORD4(v69) = *((_WORD *)v9 + 12);
        *(void *)&__int128 v68 = 16LL;
        uint64_t v41 = sub_1000364F0(dword_100070F78, 0LL, v70, 8LL, &v65, 80LL);
        if ((_DWORD)v41)
        {
LABEL_70:
          uint64_t v7 = v41;
          goto LABEL_17;
        }
      }

      if (WORD4(v69) > 1u) {
        goto LABEL_63;
      }
      if (*((void *)&v65 + 1) != (void)v65)
      {
        sub_100040C68( "file info: attribution tag (hash %llu): total count (%llu) does not match computed count (%llu)\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v70[0]);
        sub_100044E7C((char *)0x51F, 92);
        uint64_t v55 = *((void *)&v65 + 1);
        uint64_t v56 = 0LL;
        uint64_t v57 = 0LL;
        __int16 v58 = 0;
        uint64_t v32 = sub_100005D9C(v8, 1LL, 28LL, 0LL, 9LL, v70[0], &v55, 26LL);
        if ((_DWORD)v32) {
          return v32;
        }
      }

      if (*((void *)&v66 + 1) != (void)v66)
      {
        sub_100040C68( "file info: attribution tag (hash %llu): physical size (%llu) does not match computed size (%llu)\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v70[0]);
        sub_100044E7C((char *)0x520, 92);
        uint64_t v55 = 0LL;
        uint64_t v56 = *((void *)&v66 + 1);
        uint64_t v57 = 0LL;
        __int16 v58 = 0;
        uint64_t v32 = sub_100005D9C(v8, 1LL, 29LL, 0LL, 9LL, v70[0], &v55, 26LL);
        if ((_DWORD)v32) {
          return v32;
        }
      }

      if (v18)
      {
        sub_100040B50( "file info: attribution tag (hash %llu) skipping clone size repair because the clone mapping repairs were aborted\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v70[0]);
        goto LABEL_63;
      }

      if ((v67 & 0x8000000000000000LL) != 0)
      {
        sub_100040B50( "file info: attribution tag (hash %llu) skipping clone size repair: full clone size %llu > %llu\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v70[0]);
        uint64_t v47 = 1440LL;
LABEL_62:
        sub_100044E7C((char *)v47, 92);
        goto LABEL_63;
      }

      if ((*((void *)&v67 + 1) & 0x8000000000000000LL) != 0)
      {
        sub_100040B50( "file info: attribution tag (hash %llu) skipping clone size repair because the computed clone size is negative\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v70[0]);
        uint64_t v47 = 1421LL;
        goto LABEL_62;
      }

      if (*((void *)&v67 + 1) == (void)v67) {
        goto LABEL_63;
      }
      sub_100040C68( "file info: attribution tag (hash %llu): full clone size (%llu) does not match computed size (%llu)\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v70[0]);
      sub_100044E7C((char *)0x556, 92);
      uint64_t v55 = 0LL;
      uint64_t v56 = 0LL;
      uint64_t v57 = *((void *)&v67 + 1);
      __int16 v58 = 0;
      uint64_t v38 = v70[0];
      uint64_t v39 = &v55;
      uint64_t v34 = v8;
      uint64_t v35 = 1LL;
      uint64_t v36 = 30LL;
      uint64_t v37 = 9LL;
      uint64_t v40 = 26LL;
    }

    else
    {
      if (*((void *)&v68 + 1)) {
        uint64_t v33 = *((void *)&v68 + 1);
      }
      else {
        uint64_t v33 = 9LL;
      }
      sub_100040C68("file info: orphan attribution tag with hash (%llu)\n", v20, v21, v22, v23, v24, v25, v26, v70[0]);
      sub_100044E7C((char *)0x51E, 92);
      uint64_t v34 = v8;
      uint64_t v35 = 0LL;
      uint64_t v36 = 0LL;
      uint64_t v37 = v33;
      uint64_t v38 = v30;
      uint64_t v39 = 0LL;
      uint64_t v40 = 0LL;
    }

    uint64_t v32 = sub_100005D9C(v34, v35, v36, 0LL, v37, v38, v39, v40);
    if ((_DWORD)v32) {
      return v32;
    }
LABEL_63:
    unsigned int v53 = 80;
    unsigned int v54 = 8;
    unsigned int v48 = sub_100034BB4((uint64_t)dword_100070F78, 0LL, 2LL, v70, &v54, 8u, &v65, &v53);
  }

  while (!v48);
  if (v48 == 2) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = v48;
  }
  if ((v50 & 1) != 0)
  {
    uint64_t v55 = v52 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
    unsigned int v19 = sub_10003AC6C(a1, a2, a3, 0, (unsigned __int8 *)&v55, 8LL, (uint64_t (*)(void))sub_10000690C, (uint64_t)v64);
    BOOL v27 = v19 == -1;
    goto LABEL_13;
  }

LABEL_17:
  free(v9);
  sub_100036CD8((uint64_t)dword_100070F78, 0LL);
  return v7;
}

  if (v10 == *a4) {
    goto LABEL_19;
  }
  free(v10);
  return v31;
}

  if (a2 && *(void *)a2) {
    (*(void (**)(uint64_t))a2)(a2);
  }
  return v9;
}

uint64_t sub_100006798(uint64_t a1)
{
  if (qword_100071008) {
    BOOL v1 = qword_100071008 == a1;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    return 0LL;
  }
  uint64_t v5 = qword_100071008;
  if (xmmword_100070FF0 != 0
    || (*((void *)&xmmword_100070FB8 + 1)
      ? (BOOL v3 = *((void *)&xmmword_100070FB8 + 1) == (void)xmmword_100070FB8)
      : (BOOL v3 = 0),
        !v3
     || (qword_100070FD0 ? (BOOL v4 = qword_100070FD0 == qword_100070FC8) : (BOOL v4 = 0),
         !v4 || *((void *)&xmmword_100070FD8 + 1) != (void)xmmword_100070FD8)))
  {
    uint64_t result = sub_1000364F0(dword_100070F78, 0LL, &v5, 8LL, &xmmword_100070FB8, 80LL);
LABEL_22:
    if ((_DWORD)result) {
      return result;
    }
    goto LABEL_23;
  }

  uint64_t result = sub_100036AC4((uint64_t)dword_100070F78, 0LL, (uint64_t)&v5, 8LL);
  if ((_DWORD)result != 2) {
    goto LABEL_22;
  }
LABEL_23:
  uint64_t result = 0LL;
  qword_100071008 = 0LL;
  return result;
}

BOOL sub_100006884(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)&__n[1] = 0LL;
  __n[0] = -21846;
  uint64_t v4 = 1LL;
  if (!sub_10003B6C4((unsigned __int16 *)(a2 + 26), a3 - 26, 1, &__n[1], __n, 0LL, 0LL))
  {
    uint64_t v5 = *(void *)(a1 + 8) & 0x1FFFFFFFFFFFFFLL;
    uint64_t v6 = *(const void **)&__n[1];
    CC_LONG v7 = strnlen(*(const char **)&__n[1], __n[0]);
    return v5 != sub_10004A9FC(v6, v7);
  }

  return v4;
}

uint64_t sub_10000690C( char *a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v48 = 0LL;
  uint64_t v49 = 0LL;
  unsigned int v10 = sub_10003BCD8(a3, a4, 19, 8LL, &v48, a6, a7, a8);
  if (v10)
  {
    if (v10 == 2) {
      return 0LL;
    }
    else {
      return v10;
    }
  }

  else
  {
    uint64_t v12 = *v48;
    __int128 v47 = 0u;
    memset(v46, 0, sizeof(v46));
    unsigned int v44 = 80;
    unsigned int v45 = 8;
    if (!sub_100034BB4((uint64_t)dword_100070F78, 0LL, 1LL, &v49, &v45, 8u, v46, &v44))
    {
      while (BYTE10(v47) || v12 != v49)
      {
        unsigned int v42 = 80;
        unsigned int v43 = 8;
      }

      sub_100040C68( "file info: inode (jobj_id 0x%llx) has unexpected attribution tag with hash (%llu)\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  *a1);
      sub_100044E7C((char *)0x51C, 92);
      uint64_t v11 = sub_1000241BC((_DWORD *)a5[2], *(void *)a1, 19LL, v22, v23, v24, v25, v26);
      if ((_DWORD)v11
        || (uint64_t v11 = sub_100024184( (_DWORD *)a5[2],  *(void *)a1 & 0xFFFFFFFFFFFFFFFLL,  0x10000000LL,  v27,  v28,  v29,  v30,  v31),  (_DWORD)v11))
      {
        uint64_t v32 = *(void *)a1 & 0xFFFFFFFFFFFFFFFLL;
        strerror(v11);
        sub_100040B90( "inode (jobj_id %llu): unable to add repair for unexpected xfield: %s\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v32);
        sub_100044E7C((char *)0x536, v11);
        return v11;
      }

      uint64_t v40 = *a5;
      uint64_t v41 = a5[1] + 1;
      a5[1] = v41;
      if (v40 == v41) {
        return 0xFFFFFFFFLL;
      }
    }

    return 0LL;
  }

char *sub_100006AB8(uint64_t a1)
{
  qword_100071010 = a1;
  if (!sub_100034B44( (uint64_t)&unk_100071018,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  8,  24,  0,  0LL,  (uint64_t)sub_10002D39C)) {
    sub_100036C00((uint64_t)&unk_100071018, 0LL, 0);
  }
  uint64_t result = (char *)sub_10001A7FC((uint64_t)&unk_100071018, (uint64_t)"crypto", (uint64_t)sub_100006B74);
  if ((_DWORD)result)
  {
    sub_100040C68("failed to register the crypto tree in the fsck memory storage\n", v2, v3, v4, v5, v6, v7, v8, v9);
    return sub_100044E7C((char *)0x582, 12);
  }

  return result;
}

uint64_t sub_100006B74()
{
  if (qword_100071050) {
    uint64_t result = sub_100036CD8((uint64_t)&unk_100071018, 0LL);
  }
  qword_100071070 = 0LL;
  return result;
}

void sub_100006BA8( uint64_t a1, char *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_100071050)
  {
    uint64_t v12 = *(void *)a2 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v13 = *(void *)(a1 + 40);
    uint64_t v14 = *(void *)(v13 + 264);
    if (v12 == 4)
    {
      if ((v14 & 0x108) != 0 || (v14 & 1) != 0 && *(void *)(v13 + 976)) {
        goto LABEL_10;
      }
      if ((v14 & 9) != 0 && qword_100071010 != 0) {
        goto LABEL_10;
      }
    }

    else if ((v14 & 9) == 0)
    {
LABEL_10:
      sub_100006D10(v12);
      if (!v16)
      {
        BYTE8(xmmword_100071058) = 1;
        LODWORD(xmmword_100071058) = *a3;
      }

      return;
    }

    sub_100040C68( "found unexpected crypto state object (id %llu, refcnt %u)\n",  (uint64_t)a2,  (uint64_t)a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  *a2);
    sub_100044E7C((char *)0x340, -2);
    sub_100006CB8(a4, 0LL, 0LL, 0LL, (__int128 *)a2, 0LL, v17, v18);
  }

uint64_t sub_100006CB8( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return sub_100024E94(0LL, a2, a3, a4, (uint64_t)a5, a6, a7, a8);
  }
  if (a6) {
    unsigned int v8 = *(unsigned __int16 *)(a6 + 22) + 24;
  }
  else {
    unsigned int v8 = 0;
  }
  return sub_1000251C0(a1, 8u, a2, a3, a4, a5, 8u, (_BYTE *)a6, v8);
}

double sub_100006D10(uint64_t a1)
{
  uint64_t v6 = a1;
  if (!sub_100007350(a1) && !qword_100071070)
  {
    __int128 v4 = 0uLL;
    uint64_t v5 = 0LL;
    unsigned int v2 = 24;
    unsigned int v3 = 8;
    if ((sub_100034BB4((uint64_t)dword_100071018, 0LL, 0LL, &v6, &v3, 8u, &v4, &v2) & 0xFFFFFFFD) == 0)
    {
      qword_100071070 = v6;
      double result = *(double *)&v4;
      xmmword_100071058 = v4;
      qword_100071068 = v5;
    }
  }

  return result;
}

void sub_100006DB8(uint64_t a1, uint64_t a2)
{
  if (qword_100071050)
  {
    uint64_t v2 = *(void *)(a2 + 16);
    if ((unint64_t)(v2 + 1) > 6 || ((1LL << (v2 + 1)) & 0x43) == 0)
    {
      sub_100006D10(*(void *)(a2 + 16));
      if (!v5)
      {
        if (v2 != 4 && v2 != a1 && !qword_100071068) {
          qword_100071068 = a1;
        }
        ++DWORD1(xmmword_100071058);
      }
    }
  }

double sub_100006E4C(uint64_t *a1, uint64_t a2)
{
  if (qword_100071050)
  {
    if ((*(_BYTE *)(a2 + 7) & 1) != 0)
    {
      double result = sub_100006D10(4LL);
      if (v4) {
        return result;
      }
    }

    else
    {
      uint64_t v2 = *(void *)(a2 + 16);
      if (!v2) {
        return result;
      }
      if (v2 == 5) {
        return result;
      }
      uint64_t v5 = *a1;
      double result = sub_100006D10(*(void *)(a2 + 16));
      if (v6) {
        return result;
      }
      if (v2 != 4 && (v5 & 0xFFFFFFFFFFFFFFFLL) != v2 && !qword_100071068) {
        qword_100071068 = v5 & 0xFFFFFFFFFFFFFFFLL;
      }
    }

    ++DWORD1(xmmword_100071058);
  }

  return result;
}

double sub_100006EEC(uint64_t *a1, uint64_t a2)
{
  if (qword_100071050)
  {
    if ((*(_BYTE *)(a2 + 7) & 1) != 0)
    {
      double result = sub_100006D10(4LL);
      if (v4) {
        return result;
      }
    }

    else
    {
      uint64_t v2 = *(void *)(a2 + 16);
      if (!v2) {
        return result;
      }
      if (v2 == 5) {
        return result;
      }
      uint64_t v5 = *a1;
      double result = sub_100006D10(*(void *)(a2 + 16));
      if (v6) {
        return result;
      }
      if (v2 != 4 && qword_100071068 == (v5 & 0xFFFFFFFFFFFFFFFLL)) {
        qword_100071068 = 0LL;
      }
    }

    --DWORD1(xmmword_100071058);
  }

  return result;
}

uint64_t sub_100006F88(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!qword_100071050) {
    return 0LL;
  }
  uint64_t v60 = 0LL;
  uint64_t v57 = 0LL;
  uint64_t v58 = 0LL;
  uint64_t v59 = 0LL;
  uint64_t v6 = sub_100007350(0LL);
  if ((_DWORD)v6) {
    goto LABEL_28;
  }
  unsigned int v55 = 24;
  unsigned int v56 = 8;
  unsigned int v7 = sub_100034BB4((uint64_t)dword_100071018, 0LL, 1LL, &v60, &v56, 8u, &v57, &v55);
  if (v7)
  {
LABEL_25:
    if (v7 == 2) {
      uint64_t v6 = 0LL;
    }
    else {
      uint64_t v6 = v7;
    }
    goto LABEL_28;
  }

  while (1)
  {
    if ((_BYTE)v58)
    {
LABEL_17:
      if (v60 != 4)
      {
        if (HIDWORD(v57))
        {
          if (v57 >= HIDWORD(v57))
          {
            sub_100040C68( "refcnt (%u) of crypto state object (id %llu) is greater than expected (%u)\n",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v57);
            sub_100044E7C((char *)0x348, -8);
            uint64_t v54 = v60 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000LL;
            *(void *)&v49[4] = 0LL;
            uint64_t v50 = 0LL;
            int v51 = 0;
            *(_DWORD *)uint64_t v49 = HIDWORD(v57);
            uint64_t v32 = (__int128 *)&v54;
            uint64_t v33 = v49;
            uint64_t v34 = a3;
            uint64_t v35 = 1LL;
            uint64_t v36 = 22LL;
            uint64_t v37 = 0LL;
          }

          else
          {
            sub_100040B90( "refcnt (%u) of crypto state object (id %llu) is less than expected (%u)\n",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v57);
            sub_100044E7C((char *)0x347, 92);
            uint64_t v54 = v60 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000LL;
            *(void *)&v49[4] = 0LL;
            uint64_t v50 = 0LL;
            int v51 = 0;
            *(_DWORD *)uint64_t v49 = HIDWORD(v57);
            uint64_t v32 = (__int128 *)&v54;
            uint64_t v33 = v49;
            uint64_t v34 = a3;
            uint64_t v35 = 1LL;
            uint64_t v36 = 22LL;
            uint64_t v37 = 1LL;
          }
        }

        else
        {
          sub_100040C68("found orphan crypto state object (id %llu, refcnt %u)\n", v8, v9, v10, v11, v12, v13, v14, v60);
          sub_100044E7C((char *)0x346, -8);
          *(void *)uint64_t v49 = v60 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000LL;
          uint64_t v32 = (__int128 *)v49;
          uint64_t v34 = a3;
          uint64_t v35 = 0LL;
          uint64_t v36 = 0LL;
          uint64_t v37 = 0LL;
          uint64_t v33 = 0LL;
        }

        uint64_t v29 = sub_100006CB8(v34, v35, v36, v37, v32, (uint64_t)v33, v30, v31);
        if ((_DWORD)v29)
        {
LABEL_31:
          uint64_t v6 = v29;
          goto LABEL_28;
        }
      }

      goto LABEL_24;
    }

    *(void *)uint64_t v49 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v54 = v60 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000LL;
    unsigned int v52 = 3808;
    unsigned int v53 = 8;
    uint64_t v19 = calloc(1uLL, 0xEE0uLL);
    if (!v19) {
      break;
    }
    uint64_t v6 = sub_10003AB6C(a1, (void *)a2, 7, (uint64_t *)v49, v15, v16, v17, v18);
    if (!(_DWORD)v6) {
      uint64_t v6 = sub_100034BB4(*(uint64_t *)v49, qword_100071010, 0LL, &v54, &v53, v53, v19, &v52);
    }
    if ((_DWORD)v6 == 2)
    {
      free(v19);
      sub_100040B90( "missing crypto state object (id %llu) referenced by %u file extents / dstreams\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v60);
      sub_100044E7C((char *)0x345, 92);
      if ((*(void *)(*(void *)(a2 + 40) + 264LL) & 0x109LL) == 0x100)
      {
        *(_BYTE *)(a2 + 13) = 1;
      }

      else
      {
        uint64_t v27 = v60;
        uint64_t v28 = v59;
        uint64_t v29 = sub_100007414(a1, (void *)a2, a3, v60, v60, v12, v13, v14);
        if ((_DWORD)v29) {
          goto LABEL_31;
        }
        if (v28)
        {
          uint64_t v29 = sub_100007414(a1, (void *)a2, a3, v27, v28, v12, v13, v14);
          if ((_DWORD)v29) {
            goto LABEL_31;
          }
        }
      }
    }

    else
    {
      if ((_DWORD)v6) {
        goto LABEL_33;
      }
      LOBYTE(v58) = 1;
      LODWORD(v57) = *v19;
      HIDWORD(v57) += v57;
      free(v19);
    }

    if ((_BYTE)v58) {
      goto LABEL_17;
    }
LABEL_24:
    unsigned int v47 = 24;
    unsigned int v48 = 8;
    unsigned int v7 = sub_100034BB4((uint64_t)dword_100071018, 0LL, 2LL, &v60, &v48, 8u, &v57, &v47);
    if (v7) {
      goto LABEL_25;
    }
  }

  uint64_t v6 = 12LL;
LABEL_33:
  free(v19);
  char v39 = v60;
  strerror(v6);
  sub_100040B90("failed to look up crypto state object (id %llu): %s\n", v40, v41, v42, v43, v44, v45, v46, v39);
  sub_100044E7C((char *)0x3EE, v6);
LABEL_28:
  sub_100036CD8((uint64_t)dword_100071018, 0LL);
  return v6;
}

uint64_t sub_100007350(uint64_t a1)
{
  if (qword_100071070) {
    BOOL v1 = qword_100071070 == a1;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    return 0LL;
  }
  __int128 v5 = xmmword_100071058;
  uint64_t v6 = qword_100071068;
  uint64_t v7 = qword_100071070;
  if (qword_100071070 == 4
    || (!(_DWORD)v5 ? (BOOL v3 = BYTE8(v5) == 0) : (BOOL v3 = 1), v3 ? (v4 = (_DWORD)v5 == DWORD1(v5)) : (v4 = 0), !v4))
  {
    uint64_t result = sub_1000364F0(dword_100071018, 0LL, &v7, 8LL, &v5, 24LL);
    goto LABEL_16;
  }

  uint64_t result = sub_100036AC4((uint64_t)dword_100071018, 0LL, (uint64_t)&v7, 8LL);
  if ((_DWORD)result != 2)
  {
LABEL_16:
    if ((_DWORD)result) {
      return result;
    }
  }

  uint64_t result = 0LL;
  qword_100071070 = 0LL;
  return result;
}

uint64_t sub_100007414( uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
  LODWORD(v13) = sub_10003AB6C(a1, a2, 3, &v52, a5, a6, a7, a8);
  uint64_t v14 = calloc(1uLL, 0x340uLL);
  uint64_t v15 = (uint64_t *)calloc(1uLL, 0xEE0uLL);
  uint64_t v23 = v15;
  if ((_DWORD)v13 || !v14 || !v15)
  {
    if ((_DWORD)v13) {
      uint64_t v13 = v13;
    }
    else {
      uint64_t v13 = 12LL;
    }
    sub_100040B90("unable to allocate memory to repair missing crypto state\n", v16, v17, v18, v19, v20, v21, v22, v45);
    uint64_t v37 = 1084LL;
LABEL_13:
    sub_100044E7C((char *)v37, v13);
    goto LABEL_14;
  }

  int v50 = 3808;
  unsigned int v51 = 8;
  *uint64_t v14 = a5 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
  uint64_t v24 = sub_100034BB4(v52, qword_100071010, 0LL, v14, &v51, 8u, v15, (unsigned int *)&v50);
  if (!(_DWORD)v24)
  {
LABEL_7:
    uint64_t v29 = sub_10003AB6C(a1, a2, 6, &v52, v25, v26, v27, v28);
    if (!(_DWORD)v29)
    {
      uint64_t v49 = a5 & 0xFFFFFFFFFFFFFFFLL | 0x6000000000000000LL;
      unsigned int v47 = 8;
      int v48 = 0;
      unsigned int v46 = 4;
      uint64_t v39 = sub_100034BB4(v52, 0LL, 0LL, &v49, &v47, 8u, &v48, &v46);
      if ((_DWORD)v39 == 2) {
        goto LABEL_28;
      }
      uint64_t v13 = v39;
      if ((_DWORD)v39) {
        goto LABEL_14;
      }
      if (v14)
      {
        uint64_t v40 = v23[1];
        BOOL v41 = v40 == a5;
        uint64_t v42 = v40 == a5 ? (__int128 *)v14 : 0LL;
      }

      else
      {
        BOOL v41 = 0;
        uint64_t v42 = 0LL;
      }

      uint64_t v43 = sub_100007678(a1, a2, a3, a5, v42, (uint64_t)v23, v50, a4);
      if (!(_DWORD)v43)
      {
        BOOL v44 = !v14 || v41;
        if (v44 || (uint64_t v43 = sub_100007678(a1, a2, a3, v23[1], (__int128 *)v14, (uint64_t)v23, v50, a4), !(_DWORD)v43))
        {
LABEL_28:
          v55[0] = a1;
          v55[1] = a2;
          v55[2] = a3;
          v55[3] = v14;
          v55[4] = v23;
          v55[5] = a4;
          uint64_t v53 = a5 & 0xFFFFFFFFFFFFFFFLL | 0x4000000000000000LL;
          __int16 v54 = 0;
          uint64_t v43 = sub_10003AC6C( a1,  a2,  0LL,  1,  (unsigned __int8 *)&v53,  10LL,  (uint64_t (*)(void))sub_100007B18,  (uint64_t)v55);
        }
      }

      uint64_t v13 = v43;
      goto LABEL_14;
    }

    uint64_t v13 = v29;
    sub_100040B90("unable to get fsroot tree to repair missing crypto state\n", v30, v31, v32, v33, v34, v35, v36, v45);
    uint64_t v37 = 1158LL;
    goto LABEL_13;
  }

  uint64_t v13 = v24;
  if ((_DWORD)v24 == 2)
  {
    uint64_t v14 = 0LL;
    goto LABEL_7;
  }

uint64_t sub_100007678( uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, __int128 *a5, uint64_t a6, int a7, uint64_t a8)
{
  if (a5) {
    BOOL v14 = (*(_WORD *)(a6 + 80) & 0xF000) == 0x8000;
  }
  else {
    BOOL v14 = 0;
  }
  unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v51 = v15;
  __int128 v52 = v15;
  unsigned __int16 v50 = -21846;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  if (v14)
  {
    uint64_t v17 = a3;
    uint64_t v18 = sub_10003B6C4((unsigned __int16 *)(a6 + 92), a7 - 92, 8, &v54, &v50, 0LL, 0LL);
    if ((_DWORD)v18)
    {
LABEL_8:
      uint64_t v19 = *(void *)a5 & 0xFFFFFFFFFFFFFFFLL;
      strerror(v18);
      sub_100040B90("failed to get inode (id %llu) dstream: %s\n", v20, v21, v22, v23, v24, v25, v26, v19);
      sub_100044E7C((char *)0x43B, v18);
      return v18;
    }

    if (v50 < 0x28u)
    {
      uint64_t v18 = 34LL;
      goto LABEL_8;
    }

    unint64_t v27 = *(void *)(v54 + 32);
    __int128 v28 = *(_OWORD *)(v54 + 16);
    __int128 v51 = *(_OWORD *)v54;
    __int128 v52 = v28;
    unint64_t v53 = v27;
    unint64_t v16 = v28;
    a3 = v17;
  }

  BOOL v29 = v16 == a8 && v14;
  v46[0] = a1;
  v46[1] = a2;
  uint64_t v43 = a3;
  v46[2] = a3;
  v46[3] = a8;
  uint64_t v48 = 0LL;
  unint64_t v47 = 0xAAAAAAAA00000000LL;
  BYTE4(v47) = v29;
  uint64_t v49 = 0LL;
  if (v29) {
    LODWORD(v47) = *(_DWORD *)(a6 + 60);
  }
  *((void *)&v44 + 1) = a4 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000LL;
  uint64_t v45 = 0LL;
  uint64_t v18 = sub_10003AC6C(a1, a2, 0LL, 1, (unsigned __int8 *)&v44 + 8, 16LL, (uint64_t (*)(void))sub_1000078C4, (uint64_t)v46);
  if (!(_DWORD)v18)
  {
    if (!v29) {
      goto LABEL_22;
    }
    uint64_t v37 = v48;
    if (!v48) {
      uint64_t v37 = -1LL;
    }
    *(void *)&__int128 v52 = v37;
    sub_100040C68( "found dstream (id %llu) with missing crypto state object (id %llu)\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  a4);
    uint64_t v18 = sub_100007A20(v43, 14LL, a5, &v51, 40LL, v38, v39, v40);
    if (!(_DWORD)v18)
    {
      if (!v48
        || (*(void *)&__int128 v44 = v48 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000LL,
            uint64_t v18 = sub_100006CB8(v43, 1LL, 23LL, 1LL, &v44, 0LL, v35, v36),
            !(_DWORD)v18))
      {
LABEL_22:
        if (v49) {
          BOOL v41 = v14;
        }
        else {
          BOOL v41 = 0;
        }
        if (!v41) {
          return 0LL;
        }
        uint64_t v18 = sub_100007A20(v43, 16LL, a5, &v49, 8LL, v34, v35, v36);
        if (!(_DWORD)v18) {
          return 0LL;
        }
      }
    }
  }

  return v18;
}

uint64_t sub_1000078C4( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a3 + 16);
  if (v10 == *(void *)(a5 + 24))
  {
    uint64_t v12 = *(void *)(a3 + 8);
    if (v12) {
      uint64_t v12 = *(void *)a3 & 0xFFFFFFFFFFFFFFLL;
    }
    uint64_t v13 = *(void *)(a5 + 48);
    BOOL v14 = __CFADD__(v13, v12);
    uint64_t v15 = v13 + v12;
    *(void *)(a5 + 48) = v15;
    if (v14)
    {
      sub_100040C68("sparse bytes overflow (current %llu, update %llu)\n", a2, v10, a4, a5, a6, a7, a8, v15);
      sub_100044E7C((char *)0x43A, 92);
      uint64_t v10 = *(void *)(a5 + 24);
    }

    sub_100040B90("found fext (id %llu) with missing crypto state object (id %llu)\n", a2, v10, a4, a5, a6, a7, a8, *a1);
    uint64_t v23 = *(_DWORD **)(a5 + 16);
    if (v23)
    {
      uint64_t v25 = *(void *)a5;
      uint64_t v24 = *(void *)(a5 + 8);
      uint64_t result = sub_1000251C0(v23, 8u, 1, 0xBu, 1, (__int128 *)a1, 0x10u, (_BYTE *)a3, 0x18u);
      if (!(_DWORD)result) {
        return sub_10001E878( v24,  *(void *)(a3 + 8),  (*(void *)a3 & 0xFFFFFFFFFFFFFFuLL) / *(unsigned int *)(*(void *)(v25 + 8) + 36LL));
      }
    }

    else
    {
      return sub_100024E94(0LL, v16, v17, v18, v19, v20, v21, v22);
    }
  }

  else if (*(_BYTE *)(a5 + 36) && (v10 ? (BOOL v27 = *(void *)(a5 + 40) == 0LL) : (BOOL v27 = 0), v27))
  {
    char v28 = 0;
    uint64_t result = sub_100007A64(*(void *)a5, *(void **)(a5 + 8), v10, *(_DWORD *)(a5 + 32), &v28, a6, a7, a8);
    if (!(_DWORD)result && v28) {
      *(void *)(a5 + 40) = *(void *)(a3 + 16);
    }
  }

  else
  {
    return 0LL;
  }

  return result;
}

uint64_t sub_100007A20( _DWORD *a1, uint64_t a2, __int128 *a3, _BYTE *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_1000251C0(a1, 8u, 1, a2, 1, a3, 8u, a4, a5);
  }
  else {
    return sub_100024E94(0LL, a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  }
}

uint64_t sub_100007A64( uint64_t a1, void *a2, uint64_t a3, int a4, _BYTE *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003AB6C(a1, a2, 7, &v18, (uint64_t)a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = a3 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000LL;
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    unsigned int v12 = 24;
    unsigned int v13 = 8;
    LODWORD(result) = sub_100034BB4(v18, qword_100071010, 0LL, &v17, &v13, 8u, &v14, &v12);
    if (!(_DWORD)result && (BYTE4(v15) & 0x1F) == a4) {
      *a5 = 1;
    }
    if ((_DWORD)result == 2) {
      return 0LL;
    }
    else {
      return result;
    }
  }

  return result;
}

uint64_t sub_100007B18( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)a3 & 1) == 0 || *(void *)(a3 + 28) != *(void *)(a5 + 40)) {
    return 0LL;
  }
  uint64_t v10 = *(void *)(a3 + 4);
  uint64_t v11 = (const char *)(a1 + 10);
  sub_100040C68( "found xattr (id %llu, name %.*s) with missing crypto state\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(_BYTE *)a1);
  uint64_t v12 = *(void *)a5;
  unsigned int v13 = *(void **)(a5 + 8);
  v33[0] = *(void *)a5;
  v33[1] = v13;
  uint64_t v33[2] = *(void *)(a5 + 40);
  unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = *(void *)(a5 + 24);
  LOBYTE(v34) = v14 != 0;
  HIDWORD(v34) = 0;
  uint64_t v35 = 0LL;
  unint64_t v36 = 0xAAAAAAAAAAAAAA00LL;
  if (v14) {
    HIDWORD(v34) = *(_DWORD *)(*(void *)(a5 + 32) + 60LL);
  }
  v32[0] = v10 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000LL;
  v32[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003AC6C(v12, v13, 0LL, 1, (unsigned __int8 *)v32, 16LL, (uint64_t (*)(void))sub_100007D58, (uint64_t)v33);
  if (!(_DWORD)result)
  {
    uint64_t v18 = v35;
    uint64_t v37 = v35;
    if (*(_WORD *)(a1 + 8) == 23)
    {
      int v19 = strncmp(v11, "com.apple.ResourceFork", 0x17uLL);
      BOOL v20 = v19 == 0;
      if (v18) {
        goto LABEL_13;
      }
      if (!v19)
      {
        BOOL v20 = 1;
        LOBYTE(v36) = 1;
        goto LABEL_14;
      }
    }

    else if (v35)
    {
      BOOL v20 = 0;
      goto LABEL_13;
    }

    BOOL v20 = 0;
    uint64_t v37 = -1LL;
LABEL_13:
    if (!(_BYTE)v36) {
      return sub_100007DE8(*(_DWORD **)(a5 + 16), 1LL, 25LL, a1, &v37, 8LL, v16, v17);
    }
LABEL_14:
    uint64_t result = sub_100007DE8(*(_DWORD **)(a5 + 16), 0LL, 0LL, a1, 0LL, 0LL, v16, v17);
    if ((_DWORD)result) {
      return result;
    }
    uint64_t v24 = *(__int128 **)(a5 + 24);
    if (v24)
    {
      if (v20)
      {
        uint64_t v30 = 0x8000LL;
        uint64_t result = sub_100007A20(*(_DWORD **)(a5 + 16), 17LL, v24, &v30, 8LL, v21, v22, v23);
        if ((_DWORD)result) {
          return result;
        }
        uint64_t v31 = 0x4000LL;
        uint64_t v24 = *(__int128 **)(a5 + 24);
LABEL_27:
        uint64_t result = sub_100007A20(*(_DWORD **)(a5 + 16), 18LL, v24, &v31, 8LL, v25, v26, v27);
        if ((_DWORD)result) {
          return result;
        }
        return 0LL;
      }

      int v28 = *(unsigned __int16 *)(a1 + 8);
      if (v28 == 21)
      {
        if (!strncmp(v11, "com.apple.FinderInfo", 0x15uLL))
        {
          uint64_t v29 = 256LL;
          goto LABEL_26;
        }
      }

      else if (v28 == 26 && !strncmp(v11, "com.apple.system.Security", 0x1AuLL))
      {
        uint64_t v29 = 64LL;
LABEL_26:
        uint64_t v31 = v29;
        goto LABEL_27;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_100007D58( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a3 + 16);
  if (v10 == *(void *)(a5 + 16))
  {
    *(_BYTE *)(a5 + 40) = 1;
    return 0xFFFFFFFFLL;
  }

  else if (*(_BYTE *)(a5 + 24) && (v10 ? (BOOL v12 = *(void *)(a5 + 32) == 0LL) : (BOOL v12 = 0), v12))
  {
    char v13 = 0;
    uint64_t result = sub_100007A64(*(void *)a5, *(void **)(a5 + 8), v10, *(_DWORD *)(a5 + 28), &v13, a6, a7, a8);
    if (!(_DWORD)result)
    {
      if (v13) {
        *(void *)(a5 + 32) = *(void *)(a3 + 16);
      }
    }
  }

  else
  {
    return 0LL;
  }

  return result;
}

uint64_t sub_100007DE8( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_1000251C0(a1, 8u, a2, a3, 1, (__int128 *)a4, *(unsigned __int16 *)(a4 + 8) + 10, a5, a6);
  }
  else {
    return sub_100024E94(0LL, a2, a3, a4, (uint64_t)a5, a6, a7, a8);
  }
}

BOOL sub_100007E34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0LL);
  unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> ((v3 & 0xC0u) - a2);
  if (a3 >= 64)
  {
    while (((-1LL << v5) & ~((-1LL << v5) & *(void *)(a1 + 8 * v4))) == 0
         && (!v5 || (v6 & ~*(void *)(a1 + 8 * v4 + 8)) == 0))
    {
      uint64_t v7 = a3 - 64;
      ++v4;
      BOOL v8 = a3 <= 127;
      a3 -= 64LL;
      if (v8)
      {
        if (v7) {
          goto LABEL_13;
        }
        return 1LL;
      }
    }

    return 0LL;
  }

  uint64_t v7 = a3;
  if (!a3) {
    return 1LL;
  }
LABEL_13:
  unint64_t v9 = ~(-1LL << v7);
  unint64_t v10 = v9 << v5;
  unint64_t v11 = v9 >> (64 - v5);
  if (!v5) {
    unint64_t v11 = 0LL;
  }
  return (v10 & ~((-1LL << v5) & *(void *)(a1 + 8 * v4))) == 0
      && (v7 <= (uint64_t)(64 - v5) || !v11 || (v11 & ~(v6 & *(void *)(a1 + 8 * v4 + 8))) == 0);
}

uint64_t sub_100007F14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0LL);
  uint64_t v6 = 64 - v5;
  if (a3 >= 64)
  {
    while (((-1LL << v5) & *(void *)(a1 + 8 * v4)) == 0
         && (!v5 || (*(void *)(a1 + 8 * v4 + 8) & (0xFFFFFFFFFFFFFFFFLL >> v6)) == 0))
    {
      uint64_t v7 = a3 - 64;
      ++v4;
      BOOL v8 = a3 <= 127;
      a3 -= 64LL;
      if (v8)
      {
        if (v7) {
          goto LABEL_13;
        }
        return 1LL;
      }
    }

    return 0LL;
  }

  uint64_t v7 = a3;
  if (a3)
  {
LABEL_13:
    unint64_t v9 = ~(-1LL << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (!v5) {
      unint64_t v11 = 0LL;
    }
    if ((v10 & (-1LL << v5) & *(void *)(a1 + 8 * v4)) != 0
      || v7 > v6 && v11 && ((0xFFFFFFFFFFFFFFFFLL >> v6) & v11 & *(void *)(a1 + 8 * v4 + 8)) != 0)
    {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t sub_100007FF8(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0LL);
  uint64_t v6 = 64 - v5;
  if (a3 < 64)
  {
    uint64_t v7 = a3;
    if (!a3) {
      return result;
    }
    goto LABEL_12;
  }

  do
  {
    *(void *)(result + 8 * v4) = *(void *)(result + 8 * v4) & ~(-1LL << v5) | (-1LL << v5);
    if (v5) {
      *(void *)(result + 8 * v4 + 8) |= 0xFFFFFFFFFFFFFFFFLL >> v6;
    }
    uint64_t v7 = a3 - 64;
    ++v4;
    BOOL v8 = a3 <= 127;
    a3 -= 64LL;
  }

  while (!v8);
  if (v7)
  {
LABEL_12:
    unint64_t v9 = ~(-1LL << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (!v5) {
      unint64_t v11 = 0LL;
    }
    *(void *)(result + 8 * v4) = *(void *)(result + 8 * v4) & ~v10 | v10 & (-1LL << v5);
    if (v7 > v6)
    {
      if (v11) {
        *(void *)(result + 8 * v4 + 8) = *(void *)(result + 8 * v4 + 8) & ~v11 | v11 & (0xFFFFFFFFFFFFFFFFLL >> v6);
      }
    }
  }

  return result;
}

uint64_t sub_1000080E0(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0LL);
  uint64_t v6 = 64 - v5;
  if (a3 < 64)
  {
    uint64_t v7 = a3;
    if (!a3) {
      return result;
    }
    goto LABEL_12;
  }

  do
  {
    *(void *)(result + 8 * v4) &= ~(-1LL << v5);
    if (v5) {
      *(void *)(result + 8 * v4 + 8) &= ~(0xFFFFFFFFFFFFFFFFLL >> v6);
    }
    uint64_t v7 = a3 - 64;
    ++v4;
    BOOL v8 = a3 <= 127;
    a3 -= 64LL;
  }

  while (!v8);
  if (v7)
  {
LABEL_12:
    unint64_t v9 = ~(-1LL << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (v5) {
      unint64_t v12 = v11;
    }
    else {
      unint64_t v12 = 0LL;
    }
    *(void *)(result + 8 * v4) &= ~v10;
    if (v7 > v6)
    {
      if (v12) {
        *(void *)(result + 8 * v4 + 8) &= ~v12;
      }
    }
  }

  return result;
}

uint64_t sub_1000081A8(int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a4 < 1) {
    return 0LL;
  }
  if (a1) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = -1LL;
  }
  uint64_t v6 = (unint64_t *)(a2 + 8 * (a3 / 64));
  while (1)
  {
    uint64_t v7 = a3 & 0x3F;
    if (a3 <= 0) {
      uint64_t v7 = -(-a3 & 0x3F);
    }
    unint64_t v8 = 64 - v7;
    unint64_t v10 = *v6++;
    unint64_t v9 = v10;
    unint64_t v11 = __clz(__rbit64((v9 >> v7) ^ v5));
    if (v8 > v11) {
      break;
    }
    a3 += v8;
    BOOL v12 = a4 <= (uint64_t)v8;
    a4 -= v8;
    if (v12) {
      return 0LL;
    }
  }

  *a5 = v11 + a3;
  return 1LL;
}

unint64_t sub_10000822C(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a3 >= a4) {
    return 0LL;
  }
  unint64_t result = 0LL;
  if (a2) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = -1LL;
  }
  if (a2) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = 0LL;
  }
  do
  {
    unint64_t v8 = a4 - a3;
    if (a4 - a3 < 1) {
      break;
    }
    unint64_t v9 = (unint64_t *)(a1 + 8 * (a3 / 64));
    while (1)
    {
      uint64_t v10 = a3 & 0x3F;
      if (a3 <= 0) {
        uint64_t v10 = -(-a3 & 0x3F);
      }
      unint64_t v11 = 64 - v10;
      unint64_t v13 = *v9++;
      unint64_t v12 = v13;
      if (64 - v10 >= v8) {
        unint64_t v11 = v8;
      }
      unint64_t v14 = __clz(__rbit64((v12 >> v10) ^ v6));
      if (v11 > v14) {
        break;
      }
      a3 += v11;
      BOOL v15 = (uint64_t)v8 <= (uint64_t)v11;
      v8 -= v11;
      if (v15) {
        return result;
      }
    }

    uint64_t v16 = v14 + a3;
    uint64_t v17 = a4 - (v14 + a3);
    if (v17 < 1) {
      return result - v16 + a4;
    }
    uint64_t v18 = v16 + 63;
    if (v16 >= 0) {
      uint64_t v18 = v14 + a3;
    }
    int v19 = (unint64_t *)(a1 + 8 * (v18 >> 6));
    uint64_t v20 = v14 + a3;
    while (1)
    {
      uint64_t v21 = v20 & 0x3F;
      if (v20 <= 0) {
        uint64_t v21 = -(-v20 & 0x3F);
      }
      unint64_t v22 = 64 - v21;
      unint64_t v24 = *v19++;
      unint64_t v23 = v24;
      unint64_t v25 = __clz(__rbit64((v23 >> v21) ^ v7));
      if (v22 > v25) {
        break;
      }
      v20 += v22;
      BOOL v15 = v17 <= (uint64_t)v22;
      v17 -= v22;
      if (v15) {
        return result - v16 + a4;
      }
    }

    a3 = v25 + v20;
    unint64_t result = result - v16 + v25 + v20;
  }

  while ((uint64_t)(v25 + v20) < a4);
  return result;
}

void *sub_100008350(void *result, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a2 + 63;
  if (a2 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = a2 + 63;
  }
  unint64_t v7 = a2 - (v6 & 0xFFFFFFFFFFFFFFC0LL);
  uint64_t v8 = 64 - v7;
  uint64_t v9 = -1LL << v7;
  if (a2 == (v6 & 0xFFFFFFFFFFFFFFC0LL)) {
    unint64_t v10 = 0LL;
  }
  else {
    unint64_t v10 = 0xFFFFFFFFFFFFFFFFLL >> ((v6 & 0xC0u) - a2);
  }
  if (a4 >= 0) {
    uint64_t v11 = a4;
  }
  else {
    uint64_t v11 = a4 + 63;
  }
  unint64_t v12 = a4 - (v11 & 0xFFFFFFFFFFFFFFC0LL);
  uint64_t v13 = 64 - v12;
  uint64_t v14 = -1LL << v12;
  unint64_t v15 = 0xFFFFFFFFFFFFFFFFLL >> ((v11 & 0xC0u) - a4);
  if (result == a3 && a2 <= a4)
  {
    uint64_t v16 = a5 + a2;
    if (v16 >= 1) {
      uint64_t v17 = v16 - 1;
    }
    else {
      uint64_t v17 = v16 + 62;
    }
    uint64_t v18 = a5 + a4;
    uint64_t v20 = a5 + a4 - 1;
    BOOL v19 = a5 + a4 < 1;
    uint64_t v21 = a5 + a4 + 62;
    if (!v19) {
      uint64_t v21 = v20;
    }
    if (a5 <= 0) {
      uint64_t v22 = -(-a5 & 0x3F);
    }
    else {
      uint64_t v22 = a5 & 0x3F;
    }
    if (v22)
    {
      BOOL v19 = v16 < v22;
      uint64_t v23 = v16 - v22;
      if (v19) {
        v23 += 63LL;
      }
      uint64_t v24 = v23 >> 6;
      BOOL v19 = v18 < v22;
      uint64_t v25 = v18 - v22;
      if (v19) {
        v25 += 63LL;
      }
      uint64_t v26 = v25 >> 6;
      unint64_t v27 = (result[v24] & (unint64_t)v9) >> v7;
      if (v7 && v22 >= v8) {
        v27 |= (result[v24 + 1] & v10) << v8;
      }
      unint64_t v28 = ~(-1LL << v22);
      unint64_t v29 = v27 & v28;
      unint64_t v30 = v28 >> v13;
      if (!v12) {
        unint64_t v30 = 0LL;
      }
      result[v26] = (v29 << v12) & (v28 << v12) | result[v26] & ~(v28 << v12);
      if (v22 > v13 && v30) {
        result[v26 + 1] = result[v26 + 1] & ~v30 | (v29 >> v13) & v30;
      }
      a5 -= v22;
      uint64_t v31 = v24 - 1;
      uint64_t v32 = v26 - 1;
    }

    else
    {
      uint64_t v31 = v17 >> 6;
      uint64_t v32 = v21 >> 6;
    }

    if (a5 >= 64)
    {
      uint64_t v45 = v6 >> 6;
      if (v31 >= v45)
      {
        unint64_t v46 = ~v15;
        unint64_t v47 = &result[v32 + 1];
        uint64_t v48 = &result[v31 + 1];
        unint64_t result = v48;
        do
        {
          uint64_t v49 = *--result;
          unint64_t v50 = (v49 & (unint64_t)v9) >> v7;
          if (v7) {
            v50 |= *v48 << v8;
          }
          *(v47 - 1) = *(v47 - 1) & ~v14 | (v50 << v12) & v14;
          if (v12) {
            *unint64_t v47 = *v47 & v46 | (v50 >> v13);
          }
          if (a5 < 128) {
            break;
          }
          a5 -= 64LL;
          --v47;
          uint64_t v48 = result;
          BOOL v19 = v31-- <= v45;
        }

        while (!v19);
      }
    }

    return result;
  }

  uint64_t v33 = v11 >> 6;
  if (a2 >= 0) {
    uint64_t v5 = a2;
  }
  uint64_t v34 = v5 >> 6;
  if (a5 < 64)
  {
    uint64_t v39 = a5;
    if (!a5) {
      return result;
    }
    goto LABEL_47;
  }

  unint64_t v35 = ~v15;
  unint64_t v36 = &a3[v33 + 1];
  uint64_t v37 = &result[v34 + 1];
  do
  {
    unint64_t v38 = (*(v37 - 1) & (unint64_t)v9) >> v7;
    if (v7) {
      v38 |= *v37 << v8;
    }
    *(v36 - 1) = *(v36 - 1) & ~v14 | (v38 << v12) & v14;
    if (v12) {
      *unint64_t v36 = *v36 & v35 | (v38 >> v13);
    }
    ++v34;
    uint64_t v39 = a5 - 64;
    ++v36;
    ++v37;
    ++v33;
    BOOL v19 = a5 <= 127;
    a5 -= 64LL;
  }

  while (!v19);
  if (v39)
  {
LABEL_47:
    unint64_t v40 = (result[v34] & (unint64_t)v9) >> v7;
    if (v7 && v39 >= v8) {
      v40 |= (result[v34 + 1] & v10) << v8;
    }
    unint64_t v41 = ~(-1LL << v39);
    unint64_t v42 = v40 & v41;
    unint64_t v43 = v41 << v12;
    unint64_t v44 = v41 >> v13;
    if (!v12) {
      unint64_t v44 = 0LL;
    }
    a3[v33] = (v42 << v12) & v43 | a3[v33] & ~v43;
    if (v39 > v13 && v44) {
      a3[v33 + 1] = a3[v33 + 1] & ~v44 | (v42 >> v13) & v44;
    }
  }

  return result;
}

uint64_t sub_1000086AC(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (a2 << 6) - a3;
  sub_100008350(a1, a3, a1, 0LL, v5);
  return sub_1000080E0((uint64_t)a1, v5, a3);
}

uint64_t sub_1000086FC(uint64_t result)
{
  if (dword_100070040 < 99)
  {
    uint64_t v1 = result;
    int v2 = ++dword_100070040;
    uint64_t v3 = *(void *)(result + 8);
    uint64_t v4 = *(void *)(v3 + 48);
    if (!v4) {
      uint64_t v4 = *(void *)(v3 + 40);
    }
    if ((*(_BYTE *)(v4 + 56) & 0x20) == 0)
    {
      if (sub_100034B44( (uint64_t)&xmmword_100071078 + 152 * v2,  0LL,  v3,  0x8000000,  2,  0,  0,  4096,  0,  0,  0,  0LL,  (uint64_t)sub_100008874)
        || sub_100036C00((uint64_t)&xmmword_100071078 + 152 * v2, 0LL, 0x42u))
      {
        return sub_100036CD8((uint64_t)&xmmword_100071078 + 152 * v2, 0LL);
      }

      else
      {
        uint64_t v5 = *(void *)(v1 + 8);
        if (v5) {
          uint64_t v5 = *(void *)(*(void *)(v5 + 40) + 8LL);
        }
        uint64_t v6 = (char *)&xmmword_100071078 + 152 * v2;
        *((void *)v6 + 16) = v5;
        v6[144] = 0;
        unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t result = sub_100036B70(v1, 0LL, &v10);
        if ((_DWORD)result)
        {
          *((void *)&xmmword_100071078 + 19 * v2 + 17) = 50LL;
        }

        else
        {
          unint64_t v7 = v10;
          uint64_t v8 = (char *)&xmmword_100071078 + 152 * v2;
          *((void *)v8 + 17) = v10 / 0x64;
          uint64_t v9 = (unint64_t *)(v8 + 136);
          if (v7 <= 0x3E7)
          {
            if (v7 >= 0xA) {
              unint64_t v7 = 10LL;
            }
            *uint64_t v9 = v7;
          }
        }
      }
    }
  }

  else
  {
    dword_100070040 = 100;
  }

  return result;
}

uint64_t sub_100008874(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 >= 0x1C && a5 >= 0x1C)
  {
    uint64_t result = sub_10003A6AC( a1,  (unint64_t *)(a2 + 20),  *(_DWORD *)(a2 + 16),  (unint64_t *)(a4 + 20),  *(_DWORD *)(a4 + 16),  a6);
    if (!(_DWORD)result)
    {
      if (*a6) {
        return 0LL;
      }
      if (*(void *)a2 > *(void *)a4) {
        goto LABEL_9;
      }
      if (*(void *)a2 >= *(void *)a4)
      {
        unint64_t v11 = *(void *)(a2 + 8);
        unint64_t v12 = *(void *)(a4 + 8);
        if (v11 > v12)
        {
LABEL_9:
          int v13 = 1;
LABEL_12:
          uint64_t result = 0LL;
          *a6 = v13;
          return result;
        }

        if (v11 >= v12) {
          return 0LL;
        }
      }

      int v13 = -1;
      goto LABEL_12;
    }
  }

  return result;
}

uint64_t sub_100008924(uint64_t a1, int *a2, int *a3, _BYTE *a4, uint64_t a5)
{
  int v27 = -1431655766;
  int v28 = -1431655766;
  unint64_t v10 = (unint64_t *)*((void *)a2 + 2);
  unint64_t v11 = (unint64_t *)*((void *)a3 + 1);
  if (!((unint64_t)v10 | (unint64_t)v11))
  {
    int v28 = 0;
    goto LABEL_10;
  }

  if (!v10)
  {
    int v13 = 1;
LABEL_9:
    int v28 = v13;
    goto LABEL_10;
  }

  if (!v11)
  {
    int v13 = -1;
    goto LABEL_9;
  }

  uint64_t result = sub_10003A6AC(a1, v10, a2[1], v11, *a3, &v28);
  if ((_DWORD)result) {
    return result;
  }
LABEL_10:
  uint64_t v14 = (unint64_t *)*((void *)a3 + 2);
  unint64_t v15 = (unint64_t *)*((void *)a2 + 1);
  int v16 = v14 | v15;
  if ((unint64_t)v14 | (unint64_t)v15)
  {
    if (v14)
    {
      if (v15)
      {
        uint64_t result = sub_10003A6AC(a1, v14, a3[1], v15, *a2, &v27);
        if ((_DWORD)result) {
          return result;
        }
        int v16 = v27 > 0;
      }

      else
      {
        int v16 = 0;
        int v27 = -1;
      }
    }

    else
    {
      int v16 = 1;
      int v27 = 1;
    }
  }

  else
  {
    int v27 = 0;
  }

  uint64_t result = 0LL;
  if (v28 <= 0) {
    int v16 = 0;
  }
  *a4 = v16;
  if (a5 && v16)
  {
    uint64_t v17 = (unint64_t *)*((void *)a2 + 1);
    uint64_t v18 = (unint64_t *)*((void *)a3 + 1);
    if (!((unint64_t)v17 | (unint64_t)v18))
    {
      int v28 = 0;
      goto LABEL_31;
    }

    if (v17)
    {
      if (v18)
      {
        uint64_t result = sub_10003A6AC(a1, v17, *a2, v18, *a3, &v28);
        if ((_DWORD)result) {
          return result;
        }
LABEL_31:
        uint64_t v20 = (unint64_t *)*((void *)a2 + 2);
        uint64_t v21 = (unint64_t *)*((void *)a3 + 2);
        if ((unint64_t)v20 | (unint64_t)v21)
        {
          if (v20)
          {
            if (v21)
            {
              uint64_t result = sub_10003A6AC(a1, v20, a2[1], v21, a3[1], &v27);
              if ((_DWORD)result) {
                return result;
              }
              goto LABEL_40;
            }

            int v22 = -1;
          }

          else
          {
            int v22 = 1;
          }

          int v27 = v22;
        }

        else
        {
          int v27 = 0;
        }

LABEL_40:
        uint64_t result = 0LL;
        if (v28 < 0) {
          uint64_t v23 = a3;
        }
        else {
          uint64_t v23 = a2;
        }
        *(void *)(a5 + 8) = *((void *)v23 + 1);
        int v24 = *v23;
        if (v27 >= 1) {
          uint64_t v25 = a3;
        }
        else {
          uint64_t v25 = a2;
        }
        *(void *)(a5 + 16) = *((void *)v25 + 2);
        int v26 = v25[1];
        *(_DWORD *)a5 = v24;
        *(_DWORD *)(a5 + 4) = v26;
        return result;
      }

      int v19 = -1;
    }

    else
    {
      int v19 = 1;
    }

    int v28 = v19;
    goto LABEL_31;
  }

  return result;
}

    if (v103) {
      free(v103);
    }
  }

  return v20;
}

uint64_t sub_100008B08( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, unsigned int a7, const void *a8, unsigned int a9, unsigned int a10)
{
  uint64_t v10 = a10;
  if (dword_100070040 != 100)
  {
    if (*((void *)&xmmword_100071078 + 19 * dword_100070040 + 7))
    {
      uint64_t v12 = *(void *)(a1 + 8);
      if (v12)
      {
        if (!*(void *)(v12 + 56) && a6 && *(_DWORD *)(a1 + 48) == 14 && (a10 == 92 || a10 == 2))
        {
          unint64_t v15 = (char *)&xmmword_100071078 + 152 * dword_100070040;
          if (*((void *)v15 + 17) <= (unint64_t)v15[144])
          {
            sub_100040C68( "reached invalid tree node limit %llu for fs_oid %llu\n",  a2,  a3,  a4,  a5,  (uint64_t)a6,  (uint64_t)a6,  (uint64_t)a8,  *((void *)v15 + 17));
            sub_100036CD8((uint64_t)v15, 0LL);
          }

          else
          {
            uint64_t v10 = sub_100008C80(v15, a3, a4, a5, 0x7FFFFFFFFFFFFFFFLL, 0LL, a6, a7, 0, a8, a9, 0);
            if (!(_DWORD)v10)
            {
              *(_BYTE *)(a2 + 74) = 1;
              if ((byte_100074BDC & 1) == 0) {
                sub_100040C68( "aborting jobj validations for current fsck pass - trying to repair fsroot tree with invalid nodes\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23);
              }
              byte_100074BDC = 1;
              sub_100013338(*(void *)(a1 + 8));
              sub_1000051F4();
              uint64_t v10 = 0LL;
              *(_BYTE *)(*(void *)(a1 + 8) + 9LL) = 0;
              ++v15[144];
              ++dword_100074BD8;
            }
          }
        }
      }
    }
  }

  return v10;
}

uint64_t sub_100008C80( _DWORD *a1, uint64_t a2, uint64_t a3, __int16 a4, uint64_t a5, uint64_t a6, const void *a7, unsigned int a8, int a9, const void *a10, unsigned int a11, int a12)
{
  size_t v17 = a8 + 20;
  uint64_t v18 = malloc(v17);
  uint64_t v19 = (char *)malloc(a11 + 30);
  uint64_t v20 = v19;
  if (v18) {
    BOOL v21 = v19 == 0LL;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21)
  {
    *uint64_t v18 = a2;
    v18[1] = a3;
    *((_DWORD *)v18 + 4) = a8;
    memcpy((char *)v18 + 20, a7, a8);
    *((_WORD *)v20 + 4) = a4;
    *(void *)(v20 + 10) = a5;
    *(void *)uint64_t v20 = a6;
    *(_DWORD *)(v20 + 18) = a9;
    *(_DWORD *)(v20 + 22) = a12;
    *(_DWORD *)(v20 + 26) = a11;
    if (a10) {
      memcpy(v20 + 30, a10, a11);
    }
    uint64_t v24 = sub_1000364F0(a1, 0LL, v18, v17, v20, a11 + 30);
    uint64_t v22 = v24;
    if ((_DWORD)v24)
    {
      uint64_t v25 = *(void *)((char *)v18 + 20) & 0xFFFFFFFFFFFFFFFLL;
      strerror(v24);
      sub_100040B90( "unable to insert tree node at key id %llu for repairs : %s\n",  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v25);
      sub_100044E7C((char *)0x3F1, v22);
    }

uint64_t sub_100008E04(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v3 = dword_100070040;
  if (dword_100070040 == 100) {
    return 0LL;
  }
  if (!*((void *)&xmmword_100071078 + 19 * dword_100070040 + 7)) {
    return 0LL;
  }
  v33[0] = 0LL;
  sub_100036AE0((uint64_t)&xmmword_100071078 + 152 * dword_100070040, 0LL, v33);
  if (!v33[0]) {
    return 0LL;
  }
  uint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  memset(v33, 0, 80);
  uint64_t v7 = sub_10002A1E0((uint64_t)a1, a2, &v34);
  if (!(_DWORD)v7)
  {
    uint64_t v7 = sub_100030A20(v34, *(void *)(v34 + 56), 0LL, (uint64_t)v33);
    if (!(_DWORD)v7)
    {
      memset(v32, 0, sizeof(v32));
      uint64_t v7 = sub_100035838((uint64_t)v32, (uint64_t)&xmmword_100071078 + 152 * v3, 0LL, 0LL, 0);
      if ((_DWORD)v7
        || (uint64_t v7 = sub_10002930C( (uint64_t)v32,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000090B4,  a3,  0),  (_DWORD)v7))
      {
        char v8 = strerror(v7);
        sub_100040B90("unable to enqueue tree node prune repairs: %s\n", v9, v10, v11, v12, v13, v14, v15, v8);
        uint64_t v16 = 1011LL;
LABEL_9:
        sub_100044E7C((char *)v16, v7);
        return v7;
      }

      if (!*(_BYTE *)(qword_10008DB78 + 47))
      {
        sub_100009144();
        return 0LL;
      }

      uint64_t v17 = sub_1000091B4((uint64_t)&xmmword_100071078 + 152 * v3 + 64, a2);
      if ((_DWORD)v17)
      {
        uint64_t v7 = v17;
        uint64_t v16 = 1053LL;
        goto LABEL_9;
      }

      v29[1] = v34;
      v29[2] = (uint64_t)v33;
      uint64_t v30 = (char *)&xmmword_100071078 + 152 * v3;
      uint64_t v31 = v30 + 64;
      uint64_t v7 = sub_10001CF60(a1, a2, 1, 0, (uint64_t (*)(void))sub_10000922C);
      if ((_DWORD)v7) {
        return v7;
      }
      if (!*(void *)(*(void *)(a2 + 40) + 216LL)) {
        return 0LL;
      }
      if (*(_BYTE *)(qword_10008DB78 + 42)) {
        return 0LL;
      }
      v29[0] = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v19 = sub_1000422F4(a1, a2, v29);
      if ((_DWORD)v19 == 2) {
        return 0LL;
      }
      uint64_t v7 = v19;
      if (!(_DWORD)v19)
      {
        uint64_t v7 = sub_100030A20(v34, *(void *)(v34 + 56), v29[0], (uint64_t)v33);
        if (!(_DWORD)v7)
        {
          v28[0] = v34;
          v28[1] = v33;
          v28[2] = v29[0];
          v28[3] = (char *)&xmmword_100071078 + 152 * v3 + 64;
          uint64_t v7 = sub_100035838((uint64_t)v32, (uint64_t)&xmmword_100071078 + 152 * v3, 0LL, 0LL, 0);
          if ((_DWORD)v7
            || (uint64_t v7 = sub_10002930C( (uint64_t)v32,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000092D8,  (uint64_t)v28,  0),  (_DWORD)v7))
          {
            char v20 = strerror(v7);
            sub_100040B90( "unable to iterate snap fsroot tree for tree node repairs: %s\n",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v20);
            uint64_t v16 = 1054LL;
            goto LABEL_9;
          }

          return 0LL;
        }
      }
    }
  }

  return v7;
}

uint64_t sub_1000090B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  __int16 v17 = *(_WORD *)(a3 + 8);
  uint64_t v5 = (void *)(a1 + 20);
  uint64_t v6 = sub_1000251C0(a5, 7u, 0, 0, 1, (__int128 *)(a1 + 20), *(_DWORD *)(a1 + 16), &v17, 2u);
  uint64_t v7 = v6;
  if ((_DWORD)v6)
  {
    uint64_t v8 = *v5 & 0xFFFFFFFFFFFFFFFLL;
    strerror(v6);
    sub_100040B90("unable to add tree repair at key at id %llu : %s\n", v9, v10, v11, v12, v13, v14, v15, v8);
    sub_100044E7C((char *)0x3F2, v7);
  }

  return v7;
}

uint64_t sub_100009144()
{
  int v0 = dword_100070040;
  if (dword_100070040 != 100)
  {
    uint64_t v1 = (char *)&xmmword_100071078 + 152 * dword_100070040;
    dword_100074BD8 -= v1[144];
    v1[144] = 0;
    sub_100036CD8((uint64_t)&xmmword_100071078 + 152 * v0, 0LL);
    return sub_100036CD8((uint64_t)(v1 + 64), 0LL);
  }

  return result;
}

uint64_t sub_1000091B4(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100034B44(a1, 0LL, a2, 0x8000000, 2, 0, 0, 4096, 0, 0, 0, 0LL, (uint64_t)sub_100008874);
  if (!(_DWORD)result) {
    return sub_100036C00(a1, 0LL, 0x42u);
  }
  return result;
}

uint64_t sub_10000922C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((*(_BYTE *)a3 & 1) != 0) {
    return 0LL;
  }
  uint64_t v7 = *(void *)a5;
  uint64_t v8 = *(void *)(a5 + 8);
  uint64_t v13 = 0LL;
  uint64_t v11 = 0LL;
  if (!sub_100022BD0( *(uint64_t **)v7,  *(void *)(v7 + 8),  0,  *a1,  a1[1],  0,  3,  0xEu,  (uint64_t **)&v13,  0LL,  0))
  {
    uint64_t v11 = sub_100009DAC(v7, v8, *(void *)(a5 + 16), *(_DWORD **)(a5 + 24), (uint64_t)v13, *(void *)(a3 + 8), v9, v10);
    free(v13);
  }

  return v11;
}

uint64_t sub_1000092D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  int v7 = *(_DWORD *)(a3 + 26);
  uint64_t v8 = (unint64_t *)(a3 + 30);
  uint64_t v9 = *a5;
  uint64_t v36 = a5[1];
  if (v7) {
    uint64_t v10 = a3 + 30;
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v11 = a5[2];
  uint64_t v12 = (_DWORD *)a5[3];
  __int128 v52 = 0LL;
  memset(v51, 170, sizeof(v51));
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v46 = 0u;
  uint64_t v13 = a1 + 20;
  uint64_t v14 = sub_1000354C8((uint64_t)&v46, v9, v11, 4294967294LL, (const void *)(a1 + 20), *(_DWORD *)(a1 + 16), 1u);
  if ((_DWORD)v14)
  {
    uint64_t v15 = v14;
    strerror(v14);
    sub_100040B90( "unable to iterate fsroot tree (xid %llu) for tree node repairs: %s\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v11);
    uint64_t v23 = 1050LL;
LABEL_6:
    sub_100044E7C((char *)v23, v15);
    goto LABEL_9;
  }

  if (!BYTE8(v48))
  {
    while (1)
    {
      uint64_t v25 = **((void **)&v47 + 1);
      if (v52)
      {
        free(v52);
        __int128 v52 = 0LL;
      }

      uint64_t v26 = sub_100022BD0(*(uint64_t **)v9, *(void *)(v9 + 8), 0, v25, v11, 0, 3, 0xEu, &v52, (uint64_t)v51, 0);
      if ((_DWORD)v26) {
        goto LABEL_24;
      }
      memset(v45, 170, sizeof(v45));
      unsigned __int16 v44 = -21846;
      sub_100030CB4((uint64_t)v52, v36, 0, (uint64_t *)&v45[5], v45, *((_DWORD *)v52 + 9) - 1, (uint64_t *)&v45[1], &v44);
      int v43 = 0;
      if (v7)
      {
        uint64_t v15 = sub_10003A6AC( *(void *)(*(void *)(v9 + 8) + 40LL),  *(unint64_t **)&v45[5],  v45[0],  v8,  *(_DWORD *)(a3 + 26),  &v43);
        if ((_DWORD)v15 || (v43 & 0x80000000) == 0) {
          goto LABEL_9;
        }
      }

      int v27 = *(_DWORD *)(a3 + 26);
      v40[0] = *(_DWORD *)(a1 + 16);
      v40[1] = v27;
      uint64_t v41 = v13;
      uint64_t v42 = v10;
      v37[0] = v45[0];
      v37[1] = v44;
      uint64_t v38 = *(void *)&v45[5];
      uint64_t v39 = *(void *)&v45[1];
      uint64_t v26 = sub_10000A018(v12, *(void *)(*(void *)(v9 + 8) + 40LL), v36, (uint64_t)v52, v51[0], v11, v40, v37);
      if ((_DWORD)v26)
      {
LABEL_24:
        uint64_t v15 = v26;
        goto LABEL_9;
      }

      uint64_t v28 = (*((uint64_t (**)(__int128 *))&v46 + 1))(&v46);
      if ((_DWORD)v28) {
        break;
      }
      if (BYTE8(v48)) {
        goto LABEL_8;
      }
    }

    uint64_t v15 = v28;
    strerror(v28);
    sub_100040B90( "error iterating fsroot tree (xid %llu) for tree node repairs: %s\n",  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v11);
    uint64_t v23 = 1051LL;
    goto LABEL_6;
  }

LABEL_8:
  uint64_t v15 = 0LL;
LABEL_9:
  if ((void)v46) {
    ((void (*)(__int128 *))v46)(&v46);
  }
  if (v52) {
    free(v52);
  }
  return v15;
}

    *(void *)&uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)((char *)v163 + 15) = v18;
    v163[0] = v18;
    uint64_t v162 = v18;
    uint64_t v161 = v18;
    uint64_t v160 = v18;
    uint64_t v159 = v18;
    uint64_t v158 = v18;
    int v157 = v18;
    uint64_t v156 = v18;
    uint64_t v155 = v18;
    uint64_t v154 = v18;
    uint64_t v153 = v18;
    *(_OWORD *)&v152[49] = v18;
    *(_OWORD *)&v152[33] = v18;
    *(_OWORD *)&v152[17] = v18;
    *(_OWORD *)&v152[1] = v18;
    uint64_t v19 = *(void *)(a7 + 32) + 1LL;
    *(void *)(a7 + 32) = v19;
    v152[0] = 0;
    sub_1000432C4(qword_10008DB70, 214, (uint64_t)a3, a4, a5, a6, a7, a8, v19);
    uint64_t v17 = *a3;
    goto LABEL_9;
  }

  uint64_t v16 = *(_DWORD *)a5;
LABEL_12:
  if (v16 >= 4)
  {
    sub_100040C68("omap snapshot: invalid oms_flags (0x%x)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v16);
    sub_100044E7C((char *)0x175, -3);
  }

  if (*(_DWORD *)(a5 + 4))
  {
    sub_100040C68("omap snapshot: invalid oms_pad (0x%x)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(_DWORD *)(a5 + 4));
    sub_100044E7C((char *)0x176, -10);
  }

  if (*(void *)(a5 + 8))
  {
    sub_100040C68( "omap snapshot: oms_oid should be unused but has value (0x%llx)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a5 + 8));
    sub_100044E7C((char *)0x312, -2);
  }

  if ((v15 & 1) != 0)
  {
    uint64_t v21 = 0;
    uint64_t v20 = 0LL;
    goto LABEL_20;
  }

  uint64_t v28 = *(void *)(a2 + 40);
  if (!v13 || ((*(_BYTE *)(v28 + 264) & 1) == 0 || *(void *)(v28 + 976)) && !*(void *)(a2 + 24)) {
    goto LABEL_46;
  }
  uint64_t v29 = *a3;
  int v151 = 0LL;
  memset(v152, 170, 24);
  uint64_t v30 = sub_100022BD0(a1, a2, 0, v13, v29, 0, 29, 0, (uint64_t **)&v151, (uint64_t)v152, 0);
  if (!(_DWORD)v30)
  {
    uint64_t v38 = v151;
    uint64_t v39 = *((_DWORD *)v151 + 8);
    if (v39 < 2)
    {
      if (v39)
      {
        if (*((void *)v151 + 5) == v29
          || (sub_100040C68( "snap_meta_ext: (0x%llx:0x%llx): invalid xid (0x%llx)\n",  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v13),  sub_100044E7C((char *)0x35F, 92),  !sub_1000428C4( qword_10008DB70,  "Fix sme_snap_xid (xid 0x%llx)? ",  v40,  v41,  v42,  v43,  v44,  v45,  *((void *)v38 + 5))))
        {
          uint64_t v20 = 0LL;
        }

        else
        {
          *((void *)v38 + 5) = v29;
          uint64_t v20 = 1LL;
        }

        if (*((_DWORD *)v38 + 9))
        {
          sub_100040C68("snap_meta_ext: (0x%llx:0x%llx): unknown flags (%u)\n", v31, v32, v33, v34, v35, v36, v37, v13);
          sub_100044E7C((char *)0x360, -3);
        }

        if (uuid_is_null((const unsigned __int8 *)v38 + 48))
        {
          sub_100040C68( "snap_meta_ext: (0x%llx:0x%llx): sme_uuid is NULL\n",  v120,  v121,  v122,  v123,  v124,  v125,  v126,  v13);
          sub_100044E7C((char *)0x361, 92);
        }

        if ((_DWORD)v20)
        {
          uint64_t v149 = *(_OWORD *)v152;
          uint64_t v150 = *(void *)&v152[16];
          uint64_t v20 = sub_100023FA8(a1, a2, (uint64_t)v151, (uint64_t)&v149, *(int8x16_t *)v152, v127);
          if ((_DWORD)v20) {
            sub_100044E7C((char *)0x362, v20);
          }
          else {
            sub_100044E2C();
          }
        }

        goto LABEL_42;
      }
    }

    else
    {
      sub_100040C68("snap_meta_ext: (0x%llx:0x%llx): unknown version (%u)\n", v31, v32, v33, v34, v35, v36, v37, v13);
      sub_100044E7C((char *)0x35E, -6);
    }

    goto LABEL_41;
  }

  uint64_t v20 = v30;
  if ((_DWORD)v30 == 2)
  {
    sub_100040B50( "snap_meta_ext: object (oid 0x%llx): no record for snapshot (xid 0x%llx)\n",  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v13);
LABEL_41:
    uint64_t v20 = 0LL;
  }

  free(v16);
  return v25;
}

  if (v4 <= a1 || *(v4 - 1) == 47) {
    return 0xFFFFFFFFLL;
  }
  return strtoul(v4 + 1, 0LL, 10) - 1;
}

uint64_t sub_100009554(uint64_t *a1)
{
  if (!dword_100074BD8) {
    return 0LL;
  }
  if (!*(_BYTE *)(qword_10008DB78 + 47)) {
    return 92LL;
  }
  memset(v48, 0, sizeof(v48));
  int v2 = malloc(0x354uLL);
  __int128 v49 = v2;
  int v3 = malloc(0x35EuLL);
  __int128 v50 = v3;
  uint64_t v4 = malloc(0x354uLL);
  uint64_t v5 = malloc(0x35EuLL);
  uint64_t v6 = v5;
  if (!v4 || !v2 || !v3 || !v5)
  {
    uint64_t v7 = 12LL;
    sub_100044E7C((char *)0x41F, 12);
LABEL_32:
    if (v4) {
      goto LABEL_33;
    }
    goto LABEL_34;
  }

  uint64_t v7 = sub_10003E8B0( a1,  0LL,  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100009938,  (char **)a1,  0);
  if ((_DWORD)v7) {
    goto LABEL_33;
  }
  if ((*(_BYTE *)(a1[1] + 65) & 1) != 0)
  {
    uint64_t v7 = sub_10003E8B0( a1,  1LL,  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100009938,  (char **)a1,  0);
    if ((_DWORD)v7) {
      goto LABEL_33;
    }
  }

  uint64_t v7 = sub_100002120((unint64_t)a1, sub_100009968, (uint64_t)a1);
  if ((_DWORD)v7) {
    goto LABEL_33;
  }
  if (*(_BYTE *)(qword_10008DB78 + 48))
  {
    uint64_t v7 = sub_10003F7CC( (uint64_t)a1,  (uint64_t (*)(unint64_t, unint64_t, uint64_t))sub_100009984,  (uint64_t)a1);
    if ((_DWORD)v7) {
      goto LABEL_33;
    }
  }

  int v8 = dword_100070040;
  if (dword_100070040 >= 99) {
    int v8 = 99;
  }
  if (v8 < 0)
  {
    uint64_t v7 = 0LL;
    goto LABEL_33;
  }

  uint64_t v9 = (v8 + 1);
  uint64_t v10 = &xmmword_100071078;
  while (1)
  {
    __int128 v11 = v10[7];
    v45[2] = v10[6];
    v45[3] = v11;
    __int128 v46 = v10[8];
    uint64_t v47 = *((void *)v10 + 18);
    __int128 v12 = v10[3];
    uint64_t v43[2] = v10[2];
    __int128 v44 = v12;
    __int128 v13 = v10[5];
    v45[0] = v10[4];
    v45[1] = v13;
    __int128 v14 = v10[1];
    v43[0] = *v10;
    v43[1] = v14;
    if (!(_BYTE)v47) {
      goto LABEL_27;
    }
    if (!*((void *)&v44 + 1)) {
      goto LABEL_27;
    }
    uint64_t v15 = sub_10001CA50((uint64_t)a1, v46);
    if (!v15) {
      goto LABEL_27;
    }
    uint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
    memset(v41, 0, sizeof(v41));
    uint64_t v16 = sub_10002A1E0((uint64_t)a1, (uint64_t)v15, &v42);
    if ((_DWORD)v16 || (uint64_t v16 = sub_100030A20(v42, *(void *)(v42 + 56), 0LL, (uint64_t)v41), (_DWORD)v16))
    {
      uint64_t v7 = v16;
      goto LABEL_33;
    }

    uint64_t v40 = 0LL;
    memset(v39, 0, sizeof(v39));
    *(void *)&v48[0] = v42;
    *((void *)&v48[0] + 1) = v45;
    bzero(v49, 0x354uLL);
    bzero(v50, 0x35EuLL);
    bzero(v4, 0x354uLL);
    bzero(v6, 0x35EuLL);
    v4[4] = 8;
    uint64_t v17 = sub_100035394((uint64_t)v39, (uint64_t)v45, 0LL, v4, 0x354u, 0x354u, v6, 862);
    if ((_DWORD)v17
      || (uint64_t v17 = sub_10002930C( (uint64_t)v39,  (uint64_t (*)(void, void, void, void, uint64_t))sub_100009AA0,  (uint64_t)v48,  0),  (_DWORD)v17))
    {
      uint64_t v7 = v17;
      char v20 = strerror(v17);
      sub_100040B90("unable to fix overlaps in candidate tree: %s\n", v21, v22, v23, v24, v25, v26, v27, v20);
      uint64_t v28 = 1056LL;
      goto LABEL_46;
    }

    v38[0] = v42;
    v38[1] = v41;
    memset(v37, 0, sizeof(v37));
    uint64_t v18 = sub_100035838((uint64_t)v37, (uint64_t)v45, 0LL, 0LL, 0);
    if ((_DWORD)v18) {
      break;
    }
    uint64_t v18 = sub_10002930C((uint64_t)v37, sub_100009BEC, (uint64_t)v38, 0);
    if ((_DWORD)v18) {
      break;
    }
    sub_100036CD8((uint64_t)v43, 0LL);
    sub_100036CD8((uint64_t)v45, 0LL);
LABEL_27:
    uint64_t v7 = 0LL;
    uint64_t v10 = (__int128 *)((char *)v10 + 152);
    if (!--v9) {
      goto LABEL_32;
    }
  }

  uint64_t v7 = v18;
  char v29 = strerror(v18);
  sub_100040B90("unable to enqueue tree node insertion repairs: %s\n", v30, v31, v32, v33, v34, v35, v36, v29);
  uint64_t v28 = 1057LL;
LABEL_46:
  sub_100044E7C((char *)v28, v7);
LABEL_33:
  free(v4);
LABEL_34:
  if (v6) {
    free(v6);
  }
  if (v49) {
    free(v49);
  }
  if (v50) {
    free(v50);
  }
  dword_100074BD8 = 0;
  dword_100070040 = -1;
  return v7;
}

uint64_t sub_100009938(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  if (a3 && a4 != 1) {
    sub_10000A208(a2, a3, a5);
  }
  return 0LL;
}

uint64_t sub_100009968(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10003F664( a3,  a1,  a2,  (uint64_t (*)(unint64_t, unint64_t, uint64_t))sub_10000A208,  a3);
}

uint64_t sub_100009984(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v6 = *(unsigned int *)(a3[1] + 36);
  v13[1] = 0LL;
  uint64_t v14 = 8LL;
  uint64_t v7 = calloc(8uLL, 0x10uLL);
  v13[0] = v7;
  if (!v7) {
    return 12LL;
  }
  HIDWORD(v13[1]) = 1;
  uint64_t v8 = ((unint64_t)(a1 << __clz(__rbit64(v6))) >> 62) & 1;
  *uint64_t v7 = a1;
  v7[1] = a2;
  uint64_t v9 = sub_100002178((uint64_t)a3, v8, (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_10000A490, (uint64_t)v13);
  if (!(_DWORD)v9)
  {
    uint64_t v9 = sub_10000206C( (unint64_t)a3,  v8,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_10000A490,  (uint64_t)v13);
    if (!(_DWORD)v9)
    {
      if (SHIDWORD(v13[1]) >= 1)
      {
        uint64_t v10 = 0LL;
        uint64_t v11 = 0LL;
        do
        {
          sub_10000A208(*(void *)((char *)v13[0] + v10), *(void *)((char *)v13[0] + v10 + 8), a3);
          ++v11;
          v10 += 16LL;
        }

        while (v11 < SHIDWORD(v13[1]));
      }

      uint64_t v9 = 0LL;
    }
  }

  if (v13[0]) {
    free(v13[0]);
  }
  return v9;
}

uint64_t sub_100009AA0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t *a5)
{
  uint64_t v10 = *a5;
  uint64_t v11 = a5[1];
  uint64_t v13 = a5[4];
  uint64_t v12 = a5[5];
  char v25 = 0;
  if (!*((_BYTE *)a5 + 16)) {
    goto LABEL_11;
  }
  int v14 = *(_DWORD *)(v12 + 26);
  uint64_t v15 = v12 + 30;
  if (!v14) {
    uint64_t v15 = 0LL;
  }
  int v16 = *(_DWORD *)(a3 + 26);
  uint64_t v17 = a3 + 30;
  if (!v16) {
    uint64_t v17 = 0LL;
  }
  v22[0] = *(_DWORD *)(v13 + 16);
  v22[1] = v14;
  uint64_t v23 = v13 + 20;
  uint64_t v24 = v15;
  v19[0] = *(_DWORD *)(a1 + 16);
  v19[1] = v16;
  uint64_t v20 = a1 + 20;
  uint64_t v21 = v17;
  uint64_t result = sub_100008924(*(void *)(*(void *)(v10 + 8) + 40LL), v22, v19, &v25, 0LL);
  if (!(_DWORD)result)
  {
    if (!v25) {
      goto LABEL_11;
    }
    if (*(void *)(v13 + 8) > *(void *)(a1 + 8)) {
      return sub_10000A610(v11, a1, a2);
    }
    uint64_t result = sub_10000A610(v11, v13, *((unsigned int *)a5 + 5));
    if (!(_DWORD)result)
    {
LABEL_11:
      *((_BYTE *)a5 + 16) = 1;
      bzero((void *)a5[4], 0x354uLL);
      memcpy((void *)a5[4], (const void *)a1, a2);
      *((_DWORD *)a5 + 5) = a2;
      bzero((void *)a5[5], 0x35EuLL);
      memcpy((void *)a5[5], (const void *)a3, a4);
      uint64_t result = 0LL;
      *((_DWORD *)a5 + 6) = a4;
    }
  }

  return result;
}

uint64_t sub_100009BEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(void *)(a5 + 8);
  uint64_t v7 = **(uint64_t ***)a5;
  uint64_t v8 = *(void *)(*(void *)a5 + 8LL);
  unsigned int v9 = *(_DWORD *)(*(void *)a5 + 24LL);
  uint64_t v10 = calloc(1uLL, v9);
  if (v10)
  {
    uint64_t v11 = v10;
    if (!v8 || (uint64_t v12 = *(void *)(v8 + 40), (*(_BYTE *)(v12 + 264) & 1) != 0))
    {
      uint64_t v14 = 0LL;
      uint64_t v13 = *v7;
    }

    else
    {
      uint64_t v13 = *v7;
      if (*(void *)(v12 + 976))
      {
        uint64_t v14 = 0LL;
      }

      else
      {
        BOOL v19 = *(void *)(v12 + 1096) != 0LL;
        uint64_t v20 = *(void *)(v8 + 8LL * v19 + 24);
        uint64_t v21 = v8 + 96LL * v19 + 768;
        if (v20)
        {
          uint64_t v13 = v20;
          uint64_t v14 = v21;
        }

        else
        {
          uint64_t v14 = 0LL;
        }
      }
    }

    uint64_t v15 = sub_10002BF50(v13, *(void *)(a3 + 10), v9 / *(_DWORD *)(v7[1] + 36), (uint64_t)v11, v14, 0, 0LL, 0LL, 0);
    if (!(_DWORD)v15)
    {
      memset(v32, 170, sizeof(v32));
      unsigned __int16 v31 = -21846;
      unsigned int v16 = *(_DWORD *)(a3 + 18);
      if (v16 > *(_DWORD *)(a3 + 22))
      {
LABEL_12:
        uint64_t v15 = 0LL;
      }

      else
      {
        uint64_t v17 = (_DWORD *)(v8 + 704);
        while (1)
        {
          sub_100030B3C((uint64_t)v11, v6, v16, (uint64_t *)&v32[5], v32, (uint64_t *)&v32[1], &v31);
          uint64_t v18 = sub_1000251C0(v17, 7u, 2, 0, 1, *(__int128 **)&v32[5], v32[0], *(_BYTE **)&v32[1], v31);
          if ((_DWORD)v18) {
            break;
          }
          if (++v16 > *(_DWORD *)(a3 + 22)) {
            goto LABEL_12;
          }
        }

        uint64_t v15 = v18;
        uint64_t v22 = **(void **)&v32[5] & 0xFFFFFFFFFFFFFFFLL;
        strerror(v18);
        sub_100040B90("unable to add tree node repair at key id %llu : %s\n", v23, v24, v25, v26, v27, v28, v29, v22);
        sub_100044E7C((char *)0x41C, v15);
      }
    }

    free(v11);
  }

  else
  {
    uint64_t v15 = 12LL;
    sub_100044E7C((char *)0x436, 12);
  }

  return v15;
}

uint64_t sub_100009DAC( uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a5 + 34)) {
    return 0LL;
  }
  uint64_t v8 = 0LL;
  memset(v60, 170, 18);
  unsigned __int16 v59 = -21846;
  sub_100030CB4(a5, a2, 0, (uint64_t *)&v60[5], v60, *(_DWORD *)(a5 + 36) - 1, (uint64_t *)&v60[1], &v59);
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v54 = 0u;
  unsigned int v15 = v60[0] + 20;
  unsigned int v16 = (char *)calloc(1uLL, v60[0] + 20LL);
  uint64_t v17 = v16;
  if (v16)
  {
    *(void *)unsigned int v16 = -1LL;
    *((void *)v16 + 1) = -1LL;
    size_t v18 = v60[0];
    *((_DWORD *)v16 + 4) = v60[0];
    memcpy(v16 + 20, *(const void **)&v60[5], v18);
    uint64_t v19 = sub_1000354C8((uint64_t)&v54, a3, 0LL, 4294967294LL, v17, v15, 0);
    if (!(_DWORD)v19)
    {
      if (!BYTE8(v56))
      {
        while (1)
        {
          __int128 v31 = v55;
          int v32 = *(_DWORD *)(*((void *)&v55 + 1) + 26LL);
          int v53 = 0;
          uint64_t v33 = v55 + 20;
          if (sub_10003A6AC( *(void *)(*(void *)(a1 + 8) + 40LL),  (unint64_t *)(v55 + 20),  *(_DWORD *)(v55 + 16),  *(unint64_t **)&v60[1],  v59,  &v53)
            || v53 >= 1)
          {
            break;
          }

          uint64_t v35 = *((void *)&v31 + 1) + 30LL;
          if (!v32) {
            uint64_t v35 = 0LL;
          }
          int v36 = *(_DWORD *)(*((void *)&v31 + 1) + 26LL);
          v50[0] = *(_DWORD *)(v31 + 16);
          v50[1] = v36;
          uint64_t v51 = v33;
          uint64_t v52 = v35;
          v47[0] = v60[0];
          v47[1] = v59;
          uint64_t v48 = *(void *)&v60[5];
          uint64_t v49 = *(void *)&v60[1];
          uint64_t v37 = sub_10000A018(a4, *(void *)(*(void *)(a1 + 8) + 40LL), a2, a5, a6, 0LL, v50, v47);
          if ((_DWORD)v37)
          {
            uint64_t v8 = v37;
            goto LABEL_10;
          }

          uint64_t v38 = (*((uint64_t (**)(__int128 *))&v54 + 1))(&v54);
          uint64_t v8 = v38;
          if ((_DWORD)v38)
          {
            char v39 = strerror(v38);
            sub_100040B90("unable to iterate tree for tree node repairs: %s\n", v40, v41, v42, v43, v44, v45, v46, v39);
            uint64_t v28 = 1049LL;
            goto LABEL_7;
          }

          if (BYTE8(v56)) {
            goto LABEL_10;
          }
        }
      }

      uint64_t v8 = 0LL;
      goto LABEL_10;
    }

    uint64_t v8 = v19;
    char v20 = strerror(v19);
    sub_100040B90("unable to iterate tree for tree node repairs: %s\n", v21, v22, v23, v24, v25, v26, v27, v20);
    uint64_t v28 = 1048LL;
LABEL_7:
    int v29 = v8;
  }

  else
  {
    uint64_t v8 = 12LL;
    uint64_t v28 = 1047LL;
    int v29 = 12;
  }

  sub_100044E7C((char *)v28, v29);
LABEL_10:
  if ((void)v54) {
    ((void (*)(__int128 *))v54)(&v54);
  }
  if (v17) {
    free(v17);
  }
  return v8;
}

uint64_t sub_10000A018( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, int *a8)
{
  char v33 = 0;
  memset(v32, 170, sizeof(v32));
  int v14 = sub_100008924(a2, a7, a8, &v33, (uint64_t)v32);
  uint64_t result = 0LL;
  if (!v14 && v33)
  {
    memset(v31, 170, sizeof(v31));
    int v30 = 0;
    __int16 v29 = -21846;
    unsigned int v16 = -1;
    int v28 = -1;
    unsigned int v17 = *(_DWORD *)(a4 + 36);
    if (v17)
    {
      do
      {
        unsigned int v18 = v16++;
        sub_100030B3C(a4, a3, v16, &v31[2], (_WORD *)&v30 + 1, v31, &v29);
        int v19 = sub_10003A6AC(a2, (unint64_t *)v31[2], HIWORD(v30), v32[1], v32[0], &v28);
        unsigned int v17 = *(_DWORD *)(a4 + 36);
        BOOL v20 = v19 == 0;
        BOOL v21 = v18 + 2 < v17 && v19 == 0;
      }

      while (v21 && v28 < 0);
      int v28 = -1;
      if (v16 >= v17 || v19)
      {
        unsigned int v22 = v16;
      }

      else
      {
        unsigned int v22 = v16;
        do
        {
          sub_100030B3C(a4, a3, v22, &v31[1], &v30, v31, &v29);
          int v23 = sub_10003A6AC(a2, (unint64_t *)v31[1], (unsigned __int16)v30, v32[2], HIDWORD(v32[0]), &v28);
          ++v22;
          unsigned int v17 = *(_DWORD *)(a4 + 36);
          BOOL v20 = v23 == 0;
        }

        while (v22 < v17 && v23 == 0 && v28 < 1);
      }
    }

    else
    {
      BOOL v20 = 1;
      unsigned int v22 = -1;
    }

    int v26 = v22 - 1;
    if (!v20 || v26 == v17) {
      return 0LL;
    }
    else {
      return sub_100008C80( a1,  *(void *)(a4 + 8),  *(void *)(a4 + 16),  *(_WORD *)(a4 + 34),  a5,  a6,  (const void *)v31[2],  HIWORD(v30),  v16,  (const void *)v31[1],  (unsigned __int16)v30,  v26);
    }
  }

  return result;
}

uint64_t sub_10000A208(unint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = (char *)calloc(1uLL, *(unsigned int *)(a3[1] + 36));
  if (!v6)
  {
    sub_100044E7C((char *)0x435, 12);
    return 0LL;
  }

  uint64_t v7 = (uint64_t)v6;
  int v8 = dword_100070040;
  if (dword_100070040 >= 99) {
    int v8 = 99;
  }
  if (v8 < 0) {
    goto LABEL_30;
  }
  uint64_t v9 = 0LL;
  unint64_t v10 = a2 + a1;
  uint64_t v11 = (v8 + 1);
  uint64_t v32 = v11;
  char v33 = (uint32x4_t *)(v6 + 8);
  while (1)
  {
    uint64_t v12 = (char *)&xmmword_100071078 + 152 * v9;
    __int128 v13 = *((_OWORD *)v12 + 7);
    void v38[2] = *((_OWORD *)v12 + 6);
    v38[3] = v13;
    __int128 v39 = *((_OWORD *)v12 + 8);
    uint64_t v40 = *((void *)v12 + 18);
    __int128 v14 = *((_OWORD *)v12 + 3);
    v36[2] = *((_OWORD *)v12 + 2);
    __int128 v37 = v14;
    __int128 v15 = *((_OWORD *)v12 + 5);
    v38[0] = *((_OWORD *)v12 + 4);
    v38[1] = v15;
    __int128 v16 = *((_OWORD *)v12 + 1);
    v36[0] = *(_OWORD *)v12;
    v36[1] = v16;
    if (!(_BYTE)v40) {
      goto LABEL_29;
    }
    if (!*((void *)&v37 + 1)) {
      goto LABEL_29;
    }
    unsigned int v17 = sub_10001CA50((uint64_t)a3, v39);
    if (!v17) {
      goto LABEL_29;
    }
    unsigned int v18 = v17;
    uint64_t v35 = 0xAAAAAAAAAAAAAAAALL;
    memset(v34, 0, sizeof(v34));
    if (sub_10002A1E0((uint64_t)a3, (uint64_t)v17, &v35)
      || sub_100030A20(v35, *(void *)(v35 + 56), 0LL, (uint64_t)v34))
    {
      goto LABEL_30;
    }

    uint64_t v19 = *((void *)v18 + 5);
    int v20 = (*(_BYTE *)(v19 + 264) & 1) != 0 ? 0 : 4 * (*(void *)(v19 + 976) == 0LL);
    if (a1 < v10) {
      break;
    }
LABEL_28:
    uint64_t v11 = v32;
LABEL_29:
    if (++v9 == v11) {
      goto LABEL_30;
    }
  }

  unsigned int v21 = *(_DWORD *)(v35 + 24);
  BOOL v22 = *(void *)(v19 + 1096) != 0LL;
  int v23 = (uint64_t *)&v18[8 * v22 + 24];
  uint64_t v24 = (uint64_t)&v18[96 * v22 + 768];
  while (1)
  {
    uint64_t v25 = *a3;
    if (v20)
    {
      if (*v23)
      {
        uint64_t v25 = *v23;
        uint64_t v26 = v24;
      }

      else
      {
        uint64_t v26 = 0LL;
      }
    }

    else
    {
      uint64_t v26 = 0LL;
    }

    if (sub_10002BF50(v25, a1, v21 / *(_DWORD *)(a3[1] + 36), v7, v26, 0, 0LL, 0LL, 0)
      || (*(_DWORD *)(v7 + 24) & 0xFFFFFFFE) == 2
      && *(_DWORD *)(v7 + 28) == 14
      && !sub_10003A224((void *)v7, v33, v21 - 8, 0LL, v27, v28)
      && sub_100009DAC(v35, (uint64_t)v34, (uint64_t)v36, v38, v7, a1, v29, v30))
    {
      break;
    }

    if (v10 == ++a1)
    {
      a1 = v10;
      goto LABEL_28;
    }
  }

LABEL_30:
  free((void *)v7);
  return 0LL;
}

  if ((v48 - 3) <= 0xFFFFFFFD)
  {
    uint64_t v71 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040B90("%s (id %llu): unknown kind (%u)\n", v72, v73, v74, v75, v76, v77, v78, v71);
    sub_100044E7C((char *)0x33A, 92);
    unsigned int v62 = v62 | 2;
  }

  uint64_t v79 = a5[1];
  if (!v79)
  {
    char v90 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040B90("%s (id %llu): owning_obj_id is 0\n", v91, v92, v93, v94, v95, v96, v97, v90);
    sub_100044E7C((char *)0xD0, 92);
    unsigned int v62 = v62 | 4;
LABEL_42:
    sub_100040E4C(a2, (uint64_t)a3, 8LL, (uint64_t)a5, 20LL, a6, a7, a8, v106);
    goto LABEL_43;
  }

  if ((_DWORD)v48 == 2 && v79 != -1LL)
  {
    uint64_t v80 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040B90( "%s (id %llu): invalid owning_obj_id (%llu) for update extent\n",  v81,  v82,  v83,  v84,  v85,  v86,  v87,  v80);
    char v88 = 1230LL;
    char v89 = 92;
LABEL_40:
    sub_100044E7C((char *)v88, v89);
    goto LABEL_41;
  }

  if ((_DWORD)v48 == 1 && v79 >= 0xFFFFFFFFFFFFFFFELL)
  {
    uint64_t v98 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040C68("%s (id %llu): owning_obj_id is '%s'\n", v99, v100, v101, v102, v103, v104, v105, v98);
    char v88 = 988LL;
    char v89 = -2;
    goto LABEL_40;
  }

  int v53 = 0LL;
  uint64_t v49 = *a2;
  uint64_t v34 = *(_DWORD *)(a1 + 36);
  uint64_t v35 = *(void *)(a1 + 56);
  uint64_t v51 = -1431655766;
  uint64_t v52 = v35;
  __int128 v50 = v34;
  if (v19)
  {
    int v36 = 0;
    __int128 v37 = v19 + 1;
    uint64_t v38 = v55;
    do
    {
      __int128 v39 = *((_DWORD *)v38 + 2);
      if ((v36 & 1) != 0)
      {
        uint64_t v40 = *(_DWORD *)(a3 + 36);
        uint64_t v41 = (unsigned __int16 *)a3;
        __int128 v16 = v39 >= v40;
        uint64_t v42 = v39 - v40;
        if (v42 != 0 && v16)
        {
          uint64_t v41 = (unsigned __int16 *)*a9;
          __int128 v39 = v42;
        }
      }

      else
      {
        uint64_t v41 = (unsigned __int16 *)a3;
      }

      uint64_t v43 = (const void *)*((void *)v38 - 2);
      uint64_t v44 = (const void *)*((void *)v38 - 1);
      uint64_t v45 = *(_DWORD *)v38;
      uint64_t v46 = *((_DWORD *)v38 + 1);
      if (*((_BYTE *)v38 + 12))
      {
      }

      else if ((sub_1000381DC((int *)&v49, (uint64_t)v41, v39, v43, v45, v44, v46) & 1) == 0)
      {
LABEL_41:
        uint64_t result = sub_100038378( a1,  a2,  a3,  *((_DWORD *)v38 + 2),  *((unsigned __int8 *)v38 + 12),  *((const void **)v38 - 2),  *(_DWORD *)v38,  *((const void **)v38 - 1),  *((_DWORD *)v38 + 1),  a9,  &v53);
        if ((_DWORD)result) {
          return result;
        }
        int v36 = 1;
      }

      --v37;
      v38 += 2;
    }

    while (v37 > 1);
  }

  return 0LL;
}

uint64_t sub_10000A490(unint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 8) = 0;
  int v6 = 0;
  char v8 = -86;
  while (1)
  {
    uint64_t result = sub_1000032D8( *(void *)(*(void *)a3 + 16LL * v6),  *(void *)(*(void *)a3 + 16LL * v6 + 8),  a1,  a2,  &v8,  (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t))sub_10000A534,  a3);
    if ((_DWORD)result) {
      break;
    }
    int v6 = *(_DWORD *)(a3 + 8);
    if (!v8) {
      *(_DWORD *)(a3 + 8) = ++v6;
    }
    if (v6 >= *(_DWORD *)(a3 + 12)) {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10000A534(uint64_t a1, uint64_t a2, int a3, int32x2_t *a4)
{
  uint64_t v5 = (char *)*a4;
  uint64_t v6 = a4[1].i32[0];
  if (a3)
  {
    memmove(&v5[16 * v6], &v5[16 * v6 + 16], 16LL * (a4[1].i32[1] - (int)v6));
    uint64_t result = 0LL;
    --a4[1].i32[1];
    return result;
  }

  __int32 v10 = a4[1].i32[1];
  if (v10 != a4[2].i32[0]) {
    goto LABEL_6;
  }
  a4[2].i32[0] = 2 * v10;
  uint64_t v11 = (char *)realloc(v5, 32LL * v10);
  if (v11)
  {
    __int32 v10 = a4[1].i32[1];
    uint64_t v5 = v11;
LABEL_6:
    uint64_t v12 = &v5[16 * v6];
    memmove(v12 + 16, v12, 16LL * (v10 - (int)v6));
    uint64_t result = 0LL;
    *(void *)uint64_t v12 = a1;
    *((void *)v12 + 1) = a2;
    a4[1] = vadd_s32(a4[1], (int32x2_t)0x100000001LL);
    return result;
  }

  free(v5);
  return 12LL;
}

uint64_t sub_10000A610(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = sub_100036AC4(a1, 0LL, a2, a3);
  uint64_t v5 = v4;
  if ((v4 & 0xFFFFFFFD) != 0)
  {
    uint64_t v6 = *(void *)(a2 + 20) & 0xFFFFFFFFFFFFFFFLL;
    strerror(v4);
    sub_100040B90("unable to remove tree node at key id %llu for repairs : %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
    sub_100044E7C((char *)0x416, v5);
  }

  return v5;
}

uint64_t sub_10000A680(uint64_t *a1, unint64_t a2, int a3, void **a4)
{
  uint64_t v8 = (unsigned int *)a1[3];
  uint64_t v9 = v8[12 * a3 + 20];
  uint64_t v10 = *a4;
  if (!*a4)
  {
    uint64_t v10 = malloc(v8[8]);
    if (!v10)
    {
      uint64_t v32 = 526LL;
      char v33 = "Failed to allocate memory\n";
      goto LABEL_10;
    }
  }

  unsigned int v18 = (char *)v8 + v9;
  unint64_t v19 = a2 / v8[10];
  if (!v8[12 * a3 + 17])
  {
    unsigned int v21 = 0LL;
    goto LABEL_12;
  }

  int v20 = (char *)malloc(v8[8]);
  if (!v20)
  {
    uint64_t v32 = 527LL;
    char v33 = "Failed to allocate memory for cab\n";
LABEL_10:
    sub_100040B90(v33, v11, v12, v13, v14, v15, v16, v17, v43);
    uint64_t v31 = 12LL;
    sub_100044E7C((char *)v32, 12);
    goto LABEL_17;
  }

  unsigned int v21 = v20;
  unsigned int v22 = v19 / v8[11];
  uint64_t v23 = sub_10002BE74(*a1, *(void *)&v18[8 * v22]);
  if ((_DWORD)v23)
  {
    uint64_t v31 = v23;
    sub_100040B90("error (%d) getting cab %u @ %lld on device %d\n", v24, v25, v26, v27, v28, v29, v30, v23);
    sub_100044E7C((char *)0x1D6, v31);
LABEL_15:
    free(v21);
    goto LABEL_16;
  }

  unsigned int v18 = v21 + 40;
  LODWORD(v19) = v19 - v8[11] * v22;
LABEL_12:
  uint64_t v34 = sub_10002BE74(*a1, *(void *)&v18[8 * v19]);
  uint64_t v31 = v34;
  if ((_DWORD)v34)
  {
    sub_100040B90("error (%d) getting cib %u @ %lld on device %d\n", v35, v36, v37, v38, v39, v40, v41, v34);
    sub_100044E7C((char *)0x1D7, v31);
  }

  if (v21) {
    goto LABEL_15;
  }
LABEL_16:
  if (!(_DWORD)v31)
  {
LABEL_19:
    *a4 = v10;
    return v31;
  }

uint64_t sub_10000A838(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, char **a5, _DWORD *a6, int a7)
{
  uint64_t v93 = 0LL;
  uint64_t v11 = a1[3];
  char v12 = __clz(__rbit64(*(unsigned int *)(v11 + 32)));
  unint64_t v13 = (((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v12) & a2) / *(unsigned int *)(v11 + 36);
  if (a5) {
    uint64_t v93 = *a5;
  }
  uint64_t v14 = sub_10000A680(a1, v13, ((a2 << v12) & 0x4000000000000000LL) != 0, (void **)&v93);
  if ((_DWORD)v14)
  {
    uint64_t v15 = v14;
    uint64_t v93 = 0LL;
    strerror(v14);
    sub_100040B90("failed to get cib for chunk index %llu: %s\n", v16, v17, v18, v19, v20, v21, v22, v13);
    uint64_t v23 = 0LL;
    uint64_t v24 = 0LL;
    int v25 = 0;
LABEL_5:
    uint64_t v26 = a6;
    uint64_t v27 = a4;
    goto LABEL_6;
  }

  uint64_t v23 = v93;
  unint64_t v90 = v13 % *(unsigned int *)(v11 + 40);
  uint64_t v28 = &v93[32 * v90];
  uint64_t v30 = *((void *)v28 + 8);
  uint64_t v29 = v28 + 64;
  uint64_t v24 = v30;
  if (v30)
  {
    uint64_t v31 = sub_10002BE74(*a1, v24);
    uint64_t v15 = v31;
    if ((_DWORD)v31)
    {
      int v25 = v90;
      sub_100040B90("error (%d) getting cib %d bitmap %d @ %lld on device %d\n", v32, v33, v34, v35, v36, v37, v38, v31);
      sub_100044E7C((char *)0x1D8, v15);
      goto LABEL_5;
    }

LABEL_41:
    uint64_t v26 = a6;
    uint64_t v27 = a4;
    int v25 = v90;
LABEL_42:
    if (!v26) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }

  sub_1000080E0(a3, 0LL, *(unsigned int *)(v11 + 36));
  if (!a7)
  {
    uint64_t v24 = 0LL;
    uint64_t v15 = 2LL;
    goto LABEL_41;
  }

  uint64_t v95 = 0LL;
  uint64_t v96 = 0LL;
  uint64_t v39 = (unsigned int *)a1[3];
  size_t v40 = v39[8];
  uint64_t v94 = 0LL;
  uint64_t v41 = malloc(v40);
  if (!v41)
  {
    sub_100040B90("Failed to allocate memory\n", v42, v43, v44, v45, v46, v47, v48, v86);
    sub_100044E7C((char *)0x20C, 12);
    goto LABEL_54;
  }

  uint64_t v49 = v41;
  unsigned int v87 = (uint64_t *)v29;
  if (!v39[40])
  {
LABEL_52:
    free(v49);
LABEL_54:
    uint64_t v24 = 0LL;
    uint64_t v15 = 28LL;
LABEL_55:
    uint64_t v27 = a4;
    sub_100044E7C((char *)0x210, v15);
    int v25 = v90;
    uint64_t v26 = a6;
LABEL_6:
    if ((v15 & 0xFFFFFFFD) != 0)
    {
      if (v26) {
        *uint64_t v26 = 0;
      }
      if (v27)
      {
        uint64_t v24 = 0LL;
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    goto LABEL_42;
  }

  unsigned int v50 = 0;
  unint64_t v51 = 0LL;
  uint64_t v52 = (8 * v40);
  int v53 = (char *)v39 + v39[82];
  char v88 = v41;
  char v89 = v53;
  while (1)
  {
    uint64_t v54 = *(unsigned __int16 *)&v53[2 * v51];
    uint64_t v55 = a1[3];
    int v56 = *(_DWORD *)(v55 + 164);
    if ((v56 & 0x7FFFFFFFu) <= v54)
    {
      LOBYTE(v67) = 22;
LABEL_24:
      sub_100040B90("error (%d) looking up spaceman IP bitmap block %u\n", v42, v54, v44, v45, v46, v47, v48, v67);
      goto LABEL_25;
    }

    uint64_t v57 = *(void *)(v55 + 168);
    if (v56 < 0)
    {
      int v67 = sub_10002DC38((uint64_t)a1, v57, v54, &v96, 0LL);
      if (v67) {
        goto LABEL_24;
      }
      uint64_t v58 = v96;
    }

    else
    {
      uint64_t v58 = v57 + v54;
      uint64_t v96 = v58;
    }

    int v59 = sub_10002BE74(*a1, v58);
    if (!v59) {
      break;
    }
    sub_100040B90("error (%d) getting spaceman IP bitmap block %u @ %lld\n", v60, v61, v62, v63, v64, v65, v66, v59);
LABEL_25:
    ++v51;
    v50 += v52;
    if (v51 >= v39[40]) {
      goto LABEL_52;
    }
  }

  uint64_t v69 = v95;
  unint64_t v70 = v95 + v50;
  uint64_t v71 = a1[3];
  uint64_t v72 = *(void *)(v71 + 152);
  if ((v72 & 0x7FFFFFFFFFFFFFFFuLL) <= v70)
  {
    int v83 = 22;
LABEL_36:
    sub_100040B90("error (%d) looking up spaceman IP block %llu\n", v69, v68, v44, v45, v46, v47, v48, v83);
    sub_100044E7C((char *)0x21F, v83);
    uint64_t v49 = v88;
    goto LABEL_37;
  }

  uint64_t v73 = *(void *)(v71 + 176);
  if ((v72 & 0x8000000000000000LL) == 0)
  {
    uint64_t v94 = v73 + v70;
    goto LABEL_33;
  }

  int v83 = sub_10002DC38((uint64_t)a1, v73, v70, &v94, 0LL);
  if (v83) {
    goto LABEL_36;
  }
  uint64_t v69 = v95;
  uint64_t v49 = v88;
LABEL_33:
  sub_100007FF8((uint64_t)v49, v69, 1LL);
  int v74 = sub_10002BFDC(*a1, v96);
  if (v74)
  {
    int v82 = v74;
    sub_100040B90("error (%d) writing spaceman IP bitmap %d @ %lld\n", v75, v76, v77, v78, v79, v80, v81, v74);
    sub_100044E7C((char *)0x20D, v82);
LABEL_37:
    int v53 = v89;
    goto LABEL_25;
  }

  uint64_t v24 = v94;
  free(v49);
  if (!v24)
  {
    uint64_t v15 = 92LL;
    goto LABEL_55;
  }

  uint64_t v15 = 0LL;
  *unsigned int v87 = v24;
  uint64_t v85 = *(void *)(v11 + 16);
  int v25 = v90;
  *(void *)&v23[32 * v90 + 40] = v85;
  uint64_t v26 = a6;
  uint64_t v27 = a4;
  if (a6) {
LABEL_43:
  }
    *uint64_t v26 = v25;
LABEL_44:
  if (v27) {
LABEL_45:
  }
    *uint64_t v27 = v24;
LABEL_46:
  if (a5 && (!(_DWORD)v15 || v23 == *a5)) {
    *a5 = v23;
  }
  else {
    free(v23);
  }
  return v15;
}

  if ((_DWORD)v62) {
    goto LABEL_42;
  }
LABEL_43:
  uint64_t v32 = sub_10001EBD0(a1, a2, a3, (uint64_t)a5, v62, a6, a7, a8);
  if (!(_DWORD)v32) {
    return v32;
  }
  uint64_t v33 = 827LL;
  uint64_t v45 = v32;
LABEL_8:
  sub_100044E7C((char *)v33, v45);
  return v32;
}

uint64_t sub_10000AC50(uint64_t a1, uint64_t **a2, _DWORD *a3)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(v5 + 36);
  if (v4 >= v6)
  {
    uint64_t v12 = 0LL;
    *(_BYTE *)(a1 + 376) = 1;
  }

  else
  {
    uint64_t v9 = v4 + 1;
    if (v9 < v6 && (uint64_t v10 = v5 + 32 * v9, (v11 = *(void *)(v10 + 64)) != 0))
    {
      uint64_t v12 = sub_100023F40( *(uint64_t **)a1,  0LL,  0x40000000,  v11,  *(void *)(v10 + 40),  0x20000000,  8,  0,  a1 + 176 * (v9 & 1) + 24);
      if ((_DWORD)v12) {
        sub_100044E7C((char *)0x47A, v12);
      }
    }

    else
    {
      uint64_t v12 = 0LL;
    }

    uint64_t v13 = *(unsigned int *)(a1 + 16);
    uint64_t v14 = *(uint64_t **)a1;
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v16 = *(void *)(v15 + 32 * v13 + 64);
    *a3 = v13;
    if (v16)
    {
      int v17 = sub_100023F78( v14,  0LL,  0x40000000,  *(void *)(v15 + 32LL * *(unsigned int *)(a1 + 16) + 64),  *(void *)(v15 + 32LL * *(unsigned int *)(a1 + 16) + 40),  0x20000000,  8,  0,  a1 + 176LL * (*(_DWORD *)(a1 + 16) & 1) + 24,  a2,  0LL,  0);
      if (v17)
      {
        unsigned int v18 = v17;
        sub_100044E7C((char *)0x47B, v17);
        if ((_DWORD)v12) {
          uint64_t v12 = v12;
        }
        else {
          uint64_t v12 = v18;
        }
      }
    }

    else
    {
      uint64_t v19 = (uint64_t *)calloc(1uLL, *(unsigned int *)(v14[1] + 36));
      *a2 = v19;
      if (v19) {
        BOOL v20 = 0;
      }
      else {
        BOOL v20 = (_DWORD)v12 == 0;
      }
      if (v20) {
        uint64_t v12 = 12LL;
      }
      else {
        uint64_t v12 = v12;
      }
    }

    ++*(_DWORD *)(a1 + 16);
  }

  return v12;
}

uint64_t sub_10000ADC0(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t **a4, _DWORD *a5)
{
  if (!a1) {
    return 22LL;
  }
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(_BYTE *)(a1 + 376) = 0;
  uint64_t v8 = *(void *)(a3 + 64);
  if (v8)
  {
    uint64_t v9 = sub_100023F40(a2, 0LL, 0x40000000, v8, *(void *)(a3 + 40), 0x20000000, 8, 0, a1 + 24);
    if ((_DWORD)v9)
    {
      uint64_t v10 = v9;
      sub_100044E7C((char *)0x47C, v9);
      return v10;
    }
  }

  return sub_10000AC50(a1, a4, a5);
}

char *sub_10000AEA4(uint64_t a1)
{
  qword_100074BE0 = a1;
  if (!sub_100034B44( (uint64_t)&unk_100074BE8,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  8,  48,  0,  0LL,  (uint64_t)sub_10002D39C)) {
    sub_100036C00((uint64_t)&unk_100074BE8, 0LL, 0);
  }
  uint64_t result = (char *)sub_10001A7FC((uint64_t)&unk_100074BE8, (uint64_t)"dstream", (uint64_t)sub_10000AF60);
  if ((_DWORD)result)
  {
    sub_100040C68("failed to register the dstream tree in the fsck memory storage\n", v2, v3, v4, v5, v6, v7, v8, v9);
    return sub_100044E7C((char *)0x583, 12);
  }

  return result;
}

uint64_t sub_10000AF60()
{
  if (qword_100074C20) {
    uint64_t result = sub_100036CD8((uint64_t)&unk_100074BE8, 0LL);
  }
  qword_100074C28 = 0LL;
  return result;
}

uint64_t sub_10000AF94( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100074C28) {
    return 0LL;
  }
  if (qword_100074C28 >= a1)
  {
    if (qword_100074C28 > a1)
    {
      sub_100040B90("dstream (id %llu) is older than the current dstream (id %llu)\n", a2, a3, a4, a5, a6, a7, a8, a1);
      uint64_t v13 = 92LL;
      sub_100044E7C((char *)0x3B8, 92);
      return v13;
    }

    return 0LL;
  }

  uint64_t v15 = qword_100074C28;
  if ((BYTE8(xmmword_100074C50) & 3) != 2)
  {
    if ((BYTE8(xmmword_100074C50) & 4) == 0) {
      goto LABEL_19;
    }
    if (!(_DWORD)xmmword_100074C50 || (_DWORD)xmmword_100074C50 != DWORD1(xmmword_100074C50)) {
      goto LABEL_19;
    }
  }

  uint64_t v9 = qword_100074C38;
  if (qword_100074C40) {
    BOOL v10 = (BYTE8(xmmword_100074C50) & 0x80) == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10) {
    uint64_t v9 = qword_100074C40;
  }
  if ((BYTE8(xmmword_100074C50) & 0x18) == 0 && qword_100074C48 == v9) {
    uint64_t v12 = sub_100036AC4((uint64_t)dword_100074BE8, 0LL, (uint64_t)&v15, 8LL);
  }
  else {
LABEL_19:
  }
    uint64_t v12 = sub_1000364F0(dword_100074BE8, 0LL, &v15, 8LL, &unk_100074C30, 48LL);
  uint64_t v13 = v12;
  if (!(_DWORD)v12) {
    qword_100074C28 = 0LL;
  }
  return v13;
}

uint64_t sub_10000B0AC( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100074C20) {
    return 0LL;
  }
  int v8 = a6;
  int v9 = a5;
  int v10 = a4;
  unint64_t v11 = a3;
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v46 = v14;
  __int128 v47 = v14;
  __int128 v45 = v14;
  uint64_t v15 = sub_10000AF94(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)v15)
  {
    uint64_t v15 = sub_10000B31C(a2, &v45);
    if (!(_DWORD)v15)
    {
      if ((BYTE8(v47) & 3) == 1) {
        int v16 = v10;
      }
      else {
        int v16 = 0;
      }
      if ((BYTE8(v47) & 3) != 0 && !v16)
      {
        uint64_t v43 = sub_10000C6F4((uint64_t)&v45, a2, a1);
        sub_100040B90("found cloned xattr dstream (id %llu, object-ids %s)\n", v17, v18, v19, v20, v21, v22, v23, a2);
        free(v43);
        uint64_t v15 = 92LL;
        uint64_t v24 = 851LL;
LABEL_22:
        sub_100044E7C((char *)v24, 92);
        return v15;
      }

      if (v10) {
        __int16 v25 = 1;
      }
      else {
        __int16 v25 = 2;
      }
      int v26 = v9 | ((BYTE8(v47) & 0x20) >> 5);
      if (v26) {
        __int16 v27 = 32;
      }
      else {
        __int16 v27 = 0;
      }
      else {
        __int16 v28 = 0;
      }
      __int16 v29 = WORD4(v47) & 0xFF9C | v25 | v28 | v27;
      WORD4(v47) = v29;
      if (v26 && DWORD1(v47))
      {
        uint64_t v44 = sub_10000C6F4((uint64_t)&v45, a2, a1);
        sub_100040B90( "cloned dstream (id %llu, object-ids %s) is being truncated\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  a2);
        free(v44);
        uint64_t v15 = 92LL;
        uint64_t v24 = 807LL;
        goto LABEL_22;
      }

      if (DWORD1(v47))
      {
        unint64_t v37 = *((void *)&v45 + 1);
        if (*((void *)&v45 + 1) != v11)
        {
          if (*((void *)&v45 + 1) > v11)
          {
            *((void *)&v45 + 1) = v11;
            unint64_t v37 = v11;
          }

          v29 |= 0x10u;
          WORD4(v47) = v29;
          unint64_t v11 = v37;
        }
      }

      else
      {
        *(void *)&__int128 v45 = a1;
        *((void *)&v45 + 1) = v11;
      }

      if (((int v38 = DWORD1(v47) + 1, ++DWORD1(v47), v48 = a2, (v29 & 3) == 2)
         || (v29 & 4) != 0 && (_DWORD)v47 && (_DWORD)v47 == v38)
        && ((void)v46 ? (BOOL v39 = (v29 & 0x80) == 0) : (BOOL v39 = 1),
            !v39 ? (unint64_t v40 = v46) : (unint64_t v40 = v11),
            (v29 & 0x18) == 0 && *((void *)&v46 + 1) == v40))
      {
        uint64_t v41 = sub_100036AC4((uint64_t)dword_100074BE8, 0LL, (uint64_t)&v48, 8LL);
      }

      else
      {
        uint64_t v41 = sub_1000364F0(dword_100074BE8, 0LL, &v48, 8LL, &v45, 48LL);
      }

      uint64_t v15 = v41;
      if (!(_DWORD)v41)
      {
        if (a2 == a1)
        {
          uint64_t v15 = 0LL;
          qword_100074C28 = a2;
          unk_100074C30 = v45;
          *(_OWORD *)&qword_100074C40 = v46;
          xmmword_100074C50 = v47;
          return v15;
        }

        return 0LL;
      }
    }
  }

  return v15;
}

uint64_t sub_10000B31C(uint64_t a1, _OWORD *a2)
{
  uint64_t v6 = a1;
  unsigned int v4 = 48;
  unsigned int v5 = 8;
  uint64_t result = sub_100034BB4((uint64_t)dword_100074BE8, 0LL, 0LL, &v6, &v5, 8u, a2, &v4);
  if ((_DWORD)result == 2)
  {
    *a2 = xmmword_10006B120;
    *((void *)a2 + 3) = 0LL;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *((_WORD *)a2 + 20) &= 0xFE00u;
    return sub_1000364F0(dword_100074BE8, 0LL, &v6, 8LL, a2, 48LL);
  }

  return result;
}

uint64_t sub_10000B3C0( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = 8;
  return sub_10000B3F8(a1, 15LL, 0LL, a2, &v9, 1LL, a7, a8);
}

uint64_t sub_10000B3F8( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&__int128 var8 = a4;
  if (a1) {
    return sub_1000251C0(a1, 8u, 1, a2, a3, &var8, 8u, a5, a6);
  }
  else {
    return sub_100024E94(0LL, a2, a3, a4, (uint64_t)a5, a6, a7, a8);
  }
}

uint64_t sub_10000B44C(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = a1;
  if (!qword_100074C20) {
    return 0LL;
  }
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v8 = v3;
  __int128 v9 = v3;
  __int128 v7 = v3;
  if (qword_100074C28 == a1)
  {
    uint64_t result = 0LL;
    qword_100074C40 = a2;
  }

  else
  {
    unsigned int v5 = 48;
    unsigned int v6 = 8;
    LODWORD(result) = sub_100034BB4((uint64_t)dword_100074BE8, 0LL, 0LL, &v10, &v6, 8u, &v7, &v5);
    if ((_DWORD)result)
    {
      if ((_DWORD)result == 2) {
        return 0LL;
      }
      else {
        return result;
      }
    }

    else
    {
      *(void *)&__int128 v8 = a2;
      return sub_1000364F0(dword_100074BE8, 0LL, &v10, 8LL, &v7, 48LL);
    }
  }

  return result;
}

void sub_10000B51C( void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_100074C20)
  {
    sub_10000B578(*a1 & 0xFFFFFFFFFFFFFFFLL, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    if (!v9)
    {
      WORD4(xmmword_100074C50) |= 4u;
      LODWORD(xmmword_100074C50) = *a2;
    }
  }

double sub_10000B578( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!sub_10000AF94(a1, a2, a3, a4, a5, a6, a7, a8) && !qword_100074C28)
  {
    *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v12 = v10;
    __int128 v13 = v10;
    __int128 v11 = v10;
    if (!sub_10000B31C(a1, &v11))
    {
      qword_100074C28 = a1;
      unk_100074C30 = v11;
      *(_OWORD *)&qword_100074C40 = v12;
      double result = *(double *)&v13;
      xmmword_100074C50 = v13;
    }
  }

  return result;
}

void sub_10000B5F0( void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_100074C20)
  {
    sub_10000B578(*a1 & 0xFFFFFFFFFFFFFFFLL, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    if (!v10)
    {
      uint64_t v11 = *a2 & 0xFFFFFFFFFFFFFFLL;
      if (v11)
      {
        uint64_t v12 = a1[1];
        if (v12 != qword_100074C48)
        {
          WORD4(xmmword_100074C50) |= 8u;
          uint64_t v12 = a1[1];
        }

        qword_100074C48 = v12 + v11;
      }

      else
      {
        WORD4(xmmword_100074C50) |= 8u;
      }
    }
  }

uint64_t sub_10000B68C( uint64_t a1, void *a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100074C20) {
    return 0LL;
  }
  sub_10000B578(*a2 & 0xFFFFFFFFFFFFFFFLL, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v19 = v18;
  if (!(_DWORD)v18)
  {
    unint64_t v20 = a2[1] & 0xFFFFFFFFFFFFFFLL;
    int v21 = (unsigned __int16)*a3;
    int v22 = *(_DWORD *)(*(void *)(a1 + 8) + 36LL);
    unint64_t v23 = qword_100074C40;
    if (!qword_100074C40) {
      unint64_t v23 = qword_100074C38;
    }
    WORD4(xmmword_100074C50) |= 0x80u;
    if (v20 >= v23)
    {
      sub_100040B90( "data_hash: object (oid 0x%llx): Found unexpected hash at offset %llu (expected length %llu)\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  qword_100074C28);
      uint64_t v19 = 92LL;
      uint64_t v24 = 929LL;
    }

    else if (*a3)
    {
      if (v20 == qword_100074C48)
      {
        uint64_t v19 = 0LL;
        qword_100074C48 = v20 + (v22 * v21);
        return v19;
      }

      sub_100040B90( "data_hash: object (oid 0x%llx): Missing hash at offset %llu (found %llu)\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  qword_100074C28);
      uint64_t v19 = 92LL;
      uint64_t v24 = 931LL;
    }

    else
    {
      sub_100040B90( "data_hash: object (oid 0x%llx): Invalid length at offset %llu\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  qword_100074C28);
      uint64_t v19 = 92LL;
      uint64_t v24 = 930LL;
    }

    sub_100044E7C((char *)v24, 92);
  }

  return v19;
}

uint64_t sub_10000B7CC( void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100074C20) {
    return 0LL;
  }
  uint64_t result = sub_10000AF94(*a1 & 0xFFFFFFFFFFFFFFFLL, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v15 = v10;
    __int128 v16 = v10;
    __int128 v14 = v10;
    uint64_t result = sub_10000B31C(*a2, &v14);
    if (!(_DWORD)result)
    {
      char v11 = BYTE8(v16);
      WORD4(v16) |= 0x100u;
      uint64_t v17 = *a2;
      if (((v11 & 3) == 2 || (v11 & 4) != 0 && (_DWORD)v16 && (_DWORD)v16 == DWORD1(v16))
        && ((void)v15 ? (BOOL v12 = (v11 & 0x80) == 0) : (BOOL v12 = 1),
            !v12 ? (uint64_t v13 = v15) : (uint64_t v13 = *((void *)&v14 + 1)),
            (v11 & 0x18) == 0 && *((void *)&v15 + 1) == v13))
      {
        return sub_100036AC4((uint64_t)dword_100074BE8, 0LL, (uint64_t)&v17, 8LL);
      }

      else
      {
        return sub_1000364F0(dword_100074BE8, 0LL, &v17, 8LL, &v14, 48LL);
      }
    }
  }

  return result;
}

uint64_t sub_10000B8D0(void *a1)
{
  if (!qword_100074C20) {
    return 0LL;
  }
  *(void *)&__int128 v1 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v1;
  __int128 v8 = v1;
  v7[0] = v1;
  uint64_t v9 = *a1 & 0xFFFFFFFFFFFFFFFLL;
  if (qword_100074C28 == v9)
  {
    unsigned int v2 = WORD4(xmmword_100074C50);
  }

  else
  {
    unsigned int v5 = 48;
    unsigned int v6 = 8;
    int v4 = sub_100034BB4((uint64_t)&unk_100074BE8, 0LL, 0LL, &v9, &v6, 8u, v7, &v5);
    uint64_t result = 0LL;
    if (v4) {
      return result;
    }
    unsigned int v2 = WORD4(v8);
  }

  return (v2 >> 6) & 1;
}

uint64_t sub_10000B978( uint64_t *a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100074C20) {
    return 0LL;
  }
  uint64_t v119 = 0LL;
  __int128 v117 = 0u;
  __int128 v118 = 0u;
  __int128 v116 = 0u;
  uint64_t v11 = *(void *)(a2 + 48);
  if (!v11) {
    uint64_t v11 = *(void *)(a2 + 40);
  }
  uint64_t v12 = *(void *)(v11 + 56);
  char v115 = 1;
  if ((v12 & 0x20) == 0
    || (uint64_t v13 = sub_100047038(a1, a2, qword_100074BE0, (BOOL *)&v115, 0LL, 0LL, 0LL, 0), !(_DWORD)v13))
  {
    uint64_t v13 = sub_10000AF94(0xFFFFFFFFFFFFFFFFLL, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)v13)
    {
      unsigned int v113 = 48;
      unsigned int v114 = 8;
      unsigned int v14 = sub_100034BB4((uint64_t)dword_100074BE8, 0LL, 1LL, &v119, &v114, 8u, &v116, &v113);
      if (v14)
      {
LABEL_8:
        if (v14 == 2) {
          uint64_t v13 = 0LL;
        }
        else {
          uint64_t v13 = v14;
        }
        goto LABEL_11;
      }

      while (1)
      {
        if (!DWORD1(v118))
        {
          if ((BYTE8(v118) & 4) != 0)
          {
            sub_100040C68( "found orphan dstream id object (id %llu, refcnt %u)\n",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v119);
            sub_100044E7C((char *)0x256, -2);
            uint64_t v32 = sub_10000C13C(a3, 0LL, 0LL, 0LL, v119, 0LL, v33, v34);
            if ((_DWORD)v32) {
              goto LABEL_93;
            }
          }

          if (*((void *)&v117 + 1))
          {
            uint64_t v35 = "sealed volume hash records";
            if ((BYTE8(v118) & 0x80) == 0) {
              uint64_t v35 = "file extents";
            }
            sub_100040C68("found orphan %s (id %llu, size %llu)\n", v15, v16, v17, v18, v19, v20, v21, (char)v35);
            sub_100044E7C((char *)0x257, -2);
            if ((v12 & 0x20) == 0)
            {
              uint64_t v32 = sub_10000C194((uint64_t)a1, (void *)a2, a3, v119, (uint64_t)&v116, 0);
              if ((_DWORD)v32)
              {
LABEL_93:
                uint64_t v13 = v32;
                break;
              }
            }
          }

          goto LABEL_75;
        }

        if ((BYTE8(v118) & 3) == 1)
        {
          if ((BYTE8(v118) & 4) == 0)
          {
            v120[0] = 0xAAAAAAAAAAAAAAAALL;
            v128[0] = v119 & 0xFFFFFFFFFFFFFFFLL | 0x6000000000000000LL;
            LODWORD(v125) = 0;
            unsigned int v126 = 4;
            unsigned int v127 = 8;
            uint64_t v13 = sub_10003AB6C((uint64_t)a1, (void *)a2, 6, v120, v18, v19, v20, v21);
            if (!(_DWORD)v13) {
              uint64_t v13 = sub_100034BB4(v120[0], qword_100074BE0, 0LL, v128, &v127, v127, &v125, &v126);
            }
            if ((_DWORD)v13 != 2)
            {
              if ((_DWORD)v13)
              {
                char v101 = v119;
                strerror(v13);
                sub_100040B90( "failed to look up dstream id object (id %llu): %s\n",  v102,  v103,  v104,  v105,  v106,  v107,  v108,  v101);
                sub_100044E7C((char *)0x3EF, v13);
                break;
              }

              sub_100040B90( "refcnt (%u) of dstream id object (id %llu) is less than expected (%u)\n",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v125);
              sub_100044E7C((char *)0x358, 92);
              LODWORD(v125) = v125 + DWORD1(v118);
              uint64_t v32 = sub_10000C13C(a3, 1LL, 9LL, 1LL, v119, v125, v30, v31);
              if ((_DWORD)v32) {
                goto LABEL_93;
              }
              WORD4(v118) &= ~0x10u;
              goto LABEL_38;
            }

            sub_100040B90( "dstream (id %llu) does not have an associated dstream id object\n",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v119);
            sub_100044E7C((char *)0x251, 92);
            uint64_t v38 = v119;
            uint64_t v39 = DWORD1(v118);
            unint64_t v40 = a3;
            uint64_t v41 = 2LL;
            uint64_t v42 = 0LL;
            goto LABEL_36;
          }

          if (v118 < DWORD1(v118))
          {
            sub_100040B90( "refcnt (%u) of dstream id object (id %llu) is less than expected (%u)\n",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v118);
            sub_100044E7C((char *)0x2C3, 92);
            uint64_t v38 = v119;
            uint64_t v39 = DWORD1(v118);
            unint64_t v40 = a3;
            uint64_t v41 = 1LL;
            uint64_t v42 = 9LL;
LABEL_36:
            uint64_t v43 = 1LL;
LABEL_37:
            uint64_t v32 = sub_10000C13C(v40, v41, v42, v43, v38, v39, v36, v37);
            if ((_DWORD)v32) {
              goto LABEL_93;
            }
            goto LABEL_38;
          }

          if (v118 > DWORD1(v118))
          {
            sub_100040C68( "refcnt (%u) of dstream id object (id %llu) is greater than expected (%u)\n",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v118);
            sub_100044E7C((char *)0x2A2, -2);
            uint64_t v38 = v119;
            uint64_t v39 = DWORD1(v118);
            unint64_t v40 = a3;
            uint64_t v41 = 1LL;
            uint64_t v42 = 9LL;
            uint64_t v43 = 0LL;
            goto LABEL_37;
          }
        }

LABEL_38:
        if ((void)v117) {
          BOOL v44 = (BYTE8(v118) & 0x80) == 0;
        }
        else {
          BOOL v44 = 1;
        }
        if (v44) {
          uint64_t v45 = *((void *)&v116 + 1);
        }
        else {
          uint64_t v45 = v117;
        }
        if ((BYTE8(v118) & 8) == 0 && *((void *)&v117 + 1) == v45)
        {
          if ((BYTE8(v118) & 0x10) == 0) {
            goto LABEL_75;
          }
LABEL_63:
          uint64_t v55 = v119;
          v128[0] = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v125 = 0xAAAAAAAAAAAAAAAALL;
          unsigned __int16 v124 = -21846;
          unsigned int v123 = -1431655766;
          int v56 = calloc(1uLL, 0x340uLL);
          uint64_t v57 = (unsigned __int16 *)calloc(1uLL, 0xEE0uLL);
          uint64_t v58 = calloc(1uLL, 8LL * DWORD1(v118));
          uint64_t v63 = sub_10003AB6C((uint64_t)a1, (void *)a2, 3, v128, v59, v60, v61, v62);
          uint64_t v13 = v63;
          if (v56 && v57 && v58 && !(_DWORD)v63)
          {
            uint64_t v71 = sub_100001E04(v55, (uint64_t)v58, DWORD1(v118), &v123);
            if ((_DWORD)v71)
            {
              uint64_t v13 = v71;
              sub_100040B90("unable to get the file ids of dstream_id %llu\n", v72, v73, v74, v75, v76, v77, v78, v55);
            }

            else
            {
              unsigned int v79 = v123;
              if (v123 > DWORD1(v118))
              {
                unsigned int v123 = DWORD1(v118);
                unsigned int v79 = DWORD1(v118);
              }

              if (v79)
              {
                uint64_t v110 = v12;
                uint64_t v80 = 0LL;
                while (1)
                {
                  *int v56 = v58[v80] & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
                  unsigned int v126 = 3808;
                  unsigned int v127 = 8;
                  uint64_t v81 = sub_100034BB4(v128[0], qword_100074BE0, 0LL, v56, &v127, 0x340u, v57, &v126);
                  if ((_DWORD)v81)
                  {
LABEL_89:
                    uint64_t v13 = v81;
                    goto LABEL_70;
                  }

                  uint64_t v82 = sub_10003B6C4(v57 + 46, v126 - 92, 8, &v125, &v124, 0LL, 0LL);
                  if ((_DWORD)v82)
                  {
                    uint64_t v13 = v82;
                    goto LABEL_92;
                  }

                  if (v124 <= 0x27u) {
                    break;
                  }
                  uint64_t v90 = *(void *)(v125 + 8);
                  if (v90 != *((void *)&v116 + 1))
                  {
                    sub_100040B90( "alloced_size (%llu) of dstream (id %llu, object-id %llu) does not match minimum found size (%llu)\n",  v83,  v84,  v85,  v86,  v87,  v88,  v89,  v90);
                    sub_100044E7C((char *)0x2A0, 92);
                    v120[0] = 0LL;
                    __int128 v121 = 0u;
                    uint64_t v122 = 0LL;
                    v120[1] = *((void *)&v116 + 1);
                    uint64_t v81 = sub_10000B3F8(a3, 13LL, 1LL, *v56, v120, 40LL, v91, v92);
                    if ((_DWORD)v81) {
                      goto LABEL_89;
                    }
                  }

                  if (++v80 >= (unint64_t)v123)
                  {
                    uint64_t v13 = 0LL;
                    goto LABEL_70;
                  }
                }

                uint64_t v13 = 34LL;
LABEL_92:
                uint64_t v93 = *v56 & 0xFFFFFFFFFFFFFFFLL;
                strerror(v13);
                sub_100040B90("failed to get inode (id %llu) dstream: %s\n", v94, v95, v96, v97, v98, v99, v100, v93);
                sub_100044E7C((char *)0x380, v13);
                uint64_t v12 = v110;
              }

              else
              {
                uint64_t v13 = 0LL;
              }
            }

LABEL_71:
            free(v57);
          }

          else
          {
            sub_100040B90("unable to init fsroot tree for dstream repair\n", v64, v65, v66, v67, v68, v69, v70, v109);
            sub_100044E7C((char *)0x355, v13);
LABEL_70:
            if (v57) {
              goto LABEL_71;
            }
          }

          if (v56) {
            free(v56);
          }
          if ((_DWORD)v13) {
            break;
          }
          goto LABEL_75;
        }

        LOBYTE(v120[0]) = 0;
        uint64_t v46 = *(void *)(a2 + 48);
        if (!v46) {
          uint64_t v46 = *(void *)(a2 + 40);
        }
        if ((*(_BYTE *)(v46 + 56) & 0x20) != 0) {
          goto LABEL_55;
        }
        if ((WORD4(v118) & 0x120) == 0)
        {
          if (DWORD1(v118) != 1) {
            goto LABEL_55;
          }
          uint64_t v32 = sub_10003B000((uint64_t)a1, a2, qword_100074BE0, v116, v120);
          if ((_DWORD)v32) {
            goto LABEL_93;
          }
          if (!LOBYTE(v120[0]))
          {
LABEL_55:
            if ((v12 & 0x20) != 0)
            {
              if (v115)
              {
                sub_100040B90( "sealed volume hash records (id %llu, size %llu) do not match size of dstream (%llu)\n",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v119);
                __int128 v47 = sub_100044E7C((char *)0x438, 92);
                if (a3) {
                  *(_BYTE *)(a2 + 13) = 1;
                }
                else {
                  sub_100024E94((uint64_t)v47, v48, v49, v50, v51, v52, v53, v54);
                }
              }
            }

            else
            {
              uint64_t v32 = sub_10000C194((uint64_t)a1, (void *)a2, a3, v119, (uint64_t)&v116, 1u);
              if ((_DWORD)v32) {
                goto LABEL_93;
              }
            }
          }
        }

        if ((BYTE8(v118) & 0x10) != 0) {
          goto LABEL_63;
        }
LABEL_75:
        unsigned int v111 = 48;
        unsigned int v112 = 8;
        unsigned int v14 = sub_100034BB4((uint64_t)dword_100074BE8, 0LL, 2LL, &v119, &v112, 8u, &v116, &v111);
        if (v14) {
          goto LABEL_8;
        }
      }
    }
  }

    uint64_t v173 = *(_OWORD *)(a5 + 10);
    __src = *(_OWORD *)(a5 + 2);
    unint64_t v208 = v173;
    int64_t v209 = *(_OWORD *)(a5 + 18);
    if ((unint64_t)__src <= 1)
    {
      uint64_t v174 = sub_10003A294(*(void *)a3 >> 60);
      sub_100040B90("%s (id %llu): invalid xattr_obj_id (%llu)\n", v175, v176, v177, v178, v179, v180, v181, v174);
      int v22 = 92LL;
      uint64_t v23 = 271LL;
      goto LABEL_20;
    }

    if ((unint64_t)__src <= 0xF && (unint64_t)(__src - 4) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      char v182 = sub_10003A294(*(void *)a3 >> 60);
      sub_100040C68("%s (id %llu): invalid xattr_obj_id (%llu)\n", v183, v184, v185, v186, v187, v188, v189, v182);
      sub_100044E7C((char *)0x110, -2);
    }

    unsigned int v190 = sub_100014C64(a1, a2, (uint64_t *)a3, 0LL, (void *)&__src + 1, (uint64_t)a7, a8);
    if ((_DWORD)v190) {
      goto LABEL_79;
    }
    v201 = *(void *)(a2 + 48);
    v202 = v201;
    if (!v201) {
      v202 = *(void *)(a2 + 40);
    }
    if ((*(_BYTE *)(v202 + 56) & 0x20) != 0)
    {
      int v203 = __src;
      a7[8] = v24;
      a7[9] = v203;
    }

    if (v210)
    {
      if (v201)
      {
LABEL_87:
        if ((*(_BYTE *)(v201 + 56) & 0x20) != 0 || v210 || (sub_100006DB8(v24, (uint64_t)&__src + 8), !(_DWORD)v190))
        {
          if (*a8) {
            memcpy(a5 + 2, &__src, a5[1]);
          }
          return 0LL;
        }

LABEL_11:
  sub_100036CD8((uint64_t)dword_100074BE8, 0LL);
  return v13;
}

      if (!v14) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }

    uint64_t v98 = 0LL;
    __int128 v47 = 0LL;
    uint64_t v48 = v101;
    while (1)
    {
      if (*v13 != v28) {
        goto LABEL_18;
      }
      uint64_t v64 = a3;
      uint64_t v65 = v13[1];
      uint64_t v66 = *v14 & 0xFFFFFFFFFFFFFFLL;
      if (v66)
      {
        if (v65 > v47 && v65 < v48)
        {
          sub_100040B90( "found file extent gap (id %llu) at logical address %llu (expected %llu)\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  a4);
          sub_100044E7C((char *)0x255, 92);
          uint64_t v69 = v13[1];
          *(void *)&uint64_t v105 = *v13;
          *((void *)&v105 + 1) = v47;
          memset(v104, 0, sizeof(v104));
          uint64_t v76 = sub_10000C9EC((uint64_t)v104, v69 - v47, v70, v71, v72, v73, v74, v75);
          if ((_DWORD)v76)
          {
LABEL_67:
            uint64_t v27 = v76;
            goto LABEL_12;
          }

          sub_10000C8C4(a1, v100, v64, 2LL, 0LL, v99, (uint64_t *)&v105, (uint64_t)v104, 0LL, 0);
          goto LABEL_58;
        }

        if (v65 >= v47 || v65 >= v48)
        {
          if (v65 < v48) {
            goto LABEL_59;
          }
          if (*(_DWORD *)(a5 + 36)) {
            sub_100040B90( "found file extent (id %llu) at logical address %llu beyond the end of the dstream %llu\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  a4);
          }
          else {
            sub_100040C68( "found orphan file extent (id %llu) at logical address %llu\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  a4);
          }
          a3 = v64;
          sub_100044E7C((char *)0x37F, 92);
          uint64_t v85 = a1;
          uint64_t v86 = v100;
        }

        else
        {
          sub_100040B90( "found file extent overlap (id %llu) at logical address %llu (expected %llu)\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  a4);
          sub_100044E7C((char *)0x354, 92);
          uint64_t v105 = *(_OWORD *)v13;
          memset(v104, 170, sizeof(v104));
          uint64_t v102 = 24;
          uint64_t v103 = 16;
          uint64_t v77 = sub_100034BB4(v112, qword_100074BE0, 2LL, &v105, &v103, 0x10u, v104, &v102);
          if (v77 || v103 != 16)
          {
            uint64_t v84 = *((void *)&v107 + 1);
LABEL_56:
            uint64_t v87 = *(void *)&v106[0];
            uint64_t v76 = sub_10000C9EC((uint64_t)v106, v13[1] - v84, v78, v79, v80, v81, v82, v83);
            if ((_DWORD)v76) {
              goto LABEL_67;
            }
            sub_10000C8C4( a1,  v100,  v64,  1LL,  10LL,  v99,  (uint64_t *)&v107,  (uint64_t)v106,  v87 & 0xFFFFFFFFFFFFFFLL,  (*(_WORD *)(a5 + 40) & 0x40) != 0);
LABEL_58:
            if ((_DWORD)v76) {
              goto LABEL_67;
            }
LABEL_59:
            __int128 v47 = v13[1] + v66;
            uint64_t v107 = *(_OWORD *)v13;
            v106[0] = *(_OWORD *)v14;
            *(void *)&v106[1] = v14[2];
            uint64_t v98 = v66;
            a3 = v64;
            goto LABEL_64;
          }

          uint64_t v84 = *((void *)&v107 + 1);
          if ((void)v105 != *v13 || *((void *)&v105 + 1) - *((void *)&v107 + 1) != v98) {
            goto LABEL_56;
          }
          uint64_t v85 = a1;
          uint64_t v86 = v100;
          a3 = v64;
        }

        sub_10000C8C4(v85, v86, v64, 0LL, 0LL, v99, v13, (uint64_t)v14, 0LL, 0);
      }

      else
      {
        sub_100040B90( "invalid zero-length extent (id %llu) at logical address %llu\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  a4);
        sub_100044E7C((char *)0x31A, 92);
        a3 = v64;
        sub_10000C8C4(a1, v100, v64, 0LL, 0LL, 1LL, v13, (uint64_t)v14, 0LL, 0);
      }

      if ((_DWORD)v76) {
        goto LABEL_67;
      }
LABEL_64:
      uint64_t v88 = (*((uint64_t (**)(_OWORD *))&v108[0] + 1))(v108);
      if ((_DWORD)v88)
      {
        uint64_t v27 = v88;
        uint64_t v89 = strerror(v88);
        sub_100040B90("error iterating fsroot tree during dstream repair: %s\n", v90, v91, v92, v93, v94, v95, v96, v89);
        uint64_t v45 = 796LL;
        goto LABEL_10;
      }

      uint64_t v48 = v101;
      if (BYTE8(v109)) {
        goto LABEL_18;
      }
    }
  }

  uint64_t v27 = v29;
  uint64_t v37 = strerror(v29);
  sub_100040B90("unable to init fsroot tree iterator for dstream repair: %s\n", v38, v39, v40, v41, v42, v43, v44, v37);
LABEL_12:
  free(v14);
LABEL_13:
  if (v13) {
    free(v13);
  }
  return v27;
}

uint64_t sub_10000C13C( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return sub_100024E94(0LL, a2, a3, a4, a5, a6, a7, a8);
  }
  *(void *)&__int128 var8 = a5 & 0xFFFFFFFFFFFFFFFLL | 0x6000000000000000LL;
  return sub_1000251C0(a1, 8u, a2, a3, a4, &var8, 8u, &v9, 4u);
}

uint64_t sub_10000C194(uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  *(void *)&__int128 v107 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v107 + 1) = 0xAAAAAAAAAAAAAAAALL;
  memset(v106, 170, 24);
  if (*(_DWORD *)(a5 + 36)) {
    unint64_t v101 = *(void *)(a5 + 8);
  }
  else {
    unint64_t v101 = 0LL;
  }
  uint64_t v112 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v108[0] = v12;
  v108[1] = v12;
  __int128 v109 = v12;
  __int128 v110 = v12;
  unint64_t v111 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = calloc(1uLL, 0x340uLL);
  unsigned int v14 = calloc(1uLL, 0xEE0uLL);
  uint64_t v19 = sub_10003AB6C(a1, a2, 8, &v112, v15, v16, v17, v18);
  uint64_t v27 = v19;
  if (!v13 || !v14 || (_DWORD)v19)
  {
    sub_100040B90("unable to init fsroot tree for dstream repair\n", v20, v21, v22, v23, v24, v25, v26, v97);
    uint64_t v45 = 795LL;
LABEL_10:
    sub_100044E7C((char *)v45, v27);
    goto LABEL_11;
  }

  uint64_t v100 = (uint64_t)a2;
  unint64_t v28 = a4 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000LL;
  *uint64_t v13 = v28;
  v13[1] = 0LL;
  uint64_t v29 = sub_100035394((uint64_t)v108, v112, qword_100074BE0, v13, 0x10u, 0x340u, v14, 3808);
  if (!(_DWORD)v29)
  {
    unsigned int v99 = a6;
    if (BYTE8(v109))
    {
      unint64_t v47 = 0LL;
      unint64_t v48 = v101;
LABEL_18:
      if (v48 != v47) {
        sub_100040B90( "alloced_size (%llu) of dstream (id %llu) does not match calculated size (%llu)\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v48);
      }
      if (v48 < v47)
      {
        sub_100044E7C((char *)0x3E3, 92);
        uint64_t v49 = *(void *)&v106[0];
        uint64_t v27 = sub_10000C9EC((uint64_t)v106, v48 - *((void *)&v107 + 1), v50, v51, v52, v53, v54, v55);
        if ((_DWORD)v27) {
          goto LABEL_11;
        }
        sub_10000C8C4( a1,  v100,  a3,  1LL,  10LL,  v99,  (uint64_t *)&v107,  (uint64_t)v106,  v49 & 0xFFFFFFFFFFFFFFLL,  (*(_WORD *)(a5 + 40) & 0x40) != 0);
        goto LABEL_30;
      }

      if (v48 <= v47)
      {
        uint64_t v27 = 0LL;
        goto LABEL_11;
      }

      if (v47) {
        uint64_t v57 = 997LL;
      }
      else {
        uint64_t v57 = 996LL;
      }
      sub_100044E7C((char *)v57, 92);
      *(void *)&__int128 v105 = a4 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000LL;
      *((void *)&v105 + 1) = v47;
      memset(v104, 0, sizeof(v104));
      uint64_t v27 = sub_10000C9EC((uint64_t)v104, v48 - v47, v58, v59, v60, v61, v62, v63);
      if (!(_DWORD)v27)
      {
        sub_10000C8C4(a1, v100, a3, 2LL, 0LL, v99, (uint64_t *)&v105, (uint64_t)v104, 0LL, 0);
LABEL_30:
        uint64_t v27 = v56;
      }

char *sub_10000C6F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = *(_DWORD *)(a1 + 36);
  unsigned int v24 = v6;
  __int128 v7 = malloc(8LL * (v6 + 1));
  if (!v7) {
    return 0LL;
  }
  __int128 v8 = v7;
  if (!v6)
  {
LABEL_26:
    uint64_t v16 = (char *)malloc(1uLL);
LABEL_27:
    free(v8);
    return v16;
  }

  if (v6 == 1)
  {
    *__int128 v7 = *(void *)a1;
    v7[1] = a3;
    uint64_t v9 = 1LL;
LABEL_5:
    uint64_t v10 = 0LL;
    int64_t v11 = 1LL;
    do
    {
      unint64_t v12 = *((void *)v8 + v10);
      int v13 = 1;
      if (v12 >= 0x3E8)
      {
        unint64_t v14 = *((void *)v8 + v10);
        do
        {
          unint64_t v12 = v14 / 0x3E8;
          v13 += 3;
          BOOL v15 = v14 > 0xF423F;
          v14 /= 0x3E8uLL;
        }

        while (v15);
      }

      if (v12 >= 0xA)
      {
        do
        {
          ++v13;
          BOOL v15 = v12 > 0x63;
          v12 /= 0xAuLL;
        }

        while (v15);
      }

      v11 += v13 + 1;
      ++v10;
    }

    while (v10 != v9);
    uint64_t v16 = (char *)malloc(v11);
    if (v16)
    {
      int64_t v17 = 0LL;
      uint64_t v18 = (uint64_t *)v8;
      while (1)
      {
        uint64_t v19 = *v18++;
        unsigned int v20 = snprintf(&v16[v17], v11 - v17, "%llu ", v19);
        if ((v20 & 0x80000000) != 0) {
          break;
        }
        v17 += v20;
        if (v17 >= v11) {
          break;
        }
        if (!--v9) {
          goto LABEL_27;
        }
      }

      free(v16);
      uint64_t v16 = 0LL;
    }

    goto LABEL_27;
  }

  if (!sub_100001E04(a2, (uint64_t)v7, v6, &v24))
  {
    unsigned int v21 = v24;
    unsigned int v22 = *(_DWORD *)(a1 + 36);
    if (v24 > v22)
    {
      unsigned int v24 = *(_DWORD *)(a1 + 36);
      unsigned int v21 = v22;
    }

    *((void *)v8 + v21) = a3;
    if (v21)
    {
      uint64_t v9 = v21;
      goto LABEL_5;
    }

    goto LABEL_26;
  }

  free(v8);
  return 0LL;
}

void sub_10000C8C4( uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, unint64_t a9, char a10)
{
  if (a3)
  {
    int v12 = a5;
    int v13 = a4;
    if (!sub_1000251C0(a3, 8u, a4, a5, a6, (__int128 *)a7, 0x10u, (_BYTE *)a8, 0x18u))
    {
      unint64_t v16 = *(void *)(a8 + 8);
      if (v16)
      {
        if (v13)
        {
          if (v13 == 1
            && v12 == 10
            && !sub_10001E878(a2, v16, a9 / *(unsigned int *)(*(void *)(a1 + 8) + 36LL)))
          {
            sub_10001E48C( a2,  *(void *)(a8 + 8),  (*(void *)a8 & 0xFFFFFFFFFFFFFFuLL) / *(unsigned int *)(*(void *)(a1 + 8) + 36LL),  *a7 & 0xFFFFFFFFFFFFFFFLL,  a10);
          }
        }

        else
        {
          sub_100006EEC(a7, a8);
          if (!v17) {
            sub_10001E878( a2,  *(void *)(a8 + 8),  (*(void *)a8 & 0xFFFFFFFFFFFFFFuLL) / *(unsigned int *)(*(void *)(a1 + 8) + 36LL));
          }
        }
      }
    }
  }

  else
  {
    sub_100024E94(a1, a2, 0LL, a4, a5, a6, (uint64_t)a7, a8);
  }

uint64_t sub_10000C9EC( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (HIBYTE(a2))
  {
    sub_100040B90( "file extent length %llu does not fit inside %u bits, refusing to repair\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a2);
    uint64_t v8 = 92LL;
    sub_100044E7C((char *)0x37E, 92);
  }

  else
  {
    uint64_t v8 = 0LL;
    *(void *)a1 = a2 | ((unint64_t)*(unsigned __int8 *)(a1 + 7) << 56);
  }

  return v8;
}

uint64_t sub_10000CA50(uint64_t result)
{
  uint64_t v1 = 0LL;
  uint64_t v2 = 0LL;
  char v3 = 1;
  do
  {
    char v4 = v3;
    if (result)
    {
      uint64_t v5 = result + 48 * v1;
      unint64_t v6 = *(void *)(v5 + 48);
      unint64_t v7 = *(void *)(v5 + 72);
      if (v6 > v7) {
        uint64_t v2 = v6 + v2 - v7;
      }
    }

    char v3 = 0;
    uint64_t v1 = 1LL;
  }

  while ((v4 & 1) != 0);
  byte_100074C60 = 0;
  qword_100074C70 = v2;
  return result;
}

uint64_t sub_10000CAA4(uint64_t result)
{
  if (result) {
    uint64_t v1 = *(void *)(result + 88);
  }
  else {
    uint64_t v1 = 0LL;
  }
  byte_100074C60 = 1;
  qword_100074C70 = v1;
  return result;
}

uint64_t sub_10000CACC( uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (byte_100074C60 != 1 || a2 != 0)
  {
    uint64_t v9 = qword_100074C68 + result;
    qword_100074C68 += result;
    if (qword_100074C70)
    {
      unint64_t v10 = 100 * v9 / (unint64_t)qword_100074C70;
      if (dword_100074C78 < (int)v10 && (int)v10 <= 100)
      {
        uint64_t result = sub_1000432C4(qword_10008DB70, 119, a3, a4, a5, a6, a7, a8, v10);
        dword_100074C78 = v10;
      }
    }
  }

  return result;
}

uint64_t sub_10000CB60( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = (uint64_t *)(a2 + 72);
  if (!a2) {
    unint64_t v10 = a1 + 4;
  }
  uint64_t v11 = *v10;
  int v12 = (unint64_t *)(a2 + 104);
  int v13 = (unsigned int *)(a2 + 112);
  if (!a2)
  {
    int v13 = (unsigned int *)(a1 + 15);
    int v12 = (unint64_t *)(a1 + 14);
  }

  unint64_t v14 = *v12;
  unsigned int v15 = *v13;
  uint64_t v16 = *(void *)(v11 + 8);
  unsigned int v17 = *(_DWORD *)(v11 + 32);
  if (v17 >= 0x40)
  {
    sub_100040C68("omap (oid 0x%llx): invalid om_flags (0x%x)\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(v11 + 8));
    sub_100044E7C((char *)0x16C, -3);
    unsigned int v17 = *(_DWORD *)(v11 + 32);
  }

  if ((v17 & 1) != 0 && *(_DWORD *)(v11 + 36))
  {
    sub_100040B90( "omap (oid 0x%llx): invalid om_snap_count (%u), given om_flags (0x%x)\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v16);
    uint64_t v18 = 92LL;
    uint64_t v19 = 365LL;
LABEL_35:
    sub_100044E7C((char *)v19, 92);
    return v18;
  }

  int v20 = *(_DWORD *)(v11 + 40);
  if ((unsigned __int16)v20 != 2
    || ((unsigned int v21 = v20 & 0xC0000000, (v20 & 0xC0000000) != 0x80000000) ? (v22 = v21 == 0) : (v22 = 1),
        !v22 ? (BOOL v23 = v21 == 0x40000000) : (BOOL v23 = 1),
        !v23))
  {
    sub_100040B90("omap (oid 0x%llx): invalid om_tree_type (0x%x)\n", a2, a3, a4, a5, a6, a7, a8, v16);
    uint64_t v18 = 92LL;
    uint64_t v19 = 366LL;
    goto LABEL_35;
  }

  int v24 = *(_DWORD *)(v11 + 44);
  if ((unsigned __int16)v24 != 2
    || ((unsigned int v25 = v24 & 0xC0000000, (v24 & 0xC0000000) != 0x80000000) ? (v26 = v25 == 0) : (v26 = 1),
        !v26 ? (BOOL v27 = v25 == 0x40000000) : (BOOL v27 = 1),
        !v27))
  {
    sub_100040B90("omap (oid 0x%llx): invalid om_snapshot_tree_type (0x%x)\n", a2, a3, a4, a5, a6, a7, a8, v16);
    uint64_t v18 = 92LL;
    uint64_t v19 = 367LL;
    goto LABEL_35;
  }

  uint64_t v37 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v18 = sub_100029B94(a1, a2, &v37);
  if (!(_DWORD)v18)
  {
    uint64_t v18 = sub_100031CD0( v37,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10000CE04,  0LL,  0LL,  1);
    if (!(_DWORD)v18)
    {
      if ((*(_DWORD *)(v11 + 32) & 1) != 0)
      {
        if (*(void *)(v11 + 56))
        {
          sub_100040B90( "omap (oid 0x%llx): invalid om_snapshot_tree_oid (0x%llx), given om_flags (0x%x)\n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v16);
          uint64_t v18 = 92LL;
          uint64_t v19 = 368LL;
          goto LABEL_35;
        }

        if (*(void *)(v11 + 64))
        {
          sub_100040B90( "omap (oid 0x%llx): invalid om_most_recent_snap (0x%llx), given om_flags (0x%x)\n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v16);
          uint64_t v18 = 92LL;
          uint64_t v19 = 369LL;
          goto LABEL_35;
        }

        if (*(void *)(v11 + 72))
        {
          sub_100040B90( "omap (oid 0x%llx): invalid om_pending_revert_min (0x%llx), given om_flags (0x%x)\n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v16);
          uint64_t v18 = 92LL;
          uint64_t v19 = 370LL;
          goto LABEL_35;
        }

        if (*(void *)(v11 + 80))
        {
          sub_100040B90( "omap (oid 0x%llx): invalid om_pending_revert_max (0x%llx), given om_flags (0x%x)\n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v16);
          uint64_t v18 = 92LL;
          uint64_t v19 = 371LL;
          goto LABEL_35;
        }
      }

      if (a2) {
        unint64_t v35 = *(void *)(*(void *)(a2 + 40) + 8LL);
      }
      else {
        unint64_t v35 = 0LL;
      }
      sub_10003D570( (uint64_t)a1,  v14,  v15 / *(_DWORD *)(a1[1] + 36),  v35,  0x40000000,  v16,  0LL,  0xBu,  &_mh_execute_header,  (unint64_t)&_mh_execute_header >> 32);
      return 0LL;
    }
  }

  return v18;
}

uint64_t sub_10000CE04( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v9 = *(void *)(a1 + 8);
  if ((unint64_t)a3[1] > *(void *)(v9 + 16))
  {
    sub_100040B90( "omap entry (oid 0x%llx): invalid ok_xid (0x%llx)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  *a3);
    uint64_t v10 = 92LL;
    uint64_t v11 = 359LL;
LABEL_18:
    sub_100044E7C((char *)v11, 92);
    return v10;
  }

  if (!a5) {
    return 0LL;
  }
  unsigned int v16 = *(_DWORD *)(v9 + 36);
  unsigned int v17 = *(_DWORD *)a5;
  if (*(_DWORD *)a5 >= 0x800u)
  {
    sub_100040C68( "omap entry (oid 0x%llx): invalid ov_flags (0x%x)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  *a3);
    sub_100044E7C((char *)0x168, -3);
    unsigned int v17 = *(_DWORD *)a5;
  }

  unsigned int v18 = v17 >> 5;
  if (v18 >= 2)
  {
    sub_100040B90( "omap entry (oid 0x%llx): invalid crypto key index (%u) given ov_flags (0x%x)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  *a3);
    uint64_t v10 = 92LL;
    uint64_t v11 = 1151LL;
    goto LABEL_18;
  }

  if (v18 != 1 || a2 && *(void *)(*(void *)(a2 + 40) + 1096LL))
  {
LABEL_13:
    if (((v17 >> 8) & 7) >= 2)
    {
      sub_100040B90( "omap entry (oid 0x%llx): invalid tweak type (%u) given ov_flags (0x%x)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  *a3);
      uint64_t v10 = 92LL;
      uint64_t v11 = 1231LL;
      goto LABEL_18;
    }

    unsigned int v25 = *(_DWORD *)(a5 + 4);
    if (!v25 || (uint64_t v26 = v25 / v16, v25 % v16))
    {
      sub_100040B90( "omap entry (oid 0x%llx): invalid ov_size (%u)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  *a3);
      uint64_t v10 = 92LL;
      uint64_t v11 = 361LL;
      goto LABEL_18;
    }

    if ((v17 & 1) == 0)
    {
      unint64_t v27 = *(void *)(a5 + 8);
      if (!sub_10000DDF4(a1, v27, v25 / v16))
      {
        sub_100040B90("omap entry (oid 0x%llx): invalid ov_paddr (%llu)\n", v28, v29, v30, v31, v32, v33, v34, *a3);
        uint64_t v10 = 92LL;
        uint64_t v11 = 362LL;
        goto LABEL_18;
      }

      if ((v17 & 0xE0) == 0x20) {
        unsigned int v35 = 36;
      }
      else {
        unsigned int v35 = 14;
      }
      if (a2) {
        unint64_t v36 = *(void *)(*(void *)(a2 + 40) + 8LL);
      }
      else {
        unint64_t v36 = 0LL;
      }
      BOOL v37 = a2 == 0;
      BOOL v38 = a2 != 0;
      if (v37) {
        unsigned int v39 = 13;
      }
      else {
        unsigned int v39 = 3;
      }
      if (v37) {
        unsigned int v35 = 0;
      }
      sub_10003D570(a1, v27, v26, v36, 0, *a3, a3[1], v39, v35, 1u);
      int v40 = sub_10001CE20(v38, *a3, 0);
      if (v40)
      {
        int v48 = v40;
        sub_100040C68( "object (oid 0x%llx): Unable to mark omap entry for omap space verification \n",  v41,  v42,  v43,  v44,  v45,  v46,  v47,  *a3);
        sub_100044E7C((char *)0x3D0, v48);
      }
    }

    return 0LL;
  }

  sub_100040B90( "omap entry (oid 0x%llx): invalid crypto key index (%u) on %s\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  *a3);
  uint64_t v10 = 92LL;
  sub_100044E7C((char *)0x4B0, 92);
  if (sub_1000428C4( qword_10008DB70,  "Fix object (oid 0x%llx) crypto key index? ",  v19,  v20,  v21,  v22,  v23,  v24,  *a3))
  {
    *(_DWORD *)a5 &= 0xFFFFFF1F;
    *a8 = 1;
    unsigned int v17 = *(_DWORD *)a5;
    goto LABEL_13;
  }

  return v10;
}

uint64_t sub_10000D0C4( uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  uint64_t v13 = a2[9];
  uint64_t v14 = a2[13];
  uint64_t v15 = a2[14];
  uint64_t v16 = a2[15];
  unint64_t v41 = 0LL;
  if (!*(void *)(v13 + 56))
  {
    unint64_t v19 = 0LL;
    goto LABEL_5;
  }

  v40[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v17 = sub_100029C7C(a1, (uint64_t)a2, v40);
  if ((_DWORD)v17) {
    return v17;
  }
  if (*(_BYTE *)(qword_10008DB78 + 42)) {
    uint64_t v29 = 0LL;
  }
  else {
    uint64_t v29 = sub_10000D2D8;
  }
  uint64_t v18 = sub_100031CD0( v40[0],  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))v29,  a3,  &v41,  1);
  if (!(_DWORD)v18)
  {
    unint64_t v19 = v41;
    if (HIDWORD(v41))
    {
      sub_100040B90("om: invalid om_snap_count (overflow)\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v39);
      uint64_t v18 = 92LL;
      uint64_t v30 = 375LL;
LABEL_28:
      int v37 = 92;
      goto LABEL_29;
    }

uint64_t sub_10000D2D8( uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = *(void *)(*(void *)(a2 + 40) + 1000LL);
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v148[2] = v14;
  v148[3] = v14;
  v148[0] = v14;
  v148[1] = v14;
  unsigned int v146 = 3808;
  unsigned int v147 = 832;
  unsigned int v15 = *(_DWORD *)a5;
  *(void *)(a7 + 56) = *a3;
  *(void *)(a2 + 56) = *a3;
  if ((v15 & 1) != 0)
  {
    sub_1000432C4(qword_10008DB70, 215, (uint64_t)a3, a4, a5, a6, a7, a8, v138);
  }

  else if ((v15 & 2) == 0)
  {
    unsigned int v16 = v15;
    goto LABEL_12;
  }

  sub_10001CDE4(1);
  uint64_t v17 = *a3;
  if ((unint64_t)*a3 > *(void *)(a1[1] + 16))
  {
    if ((v15 & 1) != 0)
    {
LABEL_9:
      sub_100040B90("omap snapshot: invalid key (0x%llx)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v17);
      uint64_t v20 = 92LL;
      sub_100044E7C((char *)0x174, 92);
LABEL_10:
      BOOL v21 = 0;
LABEL_20:
      char v22 = (*(_BYTE *)(a2 + 14) != 0) & (v15 | v21);
      goto LABEL_21;
    }

LABEL_42:
  if (v151) {
    free(v151);
  }
  if ((_DWORD)v20) {
    goto LABEL_10;
  }
  uint64_t v28 = *(void *)(a2 + 40);
LABEL_46:
  unsigned int v46 = sub_100034B44( (uint64_t)v148,  (uint64_t)a1,  a2,  *(_DWORD *)(v28 + 124) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(v28 + 124),  16,  0,  *(_DWORD *)(a1[1] + 36),  0,  0,  0,  *(void *)(v28 + 152),  (uint64_t)sub_10003A6AC);
  uint64_t v47 = calloc(1uLL, 0x340uLL);
  int v48 = (int *)calloc(1uLL, 0xEE0uLL);
  uint64_t v55 = v48;
  if (v46 || !v47 || !v48)
  {
    *(void *)&__int128 v74 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v74 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)((char *)v163 + 15) = v74;
    v163[0] = v74;
    __int128 v162 = v74;
    __int128 v161 = v74;
    __int128 v160 = v74;
    __int128 v159 = v74;
    __int128 v158 = v74;
    __int128 v157 = v74;
    __int128 v156 = v74;
    __int128 v155 = v74;
    __int128 v154 = v74;
    __int128 v153 = v74;
    *(_OWORD *)&v152[49] = v74;
    *(_OWORD *)&v152[33] = v74;
    *(_OWORD *)&v152[17] = v74;
    *(_OWORD *)&v152[1] = v74;
    uint64_t v75 = *(void *)(a7 + 32) + 1LL;
    *(void *)(a7 + 32) = v75;
    v152[0] = 0;
    sub_1000432C4(qword_10008DB70, 214, v49, v50, v51, v52, v53, v54, v75);
    if (v46) {
      uint64_t v20 = v46;
    }
    else {
      uint64_t v20 = 12LL;
    }
    char v76 = strerror(v20);
    sub_100040B90( "unable to init snap_meta tree for extentref_tree_oid lookup: %s\n",  v77,  v78,  v79,  v80,  v81,  v82,  v83,  v76);
    sub_100044E7C((char *)0x2B0, v20);
    if (v55) {
      free(v55);
    }
    if (v47) {
      free(v47);
    }
    goto LABEL_10;
  }

  *uint64_t v47 = *a3 & 0xFFFFFFFFFFFFFFFLL | 0x1000000000000000LL;
  uint64_t v56 = sub_100034BB4((uint64_t)v148, 0LL, 0LL, v47, &v147, 0x340u, v48, &v146);
  if ((_DWORD)v56)
  {
    uint64_t v20 = v56;
    *(void *)&__int128 v63 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v63 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)((char *)v163 + 15) = v63;
    v163[0] = v63;
    __int128 v162 = v63;
    __int128 v161 = v63;
    __int128 v160 = v63;
    __int128 v159 = v63;
    __int128 v158 = v63;
    __int128 v157 = v63;
    __int128 v156 = v63;
    __int128 v155 = v63;
    __int128 v154 = v63;
    __int128 v153 = v63;
    *(_OWORD *)&v152[49] = v63;
    *(_OWORD *)&v152[33] = v63;
    *(_OWORD *)&v152[17] = v63;
    *(_OWORD *)&v152[1] = v63;
    uint64_t v64 = *(void *)(a7 + 32) + 1LL;
    *(void *)(a7 + 32) = v64;
    v152[0] = 0;
    sub_1000432C4(qword_10008DB70, 214, v57, v58, v59, v60, v61, v62, v64);
    uint64_t v65 = *a3;
    strerror(v20);
    sub_100040B90( "Could not lookup cached extent_ref_tree information at snap xid (0x%llx): %s\n",  v66,  v67,  v68,  v69,  v70,  v71,  v72,  v65);
    sub_100044E7C((char *)0x2B7, 92);
    BOOL v73 = 0;
    BOOL v21 = 0;
    goto LABEL_103;
  }

  uint64_t v145 = v47;
  *(void *)&__int128 v84 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v84 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)((char *)v163 + 15) = v84;
  v163[0] = v84;
  __int128 v162 = v84;
  __int128 v161 = v84;
  __int128 v160 = v84;
  __int128 v159 = v84;
  __int128 v158 = v84;
  __int128 v157 = v84;
  __int128 v156 = v84;
  __int128 v155 = v84;
  __int128 v154 = v84;
  __int128 v153 = v84;
  *(_OWORD *)&v152[49] = v84;
  *(_OWORD *)&v152[33] = v84;
  *(_OWORD *)&v152[17] = v84;
  *(_OWORD *)&v152[1] = v84;
  ++*(void *)(a7 + 32);
  v152[0] = 0;
  uint64_t v142 = (char *)v55 + 50;
  __strlcpy_chk(v152, (char *)v55 + 50, 256LL, 256LL);
  sub_1000432C4(qword_10008DB70, 214, v85, v86, v87, v88, v89, v90, *(void *)(a7 + 32));
  int v141 = v55[10];
  uint64_t v92 = *(void *)v55;
  uint64_t v91 = *((void *)v55 + 1);
  uint64_t v144 = v55;
  BOOL v21 = *(void *)v55 == 0LL;
  uint64_t v93 = a2 + 48;
  uint64_t v94 = sub_100022BD0(a1, 0LL, 0x40000000, v91, 0LL, 0, 13, 0, (uint64_t **)(a2 + 48), 0LL, 0);
  if ((_DWORD)v94)
  {
    uint64_t v20 = v94;
    BOOL v73 = 0;
    uint64_t v55 = v144;
    uint64_t v47 = v145;
    goto LABEL_103;
  }

  uint64_t v140 = v92;
  uint64_t v101 = *(void *)v93;
  if (!*(void *)v93) {
    uint64_t v101 = *(void *)(a2 + 40);
  }
  uint64_t v47 = v145;
  uint64_t v102 = (uint64_t)v142;
  if ((*(_BYTE *)(v101 + 56) & 0x20) != 0)
  {
    uint64_t v128 = *a3;
    if (*(void *)(*(void *)v93 + 1024LL))
    {
      uint64_t v20 = sub_1000471C0(a1, a2, v128);
      uint64_t v102 = (uint64_t)v142;
      if (!(_DWORD)v20) {
        goto LABEL_63;
      }
    }

    else
    {
      sub_100040B90("Snapshot (0x%llx): apfs_integrity_meta_oid is invalid\n", v95, v128, v96, v97, v98, v99, v100, *a3);
      uint64_t v20 = 92LL;
      sub_100044E7C((char *)0x387, 92);
    }

    BOOL v73 = 0;
    uint64_t v55 = v144;
    goto LABEL_103;
  }

BOOL sub_10000DDF4(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    unint64_t v5 = *(void *)(v4 + 48);
    unint64_t v6 = *(void *)(v4 + 96);
  }

  else
  {
    unint64_t v5 = *(void *)(v3 + 40);
    if ((*(_BYTE *)(v3 + 65) & 1) != 0) {
      unint64_t v6 = *(void *)(v3 + 40);
    }
    else {
      unint64_t v6 = 0LL;
    }
  }

  unint64_t v7 = *(unsigned int *)(v3 + 36);
  if (a2)
  {
    BOOL v8 = v5 > a3 && v5 > a2;
    if (v8 && v5 - a3 >= a2) {
      return 1LL;
    }
  }

  unint64_t v10 = 0x4000000000000000uLL >> __clz(__rbit64(v7));
  if (v10 < a2 && ((v11 = v6 | v10, BOOL v8 = v6 > a3, v12 = v6 - a3, v8) ? (v13 = v11 > a2) : (v13 = 0), v13)) {
    return (v12 | v10) >= a2;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10000DE7C(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(a3 + 48);
  uint64_t v7 = v6;
  if (!v6) {
    uint64_t v7 = *(void *)(a3 + 40);
  }
  if ((*(_BYTE *)(v7 + 56) & 0x20) != 0) {
    int v8 = *(_DWORD *)(a3 + 16);
  }
  else {
    int v8 = 0;
  }
  if (!v6) {
    uint64_t v6 = *(void *)(a3 + 40);
  }
  if ((*(_BYTE *)(v6 + 56) & 0x20) != 0) {
    int v9 = *(_DWORD *)(a3 + 20);
  }
  else {
    int v9 = 0;
  }
  return sub_100034B44( a1,  a2,  a3,  a4 & 0xC0000000,  (unsigned __int16)a4,  a5,  v8,  *(_DWORD *)(*(void *)(a2 + 8) + 36LL),  0,  0,  v9,  a6,  (uint64_t)sub_10003A6AC);
}

uint64_t sub_10000DF04(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  return sub_100034B44( a1,  a2,  a3,  a4 & 0xC0000000,  (unsigned __int16)a4,  31,  0,  *(_DWORD *)(*(void *)(a2 + 8) + 36LL),  16,  16,  0,  a5,  (uint64_t)sub_10003A650);
}

uint64_t sub_10000DF58(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  return sub_100034B44( a1,  a2,  a3,  a4 & 0xC0000000,  (unsigned __int16)a4,  15,  0,  *(_DWORD *)(*(void *)(a2 + 8) + 36LL),  0,  0,  0,  a5,  (uint64_t)sub_10003A6AC);
}

uint64_t sub_10000DFA8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  return sub_100034B44( a1,  a2,  a3,  a4 & 0xC0000000,  (unsigned __int16)a4,  32,  0,  *(_DWORD *)(*(void *)(a2 + 8) + 36LL),  8,  24,  0,  a5,  (uint64_t)sub_10002D39C);
}

uint64_t sub_10000E000()
{
  v1.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v1.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_REALTIME, &v1);
  return sub_10000E034(&v1.tv_sec);
}

uint64_t sub_10000E034(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v3 = v2 / 1000000000;
  uint64_t v4 = v2 % 1000000000;
  if (*a1 < 0 && v2 >= 1)
  {
    uint64_t v5 = v3 + 1;
    v4 -= 1000000000LL;
  }

  else
  {
    BOOL v6 = v2 >= 0;
    if (v2 < 0) {
      uint64_t v5 = v3 - 1;
    }
    else {
      uint64_t v5 = v2 / 1000000000;
    }
    if (v6) {
      uint64_t v7 = v4;
    }
    else {
      uint64_t v7 = v4 + 1000000000;
    }
    if (v1 >= 1) {
      uint64_t v4 = v7;
    }
    else {
      uint64_t v5 = v3;
    }
  }

  uint64_t v8 = v1 + v5;
  if (__OFADD__(v1, v5)
    || (uint64_t v9 = 1000000000 * v8, (unsigned __int128)(v8 * (__int128)1000000000LL) >> 64 != (1000000000 * v8) >> 63)
    || (uint64_t result = v4 + v9, __OFADD__(v4, v9)))
  {
    if (v1 > 0) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      return 0x8000000000000000LL;
    }
  }

  return result;
}

BOOL sub_10000E0D0( uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return *(void *)(*(void *)(a1 + 8) + 1384LL) <= 0x83B5A93981BC1uLL
      && sub_1000428C4( qword_10008DB70,  "Unset invalid flags? (0x%llx) ",  a3,  a4,  a5,  a6,  a7,  a8,  a2 & ~(_BYTE)a3) != 0;
}

uint64_t sub_10000E138(uint64_t a1, uint64_t *a2, int a3, unint64_t *a4, int a5, int a6, _DWORD *a7)
{
  *a7 = 0;
  if ((a3 - 267) <= 0xFFFFFEFE)
  {
    if (a6)
    {
      char v9 = sub_10003A294((unint64_t)*a2 >> 60);
      sub_100040B90("%s (id %llu): invalid key length (%u)\n", v10, v11, v12, v13, v14, v15, v16, v9);
      uint64_t v17 = 330LL;
LABEL_37:
      uint64_t v61 = 92LL;
      sub_100044E7C((char *)v17, 92);
      return v61;
    }

    return 92LL;
  }

  unint64_t v18 = *a2;
  if ((~*a2 & 0xFFFFFFFFFFFFFFFLL) != 0)
  {
    if (a6)
    {
      char v62 = sub_10003A294(v18 >> 60);
      sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v63, v64, v65, v66, v67, v68, v69, v62);
      uint64_t v17 = 331LL;
      goto LABEL_37;
    }

    return 92LL;
  }

  CFIndex v23 = *((unsigned __int16 *)a2 + 4);
  if (v23 + 10 != a3 && a6 != 0)
  {
    char v25 = sub_10003A294(v18 >> 60);
    sub_100040C68( "%s (id %llu): invalid name_len (%u), given key length (%u)\n",  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v25);
    sub_100044E7C((char *)0x14D, -9);
    *a7 |= 2u;
    CFIndex v23 = *((unsigned __int16 *)a2 + 4);
  }

  if ((unsigned __int16)(v23 - 257) <= 0xFF00u && a6 != 0)
  {
    char v34 = sub_10003A294((unint64_t)*a2 >> 60);
    sub_100040C68("%s (id %llu): invalid name_len (%u)\n", v35, v36, v37, v38, v39, v40, v41, v34);
    *a7 |= 2u;
    sub_100044E7C((char *)0x14C, -9);
    CFIndex v23 = *((unsigned __int16 *)a2 + 4);
  }

  else {
    BOOL v42 = 1;
  }
  if (!v42)
  {
    char v43 = sub_10003A294((unint64_t)*a2 >> 60);
    sub_100040B90("%s (id %llu): invalid name (%.*s), given name_len (%u)\n", v44, v45, v46, v47, v48, v49, v50, v43);
    *a7 |= 1u;
    sub_100044E7C((char *)0x14E, -9);
    CFIndex v23 = *((unsigned __int16 *)a2 + 4);
  }

  if (sub_10000E42C((UInt8 *)a2 + 10, v23) && a6)
  {
    char v51 = sub_10003A294((unint64_t)*a2 >> 60);
    sub_100040C68("%s (id %llu): invalid name (%.*s)\n", v52, v53, v54, v55, v56, v57, v58, v51);
    *a7 |= 1u;
    sub_100044E7C((char *)0x14F, -9);
  }

  if (a5 != 8)
  {
    if (a6)
    {
      char v70 = sub_10003A294((unint64_t)*a2 >> 60);
      sub_100040B90("%s (id %llu): invalid value length (%u)\n", v71, v72, v73, v74, v75, v76, v77, v70);
      uint64_t v17 = 336LL;
      goto LABEL_37;
    }

    return 92LL;
  }

  unint64_t v59 = *a4;
  if (!*a4)
  {
    if (!a6) {
      return 92LL;
    }
LABEL_36:
    char v78 = sub_10003A294((unint64_t)*a2 >> 60);
    sub_100040B90("%s (id %llu): invalid snap_xid (%llu)\n", v79, v80, v81, v82, v83, v84, v85, v78);
    uint64_t v17 = 337LL;
    goto LABEL_37;
  }

  unint64_t v60 = *(void *)(*(void *)(a1 + 40) + 16LL);
  if (v59 <= v60) {
    uint64_t v61 = 0LL;
  }
  else {
    uint64_t v61 = 92LL;
  }
  if (v59 > v60 && (a6 & 1) != 0) {
    goto LABEL_36;
  }
  return v61;
}

uint64_t sub_10000E42C(UInt8 *bytes, CFIndex numBytes)
{
  CFStringRef v2 = CFStringCreateWithBytesNoCopy( kCFAllocatorDefault,  bytes,  numBytes,  0x8000100u,  0,  kCFAllocatorNull);
  if (v2)
  {
    CFRelease(v2);
    return 0LL;
  }

  else
  {
    uint64_t v3 = 92LL;
    sub_100044E7C((char *)0xB7, 92);
  }

  return v3;
}

#error "10000E638: switch analysis failed: switch information is incomplete or incorrect (funcsize=109)"
uint64_t sub_10000E664( uint64_t a1,  uint64_t a2,  uint64_t *a3,  uint64_t a4,  uint64_t a5,  uint64_t a6,  uint64_t a7,  _DWORD *a8)
{
  unint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  CFIndex v86;
  int v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  char v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  char v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  char v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  BOOL v129;
  unint64_t v130;
  char v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  char v139;
  uint64_t v13 = *a3;
  if ((_DWORD)a4 != 8)
  {
    CFIndex v23 = sub_10003A294(v13 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v24, v25, v26, v27, v28, v29, v30, v23);
    char v22 = 313LL;
    goto LABEL_6;
  }

  if ((v13 & 0xFFFFFFFFFFFFFFFLL) == 0 || (v13 & 0xFFFFFFFFFFFFFFFLL) > *(void *)(*(void *)(a2 + 40) + 16LL))
  {
    uint64_t v14 = sub_10003A294(v13 >> 60);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v15, v16, v17, v18, v19, v20, v21, v14);
    char v22 = 314LL;
    goto LABEL_6;
  }

  if ((a6 - 307) <= 0xFFFFFEFE)
  {
    uint64_t v36 = sub_10003A294(v13 >> 60);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v37, v38, v39, v40, v41, v42, v43, v36);
    char v22 = 315LL;
    goto LABEL_6;
  }

  if (!*(void *)(a5 + 8))
  {
    uint64_t v53 = sub_10003A294(v13 >> 60);
    sub_100040B90("%s (id %llu): invalid sblock_oid (%llu)\n", v54, v55, v56, v57, v58, v59, v60, v53);
    char v22 = 317LL;
    goto LABEL_6;
  }

  uint64_t v44 = *(void *)(a5 + 32);
  if (v44 <= 1)
  {
    uint64_t v45 = sub_10003A294(v13 >> 60);
    sub_100040B90("%s (id %llu): invalid inum (%llu)\n", v46, v47, v48, v49, v50, v51, v52, v45);
    char v22 = 320LL;
    goto LABEL_6;
  }

  if (v44 <= 0xF && (v44 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    uint64_t v64 = sub_10003A294(v13 >> 60);
    sub_100040C68("%s (id %llu): invalid inum (%llu)\n", v65, v66, v67, v68, v69, v70, v71, v64);
    sub_100044E7C((char *)0x141, -2);
    uint64_t v44 = *(void *)(a5 + 32);
  }

  if (*(void *)(a7 + 40) < v44 + 1) {
    *(void *)(a7 + 40) = v44 + 1;
  }
  if (!*(_WORD *)(a5 + 40))
  {
    uint64_t v88 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid extentref_tree_type (0x%x)\n", v89, v90, v91, v92, v93, v94, v95, v88);
    char v22 = 322LL;
    goto LABEL_6;
  }

  if (*(_DWORD *)(a5 + 44) >= 4u)
  {
    uint64_t v72 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040C68("%s (id %llu): unknown flags (0x%x)\n", v73, v74, v75, v76, v77, v78, v79, v72);
    if (*(void *)(*(void *)(a1 + 8) + 1384LL) <= 0x83B5A93981BC1uLL
      && sub_1000428C4( qword_10008DB70,  "Unset invalid flags? (0x%llx) ",  v80,  v81,  v82,  v83,  v84,  v85,  *(_BYTE *)(a5 + 44) & 0xFC))
    {
      *(_DWORD *)(a5 + 44) &= 3u;
      *a8 = 1;
    }

    sub_100044E7C((char *)0x143, -3);
  }

  uint64_t v86 = *(unsigned __int16 *)(a5 + 48);
  if (v86 + 50 == a6)
  {
    uint64_t v87 = 0;
  }

  else
  {
    uint64_t v96 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040C68( "%s (id %llu): invalid name_len (%u), given value length (%u)\n",  v97,  v98,  v99,  v100,  v101,  v102,  v103,  v96);
    sub_100044E7C((char *)0x145, 92);
    uint64_t v86 = *(unsigned __int16 *)(a5 + 48);
    uint64_t v87 = 2 * (v86 + 50 > (unint64_t)a6);
  }

  if ((unsigned __int16)(v86 - 257) <= 0xFF00u)
  {
    __int128 v104 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid name_len (%u)\n", v105, v106, v107, v108, v109, v110, v111, v104);
    sub_100044E7C((char *)0x144, 92);
    uint64_t v86 = *(unsigned __int16 *)(a5 + 48);
    uint64_t v87 = 2;
  }

  if (*(_BYTE *)(a5 + 50 + v86 - 1))
  {
    uint64_t v112 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040C68( "%s (id %llu): invalid name (%.*s), given name_len (%u)\n",  v113,  v114,  v115,  v116,  v117,  v118,  v119,  v112);
    v87 |= 1u;
    sub_100044E7C((char *)0x146, -9);
    uint64_t v86 = *(unsigned __int16 *)(a5 + 48);
  }

  if (sub_10000E42C((UInt8 *)(a5 + 50), v86))
  {
    uint64_t v120 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040C68("%s (id %llu): invalid name (%.*s)\n", v121, v122, v123, v124, v125, v126, v127, v120);
    LOBYTE(v87) = v87 | 1;
    sub_100044E7C((char *)0x147, -9);
  }

  else if (!v87)
  {
LABEL_42:
    uint64_t v31 = sub_100028964(a3, a5);
    if ((_DWORD)v31) {
      goto LABEL_7;
    }
    ++*(void *)(a7 + 32);
    uint64_t v128 = *(void *)(a5 + 8);
    uint64_t v129 = sub_10000DDF4(a1, v128, 1uLL);
    __int128 v130 = *a3;
    if (v129)
    {
      sub_10003D570( a1,  v128,  1LL,  0LL,  0x40000000,  v128,  v130 & 0xFFFFFFFFFFFFFFFLL,  0xDu,  &_mh_execute_header,  (unint64_t)&_mh_execute_header >> 32);
      return 0LL;
    }

    unsigned int v131 = sub_10003A294(v130 >> 60);
    sub_100040B90("%s (id %llu): invalid sblock_oid (%llu)\n", v132, v133, v134, v135, v136, v137, v138, v131);
    char v22 = 1244LL;
LABEL_6:
    uint64_t v31 = 92LL;
    sub_100044E7C((char *)v22, 92);
LABEL_7:
    sub_100040E4C(a2, (uint64_t)a3, a4, a5, a6, v32, v33, v34, v139);
    return v31;
  }

  if ((_DWORD)a6 == 50) {
    uint64_t v31 = 92LL;
  }
  else {
    uint64_t v31 = sub_100028390(a1, a2, a3, a5, a6, v87, a8);
  }
  if ((v87 & 2) == 0 || !(_DWORD)v31) {
    goto LABEL_42;
  }
  return v31;
}

uint64_t sub_10000EB84( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v12 = *a3;
  if ((_DWORD)a4 != 8)
  {
    char v21 = sub_10003A294(v12 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v22, v23, v24, v25, v26, v27, v28, v21);
    sub_100040E4C(a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v29, v30, v31, v107);
    uint64_t v32 = 92LL;
    uint64_t v33 = 205LL;
LABEL_7:
    int v45 = 92;
    goto LABEL_8;
  }

  if ((_DWORD)a6 != 20)
  {
    char v34 = sub_10003A294(v12 >> 60);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v35, v36, v37, v38, v39, v40, v41, v34);
    sub_100040E4C(a2, (uint64_t)a3, 8LL, (uint64_t)a5, a6, v42, v43, v44, v108);
    uint64_t v32 = 92LL;
    uint64_t v33 = 206LL;
    goto LABEL_7;
  }

  unint64_t v14 = v12 & 0xFFFFFFFFFFFFFFFLL;
  unint64_t v15 = *a5 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v16 = *(void *)(a1 + 8);
  uint64_t v17 = *(void *)(a1 + 24);
  if (v17)
  {
    unint64_t v18 = *(void *)(v17 + 48);
    unint64_t v19 = *(void *)(v17 + 96);
  }

  else
  {
    unint64_t v18 = *(void *)(v16 + 40);
    if ((*(_BYTE *)(v16 + 65) & 1) != 0) {
      unint64_t v19 = *(void *)(v16 + 40);
    }
    else {
      unint64_t v19 = 0LL;
    }
  }

  unint64_t v47 = *(unsigned int *)(v16 + 36);
  uint64_t v48 = *a5 >> 60;
  if (!v14 || (v18 > v15 ? (v49 = v18 > v14) : (v49 = 0), v49 ? (BOOL v50 = v18 - v15 >= v14) : (BOOL v50 = 0), !v50))
  {
    unint64_t v51 = 0x4000000000000000uLL >> __clz(__rbit64(v47));
    BOOL v52 = v51 < v14 && v19 > v15;
    BOOL v53 = v52 && (v19 | v51) > v14;
    if (!v53 || ((v19 - v15) | v51) < v14)
    {
      char v54 = sub_10003A294(v12 >> 60);
      sub_100040B90( "%s (id %llu): Bad phys_block_num + len (%llu) for physical extent record\n",  v55,  v56,  v57,  v58,  v59,  v60,  v61,  v54);
      sub_100044E7C((char *)0x467, 92);
      uint64_t v62 = 1LL;
      if (v15) {
        goto LABEL_30;
      }
      goto LABEL_29;
    }
  }

  uint64_t v62 = 0LL;
  if (!v15)
  {
LABEL_29:
    char v63 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040B90("%s (id %llu): length is 0\n", v64, v65, v66, v67, v68, v69, v70, v63);
    sub_100044E7C((char *)0xCF, 92);
    uint64_t v62 = 1LL;
  }

uint64_t sub_10000EEF4( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, _DWORD *a8)
{
  unint64_t v13 = *a3;
  if ((_DWORD)a4 != 8)
  {
    char v25 = sub_10003A294(v13 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v23 = 92LL;
    uint64_t v24 = 218LL;
    goto LABEL_5;
  }

  unint64_t v14 = (char *)(v13 & 0xFFFFFFFFFFFFFFFLL);
  if ((v13 & 0xFFFFFFFFFFFFFFFLL) <= 1)
  {
    char v15 = sub_10003A294(v13 >> 60);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v16, v17, v18, v19, v20, v21, v22, v15);
    uint64_t v23 = 92LL;
    uint64_t v24 = 219LL;
LABEL_5:
    int v33 = 92;
LABEL_6:
    sub_100044E7C((char *)v24, v33);
LABEL_7:
    sub_100040E4C(a2, (uint64_t)a3, a4, a5, a6, v34, v35, v36, v323);
    return v23;
  }

  unint64_t v41 = (unint64_t)(v14 - 4);
  if ((unint64_t)v14 <= 0xF && (unint64_t)(v14 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v43 = sub_10003A294(v13 >> 60);
    sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v44, v45, v46, v47, v48, v49, v50, v43);
    sub_100044E7C((char *)0xDC, -2);
  }

  if (a6 <= 0x5B)
  {
    char v51 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v52, v53, v54, v55, v56, v57, v58, v51);
    uint64_t v23 = 92LL;
    uint64_t v24 = 221LL;
    goto LABEL_5;
  }

  unsigned int v59 = *(unsigned __int16 *)(a5 + 80) >> 12;
  if (v59 <= 0xE)
  {
    int v60 = 1 << v59;
    if ((v60 & 0x1556) != 0) {
      goto LABEL_20;
    }
    if ((v60 & 0x4001) != 0)
    {
      char v95 = sub_10003A294(*a3 >> 60);
      sub_100040B90("%s (id %llu): invalid type (0%o)\n", v96, v97, v98, v99, v100, v101, v102, v95);
      uint64_t v23 = 92LL;
      uint64_t v24 = 222LL;
      goto LABEL_5;
    }
  }

  char v160 = sub_10003A294(*a3 >> 60);
  sub_100040C68("%s (id %llu): invalid type (0%o)\n", v161, v162, v163, v164, v165, v166, v167, v160);
  sub_100044E7C((char *)0xDF, -5);
LABEL_20:
  if (!*(void *)a5)
  {
    char v87 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid parent_id (%llu)\n", v88, v89, v90, v91, v92, v93, v94, v87);
    uint64_t v23 = 92LL;
    uint64_t v24 = 224LL;
    goto LABEL_5;
  }

  if ((unint64_t)(*(void *)a5 - 16LL) >= 0xFFFFFFFFFFFFFFF4LL)
  {
    char v61 = sub_10003A294(*a3 >> 60);
    sub_100040C68("%s (id %llu): invalid parent_id (%llu)\n", v62, v63, v64, v65, v66, v67, v68, v61);
    sub_100044E7C((char *)0xE1, -2);
  }

  if (v41 <= 0xFFFFFFFFFFFFFFFDLL && *(void *)a5 == 1LL)
  {
    char v69 = sub_10003A294(*a3 >> 60);
    sub_100040B90( "%s (id %llu): invalid parent_id (%llu) for regular directory\n",  v70,  v71,  v72,  v73,  v74,  v75,  v76,  v69);
    sub_100044E7C((char *)0xE2, 92);
    v332 = (const char *)0xAAAAAAAAAAAAAAAALL;
    unsigned __int16 v331 = -21846;
    int v77 = sub_10003B6C4((unsigned __int16 *)(a5 + 92), (int)a6 - 92, 4, &v332, &v331, 0LL, 0LL);
    if ((*(_WORD *)(a5 + 80) & 0xF000) == 0x4000
      && !v77
      && !strncmp(v332, ".DocumentRevisions-V100", v331)
      && sub_1000428C4( qword_10008DB70,  "Fix inode_val: parent_id (%llu)? ",  (uint64_t)a3,  a4,  a5,  a6,  (uint64_t)a7,  (uint64_t)a8,  *(void *)a5))
    {
      *(void *)a5 = 2LL;
      *a8 = 1;
    }

    else
    {
      *(_BYTE *)(a2 + 13) = 1;
    }
  }

  if (v14 == (char *)2)
  {
    uint64_t v78 = *(void *)a5;
    if (*(void *)a5 != 1LL)
    {
      char v103 = sub_10003A294(*a3 >> 60);
      sub_100040B90( "%s (id %llu): invalid parent_id (%llu) for root directory\n",  v104,  v105,  v106,  v107,  v108,  v109,  v110,  v103);
      uint64_t v23 = 92LL;
      uint64_t v24 = 227LL;
      goto LABEL_5;
    }
  }

  else if (v14 == (char *)3)
  {
    uint64_t v78 = *(void *)a5;
    if (*(void *)a5 != 1LL)
    {
      char v79 = sub_10003A294(*a3 >> 60);
      sub_100040B90( "%s (id %llu): invalid parent_id (%llu) for private directory\n",  v80,  v81,  v82,  v83,  v84,  v85,  v86,  v79);
      uint64_t v23 = 92LL;
      uint64_t v24 = 228LL;
      goto LABEL_5;
    }
  }

  else
  {
    uint64_t v78 = *(void *)a5;
  }

  unint64_t v111 = v78 + 1;
  if (a7[5] < v111) {
    a7[5] = v111;
  }
  unint64_t v112 = *(void *)(a5 + 8);
  if (!v112)
  {
    LOBYTE(v332) = 0;
    uint64_t v121 = sub_10003B000(a1, a2, a7[7], *a3 & 0xFFFFFFFFFFFFFFFLL, &v332);
    if ((_DWORD)v121)
    {
      uint64_t v23 = v121;
      uint64_t v24 = 1263LL;
      int v33 = v23;
      goto LABEL_6;
    }

    if (!(_BYTE)v332)
    {
      char v186 = sub_10003A294(*a3 >> 60);
      sub_100040B90("%s (id %llu): invalid private_id (%llu)\n", v187, v188, v189, v190, v191, v192, v193, v186);
      uint64_t v23 = 92LL;
      uint64_t v24 = 229LL;
      goto LABEL_5;
    }

    unint64_t v112 = *(void *)(a5 + 8);
    unint64_t v41 = (unint64_t)(v14 - 4);
  }

  if (v112 == 1)
  {
    char v113 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid private_id (%llu)\n", v114, v115, v116, v117, v118, v119, v120, v113);
    uint64_t v23 = 92LL;
    uint64_t v24 = 1264LL;
    goto LABEL_5;
  }

  if (v112 <= 0xF && (v112 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v122 = sub_10003A294(*a3 >> 60);
    sub_100040C68("%s (id %llu): invalid private_id (%llu)\n", v123, v124, v125, v126, v127, v128, v129, v122);
    sub_100044E7C((char *)0xE6, -2);
    unint64_t v112 = *(void *)(a5 + 8);
  }

  unint64_t v130 = v112 + 1;
  if (a7[5] < v130) {
    a7[5] = v130;
  }
  unint64_t v326 = v41;
  if ((*(_WORD *)(a5 + 80) & 0xF000) == 0x4000)
  {
    uint64_t v131 = a7[7];
    if (v131) {
      uint64_t v132 = 0LL;
    }
    else {
      uint64_t v132 = (_DWORD *)(a2 + 704);
    }
    sub_100028EBC(a1, a2, v131, (uint64_t)v14, *(unsigned int *)(a5 + 68), v132, (uint64_t)a7, (uint64_t)a8);
    uint64_t v23 = v133;
    if ((_DWORD)v133) {
      return v23;
    }
    int v134 = *(_DWORD *)(a5 + 56);
    if (v134 < 0)
    {
      char v135 = sub_10003A294(*a3 >> 60);
      sub_100040C68("%s (id %llu): invalid nchildren (%d)\n", v136, v137, v138, v139, v140, v141, v142, v135);
      sub_100044E7C((char *)0x4BE, -8);
      int v134 = *(_DWORD *)(a5 + 56);
    }

    sub_1000290AC((uint64_t)v14, v134);
    if ((*(_BYTE *)(*(void *)(a2 + 40) + 57LL) & 2) != 0)
    {
      int v143 = *(_DWORD *)(a5 + 84);
      if (v143 < 0)
      {
        char v144 = sub_10003A294(*a3 >> 60);
        sub_100040C68("%s (id %llu): invalid dir_nlink (%d)\n", v145, v146, v147, v148, v149, v150, v151, v144);
        sub_100044E7C((char *)0x4BF, -8);
        int v143 = *(_DWORD *)(a5 + 84);
      }

      if (*(_DWORD *)(a5 + 56) < v143 && (*(_BYTE *)(a5 + 71) & 0x40) == 0)
      {
        char v152 = sub_10003A294(*a3 >> 60);
        sub_100040C68( "%s (id %llu): directory nlink value %d is greater than nchildren (%d)\n",  v153,  v154,  v155,  v156,  v157,  v158,  v159,  v152);
        sub_100044E7C((char *)0x483, -8);
        int v143 = *(_DWORD *)(a5 + 84);
      }

      sub_1000290BC((uint64_t)v14, v143);
    }
  }

  else if ((*(_DWORD *)(a5 + 56) & 0x80000000) != 0)
  {
    char v178 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid nlink (%d)\n", v179, v180, v181, v182, v183, v184, v185, v178);
    uint64_t v23 = 92LL;
    uint64_t v24 = 236LL;
    goto LABEL_5;
  }

  unint64_t v168 = *(void *)(a5 + 48);
  if (v168 >> 31)
  {
    char v169 = sub_10003A294(*a3 >> 60);
    sub_100040C68( "%s (id %llu): invalid internal_flags (0x%llx / valid-flags are: 0x%llx)\n",  v170,  v171,  v172,  v173,  v174,  v175,  v176,  v169);
    sub_100044E7C((char *)0xED, -3);
    unint64_t v168 = *(void *)(a5 + 48);
  }

  if ((v168 & 0x800000) != 0)
  {
    if ((*(_BYTE *)(*(void *)(a2 + 40) + 56LL) & 0x40) == 0)
    {
      unint64_t v177 = v168 & 8;
      goto LABEL_81;
    }

    unint64_t v177 = v168 & 8;
    if ((v168 & 8) == 0 || (*(_WORD *)(a5 + 80) & 0xF000) != 0x8000)
    {
LABEL_81:
      char v194 = sub_10003A294(*a3 >> 60);
      if (v177) {
        sub_100040B90( "%s (id %llu): invalid internal_flags (0x%llx), given type (0%o)\n",  v195,  v196,  v197,  v198,  v199,  v200,  v201,  v194);
      }
      else {
        sub_100040B90( "%s (id %llu): invalid internal_flags (0x%llx), inconsistent protection class\n",  v195,  v196,  v197,  v198,  v199,  v200,  v201,  v194);
      }
      if (!sub_1000428C4( qword_10008DB70,  "Fix inode_val: internal_flags (0x%llx)? ",  v202,  v203,  v204,  v205,  v206,  v207,  *(void *)(a5 + 48)))
      {
        uint64_t v23 = 92LL;
        uint64_t v24 = 972LL;
        goto LABEL_5;
      }

      unint64_t v168 = *(void *)(a5 + 48) & 0xFFFFFFFFFF7FFFFFLL;
      *(void *)(a5 + 48) = v168;
      *a8 = 1;
      goto LABEL_86;
    }

    sub_100030634(v14, a2, (uint64_t)a3, a4, a5, a6, (uint64_t)a7, (uint64_t)a8);
    unint64_t v168 = *(void *)(a5 + 48);
  }

LABEL_86:
  if ((*(_WORD *)(a5 + 80) & 0xF000) != 0x4000 && (v168 & 4) != 0)
  {
    char v208 = sub_10003A294(*a3 >> 60);
    sub_100040B90( "%s (id %llu): invalid internal_flags (0x%llx), given type (0%o)\n",  v209,  v210,  v211,  v212,  v213,  v214,  v215,  v208);
    if (!sub_1000428C4( qword_10008DB70,  "Fix inode_val: internal_flags (0x%llx)? ",  v216,  v217,  v218,  v219,  v220,  v221,  *(void *)(a5 + 48)))
    {
      uint64_t v23 = 92LL;
      uint64_t v24 = 238LL;
      goto LABEL_5;
    }

    unint64_t v168 = *(void *)(a5 + 48) & 0xFFFFFFFFFFFFFFFBLL;
    *(void *)(a5 + 48) = v168;
    *a8 = 1;
  }

  if ((v168 & 6) == 4)
  {
    char v222 = sub_10003A294(*a3 >> 60);
    sub_100040C68( "%s (id %llu): invalid internal_flags (0x%llx), (dir-stats origin but not dir-stats maintained)\n",  v223,  v224,  v225,  v226,  v227,  v228,  v229,  v222);
    sub_100044E7C((char *)0x532, -3);
    unint64_t v168 = *(void *)(a5 + 48);
  }

  if ((v168 & 0x20000002) == 0x20000000)
  {
    char v230 = sub_10003A294(*a3 >> 60);
    sub_100040C68( "%s (id %llu): invalid internal_flags (0x%llx), (dir-stats SAF but not dir-stats maintained)\n",  v231,  v232,  v233,  v234,  v235,  v236,  v237,  v230);
    sub_100044E7C((char *)0x533, -3);
  }

  if (*(_DWORD *)(a5 + 60) >= 8u)
  {
    char v238 = sub_10003A294(*a3 >> 60);
    sub_100040B90( "%s (id %llu): invalid default_protection_class (%u)\n",  v239,  v240,  v241,  v242,  v243,  v244,  v245,  v238);
    uint64_t v23 = 92LL;
    uint64_t v24 = 239LL;
    goto LABEL_5;
  }

  if ((*(_WORD *)(a5 + 70) & 0xBF60) != 0)
  {
    char v246 = sub_10003A294(*a3 >> 60);
    sub_100040C68("%s (id %llu): invalid bsd_flags (0x%x)\n", v247, v248, v249, v250, v251, v252, v253, v246);
    sub_100044E7C((char *)0xF0, -3);
  }

  if (*(_WORD *)(a5 + 82))
  {
    char v254 = sub_10003A294(*a3 >> 60);
    sub_100040C68("%s (id %llu): invalid pad1 (0x%hx)\n", v255, v256, v257, v258, v259, v260, v261, v254);
    sub_100044E7C((char *)0xF1, -10);
  }

  if ((*(_BYTE *)(*(void *)(a2 + 40) + 57LL) & 2) != 0
    && (*(_WORD *)(a5 + 80) & 0xB000 | 0x4000) == 0x6000
    && !*(_DWORD *)(a5 + 84))
  {
    char v262 = sub_10003A294(*a3 >> 60);
    sub_100040C68( "%s (id %llu): zero rdev on char/block device (mode %u)\n",  v263,  v264,  v265,  v266,  v267,  v268,  v269,  v262);
    sub_100044E7C((char *)0x4C0, 92);
  }

  if (*(void *)(a5 + 84) && (*(_BYTE *)(a5 + 50) & 4) == 0)
  {
    if ((*(_BYTE *)(*(void *)(a2 + 40) + 57LL) & 2) != 0)
    {
      int v284 = *(_WORD *)(a5 + 80) & 0xF000;
      if (v284 != 0x2000 && v284 != 0x4000 && v284 != 24576)
      {
        char v285 = sub_10003A294(*a3 >> 60);
        sub_100040C68( "%s (id %llu): uncompressed_size/rdev/dir_nlink union field is set (%llu) but inode flags and mode do not indic ate it should (flags: 0x%llx, mode %u)\n",  v286,  v287,  v288,  v289,  v290,  v291,  v292,  v285);
        sub_100044E7C((char *)0x4AC, 92);
        if (sub_1000428C4( qword_10008DB70,  "Clear uncompressed size/rdev/dir_nlink? ",  v293,  v294,  v295,  v296,  v297,  v298,  v325))
        {
          *(void *)(a5 + 84) = 0LL;
          *a8 = 1;
        }
      }

      if (*(_DWORD *)(a5 + 88))
      {
        char v299 = sub_10003A294(*a3 >> 60);
        sub_100040C68("%s (id %llu): invalid pad2 (0x%x)\n", v300, v301, v302, v303, v304, v305, v306, v299);
        sub_100044E7C((char *)0x4C1, -10);
      }
    }

    else
    {
      char v270 = sub_10003A294(*a3 >> 60);
      sub_100040C68( "%s (id %llu): uncompressed size is set (%llu) but has-uncompressed-size flag is not set (flags: 0x%llx)\n",  v271,  v272,  v273,  v274,  v275,  v276,  v277,  v270);
      sub_100044E7C((char *)0xF2, 92);
      if (sub_1000428C4( qword_10008DB70,  "Clear uncompressed size? ",  v278,  v279,  v280,  v281,  v282,  v283,  v324))
      {
        *(void *)(a5 + 84) = 0LL;
        *a8 = 1;
      }
    }
  }

  __int128 v327 = 0u;
  __int128 v328 = 0u;
  uint64_t v329 = 0LL;
  uint64_t v330 = a5;
  uint64_t v307 = sub_1000134C8( a1,  a2,  (uint64_t)a3,  (unsigned __int16 *)(a5 + 92),  (a6 - 92),  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_1000136F4,  (uint64_t)a7,  a8,  (uint64_t)&v327);
  if ((_DWORD)v307 || (uint64_t v307 = sub_1000146DC(a1, a2, (uint64_t)a7, (uint64_t)&v327, a3, a8), (_DWORD)v307))
  {
    uint64_t v23 = v307;
    char v309 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid xfields\n", v310, v311, v312, v313, v314, v315, v316, v309);
    goto LABEL_7;
  }

  if (a7[7]) {
    v317 = 0LL;
  }
  else {
    v317 = (_DWORD *)(a2 + 704);
  }
  uint64_t v23 = sub_100024DFC(a1, a2, v317, (uint64_t)v14, a5, *((uint64_t *)&v327 + 1), v329, v308);
  if ((_DWORD)v23) {
    goto LABEL_7;
  }
  uint64_t v318 = *(void *)(a5 + 48);
  if ((v318 & 0x10) != 0 && (*(_WORD *)(a5 + 80) & 0xF000) == 0x8000)
  {
    else {
      uint64_t v319 = 0LL;
    }
    if (BYTE5(v327)) {
      uint64_t v320 = v329;
    }
    else {
      uint64_t v320 = 0LL;
    }
    if (BYTE2(v327)) {
      uint64_t v321 = *((void *)&v327 + 1);
    }
    else {
      uint64_t v321 = 0LL;
    }
    uint64_t v23 = sub_100001C24((unint64_t)v14, a5, a6, v319, v320, v321);
    if ((_DWORD)v23) {
      goto LABEL_7;
    }
    uint64_t v318 = *(void *)(a5 + 48);
  }

  if ((v318 & 1) != 0) {
    return 0LL;
  }
  int v322 = *(_WORD *)(a5 + 80) & 0xF000;
  if (v322 == 40960)
  {
    uint64_t v23 = 0LL;
    ++a7[2];
    return v23;
  }

  if (v322 == 0x8000)
  {
    uint64_t v23 = 0LL;
    ++*a7;
    return v23;
  }

  if (v322 != 0x4000)
  {
    uint64_t v23 = 0LL;
    ++a7[3];
    return v23;
  }

  if (v326 > 0xFFFFFFFFFFFFFFFDLL) {
    return 0LL;
  }
  uint64_t v23 = 0LL;
  ++a7[1];
  return v23;
}

          WORD6(v174) |= 0x200u;
          unint64_t v12 = sub_1000364F0(dword_100074C88, 0LL, v194, 8LL, &v165, 160LL);
          if ((_DWORD)v12) {
            goto LABEL_286;
          }
LABEL_87:
          free(v59);
          uint64_t v36 = BYTE12(v174);
          goto LABEL_88;
        }

        if (!v49)
        {
          uint64_t v49 = v65;
          if (!v65) {
            goto LABEL_94;
          }
        }

        goto LABEL_93;
      }
    }

    else
    {
      uint64_t v92 = v12;
      uint64_t v38 = 0LL;
      uint64_t v42 = 1;
      do
      {
        char v43 = v42;
        if (v10)
        {
          uint64_t v44 = v10[v38 + 3];
          if (v44)
          {
            uint64_t v45 = sub_10001BC28(v44);
            if (v45)
            {
              uint64_t v29 = v45;
              if ((v43 & 1) == 0)
              {
                uint64_t v66 = v10[3];
                if (v66) {
                  sub_10001BC30(v66);
                }
              }

              sub_10001BC30(*v11);
              unint64_t v12 = v92;
              goto LABEL_7;
            }
          }
        }

        uint64_t v42 = 0;
        uint64_t v38 = 1LL;
      }

      while ((v43 & 1) != 0);
      unint64_t v12 = v92;
      if (v20) {
        goto LABEL_8;
      }
    }

    uint64_t v40 = 1LL;
    goto LABEL_25;
  }

  if ((*a1 & 0x800) != 0)
  {
    ++*(void *)(a5 + 72);
    unint64_t v41 = 92LL;
  }

  else
  {
    unint64_t v41 = 0LL;
  }

  sub_1000432C4(v24, 125, v46, v47, v48, v49, v50, v51, v493);
  uint64_t v35 = 0LL;
LABEL_341:
  v469 = sub_100044E64();
  v470 = sub_100044E70();
  if (!(_DWORD)v35)
  {
    if (*(_BYTE *)(qword_10008DB78 + 46) && v469 | v470)
    {
      if (*(_BYTE *)(qword_10008DB78 + 36)) {
        uint64_t v35 = 3LL;
      }
      else {
        uint64_t v35 = 8LL;
      }
      sub_10004096C( "%d failures and %d warnings issued; failing execution as requested.\n",
        v471,
        v472,
        v473,
        v474,
        v475,
        v476,
        v477,
        v470);
    }

    else
    {
      uint64_t v35 = 0LL;
    }
  }

uint64_t sub_10000FC44( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, void *a7, _DWORD *a8)
{
  unint64_t v13 = *(void *)a3;
  char v210 = -86;
  if ((a4 - 777) <= 0xFFFFFD00)
  {
    char v14 = sub_10003A294(v13 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v15, v16, v17, v18, v19, v20, v21, v14);
    uint64_t v22 = 92LL;
    uint64_t v23 = 257LL;
LABEL_20:
    int v70 = 92;
LABEL_21:
    sub_100044E7C((char *)v23, v70);
LABEL_22:
    sub_100040E4C(a2, a3, a4, (uint64_t)a5, a6, v71, v72, v73, v204);
    return v22;
  }

  unint64_t v24 = v13 & 0xFFFFFFFFFFFFFFFLL;
  if ((v13 & 0xFFFFFFFFFFFFFFFLL) <= 1)
  {
    char v25 = sub_10003A294(v13 >> 60);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v22 = 92LL;
    uint64_t v23 = 258LL;
    goto LABEL_20;
  }

  if (v24 <= 0xF && (v24 > 7 || ((1LL << v13) & 0x8C) == 0))
  {
    char v37 = sub_10003A294(v13 >> 60);
    sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v38, v39, v40, v41, v42, v43, v44, v37);
    sub_100044E7C((char *)0x103, -2);
  }

  if (a7[5] <= v24) {
    a7[5] = v24 + 1;
  }
  CFIndex v45 = *(unsigned __int16 *)(a3 + 8);
  if ((unsigned __int16)(v45 - 767) <= 0xFD02u)
  {
    char v46 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): invalid name_len (%u)\n", v47, v48, v49, v50, v51, v52, v53, v46);
    uint64_t v22 = 92LL;
    uint64_t v23 = 260LL;
    goto LABEL_20;
  }

  if (v45 + 10 != a4)
  {
    char v62 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90( "%s (id %llu): invalid key length (%u), given name_len (%u)\n",  v63,  v64,  v65,  v66,  v67,  v68,  v69,  v62);
    uint64_t v22 = 92LL;
    uint64_t v23 = 261LL;
    goto LABEL_20;
  }

  if (*(_BYTE *)(a3 + 10 + (v45 - 1)))
  {
    char v54 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): invalid name (%.*s), given name_len (%u)\n", v55, v56, v57, v58, v59, v60, v61, v54);
    uint64_t v22 = 92LL;
    uint64_t v23 = 262LL;
    goto LABEL_20;
  }

  if (sub_10000E42C((UInt8 *)(a3 + 10), v45))
  {
    char v77 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040C68("%s (id %llu): invalid name (%.*s)\n", v78, v79, v80, v81, v82, v83, v84, v77);
    sub_100044E7C((char *)0x107, -9);
  }

  if (a6 <= 3)
  {
    char v85 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v86, v87, v88, v89, v90, v91, v92, v85);
    uint64_t v22 = 92LL;
    uint64_t v23 = 264LL;
    goto LABEL_20;
  }

  __s1 = (char *)(a3 + 10);
  int v93 = *a5;
  if ((v93 & 0xFFE8) != 0)
  {
    char v94 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040C68("%s (id %llu): invalid flags (0x%x)\n", v95, v96, v97, v98, v99, v100, v101, v94);
    if (*(void *)(*(void *)(a1 + 8) + 1384LL) <= 0x83B5A93981BC1uLL
      && sub_1000428C4( qword_10008DB70,  "Unset invalid flags? (0x%llx) ",  v102,  v103,  v104,  v105,  v106,  v107,  *(_BYTE *)a5 & 0xE8))
    {
      *a5 &= 0x17u;
      *a8 = 1;
    }

    sub_100044E7C((char *)0x109, -3);
    int v93 = *a5;
  }

  if ((~v93 & 3) == 0)
  {
    char v108 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): invalid flags (0x%x)\n", v109, v110, v111, v112, v113, v114, v115, v108);
    uint64_t v22 = 92LL;
    uint64_t v23 = 266LL;
    goto LABEL_20;
  }

  if ((v93 & 4) != 0)
  {
    size_t v205 = *(unsigned __int16 *)(a3 + 8);
    if (strncmp(__s1, "com.apple.fs.symlink", v205))
    {
      if (strncmp(__s1, "com.apple.fs.altlink", v205)
        && strncmp(__s1, "com.apple.fs.firmlink", v205)
        && strncmp(__s1, "com.apple.fs.cow-exempt-file-count", v205)
        && strncmp(__s1, "com.apple.fs.graft-vol-uuid", v205)
        && strncmp(__s1, "com.apple.fs.graft-jobj-id-base", v205)
        && strncmp(__s1, "com.apple.fs.graft-jobj-id-len", v205)
        && strncmp(__s1, "com.apple.system.fs.speculative_telemetry", v205))
      {
        char v116 = sub_10003A294(*(void *)a3 >> 60);
        sub_100040C68( "%s (id %llu): invalid flags (0x%x), given name (<%.*s> ; name_len %d)\n",
          v117,
          v118,
          v119,
          v120,
          v121,
          v122,
          v123,
          v116);
        sub_100044E7C((char *)0x10B, -3);
        LOWORD(v93) = *a5;
      }
    }
  }

  if ((v93 & 1) != 0 && a5[1] != 48)
  {
    char v135 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90( "%s (id %llu): invalid xdata_len (%u), given flags (0x%x)\n",  v136,  v137,  v138,  v139,  v140,  v141,  v142,  v135);
    uint64_t v22 = 92LL;
    uint64_t v23 = 268LL;
    goto LABEL_20;
  }

  uint64_t v124 = a5[1];
  if ((v93 & 2) != 0 && v124 >= 0xEDD)
  {
    char v125 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90( "%s (id %llu): invalid xdata_len (%u), given flags (0x%x)\n",  v126,  v127,  v128,  v129,  v130,  v131,  v132,  v125);
    uint64_t v22 = 92LL;
    uint64_t v23 = 269LL;
    goto LABEL_20;
  }

  if (v124 + 4 != a6)
  {
    char v143 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90( "%s (id %llu): invalid length (%u), given xdata_len (%u)\n",  v144,  v145,  v146,  v147,  v148,  v149,  v150,  v143);
    uint64_t v22 = 92LL;
    uint64_t v23 = 270LL;
    goto LABEL_20;
  }

  if (a7[7]) {
    uint64_t v133 = 0LL;
  }
  else {
    uint64_t v133 = (_DWORD *)(a2 + 704);
  }
  sub_100024214(a1, v133, a8, a3, (uint64_t)a5, (BOOL *)&v210, v75, v76);
  if ((_DWORD)v134)
  {
    uint64_t v22 = v134;
    uint64_t v23 = 973LL;
LABEL_56:
    int v70 = v22;
    goto LABEL_21;
  }

  size_t v151 = *(unsigned __int16 *)(a3 + 8);
  int v152 = strncmp(__s1, "com.apple.ResourceFork", v151);
  __int16 v153 = *a5;
  if (!v152)
  {
    if ((v153 & 1) == 0)
    {
      char v165 = sub_10003A294(*(void *)a3 >> 60);
      sub_100040B90( "%s (id %llu): com.apple.ResourceFork is expected to be stream based\n",  v166,  v167,  v168,  v169,  v170,  v171,  v172,  v165);
      uint64_t v22 = 92LL;
      uint64_t v23 = 1453LL;
      goto LABEL_20;
    }

LABEL_79:
        uint64_t v22 = v190;
        char v193 = sub_10003A294(*(void *)a3 >> 60);
        sub_100040B90("%s (id %llu): invalid dstream\n", v194, v195, v196, v197, v198, v199, v200, v193);
        goto LABEL_22;
      }
    }

    else
    {
      uint64_t v190 = sub_10000B0AC(v24, __src, v208, 0LL, 0LL, 0LL, v191, v192);
      if ((_DWORD)v190) {
        goto LABEL_79;
      }
      uint64_t v201 = *(void *)(a2 + 48);
      if (v201) {
        goto LABEL_87;
      }
    }

    uint64_t v201 = *(void *)(a2 + 40);
    goto LABEL_87;
  }

  if ((v153 & 1) != 0) {
    goto LABEL_71;
  }
  uint64_t v154 = *(void *)(a2 + 48);
  if (!v154) {
    uint64_t v154 = *(void *)(a2 + 40);
  }
  if ((*(_BYTE *)(v154 + 56) & 0x20) == 0) {
    return 0LL;
  }
  size_t v155 = v151;
  uint64_t v22 = 0LL;
  if ((_DWORD)a6 == 20 && v24 == a7[8])
  {
    if (!strncmp(__s1, "com.apple.decmpfs", v155))
    {
      unint64_t v156 = *(unsigned int *)(*(void *)(a1 + 8) + 36LL);
      uint64_t v22 = sub_10000B44C(a7[9], (*(void *)(a5 + 6) + v156 - 1) / v156 * v156);
      if (!(_DWORD)v22) {
        return v22;
      }
      char v157 = sub_10003A294(*(void *)a3 >> 60);
      sub_100040B90("%s (id %llu): failed to update dstream (%llu)\n", v158, v159, v160, v161, v162, v163, v164, v157);
      uint64_t v23 = 953LL;
      goto LABEL_56;
    }

    return 0LL;
  }

  return v22;
}

        uint64_t v22 = 92LL;
        goto LABEL_67;
      }

      if (*(unsigned __int16 *)(a1 + 46) + v103 < v56
                                                 - (*(unsigned __int16 *)(a1 + 42)
                                                  + (unsigned __int16)v58))
      {
        if (v9)
        {
          sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_free_space (%u, %u), given total value length (%u) (%d %d %d = %d)\n",  v56,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a1 + 8));
          uint64_t v22 = 92LL;
          uint64_t v50 = 397LL;
          goto LABEL_74;
        }

        goto LABEL_79;
      }

      uint64_t v105 = sub_100031C30(a1, (unsigned int *)a2, (uint64_t)v35);
      if (v105)
      {
        if (!v9) {
          goto LABEL_146;
        }
        uint64_t v113 = v105;
        uint64_t v114 = *(void *)(a1 + 8);
        strerror(v105);
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_key_free_list, btn_val_free_list, or btn_free_space: %s\n",  v115,  v116,  v117,  v118,  v119,  v120,  v121,  v114);
        uint64_t v100 = 398LL;
        uint64_t v102 = v113;
LABEL_145:
        sub_100044E7C((char *)v100, v102);
LABEL_146:
        uint64_t v22 = 92LL;
        goto LABEL_147;
      }

      uint64_t v122 = *(void *)(a2 + 24);
      uint64_t v123 = __CFADD__(v122, v73);
      uint64_t v124 = v122 + v73;
      if (v123)
      {
        if (!v9) {
          goto LABEL_146;
        }
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_key_count (overflow)\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  *(void *)(a1 + 8));
        uint64_t v22 = 92LL;
        uint64_t v86 = 399LL;
      }

      else
      {
        char v125 = *(void *)(a2 + 32);
        if (v125 != -1)
        {
          if ((*(_WORD *)(a1 + 32) & 2) != 0) {
            *(void *)(a2 + 24) = v124;
          }
          *(void *)(a2 + 32) = v125 + 1;
          uint64_t v22 = 0LL;
          goto LABEL_147;
        }

        if (!v9) {
          goto LABEL_146;
        }
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_node_count (overflow)\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  *(void *)(a1 + 8));
        uint64_t v22 = 92LL;
        uint64_t v86 = 400LL;
      }
    }

    else
    {
      uint64_t v74 = 0;
      unint64_t v13 = a1 + 56;
      do
      {
        if ((*(_DWORD *)a2 & 0x40) != 0) {
          uint64_t v75 = 0x40000;
        }
        else {
          uint64_t v75 = 0x80000;
        }
        uint64_t v132 = v48 & 0xFFFFFFFF00000000LL | v75 | v54;
        uint64_t v76 = sub_10003191C((unsigned __int16 *)a1, (_DWORD *)a2, v75 | v54, 3, 0LL);
        if (v76)
        {
          if (!v9) {
            goto LABEL_146;
          }
          uint64_t v99 = v76;
          sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_key_free_list offset %u\n",  v77,  v78,  v79,  v80,  v81,  v82,  v83,  *(void *)(a1 + 8));
          uint64_t v100 = 388LL;
          goto LABEL_138;
        }

        uint64_t v84 = *(unsigned __int16 *)(v13 + *(unsigned __int16 *)(a1 + 42) + v54 + 2);
        uint64_t v131 = v131 & 0xFFFFFFFF00000000LL | v54 | (v84 << 16);
        char v85 = sub_10003191C((unsigned __int16 *)a1, (_DWORD *)a2, v54 | (v84 << 16), 3, v134);
        if (v85)
        {
          if (!v9) {
            goto LABEL_146;
          }
          uint64_t v101 = v85;
          sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_key_free_list entry (%u, %u)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a1 + 8));
          uint64_t v100 = 389LL;
          uint64_t v102 = v101;
          goto LABEL_145;
        }

        v74 += v84;
        char v54 = *(unsigned __int16 *)(v13 + *(unsigned __int16 *)(a1 + 42) + v54);
        uint64_t v48 = v132;
      }

      while (v54 != 0xFFFF);
      uint64_t v55 = *(unsigned __int16 *)(a1 + 50);
      if (v55 >= v74)
      {
        uint64_t v35 = (void *)v134;
        goto LABEL_82;
      }

      if (!v9) {
        goto LABEL_146;
      }
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_key_free_list length (%u), given total key length (%u)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a1 + 8));
      uint64_t v22 = 92LL;
      uint64_t v86 = 390LL;
    }

    sub_100044E7C((char *)v86, 92);
LABEL_147:
    uint64_t v35 = (void *)v134;
    goto LABEL_67;
  }

uint64_t sub_1000104BC( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v12 = *a3;
  if ((_DWORD)a4 != 16)
  {
    char v23 = sub_10003A294(v12 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v24, v25, v26, v27, v28, v29, v30, v23);
    uint64_t v22 = 293LL;
    goto LABEL_34;
  }

  unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
  if ((v12 & 0xFFFFFFFFFFFFFFFLL) <= 1)
  {
    char v14 = sub_10003A294(v12 >> 60);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v15, v16, v17, v18, v19, v20, v21, v14);
    uint64_t v22 = 294LL;
LABEL_34:
    uint64_t v111 = 92LL;
    sub_100044E7C((char *)v22, 92);
    sub_100040E4C(a2, (uint64_t)a3, a4, a5, a6, v112, v113, v114, v124);
    return v111;
  }

  if (v13 <= 0xF && v13 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v33 = sub_10003A294(v12 >> 60);
    sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v34, v35, v36, v37, v38, v39, v40, v33);
    sub_100044E7C((char *)0x127, -2);
  }

  unint64_t v41 = *(void *)(a7 + 40);
  if (v41 <= v13)
  {
    unint64_t v41 = v13 + 1;
    *(void *)(a7 + 40) = v13 + 1;
  }

  unint64_t v42 = a3[1];
  if (v42 <= 1)
  {
    char v43 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid sibling_id (%llu)\n", v44, v45, v46, v47, v48, v49, v50, v43);
    uint64_t v22 = 296LL;
    goto LABEL_34;
  }

  if (v42 <= 0xF && (v42 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v51 = sub_10003A294(*a3 >> 60);
    sub_100040C68("%s (id %llu): invalid sibling_id (%llu)\n", v52, v53, v54, v55, v56, v57, v58, v51);
    sub_100044E7C((char *)0x129, -2);
    unint64_t v42 = a3[1];
    unint64_t v41 = *(void *)(a7 + 40);
  }

  unint64_t v59 = v42 + 1;
  if (v41 < v59)
  {
    *(void *)(a7 + 40) = v59;
    unint64_t v41 = v59;
  }

  if ((a6 - 777) <= 0xFFFFFD00)
  {
    char v60 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v61, v62, v63, v64, v65, v66, v67, v60);
    uint64_t v22 = 298LL;
    goto LABEL_34;
  }

  unint64_t v68 = *(void *)a5;
  if (*(void *)a5 <= 1uLL)
  {
    char v69 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid parent_id (%llu)\n", v70, v71, v72, v73, v74, v75, v76, v69);
    uint64_t v22 = 299LL;
    goto LABEL_34;
  }

  if (v68 <= 0xF && (v68 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v77 = sub_10003A294(*a3 >> 60);
    sub_100040C68("%s (id %llu): invalid parent_id (%llu)\n", v78, v79, v80, v81, v82, v83, v84, v77);
    sub_100044E7C((char *)0x12C, -2);
    unint64_t v68 = *(void *)a5;
    unint64_t v41 = *(void *)(a7 + 40);
  }

  unint64_t v85 = v68 + 1;
  if (v41 < v85) {
    *(void *)(a7 + 40) = v85;
  }
  CFIndex v86 = *(unsigned __int16 *)(a5 + 8);
  if ((unsigned __int16)(v86 - 767) <= 0xFD02u)
  {
    char v87 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v88, v89, v90, v91, v92, v93, v94, v87);
    uint64_t v22 = 301LL;
    goto LABEL_34;
  }

  if (v86 + 10 != a6)
  {
    char v103 = sub_10003A294(*a3 >> 60);
    sub_100040B90( "%s (id %llu): invalid value length (%u), given name_len (%u)\n",  v104,  v105,  v106,  v107,  v108,  v109,  v110,  v103);
    uint64_t v22 = 302LL;
    goto LABEL_34;
  }

  if (*(_BYTE *)(a5 + 10 + (v86 - 1)))
  {
    char v95 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid name (%.*s), given name_len (%u)\n", v96, v97, v98, v99, v100, v101, v102, v95);
    uint64_t v22 = 303LL;
    goto LABEL_34;
  }

  if (sub_10000E42C((UInt8 *)(a5 + 10), v86))
  {
    char v116 = sub_10003A294(*a3 >> 60);
    sub_100040C68("%s (id %llu): invalid name (%.*s)\n", v117, v118, v119, v120, v121, v122, v123, v116);
    sub_100044E7C((char *)0x130, -9);
  }

  return 0LL;
}

void sub_100010890( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v12 = *a3;
  if ((_DWORD)a4 != 8)
  {
    char v24 = sub_10003A294(v12 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v25, v26, v27, v28, v29, v30, v31, v24);
    sub_100040E4C(a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v32, v33, v34, v56);
    uint64_t v22 = 210LL;
    goto LABEL_5;
  }

  unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
  if ((v12 & 0xFFFFFFFFFFFFFFFLL) <= 1)
  {
    char v14 = sub_10003A294(v12 >> 60);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v15, v16, v17, v18, v19, v20, v21, v14);
    uint64_t v22 = 625LL;
LABEL_5:
    sub_100044E7C((char *)v22, 92);
    return;
  }

  if (v13 <= 0xF && (v13 > 7 || ((1LL << v12) & 0x8C) == 0))
  {
    char v37 = sub_10003A294(v12 >> 60);
    sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v38, v39, v40, v41, v42, v43, v44, v37);
    sub_100044E7C((char *)0x272, -2);
  }

  if (*(void *)(a7 + 40) <= v13) {
    *(void *)(a7 + 40) = v13 + 1;
  }
  if ((_DWORD)a6 != 4)
  {
    char v45 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v46, v47, v48, v49, v50, v51, v52, v45);
    sub_100040E4C(a2, (uint64_t)a3, 8LL, (uint64_t)a5, a6, v53, v54, v55, v57);
    uint64_t v22 = 211LL;
    goto LABEL_5;
  }

  sub_10000B51C(a3, a5, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8);
}

uint64_t sub_100010A38( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *(void *)(a2 + 48);
  if (!v14) {
    uint64_t v14 = *(void *)(a2 + 40);
  }
  unint64_t v15 = *(void *)a3;
  if ((*(_BYTE *)(v14 + 56) & 0x20) != 0)
  {
    char v26 = sub_10003A294(v15 >> 60);
    sub_100040B90("%s (id %llu): present on sealed volume\n", v27, v28, v29, v30, v31, v32, v33, v26);
    uint64_t v25 = 922LL;
  }

  else if ((_DWORD)a4 == 8)
  {
    unint64_t v16 = v15 & 0xFFFFFFFFFFFFFFFLL;
    if ((v15 & 0xFFFFFFFFFFFFFFFLL) > 1)
    {
      if (v16 <= 0xF && v16 - 6 <= 0xFFFFFFFFFFFFFFFBLL)
      {
        char v48 = sub_10003A294(v15 >> 60);
        sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v49, v50, v51, v52, v53, v54, v55, v48);
        sub_100044E7C((char *)0xF6, -2);
      }

      if (*(void *)(a7 + 40) <= v16) {
        *(void *)(a7 + 40) = v16 + 1;
      }
      if (a6 > 0x17)
      {
        if (*(_WORD *)(a5 + 4) == 6) {
          unsigned int v64 = 280;
        }
        else {
          unsigned int v64 = 152;
        }
        if (v64 < a6)
        {
          char v65 = sub_10003A294(*(void *)a3 >> 60);
          sub_100040C68("%s (id %llu): invalid value length (%u)\n", v66, v67, v68, v69, v70, v71, v72, v65);
        }

        if (*(void *)(a7 + 56)) {
          uint64_t v73 = 0LL;
        }
        else {
          uint64_t v73 = (_DWORD *)(a2 + 704);
        }
        sub_100006BA8(a2, a3, (_DWORD *)a5, v73, a5, a6, a7, a8);
        uint64_t v42 = v74;
        if ((_DWORD)v74 || v16 == 4)
        {
          if (!(_DWORD)v74) {
            return v42;
          }
          goto LABEL_10;
        }

        if ((*(void *)(*(void *)(a2 + 40) + 264LL) & 0x109LL) == 0x100) {
          int v75 = 6;
        }
        else {
          int v75 = 5;
        }
        if (v75 != *(unsigned __int16 *)(a5 + 4))
        {
          char v76 = sub_10003A294(*(void *)a3 >> 60);
          sub_100040C68("%s (id %llu): invalid state.major_version (%u)\n", v77, v78, v79, v80, v81, v82, v83, v76);
          sub_100044E7C((char *)0xF9, -6);
        }

        if (*(_WORD *)(a5 + 6))
        {
          char v84 = sub_10003A294(*(void *)a3 >> 60);
          sub_100040C68("%s (id %llu): invalid state.minor_version (%u)\n", v85, v86, v87, v88, v89, v90, v91, v84);
          sub_100044E7C((char *)0xFA, -6);
        }

        if (*(_DWORD *)(a5 + 8))
        {
          char v92 = sub_10003A294(*(void *)a3 >> 60);
          sub_100040C68("%s (id %llu): invalid state.cpflags (%u)\n", v93, v94, v95, v96, v97, v98, v99, v92);
          sub_100044E7C((char *)0xFB, -3);
        }

        if ((*(_BYTE *)(a5 + 12) & 0x18) != 0)
        {
          char v100 = sub_10003A294(*(void *)a3 >> 60);
          sub_100040C68( "%s (id %llu): invalid state.persistent_class (%u)\n",  v101,  v102,  v103,  v104,  v105,  v106,  v107,  v100);
          sub_100044E7C((char *)0xFC, -6);
        }

        if (!*(_DWORD *)(a5 + 16) && *(_WORD *)(a5 + 4) != 6)
        {
          char v108 = sub_10003A294(*(void *)a3 >> 60);
          sub_100040C68( "%s (id %llu): invalid state.key_os_version (%u)\n",  v109,  v110,  v111,  v112,  v113,  v114,  v115,  v108);
          sub_100044E7C((char *)0xFD, -6);
        }

        if (*(unsigned __int16 *)(a5 + 20) >= 2u)
        {
          char v116 = sub_10003A294(*(void *)a3 >> 60);
          sub_100040C68( "%s (id %llu): invalid state.key_revision (%u)\n",  v117,  v118,  v119,  v120,  v121,  v122,  v123,  v116);
          sub_100044E7C((char *)0xFE, -6);
        }

        LODWORD(v124) = *(unsigned __int16 *)(a5 + 22);
        int v125 = *(unsigned __int16 *)(a5 + 4);
        unsigned int v126 = (v124 >> 8) + v124;
        if (v125 == 6) {
          unsigned int v127 = (v124 >> 8) + v124;
        }
        else {
          unsigned int v127 = *(unsigned __int16 *)(a5 + 22);
        }
        if (v125 == 6) {
          unsigned int v128 = 256;
        }
        else {
          unsigned int v128 = 128;
        }
        if (v127 > v128)
        {
          char v129 = sub_10003A294(*(void *)a3 >> 60);
          sub_100040C68("%s (id %llu): invalid state.key_len (%u)\n", v130, v131, v132, v133, v134, v135, v136, v129);
          sub_100044E7C((char *)0xFF, -11);
          LODWORD(v124) = *(unsigned __int16 *)(a5 + 22);
          int v125 = *(unsigned __int16 *)(a5 + 4);
          unsigned int v126 = (v124 >> 8) + v124;
        }

        if (v125 == 6) {
          uint64_t v124 = v126;
        }
        else {
          uint64_t v124 = v124;
        }
        char v137 = sub_10003A294(*(void *)a3 >> 60);
        sub_100040B90( "%s (id %llu): invalid length (%u), given state.key_len (%u)\n",  v138,  v139,  v140,  v141,  v142,  v143,  v144,  v137);
        uint64_t v25 = 256LL;
      }

      else
      {
        char v56 = sub_10003A294(*(void *)a3 >> 60);
        sub_100040B90("%s (id %llu): invalid value length (%u)\n", v57, v58, v59, v60, v61, v62, v63, v56);
        uint64_t v25 = 247LL;
      }
    }

    else
    {
      char v17 = sub_10003A294(v15 >> 60);
      sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v18, v19, v20, v21, v22, v23, v24, v17);
      uint64_t v25 = 245LL;
    }
  }

  else
  {
    char v34 = sub_10003A294(v15 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v35, v36, v37, v38, v39, v40, v41, v34);
    uint64_t v25 = 244LL;
  }

  uint64_t v42 = 92LL;
  sub_100044E7C((char *)v25, 92);
LABEL_10:
  sub_100040E4C(a2, (uint64_t)a3, a4, a5, a6, v43, v44, v45, v145);
  return v42;
}

uint64_t sub_100010EDC( uint64_t a1, void *a2, uint64_t *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v15 = a2[6];
  if (!v15) {
    uint64_t v15 = a2[5];
  }
  if ((*(_BYTE *)(v15 + 56) & 0x20) != 0)
  {
    char v25 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040B90("%s (id %llu): file extent record present on sealed volume\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v33 = 921LL;
LABEL_13:
    uint64_t v22 = 92LL;
    sub_100044E7C((char *)v33, 92);
LABEL_14:
    sub_100040E4C((uint64_t)a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v19, v20, v21, v51);
    return v22;
  }

  if ((_DWORD)a4 != 16)
  {
    char v34 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v35, v36, v37, v38, v39, v40, v41, v34);
    uint64_t v33 = 212LL;
    goto LABEL_13;
  }

  if ((_DWORD)a6 != 24)
  {
    char v42 = sub_10003A294((unint64_t)*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v43, v44, v45, v46, v47, v48, v49, v42);
    uint64_t v33 = 213LL;
    goto LABEL_13;
  }

  uint64_t v22 = sub_1000154E4(a1, a2, a3, (uint64_t)a5, a7, a8);
  if ((_DWORD)v22) {
    goto LABEL_14;
  }
  sub_10000B5F0(a3, a5, v16, v17, v18, v19, v20, v21);
  uint64_t v22 = v23;
  if ((_DWORD)v23) {
    goto LABEL_14;
  }
  sub_100015B00((uint64_t)a2, a3, (uint64_t)a5, a7, a8);
  uint64_t v22 = v24;
  if ((_DWORD)v24) {
    goto LABEL_14;
  }
  return v22;
}

uint64_t sub_10001105C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v9 = a5;
  unint64_t v13 = *(void *)(*(void *)(a2 + 40) + 56LL);
  if ((v13 & 9) != 0) {
    unint64_t v14 = 12LL;
  }
  else {
    unint64_t v14 = 10LL;
  }
  unint64_t v15 = *(void *)a3;
  uint64_t v16 = a4;
  if (v14 > a4 || v14 + 766 < a4)
  {
    char v18 = sub_10003A294(v15 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v19, v20, v21, v22, v23, v24, v25, v18);
    uint64_t v26 = 92LL;
    uint64_t v27 = 275LL;
LABEL_9:
    sub_100044E7C((char *)v27, 92);
LABEL_27:
    sub_100040E4C(a2, a3, a4, v9, a6, v28, v29, v30, v195);
    return v26;
  }

  uint64_t v31 = a1;
  unint64_t v32 = v15 & 0xFFFFFFFFFFFFFFFLL;
  if ((v13 & 9) == 0)
  {
    uint64_t v33 = (UInt8 *)(a3 + 10);
    CFIndex v35 = *(unsigned __int16 *)(a3 + 8);
    int v36 = -1;
    if (v32) {
      goto LABEL_12;
    }
LABEL_20:
    char v46 = sub_10003A294(v15 >> 60);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v47, v48, v49, v50, v51, v52, v53, v46);
    uint64_t v26 = 92LL;
    uint64_t v45 = 276LL;
    goto LABEL_25;
  }

  uint64_t v33 = (UInt8 *)(a3 + 12);
  unsigned int v34 = *(_DWORD *)(a3 + 8);
  CFIndex v35 = v34 & 0x3FF;
  int v36 = v34 >> 10;
  if (!v32) {
    goto LABEL_20;
  }
LABEL_12:
  if (v32 <= 0xF && (v32 > 7 || ((1LL << v15) & 0x8E) == 0))
  {
    uint64_t v196 = v33;
    uint64_t v200 = a7;
    uint64_t v202 = a8;
    CFIndex v204 = v35;
    char v71 = sub_10003A294(v15 >> 60);
    sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v72, v73, v74, v75, v76, v77, v78, v71);
    sub_100044E7C((char *)0x115, -2);
    a8 = v202;
    CFIndex v35 = v204;
    uint64_t v33 = v196;
    uint64_t v31 = a1;
    a7 = v200;
  }

  if (*(void *)(a7 + 40) <= v32) {
    *(void *)(a7 + 40) = v32 + 1;
  }
  if ((unsigned __int16)(v35 - 767) <= 0xFD02u)
  {
    char v37 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): invalid name_len (%u)\n", v38, v39, v40, v41, v42, v43, v44, v37);
    uint64_t v26 = 92LL;
    uint64_t v45 = 278LL;
LABEL_25:
    sub_100044E7C((char *)v45, 92);
LABEL_26:
    uint64_t v9 = a5;
    goto LABEL_27;
  }

  if (v14 + v35 != v16)
  {
    char v62 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90( "%s (id %llu): invalid key length (%u), given name_len (%u)\n",  v63,  v64,  v65,  v66,  v67,  v68,  v69,  v62);
    uint64_t v26 = 92LL;
    uint64_t v45 = 279LL;
    goto LABEL_25;
  }

  if (v33[(v35 - 1)])
  {
    char v54 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): invalid name (%.*s), given name_len (%u)\n", v55, v56, v57, v58, v59, v60, v61, v54);
    uint64_t v26 = 92LL;
    uint64_t v45 = 280LL;
    goto LABEL_25;
  }

  uint64_t v197 = (v35 - 1);
  uint64_t v199 = v31;
  uint64_t v201 = a7;
  uint64_t v203 = a8;
  unint64_t v79 = (unint64_t)v33;
  unsigned int v80 = v35;
  if (sub_10000E42C(v33, v35))
  {
    char v81 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040C68("%s (id %llu): invalid name (%.*s)\n", v82, v83, v84, v85, v86, v87, v88, v81);
    sub_100044E7C((char *)0x119, -9);
  }

  unsigned int v205 = v80;
  if ((v13 & 9) != 0)
  {
    int v207 = -1;
    if (!sub_1000034D8( v79,  v197,  (v13 >> 3) & 1,  (void (*)(_OWORD *, uint64_t, uint64_t))sub_100015F10,  (uint64_t)&v207))
    {
      int v89 = v207 & 0x3FFFFF;
      if ((v207 & 0x3FFFFF) != v36)
      {
        char v90 = sub_10003A294(*(void *)a3 >> 60);
        sub_100040B90( "%s (id %llu): invalid hash (0x%x, expected 0x%x) of name (%.*s)\n",  v91,  v92,  v93,  v94,  v95,  v96,  v97,  v90);
        sub_100044E7C((char *)0x11A, 92);
        uint64_t v102 = sub_10002926C((__int128 *)a3, a4, v89, (_DWORD *)(a2 + 704), v98, v99, v100, v101);
        if ((_DWORD)v102)
        {
          uint64_t v26 = v102;
          goto LABEL_26;
        }
      }
    }
  }

  if (a6 <= 0x11)
  {
    char v103 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v104, v105, v106, v107, v108, v109, v110, v103);
    uint64_t v26 = 92LL;
    uint64_t v45 = 283LL;
    goto LABEL_25;
  }

  uint64_t v9 = a5;
  unint64_t v111 = *(void *)a5;
  if (*(void *)a5 <= 1uLL)
  {
    char v112 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): invalid file_id (%llu) (%s)\n", v113, v114, v115, v116, v117, v118, v119, v112);
    uint64_t v26 = 92LL;
    uint64_t v27 = 284LL;
    goto LABEL_9;
  }

  if (v111 <= 0xF && (v111 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v120 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040C68("%s (id %llu): invalid file_id (%llu) (%s)\n", v121, v122, v123, v124, v125, v126, v127, v120);
    sub_100044E7C((char *)0x11D, -2);
    unint64_t v111 = *(void *)a5;
  }

  uint64_t v129 = v201;
  unsigned int v128 = v203;
  unsigned int v130 = v205;
  if (*(void *)(v201 + 40) < v111 + 1)
  {
    *(void *)(v201 + 40) = v111 + 1;
    unint64_t v111 = *(void *)a5;
  }

  if (v111 == 2)
  {
    char v131 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040C68( "%s (id %llu): file_id (%llu) and name (%.*s) mismatch for root directory\n",  v132,  v133,  v134,  v135,  v136,  v137,  v138,  v131);
    sub_100044E7C((char *)0x11E, -9);
    unsigned int v128 = v203;
    unsigned int v130 = v205;
    uint64_t v129 = v201;
    unint64_t v111 = *(void *)a5;
  }

  if (v111 == 3)
  {
    char v139 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040C68( "%s (id %llu): file_id (%llu) and name (%.*s) mismatch for private directory\n",  v140,  v141,  v142,  v143,  v144,  v145,  v146,  v139);
    sub_100044E7C((char *)0x11F, -9);
    uint64_t v129 = v201;
    unsigned int v128 = v203;
  }

  if (v32 == 7) {
    goto LABEL_64;
  }
LABEL_57:
  unsigned int v147 = *(unsigned __int16 *)(a5 + 16);
  if (v147 >= 0x10)
  {
    char v148 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040C68("%s (id %llu): unknown flags (0x%hx)\n", v149, v150, v151, v152, v153, v154, v155, v148);
    if (*(void *)(*(void *)(v199 + 8) + 1384LL) <= 0x83B5A93981BC1uLL
      && sub_1000428C4( qword_10008DB70,  "Unset invalid flags? (0x%llx) ",  v156,  v157,  v158,  v159,  v160,  v161,  *(_BYTE *)(a5 + 16) & 0xF0))
    {
      *(_WORD *)(a5 + 16) &= 0xFu;
      *uint64_t v203 = 1;
    }

    sub_100044E7C((char *)0x121, -3);
    LOWORD(v147) = *(_WORD *)(a5 + 16);
    uint64_t v129 = v201;
    unsigned int v128 = v203;
  }

  unsigned int v162 = v147 & 0xF;
  if (v162 <= 0xE)
  {
    int v163 = 1 << v162;
    if ((v163 & 0x1556) != 0) {
      goto LABEL_64;
    }
    if ((v163 & 0x4001) != 0)
    {
      char v176 = sub_10003A294(*(void *)a3 >> 60);
      sub_100040B90("%s (id %llu): invalid type (%u)\n", v177, v178, v179, v180, v181, v182, v183, v176);
      uint64_t v26 = 92LL;
      uint64_t v27 = 290LL;
      goto LABEL_9;
    }
  }

  char v184 = sub_10003A294(*(void *)a3 >> 60);
  sub_100040C68("%s (id %llu): invalid type (%u)\n", v185, v186, v187, v188, v189, v190, v191, v184);
  sub_100044E7C((char *)0x123, -5);
  uint64_t v129 = v201;
  unsigned int v128 = v203;
LABEL_64:
  uint64_t v164 = v199;
  uint64_t v165 = sub_1000134C8( v199,  a2,  a3,  (unsigned __int16 *)(a5 + 18),  (a6 - 18),  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_100015F4C,  v129,  v128,  0LL);
  if ((_DWORD)v165)
  {
    uint64_t v26 = v165;
    char v166 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): invalid xfields\n", v167, v168, v169, v170, v171, v172, v173, v166);
    goto LABEL_27;
  }

  if (v32 == 3)
  {
    if (v205 < 0xE || (v164 = v199, uint64_t v129 = v201, strncmp("tmp-ino-clone-", (const char *)v79, 0xEuLL)))
    {
      int v174 = *(_WORD *)(a5 + 16) & 0xF;
      if (v174 == 10)
      {
        uint64_t v175 = (void *)(v129 + 16);
        goto LABEL_79;
      }

      uint64_t v175 = (void *)v129;
      if (v174 == 8)
      {
LABEL_79:
        --*v175;
        goto LABEL_80;
      }

      if (v174 != 4)
      {
        uint64_t v175 = (void *)(v129 + 24);
        goto LABEL_79;
      }

      if ((*(void *)a5 & 0xFFFFFFFFFFFFFFFELL) != 2)
      {
        uint64_t v175 = (void *)(v129 + 8);
        goto LABEL_79;
      }
    }
  }

LABEL_80:
  uint64_t v192 = *(void *)(v129 + 56);
  if (v192) {
    char v193 = 0LL;
  }
  else {
    char v193 = (_DWORD *)(a2 + 704);
  }
  sub_1000290CC(v164, a2, v192, (__int128 *)a3, a4, a5, a6, v193);
  return v194;
}

      if ((v73 & 1) != 0) {
        goto LABEL_81;
      }
      uint64_t v48 = *v70;
      uint64_t v49 = *v70 & 0xFFFFFFFFFFFFFFFLL;
      if (v23 >= v49)
      {
        if (v23 == v49)
        {
          if (v25 == (*(void *)a4 & 0xFFFFFFFFFFFFFFFLL)) {
            goto LABEL_84;
          }
          HIDWORD(v73) = 1;
        }

        else
        {
          v77[0] = *v70;
          char v54 = *(void *)(a4 + 8);
          uint64_t v74 = (v23 - v48) & 0xFFFFFFFFFFFFFFFLL | v65;
          uint64_t v75 = v54;
          uint64_t v76 = *(_DWORD *)(a4 + 16);
          HIDWORD(v73) = 1;
          uint64_t v52 = sub_10001F270(v69, v77, &v74, *(void *)(a2 + 56), 2, 1);
          if ((_DWORD)v52) {
            return v52;
          }
        }

  uint64_t v57 = 92;
LABEL_81:
  sub_100044E7C((char *)v34, v57);
LABEL_12:
  if (v60) {
    free(v60);
  }
  if (v16) {
    free(v16);
  }
  return v17;
}

uint64_t sub_100011870( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = *(void *)(a2 + 48);
  if (!v13) {
    uint64_t v13 = *(void *)(a2 + 40);
  }
  unint64_t v14 = *a3;
  if ((*(_BYTE *)(v13 + 57) & 2) != 0)
  {
    char v25 = sub_10003A294(v14 >> 60);
    sub_100040B90("%s (id %llu): invalid key on expanded-records volume\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v24 = 1399LL;
  }

  else if ((_DWORD)a4 == 8)
  {
    unint64_t v15 = v14 & 0xFFFFFFFFFFFFFFFLL;
    if ((v14 & 0xFFFFFFFFFFFFFFFLL) > 1)
    {
      if (v15 <= 0xF && v15 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        char v42 = sub_10003A294(v14 >> 60);
        sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v43, v44, v45, v46, v47, v48, v49, v42);
        sub_100044E7C((char *)0x133, -2);
      }

      unint64_t v50 = *(void *)(a7 + 40);
      if (v50 <= v15)
      {
        unint64_t v50 = v15 + 1;
        *(void *)(a7 + 40) = v15 + 1;
      }

      if ((_DWORD)a6 == 32)
      {
        unint64_t v51 = a5[2];
        if (v51 == 1)
        {
          char v52 = sub_10003A294(*a3 >> 60);
          sub_100040B90("%s (id %llu): invalid chained_key (%llu)\n", v53, v54, v55, v56, v57, v58, v59, v52);
          uint64_t v24 = 310LL;
        }

        else
        {
          if (v51 <= 0xF && v51 > 3)
          {
            char v73 = sub_10003A294(*a3 >> 60);
            sub_100040C68("%s (id %llu): invalid chained_key (%llu)\n", v74, v75, v76, v77, v78, v79, v80, v73);
            sub_100044E7C((char *)0x137, -2);
            unint64_t v51 = a5[2];
            unint64_t v50 = *(void *)(a7 + 40);
          }

          unint64_t v81 = v51 + 1;
          if (v50 < v81) {
            *(void *)(a7 + 40) = v81;
          }
          if (a5[3])
          {
            sub_100016B64(v15, a5);
            uint64_t v68 = v82;
            if (!(_DWORD)v82) {
              return v68;
            }
            goto LABEL_21;
          }

          char v83 = sub_10003A294(*a3 >> 60);
          sub_100040B90("%s (id %llu): invalid gen_count (%llu)\n", v84, v85, v86, v87, v88, v89, v90, v83);
          uint64_t v24 = 312LL;
        }
      }

      else
      {
        char v60 = sub_10003A294(*a3 >> 60);
        sub_100040B90("%s (id %llu): invalid value length (%u)\n", v61, v62, v63, v64, v65, v66, v67, v60);
        uint64_t v24 = 308LL;
      }
    }

    else
    {
      char v16 = sub_10003A294(v14 >> 60);
      sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v17, v18, v19, v20, v21, v22, v23, v16);
      uint64_t v24 = 306LL;
    }
  }

  else
  {
    char v33 = sub_10003A294(v14 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v34, v35, v36, v37, v38, v39, v40, v33);
    uint64_t v24 = 305LL;
  }

  uint64_t v68 = 92LL;
  sub_100044E7C((char *)v24, 92);
LABEL_21:
  sub_100040E4C(a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v69, v70, v71, v91);
  return v68;
}

uint64_t sub_100011B10(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6)
{
  int v17 = 0;
  uint64_t v14 = sub_10000E138(a2, a3, a4, a5, a6, 1, &v17);
  return v14;
}

uint64_t sub_100011BB0( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6, uint64_t a7)
{
  unint64_t v12 = *a3;
  if ((_DWORD)a4 != 8)
  {
    char v23 = sub_10003A294(v12 >> 60);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v24, v25, v26, v27, v28, v29, v30, v23);
    uint64_t v22 = 530LL;
    goto LABEL_7;
  }

  if ((_DWORD)a6 != 8)
  {
    char v31 = sub_10003A294(v12 >> 60);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v32, v33, v34, v35, v36, v37, v38, v31);
    uint64_t v22 = 531LL;
    goto LABEL_7;
  }

  unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
  if ((v12 & 0xFFFFFFFFFFFFFFFLL) <= 1)
  {
    char v14 = sub_10003A294(v12 >> 60);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v15, v16, v17, v18, v19, v20, v21, v14);
    uint64_t v22 = 532LL;
LABEL_7:
    uint64_t v39 = 92LL;
    sub_100044E7C((char *)v22, 92);
    sub_100040E4C(a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v40, v41, v42, v73);
    return v39;
  }

  if (v13 <= 0xF && v13 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v46 = sub_10003A294(v12 >> 60);
    sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v47, v48, v49, v50, v51, v52, v53, v46);
    sub_100044E7C((char *)0x215, -2);
  }

  unint64_t v54 = *(void *)(a7 + 40);
  if (v54 <= v13)
  {
    unint64_t v54 = v13 + 1;
    *(void *)(a7 + 40) = v13 + 1;
  }

  unint64_t v55 = *a5;
  if (*a5 <= 1)
  {
    char v56 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): invalid file_id (%llu)\n", v57, v58, v59, v60, v61, v62, v63, v56);
    uint64_t v22 = 534LL;
    goto LABEL_7;
  }

  if (v55 <= 0xF)
  {
    char v64 = sub_10003A294(*a3 >> 60);
    sub_100040C68("%s (id %llu): invalid file_id (%llu)\n", v65, v66, v67, v68, v69, v70, v71, v64);
    sub_100044E7C((char *)0x217, -2);
    unint64_t v55 = *a5;
    unint64_t v54 = *(void *)(a7 + 40);
  }

  unint64_t v72 = v55 + 1;
  uint64_t v39 = 0LL;
  if (v54 < v72) {
    *(void *)(a7 + 40) = v72;
  }
  return v39;
}

uint64_t sub_100011DBC( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  unint64_t v13 = *a3;
  if ((_DWORD)a4 == 16)
  {
    unint64_t v16 = v13 & 0xFFFFFFFFFFFFFFFLL;
    unint64_t v17 = a3[1];
    unint64_t v18 = HIBYTE(v17);
    if (HIBYTE(v17) != 2)
    {
      if ((_DWORD)v18 != 1)
      {
        unint64_t v19 = v13 >> 60;
        if ((_DWORD)v18)
        {
          char v58 = sub_10003A294(v19);
          sub_100040C68("%s (id %llu): Unknown type (0x%x)\n", v59, v60, v61, v62, v63, v64, v65, v58);
          sub_100044E7C((char *)0x3AF, -5);
          return 0LL;
        }

        char v20 = sub_10003A294(v19);
        sub_100040B90("%s (id %llu): Invalid type (0x%x)\n", v21, v22, v23, v24, v25, v26, v27, v20);
        uint64_t v28 = 942LL;
        goto LABEL_7;
      }

      if (a6 <= 2)
      {
        char v50 = sub_10003A294(v13 >> 60);
        sub_100040B90("%s (id %llu): invalid value length (%u)\n", v51, v52, v53, v54, v55, v56, v57, v50);
        uint64_t v28 = 938LL;
        goto LABEL_7;
      }

      if (v16 <= 1)
      {
        char v76 = sub_10003A294(v13 >> 60);
        sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v77, v78, v79, v80, v81, v82, v83, v76);
        uint64_t v28 = 939LL;
        goto LABEL_7;
      }

      unint64_t v142 = *(unsigned int *)(*(void *)(a1 + 8) + 36LL);
      if (v16 <= 0xF && v16 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        char v143 = sub_10003A294(v13 >> 60);
        sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v144, v145, v146, v147, v148, v149, v150, v143);
        sub_100044E7C((char *)0x3AC, -2);
      }

      if (*(void *)(a7 + 40) <= v16) {
        *(void *)(a7 + 40) = v16 + 1;
      }
      if ((a3[1] & 0xFFFFFFFFFFFFFFLL) % v142)
      {
        char v151 = sub_10003A294(*a3 >> 60);
        sub_100040B90( "%s (id %llu): Logical address %llu not a multiple of the block size (%u)\n",  v152,  v153,  v154,  v155,  v156,  v157,  v158,  v151);
        uint64_t v28 = 941LL;
        goto LABEL_7;
      }

      uint64_t v161 = sub_100016130(a1, a2, (uint64_t)a3, a5);
      goto LABEL_52;
    }

    if (a6 <= 0x19)
    {
      char v42 = sub_10003A294(v13 >> 60);
      sub_100040B90("%s (id %llu): invalid value length (%u)\n", v43, v44, v45, v46, v47, v48, v49, v42);
      uint64_t v28 = 1319LL;
      goto LABEL_7;
    }

    uint64_t v67 = v17 & 0x1FFFFFFFFFFFFFLL;
    if ((*(_BYTE *)(*(void *)(a2 + 40) + 48LL) & 8) == 0)
    {
      char v68 = sub_10003A294(v13 >> 60);
      sub_100040C68( "%s (id %llu): found attribution tag on a volume that doesn't support them\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v68);
      sub_100044E7C((char *)0x528, -5);
    }

    if (v16 == 9)
    {
      if (*(void *)(a7 + 40) > 9uLL)
      {
        uint64_t v191 = 0LL;
        if (v67) {
          goto LABEL_25;
        }
        goto LABEL_24;
      }

      uint64_t v191 = 0LL;
      *(void *)(a7 + 40) = 10LL;
      if (!v67)
      {
LABEL_24:
        char v92 = sub_10003A294(*a3 >> 60);
        sub_100040C68("%s (id %llu): invalid hash (0)\n", v93, v94, v95, v96, v97, v98, v99, v92);
        sub_100044E7C((char *)0x52A, -7);
      }
    }

    else
    {
      char v84 = sub_10003A294(*a3 >> 60);
      sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v85, v86, v87, v88, v89, v90, v91, v84);
      sub_100044E7C((char *)0x529, 92);
      uint64_t v191 = v16;
      if (!v67) {
        goto LABEL_24;
      }
    }

LABEL_59:
      if (!(_DWORD)v37) {
        return v37;
      }
      goto LABEL_8;
    }

    char v162 = sub_10003A294(*a3 >> 60);
    sub_100040B90("%s (id %llu): signing id does not exist\n", v163, v164, v165, v166, v167, v168, v169, v162);
    sub_100044E7C((char *)0x52D, 92);
    if (*(void *)(a7 + 56)) {
      uint64_t v170 = 0LL;
    }
    else {
      uint64_t v170 = (_DWORD *)(a2 + 704);
    }
    uint64_t v161 = sub_100005D80(v170, v16, v67, 1LL);
LABEL_52:
    uint64_t v37 = v161;
    goto LABEL_59;
  }

  char v29 = sub_10003A294(v13 >> 60);
  sub_100040B90("%s (id %llu): invalid key length (%u)\n", v30, v31, v32, v33, v34, v35, v36, v29);
  uint64_t v28 = 937LL;
LABEL_7:
  uint64_t v37 = 92LL;
  sub_100044E7C((char *)v28, 92);
LABEL_8:
  sub_100040E4C(a2, (uint64_t)a3, a4, a5, a6, v38, v39, v40, v187);
  return v37;
}

    unint64_t v13 = v54;
    uint64_t v11 = v54[4];
    if (!v11) {
      goto LABEL_60;
    }
  }

  sub_100040B90("last reap list object 0x%llx doesn't match tail 0x%llx\n", v16, v17, v18, v19, v20, v21, v22, v11);
  uint64_t v9 = 92LL;
  uint64_t v10 = 103LL;
LABEL_62:
  sub_100044E7C((char *)v10, 92);
LABEL_63:
  if (v54) {
    free(v54);
  }
  return v9;
}

uint64_t sub_100012450( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  unint64_t v16 = *(void *)a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v17 = *(void *)a3 >> 60;
  if ((_DWORD)v17 == 14) {
    LODWORD(v17) = *(unsigned __int8 *)(a3 + 8);
  }
  if ((_DWORD)a4 != 28)
  {
    char v28 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v29, v30, v31, v32, v33, v34, v35, v28);
    uint64_t v26 = 92LL;
    uint64_t v27 = 1168LL;
    goto LABEL_7;
  }

  if (a6 <= 0x17)
  {
    char v18 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v19, v20, v21, v22, v23, v24, v25, v18);
    uint64_t v26 = 92LL;
    uint64_t v27 = 1169LL;
LABEL_7:
    sub_100044E7C((char *)v27, 92);
LABEL_8:
    sub_100040E4C(a2, a3, a4, a5, a6, v36, v37, v38, v124);
    return v26;
  }

  if (v16 <= 1)
  {
    char v40 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v41, v42, v43, v44, v45, v46, v47, v40);
    uint64_t v26 = 92LL;
    uint64_t v27 = 1170LL;
    goto LABEL_7;
  }

  if (v16 <= 0xF && (v16 > 7 || ((1LL << *(_BYTE *)a3) & 0x8C) == 0))
  {
    char v49 = sub_10003A294(v17);
    sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v50, v51, v52, v53, v54, v55, v56, v49);
    sub_100044E7C((char *)0x493, -2);
  }

  if (*(void *)(a7 + 40) <= v16) {
    *(void *)(a7 + 40) = v16 + 1;
  }
  if (!*(void *)(a3 + 12))
  {
    char v57 = sub_10003A294(v17);
    sub_100040C68("%s (id %llu): invalid atime (0)\n", v58, v59, v60, v61, v62, v63, v64, v57);
    sub_100044E7C((char *)0x58E, -2);
  }

  unint64_t v65 = *(void *)(a3 + 20);
  if (v65 <= 1)
  {
    char v66 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid file_id (%llu)\n", v67, v68, v69, v70, v71, v72, v73, v66);
    uint64_t v26 = 92LL;
    uint64_t v27 = 1172LL;
    goto LABEL_7;
  }

  if (v65 <= 0xF && (v65 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v74 = sub_10003A294(v17);
    sub_100040C68("%s (id %llu): invalid file_id (%llu)\n", v75, v76, v77, v78, v79, v80, v81, v74);
    sub_100044E7C((char *)0x495, -2);
    unint64_t v65 = *(void *)(a3 + 20);
  }

  unint64_t v82 = *(void *)(a7 + 40);
  unint64_t v83 = v65 + 1;
  if (v82 < v83)
  {
    *(void *)(a7 + 40) = v83;
    unint64_t v82 = v83;
  }

  unint64_t v84 = *(void *)(a5 + 8);
  if (v84 <= 1)
  {
    char v85 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid dstream_id (%llu)\n", v86, v87, v88, v89, v90, v91, v92, v85);
    uint64_t v26 = 92LL;
    uint64_t v27 = 1175LL;
    goto LABEL_7;
  }

  if (v84 <= 0xF && (v84 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v93 = sub_10003A294(v17);
    sub_100040C68("%s (id %llu): invalid dstream_id (%llu)\n", v94, v95, v96, v97, v98, v99, v100, v93);
    sub_100044E7C((char *)0x498, -2);
    unint64_t v84 = *(void *)(a5 + 8);
    unint64_t v82 = *(void *)(a7 + 40);
  }

  unint64_t v101 = v84 + 1;
  if (v82 < v101) {
    *(void *)(a7 + 40) = v101;
  }
  if ((*(_WORD *)(a5 + 18) & 0xFFC3) != 0)
  {
    char v102 = sub_10003A294(v17);
    sub_100040C68("%s (id %llu): unknown flags (0x%x)\n", v103, v104, v105, v106, v107, v108, v109, v102);
    if (*(void *)(*(void *)(a1 + 8) + 1384LL) <= 0x83B5A93981BC1uLL
      && sub_1000428C4( qword_10008DB70,  "Unset invalid flags? (0x%llx) ",  v110,  v111,  v112,  v113,  v114,  v115,  0))
    {
      *(_DWORD *)(a5 + 16) &= 0x3CFFFFu;
      *a8 = 1;
    }

    sub_100044E7C((char *)0x499, -3);
  }

  uint64_t v26 = sub_1000134C8( a1,  a2,  a3,  (unsigned __int16 *)(a5 + 24),  (a6 - 24),  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_100016440,  a7,  a8,  0LL);
  if ((_DWORD)v26)
  {
    char v116 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid xfields\n", v117, v118, v119, v120, v121, v122, v123, v116);
    goto LABEL_8;
  }

  return v26;
}

uint64_t sub_10001280C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v14 = *(void *)a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v15 = *(void *)a3 >> 60;
  if ((_DWORD)v15 == 14) {
    LODWORD(v15) = *(unsigned __int8 *)(a3 + 8);
  }
  if ((_DWORD)a4 != 20)
  {
    char v25 = sub_10003A294(v15);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v24 = 1178LL;
    goto LABEL_27;
  }

  if ((_DWORD)a6 != 8)
  {
    char v33 = sub_10003A294(v15);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v34, v35, v36, v37, v38, v39, v40, v33);
    uint64_t v24 = 1179LL;
    goto LABEL_27;
  }

  if (v14 <= 1)
  {
    char v16 = sub_10003A294(v15);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v17, v18, v19, v20, v21, v22, v23, v16);
    uint64_t v24 = 1180LL;
LABEL_27:
    uint64_t v78 = 92LL;
    sub_100044E7C((char *)v24, 92);
LABEL_28:
    sub_100040E4C(a2, a3, a4, (uint64_t)a5, a6, v79, v80, v81, v92);
    return v78;
  }

  if (v14 <= 0xF && (v14 > 7 || ((1LL << *(_BYTE *)a3) & 0x8C) == 0))
  {
    char v42 = sub_10003A294(v15);
    sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v43, v44, v45, v46, v47, v48, v49, v42);
    sub_100044E7C((char *)0x49D, -2);
  }

  unint64_t v50 = *(void *)(a7 + 40);
  if (v50 <= v14)
  {
    unint64_t v50 = v14 + 1;
    *(void *)(a7 + 40) = v14 + 1;
  }

  unint64_t v51 = *(void *)(a3 + 12);
  if (v51 <= 1)
  {
    char v52 = sub_10003A294(v15);
    sub_100040B90("%s (id %llu): invalid file_id (%llu)\n", v53, v54, v55, v56, v57, v58, v59, v52);
    uint64_t v24 = 1182LL;
    goto LABEL_27;
  }

  if (v51 <= 0xF && (v51 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v60 = sub_10003A294(v15);
    sub_100040C68("%s (id %llu): invalid file_id (%llu)\n", v61, v62, v63, v64, v65, v66, v67, v60);
    sub_100044E7C((char *)0x49F, -2);
    unint64_t v51 = *(void *)(a3 + 12);
    unint64_t v50 = *(void *)(a7 + 40);
  }

  unint64_t v68 = v51 + 1;
  if (v50 < v68)
  {
    *(void *)(a7 + 40) = v68;
    unint64_t v50 = v68;
  }

  unint64_t v69 = *a5;
  if ((unint64_t)*a5 <= 1)
  {
    char v70 = sub_10003A294(v15);
    sub_100040B90("%s (id %llu): invalid dstream_id (%llu)\n", v71, v72, v73, v74, v75, v76, v77, v70);
    uint64_t v24 = 1184LL;
    goto LABEL_27;
  }

  if (v69 <= 0xF && (v69 > 7 || ((1LL << v69) & 0x8C) == 0))
  {
    char v83 = sub_10003A294(v15);
    sub_100040C68("%s (id %llu): invalid dstream_id (%llu)\n", v84, v85, v86, v87, v88, v89, v90, v83);
    sub_100044E7C((char *)0x4A1, -2);
    unint64_t v69 = *a5;
    unint64_t v50 = *(void *)(a7 + 40);
  }

  unint64_t v91 = v69 + 1;
  if (v50 < v91) {
    *(void *)(a7 + 40) = v91;
  }
  uint64_t v78 = sub_10000B7CC((void *)a3, a5, a3, a4, (uint64_t)a5, a6, a7, a8);
  if ((_DWORD)v78) {
    goto LABEL_28;
  }
  return v78;
}

uint64_t sub_100012AB8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  unint64_t v16 = *(void *)a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v17 = *(void *)a3 >> 60;
  if ((_DWORD)v17 == 14) {
    LODWORD(v17) = *(unsigned __int8 *)(a3 + 8);
  }
  if ((_DWORD)a4 != 12)
  {
    char v28 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v29, v30, v31, v32, v33, v34, v35, v28);
    uint64_t v26 = 92LL;
    uint64_t v27 = 1186LL;
    goto LABEL_7;
  }

  if (a6 <= 0x33)
  {
    char v18 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v19, v20, v21, v22, v23, v24, v25, v18);
    uint64_t v26 = 92LL;
    uint64_t v27 = 1187LL;
LABEL_7:
    sub_100044E7C((char *)v27, 92);
LABEL_8:
    sub_100040E4C(a2, a3, a4, a5, a6, v36, v37, v38, v126);
    return v26;
  }

  if (v16 <= 1)
  {
    char v40 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v41, v42, v43, v44, v45, v46, v47, v40);
    uint64_t v26 = 92LL;
    uint64_t v27 = 1188LL;
    goto LABEL_7;
  }

  if (v16 <= 0xF && v16 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v49 = sub_10003A294(v17);
    sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v50, v51, v52, v53, v54, v55, v56, v49);
    sub_100044E7C((char *)0x4A5, -2);
  }

  unint64_t v57 = *(void *)(a7 + 40);
  if (v57 <= v16)
  {
    unint64_t v57 = v16 + 1;
    *(void *)(a7 + 40) = v16 + 1;
  }

  unint64_t v58 = *(void *)(a5 + 32);
  if (v58 == 1)
  {
    char v59 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid chained_key (%llu)\n", v60, v61, v62, v63, v64, v65, v66, v59);
    uint64_t v26 = 92LL;
    uint64_t v27 = 1192LL;
    goto LABEL_7;
  }

  if (v58 <= 0xF && v58 > 3)
  {
    char v67 = sub_10003A294(v17);
    sub_100040C68("%s (id %llu): invalid chained_key (%llu)\n", v68, v69, v70, v71, v72, v73, v74, v67);
    sub_100044E7C((char *)0x4A9, -2);
    unint64_t v58 = *(void *)(a5 + 32);
    unint64_t v57 = *(void *)(a7 + 40);
  }

  unint64_t v75 = v58 + 1;
  if (v57 < v75) {
    *(void *)(a7 + 40) = v75;
  }
  if (!*(void *)(a5 + 40))
  {
    char v76 = sub_10003A294(v17);
    sub_100040C68("%s (id %llu): invalid gen_count (%llu)\n", v77, v78, v79, v80, v81, v82, v83, v76);
    sub_100044E7C((char *)0x4AA, -8);
  }

  unsigned int v84 = *(_DWORD *)(a5 + 48);
  if (v84 >= 0x1000)
  {
    char v85 = sub_10003A294(v17);
    sub_100040C68("%s (id %llu): unknown flags (0x%x)\n", v86, v87, v88, v89, v90, v91, v92, v85);
    if (*(void *)(*(void *)(a1 + 8) + 1384LL) <= 0x83B5A93981BC1uLL
      && sub_1000428C4(qword_10008DB70, "Unset invalid flags? (0x%llx) ", v93, v94, v95, v96, v97, v98, 0))
    {
      *(_DWORD *)(a5 + 48) &= 0xFFFu;
      *a8 = 1;
    }

    sub_100044E7C((char *)0x4AB, -3);
    unsigned int v84 = *(_DWORD *)(a5 + 48);
  }

  if ((v84 & 0x200) != 0)
  {
    char v99 = sub_10003A294(v17);
    sub_100040B90( "%s (id %llu): found dir-stats object (chained-key %llu) that is unexpectedly being moved\n",  v100,  v101,  v102,  v103,  v104,  v105,  v106,  v99);
    sub_100044E7C((char *)0x5A8, 92);
  }

  __int128 v129 = 0u;
  __int128 v130 = 0u;
  __int128 v127 = 0u;
  __int128 v128 = 0u;
  uint64_t v107 = sub_1000134C8( a1,  a2,  a3,  (unsigned __int16 *)(a5 + 52),  (a6 - 52),  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_100016584,  a7,  a8,  (uint64_t)&v127);
  if ((_DWORD)v107)
  {
    uint64_t v26 = v107;
    char v108 = sub_10003A294(v17);
    sub_100040B90("%s (id %llu): invalid xfields\n", v109, v110, v111, v112, v113, v114, v115, v108);
    goto LABEL_8;
  }

  int v116 = v129;
  if ((~*(_DWORD *)(a5 + 48) & 0x801) == 0 && (_BYTE)v129)
  {
    if (*((void *)&v129 + 1) <= *(void *)(a5 + 16))
    {
      int v116 = 1;
    }

    else
    {
      char v117 = sub_10003A294(v17);
      sub_100040C68( "%s (id %llu): purgeable resource fork size (%llu) is larger than resource fork size (%llu)\n",  v118,  v119,  v120,  v121,  v122,  v123,  v124,  v117);
      sub_100044E7C((char *)0x5B4, -3);
      int v116 = v129;
    }
  }

  sub_100016CE8( v16,  a5,  a6,  v127,  *((uint64_t *)&v127 + 1),  v128,  *((uint64_t *)&v128 + 1),  v116 != 0,  *((uint64_t *)&v129 + 1),  v130,  *((uint64_t *)&v130 + 1));
  uint64_t v26 = v125;
  if ((_DWORD)v125) {
    goto LABEL_8;
  }
  return v26;
}

uint64_t sub_100012EC4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v16 = *(void *)a3 >> 60;
  if ((_DWORD)v16 == 14) {
    LODWORD(v16) = *(unsigned __int8 *)(a3 + 8);
  }
  if ((_DWORD)a4 != 28)
  {
    char v27 = sub_10003A294(v16);
    sub_100040B90("%s (id %llu): invalid key length (%u)\n", v28, v29, v30, v31, v32, v33, v34, v27);
    uint64_t v25 = 92LL;
    uint64_t v26 = 1299LL;
    goto LABEL_13;
  }

  if (a6 <= 7)
  {
    char v17 = sub_10003A294(v16);
    sub_100040B90("%s (id %llu): invalid value length (%u)\n", v18, v19, v20, v21, v22, v23, v24, v17);
    uint64_t v25 = 92LL;
    uint64_t v26 = 1300LL;
LABEL_13:
    sub_100044E7C((char *)v26, 92);
    goto LABEL_14;
  }

  if ((*(void *)a3 & 0xFFFFFFFFFFFFFFFLL) != 9)
  {
    char v37 = sub_10003A294(v16);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v38, v39, v40, v41, v42, v43, v44, v37);
    uint64_t v25 = 92LL;
    uint64_t v26 = 1301LL;
    goto LABEL_13;
  }

  unint64_t v35 = *(void *)(a7 + 40);
  if (v35 <= 9)
  {
    unint64_t v35 = 10LL;
    *(void *)(a7 + 40) = 10LL;
  }

  unint64_t v36 = *(void *)(a3 + 12);
  if (v36 > 0xF)
  {
    unint64_t v49 = v36 + 1;
    if (v35 < v49) {
      *(void *)(a7 + 40) = v49;
    }
  }

  else
  {
    sub_100040C68( "clone mapping (private_id %llu, file_id %llu): invalid private_id\n",  a2,  a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  *(void *)(a3 + 12));
    sub_100044E7C((char *)0x516, -2);
  }

  unint64_t v50 = *(void *)(a3 + 20);
  if (v50 > 0xF)
  {
    unint64_t v51 = v50 + 1;
    if (*(void *)(a7 + 40) < v51) {
      *(void *)(a7 + 40) = v51;
    }
  }

  else
  {
    sub_100040C68( "clone mapping (private_id %llu, file_id %llu): invalid file_id\n",  a2,  a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  *(void *)(a3 + 12));
    sub_100044E7C((char *)0x517, -2);
  }

  uint64_t v52 = *(void *)a5;
  unint64_t v53 = *(void *)a5 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v54 = HIBYTE(*(void *)a5);
  uint64_t v55 = *(void *)(a1 + 8);
  unint64_t v56 = *(unsigned int *)(v55 + 36);
  unint64_t v73 = v53;
  if (v53 % v56 || v53 / v56 > *(void *)(v55 + 40))
  {
    sub_100040C68( "clone mapping (private_id %llu, file_id %llu): invalid physical_size (%llu)\n",  a2,  a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  *(void *)(a3 + 12));
    sub_100044E7C((char *)0x518, 92);
  }

  if (v54 >= 2)
  {
    sub_100040C68( "clone mapping (private_id %llu, file_id %llu): unknown flags (0x%x)\n",  a2,  a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  *(void *)(a3 + 12));
    if (*(void *)(*(void *)(a1 + 8) + 1384LL) <= 0x83B5A93981BC1uLL
      && sub_1000428C4( qword_10008DB70,  "Unset invalid flags? (0x%llx) ",  v57,  v58,  v59,  v60,  v61,  v62,  v54 & 0xFE))
    {
      *(void *)a5 = v52 & 0x1FFFFFFFFFFFFFFLL;
      *a8 = 1;
    }

    sub_100044E7C((char *)0x554, -3);
  }

  uint64_t v74 = 0LL;
  uint64_t v75 = 0LL;
  uint64_t v63 = sub_1000134C8( a1,  a2,  a3,  (unsigned __int16 *)(a5 + 8),  (a6 - 8),  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_1000167D4,  a7,  a8,  (uint64_t)&v74);
  if (!(_DWORD)v63)
  {
    if (v75)
    {
      uint64_t v25 = sub_1000060B8(v75, v73);
      if ((_DWORD)v25) {
        goto LABEL_14;
      }
    }

    if (v74)
    {
      uint64_t v25 = sub_1000170CC(v74, v73);
      if ((_DWORD)v25) {
        goto LABEL_14;
      }
      uint64_t v71 = v74;
    }

    else
    {
      uint64_t v71 = 0LL;
    }

    uint64_t v25 = sub_1000018B8(*(void *)(a3 + 12), *(void *)(a3 + 20), (void *)a5, v75, v71);
    if (!(_DWORD)v25) {
      return v25;
    }
    goto LABEL_14;
  }

  uint64_t v25 = v63;
  sub_100040B90( "clone mapping (private_id %llu, file_id %llu): invalid xfields\n",  v64,  v65,  v66,  v67,  v68,  v69,  v70,  *(void *)(a3 + 12));
LABEL_14:
  sub_100040E4C(a2, a3, a4, a5, a6, v45, v46, v47, v72);
  return v25;
}

uint64_t sub_10001320C( uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v11 = a2[6];
  if (!v11) {
    uint64_t v11 = a2[5];
  }
  if ((*(_BYTE *)(v11 + 56) & 0x20) != 0)
  {
    if (!(*a3 >> 60))
    {
      uint64_t v29 = sub_1000154E4(a1, a2, a3, a5, a7, a8);
      if (!(_DWORD)v29) {
        return v29;
      }
      goto LABEL_8;
    }

    char v21 = sub_10003A294(8u);
    sub_100040B90("%s (id %llu): ID larger than MAX_JOBJ_ID (%llu)\n", v22, v23, v24, v25, v26, v27, v28, v21);
    uint64_t v20 = 920LL;
  }

  else
  {
    char v12 = sub_10003A294(8u);
    sub_100040B90( "%s (id %llu): fext tree record present on non-sealed volume\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v12);
    uint64_t v20 = 919LL;
  }

  uint64_t v29 = 92LL;
  sub_100044E7C((char *)v20, 92);
LABEL_8:
  sub_100040DE4((uint64_t)a2, a3, a5, v30, v31, v32, v33, v34);
  return v29;
}

char *sub_1000132EC(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    sub_1000086FC(a1);
  }
  sub_10000AEA4(a2);
  sub_100006AB8(a2);
  sub_100024E68(a2);
  sub_100016A20(a2);
  sub_100005C98();
  return sub_100001050();
}

uint64_t sub_100013338(uint64_t a1)
{
  uint64_t result = sub_10001E424();
  *(_BYTE *)(a1 + 10) = 0;
  return result;
}

uint64_t sub_100013374( uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = sub_10000AF94(0xFFFFFFFFFFFFFFFFLL, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  LODWORD(result) = sub_100024794(a1, a2, a3, v12, v13, v14, v15, v16);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v11;
  }
}

uint64_t sub_1000133C4( uint64_t *a1, void *a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3) {
    unsigned int v12 = 0;
  }
  else {
    unsigned int v12 = sub_100008E04(a1, (uint64_t)a2, (uint64_t)a4);
  }
  unsigned int v13 = sub_10000B978(a1, (uint64_t)a2, a4, (uint64_t)a4, a5, a6, a7, a8);
  if (v13) {
    unsigned int v12 = v13;
  }
  unsigned int v14 = sub_100006F88((uint64_t)a1, (uint64_t)a2, a4);
  if (v14) {
    unsigned int v12 = v14;
  }
  unsigned int v20 = sub_100024794((uint64_t)a1, (uint64_t)a2, a4, v15, v16, v17, v18, v19);
  if (v20) {
    unsigned int v25 = v20;
  }
  else {
    unsigned int v25 = v12;
  }
  sub_100029254((uint64_t)a1, (uint64_t)a2, a3, a4, v21, v22, v23, v24);
  unsigned int v27 = v26;
  unsigned int v28 = sub_100017240((uint64_t)a1, a2, a4);
  if (v28) {
    unsigned int v29 = v28;
  }
  else {
    unsigned int v29 = v27;
  }
  LODWORD(result) = sub_1000061D0((uint64_t)a1, a2, a3);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v29;
  }
}

uint64_t sub_1000134C8( uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t), uint64_t a7, _DWORD *a8, uint64_t a9)
{
  if (a5 >= 4)
  {
    uint64_t v11 = *a4;
    if ((unint64_t)a4[1] + 4 * v11 + 4 <= a5)
    {
      if (!*a4)
      {
        unsigned int v20 = 0;
LABEL_15:
        if (v20 < a4[1])
        {
          sub_100040C68( "xf: xf_used_data (%u) is larger than expected (%u)\n",  a2,  a3,  (uint64_t)a4,  a5,  (uint64_t)a6,  a7,  (uint64_t)a8,  a4[1]);
          sub_100044E7C((char *)0x44C, -11);
          if (sub_1000428C4(qword_10008DB70, "Fix xf_used_data? ", v25, v26, v27, v28, v29, v30, v40))
          {
            uint64_t v9 = 0LL;
            a4[1] = v20;
            *a8 = 1;
            return v9;
          }
        }

        return 0LL;
      }

      unint64_t v18 = 0LL;
      unsigned int v19 = 0;
      unsigned int v20 = 0;
      uint64_t v41 = (uint64_t)&a4[2 * v11 + 2];
      uint64_t v21 = a4 + 3;
      do
      {
        if ((int)(a4[1] - v19) < *v21)
        {
          uint64_t v31 = *(void *)a3 >> 60;
          if ((_DWORD)v31 == 14) {
            LODWORD(v31) = *(unsigned __int8 *)(a3 + 8);
          }
          char v32 = sub_10003A294(v31);
          sub_10003A2C4(a3, *((unsigned __int8 *)v21 - 2));
          sub_100040B90( "%s (id %llu): xf %u/%u: %s: extended field at offset %u+%u extends beyond xf_used_data (%u)\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v32);
          uint64_t v9 = 92LL;
          uint64_t v12 = 899LL;
          goto LABEL_5;
        }

        uint64_t v22 = a6(a1, a2, a3, a4, v18, v41 + v19, a7, a8, a9);
        if ((_DWORD)v22) {
          return v22;
        }
        int v23 = *v21;
        v21 += 2;
        int v24 = (v23 + 7) & 0x1FFF8;
        v20 += v24;
        ++v18;
        v19 += v24;
      }

      while (v18 < *a4);
      if (v20 < 0x10000) {
        goto LABEL_15;
      }
      sub_100040B90( "xf: xf total size (%u) is larger than UINT16_MAX\n",  a2,  a3,  (uint64_t)a4,  a5,  (uint64_t)a6,  a7,  (uint64_t)a8,  v20);
      uint64_t v9 = 92LL;
      uint64_t v12 = 1099LL;
    }

    else
    {
      sub_100040B90( "xf: xf_num_exts (%u) extended fields do not fit in the given xf_used_data (%u)\n",  a2,  a3,  (uint64_t)a4,  a5,  (uint64_t)a6,  a7,  (uint64_t)a8,  *a4);
      uint64_t v9 = 92LL;
      uint64_t v12 = 191LL;
    }

uint64_t sub_1000136F4( uint64_t *a1, int8x16_t *a2, uint64_t a3, uint64_t a4, int a5, UInt8 *bytes, uint64_t a7, _DWORD *a8, uint64_t a9)
{
  uint64_t v14 = a4 + 4LL * a5;
  uint64_t v15 = *(void *)(a9 + 40);
  unsigned int v18 = *(unsigned __int8 *)(v14 + 4);
  uint64_t v17 = (unsigned __int8 *)(v14 + 4);
  uint64_t v16 = v18;
  CFIndex v19 = *((unsigned __int16 *)v17 + 1);
  if (v18 > 0x14 || ((0x251uLL >> v16) & 1) != 0 || word_10006B15C[v16] == (_DWORD)v19)
  {
    uint64_t v29 = 0LL;
    switch((int)v16)
    {
      case 1:
      case 2:
      case 6:
      case 7:
      case 9:
        char v32 = a2;
        uint64_t v33 = a7;
        uint64_t v34 = *(void *)a3 >> 60;
        if ((_DWORD)v34 == 14) {
          LODWORD(v34) = *(unsigned __int8 *)(a3 + 8);
        }
        char v35 = sub_10003A294(v34);
        sub_10003A2C4(a3, *v17);
        sub_100040C68( "%s (id %llu): xf %u/%u: %s: extended field type is no longer used\n",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v35);
        uint64_t v43 = 987LL;
        goto LABEL_12;
      case 3:
        *(_DWORD *)uu = *(_DWORD *)bytes;
        uint64_t v352 = a7;
        int v354 = *(_DWORD *)uu;
        v351 = a2;
        if (*(_DWORD *)uu <= 2u)
        {
          uint64_t v72 = *(void *)a3 >> 60;
          if ((_DWORD)v72 == 14) {
            LODWORD(v72) = *(unsigned __int8 *)(a3 + 8);
          }
          char v349 = sub_10003A294(v72);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: invalid doc_id (%u), less than MIN_DOC_ID (%u)\n",  v73,  v74,  v75,  v76,  v77,  v78,  v79,  v349);
          sub_100044E7C((char *)0xC2, -2);
          a2 = v351;
          a7 = v352;
        }

        int v80 = *(_DWORD *)(v15 + 68);
        if ((v80 & 0x40) != 0) {
          goto LABEL_35;
        }
        int v350 = v80 | 0x40;
        uint64_t v81 = *(void *)a3 >> 60;
        if ((_DWORD)v81 == 14) {
          LODWORD(v81) = *(unsigned __int8 *)(a3 + 8);
        }
        char v348 = sub_10003A294(v81);
        sub_10003A2C4(a3, *v17);
        sub_100040B90( "%s (id %llu): xf %u/%u: %s: doc_id exists (%u), despite bsd_flags (0x%x)\n",  v82,  v83,  v84,  v85,  v86,  v87,  v88,  v348);
        uint64_t v29 = 92LL;
        sub_100044E7C((char *)0x44D, 92);
        if (sub_1000428C4(qword_10008DB70, "Set bsd_flags to 0x%x? ", v89, v90, v91, v92, v93, v94, v350))
        {
          *(_DWORD *)(v15 + 68) = v350;
          *a8 = 1;
          a2 = v351;
          a7 = v352;
LABEL_35:
          uint64_t v95 = sub_10000521C(a1, a2, *(void *)a3 & 0xFFFFFFFFFFFFFFFLL, uu, a7, a8);
          if ((_DWORD)v95)
          {
            uint64_t v29 = v95;
            uint64_t v96 = *(void *)a3 >> 60;
            if ((_DWORD)v96 == 14) {
              LODWORD(v96) = *(unsigned __int8 *)(a3 + 8);
            }
            char v97 = sub_10003A294(v96);
            sub_10003A2C4(a3, *v17);
            sub_100040B90( "%s (id %llu): xf %u/%u: %s: invalid doc_id index\n",  v98,  v99,  v100,  v101,  v102,  v103,  v104,  v97);
          }

          else
          {
            if (*a8) {
              *(_DWORD *)bytes = *(_DWORD *)uu;
            }
            uint64_t v29 = 0LL;
            *(_BYTE *)a9 = 1;
          }
        }

        return v29;
      case 4:
        if (bytes[v19 - 1])
        {
          uint64_t v105 = *(void *)a3 >> 60;
          if ((_DWORD)v105 == 14) {
            LODWORD(v105) = *(unsigned __int8 *)(a3 + 8);
          }
          char v106 = sub_10003A294(v105);
          sub_10003A2C4(a3, *v17);
          sub_100040B90( "%s (id %llu): xf %u/%u: %s: invalid name (%.*s), given name_len (%u)\n",  v107,  v108,  v109,  v110,  v111,  v112,  v113,  v106);
          uint64_t v29 = 92LL;
          uint64_t v30 = 196LL;
          goto LABEL_7;
        }

        uint64_t v261 = *(void *)a3 >> 60;
        if ((_DWORD)v261 == 14) {
          LODWORD(v261) = *(unsigned __int8 *)(a3 + 8);
        }
        char v262 = sub_10003A294(v261);
        sub_10003A2C4(a3, *v17);
        sub_100040C68("%s (id %llu): xf %u/%u: %s: invalid name (%s)\n", v263, v264, v265, v266, v267, v268, v269, v262);
        uint64_t v70 = 197LL;
        int v71 = -9;
        goto LABEL_25;
      case 5:
      case 12:
      case 15:
      case 16:
      case 18:
        return v29;
      case 8:
        __int128 v114 = *((_OWORD *)bytes + 1);
        *(_OWORD *)uu = *(_OWORD *)bytes;
        __int128 v356 = v114;
        uint64_t v357 = *((void *)bytes + 4);
        if ((*(_WORD *)(v15 + 80) & 0xF000) == 0x8000)
        {
          uint64_t v353 = a7;
          uint64_t v115 = (uint64_t *)a2;
          uint64_t v116 = sub_100014C64((uint64_t)a1, (uint64_t)a2, (uint64_t *)a3, v15, uu, a7, a8);
          if ((_DWORD)v116)
          {
            uint64_t v29 = v116;
            uint64_t v119 = *(void *)a3 >> 60;
            if ((_DWORD)v119 == 14) {
              LODWORD(v119) = *(unsigned __int8 *)(a3 + 8);
            }
            char v120 = sub_10003A294(v119);
            sub_10003A2C4(a3, *v17);
            sub_100040B90( "%s (id %llu): xf %u/%u: %s: invalid dstream\n",  v121,  v122,  v123,  v124,  v125,  v126,  v127,  v120);
            return v29;
          }

          uint64_t v291 = *(void *)(v15 + 8);
          uint64_t v292 = *(void *)&uu[8];
          if (v291)
          {
            uint64_t v293 = *(void *)&uu[8];
            uint64_t v294 = sub_10000B0AC( *(void *)a3 & 0xFFFFFFFFFFFFFFFLL,  v291,  *(uint64_t *)&uu[8],  1LL,  (*(void *)(v15 + 48) >> 7) & 1LL,  (*(void *)(v15 + 48) >> 22) & 1LL,  v117,  v118);
            uint64_t v292 = v293;
            if ((_DWORD)v294)
            {
              uint64_t v29 = v294;
              uint64_t v295 = *(void *)a3 >> 60;
              if ((_DWORD)v295 == 14) {
                LODWORD(v295) = *(unsigned __int8 *)(a3 + 8);
              }
              char v296 = sub_10003A294(v295);
              sub_10003A2C4(a3, *v17);
              sub_100040B90( "%s (id %llu): xf %u/%u: %s: failed to register dstream: %d\n",  v297,  v298,  v299,  v300,  v301,  v302,  v303,  v296);
              return v29;
            }
          }

          *(void *)(a9 + 16) = v292;
          uint64_t v322 = v115[6];
          if (!v322) {
            uint64_t v322 = v115[5];
          }
          if ((*(_BYTE *)(v322 + 56) & 0x20) == 0)
          {
            sub_100006DB8(*(void *)a3 & 0xFFFFFFFFFFFFFFFLL, (uint64_t)uu);
            if ((_DWORD)v323)
            {
              uint64_t v29 = v323;
              uint64_t v328 = *(void *)a3 >> 60;
              if ((_DWORD)v328 == 14) {
                LODWORD(v328) = *(unsigned __int8 *)(a3 + 8);
              }
              char v329 = sub_10003A294(v328);
              sub_10003A2C4(a3, *v17);
              sub_100040B90( "%s (id %llu): xf %u/%u: %s: failed to register dstream for crypto state tracking: %d\n",  v330,  v331,  v332,  v333,  v334,  v335,  v336,  v329);
              return v29;
            }

            unint64_t v346 = *(void *)(v15 + 8);
            if (v346 < (*(void *)a3 & 0xFFFFFFFFFFFFFFFuLL)
              && (*(_BYTE *)(v15 + 50) & 0x40) != 0
              && *(void *)(v353 + 56))
            {
              sub_1000153D4((uint64_t)a1, v115, v346, v353, v324, v325, v326, v327);
            }
          }

          if (*a8)
          {
            __int128 v347 = v356;
            *(_OWORD *)bytes = *(_OWORD *)uu;
            *((_OWORD *)bytes + 1) = v347;
            *((void *)bytes + 4) = v357;
          }
        }

        else
        {
          uint64_t v206 = a2;
          uint64_t v207 = a7;
          uint64_t v208 = *(void *)a3 >> 60;
          if ((_DWORD)v208 == 14) {
            LODWORD(v208) = *(unsigned __int8 *)(a3 + 8);
          }
          char v209 = sub_10003A294(v208);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: found unexpected dstream associated with non-regular file\n",  v210,  v211,  v212,  v213,  v214,  v215,  v216,  v209);
          if (*(void *)(v207 + 56)) {
            uint64_t v223 = 0LL;
          }
          else {
            uint64_t v223 = v206 + 44;
          }
          uint64_t v224 = sub_10000B3C0(v223, *(void *)a3, v217, v218, v219, v220, v221, v222);
          if ((_DWORD)v224)
          {
            uint64_t v29 = v224;
            uint64_t v225 = *(void *)a3 >> 60;
            if ((_DWORD)v225 == 14) {
              LODWORD(v225) = *(unsigned __int8 *)(a3 + 8);
            }
            char v226 = sub_10003A294(v225);
            sub_10003A2C4(a3, *v17);
            sub_100040C68( "%s (id %llu): xf %u/%u: %s: unable to remove dstream of non-regular inode\n",  v227,  v228,  v229,  v230,  v231,  v232,  v233,  v226);
            return v29;
          }
        }

        uint64_t v29 = 0LL;
        *(_BYTE *)(a9 + 3) = 1;
        return v29;
      case 10:
        uint64_t v128 = *(void *)bytes;
        if (*(void *)bytes <= 0xFuLL && (unint64_t)(v128 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v129 = a7;
          uint64_t v130 = *(void *)a3 >> 60;
          if ((_DWORD)v130 == 14) {
            LODWORD(v130) = *(unsigned __int8 *)(a3 + 8);
          }
          char v131 = sub_10003A294(v130);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: invalid dir_stats_key (%llu)\n",  v132,  v133,  v134,  v135,  v136,  v137,  v138,  v131);
          sub_100044E7C((char *)0xC7, -2);
          a7 = v129;
        }

        uint64_t v139 = *(void *)(v15 + 48);
        if ((v139 & 4) != 0
          && (uint64_t v140 = a7, sub_100016F90(v128, *(void *)a3 & 0xFFFFFFFFFFFFFFFLL, v139), a7 = v140, (_DWORD)v141))
        {
          uint64_t v29 = v141;
          uint64_t v142 = *(void *)a3 >> 60;
          if ((_DWORD)v142 == 14) {
            LODWORD(v142) = *(unsigned __int8 *)(a3 + 8);
          }
          char v143 = sub_10003A294(v142);
          sub_10003A2C4(a3, *v17);
          sub_100040B90( "%s (id %llu): xf %u/%u: %s: failed to register dir-stats (%llu) origin: %d\n",  v144,  v145,  v146,  v147,  v148,  v149,  v150,  v143);
        }

        else
        {
          uint64_t v29 = 0LL;
          *(_BYTE *)(a9 + 2) = 1;
          *(void *)(a9 + 8) = v128;
        }

        return v29;
      case 11:
        *(_OWORD *)uu = *(_OWORD *)bytes;
        if (!uuid_is_null(uu)) {
          return 0LL;
        }
        uint64_t v151 = *(void *)a3 >> 60;
        if ((_DWORD)v151 == 14) {
          LODWORD(v151) = *(unsigned __int8 *)(a3 + 8);
        }
        char v152 = sub_10003A294(v151);
        sub_10003A2C4(a3, *v17);
        sub_100040B90("%s (id %llu): xf %u/%u: %s: uuid is NULL\n", v153, v154, v155, v156, v157, v158, v159, v152);
        uint64_t v29 = 92LL;
        uint64_t v30 = 200LL;
        goto LABEL_7;
      case 13:
        if ((*(_BYTE *)(v15 + 49) & 2) == 0)
        {
          uint64_t v160 = *(void *)a3 >> 60;
          if ((_DWORD)v160 == 14) {
            LODWORD(v160) = *(unsigned __int8 *)(a3 + 8);
          }
          char v161 = sub_10003A294(v160);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: sparse_bytes set even though inode is not sparse\n",  v162,  v163,  v164,  v165,  v166,  v167,  v168,  v161);
          sub_100044E7C((char *)0xC9, -5);
        }

        uint64_t v29 = 0LL;
        *(void *)(a9 + 24) = *(void *)bytes;
        *(_BYTE *)(a9 + 4) = 1;
        return v29;
      case 14:
        *(_BYTE *)(a9 + 1) = 1;
        if ((*(_BYTE *)(a2[2].i64[1] + 57) & 2) != 0)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v234 = *(void *)a3 >> 60;
          if ((_DWORD)v234 == 14) {
            LODWORD(v234) = *(unsigned __int8 *)(a3 + 8);
          }
          char v235 = sub_10003A294(v234);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: found rdev x-field but volume has rdev in core-inode\n",  v236,  v237,  v238,  v239,  v240,  v241,  v242,  v235);
          uint64_t v43 = 1156LL;
          goto LABEL_12;
        }

        if ((*(_WORD *)(v15 + 80) & 0xB000 | 0x4000) != 0x6000)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v304 = *(void *)a3 >> 60;
          if ((_DWORD)v304 == 14) {
            LODWORD(v304) = *(unsigned __int8 *)(a3 + 8);
          }
          char v305 = sub_10003A294(v304);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: found rdev x-field even though inode is not a char/block device\n",  v306,  v307,  v308,  v309,  v310,  v311,  v312,  v305);
          uint64_t v43 = 1157LL;
          goto LABEL_12;
        }

        if (!*(_DWORD *)bytes)
        {
          uint64_t v169 = *(void *)a3 >> 60;
          if ((_DWORD)v169 == 14) {
            LODWORD(v169) = *(unsigned __int8 *)(a3 + 8);
          }
          char v170 = sub_10003A294(v169);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: found zero rdev on char/block device (mode %u)\n",  v171,  v172,  v173,  v174,  v175,  v176,  v177,  v170);
          uint64_t v70 = 1212LL;
          int v71 = 92;
LABEL_25:
          sub_100044E7C((char *)v70, v71);
        }

        return 0LL;
      case 17:
        uint64_t v178 = a2[2].i64[1];
        if ((*(_BYTE *)(v178 + 57) & 2) != 0)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v243 = *(void *)a3 >> 60;
          if ((_DWORD)v243 == 14) {
            LODWORD(v243) = *(unsigned __int8 *)(a3 + 8);
          }
          char v244 = sub_10003A294(v243);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: found nlink x-field but volume has dir-nlink in core-inode\n",  v245,  v246,  v247,  v248,  v249,  v250,  v251,  v244);
          uint64_t v43 = 1154LL;
          goto LABEL_12;
        }

        if ((*(_BYTE *)(v178 + 48) & 2) == 0)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v179 = *(void *)a3 >> 60;
          if ((_DWORD)v179 == 14) {
            LODWORD(v179) = *(unsigned __int8 *)(a3 + 8);
          }
          char v180 = sub_10003A294(v179);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: found nlink field but volume doesn't support it\n",  v181,  v182,  v183,  v184,  v185,  v186,  v187,  v180);
          uint64_t v43 = 984LL;
          goto LABEL_12;
        }

        if ((*(_WORD *)(v15 + 80) & 0xF000) != 0x4000)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v313 = *(void *)a3 >> 60;
          if ((_DWORD)v313 == 14) {
            LODWORD(v313) = *(unsigned __int8 *)(a3 + 8);
          }
          char v314 = sub_10003A294(v313);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: found nlink field even though inode is not a directory\n",  v315,  v316,  v317,  v318,  v319,  v320,  v321,  v314);
          uint64_t v43 = 985LL;
          goto LABEL_12;
        }

        unint64_t v270 = *(void *)bytes;
        if (*(void *)bytes <= (unint64_t)*(int *)(v15 + 56) || (*(_BYTE *)(v15 + 71) & 0x40) != 0)
        {
          if (!(v270 >> 31)) {
            goto LABEL_153;
          }
          uint64_t v337 = *(void *)a3 >> 60;
          if ((_DWORD)v337 == 14) {
            LODWORD(v337) = *(unsigned __int8 *)(a3 + 8);
          }
          char v338 = sub_10003A294(v337);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: directory nlink value is invalid (%llu)\n",  v339,  v340,  v341,  v342,  v343,  v344,  v345,  v338);
          LODWORD(v270) = 0;
          uint64_t v280 = 1211LL;
        }

        else
        {
          uint64_t v271 = *(void *)a3 >> 60;
          if ((_DWORD)v271 == 14) {
            LODWORD(v271) = *(unsigned __int8 *)(a3 + 8);
          }
          char v272 = sub_10003A294(v271);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: directory nlink value %lld is greater than nchildren (%d)\n",  v273,  v274,  v275,  v276,  v277,  v278,  v279,  v272);
          uint64_t v280 = 986LL;
        }

        sub_100044E7C((char *)v280, -8);
LABEL_153:
        sub_1000290BC(*(void *)a3 & 0xFFFFFFFFFFFFFFFLL, v270);
        return 0LL;
      case 19:
        if ((*(_BYTE *)(v15 + 51) & 0x20) != 0)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v252 = *(void *)a3 >> 60;
          if ((_DWORD)v252 == 14) {
            LODWORD(v252) = *(unsigned __int8 *)(a3 + 8);
          }
          char v253 = sub_10003A294(v252);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: found attribution tag on an inode with unsupported flags\n",  v254,  v255,  v256,  v257,  v258,  v259,  v260,  v253);
          uint64_t v43 = 1336LL;
        }

        else
        {
          if ((*(_BYTE *)(a2[2].i64[1] + 48) & 8) != 0)
          {
            uint64_t v281 = *(void *)bytes;
            *(void *)(a9 + 32) = *(void *)bytes;
            if (!v281)
            {
              uint64_t v282 = *(void *)a3 >> 60;
              if ((_DWORD)v282 == 14) {
                LODWORD(v282) = *(unsigned __int8 *)(a3 + 8);
              }
              char v283 = sub_10003A294(v282);
              sub_10003A2C4(a3, *v17);
              sub_100040C68( "%s (id %llu): xf %u/%u: %s: invalid hash: (0)\n",  v284,  v285,  v286,  v287,  v288,  v289,  v290,  v283);
              sub_100044E7C((char *)0x524, -7);
            }

            uint64_t v29 = 0LL;
            *(_BYTE *)(a9 + 5) = 1;
            return v29;
          }

          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v188 = *(void *)a3 >> 60;
          if ((_DWORD)v188 == 14) {
            LODWORD(v188) = *(unsigned __int8 *)(a3 + 8);
          }
          char v189 = sub_10003A294(v188);
          sub_10003A2C4(a3, *v17);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: found attribution tag on a volume that doesn't support them\n",  v190,  v191,  v192,  v193,  v194,  v195,  v196,  v189);
          uint64_t v43 = 1315LL;
        }

LABEL_12:
        int v44 = -5;
LABEL_13:
        sub_100044E7C((char *)v43, v44);
        if (*(void *)(v33 + 56)) {
          unint64_t v50 = 0LL;
        }
        else {
          unint64_t v50 = v32 + 44;
        }
        uint64_t v29 = sub_1000241BC(v50, *(void *)a3, *v17, v45, v46, v47, v48, v49);
        if ((_DWORD)v29)
        {
          uint64_t v51 = *(void *)a3 >> 60;
          if ((_DWORD)v51 == 14) {
            LODWORD(v51) = *(unsigned __int8 *)(a3 + 8);
          }
          char v52 = sub_10003A294(v51);
          sub_10003A2C4(a3, *v17);
          strerror(v29);
          sub_100040B90( "%s (id %llu): xf %u/%u: %s: unable to add repair for unexpected xfield: %s\n",  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v52);
          uint64_t v30 = 1213LL;
          int v31 = v29;
          goto LABEL_20;
        }

        return v29;
      case 20:
        if ((~*(_DWORD *)(v15 + 48) & 0x20000004) == 0) {
          return 0LL;
        }
        char v32 = a2;
        uint64_t v33 = a7;
        uint64_t v197 = *(void *)a3 >> 60;
        if ((_DWORD)v197 == 14) {
          LODWORD(v197) = *(unsigned __int8 *)(a3 + 8);
        }
        char v198 = sub_10003A294(v197);
        sub_10003A2C4(a3, *v17);
        sub_100040B90( "%s (id %llu): xf %u/%u: %s: inode is expected to be an SAF dir-stats origin\n",  v199,  v200,  v201,  v202,  v203,  v204,  v205,  v198);
        uint64_t v43 = 1470LL;
        int v44 = 92;
        goto LABEL_13;
      default:
        uint64_t v61 = *(void *)a3 >> 60;
        if ((_DWORD)v61 == 14) {
          LODWORD(v61) = *(unsigned __int8 *)(a3 + 8);
        }
        char v62 = sub_10003A294(v61);
        sub_10003A2C4(a3, *v17);
        sub_100040C68("%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n", v63, v64, v65, v66, v67, v68, v69, v62);
        uint64_t v70 = 202LL;
        int v71 = -5;
        goto LABEL_25;
    }
  }

  uint64_t v20 = *(void *)a3 >> 60;
  if ((_DWORD)v20 == 14) {
    LODWORD(v20) = *(unsigned __int8 *)(a3 + 8);
  }
  char v21 = sub_10003A294(v20);
  sub_10003A2C4(a3, *v17);
  sub_100040B90( "%s (id %llu): xf %u/%u: %s: invalid extended field size %u, expected %u\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v21);
  uint64_t v29 = 92LL;
  uint64_t v30 = 983LL;
LABEL_7:
  int v31 = 92;
LABEL_20:
  sub_100044E7C((char *)v30, v31);
  return v29;
}

  uint64_t v15 = *(void *)(a3 + 24);
  if ((v9 & 0x1A) != 0 || v15 == 0) {
    goto LABEL_17;
  }
  CFIndex v19 = v8 & 0xC0000000;
  if ((_DWORD)a4 == 1)
  {
    if (v19) {
      goto LABEL_17;
    }
    char v21 = a2 ? *(void *)(*(void *)(a2 + 40) + 8LL) : 0LL;
    if (v21 != *(void *)(a3 + 16)) {
      goto LABEL_17;
    }
    uint64_t v20 = (v8 & 0xFFFE) == 2;
  }

  else
  {
    uint64_t v20 = 1;
  }

  uint64_t v22 = sub_100022BD0( a1,  a2,  v19,  v15,  0LL,  v8 & 0x3FFF0000,  (unsigned __int16)v8,  0,  (uint64_t **)&v37,  (uint64_t)v36,  0);
  if ((_DWORD)v22)
  {
    uint64_t v17 = v22;
    sub_100040B90( "failed to read object (oid (0x%llx)) being reaped from disk \n",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  *(void *)(a3 + 24));
    sub_100044E7C((char *)0x22A, v17);
    goto LABEL_18;
  }

  if (v20)
  {
    uint64_t v30 = *((unsigned __int16 *)v37 + 12);
    if (v30 > 0xC)
    {
      if (v30 == 13)
      {
        char v35 = *(_OWORD *)(a3 + 16);
        uint64_t v40 = *(_OWORD *)a3;
        uint64_t v41 = v35;
        uint64_t v42 = *(void *)(a3 + 32);
        char v32 = sub_100021B40((uint64_t)a1, (uint64_t *)&v40, (uint64_t)v37);
LABEL_44:
        uint64_t v17 = v32;
        if ((_DWORD)v32) {
          goto LABEL_18;
        }
        goto LABEL_45;
      }

      if (v30 == 25)
      {
        uint64_t v33 = *(_OWORD *)(a3 + 16);
        uint64_t v40 = *(_OWORD *)a3;
        uint64_t v41 = v33;
        uint64_t v42 = *(void *)(a3 + 32);
        char v32 = sub_100021DFC((uint64_t)a1, &v40, (uint64_t)v37);
        goto LABEL_44;
      }
    }

    else
    {
      if (v30 - 2 < 2)
      {
        int v31 = *(_OWORD *)(a3 + 16);
        uint64_t v40 = *(_OWORD *)a3;
        uint64_t v41 = v31;
        uint64_t v42 = *(void *)(a3 + 32);
        uint64_t v38 = *(_OWORD *)v36;
        uint64_t v39 = *(void *)&v36[16];
        char v32 = sub_10002162C((uint64_t)a1, a2, (uint64_t)&v40, (uint64_t)v37, (uint64_t)&v38, a4, v28, v29);
        goto LABEL_44;
      }

      if (v30 == 11)
      {
        uint64_t v34 = *(_OWORD *)(a3 + 16);
        uint64_t v40 = *(_OWORD *)a3;
        uint64_t v41 = v34;
        uint64_t v42 = *(void *)(a3 + 32);
        char v32 = sub_100021938((uint64_t)a1, &v40, (uint64_t)v37);
        goto LABEL_44;
      }
    }
  }

    free(v11);
    goto LABEL_13;
  }

  if ((_DWORD)v10) {
    uint64_t v10 = v10;
  }
  else {
    uint64_t v10 = 12LL;
  }
  uint64_t v22 = *(void *)(v39 + 152);
  strerror(v10);
  sub_100040B90("Could not initialize snap meta tree (oid 0x%llx): %s\n", v23, v24, v25, v26, v27, v28, v29, v22);
  sub_100044E7C((char *)0x239, v10);
  if (v11) {
    goto LABEL_12;
  }
LABEL_13:
  if (v13) {
    free(v13);
  }
  if (!(_DWORD)v10) {
    goto LABEL_16;
  }
  return v10;
}

  if ((a2 & 4) != 0 && *(_DWORD *)(a1 + 24) != a4)
  {
    sub_100040B90( "object (oid 0x%llx): o_type invalid, o_type 0x%x should be 0x%x\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *v13);
    char v21 = 92LL;
    sub_100044E7C((char *)9, 92);
  }

  if ((a2 & 8) != 0 && *(_DWORD *)(a1 + 28) != a5)
  {
    sub_100040B90( "object (oid 0x%llx): o_subtype invalid, o_subtype 0x%x should be 0x%x\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *v13);
    char v21 = 92LL;
    sub_100044E7C((char *)0xA, 92);
  }

  return v21;
}

    ++v11;
  }

  if (v11 < 0xA) {
    goto LABEL_12;
  }
  sub_10004252C(a1, "\n", v20, v21, v22, v23, v24, v25, v33);
  return 0LL;
}

uint64_t sub_1000146DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, _DWORD *a6)
{
  uint64_t v12 = *(void *)(a4 + 40);
  char v147 = 0;
  uint64_t v13 = *(void *)(v12 + 48);
  if ((v13 & 6) != 0 && !*(_BYTE *)(a4 + 2))
  {
    unint64_t v14 = v13 & 0xFFFFFFFFFFFFFFF9LL;
    char v15 = sub_10003A294(*a5 >> 60);
    sub_100040C68( "%s (id %llu): dir-stats key xf does not exist, despite internal_flags (0x%llx)\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v15);
    sub_100044E7C((char *)0x4CD, -3);
    if (sub_1000428C4( qword_10008DB70,  "Set internal_flags to 0x%llx? ",  v23,  v24,  v25,  v26,  v27,  v28,  v14))
    {
      *(void *)(v12 + 48) = v14;
      *a6 = 1;
    }
  }

  if (*(_BYTE *)(a4 + 4) && !*(_BYTE *)(a4 + 3))
  {
    char v29 = sub_10003A294(*a5 >> 60);
    sub_100040B90( "%s (id %llu): dstream xf does not exist, despite existence of sparse bytes xf\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v29);
    sub_100044E7C((char *)0x4EA, -5);
    *(void *)(a4 + 16) = 0LL;
    *(void *)(a4 + 24) = 0LL;
  }

  uint64_t v146 = a3;
  if (!*(_BYTE *)(a4 + 2))
  {
    unint64_t v39 = *(void *)(a4 + 24);
    unint64_t v41 = *(void *)(a4 + 16);
    if (v39 > v41 && v41 != 0)
    {
      uint64_t v37 = a6;
      BOOL v40 = 0;
      goto LABEL_25;
    }

    goto LABEL_33;
  }

  uint64_t v37 = a6;
  unint64_t v38 = *(void *)(v12 + 48);
  unint64_t v39 = *(void *)(a4 + 24);
  BOOL v40 = (v38 & 6) == 2;
  unint64_t v41 = *(void *)(a4 + 16);
  if (v39 <= v41 || v41 == 0)
  {
    if ((v38 & 6) == 2)
    {
      BOOL v43 = v41 >= v39;
      uint64_t v44 = v41 - v39;
      if (v43) {
        uint64_t v45 = v44;
      }
      else {
        uint64_t v45 = 0LL;
      }
      sub_100016ED8(*(void *)(a4 + 8), v45, (v38 >> 29) & 1);
      if ((_DWORD)v46)
      {
        uint64_t v47 = v46;
        char v48 = sub_10003A294(*a5 >> 60);
        sub_100040B90( "%s (id %llu): failed to register dir-stats (%llu) descendant: %d\n",  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v48);
        return v47;
      }

      if ((*(_WORD *)(v12 + 80) & 0xF000) == 0x8000)
      {
        a6 = v37;
        if (*(_DWORD *)(v12 + 56) == 1
          && (*(void *)(v12 + 48) & 0x180000LL) == 0x80000
          && (*(_DWORD *)(v12 + 68) & 0x40000020) != 0x20)
        {
          sub_100017150(*(void *)(a4 + 8), v45);
          if ((_DWORD)v122)
          {
            uint64_t v47 = v122;
            char v123 = sub_10003A294(*a5 >> 60);
            sub_100040B90( "%s (id %llu): failed to register dir-stats (%llu) purgeable_size: %d\n",  v124,  v125,  v126,  v127,  v128,  v129,  v130,  v123);
            return v47;
          }
        }
      }

      else
      {
        a6 = v37;
      }

      goto LABEL_37;
    }

    a6 = v37;
LABEL_33:
    if (!*(_BYTE *)(a4 + 5))
    {
LABEL_40:
      char v60 = 0;
      goto LABEL_41;
    }

    BOOL v43 = v41 >= v39;
    uint64_t v61 = v41 - v39;
    if (v43) {
      uint64_t v45 = v61;
    }
    else {
      uint64_t v45 = 0LL;
    }
LABEL_37:
    if (*(_BYTE *)(a4 + 5))
    {
      sub_100005FD0(*a5 & 0xFFFFFFFFFFFFFFFLL, *(void *)(a4 + 32), v45);
      if ((_DWORD)v62)
      {
        uint64_t v47 = v62;
        char v63 = sub_10003A294(*a5 >> 60);
        sub_100040B90("%s (id %llu): failed to register attribution tag: %d\n", v64, v65, v66, v67, v68, v69, v70, v63);
        return v47;
      }
    }

    goto LABEL_40;
  }

uint64_t sub_100014C64(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void *a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v9 = a3;
  unint64_t v12 = *(unsigned int *)(*(void *)(a1 + 8) + 36LL);
  uint64_t v13 = *(void *)(a2 + 40);
  unint64_t v14 = a5[1];
  if (v14 % v12)
  {
    uint64_t v186 = a4;
    char v15 = a5;
    char v16 = sub_10003A294((unint64_t)*a3 >> 60);
    uint64_t v17 = v9;
    sub_100040B90( "%s (id %llu): dstream.alloced_size (%llu) is not a multiple of the block size (%u)\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v16);
    uint64_t v25 = 92LL;
    sub_100044E7C((char *)0x381, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Truncate alloced_size to block size? ",  v26,  v27,  v28,  v29,  v30,  v31,  v181)) {
      return v25;
    }
    unint64_t v14 = v15[1] / v12 * v12;
    v15[1] = v14;
    *a7 = 1;
    uint64_t v9 = v17;
    a4 = v186;
    a5 = v15;
  }

  uint64_t v32 = *(void *)(a6 + 56);
  uint64_t v184 = a6;
  uint64_t v185 = a2;
  uint64_t v188 = a7;
  if (v32) {
    BOOL v33 = (*(_BYTE *)(*(void *)(a2 + 40) + 264LL) & 9) == 0;
  }
  else {
    BOOL v33 = 1;
  }
  BOOL v34 = 0;
  uint64_t v187 = v13;
  uint64_t v35 = *(void *)(v13 + 264);
  uint64_t v36 = a5[2];
  uint64_t v37 = v35 & 0x109;
  unint64_t v38 = *a5;
  if (v37) {
    BOOL v39 = v36 != -1;
  }
  else {
    BOOL v39 = 1;
  }
  if (v33 && v36 == -1 && a4 && !v37) {
    BOOL v34 = (*(_BYTE *)(a4 + 48) & 0x10) == 0;
  }
  unsigned __int8 v189 = 0;
  if (v38 > v14 || !v39 || (int v40 = 0, v34))
  {
    BOOL v41 = v33;
    BOOL v42 = v34;
    BOOL v43 = a5;
    uint64_t v44 = a4;
    uint64_t v45 = sub_10003B000(a1, v185, v32, *v9 & 0xFFFFFFFFFFFFFFFLL, &v189);
    uint64_t v46 = v9;
    uint64_t v25 = v45;
    if ((_DWORD)v45) {
      return v25;
    }
    int v40 = v189;
    uint64_t v9 = v46;
    a4 = v44;
    a5 = v43;
    BOOL v34 = v42;
    BOOL v33 = v41;
  }

  if (v38 <= v14)
  {
    uint64_t v47 = v188;
  }

  else
  {
    uint64_t v47 = v188;
    if (!v40)
    {
      unint64_t v48 = *v9;
      if ((a4 || (v48 & 0xF000000000000000LL) != 0x4000000000000000LL) && (*(_BYTE *)(a4 + 48) & 0x80) != 0)
      {
        int v40 = 0;
      }

      else
      {
        uint64_t v49 = a4;
        uint64_t v50 = a5;
        char v51 = sub_10003A294(v48 >> 60);
        uint64_t v52 = v9;
        sub_100040B90( "%s (id %llu): dstream.size (%llu) is greater than dstream.alloced_size (%llu)\n",  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v51);
        uint64_t v25 = 92LL;
        sub_100044E7C((char *)0xB8, 92);
        if (!sub_1000428C4( qword_10008DB70,  "Truncate size to alloced size? ",  v60,  v61,  v62,  v63,  v64,  v65,  v182)) {
          return v25;
        }
        *uint64_t v50 = v50[1];
        *uint64_t v188 = 1;
        int v40 = v189;
        uint64_t v9 = v52;
        a4 = v49;
        a5 = v50;
      }
    }
  }

  if (v40) {
    char v66 = 1;
  }
  else {
    char v66 = v39;
  }
  if ((v66 & 1) == 0)
  {
    uint64_t v67 = a5;
    uint64_t v68 = a4;
    char v69 = sub_10003A294((unint64_t)*v9 >> 60);
    uint64_t v70 = v9;
    sub_100040B90( "%s (id %llu): found dstream with unassigned default_crypto_id\n",  v71,  v72,  v73,  v74,  v75,  v76,  v77,  v69);
    uint64_t v25 = 92LL;
    sub_100044E7C((char *)0x3F5, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Fix unassigned default_crypto_id? ",  v78,  v79,  v80,  v81,  v82,  v83,  v183)) {
      return v25;
    }
    a5 = v67;
    v67[2] = 4LL * ((*(void *)(v187 + 264) & 0x108LL) != 0);
    *uint64_t v47 = 1;
    uint64_t v9 = v70;
    a4 = v68;
  }

  if (!v33) {
    return 0LL;
  }
  uint64_t v84 = *(void *)(v187 + 264);
  if ((v84 & 1) != 0)
  {
    uint64_t v85 = a5[2];
    if (!*(void *)(v187 + 976))
    {
      uint64_t v110 = a5;
      char v111 = sub_10003A294((unint64_t)*v9 >> 60);
      sub_100040B90( "%s (id %llu): invalid dstream.default_crypto_id (%llu) on unencrypted volume, given apfs_fs_flags (0x%llx)\n",  v112,  v113,  v114,  v115,  v116,  v117,  v118,  v111);
      uint64_t v25 = 92LL;
      sub_100044E7C((char *)0xBD, 92);
      if (!sub_1000428C4( qword_10008DB70,  "Fix default_crypto_id (%llu)? ",  v119,  v120,  v121,  v122,  v123,  v124,  v110[2])) {
        return v25;
      }
      uint64_t v25 = 0LL;
      v110[2] = 0LL;
LABEL_57:
      *uint64_t v47 = 1;
      return v25;
    }
  }

  else
  {
    uint64_t v85 = a5[2];
  }

  if (v85 == 1)
  {
    char v86 = sub_10003A294((unint64_t)*v9 >> 60);
    sub_100040B90("%s (id %llu): invalid dstream.default_crypto_id (%llu)\n", v87, v88, v89, v90, v91, v92, v93, v86);
    uint64_t v25 = 92LL;
    sub_100044E7C((char *)0xB9, 92);
    return v25;
  }

  if (v36 == -1)
  {
    if (v189) {
      BOOL v125 = 0;
    }
    else {
      BOOL v125 = v34;
    }
    if (!v125) {
      return 0LL;
    }
    uint64_t v126 = a4;
    char v127 = sub_10003A294((unint64_t)*v9 >> 60);
    sub_100040B90( "%s (id %llu): invalid internal_flags (0x%llx) given unassigned default_crypto_id\n",  v128,  v129,  v130,  v131,  v132,  v133,  v134,  v127);
    uint64_t v25 = 92LL;
    sub_100044E7C((char *)0x534, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Fix internal flags (0x%llx)? ",  v135,  v136,  v137,  v138,  v139,  v140,  *(void *)(v126 + 48))) {
      return v25;
    }
    uint64_t v25 = 0LL;
    *(void *)(v126 + 48) |= 0x10uLL;
    goto LABEL_57;
  }

  if ((*(void *)(v187 + 264) & 0x109LL) != 8)
  {
    if ((v84 & 1) == 0 && !(*(void *)(v187 + 976) | v85))
    {
      uint64_t v141 = a4;
      uint64_t v142 = a5;
      char v143 = sub_10003A294((unint64_t)*v9 >> 60);
      uint64_t v144 = v142;
      sub_100040B90( "%s (id %llu): invalid dstream.default_crypto_id (%llu) on encrypted volume, given apfs_fs_flags (0x%llx)\n",  v145,  v146,  v147,  v148,  v149,  v150,  v151,  v143);
      sub_100044E7C((char *)0x34A, 92);
      uint64_t v158 = v185;
      if ((*(_BYTE *)(*(void *)(v185 + 40) + 57LL) & 2) == 0 || (~*(_DWORD *)(v141 + 68) & 0x40000020) != 0)
      {
        if ((*(void *)(v187 + 264) & 0x109LL) == 0x100
          && sub_1000428C4( qword_10008DB70,  "Fix default_crypto_id (%llu)? ",  v152,  v153,  v154,  v155,  v156,  v157,  v144[2]))
        {
          a5 = v144;
          v144[2] = 4LL;
          *uint64_t v47 = 1;
          uint64_t v169 = v184;
          goto LABEL_73;
        }
      }

      else
      {
        int v159 = sub_10000B3C0((_DWORD *)(v185 + 704), *v9, v152, v153, v154, v155, v156, v157);
        a5 = v144;
        if (!v159) {
          goto LABEL_68;
        }
        int v160 = v159;
        char v161 = sub_10003A294((unint64_t)*v9 >> 60);
        sub_100040C68( "%s (id %llu): unable to remove dstream of inode %llu\n",  v162,  v163,  v164,  v165,  v166,  v167,  v168,  v161);
        sub_100044E7C((char *)0x58F, v160);
        uint64_t v158 = v185;
      }

      *(_BYTE *)(v158 + 13) = 1;
      a5 = v144;
    }

LABEL_68:
    unint64_t v170 = a5[2];
    if (v170 - 16 < 0xFFFFFFFFFFFFFFF1LL)
    {
      uint64_t v169 = v184;
      goto LABEL_79;
    }

    uint64_t v169 = v184;
    if (v170 - 2 < 2 || v170 == 5) {
      goto LABEL_80;
    }
    if (v170 != 4)
    {
LABEL_78:
      uint64_t v171 = a5;
      char v172 = sub_10003A294((unint64_t)*v9 >> 60);
      sub_100040C68( "%s (id %llu): invalid dstream.default_crypto_id (%llu) on encrypted volume\n",  v173,  v174,  v175,  v176,  v177,  v178,  v179,  v172);
      sub_100044E7C((char *)0xBC, -2);
      unint64_t v170 = v171[2];
LABEL_79:
      if (v170 == -1LL) {
        return 0LL;
      }
LABEL_80:
      if (*(void *)(v169 + 40) <= v170)
      {
        uint64_t v25 = 0LL;
        *(void *)(v169 + 40) = v170 + 1;
        return v25;
      }

      return 0LL;
    }

LABEL_73:
    if ((*(void *)(v187 + 264) & 1) != 0)
    {
      unint64_t v170 = 4LL;
      if ((*(void *)(v187 + 264) & 0x109LL) == 0x100 || *(void *)(v187 + 976)) {
        goto LABEL_80;
      }
    }

    else if ((*(void *)(v187 + 264) & 0x109LL) == 0x100)
    {
      unint64_t v170 = 4LL;
      goto LABEL_80;
    }

    goto LABEL_78;
  }

  if ((v84 & 1) != 0) {
    return 0LL;
  }
  uint64_t v94 = v9;
  uint64_t v25 = 0LL;
  if (v85 != 4 && !*(void *)(v187 + 976))
  {
    unint64_t v95 = a5;
    char v96 = sub_10003A294((unint64_t)*v94 >> 60);
    sub_100040B90( "%s (id %llu): invalid dstream.default_crypto_id (%llu) on encrypted volume, given apfs_fs_flags (0x%llx)\n",  v97,  v98,  v99,  v100,  v101,  v102,  v103,  v96);
    uint64_t v25 = 92LL;
    sub_100044E7C((char *)0xBA, 92);
    if (sub_1000428C4( qword_10008DB70,  "Fix default_crypto_id (%llu)? ",  v104,  v105,  v106,  v107,  v108,  v109,  v95[2]))
    {
      uint64_t v25 = 0LL;
      v95[2] = 4LL;
      goto LABEL_57;
    }
  }

  return v25;
}

uint64_t sub_1000153D4( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  memset(v16, 170, sizeof(v16));
  uint64_t result = sub_10003AB6C(a1, a2, 8, &v18, a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    v15[0] = a1;
    v15[1] = a2;
    v17[0] = a3 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000LL;
    v17[1] = 0LL;
    uint64_t v14 = 0LL;
    memset(v13, 0, sizeof(v13));
    uint64_t result = sub_100035394((uint64_t)v13, v18, *(void *)(a4 + 56), v17, 0x10u, 0x10u, v16, 24);
    if (!(_DWORD)result) {
      return sub_10002930C( (uint64_t)v13,  (uint64_t (*)(void, void, void, void, uint64_t))sub_10001548C,  (uint64_t)v15,  0);
    }
  }

  return result;
}

uint64_t sub_10001548C(void *a1, int a2, void *a3, int a4, uint64_t *a5)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a4 == 24 && a2 == 16 && (*a1 & 0xF000000000000000LL) == 0x8000000000000000LL)
  {
    unint64_t v7 = a3[1];
    if (v7) {
      return sub_10001E858(a5[1], v7, (*a3 & 0xFFFFFFFFFFFFFFuLL) / *(unsigned int *)(*(void *)(*a5 + 8) + 36LL));
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1000154E4(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  unint64_t v6 = *a3 & 0xFFFFFFFFFFFFFFFLL;
  if (v6 <= 1)
  {
    char v7 = sub_10003A294(8u);
    sub_100040B90("%s (id %llu): invalid hdr.obj_id\n", v8, v9, v10, v11, v12, v13, v14, v7);
    uint64_t v15 = 92LL;
    uint64_t v16 = 627LL;
LABEL_3:
    int v17 = 92;
LABEL_4:
    sub_100044E7C((char *)v16, v17);
    return v15;
  }

  unint64_t v25 = *(unsigned int *)(*(void *)(a1 + 8) + 36LL);
  if (v6 <= 0xF && v6 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v27 = sub_10003A294(8u);
    sub_100040C68("%s (id %llu): invalid hdr.obj_id\n", v28, v29, v30, v31, v32, v33, v34, v27);
    sub_100044E7C((char *)0x274, -2);
  }

  if (*(void *)(a5 + 40) <= v6) {
    *(void *)(a5 + 40) = v6 + 1;
  }
  if (a3[1] % v25)
  {
    char v35 = sub_10003A294(8u);
    sub_100040B90( "%s (id %llu): Logical address %llu of file extent not a multiple of the block size (%u)\n",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v35);
    uint64_t v15 = 92LL;
    sub_100044E7C((char *)0x259, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Round down logical address (%llu) to block size? ",  v43,  v44,  v45,  v46,  v47,  v48,  a3[1])) {
      return v15;
    }
    a3[1] = a3[1] / v25 * v25;
    *a6 = 1;
  }

  uint64_t v147 = a6;
  uint64_t v148 = a2;
  unint64_t v49 = *(void *)a4;
  unint64_t v50 = *(void *)a4 & 0xFFFFFFFFFFFFFFLL;
  if (v50 % v25)
  {
    char v51 = sub_10003A294(8u);
    sub_100040B90( "%s (id %llu): Length %llu of file extent not a multiple of the block size (%u)\n",  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v51);
    sub_100044E7C((char *)0xD6, 92);
    v156[0] = 0xAAAAAAAAAAAAAAAALL;
    int v63 = sub_10003AB6C(a1, a2, 8, v156, v59, v60, v61, v62);
    uint64_t v70 = a3[1];
    unint64_t v151 = v6;
    uint64_t v152 = v70;
    memset(v157, 170, 24);
    LODWORD(v149) = 16;
    v158[0] = 24;
    if (v63
      || sub_100034BB4( v156[0],  *(void *)(a5 + 56),  2LL,  &v151,  (unsigned int *)&v149,  0x10u,  v157,  v158)
      || (_DWORD)v149 != 16
      || v151 != v6)
    {
      if (sub_1000428C4( qword_10008DB70,  "Round %s length (%llu) to block size? ",  v64,  v65,  v66,  v67,  v68,  v69,  (char)"down"))
      {
LABEL_19:
        unint64_t v71 = v50 - v50 % v25;
LABEL_20:
        unint64_t v49 = v71 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a4 + 7) << 56);
        *(void *)a4 = v49;
        *uint64_t v147 = 1;
        unint64_t v50 = v71;
        goto LABEL_21;
      }
    }

    else
    {
      unint64_t v71 = (v25 + v50 - 1) / v25 * v25;
      uint64_t v118 = "up";
      BOOL v146 = v152 - a3[1] == v71;
      if (v152 - a3[1] != v71) {
        uint64_t v118 = "down";
      }
      if (sub_1000428C4( qword_10008DB70,  "Round %s length (%llu) to block size? ",  v64,  v65,  v66,  v67,  v68,  v69,  (char)v118))
      {
        if (v146) {
          goto LABEL_20;
        }
        goto LABEL_19;
      }
    }

    return 92LL;
  }

LABEL_21:
  unint64_t v72 = HIBYTE(v49);
  if (HIBYTE(v49) >= 4)
  {
    char v88 = sub_10003A294(8u);
    sub_100040C68("%s (id %llu): invalid flags: (0x%02x)\n", v89, v90, v91, v92, v93, v94, v95, v88);
    sub_100044E7C((char *)0xD7, -3);
  }

  else
  {
    uint64_t v73 = v148[6];
    if (!v73) {
      uint64_t v73 = v148[5];
    }
    if ((v49 & 0x100000000000000LL) != 0 && (*(void *)(v73 + 56) & 0x20) != 0)
    {
      char v74 = sub_10003A294(8u);
      sub_100040B90("%s (id %llu): invalid flags: (0x%02x)\n", v75, v76, v77, v78, v79, v80, v81, v74);
      uint64_t v15 = 92LL;
      sub_100044E7C((char *)0x396, 92);
      if (!sub_1000428C4( qword_10008DB70,  "Remove invalid flags (0x%02x)? ",  v82,  v83,  v84,  v85,  v86,  v87,  1)) {
        return v15;
      }
      LOBYTE(v72) = HIBYTE(v49) & 0xFE;
      *(_BYTE *)(a4 + 7) = (v49 & 0xFE00000000000000LL) >> 56;
      *uint64_t v147 = 1;
    }
  }

  uint64_t v96 = (uint64_t)v148;
  if ((v72 & 2) != 0)
  {
    uint64_t v97 = v148[6];
    if (!v97) {
      uint64_t v97 = v148[5];
    }
    if ((*(_BYTE *)(v97 + 56) & 0x80) == 0)
    {
      char v98 = sub_10003A294(8u);
      sub_100040B90("%s (id %llu): invalid flag: (0x%02x)\n", v99, v100, v101, v102, v103, v104, v105, v98);
      uint64_t v15 = 92LL;
      sub_100044E7C((char *)0x3F6, 92);
      if (!sub_1000428C4( qword_10008DB70,  "Remove invalid flag (0x%02x)? ",  v106,  v107,  v108,  v109,  v110,  v111,  2)) {
        return v15;
      }
      LOBYTE(v72) = v72 & 0xFD;
      *(_BYTE *)(a4 + 7) = v72;
      uint64_t v96 = (uint64_t)v148;
      *uint64_t v147 = 1;
    }
  }

  unint64_t v112 = *(void *)(a4 + 8);
  if ((v72 & 2) != 0)
  {
    if (!v112)
    {
      char v136 = sub_10003A294(8u);
      sub_100040B90( "%s (id %llu): expected physical block number for extent at offset %lld\n",  v137,  v138,  v139,  v140,  v141,  v142,  v143,  v136);
      uint64_t v15 = 92LL;
      uint64_t v16 = 1015LL;
      goto LABEL_3;
    }
  }

  else if (!v112)
  {
    goto LABEL_56;
  }

  uint64_t v113 = *(void *)(a1 + 8);
  uint64_t v114 = *(void *)(a1 + 24);
  unint64_t v115 = v50 / v25;
  if (v114)
  {
    unint64_t v116 = *(void *)(v114 + 48);
    unint64_t v117 = *(void *)(v114 + 96);
  }

  else
  {
    unint64_t v116 = *(void *)(v113 + 40);
    if ((*(_BYTE *)(v113 + 65) & 1) != 0) {
      unint64_t v117 = *(void *)(v113 + 40);
    }
    else {
      unint64_t v117 = 0LL;
    }
  }

  unint64_t v119 = *(unsigned int *)(v113 + 36);
  if (v116 <= v115 || v116 <= v112 || v116 - v115 < v112)
  {
    unint64_t v121 = 0x4000000000000000uLL >> __clz(__rbit64(v119));
    if (v121 >= v112
      || (BOOL v122 = v117 >= v115, v123 = v117 - v115, v123 == 0 || !v122)
      || (v117 | v121) <= v112
      || (v123 | v121) < v112)
    {
      char v124 = sub_10003A294(8u);
      sub_100040B90( "%s (id %llu): Bad phys_block_num + len (%llu + %llu) for physical file extent record\n",  v125,  v126,  v127,  v128,  v129,  v130,  v131,  v124);
      uint64_t v15 = 92LL;
      uint64_t v16 = 216LL;
      goto LABEL_3;
    }
  }

  if (v71) {
    free(v71);
  }
  if ((_DWORD)v12)
  {
    free(v65);
    *(_DWORD *)(v7 + 140) = v64;
    *(_DWORD *)(v7 + 148) = v66;
  }

  return v12;
}

    uint64_t v23 = v6;
    fprintf(__stderrp, "%04x:  ", (_DWORD)v3 - v22);
    if (v3 >= v11)
    {
      CFStringRef v2 = 1;
    }

    else
    {
      uint64_t v13 = 0LL;
      CFStringRef v2 = 1;
      do
      {
        fprintf(__stderrp, "%02x", v3[v13]);
        if ((((_DWORD)v13 + 1) & 1) == 0) {
          fputc(32, __stderrp);
        }
        if (v3[v13]) {
          CFStringRef v2 = 0;
        }
        ++v13;
      }

      while (&v3[v13] < v11);
    }

    if ((((_DWORD)v10 - (_DWORD)v11) & 0x80000000) == 0)
    {
      uint64_t v14 = -v9;
      uint64_t v15 = v23;
      do
      {
        fwrite("  ", 2uLL, 1uLL, __stderrp);
        if ((((_BYTE)v14 + (_BYTE)v15 - 1) & 1) != 0) {
          fputc(32, __stderrp);
        }
        --v15;
      }

      while (v14 + v15 > 0);
    }

    fwrite("    |", 5uLL, 1uLL, __stderrp);
    for (int i = v21; v3 < v11; ++v3)
    {
      uint64_t v16 = __stderrp;
      int v17 = *v3;
      else {
        uint64_t v18 = _DefaultRuneLocale.__runetype[*v3] & 0x500;
      }
      if (v18) {
        uint64_t v19 = v17;
      }
      else {
        uint64_t v19 = 46;
      }
      fputc(v19, v16);
    }

    if (v21 < (unint64_t)v10)
    {
      do
      {
        fputc(32, __stderrp);
        --v8;
      }

      while (v8);
    }

    fwrite("|\n", 2uLL, 1uLL, __stderrp);
    unint64_t v6 = v23;
    goto LABEL_46;
  }

  return fputc(10, __stderrp);
}

LABEL_56:
  v156[0] = 0LL;
  v156[1] = 0LL;
  if (v96) {
    uint64_t v120 = *(void *)(*(void *)(v96 + 40) + 8LL);
  }
  else {
    uint64_t v120 = 0LL;
  }
  v157[0] = v120;
  v157[1] = 0xF000040000000LL;
  uint64_t v132 = *(void *)(a5 + 56);
  v157[2] = v112;
  v157[3] = v132;
  unsigned int v154 = 16;
  unsigned int v155 = 32;
  uint64_t v152 = 0LL;
  unint64_t v153 = 0LL;
  uint64_t v149 = 0LL;
  uint64_t v150 = 0LL;
  unint64_t v135 = v96 ? *(void *)(*(void *)(v96 + 40) + 8LL) : 0LL;
  uint64_t v144 = *(void *)(a4 + 8);
  unint64_t v151 = v135;
  uint64_t v152 = v144;
  unint64_t v153 = v6;
  uint64_t v145 = a3[1];
  uint64_t v149 = *(void *)(a5 + 56);
  uint64_t v150 = v145;
  uint64_t v15 = sub_1000364F0(dword_10008E030, 0LL, &v151, 24LL, &v149, 16LL);
  if (!(_DWORD)v15)
  {
LABEL_78:
    unint64_t v133 = *(void *)(a4 + 8);
    if (!v133) {
      return 0LL;
    }
    char v134 = sub_10000B8D0(a3);
    uint64_t v15 = sub_10001E48C(v96, v133, v50 / v25, v6, v134);
    if ((_DWORD)v15)
    {
      uint64_t v16 = 828LL;
      int v17 = v15;
      goto LABEL_4;
    }
  }

  return v15;
}

double sub_100015B00(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t v10 = *(void *)a3;
  if ((*(void *)a3 & 0x100000000000000LL) == 0)
  {
    unint64_t v11 = *(void *)(a3 + 16);
    if (v11 <= 0xF)
    {
      BOOL v12 = v11 > 5;
      uint64_t v13 = (1LL << v11) & 0x2D;
      if (v12 || v13 == 0)
      {
        char v105 = sub_10003A294((unint64_t)*a2 >> 60);
        sub_100040C68("%s (id %llu): invalid crypto_id (%llu)\n", v106, v107, v108, v109, v110, v111, v112, v105);
        sub_100044E7C((char *)0xD9, -2);
      }
    }
  }

  if (*(void *)(a3 + 8))
  {
    unint64_t v15 = HIBYTE(v10);
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v17 = *(void *)(v16 + 264);
    if (*(void *)(a4 + 56)) {
      BOOL v18 = (*(void *)(v16 + 264) & 9LL) == 0;
    }
    else {
      BOOL v18 = 1;
    }
    if (!v18)
    {
LABEL_31:
      if ((v15 & 1) != 0) {
        return sub_100006E4C(a2, a3);
      }
LABEL_32:
      unint64_t v62 = *(void *)(a3 + 16) + 1LL;
      if (*(void *)(a4 + 40) < v62) {
        *(void *)(a4 + 40) = v62;
      }
      return sub_100006E4C(a2, a3);
    }

    uint64_t v19 = *(void *)(v16 + 976);
    if ((v17 & 1) != 0)
    {
      if (v19) {
        goto LABEL_31;
      }
      if (*(void *)(a3 + 16))
      {
        char v77 = sub_10003A294((unint64_t)*a2 >> 60);
        sub_100040B90( "%s (id %llu): invalid nonzero crypto_id (%llu) on unencrypted volume\n",  v78,  v79,  v80,  v81,  v82,  v83,  v84,  v77);
        sub_100044E7C((char *)0x342, 92);
        if (!sub_1000428C4( qword_10008DB70,  "Fix crypto_id (%llu)? ",  v85,  v86,  v87,  v88,  v89,  v90,  *(void *)(a3 + 16))) {
          return result;
        }
        *(void *)(a3 + 16) = 0LL;
        *a5 = 1;
      }

      if ((v10 & 0x100000000000000LL) == 0) {
        goto LABEL_31;
      }
      char v91 = sub_10003A294((unint64_t)*a2 >> 60);
      sub_100040B90( "%s (id %llu): extent crypto flag set on unencrypted volume\n",  v92,  v93,  v94,  v95,  v96,  v97,  v98,  v91);
      sub_100044E7C((char *)0x3CF, 92);
      if (sub_1000428C4(qword_10008DB70, "Clear invalid flag? ", v99, v100, v101, v102, v103, v104, v117))
      {
        *(_BYTE *)(a3 + 7) = (v10 & 0xFE00000000000000LL) >> 56;
        *a5 = 1;
        goto LABEL_32;
      }
    }

    else
    {
      if (v19) {
        goto LABEL_31;
      }
      if (!*(void *)(a3 + 16))
      {
        char v20 = sub_10003A294((unint64_t)*a2 >> 60);
        sub_100040B90( "%s (id %llu): invalid zero crypto_id on encrypted volume\n",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v20);
        sub_100044E7C((char *)0x343, 92);
        if ((*(_WORD *)(*(void *)(a1 + 40) + 264LL) & 0x108) == 0
          || !sub_1000428C4(qword_10008DB70, "Fix crypto_id? ", v28, v29, v30, v31, v32, v33, v114))
        {
          return result;
        }

        *(void *)(a3 + 16) = *(void *)(a3 + 8);
        LOBYTE(v15) = HIBYTE(v10) | 1;
        *(_BYTE *)(a3 + 7) = HIBYTE(v10) | 1;
        *a5 = 1;
        uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 264LL);
      }

      if ((v15 & 1) != 0 || (v17 & 0x109) != 8) {
        goto LABEL_31;
      }
      char v34 = sub_10003A294((unint64_t)*a2 >> 60);
      sub_100040B90( "%s (id %llu): extent crypto flag missing on encrypted volume\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v34);
      sub_100044E7C((char *)0x3CE, 92);
      if (sub_1000428C4(qword_10008DB70, "Set missing flag? ", v42, v43, v44, v45, v46, v47, v115))
      {
        LOBYTE(v15) = v15 | 1;
        *(_BYTE *)(a3 + 7) = v15;
        *(void *)(a3 + 16) = *(void *)(a3 + 8);
        *a5 = 1;
        goto LABEL_31;
      }
    }
  }

  else
  {
    if (*(void *)(a3 + 16))
    {
      char v48 = sub_10003A294((unint64_t)*a2 >> 60);
      sub_100040C68( "%s (id %llu): invalid sparse extent with nonzero crypto_id (%llu)\n",  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v48);
      sub_100044E7C((char *)0x341, 92);
      if (sub_1000428C4( qword_10008DB70,  "Fix crypto_id (%llu)? ",  v56,  v57,  v58,  v59,  v60,  v61,  *(void *)(a3 + 16)))
      {
        *(void *)(a3 + 16) = 0LL;
        *a5 = 1;
      }
    }

    if ((v10 & 0x100000000000000LL) != 0 && (*(_BYTE *)(*(void *)(a1 + 40) + 264LL) & 9) == 0)
    {
      char v63 = sub_10003A294((unint64_t)*a2 >> 60);
      sub_100040C68("%s (id %llu): extent crypto flag set on sparse extent\n", v64, v65, v66, v67, v68, v69, v70, v63);
      sub_100044E7C((char *)0x3E8, 92);
      if (sub_1000428C4(qword_10008DB70, "Clear invalid flag? ", v71, v72, v73, v74, v75, v76, v116))
      {
        *(_BYTE *)(a3 + 7) = (v10 & 0xFE00000000000000LL) >> 56;
        *a5 = 1;
      }
    }
  }

  return result;
}

uint64_t sub_100015F10(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = off_10008D690(*a3, a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_100015F4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v9 = (unsigned __int8 *)(a4 + 4 + 4LL * a5);
  int v10 = *v9;
  if ((v10 - 1) > 1 || *(_WORD *)(a4 + 4 + 4LL * a5 + 2) == 8)
  {
    if (v10 != 2)
    {
      if (v10 == 1)
      {
        uint64_t v11 = *a6;
        if ((unint64_t)*a6 <= 0xF && (unint64_t)(v11 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v12 = *(void *)a3 >> 60;
          if ((_DWORD)v12 == 14) {
            LODWORD(v12) = *(unsigned __int8 *)(a3 + 8);
          }
          char v13 = sub_10003A294(v12);
          sub_10003A2C4(a3, *v9);
          sub_100040C68( "%s (id %llu): xf %u/%u: %s: invalid sibling_id (%llu)\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v13);
          sub_100044E7C((char *)0xC0, -2);
        }

        if (*(void *)(a7 + 40) < (unint64_t)(v11 + 1))
        {
          uint64_t v21 = 0LL;
          *(void *)(a7 + 40) = v11 + 1;
          return v21;
        }
      }

      else
      {
        uint64_t v31 = *(void *)a3 >> 60;
        if ((_DWORD)v31 == 14) {
          LODWORD(v31) = *(unsigned __int8 *)(a3 + 8);
        }
        char v32 = sub_10003A294(v31);
        sub_10003A2C4(a3, *v9);
        sub_100040C68("%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n", v33, v34, v35, v36, v37, v38, v39, v32);
        sub_100044E7C((char *)0xC1, -5);
      }
    }

    return 0LL;
  }

  uint64_t v22 = *(void *)a3 >> 60;
  if ((_DWORD)v22 == 14) {
    LODWORD(v22) = *(unsigned __int8 *)(a3 + 8);
  }
  char v23 = sub_10003A294(v22);
  sub_10003A2C4(a3, *v9);
  sub_100040B90( "%s (id %llu): xf %u/%u: %s: invalid extended field size %u for type %u, expected %lu\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v23);
  uint64_t v21 = 92LL;
  sub_100044E7C((char *)0x3D6, 92);
  return v21;
}

uint64_t sub_100016130(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a2 + 48);
  if (!v8) {
    uint64_t v8 = *(void *)(a2 + 40);
  }
  if ((*(_BYTE *)(v8 + 56) & 0x20) == 0)
  {
    char v9 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040C68("%s (id %llu): Found data hash on unsealed volume\n", v10, v11, v12, v13, v14, v15, v16, v9);
    sub_100044E7C((char *)0x3A4, -5);
    return sub_1000251C0((_DWORD *)(a2 + 704), 8u, 0, 0, 0, (__int128 *)a3, 0x10u, 0LL, 0);
  }

  if ((*(_WORD *)(a3 + 8) & 0x3FFF) != 0)
  {
    char v18 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90( "%s (id %llu): Logical address %llu of data hash not a multiple of the hash chunk size (%u)\n",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v18);
    uint64_t v26 = 92LL;
    uint64_t v27 = 933LL;
LABEL_11:
    int v50 = 92;
    goto LABEL_12;
  }

  uint64_t v28 = *(unsigned __int8 *)(a4 + 2);
  if (*(_DWORD *)(a2 + 20) != (_DWORD)v28)
  {
    char v42 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): Unexpected hash size (%u != %u)\n", v43, v44, v45, v46, v47, v48, v49, v42);
    uint64_t v26 = 92LL;
    uint64_t v27 = 934LL;
    goto LABEL_11;
  }

  if (sub_100007F14(a4 + 3, 0LL, 8 * v28))
  {
    char v34 = sub_10003A294(*(void *)a3 >> 60);
    sub_100040B90("%s (id %llu): Invalid hash at offset %llu\n", v35, v36, v37, v38, v39, v40, v41, v34);
    uint64_t v26 = 92LL;
    uint64_t v27 = 935LL;
    goto LABEL_11;
  }

  uint64_t v26 = sub_10000B68C(a1, (void *)a3, (_WORD *)a4, v29, v30, v31, v32, v33);
  if (!(_DWORD)v26) {
    return v26;
  }
  uint64_t v27 = 936LL;
  int v50 = v26;
LABEL_12:
  sub_100044E7C((char *)v27, v50);
  return v26;
}

uint64_t sub_1000162E4( int a1, int a2, uint64_t a3, uint64_t a4, int a5, void *__src, int a7, int a8, _BYTE *a9)
{
  uint64_t v10 = (_BYTE *)(a4 + 4 + 4LL * a5);
  if (*v10 == 1)
  {
    size_t v11 = *(unsigned __int16 *)(a4 + 4 + 4LL * a5 + 2);
    if (v11 < 0x100)
    {
      memcpy(a9 + 1, __src, v11);
      uint64_t v21 = 0LL;
      *a9 = 1;
    }

    else
    {
      uint64_t v12 = *(void *)a3 >> 60;
      if ((_DWORD)v12 == 14) {
        LODWORD(v12) = *(unsigned __int8 *)(a3 + 8);
      }
      char v13 = sub_10003A294(v12);
      sub_10003A2C4(a3, *v10);
      sub_100040B90( "%s (id %llu): xf %u/%u: %s: invalid extended field size %u, max %u\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v13);
      uint64_t v21 = 92LL;
      sub_100044E7C((char *)0x521, 92);
    }
  }

  else
  {
    uint64_t v22 = *(void *)a3 >> 60;
    if ((_DWORD)v22 == 14) {
      LODWORD(v22) = *(unsigned __int8 *)(a3 + 8);
    }
    char v23 = sub_10003A294(v22);
    sub_10003A2C4(a3, *v10);
    sub_100040C68("%s (id %llu): xf %u/%u: %s: invalid x_type (%u)\n", v24, v25, v26, v27, v28, v29, v30, v23);
    sub_100044E7C((char *)0x522, -5);
    return 0LL;
  }

  return v21;
}

uint64_t sub_100016440(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t v6 = (unsigned __int8 *)(a4 + 4 + 4LL * a5);
  if (*v6 - 1 > 1)
  {
    uint64_t v17 = *(void *)a3 >> 60;
    if ((_DWORD)v17 == 14) {
      LODWORD(v17) = *(unsigned __int8 *)(a3 + 8);
    }
    char v18 = sub_10003A294(v17);
    sub_10003A2C4(a3, *v6);
    sub_100040C68("%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n", v19, v20, v21, v22, v23, v24, v25, v18);
    sub_100044E7C((char *)0x50A, -5);
    return 0LL;
  }

  if (*(_WORD *)(a4 + 4 + 4LL * a5 + 2) == 8) {
    return 0LL;
  }
  uint64_t v7 = *(void *)a3 >> 60;
  if ((_DWORD)v7 == 14) {
    LODWORD(v7) = *(unsigned __int8 *)(a3 + 8);
  }
  char v8 = sub_10003A294(v7);
  sub_10003A2C4(a3, *v6);
  sub_100040B90( "%s (id %llu): xf %u/%u: %s: invalid extended field size %u for type %u, expected %lu\n",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v8);
  uint64_t v16 = 92LL;
  sub_100044E7C((char *)0x509, 92);
  return v16;
}

uint64_t sub_100016584( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = a4 + 4LL * a5;
  unsigned int v13 = *(unsigned __int8 *)(v10 + 4);
  uint64_t v12 = (unsigned __int8 *)(v10 + 4);
  uint64_t v11 = v13;
  if (v13 > 4 || ((_DWORD)v11 ? (BOOL v14 = word_10006B186[v11] == *((unsigned __int16 *)v12 + 1)) : (BOOL v14 = 1), v14))
  {
    switch((int)v11)
    {
      case 1:
        uint64_t v15 = 0LL;
        *(void *)(a9 + 8) = *a6;
        *(_BYTE *)a9 = 1;
        break;
      case 2:
        uint64_t v25 = *a6;
        if ((unint64_t)(*a6 - 1LL) > 0xE || (unint64_t)(v25 - 4) > 0xFFFFFFFFFFFFFFFDLL)
        {
        }

        else
        {
          uint64_t v26 = *(void *)a3 >> 60;
          if ((_DWORD)v26 == 14) {
            LODWORD(v26) = *(unsigned __int8 *)(a3 + 8);
          }
          char v27 = sub_10003A294(v26);
          sub_10003A2C4(a3, *v12);
          sub_100040B90( "%s (id %llu): xf %u/%u: %s: invalid shadow_key (%llu)\n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v27);
          sub_100044E7C((char *)0x53B, -2);
        }

        uint64_t v15 = 0LL;
        *(void *)(a9 + 56) = v25;
        *(_BYTE *)(a9 + 48) = 1;
        break;
      case 3:
        uint64_t v15 = 0LL;
        *(void *)(a9 + 24) = *a6;
        *(_BYTE *)(a9 + 16) = 1;
        break;
      case 4:
        uint64_t v15 = 0LL;
        *(void *)(a9 + 40) = *a6;
        *(_BYTE *)(a9 + 32) = 1;
        break;
      default:
        uint64_t v35 = *(void *)a3 >> 60;
        if ((_DWORD)v35 == 14) {
          LODWORD(v35) = *(unsigned __int8 *)(a3 + 8);
        }
        char v36 = sub_10003A294(v35);
        sub_10003A2C4(a3, *v12);
        sub_100040C68("%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n", v37, v38, v39, v40, v41, v42, v43, v36);
        sub_100044E7C((char *)0x4E7, -5);
        uint64_t v15 = 0LL;
        break;
    }
  }

  else
  {
    uint64_t v16 = *(void *)a3 >> 60;
    if ((_DWORD)v16 == 14) {
      LODWORD(v16) = *(unsigned __int8 *)(a3 + 8);
    }
    char v17 = sub_10003A294(v16);
    sub_10003A2C4(a3, *v12);
    sub_100040B90( "%s (id %llu): xf %u/%u: %s: invalid extended field size %u, expected %u\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v17);
    uint64_t v15 = 92LL;
    sub_100044E7C((char *)0x4E6, 92);
  }

  return v15;
}

uint64_t sub_1000167D4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, void *a6, uint64_t a7, uint64_t a8, void *a9)
{
  uint64_t v10 = (unsigned __int8 *)(a4 + 4 + 4LL * a5);
  int v11 = *v10;
  if ((v11 - 1) > 1 || *(_WORD *)(a4 + 4 + 4LL * a5 + 2) == 8)
  {
    if (v11 == 1)
    {
      if ((*a6 & 0x1FFFFFFFFFFFFFLL) == 0)
      {
        uint64_t v44 = *(void *)a3 >> 60;
        if ((_DWORD)v44 == 14) {
          LODWORD(v44) = *(unsigned __int8 *)(a3 + 8);
        }
        char v45 = sub_10003A294(v44);
        sub_10003A2C4(a3, *v10);
        sub_100040C68( "%s (id %llu): xf %u/%u: %s: invalid attribution hash (%llu)\n",  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v45);
        uint64_t v33 = 1297LL;
        goto LABEL_26;
      }

      uint64_t v14 = 0LL;
      a9[1] = *a6;
    }

    else
    {
      if (v11 != 2)
      {
        uint64_t v24 = *(void *)a3 >> 60;
        if ((_DWORD)v24 == 14) {
          LODWORD(v24) = *(unsigned __int8 *)(a3 + 8);
        }
        char v25 = sub_10003A294(v24);
        sub_10003A2C4(a3, *v10);
        sub_100040C68("%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n", v26, v27, v28, v29, v30, v31, v32, v25);
        uint64_t v33 = 1298LL;
        int v34 = -5;
        goto LABEL_27;
      }

      uint64_t v12 = *a6;
      if (*a6 <= 0xFuLL && v12 != 2)
      {
        uint64_t v35 = *(void *)a3 >> 60;
        if ((_DWORD)v35 == 14) {
          LODWORD(v35) = *(unsigned __int8 *)(a3 + 8);
        }
        char v36 = sub_10003A294(v35);
        sub_10003A2C4(a3, *v10);
        sub_100040C68( "%s (id %llu): xf %u/%u: %s: invalid dir_stats_key (%llu)\n",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v36);
        uint64_t v33 = 1296LL;
LABEL_26:
        int v34 = -2;
LABEL_27:
        sub_100044E7C((char *)v33, v34);
        return 0LL;
      }

      *a9 = v12;
      uint64_t v14 = 0LL;
      *(void *)(a7 + 40) = v12 + 1;
    }
  }

  else
  {
    uint64_t v15 = *(void *)a3 >> 60;
    if ((_DWORD)v15 == 14) {
      LODWORD(v15) = *(unsigned __int8 *)(a3 + 8);
    }
    char v16 = sub_10003A294(v15);
    sub_10003A2C4(a3, *v10);
    sub_100040B90( "%s (id %llu): xf %u/%u: %s: invalid extended field size %u for type %u, expected %lu\n",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v16);
    uint64_t v14 = 92LL;
    sub_100044E7C((char *)0x50F, 92);
  }

  return v14;
}

uint64_t sub_100016A20(uint64_t a1)
{
  qword_100074C80 = a1;
  if (!sub_100034B44( (uint64_t)&unk_100074C88,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  8,  160,  0,  0LL,  (uint64_t)sub_10002D39C)) {
    sub_100036C00((uint64_t)&unk_100074C88, 0LL, 0);
  }
  uint64_t result = sub_10001A7FC((uint64_t)&unk_100074C88, (uint64_t)"dir stats", (uint64_t)sub_100016ADC);
  if ((_DWORD)result)
  {
    sub_100040C68("failed to register the dir stats tree in the fsck memory storage\n", v2, v3, v4, v5, v6, v7, v8, v9);
    uint64_t result = (uint64_t)sub_100044E7C((char *)0x57C, 12);
  }

  byte_100074CC8 = 0;
  return result;
}

uint64_t sub_100016ADC()
{
  if (qword_100074DB0) {
    uint64_t result = sub_100036CD8((uint64_t)&unk_100074D78, 0LL);
  }
  if (byte_100074CC8 == 1)
  {
    byte_100074CC8 = 0;
    uint64_t result = sub_100016ADC();
  }

  if (qword_100074CC0) {
    uint64_t result = sub_100036CD8((uint64_t)&unk_100074C88, 0LL);
  }
  qword_100074CD0 = 0LL;
  return result;
}

uint64_t sub_100016B44()
{
  if (qword_100074DB0) {
    return sub_100036CD8((uint64_t)&unk_100074D78, 0LL);
  }
  return result;
}

void sub_100016B64(uint64_t a1, uint64_t *a2)
{
}

void sub_100016BB4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15)
{
  if (byte_100074CC8 == 1)
  {
    byte_100074CC8 = 0;
    sub_100016ADC();
  }

  if (qword_100074CC0)
  {
    sub_100016DCC(a1);
    if (!v23)
    {
      if (a1 == a3) {
        uint64_t v24 = 0LL;
      }
      else {
        uint64_t v24 = a3;
      }
      qword_100074CE8 = v24;
      qword_100074CF0 = a2;
      if (a1 == a3) {
        __int16 v25 = 257;
      }
      else {
        __int16 v25 = 1;
      }
      if (a14) {
        __int16 v26 = 128;
      }
      else {
        __int16 v26 = 0;
      }
      *(void *)&xmmword_100074CD8 = a15;
      *((void *)&xmmword_100074CD8 + 1) = a3;
      qword_100074D00 = a4;
      qword_100074D10 = a5;
      dword_100074D70 = a7;
      qword_100074D20 = a6;
      if (a8) {
        __int16 v27 = 8;
      }
      else {
        __int16 v27 = 0;
      }
      qword_100074D30 = a9;
      if (a10) {
        __int16 v28 = 32;
      }
      else {
        __int16 v28 = 0;
      }
      __int16 v29 = v27 | v28;
      qword_100074D40 = a11;
      if (a12) {
        __int16 v30 = 64;
      }
      else {
        __int16 v30 = 0;
      }
      word_100074D74 = word_100074D74 & 0xFF16 | v25 | v26 | v29 | v30;
      qword_100074D50 = a13;
    }
  }

void sub_100016CE8( uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, char a6, uint64_t a7, char a8, uint64_t a9, char a10, uint64_t a11)
{
}

void sub_100016D54(uint64_t a1, uint64_t a2)
{
  if (byte_100074CC8 == 1)
  {
    byte_100074CC8 = 0;
    sub_100016ADC();
  }

  if (a2 && qword_100074CC0)
  {
    sub_100016DCC(a1);
    if (!v8) {
      sub_100016E74((char *)&qword_100074D28, a2, a1, (uint64_t)"resource fork size", v4, v5, v6, v7);
    }
  }

double sub_100016DCC(uint64_t a1)
{
  if (qword_100074CD0 != a1 && !sub_100018BFC() && a1)
  {
    *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v12 = v3;
    __int128 v13 = v3;
    __int128 v10 = v3;
    __int128 v11 = v3;
    __int128 v8 = v3;
    __int128 v9 = v3;
    __int128 v6 = v3;
    __int128 v7 = v3;
    __int128 v4 = v3;
    __int128 v5 = v3;
    if (!sub_100019A74(a1, &v4))
    {
      qword_100074CD0 = a1;
      *(_OWORD *)&qword_100074D38 = v10;
      *(_OWORD *)&qword_100074D48 = v11;
      xmmword_100074D58 = v12;
      unk_100074D68 = v13;
      *(_OWORD *)&qword_100074CF8 = v6;
      *(_OWORD *)&qword_100074D08 = v7;
      *(_OWORD *)&qword_100074D18 = v8;
      *(_OWORD *)&qword_100074D28 = v9;
      double result = *(double *)&v4;
      xmmword_100074CD8 = v4;
      *(_OWORD *)&qword_100074CE8 = v5;
    }
  }

  return result;
}

char *sub_100016E74( char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8 = __OFADD__(*(void *)result, a2);
  *(void *)result += a2;
  if (v8)
  {
    __int128 v9 = result;
    sub_100040C68("dir-stats object (id %llu): %s overflow\n", a2, a3, a4, a5, a6, a7, a8, a3);
    *(void *)__int128 v9 = 0x7FFFFFFFFFFFFFFFLL;
    return sub_100044E7C((char *)0x56D, 84);
  }

  return result;
}

void sub_100016ED8(uint64_t a1, uint64_t a2, int a3)
{
  if (byte_100074CC8 == 1)
  {
    byte_100074CC8 = 0;
    sub_100016ADC();
  }

  if (qword_100074CC0)
  {
    sub_100016DCC(a1);
    if (!v10)
    {
      if (a3) {
        sub_100016E74((char *)&xmmword_100074D58 + 8, 1LL, a1, (uint64_t)"SAF descendants", v6, v7, v8, v9);
      }
      sub_100016E74((char *)&qword_100074D08, 1LL, a1, (uint64_t)"descendants", v6, v7, v8, v9);
      sub_100016E74((char *)&qword_100074D18, a2, a1, (uint64_t)"physical size", v11, v12, v13, v14);
    }
  }

void sub_100016F90(uint64_t a1, uint64_t a2, int a3)
{
  if (byte_100074CC8 == 1)
  {
    byte_100074CC8 = 0;
    sub_100016ADC();
  }

  if (!qword_100074CC0) {
    return;
  }
  sub_100016DCC(a1);
  if (v13) {
    return;
  }
  if ((unint64_t)(qword_100074CF8 - 1) > 0xFFFFFFFFFFFFFFFDLL)
  {
LABEL_11:
    qword_100074CF8 = a2;
    if ((a3 & 0x20000000) != 0) {
      word_100074D74 |= 4u;
    }
    if ((a3 & 0x80000) != 0) {
      word_100074D74 |= 0x10u;
    }
    return;
  }

  uint64_t v14 = qword_100074CF0;
  if (!qword_100074CF0)
  {
    sub_100040C68( "dir_stats (id %llu) already has a registered origin (id %llu), but we found another one (id %llu)\n",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  a1);
    sub_100044E7C((char *)0x4DE, -8);
    goto LABEL_11;
  }

  if (qword_100074CF0 == qword_100074CF8)
  {
    sub_100040C68( "dir_stats (id %llu) already has a registered origin (id %llu), but we found another one (id %llu)\n",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  a1);
    sub_100044E7C((char *)0x4DE, -8);
    return;
  }

  sub_100040C68( "dir_stats (id %llu) already has a registered origin (id %llu), but we found another one (id %llu)\n",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  a1);
  sub_100044E7C((char *)0x4DE, -8);
  if (v14 == a2) {
    goto LABEL_11;
  }
}

void sub_1000170D0(uint64_t a1, uint64_t a2)
{
  if (byte_100074CC8 == 1)
  {
    byte_100074CC8 = 0;
    sub_100016ADC();
  }

  if (a2 && qword_100074CC0)
  {
    sub_100016DCC(a1);
    if (!v8) {
      sub_100016E74((char *)&qword_100074D38, a2, a1, (uint64_t)"clone size", v4, v5, v6, v7);
    }
  }

void sub_100017148(uint64_t a1, uint64_t a2)
{
}

void sub_100017150(uint64_t a1, uint64_t a2)
{
  if (byte_100074CC8 == 1)
  {
    byte_100074CC8 = 0;
    sub_100016ADC();
  }

  if (a2 && qword_100074CC0)
  {
    sub_100016DCC(a1);
    if (!v8) {
      sub_100016E74((char *)&qword_100074D48, a2, a1, (uint64_t)"purgeable size", v4, v5, v6, v7);
    }
  }

void sub_1000171C8(uint64_t a1, uint64_t a2)
{
  if (byte_100074CC8 == 1)
  {
    byte_100074CC8 = 0;
    sub_100016ADC();
  }

  if (a2 && qword_100074CC0)
  {
    sub_100016DCC(a1);
    if (!v8) {
      sub_100016E74((char *)&xmmword_100074D58, a2, a1, (uint64_t)"purgeable rsrc size", v4, v5, v6, v7);
    }
  }

uint64_t sub_100017240(uint64_t a1, void *a2, _DWORD *a3)
{
  uint64_t v6 = &unk_100074000;
  if (byte_100074CC8 == 1)
  {
    byte_100074CC8 = 0;
    sub_100016ADC();
  }

  uint64_t v7 = &unk_100074000;
  if (!qword_100074CC0) {
    return 0LL;
  }
  uint64_t v177 = 0LL;
  uint64_t v176 = 0LL;
  uint64_t v175 = 0LL;
  __int128 v173 = 0u;
  __int128 v174 = 0u;
  __int128 v171 = 0u;
  __int128 v172 = 0u;
  __int128 v169 = 0u;
  __int128 v170 = 0u;
  __int128 v167 = 0u;
  __int128 v168 = 0u;
  __int128 v165 = 0u;
  __int128 v166 = 0u;
  uint64_t v8 = a2[6];
  if (!v8) {
    uint64_t v8 = a2[5];
  }
  uint64_t v9 = *(void *)(v8 + 56);
  char v10 = sub_100001F58();
  uint64_t v11 = sub_100018BFC();
  if ((_DWORD)v11) {
    goto LABEL_290;
  }
  *(void *)&__int128 v180 = 0LL;
  sub_100036AE0((uint64_t)dword_100074C88, 0LL, &v180);
  if (!(void)v180) {
    goto LABEL_103;
  }
  __int16 v150 = v9;
  unint64_t v151 = a3;
  int v164 = 8;
  unsigned int v163 = 160;
  if (!sub_10003510C((uint64_t)dword_100074C88, 0LL, &v177, &v164, &v165, &v163))
  {
    do
    {
      if ((BYTE9(v174) & 4) != 0 || (WORD6(v174) & 0x100) != 0 || (void)v166 != *((void *)&v165 + 1))
      {
        uint64_t v12 = sub_100018EC8(a1, a2, v177, (uint64_t)&v165);
        if ((_DWORD)v12)
        {
LABEL_286:
          uint64_t v11 = v12;
          goto LABEL_290;
        }
      }

      unsigned int v162 = 8;
      unsigned int v161 = 160;
    }

    while (!sub_100034BB4((uint64_t)dword_100074C88, 0LL, 2LL, &v177, &v162, 8u, &v165, &v161));
  }

  int v160 = 8;
  unsigned int v159 = 160;
  uint64_t v154 = a1;
  if (sub_10003510C((uint64_t)dword_100074C88, 0LL, &v177, &v160, &v165, &v159))
  {
LABEL_15:
    *(void *)uint64_t v194 = 0LL;
    __int128 v188 = 0u;
    __int128 v189 = 0u;
    __int128 v186 = 0u;
    __int128 v187 = 0u;
    __int128 v184 = 0u;
    __int128 v185 = 0u;
    __int128 v182 = 0u;
    __int128 v183 = 0u;
    __int128 v180 = 0u;
    __int128 v181 = 0u;
    if (!sub_100034B44( (uint64_t)dword_100074D78,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  16,  0,  0,  0LL,  (uint64_t)sub_10002D3D0)) {
      sub_100036C00((uint64_t)dword_100074D78, 0LL, 0);
    }
    if (sub_10001A7FC((uint64_t)dword_100074D78, (uint64_t)"dir stats repairs", (uint64_t)sub_100016B44))
    {
      sub_100040C68( "failed to register the dir stats repair tree in the fsck memory storage\n",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v148);
      sub_100044E7C((char *)0x59C, 12);
    }

    if (qword_100074DB0)
    {
      LODWORD(v155) = 8;
      LODWORD(v191) = 160;
      if (sub_10003510C((uint64_t)dword_100074C88, 0LL, v194, &v155, &v180, (unsigned int *)&v191))
      {
LABEL_23:
        char v32 = v10;
        if (qword_100074DB0)
        {
          if (v6[3272] == 1)
          {
            v6[3272] = 0;
            sub_100016ADC();
          }

          if (v7[408])
          {
            *(void *)&__int128 v180 = 0LL;
            sub_100036AE0((uint64_t)dword_100074D78, 0LL, &v180);
            uint64_t v33 = v180;
            *(void *)&__int128 v180 = 0LL;
            sub_100036AE0((uint64_t)dword_100074C88, 0LL, &v180);
            if (v33 == (void)v180)
            {
              *(void *)&__int128 v180 = v176;
              LODWORD(v178) = 16;
              *(_DWORD *)uint64_t v194 = 0;
              unsigned int v34 = sub_100034BB4( (uint64_t)dword_100074D78,  0LL,  2LL,  &v175,  (unsigned int *)&v178,  0x10u,  &v192,  (unsigned int *)v194);
              if (!v34)
              {
                *(void *)&__int128 v180 = v176;
                LODWORD(v155) = 8;
                LODWORD(v191) = 160;
                unsigned int v34 = sub_100034BB4( (uint64_t)dword_100074C88,  0LL,  0LL,  &v180,  (unsigned int *)&v155,  8u,  &v165,  (unsigned int *)&v191);
              }

              char v35 = 1;
              goto LABEL_99;
            }
          }
        }

        goto LABEL_95;
      }

      while (1)
      {
        unint64_t v178 = v189;
        unint64_t v179 = *(void *)v194;
        int v24 = sub_1000364F0(dword_100074D78, 0LL, &v178, 16LL, &v192, 0LL);
        if (v24) {
          break;
        }
        LODWORD(v190) = 8;
        unsigned int v193 = 160;
        if (sub_100034BB4( (uint64_t)dword_100074C88,  0LL,  2LL,  v194,  (unsigned int *)&v190,  8u,  &v180,  &v193)) {
          goto LABEL_23;
        }
      }

      int v66 = v24;
      sub_100040C68( "failed to insert dir-stats entry %llu into the repair tree\n",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v194[0]);
      sub_100044E7C((char *)0x59F, v66);
      sub_100036CD8((uint64_t)dword_100074D78, 0LL);
    }

    else
    {
      sub_100040C68("failed to init the dir stats repair tree\n", v17, v18, v19, v20, v21, v22, v23, v148);
      sub_100044E7C((char *)0x59E, 12);
    }

    char v32 = v10;
LABEL_95:
    if (v6[3272] == 1)
    {
      v6[3272] = 0;
      sub_100016ADC();
    }

    if (v7[408])
    {
      *(void *)&__int128 v180 = v176;
      LODWORD(v190) = 8;
      unsigned int v193 = 160;
      unsigned int v34 = sub_100034BB4((uint64_t)dword_100074C88, 0LL, 2LL, &v180, (unsigned int *)&v190, 8u, &v165, &v193);
      char v35 = 0;
      uint64_t v175 = v174;
      uint64_t v176 = v180;
LABEL_99:
      if (v34)
      {
LABEL_100:
        if (v34 == 2) {
          uint64_t v11 = 0LL;
        }
        else {
          uint64_t v11 = v34;
        }
        goto LABEL_290;
      }

      if ((v150 & 0x200) != 0) {
        uint64_t v67 = (__int128 *)&v155;
      }
      else {
        uint64_t v67 = (__int128 *)&v190;
      }
      if ((v150 & 0x200) != 0) {
        int v68 = 12;
      }
      else {
        int v68 = 8;
      }
      unsigned int v153 = v68;
      while (1)
      {
        uint64_t v190 = (uint64_t *)(v176 & 0xFFFFFFFFFFFFFFFLL | 0xA000000000000000LL);
        uint64_t v191 = v176;
        unint64_t v155 = v176 & 0xFFFFFFFFFFFFFFFLL | 0xE000000000000000LL;
        int v156 = 18;
        __int128 v182 = 0u;
        __int128 v183 = 0u;
        __int128 v180 = 0u;
        __int128 v181 = 0u;
        unint64_t v179 = 0xAAAAAAAAAAAAAA00LL;
        unint64_t v178 = v176;
        sub_10003A9B8(a1, a2, qword_100074C80, 3LL, 1u, (uint64_t)sub_10001926C, (unint64_t)&v178);
        if ((_BYTE)v179) {
          goto LABEL_120;
        }
        sub_100040B50( "\n dir-stats %llu (has dir-stats? %d)%s:\n flags: 0x%x\n chained-key: %llu (computed: %llu)\n origin-id: %llu (computed: %llu)\n shadow-key: %llu (exists? %d)\n descendants: %llu (computed: %llu)\n SAF descendants: %llu\n dir-stats descendants: %llu\n physical size: %llu (computed: %llu)\n resource fork size: %llu (computed: %llu)\n clone size: %llu (exists? %d; computed: %llu)\n"
          "purgeable size: %llu (exists? %d; computed: %llu)\n"
          "purgeable resource fork size: %llu (exists? %d; computed: %llu)\n"
          "has calculating dir-stats? %d\n"
          "origin is SAF? %d (parent is SAF? %d)\n"
          "origin is purgeable? %d\n"
          "\n",
          *((uint64_t *)&v171 + 1),
          v172,
          (WORD6(v174) >> 1) & 1,
          (WORD6(v174) >> 2) & 1,
          *((uint64_t *)&v172 + 1),
          v173,
          (WORD6(v174) >> 10) & 1,
          v191);
        if ((BYTE12(v174) & 1) != 0 && !(void)v167 && !(void)v168)
        {
          sub_100040C68("found orphan dir-stats object (id %llu)\n", v69, v70, v71, v72, v73, v74, v75, v191);
          sub_100044E7C((char *)0x576, -8);
          uint64_t v12 = sub_10001A328(v151, 0LL, 0LL, v67, v153, 0LL, 0LL, v76);
          if ((_DWORD)v12) {
            goto LABEL_286;
          }
LABEL_120:
          *(void *)&__int128 v180 = v176;
          if ((v35 & 1) != 0) {
            goto LABEL_121;
          }
          goto LABEL_281;
        }

        int v77 = DWORD2(v174);
        if ((~DWORD2(v174) & 0x30) == 0)
        {
          sub_100040C68( "found dir-stats object (id %llu) that is both shadow and calculating\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
          sub_100044E7C((char *)0x573, 92);
          int v77 = DWORD2(v174);
        }

        if ((v77 & 0x120) != 0) {
          goto LABEL_120;
        }
        if ((BYTE12(v174) & 1) != 0) {
          break;
        }
        sub_100040C68( "missing dir-stats object (id %llu) referenced by %s%llu files / directories\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
        sub_100044E7C((char *)0x4E1, 92);
        if ((unint64_t)(v167 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v12 = sub_1000192F8(v154, a2, v151, v67, (uint64_t)&v165, v78, v79, v80);
          if ((_DWORD)v12) {
            goto LABEL_286;
          }
        }

LABEL_277:
        if ((v35 & 1) != 0)
        {
          uint64_t v12 = sub_1000199F0((uint64_t)&v165, (uint64_t *)&v180);
          if ((_DWORD)v12) {
            goto LABEL_286;
          }
          *(void *)&__int128 v180 = v176;
LABEL_121:
          LODWORD(v178) = 16;
          *(_DWORD *)uint64_t v194 = 0;
          unsigned int v34 = sub_100034BB4( (uint64_t)dword_100074D78,  0LL,  2LL,  &v175,  (unsigned int *)&v178,  0x10u,  &v192,  (unsigned int *)v194);
          if (!v34)
          {
            *(void *)&__int128 v180 = v176;
            LODWORD(v155) = 8;
            LODWORD(v191) = 160;
            unsigned int v34 = sub_100034BB4( (uint64_t)dword_100074C88,  0LL,  0LL,  &v180,  (unsigned int *)&v155,  8u,  &v165,  (unsigned int *)&v191);
          }

          goto LABEL_282;
        }

        *(void *)&__int128 v180 = v176;
LABEL_281:
        LODWORD(v190) = 8;
        unsigned int v193 = 160;
        unsigned int v34 = sub_100034BB4((uint64_t)dword_100074C88, 0LL, 2LL, &v180, (unsigned int *)&v190, 8u, &v165, &v193);
        uint64_t v175 = v174;
        uint64_t v176 = v180;
LABEL_282:
        a1 = v154;
        if (v34) {
          goto LABEL_100;
        }
      }

      if ((v77 & 0x10) == 0)
      {
        if ((v77 & 0x80) != 0)
        {
          if (*((void *)&v166 + 1) && (void)v167 == *((void *)&v166 + 1)) {
            goto LABEL_154;
          }
          if ((unint64_t)(v167 + 1) < 2 || (void)v167 == *((void *)&v166 + 1))
          {
            if (!*((void *)&v166 + 1))
            {
              sub_100040C68( "dir-stats object (id %llu) unexpectedly marked as having origin-id\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
              sub_100044E7C((char *)0x579, -3);
              DWORD2(v174) &= ~0x80u;
            }

            goto LABEL_154;
          }

          sub_100040C68( "origin_id (%llu) of dir-stats object (id %llu) is not as expected (%llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v166));
          uint64_t v82 = 1400LL;
        }

        else
        {
          if ((void)v167) {
            BOOL v81 = *((void *)&v166 + 1) == 0LL;
          }
          else {
            BOOL v81 = 0;
          }
          if (v81) {
            goto LABEL_154;
          }
          if (!(void)v167) {
            goto LABEL_154;
          }
          if (!*((void *)&v166 + 1)) {
            goto LABEL_154;
          }
          sub_100040C68( "dir-stats object (id %llu) unexpectedly unmarked as having origin-id\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
          sub_100044E7C((char *)0x57A, -3);
          DWORD2(v174) |= 0x80u;
          sub_100040C68( "origin_id (%llu) of dir-stats object (id %llu) is not as expected (%llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v166));
          uint64_t v82 = 1407LL;
        }

        sub_100044E7C((char *)v82, -2);
        uint64_t v12 = sub_10001A328(v151, 1LL, 4LL, v67, v153, &v167, 8LL, v83);
        if ((_DWORD)v12) {
          goto LABEL_286;
        }
LABEL_154:
        int v85 = (BYTE12(v174) & 2) >> 1;
        if ((BYTE8(v174) & 0x10) == 0) {
          LOBYTE(v85) = (BYTE12(v174) & 2) == 0;
        }
        if ((v85 & 1) == 0)
        {
          if ((BYTE8(v174) & 0x10) != 0)
          {
            sub_100040C68( "found shadow dir-stats object (id %llu) but did not find its calculating dir-stats (%llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
            uint64_t v86 = 1396LL;
          }

          else
          {
            sub_100040C68( "found non-shadow dir-stats object (id %llu) that has calculating dir-stats\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
            uint64_t v86 = 1408LL;
          }

          sub_100044E7C((char *)v86, 92);
        }

        if ((void)v165)
        {
          sub_100040C68( "found shadow key (%llu) on non-calculating dir-stats object (id %llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v165);
          sub_100044E7C((char *)0x575, -2);
          v194[0] = 2;
          uint64_t v12 = sub_10001A328(v151, 1LL, 6LL, v67, v153, v194, 1LL, v87);
          if ((_DWORD)v12) {
            goto LABEL_286;
          }
        }

        char v88 = BYTE8(v174);
        if ((BYTE8(v174) & 0x12) == 2 && (BYTE12(v174) & 4) == 0)
        {
          sub_100040C68( "dir-stats object (id %llu) is SAF, but its origin isn't\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
          sub_100044E7C((char *)0x52F, 92);
          char v88 = BYTE8(v174);
        }

        if ((v88 & 2) != 0 || (BYTE12(v174) & 4) != 0)
        {
          if ((void)v168 == *((void *)&v173 + 1)) {
            goto LABEL_188;
          }
          sub_100040C68( "SAF descendants (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v173));
          sub_100044E7C((char *)0x530, 92);
          int v89 = DWORD2(v174);
          if ((uint64_t)v168 >= 1 && !*((void *)&v173 + 1))
          {
            if ((BYTE8(v174) & 2) != 0) {
              DWORD2(v174) &= ~2u;
            }
            if ((BYTE12(v174) & 4) == 0) {
              goto LABEL_188;
            }
            uint64_t v69 = v167;
            if (!(void)v167 || (void)v167 == -1LL) {
              goto LABEL_188;
            }
            uint64_t v12 = sub_100024184(v151, v167, 0x20000000LL, v71, v72, v73, v74, v75);
            if ((_DWORD)v12) {
              goto LABEL_286;
            }
            uint64_t v90 = -1LL;
            goto LABEL_186;
          }
        }

        else
        {
          if ((void)v174 || !*((void *)&v173 + 1) || (WORD6(v174) & 0x200) != 0) {
            goto LABEL_188;
          }
          sub_100040C68( "SAF descendants (%llu) of dir-stats object (id %llu) is greater than expected (0)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v173));
          sub_100044E7C((char *)0x59B, 92);
          int v89 = DWORD2(v174);
          if ((uint64_t)v168 >= 1 && *((void *)&v173 + 1) == (void)v168)
          {
            DWORD2(v174) |= 2u;
            uint64_t v69 = v167;
            if ((unint64_t)(v167 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
            {
              uint64_t v12 = sub_100024108(v151, v167, 0x20000000LL, v71, v72, v73, v74, v75);
              if ((_DWORD)v12) {
                goto LABEL_286;
              }
              uint64_t v90 = 1LL;
LABEL_186:
              *((void *)&v180 + 1) = v90;
            }

LABEL_188:
            if ((void)v168 != *((void *)&v167 + 1))
            {
              sub_100040C68( "descendants (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v167));
              sub_100044E7C((char *)0x4E2, 92);
              uint64_t v12 = sub_10001A328(v151, 1LL, 2LL, v67, v153, &v168, 8LL, v91);
              if ((_DWORD)v12) {
                goto LABEL_286;
              }
            }

            if ((void)v169 != *((void *)&v168 + 1))
            {
              sub_100040C68( "physical_size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v168));
              sub_100044E7C((char *)0x4E3, 92);
              uint64_t v12 = sub_10001A328(v151, 1LL, 5LL, v67, v153, &v169, 8LL, v92);
              if ((_DWORD)v12) {
                goto LABEL_286;
              }
            }

            char v93 = v32 ^ 1;
            if ((BYTE12(v174) & 8) == 0) {
              char v93 = 1;
            }
            if ((v93 & 1) == 0)
            {
              sub_100040B50( "skipping dir stats clone sizes repair because the clone mapping repairs were aborted\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v149);
              goto LABEL_203;
            }

            if ((BYTE12(v174) & 8) != 0 && (*((void *)&v170 + 1) & 0x8000000000000000LL) != 0)
            {
              sub_100040C68( "skipping dir stats clone sizes repair: present clone size %llu > %llu\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v170));
              uint64_t v94 = 1417LL;
              int v95 = 84;
LABEL_202:
              sub_100044E7C((char *)v94, v95);
              goto LABEL_203;
            }

            if ((BYTE12(v174) & 8) != 0 && (v171 & 0x8000000000000000LL) != 0)
            {
              sub_100040B50( "skipping dir stats clone sizes repair because the computed clone size is negative\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v149);
              uint64_t v94 = 1418LL;
              int v95 = 92;
              goto LABEL_202;
            }

            if ((BYTE12(v174) & 8) != 0 && (BYTE8(v174) & 4) != 0) {
              goto LABEL_240;
            }
            if (!(BYTE12(v174) & 8 | BYTE8(v174) & 4)) {
              goto LABEL_203;
            }
            if ((BYTE8(v174) & 4) == 0)
            {
              if ((BYTE12(v174) & 8) == 0) {
                goto LABEL_203;
              }
              sub_100040C68( "clone size xfield of dir-stats object (id %llu) exists unexpectedly\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
              sub_100044E7C((char *)0x562, -3);
              v194[0] = 1;
              unint64_t v119 = v151;
              uint64_t v120 = 6LL;
              unint64_t v121 = v67;
              uint64_t v122 = v153;
              uint64_t v123 = 1LL;
LABEL_243:
              uint64_t v12 = sub_10001A328(v119, 1LL, v120, v121, v122, v194, v123, v118);
              if ((_DWORD)v12) {
                goto LABEL_286;
              }
LABEL_203:
              char v96 = BYTE8(v174);
              if ((WORD4(v174) & 0x800) != 0)
              {
                if ((~DWORD2(v174) & 9) == 0 && (BYTE12(v174) & 0x40) != 0 && (void)v173 == *((void *)&v172 + 1)) {
                  goto LABEL_219;
                }
                if ((BYTE8(v174) & 8) == 0)
                {
                  sub_100040C68( "purgeable resource forks are maintained on dir-stats object (id %llu) but not purgeable data forks\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
                  sub_100044E7C((char *)0x5AF, -3);
                  char v96 = BYTE8(v174) | 8;
                  DWORD2(v174) |= 8u;
                }

                if ((v96 & 1) == 0)
                {
                  sub_100040C68( "purgeable resource forks are maintained on dir-stats object (id %llu) but not rsrc forks\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
                  sub_100044E7C((char *)0x5B0, -3);
                  DWORD2(v174) |= 1u;
                }

                if ((BYTE12(v174) & 0x40) != 0)
                {
                  if ((void)v173 == *((void *)&v172 + 1)) {
                    goto LABEL_219;
                  }
                  sub_100040C68( "purgeable resource fork size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v172));
                  uint64_t v103 = 1458LL;
                  int v104 = 92;
                }

                else
                {
                  sub_100040C68( "purgeable resource fork size xfield is missing from dir-stats object (id %llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
                  uint64_t v103 = 1457LL;
                  int v104 = -3;
                }

                sub_100044E7C((char *)v103, v104);
                *(_DWORD *)uint64_t v194 = 524292;
                *(void *)&v194[4] = v173;
                uint64_t v98 = v151;
                uint64_t v99 = 8LL;
                uint64_t v100 = v67;
                uint64_t v101 = v153;
                uint64_t v102 = 12LL;
              }

              else
              {
                if ((BYTE12(v174) & 0x40) == 0) {
                  goto LABEL_219;
                }
                sub_100040C68( "purgeable resource fork size xfield of dir-stats object (id %llu) exists unexpectedly\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
                sub_100044E7C((char *)0x5B3, -3);
                v194[0] = 4;
                uint64_t v98 = v151;
                uint64_t v99 = 6LL;
                uint64_t v100 = v67;
                uint64_t v101 = v153;
                uint64_t v102 = 1LL;
              }

              uint64_t v12 = sub_10001A328(v98, 1LL, v99, v100, v101, v194, v102, v97);
              if ((_DWORD)v12) {
                goto LABEL_286;
              }
LABEL_219:
              char v105 = BYTE8(v174);
              if ((BYTE8(v174) & 0x50) == 0x40)
              {
                if ((BYTE8(v174) & 8) == 0)
                {
                  sub_100040C68( "dir-stats object (id %llu) is purgeable, but it doesn't track purgeable size\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
                  sub_100044E7C((char *)0x568, 92);
                  goto LABEL_223;
                }

                if ((BYTE12(v174) & 0x10) == 0)
                {
LABEL_223:
                  if ((unint64_t)(v167 - 1) > 0xFFFFFFFFFFFFFFFDLL || (BYTE12(v174) & 0x10) != 0)
                  {
                    int v106 = DWORD2(v174);
                    if ((v105 & 8) != 0) {
                      goto LABEL_227;
                    }
                  }

                  else
                  {
                    sub_100040C68( "dir-stats object (id %llu) is purgeable, but its origin isn't\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
                    sub_100044E7C((char *)0x569, 92);
                    int v106 = DWORD2(v174);
                  }

                  __int16 v115 = v106;
                  v106 &= ~0x40u;
                  DWORD2(v174) = v106;
                  *(void *)&__int128 v183 = v172 - v169;
                  if ((v115 & 0x800) != 0) {
                    *((void *)&v183 + 1) = v173 - v170;
                  }
LABEL_227:
                  if ((v106 & 8) != 0 && (BYTE12(v174) & 0x20) != 0)
                  {
                    uint64_t v107 = *((void *)&v171 + 1);
                    uint64_t v108 = v172;
                    if ((void)v172 == *((void *)&v171 + 1)) {
                      goto LABEL_258;
                    }
                  }

                  else
                  {
                    if (!(v106 & 8 | BYTE12(v174) & 0x20)) {
                      goto LABEL_258;
                    }
                    if ((v106 & 8) == 0)
                    {
                      if ((BYTE12(v174) & 0x20) == 0) {
                        goto LABEL_258;
                      }
                      sub_100040C68( "purgeable size xfield of dir-stats object (id %llu) exists unexpectedly\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
                      sub_100044E7C((char *)0x56A, -3);
                      v194[0] = 3;
                      uint64_t v110 = v151;
                      uint64_t v111 = 6LL;
                      uint64_t v112 = v67;
                      uint64_t v113 = v153;
                      uint64_t v114 = 1LL;
                      goto LABEL_257;
                    }

                    if ((BYTE12(v174) & 0x20) == 0)
                    {
                      sub_100040C68( "purgeable size xfield is missing from dir-stats object (id %llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
                      uint64_t v124 = 1387LL;
                      int v125 = -3;
LABEL_256:
                      sub_100044E7C((char *)v124, v125);
                      *(_DWORD *)uint64_t v194 = 524291;
                      *(void *)&v194[4] = v172;
                      uint64_t v110 = v151;
                      uint64_t v111 = 8LL;
                      uint64_t v112 = v67;
                      uint64_t v113 = v153;
                      uint64_t v114 = 12LL;
LABEL_257:
                      uint64_t v12 = sub_10001A328(v110, 1LL, v111, v112, v113, v194, v114, v109);
                      if ((_DWORD)v12) {
                        goto LABEL_286;
                      }
LABEL_258:
                      if ((BYTE8(v174) & 1) != 0)
                      {
                        if ((void)v170 != *((void *)&v169 + 1))
                        {
                          sub_100040C68( "resource fork size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v169));
                          sub_100044E7C((char *)0x558, 92);
                          uint64_t v128 = v151;
                          uint64_t v129 = v67;
                          uint64_t v130 = v153;
                          uint64_t v127 = &v170;
LABEL_263:
                          uint64_t v12 = sub_10001A328(v128, 1LL, 7LL, v129, v130, v127, 8LL, v126);
                          if ((_DWORD)v12) {
                            goto LABEL_286;
                          }
                        }
                      }

                      else if (*((void *)&v169 + 1))
                      {
                        sub_100040C68( "resource fork size (%llu) of dir-stats object (id %llu) exists unexpectedly\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v169));
                        sub_100044E7C((char *)0x566, 92);
                        *(void *)uint64_t v194 = 0LL;
                        uint64_t v127 = (__int128 *)v194;
                        uint64_t v128 = v151;
                        uint64_t v129 = v67;
                        uint64_t v130 = v153;
                        goto LABEL_263;
                      }

                      unsigned int v131 = DWORD2(v174);
                      if ((WORD4(v174) & 0x400) != 0
                        || (WORD6(v174) & 0x100) != 0
                        || (void)v166 != *((void *)&v165 + 1))
                      {
                        sub_100040C68( "found dir-stats object (id %llu; flags 0x%x) with bad chained key (%llu/%llu)\n",
                          v69,
                          v70,
                          v71,
                          v72,
                          v73,
                          v74,
                          v75,
                          v191);
                        sub_100044E7C((char *)0x591, 92);
                        if (*((void *)&v165 + 1) != (void)v166)
                        {
                          uint64_t v12 = sub_10001A328(v151, 1LL, 1LL, v67, v153, &v166, 8LL, v75);
                          if ((_DWORD)v12) {
                            goto LABEL_286;
                          }
                        }

                        unsigned int v131 = DWORD2(v174);
                        if ((WORD4(v174) & 0x400) != 0)
                        {
                          unsigned int v131 = DWORD2(v174) & 0xFFFFFBFF;
                          DWORD2(v174) &= ~0x400u;
                        }

                        if ((v150 & 0x200) != 0)
                        {
                          DWORD2(v174) = v131 | 0x100;
                          uint64_t v12 = sub_10001973C(v154, a2, v151, v191, v166);
                          if ((_DWORD)v12) {
                            goto LABEL_286;
                          }
                          unsigned int v131 = DWORD2(v174);
                        }
                      }

                      if (v77 != v131)
                      {
                        uint64_t v12 = sub_10001A328(v151, 1LL, 3LL, v67, v153, (_BYTE *)&v174 + 8, 4LL, v75);
                        if ((_DWORD)v12) {
                          goto LABEL_286;
                        }
                        uint64_t v12 = sub_1000364F0(dword_100074C88, 0LL, &v191, 8LL, &v165, 160LL);
                        if ((_DWORD)v12) {
                          goto LABEL_286;
                        }
                      }

                      goto LABEL_277;
                    }

                    uint64_t v107 = *((void *)&v171 + 1);
                    uint64_t v108 = v172;
                  }

                  if (v108 == v107) {
                    goto LABEL_258;
                  }
                  sub_100040C68( "purgeable size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v107);
                  uint64_t v124 = 1388LL;
                  int v125 = 92;
                  goto LABEL_256;
                }
              }

              LOBYTE(v106) = BYTE8(v174);
              goto LABEL_227;
            }

            if ((BYTE12(v174) & 8) != 0)
            {
LABEL_240:
              if ((void)v171 == *((void *)&v170 + 1)) {
                goto LABEL_203;
              }
              sub_100040C68( "clone size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  SBYTE8(v170));
              uint64_t v116 = 1380LL;
              int v117 = 92;
            }

            else
            {
              sub_100040C68( "clone size xfield is missing from dir-stats object (id %llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
              uint64_t v116 = 1379LL;
              int v117 = -3;
            }

            sub_100044E7C((char *)v116, v117);
            *(_DWORD *)uint64_t v194 = 524289;
            *(void *)&v194[4] = v171;
            unint64_t v119 = v151;
            uint64_t v120 = 8LL;
            unint64_t v121 = v67;
            uint64_t v122 = v153;
            uint64_t v123 = 12LL;
            goto LABEL_243;
          }
        }

        DWORD2(v174) = v89 | 0x100;
        goto LABEL_188;
      }

      if ((v77 & 0x80) != 0)
      {
        sub_100040C68( "shadow dir-stats object (id %llu) unexpectedly marked as having origin-id\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
        sub_100044E7C((char *)0x57D, -3);
        DWORD2(v174) &= ~0x80u;
      }

      else if (!(void)v167)
      {
        if (!*((void *)&v166 + 1)) {
          goto LABEL_154;
        }
        goto LABEL_151;
      }

      if (!*((void *)&v166 + 1))
      {
LABEL_152:
        if ((void)v167)
        {
          sub_100040C68( "found shadow dir-stats object (id %llu) with origin (id %llu)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
          sub_100044E7C((char *)0x572, -2);
        }

        goto LABEL_154;
      }

LABEL_151:
      sub_100040C68( "shadow dir-stats object (id %llu) unexpectedly has origin-id\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v191);
      sub_100044E7C((char *)0x57E, -2);
      *(void *)uint64_t v194 = 0LL;
      uint64_t v12 = sub_10001A328(v151, 1LL, 4LL, v67, v153, v194, 8LL, v84);
      if ((_DWORD)v12) {
        goto LABEL_286;
      }
      goto LABEL_152;
    }

LABEL_103:
    uint64_t v11 = 0LL;
    goto LABEL_290;
  }

  while (1)
  {
    char v36 = BYTE12(v174);
    if ((BYTE12(v174) & 1) == 0) {
      break;
    }
LABEL_88:
    if ((v36 & 1) == 0)
    {
      uint64_t v12 = sub_100018EC8(a1, a2, v177, (uint64_t)&v165);
      if ((_DWORD)v12) {
        goto LABEL_286;
      }
    }

    unsigned int v158 = 8;
    unsigned int v157 = 160;
  }

  uint64_t v37 = v7;
  uint64_t v38 = v177;
  *(void *)uint64_t v194 = v177;
  uint64_t v39 = a2[6];
  if (!v39) {
    uint64_t v39 = a2[5];
  }
  uint64_t v40 = *(void *)(v39 + 56);
  unint64_t v155 = v177 & 0xFFFFFFFFFFFFFFFLL | 0xA000000000000000LL;
  unint64_t v178 = v177 & 0xFFFFFFFFFFFFFFFLL | 0xE000000000000000LL;
  if ((v40 & 0x200) != 0) {
    int v41 = 18;
  }
  else {
    int v41 = 10;
  }
  LODWORD(v179) = 18;
  if ((v40 & 0x200) != 0) {
    uint64_t v42 = &v178;
  }
  else {
    uint64_t v42 = &v155;
  }
  if ((v40 & 0x200) != 0) {
    unsigned int v43 = 12;
  }
  else {
    unsigned int v43 = 8;
  }
  unsigned int v193 = v43;
  __int128 v180 = 0u;
  __int128 v181 = 0u;
  if ((v40 & 0x200) == 0)
  {
    uint64_t v152 = 0LL;
    uint64_t v44 = &v180;
    unsigned int v45 = 32;
    goto LABEL_48;
  }

  unsigned int v45 = 3808;
  uint64_t v46 = (__int128 *)calloc(1uLL, 0xEE0uLL);
  if (v46)
  {
    uint64_t v44 = v46;
    uint64_t v152 = (unsigned __int16 *)v46;
LABEL_48:
    unsigned int v192 = v45;
    uint64_t v191 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v50 = sub_10003AB6C(v154, a2, v41, &v191, v13, v14, v15, v16);
    if ((_DWORD)v50)
    {
      uint64_t v11 = v50;
      strerror(v50);
      sub_100040B90("failed to get fsroot tree for jobj type %d: %s\n", v132, v133, v134, v135, v136, v137, v138, v41);
      sub_100044E7C((char *)0x5A7, v11);
      uint64_t v59 = v152;
      goto LABEL_289;
    }

    uint64_t v51 = sub_100034BB4(v191, qword_100074C80, 0LL, v42, &v193, v43, v44, &v192);
    if ((_DWORD)v51)
    {
      uint64_t v11 = v51;
      uint64_t v59 = v152;
      a1 = v154;
      uint64_t v7 = v37;
      uint64_t v6 = (_BYTE *)&unk_100074000;
      if ((_DWORD)v51 != 2)
      {
        strerror(v51);
        sub_100040B90( "failed to look up dir-stats object (id %llu): %s\n",  v139,  v140,  v141,  v142,  v143,  v144,  v145,  v38);
        sub_100044E7C((char *)0x4DF, v11);
        goto LABEL_289;
      }

      goto LABEL_87;
    }

    WORD6(v174) |= 1u;
    a1 = v154;
    uint64_t v7 = v37;
    if ((v40 & 0x200) == 0)
    {
      uint64_t v60 = *((void *)&v180 + 1);
      BOOL v61 = __OFADD__((void)v168, (void)v180);
      *((void *)&v167 + 1) = v180;
      *(void *)&__int128 v168 = v168 + v180;
      *((void *)&v168 + 1) = *((void *)&v180 + 1);
      uint64_t v6 = (_BYTE *)&unk_100074000;
      if (v61)
      {
        sub_100040C68("dir-stats object (id %llu): %s overflow\n", v52, v53, v54, v55, v56, v57, v58, v38);
        *(void *)&__int128 v168 = 0x7FFFFFFFFFFFFFFFLL;
        sub_100044E7C((char *)0x56D, 84);
        uint64_t v60 = *((void *)&v180 + 1);
      }

      BOOL v61 = __OFADD__((void)v169, v60);
      *(void *)&__int128 v169 = v169 + v60;
      if (v61)
      {
        sub_100040C68("dir-stats object (id %llu): %s overflow\n", v52, v53, v54, v55, v56, v57, v58, v38);
        *(void *)&__int128 v169 = 0x7FFFFFFFFFFFFFFFLL;
        sub_100044E7C((char *)0x56D, 84);
      }

      *(void *)&__int128 v167 = -1LL;
      uint64_t v59 = v152;
      goto LABEL_86;
    }

    uint64_t v59 = v152;
    DWORD2(v174) = *((_DWORD *)v152 + 12);
    uint64_t v62 = ((DWORD2(v174) >> 4) & 1) - 1;
    if (*((void *)v152 + 3)) {
      uint64_t v62 = *((void *)v152 + 3);
    }
    *((void *)&v166 + 1) = *((void *)v152 + 3);
    *(void *)&__int128 v167 = v62;
    uint64_t v63 = *((void *)v152 + 1);
    BOOL v61 = __OFADD__((void)v168, *(void *)v152);
    uint64_t v64 = v168 + *(void *)v152;
    *((void *)&v167 + 1) = *(void *)v152;
    *(void *)&__int128 v168 = v64;
    *((void *)&v168 + 1) = v63;
    uint64_t v6 = (_BYTE *)&unk_100074000;
    if (v61)
    {
      sub_100040C68("dir-stats object (id %llu): %s overflow\n", v52, v53, v54, v55, v56, v57, v58, v38);
      *(void *)&__int128 v168 = 0x7FFFFFFFFFFFFFFFLL;
      sub_100044E7C((char *)0x56D, 84);
      uint64_t v63 = *((void *)v152 + 1);
    }

    BOOL v61 = __OFADD__((void)v169, v63);
    *(void *)&__int128 v169 = v169 + v63;
    if (v61)
    {
      sub_100040C68("dir-stats object (id %llu): %s overflow\n", v52, v53, v54, v55, v56, v57, v58, v38);
      *(void *)&__int128 v169 = 0x7FFFFFFFFFFFFFFFLL;
      sub_100044E7C((char *)0x56D, 84);
    }

    __int16 v65 = WORD4(v174);
    if ((BYTE8(v174) & 1) != 0)
    {
      *((void *)&v169 + 1) = *((void *)v152 + 2);
      sub_100016E74((char *)&v170, *((uint64_t *)&v169 + 1), v38, (uint64_t)"resource fork size", v55, v56, v57, v58);
      __int16 v65 = WORD4(v174);
      if ((BYTE8(v174) & 4) == 0)
      {
LABEL_70:
        if ((v65 & 8) == 0)
        {
LABEL_80:
          if ((v65 & 0x800) != 0)
          {
            uint64_t v190 = 0LL;
            if (!sub_10003B6C4(v152 + 26, v192 - 52, 4, &v190, 0LL, 0LL, 0LL))
            {
              WORD6(v174) |= 0x40u;
              *((void *)&v172 + 1) = *v190;
              sub_100016E74((char *)&v173, *v190, *(uint64_t *)v194, (uint64_t)"purgeable rsrc size", v55, v56, v57, v58);
            }

            LOBYTE(v65) = BYTE8(v174);
          }

          if ((v65 & 2) != 0)
          {
            WORD6(v174) |= 4u;
            sub_100016E74( (char *)&v173 + 8,  *(void *)v152,  *(uint64_t *)v194,  (uint64_t)"SAF descendants",  v55,  v56,  v57,  v58);
          }

    uint64_t v50 = v370;
    uint64_t v53 = v364;
    if (!v382) {
      goto LABEL_168;
    }
    if (!(_DWORD)v25) {
      goto LABEL_171;
    }
LABEL_110:
    uint64_t v176 = v378;
    uint64_t v177 = v369;
    if ((HIDWORD(v369) & ~v374 & v366) != 1 || !v177)
    {
      if ((v360 & 1) != 0 || ((HIDWORD(v369) | v366) & 1) == 0) {
        goto LABEL_227;
      }
      uint64_t v219 = v50 ^ 4;
      if (((v50 ^ 4) & 4) != 0)
      {
        uint64_t v176 = a8 == 36;
        uint64_t v50 = v219 & 0xFFFFF81F | ((*(void *)(*(void *)(a2 + 40) + 1096LL) != 0LL) << 8) | (32 * v176);
      }

      else
      {
        uint64_t v50 = v219 & 0xFFFFFF1F;
      }

      uint64_t v220 = v379;
      uint64_t v221 = *v379;
      v378 = v176;
      if ((v50 & 4) != 0)
      {
        uint64_t v223 = 4 * ((v50 & 0x700) == 256);
        uint64_t v224 = (v50 & 0x700) == 0x100 ? v362 : 0LL;
        if (a2)
        {
          if (*(void *)(a2 + 8LL * (v50 >> 5) + 24))
          {
            uint64_t v221 = *(void *)(a2 + 8LL * (v50 >> 5) + 24);
            uint64_t v222 = a2 + 96LL * (v50 >> 5) + 768;
          }

          else
          {
            uint64_t v222 = 0LL;
          }

          uint64_t v220 = v379;
        }

        else
        {
          uint64_t v222 = 0LL;
        }
      }

      else
      {
        uint64_t v222 = 0LL;
        uint64_t v223 = 0;
        uint64_t v224 = 0LL;
      }

      if (sub_10002BF50( v221,  v377,  v51 / *(_DWORD *)(v220[1] + 36),  (uint64_t)v18,  v222,  0,  0LL,  v224,  v223)) {
        goto LABEL_227;
      }
      v53 ^= 0x10000000u;
      if ((v366 & 1) != 0) {
        uint64_t v232 = "encrypted";
      }
      else {
        uint64_t v232 = "unencrypted";
      }
      sub_100040C68( "failed to validate %s object, retrying as %s\n",  v225,  v226,  v227,  v228,  v229,  v230,  v231,  (char)v232);
      v360 = 1;
      v366 ^= 1u;
      uint64_t v54 = (uint32x4_t *)(v18 + 1);
      uint64_t v55 = a8;
      uint64_t v56 = v365;
      goto LABEL_45;
    }

    v378 ^= 1u;
    unint64_t v178 = !v176;
    unint64_t v179 = v379;
    __int128 v180 = *v379;
    if ((v50 & 4) != 0)
    {
      __int128 v182 = 4 * ((v50 & 0x700) == 256);
      if ((v50 & 0x700) == 0x100) {
        __int128 v183 = v362;
      }
      else {
        __int128 v183 = 0LL;
      }
      if (a2)
      {
        if (*(void *)(a2 + 8LL * (!v176 & 7) + 24))
        {
          __int128 v180 = *(void *)(a2 + 8LL * (!v176 & 7) + 24);
          __int128 v181 = a2 + 96LL * (!v176 & 7) + 768;
        }

        else
        {
          __int128 v181 = 0LL;
        }

        unint64_t v179 = v379;
      }

      else
      {
        __int128 v181 = 0LL;
      }
    }

    else
    {
      __int128 v181 = 0LL;
      __int128 v182 = 0;
      __int128 v183 = 0LL;
    }

    if (sub_10002BF50( v180,  v377,  v51 / *(_DWORD *)(v179[1] + 36),  (uint64_t)v18,  v181,  0,  0LL,  v183,  v182)) {
      goto LABEL_227;
    }
    uint64_t v50 = v50 & 0xFFFFFF1F | (32 * (v378 & 7));
    sub_100040C68( "failed to validate object with crypto key index (%u), retrying with (%u)\n",  v204,  v205,  v206,  v207,  v208,  v209,  v210,  !v178);
    v374 = 1;
    uint64_t v56 = v365;
  }

  v370 = v50;
  sub_1000229C0(v12, v55);
  sub_100040B90("(oid 0x%llx) %s: found a bit flip in the header\n", v156, v157, v158, v159, v160, v161, v162, v15);
  sub_100044E7C((char *)0x3E9, 92);
  if (!sub_1000428C4( qword_10008DB70,  "Fix object (oid 0x%llx) header bit flip? ",  v163,  v164,  v165,  v166,  v167,  v168,  v15)) {
    goto LABEL_103;
  }
  v54->i64[0] = v15;
  if (!v373)
  {
    uint64_t v25 = 0LL;
    v363 = 1;
    goto LABEL_103;
  }

  v18[2] = v373;
  if (v382)
  {
LABEL_171:
    if (!sub_1000428C4( qword_10008DB70,  "Fix object (oid 0x%llx) checksum? ",  v169,  v170,  v171,  v172,  v173,  v174,  v15))
    {
      uint64_t v25 = 92LL;
      goto LABEL_227;
    }
  }

  LOBYTE(v363) = 1;
LABEL_173:
  if (a2)
  {
    uint64_t v16 = v375;
    uint64_t v242 = (v375 | *(_BYTE *)(*(void *)(a2 + 40) + 264LL) & 1) == 0;
  }

  else
  {
    uint64_t v242 = 0;
    uint64_t v16 = v375;
  }

  uint64_t v243 = v55;
  char v244 = v373;
  if (!v55) {
    uint64_t v243 = *((_DWORD *)v18 + 7);
  }
  uint64_t v245 = v243 == 36;
  if (((v360 | v374) & 1) == 0)
  {
    if (v357)
    {
      uint64_t v260 = v50;
      uint64_t v259 = v378 != v245;
      if (v378 != v245)
      {
        sub_1000229C0(v12, a8);
        sub_100040C68( "(oid 0x%llx) %s: invalid crypto key index (%u), expected (%u)\n",  v261,  v262,  v263,  v264,  v265,  v266,  v267,  v15);
        uint64_t v25 = 92LL;
        sub_100044E7C((char *)0x4B4, 92);
        if (!sub_1000428C4( qword_10008DB70,  "Fix object (oid 0x%llx) crypto key index? ",  v268,  v269,  v270,  v271,  v272,  v273,  v15)) {
          goto LABEL_227;
        }
        uint64_t v260 = (v50 & 0xFFFFFF1F | (32 * (v378 & 7))) ^ 0x20;
        LOBYTE(v363) = 1;
        uint64_t v16 = v375;
        char v244 = v373;
      }

      if ((v366 & 1) == v242)
      {
        uint64_t v50 = v260;
      }

      else
      {
        sub_1000229C0(v12, a8);
        sub_100040C68("(oid 0x%llx) %s: object is %s but should be %s\n", v274, v275, v276, v277, v278, v279, v280, v15);
        sub_100044E7C((char *)0x374, -3);
        uint64_t v50 = v260;
        if (sub_1000428C4( qword_10008DB70,  "Fix object (oid 0x%llx) encryption and omap flags? ",  v281,  v282,  v283,  v284,  v285,  v286,  v15))
        {
          uint64_t v287 = v260 ^ 4;
          uint64_t v50 = (v260 ^ 4) & 0xFFFFFF1F;
          uint64_t v259 = 1;
          LODWORD(v51) = v372;
          if ((v287 & 4) == 0) {
            goto LABEL_191;
          }
          goto LABEL_190;
        }
      }

      LODWORD(v51) = v372;
    }

    else
    {
      uint64_t v259 = 0;
    }

    goto LABEL_205;
  }

  if ((v374 & 1) != 0)
  {
    if (v378 == v245)
    {
      sub_1000229C0(v12, v55);
      sub_100040B90( "(oid 0x%llx) %s: object is encrypted with crypto key index (%u)but omap says it's encrypted with crypto key index (%u)\n",  v246,  v247,  v248,  v249,  v250,  v251,  v252,  v15);
      uint64_t v25 = 92LL;
      sub_100044E7C((char *)0x4B3, 92);
      if (!sub_1000428C4( qword_10008DB70,  "Fix object (oid 0x%llx) omap flags? ",  v253,  v254,  v255,  v256,  v257,  v258,  v15)) {
        goto LABEL_227;
      }
      uint64_t v259 = 1;
    }

    else
    {
      sub_1000229C0(v12, v55);
      sub_100040B90( "(oid 0x%llx) %s: object is encrypted with crypto key index (%u) but should be encrypted with crypto key index (%u)\n",  v289,  v290,  v291,  v292,  v293,  v294,  v295,  v15);
      uint64_t v25 = 92LL;
      sub_100044E7C((char *)0x4B2, 92);
      if (!sub_1000428C4( qword_10008DB70,  "Fix object (oid 0x%llx) crypto key index? ",  v296,  v297,  v298,  v299,  v300,  v301,  v15)) {
        goto LABEL_227;
      }
      uint64_t v259 = 0;
      uint64_t v50 = (v50 & 0xFFFFFF1F | (32 * (v378 & 7))) ^ 0x20;
      LOBYTE(v363) = 1;
      uint64_t v16 = v375;
      char v244 = v373;
    }

    LODWORD(v51) = v372;
  }

  else
  {
    uint64_t v259 = 0;
  }

  if ((v360 & 1) == 0)
  {
LABEL_205:
    uint64_t v288 = v363;
    goto LABEL_206;
  }

  sub_1000229C0(v12, a8);
  if ((v366 & 1) != v242)
  {
    sub_100040B90("(oid 0x%llx) %s: object is %s but should be %s\n", v302, v303, v304, v305, v306, v307, v308, v15);
    uint64_t v25 = 92LL;
    sub_100044E7C((char *)0x372, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Fix object (oid 0x%llx) encryption? ",  v309,  v310,  v311,  v312,  v313,  v314,  v15)) {
      goto LABEL_227;
    }
    uint64_t v315 = v50 ^ 4;
    uint64_t v50 = (v50 ^ 4) & 0xFFFFFF1F;
    uint64_t v16 = v375;
    if ((v315 & 4) == 0)
    {
LABEL_191:
      v364 ^= 0x10000000u;
      uint64_t v288 = 1;
      goto LABEL_206;
    }

uint64_t sub_100018BFC()
{
  if (!qword_100074CD0) {
    return 0LL;
  }
  uint64_t v54 = 0LL;
  uint64_t v55 = 0LL;
  uint64_t v0 = xmmword_100074CD8;
  uint64_t result = sub_100019B10((uint64_t)&xmmword_100074CD8, &v55, &v54);
  if ((_DWORD)result) {
    return result;
  }
  uint64_t v2 = v54;
  uint64_t v3 = v55;
  if (!v55 && !v0 && v54 == 0)
  {
    uint64_t v5 = 0LL;
LABEL_10:
    uint64_t result = sub_10001A208(v2, v5);
    if (!(_DWORD)result)
    {
      uint64_t result = sub_100019DBC(qword_100074CD0, &xmmword_100074CD8);
      if (!(_DWORD)result) {
        qword_100074CD0 = 0LL;
      }
    }

    return result;
  }

  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v52 = v6;
  __int128 v53 = v6;
  __int128 v50 = v6;
  __int128 v51 = v6;
  __int128 v48 = v6;
  __int128 v49 = v6;
  __int128 v46 = v6;
  __int128 v47 = v6;
  __int128 v44 = v6;
  __int128 v45 = v6;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 __s2 = 0u;
  __int128 v41 = 0u;
  unsigned int v38 = 160;
  unsigned int v39 = 8;
  uint64_t result = sub_100034BB4((uint64_t)dword_100074C88, 0LL, 0LL, &qword_100074CD0, &v39, 8u, &v44, &v38);
  if ((_DWORD)result) {
    return result;
  }
  if (qword_100074CE8) {
    BOOL v7 = (void)v45 == 0LL;
  }
  else {
    BOOL v7 = 0;
  }
  int v8 = v7;
  unsigned int v9 = (unint64_t)(qword_100074CF8 - 1) < 0xFFFFFFFFFFFFFFFELL;
  if (v8 == 1)
  {
    unsigned int v10 = ((unsigned __int16)word_100074D74 >> 2) & 1;
  }

  else
  {
    unsigned int v9 = (unint64_t)(qword_100074CF8 - 1) < 0xFFFFFFFFFFFFFFFELL && (unint64_t)(v46 + 1) < 2;
    unsigned int v10 = ((BYTE12(v53) & 4) == 0) & ((unsigned __int16)word_100074D74 >> 2);
  }

  sub_100019BAC((uint64_t)&v44, v8, word_100074D74 & ((BYTE12(v53) & 1) == 0), v9, v10, (uint64_t)&__s2);
  if (!v0) {
    goto LABEL_53;
  }
  *(void *)&__int128 v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v36 = v18;
  __int128 v37 = v18;
  __int128 v34 = v18;
  __int128 v35 = v18;
  __int128 v32 = v18;
  __int128 v33 = v18;
  v30[2] = v18;
  __int128 v31 = v18;
  v30[0] = v18;
  v30[1] = v18;
  if ((void)xmmword_100074CD8) {
    BOOL v19 = (void)v44 == 0LL;
  }
  else {
    BOOL v19 = 0;
  }
  int v20 = v19;
  sub_100019BAC((uint64_t)&v44, v20, 0, 0, 0, (uint64_t)v28);
  uint64_t result = sub_100019A74(v0, v30);
  if (!(_DWORD)result)
  {
    if (v20) {
      uint64_t v29 = v29 - v37 - (BYTE12(v37) & 1);
    }
    sub_100019CD4(v0, (char *)v30, v28, v21, v22, v23, v24, v25);
    if ((word_100074D74 & 1) != 0) {
      WORD6(v37) |= 2u;
    }
    uint64_t result = sub_100019DBC(v0, v30);
    char v26 = v8 ^ 1;
    if ((_DWORD)result) {
      char v26 = 1;
    }
    if ((v26 & 1) != 0)
    {
      if ((_DWORD)result) {
        return result;
      }
      goto LABEL_53;
    }

    *(void *)&__int128 __s2 = v31 + v9;
    *((void *)&__s2 + 1) = *((void *)&v36 + 1) + v10;
    uint64_t v27 = v33;
    *((void *)&v41 + 1) = v32;
    *(void *)&__int128 v42 = v33;
    *((void *)&v42 + 1) = v34;
    if ((BYTE8(v37) & 0x40) != 0)
    {
      *(void *)&__int128 v43 = v32;
      if ((WORD4(v37) & 0x800) != 0) {
        goto LABEL_52;
      }
    }

    else
    {
      *(void *)&__int128 v43 = v35;
      if ((WORD4(v37) & 0x800) != 0)
      {
        uint64_t v27 = v36;
LABEL_52:
        *((void *)&v43 + 1) = v27;
      }
    }

LABEL_53:
    uint64_t result = sub_10001A054(v3, (uint64_t *)&__s2, v12, v13, v14, v15, v16, v17);
    if ((_DWORD)result) {
      return result;
    }
    uint64_t v5 = v41;
    goto LABEL_10;
  }

  return result;
}

      if (v13 < v6 || HIWORD(a3) > v13 - v6) {
        return 84LL;
      }
      if (!a5) {
        return 0LL;
      }
      uint64_t v24 = *(_DWORD *)(a5 + 4);
      if (v24)
      {
        uint64_t v25 = 0;
        char v26 = *(_DWORD *)(a5 + 4);
        do
        {
          else {
            uint64_t v25 = ((v26 + v25) >> 1) + 1;
          }
        }

        while (v25 < v26);
        if (v25)
        {
          uint64_t v27 = (unsigned __int16 *)(*(void *)(a5 + 8) + 4LL * (v25 - 1));
          uint64_t v28 = *v27;
        }
      }

      else
      {
        uint64_t v25 = 0;
      }

      if (v25 < v24)
      {
        uint64_t v30 = (unsigned __int16 *)(*(void *)(a5 + 8) + 4LL * v25);
        __int128 v31 = *v30;
      }

      if (v24 == *(_DWORD *)a5)
      {
        __int128 v33 = v24 + 8;
        *(_DWORD *)a5 = v33;
        __int128 v34 = reallocf(*(void **)(a5 + 8), 4LL * v33);
        *(void *)(a5 + 8) = v34;
        if (!v34) {
          return 12LL;
        }
        uint64_t v24 = *(_DWORD *)(a5 + 4);
      }

      if (v24 > v25)
      {
        memmove( (void *)(*(void *)(a5 + 8) + 4LL * (v25 + 1)),  (const void *)(*(void *)(a5 + 8) + 4LL * v25),  4LL * (v24 - v25));
        uint64_t v24 = *(_DWORD *)(a5 + 4);
      }

      uint64_t result = 0LL;
      __int128 v35 = (unsigned __int16 *)(*(void *)(a5 + 8) + 4LL * v25);
      *__int128 v35 = v6;
      v35[1] = v8;
      *(_DWORD *)(a5 + 4) = v24 + 1;
      return result;
    case 3:
LABEL_13:
      uint64_t result = 84LL;
      return result;
    case 4:
      goto LABEL_48;
    case 5:
LABEL_15:
      __int128 v6 = a1[21] + a3;
      goto LABEL_16;
    default:
LABEL_16:
      if ((v12 & 0x40) == 0) {
        goto LABEL_17;
      }
      goto LABEL_53;
  }

uint64_t sub_100018EC8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v81 = a3;
  if ((~*(_DWORD *)(a4 + 152) & 0x410) == 0 && (*(_WORD *)(a4 + 156) & 0x100) == 0)
  {
    int v7 = 0;
    uint64_t v8 = *(void *)(a4 + 8);
    goto LABEL_9;
  }

  uint64_t v9 = *(void *)(a4 + 32);
  if (v9 == 2)
  {
    uint64_t v8 = 0LL;
    int v7 = 0;
    goto LABEL_9;
  }

  uint64_t v74 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v85 = v9 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
  unsigned int v84 = 8;
  char v26 = calloc(1uLL, 0xEE0uLL);
  int v83 = 3808;
  uint64_t v82 = 0LL;
  if (!v26)
  {
    sub_100040B90("unable to allocate memory to repair dir-stats chained key\n", v19, v20, v21, v22, v23, v24, v25, v73);
    uint64_t v10 = 12LL;
    uint64_t v35 = 1430LL;
    int v36 = 12;
    goto LABEL_24;
  }

  uint64_t v27 = sub_10003AB6C(a1, a2, 3, &v74, v22, v23, v24, v25);
  if ((_DWORD)v27)
  {
    uint64_t v10 = v27;
    sub_100040B90( "failed to init fsroot tree to repair dir-stats chained key\n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v73);
    uint64_t v35 = 1431LL;
LABEL_19:
    int v36 = v10;
LABEL_24:
    sub_100044E7C((char *)v35, v36);
    free(v26);
    return v10;
  }

  uint64_t v45 = sub_100034BB4(v74, qword_100074C80, 0LL, &v85, &v84, 8u, v26, (unsigned int *)&v83);
  if ((_DWORD)v45)
  {
    uint64_t v10 = v45;
    if ((_DWORD)v45 == 2)
    {
      free(v26);
      return 0LL;
    }

    strerror(v45);
    sub_100040B90( "unable to load inode (id %llu) to repair dir-stats chained key: %s\n",  v58,  v59,  v60,  v61,  v62,  v63,  v64,  v9);
    sub_100044E7C((char *)0x598, v10);
    int v7 = 0;
    goto LABEL_32;
  }

  uint64_t v46 = *(void *)v26;
  uint64_t v85 = *(void *)v26 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
  int v83 = 3808;
  uint64_t v47 = sub_100034BB4(v74, qword_100074C80, 0LL, &v85, &v84, v84, v26, (unsigned int *)&v83);
  if ((_DWORD)v47)
  {
    uint64_t v10 = v47;
    strerror(v47);
    sub_100040B90( "unable to load inode (id %llu) to repair dir-stats chained key: %s\n",  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v46);
    uint64_t v35 = 1433LL;
    goto LABEL_19;
  }

  int v7 = (v26[12] >> 29) & 1;
  uint64_t v65 = sub_10003BCD8((uint64_t)v26, v83, 10, 8LL, &v82, v48, v49, v50);
  if ((_DWORD)v65)
  {
    uint64_t v10 = v65;
    if ((_DWORD)v65 != 2)
    {
      strerror(v65);
      sub_100040B90( "unable to get dir-stats key of inode (id %llu) to repair dir-stats chained key: %s\n",  v66,  v67,  v68,  v69,  v70,  v71,  v72,  v46);
      sub_100044E7C((char *)0x59A, v10);
LABEL_32:
      free(v26);
      if ((_DWORD)v10) {
        return v10;
      }
LABEL_10:
      if (!v7) {
        return 0LL;
      }
      goto LABEL_11;
    }

    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v8 = *v82;
  }

  free(v26);
LABEL_9:
  if (v8 == *(void *)(a4 + 16)) {
    goto LABEL_10;
  }
  unint64_t v11 = -*(void *)(a4 + 136) - (((unint64_t)*(unsigned __int16 *)(a4 + 156) >> 2) & 1);
  uint64_t v12 = ~*(void *)(a4 + 144);
  uint64_t v13 = -*(void *)(a4 + 64);
  uint64_t v14 = -*(void *)(a4 + 80);
  uint64_t v15 = -*(void *)(a4 + 96);
  uint64_t v16 = -*(void *)(a4 + 112);
  uint64_t v17 = -*(void *)(a4 + 128);
  uint64_t v74 = ~*(void *)(a4 + 48);
  v75.i64[0] = v11;
  v75.i64[1] = v12;
  uint64_t v76 = v13;
  uint64_t v77 = v14;
  uint64_t v78 = v15;
  uint64_t v79 = v16;
  uint64_t v80 = v17;
  uint64_t v18 = sub_1000199F0(a4, &v74);
  if ((_DWORD)v18) {
    return v18;
  }
  *(void *)(a4 + 16) = v8;
  unint64_t v37 = ((unint64_t)*(unsigned __int16 *)(a4 + 156) >> 2) & 1;
  uint64_t v38 = *(void *)(a4 + 64);
  uint64_t v39 = *(void *)(a4 + 80);
  uint64_t v40 = *(void *)(a4 + 96);
  uint64_t v41 = *(void *)(a4 + 112);
  uint64_t v42 = *(void *)(a4 + 128);
  uint64_t v74 = *(void *)(a4 + 48) + 1LL;
  int64x2_t v43 = vdupq_n_s64(1uLL);
  v43.i64[0] = v37;
  int64x2_t v75 = vaddq_s64(*(int64x2_t *)(a4 + 136), v43);
  uint64_t v76 = v38;
  uint64_t v77 = v39;
  uint64_t v78 = v40;
  uint64_t v79 = v41;
  uint64_t v80 = v42;
  uint64_t v10 = sub_1000199F0(a4, &v74);
  if ((_DWORD)v10) {
    return v10;
  }
  if (v7) {
LABEL_11:
  }
    *(_WORD *)(a4 + 156) |= 0x400u;
  uint64_t v10 = sub_1000364F0(dword_100074C88, 0LL, &v81, 8LL, (const void *)a4, 160LL);
  if (!(_DWORD)v10) {
    return 0LL;
  }
  return v10;
}

uint64_t sub_10001926C( uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8 = (a4 & 0xFFFFFFFC) == 0x5C || (*(void *)(a3 + 48) & 2LL) == 0;
  if (v8) {
    return 0LL;
  }
  unint64_t v11 = 0LL;
  LODWORD(result) = sub_10003BCD8(a3, a4, 10, 8LL, &v11, a6, a7, a8);
  if ((_DWORD)result)
  {
    if ((_DWORD)result == 2) {
      return 0LL;
    }
    else {
      return result;
    }
  }

  else
  {
    BOOL v8 = *v11 == *(void *)a5;
    *(_BYTE *)(a5 + 8) = v8;
    if (v8) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

uint64_t sub_1000192F8( uint64_t a1, void *a2, _DWORD *a3, __int128 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = a2[6];
  uint64_t v13 = v12;
  if (!v12) {
    uint64_t v13 = a2[5];
  }
  if ((*(_BYTE *)(v13 + 57) & 2) != 0)
  {
    uint64_t v17 = *(void *)(a5 + 16);
    if (!v17) {
      goto LABEL_9;
    }
    if (!v12) {
      uint64_t v12 = a2[5];
    }
    if ((*(_BYTE *)(v12 + 57) & 2) == 0)
    {
LABEL_9:
      unsigned int v18 = 0;
      goto LABEL_10;
    }

    uint64_t v95 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v96 = v17 & 0xFFFFFFFFFFFFFFFLL | 0xE000000000000000LL;
    LODWORD(v97) = 18;
    unsigned int v93 = 3808;
    unsigned int v94 = 12;
    uint64_t v34 = sub_10003AB6C(a1, a2, 18, &v95, a5, a6, a7, a8);
    if ((_DWORD)v34)
    {
      uint64_t v16 = v34;
      strerror(v34);
      sub_100040B90( "failed to get fsroot tree to find expanded dir-stats %llu: %s\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v17);
      sub_100044E7C((char *)0x5A1, v16);
      uint64_t v42 = 0LL;
    }

    else
    {
      uint64_t v42 = calloc(1uLL, 0xEE0uLL);
      if (v42)
      {
        uint64_t v61 = sub_100034BB4(v95, a2[7], 0LL, &v96, &v94, 0xCu, v42, &v93);
        if (!(_DWORD)v61)
        {
          unsigned int v18 = v42[12];
          free(v42);
          if (v18 <= 0xFFF)
          {
LABEL_10:
            int v19 = ((int)(v18 << 29) >> 31) & 0xC;
            if ((v18 & 8) != 0) {
              int v19 = (((int)(v18 << 29) >> 31) & 0xC) + 12;
            }
            if (v18 >= 0x800) {
              v19 += 12;
            }
            if (v19) {
              uint64_t v20 = (v19 + 4);
            }
            else {
              uint64_t v20 = 0LL;
            }
            uint64_t v21 = calloc(1uLL, (v20 + 52));
            uint64_t v29 = v21;
            if (v21)
            {
              *uint64_t v21 = *(void *)(a5 + 48);
              v21[1] = *(void *)(a5 + 64);
              v21[4] = v17;
              v21[5] = (random() << 32) | 0x80000000LL;
              uint64_t v29[3] = *(void *)(a5 + 32);
              int v32 = *((_DWORD *)v29 + 12);
              int v33 = v32 | 0x80;
              *((_DWORD *)v29 + 12) = v32 | 0x80;
              if ((v18 & 1) != 0 || !*(void *)(a5 + 144))
              {
                v29[2] = *(void *)(a5 + 80);
                int v33 = v32 | 0x81;
                *((_DWORD *)v29 + 12) = v32 | 0x81;
                if ((v18 & 4) == 0)
                {
LABEL_21:
                  if ((v18 & 8) == 0) {
                    goto LABEL_37;
                  }
                  goto LABEL_34;
                }
              }

              else if ((v18 & 4) == 0)
              {
                goto LABEL_21;
              }

              uint64_t v43 = sub_10003B77C((unsigned __int16 *)v29 + 26, v20, 1LL, (const void *)(a5 + 96), 8LL, 0LL, v30, v31);
              if (!(_DWORD)v43)
              {
                int v33 = *((_DWORD *)v29 + 12) | 4;
                *((_DWORD *)v29 + 12) = v33;
                if ((v18 & 8) == 0) {
                  goto LABEL_37;
                }
LABEL_34:
                uint64_t v71 = sub_10003B77C( (unsigned __int16 *)v29 + 26,  v20,  3LL,  (const void *)(a5 + 112),  8LL,  0LL,  v30,  v31);
                if ((_DWORD)v71)
                {
                  uint64_t v16 = v71;
                  char v72 = strerror(v71);
                  sub_100040B90( "can't add purgeable size for dir-stats: %s (%d)\n",  v73,  v74,  v75,  v76,  v77,  v78,  v79,  v72);
                  uint64_t v80 = 1446LL;
LABEL_40:
                  sub_100044E7C((char *)v80, v16);
                  goto LABEL_52;
                }

                int v33 = *((_DWORD *)v29 + 12) | 8;
                *((_DWORD *)v29 + 12) = v33;
LABEL_37:
                if (v18 >= 0x800)
                {
                  uint64_t v81 = sub_10003B77C( (unsigned __int16 *)v29 + 26,  v20,  4LL,  (const void *)(a5 + 128),  8LL,  0LL,  v30,  v31);
                  if ((_DWORD)v81)
                  {
                    uint64_t v16 = v81;
                    char v82 = strerror(v81);
                    sub_100040B90( "can't add purgeable resource fork size for dir-stats: %s (%d)\n",  v83,  v84,  v85,  v86,  v87,  v88,  v89,  v82);
                    uint64_t v80 = 1454LL;
                    goto LABEL_40;
                  }

                  int v33 = *((_DWORD *)v29 + 12) | 0x800;
                  *((_DWORD *)v29 + 12) = v33;
                }

                int v90 = *(_WORD *)(a5 + 156) & 0x404;
                if ((v18 & 0x100) != 0 || v90 == 4)
                {
                  if (v90 == 4) {
                    v33 |= 2u;
                  }
                  *((_DWORD *)v29 + 12) = v33 | v18 & 0x100;
                }

                uint64_t v16 = sub_10001A328(a3, 2LL, 0LL, a4, 12LL, v29, (v20 + 52), v31);
                goto LABEL_52;
              }

              uint64_t v16 = v43;
              char v44 = strerror(v43);
              sub_100040B90("can't add clone size for dir-stats: %s (%d)\n", v45, v46, v47, v48, v49, v50, v51, v44);
              uint64_t v52 = 1445LL;
              int v53 = v16;
            }

            else
            {
              sub_100040B90( "failed to allocate memory for insertion of dir-stats\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v92);
              uint64_t v16 = 12LL;
              uint64_t v52 = 1444LL;
              int v53 = 12;
            }

            sub_100044E7C((char *)v52, v53);
LABEL_52:
            free(v29);
            return v16;
          }

          uint64_t v16 = 0LL;
LABEL_44:
          uint64_t v29 = 0LL;
          goto LABEL_52;
        }

        uint64_t v16 = v61;
        strerror(v61);
        sub_100040B90( "unable to load dir-stats %llu to retrieve attributes: %s\n",  v62,  v63,  v64,  v65,  v66,  v67,  v68,  v17);
        uint64_t v69 = 1443LL;
        int v70 = v16;
      }

      else
      {
        sub_100040B90("failed to allocate memory to find dir-stats %llu\n", v54, v55, v56, v57, v58, v59, v60, v17);
        uint64_t v16 = 12LL;
        uint64_t v69 = 1442LL;
        int v70 = 12;
      }

      sub_100044E7C((char *)v69, v70);
    }

    free(v42);
    goto LABEL_44;
  }

  uint64_t v14 = *(void *)(a5 + 64);
  unint64_t v96 = *(void *)(a5 + 48);
  uint64_t v97 = v14;
  uint64_t v98 = *(void *)(a5 + 16);
  uint64_t v99 = (random() << 32) | 0x80000000LL;
  return sub_10001A328(a3, 2LL, 0LL, a4, 8LL, &v96, 32LL, v15);
}

BOOL sub_1000196FC(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 152);
  if ((v1 & 0x800) != 0)
  {
    if ((~v1 & 9) != 0 || (*(_WORD *)(a1 + 156) & 0x40) == 0) {
      return 0LL;
    }
    return *(void *)(a1 + 128) == *(void *)(a1 + 120);
  }

  else
  {
    return (*(_WORD *)(a1 + 156) & 0x40) == 0;
  }

uint64_t sub_10001973C(uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  *(void *)uint64_t v56 = a5;
  if (!a5) {
    return 0LL;
  }
  uint64_t v5 = a5;
  uint64_t v55 = 0xAAAAAAAAAAAAAAAALL;
  DWORD2(v54) = 18;
  *(void *)&__int128 v54 = 0LL;
  unsigned int v53 = 12;
  uint64_t v16 = calloc(1uLL, 0xEE0uLL);
  unsigned int v52 = 3808;
  if (!v16)
  {
    sub_100040B90( "failed to allocate memory to mark dir-stats chain as inconsistent\n",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v46);
    uint64_t v25 = 12LL;
    uint64_t v26 = 1426LL;
    int v27 = 12;
    goto LABEL_7;
  }

  uint64_t v17 = sub_10003AB6C(a1, a2, 18, &v55, v12, v13, v14, v15);
  if ((_DWORD)v17)
  {
    uint64_t v25 = v17;
    sub_100040B90( "failed to init fsroot tree to mark dir-stats chain as inconsistent\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v46);
    uint64_t v26 = 1427LL;
    int v27 = v25;
LABEL_7:
    sub_100044E7C((char *)v26, v27);
    goto LABEL_8;
  }

  int v29 = 513;
  while (1)
  {
    if (!--v29)
    {
      sub_100040C68( "performed too many chained-key iterations (current id %llu); can't mark the entire chain as needing reconciliation\n",
        v18,
        v19,
        v20,
        v21,
        v22,
        v23,
        v24,
        v5);
      sub_100044E7C((char *)0x594, 92);
LABEL_24:
      uint64_t v25 = 0LL;
      goto LABEL_8;
    }

    int v51 = 0;
    *(void *)&__int128 v54 = v5 & 0xFFFFFFFFFFFFFFFLL | 0xE000000000000000LL;
    *(void *)&__int128 v30 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v49[8] = v30;
    __int128 v50 = v30;
    v49[6] = v30;
    v49[7] = v30;
    v49[4] = v30;
    v49[5] = v30;
    v49[2] = v30;
    v49[3] = v30;
    v49[0] = v30;
    v49[1] = v30;
    unsigned int v47 = 160;
    unsigned int v48 = 8;
    uint64_t v31 = sub_100034BB4((uint64_t)dword_100074C88, 0LL, 0LL, v56, &v48, 8u, v49, &v47);
    if ((_DWORD)v31) {
      break;
    }
    int v34 = DWORD2(v50);
    if ((WORD4(v50) & 0x100) != 0) {
      goto LABEL_20;
    }
    DWORD2(v50) |= 0x100u;
    int v51 = v34 | 0x100;
    uint64_t v35 = sub_1000364F0(dword_100074C88, 0LL, v56, 8LL, v49, 160LL);
    if ((_DWORD)v35) {
      goto LABEL_27;
    }
LABEL_19:
    sub_100040C68( "need to mark dir-stats %llu as needing reconciliation, due to an issue with dir-stats %llu\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v56[0]);
    uint64_t v35 = sub_10001A328(a3, 1LL, 3LL, &v54, v53, &v51, 4LL, v36);
    if ((_DWORD)v35)
    {
LABEL_27:
      uint64_t v25 = v35;
      goto LABEL_8;
    }

uint64_t sub_1000199F0(uint64_t a1, uint64_t *a2)
{
  uint64_t v11 = 0LL;
  *(void *)uint64_t v12 = 0LL;
  memset(__s1, 0, sizeof(__s1));
  uint64_t result = memcmp(__s1, a2, 0x40uLL);
  if ((_DWORD)result)
  {
    uint64_t result = sub_100019B10(a1, (uint64_t *)v12, &v11);
    if (!(_DWORD)result)
    {
      uint64_t result = sub_10001A208(v11, a2[2]);
      if (!(_DWORD)result) {
        return sub_10001A054(*(uint64_t *)v12, a2, v5, v6, v7, v8, v9, v10);
      }
    }
  }

  return result;
}

uint64_t sub_100019A74(uint64_t a1, _OWORD *a2)
{
  uint64_t v6 = a1;
  unsigned int v4 = 160;
  unsigned int v5 = 8;
  uint64_t result = sub_100034BB4((uint64_t)dword_100074C88, 0LL, 0LL, &v6, &v5, 8u, a2, &v4);
  if ((_DWORD)result == 2)
  {
    a2[8] = 0u;
    a2[9] = 0u;
    a2[6] = 0u;
    a2[7] = 0u;
    a2[4] = 0u;
    a2[5] = 0u;
    a2[2] = 0u;
    a2[3] = 0u;
    *a2 = 0u;
    a2[1] = 0u;
    return sub_1000364F0(dword_100074C88, 0LL, &v6, 8LL, a2, 160LL);
  }

  return result;
}

uint64_t sub_100019B10(uint64_t a1, uint64_t *a2, void *a3)
{
  *a3 = 0LL;
  *a2 = 0LL;
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4) {
    return 0LL;
  }
  if ((*(_BYTE *)(a1 + 152) & 0x10) != 0)
  {
    *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v18 = v8;
    __int128 v19 = v8;
    __int128 v16 = v8;
    __int128 v17 = v8;
    __int128 v14 = v8;
    __int128 v15 = v8;
    __int128 v12 = v8;
    __int128 v13 = v8;
    __int128 v10 = v8;
    __int128 v11 = v8;
    uint64_t v6 = sub_100019A74(v4, &v10);
    if (!(_DWORD)v6)
    {
      *a3 = *(void *)(a1 + 16);
      *a2 = v11;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
    *a2 = v4;
  }

  return v6;
}

uint64_t sub_100019BAC@<X0>( uint64_t result@<X0>, int a2@<W1>, unsigned int a3@<W2>, unsigned int a4@<W3>, unsigned int a5@<W4>, uint64_t a6@<X8>)
{
  *(_OWORD *)(a6 + 32) = 0u;
  *(_OWORD *)(a6 + 48) = 0u;
  *(_OWORD *)a6 = 0u;
  *(_OWORD *)(a6 + 16) = 0u;
  __int16 v6 = dword_100074D70;
  if (a2)
  {
    uint64_t v7 = unk_100074D68;
    uint64_t v8 = *((void *)&xmmword_100074D58 + 1) + a5;
    *(void *)a6 = qword_100074D08 + a4;
    *(void *)(a6 + 8) = v8;
    uint64_t v9 = qword_100074D18;
    *(void *)(a6 + 16) = v7 + a3;
    *(void *)(a6 + 24) = v9;
    uint64_t v10 = qword_100074D28;
    uint64_t v11 = qword_100074D38;
    *(void *)(a6 + 32) = qword_100074D28;
    *(void *)(a6 + 40) = v11;
    if ((v6 & 0x40) == 0)
    {
      *(void *)(a6 + 48) = qword_100074D48;
      if ((v6 & 0x800) == 0) {
        return result;
      }
      uint64_t v10 = xmmword_100074D58;
      goto LABEL_11;
    }

LABEL_10:
    *(void *)(a6 + 48) = v9;
    if ((v6 & 0x800) == 0) {
      return result;
    }
    goto LABEL_11;
  }

  uint64_t v12 = unk_100074D68;
  uint64_t v13 = *(void *)(result + 144);
  uint64_t v14 = *((void *)&xmmword_100074D58 + 1) + a5 - *(void *)(result + 136);
  *(void *)a6 = qword_100074D08 + a4 - *(void *)(result + 48);
  *(void *)(a6 + 8) = v14;
  uint64_t v15 = v12 + a3 - v13;
  uint64_t v16 = qword_100074D18;
  uint64_t v17 = qword_100074D18 - *(void *)(result + 64);
  *(void *)(a6 + 16) = v15;
  *(void *)(a6 + 24) = v17;
  uint64_t v10 = qword_100074D28 - *(void *)(result + 80);
  uint64_t v18 = qword_100074D38 - *(void *)(result + 96);
  *(void *)(a6 + 32) = v10;
  *(void *)(a6 + 40) = v18;
  if ((v6 & 0x40) == 0)
  {
    *(void *)(a6 + 48) = qword_100074D48 - *(void *)(result + 112);
    if ((v6 & 0x800) == 0) {
      return result;
    }
    uint64_t v10 = xmmword_100074D58 - *(void *)(result + 128);
    goto LABEL_11;
  }

  if ((*(_BYTE *)(result + 152) & 0x40) == 0)
  {
    uint64_t v9 = v16 - *(void *)(result + 112);
    goto LABEL_10;
  }

  *(void *)(a6 + 48) = v17;
  if ((v6 & 0x800) == 0) {
    return result;
  }
LABEL_11:
  *(void *)(a6 + 56) = v10;
  return result;
}

char *sub_100019CD4( uint64_t a1, char *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100016E74(a2 + 128, a3[7], a1, (uint64_t)"purgeable rsrc size", v35, v36, v37, v38);
}

uint64_t sub_100019DBC(uint64_t result, void *a2)
{
  uint64_t v16 = result;
  if (result)
  {
    uint64_t v3 = result;
    memset(__s1, 0, sizeof(__s1));
    if (memcmp(__s1, a2, 0xA0uLL))
    {
      __int16 v4 = *((_WORD *)a2 + 78);
      if ((v4 & 1) == 0) {
        return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
      }
      int v5 = *((_DWORD *)a2 + 38);
      if ((v5 & 0x20) != 0) {
        return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
      }
      if ((v5 & 0x10) != 0)
      {
        if ((v5 & 0x80) != 0 || a2[4] || a2[3]) {
          return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
        }
      }

      else
      {
        uint64_t v6 = a2[3];
        if ((v5 & 0x80) != 0)
        {
          if (!v6 || a2[4] != v6) {
            return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
          }
        }

        else if (v6 || !a2[4])
        {
          return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
        }
      }

      int v8 = (v4 & 2) >> 1;
      if ((v5 & 0x10) == 0) {
        int v8 = (v4 & 2) == 0;
      }
      if (v8 != 1 || *a2 || (v4 & 4) == 0 && (a2[19] & 0x12) == 2) {
        return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
      }
      if (v4 & 4 | a2[19] & 2)
      {
        uint64_t v10 = a2 + 6;
        uint64_t v9 = a2[17];
      }

      else
      {
        if (a2[18])
        {
LABEL_33:
          if (a2[6] != a2[5] || a2[8] != a2[7]) {
            return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
          }
          if ((v5 & 1) != 0)
          {
            uint64_t v12 = a2 + 10;
            uint64_t v11 = a2[9];
          }

          else
          {
            uint64_t v11 = 0LL;
            uint64_t v12 = a2 + 9;
          }

          if (*v12 != v11) {
            return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
          }
          if ((v4 & 8) != 0 && (v5 & 4) != 0)
          {
            if (a2[12] != a2[11]) {
              return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
            }
          }

          else if (v4 & 8 | a2[19] & 4)
          {
            return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
          }

          if ((a2[19] & 0x50) == 0x40 && ((v4 & 0x10) == 0 || (v5 & 8) == 0)) {
            return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
          }
          int v15 = *((_DWORD *)a2 + 38);
          if ((v4 & 0x20) != 0 && (v5 & 8) != 0)
          {
            if (a2[14] != a2[13]) {
              return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
            }
LABEL_52:
            __int16 v13 = *((_WORD *)a2 + 78);
            BOOL v14 = sub_1000196FC((uint64_t)a2);
            if ((v13 & 0x100) == 0 && (v15 & 0x400) == 0 && v14 && a2[2] == a2[1]) {
              return sub_10001A2AC(v3, (uint64_t)a2);
            }
            return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
          }

          if (!(v4 & 0x20 | a2[19] & 8)) {
            goto LABEL_52;
          }
          return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
        }

        uint64_t v9 = 0LL;
        uint64_t v10 = a2 + 17;
      }

      if (*v10 != v9) {
        return sub_1000364F0(dword_100074C88, 0LL, &v16, 8LL, a2, 160LL);
      }
      goto LABEL_33;
    }

    uint64_t v18 = v3;
    if (qword_100074DB0)
    {
      *(void *)&__s1[0] = a2[18];
      *((void *)&__s1[0] + 1) = v3;
      unsigned int v7 = sub_100036AC4((uint64_t)&unk_100074D78, 0LL, (uint64_t)__s1, 16LL);
    }

    else
    {
      unsigned int v7 = 0;
    }

    LODWORD(result) = sub_100036AC4((uint64_t)dword_100074C88, 0LL, (uint64_t)&v18, 8LL);
    if ((_DWORD)result) {
      return result;
    }
    else {
      return v7;
    }
  }

  return result;
}

uint64_t sub_10001A054( uint64_t a1, uint64_t *__s2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v36 = v10;
  __int128 v37 = v10;
  __int128 v34 = v10;
  __int128 v35 = v10;
  __int128 v32 = v10;
  __int128 v33 = v10;
  __int128 v30 = v10;
  __int128 v31 = v10;
  int v11 = 513;
  __int128 v28 = v10;
  __int128 v29 = v10;
  while (1)
  {
    if (!a1) {
      return 0LL;
    }
    uint64_t v12 = a1;
    if (!--v11) {
      break;
    }
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 __s1 = 0u;
    __int128 v39 = 0u;
    uint64_t result = memcmp(&__s1, __s2, 0x40uLL);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t result = sub_100019A74(a1, &v28);
    if ((_DWORD)result) {
      return result;
    }
    sub_100019CD4(a1, (char *)&v28, __s2, v14, v15, v16, v17, v18);
    uint64_t result = sub_100019DBC(a1, &v28);
    if ((_DWORD)result) {
      return result;
    }
    a1 = v29;
    if ((void)v29 && (BYTE8(v37) & 0x10) != 0)
    {
      *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v46 = v20;
      __int128 v47 = v20;
      __int128 v44 = v20;
      __int128 v45 = v20;
      __int128 v42 = v20;
      __int128 v43 = v20;
      __int128 v40 = v20;
      __int128 v41 = v20;
      __int128 __s1 = v20;
      __int128 v39 = v20;
      uint64_t result = sub_100019A74(v29, &__s1);
      if ((_DWORD)result) {
        return result;
      }
      uint64_t v19 = v29;
      a1 = v39;
    }

    else
    {
      uint64_t v19 = 0LL;
    }

    uint64_t result = sub_10001A208(v19, __s2[2]);
    if ((_DWORD)result) {
      return result;
    }
    uint64_t v21 = v28;
    if ((void)v28)
    {
      uint64_t result = sub_100019A74(v28, &v28);
      if ((_DWORD)result) {
        return result;
      }
      sub_100019CD4(v21, (char *)&v28, __s2, v22, v23, v24, v25, v26);
      uint64_t result = sub_100019DBC(v21, &v28);
      if ((_DWORD)result) {
        return result;
      }
    }

    __int16 v27 = WORD4(v37);
    if ((BYTE8(v37) & 0x40) != 0)
    {
      __s2[6] = __s2[3];
      if ((v27 & 0x800) != 0) {
        __s2[7] = __s2[4];
      }
    }

    if (v12 == a1)
    {
      sub_100040C68("detected chained-key loop involving dir-stats %llu\n", (uint64_t)__s2, a3, a4, a5, a6, a7, a8, v12);
      sub_100044E7C((char *)0x59D, 92);
      return 0LL;
    }
  }

  sub_100040C68( "performed too many chained-key iterations (current id %llu); aborting dir-stats repairs\n",
    (uint64_t)__s2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a1);
  sub_100044E7C((char *)0x590, 92);
  uint64_t result = 0LL;
  byte_100074CC8 = 1;
  return result;
}

uint64_t sub_10001A208(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0LL;
  if (a1)
  {
    if (a2)
    {
      *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v14[8] = v5;
      __int128 v15 = v5;
      v14[6] = v5;
      v14[7] = v5;
      v14[4] = v5;
      v14[5] = v5;
      v14[2] = v5;
      v14[3] = v5;
      v14[0] = v5;
      v14[1] = v5;
      uint64_t result = sub_100019A74(a1, v14);
      if (!(_DWORD)result)
      {
        BOOL v13 = __OFADD__((void)v15, a2);
        *(void *)&__int128 v15 = v15 + a2;
        if (v13)
        {
          sub_100040C68("dir-stats object (id %llu): %s overflow\n", v6, v7, v8, v9, v10, v11, v12, a1);
          *(void *)&__int128 v15 = 0x7FFFFFFFFFFFFFFFLL;
          sub_100044E7C((char *)0x56D, 84);
        }

        return sub_100019DBC(a1, v14);
      }
    }
  }

  return result;
}

uint64_t sub_10001A2AC(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1;
  if (qword_100074DB0)
  {
    v4[0] = *(void *)(a2 + 144);
    v4[1] = a1;
    unsigned int v2 = sub_100036AC4((uint64_t)&unk_100074D78, 0LL, (uint64_t)v4, 16LL);
  }

  else
  {
    unsigned int v2 = 0;
  }

  LODWORD(result) = sub_100036AC4((uint64_t)dword_100074C88, 0LL, (uint64_t)&v5, 8LL);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v2;
  }
}

uint64_t sub_10001A328( _DWORD *a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, _BYTE *a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_1000251C0(a1, 8u, a2, a3, 0, a4, a5, a6, a7);
  }
  sub_100024E94(0LL, a2, a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8);
  return 0LL;
}

uint64_t sub_10001A378(char *__s, uint64_t a2, __int128 *a3, io_connect_t *a4, uint64_t a5)
{
  size_t outputStructCnt = 100LL;
  uint64_t result = 22LL;
  if (__s && a4)
  {
    uint64_t v11 = sub_10002AECC(__s, 0LL, a4, 0LL, 0);
    if ((_DWORD)v11)
    {
      return sub_10004A8D8(v11);
    }

    else
    {
      memset((char *)v20 + 8, 170, 0x950uLL);
      __int128 v12 = a3[1];
      __int128 outputStruct = *a3;
      __int128 v19 = v12;
      *(void *)&v20[0] = a2;
      uint64_t v13 = IOConnectCallStructMethod(*a4, 0x32u, &outputStruct, 0x28uLL, &outputStruct, &outputStructCnt);
      if ((_DWORD)v13) {
        IOServiceClose(*a4);
      }
      if (a5)
      {
        __int128 v14 = v20[3];
        *(_OWORD *)(a5 + 64) = v20[2];
        *(_OWORD *)(a5 + 80) = v14;
        *(_DWORD *)(a5 + 96) = v20[4];
        __int128 v15 = v19;
        *(_OWORD *)a5 = outputStruct;
        *(_OWORD *)(a5 + 16) = v15;
        __int128 v16 = v20[1];
        *(_OWORD *)(a5 + 32) = v20[0];
        *(_OWORD *)(a5 + 48) = v16;
      }

      if ((_DWORD)v13) {
        return sub_10004A8D8(v13);
      }
      else {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_10001A488(io_connect_t *a1)
{
  size_t outputStructCnt = 0LL;
  if (!a1) {
    return 22LL;
  }
  mach_port_t v2 = *a1;
  if (!v2) {
    return 22LL;
  }
  uint64_t v3 = IOConnectCallStructMethod(v2, 0x33u, 0LL, 0LL, 0LL, &outputStructCnt);
  if ((_DWORD)v3) {
    return sub_10004A8D8(v3);
  }
  IOServiceClose(*a1);
  uint64_t result = 0LL;
  *a1 = 0;
  return result;
}

uint64_t sub_10001A4F8(char *a1, unsigned __int8 *uu, _OWORD *a3, char a4, uint64_t a5)
{
  size_t outputStructCnt = 0LL;
  if (!a1) {
    return 22LL;
  }
  int is_null = uuid_is_null(uu);
  uint64_t result = 22LL;
  if (a5 && !is_null)
  {
    io_connect_t v16 = -1431655766;
    memset(__b, 170, sizeof(__b));
    uint64_t v12 = sub_10002AECC(a1, 0LL, &v16, 0LL, 0);
    if ((_DWORD)v12) {
      return sub_10004A8D8(v12);
    }
    uuid_copy(__b, uu);
    __int128 v13 = a3[1];
    *(_OWORD *)&__b[16] = *a3;
    *(_OWORD *)&__b[32] = v13;
    *(void *)&__b[56] = a5;
    __b[48] = a4;
    uint64_t v12 = IOConnectCallStructMethod(v16, 0x3Bu, __b, 0x40uLL, 0LL, &outputStructCnt);
    IOServiceClose(v16);
    if ((_DWORD)v12) {
      return sub_10004A8D8(v12);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10001A5F8(char *a1, io_connect_t *a2)
{
  uint64_t result = 22LL;
  if (a1 && a2)
  {
    if (*a2)
    {
      return 37LL;
    }

    else
    {
      if (*a1 == 114) {
        __int16 v4 = a1 + 1;
      }
      else {
        __int16 v4 = a1;
      }
      int v6 = 0;
      uint64_t v5 = sub_10002AECC(v4, &v6, a2, 0LL, 0);
      return sub_10004A8D8(v5);
    }
  }

  return result;
}

uint64_t sub_10001A65C( const char *a1, mach_port_t a2, unsigned int a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v18 = 8LL;
  unsigned int v16 = sub_10002ABF0(a1, 0);
  uint64_t result = 22LL;
  if (a3 - 6 >= 0xFFFFFFFB && a2 && v16 <= 0x63)
  {
    memset(&outputStruct[4], 170, 0x958uLL);
    outputStruct[0] = __PAIR64__(v16, a3);
    outputStruct[1] = a4;
    outputStruct[2] = a5;
    outputStruct[3] = *a6;
    LOBYTE(outputStruct[4]) = *(void *)(a7 + 64);
    outputStruct[5] = a8;
    LOBYTE(outputStruct[6]) = a9;
    uint64_t result = IOConnectCallStructMethod(a2, 0x40u, outputStruct, 0x38uLL, outputStruct, &v18);
    if (a3 <= 4 && ((1 << a3) & 0x1A) != 0) {
      *a6 = outputStruct[0];
    }
    if ((_DWORD)result) {
      return sub_10004A8D8(result);
    }
  }

  return result;
}

uint64_t sub_10001A768(uint64_t connect)
{
  if ((_DWORD)connect) {
    return IOServiceClose(connect);
  }
  return connect;
}

unint64_t sub_10001A774(unsigned int a1, unint64_t a2, unint64_t a3)
{
  size_t v8 = 8LL;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  if (sysctlbyname("hw.memsize", &v9, &v8, 0LL, 0LL) == -1) {
    unint64_t v6 = 0x4000000LL;
  }
  else {
    unint64_t v6 = v9 / a1;
  }
  if (v6 >= a2) {
    unint64_t v6 = a2;
  }
  if (v6 <= a3) {
    return a3;
  }
  else {
    return v6;
  }
}

uint64_t sub_10001A7FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = dword_100074DB8;
  if (dword_100074DB8)
  {
    uint64_t v7 = (void *)qword_100074DC0;
    uint64_t v8 = dword_100074DB8;
    do
    {
      if (*v7 == a1) {
        return 0LL;
      }
      v7 += 3;
      --v8;
    }

    while (v8);
    unint64_t v9 = (char *)qword_100074DC0;
    if ((dword_100074DB8 & (dword_100074DB8 - 1)) != 0) {
      goto LABEL_9;
    }
    unint64_t v9 = (char *)realloc((void *)qword_100074DC0, 24LL * (2 * dword_100074DB8));
    if (v9)
    {
      qword_100074DC0 = (uint64_t)v9;
      goto LABEL_9;
    }

    return 12LL;
  }

  unint64_t v9 = (char *)malloc(0x18uLL);
  qword_100074DC0 = (uint64_t)v9;
  if (!v9) {
    return 12LL;
  }
LABEL_9:
  uint64_t v10 = 0LL;
  uint64_t v11 = &v9[24 * v6];
  *((void *)v11 + 1) = a2;
  *((void *)v11 + 2) = a3;
  *(void *)uint64_t v11 = a1;
  dword_100074DB8 = v6 + 1;
  return v10;
}

uint64_t sub_10001A8D0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_100074DD8 >= (unint64_t)qword_100074DC8)
  {
    qword_100074DC8 = qword_100074DD8 + 52428800;
    sub_100040B50( "Allocated (%llu) MB for cached btrees in %u blocks, limit is (%llu) MB\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (unint64_t)qword_100074DD8 >> 20);
    if (dword_100074DB8)
    {
      sub_100040B50("Node counts:", v9, v10, v11, v12, v13, v14, v15, v39);
      if (dword_100074DB8)
      {
        uint64_t v16 = 0LL;
        unint64_t v17 = 0LL;
        do
        {
          uint64_t v18 = *(void *)(qword_100074DC0 + v16 + 8);
          unint64_t v40 = 0LL;
          sub_100036B70(*(void *)(qword_100074DC0 + v16), 0LL, &v40);
          sub_100040B50(" %s tree (%llu)%s", v19, v20, v21, v22, v23, v24, v25, v18);
          ++v17;
          v16 += 24LL;
        }

        while (v17 < dword_100074DB8);
      }
    }
  }

  uint64_t result = 1LL;
  if (qword_100074DC0 && dword_100074DB8)
  {
    uint64_t v26 = 0LL;
    unint64_t v27 = 0LL;
    uint64_t v28 = 0LL;
    unint64_t v29 = 0LL;
    do
    {
      uint64_t v30 = qword_100074DC0 + v26;
      unint64_t v40 = 0LL;
      sub_100036B70(*(void *)(qword_100074DC0 + v26), 0LL, &v40);
      if (v40 > v29)
      {
        unint64_t v29 = v40;
        uint64_t v28 = v30;
      }

      ++v27;
      v26 += 24LL;
    }

    while (v27 < dword_100074DB8);
    if (v28)
    {
      uint64_t v38 = sub_100040B50( "Disabling fsck cross checks of %s tree\n",  v31,  v32,  v33,  v34,  v35,  v36,  v37,  *(void *)(v28 + 8));
      (*(void (**)(char *))(v28 + 16))(v38);
      qword_100074DC8 = 0LL;
    }

    return 1LL;
  }

  return result;
}

uint64_t sub_10001AA9C(size_t __size, void *a2, void *a3)
{
  unsigned int v5 = __size;
  if (!qword_100074DD0) {
    qword_100074DD0 = sub_10001A774(0x10u, 0x80000000uLL, 0LL);
  }
  int v6 = dword_100074DE0;
  if (dword_100074DE0)
  {
    if ((dword_100074DE0 & (dword_100074DE0 - 1)) != 0) {
      goto LABEL_8;
    }
    uint64_t v7 = realloc((void *)qword_100074DE8, 8LL * (2 * dword_100074DE0));
    if (v7)
    {
      qword_100074DE8 = (uint64_t)v7;
      goto LABEL_8;
    }

    return 12LL;
  }

  qword_100074DE8 = (uint64_t)malloc(8uLL);
  if (!qword_100074DE8) {
    return 12LL;
  }
LABEL_8:
  dword_100074DE0 = v6 + 1;
  *a2 = (v6 + 1);
  uint64_t v8 = calloc(1uLL, v5);
  *(void *)(qword_100074DE8 + 8LL * *a2 - 8) = v8;
  qword_100074DD8 += v5;
  if (!v8) {
    return 12LL;
  }
  if (!a3) {
    return 0LL;
  }
  uint64_t v9 = v8;
  uint64_t result = 0LL;
  *a3 = v9;
  return result;
}

uint64_t sub_10001AB94(unsigned int a1, uint64_t a2)
{
  uint64_t result = 14LL;
  if (a2)
  {
    if (dword_100074DE0 >= a2)
    {
      uint64_t v4 = qword_100074DE8 + 8 * a2;
      free(*(void **)(v4 - 8));
      uint64_t result = 0LL;
      qword_100074DD8 -= a1;
      *(void *)(v4 - 8) = 0LL;
    }
  }

  return result;
}

uint64_t sub_10001ABF4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = 14LL;
  if (a2 && dword_100074DE0 >= a2)
  {
    uint64_t v4 = *(void *)(qword_100074DE8 + 8 * a2 - 8);
    if (v4)
    {
      uint64_t result = 0LL;
      *a3 = v4;
    }
  }

  return result;
}

uint64_t sub_10001AC2C(size_t __n, uint64_t a2, void *__src)
{
  uint64_t v3 = 14LL;
  if (a2 && dword_100074DE0 >= a2)
  {
    uint64_t v4 = *(void **)(qword_100074DE8 + 8 * a2 - 8);
    if (v4)
    {
      if (v4 != __src) {
        memcpy(*(void **)(qword_100074DE8 + 8 * a2 - 8), __src, __n);
      }
      return 0LL;
    }

    else
    {
      return 14LL;
    }
  }

  return v3;
}

uint64_t sub_10001AC94(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0LL;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }

  return result;
}

uint64_t sub_10001ACC8( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8)
{
  if ((_DWORD)a4 != 8)
  {
    sub_100040B90( "fusion middle tree: invalid key length %u (expected %lu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  a4);
    uint64_t v22 = 92LL;
    uint64_t v23 = 875LL;
    goto LABEL_28;
  }

  if ((_DWORD)a6 != 16)
  {
    sub_100040B90( "fusion middle tree: invalid value length %u (expected %lu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  a6);
    uint64_t v22 = 92LL;
    uint64_t v23 = 876LL;
    goto LABEL_28;
  }

  unint64_t v10 = *a3;
  unint64_t v11 = *(void *)a5;
  unint64_t v12 = *(unsigned int *)(a5 + 8);
  uint64_t v13 = *(void *)(a1 + 8);
  int64_t v14 = *(void *)(v13 + 1368);
  unint64_t v15 = *(void *)(v13 + 1376);
  unint64_t v16 = *(void *)a5 - v14;
  BOOL v18 = v16 < v15 && v15 >= v12 && v16 <= v15 - v12;
  BOOL v19 = (uint64_t)v11 >= v14 && v18;
  uint64_t v20 = *(void *)(a1 + 24);
  if (v20)
  {
    uint64_t v21 = (unint64_t *)(v20 + 96);
  }

  else
  {
    if ((*(_BYTE *)(v13 + 65) & 1) == 0)
    {
      unint64_t v24 = 0LL;
      goto LABEL_20;
    }

    uint64_t v21 = (unint64_t *)(v13 + 40);
  }

  unint64_t v24 = *v21;
LABEL_20:
  unint64_t v25 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v13 + 36)));
  BOOL v27 = v25 < v10 && v24 > v12 && (v24 | v25) > v10;
  if (v27 && ((v24 - v12) | v25) >= v10)
  {
    if (v11)
    {
      unint64_t v29 = (unint64_t *)(v13 + 40);
      if (v20) {
        unint64_t v29 = (unint64_t *)(v20 + 48);
      }
      unint64_t v30 = *v29;
      BOOL v31 = v30 > v12 && v30 > v11;
      if (v31 && v30 - v12 >= v11)
      {
        int v33 = *(_DWORD *)(a5 + 12);
        if ((v33 & 3) == 3)
        {
          sub_100040B90( "fusion middle tree: bogus combination of flags. Dirty (0x%x) and Tenant (0x%x) flags are mutually exclusive (0x%llx -> 0x%llx:%llu Flags:0x%x)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  1);
          sub_100044E7C((char *)0x24E, 92);
        }

        char v34 = !v19;
        if ((v33 & 3) == 1) {
          char v34 = 1;
        }
        if ((v34 & 1) == 0)
        {
          sub_100040B90( "fusion middle tree: WBC mapping must have only the Dirty (0x%x) flag set (0x%llx -> 0x%llx:%llu Flags:0x%x)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  1);
          sub_100044E7C((char *)0x24F, 92);
        }

        if (!v19)
        {
          if ((v33 & 1) != 0) {
            *a7 += v12;
          }
          if ((v33 & 3) != 0)
          {
            sub_100007FF8(a7[2], v11, v12);
            uint64_t v22 = 0LL;
            a7[1] += v12;
            return v22;
          }

          a7[1] += v12;
          sub_10003D570(a1, v11, v12, 0LL, 0x40000000, v11, 0LL, 0, 0x15u, 2u);
        }

        return 0LL;
      }
    }

    sub_100040B90( "fusion middle tree: invalid to range 0x%llx:%llu\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  *(void *)a5);
    uint64_t v22 = 92LL;
    uint64_t v23 = 169LL;
  }

  else
  {
    sub_100040B90( "fusion middle tree: invalid from range 0x%llx:%llu\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  *a3);
    uint64_t v22 = 92LL;
    uint64_t v23 = 168LL;
  }

LABEL_28:
  sub_100044E7C((char *)v23, 92);
  return v22;
}

  if (!v7)
  {
    BOOL v19 = (*a1)[1];
    int v7 = *(void *)(v19 + 88);
    *(void *)(v19 + 88) = v7 + 1;
  }

  DWORD2(v28) = *((_DWORD *)a1 + 6);
  uint64_t v20 = (uint64_t)a1[1];
  if (v16)
  {
    uint64_t v21 = HIDWORD(v28) | 4;
    uint64_t v22 = *(void *)(v20 + 72);
    if (v22 && (*(_BYTE *)(v22 + 32) & 0x10) != 0) {
      uint64_t v21 = HIDWORD(v28) | 0x14;
    }
    HIDWORD(v28) = v21 & 0xFFFFFF1F | (32 * (*(void *)(*(void *)(v20 + 40) + 1096LL) != 0LL));
  }

  uint64_t v23 = (uint64_t)*a1;
  uint64_t v26 = v28;
  BOOL v27 = v29;
  uint64_t result = sub_10001E10C(v23, v20, v7, a4, (int32x2_t *)&v26);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10002D42C(*a1, v24, v25);
    if (!(_DWORD)result) {
      goto LABEL_24;
    }
  }

  return result;
}

uint64_t sub_10001AF50(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t result = sub_10003D51C(*a3, *(unsigned int *)(a5 + 8), 0);
  if ((_DWORD)result == 17)
  {
    sub_100040C68( "MT mapping (0x%llx -> 0x%llx, %llu, %c%s) is not completely referenced\n",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v5);
    return 0LL;
  }

  return result;
}

uint64_t sub_10001AFDC( uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 24);
  uint64_t v65 = 0LL;
  uint64_t v62 = 0LL;
  uint64_t v63 = 0LL;
  uint64_t v64 = 0LL;
  unint64_t v9 = *(void *)(v8 + 56);
  if (v9 > *(void *)(v8 + 64))
  {
    sub_100040B90( "fusion wbc: stable head offset (%llu) is greater than tail (%llu)\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(v8 + 56));
    uint64_t v10 = 92LL;
    uint64_t v11 = 171LL;
    goto LABEL_13;
  }

  uint64_t v13 = *(void *)(v8 + 40);
  uint64_t v12 = *(void *)(v8 + 48);
  if ((v12 != 0) == (v13 == 0))
  {
    sub_100040B90( "fusion wbc: WBC list OIDs are not consistent: Head: 0x%llx, Tail: 0x%llx\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(v8 + 40));
    uint64_t v10 = 92LL;
    uint64_t v11 = 172LL;
    goto LABEL_13;
  }

  int64_t v14 = (unint64_t *)a2;
  uint64_t v16 = a1[1];
  int64_t v17 = *(void *)(v16 + 1368);
  unint64_t v18 = *(void *)(v16 + 1376);
  if (v13)
  {
    unint64_t v19 = v13 - v17;
    if (v13 < v17 || (v19 < v18 ? (BOOL v20 = v19 > v18 - 1) : (BOOL v20 = 1), v20))
    {
      sub_100040B90( "fusion wbc: WBC list head OID 0x%llx is not in the WBC range\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(v8 + 40));
      uint64_t v10 = 92LL;
      uint64_t v11 = 173LL;
      goto LABEL_13;
    }
  }

  if (v12)
  {
    unint64_t v22 = v12 - v17;
    if (v12 < v17 || ((unint64_t v23 = v18 - 1, v22 < v18) ? (v24 = v22 > v23) : (v24 = 1), v24))
    {
      sub_100040B90( "fusion wbc: WBC list tail OID 0x%llx is not in the WBC range\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(v8 + 48));
      uint64_t v10 = 92LL;
      uint64_t v11 = 174LL;
      goto LABEL_13;
    }

    uint64_t v32 = 0LL;
    unint64_t v33 = 0LL;
    int v34 = 0;
    uint64_t v60 = v18 + v17;
    while (1)
    {
      unint64_t v35 = v13 - v17;
      if (v13 < v17 || v35 >= v18 || v35 > v23) {
        break;
      }
      int v59 = v34;
      if (v32)
      {
        free(v32);
        uint64_t v65 = 0LL;
      }

      uint64_t v36 = sub_100022BD0(a1, 0LL, 0x40000000, v13, 0LL, 0, 23, 0, &v65, (uint64_t)&v62, 0);
      if ((_DWORD)v36)
      {
        uint64_t v10 = v36;
        goto LABEL_14;
      }

      unint64_t v37 = ((unint64_t)v63 - 64) / 0x18;
      uint64_t v32 = v65;
      if (*((_DWORD *)v65 + 14) != (_DWORD)v37)
      {
        sub_100040B90( "fusion wbc: WBC list chunk (oid 0x%llx) has max entries %u != %u\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v13);
        uint64_t v10 = 92LL;
        uint64_t v11 = 176LL;
        goto LABEL_13;
      }

      unint64_t v38 = *((unsigned int *)v65 + 12);
      if (v38 >= v37 || (uint64_t v39 = *(void *)(v8 + 40), (_DWORD)v38) && v13 != v39)
      {
        sub_100040B90( "fusion wbc: WBC list chunk (oid 0x%llx) has invalid first index %u\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v13);
        uint64_t v10 = 92LL;
        uint64_t v11 = 177LL;
        goto LABEL_13;
      }

      unsigned int v40 = *((_DWORD *)v65 + 13);
      if (v40 > v37 || v13 != v39 && !v40)
      {
        sub_100040B90( "fusion wbc: WBC list chunk (oid 0x%llx) has invalid last index %u\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v13);
        uint64_t v10 = 92LL;
        uint64_t v11 = 178LL;
        goto LABEL_13;
      }

      if (v38 > v40)
      {
        sub_100040B90( "fusion wbc: bogus index combination in WBC list chunk (oid 0x%llx): %u starts after %u\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v13);
        uint64_t v10 = 92LL;
        uint64_t v11 = 712LL;
        goto LABEL_13;
      }

      unint64_t v61 = v33;
      if (v38 < v40)
      {
        uint64_t v41 = 3 * v38;
        do
        {
          uint64_t v42 = a1[1];
          uint64_t v43 = a1[3];
          if (v43)
          {
            __int128 v44 = (unint64_t *)(v43 + 96);
          }

          else
          {
            if ((*(_BYTE *)(v42 + 65) & 1) == 0)
            {
              unint64_t v45 = 0LL;
              goto LABEL_67;
            }

            __int128 v44 = (unint64_t *)(v42 + 40);
          }

          unint64_t v45 = *v44;
LABEL_67:
          __int128 v46 = &v32[v41];
          unint64_t v47 = v32[v41 + 9];
          a3 = v32[v41 + 10];
          unint64_t v48 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v42 + 36)));
          if (v48 >= v47) {
            goto LABEL_99;
          }
          unint64_t v49 = v45 | v48;
          BOOL v20 = v45 > a3;
          unint64_t v50 = v45 - a3;
          BOOL v51 = v20 && v49 > v47;
          if (!v51 || (v50 | v48) < v47)
          {
            if (a3 + v47 <= v48)
            {
LABEL_99:
              sub_100040B90( "fusion wbc: WBC list entry has invalid target range (0x%llx->0x%llx+%llu), Tier2: 0x%llx+%llu\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v47);
              uint64_t v10 = 92LL;
              uint64_t v11 = 180LL;
              goto LABEL_13;
            }

            sub_100040C68( "fusion wbc: WBC list entry has target range 0x%llx+%llu which is outside of Tier2 size\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v32[v41 + 9]);
            a3 = v46[10];
          }

          a2 = v46[8];
          int64_t v52 = a3 + a2;
          BOOL v54 = a2 < v17 || v52 > v60;
          BOOL v56 = v60 <= a2 || v52 <= v17;
          if (v54 && !v56)
          {
            sub_100040B90( "fusion wbc: WBC list entry 0x%llx+%llu is intersecting the WBC range 0x%llx+%llu\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a2);
            uint64_t v10 = 92LL;
            uint64_t v11 = 179LL;
            goto LABEL_13;
          }

          if (v54 && v56)
          {
            v61 += a3;
            sub_1000080E0(v14[2], a2, a3);
            sub_10003D570((uint64_t)a1, v46[8], v46[10], 0LL, 0x40000000, v46[8], 0LL, 0, 0x17u, 2u);
          }

          ++v38;
          uint64_t v32 = v65;
          v41 += 3LL;
        }

        while (v38 < *((unsigned int *)v65 + 13));
      }

      unint64_t v57 = v32[5];
      if (v57 <= v9 || v57 < *(void *)(v8 + 56) || v57 > *(void *)(v8 + 64))
      {
        sub_100040B90( "fusion wbc: WBC list chunk (oid 0x%llx) has incorrect tailOffset %llu, should be >%llu, >=%llu, and <=%llu\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v13);
        uint64_t v10 = 92LL;
        uint64_t v11 = 181LL;
        goto LABEL_13;
      }

      int v34 = v59 + 1;
      unint64_t v9 = v32[5];
      BOOL v58 = v13 == *(void *)(v8 + 48);
      uint64_t v13 = v57 % v18 + v17;
      unint64_t v33 = v61;
      unint64_t v23 = v18 - 1;
      if (v58) {
        goto LABEL_26;
      }
    }

    sub_100040B90("fusion wbc: WBC list object OID 0x%llx is not in the WBC range\n", a2, a3, a4, a5, a6, a7, a8, v13);
    uint64_t v10 = 92LL;
    uint64_t v11 = 175LL;
LABEL_13:
    sub_100044E7C((char *)v11, 92);
    goto LABEL_14;
  }

  int v34 = 0;
  unint64_t v33 = 0LL;
LABEL_26:
  if (v34 != *(_DWORD *)(v8 + 72))
  {
    sub_100040C68( "fusion wbc: expected %u list chunks but found %u\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(v8 + 72));
    sub_100044E7C((char *)0xB6, -8);
  }

  if (v33 != *(void *)(v8 + 88))
  {
    sub_100040C68( "fusion wbc: expected %llu W2RC dirty blocks but found %llu\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(v8 + 88));
    sub_100044E7C((char *)0x250, -8);
    unint64_t v33 = *(void *)(v8 + 88);
  }

  if (*v14 > v33)
  {
    sub_100040C68( "fusion mt: W2RC dirty blocks count (%llu) is smaller than number of dirty blocks found in MT (%llu)\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v33);
    sub_100044E7C((char *)0x331, -8);
  }

  if (v14[1] > *(void *)(v8 + 80))
  {
    sub_100040C68( "fusion mt: total RC blocks count (%llu) is smaller than number of blocks found in MT (%llu)\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(v8 + 80));
    sub_100044E7C((char *)0x332, -8);
  }

  unint64_t v25 = *(void *)(v8 + 104);
  if (v25)
  {
    unint64_t v26 = *(void *)(v8 + 96);
    if (!v26) {
      goto LABEL_44;
    }
    uint64_t v27 = a1[3];
    uint64_t v28 = (unint64_t *)(a1[1] + 40);
    if (v27) {
      uint64_t v28 = (unint64_t *)(v27 + 48);
    }
    unint64_t v29 = *v28;
    BOOL v30 = *v28 >= v25;
    unint64_t v31 = *v28 - v25;
    if (v31 == 0 || !v30 || v29 <= v26 || v31 < v26)
    {
LABEL_44:
      sub_100040B90( "RCStash: The stashed range is invalid: 0x%llx+%llu\n",  v26,  v25,  a4,  a5,  a6,  a7,  a8,  *(void *)(v8 + 96));
      uint64_t v10 = 92LL;
      uint64_t v11 = 742LL;
      goto LABEL_13;
    }

    sub_10003D570((uint64_t)a1, v26, v25, 0LL, 0x40000000, v26, 0LL, 0, 0x16u, 2u);
  }

  uint64_t v10 = 0LL;
LABEL_14:
  if (v65) {
    free(v65);
  }
  return v10;
}

uint64_t sub_10001B5EC( uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, int64_t *a5, uint64_t a6, int8x16_t *a7, _DWORD *a8)
{
  uint64_t v11 = *a3;
  int64_t v12 = *a5;
  unint64_t v13 = *((unsigned int *)a5 + 2);
  uint64_t v14 = a1[1];
  uint64_t v15 = *(void *)(v14 + 1368);
  BOOL v16 = __OFSUB__(*a5, v15);
  uint64_t v17 = *a5 - v15;
  if (v17 < 0 != v16
    || ((unint64_t v18 = *(void *)(v14 + 1376), v17 < v18) ? (v19 = v18 >= v13) : (v19 = 0),
        v19 ? (BOOL v20 = v17 > v18 - v13) : (BOOL v20 = 1),
        v20))
  {
    int v21 = *((_DWORD *)a5 + 3) & 3;
    if ((*((_DWORD *)a5 + 3) & 3) != 0 && v21 != 3)
    {
      int64_t v23 = v12 + v13;
      if (v12 < (uint64_t)(v12 + v13))
      {
        int v76 = *((_DWORD *)a5 + 3);
        BOOL v24 = "Unknown";
        if (v21 == 2) {
          BOOL v24 = "Tenant";
        }
        if (v21 == 1) {
          unint64_t v25 = "Dirty";
        }
        else {
          LOBYTE(v25) = (_BYTE)v24;
        }
        char v77 = (char)v25;
        uint64_t v74 = a7 + 2;
        uint64_t v26 = *a5;
        do
        {
          unint64_t v80 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v32 = v80;
          uint64_t v33 = v80 + 1;
          unint64_t v34 = v12 + v13;
          uint64_t v35 = v23 - (v80 + 1);
          if (v23 > (uint64_t)(v80 + 1))
          {
            else {
              unint64_t v34 = v12 + v13;
            }
          }

          char v36 = v32 - v12 + v11;
          if (v32 == v12 && v34 - v32 == v13)
          {
            if (sub_1000428C4( qword_10008DB70,  "Fix an orphaned %s MT mapping [0x%llx -> 0x%llx, %llu]? ",  v33,  v35,  v28,  v29,  v30,  v31,  v77))
            {
              if ((v76 & 1) != 0)
              {
                sub_100040B50( "...Elevating a Dirty mapping [0x%llx -> 0x%llx, %llu]\n",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v32 - v12 + v11);
                uint64_t v44 = sub_10002E1E0(a1, v12, v32 - v12 + v11, v13);
                if ((_DWORD)v44)
                {
                  uint64_t v55 = v44;
                  strerror(v44);
                  sub_100040B90( "Failed to elevate the content for Dirty mapping [0x%llx -> 0x%llx, %llu]: %s\n",  v57,  v58,  v59,  v60,  v61,  v62,  v63,  v36);
                  uint64_t v64 = 813LL;
                  int v65 = 92;
LABEL_39:
                  sub_100044E7C((char *)v64, v65);
                  return v55;
                }

                a7->i64[0] -= v13;
                *(void *)(a7[1].i64[1] + 88) -= v13;
                sub_100040B50( "...Decrementing fwp_dirtyInRC by %llu, new value: %llu\n",  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v13);
                uint64_t v52 = a7[1].i64[1];
                int8x16_t v78 = *v74;
                uint64_t v79 = v74[1].i64[0];
                uint64_t v54 = sub_100023FA8(a1, 0LL, v52, (uint64_t)&v78, v78, v53);
                if ((_DWORD)v54)
                {
                  uint64_t v55 = v54;
                  uint64_t v66 = v74->i64[0];
                  strerror(v54);
                  sub_100040B90( "Unable to write WBC Instance object (LBA 0x%llx): %s\n",  v67,  v68,  v69,  v70,  v71,  v72,  v73,  v66);
                  uint64_t v64 = 814LL;
                  int v65 = v55;
                  goto LABEL_39;
                }
              }

              *((_DWORD *)a5 + 3) &= 0xFFFFFFFC;
              *a8 = 1;
              sub_10003D570((uint64_t)a1, v12, v13, 0LL, 0x40000000, v12, 0LL, 0, 0x15u, 2u);
            }
          }

          else
          {
            sub_100040C68( "Found a partially orphaned %s mapping [0x%llx -> 0x%llx, %llu], where [0x%llx -> 0x%llx, %llu] region is n ot backed by WBCL.\n This is currently not supported, skipping\n",  v27,  v33,  v35,  v28,  v29,  v30,  v31,  v77);
          }

          uint64_t v26 = v34 + 1;
        }

        while ((uint64_t)(v34 + 1) < v23);
      }
    }
  }

  return 0LL;
}

BOOL sub_10001B8BC(uint64_t a1, int64_t a2, uint64_t a3)
{
  if (!*(void *)(a1 + 448)) {
    return 0LL;
  }
  uint64_t v5 = a1 + 392;
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  int64_t v12 = a2;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v8 = 16;
  unsigned int v9 = 8;
  int64_t v7 = v12;
  if (!sub_100034BB4(v5, 0LL, 2LL, &v12, &v9, 8u, &v10, &v8))
  {
    int64_t v7 = v12;
    return v7 < a3 + a2;
  }

  return 0LL;
}

uint64_t sub_10001B98C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10001B9C0(0);
}

uint64_t sub_10001B9C0(int a1)
{
  if (a1) {
    int v1 = "hit";
  }
  else {
    int v1 = "miss";
  }
  *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v42 = v2;
  __int128 v43 = v2;
  __sprintf_chk(v42, 0, 0x20uLL, "Cache %s count:", v1);
  sub_10004096C("\t%-32s %u\n", v3, v4, v5, v6, v7, v8, v9, (char)v42);
  __sprintf_chk(v42, 0, 0x20uLL, "Cache %s time:", v1);
  sub_10004096C("\t%-32s %.2lf [usec]\n", v10, v11, v12, v13, v14, v15, v16, (char)v42);
  __sprintf_chk(v42, 0, 0x20uLL, "Cache average %s time:", v1);
  sub_10004096C("\t%-32s %.2lf [usec]\n", v17, v18, v19, v20, v21, v22, v23, (char)v42);
  sub_10004096C("\tCache %s histogram:\n", v24, v25, v26, v27, v28, v29, v30, (char)v1);
  unint64_t v31 = 0LL;
  unint64_t v32 = 0LL;
  do
  {
    unint64_t v40 = (unint64_t)__exp10((double)(int)v31);
    if (v31 >= 4)
    {
      if (v31 > 6) {
        v32 /= 0xF4240uLL;
      }
      else {
        v32 /= 0x3E8uLL;
      }
    }

    uint64_t result = sub_10004096C("\t\t[%4llu - %4llu) [%4s] = %d\n", v33, v34, v35, v36, v37, v38, v39, v32);
    ++v31;
    unint64_t v32 = v40;
  }

  while (v31 != 8);
  return result;
}

void *sub_10001BBE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = *(void **)(a1 + 16);
  if (result) {
    return sub_100043770(result, a2, a3, a4);
  }
  return result;
}

uint64_t sub_10001BBF8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 24LL))();
}

uint64_t sub_10001BC08(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 64LL))();
}

uint64_t sub_10001BC18(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return sub_100044C70(result);
  }
  return result;
}

uint64_t sub_10001BC28(uint64_t a1)
{
  return sub_100044500(*(void *)(a1 + 16));
}

uint64_t sub_10001BC30(uint64_t a1)
{
  return sub_100044530(*(void *)(a1 + 16));
}

uint64_t sub_10001BC38(uint64_t a1)
{
  return sub_100043788(*(void *)(a1 + 16));
}

uint64_t sub_10001BC40(uint64_t a1)
{
  return sub_1000445C8(*(void *)(a1 + 16));
}

uint64_t sub_10001BC48(uint64_t *a1, __int128 *a2, int a3, unsigned int a4)
{
  uint64_t v37 = 0LL;
  uint64_t v8 = *a1;
  uint64_t v9 = *(uint64_t (***)(uint64_t))(*a1 + 72);
  if (v9 && v9[14] == sub_10001BEAC) {
    return 0LL;
  }
  uint64_t v10 = malloc(0xA0uLL);
  if (!v10) {
    return 12LL;
  }
  uint64_t v18 = v10;
  if (a4) {
    vm_size_t v19 = a4;
  }
  else {
    vm_size_t v19 = dword_100070044;
  }
  if (v19 > 0x100000
    || (unsigned int v20 = *(_DWORD *)(v8 + 100), v19 % v20)
    || vm_page_size < v19 && v19 % vm_page_size
    || vm_page_size > v19 && vm_page_size % v19)
  {
    uint64_t v21 = 34LL;
  }

  else
  {
    __int128 v24 = *((_OWORD *)v9 + 8);
    __int128 v23 = *((_OWORD *)v9 + 9);
    __int128 v25 = *((_OWORD *)v9 + 6);
    v10[7] = *((_OWORD *)v9 + 7);
    __int128 v26 = *(_OWORD *)v9;
    v10[1] = *((_OWORD *)v9 + 1);
    __int128 v28 = *((_OWORD *)v9 + 4);
    __int128 v27 = *((_OWORD *)v9 + 5);
    __int128 v29 = *((_OWORD *)v9 + 3);
    v10[2] = *((_OWORD *)v9 + 2);
    v10[3] = v29;
    v10[4] = v28;
    v10[5] = v27;
    *uint64_t v10 = v26;
    v10[8] = v24;
    v10[9] = v23;
    *((void *)v10 + 14) = sub_10001BEAC;
    *((void *)v10 + 5) = sub_10001BF20;
    *((void *)v10 + 3) = sub_10001BEF4;
    *((void *)v10 + 4) = sub_10001C12C;
    *((void *)v10 + 6) = sub_10001C134;
    *((void *)v10 + 8) = sub_10001C274;
    *((void *)v10 + 9) = sub_10001C2EC;
    *((void *)v10 + 11) = sub_10001C370;
    v10[6] = v25;
    *((void *)v10 + 16) = sub_10001C3EC;
    if (*(_BYTE *)(qword_10008DB78 + 36))
    {
      unint64_t v30 = 0x4000000LL;
    }

    else
    {
      if (a3) {
        unsigned __int8 v31 = a3;
      }
      else {
        unsigned __int8 v31 = 8;
      }
      unint64_t v30 = sub_10001A774(v31, (unint64_t)&_mh_execute_header, 0LL);
      uint64_t v8 = *a1;
      unsigned int v20 = *(_DWORD *)(*a1 + 100);
    }

    char v32 = a4 != 0;
    unint64_t v33 = v30 / v20;
    unint64_t v34 = *(void *)(v8 + 128);
    unint64_t v35 = v34 * v20;
    if (v33 <= v34) {
      unint64_t v35 = v30;
    }
    vm_size_t v36 = v35 / v19;
    sub_100040B50("Requested cache size: %lluMB (%uk blocks * %ukB)\n", v11, v12, v13, v14, v15, v16, v17, v35 >> 20);
    uint64_t v21 = sub_100043374(&v37, *a1, a2, *(void *)(*a1 + 72), v19, v36, 0x101u, 0, v32);
    uint64_t v8 = *a1;
    if (!(_DWORD)v21)
    {
      *(void *)(v8 + 16) = v37;
      *(void *)(*a1 + 72) = v18;
      return v21;
    }
  }

  free(v18);
  sub_10002BE10(v8);
  *a1 = 0LL;
  return v21;
}

uint64_t sub_10001BEAC(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    free(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = sub_10004377C(*(void *)(a1 + 16));
    sub_100043608(*(unsigned int **)(a1 + 16));
    *(void *)(a1 + 16) = 0LL;
  }

  return sub_10002BE10(a1);
}

double sub_10001BEF4(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6)
{
  LODWORD(v7) = a6;
  return sub_10001BF20(a1, a2, a3, a4, a5, 0, 0LL, 0LL, v7);
}

double sub_10001BF20( uint64_t a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, void *a7, uint64_t a8, uint64_t a9)
{
  if (a6)
  {
    sub_10001C510(a1, a2, a3, a4, a5, a9, a7, a8);
  }

  else
  {
    unsigned int v16 = sub_10002BDBC(a1);
    unsigned __int8 v24 = 1;
    uint64_t v23 = 0LL;
    if ((a9 & 0x10000) != 0)
    {
      uint64_t v21 = sub_10004377C(*(void *)(a1 + 16));
      LODWORD(a9) = a9 & 0xFFFEFFFF;
      (*(void (**)(uint64_t, uint64_t, unint64_t, void *, uint64_t, void, void, uint64_t, uint64_t, void))(v21 + 40))( a1,  a2,  a3,  a4,  a5,  0LL,  0LL,  a8,  a9,  0LL);
    }

    else
    {
      unint64_t v17 = v16 * a2;
      size_t v18 = v16 * a3;
      if (byte_10008DB68)
      {
        __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
        __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
        __darwin_time_t tv_sec = __tp.tv_sec;
        int v20 = SLODWORD(__tp.tv_nsec) / 1000;
      }

      else
      {
        __darwin_time_t tv_sec = 0LL;
        int v20 = 0;
      }

      if (!sub_1000439AC(*(void *)(a1 + 16), v17, v18, &v23, a5, a9, &v24, 0LL, a8))
      {
        if (byte_10008DB68)
        {
          __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
          __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
          sub_10001C710(v24, tv_sec, v20, __tp.tv_sec, SLODWORD(__tp.tv_nsec) / 1000, 0LL);
        }

        uint64_t v22 = (uint64_t *)v23;
        memcpy(a4, *(const void **)(v23 + 40), v18);
        return sub_1000446A8(*(void *)(a1 + 16), v22, 0);
      }
    }
  }

  return result;
}

void sub_10001C12C(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, void *a7)
{
}

uint64_t sub_10001C134(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 112)) {
    return 0LL;
  }
  unsigned int v4 = sub_10002BDBC(a1);
  unint64_t v5 = *(void *)(a2 + 120);
  uint64_t v6 = *(void *)(a2 + 128);
  uint64_t v7 = *(void *)(a2 + 112);
  uint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  if (byte_10008DB68)
  {
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t tv_sec = __tp.tv_sec;
    int v9 = SLODWORD(__tp.tv_nsec) / 1000;
  }

  else
  {
    __darwin_time_t tv_sec = 0LL;
    int v9 = 0;
  }

  uint64_t result = sub_100043840(*(void *)(a1 + 16), v5, &v11);
  if (!(_DWORD)result)
  {
    if (byte_10008DB68)
    {
      __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
      __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
      sub_10001C710(0LL, tv_sec, v9, __tp.tv_sec, SLODWORD(__tp.tv_nsec) / 1000, *(void *)(a2 + 136));
    }

    memcpy(*(void **)(a2 + 104), (const void *)(v7 + v6), v4);
    return sub_100043910(*(void **)(a1 + 16), v11);
  }

  return result;
}

uint64_t sub_10001C274(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  unsigned int v12 = sub_10002BDBC(a1);
  return sub_100044108(*(_DWORD **)(a1 + 16), a4, v12 * a2, v12 * a3, 0, 0, a5, a6, 0LL);
}

uint64_t sub_10001C2EC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  unsigned int v14 = sub_10002BDBC(a1);
  return sub_100044108(*(_DWORD **)(a1 + 16), a4, v14 * a2, v14 * a3, 0, 0, a5, a7, a6);
}

uint64_t sub_10001C370(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = sub_10002BDBC(a1);
  uint64_t v7 = sub_10004377C(*(void *)(a1 + 16));
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 88))(a1, a2, a3);
  if (!(_DWORD)v8) {
    sub_1000449B4(*(void *)(a1 + 16), 0LL, v6 * a2, v6 * a3);
  }
  return v8;
}

uint64_t sub_10001C3EC(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100043730(*(void *)(a1 + 16), a2);
  if (!(_DWORD)result)
  {
    unint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(sub_10004377C(*(void *)(a1 + 16)) + 128);
    return v5(a1, a2);
  }

  return result;
}

uint64_t sub_10001C438(int a1, uint64_t *a2)
{
  uint64_t result = sub_10002C5F0(a1, a2);
  if (!(_DWORD)result) {
    return sub_10001BC48(a2, 0LL, 0, 0);
  }
  return result;
}

uint64_t sub_10001C478(const char *a1, int a2, uint64_t *a3, __int128 *a4, int a5, unsigned int a6)
{
  uint64_t result = sub_10002C8BC(a1, a2, a3);
  if (!(_DWORD)result) {
    return sub_10001BC48(a3, a4, a5, a6);
  }
  return result;
}

uint64_t sub_10001C4D0(const char *a1, int a2, uint64_t *a3)
{
  uint64_t result = sub_10002C8BC(a1, a2, a3);
  if (!(_DWORD)result) {
    return sub_10001BC48(a3, 0LL, 0, 0);
  }
  return result;
}

void sub_10001C510( uint64_t a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, void *a7, uint64_t a8)
{
  if (a3 <= 1 && (a6 & 0x10000) == 0)
  {
    uint64_t v15 = *(void *)(a1 + 16);
    unsigned int v16 = sub_10002BDBC(a1);
    unint64_t v17 = v16 * a2;
    uint64_t v25 = 0LL;
    char v24 = 1;
    unsigned int v22 = sub_100043728(v15);
    if (byte_10008DB68)
    {
      __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
      __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
      __darwin_time_t tv_sec = __tp.tv_sec;
      int v18 = SLODWORD(__tp.tv_nsec) / 1000;
    }

    else
    {
      __darwin_time_t tv_sec = 0LL;
      int v18 = 0;
    }

    if (!sub_1000439AC(*(void *)(a1 + 16), v17, v16, &v25, a5, a6, &v24, (uint64_t)a7, a8))
    {
      if (byte_10008DB68)
      {
        __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
        __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
        __darwin_time_t v19 = __tp.tv_sec;
        int v20 = SLODWORD(__tp.tv_nsec) / 1000;
      }

      else
      {
        __darwin_time_t v19 = 0LL;
        int v20 = 0;
      }

      if (v24)
      {
        if (byte_10008DB68) {
          sub_10001C710(1LL, tv_sec, v18, v19, v20, 0LL);
        }
        uint64_t v21 = (uint64_t *)v25;
        memcpy(a4, *(const void **)(v25 + 40), v16);
        sub_1000446A8(*(void *)(a1 + 16), v21, 0);
        a7[14] = 0LL;
      }

      else
      {
        if (byte_10008DB68) {
          a7[17] = 1000000 * (v19 - tv_sec) - v18 + v20;
        }
        a7[13] = a4;
        a7[15] = v17 / v22 * v22;
        a7[16] = v17 % v22;
      }
    }
  }

uint64_t sub_10001C710(uint64_t result, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  int v6 = result;
  uint64_t v7 = a6 - a3 + a5 + 1000000 * (a4 - a2);
  if (v7)
  {
    uint64_t result = sub_10004A708(a6 - a3 + a5 + 1000000 * (a4 - a2));
    int v8 = result + 1;
  }

  else
  {
    int v8 = 0;
  }

  if (v8 >= 7) {
    int v8 = 7;
  }
  if (v6) {
    int v9 = (double *)&unk_100074DF0;
  }
  else {
    int v9 = (double *)&unk_100074E20;
  }
  ++*((_DWORD *)v9 + 2);
  *int v9 = *v9 + (double)(unint64_t)v7;
  uint64_t v10 = &unk_100074E2C;
  if (v6) {
    uint64_t v10 = &unk_100074DFC;
  }
  ++v10[v8];
  return result;
}

uint64_t sub_10001C7B4(void *a1, const char *a2, uint64_t a3)
{
  int v6 = sub_100003F34();
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__str = v7;
  __int128 v12 = v7;
  snprintf(__str, 0x20uLL, "%s (%s)", a2, v6);
  uint64_t v8 = 0LL;
  int v9 = (const char *)(a1 + 40);
  do
  {
    if (!strncmp(v9, __str, 0x20uLL)) {
      break;
    }
    ++v8;
    v9 += 48;
  }

  while (v8 != 7);
  memmove(a1 + 46, a1 + 40, 48LL * v8);
  __strlcpy_chk(a1 + 40, __str, 32LL, 32LL);
  uint64_t result = sub_10000E000();
  a1[44] = result;
  a1[45] = a3;
  return result;
}

char *sub_10001C8A0(unint64_t a1, char *__str, int a3)
{
  uint64_t v6 = 0LL;
  LODWORD(v7) = 1;
  do
  {
    if (__ROR8__(0x1CAC083126E978D5LL * (a1 / *((void *)&unk_10006B190 + v6 + 1)), 3) >= 0x4189374BC6A7F0uLL) {
      uint64_t v7 = (v6 + 2);
    }
    else {
      uint64_t v7 = v7;
    }
    ++v6;
  }

  while (v6 != 4);
  int v8 = snprintf(__str, a3, "%llu", a1 / 0xE8D4A51000LL);
  uint64_t result = 0LL;
  if ((v8 & 0x80000000) == 0 && v8 <= a3)
  {
    if ((int)v7 < 2)
    {
      return __str;
    }

    else
    {
      uint64_t v10 = v7 - 1;
      uint64_t v11 = &qword_10006B198;
      while (1)
      {
        unint64_t v12 = *v11++;
        int v13 = snprintf(&__str[v8], a3 - v8, ".%llu", a1 / v12 % 0x3E8);
        if (v13 < 0) {
          break;
        }
        v8 += v13;
        if (v8 > a3) {
          break;
        }
        if (!--v10) {
          return __str;
        }
      }

      return 0LL;
    }
  }

  return result;
}

void *sub_10001CA10()
{
  return &unk_100074E50;
}

char *sub_10001CA1C(uint64_t a1, unsigned int a2)
{
  if (a1 && (uint64_t v2 = *(void *)(a1 + 8)) != 0) {
    unsigned int v3 = *(_DWORD *)(v2 + 180);
  }
  else {
    unsigned int v3 = 100;
  }
  if (v3 <= a2) {
    return 0LL;
  }
  else {
    return (char *)&unk_100075058 + 960 * a2;
  }
}

char *sub_10001CA50(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(v2 + 180);
  if (!(_DWORD)v3) {
    return 0LL;
  }
  unsigned int v4 = (uint64_t *)(v2 + 184);
  for (uint64_t result = (char *)&unk_100075058; ; result += 960)
  {
    uint64_t v6 = *v4++;
    if (v6 == a2) {
      break;
    }
    if (!--v3) {
      return 0LL;
    }
  }

  return result;
}

void *sub_10001CA88(uint64_t a1, unsigned __int8 *uu1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(_DWORD *)(v2 + 180))
  {
    unint64_t v5 = 0LL;
    uint64_t v6 = &unk_100075058;
    do
    {
      uint64_t v7 = v6[5];
      if (v7)
      {
        uint64_t v2 = *(void *)(a1 + 8);
      }

      ++v5;
      v6 += 120;
    }

    while (v5 < *(unsigned int *)(v2 + 180));
  }

  return 0LL;
}

uint64_t sub_10001CB00(uint64_t result, _DWORD *a2, int *a3)
{
  uint64_t v3 = qword_10008DB78;
  int v4 = *(_DWORD *)(qword_10008DB78 + 20);
  if (v4 == -1)
  {
    *a2 = 0;
    if (result && (uint64_t v6 = *(void *)(result + 8)) != 0) {
      int v5 = *(_DWORD *)(v6 + 180);
    }
    else {
      int v5 = 100;
    }
  }

  else
  {
    *a2 = v4;
    int v5 = *(_DWORD *)(v3 + 20) + 1;
  }

  *a3 = v5;
  return result;
}

void sub_10001CB48()
{
  uint64_t v0 = (void **)&unk_100075058;
  uint64_t v1 = 100LL;
  do
  {
    sub_10002961C(v0);
    v0 += 120;
    --v1;
  }

  while (v1);
}

void sub_10001CB80()
{
  uint64_t v0 = (void **)&unk_100075058;
  uint64_t v1 = 100LL;
  do
  {
    sub_10002961C(v0);
    v0 += 120;
    --v1;
  }

  while (v1);
  sub_10002955C(qword_100074E50);
  sub_100041470();
  sub_10003FF90();
  uint64_t v2 = qword_10008DB78;
  if (qword_10008DB78)
  {
    if (*(void *)(qword_10008DB78 + 56))
    {
      time_t v8 = time(0LL);
      sub_100044FEC(*(FILE **)(qword_10008DB78 + 56), *(_DWORD *)(qword_10008DB78 + 28));
      uint64_t v3 = *(FILE **)(qword_10008DB78 + 56);
      int v4 = ctime(&v8);
      fprintf(v3, "fsck_apfs completed at %s", v4);
      fclose(*(FILE **)(qword_10008DB78 + 56));
      uint64_t v2 = qword_10008DB78;
    }

    int v5 = *(FILE **)(v2 + 64);
    if (v5)
    {
      sub_100044FEC(v5, *(_DWORD *)(v2 + 28));
      fclose(*(FILE **)(qword_10008DB78 + 64));
    }
  }

  sub_100044E08();
  if (qword_10008DB70) {
    sub_100042804((FILE **)qword_10008DB70);
  }
  uint64_t v6 = (void *)qword_10008DB78;
  if (qword_10008DB78)
  {
    uint64_t v7 = *(void **)(qword_10008DB78 + 8);
    if (v7)
    {
      if (*(_BYTE *)(qword_10008DB78 + 49))
      {
        sub_100041530(*(const char **)(qword_10008DB78 + 8));
        uint64_t v7 = *(void **)(qword_10008DB78 + 8);
      }

      free(v7);
      uint64_t v6 = (void *)qword_10008DB78;
    }

    free(v6);
  }

void (__cdecl *sub_10001CCA4())(int)
{
  return signal(6, (void (__cdecl *)(int))sub_10001CD20);
}

void sub_10001CD20(int a1)
{
  uint64_t v2 = (char *)&unk_100075058;
  uint64_t v3 = 100LL;
  do
  {
    sub_10002970C((uint64_t)v2);
    v2 += 960;
    --v3;
  }

  while (v3);
  sub_100029604(qword_100074E50);
  sub_100041470();
  if (qword_10008DB78)
  {
    int v4 = *(const char **)(qword_10008DB78 + 8);
    if (v4)
    {
      if (*(_BYTE *)(qword_10008DB78 + 49)) {
        sub_100041530(v4);
      }
    }
  }

  _exit(a1 + 128);
}

void sub_10001CD90(int a1, uint64_t a2, uint64_t a3)
{
  if (a1) {
    unint64_t v4 = 52428800LL;
  }
  else {
    unint64_t v4 = 10485760LL;
  }
  if (a1) {
    int v5 = &unk_10008C7D8;
  }
  else {
    int v5 = &unk_10008C758;
  }
  sub_10001D49C((uint64_t)v5, a2, v4);
  v5[14] = a3;
  *((_BYTE *)v5 + 120) = 1;
}

void sub_10001CDE4(int a1)
{
  if (a1) {
    uint64_t v1 = &unk_10008C7D8;
  }
  else {
    uint64_t v1 = &unk_10008C758;
  }
  sub_10001D5BC((uint64_t)v1);
  v1[13] = 0LL;
  v1[14] = 0LL;
}

uint64_t sub_10001CE20(int a1, unint64_t a2, int a3)
{
  if (a1) {
    uint64_t v6 = &unk_10008C7D8;
  }
  else {
    uint64_t v6 = &unk_10008C758;
  }
  uint64_t v7 = a1 ? &unk_10008C7D8 : &unk_10008C758;
  if (v7[80]) {
    return 0LL;
  }
  uint64_t v10 = sub_10001DA4C((uint64_t)v6, a2, 1uLL, a3 == 0);
  if ((_DWORD)v10 == 17) {
    return 0LL;
  }
  uint64_t v8 = v10;
  if (!(_DWORD)v10)
  {
    if (a1) {
      uint64_t v11 = &unk_10008C7D8;
    }
    else {
      uint64_t v11 = &unk_10008C758;
    }
    if (v11[13] < a2)
    {
      uint64_t v8 = 0LL;
      v11[13] = a2;
      return v8;
    }

    return 0LL;
  }

  if (v7[80]) {
    return 0LL;
  }
  sub_10001D5BC((uint64_t)v6);
  if (a1) {
    unint64_t v12 = &unk_10008C7D8;
  }
  else {
    unint64_t v12 = &unk_10008C758;
  }
  v12[13] = 0LL;
  v12[14] = 0LL;
  return v8;
}

uint64_t sub_10001CF00(unint64_t a1, int a2)
{
  char v2 = a1;
  int v3 = sub_10001CE20(a2 != 13, a1, 1);
  if (v3)
  {
    int v11 = v3;
    sub_100040C68( "object (oid 0x%llx): Unable to mark omap entry in usefor omap space verification \n",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v2);
    sub_100044E7C((char *)0x3D1, v11);
  }

  return 0LL;
}

uint64_t sub_10001CF60(uint64_t *a1, uint64_t a2, int a3, int a4, uint64_t (*a5)(void))
{
  if (a3) {
    uint64_t v9 = &unk_10008C7D8;
  }
  else {
    uint64_t v9 = &unk_10008C758;
  }
  if (a3) {
    uint64_t v10 = &unk_10008C828;
  }
  else {
    uint64_t v10 = &unk_10008C7A8;
  }
  if (sub_10001D604((uint64_t)v9) && *v10 == 0)
  {
    if (a2) {
      uint64_t v13 = *(void *)(*(void *)(a2 + 40) + 8LL);
    }
    else {
      uint64_t v13 = 0LL;
    }
    uint64_t v40 = 0LL;
    BOOL v14 = sub_1000215C0(v13);
    uint64_t v15 = (unint64_t *)&unk_10008C7C8;
    if (a3) {
      uint64_t v15 = (unint64_t *)&unk_10008C848;
    }
    unint64_t v16 = *v15;
    if (a3) {
      unint64_t v17 = &unk_10008C7D8;
    }
    else {
      unint64_t v17 = &unk_10008C758;
    }
    if (v14) {
      unint64_t v18 = v16;
    }
    else {
      unint64_t v18 = 0LL;
    }
    uint64_t v12 = sub_10001D178(a1, a2, (uint64_t)v9, v18, v17[13] + 1LL, *((_BYTE *)v17 + 120) == 0, &v40, a4, a5);
    uint64_t v19 = v40;
    if ((_DWORD)v12) {
      BOOL v20 = 1;
    }
    else {
      BOOL v20 = v40 == 0;
    }
    if (v20) {
      goto LABEL_43;
    }
    uint64_t v41 = 0LL;
    if (v13) {
      asprintf(&v41, "volume omap (fs_oid 0x%llx)");
    }
    else {
      asprintf(&v41, "container omap");
    }
    __int128 v28 = v41;
    if (!*((_BYTE *)v17 + 120)) {
      goto LABEL_35;
    }
    uint64_t v29 = sub_100020AC0(a1, a2, 1LL);
    if ((_DWORD)v29)
    {
      uint64_t v12 = v29;
      sub_100040C68( "%s: could not iterate reaper for omap space verification\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  (char)v28);
      uint64_t v37 = 978LL;
      goto LABEL_40;
    }

    if (sub_10001D604((uint64_t)v9))
    {
      uint64_t v12 = sub_10001D178(a1, a2, (uint64_t)v9, v18, v17[13] + 1LL, 1, &v40, a4, a5);
      uint64_t v19 = v40;
    }

    else
    {
LABEL_35:
      uint64_t v12 = 0LL;
    }

    if ((_DWORD)v12 || !v19 || !a4)
    {
LABEL_41:
      if (v28) {
        free(v28);
      }
LABEL_43:
      *((_BYTE *)v17 + 120) = 0;
      return v12;
    }

    sub_100040C68("%s: %llu orphan mappings found\n", v21, v22, v23, v24, v25, v26, v27, (char)v28);
    uint64_t v12 = 0LL;
    uint64_t v37 = 979LL;
LABEL_40:
    sub_100044E7C((char *)v37, -7);
    goto LABEL_41;
  }

  return 0LL;
}

uint64_t sub_10001D178( uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, char a6, void *a7, int a8, uint64_t (*a9)(void))
{
  unint64_t v49 = 0LL;
  unint64_t v50 = 0LL;
  *a7 = 0LL;
  if (a4 < a5)
  {
    unint64_t v13 = a4;
    while (sub_10001D7F8(a3, v13, a5 - v13, &v50))
    {
      if ((a6 & 1) == 0)
      {
        uint64_t v26 = 0LL;
        *a7 = 1LL;
        return v26;
      }

      if ((sub_10001D918(a3, v50, a5 - v50, &v49) & 1) == 0) {
        unint64_t v49 = a5;
      }
      if (a8)
      {
        if (v50 == v49 - 1) {
          sub_100040C68("orphan omap mapping found for oid %llu\n", v15, v16, v17, v18, v19, v20, v21, v50);
        }
        else {
          sub_100040C68( "orphan omap mappings found for oid range %llu --> %llu\n",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v50);
        }
      }

      unint64_t v13 = v49;
      if (*(_BYTE *)(qword_10008DB78 + 41))
      {
        unint64_t v22 = v50;
        uint64_t v57 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v23 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v55 = v23;
        __int128 v56 = v23;
        __int128 v53 = v23;
        __int128 v54 = v23;
        __int128 v52 = v23;
        uint64_t v24 = sub_100029B94(a1, a2, &v57);
        if ((_DWORD)v24) {
          return v24;
        }
        v51[0] = v22;
        v51[1] = 0LL;
        uint64_t v25 = sub_100035838((uint64_t)&v52, v57, 0LL, v51, 0x10u);
        if ((_DWORD)v25)
        {
          uint64_t v26 = v25;
          char v39 = strerror(v25);
          sub_100040B90( "unable to initialize omap tree iterator for repair: %s\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v39);
          sub_100044E7C((char *)0x3DF, v26);
          return v26;
        }

        if (!BYTE8(v54))
        {
          uint64_t v27 = (unint64_t *)v53;
          while (*v27 < v13)
          {
            ++*a7;
            uint64_t v28 = a9();
            if ((_DWORD)v28)
            {
              uint64_t v26 = v28;
              goto LABEL_16;
            }

            uint64_t v29 = (*((uint64_t (**)(__int128 *))&v52 + 1))(&v52);
            if ((_DWORD)v29)
            {
              uint64_t v26 = v29;
              char v30 = strerror(v29);
              sub_100040B90("error iterating omap tree for repair: %s\n", v31, v32, v33, v34, v35, v36, v37, v30);
              sub_100044E7C((char *)0x3E1, v26);
              goto LABEL_16;
            }

            uint64_t v27 = (unint64_t *)v53;
            if (BYTE8(v54)) {
              break;
            }
          }
        }

        uint64_t v26 = 0LL;
LABEL_16:
        if ((void)v52) {
          ((void (*)(__int128 *))v52)(&v52);
        }
        if ((_DWORD)v26) {
          return v26;
        }
        unint64_t v13 = v49;
      }

      if (v13 >= a5) {
        return 0LL;
      }
    }
  }

  return 0LL;
}

uint64_t sub_10001D3B0(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v4 = sub_10001CF60(a1, a2, a3, 1, (uint64_t (*)(void))sub_10001D418);
  if (a3) {
    uint64_t v5 = &unk_10008C7D8;
  }
  else {
    uint64_t v5 = &unk_10008C758;
  }
  sub_10001D5BC((uint64_t)v5);
  v5[13] = 0LL;
  v5[14] = 0LL;
  return v4;
}

uint64_t sub_10001D418(__int128 *a1, uint64_t a2, _BYTE *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v6 = sub_1000251C0(a5, 3u, 0, 0, 0, a1, 0x10u, a3, 0x10u);
  uint64_t v7 = v6;
  if ((_DWORD)v6)
  {
    uint64_t v8 = *(void *)a1;
    strerror(v6);
    sub_100040B90("object (oid 0x%llx): unable to add omap repair: %s\n", v9, v10, v11, v12, v13, v14, v15, v8);
    sub_100044E7C((char *)0x3E0, v7);
  }

  return v7;
}

void sub_10001D49C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6 = *(unsigned int *)(a1 + 24);
  if (a2) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = -1LL;
  }
  if (v6 > a3) {
    uint64_t v8 = -1LL;
  }
  else {
    uint64_t v8 = a3 / v6;
  }
  *(void *)(a1 + 64) = v7;
  *(void *)(a1 + 72) = v8;
  *(void *)(a1 + 96) = 1024LL;
  uint64_t v9 = calloc(0x80uLL, 1uLL);
  *(void *)(a1 + 88) = v9;
  if (v9)
  {
    uint64_t v10 = v9;
    int v11 = *(_DWORD *)(a1 + 96);
    int v12 = v11 - 1;
    if ((v11 - 1) > 7)
    {
      int v14 = v12 >> 3;
      *uint64_t v9 = 0;
      if (v12 >= 16)
      {
        uint64_t v15 = v9 + 1;
        if (v14 <= 2) {
          int v16 = 2;
        }
        else {
          int v16 = v12 >> 3;
        }
        bzero(v15, (v16 - 1));
      }

      int v13 = 510 << (v12 & 7);
      v10 += v14;
    }

    else
    {
      int v13 = 255 << v11;
    }

    *v10 &= v13;
  }

void sub_10001D5BC(uint64_t a1)
{
  char v2 = *(void **)(a1 + 88);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 88) = 0LL;
  }

  if (*(void *)(a1 + 56)) {
    sub_100036CD8(a1, 0LL);
  }
}

BOOL sub_10001D604(uint64_t a1)
{
  return *(void *)(a1 + 56) != 0LL;
}

uint64_t sub_10001D614(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  if (!a3) {
    return 0LL;
  }
  unint64_t v5 = a3;
  uint64_t v8 = 0LL;
  v9.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v9.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v12[6] = v9;
  v12[7] = v9;
  v12[4] = v9;
  v12[5] = v9;
  int v12[2] = v9;
  void v12[3] = v9;
  v12[0] = v9;
  v12[1] = v9;
  while (1)
  {
    uint64_t result = sub_10001D6FC(a1, a2, v12);
    if ((_DWORD)result) {
      break;
    }
    if (v5 >= 1024 - (a2 & 0x3FF)) {
      unint64_t v11 = 1024 - (a2 & 0x3FF);
    }
    else {
      unint64_t v11 = v5;
    }
    memcpy((void *)(a4 + 8 * v8), (char *)v12 + ((a2 >> 3) & 0x78), v11 >> 3);
    a2 += v11;
    v8 += v11 >> 6;
    v5 -= v11;
    if (!v5) {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10001D6FC(uint64_t a1, unint64_t a2, int8x16_t *a3)
{
  unint64_t v6 = a2 >> 10;
  unint64_t v23 = a2 >> 10;
  unsigned int v21 = 128;
  unsigned int v22 = 8;
  uint64_t v7 = sub_100034BB4(a1, 0LL, 0LL, &v23, &v22, 8u, a3, &v21);
  uint64_t v8 = v7;
  if ((v7 & 0xFFFFFFFD) != 0)
  {
    char v9 = v23;
    strerror(v7);
    sub_100040B90("failed to find node at segment (%llu) : error %s\n", v10, v11, v12, v13, v14, v15, v16, v9);
    sub_100044E7C((char *)0x363, v8);
  }

  if ((_DWORD)v8 == 2)
  {
    uint64_t v17 = *(void *)(a1 + 88);
    if (v17
      && *(void *)(a1 + 96) > v6
      && ((*(unsigned __int8 *)(v17 + (a2 >> 13)) >> ((a2 >> 10) & 7)) & 1) != 0)
    {
      unsigned int v18 = 255;
    }

    else
    {
      unsigned int v18 = 0;
    }

    uint64_t v8 = 0LL;
    int8x16_t v19 = vdupq_n_s8(v18);
    a3[6] = v19;
    a3[7] = v19;
    a3[4] = v19;
    a3[5] = v19;
    a3[2] = v19;
    a3[3] = v19;
    *a3 = v19;
    a3[1] = v19;
  }

  return v8;
}

uint64_t sub_10001D7F8(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  unint64_t v6 = a2;
  memset(&v12, 0, 128);
  sub_10001D6FC(a1, a2, &v12);
  if (!a3) {
    return 0LL;
  }
  for (unint64_t i = (v6 >> 6) & 0xF; ; ++i)
  {
    if (i >= 0x10)
    {
      sub_10001D6FC(a1, v6, &v12);
      unint64_t i = (v6 >> 6) & 0xF;
    }

    unint64_t v9 = 64 - (v6 & 0x3F);
    if (a3 < v9) {
      unint64_t v9 = a3;
    }
    unint64_t v10 = (0xFFFFFFFFFFFFFFFFLL >> -(char)((v6 & 0x3F) + v9)) & (-1LL << v6) & v12.i64[i];
    if (v10) {
      break;
    }
    v6 += v9;
    a3 -= v9;
    if (!a3) {
      return 0LL;
    }
  }

  *a4 = __clz(__rbit64(v10)) | v6 & 0xFFFFFFFFFFFFFFC0LL;
  return 1LL;
}

uint64_t sub_10001D918(uint64_t a1, unint64_t a2, unint64_t a3, void *a4)
{
  unint64_t v6 = a2;
  memset(&v16, 0, 128);
  sub_10001D6FC(a1, a2, &v16);
  if (!a3) {
    return 0LL;
  }
  for (unint64_t i = (v6 >> 6) & 0xF; ; ++i)
  {
    if (i >= 0x10)
    {
      sub_10001D6FC(a1, v6, &v16);
      unint64_t i = (v6 >> 6) & 0xF;
    }

    unint64_t v9 = 64 - (v6 & 0x3F);
    if (a3 < v9) {
      unint64_t v9 = a3;
    }
    unint64_t v10 = (0xFFFFFFFFFFFFFFFFLL >> (-(v6 & 0x3F) - v9)) & (-1LL << v6);
    uint64_t v11 = v16.i64[i] & v10;
    if (v11 != v10) {
      break;
    }
    v6 += v9;
    a3 -= v9;
    if (!a3) {
      return 0LL;
    }
  }

  unint64_t v13 = v11 ^ v10;
  unint64_t v14 = __clz(__rbit64(v11 ^ v10));
  if (v13) {
    unint64_t v15 = v14 + 1;
  }
  else {
    unint64_t v15 = 0LL;
  }
  *a4 = (v6 & 0xFFFFFFFFFFFFFFC0LL) + v15 - 1;
  return 1LL;
}

uint64_t sub_10001DA4C(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  unint64_t v6 = a2;
  memset(&v22, 0, 128);
  uint64_t result = sub_10001D6FC(a1, a2, &v22);
  if (!(_DWORD)result)
  {
    if (a3)
    {
      unint64_t v14 = (v6 >> 6) & 0xF;
      unint64_t v15 = v6;
      while (1)
      {
        if (v14 >= 0x10)
        {
          uint64_t result = sub_10001DBA8(a1, v6, &v22, v9, v10, v11, v12, v13);
          if ((_DWORD)result) {
            return result;
          }
          uint64_t result = sub_10001D6FC(a1, v15, &v22);
          if ((_DWORD)result) {
            return result;
          }
          unint64_t v14 = (v15 >> 6) & 0xF;
          unint64_t v6 = v15;
        }

        unint64_t v16 = 64 - (v15 & 0x3F);
        if (a3 < v16) {
          unint64_t v16 = a3;
        }
        unint64_t v17 = (0xFFFFFFFFFFFFFFFFLL >> (-(v15 & 0x3F) - v16)) & (-1LL << v15);
        uint64_t v18 = v22.i64[v14];
        unint64_t v19 = a4 ? 0LL : (0xFFFFFFFFFFFFFFFFLL >> (-(v15 & 0x3F) - v16)) & (-1LL << v15);
        if ((v18 & v17) != v19) {
          break;
        }
        unint64_t v20 = v18 & ~v17;
        uint64_t v21 = v18 | v17;
        if (!a4) {
          uint64_t v21 = v20;
        }
        v22.i64[v14] = v21;
        v15 += v16;
        ++v14;
        a3 -= v16;
        if (!a3) {
          return sub_10001DBA8(a1, v6, &v22, v9, v10, v11, v12, v13);
        }
      }

      return 17LL;
    }

    else
    {
      return sub_10001DBA8(a1, v6, &v22, v9, v10, v11, v12, v13);
    }
  }

  return result;
}

uint64_t sub_10001DBA8( uint64_t a1, unint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 64) <= a2)
  {
    sub_100040C68( "bitmap store: address %llu is beyond maximum allowed %llu\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  a2);
    return 34LL;
  }

  uint64_t v10 = a1;
  unint64_t v40 = 0LL;
  sub_100036B70(a1, 0LL, &v40);
  if (v40 >= *(void *)(v10 + 72))
  {
    if (!*(_BYTE *)(v10 + 80)) {
      sub_100040C68( "bitmap store: reached limit of %llu B-tree nodes\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  *(void *)(v10 + 72));
    }
    *(_BYTE *)(v10 + 80) = 1;
    return 12LL;
  }

  else
  {
    if (sub_100007E34((uint64_t)a3, 0LL, 1024LL) && *(void *)(v10 + 88) && !sub_10001DEB0(v10, a2 >> 10))
    {
      uint64_t v27 = *(void *)(v10 + 88);
      unint64_t v28 = a2 >> 13;
      int v29 = *(unsigned __int8 *)(v27 + (a2 >> 13)) | (1 << ((a2 >> 10) & 7));
    }

    else
    {
      if (!sub_100007F14((uint64_t)a3, 0LL, 1024LL)
        || !*(void *)(v10 + 88)
        || sub_10001DEB0(v10, a2 >> 10))
      {
        unint64_t v40 = a2 >> 10;
        uint64_t v18 = sub_1000364F0((_DWORD *)v10, 0LL, &v40, 8LL, a3, 128LL);
        uint64_t v10 = v18;
        if ((_DWORD)v18)
        {
          char v19 = v40;
          strerror(v18);
          sub_100040B90("failed to insert node at segment (%llu) error : %s\n", v20, v21, v22, v23, v24, v25, v26, v19);
          sub_100044E7C((char *)0x1C9, v10);
        }

        return v10;
      }

      uint64_t v27 = *(void *)(v10 + 88);
      unint64_t v28 = a2 >> 13;
      int v29 = *(unsigned __int8 *)(v27 + (a2 >> 13)) & ~(1 << ((a2 >> 10) & 7));
    }

    *(_BYTE *)(v27 + v28) = v29;
    unint64_t v40 = a2 >> 10;
    int v30 = sub_100036AC4(v10, 0LL, (uint64_t)&v40, 8LL);
    LODWORD(v10) = v30;
    if ((v30 & 0xFFFFFFFD) != 0)
    {
      char v31 = v40;
      strerror(v30);
      sub_100040B90("failed to remove node at segment (%llu) error : %s\n", v32, v33, v34, v35, v36, v37, v38, v31);
      sub_100044E7C((char *)0x1CA, v10);
    }

    if ((_DWORD)v10 == 2) {
      return 0LL;
    }
    else {
      return v10;
    }
  }

uint64_t sub_10001DD90(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  unint64_t v6 = a2;
  memset(&v13, 0, 128);
  uint64_t result = sub_10001D6FC(a1, a2, &v13);
  if (!(_DWORD)result)
  {
    unint64_t v9 = (v6 >> 6) & 0xF;
    while (a3)
    {
      if (v9 >= 0x10)
      {
        uint64_t result = sub_10001D6FC(a1, v6, &v13);
        if ((_DWORD)result) {
          return result;
        }
        unint64_t v9 = (v6 >> 6) & 0xF;
      }

      unint64_t v10 = 64 - (v6 & 0x3F);
      if (a3 < v10) {
        unint64_t v10 = a3;
      }
      unint64_t v11 = (0xFFFFFFFFFFFFFFFFLL >> (-(v6 & 0x3F) - v10)) & (-1LL << v6);
      uint64_t v12 = v13.i64[v9] & v11;
      if (!a4) {
        unint64_t v11 = 0LL;
      }
      a3 -= v10;
      v6 += v10;
      ++v9;
      if (v12 != v11) {
        return 17LL;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_10001DEB0(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 96);
  if (v2 > a2) {
    return 0LL;
  }
  unint64_t v5 = *(void **)(a1 + 88);
  uint64_t v6 = 1LL << -(char)__clz(a2);
  uint64_t v7 = realloc(v5, (unint64_t)(v6 + 7) >> 3);
  if (v7)
  {
    uint64_t v8 = v7;
    int v9 = v6 - 1;
    int v10 = (int)v2 >> 3;
    unsigned int v11 = 0xFFu >> (8 - (v2 & 7));
    if ((int)v2 >> 3 == ((int)v6 - 1) >> 3)
    {
      int v12 = v11 | (510 << (v9 & 7));
    }

    else
    {
      v7[v10] &= v11;
      if (v10 + 1 < v9 >> 3) {
        bzero(&v7[v10 + 1], ((v9 >> 3) - v10 - 2) + 1LL);
      }
      int v12 = 510 << (v9 & 7);
      int v10 = v9 >> 3;
    }

    uint64_t v3 = 0LL;
    v8[v10] &= v12;
    *(void *)(a1 + 88) = v8;
    *(void *)(a1 + 96) = v6;
  }

  else
  {
    free(v5);
    sub_100040B90("failed to allocate memory for bitmap store\n", v13, v14, v15, v16, v17, v18, v19, v21);
    uint64_t v3 = 12LL;
    sub_100044E7C((char *)0x3B2, 12);
  }

  return v3;
}

uint64_t sub_10001DFDC(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }

      else
      {
        unint64_t v8 = a2[1];
        unint64_t v9 = a4[1];
        BOOL v10 = v8 >= v9;
        int v7 = v8 > v9;
        if (!v10) {
          int v7 = -1;
        }
      }
    }

    else
    {
      int v7 = -1;
    }

    uint64_t result = 0LL;
    *a6 = v7;
  }

  return result;
}

uint64_t sub_10001E038(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  if (a4) {
    uint64_t v7 = a4;
  }
  else {
    uint64_t v7 = -1LL;
  }
  uint64_t v14 = a3;
  uint64_t v15 = v7;
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v10 = 16;
  unsigned int v11 = 16;
  uint64_t result = sub_100029B94(a1, a2, &v16);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_100034BB4(v16, 0LL, 0xFFFFFFFFLL, &v14, &v11, 0x10u, &v12, &v10);
    if (!(_DWORD)result)
    {
      uint64_t result = 92LL;
      if (v11 == 16 && v10 == 16)
      {
        if (v14 != a3) {
          return 2LL;
        }
        int v9 = v12;
        if ((v12 & 1) != 0)
        {
          return 2LL;
        }

        else
        {
          uint64_t result = 0LL;
          *(void *)a5 = v13;
          *(_DWORD *)(a5 + 8) = HIDWORD(v12);
          *(_DWORD *)(a5 + 12) = v9;
          *(void *)(a5 + 16) = v15;
        }
      }
    }
  }

  return result;
}

uint64_t sub_10001E10C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int32x2_t *a5)
{
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  v7[0] = a3;
  v7[1] = a4;
  v6[0] = vrev64_s32(a5[1]);
  v6[1] = *a5;
  uint64_t result = sub_100029B94(a1, a2, &v8);
  if (!(_DWORD)result) {
    return sub_1000364F0(v8, 0LL, v7, 16LL, v6, 16LL);
  }
  return result;
}

uint64_t sub_10001E16C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v24 = a3;
  *((void *)&v24 + 1) = a4;
  unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v20 = 16;
  unsigned int v21 = 16;
  uint64_t result = sub_10002996C(a1, a2, &v26);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_100029B94(a1, a2, &v25);
    if (!(_DWORD)result)
    {
      uint64_t result = sub_100034BB4(v25, 0LL, 0LL, &v24, &v21, 0x10u, &v22, &v20);
      if (!(_DWORD)result)
      {
        uint64_t result = 92LL;
        if (v21 == 16 && v20 == 16)
        {
          int v11 = v22;
          if ((v22 & 1) != 0) {
            return 2LL;
          }
          if (a5)
          {
            *(void *)a5 = v23;
            *(_DWORD *)(a5 + 8) = HIDWORD(v22);
            *(_DWORD *)(a5 + 12) = v11;
            *(void *)(a5 + 16) = *((void *)&v24 + 1);
          }

          unint64_t v12 = *(void *)(v26 + 64);
          if (v12) {
            BOOL v13 = v12 >= a4;
          }
          else {
            BOOL v13 = 0;
          }
          int v14 = !v13;
          if (v14 != 1) {
            goto LABEL_22;
          }
          __int128 v19 = v24;
          v18[0] = 0xAAAAAAAAAAAAAAAALL;
          v18[1] = 0xAAAAAAAAAAAAAAAALL;
          uint64_t result = sub_100034BB4(v25, 0LL, 4294967294LL, &v19, &v21, 0x10u, v18, &v20);
          if ((result & 0xFFFFFFFD) == 0)
          {
            int v15 = result;
            uint64_t result = 92LL;
            if (v21 == 16 && v20 == 16)
            {
              if (v15 == 2 || (void)v19 != a3)
              {
                LODWORD(result) = sub_100036AC4(v25, 0LL, (uint64_t)&v24, 16LL);
                BOOL v16 = result == 0;
                goto LABEL_23;
              }

LABEL_23:
              unsigned int v17 = 0;
              goto LABEL_26;
            }
          }
        }
      }
    }
  }

  return result;
}

          IOObjectRelease(v18);
          goto LABEL_24;
        }

        BOOL v13 = 49154LL;
      }

      else
      {
        BOOL v13 = 49231LL;
      }

      uint64_t v18 = parent;
      goto LABEL_23;
    }
  }

  else
  {
    int v15 = sub_10002AC7C(__s);
    if (v15)
    {
      unint64_t v12 = v15;
      BOOL v16 = sub_10002AB74(v15, "AppleAPFSContainer");
      parent = v16;
      if (!v16)
      {
        if (!a5 || (BOOL v16 = sub_10002AD34(v12), (parent = v16) == 0))
        {
          BOOL v13 = 49231LL;
          goto LABEL_24;
        }
      }

      goto LABEL_17;
    }
  }

  return 49154LL;
}

  int v15 = 2 * (v14 == v10[35] - 1);
LABEL_24:
  free(v13);
  return v15;
}

char *sub_10001E358(char *result)
{
  if (result[10]) {
    BOOL v1 = qword_10008C890 == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (v1)
  {
    if (!sub_100034B44( (uint64_t)&xmmword_10008C858,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  8,  21,  0,  0LL,  (uint64_t)sub_10002D39C)) {
      sub_100036C00((uint64_t)&xmmword_10008C858, 0LL, 0);
    }
    uint64_t result = (char *)sub_10001A7FC((uint64_t)&xmmword_10008C858, (uint64_t)"phys extent", (uint64_t)sub_10001E424);
    if ((_DWORD)result)
    {
      sub_100040C68( "failed to register the phys extent tree in the fsck memory storage\n",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9);
      return sub_100044E7C((char *)0x587, 12);
    }
  }

  return result;
}

uint64_t sub_10001E424()
{
  xmmword_100070168 = 0u;
  unk_100070178 = 0u;
  xmmword_100070148 = 0u;
  unk_100070158 = 0u;
  xmmword_100070128 = 0u;
  unk_100070138 = 0u;
  xmmword_100070108 = 0u;
  unk_100070118 = 0u;
  xmmword_1000700E8 = 0u;
  unk_1000700F8 = 0u;
  xmmword_1000700C8 = 0u;
  unk_1000700D8 = 0u;
  xmmword_1000700A8 = 0u;
  unk_1000700B8 = 0u;
  xmmword_100070088 = 0u;
  unk_100070098 = 0u;
  xmmword_100070068 = 0u;
  unk_100070078 = 0u;
  xmmword_100070048 = 0u;
  *(_OWORD *)&qword_100070058 = 0u;
  BYTE8(xmmword_100070068) = 1;
  sub_100036CD8((uint64_t)&xmmword_10008C858, 0LL);
  return sub_100036CD8((uint64_t)&xmmword_10008C898, 0LL);
}

uint64_t sub_10001E48C(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v6 = a4;
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  LOBYTE(v7) = a5;
  return sub_10001E4C4(a1, a2, a3, 1, (void (*)(_BYTE *, uint64_t))sub_10001E82C, (uint64_t)&v6);
}

uint64_t sub_10001E4C4( uint64_t a1, unint64_t a2, uint64_t a3, int a4, void (*a5)(_BYTE *, uint64_t), uint64_t a6)
{
  if (!qword_10008C890) {
    return 0LL;
  }
  unint64_t v10 = a2;
  uint64_t v29 = 0LL;
  memset(v28, 0, sizeof(v28));
  unint64_t v27 = a2;
  memset(v26, 0, sizeof(v26));
  uint64_t result = sub_10001F548((uint64_t *)&v27, v26, 4294967294LL);
  if ((_DWORD)result == 2 && (uint64_t result = sub_10001F548((uint64_t *)&v27, v26, 1LL), (_DWORD)result == 2) && a4)
  {
    unint64_t v27 = -1LL;
  }

  else
  {
    if ((_DWORD)result == 2) {
      return 0LL;
    }
    if ((_DWORD)result)
    {
LABEL_59:
      if ((_DWORD)result == 12)
      {
        xmmword_100070168 = 0u;
        unk_100070178 = 0u;
        xmmword_100070148 = 0u;
        unk_100070158 = 0u;
        xmmword_100070128 = 0u;
        unk_100070138 = 0u;
        xmmword_100070108 = 0u;
        unk_100070118 = 0u;
        xmmword_1000700E8 = 0u;
        unk_1000700F8 = 0u;
        xmmword_1000700C8 = 0u;
        unk_1000700D8 = 0u;
        xmmword_1000700A8 = 0u;
        unk_1000700B8 = 0u;
        xmmword_100070088 = 0u;
        unk_100070098 = 0u;
        xmmword_100070068 = 0u;
        unk_100070078 = 0u;
        xmmword_100070048 = 0u;
        *(_OWORD *)&qword_100070058 = 0u;
        BYTE8(xmmword_100070068) = 1;
        sub_100036CD8((uint64_t)&xmmword_10008C858, 0LL);
        sub_100036CD8((uint64_t)&xmmword_10008C898, 0LL);
        uint64_t result = 0LL;
        *(_BYTE *)(a1 + 10) = 0;
      }

      return result;
    }
  }

  unint64_t v13 = a3 + v10;
  if (a3 + v10 < v10) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v14 = v27;
    if (a4)
    {
      unint64_t v15 = v27 - v10;
      if (v27 > v10)
      {
        uint64_t v16 = v15 & 0xFFFFFFFFFFFFFFFLL | 0x1000000000000000LL;
        *(void *)unint64_t v26 = v16;
        unint64_t v17 = v15 & 0xFFFFFFFFFFFFFFFLL;
        *(_DWORD *)&v26[16] = 0;
        unint64_t v27 = v10;
        uint64_t v14 = v10;
LABEL_17:
        BOOL v20 = v13 <= v14 || v13 - v14 >= v17;
        uint64_t v19 = v13;
        if (v20) {
          goto LABEL_25;
        }
        goto LABEL_21;
      }
    }

    uint64_t v16 = *(void *)v26;
    unint64_t v17 = *(void *)v26 & 0xFFFFFFFFFFFFFFFLL;
    BOOL v18 = v10 <= v27 || v10 - v27 >= v17;
    uint64_t v19 = v10;
    if (v18) {
      goto LABEL_17;
    }
LABEL_21:
    uint64_t v31 = v19;
    v30[1] = *(void *)&v26[8];
    *(void *)((char *)&v30[1] + 5) = *(void *)&v26[13];
    uint64_t v21 = (v14 + v16 - v19) & 0xFFFFFFFFFFFFFFFLL;
    v30[0] = v16 & 0xF000000000000000LL | v21;
    *(void *)unint64_t v26 = (v17 - v21) | v16 & 0xF000000000000000LL;
    if (*(_DWORD *)&v26[16])
    {
      uint64_t result = sub_10001F658(&xmmword_10008C858, (uint64_t *)&v27, v26);
      if ((_DWORD)result) {
        goto LABEL_59;
      }
      uint64_t result = sub_10001F658(&xmmword_10008C858, &v31, v30);
      if ((_DWORD)result) {
        goto LABEL_59;
      }
      uint64_t v14 = v27;
    }

uint64_t sub_10001E82C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = *(void *)a2;
  ++*(_DWORD *)(result + 16);
  if (!*(_BYTE *)(result + 20)) {
    *(_BYTE *)(result + 20) = *(_BYTE *)(a2 + 8);
  }
  return result;
}

uint64_t sub_10001E858(uint64_t a1, unint64_t a2, uint64_t a3)
{
  return sub_10001E4C4(a1, a2, a3, 0, (void (*)(_BYTE *, uint64_t))sub_10001E86C, 0LL);
}

uint64_t sub_10001E86C(uint64_t result)
{
  *(_BYTE *)(result + 20) = 1;
  return result;
}

uint64_t sub_10001E878(uint64_t a1, unint64_t a2, uint64_t a3)
{
  return sub_10001E4C4(a1, a2, a3, 0, (void (*)(_BYTE *, uint64_t))sub_10001E88C, 0LL);
}

uint64_t sub_10001E88C(uint64_t result)
{
  return result;
}

uint64_t sub_10001E89C(uint64_t a1)
{
  uint64_t v2 = sub_10001E958(a1 + 48, (uint64_t)&xmmword_10008C858);
  if ((_DWORD)v2 || (uint64_t v2 = sub_10001E958(a1 + 168, (uint64_t)&xmmword_10008C898), (_DWORD)v2))
  {
    char v3 = strerror(v2);
    sub_100040B90("unable to init physical extent tree iterator for repairs: %s\n", v4, v5, v6, v7, v8, v9, v10, v3);
    sub_100044E7C((char *)0x461, v2);
    return v2;
  }

  else
  {
    *(void *)(a1 + 8) = sub_10001EA18;
    *(void *)(a1 + --*(_DWORD *)(result + 16) = a1 + 288;
    *(void *)(a1 + 24) = a1 + 296;
    *(void *)(a1 + 32) = 0x1500000008LL;
    *(_BYTE *)(a1 + 317) = 1;
    return sub_10001EA18(a1);
  }

uint64_t sub_10001E958(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 56))
  {
    uint64_t v4 = 0LL;
    goto LABEL_5;
  }

  uint64_t v3 = sub_100035394(a1, a2, 0LL, (void *)(a1 + 72), 8u, 8u, (void *)(a1 + 80), 21);
  if ((_DWORD)v3)
  {
    uint64_t v4 = v3;
    char v5 = strerror(v3);
    sub_100040B90("unable to init physical extent tree iterator for repairs: %s\n", v6, v7, v8, v9, v10, v11, v12, v5);
    sub_100044E7C((char *)0x460, v4);
LABEL_5:
    *(_BYTE *)(a1 + 40) = 1;
    goto LABEL_6;
  }

  if (a1 && !*(_BYTE *)(a1 + 40))
  {
    uint64_t v4 = 0LL;
    uint64_t v15 = *(void *)(a1 + 80);
    *(void *)(a1 + 104) = *(void *)(a1 + 72);
    uint64_t v13 = v15 & 0xFFFFFFFFFFFFFFFLL;
    goto LABEL_7;
  }

  uint64_t v4 = 0LL;
LABEL_6:
  uint64_t v13 = 0LL;
  *(void *)(a1 + 104) = -1LL;
LABEL_7:
  *(void *)(a1 + 112) = v13;
  return v4;
}

uint64_t sub_10001EA18(uint64_t a1)
{
  uint64_t result = sub_10001F6E0(a1 + 48);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10001F6E0(a1 + 168);
    if (!(_DWORD)result)
    {
      if (*(_BYTE *)(a1 + 208))
      {
        int v3 = *(unsigned __int8 *)(a1 + 88);
        *(_BYTE *)(a1 + 40) = v3;
        if (v3) {
          return 0LL;
        }
        uint64_t v5 = 0LL;
        uint64_t v4 = *(void *)(a1 + 72);
      }

      else
      {
        *(_BYTE *)(a1 + 40) = 0;
        if (*(_BYTE *)(a1 + 88)) {
          uint64_t v4 = 0LL;
        }
        else {
          uint64_t v4 = *(void *)(a1 + 72);
        }
        uint64_t v5 = *(void *)(a1 + 192);
      }

      uint64_t v7 = *(void **)(a1 + 16);
      uint64_t v6 = *(void *)(a1 + 24);
      unint64_t v8 = *(void *)(a1 + 152);
      unint64_t v9 = *(void *)(a1 + 272);
      unint64_t v10 = v8 - v9;
      if (v8 >= v9) {
        uint64_t v11 = *(void *)(a1 + 272);
      }
      else {
        uint64_t v11 = *(void *)(a1 + 152);
      }
      if (v8 >= v9)
      {
        if (v8 <= v9)
        {
          unint64_t v16 = *(void *)(a1 + 160);
          unint64_t v17 = *(void *)(a1 + 280);
          if (v16 >= v17) {
            unint64_t v10 = *(void *)(a1 + 280);
          }
          else {
            unint64_t v10 = *(void *)(a1 + 160);
          }
          *(void *)(a1 + 152) = v10 + v8;
          *(void *)(a1 + 160) = v16 - v10;
          *(void *)(a1 + 272) = v10 + v9;
          *(void *)(a1 + 280) = v17 - v10;
          *(void *)(v6 + 8) = -1LL;
          int v13 = *(_DWORD *)(v4 + 16) - *(_DWORD *)(v5 + 16);
          uint64_t v14 = 0x2000000000000000LL;
        }

        else
        {
          unint64_t v15 = *(void *)(a1 + 280);
          if (v15 < v10) {
            unint64_t v10 = *(void *)(a1 + 280);
          }
          *(void *)(a1 + 272) = v10 + v9;
          *(void *)(a1 + 280) = v15 - v10;
          *(void *)(v6 + 8) = -1LL;
          int v13 = -*(_DWORD *)(v5 + 16);
          uint64_t v14 = 0x2000000000000000LL;
          uint64_t v4 = v5;
        }
      }

      else
      {
        unint64_t v12 = *(void *)(a1 + 160);
        unint64_t v10 = v9 - v8;
        if (v12 < v9 - v8) {
          unint64_t v10 = *(void *)(a1 + 160);
        }
        *(void *)(a1 + 152) = v10 + v8;
        *(void *)(a1 + 160) = v12 - v10;
        *(void *)(v6 + 8) = *(void *)(v4 + 8);
        int v13 = *(_DWORD *)(v4 + 16);
        uint64_t v14 = 0x1000000000000000LL;
      }

      uint64_t result = 0LL;
      *(_DWORD *)(v6 + --*(_DWORD *)(result + 16) = v13;
      *(_BYTE *)(v6 + 20) = *(_BYTE *)(v4 + 20);
      *uint64_t v7 = v11;
      *(void *)uint64_t v6 = v10 & 0xFFFFFFFFFFFFFFFLL | v14;
    }
  }

  return result;
}

uint64_t sub_10001EB70(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, int a5)
{
  if (a5 == 1)
  {
    if (a2) {
      unint64_t v5 = *(void *)(*(void *)(a2 + 40) + 8LL);
    }
    else {
      unint64_t v5 = 0LL;
    }
    return sub_10003D570(result, a3, a4, v5, 0x40000000, a3, *(void *)(a2 + 56), 0, 0xFu, 2u);
  }

  return result;
}

uint64_t sub_10001EBD0( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a5;
  unint64_t v11 = *a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v12 = *(void *)a4;
  unint64_t v13 = *(void *)a4 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v14 = *(void *)a4 >> 60;
  if (!qword_10008C890 || *(_BYTE *)(a2 + 14))
  {
    if ((a5 & 3) != 0) {
      return 92LL;
    }
    sub_10001EB70(a1, a2, *a3 & 0xFFFFFFFFFFFFFFFLL, *(void *)a4 & 0xFFFFFFFFFFFFFFFLL, v14);
    return 0LL;
  }

  if (byte_100070185)
  {
    uint64_t v68 = *(void *)a4 >> 60;
    char v17 = a5;
    uint64_t v66 = a1;
    uint64_t v70 = a3;
    BOOL v18 = qword_100070060;
    uint64_t v67 = (unint64_t *)qword_100070058;
    unint64_t v19 = *(void *)qword_100070058;
    unint64_t v20 = *qword_100070060 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v21 = *qword_100070060 >> 60;
  }

  else
  {
    uint64_t v15 = sub_10001E89C((uint64_t)&xmmword_100070048);
    if ((_DWORD)v15) {
      return v15;
    }
    LODWORD(v68) = v14;
    char v17 = v8;
    uint64_t v66 = a1;
    uint64_t v70 = a3;
    BOOL v18 = qword_100070060;
    uint64_t v67 = (unint64_t *)qword_100070058;
    unint64_t v19 = *(void *)qword_100070058;
    unint64_t v20 = *qword_100070060 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v21 = *qword_100070060 >> 60;
    if (!BYTE8(xmmword_100070068)) {
      sub_10001EB70(v66, a2, v19, v20, v21);
    }
  }

  unint64_t v74 = 0LL;
  unint64_t v75 = 0LL;
  int v76 = 0;
  if ((v17 & 1) != 0) {
    return sub_10001F270((_DWORD *)(a2 + 704), v70, 0LL, *(void *)(a2 + 56), 0, 0);
  }
  unsigned __int8 v72 = v21;
  if (!v13)
  {
LABEL_113:
    uint64_t v15 = 0LL;
    goto LABEL_114;
  }

  uint64_t v73 = 0LL;
  uint64_t v69 = (_DWORD *)(a2 + 704);
  unint64_t v22 = &off_100070000;
  unint64_t v65 = v12 & 0xF000000000000000LL;
  do
  {
    while (1)
    {
      if (*((_BYTE *)v22 + 112)) {
        unint64_t v19 = -1LL;
      }
      unint64_t v23 = v19 >= v11 ? v11 : v19;
      if (*((_BYTE *)v18 + 20))
      {
        uint64_t v24 = *(void *)(a2 + 56);
        if (v19 < v11)
        {
          if (v20 >= v11 - v19) {
            unint64_t v25 = v11 - v19;
          }
          else {
            unint64_t v25 = v20;
          }
          v19 += v25;
          v20 -= v25;
          if (v24) {
            goto LABEL_89;
          }
          goto LABEL_28;
        }

        if (v11 < v19)
        {
          if (v13 >= v19 - v11) {
            unint64_t v25 = v19 - v11;
          }
          else {
            unint64_t v25 = v13;
          }
          v11 += v25;
          v13 -= v25;
          if (v24) {
            goto LABEL_89;
          }
          goto LABEL_43;
        }

        if (v13 >= v20) {
          unint64_t v25 = v20;
        }
        else {
          unint64_t v25 = v13;
        }
        v19 += v25;
        v20 -= v25;
        v11 += v25;
        v13 -= v25;
        if (v24)
        {
LABEL_57:
          int v37 = -1;
          goto LABEL_65;
        }
      }

      else
      {
        if (v19 < v11)
        {
          if (v20 >= v11 - v19) {
            unint64_t v25 = v11 - v19;
          }
          else {
            unint64_t v25 = v20;
          }
          v19 += v25;
          v20 -= v25;
LABEL_28:
          if (!*((_DWORD *)v18 + 4)) {
            goto LABEL_89;
          }
          sub_100044E7C((char *)0x462, 92);
          int v26 = *((_DWORD *)v18 + 4);
          HIDWORD(v73) |= v26 > 0;
          unint64_t v27 = (void (*)(const char *, ...))sub_100040C68;
          if ((v73 & 0x100000000LL) != 0) {
            unint64_t v27 = (void (*)(const char *, ...))sub_100040B90;
          }
          v27( "mismatch between extentref entry reference count (0) and calculated fsroot entry reference count (%d) for ex tent (%llu + %llu)\n",  v26,  v23,  v25);
          goto LABEL_79;
        }

        if (v11 < v19)
        {
          if (v13 >= v19 - v11) {
            unint64_t v25 = v19 - v11;
          }
          else {
            unint64_t v25 = v13;
          }
          v11 += v25;
          v13 -= v25;
LABEL_43:
          sub_100044E7C((char *)0x463, 92);
          int v35 = *(_DWORD *)(a4 + 16);
          if (v35)
          {
            HIDWORD(v73) |= v35 < 0;
            uint64_t v36 = (void (*)(const char *, ...))sub_100040C68;
            if ((v73 & 0x100000000LL) != 0) {
              uint64_t v36 = (void (*)(const char *, ...))sub_100040B90;
            }
            v36( "mismatch between extentref entry reference count (%d) and calculated fsroot entry reference count (0) for extent (%llu + %llu)\n",  v35,  v23,  v25);
          }

          else
          {
            sub_100040C68( "invalid extent (%llu + %llu) with reference count (0)\n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v23);
          }

LABEL_74:
          int v37 = 0;
          goto LABEL_80;
        }

        unint64_t v25 = v13 >= v20 ? v20 : v13;
        v19 += v25;
        v20 -= v25;
        v11 += v25;
        v13 -= v25;
      }

      if (*((_DWORD *)v18 + 4) == *(_DWORD *)(a4 + 16)) {
        goto LABEL_57;
      }
      sub_100044E7C((char *)0x464, 92);
      int v45 = *(_DWORD *)(a4 + 16);
      if ((v73 & 0x100000000LL) != 0 || v45 < *((_DWORD *)v18 + 4))
      {
        HIDWORD(v73) = 1;
        uint64_t v46 = sub_100040B90;
      }

      else
      {
        HIDWORD(v73) = 0;
        uint64_t v46 = sub_100040C68;
      }

      v46( "mismatch between extentref entry reference count (%d) and calculated fsroot entry reference count (%d) for exten t (%llu + %llu)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45);
      if (!*((_DWORD *)v18 + 4)) {
        goto LABEL_74;
      }
      int v37 = 2;
LABEL_65:
      if (v72 != (_DWORD)v68)
      {
        if ((v17 & 2) == 0) {
          sub_100044E7C((char *)0x465, 92);
        }
        sub_100040B90( "invalid kind (expected %u, actual %u) for extent (%llu + %llu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  v72);
        int v37 = 2;
        HIDWORD(v73) = 1;
      }

      if ((v17 & 4) != 0)
      {
LABEL_78:
        HIDWORD(v73) = 1;
LABEL_79:
        int v37 = 2;
        goto LABEL_80;
      }

      if (v72 == 1)
      {
        unint64_t v47 = *(void *)(a4 + 8);
        HIDWORD(v73) |= v47 > 0xFFFFFFFFFFFFFFFDLL;
        if (v47 > 0xFFFFFFFFFFFFFFFDLL) {
          int v37 = 2;
        }
      }

      else if (v72 == 2 && *(void *)(a4 + 8) != -1LL)
      {
        goto LABEL_78;
      }

      if (v37 == -1)
      {
LABEL_82:
        unint64_t v22 = &off_100070000;
        goto LABEL_89;
      }

LABEL_81:
        LOBYTE(v73) = 1;
        if (v37 != 2) {
          goto LABEL_82;
        }
        goto LABEL_85;
      }

uint64_t sub_10001F270(_DWORD *a1, uint64_t *a2, _BYTE *a3, uint64_t a4, int a5, char a6)
{
  uint64_t v6 = *a2;
  *(void *)&__int128 v19 = a4;
  *((void *)&v19 + 1) = v6;
  if (a3) {
    unsigned int v7 = 20;
  }
  else {
    unsigned int v7 = 0;
  }
  uint64_t v8 = sub_1000251C0(a1, 6u, a5, 0, a6, &v19, 0x10u, a3, v7);
  uint64_t v9 = v8;
  if ((_DWORD)v8)
  {
    char v10 = BYTE8(v19);
    strerror(v8);
    sub_100040B90("could not cache physical extent repair at %llu error: %s\n", v11, v12, v13, v14, v15, v16, v17, v10);
    sub_100044E7C((char *)0x336, v9);
  }

  return v9;
}

uint64_t sub_10001F304(uint64_t a1, uint64_t a2)
{
  if (!qword_10008C890) {
    return 0LL;
  }
  int v3 = (_DWORD *)(a1 + 704);
  while (!BYTE8(xmmword_100070068))
  {
    unint64_t v5 = (void *)qword_100070058;
    uint64_t v4 = (__int128 *)unk_100070060;
    if ((!*(_BYTE *)(unk_100070060 + 20LL) || !*(void *)(a1 + 56)) && *(_DWORD *)(unk_100070060 + 16LL))
    {
      sub_100044E7C((char *)0x47D, 92);
      int v6 = *((_DWORD *)v4 + 4);
      char v7 = v6 > 0;
      uint64_t v8 = (void (*)(const char *, ...))sub_100040C68;
      if (v6 > 0) {
        uint64_t v8 = (void (*)(const char *, ...))sub_100040B90;
      }
      v8( "mismatch between extentref entry reference count (0) and calculated fsroot entry reference count (%d) for extent (%llu + %llu)\n",  v6,  *v5,  *(void *)v4 & 0xFFFFFFFFFFFFFFFLL);
      uint64_t v33 = *v5 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000LL;
      int v32 = -1431655766;
      *(void *)&__int128 v31 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v9 = *v4;
      int v32 = *((_DWORD *)v4 + 4);
      __int128 v31 = v9;
      uint64_t v10 = sub_10001F270(v3, &v33, &v31, *(void *)(a1 + 56), 2, v7);
      if ((_DWORD)v10) {
        return v10;
      }
    }

    uint64_t v11 = (*((uint64_t (**)(__int128 *))&xmmword_100070048 + 1))(&xmmword_100070048);
    if ((_DWORD)v11)
    {
      uint64_t v12 = v11;
      char v13 = strerror(v11);
      sub_100040B90("error iterating physical extent tree: %s\n", v14, v15, v16, v17, v18, v19, v20, v13);
      sub_100044E7C((char *)0x47E, v12);
      return v12;
    }
  }

  xmmword_100070168 = 0u;
  unk_100070178 = 0u;
  xmmword_100070148 = 0u;
  unk_100070158 = 0u;
  xmmword_100070128 = 0u;
  unk_100070138 = 0u;
  xmmword_100070108 = 0u;
  unk_100070118 = 0u;
  xmmword_1000700E8 = 0u;
  unk_1000700F8 = 0u;
  xmmword_1000700C8 = 0u;
  unk_1000700D8 = 0u;
  xmmword_1000700A8 = 0u;
  unk_1000700B8 = 0u;
  xmmword_100070088 = 0u;
  unk_100070098 = 0u;
  xmmword_100070068 = 0u;
  unk_100070078 = 0u;
  xmmword_100070048 = 0u;
  *(_OWORD *)&qword_100070058 = 0u;
  BYTE8(xmmword_100070068) = 1;
  if (!a2)
  {
    sub_100036CD8((uint64_t)&xmmword_10008C858, 0LL);
    sub_100036CD8((uint64_t)&xmmword_10008C898, 0LL);
    return 0LL;
  }

  sub_100036CD8((uint64_t)&xmmword_10008C898, 0LL);
  xmmword_10008C898 = xmmword_10008C858;
  unk_10008C8A8 = unk_10008C868;
  xmmword_10008C8B8 = xmmword_10008C878;
  unk_10008C8C8 = unk_10008C888;
  if (sub_10001A7FC((uint64_t)&xmmword_10008C898, (uint64_t)"prev phys extent", (uint64_t)sub_10001E424))
  {
    sub_100040C68( "failed to register the prev phys extent tree in the fsck memory storage\n",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v29);
    sub_100044E7C((char *)0x588, 12);
  }

  uint64_t v12 = 0LL;
  xmmword_10008C878 = 0u;
  unk_10008C888 = 0u;
  xmmword_10008C858 = 0u;
  unk_10008C868 = 0u;
  return v12;
}

uint64_t sub_10001F548(uint64_t *a1, void *a2, uint64_t a3)
{
  if (!qword_10008C890) {
    return 2LL;
  }
  unsigned int v16 = 8;
  unsigned int v15 = 21;
  uint64_t v4 = sub_100034BB4((uint64_t)&xmmword_10008C858, 0LL, a3, a1, &v16, 8u, a2, &v15);
  uint64_t v5 = v4;
  if ((v4 & 0xFFFFFFFD) != 0)
  {
    uint64_t v6 = *a1;
    strerror(v4);
    sub_100040B90( "could not lookup extent at %llu for physical extent repair: %s\n",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v6);
    sub_100044E7C((char *)0x335, v5);
  }

  return v5;
}

BOOL sub_10001F5EC(uint64_t a1, uint64_t *a2)
{
  int v3 = sub_100036AC4(a1, 0LL, (uint64_t)a2, 8LL);
  BOOL v4 = v3 != 0;
  if (v3)
  {
    uint64_t v5 = *a2;
    strerror(v3 != 0);
    sub_100040B90("could not remove extent at %llu for physical extent repair: %s\n", v6, v7, v8, v9, v10, v11, v12, v5);
    sub_100044E7C((char *)0x2B1, v4);
  }

  return v4;
}

uint64_t sub_10001F658(_DWORD *a1, uint64_t *a2, const void *a3)
{
  uint64_t v4 = sub_1000364F0(a1, 0LL, a2, 8LL, a3, 21LL);
  uint64_t v5 = v4;
  if ((_DWORD)v4)
  {
    uint64_t v6 = *a2;
    strerror(v4);
    sub_100040B90( "could not insert extent with range (%llu + %llu) for physical extent repair: %s\n",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v6);
    sub_100044E7C((char *)0x34F, v5);
  }

  return v5;
}

uint64_t sub_10001F6E0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(_BYTE *)(result + 40) || *(void *)(result + 112))
    {
      return 0LL;
    }

    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(result + 8))(result);
      if (!(_DWORD)result)
      {
        if (*(_BYTE *)(v1 + 40))
        {
          uint64_t v2 = 0LL;
          uint64_t v3 = -1LL;
        }

        else
        {
          uint64_t v3 = *(void *)(v1 + 72);
          uint64_t v2 = *(void *)(v1 + 80) & 0xFFFFFFFFFFFFFFFLL;
        }

        uint64_t result = 0LL;
        *(void *)(v1 + 104) = v3;
        *(void *)(v1 + 112) = v2;
      }
    }
  }

  return result;
}

uint64_t sub_10001F74C( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[1];
  size_t v10 = *(void *)(v9 + 1400);
  if (v10)
  {
    uint64_t result = sub_10001F838(a1, 0x6D6B6579uLL, *(void *)(v9 + 1392), v10, (unsigned __int8 *)(v9 + 72), a6, a7, a8);
    if ((_DWORD)result) {
      return result;
    }
    uint64_t v9 = a1[1];
  }

  size_t v12 = *(void *)(v9 + 1304);
  if (!v12 || *(_BYTE *)(qword_10008DB78 + 43)) {
    goto LABEL_6;
  }
  uint64_t result = sub_10001F838(a1, 0x6B657973uLL, *(void *)(v9 + 1296), v12, (unsigned __int8 *)(v9 + 72), a6, a7, a8);
  if (!(_DWORD)result)
  {
    uint64_t v9 = a1[1];
LABEL_6:
    sub_10003D570( (uint64_t)a1,  *(void *)(v9 + 1392),  *(void *)(v9 + 1400),  0LL,  0x40000000,  *(void *)(v9 + 1392),  0LL,  0,  1u,  1u);
    sub_10003D570( (uint64_t)a1,  *(void *)(a1[1] + 1296),  *(void *)(a1[1] + 1304),  0LL,  0x40000000,  *(void *)(a1[1] + 1296),  0LL,  0,  1u,  1u);
    return 0LL;
  }

  return result;
}

uint64_t sub_10001F838( uint64_t *a1, size_t a2, uint64_t a3, size_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  uint64_t v127 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = sub_10002070C(a1, a2, a3, a4, a5, &v127, a7, a8);
  if ((_DWORD)v13) {
    return v13;
  }
  unsigned int v16 = v127;
  uint64_t v17 = sub_10002E32C((uint64_t)v127, 12, *(void *)(a1[1] + 16), v11, 0, *(_DWORD *)(a1[1] + 36) * (int)a4, v14, v15);
  if ((_DWORD)v17)
  {
    uint64_t v13 = v17;
    if (v11 == 1835754873)
    {
      char v29 = "media";
    }

    else
    {
      if (v11 == 1919247219)
      {
        sub_100040C68( "%s keybag (%llu+%llu): block range isn't a valid keybag, skipping checks\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)"volume");
LABEL_34:
        uint64_t v13 = 0LL;
        goto LABEL_55;
      }

      char v29 = "unknown";
      if (v11 == 1801812339) {
        char v29 = "container";
      }
    }

    sub_100040B90( "%s keybag (%llu+%llu): block range isn't a valid keybag, aborting\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v29);
    goto LABEL_55;
  }

  uint64_t v27 = (char *)(v16 + 16);
  if (v16[16] != 2)
  {
    if (!v16[16])
    {
      if (v11 == 1835754873)
      {
        uint64_t v28 = "media";
      }

      else if (v11 == 1919247219)
      {
        uint64_t v28 = "volume";
      }

      else
      {
        uint64_t v28 = "unknown";
        if (v11 == 1801812339) {
          uint64_t v28 = "container";
        }
      }

      sub_100040B90("%s keybag (%llu+%llu): version cannot be 0\n", v18, v19, v20, v21, v22, v23, v24, (char)v28);
      uint64_t v13 = 92LL;
      uint64_t v35 = 1061LL;
      goto LABEL_54;
    }

    if (v11 == 1835754873)
    {
      int v32 = "media";
    }

    else if (v11 == 1919247219)
    {
      int v32 = "volume";
    }

    else
    {
      int v32 = "unknown";
      if (v11 == 1801812339) {
        int v32 = "container";
      }
    }

    sub_100040C68( "%s keybag (%llu+%llu): unknown version %u\n, skipping checks\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v32);
    sub_100044E7C((char *)0x426, -6);
    goto LABEL_34;
  }

  unsigned int v30 = *(_DWORD *)(a1[1] + 36) * a4;
  if (v30 / 0x18 < (unsigned __int16)v16[17])
  {
    if (v11 == 1835754873)
    {
      __int128 v31 = "media";
    }

    else if (v11 == 1919247219)
    {
      __int128 v31 = "volume";
    }

    else
    {
      __int128 v31 = "unknown";
      if (v11 == 1801812339) {
        __int128 v31 = "container";
      }
    }

    sub_100040B90( "%s keybag (%llu+%llu): number of entries %u exceeds object capacity %lu\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v31);
    uint64_t v13 = 92LL;
    uint64_t v35 = 1063LL;
    goto LABEL_54;
  }

  unsigned int v33 = *((_DWORD *)v16 + 9);
  if (v33 > v30)
  {
    if (v11 == 1835754873)
    {
      uint64_t v34 = "media";
    }

    else if (v11 == 1919247219)
    {
      uint64_t v34 = "volume";
    }

    else
    {
      uint64_t v34 = "unknown";
      if (v11 == 1801812339) {
        uint64_t v34 = "container";
      }
    }

    sub_100040B90( "%s keybag (%llu+%llu): number of bytes %u exceeds object size %u\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v34);
    uint64_t v13 = 92LL;
    uint64_t v35 = 1064LL;
    goto LABEL_54;
  }

  if (*((_BYTE *)v16 + 40)
    || *((_BYTE *)v16 + 41)
    || *((_BYTE *)v16 + 42)
    || *((_BYTE *)v16 + 43)
    || *((_BYTE *)v16 + 44)
    || *((_BYTE *)v16 + 45)
    || *((_BYTE *)v16 + 46)
    || *((_BYTE *)v16 + 47))
  {
    if (v11 == 1835754873)
    {
      uint64_t v36 = "media";
    }

    else if (v11 == 1919247219)
    {
      uint64_t v36 = "volume";
    }

    else
    {
      uint64_t v36 = "unknown";
      if (v11 == 1801812339) {
        uint64_t v36 = "container";
      }
    }

    sub_100040C68("%s keybag (%llu+%llu): invalid padding\n", v18, v19, v20, v21, v22, v23, v24, (char)v36);
    sub_100044E7C((char *)0x429, -10);
    unsigned int v33 = *((_DWORD *)v16 + 9);
  }

  uint64_t v38 = (char *)(v16 + 24);
  unint64_t v39 = (unint64_t)&v27[v33];
  if ((unint64_t)(v16 + 24) >= v39)
  {
    LOBYTE(v122) = 0;
    int v121 = 0;
    LODWORD(v42) = 16;
LABEL_130:
    if (v121 == (unsigned __int16)v16[17])
    {
      if (*((_DWORD *)v16 + 9) == (_DWORD)v42)
      {
        if (!(_BYTE)v122) {
          goto LABEL_34;
        }
LABEL_158:
        uint64_t v80 = sub_100020970(a1, v11, a3, a4, a5, (uint64_t)v127, v25, v26);
LABEL_159:
        uint64_t v13 = v80;
        goto LABEL_55;
      }
    }

    else
    {
      if (v11 == 1835754873)
      {
        int v91 = v42;
        char v92 = "media";
      }

      else
      {
        int v91 = v42;
        if (v11 == 1919247219)
        {
          char v92 = "volume";
        }

        else
        {
          char v92 = "unknown";
          if (v11 == 1801812339) {
            char v92 = "container";
          }
        }
      }

      sub_100040B90( "%s keybag (%llu+%llu): number of keys %u does not match number of entries found %u\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v92);
      uint64_t v13 = 92LL;
      sub_100044E7C((char *)0x444, 92);
      if (!sub_1000428C4( qword_10008DB70,  "Fix the number of keys? ",  v96,  v97,  v98,  v99,  v100,  v101,  v113)) {
        goto LABEL_55;
      }
      v16[17] = v121;
      LODWORD(v42) = v91;
      if (*((_DWORD *)v16 + 9) == v91) {
        goto LABEL_158;
      }
    }

    if (v11 == 1835754873)
    {
      uint64_t v102 = "media";
    }

    else if (v11 == 1919247219)
    {
      uint64_t v102 = "volume";
    }

    else
    {
      uint64_t v102 = "unknown";
      if (v11 == 1801812339) {
        uint64_t v102 = "container";
      }
    }

    int v103 = v42;
    sub_100040B90( "%s keybag (%llu+%llu): number of bytes %u does not match sum of all entries %u\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v102);
    uint64_t v13 = 92LL;
    sub_100044E7C((char *)0x432, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Fix the number of bytes? ",  v104,  v105,  v106,  v107,  v108,  v109,  v114)) {
      goto LABEL_55;
    }
    *((_DWORD *)v16 + 9) = v103;
    goto LABEL_158;
  }

  int v40 = 0;
  int v121 = 0;
  int v122 = 0;
  uint64_t v41 = "unknown";
  if (v11 == 1801812339) {
    uint64_t v41 = "container";
  }
  char v119 = (char)v41;
  uint64_t v42 = 16LL;
  uint64_t v116 = (char *)(v16 + 16);
  unsigned int v117 = v30;
  __int16 v115 = v16;
  while (1)
  {
    uint64_t v43 = *((unsigned __int16 *)v38 + 9);
    unsigned int v44 = v43 + 24;
    if (((v43 + 24) & 0xF) != 0) {
      unsigned int v44 = v43 - ((v43 + 24) & 0xF) + 40;
    }
    unsigned int v126 = v44;
    unint64_t v123 = v39;
    unsigned int v124 = v39 - (_DWORD)v38;
    if (v44 > (int)v39 - (int)v38)
    {
      uint64_t v45 = v42;
      if (v11 == 1835754873)
      {
        uint64_t v46 = "media";
      }

      else
      {
        LOBYTE(v46) = v119;
        if (v11 == 1919247219) {
          uint64_t v46 = "volume";
        }
      }

      sub_100040B90( "%s keybag (%llu+%llu): entry %u has size %u > remaining size %u (keybag size %u)\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v46);
      sub_100044E7C((char *)0x4EE, -11);
      LODWORD(v43) = *((unsigned __int16 *)v38 + 9);
      uint64_t v42 = v45;
      uint64_t v27 = v116;
    }

    if (v42 + v126 > v30)
    {
      if (v11 == 1835754873)
      {
        uint64_t v95 = "media";
      }

      else
      {
        LOBYTE(v95) = v119;
        if (v11 == 1919247219) {
          uint64_t v95 = "volume";
        }
      }

      sub_100040B90( "%s keybag (%llu+%llu): entry %u with size %u brings total size %u beyond object size %u\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v95);
      uint64_t v13 = 92LL;
      uint64_t v35 = 1067LL;
      goto LABEL_54;
    }

    uint64_t v120 = v42 + v126;
    uint64_t v118 = v42;
    if (uuid_is_null((const unsigned __int8 *)v38))
    {
      char v47 = v119;
      if (v11 == 1835754873)
      {
        uint64_t v48 = "media";
      }

      else
      {
        LOBYTE(v48) = v119;
        if (v11 == 1919247219) {
          uint64_t v48 = "volume";
        }
      }

      sub_100040C68("%s keybag (%llu+%llu): UUID of entry %u is null\n", v18, v19, v20, v21, v22, v23, v24, (char)v48);
      sub_100044E7C((char *)0x42C, -2);
      int v55 = sub_1000428C4(qword_10008DB70, "Remove entry with null UUID? ", v49, v50, v51, v52, v53, v54, v111);
      BOOL v125 = v55 != 0;
      int v56 = v122;
      if (v55) {
        int v56 = 1;
      }
      int v122 = v56;
    }

    else
    {
      BOOL v125 = 0;
      char v47 = v119;
    }

    if (v11 == 1835754873
      && !uuid_is_null((const unsigned __int8 *)v38)
      && uuid_compare((const unsigned __int8 *)v38, (const unsigned __int8 *)(a1[1] + 72)))
    {
      *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&__int128 v57 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v57 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)uuid_string_t out = v57;
      *(_OWORD *)&out[16] = v57;
      *(void *)&v128[29] = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)uuid_string_t v128 = v57;
      *(_OWORD *)&v128[16] = v57;
      uuid_unparse((const unsigned __int8 *)v38, out);
      uuid_unparse((const unsigned __int8 *)(a1[1] + 72), v128);
      sub_100040C68( "%s keybag (%llu+%llu): UUID %s of entry %u (tag %u) is not the container UUID %s\n",  v58,  v59,  v60,  v61,  v62,  v63,  v64,  (char)"media");
      sub_100044E7C((char *)0x42D, -2);
    }

    if (!*((_WORD *)v38 + 8))
    {
      if (v11 == 1835754873)
      {
        unint64_t v65 = "media";
      }

      else
      {
        LOBYTE(v65) = v47;
        if (v11 == 1919247219) {
          unint64_t v65 = "volume";
        }
      }

      sub_100040C68( "%s keybag (%llu+%llu): entry %u has 'unknown' tag type\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v65);
      sub_100044E7C((char *)0x42E, -5);
    }

    if (v38[20] || v38[21] || v38[22] || v38[23])
    {
      if (v11 == 1835754873)
      {
        uint64_t v66 = "media";
      }

      else
      {
        LOBYTE(v66) = v47;
        if (v11 == 1919247219) {
          uint64_t v66 = "volume";
        }
      }

      sub_100040C68( "%s keybag (%llu+%llu): entry %u has invalid padding\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v66);
      sub_100044E7C((char *)0x42F, -10);
    }

    if (v11 == 1801812339 && *((_WORD *)v38 + 8) == 3)
    {
      if (*((_WORD *)v38 + 9) != 16)
      {
        sub_100040B90( "%s keybag (%llu+%llu): unlock records entry %u does not contain a range (size %u)\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)"container");
        uint64_t v13 = 92LL;
        uint64_t v35 = 1072LL;
        goto LABEL_54;
      }

      if (!sub_10000DDF4((uint64_t)a1, *((void *)v38 + 3), *((void *)v38 + 4)))
      {
        sub_100040B90( "%s keybag (%llu+%llu): unlock records entry %u contains invalid range %llu+%llu\n",  v67,  v68,  v69,  v70,  v71,  v72,  v73,  (char)"container");
        sub_100044E7C((char *)0x431, 92);
        if (!v125)
        {
          if (!sub_1000428C4( qword_10008DB70,  "Remove entry with invalid range? ",  v74,  v75,  v76,  v77,  v78,  v79,  v112))
          {
            uint64_t v13 = 92LL;
            goto LABEL_55;
          }

          int v122 = 1;
        }

        BOOL v125 = 1;
      }

      uint64_t v80 = sub_10001F838(a1, 1919247219LL, *((void *)v38 + 3), *((void *)v38 + 4), v38);
      if ((_DWORD)v80) {
        goto LABEL_159;
      }
      sub_10003D570( (uint64_t)a1,  *((void *)v38 + 3),  *((void *)v38 + 4),  0LL,  0x40000000,  *((void *)v38 + 3),  0LL,  0,  0xDu,  1u);
      uint64_t v27 = v116;
    }

    if (v126 > v124)
    {
      if (!v125
        && !sub_1000428C4(qword_10008DB70, "Fix the keybag size? ", v19, v20, v21, v22, v23, v24, v110))
      {
LABEL_124:
        uint64_t v88 = *((unsigned __int16 *)v38 + 9);
        uint64_t v89 = v88 + 24;
        uint64_t v42 = v120;
        ++v121;
        uint64_t v90 = v88 - ((v88 + 24) & 0xF) + 40;
        if ((v89 & 0xF) == 0) {
          uint64_t v90 = v89;
        }
        v38 += v90;
        unint64_t v39 = v123;
        goto LABEL_127;
      }

      unsigned int v81 = *((_DWORD *)v16 + 9) + v126 - v124;
      *((_DWORD *)v16 + 9) = v81;
      unsigned int v82 = (unsigned __int16)v16[17];
      if (v121 + 1 > v82) {
        v16[17] = v82 + 1;
      }
      unint64_t v123 = (unint64_t)&v27[v81];
      int v122 = 1;
    }

    if (!v125) {
      goto LABEL_124;
    }
    uint64_t v83 = *((unsigned __int16 *)v38 + 9);
    rsize_t v84 = v83 + 24;
    uint64_t v85 = v83 - ((v83 + 24) & 0xF) + 40;
    if ((v84 & 0xF) != 0) {
      rsize_t v86 = v85;
    }
    else {
      rsize_t v86 = v84;
    }
    memmove(v38, &v38[v86], v123 - (void)&v38[v86]);
    unsigned int v16 = v115;
    memset_s((void *)(v123 - v86), v86, 0, v86);
    uint64_t v87 = (*((_DWORD *)v115 + 9) - v86);
    *((_DWORD *)v115 + 9) = v87;
    --v115[17];
    unint64_t v39 = (unint64_t)&v27[v87];
    uint64_t v42 = v118;
LABEL_127:
    ++v40;
    unsigned int v30 = v117;
  }

  unsigned int v93 = "media";
  unsigned int v94 = "volume";
  if (v11 != 1919247219) {
    LOBYTE(v94) = v119;
  }
  if (v11 != 1835754873) {
    LOBYTE(v93) = (_BYTE)v94;
  }
  sub_100040B90( "%s keybag (%llu+%llu): entry %u has size %u > maximum size %u\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (char)v93);
  uint64_t v13 = 92LL;
  uint64_t v35 = 1066LL;
LABEL_54:
  sub_100044E7C((char *)v35, 92);
LABEL_55:
  free(v127);
  return v13;
}

uint64_t sub_1000204AC( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[1];
  size_t v9 = *(void *)(v8 + 1304);
  if (!v9 || *(_BYTE *)(qword_10008DB78 + 43)) {
    return 0LL;
  }
  uint64_t v13 = *(void *)(v8 + 1296);
  unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = sub_10002070C(a1, 0x6B657973uLL, v13, v9, (unsigned __int8 *)(v8 + 72), &v45, a7, a8);
  if (!(_DWORD)v10)
  {
    uint64_t v14 = v45;
    unint64_t v15 = v45 + 32;
    unint64_t v16 = v45 + 48;
    unint64_t v17 = v45 + 32 + *(unsigned int *)(v45 + 36);
    if (v45 + 48 >= v17)
    {
LABEL_22:
      uint64_t v10 = 0LL;
    }

    else
    {
      int v18 = 0;
      char v19 = 0;
      do
      {
        while (!uuid_is_null((const unsigned __int8 *)v16))
        {
          *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&__int128 v22 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)uuid_string_t out = v22;
          *(_OWORD *)&out[16] = v22;
          uuid_unparse((const unsigned __int8 *)v16, out);
          sub_100040C68( "%s keybag (%llu+%llu): UUID %s of entry %u (tag %u) does not reference any volume\n",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  (char)"container");
          sub_100044E7C((char *)0x445, -2);
          uint64_t v39 = *(unsigned __int16 *)(v16 + 18);
          rsize_t v40 = v39 + 24;
          uint64_t v41 = v39 - ((v39 + 24) & 0xF) + 40;
          if ((v40 & 0xF) != 0) {
            rsize_t v42 = v41;
          }
          else {
            rsize_t v42 = v40;
          }
          memmove((void *)v16, (const void *)(v16 + v42), v17 - (v16 + v42));
          memset_s((void *)(v17 - v42), v42, 0, v42);
          uint64_t v43 = (*(_DWORD *)(v14 + 36) - v42);
          *(_DWORD *)(v14 + 36) = v43;
          --*(_WORD *)(v14 + 34);
          unint64_t v17 = v15 + v43;
          ++v18;
          char v19 = 1;
          if (v16 >= v15 + v43)
          {
            uint64_t v14 = v45;
            goto LABEL_21;
          }
        }

        uint64_t v36 = *(unsigned __int16 *)(v16 + 18);
        uint64_t v37 = v36 + 24;
        uint64_t v38 = v36 - ((v36 + 24) & 0xF) + 40;
        if ((v37 & 0xF) == 0) {
          uint64_t v38 = v37;
        }
        v16 += v38;
        ++v18;
      }

      while (v16 < v17);
      uint64_t v14 = v45;
      if ((v19 & 1) == 0) {
        goto LABEL_22;
      }
LABEL_21:
      uint64_t v10 = sub_100020970(a1, 1801812339, v13, v9, (unsigned __int8 *)(a1[1] + 72), v14, v20, v21);
    }

    free((void *)v14);
  }

  return v10;
}

uint64_t sub_10002070C( uint64_t *a1, size_t a2, uint64_t a3, size_t __count, unsigned __int8 *a5, void *a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2;
  if (HIDWORD(__count) || (a2 = *(unsigned int *)(a1[1] + 36), (__count * a2) >> 32))
  {
    uint64_t v24 = "media";
    uint64_t v25 = "volume";
    uint64_t v26 = "unknown";
    if (v10 == 1801812339) {
      uint64_t v26 = "container";
    }
    if (v10 != 1919247219) {
      LOBYTE(v25) = (_BYTE)v26;
    }
    if (v10 != 1835754873) {
      LOBYTE(v24) = (_BYTE)v25;
    }
    sub_100040B90( "%s keybag (%llu+%llu): size is too large\n",  a2,  a3,  __count,  (uint64_t)a5,  (uint64_t)a6,  a7,  a8,  (char)v24);
    uint64_t v27 = 92LL;
    uint64_t v28 = 1058LL;
    int v29 = 92;
    goto LABEL_13;
  }

  uint64_t v14 = calloc(__count, a2);
  if (!v14)
  {
    uint64_t v31 = "media";
    uint64_t v32 = "volume";
    uint64_t v33 = "unknown";
    if (v10 == 1801812339) {
      uint64_t v33 = "container";
    }
    if (v10 != 1919247219) {
      LOBYTE(v32) = (_BYTE)v33;
    }
    if (v10 != 1835754873) {
      LOBYTE(v31) = (_BYTE)v32;
    }
    sub_100040B90("%s keybag (%llu+%llu): failed to allocate memory\n", v15, v16, v17, v18, v19, v20, v21, (char)v31);
    uint64_t v27 = 12LL;
    uint64_t v28 = 1059LL;
    int v29 = 12;
LABEL_13:
    sub_100044E7C((char *)v28, v29);
    return v27;
  }

  __int128 v22 = v14;
  if (v10 == 1835754873)
  {
    uint64_t v23 = sub_10002BE74(*a1, a3);
  }

  else
  {
    uint64_t v34 = a1[1];
    uint64_t v35 = *(char **)(qword_10008DB78 + 8);
    *(void *)&v44[0] = a3;
    *((void *)&v44[0] + 1) = __count;
    v44[1] = *(_OWORD *)(v34 + 1392);
    uint64_t v23 = sub_10001A4F8(v35, a5, v44, 1, (uint64_t)v22);
  }

  uint64_t v27 = v23;
  if ((_DWORD)v23)
  {
    switch(v10)
    {
      case 1835754873:
        uint64_t v36 = "media";
        break;
      case 1919247219:
        uint64_t v36 = "volume";
        break;
      case 1801812339:
        uint64_t v36 = "container";
        break;
      default:
        uint64_t v36 = "unknown";
        break;
    }

    strerror(v23);
    sub_100040B90("%s keybag (%llu+%llu): failed to get keybag: %s\n", v37, v38, v39, v40, v41, v42, v43, (char)v36);
    sub_100044E7C((char *)0x424, v27);
    free(v22);
  }

  else
  {
    *a6 = v22;
  }

  return v27;
}

uint64_t sub_100020970( uint64_t *a1, int a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, int8x16_t a7, int8x16_t a8)
{
  if (a2 == 1835754873)
  {
    uint64_t v14 = sub_10002BFDC(*a1, a3);
  }

  else
  {
    uint64_t v15 = a1[1];
    uint64_t v16 = *(char **)(qword_10008DB78 + 8);
    *(void *)&v28[0] = a3;
    *((void *)&v28[0] + 1) = a4;
    v28[1] = *(_OWORD *)(v15 + 1392);
    uint64_t v14 = sub_10001A4F8(v16, a5, v28, 0, a6);
  }

  uint64_t v17 = v14;
  if ((_DWORD)v14)
  {
    if (a2 == 1835754873)
    {
      uint64_t v19 = "media";
    }

    else
    {
      uint64_t v18 = "unknown";
      if (a2 == 1801812339) {
        uint64_t v18 = "container";
      }
      if (a2 == 1919247219) {
        uint64_t v19 = "volume";
      }
      else {
        LOBYTE(v19) = (_BYTE)v18;
      }
    }

    strerror(v14);
    sub_100040B90("%s keybag (%llu+%llu): failed to put keybag: %s\n", v20, v21, v22, v23, v24, v25, v26, (char)v19);
    sub_100044E7C((char *)0x443, v17);
  }

  return v17;
}

uint64_t sub_100020AC0(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[2];
  int v7 = *(_DWORD *)(v6 + 104);
  uint64_t v8 = *(void *)(v6 + 96);
  int v27 = 0;
  *(_DWORD *)uint64_t v28 = v7;
  *(void *)&void v28[4] = *(void *)(v6 + 72);
  __int128 v29 = *(_OWORD *)(v6 + 80);
  uint64_t v30 = v8;
  uint64_t v31 = 0LL;
  uint64_t v9 = sub_100020C50(a1, a2, (uint64_t)&v27, a3);
  if ((_DWORD)v9) {
    return v9;
  }
  uint64_t v11 = *(void *)(v6 + 48);
  if (!v11) {
    return 0LL;
  }
  size_t v12 = 0LL;
  while (2)
  {
    if (v12)
    {
      free(v12);
      uint64_t v31 = 0LL;
    }

    memset(v26, 170, sizeof(v26));
    uint64_t v13 = sub_100022BD0(a1, 0LL, 0x80000000, v11, 0LL, 0, 18, 0, (uint64_t **)&v31, (uint64_t)v26, 0);
    if (!(_DWORD)v13)
    {
      size_t v12 = v31;
      for (uint64_t i = *((unsigned int *)v31 + 13); (_DWORD)i != -1; uint64_t i = *((unsigned int *)v31 + 10 * i + 16))
      {
        uint64_t v15 = &v12[5 * i];
        int v16 = *((_DWORD *)v15 + 19);
        uint64_t v17 = v15[12];
        int v27 = 0;
        *(void *)uint64_t v28 = *(void *)((char *)v15 + 68);
        *(_DWORD *)&v28[8] = v16;
        __int128 v29 = *((_OWORD *)v15 + 5);
        uint64_t v30 = v17;
        uint64_t v18 = sub_100020C50(a1, a2, (uint64_t)&v27, a3);
        if ((_DWORD)v18)
        {
          uint64_t v9 = v18;
          goto LABEL_15;
        }

        size_t v12 = v31;
      }

      uint64_t v11 = v12[4];
      if (v11) {
        continue;
      }
      uint64_t v9 = 0LL;
      goto LABEL_16;
    }

    break;
  }

  uint64_t v9 = v13;
  strerror(v13);
  sub_100040B90("Could not read nx_reaper_list object (oid (0x%llx)): %s\n", v19, v20, v21, v22, v23, v24, v25, v11);
LABEL_15:
  size_t v12 = v31;
  if (v31) {
LABEL_16:
  }
    free(v12);
  return v9;
}

uint64_t sub_100020C50(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = 0LL;
  memset(v36, 170, sizeof(v36));
  int v9 = *(_DWORD *)(a3 + 4);
  int v8 = *(_DWORD *)(a3 + 8);
  uint64_t v10 = *(void *)(a3 + 16);
  if (!byte_10008DB80[0])
  {
    uint64_t v14 = 0LL;
LABEL_11:
    ++byte_10008DB80[0];
    *(void *)&byte_10008DB80[8 * v14 + 8] = v10;
    goto LABEL_12;
  }

  if (qword_10008DB88 != v10)
  {
    uint64_t v11 = 0LL;
    do
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)&byte_10008DB80[8 * v11++ + 16];
    }

    while (v13 != v10);
    uint64_t v14 = byte_10008DB80[0];
  }

LABEL_45:
  if (v19 == 0x40000000)
  {
    sub_10003D570( (uint64_t)a1,  *(unint64_t *)v36,  (*(_DWORD *)&v36[8] / *(_DWORD *)(a1[1] + 36)),  *(void *)(a3 + 16),  0x40000000,  *(void *)(a3 + 24),  0LL,  *((unsigned __int16 *)v37 + 12),  *((_DWORD *)v37 + 7),  5u);
LABEL_17:
    uint64_t v17 = 0LL;
    goto LABEL_18;
  }

  uint64_t v17 = 0LL;
  if ((_DWORD)a4 == 1 && !v19)
  {
    sub_10001CF00(*(void *)(a3 + 24), *(_DWORD *)(a3 + 8));
    goto LABEL_17;
  }

        if (v33) {
          goto LABEL_46;
        }
        goto LABEL_21;
      }

      uint64_t v12 = 12LL;
    }

    __int128 v33 = v60;
    goto LABEL_46;
  }

  if (v36 && a1[10] != 0x8000000) {
    free(v36);
  }
  if (__src && a1[10] != 0x8000000) {
    free(__src);
  }
  return v12;
}

LABEL_18:
  if (v37) {
    free(v37);
  }
  return v17;
}

        v4 += v5;
        uint64_t v6 = *v3++;
        uint64_t v2 = v6;
      }

      while (v6);
    }

    return strdup(__s1);
  }

  return result;
}

uint64_t sub_100020F60( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v54 = 0LL;
  memset(v55, 170, sizeof(v55));
  uint64_t v8 = a1[2];
  if (*(void *)(v8 + 40) >= *(void *)(v8 + 32))
  {
    sub_100040B90( "reaper completed ID 0x%llx not less than next reap ID 0x%llx\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(v8 + 40));
    uint64_t v9 = 92LL;
    uint64_t v10 = 96LL;
    goto LABEL_62;
  }

  if ((*(_DWORD *)(v8 + 64) & 1) == 0)
  {
    sub_100040B90("reaper needs more cowbell, flags 0x%x\n", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(v8 + 64));
    uint64_t v9 = 92LL;
    uint64_t v10 = 97LL;
    goto LABEL_62;
  }

  uint64_t v11 = *(void *)(v8 + 48);
  if ((v11 != 0) == (*(void *)(v8 + 56) == 0LL))
  {
    sub_100040B90( "reaper head (0x%llx) and tail (0x%llx) should be both valid or both invalid\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(v8 + 48));
    uint64_t v9 = 92LL;
    uint64_t v10 = 98LL;
    goto LABEL_62;
  }

  if (!v11)
  {
LABEL_60:
    uint64_t v9 = sub_100020AC0(a1, 0LL, 0LL);
    goto LABEL_63;
  }

  uint64_t v13 = 0LL;
  int v14 = *(_DWORD *)(v8 + 68);
  while (1)
  {
    if (v13) {
      free(v13);
    }
    uint64_t v15 = sub_100022BD0(a1, 0LL, 0x80000000, v11, 0LL, 0, 18, 0, &v54, (uint64_t)v55, 0);
    if ((_DWORD)v15)
    {
      uint64_t v9 = v15;
      sub_100040B90("verification/reading of the nx_reaper object failed\n", v16, v17, v18, v19, v20, v21, v22, v53[0]);
      goto LABEL_63;
    }

    uint64_t v23 = *((unsigned int *)v54 + 11);
    if (((unint64_t)LODWORD(v55[1]) - 64) / 0x28 != v23)
    {
      sub_100040B90( "reap list object 0x%llx max record count %u different than expected %lu\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v11);
      uint64_t v9 = 92LL;
      uint64_t v10 = 642LL;
      goto LABEL_62;
    }

    if (*((_DWORD *)v54 + 12) > v23)
    {
      sub_100040B90( "reap list object 0x%llx record count %u larger than max %u\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v11);
      uint64_t v9 = 92LL;
      uint64_t v10 = 99LL;
      goto LABEL_62;
    }

    unsigned int v24 = *((_DWORD *)v54 + 13);
    if (v24 != -1 && v24 > v23)
    {
      sub_100040B90( "reap list object 0x%llx first index %u larger than max %u\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v11);
      uint64_t v9 = 92LL;
      uint64_t v10 = 100LL;
      goto LABEL_62;
    }

    unsigned int v26 = *((_DWORD *)v54 + 14);
    if (v26 != -1 && v26 > v23)
    {
      sub_100040B90( "reap list object 0x%llx last index %u larger than max %u\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v11);
      uint64_t v9 = 92LL;
      uint64_t v10 = 101LL;
      goto LABEL_62;
    }

    unsigned int v28 = *((_DWORD *)v54 + 15);
    if (v28 != -1 && v28 > v23)
    {
      sub_100040B90( "reap list object 0x%llx free index %u larger than max %u\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v11);
      uint64_t v9 = 92LL;
      uint64_t v10 = 102LL;
      goto LABEL_62;
    }

    uint64_t v30 = v54[4];
    uint64_t v31 = *(void *)(v8 + 56);
    if (v30)
    {
      if (v31 == v11)
      {
        sub_100040B90( "reap list tail 0x%llx is not last reap list object, next 0x%llx\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v11);
        uint64_t v9 = 92LL;
        uint64_t v10 = 104LL;
        goto LABEL_62;
      }

      goto LABEL_29;
    }

    if (v31 != v11) {
      break;
    }
LABEL_29:
    if (*(_DWORD *)(v8 + 68))
    {
      --v14;
      if (v30 && !v14)
      {
        sub_100040B90( "reap list expected %u objects, but haven't seen last reap list object yet\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  *(_DWORD *)(v8 + 68));
        uint64_t v9 = 92LL;
        uint64_t v10 = 105LL;
        goto LABEL_62;
      }

      if (!v30 && v14)
      {
        sub_100040B90( "reap list expected %u objects, but got last reap list object with %u more objects left\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  *(_DWORD *)(v8 + 68));
        uint64_t v9 = 92LL;
        uint64_t v10 = 106LL;
        goto LABEL_62;
      }
    }

    size_t v32 = 2 * v23;
    __chkstk_darwin(v15);
    __int128 v33 = &v53[-((v32 + 15) & 0x3FFFFFFF0LL)];
    if (v34) {
      memset(&v53[-((v32 + 15) & 0x3FFFFFFF0LL)], 170, v32);
    }
    else {
      size_t v32 = 0LL;
    }
    bzero(v33, v32);
    uint64_t v42 = v54;
    unsigned int v43 = *((_DWORD *)v54 + 13);
    if (v43 != -1)
    {
      int v44 = 0;
      while (1)
      {
        if (v43 >= *((_DWORD *)v42 + 11))
        {
          sub_100040B90( "reaper list entry (index (%u) list oid (0x%llx)) : index not less than nrl_max (%u)\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v43);
          uint64_t v51 = 556LL;
          goto LABEL_74;
        }

        if (*(_WORD *)&v33[2 * v43] == 1)
        {
          sub_100040B90( "reaper list entry (index (%u) list oid (0x%llx)) : cycle detected\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v43);
          uint64_t v51 = 643LL;
          goto LABEL_74;
        }

        *(_WORD *)&v33[2 * v43] = 1;
        unsigned int v45 = HIDWORD(v42[5 * v43 + 8]);
        if (v45 >= 0x20)
        {
          sub_100040C68( "reaper list entry (index (%u) list oid (0x%llx)) : invalid flags (0x%x) set\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v43);
          sub_100044E7C((char *)0x22D, -3);
          uint64_t v42 = v54;
          unsigned int v45 = HIDWORD(v54[5 * v43 + 8]);
        }

        if ((v45 & 1) == 0)
        {
          sub_100040B90( "reaper list entry (index (%u) list oid (0x%llx)) : is not valid as per flags(0x%x)\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v43);
          uint64_t v51 = 572LL;
          goto LABEL_74;
        }

        ++v44;
        unsigned int v43 = v42[5 * v43 + 8];
        if (v43 == -1) {
          goto LABEL_48;
        }
      }

      sub_100040C68( "reaper list entry (index (%u) list oid (0x%llx)) : invalid nrle_fs_oid (0x%llx)\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v43);
      uint64_t v51 = 558LL;
      int v52 = -2;
      goto LABEL_75;
    }

    int v44 = 0;
LABEL_48:
    if (v44 != *((_DWORD *)v42 + 12))
    {
      sub_100040B90( "reap list object (oid 0x%llx) expected %u entries, found %u\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v11);
      uint64_t v51 = 644LL;
      goto LABEL_74;
    }

    unsigned int v46 = *((_DWORD *)v42 + 15);
    uint64_t v47 = *((unsigned int *)v42 + 11);
    if (v46 != -1)
    {
      while (1)
      {
        if (v46 >= v47)
        {
          sub_100040B90( "reaper list entry (index (%u) list oid (0x%llx)) : index not less than nrl_max (%u)\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v46);
          uint64_t v51 = 645LL;
          goto LABEL_74;
        }

        int v48 = *(unsigned __int16 *)&v33[2 * v46];
        if (v48 == 2)
        {
          sub_100040B90( "reaper list entry (index (%u) list oid (0x%llx)) : cycle detected\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v46);
          uint64_t v51 = 647LL;
          goto LABEL_74;
        }

        if (v48 == 1) {
          break;
        }
        *(_WORD *)&v33[2 * v46] = 2;
        unsigned int v46 = v42[5 * v46 + 8];
        if (v46 == -1) {
          goto LABEL_56;
        }
      }

      sub_100040B90( "reaper list entry (index (%u) list oid (0x%llx)) : entry is both occupied and free!\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v46);
      uint64_t v51 = 646LL;
LABEL_74:
      int v52 = 92;
LABEL_75:
      sub_100044E7C((char *)v51, v52);
      uint64_t v9 = 92LL;
      goto LABEL_63;
    }

    if ((_DWORD)v47)
    {
LABEL_56:
      uint64_t v49 = 0LL;
      while (*(_WORD *)&v33[2 * v49])
      {
        if (v47 == ++v49) {
          goto LABEL_59;
        }
      }

      sub_100040B90( "reaper list entry (index (%u) list oid (0x%llx)) : entry is not referenced\n",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v49);
      uint64_t v51 = 648LL;
      goto LABEL_74;
    }

BOOL sub_1000215C0(uint64_t a1)
{
  if (!byte_10008DB80[0]) {
    return 0LL;
  }
  if (qword_10008DB88 == a1) {
    return 1LL;
  }
  uint64_t v2 = 0LL;
  do
  {
    uint64_t v3 = v2;
    uint64_t v4 = *(void *)&byte_10008DB80[8 * v2++ + 16];
  }

  while (v4 != a1);
  return v3 + 1 < (unint64_t)byte_10008DB80[0];
}

uint64_t sub_10002162C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v58 = 0u;
  int v56 = 0LL;
  uint64_t v57 = 0LL;
  __int16 v8 = *(_WORD *)(a4 + 32);
  if ((v8 & 2) != 0) {
    return 0LL;
  }
  uint64_t v10 = *(void *)(a3 + 24);
  if ((v8 & 8) != 0)
  {
    sub_100040B90("btree node (oid (0%llx)) being reaped is hashed\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(a3 + 24));
    uint64_t v18 = 22LL;
    uint64_t v19 = 916LL;
    int v20 = 22;
    goto LABEL_11;
  }

  unsigned int v51 = *(_DWORD *)(*(void *)(a1 + 8) + 36LL);
  int v15 = *(_DWORD *)(a3 + 8);
  if ((v8 & 1) != 0)
  {
    uint64_t v21 = a4 + *(unsigned int *)(a5 + 8);
    __int128 v22 = *(_OWORD *)(v21 - 24);
    __int128 v58 = *(_OWORD *)(v21 - 40);
    __int128 v59 = v22;
    *(void *)&__int128 v60 = *(void *)(v21 - 8);
  }

  else
  {
    uint64_t v16 = *(unsigned int *)(a4 + 28);
    if (v16 > 0x24 || ((0x87BD631FFuLL >> v16) & 1) != 0)
    {
      sub_100040C68("object (oid (0%llx)) being reaped : Invalid tree subtype (%u)\n", a2, a3, a4, a5, a6, a7, a8, v10);
      sub_100044E7C((char *)0x233, -5);
      return 22LL;
    }

    int v17 = ((0x100001C000uLL >> v16) & 1) != 0 ? 0 : dword_10006B1C0[v16];
    DWORD1(v58) = *(_DWORD *)(*(void *)(a1 + 8) + 36LL);
    DWORD2(v58) = v17;
  }

  if (!*(_DWORD *)(a4 + 36)) {
    return 0LL;
  }
  unsigned int v23 = 0;
  unsigned int v24 = v15 & 0xC0000000;
  __int16 v55 = -21846;
  __int16 v54 = -21846;
  unsigned int v25 = v15 & 0xC0000000 | 3;
  BOOL v27 = (_DWORD)a6 == 1 && v24 == 0;
  BOOL v50 = v27;
  while (1)
  {
    sub_100030B3C(a4, (uint64_t)&v58, v23, &v57, &v55, (uint64_t *)&v56, &v54);
    if (v54 != 8)
    {
      sub_100040B90( "btree node (oid (0%llx)) being reaped has invalid val_len (%u) at index (%d) \n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v10);
      uint64_t v18 = 92LL;
      uint64_t v19 = 559LL;
      goto LABEL_57;
    }

    unint64_t v35 = *v56;
    *(void *)(a3 + 24) = *v56;
    *(_DWORD *)(a3 + 8) = v25;
    __int128 v36 = *(_OWORD *)(a3 + 16);
    v52[0] = *(_OWORD *)a3;
    v52[1] = v36;
    uint64_t v53 = *(void *)(a3 + 32);
    uint64_t v37 = sub_100020C50(a1, a2, v52, a6);
    if ((_DWORD)v37) {
      return v37;
    }
LABEL_51:
    if (++v23 >= *(_DWORD *)(a4 + 36)) {
      return 0LL;
    }
  }

  if (v24 != 0x40000000)
  {
    if (v50) {
      sub_10001CF00(v35, v24 | 3);
    }
    goto LABEL_51;
  }

  uint64_t v38 = *(void *)(a1 + 8);
  uint64_t v39 = *(void *)(a1 + 24);
  if (v39)
  {
    unint64_t v40 = *(void *)(v39 + 48);
    unint64_t v41 = *(void *)(v39 + 96);
  }

  else
  {
    unint64_t v40 = *(void *)(v38 + 40);
    if ((*(_BYTE *)(v38 + 65) & 1) != 0) {
      unint64_t v41 = *(void *)(v38 + 40);
    }
    else {
      unint64_t v41 = 0LL;
    }
  }

  unint64_t v42 = *(unsigned int *)(v38 + 36);
  unint64_t v43 = DWORD1(v58) / v51;
  if (v35 && (v40 > v43 ? (BOOL v44 = v40 > v35) : (BOOL v44 = 0), v44 ? (v45 = v40 - v43 >= v35) : (v45 = 0), v45)
    || ((unint64_t v46 = 0x4000000000000000uLL >> __clz(__rbit64(v42)), v46 < v35) ? (v47 = v41 > v43) : (v47 = 0),
        v47 ? (BOOL v48 = (v41 | v46) > v35) : (BOOL v48 = 0),
        v48 && ((v41 - v43) | v46) >= v35))
  {
    sub_10003D570(a1, v35, v43, *(void *)(a3 + 16), 0x40000000, v35, 0LL, 3u, *(_DWORD *)(a4 + 28), 5u);
    goto LABEL_51;
  }

  sub_100040B90("invalid btree node address range (0x%llx+%llu)\n", v35, v43, v30, v31, v32, v33, v34, v35);
  uint64_t v18 = 92LL;
  uint64_t v19 = 1238LL;
LABEL_57:
  int v20 = 92;
LABEL_11:
  sub_100044E7C((char *)v19, v20);
  return v18;
}

uint64_t sub_100021938(uint64_t a1, __int128 *a2, uint64_t a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v41[2] = v6;
  v41[3] = v6;
  v41[0] = v6;
  v41[1] = v6;
  v39[2] = v6;
  v39[3] = v6;
  v39[0] = v6;
  v39[1] = v6;
  __int128 v7 = a2[1];
  __int128 v35 = *a2;
  unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
  memset(v38, 170, sizeof(v38));
  v34[1] = 0LL;
  v34[2] = 0LL;
  v34[0] = a1;
  __int128 v36 = v7;
  uint64_t v37 = *((void *)a2 + 4);
  if (*(void *)(a3 + 48))
  {
    uint64_t v8 = sub_100034B44( (uint64_t)v41,  a1,  0LL,  *(_DWORD *)(a3 + 40) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(a3 + 40),  11,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  16,  16,  0,  *(void *)(a3 + 48),  (uint64_t)sub_10001DFDC);
    if ((_DWORD)v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(a3 + 48);
      strerror(v8);
      sub_100040B90("Could not initialize omap tree (oid 0x%llx): %s\n", v11, v12, v13, v14, v15, v16, v17, v10);
      uint64_t v18 = 566LL;
LABEL_7:
      sub_100044E7C((char *)v18, v9);
      return v9;
    }

    void v38[2] = 0LL;
    v38[3] = 0LL;
    uint64_t v9 = sub_100035394((uint64_t)v39, (uint64_t)v41, 0LL, &v38[2], 0x10u, 0x10u, v38, 16);
    if ((_DWORD)v9
      || (uint64_t v9 = sub_10002930C( (uint64_t)v39,  (uint64_t (*)(void, void, void, void, uint64_t))sub_100021FB4,  (uint64_t)v34,  0),  (_DWORD)v9))
    {
      uint64_t v19 = *(void *)(a3 + 48);
      strerror(v9);
      sub_100040B90( "Could not iterate omap tree to read reaper objects (oid 0x%llx): %s\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v19);
      uint64_t v18 = 567LL;
      goto LABEL_7;
    }

    *((_DWORD *)a2 + 2) = *(_DWORD *)(a3 + 40);
    *((_DWORD *)a2 + 3) = *(_DWORD *)(*(void *)(a1 + 8) + 36LL);
    *((void *)a2 + 3) = *(void *)(a3 + 48);
    *((void *)a2 + 4) = 0LL;
    __int128 v27 = a2[1];
    __int128 v31 = *a2;
    __int128 v32 = v27;
    uint64_t v33 = 0LL;
    uint64_t v9 = sub_100020C50(a1, 0LL, &v31, 0LL);
    if ((_DWORD)v9) {
      return v9;
    }
  }

  uint64_t v28 = *(void *)(a3 + 56);
  if (!v28) {
    return 0LL;
  }
  *((_DWORD *)a2 + 2) = *(_DWORD *)(a3 + 44);
  *((_DWORD *)a2 + 3) = *(_DWORD *)(*(void *)(a1 + 8) + 36LL);
  *((void *)a2 + 3) = v28;
  *((void *)a2 + 4) = 0LL;
  __int128 v29 = a2[1];
  __int128 v31 = *a2;
  __int128 v32 = v29;
  uint64_t v33 = 0LL;
  uint64_t v9 = sub_100020C50(a1, 0LL, &v31, 0LL);
  if (!(_DWORD)v9) {
    return 0LL;
  }
  return v9;
}

uint64_t sub_100021B40(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v39 = a3;
  uint64_t v6 = *(void *)(a3 + 152);
  if (!v6)
  {
LABEL_16:
    uint64_t v30 = *(void *)(a3 + 144);
    int v31 = *(_DWORD *)(a3 + 120);
    __int128 v32 = *((_OWORD *)a2 + 1);
    __int128 v48 = *(_OWORD *)a2;
    __int128 v49 = v32;
    *(void *)&__int128 v50 = a2[4];
    uint64_t v10 = sub_1000220E8(a1, (uint64_t)v38, &v48, 0LL, v30, v31);
    if (!(_DWORD)v10)
    {
      *((_DWORD *)a2 + 2) = 1073741835;
      *((_DWORD *)a2 + 3) = *(_DWORD *)(*(void *)(a1 + 8) + 36LL);
      a2[3] = *(void *)(a3 + 128);
      a2[4] = 0LL;
      __int128 v33 = *((_OWORD *)a2 + 1);
      __int128 v48 = *(_OWORD *)a2;
      __int128 v49 = v33;
      *(void *)&__int128 v50 = 0LL;
      return sub_100020C50(a1, 0LL, &v48, 0LL);
    }

    return v10;
  }

  uint64_t v7 = *a2;
  uint64_t v8 = a2[2];
  *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v53[2] = v9;
  v53[3] = v9;
  v53[0] = v9;
  v53[1] = v9;
  unint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
  __int128 v50 = v9;
  __int128 v51 = v9;
  __int128 v48 = v9;
  __int128 v49 = v9;
  v46[0] = a1;
  v46[1] = v38;
  v46[2] = 0LL;
  v46[3] = v7;
  void v46[4] = a2[1];
  v46[5] = v8;
  __int128 v47 = *(_OWORD *)(a2 + 3);
  LODWORD(v10) = sub_100034B44( (uint64_t)v53,  a1,  (uint64_t)v38,  *(_DWORD *)(a3 + 124) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(a3 + 124),  16,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  0,  0,  0,  v6,  (uint64_t)sub_10003A6AC);
  uint64_t v11 = calloc(1uLL, 0x340uLL);
  uint64_t v12 = calloc(1uLL, 0xEE0uLL);
  uint64_t v13 = v12;
  if (!(_DWORD)v10 && v11 && v12)
  {
    uint64_t v10 = sub_100035394((uint64_t)&v48, (uint64_t)v53, 0LL, v11, 8u, 0x340u, v12, 3808);
    if ((_DWORD)v10
      || (uint64_t v10 = sub_10002930C( (uint64_t)&v48,  (uint64_t (*)(void, void, void, void, uint64_t))sub_100022280,  (uint64_t)v46,  0),  (_DWORD)v10))
    {
      uint64_t v14 = *(void *)(v39 + 152);
      strerror(v10);
      sub_100040B90( "Could not iterate snap meta tree to read reaper objects (oid 0x%llx): %s\n",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v14);
      sub_100044E7C((char *)0x23A, v10);
    }

    else
    {
      int v35 = *(_DWORD *)(v39 + 124);
      int v36 = *(_DWORD *)(*(void *)(a1 + 8) + 36LL);
      uint64_t v37 = *(void *)(v39 + 152);
      uint64_t v40 = v7;
      int v41 = v35;
      int v42 = v36;
      uint64_t v43 = v8;
      uint64_t v44 = v37;
      uint64_t v45 = 0LL;
      uint64_t v10 = sub_100020C50(a1, 0LL, &v40, 0LL);
    }

uint64_t sub_100021DFC(uint64_t a1, __int128 *a2, uint64_t a3)
{
  __int128 v3 = a2[1];
  __int128 v32 = *a2;
  uint64_t v35 = 0LL;
  uint64_t v36 = 0LL;
  v31[1] = 0LL;
  v31[2] = 0LL;
  v31[0] = a1;
  __int128 v33 = v3;
  uint64_t v34 = *((void *)a2 + 4);
  if ((*(_BYTE *)(a3 + 27) & 0x40) != 0)
  {
    *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v39[2] = v8;
    v39[3] = v8;
    v39[0] = v8;
    v39[1] = v8;
    int v37[2] = v8;
    v37[3] = v8;
    unint64_t v38 = 0xAAAAAAAAAAAAAAAALL;
    v37[0] = v8;
    v37[1] = v8;
    uint64_t v9 = sub_100034B44( (uint64_t)v39,  a1,  0LL,  0x40000000,  2,  26,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  8,  8,  0,  *(void *)(a3 + 32),  (uint64_t)sub_10002D39C);
    if ((_DWORD)v9)
    {
      uint64_t v4 = v9;
      uint64_t v10 = *(void *)(a3 + 32);
      strerror(v9);
      sub_100040B90("Could not initialize gbitmap tree (oid 0x%llx): %s\n", v11, v12, v13, v14, v15, v16, v17, v10);
      uint64_t v18 = 553LL;
    }

    else
    {
      uint64_t v4 = sub_100035394((uint64_t)v37, (uint64_t)v39, 0LL, &v36, 8u, 8u, &v35, 8);
      if (!(_DWORD)v4)
      {
        uint64_t v4 = sub_10002930C( (uint64_t)v37,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000224D4,  (uint64_t)v31,  0);
        if (!(_DWORD)v4)
        {
          *((_DWORD *)a2 + 2) = 0x40000000;
          *((_DWORD *)a2 + 3) = *(_DWORD *)(*(void *)(a1 + 8) + 36LL);
          *((void *)a2 + 3) = *(void *)(a3 + 32);
          __int128 v28 = a2[1];
          v29[0] = *a2;
          v29[1] = v28;
          uint64_t v30 = *((void *)a2 + 4);
          uint64_t v4 = sub_100020C50(a1, 0LL, v29, 0LL);
          if ((_DWORD)v4) {
            return v4;
          }
          return 0LL;
        }
      }

      uint64_t v19 = *(void *)(a3 + 32);
      strerror(v4);
      sub_100040B90( "Could not iterate gbitmap tree to read reaper objects (oid 0x%llx): %s\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v19);
      uint64_t v18 = 571LL;
    }

    sub_100044E7C((char *)v18, v4);
    return v4;
  }

  return 0LL;
}

uint64_t sub_100021FB4( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)a3 & 1) != 0) {
    return 0LL;
  }
  uint64_t v10 = *a5;
  uint64_t v11 = *(void *)(*a5 + 8);
  unint64_t v12 = *(unsigned int *)(v11 + 36);
  if ((*(_DWORD *)a3 & 0xE0) == 0x20) {
    int v13 = 36;
  }
  else {
    int v13 = 14;
  }
  unint64_t v14 = ((int)v12 + *(_DWORD *)(a3 + 4) - 1) / v12;
  unint64_t v15 = *(void *)(a3 + 8);
  uint64_t v16 = *(void *)(v10 + 24);
  if (v16)
  {
    unint64_t v17 = *(void *)(v16 + 48);
    unint64_t v18 = *(void *)(v16 + 96);
    if (!v15) {
      goto LABEL_19;
    }
  }

  else
  {
    unint64_t v17 = *(void *)(v11 + 40);
    if ((*(_BYTE *)(v11 + 65) & 1) != 0) {
      unint64_t v18 = *(void *)(v11 + 40);
    }
    else {
      unint64_t v18 = 0LL;
    }
    if (!v15) {
      goto LABEL_19;
    }
  }

  if (v17 > v14 && v17 > v15 && v17 - v14 >= v15) {
    goto LABEL_28;
  }
LABEL_19:
  unint64_t v21 = 0x4000000000000000uLL >> __clz(__rbit64(v12));
  BOOL v23 = v21 < v15 && v18 > v14 && (v18 | v21) > v15;
  if (v23 && ((v18 - v14) | v21) >= v15)
  {
LABEL_28:
    unint64_t v25 = a5[5];
    uint64_t v26 = *a1;
    uint64_t v27 = a1[1];
    if (v25) {
      unsigned int v28 = 3;
    }
    else {
      unsigned int v28 = 13;
    }
    if (v25) {
      unsigned int v29 = v13;
    }
    else {
      unsigned int v29 = 0;
    }
    sub_10003D570(v10, v15, v14, v25, 0, v26, v27, v28, v29, 5u);
    return 0LL;
  }

  sub_100040B90("omap entry (oid 0x%llx): invalid ov_range (0x%llx+%llu)\n", v15, v14, a4, (uint64_t)a5, a6, a7, a8, *a1);
  uint64_t v24 = 92LL;
  sub_100044E7C((char *)0x4D7, 92);
  return v24;
}

uint64_t sub_1000220E8(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5, int a6)
{
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v41[2] = v10;
  v41[3] = v10;
  v41[0] = v10;
  v41[1] = v10;
  v39[2] = v10;
  v39[3] = v10;
  v39[0] = v10;
  v39[1] = v10;
  __int128 v11 = a3[1];
  __int128 v34 = *a3;
  unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
  memset(v37, 170, 20);
  v33[0] = a1;
  v33[1] = a2;
  uint64_t v33[2] = a4;
  __int128 v35 = v11;
  uint64_t v36 = *((void *)a3 + 4);
  uint64_t v12 = sub_100034B44( (uint64_t)v41,  a1,  a2,  a6 & 0xC0000000,  (unsigned __int16)a6,  15,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  0,  0,  0,  a5,  (uint64_t)sub_10003A6AC);
  if ((_DWORD)v12)
  {
    uint64_t v13 = v12;
    strerror(v12);
    sub_100040B90("Could not initialize extentref tree (oid 0x%llx): %s\n", v14, v15, v16, v17, v18, v19, v20, a5);
    uint64_t v21 = 548LL;
  }

  else
  {
    uint64_t v38 = 0LL;
    uint64_t v13 = sub_100035394((uint64_t)v39, (uint64_t)v41, 0LL, &v38, 8u, 0x340u, v37, 20);
    if (!(_DWORD)v13)
    {
      uint64_t v13 = sub_10002930C( (uint64_t)v39,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000223CC,  (uint64_t)v33,  0);
      if (!(_DWORD)v13)
      {
        *((_DWORD *)a3 + 2) = a6;
        *((_DWORD *)a3 + 3) = *(_DWORD *)(*(void *)(a1 + 8) + 36LL);
        *((void *)a3 + 3) = a5;
        *((void *)a3 + 4) = 0LL;
        __int128 v30 = a3[1];
        v31[0] = *a3;
        v31[1] = v30;
        uint64_t v32 = 0LL;
        return sub_100020C50(a1, 0LL, v31, 0LL);
      }
    }

    strerror(v13);
    sub_100040B90( "Could not iterate extentref tree to read reaper objects(oid 0x%llx): %s\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  a5);
    uint64_t v21 = 568LL;
  }

  sub_100044E7C((char *)v21, v13);
  return v13;
}

uint64_t sub_100022280(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a1;
  uint64_t v9 = *(void *)a5;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v11 = *(void *)a3;
  int v12 = *(_DWORD *)(a3 + 40);
  __int128 v13 = *(_OWORD *)(a5 + 40);
  v33[0] = *(_OWORD *)(a5 + 24);
  v33[1] = v13;
  uint64_t v34 = *(void *)(a5 + 56);
  uint64_t v20 = sub_1000220E8(v9, v10, v33, v5 & 0xFFFFFFFFFFFFFFFLL, v11, v12);
  if (!(_DWORD)v20)
  {
    unint64_t v21 = *(void *)(a3 + 8);
    uint64_t v22 = *(void *)(*(void *)a5 + 8LL);
    uint64_t v23 = *(void *)(*(void *)a5 + 24LL);
    if (v23)
    {
      unint64_t v24 = *(void *)(v23 + 48);
      unint64_t v25 = *(void *)(v23 + 96);
    }

    else
    {
      unint64_t v24 = *(void *)(v22 + 40);
      if ((*(_BYTE *)(v22 + 65) & 1) != 0) {
        unint64_t v25 = *(void *)(v22 + 40);
      }
      else {
        unint64_t v25 = 0LL;
      }
    }

    unint64_t v26 = *(unsigned int *)(v22 + 36);
    if (v21 && (v24 >= 2 ? (BOOL v27 = v24 > v21) : (BOOL v27 = 0), v27 ? (v28 = v24 - 1 >= v21) : (v28 = 0), v28)
      || ((unint64_t v29 = 0x4000000000000000uLL >> __clz(__rbit64(v26)), v29 < v21) ? (v30 = v25 >= 2) : (v30 = 0),
          v30 ? (BOOL v31 = (v25 | v29) > v21) : (BOOL v31 = 0),
          v31 && ((v25 - 1) | v29) >= v21))
    {
      sub_10003D570( *(void *)a5,  v21,  1LL,  *(void *)(a5 + 40),  0x40000000,  v21,  *a1 & 0xFFFFFFFFFFFFFFFLL,  0xDu,  0,  5u);
      return 0LL;
    }

    sub_100040B90("invalid sblock_oid (%llu)\n", v21, v14, v15, v16, v17, v18, v19, *(void *)(a3 + 8));
    uint64_t v20 = 92LL;
    sub_100044E7C((char *)0x4D9, 92);
  }

  return v20;
}

uint64_t sub_1000223CC( char *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 >> 60 != 1LL) {
    return 0LL;
  }
  unint64_t v8 = *(void *)a1 & 0xFFFFFFFFFFFFFFFLL;
  unint64_t v9 = *a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v10 = *(void *)(*(void *)a5 + 8LL);
  uint64_t v11 = *(void *)(*(void *)a5 + 24LL);
  if (v11)
  {
    unint64_t v12 = *(void *)(v11 + 48);
    unint64_t v13 = *(void *)(v11 + 96);
  }

  else
  {
    unint64_t v12 = *(void *)(v10 + 40);
    if ((*(_BYTE *)(v10 + 65) & 1) != 0) {
      unint64_t v13 = *(void *)(v10 + 40);
    }
    else {
      unint64_t v13 = 0LL;
    }
  }

  unint64_t v14 = *(unsigned int *)(v10 + 36);
  if (v8 && (v12 > v9 ? (BOOL v15 = v12 > v8) : (BOOL v15 = 0), v15 ? (v16 = v12 - v9 >= v8) : (v16 = 0), v16)
    || ((unint64_t v17 = 0x4000000000000000uLL >> __clz(__rbit64(v14)), v17 < v8) ? (v18 = v13 > v9) : (v18 = 0),
        v18 ? (BOOL v19 = (v13 | v17) > v8) : (BOOL v19 = 0),
        v19 && ((v13 - v9) | v17) >= v8))
  {
    sub_10003D570(*(void *)a5, v8, v9, *(void *)(a5 + 40), 0x40000000, v8, *(void *)(a5 + 16), 0, 0xFu, 6u);
    return 0LL;
  }

  sub_100040B90( "invalid extent address range (0x%llx+%llu)\n",  *(void *)a1 & 0xFFFFFFFFFFFFFFFLL,  v9,  a4,  a5,  a6,  a7,  a8,  *a1);
  uint64_t v20 = 92LL;
  sub_100044E7C((char *)0x4D8, 92);
  return v20;
}

uint64_t sub_1000224D4( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(void *)a3 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v9 = *(void *)(*(void *)a5 + 8LL);
  uint64_t v10 = *(void *)(*(void *)a5 + 24LL);
  if (v10)
  {
    unint64_t v11 = *(void *)(v10 + 48);
    unint64_t v12 = *(void *)(v10 + 96);
  }

  else
  {
    unint64_t v11 = *(void *)(v9 + 40);
    if ((*(_BYTE *)(v9 + 65) & 1) != 0) {
      unint64_t v12 = *(void *)(v9 + 40);
    }
    else {
      unint64_t v12 = 0LL;
    }
  }

  unint64_t v13 = *(unsigned int *)(v9 + 36);
  if (v8 && (v11 >= 2 ? (BOOL v14 = v11 > v8) : (BOOL v14 = 0), v14 ? (v15 = v11 - 1 >= v8) : (v15 = 0), v15)
    || ((unint64_t v16 = 0x4000000000000000uLL >> __clz(__rbit64(v13)), v16 < v8) ? (v17 = v12 >= 2) : (v17 = 0),
        v17 ? (BOOL v18 = (v12 | v16) > v8) : (BOOL v18 = 0),
        v18 && ((v12 - 1) | v16) >= v8))
  {
    sub_10003D570(*(void *)a5, v8, 1LL, *(void *)(a5 + 40), 0x40000000, v8, 0LL, 0x1Bu, 0, 5u);
    return 0LL;
  }

  else
  {
    sub_100040B90("invalid gbitmap block oid 0x%llx\n", v8, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
    uint64_t v19 = 92LL;
    sub_100044E7C((char *)0x4DA, 92);
  }

  return v19;
}

uint64_t sub_1000225C8( uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9)
{
  char v11 = a4;
  unsigned int v13 = *(_DWORD *)(a1[1] + 36);
  __int128 v108 = 0uLL;
  uint64_t v109 = 0LL;
  if (a3 == 0x80000000)
  {
    uint64_t v14 = sub_10002DA58(a1, a4, a6, a7, (uint64_t)&v108);
    if ((_DWORD)v14)
    {
      uint64_t v15 = v14;
      sub_1000229C0(a7, a8);
      strerror(v15);
      sub_100040B90("(oid 0x%llx) %s: _xp_lookup_obj(0x%llx): %s\n", v16, v17, v18, v19, v20, v21, v22, v11);
      uint64_t v23 = 341LL;
LABEL_10:
      int v33 = v15;
LABEL_38:
      sub_100044E7C((char *)v23, v33);
      return v15;
    }

LABEL_34:
    if (DWORD2(v108) && (unint64_t v82 = DWORD2(v108) / v13, !(DWORD2(v108) % v13)))
    {
      uint64_t v91 = a1[1];
      uint64_t v92 = a1[3];
      if (v92)
      {
        unint64_t v93 = *(void *)(v92 + 48);
        unint64_t v94 = *(void *)(v92 + 96);
      }

      else
      {
        unint64_t v93 = *(void *)(v91 + 40);
        if ((*(_BYTE *)(v91 + 65) & 1) != 0) {
          unint64_t v94 = *(void *)(v91 + 40);
        }
        else {
          unint64_t v94 = 0LL;
        }
      }

      unint64_t v95 = *(unsigned int *)(v91 + 36);
      if ((void)v108
        && (v93 > v82 ? (BOOL v96 = v93 > (unint64_t)v108) : (BOOL v96 = 0),
            v96 ? (BOOL v97 = v93 - v82 >= (unint64_t)v108) : (BOOL v97 = 0),
            v97)
        || ((unint64_t v98 = 0x4000000000000000uLL >> __clz(__rbit64(v95)), v98 < (unint64_t)v108)
          ? (BOOL v99 = v94 > v82)
          : (BOOL v99 = 0),
            v99 ? (BOOL v100 = (v94 | v98) > (unint64_t)v108) : (BOOL v100 = 0),
            v100 && ((v94 - v82) | v98) >= (unint64_t)v108))
      {
        uint64_t v15 = 0LL;
        *(_OWORD *)a9 = v108;
        *(void *)(a9 + --*(_DWORD *)(result + 16) = v109;
        return v15;
      }

      sub_1000229C0(a7, a8);
      sub_100040B90("(oid 0x%llx) %s: invalid object address (0x%llx)\n", v101, v102, v103, v104, v105, v106, v107, v11);
      uint64_t v15 = 92LL;
      uint64_t v23 = 346LL;
    }

    else
    {
      sub_1000229C0(a7, a8);
      sub_100040B90("(oid 0x%llx) %s: invalid object size (0x%x)\n", v83, v84, v85, v86, v87, v88, v89, v11);
      uint64_t v15 = 92LL;
      uint64_t v23 = 345LL;
    }

    int v33 = 92;
    goto LABEL_38;
  }

  if (a3 == 0x40000000)
  {
    *(void *)&__int128 v108 = a4;
    DWORD2(v108) = v13;
    goto LABEL_34;
  }

  uint64_t v25 = sub_10001E038(a1, a2, a4, a5, &v108);
  if (!(_DWORD)v25)
  {
    __int16 v34 = WORD6(v108);
    if (HIDWORD(v108) >= 0x800)
    {
      sub_1000229C0(a7, a8);
      sub_100040C68("(oid 0x%llx) %s: invalid ov_flags (0x%x)\n", v35, v36, v37, v38, v39, v40, v41, v11);
      sub_100044E7C((char *)0x1DF, -3);
      __int16 v34 = WORD6(v108);
    }

    if ((v34 & 4) == 0 && (v34 & 0xE0) != 0)
    {
      sub_1000229C0(a7, a8);
      sub_100040C68( "(oid 0x%llx) %s: invalid ov_flags (0x%x), crypto key index set for unencrypted object\n",  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v11);
      sub_100044E7C((char *)0x481, -3);
      __int16 v34 = WORD6(v108);
    }

    if ((v34 & 4) == 0 && (v34 & 0x700) != 0)
    {
      sub_1000229C0(a7, a8);
      sub_100040C68( "(oid 0x%llx) %s: invalid ov_flags (0x%x), tweak type set for unencrypted object\n",  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v11);
      sub_100044E7C((char *)0x4D0, -3);
    }

    if (!a2)
    {
      if ((BYTE12(v108) & 4) == 0) {
        goto LABEL_34;
      }
      sub_1000229C0(a7, a8);
      sub_100040C68( "(oid 0x%llx) %s: invalid encryption type ov_flags (0x%x)\n",  v60,  v61,  v62,  v63,  v64,  v65,  v66,  v11);
      uint64_t v67 = 480LL;
      goto LABEL_33;
    }

    uint64_t v56 = *(void *)(a2 + 40);
    uint64_t v57 = *(void *)(v56 + 264);
    if ((BYTE12(v108) & 4) != 0)
    {
      if ((v57 & 1) == 0 || *(void *)(v56 + 976)) {
        goto LABEL_30;
      }
      uint64_t v58 = 854LL;
      __int128 v59 = "(oid 0x%llx) %s: should not be encrypted (ov_flags 0x%x)\n";
    }

    else
    {
      if ((v57 & 1) != 0 || *(void *)(v56 + 976)) {
        goto LABEL_30;
      }
      uint64_t v58 = 855LL;
      __int128 v59 = "(oid 0x%llx) %s: should be encrypted (ov_flags 0x%x)\n";
    }

    sub_1000229C0(a7, a8);
    sub_100040C68(v59, v68, v69, v70, v71, v72, v73, v74, v11);
    sub_100044E7C((char *)v58, -3);
LABEL_30:
    if ((BYTE12(v108) & 4) == 0 || BYTE12(v108) >> 5 == (a8 == 36)) {
      goto LABEL_34;
    }
    sub_1000229C0(a7, a8);
    sub_100040C68( "(oid 0x%llx) %s: invalid crypto key index (%u) given obj_subtype\n",  v75,  v76,  v77,  v78,  v79,  v80,  v81,  v11);
    uint64_t v67 = 1201LL;
LABEL_33:
    sub_100044E7C((char *)v67, -3);
    goto LABEL_34;
  }

  uint64_t v15 = v25;
  if (a7 != 29 || (_DWORD)v25 != 2)
  {
    sub_1000229C0(a7, a8);
    strerror(v15);
    sub_100040B90("(oid 0x%llx) %s: _omap_lookup_obj(0x%llx, 0x%llx): %s\n", v26, v27, v28, v29, v30, v31, v32, v11);
    uint64_t v23 = 344LL;
    goto LABEL_10;
  }

  return v15;
}

      uint64_t v25 = 92LL;
    }

const char *sub_1000229C0(int a1, int a2)
{
  uint64_t v2 = "nx";
  switch(a1)
  {
    case 1:
      return v2;
    case 2:
    case 3:
      __int128 v3 = "extent_list: ";
      switch(a2)
      {
        case 10:
          break;
        case 11:
          __int128 v3 = "om: ";
          break;
        case 12:
        case 13:
        case 17:
        case 18:
        case 20:
        case 22:
        case 23:
        case 24:
        case 25:
          goto LABEL_25;
        case 14:
          __int128 v3 = "apfs_root: ";
          break;
        case 15:
          __int128 v3 = "apfs_extentref: ";
          break;
        case 16:
          __int128 v3 = "apfs_snap_meta: ";
          break;
        case 19:
          __int128 v3 = "oms: ";
          break;
        case 21:
          __int128 v3 = "fusion_mid_tree: ";
          break;
        case 26:
          __int128 v3 = "gbitmap: ";
          break;
        default:
          if (a2 == 33)
          {
            __int128 v3 = "evict_mapping_tree: ";
          }

          else if (a2 == 36)
          {
            __int128 v3 = "apfs_sec_root: ";
          }

          else
          {
LABEL_25:
            __int128 v3 = "";
          }

          break;
      }

      uint64_t v4 = "btn";
      if (a1 == 2) {
        uint64_t v4 = "bt";
      }
      uint64_t v2 = byte_10008C8D8;
      snprintf(byte_10008C8D8, 0x28uLL, "%s%s", v3, v4);
      break;
    case 5:
      uint64_t v2 = "sm";
      break;
    case 6:
      uint64_t v2 = "cab";
      break;
    case 7:
      uint64_t v2 = "cib";
      break;
    case 8:
      uint64_t v2 = "sm_ip";
      break;
    case 11:
      uint64_t v2 = "om";
      break;
    case 12:
      uint64_t v2 = "cpm";
      break;
    case 13:
      uint64_t v2 = "apfs";
      break;
    case 15:
      uint64_t v2 = "extent";
      break;
    case 17:
      uint64_t v2 = "nr";
      break;
    case 18:
      uint64_t v2 = "nrl";
      break;
    case 20:
      uint64_t v2 = "efi_jumpstart";
      break;
    case 22:
      uint64_t v2 = "wbc";
      break;
    case 23:
      uint64_t v2 = "wbcl";
      break;
    case 24:
      uint64_t v2 = "er_state";
      break;
    case 25:
      uint64_t v2 = "gbitmap";
      break;
    case 27:
      uint64_t v2 = "gbitmap_blk";
      break;
    case 29:
      uint64_t v2 = "snap_meta_ext";
      break;
    default:
      uint64_t v2 = "?";
      break;
  }

  return v2;
}

uint64_t sub_100022BD0( uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, unsigned int a8, uint64_t **a9, uint64_t a10, char a11)
{
  if (a9) {
    return sub_100022C10(a1, a2, a3, a4, a5, a6, a7, a8, 0LL, a9, a10, a11);
  }
  else {
    return 22LL;
  }
}

uint64_t sub_100022C10( uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, unsigned int a8, uint64_t a9, uint64_t **a10, uint64_t a11, char a12)
{
  unsigned int v12 = a7;
  unint64_t v15 = a4;
  int v16 = a3;
  unsigned int v17 = *(_DWORD *)(a1[1] + 36);
  __int128 v383 = 0uLL;
  unint64_t v384 = 0LL;
  if (a9 && a10)
  {
    uint64_t v371 = a5;
    __int128 v383 = *(_OWORD *)(a9 + 144);
    uint64_t v18 = *(uint64_t **)(a9 + 168);
    unint64_t v384 = *(void *)(a9 + 160);
  }

  else
  {
    unint64_t v24 = a1;
    uint64_t v25 = sub_1000225C8(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t)&v383);
    if ((_DWORD)v25) {
      return v25;
    }
    uint64_t v371 = a5;
    uint64_t v18 = (uint64_t *)malloc(DWORD2(v383));
    a1 = v24;
    if (!v18)
    {
      sub_1000229C0(v12, a8);
      sub_100040B90("(oid 0x%llx) %s: malloc(%u)\n", v26, v27, v28, v29, v30, v31, v32, v15);
      uint64_t v25 = 12LL;
      sub_100044E7C((char *)0x15B, 12);
      return v25;
    }
  }

  v379 = a1;
  unint64_t v19 = v384;
  uint64_t v20 = *a1;
  if ((BYTE12(v383) & 4) == 0)
  {
    unsigned int v21 = HIDWORD(v383);
    unint64_t v22 = 0LL;
    int v23 = 0;
    goto LABEL_25;
  }

  if ((WORD6(v383) & 0x700) == 0x100) {
    unint64_t v22 = v15 ^ HIDWORD(v384) | v15 & 0xFFFFFFFF00000000LL ^ (v384 << 32);
  }
  else {
    unint64_t v22 = 0LL;
  }
  if ((WORD6(v383) & 0x700) == 0x100) {
    int v23 = 4;
  }
  else {
    int v23 = 0;
  }
  if (!a2)
  {
    unsigned int v21 = HIDWORD(v383);
LABEL_25:
    uint64_t v34 = 0LL;
    if (a9) {
      goto LABEL_26;
    }
LABEL_22:
    uint64_t v372 = DWORD2(v383);
    uint64_t v377 = v383;
    uint64_t v35 = sub_10002BF50(v20, v383, DWORD2(v383) / v17, (uint64_t)v18, v34, 0, 0LL, v22, v23);
    if ((_DWORD)v35)
    {
      uint64_t v25 = v35;
LABEL_31:
      sub_1000229C0(v12, a8);
      strerror(v25);
      sub_100040B90("(oid 0x%llx) %s: %s(%llu, %u): %s\n", v40, v41, v42, v43, v44, v45, v46, v15);
      sub_100044E7C((char *)0x15C, v25);
LABEL_32:
      if (!(_DWORD)v25 || !v18) {
        goto LABEL_232;
      }
      free(v18);
      return v25;
    }

    if (a10) {
      goto LABEL_37;
    }
LABEL_41:
    uint64_t v25 = 0LL;
    *(_OWORD *)(a9 + 144) = v383;
    *(void *)(a9 + 160) = v384;
    *(void *)(a9 + 168) = v18;
    return v25;
  }

  unsigned int v21 = HIDWORD(v383);
  uint64_t v33 = *(void *)(a2 + 8LL * (BYTE12(v383) >> 5) + 24);
  if (v33) {
    uint64_t v34 = a2 + 96LL * (BYTE12(v383) >> 5) + 768;
  }
  else {
    uint64_t v34 = 0LL;
  }
  if (v33) {
    uint64_t v20 = *(void *)(a2 + 8LL * (BYTE12(v383) >> 5) + 24);
  }
  if (!a9) {
    goto LABEL_22;
  }
LABEL_26:
  if (!a10)
  {
    uint64_t v39 = sub_10002BF50(v20, v383, DWORD2(v383) / v17, (uint64_t)v18, v34, 1, a9, v22, v23);
    if ((_DWORD)v39)
    {
      uint64_t v25 = v39;
      goto LABEL_31;
    }

    goto LABEL_41;
  }

  uint64_t v38 = sub_10002BFD0(v20);
  uint64_t v377 = v383;
  if ((_DWORD)v38)
  {
    uint64_t v25 = v38;
    goto LABEL_31;
  }

  uint64_t v372 = DWORD2(v383);
LABEL_37:
  if (a2)
  {
    uint64_t v47 = *(void *)(a2 + 40);
    BOOL v48 = (*(_BYTE *)(v47 + 264) & 1) == 0;
    BOOL v49 = *(void *)(v47 + 976) == 0LL;
    if (*(void *)(v47 + 976)) {
      BOOL v48 = 1;
    }
    LODWORD(v369) = *(void *)(v47 + 1096) != 0LL;
    HIDWORD(v369) = v48;
  }

  else
  {
    uint64_t v369 = 0LL;
    BOOL v49 = 1;
  }

  unsigned int v50 = v21;
  uint64_t v51 = v372;
  int v375 = v16;
  if ((a6 & 0x20000000) != 0) {
    goto LABEL_218;
  }
  BOOL v357 = v49;
  int v363 = 0;
  int v376 = 0;
  int v360 = 0;
  int v374 = 0;
  int v366 = (v50 & 4) != 0;
  int v378 = v50 >> 5;
  unint64_t v52 = v19;
  int v53 = a6 | ((v50 & 4) << 26);
  uint64_t v54 = (uint32x4_t *)(v18 + 1);
  int v55 = a8;
  unint64_t v368 = (v372 - 8);
  uint64_t v367 = (8 * v372);
  unint64_t v56 = v372 - 8LL;
  unint64_t v373 = v52;
  uint64_t v361 = 8LL * v372;
  unint64_t v362 = v15 ^ HIDWORD(v52) | v15 & 0xFFFFFFFF00000000LL ^ (v52 << 32);
  unint64_t v365 = v56;
LABEL_45:
  int v364 = v53;
  while (1)
  {
    unint64_t v382 = sub_10003A224(v18, v54, v368, 0LL, v36, v37);
    if (v382)
    {
      sub_1000229C0(v12, v55);
      sub_100040C68("(oid 0x%llx) %s: invalid o_cksum (0x%llx)\n", v57, v58, v59, v60, v61, v62, v63, v15);
      sub_100044E7C((char *)0x15E, 92);
    }

    if (sub_100007F14((uint64_t)v18, 0LL, v367))
    {
      sub_1000229C0(v12, v55);
      sub_100040B90("(oid 0x%llx) %s: found zeroed-out block\n", v233, v234, v235, v236, v237, v238, v239, v15);
      uint64_t v25 = 92LL;
      uint64_t v240 = 845LL;
      int v241 = 92;
LABEL_217:
      sub_100044E7C((char *)v240, v241);
      goto LABEL_227;
    }

    uint64_t v66 = v54->i64[0];
    if (v54->i64[0] == v15)
    {
      unsigned int v67 = 0;
      int v68 = v376;
    }

    else
    {
      int v69 = v376;
      if (!v382)
      {
        sub_1000229C0(v12, v55);
        sub_100040B90("(oid 0x%llx) %s: invalid o_oid (0x%llx)\n", v70, v71, v72, v73, v74, v75, v76, v15);
        sub_100044E7C((char *)0x15F, 92);
        int v69 = v376;
        uint64_t v66 = v54->i64[0];
      }

      *(int8x8_t *)v64.i8 = vcnt_s8((int8x8_t)(v66 ^ v15));
      v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
      int v68 = v69 + v64.i32[0];
      unsigned int v67 = 92;
    }

    unint64_t v77 = v18[2];
    if (v77)
    {
      unint64_t v78 = *(void *)(v379[1] + 16);
      if (v77 <= v78) {
        uint64_t v25 = v67;
      }
      else {
        uint64_t v25 = 92LL;
      }
      if (!v382 && v77 > v78)
      {
LABEL_63:
        uint64_t v79 = v51;
        int v80 = v68;
        sub_1000229C0(v12, v55);
        sub_100040B90("(oid 0x%llx) %s: invalid o_xid (0x%llx)\n", v81, v82, v83, v84, v85, v86, v87, v15);
        uint64_t v25 = 92LL;
        sub_100044E7C((char *)0x160, 92);
        int v68 = v80;
        uint64_t v51 = v79;
        uint64_t v54 = (uint32x4_t *)(v18 + 1);
      }
    }

    else
    {
      if (!v382) {
        goto LABEL_63;
      }
      uint64_t v25 = 92LL;
    }

    if (v373)
    {
      uint64_t v88 = v18[2];
      if (v88 != v373)
      {
        if (!v382)
        {
          uint64_t v89 = v51;
          int v90 = v68;
          sub_1000229C0(v12, v55);
          sub_100040B90( "(oid 0x%llx) %s: invalid o_xid (0x%llx, expected 0x%llx)\n",  v91,  v92,  v93,  v94,  v95,  v96,  v97,  v15);
          sub_100044E7C((char *)0x371, 92);
          int v68 = v90;
          uint64_t v51 = v89;
          uint64_t v54 = (uint32x4_t *)(v18 + 1);
          uint64_t v88 = v18[2];
        }

        *(int8x8_t *)v64.i8 = vcnt_s8((int8x8_t)(v88 ^ v373));
        v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
        v68 += v64.i32[0];
        uint64_t v25 = 92LL;
      }
    }

    if (v12)
    {
      int v98 = *((unsigned __int16 *)v18 + 12);
      if (v98 != v12)
      {
        if (!v382)
        {
          uint64_t v99 = v51;
          int v100 = v68;
          sub_1000229C0(v12, v55);
          sub_100040B90( "(oid 0x%llx) %s: invalid o_type (0x%x, expected 0x%x)\n",  v101,  v102,  v103,  v104,  v105,  v106,  v107,  v15);
          sub_100044E7C((char *)0x161, 92);
          int v68 = v100;
          uint64_t v51 = v99;
          uint64_t v54 = (uint32x4_t *)(v18 + 1);
          int v98 = *((unsigned __int16 *)v18 + 12);
        }

        v64.i32[0] = v98 ^ v12;
        *(int8x8_t *)v64.i8 = vcnt_s8(*(int8x8_t *)v64.i8);
        v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
        v68 += v64.i32[0];
        uint64_t v25 = 92LL;
      }
    }

    if (v55)
    {
      int v108 = *((_DWORD *)v18 + 7);
      if (v108 != v55)
      {
        if (v382)
        {
          v64.i32[0] = (unsigned __int16)*((_DWORD *)v18 + 7) ^ v55;
          *(int8x8_t *)v64.i8 = vcnt_s8(*(int8x8_t *)v64.i8);
          v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
          v68 += v64.i32[0];
          int v109 = *((_DWORD *)v18 + 6);
          if ((v109 & 0xC0000000) == v375) {
            goto LABEL_90;
          }
          goto LABEL_89;
        }

        uint64_t v372 = v51;
        int v110 = v68;
        if (v55 != 33 || v108)
        {
          sub_1000229C0(v12, v55);
          sub_100040B90( "(oid 0x%llx) %s: invalid o_subtype (0x%x, expected 0x%x)\n",  v124,  v125,  v126,  v127,  v128,  v129,  v130,  v15);
          uint64_t v25 = 92LL;
          sub_100044E7C((char *)0x164, 92);
          v64.i32[0] = *((unsigned __int16 *)v18 + 14) ^ v55;
          *(int8x8_t *)v64.i8 = vcnt_s8(*(int8x8_t *)v64.i8);
          v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
          int v68 = v64.i32[0] + v110;
        }

        else
        {
          sub_1000229C0(v12, 33);
          sub_100040C68( "(oid 0x%llx) %s: using old subtype (0x%x, expected 0x%x)\n",  v111,  v112,  v113,  v114,  v115,  v116,  v117,  v15);
          if (!(_DWORD)v25) {
            v363 |= sub_1000428C4( qword_10008DB70,  "Fix object (oid 0x%llx) subtype? ",  v118,  v119,  v120,  v121,  v122,  v123,  v15) != 0;
          }
          int v68 = v110;
        }

        uint64_t v51 = v372;
      }
    }

    int v109 = *((_DWORD *)v18 + 6);
    if ((v109 & 0xC0000000) == v375) {
      goto LABEL_91;
    }
    if (!v382)
    {
      uint64_t v131 = v51;
      int v132 = v68;
      sub_1000229C0(v12, v55);
      sub_100040B90( "(oid 0x%llx) %s: invalid o_type (0x%x, expected 0x%x)\n",  v133,  v134,  v135,  v136,  v137,  v138,  v139,  v15);
      sub_100044E7C((char *)0x162, 92);
      int v68 = v132;
      uint64_t v51 = v131;
      uint64_t v54 = (uint32x4_t *)(v18 + 1);
      int v109 = *((_DWORD *)v18 + 6);
    }

LABEL_89:
    v64.i32[0] = *((_DWORD *)v18 + 7) & 0xC0000000 ^ v375;
    *(int8x8_t *)v64.i8 = vcnt_s8(*(int8x8_t *)v64.i8);
    v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
    v68 += v64.i32[0];
LABEL_90:
    uint64_t v25 = 92LL;
LABEL_91:
    int v140 = v109 & 0x3FFF0000;
    if (v140 != v53)
    {
      if (v382 && (_DWORD)v25) {
        goto LABEL_96;
      }
      uint64_t v141 = v51;
      int v142 = v68;
      sub_1000229C0(v12, v55);
      sub_100040B90( "(oid 0x%llx) %s: invalid o_type (0x%x, expected 0x%x)\n",  v143,  v144,  v145,  v146,  v147,  v148,  v149,  v15);
      sub_100044E7C((char *)0x163, 92);
      if ((_DWORD)v25)
      {
        int v140 = v18[3] & 0x3FFF0000;
        int v68 = v142;
        uint64_t v51 = v141;
        uint64_t v54 = (uint32x4_t *)(v18 + 1);
LABEL_96:
        v64.i32[0] = v140 ^ v53;
        *(int8x8_t *)v64.i8 = vcnt_s8(*(int8x8_t *)v64.i8);
        v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
        v68 += v64.i32[0];
        goto LABEL_97;
      }

      int v211 = sub_1000428C4(qword_10008DB70, "Fix object (oid 0x%llx) flags? ", v150, v151, v152, v153, v154, v155, v15);
      if (v211) {
        uint64_t v25 = 0LL;
      }
      else {
        uint64_t v25 = 92LL;
      }
      v363 |= v211 != 0;
      int v68 = v142;
      uint64_t v51 = v141;
      uint64_t v54 = (uint32x4_t *)(v18 + 1);
    }

LABEL_97:
    int v376 = v68;
    if (v55)
    {
      if (v12 && v68 == 1) {
        break;
      }
    }

    if (!v382)
    {
LABEL_168:
      if ((_DWORD)v25) {
        goto LABEL_227;
      }
      goto LABEL_173;
    }

    if (v68)
    {
      uint64_t v175 = 1005LL;
      goto LABEL_109;
    }

    uint64_t v385 = 0LL;
    if (!(_DWORD)v51)
    {
      uint64_t v175 = 1004LL;
      goto LABEL_109;
    }

    int v359 = v12;
    unsigned int v370 = v50;
    unint64_t v358 = v15;
    uint64_t v184 = 0LL;
    int v185 = 0;
    LODWORD(v186) = -1431655766;
    __int128 v187 = v54;
    do
    {
      uint64_t v188 = v184 >> 3;
      int v189 = 1 << (v184 & 7);
      *((_BYTE *)v18 + v188) ^= v189;
      uint64_t v190 = *v18;
      sub_10003A1B8((unint64_t *)&v385, v187, v56, 0LL, v64, v65);
      if (v190 == v385) {
        unint64_t v186 = v184;
      }
      else {
        unint64_t v186 = v186;
      }
      if (v190 == v385) {
        ++v185;
      }
      *((_BYTE *)v18 + v188) ^= v189;
      ++v184;
    }

    while (v361 != v184);
    unsigned int v12 = v359;
    if (!v185)
    {
      uint64_t v175 = 1004LL;
      unint64_t v15 = v358;
      int v55 = a8;
      unsigned int v50 = v370;
      uint64_t v54 = (uint32x4_t *)(v18 + 1);
      uint64_t v51 = v372;
      int v53 = v364;
      uint64_t v25 = v25;
      goto LABEL_109;
    }

    int v55 = a8;
    uint64_t v54 = (uint32x4_t *)(v18 + 1);
    uint64_t v25 = v25;
    if (v185 != 1)
    {
      sub_1000229C0(v359, a8);
      unint64_t v15 = v358;
      sub_100040B90( "(oid 0x%llx) %s: could not repair object to match checksum: too many bit flip candidates (%d)\n",  v212,  v213,  v214,  v215,  v216,  v217,  v218,  v358);
      uint64_t v175 = 1003LL;
      unsigned int v50 = v370;
      uint64_t v51 = v372;
      int v53 = v364;
LABEL_109:
      sub_100044E7C((char *)v175, 92);
      if (!(_DWORD)v25) {
        goto LABEL_171;
      }
      goto LABEL_110;
    }

    sub_1000229C0(v359, a8);
    unint64_t v15 = v358;
    sub_100040B90("(oid 0x%llx) %s: found a bit flip at index 0x%x\n", v191, v192, v193, v194, v195, v196, v197, v358);
    uint64_t v25 = 92LL;
    sub_100044E7C((char *)0x3EA, 92);
    uint64_t v51 = v372;
    if (sub_1000428C4( qword_10008DB70,  "Fix object (oid 0x%llx) bit flip? ",  v198,  v199,  v200,  v201,  v202,  v203,  v358))
    {
      LOBYTE(v363) = 1;
      *((_BYTE *)v18 + (v186 >> 3)) ^= 1 << (v186 & 7);
      unsigned int v50 = v370;
      goto LABEL_173;
    }

LABEL_190:
    v50 |= 32 * (*(void *)(*(void *)(a2 + 40) + 1096LL) != 0LL);
    goto LABEL_191;
  }

  sub_100040B90("(oid 0x%llx) %s: object is %s but omap says it's %s\n", v302, v303, v304, v305, v306, v307, v308, v15);
  uint64_t v25 = 92LL;
  sub_100044E7C((char *)0x373, 92);
  int v356 = sub_1000428C4(qword_10008DB70, "Fix object (oid 0x%llx) omap flags? ", v350, v351, v352, v353, v354, v355, v15);
  char v288 = v363;
  if (v356)
  {
    BOOL v259 = 1;
    int v16 = v375;
LABEL_206:
    unsigned int v316 = v12;
    if (!v12) {
      unsigned int v316 = *((unsigned __int16 *)v18 + 12);
    }
    unsigned int v317 = a8;
    if (!a8) {
      unsigned int v317 = *((_DWORD *)v18 + 7);
    }
    if ((v288 & 1) != 0)
    {
      *((_DWORD *)v18 + 6) = v364 | v316 | v16;
      *((_DWORD *)v18 + 7) = v317;
      uint64_t v385 = v377;
      int v386 = v51;
      unsigned int v387 = v50;
      unint64_t v388 = v244;
      uint64_t v318 = sub_100023FA8(v379, a2, (uint64_t)v18, (uint64_t)&v385, v64, v65);
      if ((_DWORD)v318)
      {
        uint64_t v25 = v318;
        char v319 = strerror(v318);
        sub_100040B90("error writing object: %s\n", v320, v321, v322, v323, v324, v325, v326, v319);
        uint64_t v240 = 880LL;
LABEL_216:
        int v241 = v25;
        goto LABEL_217;
      }
    }

    if (v259)
    {
      uint64_t v327 = v18[1];
      uint64_t v328 = v18[2];
      uint64_t v385 = v377;
      int v386 = v51;
      unsigned int v387 = v50;
      unint64_t v388 = v244;
      uint64_t v329 = sub_10001E10C((uint64_t)v379, a2, v327, v328, (int32x2_t *)&v385);
      if ((_DWORD)v329)
      {
        uint64_t v25 = v329;
        char v330 = strerror(v329);
        sub_100040B90("error updating omap entry: %s\n", v331, v332, v333, v334, v335, v336, v337, v330);
        uint64_t v240 = 885LL;
        goto LABEL_216;
      }
    }

LABEL_218:
    uint64_t v25 = 0LL;
    if (v16 && a12)
    {
      if (v12 - 6 >= 3) {
        unsigned int v338 = 1;
      }
      else {
        unsigned int v338 = 9;
      }
      if (a2) {
        unint64_t v339 = *(void *)(*(void *)(a2 + 40) + 8LL);
      }
      else {
        unint64_t v339 = 0LL;
      }
      sub_10003D570( (uint64_t)v379,  v383,  (DWORD2(v383) / *(_DWORD *)(v379[1] + 36)),  v339,  v375,  v15,  v371,  v12,  a8,  v338);
      uint64_t v25 = 0LL;
    }
  }

LABEL_227:
  int v340 = sub_10001CE20(a2 != 0, v15, 1);
  if (v340)
  {
    int v348 = v340;
    sub_100040C68( "object (oid 0x%llx): Unable to mark omap entry in use for omap space verification \n",  v341,  v342,  v343,  v344,  v345,  v346,  v347,  v15);
    sub_100044E7C((char *)0x3D4, v348);
  }

  uint64_t v25 = 0LL;
LABEL_232:
  if (v18)
  {
    *a10 = v18;
    if (a11)
    {
      *(_OWORD *)a11 = v383;
      *(void *)(a11 + --*(_DWORD *)(result + 16) = v384;
    }
  }

  return v25;
}

uint64_t sub_100023F40( uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, unsigned int a8, uint64_t a9)
{
  if (a9) {
    return sub_100022C10(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0LL, 0LL, 0);
  }
  else {
    return 22LL;
  }
}

uint64_t sub_100023F78( uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, unsigned int a8, uint64_t a9, uint64_t **a10, uint64_t a11, char a12)
{
  if (a9) {
    BOOL v12 = a10 == 0LL;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12) {
    return 22LL;
  }
  else {
    return sub_100022C10(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  }
}

uint64_t sub_100023FA8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int8x16_t a5, int8x16_t a6)
{
  int v10 = *(_DWORD *)(a4 + 12);
  uint64_t v11 = *a1;
  if ((v10 & 4) != 0)
  {
    if ((*(_DWORD *)(a4 + 12) & 0x700) == 0x100) {
      int v13 = 4;
    }
    else {
      int v13 = 0;
    }
    if ((*(_DWORD *)(a4 + 12) & 0x700) == 0x100) {
      unint64_t v14 = *(void *)(a3 + 8) ^ HIDWORD(*(void *)(a4 + 16)) | *(void *)(a3 + 8) & 0xFFFFFFFF00000000LL ^ (*(void *)(a4 + 16) << 32);
    }
    else {
      unint64_t v14 = 0LL;
    }
    if (a2)
    {
      uint64_t v15 = v10 >> 5;
      uint64_t v16 = *(void *)(a2 + 8 * v15 + 24);
      uint64_t v17 = a2 + 96LL * v15 + 768;
      if (v16)
      {
        uint64_t v11 = v16;
        uint64_t v12 = v17;
      }

      else
      {
        uint64_t v12 = 0LL;
      }
    }

    else
    {
      uint64_t v12 = 0LL;
    }
  }

  else
  {
    uint64_t v12 = 0LL;
    int v13 = 0;
    unint64_t v14 = 0LL;
  }

  uint64_t v18 = sub_10002C020( v11,  *(void *)a4,  (*(_DWORD *)(a4 + 8) / *(_DWORD *)(a1[1] + 36)),  a3,  v12,  v14,  v13);
  if ((_DWORD)v18)
  {
    uint64_t v19 = *(void *)(a3 + 8);
    sub_1000229C0(*(_DWORD *)(a3 + 24), *(_DWORD *)(a3 + 28));
    strerror(v18);
    sub_100040B90("(oid 0x%llx) %s: dev_write(%llu, %u): %s\n", v20, v21, v22, v23, v24, v25, v26, v19);
    sub_100044E7C((char *)0x166, v18);
  }

  if (a2) {
    *(_BYTE *)(a2 + 12) = 1;
  }
  return v18;
}

uint64_t sub_100024108( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a3;
  *(void *)&__int128 var8 = a2 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
  return sub_100024140(a1, &var8, &v9, 8LL, 17LL, a6, a7, a8);
}

uint64_t sub_100024140( _DWORD *a1, __int128 *a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_1000251C0(a1, 8u, 1, a5, 0, a2, 8u, a3, a4);
  }
  else {
    return sub_100024E94(0LL, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_100024184( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a3;
  *(void *)&__int128 var8 = a2 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
  return sub_100024140(a1, &var8, &v9, 8LL, 18LL, a6, a7, a8);
}

uint64_t sub_1000241BC( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&__int128 var8 = a2;
  char v9 = a3;
  if (a1) {
    return sub_1000251C0(a1, 8u, 1, 0xFu, 0, &var8, 8u, &v9, 1u);
  }
  sub_100024E94(0LL, a2, a3, a4, a5, a6, a7, a8);
  return 0LL;
}

void sub_100024214( uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, BOOL *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)a4 & 0xFFFFFFFFFFFFFFFLL;
  if (v10 != (void)xmmword_10008C900)
  {
    sub_100040C68( "extended attribute (id %llu, name %.*s) is orphan\n",  (uint64_t)a2,  (uint64_t)a3,  a4,  a5,  (uint64_t)a6,  a7,  a8,  *(_BYTE *)a4);
    sub_100044E7C((char *)0x3C1, -2);
    sub_1000246D8(a2, (__int128 *)a4, *(unsigned __int16 *)(a4 + 8) + 10, v33, v34, v35, v36, v37);
    goto LABEL_47;
  }

  unint64_t v14 = (const char *)(a4 + 10);
  size_t v15 = *(unsigned __int16 *)(a4 + 8);
  if (!strncmp((const char *)(a4 + 10), "com.apple.decmpfs", v15) && (dword_10008C944 & 0x40000020) != 0)
  {
    LOBYTE(xmmword_10008C930) = 1;
    unsigned int v38 = *(unsigned __int16 *)(a5 + 2);
    dword_10008C940 = v38;
    if ((*(_WORD *)a5 & 2) != 0)
    {
      if (v38 > 0xF)
      {
        if (*(_DWORD *)(a5 + 4) == 1668116582)
        {
          int v55 = *(_DWORD *)(a5 + 8);
          BYTE8(xmmword_10008C930) = sub_10002471C(v55, v16, v17, v18, v19, v20, v21, v22);
          BYTE9(xmmword_10008C930) = (v55 + 0x7FFFFFFF) < 2;
          HIDWORD(xmmword_10008C930) = v55;
          goto LABEL_47;
        }

        sub_100040C68( "compression xattr (id %llu): compression magic is unknown: 0x%x\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v10);
        uint64_t v31 = 1220LL;
      }

      else
      {
        sub_100040C68( "compression xattr (id %llu): size is too small, actual: %u, minimum: %lu\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v10);
        uint64_t v31 = 1219LL;
      }

      int v39 = 92;
      goto LABEL_46;
    }

    if (!*(_WORD *)a5 || (*(_WORD *)a5 & 1) != 0) {
      goto LABEL_47;
    }
    sub_100040C68( "compression xattr (id %llu): internal flags are invalid (0x%x)\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v10);
    uint64_t v31 = 1221LL;
    goto LABEL_13;
  }

  if (strncmp(v14, "com.apple.ResourceFork", v15))
  {
    if (strncmp(v14, "com.apple.system.fs.speculative_telemetry", v15)) {
      goto LABEL_47;
    }
    uint64_t v23 = sub_10000E000();
    if ((BYTE11(xmmword_10008C910) & 0x20) != 0)
    {
      unint64_t v46 = v23;
      __int16 v47 = *(_WORD *)a5;
      if ((*(_WORD *)a5 & 4) == 0)
      {
        sub_100040C68( "speculative download xattr (id %llu): invalid flags: 0x%x\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v10);
        sub_100044E7C((char *)0x5B6, -3);
        int v54 = sub_1000428C4(qword_10008DB70, "set missing flag? (0x%x) ", v48, v49, v50, v51, v52, v53, 4);
        __int16 v47 = *(_WORD *)a5;
        if (v54)
        {
          v47 |= 4u;
          *(_WORD *)a5 = v47;
          *a3 = 1;
        }
      }

      if ((v47 & 1) != 0)
      {
        unint64_t v56 = *(void *)(a5 + 12);
        sub_100040C68( "speculative download xattr (id %llu): shouldn't be stream based\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v10);
        sub_100044E7C((char *)0x5B7, -5);
        if (v56 > 0xB) {
          goto LABEL_47;
        }
        sub_100040C68( "speculative download xattr (id %llu): size is too small, actual: %u, minimum: %lu\n",  v57,  v58,  v59,  v60,  v61,  v62,  v63,  v10);
        uint64_t v31 = 1464LL;
      }

      else
      {
        if (*(unsigned __int16 *)(a5 + 2) > 0xBu)
        {
          char v64 = *(_BYTE *)(a5 + 4);
          if (v64)
          {
            sub_100040C68( "speculative download xattr (id %llu): unknown version: %u\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v10);
            uint64_t v31 = 1466LL;
            int v39 = -6;
          }

          else
          {
            unsigned int v65 = *(unsigned __int8 *)(a5 + 5);
            unsigned int v66 = *(unsigned __int16 *)(a5 + 6);
            unint64_t v67 = *(void *)(a5 + 8);
            unint64_t v74 = v67;
            if (v65 >= 6)
            {
              sub_100040C68( "speculative download xattr (id %llu): unknown purge reason: %u\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v10);
              sub_100044E7C((char *)0x5BB, -3);
              unint64_t v67 = v74;
            }

            if (v66 >= 0x40)
            {
              sub_100040C68( "speculative download xattr (id %llu): unknown flags: %x\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v10);
              sub_100044E7C((char *)0x5BC, -3);
              BOOL v73 = sub_10000E0D0(a1, v66, 63LL, v68, v69, v70, v71, v72);
              unint64_t v67 = v74;
              if (v73)
              {
                *a3 = 1;
                *(_BYTE *)a5 = v64;
                *(_BYTE *)(a5 + 1) = v65;
                *(_WORD *)(a5 + 2) = v66 & 0x3F;
                *(void *)(a5 + 4) = v74;
              }
            }

            if (v67 <= v46) {
              goto LABEL_47;
            }
            sub_100040C68( "speculative download xattr (id %llu): pristine time (%llu) is greater than current time (%llu)\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v10);
            uint64_t v31 = 1469LL;
            int v39 = -4;
          }

          goto LABEL_46;
        }

        sub_100040C68( "speculative download xattr (id %llu): size is too small, actual: %u, minimum: %lu\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v10);
        uint64_t v31 = 1465LL;
      }

      int v39 = -11;
LABEL_46:
      sub_100044E7C((char *)v31, v39);
LABEL_47:
      if (a6) {
        *a6 = v10 != (void)xmmword_10008C900;
      }
      return;
    }

    sub_100040C68( "speculative download xattr (id %llu): found outside of an SAF dir stats hierarchy\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v10);
    uint64_t v31 = 1461LL;
LABEL_13:
    int v39 = -3;
    goto LABEL_46;
  }

  if ((*(_WORD *)a5 & 2) != 0)
  {
    uint64_t v40 = *(unsigned __int16 *)(a5 + 2);
LABEL_27:
    if (v40) {
      int v45 = 2;
    }
    else {
      int v45 = 1;
    }
    DWORD1(xmmword_10008C930) = v45;
    goto LABEL_47;
  }

  uint64_t v40 = *(void *)(a5 + 12);
  uint64_t v41 = *(void *)(a5 + 20);
  *((void *)&xmmword_10008C920 + 1) = v41;
  if (!*((void *)&xmmword_10008C900 + 1)
    || (sub_100016D54(*((uint64_t *)&xmmword_10008C900 + 1), v41), !v42)
    && ((word_10008C94C & 0xF000) != 0x8000
     || (BYTE8(xmmword_10008C910) & 2) == 0
     || (DWORD2(xmmword_10008C910) & 0x180000) != 0x80000LL
     || dword_10008C948 != 1
     || (dword_10008C944 & 0x40000020) != 0x20
     || (sub_1000171C8(*((uint64_t *)&xmmword_10008C900 + 1), v41), !v43)))
  {
    if (!(void)xmmword_10008C910) {
      goto LABEL_27;
    }
    sub_100006150(xmmword_10008C910, v41);
    if (!v44) {
      goto LABEL_27;
    }
  }

uint64_t sub_1000246D8( _DWORD *a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_1000251C0(a1, 8u, 0, 0, 0, a2, a3, 0LL, 0);
  }
  else {
    return sub_100024E94(0LL, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  }
}

BOOL sub_10002471C( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 + 0x7FFFFFFF) >= 2)
  {
    sub_100040C68("inode (id %llu): unknown compression type: %u\n", a2, a3, a4, a5, a6, a7, a8, xmmword_10008C900);
    sub_100044E7C((char *)0x4C2, 92);
  }

  return 0LL;
}

uint64_t sub_100024794( uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = xmmword_10008C900;
  if (!(void)xmmword_10008C900) {
    return 0LL;
  }
  int v12 = dword_10008C944;
  if ((dword_10008C944 & 0x20) == 0) {
    goto LABEL_3;
  }
  if (!(_BYTE)xmmword_10008C930)
  {
    if (qword_10008C958 == (void)xmmword_10008C900)
    {
      uint64_t v13 = 0LL;
    }

    else
    {
      uint64_t v13 = sub_10003B000(a1, a2, qword_10008C950, xmmword_10008C900, &byte_10008C960);
      qword_10008C958 = v8;
    }

    if ((_DWORD)v13 || byte_10008C960) {
      return v13;
    }
    sub_100040C68( "inode (id %llu): has the compression bsdflag, but doesn't have the compression xattr\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  xmmword_10008C900);
    sub_100044E7C((char *)0x4C8, -3);
  }

  if (BYTE8(xmmword_10008C930)) {
    BOOL v21 = DWORD1(xmmword_10008C930) == 2;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21)
  {
    uint64_t v25 = xmmword_10008C900;
    if (qword_10008C958 == (void)xmmword_10008C900)
    {
      uint64_t v13 = 0LL;
    }

    else
    {
      uint64_t v13 = sub_10003B000(a1, a2, qword_10008C950, xmmword_10008C900, &byte_10008C960);
      qword_10008C958 = v25;
    }

    if ((_DWORD)v13 || byte_10008C960) {
      return v13;
    }
    sub_100040C68( "inode (id %llu): Resource Fork xattr is missing or empty for compressed file\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  xmmword_10008C900);
    sub_100044E7C((char *)0x4C6, 92);
    *(void *)&v59[0] = xmmword_10008C900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
    LODWORD(v58) = 32;
    uint64_t v13 = sub_100024140(a3, v59, &v58, 4LL, 20LL, v26, v27, v28);
    if (!(_DWORD)v13 && dword_10008C940 == 16)
    {
      *(void *)&v59[0] = xmmword_10008C900 & 0xFFFFFFFFFFFFFFFLL | 0x4000000000000000LL;
      WORD4(v59[0]) = 18;
      strcpy((char *)v59 + 10, "com.apple.decmpfs");
      uint64_t v13 = sub_1000246D8(a3, v59, 28LL, a4, a5, a6, a7, a8);
    }

    if ((_DWORD)v13)
    {
LABEL_44:
      sub_100040B90( "inode (id %llu): failed to enqueue to the repairs\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  xmmword_10008C900);
      sub_100044E7C((char *)0x4D2, v13);
      goto LABEL_45;
    }
  }

  int v12 = dword_10008C944;
  if ((dword_10008C944 & 0x40000000) == 0 && BYTE9(xmmword_10008C930))
  {
    sub_100040C68( "inode (id %llu): compression type is dataless, but the dataless bsd_flag is not set\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  xmmword_10008C900);
    sub_100044E7C((char *)0x4FD, -3);
    *(void *)&v59[0] = xmmword_10008C900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
    LODWORD(v58) = 0x40000000;
    uint64_t v13 = sub_100024140(a3, v59, &v58, 4LL, 19LL, v22, v23, v24);
    if ((_DWORD)v13) {
      goto LABEL_44;
    }
    int v12 = dword_10008C944;
  }

LABEL_3:
  if ((v12 & 0x40000000) == 0)
  {
    if ((BYTE8(xmmword_10008C910) & 0x10) == 0) {
      goto LABEL_5;
    }
LABEL_4:
    uint64_t v13 = 0LL;
    int v19 = DWORD1(xmmword_10008C930);
    if ((dword_10008C944 & 0x20) == 0 || DWORD1(xmmword_10008C930) != 2)
    {
LABEL_46:
      if (v19)
      {
        if (v19 == 1)
        {
LABEL_58:
          xmmword_10008C930 = 0u;
          *(_OWORD *)&dword_10008C940 = 0u;
          xmmword_10008C910 = 0u;
          xmmword_10008C920 = 0u;
          xmmword_10008C900 = 0u;
          *(void *)((char *)&xmmword_10008C930 + 12) = -1LL;
          return v13;
        }

        uint64_t v29 = WORD4(xmmword_10008C910) & 0x8000;
        uint64_t v30 = ~DWORD2(xmmword_10008C910) & 0x4000LL;
        if ((_DWORD)v13) {
          goto LABEL_54;
        }
      }

      else
      {
        uint64_t v30 = ~DWORD2(xmmword_10008C910) & 0x8000LL;
        uint64_t v29 = WORD4(xmmword_10008C910) & 0x4000;
        if ((_DWORD)v13) {
          goto LABEL_54;
        }
      }

      if (v30)
      {
        sub_100040C68( "inode (id %llu): need to set internal_flags 0x%llx\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  xmmword_10008C900);
        sub_100044E7C((char *)0x5A9, 92);
        uint64_t v58 = v30;
        *(void *)&v59[0] = xmmword_10008C900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
        uint64_t v34 = sub_100024140(a3, v59, &v58, 8LL, 17LL, v31, v32, v33);
        uint64_t v13 = v34;
        if ((_DWORD)v34)
        {
          char v35 = xmmword_10008C900;
          strerror(v34);
          sub_100040B90( "inode (id %llu): can't add internal flags repair: %d (%s)\n",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v35);
          sub_100044E7C((char *)0x5AA, v13);
          goto LABEL_58;
        }
      }

LABEL_54:
      if (v29)
      {
        if (!(_DWORD)v13)
        {
          sub_100040C68( "inode (id %llu): need to clear internal_flags 0x%llx\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  xmmword_10008C900);
          sub_100044E7C((char *)0x5AB, 92);
          uint64_t v58 = v29;
          *(void *)&v59[0] = xmmword_10008C900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
          uint64_t v46 = sub_100024140(a3, v59, &v58, 8LL, 18LL, v43, v44, v45);
          uint64_t v13 = v46;
          if ((_DWORD)v46)
          {
            char v47 = xmmword_10008C900;
            strerror(v46);
            sub_100040B90( "inode (id %llu): can't add internal flags repair: %d (%s)\n",  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v47);
            sub_100044E7C((char *)0x5AC, v13);
          }
        }
      }

      goto LABEL_58;
    }

    else {
LABEL_5:
    }
      uint64_t v13 = 0LL;
LABEL_45:
    int v19 = DWORD1(xmmword_10008C930);
    goto LABEL_46;
  }

  if ((v12 & 0x20) == 0)
  {
    sub_100040C68( "inode (id %llu): dataless bsd_flag is set, but compression bsd_flag is not\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  xmmword_10008C900);
    sub_100044E7C((char *)0x4D3, -3);
    if ((_BYTE)xmmword_10008C930 && BYTE9(xmmword_10008C930))
    {
      *(void *)&v59[0] = xmmword_10008C900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
      LODWORD(v58) = 32;
      uint64_t v17 = a3;
      uint64_t v18 = 19LL;
    }

    else
    {
      *(void *)&v59[0] = xmmword_10008C900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
      LODWORD(v58) = 0x40000000;
      uint64_t v17 = a3;
      uint64_t v18 = 20LL;
    }

    uint64_t v13 = sub_100024140(v17, v59, &v58, 4LL, v18, v14, v15, v16);
    if ((_DWORD)v13)
    {
      sub_100040B90( "inode (id %llu): failed to enqueue to the repairs\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  xmmword_10008C900);
      sub_100044E7C((char *)0x4D4, v13);
      return v13;
    }

    goto LABEL_4;
  }

  if ((_BYTE)xmmword_10008C930)
  {
    if (BYTE9(xmmword_10008C930)) {
      goto LABEL_4;
    }
    uint64_t v20 = xmmword_10008C900;
    if (qword_10008C958 == (void)xmmword_10008C900)
    {
      uint64_t v13 = 0LL;
    }

    else
    {
      uint64_t v13 = sub_10003B000(a1, a2, qword_10008C950, xmmword_10008C900, &byte_10008C960);
      qword_10008C958 = v20;
    }

    if (!(_DWORD)v13 && !byte_10008C960)
    {
      sub_100040C68( "inode (id %llu): dataless bsd_flag is set, but the compression type is different: 0x%x\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  xmmword_10008C900);
      uint64_t v57 = 1226LL;
      goto LABEL_73;
    }
  }

  else
  {
    uint64_t v56 = xmmword_10008C900;
    if (qword_10008C958 == (void)xmmword_10008C900)
    {
      uint64_t v13 = 0LL;
    }

    else
    {
      uint64_t v13 = sub_10003B000(a1, a2, qword_10008C950, xmmword_10008C900, &byte_10008C960);
      qword_10008C958 = v56;
    }

    if (!(_DWORD)v13 && !byte_10008C960)
    {
      sub_100040C68( "inode (id %llu): dataless bsd_flag is set, but the compression xattr is missing\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  xmmword_10008C900);
      uint64_t v57 = 1237LL;
LABEL_73:
      sub_100044E7C((char *)v57, -3);
      goto LABEL_4;
    }
  }

  return v13;
}

uint64_t sub_100024DFC( uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_100024794(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    *(void *)&xmmword_10008C900 = a4;
    *((void *)&xmmword_10008C900 + 1) = a6;
    dword_10008C944 = *(_DWORD *)(a5 + 68);
    uint64_t v13 = *(void *)(a5 + 48);
    *(void *)&xmmword_10008C910 = a7;
    *((void *)&xmmword_10008C910 + 1) = v13;
    *(void *)&xmmword_10008C920 = *(void *)(a5 + 8);
    dword_10008C948 = *(_DWORD *)(a5 + 56);
    word_10008C94C = *(_WORD *)(a5 + 80);
  }

  return result;
}

double sub_100024E68(uint64_t a1)
{
  qword_10008C950 = a1;
  xmmword_10008C930 = 0u;
  *(_OWORD *)&dword_10008C940 = 0u;
  xmmword_10008C900 = 0u;
  xmmword_10008C910 = 0u;
  xmmword_10008C920 = 0u;
  double result = NAN;
  *(void *)((char *)&xmmword_10008C930 + 12) = -1LL;
  return result;
}

uint64_t sub_100024E94( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_10008C964 & 1) == 0)
  {
    sub_100040C68( "snapshot fsroot / file key rolling / doc-id tree corruptions are not repaired; they'll go away once the snapshot is deleted\n",
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      v9);
    byte_10008C964 = 1;
  }

  return 0LL;
}

uint64_t sub_100024ED0(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100034B44(a1, 0LL, a2, 0x8000000, 2, 0, 0, 4096, 0, 0, 0, 0LL, (uint64_t)sub_100024F48);
  if (!(_DWORD)result) {
    return sub_100036C00(a1, 0LL, 0x42u);
  }
  return result;
}

uint64_t sub_100024F48(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 >= 2 && a5 >= 2)
  {
    int v13 = sub_100025D4C((unsigned __int16 *)a2, a3, (unsigned __int16 *)a4, a5);
    *a6 = v13;
    if (v13) {
      return 0LL;
    }
    switch(*(_WORD *)a2 & 0xF)
    {
      case 0:
      case 1:
      case 2:
        uint64_t result = 22LL;
        if (a3 == 18 && a5 == 18)
        {
          __int128 v34 = *(_OWORD *)(a2 + 2);
          __int128 v33 = *(_OWORD *)(a4 + 2);
          return sub_10000200C(a1, &v34, 16, &v33, 16, a6);
        }

        return result;
      case 3:
        uint64_t result = 22LL;
        if (a3 == 18 && a5 == 18)
        {
          __int128 v25 = *(_OWORD *)(a2 + 2);
          __int128 v31 = *(_OWORD *)(a4 + 2);
          __int128 v32 = v25;
          return sub_10001DFDC(a1, &v32, 16, &v31, 16, a6);
        }

        return result;
      case 4:
        uint64_t result = 22LL;
        if (a3 != 10 || a5 != 10) {
          return result;
        }
        uint64_t v26 = *(void *)(a2 + 2);
        uint64_t v29 = *(void *)(a4 + 2);
        uint64_t v30 = v26;
        uint64_t v23 = &v30;
        uint64_t v24 = &v29;
        return sub_10002D39C(a1, v23, 8, v24, 8, a6);
      case 5:
      case 7:
      case 8:
        uint64_t result = 22LL;
        if (a3 < 0xD || a5 < 0xD) {
          return result;
        }
        uint64_t v14 = (unint64_t *)(a2 + 5);
        unsigned int v15 = a3 - 5;
        uint64_t v16 = (unint64_t *)(a4 + 5);
        unsigned int v17 = a5 - 5;
        uint64_t v18 = a1;
        goto LABEL_13;
      case 6:
        uint64_t result = 22LL;
        if (a3 != 18 || a5 != 18) {
          return result;
        }
        unint64_t v19 = *(void *)(a2 + 2);
        unint64_t v20 = *(void *)(a4 + 2);
        if (v19 < v20)
        {
          uint64_t result = 0LL;
          int v21 = -1;
LABEL_34:
          *a6 = v21;
          return result;
        }

        if (v19 > v20)
        {
          uint64_t result = 0LL;
          int v21 = 1;
          goto LABEL_34;
        }

        uint64_t v14 = (unint64_t *)(a2 + 10);
        uint64_t v16 = (unint64_t *)(a4 + 10);
        uint64_t v18 = a1;
        unsigned int v15 = 8;
        unsigned int v17 = 8;
LABEL_13:
        uint64_t result = sub_10003A6AC(v18, v14, v15, v16, v17, a6);
        break;
      case 9:
        uint64_t result = 22LL;
        if (a3 != 10 || a5 != 10) {
          return result;
        }
        uint64_t v22 = *(void *)(a2 + 2);
        uint64_t v27 = *(void *)(a4 + 2);
        uint64_t v28 = v22;
        uint64_t v23 = &v28;
        uint64_t v24 = &v27;
        return sub_10002D39C(a1, v23, 8, v24, 8, a6);
      case 0xA:
        uint64_t result = 22LL;
        if (a3 == 6 && a5 == 6) {
          return sub_10002D368(a1, (_DWORD *)(a2 + 2), 4, (_DWORD *)(a4 + 2), 4, a6);
        }
        return result;
      default:
        return 0LL;
    }
  }

  return result;
}

uint64_t sub_1000251C0( _DWORD *a1, unsigned int a2, int a3, unsigned int a4, char a5, __int128 *a6, unsigned int a7, _BYTE *a8, unsigned int a9)
{
  if ((a5 & 1) != 0)
  {
    __int16 v13 = 2048;
  }

  else
  {
    __int16 v13 = 0;
    uint64_t result = 0LL;
    int v15 = dword_10008C968++;
    if (v15 > 999998) {
      return result;
    }
  }

  uint64_t v16 = a9;
  if (!a3 && (a2 > 7 || ((1 << a2) & 0xB8) == 0))
  {
    a8 = 0LL;
    uint64_t v16 = 0LL;
  }

  __int16 v17 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
  switch(a2)
  {
    case 0u:
    case 1u:
    case 2u:
      uint64_t result = 22LL;
      if (a7 == 16 && 8LL * (a3 != 0) == v16)
      {
        __int16 v37 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
        __int128 v38 = *a6;
        uint64_t v18 = &v37;
        goto LABEL_26;
      }

      return result;
    case 3u:
      uint64_t result = 22LL;
      if (a7 == 16 && (_DWORD)v16 == 16)
      {
        __int16 v35 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
        __int128 v36 = *a6;
        uint64_t v18 = &v35;
        unint64_t v20 = a1;
        uint64_t v21 = 18LL;
        goto LABEL_23;
      }

      return result;
    case 4u:
      uint64_t result = 22LL;
      if (a7 == 8 && (_DWORD)v16 == 16)
      {
        __int16 v33 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
        uint64_t v34 = *(void *)a6;
        uint64_t v18 = &v33;
        unint64_t v20 = a1;
        uint64_t v21 = 10LL;
LABEL_23:
        uint64_t v22 = a8;
        uint64_t v23 = 16LL;
        return sub_1000364F0(v20, 0LL, v18, v21, v22, v23);
      }

      return result;
    case 5u:
    case 7u:
    case 8u:
      if (a7 - 833 < 0xFFFFFCC7) {
        return 22LL;
      }
      if (a3 == 1)
      {
        char v19 = 0;
        if (a4 <= 0xF && ((1 << a4) & 0x8140) != 0)
        {
          if (!(_DWORD)v16) {
            return 22LL;
          }
          char v19 = *a8;
        }
      }

      else
      {
        char v19 = 0;
      }

      uint64_t v24 = (char *)malloc(a7 + 5);
      if (!v24) {
        return 12LL;
      }
      __int128 v25 = v24;
      *(_WORD *)uint64_t v24 = v17;
      *((_WORD *)v24 + 1) = a7;
      v24[4] = v19;
      memcpy(v24 + 5, a6, a7);
      uint64_t v26 = sub_1000364F0(a1, 0LL, v25, a7 + 5, a8, v16);
      free(v25);
      return v26;
    case 6u:
      if (a7 != 16) {
        return 22LL;
      }
      __int16 v31 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
      __int128 v32 = *a6;
      uint64_t v18 = &v31;
LABEL_26:
      unint64_t v20 = a1;
      uint64_t v21 = 18LL;
      goto LABEL_27;
    case 9u:
      uint64_t result = 22LL;
      if (a7 != 8 || (_DWORD)v16 != 24) {
        return result;
      }
      __int16 v29 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
      uint64_t v30 = *(void *)a6;
      uint64_t v18 = &v29;
      unint64_t v20 = a1;
      uint64_t v21 = 10LL;
      uint64_t v22 = a8;
      uint64_t v23 = 24LL;
      break;
    case 0xAu:
      uint64_t result = 22LL;
      __int16 v27 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
      int v28 = *(_DWORD *)a6;
      uint64_t v18 = &v27;
      unint64_t v20 = a1;
      uint64_t v21 = 6LL;
LABEL_27:
      uint64_t v22 = a8;
      uint64_t v23 = v16;
      break;
    default:
      return 22LL;
  }

  return sub_1000364F0(v20, 0LL, v18, v21, v22, v23);
}

uint64_t sub_1000254BC( uint64_t a1, uint64_t *a2, uint64_t a3, int a4, void *a5, void *a6, void *a7, void *a8)
{
  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v82 = 0xAAAAAAAAAAAAAAAALL;
  __int128 v80 = 0xAAAAAAAAAAAAAA00LL;
  *(_OWORD *)&v79[8] = v15;
  v78[0] = a2;
  v78[1] = a3;
  uint64_t v81 = 0LL;
  if (a4) {
    uint64_t v16 = sub_1000258B4;
  }
  else {
    uint64_t v16 = sub_100025D30;
  }
  uint64_t v83 = 0LL;
  uint64_t v84 = 0LL;
  *(void *)uint64_t v79 = -1LL;
  *(void *)&v79[5] = -1LL;
  uint64_t v85 = 0LL;
  uint64_t v17 = sub_100036AE0(a1, 0LL, &v82);
  if ((_DWORD)v17)
  {
    uint64_t v18 = v17;
    char v19 = strerror(v17);
    sub_100040B90("unable to access the tree repairs structure: %s\n", v20, v21, v22, v23, v24, v25, v26, v19);
    sub_100044E7C((char *)0x2C4, v18);
    goto LABEL_6;
  }

  if (!v82)
  {
    uint64_t v18 = 0LL;
    goto LABEL_6;
  }

  unint64_t v87 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v28 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v86[2] = v28;
  v86[3] = v28;
  v86[0] = v28;
  v86[1] = v28;
  __int16 v29 = calloc(1uLL, 0x345uLL);
  uint64_t v30 = calloc(1uLL, 0xEE0uLL);
  uint64_t v76 = v29;
  unint64_t v77 = v30;
  if (!v29 || !v30)
  {
    sub_100040B90("unable to allocate memory for tree repairs\n", v31, v32, v33, v34, v35, v36, v37, v75);
    uint64_t v18 = 12LL;
    uint64_t v49 = 701LL;
    int v50 = 12;
LABEL_27:
    sub_100044E7C((char *)v49, v50);
    uint64_t v48 = v76;
    goto LABEL_36;
  }

  if (a3)
  {
    uint64_t v38 = *(void *)(a3 + 40);
    if ((*(_BYTE *)(v38 + 264) & 1) == 0 || *(void *)(v38 + 976))
    {
      if (*(_BYTE *)(a3 + 8))
      {
        uint64_t v39 = sub_1000416DC((const char **)a3, a2, 2);
        if ((_DWORD)v39)
        {
          uint64_t v18 = v39;
          char v40 = strerror(v39);
          sub_100040B90("unable to open the volume for repairs: %s\n", v41, v42, v43, v44, v45, v46, v47, v40);
          sub_100044E7C((char *)0x2C5, v18);
LABEL_24:
          uint64_t v48 = v76;
LABEL_37:
          sub_100041874(a3);
LABEL_38:
          uint64_t v60 = v77;
          if (!v77) {
            goto LABEL_40;
          }
          goto LABEL_39;
        }
      }
    }
  }

  uint64_t v48 = v29;
  uint64_t v51 = sub_100035394((uint64_t)v86, a1, 0LL, v29, 2u, 0x345u, v77, 3808);
  if ((_DWORD)v51)
  {
    uint64_t v18 = v51;
    LOBYTE(v80) = 0;
    *((void *)&v80 + 1) = 0LL;
    uint64_t v81 = 0LL;
    goto LABEL_36;
  }

  uint64_t v18 = sub_10002930C( (uint64_t)v86,  (uint64_t (*)(void, void, void, void, uint64_t))v16,  (uint64_t)v78,  1);
  if (*((void *)&v80 + 1) >= 2uLL)
  {
    if ((_BYTE)v80) {
      uint64_t v59 = "Applied";
    }
    else {
      uint64_t v59 = "Skipped";
    }
    sub_10004096C("%s %llu/%llu repairs of this type in total.\n", v52, v53, v54, v55, v56, v57, v58, (char)v59);
  }

  LOBYTE(v80) = 0;
  *((void *)&v80 + 1) = 0LL;
  uint64_t v81 = 0LL;
  if ((_DWORD)v18)
  {
LABEL_36:
    if (!a3) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }

  if (v84)
  {
    uint64_t v61 = sub_10001BC38(*a2);
    uint64_t v18 = v61;
    if (a3 && !(_DWORD)v61)
    {
      uint64_t v62 = 0LL;
      char v63 = 1;
      while (1)
      {
        char v64 = v63;
        uint64_t v65 = *(void *)(a3 + 8 * v62 + 24);
        if (v65)
        {
          uint64_t v66 = sub_10001BC38(v65);
          if ((_DWORD)v66) {
            break;
          }
        }

        char v63 = 0;
        uint64_t v62 = 1LL;
        if ((v64 & 1) == 0) {
          goto LABEL_52;
        }
      }

      uint64_t v18 = v66;
      goto LABEL_59;
    }

    if ((_DWORD)v61)
    {
LABEL_59:
      char v67 = strerror(v18);
      sub_100040B90("unable to flush deferred repairs: %s\n", v68, v69, v70, v71, v72, v73, v74, v67);
      uint64_t v49 = 900LL;
      int v50 = v18;
      goto LABEL_27;
    }
  }

  if (a3)
  {
LABEL_52:
    if (*(_BYTE *)(a3 + 12))
    {
      if (v84 == v82) {
        *(void *)(*(void *)(a3 + 40) + 264LL) &= ~4uLL;
      }
      sub_10004227C(a2, (int8x16_t *)a3);
      uint64_t v18 = 0LL;
      *(_BYTE *)(a3 + 12) = 0;
    }

    else
    {
      uint64_t v18 = 0LL;
    }

    goto LABEL_24;
  }

  uint64_t v18 = 0LL;
  uint64_t v48 = v76;
  uint64_t v60 = v77;
LABEL_39:
  free(v60);
LABEL_40:
  if (v48) {
    free(v48);
  }
LABEL_6:
  if (a5) {
    *a5 += v82;
  }
  if (a6) {
    *a6 += v83;
  }
  if (a7) {
    *a7 += v84;
  }
  if (a8) {
    *a8 += v85;
  }
  sub_100036CD8(a1, 0LL);
  return v18;
}

uint64_t sub_1000258B4(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v11 = *(uint64_t **)a5;
  uint64_t v10 = *(void **)(a5 + 8);
  int v12 = (void *)(a5 + 16);
  int v20 = sub_100025D4C(a1, a2, (unsigned __int16 *)(a5 + 16), *(_DWORD *)(a5 + 36));
  if (v20)
  {
    sub_100025E68(a5, v13, v14, v15, v16, v17, v18, v19);
    unsigned int v21 = *a1 & 0xF;
    if (v21 >= 0xB) {
      return 22LL;
    }
    goto LABEL_6;
  }

  unsigned int v21 = *a1 & 0xF;
  if (v21 >= 0xB) {
    return 22LL;
  }
  if (*(_BYTE *)(a5 + 40))
  {
LABEL_6:
    uint64_t v94 = off_10006C588[v21];
    int v29 = sub_10001BC28(*v11);
    if (v29)
    {
LABEL_7:
      char v30 = strerror(v29);
      sub_100040C68("error starting transaction: %s\n", v31, v32, v33, v34, v35, v36, v37, v30);
      sub_100044E7C((char *)0x36E, v29);
      LODWORD(v38) = 0;
      if (v20)
      {
        if (!v10) {
          goto LABEL_17;
        }
LABEL_8:
        uint64_t v39 = v10[6];
        if (!v39) {
          uint64_t v39 = v10[5];
        }
        if ((*(_BYTE *)(v39 + 56) & 0x20) != 0 && (*a1 & 0xF) == 8)
        {
          if ((byte_10008C96D & 1) == 0)
          {
            sub_100040C68( "sealed volume fsroot corruptions cannot be repaired and will automatically be skipped\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v91);
            byte_10008C96D = 1;
          }

          uint64_t v40 = 2LL;
        }

        else
        {
LABEL_17:
          uint64_t v40 = 0LL;
        }

LABEL_93:
          char v81 = strerror(v49);
          sub_100040B90("error ending transaction: %s\n", v82, v83, v84, v85, v86, v87, v88, v81);
          sub_100044E7C((char *)0x36F, v49);
LABEL_94:
          int v12 = v93;
LABEL_95:
          if ((_DWORD)v41) {
            uint64_t v41 = v41;
          }
          else {
            uint64_t v41 = v49;
          }
          goto LABEL_98;
        }

LABEL_98:
  else {
    size_t v89 = a2;
  }
  *(_DWORD *)(a5 + 36) = v89;
  memcpy(v12, a1, v89);
  ++*(void *)(a5 + 48);
  return v41;
}

uint64_t sub_100025D30(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((*a1 & 0x800) != 0) {
    ++*(void *)(a5 + 72);
  }
  return 0LL;
}

uint64_t sub_100025D4C(unsigned __int16 *a1, unsigned int a2, unsigned __int16 *a3, unsigned int a4)
{
  unsigned int v4 = *a1;
  unsigned int v5 = v4 & 0xF;
  unsigned int v6 = *a3;
  if (v5 < (v6 & 0xF)) {
    return 0xFFFFFFFFLL;
  }
  if (v5 > (v6 & 0xF)) {
    return 1LL;
  }
  if (v5 != 5)
  {
    uint64_t v8 = 0LL;
    if (a4 >= 0xD && a2 >= 0xD)
    {
      char v9 = 0LL;
      if (v5 != 8) {
        goto LABEL_23;
      }
      goto LABEL_12;
    }

uint64_t sub_100025E68( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = result;
  char v9 = (void *)(result + 48);
  if (*(void *)(result + 48) >= 2uLL)
  {
    if (*(_BYTE *)(result + 40)) {
      uint64_t v10 = "Applied";
    }
    else {
      uint64_t v10 = "Skipped";
    }
    uint64_t result = sub_10004096C("%s %llu/%llu repairs of this type in total.\n", a2, a3, a4, a5, a6, a7, a8, (char)v10);
  }

  *(_BYTE *)(v8 + 40) = 0;
  *char v9 = 0LL;
  v9[1] = 0LL;
  return result;
}

uint64_t sub_100025EDC( uint64_t *a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  unsigned int v10 = *a3 & 0xF;
  uint64_t v18 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100029A94(a1, v10, (uint64_t *)&v18);
  if (!(_DWORD)result)
  {
    uint64_t v12 = *(void *)(a3 + 1);
    uint64_t v13 = *(void *)(a3 + 5);
    v17[0] = v12;
    v17[1] = v13;
    unsigned int v14 = *a3;
    int v15 = (v14 >> 4) & 3;
    if (v15 == 2)
    {
      if ((v14 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "need to insert spaceman free queue tree entry (0x%llx+%llu, xid %llu) to replace existing overlapping ranges\n",  v13,  *a5,  v12);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "need to insert spaceman free queue tree entry (0x%llx+%llu, xid %llu) to replace existing overlapping ranges\n",  v13,  *a5,  v12);
      }
      return sub_100026658(v18, 0LL, v17, 16LL, a5, 8LL, (uint64_t)"free queue tree entry", a7);
    }

    else if (v15)
    {
      return 22LL;
    }

    else
    {
      if ((v14 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "found spaceman free queue tree entry (0x%llx, xid %llu) which overlaps with existing range\n",  v13,  v12);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "found spaceman free queue tree entry (0x%llx, xid %llu) which overlaps with existing range\n",  v13,  v12);
      }
      return sub_100026730( (uint64_t)v18,  0LL,  (uint64_t)v17,  16LL,  0LL,  (uint64_t)"free queue tree entry",  (_DWORD)a7 != 0,  v16);
    }
  }

  return result;
}

uint64_t sub_100026004(uint64_t *a1, int8x16_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100029B94(a1, (uint64_t)a2, &v17);
  if (!(_DWORD)result)
  {
    uint64_t v13 = *(void *)(a3 + 2);
    uint64_t v14 = *(void *)(a3 + 10);
    v16[0] = v13;
    v16[1] = v14;
    if ((*(_WORD *)a3 & 0x800) != 0) {
      ((void (*)(const char *, ...))sub_100040B90)("found orphan omap mapping (oid %llu xid %llu)\n", v13, v14);
    }
    else {
      ((void (*)(const char *, ...))sub_100040C68)("found orphan omap mapping (oid %llu xid %llu)\n", v13, v14);
    }
    uint64_t result = sub_100026730(v17, 0LL, (uint64_t)v16, 16LL, 0LL, (uint64_t)"omap mapping", a7 != 0, v15);
    if (!(_DWORD)result)
    {
      if ((*(_BYTE *)a5 & 1) != 0) {
        return 0LL;
      }
      else {
        return sub_1000032D0(a1, a2, *(void *)(a5 + 8), (*(_DWORD *)(a5 + 4) / *(_DWORD *)(a1[1] + 36)));
      }
    }
  }

  return result;
}

uint64_t sub_1000260F0(int8x16_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, int a7)
{
  int v7 = *(_WORD *)a3 & 0xF;
  if (v7 == 5) {
    return sub_100004AEC((uint64_t)a1, a2, (char *)(a3 + 5), (uint64_t)a5, a7 != 0);
  }
  if (v7 == 4) {
    return sub_1000049B0(a1, a2, *(void *)(a3 + 2), *a5, a5[1], a7 != 0);
  }
  return 22LL;
}

#error "10002617C: switch analysis failed: switch information is incomplete or incorrect (funcsize=17)"
uint64_t sub_100026188( uint64_t a1,  uint64_t a2,  unsigned __int16 *a3,  uint64_t a4,  const void *a5,  uint64_t a6,  uint64_t a7)
{
  __int128 v10;
  uint64_t v11;
  uint64_t result;
  void *v13;
  unsigned int v14;
  int v15;
  void (*v16)(const char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char);
  const char *v17;
  void (*v18)(const char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char);
  const char *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  _OWORD v25[4];
  *(void *)&unsigned int v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v25[2] = v10;
  v25[3] = v10;
  v25[0] = v10;
  v25[1] = v10;
  uint64_t v11 = *(void *)(a3 + 1);
  uint64_t result = sub_10003B518((uint64_t)v25, a1, a2, v11);
  if (!(_DWORD)result)
  {
    uint64_t v13 = a3 + 5;
    uint64_t v14 = *a3;
    uint64_t v15 = (v14 >> 4) & 3;
    if (v15 == 2)
    {
      if ((v14 & 0x800) != 0) {
        uint64_t v18 = sub_100040B90;
      }
      else {
        uint64_t v18 = sub_100040C68;
      }
      if (v11) {
        uint64_t v19 = "missing/invalid physical extent (%llu + %llu) with refcnt %d at snapshot %llu\n";
      }
      else {
        uint64_t v19 = "missing/invalid physical extent (%llu + %llu) with refcnt %d\n";
      }
      ((void (*)(const char *))v18)(v19);
      uint64_t v23 = *v13 >> 60;
      if ((_DWORD)v23 == 14) {
        LODWORD(v23) = *((unsigned __int8 *)a3 + 18);
      }
      uint64_t v24 = sub_10003A294(v23);
      return sub_100026658(v25, v11, a3 + 5, 8LL, a5, 20LL, (uint64_t)v24, a7);
    }

    else if (v15)
    {
      return 22LL;
    }

    else
    {
      if ((v14 & 0x800) != 0) {
        uint64_t v16 = sub_100040B90;
      }
      else {
        uint64_t v16 = sub_100040C68;
      }
      if (v11) {
        uint64_t v17 = "orphan/invalid physical extent (%llu) at snapshot %llu\n";
      }
      else {
        uint64_t v17 = "orphan/invalid physical extent (%llu)\n";
      }
      ((void (*)(const char *))v16)(v17);
      int v20 = *v13 >> 60;
      if ((_DWORD)v20 == 14) {
        LODWORD(v20) = *((unsigned __int8 *)a3 + 18);
      }
      unsigned int v21 = sub_10003A294(v20);
      return sub_100026730((uint64_t)v25, v11, (uint64_t)(a3 + 5), 8LL, 0LL, (uint64_t)v21, (_DWORD)a7 != 0, v22);
    }
  }

  return result;
}

uint64_t sub_100026328( uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, _WORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_10008C96C & 1) == 0)
  {
    sub_100040C68( "detected invalid fsroot tree nodes (& thus data loss), pruning the nodes to make the system usable\n",  a2,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  v21);
    byte_10008C96C = 1;
  }

  uint64_t v22 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10002A1E0(a1, a2, (uint64_t *)&v22);
  if (!(_DWORD)result)
  {
    uint64_t v15 = a3[1];
    uint64_t v16 = (void *)((char *)a3 + 5);
    unsigned int v17 = *a3;
    int v18 = (v17 >> 4) & 3;
    if (v18 == 2)
    {
      if ((v17 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "need to insert key at id (%llu) to repair invalid internal node\n",  *v16 & 0xFFFFFFFFFFFFFFFLL);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "need to insert key at id (%llu) to repair invalid internal node\n",  *v16 & 0xFFFFFFFFFFFFFFFLL);
      }
      return sub_100026658(v22, 0LL, (char *)a3 + 5, v15, a5, a6, (uint64_t)"btree node", a7);
    }

    else if (v18)
    {
      return 22LL;
    }

    else
    {
      unsigned __int16 v19 = *a5 + 1;
      if ((v17 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "found invalid fsroot btree node key id (%llu)\n",  *v16 & 0xFFFFFFFFFFFFFFFLL);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "found invalid fsroot btree node key id (%llu)\n",  *v16 & 0xFFFFFFFFFFFFFFFLL);
      }
      return sub_100026730((uint64_t)v22, 0LL, (uint64_t)a3 + 5, v15, v19, (uint64_t)"btree node", a7, v20);
    }
  }

  return result;
}

uint64_t sub_100026494( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100029E0C(a1, a2, (uint64_t *)&v15, a4, (uint64_t)a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    uint64_t v13 = *(void *)(a3 + 2);
    uint64_t v14 = v13;
    if ((*(_WORD *)a3 & 0x800) != 0) {
      ((void (*)(const char *, ...))sub_100040B90)("no file key rolling entry found for inode object (%llu)\n", v13);
    }
    else {
      ((void (*)(const char *, ...))sub_100040C68)("no file key rolling entry found for inode object (%llu)\n", v13);
    }
    return sub_100026658(v15, 0LL, &v14, 8LL, a5, a6, (uint64_t)"file key rolling", a7);
  }

  return result;
}

uint64_t sub_10002653C( uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  unsigned int v17 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100029EE0(a1, a2, (uint64_t *)&v17);
  if (!(_DWORD)result)
  {
    int v12 = *(_DWORD *)(a3 + 1);
    int v16 = v12;
    unsigned int v13 = *a3;
    int v14 = (v13 >> 4) & 3;
    if (v14 == 2)
    {
      if ((v13 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "inode with file-id %llu has doc-id %u but doc-id tree record is missing or points to another inode\n",  *a5,  v12);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "inode with file-id %llu has doc-id %u but doc-id tree record is missing or points to another inode\n",  *a5,  v12);
      }
      return sub_100026658(v17, 0LL, &v16, 4LL, a5, a6, (uint64_t)"doc-id tree entry", a7);
    }

    else if (v14)
    {
      return 22LL;
    }

    else
    {
      if ((v13 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "doc-id tree record exists for doc-id %u, but no inode references this doc-id\n",  v12);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "doc-id tree record exists for doc-id %u, but no inode references this doc-id\n",  v12);
      }
      return sub_100026730( (uint64_t)v17,  0LL,  (uint64_t)&v16,  4LL,  0LL,  (uint64_t)"doc-id tree entry",  (_DWORD)a7 != 0,  v15);
    }
  }

  return result;
}

uint64_t sub_100026658( _DWORD *a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a7;
  if ((_DWORD)a8 != 1
    && ((_DWORD)a8 == 2
     || !sub_1000428C4( qword_10008DB70,  "Insert missing %s objects? ",  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  a7)))
  {
    return 89LL;
  }

  uint64_t v15 = sub_1000364F0(a1, a2, a3, a4, a5, a6);
  uint64_t v16 = v15;
  if ((_DWORD)v15)
  {
    strerror(v15);
    sub_100040B90("failed to insert %s object: %s\n", v17, v18, v19, v20, v21, v22, v23, v8);
    sub_100044E7C((char *)0x28F, v16);
  }

  return v16;
}

uint64_t sub_100026730( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a6;
  unsigned int v9 = a5;
  if ((_DWORD)a7 != 1
    && ((_DWORD)a7 == 2
     || !sub_1000428C4(qword_10008DB70, "Remove orphan/invalid %s objects? ", a3, a4, a5, a6, a7, a8, a6)))
  {
    return 89LL;
  }

  uint64_t v14 = sub_1000367BC(a1, a2, a3, a4, v9);
  uint64_t v22 = v14;
  if ((_DWORD)v14)
  {
    if ((_DWORD)v14 == 2)
    {
      sub_100040C68("tried to remove %s object but it wasn't there!\n", v15, v16, v17, v18, v19, v20, v21, v8);
      return 0LL;
    }

    else
    {
      strerror(v14);
      sub_100040B90("failed to remove %s object: %s\n", v23, v24, v25, v26, v27, v28, v29, v8);
      sub_100044E7C((char *)0x28D, v22);
    }
  }

  return v22;
}

uint64_t sub_100026818( uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003AB6C(a1, a2, 3, &v18, (uint64_t)a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    unsigned int v12 = *a3;
    uint64_t v13 = a3[1];
    switch((v12 >> 6) & 0x1F)
    {
      case 0xCu:
        if ((v12 & 0x800) != 0) {
          uint64_t v14 = sub_100040B90;
        }
        else {
          uint64_t v14 = sub_100040C68;
        }
        uint64_t v15 = "nchildren of inode object (id %llu) does not match expected value (%d)\n";
        goto LABEL_44;
      case 0xDu:
        if ((v12 & 0x800) != 0) {
          uint64_t v14 = sub_100040B90;
        }
        else {
          uint64_t v14 = sub_100040C68;
        }
        uint64_t v15 = "alloced_size of dstream (object-id %llu) does not match minimum found size (%llu)\n";
        goto LABEL_44;
      case 0xEu:
        if ((v12 & 0x800) != 0) {
          uint64_t v14 = sub_100040B90;
        }
        else {
          uint64_t v14 = sub_100040C68;
        }
        uint64_t v15 = "need to update default_crypto_id (%llu) of dstream (object-id %llu) with missing crypto state\n";
        goto LABEL_44;
      case 0xFu:
        if ((v12 & 0x800) != 0) {
          uint64_t v16 = (void (*)(const char *, ...))sub_100040B90;
        }
        else {
          uint64_t v16 = (void (*)(const char *, ...))sub_100040C68;
        }
        uint64_t v17 = sub_10003A2C4((uint64_t)a3 + 5, *a5);
        v16( "found unexpected %s xfield associated with inode (object-id %llu)\n",  v17,  *(void *)((_BYTE *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL);
        goto LABEL_45;
      case 0x10u:
        if ((v12 & 0x800) != 0) {
          uint64_t v14 = sub_100040B90;
        }
        else {
          uint64_t v14 = sub_100040C68;
        }
        uint64_t v15 = "need to update inode (object-id %llu) sparse bytes with (%llu)\n";
        goto LABEL_44;
      case 0x11u:
        if ((v12 & 0x800) != 0) {
          uint64_t v14 = sub_100040B90;
        }
        else {
          uint64_t v14 = sub_100040C68;
        }
        uint64_t v15 = "need to set flags (0x%llx) in inode (object-id %llu)\n";
        goto LABEL_44;
      case 0x12u:
        if ((v12 & 0x800) != 0) {
          uint64_t v14 = sub_100040B90;
        }
        else {
          uint64_t v14 = sub_100040C68;
        }
        uint64_t v15 = "need to clear flags (0x%llx) in inode (object-id %llu)\n";
        goto LABEL_44;
      case 0x13u:
        if ((v12 & 0x800) != 0) {
          uint64_t v14 = sub_100040B90;
        }
        else {
          uint64_t v14 = sub_100040C68;
        }
        uint64_t v15 = "need to set bsd flags (0x%x) in inode (object-id %llu)\n";
        goto LABEL_44;
      case 0x14u:
        if ((v12 & 0x800) != 0) {
          uint64_t v14 = sub_100040B90;
        }
        else {
          uint64_t v14 = sub_100040C68;
        }
        uint64_t v15 = "need to clear bsd flags (0x%x) in inode (object-id %llu)\n";
        goto LABEL_44;
      case 0x15u:
        if ((v12 & 0x800) != 0) {
          uint64_t v14 = sub_100040B90;
        }
        else {
          uint64_t v14 = sub_100040C68;
        }
        uint64_t v15 = "dir_nlink of inode object (id %llu) does not match expected value (%d)\n";
LABEL_44:
        ((void (*)(const char *))v14)(v15);
LABEL_45:
        uint64_t result = sub_100027A6C(v18, (*a3 >> 6) & 0x1F, (uint64_t)a3 + 5, v13, a5, v8);
        break;
      default:
        uint64_t result = 22LL;
        break;
    }
  }

  return result;
}

uint64_t sub_100026ADC( uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003AB6C(a1, a2, 4, &v19, (uint64_t)a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    uint64_t v12 = a3[1];
    unsigned int v13 = *a3;
    int v14 = (v13 >> 4) & 3;
    if (v14 == 1)
    {
      if ((v13 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "found xattr dstream (id %llu, name %.*s) that references a missing crypto state\n",  *(void *)((_BYTE *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL,  *(unsigned __int16 *)((char *)a3 + 13),  (const char *)a3 + 15);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "found xattr dstream (id %llu, name %.*s) that references a missing crypto state\n",  *(void *)((_BYTE *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL,  *(unsigned __int16 *)((char *)a3 + 13),  (const char *)a3 + 15);
      }
      return sub_100027A6C(v19, 25, (uint64_t)a3 + 5, v12, a5, v8);
    }

    else if (v14)
    {
      return 22LL;
    }

    else
    {
      if ((v13 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "found orphan/invalid xattr (id %llu, name %.*s)\n",  *(void *)((_BYTE *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL,  *(unsigned __int16 *)((char *)a3 + 13),  (const char *)a3 + 15);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "found orphan/invalid xattr (id %llu, name %.*s)\n",  *(void *)((_BYTE *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL,  *(unsigned __int16 *)((char *)a3 + 13),  (const char *)a3 + 15);
      }
      uint64_t v15 = v19;
      uint64_t v16 = *(void *)((char *)a3 + 5) >> 60;
      if ((_DWORD)v16 == 14) {
        LODWORD(v--*(_DWORD *)(result + 16) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v17 = sub_10003A294(v16);
      return sub_100026730(v15, 0LL, (uint64_t)a3 + 5, v12, 0LL, (uint64_t)v17, v8 != 0, v18);
    }
  }

  return result;
}

uint64_t sub_100026C30( uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = 0LL;
  uint64_t v12 = (unint64_t *)((char *)a3 + 5);
  uint64_t v13 = a3[1];
  uint64_t v14 = *(void *)((char *)a3 + 5) >> 60;
  uint64_t result = sub_10003AB6C(a1, a2, v14, (uint64_t *)&v36, (uint64_t)a5, a6, a7, a8);
  if ((_DWORD)result) {
    return result;
  }
  if ((_DWORD)v14 != 8)
  {
    if ((_DWORD)v14 != 6) {
      return 22LL;
    }
    unsigned int v16 = *a3;
    int v17 = (v16 >> 4) & 3;
    switch(v17)
    {
      case 2:
        if ((v16 & 0x800) != 0) {
          ((void (*)(const char *, ...))sub_100040B90)( "dstream (id %llu) does not have an associated dstream id object\n",  *v12 & 0xFFFFFFFFFFFFFFFLL);
        }
        else {
          ((void (*)(const char *, ...))sub_100040C68)( "dstream (id %llu) does not have an associated dstream id object\n",  *v12 & 0xFFFFFFFFFFFFFFFLL);
        }
        uint64_t v29 = v36;
        unint64_t v30 = *v12;
        goto LABEL_37;
      case 1:
        if ((v16 & 0x800) != 0) {
          ((void (*)(const char *, ...))sub_100040B90)( "refcnt of dstream id object (id %llu) less than expected\n",  *(void *)((_BYTE *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL);
        }
        else {
          ((void (*)(const char *, ...))sub_100040C68)( "refcnt of dstream id object (id %llu) less than expected\n",  *(void *)((_BYTE *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL);
        }
        return sub_100027A6C((uint64_t)v36, (*a3 >> 6) & 0x1F, (uint64_t)v12, v13, a5, a7);
      case 0:
        if ((v16 & 0x800) != 0) {
          ((void (*)(const char *, ...))sub_100040B90)( "found orphan dstream id object (id %llu)\n",  *v12 & 0xFFFFFFFFFFFFFFFLL);
        }
        else {
          ((void (*)(const char *, ...))sub_100040C68)( "found orphan dstream id object (id %llu)\n",  *v12 & 0xFFFFFFFFFFFFFFFLL);
        }
        uint64_t v18 = (uint64_t)v36;
        unint64_t v19 = *v12;
LABEL_22:
        unint64_t v26 = v19 >> 60;
        if (v19 >> 60 == 14) {
          LODWORD(v26) = *((unsigned __int8 *)a3 + 13);
        }
        uint64_t v27 = sub_10003A294(v26);
        return sub_100026730(v18, 0LL, (uint64_t)v12, v13, 0LL, (uint64_t)v27, (_DWORD)a7 != 0, v28);
    }
  }

  if ((_DWORD)a6) {
    uint64_t v20 = *(void *)a5 & 0xFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v20 = 0LL;
  }
  unsigned int v21 = *a3;
  int v22 = (v21 >> 4) & 3;
  if (v22 != 2)
  {
    if (v22 != 1)
    {
      if (!v22)
      {
        uint64_t v23 = (void (*)(const char *, ...))sub_100040B90;
        BOOL v24 = (v21 & 0x800) == 0;
        if ((v21 & 0x800) == 0) {
          uint64_t v23 = (void (*)(const char *, ...))sub_100040C68;
        }
        uint64_t v25 = "invalid";
        if (v24) {
          uint64_t v25 = "orphan";
        }
        v23( "found %s file extent object (id %llu) at logical address %llu\n",  v25,  *(void *)((_BYTE *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL,  *(void *)((char *)a3 + 13));
        uint64_t v18 = (uint64_t)v36;
        unint64_t v19 = *(void *)((char *)a3 + 5);
        goto LABEL_22;
      }

      return 22LL;
    }

    int v31 = (v21 >> 6) & 0x1F;
    if (v31 == 10)
    {
      uint64_t v32 = "found file extent overlap (id %llu) with next extent / end of dstream at logical address %llu+%llu\n";
    }

    else
    {
      if (v31 != 11) {
        return 22LL;
      }
      uint64_t v32 = "need to make file extent with missing crypto state (id %llu) at logical address %llu+%llu sparse\n";
    }

    if ((v21 & 0x800) != 0) {
      uint64_t v35 = sub_100040B90;
    }
    else {
      uint64_t v35 = sub_100040C68;
    }
    ((void (*)(const char *))v35)(v32);
    return sub_100027A6C((uint64_t)v36, (*a3 >> 6) & 0x1F, (uint64_t)v12, v13, a5, a7);
  }

  if ((v21 & 0x800) != 0) {
    ((void (*)(const char *, ...))sub_100040B90)( "found file extent gap (id %llu) at logical address %llu+%llu\n",  *(void *)((_BYTE *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL,  *(void *)((char *)a3 + 13),  v20);
  }
  else {
    ((void (*)(const char *, ...))sub_100040C68)( "found file extent gap (id %llu) at logical address %llu+%llu\n",  *(void *)((_BYTE *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL,  *(void *)((char *)a3 + 13),  v20);
  }
  uint64_t v29 = v36;
  unint64_t v30 = *(void *)((char *)a3 + 5);
LABEL_37:
  unint64_t v33 = v30 >> 60;
  if (v30 >> 60 == 14) {
    LODWORD(v33) = *((unsigned __int8 *)a3 + 13);
  }
  uint64_t v34 = sub_10003A294(v33);
  return sub_100026658(v29, 0LL, v12, v13, a5, a6, (uint64_t)v34, a7);
}

uint64_t sub_100026F30( uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003AB6C(a1, a2, 7, &v23, (uint64_t)a5, a6, a7, a8);
  if ((_DWORD)result) {
    return result;
  }
  uint64_t v12 = a3[1];
  uint64_t v13 = (void *)((char *)a3 + 5);
  unsigned int v14 = *a3;
  int v15 = (v14 >> 4) & 3;
  if (v15 == 1)
  {
    int v20 = (v14 >> 6) & 0x1F;
    if (v20 == 23)
    {
      if ((v14 & 0x800) != 0) {
        unsigned int v21 = sub_100040B90;
      }
      else {
        unsigned int v21 = sub_100040C68;
      }
      int v22 = "need to increment crypto state object (id %llu) refcount (%u)\n";
    }

    else
    {
      if (v20 != 22) {
        return 22LL;
      }
      if ((v14 & 0x800) != 0) {
        unsigned int v21 = sub_100040B90;
      }
      else {
        unsigned int v21 = sub_100040C68;
      }
      int v22 = "refcnt of crypto state object (id %llu) is %s than expected (%u)\n";
    }

    ((void (*)(const char *))v21)(v22);
    return sub_100027A6C(v23, (*a3 >> 6) & 0x1F, (uint64_t)a3 + 5, v12, a5, v8);
  }

  if (v15) {
    return 22LL;
  }
  if ((v14 & 0x800) != 0) {
    ((void (*)(const char *, ...))sub_100040B90)( "found orphan/unexpected crypto state object (id %llu)\n",  *v13 & 0xFFFFFFFFFFFFFFFLL);
  }
  else {
    ((void (*)(const char *, ...))sub_100040C68)( "found orphan/unexpected crypto state object (id %llu)\n",  *v13 & 0xFFFFFFFFFFFFFFFLL);
  }
  uint64_t v16 = v23;
  uint64_t v17 = *v13 >> 60;
  if ((_DWORD)v17 == 14) {
    LODWORD(v17) = *((unsigned __int8 *)a3 + 13);
  }
  uint64_t v18 = sub_10003A294(v17);
  return sub_100026730(v16, 0LL, (uint64_t)a3 + 5, v12, 0LL, (uint64_t)v18, v8 != 0, v19);
}

uint64_t sub_1000270D0( uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003AB6C(a1, a2, 9, &v20, (uint64_t)a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    uint64_t v12 = a3[1];
    uint64_t v13 = (void *)((char *)a3 + 5);
    unsigned int v14 = *a3;
    int v15 = (v14 >> 4) & 3;
    if (v15 == 1)
    {
      if ((v14 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "found invalid directory record object (id %llu)\n",  *v13 & 0xFFFFFFFFFFFFFFFLL);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "found invalid directory record object (id %llu)\n",  *v13 & 0xFFFFFFFFFFFFFFFLL);
      }
      return sub_100027A6C(v20, 24, (uint64_t)a3 + 5, v12, a5, v8);
    }

    else if (v15)
    {
      return 22LL;
    }

    else
    {
      if ((v14 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "found orphan directory record object (id %llu)\n",  *v13 & 0xFFFFFFFFFFFFFFFLL);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "found orphan directory record object (id %llu)\n",  *v13 & 0xFFFFFFFFFFFFFFFLL);
      }
      uint64_t v16 = v20;
      uint64_t v17 = *v13 >> 60;
      if ((_DWORD)v17 == 14) {
        LODWORD(v17) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v18 = sub_10003A294(v17);
      return sub_100026730(v16, 0LL, (uint64_t)a3 + 5, v12, 0LL, (uint64_t)v18, v8 != 0, v19);
    }
  }

  return result;
}

uint64_t sub_10002720C( uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v29 = 0LL;
  uint64_t v12 = (void *)((char *)a3 + 5);
  uint64_t v13 = *(void *)((char *)a3 + 5) >> 60;
  if ((_DWORD)v13 == 14) {
    LODWORD(v13) = *((unsigned __int8 *)a3 + 13);
  }
  uint64_t v14 = *(unsigned __int16 *)((char *)v12 - 3);
  uint64_t result = sub_10003AB6C(a1, a2, v13, (uint64_t *)&v29, (uint64_t)a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    unsigned int v16 = *a3;
    int v17 = (v16 >> 4) & 3;
    if (v17 == 2)
    {
      if ((v16 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)("dir-stats (id %llu) is missing\n", *v12 & 0xFFFFFFFFFFFFFFFLL);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)("dir-stats (id %llu) is missing\n", *v12 & 0xFFFFFFFFFFFFFFFLL);
      }
      int v22 = v29;
      uint64_t v23 = *v12 >> 60;
      if ((_DWORD)v23 == 14) {
        LODWORD(v23) = *((unsigned __int8 *)a3 + 13);
      }
      BOOL v24 = sub_10003A294(v23);
      return sub_100026658(v22, 0LL, v12, v14, a5, a6, (uint64_t)v24, a7);
    }

    else if (v17 == 1)
    {
      switch((v16 >> 6) & 0x1F)
      {
        case 1u:
          if ((v16 & 0x800) != 0) {
            uint64_t v25 = sub_100040B90;
          }
          else {
            uint64_t v25 = sub_100040C68;
          }
          unint64_t v26 = "chained key of dir-stats object (id %llu) does not match expected value (%llu)\n";
          goto LABEL_49;
        case 2u:
          if ((v16 & 0x800) != 0) {
            uint64_t v25 = sub_100040B90;
          }
          else {
            uint64_t v25 = sub_100040C68;
          }
          unint64_t v26 = "descendants of dir-stats object (id %llu) does not match expected value (%llu)\n";
          goto LABEL_49;
        case 3u:
          if ((v16 & 0x800) != 0) {
            uint64_t v25 = sub_100040B90;
          }
          else {
            uint64_t v25 = sub_100040C68;
          }
          unint64_t v26 = "flags of dir-stats object (id %llu) does not match expected value (0x%x)\n";
          goto LABEL_49;
        case 4u:
          if ((v16 & 0x800) != 0) {
            uint64_t v25 = sub_100040B90;
          }
          else {
            uint64_t v25 = sub_100040C68;
          }
          unint64_t v26 = "origin_id of dir-stats object (id %llu) does not match expected value (%llu)\n";
          goto LABEL_49;
        case 5u:
          if ((v16 & 0x800) != 0) {
            uint64_t v25 = sub_100040B90;
          }
          else {
            uint64_t v25 = sub_100040C68;
          }
          unint64_t v26 = "physical size of dir-stats object (id %llu) does not match expected value (%llu)\n";
          goto LABEL_49;
        case 6u:
          if ((v16 & 0x800) != 0) {
            uint64_t v27 = sub_100040B90;
          }
          else {
            uint64_t v27 = sub_100040C68;
          }
          sub_10003A2C4((uint64_t)v12, *a5);
          uint64_t v28 = "%s xfield of dir-stats object (id %llu) exists unexpectedly\n";
          goto LABEL_54;
        case 7u:
          if ((v16 & 0x800) != 0) {
            uint64_t v25 = sub_100040B90;
          }
          else {
            uint64_t v25 = sub_100040C68;
          }
          unint64_t v26 = "resource fork size of dir-stats object (id %llu) does not match expected value (%llu)\n";
LABEL_49:
          ((void (*)(const char *))v25)(v26);
          break;
        case 8u:
          if ((v16 & 0x800) != 0) {
            uint64_t v27 = sub_100040B90;
          }
          else {
            uint64_t v27 = sub_100040C68;
          }
          sub_10003A2C4((uint64_t)v12, *a5);
          uint64_t v28 = "%s xfield of dir-stats object (id %llu) does not match expected value (%llu)\n";
LABEL_54:
          ((void (*)(const char *))v27)(v28);
          break;
        default:
          return 22LL;
      }

      return sub_100027A6C((uint64_t)v29, (*a3 >> 6) & 0x1F, (uint64_t)v12, v14, a5, a7);
    }

    else if (v17)
    {
      return 22LL;
    }

    else
    {
      if ((v16 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "found invalid dir-stats object (id %llu)\n",  *v12 & 0xFFFFFFFFFFFFFFFLL);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "found invalid dir-stats object (id %llu)\n",  *v12 & 0xFFFFFFFFFFFFFFFLL);
      }
      uint64_t v18 = (uint64_t)v29;
      uint64_t v19 = *v12 >> 60;
      if ((_DWORD)v19 == 14) {
        LODWORD(v19) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v20 = sub_10003A294(v19);
      return sub_100026730(v18, 0LL, (uint64_t)v12, v14, 0LL, (uint64_t)v20, (_DWORD)a7 != 0, v21);
    }
  }

  return result;
}

uint64_t sub_100027594( uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v21 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100029FA4(a1, a2, (uint64_t *)&v21);
  if (!(_DWORD)result)
  {
    uint64_t v11 = a3[1];
    unsigned int v12 = *a3;
    int v13 = (v12 >> 4) & 3;
    if (v13 == 2)
    {
      if ((v12 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "no snap_name entry found for snap_meta entry with xid %llu and name %.*s\n",  *a5,  *(unsigned __int16 *)((char *)a3 + 13),  (const char *)a3 + 15);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "no snap_name entry found for snap_meta entry with xid %llu and name %.*s\n",  *a5,  *(unsigned __int16 *)((char *)a3 + 13),  (const char *)a3 + 15);
      }
      uint64_t v18 = v21;
      uint64_t v19 = *(void *)((char *)a3 + 5) >> 60;
      if ((_DWORD)v19 == 14) {
        LODWORD(v19) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v20 = sub_10003A294(v19);
      return sub_100026658(v18, 0LL, (char *)a3 + 5, v11, a5, 8LL, (uint64_t)v20, a7);
    }

    else if (v13)
    {
      return 22LL;
    }

    else
    {
      if ((v12 & 0x800) != 0) {
        ((void (*)(const char *, ...))sub_100040B90)( "no snap_meta entry found for snap_name entry with name %.*s\n",  *(unsigned __int16 *)((char *)a3 + 13),  (const char *)a3 + 15);
      }
      else {
        ((void (*)(const char *, ...))sub_100040C68)( "no snap_meta entry found for snap_name entry with name %.*s\n",  *(unsigned __int16 *)((char *)a3 + 13),  (const char *)a3 + 15);
      }
      uint64_t v14 = (uint64_t)v21;
      uint64_t v15 = *(void *)((char *)a3 + 5) >> 60;
      if ((_DWORD)v15 == 14) {
        LODWORD(v15) = *((unsigned __int8 *)a3 + 13);
      }
      unsigned int v16 = sub_10003A294(v15);
      return sub_100026730(v14, 0LL, (uint64_t)a3 + 5, v11, 0LL, (uint64_t)v16, (_DWORD)a7 != 0, v17);
    }
  }

  return result;
}

uint64_t sub_1000276F8( uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v11 = (void *)((char *)a3 + 5);
  uint64_t v12 = a3[1];
  uint64_t v13 = *(void *)((char *)a3 + 5) >> 60;
  unint64_t v14 = v11[1];
  uint64_t v26 = 0LL;
  uint64_t result = sub_10003AB6C(a1, a2, v13, &v26, (uint64_t)a5, a6, a7, a8);
  if ((_DWORD)result) {
    return result;
  }
  unsigned int v16 = *a3;
  int v17 = (v16 >> 4) & 3;
  if (v17 != 1)
  {
    if (!v17)
    {
      if (HIBYTE(v14) == 2)
      {
        if ((v16 & 0x800) != 0) {
          uint64_t v18 = sub_100040B90;
        }
        else {
          uint64_t v18 = sub_100040C68;
        }
        uint64_t v19 = "file info: found orphan attribution tag with hash (%llu)\n";
        goto LABEL_20;
      }

      if (HIBYTE(v14) == 1)
      {
        if ((v16 & 0x800) != 0) {
          uint64_t v18 = sub_100040B90;
        }
        else {
          uint64_t v18 = sub_100040C68;
        }
        uint64_t v19 = "file info: found orphan data hash (id %llu) at logical address %llu\n";
LABEL_20:
        ((void (*)(const char *))v18)(v19);
        uint64_t v22 = v26;
        uint64_t v23 = *v11 >> 60;
        if ((_DWORD)v23 == 14) {
          LODWORD(v23) = *((unsigned __int8 *)a3 + 13);
        }
        BOOL v24 = sub_10003A294(v23);
        return sub_100026730(v22, 0LL, (uint64_t)v11, v12, 0LL, (uint64_t)v24, v8 != 0, v25);
      }
    }

    return 22LL;
  }

  switch((v16 >> 6) & 0x1F)
  {
    case 0x1Au:
      if ((v16 & 0x800) != 0) {
        uint64_t v20 = sub_100040B90;
      }
      else {
        uint64_t v20 = sub_100040C68;
      }
      uint64_t v21 = "file info: attribution tag (hash %llu) with invalid jobj_id (%llu)\n";
      break;
    case 0x1Bu:
      if ((v16 & 0x800) != 0) {
        uint64_t v20 = sub_100040B90;
      }
      else {
        uint64_t v20 = sub_100040C68;
      }
      uint64_t v21 = "file info: attribution tag with invalid hash (%llu)\n";
      break;
    case 0x1Cu:
      if ((v16 & 0x800) != 0) {
        uint64_t v20 = sub_100040B90;
      }
      else {
        uint64_t v20 = sub_100040C68;
      }
      uint64_t v21 = "file info: attribution tag (hash %llu): total count does not match expected value (%llu)\n";
      break;
    case 0x1Du:
      if ((v16 & 0x800) != 0) {
        uint64_t v20 = sub_100040B90;
      }
      else {
        uint64_t v20 = sub_100040C68;
      }
      uint64_t v21 = "file info: attribution tag (hash %llu): physical size does not match expected value (%llu)\n";
      break;
    case 0x1Eu:
      if ((v16 & 0x800) != 0) {
        uint64_t v20 = sub_100040B90;
      }
      else {
        uint64_t v20 = sub_100040C68;
      }
      uint64_t v21 = "file info: attribution tag (hash %llu): full clone size does not match expected value (%llu)\n";
      break;
    default:
      return 22LL;
  }

  ((void (*)(const char *))v20)(v21);
  return sub_100027A6C(v26, (*a3 >> 6) & 0x1F, (uint64_t)v11, v12, a5, v8);
}

uint64_t sub_100027960( uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003AB6C(a1, a2, 19, (uint64_t *)&v23, (uint64_t)a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    uint64_t v13 = a3[1];
    unint64_t v14 = (void *)((char *)a3 + 5);
    int v15 = (*a3 >> 4) & 3;
    if (v15 == 2)
    {
      uint64_t v20 = v23;
      uint64_t v21 = *v14 >> 60;
      if ((_DWORD)v21 == 14) {
        LODWORD(v21) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v22 = sub_10003A294(v21);
      return sub_100026658(v20, 0LL, (char *)a3 + 5, v13, a5, a6, (uint64_t)v22, a7);
    }

    else if (v15)
    {
      return 22LL;
    }

    else
    {
      uint64_t v16 = (uint64_t)v23;
      uint64_t v17 = *v14 >> 60;
      if ((_DWORD)v17 == 14) {
        LODWORD(v17) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v18 = sub_10003A294(v17);
      return sub_100026730(v16, 0LL, (uint64_t)a3 + 5, v13, 0LL, (uint64_t)v18, (_DWORD)a7 != 0, v19);
    }
  }

  return result;
}

uint64_t sub_100027A6C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, int a6)
{
  uint64_t v12 = *(void *)a3 >> 60;
  if ((_DWORD)v12 == 14) {
    LODWORD(v12) = *(unsigned __int8 *)(a3 + 8);
  }
  char v111 = sub_10003A294(v12);
  uint64_t v13 = calloc(1uLL, 0x340uLL);
  unsigned int v117 = -1431655766;
  unint64_t v14 = calloc(1uLL, 0xEE0uLL);
  uint64_t v22 = v14;
  unsigned int v116 = 3808;
  if (v13 && v14)
  {
    if (a6 == 1
      || a6 != 2
      && sub_1000428C4(qword_10008DB70, "Update %s objects? ", v16, v17, v18, v19, v20, v21, v111))
    {
      __memcpy_chk(v13, a3, a4, 832LL);
      unsigned int v117 = a4;
      uint64_t v23 = sub_100034BB4(a1, 0LL, 0LL, v13, &v117, 0x340u, v22, &v116);
      if ((_DWORD)v23)
      {
        uint64_t v24 = v23;
        strerror(v23);
        sub_100040B90("failed to lookup %s object: %s\n", v25, v26, v27, v28, v29, v30, v31, v111);
        uint64_t v32 = 819LL;
LABEL_10:
        sub_100044E7C((char *)v32, v24);
        goto LABEL_16;
      }

      unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v115 = 0LL;
      memset(v114, 170, sizeof(v114));
      if ((a2 - 13) > 1)
      {
        uint64_t v43 = 0LL;
        unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
      }

      else
      {
        uint64_t v24 = sub_10003B6C4((unsigned __int16 *)v22 + 46, v116 - 92, 8, &v115, v114, 0LL, 0LL);
        if ((_DWORD)v24)
        {
LABEL_22:
          uint64_t v35 = *(void *)v13 & 0xFFFFFFFFFFFFFFFLL;
          strerror(v24);
          sub_100040B90("failed to get inode (id %llu) dstream: %s\n", v36, v37, v38, v39, v40, v41, v42, v35);
          uint64_t v32 = 892LL;
          goto LABEL_10;
        }

        if (v114[0] < 0x28u)
        {
          uint64_t v24 = 34LL;
          goto LABEL_22;
        }

        uint64_t v43 = v115;
        unint64_t v34 = *(void *)v115;
        unint64_t v44 = *(void *)(v115 + 8);
        unint64_t v45 = *(void *)(v115 + 16);
        *(_OWORD *)&v114[1] = *(_OWORD *)(v115 + 24);
      }

      switch(a2)
      {
        case 1:
          uint64_t v47 = *(void *)a5;
          if ((_DWORD)v12 == 10) {
            goto LABEL_69;
          }
          v22[4] = v47;
          goto LABEL_70;
        case 2:
        case 10:
        case 28:
          *uint64_t v22 = *(void *)a5;
          goto LABEL_70;
        case 3:
          *((_DWORD *)v22 + 12) = *(_DWORD *)a5;
          goto LABEL_70;
        case 4:
          v22[3] = *(void *)a5;
          goto LABEL_70;
        case 5:
          uint64_t v48 = *(void *)a5;
          goto LABEL_67;
        case 6:
          int v49 = *a5;
          LODWORD(v113) = v116 - 52;
          uint64_t v50 = sub_10003B954((unsigned __int16 *)v22 + 26, (unsigned int *)&v113, v49);
          if ((_DWORD)v50)
          {
            uint64_t v24 = v50;
            uint64_t v51 = *(void *)v13 & 0xFFFFFFFFFFFFFFFLL;
            sub_10003A2C4((uint64_t)v13, v49);
            strerror(v24);
            sub_100040B90( "failed to remove dir stats (id %llu) %s xfield: %s (%d)",  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v51);
            uint64_t v32 = 1377LL;
            goto LABEL_10;
          }

          unsigned int v116 = v113 + 52;
          goto LABEL_70;
        case 7:
          uint64_t v47 = *(void *)a5;
          goto LABEL_69;
        case 8:
          uint64_t v113 = 0LL;
          uint64_t v59 = sub_10003BE34(v22, (int *)&v116, *a5, a5 + 4, *((unsigned __int16 *)a5 + 1), &v113);
          uint64_t v24 = v59;
          if (!(_DWORD)v59)
          {
            uint64_t v60 = v113;
            if (v113)
            {
              free(v22);
              uint64_t v22 = (void *)v60;
              goto LABEL_70;
            }
          }

          if (!(_DWORD)v59) {
            goto LABEL_70;
          }
          goto LABEL_16;
        case 9:
        case 22:
          int v46 = *(_DWORD *)a5;
          goto LABEL_59;
        case 11:
          v22[1] = 0LL;
          int v22[2] = 0LL;
          goto LABEL_70;
        case 12:
          *((_DWORD *)v22 + 14) = *((_DWORD *)a5 + 14);
          goto LABEL_70;
        case 13:
          unint64_t v44 = *((void *)a5 + 1);
          goto LABEL_44;
        case 14:
          unint64_t v45 = *((void *)a5 + 2);
          if (v45 == -1LL) {
            v22[6] |= 0x10uLL;
          }
LABEL_44:
          *(void *)uint64_t v43 = v34;
          *(void *)(v43 + 8) = v44;
          *(void *)(v43 + --*(_DWORD *)(result + 16) = v45;
          *(_OWORD *)(v43 + 24) = *(_OWORD *)&v114[1];
          goto LABEL_70;
        case 15:
          int v61 = *a5;
          LODWORD(v113) = v116 - 92;
          uint64_t v62 = sub_10003B954((unsigned __int16 *)v22 + 46, (unsigned int *)&v113, v61);
          unsigned int v116 = v113 + 92;
          if (!(_DWORD)v62) {
            goto LABEL_70;
          }
          uint64_t v24 = v62;
          uint64_t v63 = *(void *)v13 & 0xFFFFFFFFFFFFFFFLL;
          strerror(v62);
          sub_100040B90( "failed to remove inode (oid 0x%llx) xfield (type %u): %s\n",  v64,  v65,  v66,  v67,  v68,  v69,  v70,  v63);
          uint64_t v32 = 893LL;
          goto LABEL_10;
        case 16:
          v22[6] |= 0x200uLL;
          uint64_t v113 = 0LL;
          uint64_t v71 = sub_10003BD8C(v22, (int *)&v116, *(void *)a5, &v113);
          if (!(_DWORD)v71) {
            goto LABEL_78;
          }
          uint64_t v24 = v71;
          uint64_t v72 = *(void *)v13 & 0xFFFFFFFFFFFFFFFLL;
          strerror(v71);
          sub_100040B90("failed to repair inode sparse bytes (id %llu): %s\n", v73, v74, v75, v76, v77, v78, v79, v72);
          uint64_t v32 = 1205LL;
          goto LABEL_10;
        case 17:
          uint64_t v80 = v22[6] | *(void *)a5;
          goto LABEL_51;
        case 18:
          uint64_t v80 = v22[6] & ~*(void *)a5;
LABEL_51:
          v22[6] = v80;
          goto LABEL_70;
        case 19:
          int v81 = *((_DWORD *)v22 + 17) | *(_DWORD *)a5;
          goto LABEL_54;
        case 20:
          int v81 = *((_DWORD *)v22 + 17) & ~*(_DWORD *)a5;
LABEL_54:
          *((_DWORD *)v22 + 17) = v81;
          goto LABEL_70;
        case 21:
          uint64_t v82 = *(void *)(*(void *)(a1 + 8) + 40LL);
          if ((*(_BYTE *)(v82 + 57) & 2) != 0)
          {
            *((_DWORD *)v22 + 21) = *((_DWORD *)a5 + 21);
          }

          else
          {
            if ((*(_BYTE *)(v82 + 48) & 2) == 0)
            {
LABEL_57:
              uint64_t v24 = 22LL;
              goto LABEL_16;
            }

            uint64_t v112 = *((int *)a5 + 21);
            uint64_t v113 = 0LL;
            uint64_t v100 = sub_10003BB1C(v22, (int *)&v116, 17LL, &v112, 8LL, &v113);
            if ((_DWORD)v100)
            {
              uint64_t v24 = v100;
              uint64_t v101 = *(void *)v13 & 0xFFFFFFFFFFFFFFFLL;
              strerror(v100);
              sub_100040B90( "failed to repair inode nlink (id %llu): %s\n",  v102,  v103,  v104,  v105,  v106,  v107,  v108,  v101);
              uint64_t v32 = 1206LL;
              goto LABEL_10;
            }

LABEL_78:
            uint64_t v109 = v113;
            if (v113)
            {
              free(v22);
              uint64_t v22 = (void *)v109;
            }
          }

LABEL_70:
          uint64_t v92 = sub_1000364F0((_DWORD *)a1, 0LL, v13, v117, v22, v116);
          uint64_t v24 = v92;
          if (!(_DWORD)v92) {
            goto LABEL_16;
          }
          strerror(v92);
          sub_100040B90("failed to update %s object: %s\n", v93, v94, v95, v96, v97, v98, v99, v111);
          uint64_t v32 = 706LL;
          break;
        case 23:
          int v46 = *(_DWORD *)v22 + 1;
LABEL_59:
          *(_DWORD *)uint64_t v22 = v46;
          goto LABEL_70;
        case 24:
          __int16 v83 = v13[2];
          v13[2] &= 0x3FFu;
          v13[2] = v83 & 0x3FF | (*(_DWORD *)a5 << 10);
          goto LABEL_64;
        case 25:
          *(void *)((char *)v22 + 28) = *(void *)a5;
          goto LABEL_70;
        case 26:
          *(void *)uint64_t v13 = 0xD000000000000009LL;
          goto LABEL_64;
        case 27:
          *((void *)v13 + 1) = *(void *)a5 & 0xFFFFFFFFFFFFFFLL | 0x200000000000000LL;
LABEL_64:
          uint64_t v84 = sub_100036AC4(a1, 0LL, a3, a4);
          if (!(_DWORD)v84) {
            goto LABEL_70;
          }
          uint64_t v24 = v84;
          strerror(v84);
          sub_100040B90("failed to remove %s object (id %llu): %s\n", v85, v86, v87, v88, v89, v90, v91, v111);
          uint64_t v32 = 950LL;
          goto LABEL_10;
        case 29:
          uint64_t v48 = *((void *)a5 + 1);
LABEL_67:
          v22[1] = v48;
          goto LABEL_70;
        case 30:
          uint64_t v47 = *((void *)a5 + 2);
LABEL_69:
          int v22[2] = v47;
          goto LABEL_70;
        default:
          goto LABEL_57;
      }

      goto LABEL_10;
    }

    uint64_t v24 = 89LL;
LABEL_16:
    free(v13);
    if (!v22) {
      return v24;
    }
    goto LABEL_13;
  }

  sub_100040B90("unable to allocate memory for tree repairs\n", v15, v16, v17, v18, v19, v20, v21, v110);
  uint64_t v24 = 12LL;
  sub_100044E7C((char *)0x34B, 12);
  if (v13) {
    goto LABEL_16;
  }
  if (v22) {
LABEL_13:
  }
    free(v22);
  return v24;
}

const char *sub_1000280A8(const char *result, ...)
{
  if (dword_1000705E8 >= 5) {
    return (const char *)vfprintf(__stderrp, result, va);
  }
  return result;
}

const char *sub_1000280F0(const char *result, ...)
{
  if (dword_1000705E8 >= 2) {
    return (const char *)vfprintf(__stderrp, result, va);
  }
  return result;
}

void *sub_100028138(size_t a1, size_t a2)
{
  uint64_t result = calloc(a1, a2);
  if (result)
  {
    do
      unint64_t v5 = __ldxr(&qword_10008DEB0);
    while (__stxr(v5 + a2 * a1, &qword_10008DEB0));
  }

  return result;
}

void sub_10002817C(void *a1, uint64_t a2)
{
  if (a1)
  {
    free(a1);
    do
      unint64_t v3 = __ldxr(&qword_10008DEB0);
    while (__stxr(v3 - a2, &qword_10008DEB0));
  }

void *sub_1000281BC(size_t a1)
{
  uint64_t result = malloc(a1);
  if (result)
  {
    do
      unint64_t v3 = __ldxr(&qword_10008DEB0);
    while (__stxr(v3 + a1, &qword_10008DEB0));
  }

  return result;
}

uint64_t sub_1000281F8(_DWORD *a1, unsigned int a2, const void *a3, uint64_t a4)
{
  unsigned int v11 = -1431655766;
  unsigned int v10 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = sub_10002828C(a2, a3, &v10, &v11);
  if (!(_DWORD)v6)
  {
    uint64_t v9 = a4;
    int v7 = v10;
    uint64_t v6 = sub_1000364F0(a1, 0LL, v10, v11, &v9, 8LL);
    free(v7);
  }

  return v6;
}

uint64_t sub_10002828C(unsigned int a1, const void *a2, void *a3, unsigned int *a4)
{
  unsigned int v8 = a1 + 10;
  uint64_t v9 = malloc(a1 + 10);
  if (!v9) {
    return 12LL;
  }
  unsigned int v10 = v9;
  *(void *)uint64_t v9 = 0xBFFFFFFFFFFFFFFFLL;
  v9[4] = a1;
  memcpy(v9 + 5, a2, a1);
  *a3 = v10;
  uint64_t result = 0LL;
  if (a4) {
    *a4 = v8;
  }
  return result;
}

uint64_t sub_10002830C(uint64_t a1, unsigned int a2, const void *a3)
{
  unsigned int v8 = -1431655766;
  int v7 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = sub_10002828C(a2, a3, &v7, &v8);
  if (!(_DWORD)v4)
  {
    unint64_t v5 = v7;
    uint64_t v4 = sub_100036AC4(a1, 0LL, (uint64_t)v7, v8);
    free(v5);
  }

  return v4;
}

uint64_t sub_100028390(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned int a5, char a6, _DWORD *a7)
{
  uint64_t v13 = *a3;
  unint64_t v14 = (char *)calloc(1uLL, 0x10AuLL);
  uint64_t v15 = (unint64_t *)calloc(1uLL, 0x132uLL);
  if (v14 && (uint64_t v23 = v15) != 0LL)
  {
    unint64_t v76 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v77 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v24 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v73[0] = v24;
    v73[1] = v24;
    __int128 v74 = v24;
    __int128 v75 = v24;
    __src[14] = v24;
    __src[15] = v24;
    __src[12] = v24;
    __src[13] = v24;
    __src[10] = v24;
    __src[11] = v24;
    __src[8] = v24;
    __src[9] = v24;
    __src[6] = v24;
    __src[7] = v24;
    __src[4] = v24;
    __src[5] = v24;
    __src[3] = v24;
    __src[1] = v24;
    __src[2] = v24;
    __src[0] = v24;
    *(void *)unint64_t v14 = 0xBFFFFFFFFFFFFFFFLL;
    uint64_t v25 = sub_100029FA4(a1, a2, &v77);
    if ((_DWORD)v25 || (uint64_t v25 = sub_100035394((uint64_t)v73, v77, 0LL, v14, 0xAu, 0x10Au, v23, 306), (_DWORD)v25))
    {
      char v26 = strerror(v25);
      sub_100040B90("unable to setup snapshot tree iteration: %s\n", v27, v28, v29, v30, v31, v32, v33, v26);
      uint64_t v34 = 1266LL;
LABEL_6:
      sub_100044E7C((char *)v34, v25);
    }

    else if (BYTE8(v74))
    {
      uint64_t v25 = 2LL;
    }

    else
    {
      unsigned __int16 v68 = 0;
      uint64_t v36 = v13 & 0xFFFFFFFFFFFFFFFLL;
      size_t v37 = a5 - 50LL;
      uint64_t v70 = (void *)(a4 + 50);
      uint64_t v71 = v14 + 10;
      unsigned int v69 = -1;
      do
      {
        if (*(void *)v14 >> 60 == 11LL && *v23 == v36)
        {
          int v72 = -1431655766;
          int v38 = sub_10000E138(a2, (uint64_t *)v14, v74, v23, SDWORD1(v74), 0, &v72);
          if (!(v38 | v72))
          {
            size_t v39 = *((unsigned __int16 *)v14 + 4);
            if (v37 >= v39) {
              size_t v40 = *((unsigned __int16 *)v14 + 4);
            }
            else {
              size_t v40 = v37;
            }
            if ((a6 & 2) != 0 && !strncmp((const char *)v70, v71, v40))
            {
              if (sub_1000428C4( qword_10008DB70,  "Fix snapshot meta name_len (%u) from snap name entry? ",  v41,  v42,  v43,  v44,  v45,  v46,  v39))
              {
                *(_WORD *)(a4 + 48) = v40;
                bzero(v70, v37);
                uint64_t v57 = (void *)(a4 + 50);
                uint64_t v56 = v14 + 10;
                size_t v58 = v40;
                goto LABEL_29;
              }

              goto LABEL_34;
            }

            if ((a6 & 1) != 0)
            {
              unsigned int v47 = sub_100028700((uint64_t)v70, *(unsigned __int16 *)(a4 + 48), (unsigned __int8 *)v71, v39);
              if (v47 < v69)
              {
                unsigned int v48 = v47;
                __memcpy_chk(__src, v71, v40, 256LL);
                unsigned int v69 = v48;
                unsigned __int16 v68 = v40;
              }
            }
          }
        }

        uint64_t v49 = (*((uint64_t (**)(_OWORD *))&v73[0] + 1))(v73);
        if ((_DWORD)v49)
        {
          uint64_t v25 = v49;
          char v59 = strerror(v49);
          sub_100040B90("error iterating snapshot tree: %s\n", v60, v61, v62, v63, v64, v65, v66, v59);
          uint64_t v34 = 1267LL;
          goto LABEL_6;
        }
      }

      while (!BYTE8(v74));
      if (v69 == -1)
      {
        uint64_t v25 = 0LL;
        goto LABEL_7;
      }

      if (sub_1000428C4( qword_10008DB70,  "Fix snapshot meta name (%.*s) from snap name entry? ",  v50,  v51,  v52,  v53,  v54,  v55,  v68))
      {
        *(_WORD *)(a4 + 48) = v68;
        bzero(v70, v68);
        uint64_t v56 = __src;
        uint64_t v57 = (void *)(a4 + 50);
        size_t v58 = v68;
LABEL_29:
        memcpy(v57, v56, v58);
        uint64_t v25 = 0LL;
        *a7 = 1;
        goto LABEL_7;
      }

LABEL_7:
    free(v14);
    free(v23);
  }

  else
  {
    sub_100040B90("failed to allocate memory for snapshot repair\n", v16, v17, v18, v19, v20, v21, v22, v67);
    uint64_t v25 = 12LL;
    sub_100044E7C((char *)0x4F1, 12);
  }

  return v25;
}

      uint64_t v9 = v8;
      goto LABEL_15;
    }

uint64_t sub_100028700(uint64_t a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v7 = a4;
  uint64_t v8 = a4 + 1LL;
  __chkstk_darwin();
  unsigned int v10 = (_DWORD *)((char *)&v25 - v9);
  memset((char *)&v25 - v9, 170, v11);
  uint64_t v12 = 0LL;
  do
  {
    v10[v12] = v12;
    ++v12;
  }

  while (v8 != v12);
  if (a2)
  {
    uint64_t v13 = 1LL;
    do
    {
      int v14 = v13;
      if ((_DWORD)v7)
      {
        unsigned __int16 v15 = v13 - 1;
        int v16 = *(unsigned __int8 *)(a1 + v13 - 1);
        uint64_t v17 = a3;
        uint64_t v18 = v10 + 1;
        uint64_t v19 = v7;
        LOWORD(v20) = v13;
        do
        {
          int v21 = *v17++;
          if (v16 != v21) {
            ++v15;
          }
          unsigned int v22 = *v18;
          LOWORD(v20) = v20 + 1;
          else {
            unsigned int v20 = (unsigned __int16)(v22 + 1);
          }
          if (v20 >= v15) {
            unsigned int v20 = v15;
          }
          *v18++ = v20;
          unsigned __int16 v15 = v22;
          --v19;
        }

        while (v19);
      }
    }

    while (v13++ != a2);
    *unsigned int v10 = v14;
  }

  return v10[v7];
}

uint64_t sub_100028844()
{
  uint64_t result = sub_100034B44( (uint64_t)&unk_10008C970,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  0,  2,  0,  0LL,  (uint64_t)sub_1000288C0);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_100036C00((uint64_t)&unk_10008C970, 0LL, 0);
    if ((_DWORD)result) {
      qword_10008C9A8 = 0LL;
    }
  }

  return result;
}

uint64_t sub_1000288C0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 >= 0x10 && a5 >= 0x10)
  {
    if (*(void *)a2 >= *(void *)a4)
    {
      if (*(void *)a2 > *(void *)a4)
      {
        int v8 = 1;
LABEL_11:
        uint64_t result = 0LL;
        *a6 = v8;
        return result;
      }

      unsigned int v9 = *(unsigned __int16 *)(a2 + 8);
      unsigned int v10 = *(unsigned __int16 *)(a4 + 8);
      if (v9 >= v10) {
        size_t v11 = *(unsigned __int16 *)(a4 + 8);
      }
      else {
        size_t v11 = *(unsigned __int16 *)(a2 + 8);
      }
      int v12 = memcmp((const void *)(a2 + 10), (const void *)(a4 + 10), v11);
      if ((v12 & 0x80000000) == 0)
      {
        if (v12) {
          int v8 = 1;
        }
        else {
          int v8 = -1;
        }
        if (v12) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = v9 >= v10;
        }
        if (v13) {
          int v8 = v9 > v10;
        }
        goto LABEL_11;
      }
    }

    int v8 = -1;
    goto LABEL_11;
  }

  return result;
}

uint64_t sub_100028964(void *a1, uint64_t a2)
{
  return sub_100028980(*a1 & 0xFFFFFFFFFFFFFFFLL, *(unsigned __int16 *)(a2 + 48), a2 + 50, 0);
}

uint64_t sub_100028980(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  if (!qword_10008C9A8) {
    return 0LL;
  }
  unsigned int v24 = a2 + 16;
  int v8 = calloc(1uLL, 0x110uLL);
  if (v8)
  {
    int v16 = v8;
    unsigned int v23 = 2;
    __int16 v22 = 0;
    *(void *)int v8 = a1;
    v8[4] = a2;
    uint64_t v17 = (char *)(v8 + 5);
    __memcpy_chk(v8 + 5, a3, a2, 262LL);
    uint64_t v18 = sub_100034BB4((uint64_t)dword_10008C970, 0LL, 0LL, v16, &v24, 0x110u, &v22, &v23);
    if ((_DWORD)v18)
    {
      uint64_t v19 = v18;
      if ((_DWORD)v18 != 2)
      {
LABEL_12:
        free(v16);
        return v19;
      }

      *(void *)int v16 = a1;
      v16[4] = a2;
      __memcpy_chk(v17, a3, a2, 262LL);
    }

    if (a4) {
      HIBYTE(v22) = 1;
    }
    else {
      LOBYTE(v22) = 1;
    }
    uint64_t v19 = sub_1000364F0(dword_10008C970, 0LL, v16, v24, &v22, v23);
    goto LABEL_12;
  }

  sub_100040B90("failed to allocate memory for snapshot tracking\n", v9, v10, v11, v12, v13, v14, v15, v21);
  uint64_t v19 = 12LL;
  sub_100044E7C((char *)0x153, 12);
  return v19;
}

uint64_t sub_100028ADC(uint64_t a1, uint64_t *a2)
{
  return sub_100028980(*a2, *(unsigned __int16 *)(a1 + 8), a1 + 10, 1);
}

uint64_t sub_100028AF4(_DWORD *a1)
{
  if (qword_10008C9A8)
  {
    unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v51 = v2;
    __int128 v52 = v2;
    v50[0] = v2;
    v50[1] = v2;
    unint64_t v3 = (unsigned __int16 *)calloc(1uLL, 0x110uLL);
    if (!v3)
    {
      sub_100040B90("failed to allocate memory for snapshot validation\n", v4, v5, v6, v7, v8, v9, v10, v45);
      uint64_t v20 = 12LL;
      sub_100044E7C((char *)0x368, 12);
LABEL_9:
      sub_100036CD8((uint64_t)&unk_10008C970, 0LL);
      return v20;
    }

    uint64_t v11 = v3;
    __int16 v49 = 0;
    unsigned int v48 = -1431655766;
    uint64_t v46 = 0LL;
    unsigned int v47 = 0LL;
    uint64_t v12 = sub_100035394((uint64_t)v50, (uint64_t)&unk_10008C970, 0LL, v3, 0x10u, 0x110u, &v49, 2);
    if ((_DWORD)v12)
    {
      uint64_t v20 = v12;
      char v21 = strerror(v12);
      sub_100040B90( "unable to initialize iterator for snapshot validation: %s\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v21);
      uint64_t v29 = 873LL;
LABEL_5:
      sub_100044E7C((char *)v29, v20);
LABEL_6:
      free(v11);
      goto LABEL_9;
    }

    while (1)
    {
      if (BYTE8(v51))
      {
        uint64_t v20 = 0LL;
        goto LABEL_6;
      }

      if (HIBYTE(v49)) {
        BOOL v32 = 1;
      }
      else {
        BOOL v32 = v49 == 0;
      }
      if (!v32)
      {
        sub_100040B90( "no snap_name entry found for snap_meta entry with xid %llu and name %.*s\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  *(void *)v11);
        sub_100044E7C((char *)0x28E, 92);
        uint64_t v33 = sub_10002828C(v11[4], v11 + 5, &v47, &v48);
        if ((_DWORD)v33) {
          goto LABEL_28;
        }
        uint64_t v46 = *(void *)v11;
        uint64_t v34 = v47;
        uint64_t v35 = sub_1000251C0(a1, 5u, 2, 0, 1, v47, v48, &v46, 8u);
LABEL_24:
        uint64_t v20 = v35;
        free(v34);
        if ((_DWORD)v20) {
          goto LABEL_6;
        }
      }

      uint64_t v36 = (*((uint64_t (**)(_OWORD *))&v50[0] + 1))(v50);
      if ((_DWORD)v36)
      {
        uint64_t v20 = v36;
        char v37 = strerror(v36);
        sub_100040B90("error iterating snapshot tree: %s\n", v38, v39, v40, v41, v42, v43, v44, v37);
        uint64_t v29 = 874LL;
        goto LABEL_5;
      }
    }

    sub_100040B90( "no snap_meta entry found for snap_name entry with xid %llu and name %.*s\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  *(void *)v11);
    sub_100044E7C((char *)0x28C, 92);
    uint64_t v33 = sub_10002828C(v11[4], v11 + 5, &v47, &v48);
    if ((_DWORD)v33)
    {
LABEL_28:
      uint64_t v20 = v33;
      goto LABEL_6;
    }

    uint64_t v46 = *(void *)v11;
    uint64_t v34 = v47;
    uint64_t v35 = sub_1000251C0(a1, 5u, 0, 0, 1, v47, v48, 0LL, 0);
    goto LABEL_24;
  }

  return 0LL;
}

uint64_t sub_100028D78( unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void *a5, void *a6)
{
  if (!a4) {
    return 28LL;
  }
  unint64_t v6 = a1;
  if (a1 <= a2 || a4 < a1)
  {
    if (0x180000000LL * (a2 >> 12) > a4) {
      return 28LL;
    }
    if (a4 >> 34)
    {
      uint64_t v9 = 0x1000000000LL;
      if (a4 >= 0x1000000000LL) {
        unint64_t v10 = 0x1000000000LL;
      }
      else {
        unint64_t v10 = a4;
      }
      uint64_t v8 = v10 >> 5;
      if (a4 >= 0x1000000001LL)
      {
        if (a4 - 0x1000000000LL < 0x1000000000LL) {
          uint64_t v9 = a4 - 0x1000000000LL;
        }
        v8 += ((unint64_t)v9 * (unsigned __int128)0x666666666666667uLL) >> 64;
        if (a4 >= 0x2000000001LL)
        {
          unint64_t v11 = a4 - 0x2000000000LL;
          if (a4 - 0x2000000000LL >= 0x2000000000LL) {
            unint64_t v11 = 0x2000000000LL;
          }
          v8 += v11 >> 7;
          if (a4 >= 0x4000000001LL) {
            v8 += (a4 - 0x4000000000LL) / 0xA0;
          }
        }
      }
    }

    else
    {
      uint64_t v8 = 0x20000000LL;
    }

    unint64_t v6 = v8 * (a2 >> 12);
    if (v6 >= a4 >> 2) {
      unint64_t v6 = a4 >> 2;
    }
  }

  uint64_t result = 0LL;
  unint64_t v12 = v6 / a2;
  *a5 = v12 * a2;
  *a6 = a3 - v12;
  return result;
}

unint64_t sub_100028E80( unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6)
{
  if (a5) {
    *a5 = (a2 >> 1) / result + a3;
  }
  if (a6)
  {
    unint64_t v6 = (a2 >> 4) / result;
    if (v6 >= 0x8000000 / result) {
      unint64_t v6 = 0x8000000 / result;
    }
    *a6 = a4 - v6;
  }

  return result;
}

void sub_100028EBC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  if (!(void)xmmword_10008C9B0 || (sub_100028F14(a1, a2, a3, a6, a5, (uint64_t)a6, a7, a8), !v10))
  {
    if ((v8 & 0x40000000) != 0) {
      byte_10008C9C8 = 1;
    }
    *(void *)&xmmword_10008C9B0 = a4;
  }

double sub_100028F14( uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v29 = 0;
  int v10 = DWORD2(xmmword_10008C9B0);
  int v9 = HIDWORD(xmmword_10008C9B0);
  uint64_t v11 = *(void *)(a2 + 40);
  if ((*(_BYTE *)(v11 + 57) & 2) != 0) {
    int v12 = 1;
  }
  else {
    int v12 = (*(unsigned __int8 *)(v11 + 48) >> 1) & 1;
  }
  if (unk_10008C9C4 == dword_10008C9C0) {
    int v13 = 0;
  }
  else {
    int v13 = v12;
  }
  if (HIDWORD(xmmword_10008C9B0) != DWORD2(xmmword_10008C9B0) || v13 != 0)
  {
    if (byte_10008C9C8) {
      goto LABEL_18;
    }
    if (v29) {
      goto LABEL_18;
    }
  }

  uint64_t v16 = xmmword_10008C9B0 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
  if (v9 == v10) {
    goto LABEL_21;
  }
  sub_100040B90( "directory valence check: directory (oid 0x%llx): nchildren (%d) does not match drec count (%d)\n",  a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  xmmword_10008C9B0);
  sub_100044E7C((char *)0x330, 92);
  *(void *)uint64_t v28 = 0LL;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v25 = 0u;
  *(_DWORD *)&v28[8] = DWORD2(xmmword_10008C9B0);
  memset(&v28[12], 0, 32);
  if (!sub_1000292B8(a4, 12LL, v16, &v25, v17, v18, v19, v20))
  {
LABEL_21:
    if (!v13
      || (sub_100040B90( "directory valence check: directory (oid 0x%llx): nlink (%d) does not match subdirectory count (%d)\n",  a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  xmmword_10008C9B0),  sub_100044E7C((char *)0x4B7, 92),  memset(v28, 0, 36),  v26 = 0u,  v27 = 0u,  __int128 v25 = 0u,  *(void *)&v28[36] = dword_10008C9C0,  !sub_1000292B8(a4, 21LL, v16, &v25, v21, v22, v23, v24)))
    {
LABEL_18:
      double result = 0.0;
      xmmword_10008C9B0 = 0u;
      *(_OWORD *)&dword_10008C9C0 = 0u;
    }
  }

  return result;
}

void sub_1000290AC(uint64_t a1, int a2)
{
  DWORD2(xmmword_10008C9B0) = 0;
  HIDWORD(xmmword_10008C9B0) = a2;
}

void sub_1000290BC(uint64_t a1, int a2)
{
  dword_10008C9C0 = 0;
  unk_10008C9C4 = a2;
}

void sub_1000290CC( uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v8 = *(void *)a4 & 0xFFFFFFFFFFFFFFFLL;
  if (v8 != 1 && v8 != 7)
  {
    if (v8 == (void)xmmword_10008C9B0)
    {
      BOOL v11 = __OFADD__(DWORD2(xmmword_10008C9B0), 1);
      char v12 = BYTE8(xmmword_10008C9B0) + 1;
      ++DWORD2(xmmword_10008C9B0);
      if (v11)
      {
        sub_100040C68("drec count overflow (%d)\n", a2, a3, (uint64_t)a4, a5, a6, a7, (uint64_t)a8, v12);
        sub_100044E7C((char *)0x4B8, 92);
        DWORD2(xmmword_10008C9B0) = 0x7FFFFFFF;
      }

      if ((*(_WORD *)(a6 + 16) & 0xF) == 4)
      {
        BOOL v11 = __OFADD__(dword_10008C9C0, 1);
        char v13 = ++dword_10008C9C0;
        if (v11)
        {
          sub_100040C68("subdir count overflow (%d)\n", a2, a3, (uint64_t)a4, a5, a6, a7, (uint64_t)a8, v13);
          sub_100044E7C((char *)0x4B9, 92);
          dword_10008C9C0 = 0x7FFFFFFF;
        }
      }
    }

    else
    {
      sub_100028F14(a1, a2, a3, a8, a5, a6, a7, (uint64_t)a8);
      if (!v25)
      {
        sub_100040C68( "directory valence check: directory (oid 0x%llx): orphan directory record\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v8);
        sub_100044E7C((char *)0x34C, -8);
        sub_10002920C(a8, 0LL, 0LL, a4, a5, (_BYTE *)a6, a7, v26);
      }
    }
  }

uint64_t sub_10002920C( _DWORD *a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, _BYTE *a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_1000251C0(a1, 8u, a2, a3, 0, a4, a5, a6, a7);
  }
  else {
    return sub_100024E94(0LL, a2, a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8);
  }
}

void sub_100029254( uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((void)xmmword_10008C9B0) {
    sub_100028F14(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_10002926C( __int128 *a1, uint64_t a2, int a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a3;
  return sub_10002920C(a4, 1LL, 24LL, a1, a2, &v9, 4LL, a8);
}

void sub_1000292AC()
{
  *(void *)&xmmword_10008C9B0 = 0LL;
}

uint64_t sub_1000292B8( _DWORD *a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&__int128 var8 = a3;
  if (a1) {
    return sub_1000251C0(a1, 8u, 1, a2, 1, &var8, 8u, a4, 0x5Cu);
  }
  else {
    return sub_100024E94(0LL, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  }
}

uint64_t sub_10002930C( uint64_t a1, uint64_t (*a2)(void, void, void, void, uint64_t), uint64_t a3, int a4)
{
  uint64_t v8 = 0LL;
  while (1)
  {
    if (!a1) {
      return 0LL;
    }
    if (*(_BYTE *)(a1 + 40)) {
      break;
    }
    uint64_t v9 = a2(*(void *)(a1 + 16), *(unsigned int *)(a1 + 32), *(void *)(a1 + 24), *(unsigned int *)(a1 + 36), a3);
    if ((_DWORD)v9) {
      BOOL v10 = a4 == 0;
    }
    else {
      BOOL v10 = 0;
    }
    if (!v10)
    {
      uint64_t v8 = (_DWORD)v9 ? v9 : v8;
      uint64_t v9 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a1);
      if (!(_DWORD)v9) {
        continue;
      }
    }

    uint64_t v8 = v9;
    break;
  }

  if (*(void *)a1) {
    (*(void (**)(uint64_t))a1)(a1);
  }
  return v8;
}

uint64_t sub_1000293A8( uint64_t a1, uint64_t a2, uint64_t (*a3)(__int128 *, __int128 *, int *, uint64_t), uint64_t a4)
{
  int v24 = -1431655766;
  if (a1)
  {
    if (a2 && !*(_BYTE *)(a1 + 40))
    {
      while (1)
      {
        if (*(_BYTE *)(a2 + 40)) {
          goto LABEL_4;
        }
        int v24 = 3;
        __int128 v22 = *(_OWORD *)(a1 + 16);
        uint64_t v23 = *(void *)(a1 + 32);
        __int128 v20 = *(_OWORD *)(a2 + 16);
        uint64_t v21 = *(void *)(a2 + 32);
        uint64_t v8 = a3(&v22, &v20, &v24, a4);
        if ((_DWORD)v8) {
          break;
        }
        char v12 = v24;
        if ((v24 & 1) != 0)
        {
          uint64_t v8 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a1);
          if ((_DWORD)v8) {
            break;
          }
          char v12 = v24;
        }

        if ((v12 & 2) != 0)
        {
          uint64_t v8 = (*(uint64_t (**)(uint64_t))(a2 + 8))(a2);
          if ((_DWORD)v8) {
            break;
          }
        }

        if (*(_BYTE *)(a1 + 40)) {
          goto LABEL_4;
        }
      }

LABEL_4:
    while (!*(_BYTE *)(a1 + 40))
    {
      __int128 v18 = *(_OWORD *)(a1 + 16);
      uint64_t v19 = *(void *)(a1 + 32);
      uint64_t v15 = 0LL;
      uint64_t v16 = 0LL;
      uint64_t v17 = 0LL;
      uint64_t v8 = a3(&v18, (__int128 *)&v15, &v24, a4);
      if (!(_DWORD)v8)
      {
        uint64_t v8 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a1);
        if (!(_DWORD)v8) {
          continue;
        }
      }

      goto LABEL_7;
    }
  }

  if (a2)
  {
    while (!*(_BYTE *)(a2 + 40))
    {
      __int128 v13 = *(_OWORD *)(a2 + 16);
      uint64_t v14 = *(void *)(a2 + 32);
      uint64_t v15 = 0LL;
      uint64_t v16 = 0LL;
      uint64_t v17 = 0LL;
      uint64_t v10 = a3((__int128 *)&v15, &v13, &v24, a4);
      if (!(_DWORD)v10)
      {
        uint64_t v10 = (*(uint64_t (**)(uint64_t))(a2 + 8))(a2);
        if (!(_DWORD)v10) {
          continue;
        }
      }

      uint64_t v9 = v10;
      if (a1) {
        goto LABEL_15;
      }
      goto LABEL_17;
    }
  }

  uint64_t v9 = 0LL;
  if (a1)
  {
LABEL_15:
    if (*(void *)a1) {
      (*(void (**)(uint64_t))a1)(a1);
    }
  }

  uint64_t v5 = 0LL;
  *(_DWORD *)(a2 + 32) = 0;
  return v5;
}

void sub_10002955C(uint64_t *a1)
{
  if (a1[64]) {
    sub_100036CD8((uint64_t)(a1 + 57), 0LL);
  }
  for (uint64_t i = 24LL; i != 48; i += 8LL)
  {
    if (a1[i]) {
      a1[i] = 0LL;
    }
  }

  if (a1[48]) {
    a1[48] = 0LL;
  }
  if (a1[56]) {
    a1[56] = 0LL;
  }
  unint64_t v3 = (void *)a1[4];
  if (v3) {
    free(v3);
  }
  uint64_t v4 = (void *)a1[3];
  if (v4) {
    free(v4);
  }
  uint64_t v5 = (void *)a1[2];
  if (v5) {
    free(v5);
  }
  unint64_t v6 = (void *)a1[1];
  if (v6) {
    free(v6);
  }
  if (*a1) {
    sub_10002BE10(*a1);
  }
  bzero(a1, 0x208uLL);
}

uint64_t sub_100029604(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    *a1 = 0LL;
    return sub_10002BE10(result);
  }

  return result;
}

void sub_10002961C(void **a1)
{
  if (a1[95]) {
    sub_100036CD8((uint64_t)(a1 + 88), 0LL);
  }
  if (a1[71]) {
    a1[71] = 0LL;
  }
  if (a1[63]) {
    a1[63] = 0LL;
  }
  if (a1[55]) {
    a1[55] = 0LL;
  }
  if (a1[47]) {
    a1[47] = 0LL;
  }
  if (a1[39]) {
    a1[39] = 0LL;
  }
  if (a1[79]) {
    a1[79] = 0LL;
  }
  if (a1[31]) {
    a1[31] = 0LL;
  }
  if (a1[23]) {
    a1[23] = 0LL;
  }
  __int128 v2 = a1[9];
  if (v2) {
    free(v2);
  }
  unint64_t v3 = a1[6];
  if (v3) {
    free(v3);
  }
  uint64_t v4 = a1[5];
  if (v4) {
    free(v4);
  }
  uint64_t v5 = 0LL;
  char v6 = 1;
  do
  {
    char v7 = v6;
    uint64_t v8 = (uint64_t)a1[v5 + 3];
    if (v8) {
      sub_10002BE10(v8);
    }
    char v6 = 0;
    uint64_t v5 = 1LL;
  }

  while ((v7 & 1) != 0);
  if (*a1) {
    free(*a1);
  }
  bzero(a1, 0x3C0uLL);
}

uint64_t sub_10002970C(uint64_t a1)
{
  uint64_t v2 = 0LL;
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = a1 + 8 * v2;
    uint64_t v8 = *(void *)(v5 + 24);
    char v7 = (void *)(v5 + 24);
    uint64_t result = v8;
    if (v8)
    {
      *char v7 = 0LL;
      uint64_t result = sub_10002BE10(result);
    }

    char v3 = 0;
    uint64_t v2 = 1LL;
  }

  while ((v4 & 1) != 0);
  return result;
}

void sub_100029754(uint64_t a1, char a2)
{
  char v4 = *(void **)(a1 + 48);
  if (v4)
  {
    free(v4);
    *(void *)(a1 + 48) = 0LL;
  }

  *(_BYTE *)(a1 + 14) = a2;
  uint64_t v5 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = v5;
}

uint64_t sub_100029790(uint64_t *a1)
{
  uint64_t result = sub_10002BE74(*a1, a1[5]);
  if (!(_DWORD)result)
  {
    char v3 = (void *)a1[2];
    if (!v3 || (free(v3), a1[2] = 0LL, uint64_t result = sub_100029834(a1, 0LL), !(_DWORD)result))
    {
      char v4 = (void *)a1[3];
      if (!v4 || (free(v4), a1[3] = 0LL, uint64_t result = sub_1000298D0(a1, 0LL), !(_DWORD)result))
      {
        uint64_t v5 = (void *)a1[4];
        if (!v5) {
          return 0LL;
        }
        free(v5);
        a1[4] = 0LL;
        uint64_t result = sub_10002996C(a1, 0LL, 0LL);
        if (!(_DWORD)result) {
          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t sub_100029834(uint64_t *a1, void *a2)
{
  char v3 = a1 + 2;
  if (a1[2]
    || (uint64_t v5 = sub_100022BD0( a1,  0LL,  0x80000000,  *(void *)(a1[1] + 168),  0LL,  0,  17,  0,  (uint64_t **)a1 + 2,  (uint64_t)(a1 + 8),  0),  !(_DWORD)v5))
  {
    uint64_t v4 = 0LL;
    if (a2) {
      *a2 = *v3;
    }
  }

  else
  {
    uint64_t v4 = v5;
    char v6 = strerror(v5);
    sub_100040B90("verification/reading of the nx_reaper object failed: %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
  }

  return v4;
}

uint64_t sub_1000298D0(uint64_t *a1, void *a2)
{
  char v3 = a1 + 3;
  if (a1[3]
    || (uint64_t v5 = sub_100022BD0( a1,  0LL,  0x80000000,  *(void *)(a1[1] + 152),  0LL,  0,  5,  0,  (uint64_t **)a1 + 3,  (uint64_t)(a1 + 11),  0),  !(_DWORD)v5))
  {
    uint64_t v4 = 0LL;
    if (a2) {
      *a2 = *v3;
    }
  }

  else
  {
    uint64_t v4 = v5;
    char v6 = strerror(v5);
    sub_100040B90("verification/reading of the spaceman object failed: %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
  }

  return v4;
}

uint64_t sub_10002996C(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  if (a2) {
    uint64_t v4 = (uint64_t *)(*(void *)(a2 + 40) + 128LL);
  }
  else {
    uint64_t v4 = (uint64_t *)(a1[1] + 160);
  }
  if (a2) {
    uint64_t v5 = (uint64_t **)(a2 + 72);
  }
  else {
    uint64_t v5 = (uint64_t **)(a1 + 4);
  }
  if (*v5) {
    goto LABEL_8;
  }
  uint64_t v7 = (uint64_t)(a1 + 14);
  if (a2) {
    uint64_t v7 = a2 + 104;
  }
  uint64_t v8 = sub_100022BD0(a1, a2, 0x40000000, *v4, 0LL, 0, 11, 0, v5, v7, 0);
  if (!(_DWORD)v8)
  {
LABEL_8:
    uint64_t v6 = 0LL;
    if (a3) {
      *a3 = *v5;
    }
  }

  else
  {
    uint64_t v6 = v8;
    char v9 = strerror(v8);
    sub_100040B90("verification/reading of the omap object failed: %s\n", v10, v11, v12, v13, v14, v15, v16, v9);
  }

  return v6;
}

uint64_t sub_100029A30(uint64_t *a1, uint64_t a2)
{
  uint64_t result = sub_10002BE74(*a1, *(void *)(a2 + 80));
  if (!(_DWORD)result)
  {
    uint64_t v5 = *(void **)(a2 + 72);
    if (!v5) {
      return 0LL;
    }
    free(v5);
    *(void *)(a2 + 72) = 0LL;
    uint64_t result = sub_10002996C(a1, a2, 0LL);
    if (!(_DWORD)result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100029A94(uint64_t *a1, unsigned int a2, uint64_t *a3)
{
  if (a2 > 2) {
    return 22LL;
  }
  char v5 = a2;
  uint64_t v8 = &a1[8 * (unint64_t)a2];
  uint64_t v9 = (uint64_t)(v8 + 17);
  if (!v8[24])
  {
    unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v3 = sub_1000298D0(a1, &v19);
    if ((_DWORD)v3) {
      return v3;
    }
    uint64_t v10 = sub_100034B44( v9,  (uint64_t)a1,  0LL,  0x80000000,  2,  9,  0,  *(_DWORD *)(a1[1] + 36),  16,  8,  0,  *(void *)(v19 + 40LL * a2 + 208),  (uint64_t)sub_10000200C);
    if ((_DWORD)v10)
    {
      uint64_t v3 = v10;
      strerror(v10);
      sub_100040B90("failed to initialize the spaceman free queue tree %d: %s\n", v11, v12, v13, v14, v15, v16, v17, v5);
      return v3;
    }
  }

  uint64_t v3 = 0LL;
  if (a3) {
    *a3 = v9;
  }
  return v3;
}

uint64_t sub_100029B94(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  if (a2) {
    uint64_t v4 = a2 + 128;
  }
  else {
    uint64_t v4 = (uint64_t)(a1 + 41);
  }
  if (!*(void *)(v4 + 56))
  {
    __int128 v18 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v5 = sub_10002996C(a1, a2, &v18);
    if ((_DWORD)v5) {
      return v5;
    }
    uint64_t v8 = sub_100034B44( v4,  (uint64_t)a1,  a2,  (_DWORD)v18[5] & 0xC0000000,  (unsigned __int16)*((_DWORD *)v18 + 10),  11,  0,  *(_DWORD *)(a1[1] + 36),  16,  16,  0,  v18[6],  (uint64_t)sub_10001DFDC);
    if ((_DWORD)v8)
    {
      uint64_t v5 = v8;
      char v9 = strerror(v8);
      sub_100040B90("failed to initialize the omap tree: %s\n", v10, v11, v12, v13, v14, v15, v16, v9);
      return v5;
    }
  }

  uint64_t v5 = 0LL;
  if (a3) {
    *a3 = v4;
  }
  return v5;
}

uint64_t sub_100029C7C(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2 + 192;
  if (!*(void *)(a2 + 248))
  {
    __int128 v18 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v5 = sub_10002996C(a1, a2, &v18);
    if ((_DWORD)v5) {
      return v5;
    }
    uint64_t v8 = sub_100034B44( v4,  (uint64_t)a1,  a2,  *((_DWORD *)v18 + 11) & 0xC0000000,  (unsigned __int16)*((_DWORD *)v18 + 11),  19,  0,  *(_DWORD *)(a1[1] + 36),  8,  16,  0,  v18[7],  (uint64_t)sub_10002D39C);
    if ((_DWORD)v8)
    {
      uint64_t v5 = v8;
      char v9 = strerror(v8);
      sub_100040B90("failed to initialize the omap snap tree: %s\n", v10, v11, v12, v13, v14, v15, v16, v9);
      return v5;
    }
  }

  uint64_t v5 = 0LL;
  if (a3) {
    *a3 = v4;
  }
  return v5;
}

uint64_t sub_100029D5C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = a1 + 392;
  if (*(void *)(a1 + 448)
    || (uint64_t v5 = sub_100034B44( a1 + 392,  a1,  0LL,  0x40000000,  2,  21,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  8,  16,  0,  *(void *)(*(void *)(a1 + 8) + 1352LL),  (uint64_t)sub_10001AC94),  !(_DWORD)v5))
  {
    uint64_t v4 = 0LL;
    if (a2) {
      *a2 = v3;
    }
  }

  else
  {
    uint64_t v4 = v5;
    char v6 = strerror(v5);
    sub_100040B90("failed to initialize the fusion middle tree: %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
  }

  return v4;
}

uint64_t sub_100029E0C( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a2 + 40);
  if ((*(_BYTE *)(v9 + 56) & 0x40) != 0)
  {
    uint64_t v11 = a2 + 576;
    if (*(void *)(a2 + 632)
      || (uint64_t v12 = sub_100034B44( a2 + 576,  a1,  a2,  *(_DWORD *)(v9 + 1044) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(v9 + 1044),  32,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  8,  24,  0,  *(void *)(v9 + 1048),  (uint64_t)sub_10002D39C),  !(_DWORD)v12))
    {
      uint64_t v10 = 0LL;
      if (a3) {
        *a3 = v11;
      }
    }

    else
    {
      uint64_t v10 = v12;
      char v13 = strerror(v12);
      sub_100040B90("failed to initialize the pfkur tree: %s\n", v14, v15, v16, v17, v18, v19, v20, v13);
    }
  }

  else
  {
    sub_100040B90("get_pfkur_tree() called on non-pfk volume\n", a2, a2, a4, a5, a6, a7, a8, v22);
    return 22LL;
  }

  return v10;
}

uint64_t sub_100029EE0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(void *)(a2 + 40);
  uint64_t v5 = *(void *)(v4 + 1072);
  if (!v5) {
    return 2LL;
  }
  uint64_t v6 = a2 + 640;
  if (*(void *)(a2 + 696)
    || (uint64_t v8 = sub_100034B44( a2 + 640,  a1,  a2,  *(_DWORD *)(v4 + 1068) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(v4 + 1068),  34,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  4,  8,  0,  v5,  (uint64_t)sub_10002D368),  !(_DWORD)v8))
  {
    uint64_t v7 = 0LL;
    if (a3) {
      *a3 = v6;
    }
  }

  else
  {
    uint64_t v7 = v8;
    char v9 = strerror(v8);
    sub_100040B90("failed to initialize the doc-id tree: %s\n", v10, v11, v12, v13, v14, v15, v16, v9);
  }

  return v7;
}

uint64_t sub_100029FA4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2 + 256;
  if (*(void *)(a2 + 312)
    || (uint64_t v6 = sub_100034B44( v4,  a1,  a2,  *(_DWORD *)(*(void *)(a2 + 40) + 124LL) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(*(void *)(a2 + 40) + 124LL),  16,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  0,  0,  0,  *(void *)(*(void *)(a2 + 40) + 152LL),  (uint64_t)sub_10003A6AC),  !(_DWORD)v6))
  {
    uint64_t v5 = 0LL;
    if (a3) {
      *a3 = v4;
    }
  }

  else
  {
    uint64_t v5 = v6;
    char v7 = strerror(v6);
    sub_100040B90("failed to initialize the snap meta tree: %s\n", v8, v9, v10, v11, v12, v13, v14, v7);
  }

  return v5;
}

uint64_t sub_10002A054(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2 + 320;
  if (*(void *)(a2 + 376)
    || (uint64_t v6 = sub_100034B44( v4,  a1,  a2,  *(_DWORD *)(*(void *)(a2 + 40) + 120LL) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(*(void *)(a2 + 40) + 120LL),  15,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  0,  0,  0,  *(void *)(*(void *)(a2 + 40) + 144LL),  (uint64_t)sub_10003A6AC),  !(_DWORD)v6))
  {
    uint64_t v5 = 0LL;
    if (a3) {
      *a3 = v4;
    }
  }

  else
  {
    uint64_t v5 = v6;
    char v7 = strerror(v6);
    sub_100040B90("failed to initialize the extentref tree: %s\n", v8, v9, v10, v11, v12, v13, v14, v7);
  }

  return v5;
}

uint64_t sub_10002A104( uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a2[6];
  if (!v9) {
    uint64_t v9 = a2[5];
  }
  if ((*(_BYTE *)(v9 + 56) & 0x20) != 0)
  {
    uint64_t v11 = a2 + 48;
    if (a2[55]
      || (uint64_t v12 = sub_100034B44( (uint64_t)(a2 + 48),  a1,  (uint64_t)a2,  *(_DWORD *)(a2[5] + 1040LL) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(a2[5] + 1040LL),  31,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  16,  16,  0,  *(void *)(a2[5] + 1032LL),  (uint64_t)sub_10003A650),  !(_DWORD)v12))
    {
      uint64_t v10 = 0LL;
      if (a3) {
        *a3 = v11;
      }
    }

    else
    {
      uint64_t v10 = v12;
      char v13 = strerror(v12);
      sub_100040B90("failed to initialize the fext tree: %s\n", v14, v15, v16, v17, v18, v19, v20, v13);
    }
  }

  else
  {
    sub_100040B90("get_fext_tree() called on unsealed volume\n", a1, (uint64_t)a2, a4, a5, a6, a7, a8, v22);
    return 22LL;
  }

  return v10;
}

uint64_t sub_10002A1E0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2 + 448;
  if (*(void *)(a2 + 504)) {
    goto LABEL_2;
  }
  uint64_t v6 = *(void *)(a2 + 40);
  int v7 = *(_DWORD *)(v6 + 116);
  uint64_t v8 = *(void *)(v6 + 136);
  if (*(void *)(a2 + 48)) {
    uint64_t v6 = *(void *)(a2 + 48);
  }
  if ((*(_BYTE *)(v6 + 56) & 0x20) != 0)
  {
    int v9 = *(_DWORD *)(a2 + 16);
    int v10 = *(_DWORD *)(a2 + 20);
  }

  else
  {
    int v9 = 0;
    int v10 = 0;
  }

  uint64_t v11 = sub_100034B44( v4,  a1,  a2,  v7 & 0xC0000000,  (unsigned __int16)v7,  14,  v9,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  0,  0,  v10,  v8,  (uint64_t)sub_10003A6AC);
  if (!(_DWORD)v11)
  {
LABEL_2:
    uint64_t v5 = 0LL;
    if (a3) {
      *a3 = v4;
    }
  }

  else
  {
    uint64_t v5 = v11;
    char v12 = strerror(v11);
    sub_100040B90("failed to initialize the fsroot tree: %s\n", v13, v14, v15, v16, v17, v18, v19, v12);
  }

  return v5;
}

uint64_t sub_10002A2AC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2 + 512;
  if (*(void *)(a2 + 568)) {
    goto LABEL_2;
  }
  uint64_t v6 = *(void *)(a2 + 40);
  int v7 = *(_DWORD *)(v6 + 1104);
  uint64_t v8 = *(void *)(v6 + 1096);
  if (*(void *)(a2 + 48)) {
    uint64_t v6 = *(void *)(a2 + 48);
  }
  if ((*(_BYTE *)(v6 + 56) & 0x20) != 0)
  {
    int v9 = *(_DWORD *)(a2 + 16);
    int v10 = *(_DWORD *)(a2 + 20);
  }

  else
  {
    int v9 = 0;
    int v10 = 0;
  }

  uint64_t v11 = sub_100034B44( v4,  a1,  a2,  v7 & 0xC0000000,  (unsigned __int16)v7,  36,  v9,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  0,  0,  v10,  v8,  (uint64_t)sub_10003A6AC);
  if (!(_DWORD)v11)
  {
LABEL_2:
    uint64_t v5 = 0LL;
    if (a3) {
      *a3 = v4;
    }
  }

  else
  {
    uint64_t v5 = v11;
    char v12 = strerror(v11);
    sub_100040B90("failed to initialize the secondary fsroot tree: %s\n", v13, v14, v15, v16, v17, v18, v19, v12);
  }

  return v5;
}

uint64_t sub_10002A378(int a1, dev_t *a2, _DWORD *a3, int *a4, dev_t *a5)
{
  if (a2)
  {
    v42.dev_t st_dev = -1431655766;
    if (ioctl(a1, 0x4004644CuLL, &v42))
    {
      if (*__error() != 25)
      {
        int v10 = __error();
        uint64_t v11 = strerror(*v10);
        sub_1000280F0("%s:%d: can't get features for device (%s)\n", "io_get_device_features", 182, v11);
      }

      dev_t st_dev = 0;
    }

    else
    {
      dev_t st_dev = v42.st_dev;
    }

    *a2 = st_dev;
  }

  if (a3) {
    *a3 = (fcntl(a1, 3) & 3) != 0;
  }
  if (!a4) {
    goto LABEL_14;
  }
  v13.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v13.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v42.st_blksize = v13;
  *(timespec *)v42.st_qspare = v13;
  v42.st_birthtimespec = v13;
  *(timespec *)&v42.st_size = v13;
  v42.st_mtimespec = v13;
  v42.st_ctimespec = v13;
  *(timespec *)&v42.st_uid = v13;
  v42.st_atimespec = v13;
  *(timespec *)&v42.dev_t st_dev = v13;
  if (fstat(a1, &v42) || (v42.st_mode & 0xB000 | 0x4000) != 0x6000 || (CFMutableDictionaryRef v18 = IOServiceMatching("IOMedia")) == 0LL)
  {
LABEL_12:
    int v14 = 0;
    goto LABEL_13;
  }

  uint64_t v19 = v18;
  int v40 = v42.st_rdev & 0xFFFFFF;
  unsigned int valuePtr = HIBYTE(v42.st_rdev);
  CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v20)
  {
    CFNumberRef v21 = v20;
    CFDictionarySetValue(v19, @"BSD Major", v20);
    CFRelease(v21);
  }

  CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v40);
  if (v22)
  {
    CFNumberRef v23 = v22;
    CFDictionarySetValue(v19, @"BSD Minor", v22);
    CFRelease(v23);
  }

  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v19);
  if (!MatchingService)
  {
    sub_1000280A8( "%s:%d: fd %d is type %o rdev %d (%d, %d): I/O registry entry not found\n",  "io_get_device_features",  230,  a1,  v42.st_mode & 0xF000,  v42.st_rdev,  HIBYTE(v42.st_rdev),  v42.st_rdev & 0xFFFFFF);
    goto LABEL_12;
  }

  io_object_t v25 = MatchingService;
  IOObjectRetain(MatchingService);
  iterator[0] = -1431655766;
  io_object_t v26 = v25;
  while (1)
  {
    io_registry_entry_t parent = -1431655766;
    if (IOObjectConformsTo(v26, "AppleAPFSContainerScheme")) {
      break;
    }
    if (IOObjectConformsTo(v26, "IOBlockStorageDevice")) {
      goto LABEL_43;
    }
    if (IORegistryEntryGetParentEntry(v26, "IOService", &parent)) {
      io_registry_entry_t parent = 0;
    }
    IOObjectRelease(v26);
    io_object_t v26 = parent;
    if (!parent)
    {
      int v14 = 0;
      goto LABEL_45;
    }
  }

  uint64_t v28 = (const __CFDictionary *)IORegistryEntrySearchCFProperty( v26,  "IOService",  @"Device Characteristics",  kCFAllocatorDefault,  3u);
  if (v28)
  {
    char v29 = v28;
    Value = (const __CFBoolean *)CFDictionaryGetValue(v28, @"Target Disk Mode");
    if (Value)
    {
      int v31 = CFBooleanGetValue(Value);
      CFRelease(v29);
      if (v31)
      {
LABEL_43:
        int v14 = 0;
        goto LABEL_44;
      }
    }

    else
    {
      CFRelease(v29);
    }
  }

  if (IORegistryEntryGetParentIterator(v26, "IOService", iterator)) {
    goto LABEL_43;
  }
  while (1)
  {
    io_object_t v32 = IOIteratorNext(iterator[0]);
    if (!v32) {
      break;
    }
    io_registry_entry_t v33 = v32;
    if (sub_10002B02C(v32, @"image-format-read-only"))
    {
      BOOL v34 = 0;
    }

    else
    {
      if (!sub_10002B02C(v33, @"Removable"))
      {
        CFTypeRef v35 = IORegistryEntrySearchCFProperty( v33,  "IOService",  @"Protocol Characteristics",  kCFAllocatorDefault,  3u);
        if (v35)
        {
          uint64_t v36 = v35;
          CFTypeID TypeID = CFDictionaryGetTypeID();
          if (TypeID != CFGetTypeID(v36)) {
            goto LABEL_56;
          }
          uint64_t v38 = CFDictionaryGetValue((CFDictionaryRef)v36, @"Physical Interconnect Location");
          if (!v38) {
            goto LABEL_57;
          }
          CFTypeID v39 = CFStringGetTypeID();
          if (v39 == CFGetTypeID(v38)) {
            LODWORD(v38) = CFEqual(v38, @"Internal") == 0;
          }
          else {
LABEL_56:
          }
            LODWORD(v38) = 0;
LABEL_57:
          CFRelease(v36);
        }

        else
        {
          LODWORD(v38) = 0;
        }

        BOOL v34 = (_DWORD)v38 != 0;
        goto LABEL_60;
      }

      BOOL v34 = 1;
    }

LABEL_60:
    IOObjectRelease(v33);
    if (v34)
    {
      int v14 = 1;
      goto LABEL_63;
    }
  }

  int v14 = 0;
LABEL_63:
  IOObjectRelease(iterator[0]);
LABEL_44:
  IOObjectRelease(v26);
LABEL_45:
  IOObjectRelease(v25);
LABEL_13:
  *a4 = v14;
LABEL_14:
  if (a5)
  {
    v42.dev_t st_dev = -1431655766;
    if (ioctl(a1, 0x4004644FuLL, &v42))
    {
      if (*__error() != 25)
      {
        uint64_t v15 = __error();
        uint64_t v16 = strerror(*v15);
        sub_1000280F0("%s:%d: can't get solidstate for device (%s)\n", "io_get_device_features", 246, v16);
      }

      dev_t v17 = 1;
    }

    else
    {
      dev_t v17 = v42.st_dev;
    }

    *a5 = v17;
  }

  return 0LL;
}

uint64_t sub_10002A840(io_object_t *a1, _BYTE *a2)
{
  if (a2) {
    *a2 = 0;
  }
  BOOLean_t v4 = IOObjectConformsTo(*a1, "AppleAPFSSnapshot");
  io_registry_entry_t v5 = *a1;
  if (v4)
  {
    io_registry_entry_t parent = -1431655766;
    if (IORegistryEntryGetParentEntry(v5, "IOService", &parent)) {
      return 0LL;
    }
    IOObjectRelease(*a1);
    io_registry_entry_t v5 = parent;
    *a1 = parent;
    if (a2) {
      *a2 = 1;
    }
  }

  uint64_t result = IOObjectConformsTo(v5, "AppleAPFSVolume");
  if ((_DWORD)result) {
    return *a1;
  }
  return result;
}

const char *sub_10002A8E0(const char *a1)
{
  uint64_t v1 = a1;
  if (!strncmp(a1, "/dev/", 5uLL))
  {
    int v2 = *((unsigned __int8 *)v1 + 5);
    v1 += 5;
    if (v2 == 114) {
      ++v1;
    }
  }

  return v1;
}

unint64_t sub_10002A920(const char *a1, _DWORD *a2)
{
  if (!sub_10002A9A0(a1)) {
    return 0LL;
  }
  unint64_t result = (unint64_t)strrchr(a1, 115);
  if (result)
  {
    unint64_t v5 = result;
    unint64_t result = strtoul((const char *)(result + 1), 0LL, 10);
    if (result)
    {
      int v6 = result;
      unint64_t result = (unint64_t)strndup(a1, v5 - (void)a1);
      if (result)
      {
        if (a2) {
          *a2 = v6 - 1;
        }
      }
    }
  }

  return result;
}

BOOL sub_10002A9A0(const char *a1)
{
  uint64_t v1 = a1;
  if (!strncmp(a1, "/dev/", 5uLL))
  {
    int v2 = *((unsigned __int8 *)v1 + 5);
    v1 += 5;
    if (v2 == 114) {
      ++v1;
    }
  }

  uint64_t v3 = IOBSDNameMatching(kIOMasterPortDefault, 0, v1);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v3);
  if (!MatchingService) {
    return 0LL;
  }
  io_object_t v5 = MatchingService;
  BOOL v6 = IOObjectConformsTo(MatchingService, "AppleAPFSVolume") != 0;
  IOObjectRelease(v5);
  return v6;
}

BOOL sub_10002AA34(const char *a1)
{
  return sub_10002AA40(a1, "Encrypted");
}

BOOL sub_10002AA40(const char *a1, const char *a2)
{
  CFBooleanRef v2 = (CFBooleanRef)sub_10002AA90(a1, a2);
  if (!v2) {
    return 0LL;
  }
  BOOL v3 = v2 == kCFBooleanTrue;
  CFRelease(v2);
  return v3;
}

BOOL sub_10002AA84(const char *a1)
{
  return sub_10002AA40(a1, "multiKeyEncryption");
}

CFTypeRef sub_10002AA90(const char *a1, const char *a2)
{
  BOOL v3 = a1;
  if (!strncmp(a1, "/dev/", 5uLL))
  {
    int v4 = *((unsigned __int8 *)v3 + 5);
    v3 += 5;
    if (v4 == 114) {
      ++v3;
    }
  }

  if (*v3 == 114) {
    io_object_t v5 = v3 + 1;
  }
  else {
    io_object_t v5 = v3;
  }
  BOOL v6 = IOBSDNameMatching(kIOMasterPortDefault, 0, v5);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v6);
  if (!MatchingService) {
    return 0LL;
  }
  io_registry_entry_t v8 = MatchingService;
  int v9 = CFStringCreateWithCString(0LL, a2, 0x8000100u);
  if (v9)
  {
    int v10 = v9;
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v8, v9, kCFAllocatorDefault, 0);
    CFRelease(v10);
  }

  else
  {
    CFTypeRef CFProperty = 0LL;
  }

  IOObjectRelease(v8);
  return CFProperty;
}

uint64_t sub_10002AB74(io_registry_entry_t a1, const char *a2)
{
  io_iterator_t iterator = -1431655766;
  if (IORegistryEntryGetChildIterator(a1, "IOService", &iterator)) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v4 = IOIteratorNext(iterator);
    uint64_t v3 = v4;
    if (!(_DWORD)v4 || IOObjectConformsTo(v4, a2)) {
      break;
    }
    IOObjectRelease(v3);
  }

  IOObjectRelease(iterator);
  return v3;
}

uint64_t sub_10002ABF0(const char *a1, int a2)
{
  uint64_t v4 = strrchr(a1, 115);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  if (a2)
  {
    io_object_t v5 = v4 - 1;
    while (v5 > a1)
    {
      int v7 = *v5--;
      char v6 = v7;
      if ((v7 - 48) >= 0xA)
      {
        if (v6 != 115) {
          return 0xFFFFFFFFLL;
        }
        uint64_t v4 = (char *)(v5 + 1);
        goto LABEL_8;
      }
    }

    return 0xFFFFFFFFLL;
  }

const char *sub_10002AC7C(const char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!strncmp(result, "/dev/", 5uLL))
    {
      int v2 = *((unsigned __int8 *)v1 + 5);
      v1 += 5;
      if (v2 == 114) {
        ++v1;
      }
    }

    uint64_t v3 = IOBSDNameMatching(kIOMasterPortDefault, 0, v1);
    return (const char *)IOServiceGetMatchingService(kIOMasterPortDefault, v3);
  }

  return result;
}

const char *sub_10002ACE4(const char *a1, _BYTE *a2)
{
  unint64_t result = sub_10002AC7C(a1);
  io_object_t object = result;
  if ((_DWORD)result)
  {
    int v4 = sub_10002A840(&object, a2);
    unint64_t result = (const char *)object;
    if (!v4)
    {
      IOObjectRelease(object);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10002AD34(io_registry_entry_t a1)
{
  io_iterator_t v9 = -1431655766;
  io_iterator_t iterator = -1431655766;
  io_iterator_t object = -1431655766;
  if (IORegistryEntryGetChildIterator(a1, "IOService", &iterator)) {
    return 0LL;
  }
  io_object_t v2 = IOIteratorNext(iterator);
  if (!v2)
  {
LABEL_19:
    uint64_t v1 = 0LL;
    io_iterator_t v5 = iterator;
    goto LABEL_21;
  }

  io_object_t v3 = v2;
  while (1)
  {
    if (!IOObjectConformsTo(v3, "AppleAPFSContainerScheme") || IORegistryEntryGetChildIterator(v3, "IOService", &v9)) {
      goto LABEL_18;
    }
    io_object_t v4 = IOIteratorNext(v9);
    if (v4) {
      break;
    }
LABEL_17:
    IOObjectRelease(v9);
LABEL_18:
    IOObjectRelease(v3);
    io_object_t v3 = IOIteratorNext(iterator);
    if (!v3) {
      goto LABEL_19;
    }
  }

  io_iterator_t v5 = v4;
  while (1)
  {
    if (!IOObjectConformsTo(v5, "AppleAPFSMedia") || IORegistryEntryGetChildIterator(v5, "IOService", &object)) {
      goto LABEL_16;
    }
    uint64_t v6 = IOIteratorNext(object);
    if ((_DWORD)v6) {
      break;
    }
LABEL_15:
    IOObjectRelease(object);
LABEL_16:
    IOObjectRelease(v5);
    io_iterator_t v5 = IOIteratorNext(v9);
    if (!v5) {
      goto LABEL_17;
    }
  }

  uint64_t v1 = v6;
  while (!IOObjectConformsTo(v1, "AppleAPFSContainer"))
  {
    IOObjectRelease(v1);
    uint64_t v1 = IOIteratorNext(object);
    if (!(_DWORD)v1) {
      goto LABEL_15;
    }
  }

  IOObjectRelease(iterator);
  IOObjectRelease(v9);
  IOObjectRelease(object);
  IOObjectRelease(v3);
LABEL_21:
  IOObjectRelease(v5);
  return v1;
}

uint64_t sub_10002AECC(char *__s, _DWORD *a2, io_connect_t *a3, io_registry_entry_t *a4, int a5)
{
  io_registry_entry_t parent = -1431655766;
  if (a2)
  {
    io_iterator_t v9 = strrchr(__s, 47);
    if (v9) {
      int v10 = v9 + 1;
    }
    else {
      int v10 = __s;
    }
    unsigned __int8 v20 = 0;
    io_registry_entry_t v11 = sub_10002ACE4(v10, &v20);
    if (v11)
    {
      io_object_t v12 = v11;
      if (IORegistryEntryGetParentEntry(v11, "IOService", &parent))
      {
        uint64_t v13 = 49158LL;
LABEL_24:
        IOObjectRelease(v12);
        return v13;
      }

      if (IOObjectConformsTo(parent, "AppleAPFSContainer"))
      {
        int v17 = sub_10002ABF0(v10, v20);
        *a2 = v17;
        if (v17 != -1)
        {
          io_service_t v16 = parent;
LABEL_17:
          uint64_t v13 = IOServiceOpen(v16, mach_task_self_, 0, a3);
          io_object_t v18 = parent;
          if (a4 && !(_DWORD)v13)
          {
            *a4 = parent;
            goto LABEL_24;
          }

BOOL sub_10002B02C(io_registry_entry_t a1, CFStringRef key)
{
  CFBooleanRef v2 = (CFBooleanRef)IORegistryEntrySearchCFProperty(a1, "IOService", key, kCFAllocatorDefault, 3u);
  if (!v2) {
    return 0LL;
  }
  BOOL v3 = v2 == kCFBooleanTrue;
  CFRelease(v2);
  return v3;
}

uint64_t sub_10002B08C(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(*(void *)(a2 + 40) + 264LL) & 0x109) != 0)
  {
    unint64_t v73 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v3 = sub_10002B4A8(a1, a2, &v73, &v72);
    if ((_DWORD)v3)
    {
      uint64_t v11 = v3;
      if ((_DWORD)v3 != 2)
      {
        sub_100040B90( "iOS encryption rolling state object: cannot determine absence of ierso xattr\n",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v71);
        uint64_t v12 = 1144LL;
LABEL_12:
        sub_100044E7C((char *)v12, v11);
        return v11;
      }

      return 0LL;
    }

    sub_100040B90( "iOS encryption rolling state object: non-iOS content protected volume unexpectedly has ierso\n",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v71);
    uint64_t v11 = 92LL;
    sub_100044E7C((char *)0x479, 92);
    CFNumberRef v21 = (void *)v73;
LABEL_22:
    free(v21);
    return v11;
  }

  unint64_t v72 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v73 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = sub_10002B4A8(a1, a2, &v73, &v72);
  if (!(_DWORD)v13)
  {
    CFNumberRef v22 = (char *)v73;
    if (v72 <= 4)
    {
      sub_100040B90( "iOS encryption rolling state object: xattr record too small (%zu)\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v72);
      uint64_t v11 = 92LL;
      uint64_t v23 = 1136LL;
LABEL_19:
      int v25 = 92;
LABEL_20:
      sub_100044E7C((char *)v23, v25);
LABEL_21:
      CFNumberRef v21 = v22;
      goto LABEL_22;
    }

    if ((*(_WORD *)v73 & 3) != 2)
    {
      sub_100040B90( "iOS encryption rolling state object: xattr invalid storage type, flags (%hu)\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *(_WORD *)v73);
      uint64_t v11 = 92LL;
      uint64_t v23 = 1137LL;
      goto LABEL_19;
    }

    uint64_t v24 = *(unsigned __int16 *)(v73 + 2);
    if (v24 + 4 != v72)
    {
      sub_100040B90( "iOS encryption rolling state object: xattr payload (%hu) does not match record size (%zu)\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *(_WORD *)(v73 + 2));
      uint64_t v11 = 92LL;
      uint64_t v23 = 1138LL;
      goto LABEL_19;
    }

    if (v24 <= 3)
    {
      sub_100040B90( "iOS encryption rolling state object: xattr payload (%hu) is too small\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *(_WORD *)(v73 + 2));
      uint64_t v11 = 92LL;
      uint64_t v23 = 1139LL;
      goto LABEL_19;
    }

    uint64_t v27 = *(unsigned int *)(v73 + 4);
    if (v27 > 2)
    {
      sub_100040C68( "iOS encryption rolling state object: ierso version (%u) unrecognized\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *(_DWORD *)(v73 + 4));
      sub_100044E7C((char *)0x474, -6);
      uint64_t v11 = 0LL;
      goto LABEL_21;
    }

    if (qword_10006B370[v27] != v24)
    {
      sub_100040B90( "iOS encryption rolling state object: size (%u), version (%u) does not match expected size (%zu)\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v24);
      uint64_t v11 = 92LL;
      uint64_t v23 = 1141LL;
      goto LABEL_19;
    }

    uint64_t v28 = (char *)calloc(1uLL, 0x170uLL);
    if (!v28)
    {
      sub_100040B90( "iOS encryption rolling state object: failed to allocate ierso\n",  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v71);
      uint64_t v11 = 12LL;
      uint64_t v23 = 1142LL;
      int v25 = 12;
      goto LABEL_20;
    }

    uint64_t v36 = v28;
    __memcpy_chk(v28, v22 + 4, v24, 368LL);
    int v44 = *(_DWORD *)v36;
    if (!*(_DWORD *)v36) {
      *((_DWORD *)v36 + 8) = 1;
    }
    uint64_t v45 = 48LL;
    if (!*(void *)(a2 + 56)) {
      uint64_t v45 = 40LL;
    }
    uint64_t v46 = *(void *)(a2 + v45);
    unint64_t v48 = *((void *)v36 + 1);
    unint64_t v47 = *((void *)v36 + 2);
    unint64_t v49 = *(void *)(v46 + 176);
    if (v47 > v48 || (v48 < v49 ? (BOOL v50 = v49 >> 60 == 0) : (BOOL v50 = 0), !v50))
    {
      sub_100040B90( "iOS encryption rolling state object: epoch unordered: current_id (%llu) <= epoch (%llu) < apfs_next_obj_id (%llu) <= MAX_JOBJ_ID (%llu)\n",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v47);
      uint64_t v11 = 92LL;
      uint64_t v51 = 1128LL;
LABEL_38:
      sub_100044E7C((char *)v51, 92);
LABEL_39:
      free(v36);
      goto LABEL_21;
    }

    if (*((void *)v36 + 3) >> 55)
    {
      sub_100040B90( "iOS encryption rolling state object: current_offset (%llu) too large\n",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  *((void *)v36 + 3));
      uint64_t v11 = 92LL;
      uint64_t v51 = 1129LL;
      goto LABEL_38;
    }

    int v52 = *((_DWORD *)v36 + 8);
    if ((v52 - 1) >= 2)
    {
      sub_100040B90( "iOS encryption rolling state object: (version %u) invalid policy (%u)\n",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44);
      uint64_t v11 = 92LL;
      uint64_t v51 = 1130LL;
      goto LABEL_38;
    }

    unsigned int v53 = *((_DWORD *)v36 + 9);
    if (v52 == 1)
    {
      if (v53 >= 2)
      {
        sub_100040B90( "iOS encryption rolling state object: (version %u) lite rolling has invalid current_state (%u)\n",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44);
        uint64_t v51 = 1131LL;
LABEL_64:
        uint64_t v11 = 92LL;
        goto LABEL_38;
      }
    }

    else if (v53 == 2)
    {
      if (!memchr(v36 + 40, 0, 0x80uLL))
      {
        sub_100040B90( "iOS encryption rolling state object: current_xattr is unterminated\n",  v54,  v55,  v56,  v57,  v58,  v59,  v60,  v71);
        uint64_t v11 = 92LL;
        uint64_t v51 = 1134LL;
        goto LABEL_38;
      }
    }

    else if (v53 != 1)
    {
      if (v53)
      {
        sub_100040B90( "iOS encryption rolling state object: (version %u) full rolling has unrecognized current_state (%u)\n",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44);
        uint64_t v51 = 1133LL;
        goto LABEL_64;
      }

      if (v47)
      {
        sub_100040B90( "iOS encryption rolling state object: (version %u) current_state unset, yet non-zero current_id (%llu)",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44);
        uint64_t v51 = 1132LL;
        goto LABEL_64;
      }
    }

    uint64_t v61 = sub_10000E000();
    uint64_t v69 = *((void *)v36 + 21);
    uint64_t v70 = *((void *)v36 + 22);
    if (!v69) {
      uint64_t v69 = v61;
    }
    if (!v70) {
      uint64_t v70 = v61;
    }
    if (v69 > v70 || v70 > v61)
    {
      sub_100040C68( "iOS encryption rolling state object: (version %u) timestamps unordered: start_time (%llu) <= end_time (%llu) <= current_time (%llu)\n",  v62,  v63,  v64,  v65,  v66,  v67,  v68,  *(_DWORD *)v36);
      sub_100044E7C((char *)0x46F, -4);
    }

    uint64_t v11 = 0LL;
    goto LABEL_39;
  }

  uint64_t v11 = v13;
  if ((_DWORD)v13 != 2)
  {
    sub_100040B90( "iOS encryption rolling state object: cannot get ierso xattr\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v71);
    uint64_t v12 = 1143LL;
    goto LABEL_12;
  }

  return 0LL;
}

uint64_t sub_10002B4A8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  unsigned int v23 = 38;
  unsigned int v22 = 3804;
  uint64_t v24 = 0x4000000000000003LL;
  __int16 v25 = 28;
  strcpy(v26, "com.apple.system.apfs.ierso");
  uint64_t v8 = malloc(0xEDCuLL);
  if (!v8) {
    return 12LL;
  }
  uint64_t v9 = v8;
  uint64_t v10 = *(void *)(a2 + 48);
  uint64_t v11 = 48LL;
  if (!*(void *)(a2 + 56)) {
    uint64_t v11 = 40LL;
  }
  uint64_t v12 = *(void *)(a2 + v11);
  uint64_t v13 = *(void *)(a2 + 48);
  if (!v10) {
    uint64_t v13 = *(void *)(a2 + 40);
  }
  int v14 = *(_DWORD *)(v12 + 116);
  uint64_t v15 = *(void *)(v12 + 136);
  *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v21[2] = v16;
  v21[3] = v16;
  v21[0] = v16;
  v21[1] = v16;
  if ((*(_BYTE *)(v13 + 56) & 0x20) != 0) {
    int v17 = *(_DWORD *)(a2 + 16);
  }
  else {
    int v17 = 0;
  }
  if (!v10) {
    uint64_t v10 = *(void *)(a2 + 40);
  }
  if ((*(_BYTE *)(v10 + 56) & 0x20) != 0) {
    int v19 = *(_DWORD *)(a2 + 20);
  }
  else {
    int v19 = 0;
  }
  uint64_t v18 = sub_100034B44( (uint64_t)v21,  a1,  a2,  v14 & 0xC0000000,  (unsigned __int16)v14,  14,  v17,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  0,  0,  v19,  v15,  (uint64_t)sub_10003A6AC);
  if ((_DWORD)v18
    || (uint64_t v18 = sub_100034BB4((uint64_t)v21, *(void *)(a2 + 56), 0LL, &v24, &v23, 0x26u, v9, &v22), (_DWORD)v18))
  {
    free(v9);
  }

  else
  {
    *a3 = v9;
    *a4 = v22;
  }

  return v18;
}

uint64_t sub_10002B658(uint64_t **a1, void **a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  unint64_t v21 = 0LL;
  uint64_t v8 = 22LL;
  if (a3 > 0x7FFFFFF)
  {
    if (a3 == 0x40000000)
    {
      LODWORD(v20) = *((_DWORD *)a1 + 6);
      int v12 = v20;
      uint64_t v19 = a5;
      int v11 = v20;
LABEL_12:
      if (v11 == v12) {
        uint64_t v8 = 0LL;
      }
      else {
        uint64_t v8 = 22LL;
      }
      goto LABEL_15;
    }

    if (a3 == 0x8000000) {
      return sub_10001ABF4(*((unsigned int *)a1 + 6), a5, a2);
    }
  }

  else
  {
    if (a3 == 0x80000000)
    {
      uint64_t v9 = sub_10002DA58(*a1, a5, 0, 0, (uint64_t)&v19);
    }

    else
    {
      if (a3) {
        goto LABEL_15;
      }
      uint64_t v9 = sub_10001E038(*a1, (uint64_t)a1[1], a5, a4, (uint64_t)&v19);
    }

    uint64_t v8 = v9;
    if (!(_DWORD)v9)
    {
      int v11 = v20;
      int v12 = *((_DWORD *)a1 + 6);
      goto LABEL_12;
    }
  }

LABEL_15:
  uint64_t v13 = *a2;
  if (!*a2)
  {
    uint64_t v13 = malloc(*((unsigned int *)a1 + 6));
    *a2 = v13;
    if (!v13) {
      return 12LL;
    }
  }

  if (!(_DWORD)v8)
  {
    uint64_t v14 = **a1;
    if ((v20 & 0x400000000LL) != 0)
    {
      uint64_t v18 = a1[1];
      if ((WORD2(v20) & 0x700) == 0x100) {
        int v16 = 4;
      }
      else {
        int v16 = 0;
      }
      if ((WORD2(v20) & 0x700) == 0x100) {
        unint64_t v17 = a5 ^ HIDWORD(v21) | a5 & 0xFFFFFFFF00000000LL ^ (v21 << 32);
      }
      else {
        unint64_t v17 = 0LL;
      }
      if (v18)
      {
        if (v18[(BYTE4(v20) >> 5) + 3])
        {
          uint64_t v14 = v18[(BYTE4(v20) >> 5) + 3];
          uint64_t v15 = (uint64_t)&v18[12 * (BYTE4(v20) >> 5) + 96];
        }

        else
        {
          uint64_t v15 = 0LL;
        }
      }

      else
      {
        uint64_t v15 = 0LL;
      }
    }

    else
    {
      uint64_t v15 = 0LL;
      int v16 = 0;
      unint64_t v17 = 0LL;
    }

    return sub_10002BF50(v14, v19, v20 / *(_DWORD *)((*a1)[1] + 36), (uint64_t)v13, v15, 0, 0LL, v17, v16);
  }

  return v8;
}

    if ((_DWORD)v11 == (_DWORD)v9 && v8 <= 4 && v10 >= 1)
    {
      dword_10008D660[v9] = v10;
      dword_10008D674[v9] = 1;
      dword_10008D65C = v9 + 1;
    }

    free((void *)qword_10008D558);
    unint64_t result = strdup((const char *)qword_10008D540);
    qword_10008D558 = (uint64_t)result;
    dword_10008D688 = dword_10008D548;
    dword_10008D54C = v2;
    dword_10008D550 = v3;
    uint64_t v7 = &dword_10008D568;
    uint64_t v4 = dword_10008D568;
    goto LABEL_20;
  }

  uint64_t v4 = dword_10008D564;
  if (dword_10008D564 <= 20)
  {
    uint64_t v5 = (-2 - v3);
    uint64_t v6 = dword_10008D56C[v5];
    if ((int)v6 <= 4)
    {
      *((_DWORD *)&unk_10008D594 + 5 * v5 + v6) = (_DWORD)result;
      dword_10008D56C[v5] = v6 + 1;
      uint64_t v7 = &dword_10008D564;
LABEL_20:
      *uint64_t v7 = v4 + 1;
    }
  }

  return result;
}

uint64_t sub_10002B81C(uint64_t **a1, void *__src, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  unint64_t v18 = 0LL;
  uint64_t result = 22LL;
  if (a3 <= 0x7FFFFFF)
  {
    if (a3 == 0x80000000)
    {
      uint64_t result = sub_10002DA58(*a1, a5, 0, 0, (uint64_t)&v16);
      if ((_DWORD)result) {
        return result;
      }
    }

    else
    {
      if (a3) {
        return result;
      }
      uint64_t result = sub_10001E038(*a1, a1[1], a5, a4, &v16);
      if ((_DWORD)result) {
        return result;
      }
    }

    unsigned int v9 = *((_DWORD *)a1 + 6);
    if ((_DWORD)v17 != v9) {
      return 22LL;
    }
    goto LABEL_13;
  }

  if (a3 == 0x40000000)
  {
    unsigned int v9 = *((_DWORD *)a1 + 6);
    LODWORD(v17) = v9;
    uint64_t v16 = a5;
LABEL_13:
    uint64_t v10 = **a1;
    if ((v17 & 0x400000000LL) != 0)
    {
      uint64_t v14 = a1[1];
      if ((WORD2(v17) & 0x700) == 0x100) {
        int v12 = 4;
      }
      else {
        int v12 = 0;
      }
      if ((WORD2(v17) & 0x700) == 0x100) {
        unint64_t v13 = a5 ^ HIDWORD(v18) | a5 & 0xFFFFFFFF00000000LL ^ (v18 << 32);
      }
      else {
        unint64_t v13 = 0LL;
      }
      if (v14)
      {
        if (v14[(BYTE4(v17) >> 5) + 3])
        {
          uint64_t v10 = v14[(BYTE4(v17) >> 5) + 3];
          uint64_t v11 = (uint64_t)&v14[12 * (BYTE4(v17) >> 5) + 96];
        }

        else
        {
          uint64_t v11 = 0LL;
        }
      }

      else
      {
        uint64_t v11 = 0LL;
      }
    }

    else
    {
      uint64_t v11 = 0LL;
      int v12 = 0;
      unint64_t v13 = 0LL;
    }

    uint64_t result = sub_10002C020(v10, v16, v9 / *(_DWORD *)((*a1)[1] + 36), (uint64_t)__src, v11, v13, v12);
    if (!(_DWORD)result)
    {
      uint64_t v15 = a1[1];
      uint64_t result = 0LL;
      if (v15) {
        *((_BYTE *)v15 + 12) = 1;
      }
    }

    return result;
  }

  if (a3 == 0x8000000) {
    return sub_10001AC2C(*((unsigned int *)a1 + 6), a5, __src);
  }
  return result;
}

uint64_t sub_10002B9C4(uint64_t **a1, void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v7 = a5;
  __int128 v28 = 0uLL;
  uint64_t v29 = 0LL;
  if (a3 && a5) {
    return 22LL;
  }
  if (a3 && a3 != 0x40000000)
  {
    if (a3 != 0x8000000) {
      return 45LL;
    }
    uint64_t result = sub_10001AA9C(*((unsigned int *)a1 + 6), &v28, a2);
    if (!(_DWORD)result) {
      *a6 = v28;
    }
    return result;
  }

  unint64_t v13 = *a1;
  if (!(*a1)[3]) {
    return 22LL;
  }
  uint64_t v14 = (int8x16_t *)a1[1];
  unint64_t v15 = (*((_DWORD *)a1 + 6) / *(_DWORD *)(v13[1] + 36));
  if (v14)
  {
    BOOL v16 = (*(void *)(v14[2].i64[1] + 264) & 1LL) == 0;
    if ((*(void *)(v14[2].i64[1] + 264) & 1) == 0 && !a3)
    {
      uint64_t result = sub_100002228(v13, v14, 0, v15, (uint64_t *)&v28);
      if ((_DWORD)result) {
        return result;
      }
      BOOL v16 = 1;
      goto LABEL_28;
    }
  }

  else
  {
    BOOL v16 = 0;
  }

  if (*((_DWORD *)a1 + 12) == 11) {
    unsigned int v17 = 2;
  }
  else {
    unsigned int v17 = 1;
  }
  uint64_t result = sub_100002228(v13, v14, v17, v15, (uint64_t *)&v28);
  if ((_DWORD)result) {
    return result;
  }
  if (a3)
  {
    uint64_t v7 = v28;
LABEL_24:
    *a6 = v7;
    if (!a2) {
      return 0LL;
    }
    if (*a2) {
      return 0LL;
    }
    unint64_t v18 = malloc(*((unsigned int *)a1 + 6));
    *a2 = v18;
    if (v18) {
      return 0LL;
    }
    else {
      return 12LL;
    }
  }

uint64_t sub_10002BBB8(uint64_t a1, int a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  memset(v17, 0, sizeof(v17));
  if (a2 == 0x8000000) {
    return sub_10001AB94(*(_DWORD *)(a1 + 24), a4);
  }
  if ((a2 | 0x40000000) != 0x40000000) {
    return 45LL;
  }
  uint64_t v7 = *(uint64_t **)a1;
  if (!*(void *)(*(void *)a1 + 24LL)) {
    return 22LL;
  }
  unsigned int v8 = *(_DWORD *)(a1 + 24);
  unsigned int v9 = *(_DWORD *)(v7[1] + 36);
  if (a2)
  {
    v17[0] = a4;
    return sub_1000032D0(v7, *(int8x16_t **)(a1 + 8), v4, v8 / v9);
  }

  LODWORD(va_start(va, result) = sub_10001E16C((uint64_t)v7, *(void *)(a1 + 8), a4, a3, (uint64_t)v17);
  switch((_DWORD)result)
  {
    case 2:
      sub_100040C68( "tried to remove oid %llu from the omap but it wasn't there\n",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v4);
      return 0LL;
    case 0:
      uint64_t v7 = *(uint64_t **)a1;
      uint64_t v4 = v17[0];
      return sub_1000032D0(v7, *(int8x16_t **)(a1 + 8), v4, v8 / v9);
    case 0x11:
      return 0LL;
    default:
      return result;
  }

uint64_t sub_10002BCB8(int a1)
{
  unsigned int v7 = -1431655766;
  v2.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v6.st_blksize = v2;
  *(timespec *)v6.st_qspare = v2;
  v6.st_birthtimespec = v2;
  *(timespec *)&v6.st_size = v2;
  v6.st_mtimespec = v2;
  v6.st_ctimespec = v2;
  *(timespec *)&v6.st_uid = v2;
  v6.st_atimespec = v2;
  *(timespec *)&v6.dev_t st_dev = v2;
  memset(&__b, 170, sizeof(__b));
  if (!ioctl(a1, 0x40046418uLL, &v7)) {
    return v7;
  }
  if (!fstatfs(a1, &__b)) {
    return __b.f_bsize;
  }
  if (!fstat(a1, &v6)) {
    return v6.st_blksize;
  }
  uint64_t v3 = __error();
  uint64_t v4 = strerror(*v3);
  sub_1000280F0("%s:%d: can't get the device block size (%s). assuming 512\n", "io_get_device_block_size", 56, v4);
  return 512LL;
}

uint64_t sub_10002BDBC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 72))();
}

uint64_t sub_10002BDC8(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    uint64_t v2 = sub_10002BDC8();
  }
  else {
    uint64_t v2 = 0LL;
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 8LL))(a1) + v2;
}

uint64_t sub_10002BE10(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    unsigned int v2 = sub_10002BE10();
  }
  else {
    unsigned int v2 = 0;
  }
  LODWORD(va_start(va, result) = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 112LL))(a1);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v2;
  }
}

uint64_t sub_10002BE5C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 128LL))();
}

uint64_t sub_10002BE68(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 144LL))();
}

uint64_t sub_10002BE74(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 24LL))();
      }
    }
  }

  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 24LL))();
}

uint64_t sub_10002BEB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8)
  {
    while (1)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v7 + 88);
      if ((v10 & a2) == 0) {
        break;
      }
      a2 &= ~v10;
      uint64_t v8 = *(void *)(v9 + 80);
      uint64_t v7 = v9;
      if (!v8) {
        goto LABEL_6;
      }
    }
  }

  uint64_t v9 = v7;
LABEL_6:
  uint64_t v11 = *(void *)(v9 + 72);
  uint64_t v12 = *(uint64_t (**)(void))(v11 + 32);
  if (v12) {
    return v12();
  }
  uint64_t v14 = (*(uint64_t (**)(void))(v11 + 24))();
  uint64_t v15 = v14;
  uint64_t v16 = *(void (**)(uint64_t))a6;
  if (*(void *)a6)
  {
    *(_DWORD *)(a6 + 96) = v14;
    v16(a6);
  }

  return v15;
}

uint64_t sub_10002BF50( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = a1;
  uint64_t v10 = *(void *)(a1 + 80);
  if (v10)
  {
    while (1)
    {
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)(v9 + 88);
      if ((v12 & a2) == 0) {
        break;
      }
      a2 &= ~v12;
      uint64_t v10 = *(void *)(v11 + 80);
      uint64_t v9 = v11;
      if (!v10)
      {
        if (!a9) {
          goto LABEL_8;
        }
        goto LABEL_5;
      }
    }
  }

  uint64_t v11 = v9;
  if (a9)
  {
LABEL_5:
    uint64_t v13 = *(uint64_t (**)(void))(*(void *)(v11 + 72) + 40LL);
    if (v13) {
      return v13();
    }
    else {
      return 45LL;
    }
  }

  else
  {
LABEL_8:
    if (a6) {
      return sub_10002BEB8(v11, a2, a3, a4, a5, a7);
    }
    else {
      return (*(uint64_t (**)(void))(*(void *)(v11 + 72) + 24LL))();
    }
  }

uint64_t sub_10002BFD0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 48LL))();
}

uint64_t sub_10002BFDC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 64LL))();
      }
    }
  }

  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 64LL))();
}

uint64_t sub_10002C020(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8)
  {
    while (1)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v7 + 88);
      if ((v10 & a2) == 0) {
        break;
      }
      a2 &= ~v10;
      uint64_t v8 = *(void *)(v9 + 80);
      uint64_t v7 = v9;
      if (!v8) {
        goto LABEL_6;
      }
    }
  }

  uint64_t v9 = v7;
LABEL_6:
  uint64_t v11 = *(void *)(v9 + 72);
  if (!a7) {
    return (*(uint64_t (**)(void))(v11 + 64))();
  }
  uint64_t v12 = *(uint64_t (**)(void))(v11 + 72);
  if (v12) {
    return v12();
  }
  else {
    return 45LL;
  }
}

uint64_t sub_10002C080(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 16LL))();
}

uint64_t sub_10002C08C(uint64_t a1, uint64_t a2)
{
  mach_port_t v3 = *(_DWORD *)(a1 + 68);
  if (v3 && (uint64_t v4 = *(void *)(a2 + 88)) != 0)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    uint64_t v7 = *(void *)(a2 + 32);
    return sub_10001A65C((const char *)(a1 + 208), v3, 5u, v5, *(void *)(a2 + 16), &v7, v4, 0LL, 0);
  }

  else
  {
    uint64_t result = aio_error((const aiocb *)(a2 + 8));
    if ((_DWORD)result == -1) {
      return *__error();
    }
  }

  return result;
}

uint64_t sub_10002C0F8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t sub_10002C100(uint64_t a1)
{
  return *(void *)(a1 + 128);
}

uint64_t sub_10002C108(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  if (a2) {
    *a2 = a1[26];
  }
  if (a3) {
    *a3 = a1[27];
  }
  if (a4) {
    *a4 = a1[28];
  }
  if (a5) {
    *a5 = a1[29];
  }
  return 0LL;
}

uint64_t sub_10002C140(uint64_t a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5, char a6)
{
  return sub_10002CD38(a1, a2, a3, a4, a5, a6, 0LL);
}

uint64_t sub_10002C148( uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7)
{
  return sub_10002D080(a1, a2, a3, a4, a5, a6, a7, 0LL);
}

uint64_t sub_10002C150( uint64_t a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  if ((a9 & 0xFFFFFFFA) != 0)
  {
    uint64_t v9 = 45LL;
LABEL_7:
    sub_1000280F0( "%s:%d: failed to read blknum 0x%llx size %zu flags 0x%x error %d dev_name = %s\n",  "fd_dev_read_extended",  622,  a2,  a3,  a9,  v9,  (const char *)(a1 + 208));
    return v9;
  }

  if (((a9 >> 2) ^ 1) != (a8 == 0))
  {
    uint64_t v9 = 22LL;
    goto LABEL_7;
  }

  if (a6) {
    return sub_10002D080(a1, a2, a3, (uint64_t)a4, a5, a9, a7, a8);
  }
  else {
    return sub_10002CD38(a1, a2, a3, a4, a5, a9, a8);
  }
}

uint64_t sub_10002C200(uint64_t a1, uint64_t a2)
{
  mach_port_t v3 = (aiocb *)(a2 + 8);
  aiocblist = (aiocb *)(a2 + 8);
  mach_port_t v4 = *(_DWORD *)(a1 + 68);
  if (v4 && (uint64_t v5 = *(void *)(a2 + 88)) != 0)
  {
    uint64_t v6 = *(void *)(a2 + 24);
    uint64_t v11 = *(void *)(a2 + 32);
    uint64_t v7 = sub_10001A65C((const char *)(a1 + 208), v4, 3u, v6, *(void *)(a2 + 16), &v11, v5, 0LL, 0);
    if (!(_DWORD)v7)
    {
      if (v11 == *(void *)(a2 + 32)) {
        uint64_t v7 = 0LL;
      }
      else {
        uint64_t v7 = 5LL;
      }
    }
  }

  else if (aio_suspend((const aiocb *const *)&aiocblist, 1, 0LL) || (unint64_t v8 = aio_return(v3), v8 == -1LL))
  {
    uint64_t v7 = *__error();
  }

  else if (v8 >= *(void *)(a2 + 32))
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v7 = 5LL;
  }

  uint64_t v9 = *(void (**)(uint64_t))a2;
  if (*(void *)a2)
  {
    *(_DWORD *)(a2 + 96) = v7;
    v9(a2);
  }

  return v7;
}

uint64_t sub_10002C2D8(uint64_t a1, unint64_t a2, unint64_t a3, char *a4, uint64_t a5, int a6)
{
  return sub_10002D1CC(a1, a2, a3, a4, a5, a6, 0LL);
}

uint64_t sub_10002C2E0( uint64_t a1, unint64_t a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  if ((a7 & 0xFFFFFFFA) != 0)
  {
    uint64_t v7 = 45LL;
  }

  else
  {
    if (((a7 >> 2) ^ 1) == (a6 == 0)) {
      return sub_10002D1CC(a1, a2, a3, a4, a5, a7, a6);
    }
    uint64_t v7 = 22LL;
  }

  sub_1000280F0( "%s:%d: failed to write blknum 0x%llx size %zu flags 0x%x error %d dev_name = %s\n",  "fd_dev_write_extended",  866,  a2,  a3,  a7,  v7,  (const char *)(a1 + 208));
  return v7;
}

uint64_t sub_10002C37C(uint64_t a1, int a2)
{
  mach_port_t v4 = *(void **)(a1 + 24);
  if (v4)
  {
    unint64_t v5 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v5)
    {
      uint64_t result = sub_10002CF4C(a1, *(void *)(a1 + 40), v5, v4, *(void *)(a1 + 48), *(_DWORD *)(a1 + 56) & 1, 0LL);
      if ((_DWORD)result) {
        return result;
      }
      *(_DWORD *)(a1 + 36) = 0;
    }
  }

  fsync(*(_DWORD *)a1);
  int v7 = *(_DWORD *)(a1 + 4);
  if ((v7 & 0x80000000) == 0) {
    fsync(v7);
  }
  if (!a2 && (*(_BYTE *)(a1 + 104) & 2) != 0)
  {
    __int128 v10 = xmmword_10006B388;
    uint64_t v11 = 2LL;
    int v9 = ioctl(*(_DWORD *)a1, 0x80186416uLL, &v10);
  }

  else
  {
    int v8 = *(_DWORD *)a1;
    if ((*(_WORD *)(a1 + 64) & 0xF000) == 0x8000) {
      int v9 = fcntl(v8, 51, 0LL);
    }
    else {
      int v9 = ioctl(v8, 0x20006416uLL, 0LL);
    }
  }

  if (v9 == -1) {
    return *__error();
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10002C470()
{
  return 0LL;
}

uint64_t sub_10002C478()
{
  return 0LL;
}

uint64_t sub_10002C480(uint64_t a1)
{
  uint64_t v2 = (const char *)(a1 + 208);
  size_t v3 = strlen((const char *)(a1 + 208));
  mach_port_t v4 = *(void **)(a1 + 24);
  if (!v4)
  {
    uint64_t v7 = 0LL;
    goto LABEL_10;
  }

  unint64_t v5 = *(unsigned int *)(a1 + 36);
  if (!(_DWORD)v5)
  {
    uint64_t v7 = 0LL;
LABEL_9:
    sub_10002817C(v4, (*(_DWORD *)(a1 + 100) * *(_DWORD *)(a1 + 32)));
    *(void *)(a1 + 24) = 0LL;
    goto LABEL_10;
  }

  uint64_t v6 = sub_10002CF4C(a1, *(void *)(a1 + 40), v5, v4, *(void *)(a1 + 48), *(_DWORD *)(a1 + 56) & 1, 0LL);
  uint64_t v7 = v6;
  if ((_DWORD)v6) {
    sub_1000280F0("%s:%d: Hit an error flushing the cache, %d dev_name = %s\n", "fd_dev_close", 370, v6, v2);
  }
  *(_DWORD *)(a1 + 36) = 0;
  mach_port_t v4 = *(void **)(a1 + 24);
  if (v4) {
    goto LABEL_9;
  }
LABEL_10:
  if (close(*(_DWORD *)a1)) {
    uint64_t v7 = *__error();
  }
  int v8 = *(_DWORD *)(a1 + 4);
  if ((v8 & 0x80000000) == 0 && close(v8)) {
    uint64_t v7 = *__error();
  }
  int v9 = *(_DWORD *)(a1 + 8);
  if ((v9 & 0x80000000) == 0 && close(v9)) {
    uint64_t v7 = *__error();
  }
  sub_10001A768(*(unsigned int *)(a1 + 68));
  sub_10002817C((void *)a1, v3 + 216);
  return v7;
}

uint64_t sub_10002C59C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t sub_10002C5A4(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 128) * (unint64_t)*(unsigned int *)(a1 + 100) / a2;
  *(_DWORD *)(a1 + 100) = a2;
  *(void *)(a1 + 128) = v2;
  return 0LL;
}

BOOL sub_10002C5C8(uint64_t a1)
{
  return *(_DWORD *)(a1 + 108) != 0;
}

BOOL sub_10002C5D8(uint64_t a1)
{
  return *(_DWORD *)(a1 + 112) != 0;
}

uint64_t sub_10002C5E8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 120);
}

uint64_t sub_10002C5F0(int a1, void *a2)
{
  *a2 = 0LL;
  if (fcntl(a1, 50, __b)) {
    LOBYTE(__b[0]) = 0;
  }
  uint64_t v4 = 5LL;
  if (__b[0] ^ 0x7665642F | LOBYTE(__b[1]) ^ 0x2F) {
    uint64_t v4 = 0LL;
  }
  unint64_t v5 = (char *)__b + v4;
  size_t v6 = strlen((const char *)__b + v4);
  uint64_t v7 = (char *)sub_100028138(1uLL, v6 + 216);
  if (!v7) {
    return 12LL;
  }
  int v8 = v7;
  *(void *)(v7 + 4) = -1LL;
  *(_DWORD *)uint64_t v7 = a1;
  strlcpy(v7 + 208, v5, v6 + 1);
  uint64_t v9 = sub_10002C728((uint64_t)v8);
  if ((_DWORD)v9) {
    sub_10002817C(v8, v6 + 216);
  }
  else {
    *a2 = v8;
  }
  return v9;
}

uint64_t sub_10002C728(uint64_t a1)
{
  dev_t v19 = -1431655766;
  int v17 = -1431655766;
  int v18 = -1431655766;
  dev_t v16 = -1431655766;
  v2.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v15.st_blksize = v2;
  *(timespec *)v15.st_qspare = v2;
  v15.st_birthtimespec = v2;
  *(timespec *)&v15.off_t st_size = v2;
  v15.st_mtimespec = v2;
  v15.st_ctimespec = v2;
  *(timespec *)&v15.st_uid = v2;
  v15.st_atimespec = v2;
  *(timespec *)&v15.dev_t st_dev = v2;
  if (fstat(*(_DWORD *)a1, &v15))
  {
    size_t v3 = __error();
    uint64_t v4 = *v3;
    sub_1000280F0( "%s:%d: Couldn't fstat dev_fd (%d), err %d dev_name = %s\n",  "dev_init_common",  983,  *(_DWORD *)a1,  *v3,  (const char *)(a1 + 208));
  }

  else
  {
    *(void *)(a1 + 72) = off_1000705F0;
    int v5 = sub_10002BCB8(*(_DWORD *)a1);
    *(_DWORD *)(a1 + 96) = v5;
    *(_DWORD *)(a1 + 100) = v5;
    int v6 = *(_DWORD *)a1;
    unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
    v7.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v7.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v20.st_blksize = v7;
    *(timespec *)v20.st_qspare = v7;
    v20.st_birthtimespec = v7;
    *(timespec *)&v20.off_t st_size = v7;
    v20.st_mtimespec = v7;
    v20.st_ctimespec = v7;
    *(timespec *)&v20.st_uid = v7;
    v20.st_atimespec = v7;
    *(timespec *)&v20.dev_t st_dev = v7;
    if (ioctl(v6, 0x40086419uLL, &v21))
    {
      if (fstat(v6, &v20))
      {
        int v8 = __error();
        uint64_t v9 = strerror(*v8);
        sub_1000280F0("%s:%d: can't get block count (%s)\n", "io_get_num_device_blocks", 77, v9);
        unint64_t v10 = 0LL;
      }

      else
      {
        off_t st_size = v20.st_size;
        unint64_t v10 = st_size / (int)sub_10002BCB8(v6);
      }
    }

    else
    {
      unint64_t v10 = v21;
    }

    *(void *)(a1 + 128) = v10;
    sub_10002A378(*(_DWORD *)a1, &v19, &v18, &v17, &v16);
    uint64_t v4 = 0LL;
    int v12 = v18;
    *(_DWORD *)(a1 + 104) = v19;
    *(_DWORD *)(a1 + 108) = v12;
    dev_t v13 = v16;
    *(_DWORD *)(a1 + 112) = v17;
    *(_DWORD *)(a1 + 1--*(_DWORD *)(result + 16) = v13;
    *(_WORD *)(a1 + 64) = v15.st_mode;
    *(_DWORD *)(a1 + 120) = 0;
  }

  return v4;
}

uint64_t sub_10002C8BC(const char *a1, int a2, uint64_t *a3)
{
  if (!strncmp(a1, "/dev/", 5uLL)) {
    uint64_t v6 = 5LL;
  }
  else {
    uint64_t v6 = 0LL;
  }
  timespec v7 = (char *)&a1[v6];
  size_t v8 = strlen(&a1[v6]);
  *a3 = 0LL;
  uint64_t v9 = sub_100028138(1uLL, v8 + 216);
  if (v9)
  {
    uint64_t v10 = (uint64_t)v9;
    v11.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v11.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v38.st_blksize = v11;
    *(timespec *)v38.st_qspare = v11;
    v38.st_birthtimespec = v11;
    *(timespec *)&v38.off_t st_size = v11;
    v38.st_mtimespec = v11;
    v38.st_ctimespec = v11;
    *(timespec *)&v38.st_uid = v11;
    v38.st_atimespec = v11;
    *(timespec *)&v38.dev_t st_dev = v11;
    v9[17] = 0;
    int v12 = v9 + 17;
    if (stat(a1, &v38) || (v38.st_mode & 0xF000) != 0x4000)
    {
      unint64_t v15 = sub_10002A920(a1, 0LL);
      if (v15)
      {
        dev_t v16 = (char *)v15;
        unsigned int v17 = a2 & 0xFFFFFFCF | 0x10;
        *(_DWORD *)(v10 + 8) = -1;
        int v18 = open(a1, v17);
        *(_DWORD *)(v10 + 4) = v18;
        if (v18 < 0)
        {
          __int128 v26 = __error();
          uint64_t v14 = *v26;
          uint64_t v27 = strerror(*v26);
          sub_1000280F0("%s:%d: failed to open volume device %s: %s\n", "dev_init", 1107, a1, v27);
        }

        else
        {
          int v19 = open(v16, v17);
          *(_DWORD *)uint64_t v10 = v19;
          if ((v19 & 0x80000000) == 0)
          {
            if (sub_10002AA84(v7))
            {
              uint64_t v20 = sub_10001A5F8(v7, v12);
              if ((_DWORD)v20)
              {
                uint64_t v14 = v20;
                unint64_t v21 = strerror(v20);
                sub_1000280F0( "%s:%d: failed to open connection for multikey crypto i/o on device %s: %s\n",  "dev_init",  1121,  v16,  v21);
                close(*(_DWORD *)v10);
                close(*(_DWORD *)(v10 + 4));
LABEL_35:
                free(v16);
LABEL_42:
                sub_10002817C((void *)v10, v8 + 216);
                return v14;
              }
            }

            goto LABEL_33;
          }

          __int128 v28 = __error();
          uint64_t v14 = *v28;
          uint64_t v29 = strerror(*v28);
          sub_1000280F0("%s:%d: failed to open container device %s: %s\n", "dev_init", 1113, v16, v29);
          close(*(_DWORD *)(v10 + 4));
        }
      }

      else
      {
        *(void *)(v10 + 4) = -1LL;
        int v22 = open(a1, a2);
        *(_DWORD *)uint64_t v10 = v22;
        if ((v22 & 0x80000000) == 0)
        {
LABEL_32:
          dev_t v16 = 0LL;
LABEL_33:
          uint64_t v34 = sub_10002C728(v10);
          if ((_DWORD)v34)
          {
            uint64_t v14 = v34;
            goto LABEL_35;
          }

          strlcpy((char *)(v10 + 208), v7, v8 + 1);
          free(v16);
LABEL_43:
          uint64_t v14 = 0LL;
          *a3 = v10;
          return v14;
        }

        int v23 = 30;
        while (*__error() == 16 && v23 != 0)
        {
          sub_1000280F0( "%s:%d: open %s hit EBUSY, attempts remaining: %u dev_name = %s\n",  "dev_init",  1133,  a1,  v23,  v7);
          sleep(1u);
          int v25 = open(a1, a2);
          *(_DWORD *)uint64_t v10 = v25;
          --v23;
          if ((v25 & 0x80000000) == 0)
          {
            dev_t v16 = 0LL;
            goto LABEL_33;
          }
        }

        dev_t v16 = 0LL;
        uint64_t v14 = *__error();
      }
    }

    else
    {
      memset(__b, 170, sizeof(__b));
      memset(v40, 170, sizeof(v40));
      memset(__str, 170, sizeof(__str));
      snprintf(__b, 0x400uLL, "%s/apfs", a1);
      snprintf(__str, 0x400uLL, "%s/apfs_data", a1);
      snprintf(v40, 0x400uLL, "%s/nx", a1);
      int v13 = open(__b, a2);
      *(_DWORD *)(v10 + 4) = v13;
      if (v13 < 0) {
        uint64_t v14 = *__error();
      }
      else {
        uint64_t v14 = 0LL;
      }
      int v30 = open(__str, a2);
      *(_DWORD *)(v10 + 8) = v30;
      if (v30 < 0) {
        uint64_t v14 = *__error();
      }
      int v31 = open(v40, a2);
      int v32 = v31;
      *(_DWORD *)uint64_t v10 = v31;
      int v33 = *(_DWORD *)(v10 + 4);
      if ((v33 & 0x80000000) == 0 && (*(_DWORD *)(v10 + 8) & 0x80000000) == 0 && (v31 & 0x80000000) == 0) {
        goto LABEL_32;
      }
      if (!(_DWORD)v14)
      {
        uint64_t v14 = *__error();
        int v32 = *(_DWORD *)v10;
        int v33 = *(_DWORD *)(v10 + 4);
      }

      int v35 = *(_DWORD *)(v10 + 8);
      uint64_t v36 = strerror(v14);
      sub_1000280F0( "%s:%d: failed to open apfs/nx special devices ['%s'(%d) / '%s'(%d) / '%s'(%d)] - err %d (%s) dev_name = '%s'\n",  "dev_init",  1094,  __b,  v33,  __str,  v35,  v40,  v32,  v14,  v36,  v7);
      close(*(_DWORD *)v10);
      close(*(_DWORD *)(v10 + 4));
      close(*(_DWORD *)(v10 + 8));
      dev_t v16 = 0LL;
    }

    free(v16);
    if ((_DWORD)v14) {
      goto LABEL_42;
    }
    goto LABEL_43;
  }

  return 12LL;
}

uint64_t sub_10002CD38( uint64_t a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5, char a6, uint64_t a7)
{
  uint64_t v14 = sub_10002CEBC(a1, a2, a3);
  if (!(_DWORD)v14)
  {
    unint64_t v15 = *(unsigned int *)(a1 + 100);
    if ((a2 & 0x8000000000000000LL) == 0
      && is_mul_ok(a2, v15)
      && (uint64_t v16 = a2 * v15, ((a2 * v15) & 0x8000000000000000LL) == 0)
      && is_mul_ok(a3, v15))
    {
      unint64_t v18 = a3 * v15;
      if (a5 && (mach_port_t v19 = *(_DWORD *)(a1 + 68)) != 0)
      {
        char v20 = a7 == 0;
        if ((a6 & 4) != 0)
        {
          char v20 = 0;
          uint64_t v21 = 0LL;
        }

        else
        {
          uint64_t v21 = v16;
        }

        if (a7) {
          uint64_t v22 = a7;
        }
        else {
          uint64_t v22 = v21;
        }
        unint64_t v28 = v18;
        unsigned int v23 = sub_10001A65C((const char *)(a1 + 208), v19, 1u, (uint64_t)a4, v16, &v28, a5, v22, v20);
        if (v28 == v18) {
          unsigned int v24 = 0;
        }
        else {
          unsigned int v24 = 5;
        }
        if (v23) {
          return v23;
        }
        else {
          return v24;
        }
      }

      else
      {
        if (!a5 || (int v25 = *(_DWORD *)(a1 + 4), v25 < 0)) {
          int v25 = *(_DWORD *)a1;
        }
        ssize_t v26 = pread(v25, a4, a3 * v15, a2 * v15);
        if (v26 < 0)
        {
          uint64_t v27 = __error();
          uint64_t v14 = *v27;
          sub_1000280F0( "%s:%d: blknum 0x%llx size %zu, error %d dev_name = %s\n",  "fd_dev_read_helper",  510,  a2,  a3,  *v27,  (const char *)(a1 + 208));
        }

        else if (v26 == v18)
        {
          return 0LL;
        }

        else
        {
          return 5LL;
        }
      }
    }

    else
    {
      sub_1000280F0( "%s:%d: blknum %lld size %zu blksize %u invalid, dev_name = %s\n",  "fd_dev_read_helper",  476,  a2,  a3,  *(_DWORD *)(a1 + 100),  (const char *)(a1 + 208));
      return 22LL;
    }
  }

  return v14;
}

uint64_t sub_10002CEBC(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v6 = *(void **)(a1 + 24);
  if (v6)
  {
    unint64_t v7 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v7)
    {
      unint64_t v8 = *(void *)(a1 + 40);
      if (a3 + a2 > v8 && v8 + v7 > a2)
      {
        uint64_t result = sub_10002CF4C(a1, v8, v7, v6, *(void *)(a1 + 48), *(_DWORD *)(a1 + 56) & 1, 0LL);
        if ((_DWORD)result) {
          return result;
        }
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }

  unint64_t v10 = *(void *)(a1 + 128);
  if (v10 - a2 >= a3 && v10 > a2) {
    return 0LL;
  }
  else {
    return 6LL;
  }
}

uint64_t sub_10002CF4C( uint64_t a1, unint64_t a2, unint64_t a3, void *__buf, uint64_t a5, char a6, uint64_t a7)
{
  unint64_t v7 = *(void *)(a1 + 128);
  BOOL v8 = v7 > a2;
  unint64_t v9 = v7 - a2;
  if (!v8 || v9 < a3) {
    return 6LL;
  }
  unint64_t v12 = *(unsigned int *)(a1 + 100);
  if ((a2 & 0x8000000000000000LL) == 0
    && is_mul_ok(a2, v12)
    && (uint64_t v14 = a2 * v12, ((a2 * v12) & 0x8000000000000000LL) == 0)
    && is_mul_ok(a3, v12))
  {
    unint64_t v15 = a3 * v12;
    if (a5 && (mach_port_t v16 = *(_DWORD *)(a1 + 68)) != 0)
    {
      char v17 = a7 == 0;
      if ((a6 & 4) != 0)
      {
        char v17 = 0;
        uint64_t v18 = 0LL;
      }

      else
      {
        uint64_t v18 = v14;
      }

      if (a7) {
        uint64_t v19 = a7;
      }
      else {
        uint64_t v19 = v18;
      }
      unint64_t v23 = v15;
      LODWORD(va_start(va, result) = sub_10001A65C((const char *)(a1 + 208), v16, 4u, (uint64_t)__buf, v14, &v23, a5, v19, v17);
      if (v23 == v15) {
        unsigned int v20 = 0;
      }
      else {
        unsigned int v20 = 5;
      }
      if ((_DWORD)result) {
        return result;
      }
      else {
        return v20;
      }
    }

    else
    {
      if (!a5 || (int v21 = *(_DWORD *)(a1 + 4), v21 < 0)) {
        int v21 = *(_DWORD *)a1;
      }
      ssize_t v22 = pwrite(v21, __buf, a3 * v12, v14);
      if (v22 < 0)
      {
        return *__error();
      }

      else if (v22 == v15)
      {
        return 0LL;
      }

      else
      {
        return 5LL;
      }
    }
  }

  else
  {
    sub_1000280F0( "%s:%d: blknum %lld size %zu blksize %u invalid, dev_name = %s\n",  "_fd_dev_write",  725,  a2,  a3,  *(_DWORD *)(a1 + 100),  (const char *)(a1 + 208));
    return 22LL;
  }

uint64_t sub_10002D080( uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = sub_10002CEBC(a1, a2, a3);
  if ((_DWORD)v16) {
    goto LABEL_2;
  }
  *(_OWORD *)(a7 + 8) = 0u;
  uint64_t v19 = (aiocb *)(a7 + 8);
  *(void *)(a7 + 88) = a5;
  *(_OWORD *)(a7 + 24) = 0u;
  *(_OWORD *)(a7 + 40) = 0u;
  *(_OWORD *)(a7 + 56) = 0u;
  *(_OWORD *)(a7 + 72) = 0u;
  uint64_t v20 = *(unsigned int *)(a1 + 100);
  uint64_t v21 = v20 * a2;
  *(void *)(a7 + --*(_DWORD *)(result + 16) = v20 * a2;
  *(void *)(a7 + 24) = a4;
  unint64_t v22 = v20 * a3;
  *(void *)(a7 + 32) = v22;
  if (!a5 || (mach_port_t v23 = *(_DWORD *)(a1 + 68)) == 0)
  {
    if (!a5 || (int v27 = *(_DWORD *)(a1 + 4), v27 < 0)) {
      int v27 = *(_DWORD *)a1;
    }
    v19->aio_fildes = v27;
    if (!aio_read(v19)) {
      return 0LL;
    }
    if (*__error() == 35)
    {
      uint64_t v16 = 16LL;
    }

    else
    {
      uint64_t v16 = *__error();
      if (!(_DWORD)v16) {
        return v16;
      }
    }

    goto LABEL_2;
  }

  char v24 = (a6 & 4) == 0;
  uint64_t v25 = (a6 & 4) != 0 ? 0LL : v21;
  if (a8)
  {
    char v24 = 0;
    uint64_t v26 = a8;
  }

  else
  {
    uint64_t v26 = v25;
  }

  unint64_t v28 = v22;
  uint64_t v16 = sub_10001A65C((const char *)(a1 + 208), v23, 2u, a4, v21, &v28, a5, v26, v24);
  if ((_DWORD)v16)
  {
LABEL_2:
    char v17 = *(void (**)(uint64_t))a7;
    if (*(void *)a7)
    {
      *(_DWORD *)(a7 + 96) = v16;
      v17(a7);
    }
  }

  return v16;
}

uint64_t sub_10002D1CC( uint64_t a1, unint64_t a2, unint64_t a3, char *__buf, uint64_t a5, int a6, uint64_t a7)
{
  unint64_t v10 = __buf;
  unint64_t v11 = a3;
  unint64_t v12 = a2;
  uint64_t v14 = *(void *)(a1 + 24);
  if (*(_DWORD *)(a1 + 60))
  {
    if (!v14)
    {
      unsigned int v15 = *(_DWORD *)(a1 + 100);
      unsigned int v16 = v15 <= 0x100000 ? 0x100000 / v15 : 1;
      *(_DWORD *)(a1 + 32) = v16;
      uint64_t v18 = sub_1000281BC(v16 * v15);
      *(void *)(a1 + 24) = v18;
      *(_DWORD *)(a1 + 36) = 0;
      if (!v18) {
        return 12LL;
      }
    }
  }

  else if (!v14)
  {
    return sub_10002CF4C(a1, a2, a3, __buf, a5, a6, a7);
  }

  if (!v11) {
    return 0LL;
  }
  unsigned int v19 = *(_DWORD *)(a1 + 36);
  while (1)
  {
    while (1)
    {
      unint64_t v20 = v11 >= *(_DWORD *)(a1 + 32) - v19 ? *(_DWORD *)(a1 + 32) - v19 : v11;
      if ((a6 & 4) != 0 || ((*(_DWORD *)(a1 + 56) ^ a6) & 1) != 0 || v12 != *(void *)(a1 + 40) + v19) {
        break;
      }
      if (!(_DWORD)v20 || *(void *)(a1 + 48) != a5) {
        break;
      }
      memcpy( (void *)(*(void *)(a1 + 24) + *(_DWORD *)(a1 + 100) * v19),  v10,  (*(_DWORD *)(a1 + 100) * v20));
      unsigned int v19 = *(_DWORD *)(a1 + 36) + v20;
      *(_DWORD *)(a1 + 36) = v19;
      v12 += v20;
      v11 -= v20;
      v10 += (*(_DWORD *)(a1 + 100) * v20);
      if (!v11) {
        return 0LL;
      }
    }

    if (v19)
    {
      uint64_t result = sub_10002CF4C( a1,  *(void *)(a1 + 40),  v19,  *(void **)(a1 + 24),  *(void *)(a1 + 48),  *(_DWORD *)(a1 + 56) & 1,  a7);
      if ((_DWORD)result) {
        break;
      }
    }

    unsigned int v19 = 0;
    *(_DWORD *)(a1 + 36) = 0;
    *(void *)(a1 + 40) = v12;
    *(void *)(a1 + 48) = a5;
    *(_DWORD *)(a1 + 56) = a6;
  }

  return result;
}

uint64_t sub_10002D368(uint64_t a1, _DWORD *a2, int a3, _DWORD *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 4 && a5 == 4)
  {
    uint64_t result = 0LL;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }

  return result;
}

uint64_t sub_10002D39C(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0LL;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }

  return result;
}

uint64_t sub_10002D3D0(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }

      else
      {
        unint64_t v8 = a2[1];
        unint64_t v9 = a4[1];
        BOOL v10 = v8 >= v9;
        int v7 = v8 > v9;
        if (!v10) {
          int v7 = -1;
        }
      }
    }

    else
    {
      int v7 = -1;
    }

    uint64_t result = 0LL;
    *a6 = v7;
  }

  return result;
}

uint64_t sub_10002D42C(uint64_t *a1, double a2, int8x16_t a3)
{
  uint64_t v4 = a1[1];
  unint64_t v5 = *(unsigned int *)(v4 + 36);
  v16.i64[0] = 0LL;
  uint64_t v17 = 0LL;
  v16.i64[1] = v5;
  int v6 = *(_DWORD *)(v4 + 104);
  uint64_t v7 = (*(_DWORD *)(v4 + 140) + *(_DWORD *)(v4 + 136) - 1) % (v6 & 0x7FFFFFFFu);
  uint64_t v8 = *(void *)(v4 + 112);
  if (v6 < 0)
  {
    uint64_t result = sub_10002DC38((uint64_t)a1, v8, v7, &v16, 0LL);
    if ((_DWORD)result) {
      return result;
    }
  }

  else
  {
    v16.i64[0] = v8 + v7;
  }

  int8x16_t v14 = v16;
  uint64_t v15 = v17;
  uint64_t result = sub_100023FA8(a1, 0LL, v4, (uint64_t)&v14, v16, a3);
  if (!(_DWORD)result)
  {
    v16.i64[0] = 0LL;
    int8x16_t v14 = v16;
    uint64_t v15 = v17;
    uint64_t result = sub_100023FA8(a1, 0LL, v4, (uint64_t)&v14, v16, v10);
    if (!(_DWORD)result)
    {
      if ((*(_BYTE *)(a1[1] + 65) & 1) != 0)
      {
        char v12 = *(_BYTE *)(v4 + 1295);
        char v13 = ~v12;
        *(_BYTE *)(v4 + 1295) = v12 | 1;
        v16.i64[0] = 0x4000000000000000uLL >> __clz(__rbit64(v5));
        int8x16_t v14 = v16;
        uint64_t v15 = v17;
        uint64_t result = sub_100023FA8(a1, 0LL, v4, (uint64_t)&v14, v16, v11);
        *(_BYTE *)(v4 + 1295) &= v13 | 0xFE;
      }

      else
      {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_10002D570(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(_DWORD *)(v3 + 104);
  if ((v4 & 0x7FFFFFFFu) <= a2) {
    return 22LL;
  }
  uint64_t v7 = *(void *)(v3 + 112);
  if (v4 < 0) {
    return sub_10002DC38(a1, v7, a2, a3, 0LL);
  }
  uint64_t result = 0LL;
  *a3 = v7 + a2;
  return result;
}

uint64_t sub_10002D5B4(uint64_t *a1, int a2, int a3, size_t __size, uint64_t a5, void *a6, uint64_t a7)
{
  uint64_t v7 = a1[1];
  int v8 = *(_DWORD *)(v7 + 140);
  int v9 = *(_DWORD *)(v7 + 148);
  size_t v10 = *(unsigned int *)(v7 + 36);
  uint64_t v70 = 0LL;
  char v71 = 0LL;
  v69.i64[0] = 0LL;
  v69.i64[1] = v10;
  unsigned int v11 = __size / v10;
  int v16 = __size;
  int v66 = v9;
  unint64_t v20 = calloc(1uLL, __size);
  if (!v20) {
    return 12LL;
  }
  uint64_t v21 = (*(_DWORD *)(v7 + 140) + *(_DWORD *)(v7 + 136) - 2) % (*(_DWORD *)(v7 + 104) & 0x7FFFFFFFu);
  uint64_t v22 = a1[1];
  int v23 = *(_DWORD *)(v22 + 104);
  int v64 = v8;
  uint64_t v65 = v20;
  if ((v23 & 0x7FFFFFFFu) <= v21)
  {
    uint64_t v12 = 22LL;
    goto LABEL_21;
  }

  uint64_t v62 = a7;
  uint64_t v24 = *(void *)(v22 + 112);
  if (v23 < 0)
  {
    uint64_t v12 = sub_10002DC38((uint64_t)a1, v24, v21, &v69, 0LL);
    if ((_DWORD)v12) {
      goto LABEL_21;
    }
    uint64_t v25 = v69.i64[0];
  }

  else
  {
    uint64_t v25 = v24 + v21;
    v69.i64[0] = v24 + v21;
  }

  uint64_t v12 = sub_100022BD0(a1, 0LL, 0x40000000, v25, 0LL, 0, 12, 0, &v71, 0LL, 0);
  if (!(_DWORD)v12)
  {
    uint64_t v61 = v25;
    unint64_t v28 = v71;
    if (*((_DWORD *)v71 + 9) < ((v10 - 40) / 0x28))
    {
      uint64_t v29 = 0LL;
      uint64_t v30 = 0LL;
      uint64_t v31 = a1[1];
      int8x16_t v32 = (int8x16_t)v10;
      int v33 = 0LL;
      uint64_t v34 = v62;
      goto LABEL_11;
    }

    uint64_t v60 = v71;
    v26.i64[0] = v69.i64[1];
    int8x16_t v58 = v26;
    uint64_t v45 = v70;
    char v71 = 0LL;
    uint64_t v46 = sub_10002D570( (uint64_t)a1,  (*(_DWORD *)(v7 + 140) + *(_DWORD *)(v7 + 136) - 1) % (*(_DWORD *)(v7 + 104) & 0x7FFFFFFFu),  &v69);
    if ((_DWORD)v46)
    {
      uint64_t v12 = v46;
    }

    else
    {
      unint64_t v28 = (uint64_t *)calloc(1uLL, v10);
      char v71 = v28;
      if (v28)
      {
        v28[1] = v69.i64[0];
        uint64_t v31 = a1[1];
        _OWORD v28[2] = *(void *)(v31 + 16);
        v28[3] = 1073741836LL;
        *((_DWORD *)v28 + 8) |= 1u;
        int v33 = v60;
        *((_DWORD *)v60 + 8) &= ~1u;
        int v47 = *(_DWORD *)(v7 + 140);
        unsigned int v48 = *(_DWORD *)(v7 + 104) & 0x7FFFFFFF;
        unsigned int v49 = (*(_DWORD *)(v7 + 136) + v47) % v48;
        *(_DWORD *)(v7 + 140) = v47 + 1;
        if (*(_DWORD *)(v7 + 128) == v49) {
          *(_DWORD *)(v7 + 128) = (v48 + v49 + 1) % v48;
        }
        uint64_t v30 = v45;
        uint64_t v29 = v61;
        uint64_t v34 = v62;
        int8x16_t v32 = v58;
LABEL_11:
        unsigned int v35 = a2 | 0x80000000;
        uint64_t v36 = (uint64_t)&v28[5 * *((unsigned int *)v28 + 9) + 5];
        *(_DWORD *)uint64_t v36 = v35;
        *(_DWORD *)(v36 + 4) = a3;
        *(_DWORD *)(v36 + 8) = v16;
        *(void *)(v36 + --*(_DWORD *)(result + 16) = a5;
        uint64_t v37 = *(void *)(v7 + 88);
        *(void *)(v7 + 88) = v37 + 1;
        *(void *)(v36 + 24) = v37;
        LODWORD(v36) = *(_DWORD *)(v7 + 148);
        uint64_t v38 = (*(_DWORD *)(v7 + 144) + (int)v36) % (*(_DWORD *)(v7 + 108) & 0x7FFFFFFFu);
        *(_DWORD *)(v7 + 148) = v11 + v36;
        int v39 = *(_DWORD *)(v31 + 108);
        if ((v39 & 0x7FFFFFFFu) <= v38)
        {
          uint64_t v12 = 22LL;
        }

        else
        {
          uint64_t v40 = &v28[5 * *((unsigned int *)v28 + 9) + 9];
          uint64_t v41 = *(void *)(v31 + 120);
          if ((v39 & 0x80000000) == 0)
          {
            *uint64_t v40 = v41 + v38;
LABEL_14:
            if (*(_DWORD *)(v7 + 132) == (_DWORD)v38) {
            uint64_t v42 = v71;
            }
            ++*((_DWORD *)v71 + 9);
            if (v33)
            {
              v67.i64[0] = v29;
              v67.i64[1] = v32.i64[0];
              uint64_t v68 = v30;
              uint64_t v43 = v33;
              uint64_t v44 = sub_100023FA8(a1, 0LL, (uint64_t)v33, (uint64_t)&v67, v32, v27);
              if ((_DWORD)v44)
              {
                uint64_t v12 = v44;
                int v33 = v43;
LABEL_46:
                free(v33);
                goto LABEL_21;
              }

              uint64_t v42 = v71;
            }

            else
            {
              uint64_t v43 = 0LL;
            }

            int8x16_t v67 = v69;
            uint64_t v68 = v70;
            uint64_t v12 = sub_100023FA8(a1, 0LL, (uint64_t)v42, (uint64_t)&v67, v69, v27);
            int v33 = v43;
            if (!(_DWORD)v12)
            {
              uint64_t v56 = sub_10002D42C(a1, v54, v55);
              int v33 = v43;
              uint64_t v12 = v56;
              if (!(_DWORD)v56)
              {
                uint64_t v57 = v71;
                if (v34)
                {
                  *(void *)uint64_t v34 = v71[5 * (*((_DWORD *)v71 + 9) - 1) + 9];
                  *(_DWORD *)(v34 + 8) = v16;
                  *(_DWORD *)(v34 + 12) = 0;
                  *(void *)(v34 + --*(_DWORD *)(result + 16) = 0LL;
                }

                uint64_t v12 = 0LL;
                v65[1] = v57[5 * (*((_DWORD *)v57 + 9) - 1) + 8];
                v65[2] = *(void *)(v7 + 16);
                *((_DWORD *)v65 + 6) = v35;
                *((_DWORD *)v65 + 7) = a3;
                *a6 = v65;
              }
            }

            goto LABEL_45;
          }

          BOOL v50 = v33;
          uint64_t v51 = v29;
          uint64_t v52 = v30;
          int8x16_t v59 = v32;
          uint64_t v53 = sub_10002DC38((uint64_t)a1, v41, v38, v40, 0LL);
          int8x16_t v32 = v59;
          uint64_t v30 = v52;
          uint64_t v29 = v51;
          uint64_t v34 = v62;
          int v33 = v50;
          uint64_t v12 = v53;
          if (!(_DWORD)v53) {
            goto LABEL_14;
          }
        }

uint64_t sub_10002DA58(uint64_t *a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  size_t v10 = (unsigned int *)a1[1];
  size_t v11 = v10[9];
  uint64_t v12 = malloc(v11);
  if (!v12) {
    return 12LL;
  }
  char v13 = v12;
  if (v10[35] == 1)
  {
    int v14 = 0;
  }

  else
  {
    int v14 = 0;
    unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
    while (1)
    {
      uint64_t v16 = (v10[34] + v14) % (v10[26] & 0x7FFFFFFF);
      uint64_t v17 = a1[1];
      int v18 = *(_DWORD *)(v17 + 104);
      if ((v18 & 0x7FFFFFFFu) <= v16)
      {
        uint64_t v15 = 22LL;
        goto LABEL_24;
      }

      uint64_t v19 = *(void *)(v17 + 112);
      if (v18 < 0)
      {
        uint64_t v21 = sub_10002DC38((uint64_t)a1, v19, v16, &v25, 0LL);
        if ((_DWORD)v21) {
          goto LABEL_27;
        }
        uint64_t v20 = v25;
      }

      else
      {
        uint64_t v20 = v19 + v16;
        unint64_t v25 = v20;
      }

      uint64_t v21 = sub_10002BE74(*a1, v20);
      if ((_DWORD)v21)
      {
LABEL_27:
        uint64_t v15 = v21;
        goto LABEL_24;
      }

      if (v13[6] != 1073741836) {
        goto LABEL_26;
      }
      unint64_t v22 = v13[9];
      if ((v11 - 40) / 0x28 < v22) {
        goto LABEL_26;
      }
      int v23 = v13 + 18;
      if ((_DWORD)v22) {
        break;
      }
LABEL_17:
      if (++v14 >= v10[35] - 1) {
        goto LABEL_23;
      }
    }

    while (*(v23 - 1) != a2)
    {
      v23 += 5;
      if (!--v22) {
        goto LABEL_17;
      }
    }

    if (a4 && *((_DWORD *)v23 - 8) != (a3 | a4 | 0x80000000))
    {
LABEL_26:
      uint64_t v15 = 92LL;
      goto LABEL_24;
    }

    if (a5)
    {
      *(void *)a5 = *v23;
      *(_DWORD *)(a5 + 8) = *((_DWORD *)v23 - 6);
    }
  }

uint64_t sub_10002DC38(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t *a5)
{
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v16[2] = v8;
  void v16[3] = v8;
  v16[0] = v8;
  v16[1] = v8;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v15 = a3;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v11 = 16;
  unsigned int v12 = 8;
  uint64_t result = sub_100034B44( (uint64_t)v16,  a1,  0LL,  0x40000000,  2,  10,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  8,  16,  0,  a2,  (uint64_t)sub_10002D39C);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_100034BB4((uint64_t)v16, 0LL, 0xFFFFFFFFLL, &v15, &v12, 8u, &v13, &v11);
    if (!(_DWORD)result)
    {
      unint64_t v10 = v14 - (a3 - v15);
      if (v14 <= a3 - v15)
      {
        return 2LL;
      }

      else
      {
        *a4 = v13 + a3 - v15;
        uint64_t result = 0LL;
        if (a5) {
          *a5 = v10;
        }
      }
    }
  }

  return result;
}

uint64_t sub_10002DD38( uint64_t a1, uint64_t a2, uint64_t (*a3)(void, void, void, void, uint64_t), uint64_t a4)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  int v12[2] = v6;
  void v12[3] = v6;
  v12[0] = v6;
  v12[1] = v6;
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  v10[2] = v6;
  v10[3] = v6;
  v10[0] = v6;
  v10[1] = v6;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v9 = 0LL;
  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100034B44( (uint64_t)v12,  a1,  0LL,  0x40000000,  2,  10,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  8,  16,  0,  a2,  (uint64_t)sub_10002D39C);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_100035394((uint64_t)v10, (uint64_t)v12, 0LL, &v9, 8u, 8u, v8, 16);
    if (!(_DWORD)result) {
      return sub_10002930C((uint64_t)v10, a3, a4, 0);
    }
  }

  return result;
}

uint64_t sub_10002DE10(int8x16_t *a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v46 = 0LL;
  int8x16_t v44 = 0uLL;
  uint64_t v45 = 0LL;
  int8x16_t v42 = 0uLL;
  uint64_t v43 = 0LL;
  uint64_t v14 = a1[1].i64[0];
  if (*(void *)(v14 + 48)) {
    uint64_t v15 = sub_100022BD0(a1->i64, 0LL, 0x80000000, *(void *)(v14 + 56), 0LL, 0, 18, 0, &v46, (uint64_t)&v44, 0);
  }
  else {
    uint64_t v15 = sub_10002E0D4(a1->i64, 0LL, &v46, (uint64_t)&v44);
  }
  uint64_t v17 = v15;
  if (!(_DWORD)v15)
  {
    int v18 = v46;
    if ((*((_DWORD *)v46 + 11) - *((_DWORD *)v46 + 12)) > 1)
    {
      uint64_t v20 = v46;
      int v18 = 0LL;
    }

    else
    {
      int8x16_t v42 = v44;
      uint64_t v43 = v45;
      uint64_t v46 = 0LL;
      uint64_t v19 = sub_10002E0D4(a1->i64, (uint64_t)v18, &v46, (uint64_t)&v44);
      if ((_DWORD)v19)
      {
LABEL_19:
        uint64_t v17 = v19;
LABEL_23:
        free(v18);
        goto LABEL_24;
      }

      uint64_t v20 = v46;
    }

    unsigned int v22 = *((_DWORD *)v20 + 14);
    unsigned int v21 = *((_DWORD *)v20 + 15);
    int v23 = &v20[5 * v21];
    int v25 = *((_DWORD *)v23 + 16);
    uint64_t v24 = v23 + 8;
    *((_DWORD *)v20 + 15) = v25;
    if (v22 != -1) {
      LODWORD(v20[5 * v22 + 8]) = v21;
    }
    int v26 = (8 * (_BYTE)a7) & 0x10;
    if (*((_DWORD *)v20 + 13) == -1) {
      *((_DWORD *)v20 + 13) = v21;
    }
    *((_DWORD *)v20 + 14) = v21;
    *uint64_t v24 = -1;
    ++*((_DWORD *)v20 + 12);
    int8x16_t v27 = &v20[5 * v21];
    *((_DWORD *)v27 + 18) = a2;
    *((_DWORD *)v27 + 19) = a3;
    v27[10] = a4;
    v27[11] = a5;
    v27[12] = a6;
    *((_DWORD *)v27 + 17) = v26 | 5;
    unint64_t v28 = v46;
    uint64_t v29 = a1[1].i64[0];
    uint64_t v30 = *(void *)(v29 + 32);
    *(void *)(v29 + 32) = v30 + 1;
    unsigned int v32 = *((_DWORD *)v28 + 14);
    unsigned int v31 = *((_DWORD *)v28 + 15);
    int v33 = &v28[5 * v31];
    int v35 = *((_DWORD *)v33 + 16);
    uint64_t v34 = v33 + 8;
    *((_DWORD *)v28 + 15) = v35;
    if (v32 != -1) {
      LODWORD(v28[5 * v32 + 8]) = v31;
    }
    if (*((_DWORD *)v28 + 13) == -1) {
      *((_DWORD *)v28 + 13) = v31;
    }
    *((_DWORD *)v28 + 14) = v31;
    *uint64_t v34 = -1;
    ++*((_DWORD *)v28 + 12);
    uint64_t v36 = &v28[5 * v31];
    *((_DWORD *)v36 + 18) = a2;
    *((_DWORD *)v36 + 19) = a3;
    v36[10] = a4;
    v36[11] = a5;
    v36[12] = v30;
    *((_DWORD *)v36 + 17) = v26 | (a7 << 31 >> 31) & 0xC | 3;
    if (v18)
    {
      int8x16_t v40 = v42;
      uint64_t v41 = v43;
      uint64_t v19 = sub_100023FA8(a1->i64, 0LL, (uint64_t)v18, (uint64_t)&v40, v42, v16);
      if ((_DWORD)v19) {
        goto LABEL_19;
      }
    }

    int8x16_t v40 = v44;
    uint64_t v41 = v45;
    uint64_t v17 = sub_100023FA8(a1->i64, 0LL, (uint64_t)v46, (uint64_t)&v40, v44, v16);
    if (!(_DWORD)v17)
    {
      uint64_t v38 = a1[1].i64[0];
      int8x16_t v40 = a1[4];
      uint64_t v41 = a1[5].i64[0];
      uint64_t v17 = sub_100023FA8(a1->i64, 0LL, v38, (uint64_t)&v40, v40, v37);
    }

    if (v18) {
      goto LABEL_23;
    }
  }

LABEL_24:
  if (v46) {
    free(v46);
  }
  return v17;
}

  if (!*((_DWORD *)__src + 9))
  {
    uint64_t v15 = 22LL;
    goto LABEL_4;
  }

  int v23 = (char *)__src + 56;
  uint64_t v24 = *((unsigned __int16 *)__src + 28);
  int v25 = *((unsigned __int16 *)__src + 22);
  int v26 = v25 >= v24;
  int8x16_t v27 = v25 - v24;
  if (v27 == 0
    || !v26
    || ((*((_WORD *)__src + 16) & 4) != 0 ? (unint64_t v28 = WORD4(v34)) : (unint64_t v28 = *((_WORD *)__src + 29)), v27 < v28))
  {
    uint64_t v15 = 92LL;
    goto LABEL_4;
  }

  uint64_t v29 = *((unsigned __int16 *)__src + 21);
  *(void *)unsigned int v32 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v31 = -1431655766;
  uint64_t v15 = sub_10003735C((uint64_t)&v34, (uint64_t)__src, 0, v32, (unsigned int *)&v31);
  if ((_DWORD)v15 || (uint64_t v15 = sub_10003744C(&v23[v29 + v24], v28, *(const void **)v32, v31, a3, a4, a5, a6), (_DWORD)v15))
  {
LABEL_4:
    if (a7)
    {
      free(*a7);
      *a7 = 0LL;
    }
  }

  if (__src && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(__src);
  }
  return v15;
}

        if (*a3) {
          goto LABEL_27;
        }
        unsigned int v31 = 1;
LABEL_26:
        *int8x16_t v37 = v31;
LABEL_27:
        *a3 = 1;
        if ((f_flags & 1) == 0) {
          *uint64_t v36 = 0;
        }
        if (!*a6)
        {
          int v33 = strdup(v15[v17 / 0x878].f_mntonname);
          *a6 = v33;
          if (!v33)
          {
            __int128 v8 = v36;
            goto LABEL_34;
          }
        }

uint64_t sub_10002E0D4(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v7 = a1[2];
  uint64_t result = sub_10002D5B4(a1, 18, 0, *(unsigned int *)(a1[1] + 36), 0LL, (void *)&v18[1] + 1, (uint64_t)v18);
  if ((_DWORD)result) {
    return result;
  }
  uint64_t v9 = *((void *)&v18[1] + 1);
  *(void *)(*((void *)&v18[1] + 1) + 32LL) = 0LL;
  unint64_t v10 = ((unint64_t)DWORD2(v18[0]) - 64) / 0x28;
  *(_DWORD *)(v9 + 44) = v10;
  *(void *)(v9 + 52) = -1LL;
  *(_DWORD *)(v9 + 60) = 0;
  if ((_DWORD)v10)
  {
    unint64_t v11 = 0LL;
    unsigned int v12 = (int *)(v9 + 64);
    do
    {
      unint64_t v13 = v11 + 1;
      else {
        int v14 = v11 + 1;
      }
      *unsigned int v12 = v14;
      v12 += 10;
      unint64_t v11 = v13;
    }

    while (v13 < v10);
  }

  uint64_t v15 = *(void *)(v9 + 8);
  *(void *)(v7 + 56) = v15;
  if (!a2)
  {
    *(void *)(v7 + 48) = v15;
    int v17 = 1;
    goto LABEL_12;
  }

  *(void *)(a2 + 32) = v15;
  int v16 = *(_DWORD *)(v7 + 68);
  if (v16)
  {
    int v17 = v16 + 1;
LABEL_12:
    *(_DWORD *)(v7 + 68) = v17;
  }

  if (a4)
  {
    *(_OWORD *)a4 = v18[0];
    *(void *)(a4 + --*(_DWORD *)(result + 16) = *(void *)&v18[1];
  }

  uint64_t result = 0LL;
  *a3 = v9;
  return result;
}

uint64_t sub_10002E1E0(uint64_t *a1, char a2, char a3, unint64_t a4)
{
  unint64_t v4 = a4;
  uint64_t v8 = *(unsigned int *)(a1[1] + 36);
  if (v8 * a4 >= 0x100000) {
    size_t v9 = 0x100000LL;
  }
  else {
    size_t v9 = v8 * a4;
  }
  unint64_t v10 = malloc(v9);
  if (v10)
  {
    int v18 = v10;
    if (v4)
    {
      unint64_t v19 = v9 / v8;
      while (1)
      {
        if (v4 >= v19) {
          unint64_t v20 = v19;
        }
        else {
          unint64_t v20 = v4;
        }
        uint64_t v21 = sub_10001BBF8(*a1);
        if ((_DWORD)v21)
        {
          uint64_t v23 = v21;
          strerror(v21);
          sub_100040B90( "blockcopy: unable to read paddr 0x%llx block_count 0x%llx: %s\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  a2);
          uint64_t v31 = 611LL;
          goto LABEL_17;
        }

        uint64_t v22 = sub_10001BC08(*a1);
        if ((_DWORD)v22) {
          break;
        }
        a2 += v20;
        a3 += v20;
        v4 -= v20;
        if (!v4) {
          goto LABEL_13;
        }
      }

      uint64_t v23 = v22;
      strerror(v22);
      sub_100040B90( "blockcopy: unable to write paddr 0x%llx block_count 0x%llx: %s\n",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  a3);
      uint64_t v31 = 612LL;
LABEL_17:
      sub_100044E7C((char *)v31, v23);
    }

    else
    {
LABEL_13:
      uint64_t v23 = 0LL;
    }

    free(v18);
  }

  else
  {
    sub_100040B90( "blockcopy: unable to allocate memory for buffer_size 0x%zx.\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v9);
    uint64_t v23 = 12LL;
    sub_100044E7C((char *)0x262, 12);
  }

  return v23;
}

uint64_t sub_10002E32C( uint64_t a1, char a2, unint64_t a3, int a4, int a5, int a6, int8x16_t a7, int8x16_t a8)
{
  uint64_t v13 = (void *)(a1 + 8);
  if (sub_10003A224((void *)a1, (uint32x4_t *)(a1 + 8), (a6 - 8), 0LL, a7, a8))
  {
    sub_100040B90( "object (oid 0x%llx): o_cksum (0x%llx) is invalid for object\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *(void *)(a1 + 8));
    uint64_t v21 = 92LL;
    sub_100044E7C((char *)5, 92);
    if ((a2 & 1) == 0)
    {
LABEL_6:
      if ((a2 & 2) == 0) {
        goto LABEL_12;
      }
      goto LABEL_7;
    }
  }

  else
  {
    uint64_t v21 = 0LL;
    if ((a2 & 1) == 0) {
      goto LABEL_6;
    }
  }

  if (*v13) {
    goto LABEL_6;
  }
  sub_100040B90("object (oid 0x%llx): o_oid invalid\n", v14, v15, v16, v17, v18, v19, v20, 0);
  uint64_t v21 = 92LL;
  sub_100044E7C((char *)6, 92);
  if ((a2 & 2) == 0) {
    goto LABEL_12;
  }
LABEL_7:
  unint64_t v22 = *(void *)(a1 + 16);
  if (!v22)
  {
    sub_100040B90( "object (oid 0x%llx): o_xid invalid, o_xid is 0\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *(void *)(a1 + 8));
    uint64_t v21 = 92LL;
    sub_100044E7C((char *)7, 92);
    unint64_t v22 = *(void *)(a1 + 16);
  }

  if (v22 > a3)
  {
    sub_100040B90( "object (oid 0x%llx): o_xid invalid, o_xid %llu is greater than nx_next_xid: %llu\n",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *v13);
    uint64_t v21 = 92LL;
    sub_100044E7C((char *)8, 92);
  }

unsigned int *sub_10002E4CC(uint64_t a1, int a2, _BYTE *a3)
{
  unsigned int v5 = sub_10002BDBC(a1);
  if (v5 <= 0x1000) {
    size_t v6 = 4096LL;
  }
  else {
    size_t v6 = v5;
  }
  unint64_t v7 = sub_10002BDC8(a1);
  uint64_t v8 = (unsigned int *)calloc(1uLL, v6);
  if (v8)
  {
    uint64_t v16 = v8;
    while (1)
    {
      unint64_t v17 = 0x4000000000000000uLL >> __clz(__rbit64(v6));
      if (a2) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = 0LL;
      }
      sub_10002BDBC(a1);
      int v19 = sub_10002BE74(a1, v18);
      if (v19)
      {
        int v40 = v19;
        sub_100040B90("failed to read container superblock\n", v20, v21, v22, v23, v24, v25, v26, v60);
        uint64_t v39 = 87LL;
        int v41 = v40;
        goto LABEL_32;
      }

      if (v16[8] != 1112758350)
      {
        sub_1000348B8((unsigned __int8 *)v16, v6);
        sub_100040B90("Device does not contain a valid APFS container.\n", v42, v43, v44, v45, v46, v47, v48, v60);
        uint64_t v39 = 88LL;
        goto LABEL_31;
      }

      v27.i32[0] = v16[9];
      if ((v27.i32[0] - 65537) < 0xFFFF0FFF
        || (v28 = v27.i32[0] % sub_10002BDBC(a1), int8x8_t v27 = (int8x8_t)v16[9], v28)
        || (uint8x8_t v29 = (uint8x8_t)vcnt_s8(v27), v29.i16[0] = vaddlv_u8(v29), v29.i32[0] >= 2u))
      {
        sub_100040B90("nx_block_size of %u is invalid\n", v20, v21, v22, v23, v24, v25, v26, v27.i8[0]);
        uint64_t v39 = 89LL;
        goto LABEL_31;
      }

      sub_10002BE5C(a1);
      size_t v6 = v16[9];
      free(v16);
      unint64_t v7 = sub_10002BDC8(a1);
      uint64_t v16 = (unsigned int *)calloc(1uLL, v6);
      if (!v16) {
        goto LABEL_16;
      }
    }

    if (*((void *)v16 + 5) - 1LL < v7) {
      goto LABEL_23;
    }
    if ((*((_BYTE *)v16 + 65) & 1) != 0)
    {
      sub_100040B90( "nx_block_count is %llu, while device block count is %llu\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  *((void *)v16 + 5));
      uint64_t v39 = 1225LL;
      int v41 = 92;
      goto LABEL_32;
    }

    sub_100040C68( "nx_block_count is %llu, while device block count is %llu\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  *((void *)v16 + 5));
    sub_100044E7C((char *)0x1F9, -7);
    *((void *)v16 + 5) = v7;
    *a3 = 1;
LABEL_23:
    uint64_t v95 = 0LL;
    __int128 v94 = 0u;
    __int128 v93 = 0u;
    __int128 v92 = 0u;
    __int128 v91 = 0u;
    __int128 v90 = 0u;
    __int128 v89 = 0u;
    __int128 v88 = 0u;
    __int128 v87 = 0u;
    __int128 v86 = 0u;
    __int128 v85 = 0u;
    __int128 v84 = 0u;
    __int128 v83 = 0u;
    __int128 v82 = 0u;
    __int128 v81 = 0u;
    __int128 v80 = 0u;
    __int128 v79 = 0u;
    __int128 v78 = 0u;
    __int128 v77 = 0u;
    __int128 v76 = 0u;
    __int128 v75 = 0u;
    __int128 v74 = 0u;
    __int128 v73 = 0u;
    __int128 v72 = 0u;
    __int128 v71 = 0u;
    __int128 v70 = 0u;
    __int128 v69 = 0u;
    __int128 v68 = 0u;
    __int128 v67 = 0u;
    __int128 v66 = 0u;
    __int128 v65 = 0u;
    __int128 v64 = 0u;
    v63[0] = a1;
    v63[1] = v16;
    v62[0] = v63;
    v62[1] = 0LL;
    unsigned int v56 = v16[26];
    if ((v56 & 0x7FFFFFF8) == 0
      || ((uint64_t v57 = *((void *)v16 + 14), (v56 & 0x80000000) != 0)
        ? (int v58 = sub_10002DD38( (uint64_t)v63,  v57,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000451FC,  (uint64_t)v62))
        : (v96[1] = v16[26],
           uint64_t v97 = 0LL,
           v96[0] = v57,
           int v58 = sub_1000451FC((uint64_t)&v97, 8LL, v96, 16LL, v62, v53, v54, v55)),
          v58))
    {
      sub_100040B90( "cannot find checkpoint area because container superblock is too damaged\n",  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v60);
      uint64_t v39 = 506LL;
LABEL_31:
      int v41 = 22;
LABEL_32:
      sub_100044E7C((char *)v39, v41);
      free(v16);
      return 0LL;
    }

    *a3 = 1;
  }

  else
  {
LABEL_16:
    sub_100040B90("failed to allocate memory to read the container superblock\n", v9, v10, v11, v12, v13, v14, v15, v60);
    sub_100044E7C((char *)0x56, 12);
    return 0LL;
  }

  return v16;
}

uint64_t sub_10002E878( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8) != 1LL)
  {
    sub_100040B90("nx_sb->nx_o.o_oid != OID_NX_SUPERBLOCK, %llu\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(a2 + 8));
    uint64_t v20 = 92LL;
    uint64_t v21 = 51LL;
    goto LABEL_12;
  }

  if (*(_DWORD *)(a2 + 32) != 1112758350)
  {
    sub_100040B90("nx_superblock magic number invalid: 0x%X\n", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(a2 + 32));
    uint64_t v20 = 92LL;
    uint64_t v21 = 52LL;
    goto LABEL_12;
  }

  char v9 = a3;
  if (*(void *)(a2 + 40) - 1LL >= (unint64_t)sub_10002BDC8(a1))
  {
    sub_100040B90( "nx_block_count is %llu, while device block count is %llu\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  *(void *)(a2 + 40));
    uint64_t v23 = 53LL;
    int v24 = 92;
    goto LABEL_15;
  }

  if ((*(void *)(a2 + 48) & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    sub_100040C68( "nx_features has unsupported flags: (0x%llX)\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  *(_BYTE *)(a2 + 48) & 0xFC);
    sub_100044E7C((char *)0x36, -3);
  }

  if (*(void *)(a2 + 56))
  {
    sub_100040C68( "nx_read_only_compatible_features has unsupported flags: (0x%llX)\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  *(void *)(a2 + 56));
    uint64_t v18 = qword_10008DB78;
    *(_DWORD *)(qword_10008DB78 + 28) = 1;
    *(_BYTE *)(v18 + 37) = 1;
    sub_1000428A8(qword_10008DB70, 1);
    sub_100044E7C((char *)0x37, -3);
  }

  uint64_t v19 = *(void *)(a2 + 64);
  if ((v19 & 0xFFFFFFFFFFFFFEFDLL) != 0)
  {
    sub_100040B90( "nx_incompatible_features has unsupported flags: (0x%llX)\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v19 & 0xFD);
    uint64_t v20 = 92LL;
    uint64_t v21 = 56LL;
LABEL_12:
    sub_100044E7C((char *)v21, 92);
    return v20;
  }

  if (uuid_is_null((const unsigned __int8 *)(a2 + 72)))
  {
    sub_100040B90("nx_uuid is NULL\n", v25, v26, v27, v28, v29, v30, v31, v85);
    uint64_t v20 = 92LL;
    uint64_t v21 = 57LL;
    goto LABEL_12;
  }

  if (*(void *)(a2 + 88) <= 0x3FFuLL)
  {
    sub_100040B90( "nx_next_oid (%llu) is less than the minimum (%u)\n",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  *(void *)(a2 + 88));
    uint64_t v20 = 92LL;
    uint64_t v21 = 58LL;
    goto LABEL_12;
  }

  uint64_t v121 = 0LL;
  __int128 v120 = 0u;
  __int128 v119 = 0u;
  __int128 v118 = 0u;
  __int128 v117 = 0u;
  __int128 v116 = 0u;
  __int128 v115 = 0u;
  __int128 v114 = 0u;
  __int128 v113 = 0u;
  __int128 v112 = 0u;
  __int128 v111 = 0u;
  __int128 v110 = 0u;
  __int128 v109 = 0u;
  __int128 v108 = 0u;
  __int128 v107 = 0u;
  __int128 v106 = 0u;
  __int128 v105 = 0u;
  __int128 v104 = 0u;
  __int128 v103 = 0u;
  __int128 v102 = 0u;
  __int128 v101 = 0u;
  __int128 v100 = 0u;
  __int128 v99 = 0u;
  __int128 v98 = 0u;
  __int128 v97 = 0u;
  __int128 v96 = 0u;
  __int128 v95 = 0u;
  __int128 v94 = 0u;
  __int128 v93 = 0u;
  __int128 v92 = 0u;
  __int128 v91 = 0u;
  __int128 v90 = 0u;
  uint64_t v88 = a1;
  uint64_t v89 = a2;
  unsigned int v32 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
  __int128 v86 = &v88;
  uint64_t v87 = 0LL;
  if (v32 <= 7)
  {
    sub_100040B90("nx_xp_desc_blocks (%u) is less than 8\n", v25, v26, v27, v28, v29, v30, v31, v32);
    uint64_t v20 = 92LL;
    uint64_t v21 = 59LL;
    goto LABEL_12;
  }

  if (sub_10002F260((uint64_t)&v88, &v86, v26, v27, v28, v29, v30, v31))
  {
    sub_100040B90( "NX checkpoint desc range is invalid: 0x%llx+0x%x\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  *(void *)(a2 + 112));
    uint64_t v20 = 92LL;
    uint64_t v21 = 60LL;
    goto LABEL_12;
  }

  if (v87 != (*(_DWORD *)(a2 + 104) & 0x7FFFFFFF))
  {
    sub_100040B90( "NX checkpoint desc blocks field is %u, but sum of ranges is %llu\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  *(_BYTE *)(a2 + 104));
    uint64_t v20 = 92LL;
    uint64_t v21 = 574LL;
    goto LABEL_12;
  }

  if ((*(_DWORD *)(a2 + 108) & 0x7FFFFFFFu) <= 7)
  {
    sub_100040B90("nx_xp_data_blocks (%u) is less than 8\n", v33, v34, v35, v36, v37, v38, v39, *(_BYTE *)(a2 + 108));
    uint64_t v20 = 92LL;
    uint64_t v21 = 61LL;
    goto LABEL_12;
  }

  uint64_t v87 = 0LL;
  uint64_t v40 = *(unsigned int *)(v89 + 108);
  uint64_t v41 = *(void *)(v89 + 120);
  if ((v40 & 0x80000000) != 0)
  {
    int v42 = sub_10002DD38( (uint64_t)&v88,  v41,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000451FC,  (uint64_t)&v86);
  }

  else
  {
    uint64_t v122 = 0LL;
    *(void *)__str = v41;
    v124[0] = v40;
    int v42 = sub_1000451FC((uint64_t)&v122, 8LL, (unint64_t *)__str, 16LL, &v86, v37, v38, v39);
  }

  if (v42)
  {
    sub_100040B90( "NX checkpoint data range is invalid: 0x%llx+0x%x\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(void *)(a2 + 120));
    uint64_t v20 = 92LL;
    uint64_t v21 = 62LL;
    goto LABEL_12;
  }

  uint64_t v50 = *(_DWORD *)(a2 + 108) & 0x7FFFFFFF;
  if (v87 != v50)
  {
    sub_100040B90( "NX checkpoint data blocks field is %u, but sum of ranges is %llu\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(_BYTE *)(a2 + 108));
    uint64_t v20 = 92LL;
    uint64_t v21 = 575LL;
    goto LABEL_12;
  }

  unsigned int v51 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
  if (*(_DWORD *)(a2 + 128) >= v51)
  {
    sub_100040B90( "nx_xp_desc_next (%u) is larger than the # of nx_xp_desc_blocks (%u)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(_DWORD *)(a2 + 128));
    uint64_t v20 = 92LL;
    uint64_t v21 = 63LL;
    goto LABEL_12;
  }

  if (*(_DWORD *)(a2 + 132) >= v50)
  {
    sub_100040B90( "nx_xp_data_next (%u) is larger than the # of nx_xp_data_blocks (%u)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(_DWORD *)(a2 + 132));
    uint64_t v20 = 92LL;
    uint64_t v21 = 64LL;
    goto LABEL_12;
  }

  if ((v9 & 1) != 0 || *(_DWORD *)(a2 + 140) || *(_DWORD *)(a2 + 148) || *(_DWORD *)(a2 + 136) || *(_DWORD *)(a2 + 144))
  {
    if (*(_DWORD *)(a2 + 136) >= v51)
    {
      sub_100040B90( "nx_xp_desc_index (%u) is larger than nx_xp_desc_blocks (%u)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(_DWORD *)(a2 + 136));
      uint64_t v20 = 92LL;
      uint64_t v21 = 65LL;
      goto LABEL_12;
    }

    unsigned int v52 = *(_DWORD *)(a2 + 140);
    if (v52 <= 1)
    {
      sub_100040B90("nx_xp_desc_len (%u) is less than 2\n", v43, v44, v45, v46, v47, v48, v49, *(_DWORD *)(a2 + 140));
      uint64_t v20 = 92LL;
      uint64_t v21 = 66LL;
      goto LABEL_12;
    }

    if (v52 >= v51)
    {
      sub_100040B90( "nx_xp_desc_len (%u) is larger than nx_xp_desc_blocks (%u)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(_DWORD *)(a2 + 140));
      uint64_t v20 = 92LL;
      uint64_t v21 = 67LL;
      goto LABEL_12;
    }

    if (*(_DWORD *)(a2 + 144) >= v50)
    {
      sub_100040B90( "nx_xp_data_index (%u) is is larger than nx_xp_data_blocks (%u)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(_DWORD *)(a2 + 144));
      uint64_t v20 = 92LL;
      uint64_t v21 = 68LL;
      goto LABEL_12;
    }

    unsigned int v53 = *(_DWORD *)(a2 + 148);
    if (v53 <= 1)
    {
      sub_100040B90("nx_xp_data_len (%u) is less than 2\n", v43, v44, v45, v46, v47, v48, v49, *(_DWORD *)(a2 + 148));
      uint64_t v20 = 92LL;
      uint64_t v21 = 69LL;
      goto LABEL_12;
    }

    if (v53 >= v50)
    {
      sub_100040B90( "nx_xp_data_len (%u) is larger than nx_xp_data_blocks (%u)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(_DWORD *)(a2 + 148));
      uint64_t v20 = 92LL;
      uint64_t v21 = 70LL;
      goto LABEL_12;
    }
  }

  if (!*(void *)(a2 + 152))
  {
    sub_100040B90("nx_spaceman_oid is invalid\n", v43, v44, v45, v46, v47, v48, v49, v85);
    uint64_t v20 = 92LL;
    uint64_t v21 = 71LL;
    goto LABEL_12;
  }

  if (!*(void *)(a2 + 160))
  {
    sub_100040B90("nx_omap_oid is invalid\n", v43, v44, v45, v46, v47, v48, v49, v85);
    uint64_t v20 = 92LL;
    uint64_t v21 = 72LL;
    goto LABEL_12;
  }

  if ((unint64_t)(*(void *)(a2 + 168) - 1LL) <= 0x3FE)
  {
    sub_100040B90( "nx_reaper_oid (%llu) is less than minimum OID (%d)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(void *)(a2 + 168));
    uint64_t v20 = 92LL;
    uint64_t v21 = 73LL;
    goto LABEL_12;
  }

  if ((*(_DWORD *)(a2 + 180) - 101) < 0xFFFFFF9C)
  {
    sub_100040B90("nx_max_file_systems (%u) is invalid\n", v43, v44, v45, v46, v47, v48, v49, *(_DWORD *)(a2 + 180));
    uint64_t v20 = 92LL;
    uint64_t v21 = 74LL;
    goto LABEL_12;
  }

  uint64_t v54 = 0LL;
  unint64_t v55 = v19 & 0x100;
  do
  {
    uint64_t v56 = *(void *)(a2 + 184 + 8 * v54);
    if ((unint64_t)(v56 - 1) < 0x3FF)
    {
      sub_100040B90( "nx_fs_oid (%llu) at index (%d) is less than minimum OID (%d)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v56);
      uint64_t v20 = 92LL;
      uint64_t v21 = 75LL;
      goto LABEL_12;
    }

    ++v54;
  }

  while (v54 != 100);
  if (*(void *)(a2 + 1264) >= 8uLL)
  {
    sub_100040C68( "nx_flags (0x%llx) has an unknown flag set \n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(void *)(a2 + 1264));
    sub_100044E7C((char *)0x4C, -3);
  }

  int v57 = *(_DWORD *)(a2 + 1316);
  int v58 = HIWORD(*(_DWORD *)(a2 + 1312));
  if ((unsigned __int16)*(_DWORD *)(a2 + 1312) != 1)
  {
    sub_100040C68( "nx_ephemeral_info 0: invalid version (%u), should be: (%d)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(_DWORD *)(a2 + 1312));
    sub_100044E7C((char *)0x4D, -6);
  }

  if (v58 != 4)
  {
    sub_100040C68( "nx_ephemeral_info 0: invalid structures per fs (%u), should be: (%d)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v58);
    sub_100044E7C((char *)0x4E, -8);
  }

  if ((v57 - 9) <= 0xFFFFFFF7)
  {
    sub_100040C68( "nx_ephemeral_info 0: invalid minimum block count per structure (%u), should be less than: (%d)\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v58);
    sub_100044E7C((char *)0x4F, -7);
  }

  for (uint64_t i = 0LL; i != 3; ++i)
  {
    if (*(void *)(a2 + 1320 + 8 * i))
    {
      sub_100040C68("nx_ephemeral_info %d: invalid info (0x%llx)\n", v43, v44, v45, v46, v47, v48, v49, i + 1);
      sub_100044E7C((char *)0x50, -10);
    }
  }

  if (*(void *)(a2 + 1400))
  {
    unint64_t v60 = *(void *)(a2 + 1392);
    if (!sub_10000DDF4((uint64_t)&v88, v60, *(void *)(a2 + 1400)))
    {
      sub_100040B90("NX media keylocker data range is invalid: 0x%llx+%llu\n", v43, v44, v45, v46, v47, v48, v49, v60);
      uint64_t v20 = 92LL;
      uint64_t v21 = 949LL;
      goto LABEL_12;
    }
  }

  if (*(void *)(a2 + 1304))
  {
    unint64_t v61 = *(void *)(a2 + 1296);
    if (!sub_10000DDF4((uint64_t)&v88, v61, *(void *)(a2 + 1304)))
    {
      sub_100040B90("NX keybag data range is invalid: 0x%llx+%llu\n", v43, v44, v45, v46, v47, v48, v49, v61);
      uint64_t v20 = 92LL;
      uint64_t v21 = 81LL;
      goto LABEL_12;
    }
  }

  if (*(void *)(a2 + 1248))
  {
    unint64_t v62 = *(void *)(a2 + 1240);
    if (!sub_10000DDF4((uint64_t)&v88, v62, *(void *)(a2 + 1248)))
    {
      sub_100040B90("NX blocked out range is invalid: 0x%llx+%llu\n", v43, v44, v45, v46, v47, v48, v49, v62);
      uint64_t v20 = 92LL;
      uint64_t v21 = 82LL;
      goto LABEL_12;
    }
  }

  uint64_t v63 = *(void *)(a2 + 1352);
  if ((v63 != 0) != (v55 >> 8))
  {
    if (v55) {
      __int128 v70 = "nx_fusion_mt_oid is invalid\n";
    }
    else {
      __int128 v70 = "nx_fusion_mt_oid should be invalid but isn't\n";
    }
    sub_100040B90(v70, v43, v44, v45, v46, v47, v48, v49, v85);
    uint64_t v20 = 92LL;
    uint64_t v21 = 83LL;
    goto LABEL_12;
  }

  if ((*(void *)(a2 + 1360) == 0LL) == (v63 != 0))
  {
    if (v55) {
      __int128 v71 = "nx_fusion_wbc_oid is invalid\n";
    }
    else {
      __int128 v71 = "nx_fusion_wbc_oid should be invalid but isn't\n";
    }
    sub_100040B90(v71, v43, v44, v45, v46, v47, v48, v49, v85);
    uint64_t v20 = 92LL;
    uint64_t v21 = 84LL;
    goto LABEL_12;
  }

  if (v55)
  {
    unint64_t v64 = *(void *)(a2 + 1368);
    unint64_t v65 = *(void *)(a2 + 1376);
    if (!v64
      || (*((void *)&v90 + 1)
        ? (__int128 v66 = (unint64_t *)(*((void *)&v90 + 1) + 48LL))
        : (__int128 v66 = (unint64_t *)(v89 + 40)),
          (unint64_t v67 = *v66, v67 > v65) ? (v68 = v67 > v64) : (v68 = 0),
          v68 ? (BOOL v69 = v67 - v65 >= v64) : (BOOL v69 = 0),
          !v69))
    {
      sub_100040B90( "nx_fusion_wbc range is invalid: 0x%llx+%llu\n",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *(void *)(a2 + 1368));
      uint64_t v20 = 92LL;
      uint64_t v21 = 85LL;
      goto LABEL_12;
    }
  }

  unint64_t v72 = *(void *)(a2 + 1384);
  unint64_t v73 = v72 / 0xE8D4A51000LL;
  if (v72 > 0x3B9AC9BB15066FFFLL || (uint64_t v20 = 0LL, v72) && v73 <= 0x538)
  {
    memset(v124, 170, 17);
    *(void *)__str = 0xAAAAAAAAAAAAAAAALL;
    __int128 v74 = sub_10001C8A0(v72, __str, 25);
    LOBYTE(v82) = (_BYTE)v74;
    if (!v74)
    {
      __int128 v82 = __str;
      snprintf(__str, 0x19uLL, "%llu", v72);
    }

    if (v72 <= 0x3B9AC9BB15066FFFLL)
    {
      if ((_DWORD)v73)
      {
        uint64_t v83 = 860LL;
        __int128 v84 = "nx_newest_mounted_version is less than expected: %s\n";
      }

      else
      {
        uint64_t v83 = 859LL;
        __int128 v84 = "nx_newest_mounted_version should not start with a 0: %s\n";
      }
    }

    else
    {
      uint64_t v83 = 858LL;
      __int128 v84 = "nx_newest_mounted_version is greater than expected: %s\n";
    }

    sub_100040C68(v84, v75, v76, v77, v78, v79, v80, v81, (char)v82);
    uint64_t v23 = v83;
    int v24 = -6;
LABEL_15:
    sub_100044E7C((char *)v23, v24);
    return 0LL;
  }

  return v20;
}

uint64_t sub_10002F260( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = *(unsigned int *)(v9 + 104);
  uint64_t v11 = *(void *)(v9 + 112);
  if ((v10 & 0x80000000) != 0) {
    return sub_10002DD38( a1,  v11,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000451FC,  (uint64_t)a2);
  }
  uint64_t v14 = 0LL;
  v13[0] = v11;
  v13[1] = v10;
  return sub_1000451FC((uint64_t)&v14, 8LL, v13, 16LL, a2, a6, a7, a8);
}

uint64_t sub_10002F2C0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  if ((_DWORD)a4) {
    uint64_t v11 = "tier2 superblock";
  }
  else {
    uint64_t v11 = "main superblock";
  }
  if ((_DWORD)a3 && (unint64_t v12 = *(void *)(a2 + 16), *(void *)(a1 + 16) > v12))
  {
    sub_100040B50( "the checkpoint superblock has a lower o_xid (%lld) than the %s (%lld)\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v12);
  }

  else if (*(_DWORD *)(a1 + 36) == *(_DWORD *)(a2 + 36))
  {
    if (*(void *)(a1 + 40) == *(void *)(a2 + 40))
    {
      if (uuid_compare((const unsigned __int8 *)(a1 + 72), (const unsigned __int8 *)(a2 + 72)))
      {
        sub_100040B50("checkpoint<->%s mismatch on uuid\n", v13, v14, v15, v16, v17, v18, v19, (char)v11);
      }

      else
      {
        BOOL v20 = *(void *)(a1 + 1280) == *(void *)(a2 + 1280) && *(void *)(a1 + 1287) == *(void *)(a2 + 1287);
        if (v20 && (*(unsigned __int8 *)(a2 + 1295) ^ *(unsigned __int8 *)(a1 + 1295)) == v8)
        {
          if (*(_DWORD *)(a1 + 104) == *(_DWORD *)(a2 + 104))
          {
            if (*(_DWORD *)(a1 + 108) == *(_DWORD *)(a2 + 108))
            {
              if (*(void *)(a1 + 112) == *(void *)(a2 + 112))
              {
                if (*(void *)(a1 + 120) == *(void *)(a2 + 120)) {
                  return 0LL;
                }
                sub_100040B50( "checkpoint<->%s mismatch on nx_xp_data_base: %lld %lld\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  (char)v11);
              }

              else
              {
                sub_100040B50( "checkpoint<->%s mismatch on nx_xp_desc_base: %lld %lld\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  (char)v11);
              }
            }

            else
            {
              sub_100040B50( "checkpoint<->%s mismatch on nx_xp_data_blocks: %d %d\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  (char)v11);
            }
          }

          else
          {
            sub_100040B50( "checkpoint<->%s mismatch on nx_xp_desc_blocks: %d %d\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  (char)v11);
          }
        }

        else
        {
          sub_100040B50("checkpoint<->%s mismatch on fusion uuid\n", v13, v14, v15, v16, v17, v18, v19, (char)v11);
        }
      }
    }

    else
    {
      sub_100040B50("checkpoint<->%s mismatch on nx_block_count: %lld %lld\n", a2, a3, a4, a5, a6, a7, a8, (char)v11);
    }
  }

  else
  {
    sub_100040B50("checkpoint<->%s mismatch on nx_block_size: %d %d\n", a2, a3, a4, a5, a6, a7, a8, (char)v11);
  }

  return 92LL;
}

uint64_t sub_10002F480(uint64_t a1, uint64_t a2, void **a3, unint64_t *a4)
{
  uint64_t v174 = a3;
  uint64_t v170 = a4;
  uint64_t v171 = v165;
  __chkstk_darwin(a1);
  uint64_t v13 = &v165[-((v7 + 15) & 0x1FFFFFFF0LL)];
  if ((_DWORD)v7) {
    memset(&v165[-((v7 + 15) & 0x1FFFFFFF0LL)], 170, v7);
  }
  unint64_t v208 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = *(void *)(a2 + 1264);
  __int128 v206 = 0u;
  __int128 v207 = 0u;
  __int128 v204 = 0u;
  __int128 v205 = 0u;
  __int128 v202 = 0u;
  __int128 v203 = 0u;
  __int128 v200 = 0u;
  __int128 v201 = 0u;
  __int128 v198 = 0u;
  __int128 v199 = 0u;
  __int128 v196 = 0u;
  __int128 v197 = 0u;
  __int128 v194 = 0u;
  __int128 v195 = 0u;
  __int128 v192 = 0u;
  __int128 v193 = 0u;
  __int128 v191 = 0u;
  __int128 v190 = 0u;
  __int128 v189 = 0u;
  __int128 v188 = 0u;
  __int128 v187 = 0u;
  __int128 v186 = 0u;
  __int128 v185 = 0u;
  __int128 v184 = 0u;
  __int128 v182 = 0u;
  __int128 v183 = 0u;
  __int128 v180 = 0u;
  __int128 v181 = 0u;
  __int128 v178 = 0u;
  __int128 v179 = 0u;
  __int128 v176 = 0u;
  __int128 v177 = 0u;
  uint64_t v175 = a1;
  *uint64_t v174 = 0LL;
  if (!*(_DWORD *)(a2 + 140)
    || !*(_DWORD *)(a2 + 148)
    || !*(_DWORD *)(a2 + 136)
    || !*(_DWORD *)(a2 + 144)
    || sub_10002BE68(a1)
    || (v14 & 2) == 0)
  {
    goto LABEL_136;
  }

  unsigned int v15 = (*(_DWORD *)(a2 + 140) + *(_DWORD *)(a2 + 136) - 1) % (*(_DWORD *)(a2 + 104) & 0x7FFFFFFFu);
  int v16 = 1;
  int v172 = 1;
  do
  {
    int v17 = 0;
    while (1)
    {
      int v18 = *(_DWORD *)(a2 + 104);
      unsigned int v19 = v15 - v17 + (v18 & 0x7FFFFFFF);
      uint64_t v20 = v19 % (v18 & 0x7FFFFFFFu);
      *(void *)&__int128 v176 = a2;
      uint64_t v21 = *(void *)(a2 + 112);
      if (v18 < 0)
      {
        int v35 = sub_10002DC38((uint64_t)&v175, v21, v19 % (v18 & 0x7FFFFFFFu), &v208, 0LL);
        if (v35)
        {
          int v26 = v35;
          char v36 = strerror(v35);
          sub_100040C68("failed to look up checkpoint block address: %s\n", v37, v38, v39, v40, v41, v42, v43, v36);
          uint64_t v34 = 542LL;
          goto LABEL_17;
        }

        uint64_t v22 = v208;
      }

      else
      {
        uint64_t v22 = v21 + v20;
        unint64_t v208 = v22;
      }

      int v23 = sub_10002BE74(a1, v22);
      if (v23)
      {
        int v26 = v23;
        char v164 = v208;
        strerror(v23);
        sub_100040B90("dev_read(%llu, 1): %s\n", v27, v28, v29, v30, v31, v32, v33, v164);
        uint64_t v34 = 127LL;
LABEL_17:
        int v44 = v26;
LABEL_18:
        sub_100044E7C((char *)v34, v44);
        goto LABEL_19;
      }

      if (!*((void *)v13 + 1) && *v174) {
        return 0LL;
      }
      if (*((_DWORD *)v13 + 6) == -2147483647) {
        break;
      }
LABEL_19:
      if (++v17 == v16) {
        goto LABEL_134;
      }
    }

    if (sub_10002E32C((uint64_t)v13, 11, *((void *)v13 + 2), 0, 0, *(_DWORD *)(a2 + 36), v24, v25))
    {
      sub_100040C68("checkpoint %d (xid %llu) fsck_obj_phys failed\n", v45, v46, v47, v48, v49, v50, v51, v20);
      goto LABEL_19;
    }

    if (sub_10002F2C0(a2, (uint64_t)v13, v17 == 0, 0LL, v48, v49, v50, v51))
    {
      sub_100040C68("checkpoint %d (xid %llu) superblock disagrees with block 0\n", v6, v7, v8, v9, v10, v11, v12, v20);
      goto LABEL_19;
    }

    int v52 = *((_DWORD *)v13 + 35);
    unsigned int v53 = (v52 + *((_DWORD *)v13 + 34) - 1) % (*((_DWORD *)v13 + 26) & 0x7FFFFFFFu);
    if ((_DWORD)v20 != v53)
    {
      sub_100040C68("xp_sb->nx_xp_desc_index (%d) doesn't match index block (%d)\n", v6, v7, v8, v9, v10, v11, v12, v53);
      uint64_t v34 = 128LL;
      int v44 = -7;
      goto LABEL_18;
    }

    if (v52 + v17 > (*(_DWORD *)(a2 + 104) & 0x7FFFFFFFu)) {
      goto LABEL_19;
    }
    if (sub_10002E878(a1, (uint64_t)v13, 1LL, v8, v9, v10, v11, v12))
    {
      sub_100040C68("checkpoint %d (xid %llu) superblock is invalid\n", v54, v55, v56, v57, v58, v59, v60, v20);
      goto LABEL_19;
    }

    *(void *)&__int128 v176 = v13;
    uint64_t v209 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v210 = 0LL;
    int v61 = *((_DWORD *)v13 + 35);
    unsigned int v173 = v15;
    if (v61 == 1) {
      goto LABEL_113;
    }
    int v62 = 0;
    while (1)
    {
      int v63 = *((_DWORD *)v13 + 34);
      int v166 = v62;
      uint64_t v64 = (v63 + v62) % (*((_DWORD *)v13 + 26) & 0x7FFFFFFFu);
      int v65 = *(_DWORD *)(v176 + 104);
      if ((v65 & 0x7FFFFFFFu) <= v64)
      {
        int v67 = 22;
LABEL_97:
        LODWORD(v169) = v67;
        strerror(v67);
        sub_100040B90("failed to look up checkpoint block address %d: %s\n", v95, v96, v97, v98, v99, v100, v101, v64);
        uint64_t v102 = 540LL;
        int v113 = (int)v169;
        int v103 = (int)v169;
        goto LABEL_104;
      }

      uint64_t v66 = *(void *)(v176 + 112);
      if (v65 < 0)
      {
        int v67 = sub_10002DC38((uint64_t)&v175, v66, v64, &v209, 0LL);
        if (v67) {
          goto LABEL_97;
        }
      }

      else
      {
        uint64_t v209 = v66 + v64;
      }

      if (v210)
      {
        free(v210);
        uint64_t v210 = 0LL;
      }

      int v68 = sub_100022BD0(&v175, 0LL, 0x40000000, v209, 0LL, 0, 12, 0, (uint64_t **)&v210, 0LL, 0);
      if (v68)
      {
        int v113 = v68;
        goto LABEL_109;
      }

      uint64_t v76 = (uint64_t *)v210;
      if (*((void *)v210 + 1) != v209)
      {
        sub_100040B90( "cpm_o.o_oid (0x%llx) doesn't match the physical address (0x%llx)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  *((void *)v210 + 1));
        int v113 = 92;
        uint64_t v102 = 107LL;
        goto LABEL_103;
      }

      if (*((void *)v210 + 2) != *(void *)(v176 + 16))
      {
        sub_100040B90( "checkpoint map o_xid (0x%llx) doesn't match checkpoint superblock o_xid (0x%llx)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  *((void *)v210 + 2));
        int v113 = 92;
        uint64_t v102 = 108LL;
        goto LABEL_103;
      }

      unint64_t v77 = v210[9];
      if (!(_DWORD)v77)
      {
        sub_100040B90("cpm_count is 0\n", v69, v70, v71, v72, v73, v74, v75, v165[0]);
        int v113 = 92;
        uint64_t v102 = 109LL;
        goto LABEL_103;
      }

      uint64_t v78 = *(unsigned int *)(v176 + 36);
      uint64_t v167 = (_DWORD *)v176;
      uint64_t v168 = v78;
      if ((v78 - 40) / 0x28uLL < v77)
      {
        sub_100040B90( "cpm_count (%u) is larger than the max that this block size can accommodate (%u)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v77);
        int v113 = 92;
        uint64_t v102 = 110LL;
LABEL_103:
        int v103 = 92;
LABEL_104:
        sub_100044E7C((char *)v102, v103);
        goto LABEL_109;
      }

      int v79 = *((_DWORD *)v13 + 35);
      unsigned int v80 = v210[8];
      uint64_t v169 = (uint64_t *)v210;
      if (v80 >= 2)
      {
        sub_100040C68("cpm_flags has an unknown flag set 0x%x\n", v69, v70, v71, v72, v73, v74, v75, v80);
        sub_100044E7C((char *)0x6F, -3);
        uint64_t v76 = v169;
        unsigned int v80 = *((_DWORD *)v169 + 8);
      }

      if (v166 == v79 - 2)
      {
        if ((v80 & 1) == 0)
        {
          sub_100040B90("cpm_flags has invalid flags set: 0x%x\n", v69, v70, v71, v72, v73, v74, v75, v80);
          int v113 = 92;
          uint64_t v114 = 112LL;
          goto LABEL_108;
        }
      }

      else if ((v80 & 1) != 0)
      {
        sub_100040B90("cpm_flags has invalid flags set: 0x%x\n", v69, v70, v71, v72, v73, v74, v75, v80);
        int v113 = 92;
        uint64_t v114 = 113LL;
        goto LABEL_108;
      }

      if (*((_DWORD *)v76 + 9)) {
        break;
      }
LABEL_87:
      int v62 = v166 + 1;
      unsigned int v15 = v173;
      if (v166 + 1 >= (*((_DWORD *)v13 + 35) - 1))
      {
        int v113 = 0;
        goto LABEL_109;
      }
    }

    unint64_t v81 = 0LL;
    __int128 v82 = (uint64_t **)(v76 + 9);
    while (2)
    {
      int v83 = *((_DWORD *)v82 - 8);
      if ((v83 & 0xC0000000) != 0x80000000)
      {
        sub_100040B90( "cpm_map[%d].cpm_type storage type (0x%x) != OBJ_EPHEMERAL\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v81);
        int v113 = 92;
        uint64_t v114 = 114LL;
        goto LABEL_108;
      }

      if ((unsigned __int16)*((_DWORD *)v82 - 8) > 0x17u || ((1 << v83) & 0xC6002C) == 0)
      {
        sub_100040C68("cpm_map[%d].cpm_type object type (0x%x) is invalid!\n", v69, v70, v71, v72, v73, v74, v75, v81);
        sub_100044E7C((char *)0x73, -5);
      }

      int v85 = *((_DWORD *)v82 - 7);
      if ((v85 & 0xC0000000) != 0)
      {
        sub_100040B90( "cpm_map[%d].cpm_subtype has nonzero storage type (0x%x)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v81);
        int v113 = 92;
        uint64_t v114 = 649LL;
        goto LABEL_108;
      }

      if (((unsigned __int16)*((_DWORD *)v82 - 7) > 0x24u || ((1LL << v85) & 0x100029CA01LL) == 0)
        && (unsigned __int16)*((_DWORD *)v82 - 7) != 255)
      {
        sub_100040C68( "cmp_map[%d].cpm_subtype object type (0x%x) is invalid!\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v81);
        sub_100044E7C((char *)0x28A, -5);
      }

      if ((unint64_t)*(v82 - 2) - 1 <= 0x3FE)
      {
        sub_100040B90( "cpm_map[%d].cpm_fs_oid (%llu) is less than minimum oid (%u)!\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v81);
        int v113 = 92;
        uint64_t v114 = 515LL;
        goto LABEL_108;
      }

      if (!*(v82 - 1))
      {
        sub_100040B90("cpm_map[%d].cpm_oid object type is invalid!\n", v69, v70, v71, v72, v73, v74, v75, v81);
        int v113 = 92;
        uint64_t v114 = 116LL;
        goto LABEL_108;
      }

      unsigned int v86 = *((_DWORD *)v82 - 6);
      if (!v86)
      {
        sub_100040B90("xp_map->cpm_map[%d].cpm_size is 0\n", v69, v70, v71, v72, v73, v74, v75, v81);
        int v113 = 92;
        uint64_t v114 = 121LL;
        goto LABEL_108;
      }

      if (v86 % v168)
      {
        sub_100040B90( "xp_map->cpm_map[%d].cpm_size (%u) is not a multiple of nx_block_size (%u)\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v81);
        int v113 = 92;
        uint64_t v114 = 122LL;
        goto LABEL_108;
      }

      v211[0] = *v82;
      v211[1] = (uint64_t *)(v86 / v168);
      uint64_t v87 = *(void *)(v176 + 120);
      if ((*(_DWORD *)(v176 + 108) & 0x80000000) != 0)
      {
        if (!sub_10002DD38( (uint64_t)&v175,  v87,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000452FC,  (uint64_t)v211))
        {
LABEL_95:
          sub_100040B90( "cpm_map[%d].cpm_paddr (%llu) + cpm_size (%u) is not in the checkpoint data area\n",  v88,  v70,  v71,  v72,  v73,  v74,  v75,  v81);
          uint64_t v114 = 538LL;
          goto LABEL_107;
        }
      }

      else
      {
        v212[1] = *(unsigned int *)(v176 + 108);
        uint64_t v213 = 0LL;
        v212[0] = v87;
      }

      uint64_t v89 = *v82;
      v212[0] = (uint64_t)*v82;
      unint64_t v90 = *(unsigned int *)(v176 + 108);
      uint64_t v69 = *(void *)(v176 + 120);
      if ((v90 & 0x80000000) != 0)
      {
        if (sub_10002DD38( (uint64_t)&v175,  v69,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000305E4,  (uint64_t)v212) != -1) {
          goto LABEL_106;
        }
        unint64_t v91 = v212[0];
LABEL_78:
        unint64_t v92 = v167[36];
        if (v91 >= v92)
        {
          BOOL v93 = v91 >= (v167[37] + v92);
          __int128 v94 = v169;
          if (v93)
          {
            sub_100040B90( "nx_xp_data_index (%u) puts the checkpoint data outside of its range\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v167[36]);
            uint64_t v114 = 120LL;
            goto LABEL_107;
          }
        }

        else
        {
          BOOL v93 = v91 + (v167[27] & 0x7FFFFFFF) >= (v167[37] + v92);
          __int128 v94 = v169;
          if (v93)
          {
            sub_100040B90( "nx_xp_data_index (%u) puts the checkpoint data outside of its range\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v167[36]);
            uint64_t v114 = 119LL;
            goto LABEL_107;
          }
        }

        ++v81;
        v82 += 5;
        continue;
      }

      break;
    }

    unint64_t v91 = (unint64_t)v89 - v69;
LABEL_106:
    sub_100040B90( "could not look up cpm_map[%d].cpm_paddr (%llu) in checkpoint data area\n",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v81);
    uint64_t v114 = 539LL;
LABEL_107:
    int v113 = 92;
LABEL_108:
    sub_100044E7C((char *)v114, 92);
    unsigned int v15 = v173;
LABEL_109:
    if (v210) {
      free(v210);
    }
    if (v113)
    {
      sub_100040C68("checkpoint %d (xid %llu) checkpoint map is invalid\n", v69, v70, v71, v72, v73, v74, v75, v20);
      goto LABEL_19;
    }

LABEL_118:
    uint64_t v105 = v175;
    uint64_t v175 = 0LL;
    *(void *)&__int128 v176 = 0LL;
    sub_10002955C(&v175);
    uint64_t v175 = v105;
    if (v104)
    {
      sub_100040C68( "checkpoint %d (xid %llu) failed consistency check\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v20);
      sub_100044E7C((char *)0x3DE, -7);
      unsigned int v15 = v173;
      goto LABEL_19;
    }

    if (*v174) {
      free(*v174);
    }
    unsigned int v119 = *(_DWORD *)(a2 + 36);
    __int128 v120 = malloc(v119);
    *uint64_t v174 = v120;
    if (!v120)
    {
      sub_100040B90("malloc(%u)\n", v121, v122, v123, v124, v125, v126, v127, v119);
      uint64_t v160 = 12LL;
      uint64_t v161 = 129LL;
      int v162 = 12;
      goto LABEL_168;
    }

    memcpy(v120, v13, 0x588uLL);
    uint64_t v128 = v170;
    unint64_t *v170 = v208;
    *((_DWORD *)v128 + 2) = v119;
LABEL_134:
    if (*v174) {
      return 0LL;
    }
    if ((v172 & 1) == 0) {
      goto LABEL_166;
    }
LABEL_136:
    int v129 = *(_DWORD *)(a2 + 104);
    if ((v129 & 0x7FFFFFFF) == 0)
    {
LABEL_165:
      sub_100040B90("no valid checkpoint found\n", v6, v7, v8, v9, v10, v11, v12, v165[0]);
      uint64_t v160 = 92LL;
      uint64_t v161 = 126LL;
      goto LABEL_167;
    }

    unint64_t v130 = 0LL;
    BOOL v131 = 0;
    unsigned int v173 = 0;
    unint64_t v132 = 0LL;
    while (2)
    {
      *(void *)&__int128 v176 = a2;
      uint64_t v133 = *(void *)(a2 + 112);
      if ((v129 & 0x80000000) == 0)
      {
        uint64_t v134 = v130 + v133;
        unint64_t v208 = v134;
        goto LABEL_140;
      }

      int v148 = sub_10002DC38((uint64_t)&v175, v133, v130, &v208, 0LL);
      if (v148)
      {
        int v138 = v148;
        strerror(v148);
        sub_100040C68( "failed to look up checkpoint block address %d: %s\n",  v149,  v150,  v151,  v152,  v153,  v154,  v155,  v130);
        uint64_t v147 = 541LL;
LABEL_144:
        int v156 = v138;
LABEL_145:
        sub_100044E7C((char *)v147, v156);
      }

      else
      {
        uint64_t v134 = v208;
LABEL_140:
        int v135 = sub_10002BE74(a1, v134);
        if (v135)
        {
          int v138 = v135;
          char v139 = v208;
          strerror(v135);
          sub_100040B90("dev_read(%llu, 1): %s\n", v140, v141, v142, v143, v144, v145, v146, v139);
          uint64_t v147 = 124LL;
          goto LABEL_144;
        }

        if (*((void *)v13 + 1))
        {
          if (sub_10002E32C( (uint64_t)v13,  10,  *((void *)v13 + 2),  0,  0,  *(_DWORD *)(a2 + 36),  v136,  v137))
          {
            sub_100040C68("checkpoint %d fsck_obj_phys failed\n", v6, v7, v8, v9, v10, v11, v12, v130);
            goto LABEL_146;
          }

          int v157 = *((_DWORD *)v13 + 6);
          if (v157 != -2147483647 && v157 != 1073741836)
          {
            sub_100040C68("checkpoint %d obj->o_type is invalid: (0x%x)\n", v6, v7, v8, v9, v10, v11, v12, v130);
            uint64_t v147 = 125LL;
            int v156 = -5;
            goto LABEL_145;
          }
        }

        unint64_t v158 = *((void *)v13 + 2);
        if (v158 == v132 && v131)
        {
          int v159 = -2147483647;
          if (*((_DWORD *)v13 + 6) != -2147483647)
          {
            BOOL v131 = 1;
            goto LABEL_146;
          }
        }

        else
        {
          if (v158 < v132) {
            goto LABEL_146;
          }
          int v159 = *((_DWORD *)v13 + 6);
        }

        BOOL v131 = v159 == -2147483647;
        unint64_t v132 = *((void *)v13 + 2);
        unsigned int v173 = v130;
      }

LABEL_146:
      ++v130;
      int v129 = *(_DWORD *)(a2 + 104);
      int v16 = v129 & 0x7FFFFFFF;
      if (v130 < (v129 & 0x7FFFFFFFu)) {
        continue;
      }
      break;
    }

    if (!v132) {
      goto LABEL_165;
    }
    int v172 = 0;
    unsigned int v15 = v173;
  }

  while (v16);
  if (*v174) {
    return 0LL;
  }
LABEL_166:
  sub_100040B90("no valid checkpoint\n", v6, v7, v8, v9, v10, v11, v12, v165[0]);
  uint64_t v160 = 92LL;
  uint64_t v161 = 130LL;
LABEL_167:
  int v162 = 92;
LABEL_168:
  sub_100044E7C((char *)v161, v162);
  return v160;
}

uint64_t sub_1000301EC( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a4 == 8 && (_DWORD)a6 == 16)
  {
    unint64_t v8 = *a3;
    unint64_t v9 = *a5;
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v11 = *(void *)(a1 + 24);
    if (v11)
    {
      unint64_t v12 = *(void *)(v11 + 48);
      unint64_t v13 = *(void *)(v11 + 96);
    }

    else
    {
      unint64_t v12 = *(void *)(v10 + 40);
      if ((*(_BYTE *)(v10 + 65) & 1) != 0) {
        unint64_t v13 = *(void *)(v10 + 40);
      }
      else {
        unint64_t v13 = 0LL;
      }
    }

    unint64_t v15 = a5[1];
    char v16 = __clz(__rbit64(*(unsigned int *)(v10 + 36)));
    if (!v8 || (v12 > v15 ? (BOOL v17 = v12 > v8) : (BOOL v17 = 0), v17 ? (v18 = v12 - v15 >= v8) : (v18 = 0), !v18))
    {
      BOOL v19 = 0x4000000000000000uLL >> v16 < v8 && v13 > v15;
      BOOL v20 = v19 && (v13 | (0x4000000000000000uLL >> v16)) > v8;
      if (!v20 || ((v13 - v15) | (0x4000000000000000uLL >> v16)) < v8)
      {
LABEL_43:
        sub_100040B90( "evict mapping range is invalid: (0x%llx+%llu --> 0x%llx+%llu)\n",  a2,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  v8);
        uint64_t v14 = 850LL;
        goto LABEL_44;
      }
    }

    if (v11)
    {
      unint64_t v21 = *(void *)(v11 + 48);
      unint64_t v22 = *(void *)(v11 + 96);
      if (!v9) {
        goto LABEL_36;
      }
    }

    else
    {
      unint64_t v21 = *(void *)(v10 + 40);
      if ((*(_BYTE *)(v10 + 65) & 1) != 0) {
        unint64_t v22 = *(void *)(v10 + 40);
      }
      else {
        unint64_t v22 = 0LL;
      }
      if (!v9)
      {
LABEL_36:
        unint64_t v23 = 0x4000000000000000uLL >> v16;
        BOOL v25 = v23 < v9 && v22 > v15 && (v22 | v23) > v9;
        if (v25 && ((v22 - v15) | v23) >= v9) {
          return 0LL;
        }
        goto LABEL_43;
      }
    }

    if (v21 > v15 && v21 > v9 && v21 - v15 >= v9) {
      return 0LL;
    }
    goto LABEL_36;
  }

  sub_100040B90( "unexpected key (%u) / val (%u) size in evict mapping tree\n",  a2,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  a4);
  uint64_t v14 = 849LL;
LABEL_44:
  uint64_t v26 = 92LL;
  sub_100044E7C((char *)v14, 92);
  return v26;
}

uint64_t sub_100030350(uint64_t a1)
{
  *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v20[2] = v2;
  v20[3] = v2;
  v20[0] = v2;
  v20[1] = v2;
  v19[0] = a1;
  v19[1] = 0LL;
  uint64_t v3 = *(void *)(a1 + 8);
  if ((*(_DWORD *)(v3 + 104) & 0x80000000) != 0)
  {
    sub_100034B44( (uint64_t)v20,  a1,  0LL,  0x40000000,  2,  10,  0,  *(_DWORD *)(v3 + 36),  8,  16,  0,  *(void *)(v3 + 112),  (uint64_t)sub_10002D39C);
    uint64_t v6 = sub_100031CD0( (uint64_t)v20,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000305B0,  (uint64_t)v19,  0LL,  1);
    if ((_DWORD)v6)
    {
      uint64_t v5 = v6;
      uint64_t v14 = "NX checkpoint descriptor area fragmented metadata tree is invalid\n";
LABEL_14:
      sub_100040B90(v14, v7, v8, v9, v10, v11, v12, v13, v18);
      return v5;
    }

    uint64_t v3 = *(void *)(a1 + 8);
  }

  if ((*(_DWORD *)(v3 + 108) & 0x80000000) != 0)
  {
    sub_100034B44( (uint64_t)v20,  a1,  0LL,  0x40000000,  2,  10,  0,  *(_DWORD *)(v3 + 36),  8,  16,  0,  *(void *)(v3 + 120),  (uint64_t)sub_10002D39C);
    uint64_t v15 = sub_100031CD0( (uint64_t)v20,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000305B0,  (uint64_t)v19,  0LL,  1);
    if ((_DWORD)v15)
    {
      uint64_t v5 = v15;
      uint64_t v14 = "NX checkpoint data area fragmented metadata tree is invalid\n";
      goto LABEL_14;
    }
  }

  uint64_t v4 = *(void *)(a1 + 24);
  if ((*(_DWORD *)(v4 + 164) & 0x80000000) != 0)
  {
    sub_100034B44( (uint64_t)v20,  a1,  0LL,  0x40000000,  2,  10,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  8,  16,  0,  *(void *)(v4 + 168),  (uint64_t)sub_10002D39C);
    uint64_t v16 = sub_100031CD0( (uint64_t)v20,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000305B0,  (uint64_t)v19,  0LL,  1);
    if ((_DWORD)v16)
    {
      uint64_t v5 = v16;
      uint64_t v14 = "Spaceman internal pool bitmap fragmented metadata tree is invalid\n";
      goto LABEL_14;
    }

    uint64_t v4 = *(void *)(a1 + 24);
  }

  if ((*(void *)(v4 + 152) & 0x8000000000000000LL) == 0) {
    return 0LL;
  }
  sub_100034B44( (uint64_t)v20,  a1,  0LL,  0x40000000,  2,  10,  0,  *(_DWORD *)(*(void *)(a1 + 8) + 36LL),  8,  16,  0,  *(void *)(v4 + 176),  (uint64_t)sub_10002D39C);
  uint64_t v5 = sub_100031CD0( (uint64_t)v20,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000305B0,  (uint64_t)v19,  0LL,  1);
  if ((_DWORD)v5)
  {
    uint64_t v14 = "Spaceman internal pool fragmented metadata tree is invalid\n";
    goto LABEL_14;
  }

  return v5;
}

uint64_t sub_1000305B0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, void *a7, uint64_t a8)
{
  else {
    return 0LL;
  }
}

uint64_t sub_1000305E4(void *a1, int a2, void *a3, int a4, void *a5)
{
  uint64_t result = 92LL;
  if (a2 == 8 && a4 == 16)
  {
    unint64_t v7 = *a5 - *a3;
    if (*a5 < *a3 || v7 >= a3[1])
    {
      return 0LL;
    }

    else
    {
      *a5 = *a1 + v7;
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

char *sub_100030634( char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_10008C9D0 & 1) == 0)
  {
    int v8 = dword_10008C9D4;
    if (dword_10008C9D4 <= 0xFF && (v9 = result, (uint64_t result = (char *)malloc(0x10uLL)) != 0LL))
    {
      *(void *)uint64_t result = v9;
      *((void *)result + 1) = 0LL;
      *off_100070698 = result;
      off_100070698 = (_UNKNOWN **)(result + 8);
      dword_10008C9D4 = v8 + 1;
    }

    else
    {
      uint64_t result = sub_100040B50( "more than %d inodes tracked as rolling, disabling pfkur tracking repairs\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  0);
      byte_10008C9D0 = 1;
    }
  }

  return result;
}

uint64_t sub_1000306CC( uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_10008C9D0 & 1) == 0)
  {
    int v8 = (__int128 *)off_100070690;
    if (!off_100070690)
    {
      uint64_t v25 = 0LL;
      goto LABEL_19;
    }

    do
    {
      sub_100040C68( "missing upgrade-rolling entry for inode (%llu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(void *)v8);
      uint64_t v10 = sub_100044E7C((char *)0x3C2, -2);
      memset(v26, 0, sizeof(v26));
      if (a3)
      {
        uint64_t v18 = sub_1000251C0(a3, 9u, 2, 0, 1, v8, 8u, v26, 0x18u);
        if ((_DWORD)v18)
        {
          uint64_t v25 = v18;
          goto LABEL_9;
        }
      }

      else
      {
        sub_100024E94((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17);
      }

      int v8 = (__int128 *)*((void *)v8 + 1);
    }

    while (v8);
  }

  uint64_t v25 = 0LL;
LABEL_9:
  BOOL v19 = off_100070690;
  if (!off_100070690) {
    goto LABEL_19;
  }
  BOOL v20 = &off_100070690;
  for (unint64_t i = off_100070690; ; unint64_t i = v22)
  {
    unint64_t v22 = (void *)i[1];
    if (v19 != i) {
      break;
    }
    off_100070690 = (_UNKNOWN *)i[1];
    if (!v22) {
      goto LABEL_17;
    }
LABEL_16:
    free(i);
    BOOL v19 = off_100070690;
  }

  do
  {
    unint64_t v23 = v19;
    BOOL v19 = (void *)v19[1];
  }

  while (v19 != i);
  v23[1] = v22;
  if (v22) {
    goto LABEL_16;
  }
  BOOL v20 = (_UNKNOWN **)(v23 + 1);
LABEL_17:
  off_100070698 = v20;
  free(i);
LABEL_19:
  dword_10008C9D4 = 0;
  byte_10008C9D0 = 0;
  return v25;
}

uint64_t sub_100030818( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(*(void *)(a2 + 40) + 56LL) & 0x40) == 0)
  {
    sub_100040B90( "pfkur_tree_key : object (oid 0x%llx): pfkur tree record present on non-pfkur volume\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *a3);
    uint64_t v11 = 963LL;
    goto LABEL_26;
  }

  unint64_t v12 = *a3;
  if ((byte_10008C9D0 & 1) == 0)
  {
    uint64_t v13 = off_100070690;
    if (off_100070690)
    {
      uint64_t v14 = off_100070690;
      while (*v14 != v12)
      {
        uint64_t v14 = (void *)v14[1];
        if (!v14) {
          goto LABEL_14;
        }
      }

      if (off_100070690 == (_UNKNOWN *)v14)
      {
        uint64_t v17 = &off_100070690;
        off_100070690 = (_UNKNOWN *)*((void *)off_100070690 + 1);
        if (off_100070690) {
          goto LABEL_13;
        }
      }

      else
      {
        do
        {
          uint64_t v15 = v13;
          uint64_t v13 = (void *)v13[1];
        }

        while (v13 != v14);
        uint64_t v16 = v14[1];
        v15[1] = v16;
        uint64_t v17 = (_UNKNOWN **)(v15 + 1);
        if (v16) {
          goto LABEL_13;
        }
      }

      off_100070698 = v17;
LABEL_13:
      --dword_10008C9D4;
      free(v14);
      unint64_t v12 = *a3;
    }
  }

uint64_t sub_100030A20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100030A38(a1, a2, a3, 0LL, 0LL, 0LL, a4, 0);
}

uint64_t sub_100030A38( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, uint64_t a7, char a8)
{
  unsigned int v14 = *(_DWORD *)(a1 + 48);
  int v15 = *(_DWORD *)(a1 + 52) != 0;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  __int128 v20 = 0uLL;
  uint64_t v16 = sub_100022BD0( *(uint64_t **)a1,  *(void *)(a1 + 8),  *(_DWORD *)(a1 + 40),  *(void *)(a1 + 56),  a3,  v15 << 29,  2,  v14,  (uint64_t **)&v22,  (uint64_t)&v20,  a8);
  if (!(_DWORD)v16)
  {
    uint64_t v18 = v22;
    uint64_t v19 = (char *)v22 + DWORD2(v20) - 40;
    if (a7)
    {
      *(_OWORD *)a7 = *v19;
      *(_DWORD *)(a7 + 40) = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a7 + 44) = *(_DWORD *)(a1 + 36);
      *(void *)(a7 + 64) = a2;
    }

    if (a4)
    {
      *(_OWORD *)a4 = v20;
      *(void *)(a4 + --*(_DWORD *)(result + 16) = v21;
    }

    if (a5)
    {
      *a5 = v18;
      if (a6) {
        *a6 = v19;
      }
    }

    else
    {
      free(v18);
    }
  }

  return v16;
}

unint64_t sub_100030B3C( uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, _WORD *a5, uint64_t *a6, _WORD *a7)
{
  unint64_t result = sub_100030C08(a1, a2, a3);
  if ((unsigned __int16)result == 0xFFFFLL)
  {
    uint64_t v14 = 0LL;
    LOWORD(v15) = 0;
  }

  else
  {
    unint64_t v15 = result >> 16;
    uint64_t v14 = a1 + (unsigned __int16)result + *(unsigned __int16 *)(a1 + 42) + 56;
  }

  int v16 = *(unsigned __int16 *)(a1 + 32);
  int v17 = *(_DWORD *)(a2 + 4);
  *a4 = v14;
  *a5 = v15;
  if (a6)
  {
    unint64_t v18 = HIWORD(result);
    uint64_t v19 = a1 + v17 + ((v16 << 31 >> 31) & 0xFFFFFFD8) - 56 - WORD2(result) + 56;
    if ((result & 0xFFFE00000000LL) == 0xFFFE00000000LL)
    {
      uint64_t v19 = 0LL;
      LOWORD(v18) = 0;
    }

    *a6 = v19;
    *a7 = v18;
  }

  return result;
}

unint64_t sub_100030C08(uint64_t a1, uint64_t a2, unsigned int a3)
{
  __int16 v3 = *(_WORD *)(a1 + 32);
  uint64_t v4 = a1 + 56;
  if ((v3 & 4) != 0)
  {
    uint64_t v10 = (unsigned __int16 *)(v4 + 4LL * a3);
    unsigned int v6 = *v10;
    uint64_t v8 = v10[1];
    if (v6 == 0xFFFF) {
      LOWORD(v7) = 0;
    }
    else {
      int v7 = *(_DWORD *)(a2 + 8);
    }
    if ((_DWORD)v8 == 0xFFFF)
    {
      uint64_t v9 = 0LL;
    }

    else if ((_DWORD)v8 == 65534)
    {
      uint64_t v8 = 65534LL;
      uint64_t v9 = 65534LL;
    }

    else if ((v3 & 2) != 0)
    {
      uint64_t v9 = *(unsigned int *)(a2 + 12);
    }

    else if ((v3 & 8) != 0)
    {
      uint64_t v9 = *(unsigned __int16 *)(a2 + 44) + 8;
    }

    else
    {
      uint64_t v9 = 8LL;
    }
  }

  else
  {
    uint64_t v5 = (unsigned __int16 *)(v4 + 8LL * a3);
    unsigned int v6 = *v5;
    LOWORD(v7) = v5[1];
    uint64_t v8 = v5[2];
    uint64_t v9 = v5[3];
  }

  return (v8 << 32) | (v9 << 48) | ((unint64_t)(unsigned __int16)v7 << 16) | v6;
}

unint64_t sub_100030CB4( uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, _WORD *a5, unsigned int a6, uint64_t *a7, _WORD *a8)
{
  return sub_100030B3C(a1, a2, a6, a7, a8, 0LL, 0LL);
}

uint64_t sub_100030D18( uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a3;
  unsigned int v12 = *(unsigned __int16 *)(a1 + 32);
  unint64_t v13 = 8LL;
  if ((v12 & 2) != 0) {
    unint64_t v13 = *(unsigned int *)(a2 + 12);
  }
  if ((v12 & 4) != 0) {
    unsigned int v14 = 4;
  }
  else {
    unsigned int v14 = 8;
  }
  if ((v12 & 1) != 0) {
    int v15 = -96;
  }
  else {
    int v15 = -56;
  }
  int v16 = *(_DWORD *)a2;
  unint64_t v17 = *(unsigned int *)(a2 + 4);
  BOOL v18 = v12 < 0x20 || (_DWORD)a3 == 0;
  int v19 = *(_DWORD *)a2;
  if (!v18)
  {
    sub_100040C68( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n warning: btn: invalid btn_flags (0x%x)\n",  a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 8));
    sub_100044E7C((char *)0x17A, -3);
    int v19 = *(_DWORD *)a2;
  }

  __int16 v20 = *(_WORD *)(a1 + 32);
  if ((v19 & 0x80) != 0)
  {
    if ((v20 & 0x18) != 0x18)
    {
      if (v9)
      {
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: missing btn_flags (expected 0x%x, actual 0x%x)\n",  a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 8));
        sub_100044E7C((char *)0x390, 92);
      }

      if (!a4
        || !sub_1000428C4(qword_10008DB70, "Set missing flags? ", a3, (uint64_t)a4, a5, a6, a7, a8, v126))
      {
        return 92LL;
      }

      __int16 v20 = *(_WORD *)(a1 + 32) | 0x18;
      *(_WORD *)(a1 + 32) = v20;
      *a4 = 1;
    }

    unint64_t v13 = (*(_DWORD *)(a2 + 44) + v13);
  }

  else if ((v20 & 0x18) != 0)
  {
    if (v9)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: unexpected btn_flags (0x%x)\n",  a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 8));
      sub_100044E7C((char *)0x391, 92);
    }

    if (!a4
      || !sub_1000428C4( qword_10008DB70,  "Clear unexpected flags? ",  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  v126))
    {
      return 92LL;
    }

    __int16 v20 = *(_WORD *)(a1 + 32) & 0xFFE7;
    *(_WORD *)(a1 + 32) = v20;
    *a4 = 1;
  }

  char v21 = v20;
  if ((v20 & 4) != 0)
  {
    if (!(_DWORD)v13)
    {
      if (v9)
      {
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_fixed.bt_val_size (%u), given btn_flags (0x%x)\n",  a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 8));
        uint64_t v22 = 92LL;
        uint64_t v23 = 380LL;
        goto LABEL_52;
      }

      return 92LL;
    }
  }

  else if (*(_DWORD *)(a2 + 8) && (_DWORD)v13)
  {
    if (v9)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_flags (0x%x), given btn_btree.bt_fixed.bt_key_size (%u) and btn_btree.bt_fixed.bt_val_size (%u)\n",  a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 8));
      uint64_t v22 = 92LL;
      uint64_t v23 = 379LL;
LABEL_52:
      int v46 = 92;
LABEL_53:
      sub_100044E7C((char *)v23, v46);
      return v22;
    }

    return 92LL;
  }

  unsigned int v24 = *(unsigned __int16 *)(a1 + 42);
  if (v14 > v24)
  {
    if (v9)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_table_space.len (%u), given toc_entry_size (%u) and btn_flags (0x%x)\n",  a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 8));
      uint64_t v22 = 92LL;
      uint64_t v23 = 381LL;
      goto LABEL_52;
    }

    return 92LL;
  }

  unsigned int v25 = *(_DWORD *)(a1 + 36);
  if ((v12 & 4) != 0) {
    char v26 = 2;
  }
  else {
    char v26 = 3;
  }
  if (v25 > v24 >> v26)
  {
    if (v9)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_nkeys (%u), given btn_table_space.len (%u) and toc_entry_size (%u)\n",  a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 8));
      uint64_t v22 = 92LL;
      uint64_t v23 = 382LL;
      goto LABEL_52;
    }

    return 92LL;
  }

  if (!(v25 | v21 & 1))
  {
    if (v9)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_nkeys (%u), given btn_flags (0x%x)\n",  a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 8));
      uint64_t v22 = 92LL;
      uint64_t v23 = 383LL;
      goto LABEL_52;
    }

    return 92LL;
  }

  uint64_t v27 = calloc(1uLL, 0x10uLL);
  if (!v27)
  {
LABEL_57:
    if (!v9) {
      return 12LL;
    }
    sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: validate_loc_ctx_alloc failed for btn_nkeys (%u)\n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  *(void *)(a1 + 8));
    uint64_t v22 = 12LL;
    uint64_t v23 = 384LL;
    int v46 = 12;
    goto LABEL_53;
  }

  int v35 = v27;
  size_t v36 = (2 * *(_DWORD *)(a1 + 36) + 7) & 0xFFFFFFF8;
  *(_DWORD *)int v35 = v36;
  uint64_t v37 = calloc(v36, 4uLL);
  v35[1] = v37;
  if (!v37)
  {
    free(v35);
    goto LABEL_57;
  }

  if (*(_WORD *)(a1 + 40))
  {
    int v45 = 0;
    goto LABEL_61;
  }

  int v45 = sub_10003191C((unsigned __int16 *)a1, (_DWORD *)a2, *(_DWORD *)(a1 + 40), 0, (uint64_t)v35);
  if (!v45)
  {
    if ((*(_WORD *)(a1 + 32) & 4) != 0)
    {
      unint64_t v48 = *(unsigned __int16 *)(a1 + 42) >> v26;
      if (((((unint64_t)*(unsigned int *)(a2 + 4) - 56)
           / ((unint64_t)(*(_DWORD *)(a2 + 8) + v13) + 4)) & 0xFFFFFFFFFFFFFFFELL) > v48)
      {
        if (v9)
        {
          sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_table_space (%u, %u), given btn_flags (0x%x)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a1 + 8));
          uint64_t v22 = 92LL;
          uint64_t v50 = 386LL;
LABEL_74:
          int v49 = 92;
LABEL_66:
          sub_100044E7C((char *)v50, v49);
          goto LABEL_67;
        }

        goto LABEL_79;
      }
    }

    if (*(_WORD *)(a1 + 46))
    {
      int v52 = sub_10003191C((unsigned __int16 *)a1, (_DWORD *)a2, *(_DWORD *)(a1 + 44), 5, (uint64_t)v35);
      if (v52)
      {
        if (v9)
        {
          int v53 = v52;
          sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_free_space (%u, %u)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a1 + 8));
          sub_100044E7C((char *)0x183, v53);
        }

        goto LABEL_79;
      }
    }

    unsigned int v54 = *(unsigned __int16 *)(a1 + 48);
    uint64_t v134 = (uint64_t)v35;
    if (v54 == 0xFFFF)
    {
      unsigned int v55 = *(unsigned __int16 *)(a1 + 50);
LABEL_82:
      uint64_t v56 = (v15 + v17);
      unsigned int v57 = *(unsigned __int16 *)(a1 + 52);
      if (v57 != 0xFFFF)
      {
        uint64_t v128 = (v15 + v17);
        unsigned int v130 = v55;
        LODWORD(v17) = 0;
        unint64_t v131 = a1 + v56 + 56;
        while (1)
        {
          if ((*(_DWORD *)a2 & 0x40) != 0) {
            int v87 = 0x40000;
          }
          else {
            int v87 = 0x80000;
          }
          unint64_t v13 = v13 & 0xFFFFFFFF00000000LL | v87 | v57;
          int v88 = sub_10003191C((unsigned __int16 *)a1, (_DWORD *)a2, v13, 4, 0LL);
          if (v88)
          {
            if (!v9) {
              goto LABEL_146;
            }
            int v99 = v88;
            sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_val_free_list offset %u\n",  v89,  v90,  v91,  v92,  v93,  v94,  v95,  *(void *)(a1 + 8));
            uint64_t v100 = 391LL;
            goto LABEL_138;
          }

          uint64_t v96 = (unsigned __int16 *)(v131 - v57);
          int v97 = v96[1];
          unint64_t v132 = v132 & 0xFFFFFFFF00000000LL | v57 | (v97 << 16);
          int v98 = sub_10003191C((unsigned __int16 *)a1, (_DWORD *)a2, v57 | (v97 << 16), 4, v134);
          if (v98) {
            break;
          }
          unint64_t v17 = (v97 + v17);
          unsigned int v57 = *v96;
          if (v57 == 0xFFFF)
          {
            unsigned int v58 = *(unsigned __int16 *)(a1 + 54);
            int v35 = (void *)v134;
            uint64_t v56 = v128;
            unsigned int v55 = v130;
            if (v9)
            {
              sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_val_free_list length (%u), given total value length (%u)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a1 + 8));
              uint64_t v22 = 92LL;
              uint64_t v50 = 393LL;
              goto LABEL_74;
            }

            goto LABEL_79;
          }
        }

        if (!v9) {
          goto LABEL_146;
        }
        int v99 = v98;
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_val_free_list entry (%u, %u)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a1 + 8));
        uint64_t v100 = 392LL;
LABEL_138:
        int v102 = v99;
        goto LABEL_145;
      }

      unsigned int v58 = *(unsigned __int16 *)(a1 + 54);
LABEL_84:
      if (*(_DWORD *)(a1 + 36))
      {
        uint64_t v127 = v56;
        unsigned int v129 = v58;
        unsigned int v59 = 0;
        unsigned int v60 = v55;
        while (1)
        {
          unsigned int v133 = v60;
          unint64_t v61 = sub_100030C08(a1, a2, v59);
          unint64_t v17 = v17 & 0xFFFFFFFF00000000LL | v61;
          int v62 = sub_10003191C((unsigned __int16 *)a1, (_DWORD *)a2, v17, 1, v134);
          if (v62)
          {
            if (!v9) {
              goto LABEL_146;
            }
            int v104 = v62;
            sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid key (%u, %u)\n",  v63,  v64,  v65,  v66,  v67,  v68,  v69,  *(void *)(a1 + 8));
            uint64_t v100 = 394LL;
            goto LABEL_144;
          }

          unint64_t v70 = HIWORD(v61);
          unint64_t v131 = v131 & 0xFFFFFFFF00000000LL | WORD2(v61) | (HIWORD(v61) << 16);
          int v71 = sub_10003191C((unsigned __int16 *)a1, (_DWORD *)a2, WORD2(v61) | (HIWORD(v61) << 16), 2, v134);
          if (v71) {
            break;
          }
          unint64_t v72 = v61 >> 16;
          if ((v16 & 0x40) == 0) {
            LODWORD(v72) = ((v61 >> 16) + 7) & 0xFFFFFFF8;
          }
          if ((_DWORD)v70 != 65534)
          {
            if ((v16 & 0x40) != 0) {
              v129 += v70;
            }
            else {
              v129 += (v70 + 7) & 0x1FFF8;
            }
          }

          unsigned int v60 = v72 + v133;
          ++v59;
          uint64_t v73 = *(unsigned int *)(a1 + 36);
          if (v59 >= v73)
          {
            int v35 = (void *)v134;
            uint64_t v56 = v127;
            LOWORD(v58) = v129;
            goto LABEL_128;
          }
        }

        if (!v9) {
          goto LABEL_146;
        }
        int v104 = v71;
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid value (%u, %u)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a1 + 8));
        uint64_t v100 = 395LL;
LABEL_144:
        int v102 = v104;
        goto LABEL_145;
      }

      uint64_t v73 = 0LL;
      LOWORD(v60) = v55;
LABEL_128:
      unsigned int v103 = *(unsigned __int16 *)(a1 + 44);
      if (v103 < (unsigned __int16)v60)
      {
        if (v9)
        {
          sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_free_space (%u, %u), given total key length (%u)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a1 + 8));
          uint64_t v22 = 92LL;
          uint64_t v50 = 396LL;
          goto LABEL_74;
        }

LABEL_61:
  uint64_t v22 = 92LL;
  if (v9)
  {
    sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_table_space (%u, %u)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a1 + 8));
    if (v45) {
      int v49 = v45;
    }
    else {
      int v49 = 92;
    }
    uint64_t v50 = 385LL;
    goto LABEL_66;
  }

uint64_t sub_10003191C(unsigned __int16 *a1, _DWORD *a2, int a3, int a4, uint64_t a5)
{
  unsigned __int16 v6 = a3;
  unsigned __int16 v8 = HIWORD(a3);
  int v9 = a1[16];
  if ((v9 & 2) != 0)
  {
    int v11 = a2[3];
  }

  else
  {
    if ((v9 & 8) != 0) {
      int v10 = a2[11];
    }
    else {
      int v10 = 0;
    }
    int v11 = v10 + 8;
  }

  int v12 = *a2;
  if ((unsigned __int16)a3 == 0xFFFF || !HIWORD(a3))
  {
    uint64_t result = 22LL;
    if ((unsigned __int16)a3 == 0xFFFF)
    {
      if ((v12 & 4) != 0 && a4 == 2) {
        int v19 = 0;
      }
      else {
        int v19 = 22;
      }
      if ((v9 & 2) != 0) {
        unsigned int v20 = v19;
      }
      else {
        unsigned int v20 = 22;
      }
      if (HIWORD(a3)) {
        return 22LL;
      }
      else {
        return v20;
      }
    }

    return result;
  }

  unsigned int v13 = a2[1] + ((v9 << 31 >> 31) & 0xFFFFFFD8) - 56;
  unsigned int v14 = 8;
  unsigned int v15 = a1[22];
  switch(a4)
  {
    case 1:
      if (HIWORD(a3) > 0x340u) {
        return 7LL;
      }
      int v16 = a2[2];
      unsigned int v14 = 1;
      if (v16 && HIWORD(a3) != v16) {
        return 22LL;
      }
      goto LABEL_13;
    case 2:
      if ((unsigned __int16)a3 == 65534 || HIWORD(a3) == 65534)
      {
        uint64_t result = 22LL;
        if ((unsigned __int16)a3 == 65534 && HIWORD(a3) == 65534)
        {
          if ((v12 & 4) != 0) {
            unsigned int v21 = 0;
          }
          else {
            unsigned int v21 = 22;
          }
          if ((v9 & 2) != 0) {
            return v21;
          }
          else {
            return 22LL;
          }
        }

        return result;
      }

      if (HIWORD(a3) > 0xEE0u) {
        return 7LL;
      }
      unsigned int v14 = 1;
      if (v11 && HIWORD(a3) != v11) {
        return 22LL;
      }
LABEL_48:
      unsigned __int16 v6 = *((_WORD *)a2 + 2) + (((__int16)((_WORD)v9 << 15) >> 15) & 0xFFD8) - 56 - a3;
      if ((v12 & 0x40) == 0)
      {
LABEL_17:
        if ((v6 & 7) != 0 || HIWORD(a3) % v14) {
          return 14LL;
        }
      }

uint64_t sub_100031C30(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v3 = *a2;
  uint64_t v4 = *(unsigned int *)(a3 + 4);
  if ((_DWORD)v4)
  {
    uint64_t v5 = 0LL;
    int v6 = 0;
    int v7 = *(unsigned __int16 **)(a3 + 8);
    while (1)
    {
      if ((v3 & 0x40) != 0)
      {
        uint64_t v5 = *v7;
      }

      else
      {
        uint64_t v8 = ((v6 + 7) & 0x1FFF8) + v5;
        uint64_t v5 = *v7;
        if (v8 != v5) {
          return 22LL;
        }
      }

      int v6 = v7[1];
      v7 += 2;
      if (!--v4)
      {
        uint64_t v9 = (v6 + 7) & 0x1FFF8;
        goto LABEL_9;
      }
    }
  }

  uint64_t v9 = 0LL;
  uint64_t v5 = 0LL;
LABEL_9:
  int v10 = (v3 >> 6) & 1;
  if (v10) {
    return 0LL;
  }
  else {
    return 22LL;
  }
}

uint64_t sub_100031CD0( uint64_t a1, uint64_t a2, uint64_t (*a3)(void, void, const void *, void, void *, void, uint64_t, int *), uint64_t a4, void *a5, char a6)
{
  if (*(_DWORD *)(a1 + 44) != 2) {
    return 45LL;
  }
  uint64_t v12 = *(void *)(a1 + 56);
  unsigned int v103 = 0LL;
  memset(v104, 170, sizeof(v104));
  int v102 = 0LL;
  __int128 v100 = 0u;
  __int128 v101 = 0u;
  __int128 v98 = 0u;
  __int128 v99 = 0u;
  __int128 v97 = 0u;
  memset(v106, 0, sizeof(v106));
  uint64_t v105 = v12;
  __int16 v96 = -1;
  uint64_t v20 = sub_100030A38(a1, v12, a2, (uint64_t)v104, &v103, &v102, (uint64_t)&v97, a6);
  if (!(_DWORD)v20)
  {
    unsigned int v21 = v102;
    unsigned int v22 = *v102;
    if ((*v102 & 0xFFFFFE20) != 0)
    {
      sub_100040C68( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n warning: btn: invalid btn_btree.bt_fixed.bt_flags (0x%x)\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v103[1]);
      sub_100044E7C((char *)0x19A, -3);
      unsigned int v21 = v102;
      unsigned int v22 = *v102;
    }

    if ((~v22 & 0x18) == 0)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_fixed.bt_flags (0x%x)\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v103[1]);
      uint64_t v20 = 92LL;
      uint64_t v24 = 411LL;
LABEL_38:
      int v32 = 92;
LABEL_39:
      sub_100044E7C((char *)v24, v32);
      goto LABEL_40;
    }

    int v25 = *(_DWORD *)(a1 + 52);
    if ((v22 & 0x180) == 0x180)
    {
      if (!v25) {
        goto LABEL_13;
      }
    }

    else
    {
      if (v25 | v22 & 0x180)
      {
LABEL_13:
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: unexpected btn_btree.bt_fixed.bt_flags (0x%x)\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v103[1]);
        uint64_t v20 = 92LL;
        uint64_t v24 = 914LL;
        goto LABEL_38;
      }

      int v25 = 0;
    }

    if (((v22 << 28) & 0x80000000 | (((v22 >> 4) & 1) << 30)) != *(_DWORD *)(a1 + 40))
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_fixed.bt_flags (0x%x), given mt_btflags\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v103[1]);
      uint64_t v20 = 92LL;
      uint64_t v24 = 412LL;
      goto LABEL_38;
    }

    int v26 = *(_DWORD *)(a1 + 24);
    if (v26 && v21[1] != v26)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_fixed.bt_node_size (%u), given mt_node_size (%u)\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v103[1]);
      uint64_t v20 = 92LL;
      uint64_t v24 = 415LL;
      goto LABEL_38;
    }

    unsigned int v27 = v21[2];
    uint64_t v28 = (uint64_t)v103;
    if (v27 > 0x340 || (v27 & 3) != 0)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_fixed.bt_key_size (%u)\n",  v13,  v14,  (uint64_t)v103,  v16,  v17,  v18,  v19,  v103[1]);
      uint64_t v20 = 92LL;
      uint64_t v24 = 416LL;
      goto LABEL_38;
    }

    if (!v27 && (v103[4] & 4) != 0)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_fixed.bt_key_size (%u), given btn_flags (0x%x)\n",  v13,  v14,  (uint64_t)v103,  v16,  v17,  v18,  v19,  v103[1]);
      uint64_t v20 = 92LL;
      uint64_t v24 = 417LL;
      goto LABEL_38;
    }

    if ((v22 & 1) != 0 && v27 != 8)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_fixed.bt_key_size (%u), given btn_btree.bt_fixed.bt_flags (0x%x)\n",  v13,  v14,  (uint64_t)v103,  v16,  v17,  v18,  v19,  v103[1]);
      uint64_t v20 = 92LL;
      uint64_t v24 = 418LL;
      goto LABEL_38;
    }

    int v29 = *(_DWORD *)(a1 + 28);
    if (v29 && v27 != v29)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_fixed.bt_key_size (%u), given mt_key_size (%u)\n",  v13,  v14,  (uint64_t)v103,  v16,  v17,  v18,  v19,  v103[1]);
      uint64_t v20 = 92LL;
      uint64_t v24 = 419LL;
      goto LABEL_38;
    }

    unsigned int v30 = v21[3];
    if (v30 > 0xEE0 || (v30 & 7) != 0)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_fixed.bt_val_size (%u)\n",  v13,  v14,  (uint64_t)v103,  v16,  v17,  v18,  v19,  v103[1]);
      uint64_t v20 = 92LL;
      uint64_t v24 = 420LL;
      goto LABEL_38;
    }

    int v31 = *(_DWORD *)(a1 + 32);
    if (v31 && v30 != v31)
    {
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_fixed.bt_val_size (%u), given mt_val_size (%u)\n",  v13,  v14,  (uint64_t)v103,  v16,  v17,  v18,  v19,  v103[1]);
      uint64_t v20 = 92LL;
      uint64_t v24 = 421LL;
      goto LABEL_38;
    }

    if (v25)
    {
      uint64_t v20 = sub_100047038( *(uint64_t **)a1,  *(void *)(a1 + 8),  a2,  (BOOL *)&v101 + 8,  &v100,  (void *)&v100 + 1,  v106,  0x40u);
      if ((_DWORD)v20) {
        goto LABEL_40;
      }
      uint64_t v28 = (uint64_t)v103;
    }

    __int128 v94 = 0uLL;
    uint64_t v95 = 0LL;
    __int128 v92 = *(_OWORD *)v104;
    uint64_t v93 = *(void *)&v104[16];
    uint64_t v20 = sub_10003262C( a1,  0LL,  (uint64_t)&v94,  v28,  (uint64_t)&v92,  (unint64_t *)&v105,  a2,  a3,  a4,  0LL,  0,  0LL,  0,  &v96,  (uint64_t)&v97,  1u,  a6);
    if (!(_DWORD)v20)
    {
      if (BYTE11(v101))
      {
        while (1)
        {
          sub_10004096C( "Restarting tree validation in case more minkey errors exist...\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v91);
          BYTE11(v101) = 0;
          BYTE9(v101) = 1;
          uint64_t v41 = v99;
          __int128 v94 = 0uLL;
          uint64_t v95 = 0LL;
          __int128 v92 = *(_OWORD *)v104;
          uint64_t v93 = *(void *)&v104[16];
          uint64_t v42 = sub_10003262C( a1,  0LL,  (uint64_t)&v94,  (uint64_t)v103,  (uint64_t)&v92,  (unint64_t *)&v105,  a2,  0LL,  0LL,  0LL,  0,  0LL,  0,  &v96,  (uint64_t)&v97,  1u,  0);
          if ((_DWORD)v42) {
            break;
          }
          *(void *)&__int128 v99 = v41;
          if (!BYTE11(v101)) {
            goto LABEL_49;
          }
        }

        uint64_t v20 = v42;
        goto LABEL_40;
      }

LABEL_49:
      uint64_t v43 = v102;
      unsigned int v44 = v102[4];
      if (v44 > 0x340 || v44 < v98)
      {
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_longest_key (expected %u, actual %u)\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v103[1]);
        uint64_t v20 = 92LL;
        sub_100044E7C((char *)0x1AA, 92);
        if (!sub_1000428C4( qword_10008DB70,  "Fix btree: bt_longest_key (%u)? ",  v46,  v47,  v48,  v49,  v50,  v51,  v102[4])) {
          goto LABEL_40;
        }
        unsigned int v44 = v98;
        uint64_t v43 = v102;
        v102[4] = v98;
        int v45 = 1;
      }

      else
      {
        int v45 = 0;
      }

      if (*((void *)v43 + 3))
      {
        int v52 = v43[2];
        if (v52)
        {
          if (v44 != v52)
          {
            sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_longest_key (%u), given btn_btree.bt_fixed.bt_key_size (%u)\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v103[1]);
            uint64_t v20 = 92LL;
            sub_100044E7C((char *)0x1AB, 92);
            if (!sub_1000428C4( qword_10008DB70,  "Fix btree: bt_longest_key (%u)? ",  v53,  v54,  v55,  v56,  v57,  v58,  v102[4])) {
              goto LABEL_40;
            }
            uint64_t v43 = v102;
            v102[4] = v102[2];
            int v45 = 1;
          }
        }
      }

      unsigned int v59 = v43[5];
      if (v59 > 0xEE0 || (int v60 = v43[5], v59 < DWORD1(v98)))
      {
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_longest_val (expected %u, actual %u)\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v103[1]);
        uint64_t v20 = 92LL;
        sub_100044E7C((char *)0x1AC, 92);
        if (!sub_1000428C4( qword_10008DB70,  "Fix btree: bt_longest_val (%u)? ",  v61,  v62,  v63,  v64,  v65,  v66,  v102[5])) {
          goto LABEL_40;
        }
        int v60 = DWORD1(v98);
        uint64_t v43 = v102;
        v102[5] = DWORD1(v98);
        int v45 = 1;
      }

      uint64_t v67 = *((void *)v43 + 3);
      if (v67)
      {
        int v68 = v43[3];
        if (v68)
        {
          if (v60 != v68 && (v60 || (*(_BYTE *)v43 & 4) == 0))
          {
            sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_longest_val (%u), given btn_btree.bt_fixed.bt_val_size (%u)\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v103[1]);
            uint64_t v20 = 92LL;
            sub_100044E7C((char *)0x1AD, 92);
            if (!sub_1000428C4( qword_10008DB70,  "Fix btree: bt_longest_val (%u)? ",  v69,  v70,  v71,  v72,  v73,  v74,  v102[5])) {
              goto LABEL_40;
            }
            uint64_t v43 = v102;
            v102[5] = v102[3];
            uint64_t v67 = *((void *)v43 + 3);
            int v45 = 1;
          }
        }
      }

      if (v67 == *((void *)&v98 + 1))
      {
        if (*((void *)v43 + 4) == (void)v99)
        {
          if (!v45) {
            goto LABEL_82;
          }
          goto LABEL_79;
        }
      }

      else
      {
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_key_count (expected %llu, actual %llu)\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v103[1]);
        uint64_t v20 = 92LL;
        sub_100044E7C((char *)0x1AE, 92);
        if (!sub_1000428C4( qword_10008DB70,  "Fix btree: bt_key_count (%llu)? ",  v75,  v76,  v77,  v78,  v79,  v80,  *((void *)v102 + 3))) {
          goto LABEL_40;
        }
        uint64_t v81 = v102;
        *((void *)v102 + 3) = *((void *)&v98 + 1);
        if (*((void *)v81 + 4) == (void)v99)
        {
LABEL_79:
          int v88 = *(uint64_t **)a1;
          uint64_t v89 = *(void *)(a1 + 8);
          __int128 v94 = *(_OWORD *)v104;
          uint64_t v95 = *(void *)&v104[16];
          uint64_t v90 = sub_100023FA8(v88, v89, (uint64_t)v103, (uint64_t)&v94, *(int8x16_t *)v104, v40);
          if ((_DWORD)v90)
          {
            uint64_t v20 = v90;
            uint64_t v24 = 434LL;
            int v32 = v20;
            goto LABEL_39;
          }

          sub_100044E2C();
LABEL_82:
          uint64_t v20 = 0LL;
          if (a5) {
            *a5 = *((void *)&v98 + 1);
          }
          goto LABEL_40;
        }
      }

      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_btree.bt_node_count (expected %llu, actual %llu)\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v103[1]);
      uint64_t v20 = 92LL;
      sub_100044E7C((char *)0x1AF, 92);
      if (sub_1000428C4( qword_10008DB70,  "Fix btree: bt_node_count (%llu)? ",  v82,  v83,  v84,  v85,  v86,  v87,  *((void *)v102 + 4)))
      {
        *((void *)v102 + 4) = v99;
        goto LABEL_79;
      }
    }

uint64_t sub_10003262C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7, uint64_t (*a8)(void, void, const void *, void, void *, void, uint64_t, int *), uint64_t a9, const void *a10, unsigned int a11, const void *a12, unsigned int a13, _WORD *a14, uint64_t a15, unsigned __int8 a16, char a17)
{
  uint64_t v18 = a14;
  unsigned __int16 v19 = a11;
  uint64_t v240 = a10;
  uint64_t v237 = 0LL;
  uint64_t v238 = 0LL;
  unsigned __int16 v236 = a11;
  __int16 v235 = -21846;
  int v234 = 0;
  int v232 = 0;
  if (*(_DWORD *)(a5 + 8) != *(_DWORD *)(a15 + 4))
  {
    sub_100040C68( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n warning: btn: invalid cpm_size or ov_size (%u), given btn_btree.bt_fixed.bt_node_size (%u)\n",  a2,  a3,  a4,  a5,  (uint64_t)a6,  a7,  (uint64_t)a8,  *(void *)(a4 + 8));
    uint64_t v26 = 92LL;
    uint64_t v39 = 401LL;
LABEL_18:
    int v40 = 92;
LABEL_19:
    sub_100044E7C((char *)v39, v40);
    goto LABEL_168;
  }

  unsigned __int16 v23 = *(_WORD *)(a4 + 32);
  if (((((v23 & 1) == 0) ^ a16) & 1) == 0)
  {
    uint64_t v24 = "not a root";
    if (a16) {
      uint64_t v24 = "a root";
    }
    unint64_t v215 = *(unsigned __int16 *)(a4 + 32);
    uint64_t v216 = v24;
    uint64_t v213 = (const char *)v215;
    uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
    if (a16) {
      int v25 = "Set";
    }
    else {
      int v25 = "Clear";
    }
    sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_flags (0x%x), given btree node is %s\n",  a2,  a3,  a4,  a5,  (uint64_t)a6,  a7,  (uint64_t)a8,  *(void *)(a4 + 8));
    uint64_t v26 = 92LL;
    sub_100044E7C((char *)0x192, 92);
    unsigned __int16 v23 = *(_WORD *)(a4 + 32) & 0xFFFE | a16;
    *(_WORD *)(a4 + 32) = v23;
    int v232 = 1;
  }

  uint64_t v223 = a1;
  int v33 = *(unsigned __int16 *)(a4 + 34);
  if ((*(_WORD *)(a4 + 34) == 0) == ((v23 & 2) == 0))
  {
    if ((v23 & 1) == 0
      || (uint64_t v34 = a4 + *(unsigned int *)(a5 + 8),
          uint64_t v35 = *(unsigned int *)(a4 + 36),
          uint64_t v36 = *(void *)(v34 - 16),
          (*(void *)(v34 - 8) != 1LL) == (v36 == v35)))
    {
      int v41 = (unsigned __int16)*a14;
      if (v41 == 0xFFFF || v33 != v41) {
        goto LABEL_37;
      }
      uint64_t v42 = "not a leaf";
      if (!*(_WORD *)(a4 + 34)) {
        uint64_t v42 = "a leaf";
      }
      unint64_t v215 = v23;
      uint64_t v216 = v42;
      uint64_t v213 = (const char *)v23;
      uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
      if (*(_WORD *)(a4 + 34)) {
        uint64_t v43 = "Clear";
      }
      else {
        uint64_t v43 = "Set";
      }
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_flags (0x%x), given btree node is %s\n",  a2,  a3,  a4,  a5,  (uint64_t)a6,  a7,  (uint64_t)a8,  *(void *)(a4 + 8));
      uint64_t v26 = 92LL;
      sub_100044E7C((char *)0x4AF, 92);
      if (!sub_1000428C4( qword_10008DB70,  "%s BTNODE_LEAF flag? ",  v44,  v45,  v46,  v47,  v48,  v49,  (char)v43)) {
        goto LABEL_168;
      }
      BOOL v50 = v33 == 0;
    }

    else
    {
      uint64_t v37 = *(void *)(a4 + 8);
      uint64_t v38 = "not a leaf";
      if (v36 == v35) {
        uint64_t v38 = "a leaf";
      }
      if ((v33 == 0) != (v36 == v35))
      {
        unint64_t v215 = *(unsigned __int16 *)(a4 + 34);
        uint64_t v216 = v38;
        uint64_t v213 = (const char *)v23;
        uint64_t v214 = (const char *)v215;
        sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_level (%u), given btree node is %s\n",  a2,  a3,  a4,  a5,  (uint64_t)a6,  a7,  (uint64_t)a8,  v37);
        sub_100044E7C((char *)0x4AE, 92);
        goto LABEL_37;
      }

      unint64_t v215 = v23;
      uint64_t v216 = v38;
      uint64_t v213 = (const char *)v23;
      uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
      sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_flags (0x%x), given btree node is %s\n",  a2,  a3,  a4,  a5,  (uint64_t)a6,  a7,  (uint64_t)a8,  v37);
      uint64_t v26 = 92LL;
      sub_100044E7C((char *)0x4AD, 92);
      uint64_t v57 = "Clear";
      if (v36 == v35) {
        uint64_t v57 = "Set";
      }
      if (!sub_1000428C4( qword_10008DB70,  "%s BTNODE_LEAF flag? ",  v51,  v52,  v53,  v54,  v55,  v56,  (char)v57)) {
        goto LABEL_168;
      }
      BOOL v50 = v36 == v35;
    }

    __int16 v58 = v50;
    *(_WORD *)(a4 + 32) = *(_WORD *)(a4 + 32) & 0xFFFD | (2 * v58);
    int v232 = 1;
  }

LABEL_37:
  uint64_t v239 = (void *)0xAAAAAAAAAAAAAAAALL;
  int v233 = -1431655766;
  uint64_t v59 = sub_100030D18(a4, a15, 1LL, &v232, a5, (uint64_t)a6, a7, (uint64_t)a8);
  int v68 = *(unsigned __int16 *)(a4 + 32);
  if ((_DWORD)v59)
  {
    unsigned int v69 = v59;
    *(_WORD *)(a4 + 32) = v68 ^ 2;
    int v70 = sub_100030D18(a4, a15, 0LL, &v232, v63, v64, v65, v66);
    int v78 = *(unsigned __int16 *)(a4 + 32);
    *(_WORD *)(a4 + 32) = v78 ^ 2;
    if (v70) {
      goto LABEL_39;
    }
    uint64_t v79 = "a leaf";
    if ((v78 & 2) == 0) {
      uint64_t v79 = "not a leaf";
    }
    unint64_t v215 = v78 ^ 2u;
    uint64_t v216 = v79;
    uint64_t v213 = (const char *)v215;
    uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
    uint64_t v80 = (v78 & 2) != 0 ? "Set" : "Clear";
    sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_flags (0x%x), given btree node is %s\n",  v71,  v72,  v73,  v74,  v75,  v76,  v77,  *(void *)(a4 + 8));
    sub_100044E7C((char *)0x480, 92);
    uint64_t v59 = sub_1000428C4(qword_10008DB70, "%s BTNODE_LEAF flags? ", v81, v82, v83, v84, v85, v86, (char)v80);
    if (!(_DWORD)v59)
    {
LABEL_39:
      uint64_t v26 = sub_100008B08( v223,  a15,  *(void *)(a4 + 8),  *(void *)(a4 + 16),  *(unsigned __int16 *)(a4 + 34),  a10,  a11,  a12,  a13,  v69);
      goto LABEL_168;
    }

    int v87 = *(unsigned __int16 *)(a4 + 32);
    int v68 = v87 ^ 2;
    *(_WORD *)(a4 + 32) = v87 ^ 2;
    if ((v78 & 2) != 0) {
      *(_WORD *)(a4 + 34) = 0;
    }
    int v232 = 1;
  }

  uint64_t v219 = a5;
  if ((v68 & 2) != 0 && sub_10001A8D0(v59, v60, v61, v62, v63, v64, v65, v66))
  {
    sub_100040B90( "fsck_apfs is out of memory - some cross checks are skipped\n",  v60,  v61,  v88,  v63,  v64,  v65,  v66,  v210);
    sub_100044E7C((char *)0x585, 12);
  }

  if (!*(_DWORD *)(v223 + 52)
    || (uint64_t v26 = sub_1000473D0(a15, a4, a6, *(unsigned int *)(v223 + 24), v63, v64, v65, v66), !(_DWORD)v26))
  {
    unsigned __int16 v89 = 0;
    uint64_t v90 = 0LL;
    char v91 = 0LL;
    char v225 = v68;
    int v218 = (v68 << 25) & 0x20000000;
    unsigned int v224 = (unsigned __int16)a13;
    unsigned int v92 = *(_DWORD *)(a4 + 36);
    uint64_t v93 = v223;
    __int128 v94 = a10;
    while (1)
    {
      unsigned __int16 v95 = v19;
      uint64_t v96 = (uint64_t)v94;
      if (v92 <= v91)
      {
        __int128 v94 = a12;
        uint64_t v237 = 0LL;
        uint64_t v238 = a12;
        HIWORD(v234) = a13;
        if (!v96) {
          goto LABEL_128;
        }
      }

      else
      {
        sub_100030B3C(a4, a15, v91, (uint64_t *)&v238, (_WORD *)&v234 + 1, (uint64_t *)&v237, &v234);
        __int128 v94 = v238;
        if (!v96) {
          goto LABEL_128;
        }
      }

      if (v94)
      {
        uint64_t v97 = *(void *)(v93 + 8);
        if (v97) {
          uint64_t v98 = *(void *)(v97 + 40);
        }
        else {
          uint64_t v98 = 0LL;
        }
        unsigned __int16 v226 = v19;
        unsigned int v99 = HIWORD(v234);
        unsigned int v221 = v95;
        uint64_t v229 = (uint64_t)v94;
        uint64_t v100 = (*(uint64_t (**)(uint64_t, uint64_t))(v93 + 16))(v98, v96);
        if ((_DWORD)v100 == 45)
        {
          unint64_t v215 = ((_DWORD)v91 - 1);
          uint64_t v216 = v91;
          uint64_t v213 = (const char *)*(unsigned __int16 *)(a4 + 32);
          uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
          sub_100040C68( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n warning: btn: can't compare key (%u) with key (%u)\n",  v60,  v61,  v101,  v63,  v64,  v65,  v66,  *(void *)(a4 + 8));
          sub_100044E7C((char *)0x55F, -5);
          if ((_DWORD)v91) {
            int v102 = -1;
          }
          else {
            int v102 = 0;
          }
          int v233 = v102;
        }

        else
        {
          uint64_t v26 = v100;
          if ((_DWORD)v100)
          {
            sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: key (%u) compare error: %d\n",  v60,  v61,  v101,  v63,  v64,  v65,  v66,  *(void *)(a4 + 8));
            uint64_t v194 = 403LL;
            goto LABEL_165;
          }

          int v102 = v233;
        }

        unsigned __int16 v95 = v226;
        if (!(_DWORD)v91 && v102)
        {
          BOOL v103 = v102 < 0;
          int v104 = "greater than";
          if (v103) {
            int v104 = "less than";
          }
          uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
          unint64_t v215 = (unint64_t)v104;
          uint64_t v213 = (const char *)*(unsigned __int16 *)(a4 + 32);
          sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid key order: minkey is %s index 0 (should be equal)\n",  v60,  v61,  v101,  v63,  v64,  v65,  v66,  *(void *)(a4 + 8));
          uint64_t v105 = 1117LL;
          goto LABEL_82;
        }

        __int128 v94 = (const void *)v229;
        if ((_DWORD)v91)
        {
          if ((v102 & 0x80000000) == 0)
          {
            uint64_t v106 = *(void *)(a4 + 8);
            BOOL v50 = v102 == 0;
            uint64_t v107 = "greater than";
            if (v50) {
              uint64_t v107 = "equal to";
            }
            if ((_DWORD)v91 == *(_DWORD *)(a4 + 36))
            {
              unint64_t v215 = ((_DWORD)v91 - 1);
              uint64_t v216 = v107;
              uint64_t v213 = (const char *)*(unsigned __int16 *)(a4 + 32);
              uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
              sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid key order: index %u is %s maxkey (should be less than)\n",  v60,  v61,  v229,  v63,  v64,  v65,  v66,  v106);
              uint64_t v105 = 1118LL;
            }

            else
            {
              uint64_t v216 = v107;
              uint64_t v217 = v91;
              uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
              unint64_t v215 = ((_DWORD)v91 - 1);
              uint64_t v213 = (const char *)*(unsigned __int16 *)(a4 + 32);
              sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid key order: index %u is %s index %u (should be less than)\n",  v60,  v61,  v229,  v63,  v64,  v65,  v66,  v106);
              uint64_t v105 = 404LL;
            }

LABEL_82:
            sub_100044E7C((char *)v105, 92);
            unsigned int v108 = v226;
            if (v226 <= v99) {
              unsigned int v108 = v99;
            }
            size_t v109 = 3 * v108 + 1;
            uint64_t v110 = (char *)malloc(v109);
            *(void *)&__int128 v118 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v118 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)__str = v118;
            __int128 v255 = v118;
            if (v110)
            {
              uint64_t v119 = v110;
              if ((_DWORD)v91 && v90)
              {
                sub_100033678(__str, (_DWORD)v91 - 1, *(_DWORD *)(a4 + 36));
                sub_100033700(v119, v109, v90, v89);
                sub_10004096C("\t%-14s: %s\n", v120, v121, v122, v123, v124, v125, v126, (char)__str);
              }

              sub_100033678(__str, v91, *(_DWORD *)(a4 + 36));
              sub_100033700(v119, v109, v96, v221);
              sub_10004096C("\t%-14s: %s\n", v127, v128, v129, v130, v131, v132, v133, (char)__str);
              sub_100033678(__str, (_DWORD)v91 + 1, *(_DWORD *)(a4 + 36));
              sub_100033700(v119, v109, v229, v99);
              sub_10004096C("\t%-14s: %s\n", v134, v135, v136, v137, v138, v139, v140, (char)__str);
              unsigned int v141 = *(_DWORD *)(a4 + 36);
              if (v91 < v141)
              {
                *(void *)int v243 = 0xAAAAAAAAAAAAAAAALL;
                LOWORD(v241) = -21846;
                unsigned int v142 = (unsigned __int16)a13;
                uint64_t v143 = (uint64_t)a12;
                if (v141 > (int)v91 + 1)
                {
                  sub_100030B3C(a4, a15, (_DWORD)v91 + 1, (uint64_t *)v243, &v241, 0LL, 0LL);
                  unsigned int v141 = *(_DWORD *)(a4 + 36);
                  uint64_t v143 = *(void *)v243;
                  unsigned int v142 = (unsigned __int16)v241;
                }

                sub_100033678(__str, (_DWORD)v91 + 2, v141);
                sub_100033700(v119, v109, v143, v142);
                sub_10004096C("\t%-14s: %s\n", v144, v145, v146, v147, v148, v149, v150, (char)__str);
              }

              free(v119);
            }

            uint64_t v26 = 92LL;
            if ((_DWORD)v91 || (v233 & 0x80000000) == 0) {
              goto LABEL_167;
            }
            sub_10004096C( "Checking if the parent's minkey can be updated...\n",  v111,  v112,  v113,  v114,  v115,  v116,  v117,  v211);
            uint64_t v93 = v223;
            *(_OWORD *)uint64_t v230 = *(_OWORD *)a3;
            uint64_t v231 = *(void *)(a3 + 16);
            uint64_t v252 = (void *)0xAAAAAAAAAAAAAAAALL;
            if (!*(_DWORD *)(a2 + 36)) {
              goto LABEL_104;
            }
            unsigned int v151 = 0;
            do
            {
              sub_100030B3C(a2, a15, v151, &v253, &v249, (uint64_t *)&v252, &v248);
              uint64_t v152 = *(_DWORD *)(a15 + 40) ? *(void *)(a15 + 64) : 0LL;
              if (v152 + *v252 == *a6) {
                break;
              }
              ++v151;
            }

            while (v151 < *(_DWORD *)(a2 + 36));
            if (!v151)
            {
LABEL_104:
              unsigned int v151 = 0;
              if ((*(_WORD *)(a2 + 32) & 1) == 0) {
                *(_BYTE *)(a15 + 75) = 1;
              }
            }

            uint64_t v250 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v251 = (const void *)0xAAAAAAAAAAAAAAAALL;
            unsigned __int16 v247 = -21846;
            __int16 v246 = -21846;
            sub_100030B3C(a4, a15, 0, (uint64_t *)&v251, &v247, 0LL, 0LL);
            uint64_t v157 = v151 + 1;
            if (*(_DWORD *)(a2 + 36) <= v157)
            {
              uint64_t v158 = (uint64_t)a12;
              uint64_t v250 = (uint64_t)a12;
              __int16 v246 = a13;
            }

            else
            {
              sub_100030B3C(a2, a15, v157, &v250, &v246, 0LL, 0LL);
              uint64_t v158 = v250;
            }

            int v245 = -1431655766;
            if (v158)
            {
              uint64_t v159 = *(void *)(v223 + 8);
              uint64_t v160 = v159 ? *(void *)(v159 + 40) : 0LL;
              LODWORD(v26) = (*(uint64_t (**)(uint64_t, const void *, void))(v223 + 16))(v160, v251, v247);
              if ((_DWORD)v26 || (v245 & 0x80000000) == 0)
              {
                sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: unable to repair minkey\n",  v161,  v157,  v162,  v153,  v154,  v155,  v156,  *(void *)(a2 + 8));
                if ((_DWORD)v26) {
                  uint64_t v26 = v26;
                }
                else {
                  uint64_t v26 = 92LL;
                }
                uint64_t v194 = 1114LL;
LABEL_165:
                int v195 = v26;
LABEL_166:
                sub_100044E7C((char *)v194, v195);
LABEL_167:
                uint64_t v18 = a14;
                break;
              }
            }

            if (*(_DWORD *)(a4 + 36) < 2u)
            {
              __int16 v246 = a13;
              uint64_t v163 = (uint64_t)a12;
              if (!a12)
              {
LABEL_124:
                if (!sub_1000428C4( qword_10008DB70,  "Update the parent's minkey? ",  v157,  v163,  v153,  v154,  v155,  v156,  v212))
                {
                  uint64_t v26 = 92LL;
                  goto LABEL_167;
                }

                *(_OWORD *)int v243 = *(_OWORD *)a15;
                int v167 = *(_DWORD *)(v223 + 36);
                uint64_t v168 = *(void *)(v223 + 56);
                *(_DWORD *)&v243[20] = -1431655766;
                uint64_t v244 = v168;
                *(_DWORD *)&v243[16] = v167;
                if (!sub_10003584C((uint64_t)v243, (unsigned __int16 *)a2, v151, v251, v247, 0LL, 0))
                {
                  sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: parent doesn't have enough space to update the minkey\n",  v169,  v170,  v171,  v172,  v173,  v174,  v175,  *(void *)(a2 + 8));
                  uint64_t v26 = 92LL;
                  uint64_t v194 = 1116LL;
                  int v195 = 92;
                  goto LABEL_166;
                }

                __int128 v177 = *(uint64_t **)v223;
                uint64_t v178 = *(void *)(v223 + 8);
                __int128 v241 = *(_OWORD *)v230;
                uint64_t v242 = v231;
                uint64_t v179 = sub_100023FA8(v177, v178, a2, (uint64_t)&v241, *(int8x16_t *)v230, v176);
                if ((_DWORD)v179) {
                  goto LABEL_142;
                }
                sub_100044E2C();
                __int128 v94 = (const void *)v229;
                unsigned __int16 v95 = v226;
                goto LABEL_128;
              }
            }

            else
            {
              sub_100030B3C(a4, a15, 1u, &v250, &v246, 0LL, 0LL);
              uint64_t v163 = v250;
              if (!v250) {
                goto LABEL_124;
              }
            }

            uint64_t v164 = *(void *)(v223 + 8);
            if (v164) {
              uint64_t v165 = *(void *)(v164 + 40);
            }
            else {
              uint64_t v165 = 0LL;
            }
            LODWORD(v26) = (*(uint64_t (**)(uint64_t, const void *, void))(v223 + 16))(v165, v251, v247);
            if ((_DWORD)v26 || (v245 & 0x80000000) == 0)
            {
              sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: unable to repair minkey\n",  v166,  v157,  v163,  v153,  v154,  v155,  v156,  *(void *)(a2 + 8));
              if ((_DWORD)v26) {
                uint64_t v26 = v26;
              }
              else {
                uint64_t v26 = 92LL;
              }
              uint64_t v194 = 1115LL;
              goto LABEL_165;
            }

            goto LABEL_124;
          }
        }
      }

LABEL_128:
      unsigned int v92 = *(_DWORD *)(a4 + 36);
      if ((v225 & 2) != 0 && a8 && v91 < v92)
      {
        unsigned __int16 v19 = HIWORD(v234);
        if (!*(_BYTE *)(a15 + 74))
        {
          __int128 v180 = v94;
          uint64_t v179 = a8(*(void *)v93, *(void *)(v93 + 8), v94, HIWORD(v234), v237, (unsigned __int16)v234, a9, &v232);
          if ((_DWORD)v179)
          {
LABEL_142:
            uint64_t v26 = v179;
            goto LABEL_167;
          }

          unsigned int v92 = *(_DWORD *)(a4 + 36);
          __int128 v94 = v180;
        }
      }

      else
      {
        unsigned __int16 v19 = HIWORD(v234);
      }

      uint64_t v239 = v237;
      char v91 = (const char *)((_DWORD)v91 + 1);
      unsigned __int16 v89 = v95;
      uint64_t v90 = v96;
      if (v91 > v92)
      {
        uint64_t v240 = v94;
        unsigned __int16 v236 = v19;
        if ((v225 & 2) != 0 || !v92)
        {
          uint64_t v181 = v219;
          uint64_t v18 = a14;
          if ((v225 & 2) != 0) {
            *a14 = 0;
          }
          goto LABEL_145;
        }

        uint64_t v181 = v219;
        uint64_t v18 = a14;
        memset(v243, 170, sizeof(v243));
        v230[0] = 0LL;
        sub_100030B3C(a4, a15, 0, (uint64_t *)&v240, &v236, (uint64_t *)&v239, &v235);
        uint64_t v182 = *(_DWORD *)(a15 + 40) ? *(void *)(a15 + 64) : 0LL;
        uint64_t v197 = v182 + *v239;
        unsigned int v198 = sub_100022BD0( *(uint64_t **)v93,  *(void *)(v93 + 8),  *(_DWORD *)(v93 + 40),  v197,  a7,  v218,  3,  *(_DWORD *)(v93 + 48),  (uint64_t **)v230,  (uint64_t)v243,  a17);
        if (!v198) {
          goto LABEL_194;
        }
        unsigned int v199 = v198;
        __int128 v200 = a12;
        if (*(_DWORD *)(a4 + 36) >= 2u)
        {
          sub_100030B3C(a4, a15, 1u, (uint64_t *)&v238, (_WORD *)&v234 + 1, 0LL, 0LL);
          __int128 v200 = v238;
          unsigned int v224 = HIWORD(v234);
        }

        uint64_t v26 = sub_100008B08( v93,  a15,  v197,  *(void *)(a4 + 16),  (unsigned __int16)(*(_WORD *)(a4 + 34) - 1),  v240,  v236,  v200,  v224,  v199);
        if (!(_DWORD)v26)
        {
LABEL_194:
          if (*(unsigned __int16 *)(a4 + 34) > 1u)
          {
            __int128 v201 = sub_100033808;
            goto LABEL_190;
          }

          *(_DWORD *)__str = -1431655766;
          uint64_t v202 = sub_10002C080(**(void **)v93);
          if ((_DWORD)v202)
          {
            uint64_t v26 = v202;
            free(v230[0]);
            break;
          }

          __int128 v201 = *(_DWORD *)__str
               ? (uint64_t (*)(uint64_t, uint64_t, __int128 *, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, const void *, unsigned __int16, _WORD *, uint64_t, char))sub_100033B88
               : (uint64_t (*)(uint64_t, uint64_t, __int128 *, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, const void *, unsigned __int16, _WORD *, uint64_t, char))sub_100034008;
LABEL_190:
          *(_OWORD *)__str = *(_OWORD *)v219;
          *(void *)&__int128 v255 = *(void *)(v219 + 16);
          __int128 v241 = *(_OWORD *)v243;
          uint64_t v242 = *(void *)&v243[16];
          LOBYTE(v213) = a17;
          uint64_t v26 = ((uint64_t (*)(uint64_t, uint64_t, char *, void *, __int128 *, uint64_t, uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *), uint64_t, const void *, unsigned int, _WORD *, uint64_t, const char *, const char *, unint64_t, const char *, const char *))v201)( v93,  a4,  __str,  v230[0],  &v241,  a7,  a8,  a9,  a12,  a13,  a14,  a15,  v213,  v214,  v215,  v216,  v217);
          if (!(_DWORD)v26)
          {
LABEL_145:
            if (*(_BYTE *)(a15 + 74) || *(_BYTE *)(a15 + 73)) {
              goto LABEL_147;
            }
            int v203 = *(unsigned __int16 *)(a4 + 34);
            if (v203 != (unsigned __int16)*v18)
            {
              sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_level (expected %u, actual %u)\n",  v60,  v61,  (uint64_t)v94,  v63,  v64,  v65,  v66,  *(void *)(a4 + 8));
              uint64_t v26 = 92LL;
              sub_100044E7C((char *)0x197, 92);
              if (!sub_1000428C4( qword_10008DB70,  "Fix btn_level (%u)? ",  v204,  v205,  v206,  v207,  v208,  v209,  *(_WORD *)(a4 + 34))) {
                break;
              }
              int v203 = (unsigned __int16)*v18;
              *(_WORD *)(a4 + 34) = v203;
              int v232 = 1;
            }

            if ((v225 & 2) != 0)
            {
              if (v203) {
                goto LABEL_186;
              }
            }

            else if (!v203)
            {
LABEL_186:
              sub_100040B90( "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\n error: btn: invalid btn_flags (0x%x), given btn_level (%u)\n",  v60,  v61,  (uint64_t)v94,  v63,  v64,  v65,  v66,  *(void *)(a4 + 8));
              uint64_t v26 = 92LL;
              uint64_t v39 = 408LL;
              goto LABEL_18;
            }

LABEL_147:
            if (!*(_DWORD *)(v93 + 40))
            {
              int v183 = sub_10001CE20(1, *a6, 1);
              if (v183)
              {
                int v191 = v183;
                sub_100040C68( "object (oid 0x%llx): Unable to mark omap entry in use for omap space verification \n",  v184,  v185,  v186,  v187,  v188,  v189,  v190,  *a6);
                sub_100044E7C((char *)0x3F4, v191);
              }
            }

            if (v232)
            {
              __int128 v192 = *(uint64_t **)v93;
              uint64_t v193 = *(void *)(v93 + 8);
              *(_OWORD *)int v243 = *(_OWORD *)v181;
              *(void *)&v243[16] = *(void *)(v181 + 16);
              uint64_t v26 = sub_100023FA8(v192, v193, a4, (uint64_t)v243, *(int8x16_t *)v243, v67);
              if ((_DWORD)v26)
              {
                uint64_t v39 = 409LL;
                int v40 = v26;
                goto LABEL_19;
              }

              sub_100044E2C();
            }

            else
            {
              uint64_t v26 = 0LL;
            }
          }
        }

        break;
      }
    }
  }

LABEL_168:
  ++*v18;
  return v26;
}

char *sub_100033678(char *__str, unsigned int a2, int a3)
{
  if (!a2)
  {
    *(_DWORD *)(__str + 3) = 7955819;
    int v4 = 1802398061;
LABEL_6:
    *(_DWORD *)__str = v4;
    return __str;
  }

  if (a3 + 1 <= a2)
  {
    *(_DWORD *)(__str + 3) = 7955819;
    int v4 = 1803051373;
    goto LABEL_6;
  }

  snprintf(__str, 0x20uLL, "index %u key", a2 - 1);
  return __str;
}

char *sub_100033700(char *__s, size_t __size, uint64_t a3, unsigned int a4)
{
  unsigned int v5 = __size;
  if (a4 == 4)
  {
    snprintf(__s, __size, "0x%08x");
  }

  else if (a4 == 8)
  {
    snprintf(__s, __size, "0x%016llx");
  }

  else
  {
    BOOL v7 = a4 != 0;
    if (a4 && (_DWORD)__size)
    {
      unint64_t v8 = 0LL;
      unint64_t v9 = 0LL;
      unint64_t v10 = __size;
      unint64_t v11 = a4;
      do
      {
        snprintf(&__s[v9], v5, "%02x ", *(unsigned __int8 *)(a3 + v8++));
        BOOL v7 = v8 < v11;
        if (v8 >= v11) {
          break;
        }
        v9 += 3LL;
        v5 -= 3;
      }

      while (v9 < v10);
    }

    if (v7) {
      __s[strlen(__s) - 1] = 43;
    }
  }

  return __s;
}

uint64_t sub_100033808( uint64_t a1, uint64_t a2, __int128 *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, unsigned __int16 a10, _WORD *a11, uint64_t a12, char a13)
{
  uint64_t v13 = a4;
  uint64_t v51 = (const void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v52 = a4;
  uint64_t v49 = 0LL;
  BOOL v50 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v48 = 0LL;
  unsigned __int16 v47 = -21846;
  __int16 v46 = -21846;
  unsigned __int16 v45 = 0;
  __int16 v44 = 0;
  __int16 v16 = *(_WORD *)(a2 + 32);
  *(void *)&__int128 v17 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v54[3] = v17;
  _OWORD v54[2] = v17;
  v54[1] = v17;
  v54[0] = v17;
  sub_100030B3C(a2, a12, 0, (uint64_t *)&v51, &v47, (uint64_t *)&v50, &v46);
  uint64_t v18 = v50;
  uint64_t v19 = *v50;
  uint64_t v53 = *v50;
  if (*(_DWORD *)(a12 + 40))
  {
    uint64_t v53 = *(void *)(a12 + 64) + v19;
    __memcpy_chk(v54, v50 + 1, *(unsigned int *)(a12 + 44), 64LL);
  }

  uint64_t v20 = v51;
  unsigned int v21 = v47;
  __int16 v22 = v46;
  unsigned int v23 = *(_DWORD *)(a2 + 36);
  if (!v23)
  {
LABEL_22:
    uint64_t v31 = 0LL;
    goto LABEL_23;
  }

  int v24 = 0;
  int v37 = (v16 & 0x10) << 25;
  int v25 = v13;
  while (1)
  {
    *a11 = *(_WORD *)(a2 + 34) - 1;
    unsigned int v26 = v24 + 1;
    if (v23 <= v24 + 1)
    {
      uint64_t v48 = 0LL;
      uint64_t v49 = a9;
      unsigned __int16 v45 = a10;
      if (!v24) {
        goto LABEL_17;
      }
    }

    else
    {
      sub_100030B3C(a2, a12, v24 + 1, (uint64_t *)&v49, &v45, (uint64_t *)&v48, &v44);
      if (!v24) {
        goto LABEL_17;
      }
    }

    uint64_t v27 = *v18;
    uint64_t v53 = *v18;
    if (*(_DWORD *)(a12 + 40))
    {
      v27 += *(void *)(a12 + 64);
      uint64_t v53 = v27;
      __memcpy_chk(v54, v18 + 1, *(unsigned int *)(a12 + 44), 64LL);
    }

    unsigned int v28 = sub_100022BD0( *(uint64_t **)a1,  *(void *)(a1 + 8),  *(_DWORD *)(a1 + 40),  v27,  a6,  v37,  3,  *(_DWORD *)(a1 + 48),  &v52,  a5,  a13);
    if (!v28)
    {
      uint64_t v13 = v52;
      int v25 = v52;
LABEL_17:
      if (v25)
      {
        __int128 v42 = *a3;
        uint64_t v43 = *((void *)a3 + 2);
        __int128 v40 = *(_OWORD *)a5;
        uint64_t v41 = *(void *)(a5 + 16);
        BYTE1(v33) = a13;
        LOBYTE(v33) = 0;
        uint64_t v31 = sub_10003262C(a1, a2, &v42, v25, &v40, &v53, a6, a7, a8, v20, v21, v49, v45, a11, a12, v33);
        free(v52);
        uint64_t v52 = 0LL;
        if ((_DWORD)v31) {
          return v31;
        }
        uint64_t v13 = 0LL;
        uint64_t v20 = v49;
      }

      else
      {
        uint64_t v20 = v49;
      }

      goto LABEL_21;
    }

    uint64_t v29 = v49;
    uint64_t v30 = sub_100008B08( a1,  a12,  v53,  *(void *)(a2 + 16),  (unsigned __int16)(*(_WORD *)(a2 + 34) - 1),  v20,  v21,  v49,  v45,  v28);
    uint64_t v13 = v52;
    if ((_DWORD)v30) {
      break;
    }
    if (v52) {
      free(v52);
    }
    uint64_t v13 = 0LL;
    uint64_t v52 = 0LL;
    uint64_t v20 = v29;
LABEL_21:
    int v25 = 0LL;
    unsigned int v21 = v45;
    uint64_t v18 = v48;
    BOOL v50 = v48;
    __int16 v22 = v44;
    unsigned int v23 = *(_DWORD *)(a2 + 36);
    ++v24;
    if (v26 >= v23) {
      goto LABEL_22;
    }
  }

  uint64_t v31 = v30;
LABEL_23:
  uint64_t v51 = v20;
  unsigned __int16 v47 = v21;
  __int16 v46 = v22;
  if (v13) {
    free(v13);
  }
  return v31;
}

uint64_t sub_100033B88( uint64_t a1, uint64_t a2, __int128 *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, unsigned __int16 a10, _WORD *a11, uint64_t a12, char a13)
{
  BOOL v50 = (const void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v51 = a4;
  uint64_t v48 = 0LL;
  uint64_t v49 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  unsigned __int16 v47 = -21846;
  __int16 v46 = -21846;
  unsigned __int16 v45 = 0;
  __int16 v15 = *(_WORD *)(a2 + 32);
  *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v58[56] = v16;
  *(_OWORD *)&v58[40] = v16;
  *(_OWORD *)&v58[24] = v16;
  *(_OWORD *)&v58[8] = v16;
  uint64_t v57 = 0LL;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  memset(v52, 0, sizeof(v52));
  __int16 v44 = -21846;
  sub_100030B3C(a2, a12, 0, (uint64_t *)&v50, &v47, (uint64_t *)&v49, &v46);
  uint64_t v17 = *v49;
  *(void *)__int16 v58 = *v49;
  if (*(_DWORD *)(a12 + 40))
  {
    *(void *)__int16 v58 = *(void *)(a12 + 64) + v17;
    __memcpy_chk(&v58[8], v49 + 1, *(unsigned int *)(a12 + 44), 64LL);
  }

  unsigned int v18 = *(_DWORD *)(a2 + 36);
  if (!v18)
  {
LABEL_26:
    uint64_t v31 = 0LL;
    goto LABEL_28;
  }

  unsigned int v19 = 0;
  int v37 = (v15 & 0x10) << 25;
  unsigned int v20 = v47;
  unsigned int v21 = v50;
  while (1)
  {
    *a11 = *(_WORD *)(a2 + 34) - 1;
    unsigned int v22 = v19 + 1;
    if (v18 <= v19 + 1)
    {
      uint64_t v48 = a9;
      uint64_t v49 = 0LL;
      unsigned __int16 v45 = a10;
    }

    else
    {
      sub_100030B3C(a2, a12, v19 + 1, (uint64_t *)&v48, &v45, (uint64_t *)&v49, &v46);
      unsigned int v18 = *(_DWORD *)(a2 + 36);
    }

    if (v19 < v18 - 1)
    {
      uint64_t v23 = *v49;
      *(void *)&__int128 v53 = *v49;
      if (*(_DWORD *)(a12 + 40))
      {
        v23 += *(void *)(a12 + 64);
        *(void *)&__int128 v53 = v23;
        __memcpy_chk((char *)&v53 + 8, v49 + 1, *(unsigned int *)(a12 + 44), 64LL);
      }

      *((_BYTE *)&v44 + (v19 & 1)) = 1;
      unsigned int v24 = sub_100023F40( *(uint64_t **)a1,  *(void *)(a1 + 8),  *(_DWORD *)(a1 + 40),  v23,  a6,  v37,  3,  *(_DWORD *)(a1 + 48),  (uint64_t)&v52[11 * (v19 & 1)]);
      if (v24) {
        break;
      }
    }

LABEL_16:
    if (v19
      && *((_BYTE *)&v44 + !(v19 & 1))
      && (unsigned int v29 = sub_100023F78( *(uint64_t **)a1,  *(void *)(a1 + 8),  *(_DWORD *)(a1 + 40),  *(uint64_t *)v58,  a6,  v37,  3,  *(_DWORD *)(a1 + 48),  (uint64_t)&v52[11 * !(v19 & 1)],  (uint64_t **)&v51,  a5,  a13)) != 0)
    {
      uint64_t v30 = v48;
      uint64_t v28 = sub_100008B08( a1,  a12,  *(uint64_t *)v58,  *(void *)(a2 + 16),  (unsigned __int16)(*(_WORD *)(a2 + 34) - 1),  v21,  v20,  v48,  v45,  v29);
      if ((_DWORD)v28) {
        goto LABEL_27;
      }
      if (v51) {
        free(v51);
      }
      uint64_t v51 = 0LL;
    }

    else
    {
      uint64_t v30 = v48;
      if (v51)
      {
        __int128 v42 = *a3;
        uint64_t v43 = *((void *)a3 + 2);
        __int128 v40 = *(_OWORD *)a5;
        uint64_t v41 = *(void *)(a5 + 16);
        BYTE1(v33) = a13;
        LOBYTE(v33) = 0;
        uint64_t v31 = sub_10003262C(a1, a2, &v42, v51, &v40, v58, a6, a7, a8, v21, v20, v48, v45, a11, a12, v33);
        free(v51);
        uint64_t v51 = 0LL;
        if ((_DWORD)v31) {
          return v31;
        }
      }
    }

    unsigned int v20 = v45;
    *(_OWORD *)&v58[32] = v55;
    *(_OWORD *)&v58[48] = v56;
    *(void *)&v58[64] = v57;
    *(_OWORD *)__int16 v58 = v53;
    *(_OWORD *)&v58[16] = v54;
    ++v19;
    unsigned int v21 = v30;
    unsigned int v18 = *(_DWORD *)(a2 + 36);
    if (v22 >= v18) {
      goto LABEL_26;
    }
  }

  unsigned int v25 = v24;
  *(void *)&__int128 v42 = 0xAAAAAAAAAAAAAAAALL;
  LOWORD(v40) = -21846;
  unsigned int v26 = a10;
  uint64_t v27 = a9;
  if (*(_DWORD *)(a2 + 36) > v19 + 2)
  {
    sub_100030B3C(a2, a12, v19 + 2, (uint64_t *)&v42, &v40, 0LL, 0LL);
    uint64_t v27 = (const void *)v42;
    unsigned int v26 = (unsigned __int16)v40;
  }

  uint64_t v28 = sub_100008B08( a1,  a12,  v53,  *(void *)(a2 + 16),  (unsigned __int16)(*(_WORD *)(a2 + 34) - 1),  v48,  v45,  v27,  v26,  v25);
  if (!(_DWORD)v28)
  {
    *((_BYTE *)&v44 + (v19 & 1)) = 0;
    goto LABEL_16;
  }

    ++v2;
    v3 += 16;
    if (v2 == 3)
    {
      uint64_t v14 = 0LL;
      byte_10008CA01 = 0;
      return v14;
    }
  }

  unint64_t v8 = v51;
  *(void *)&unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v58[2] = v9;
  v58[3] = v9;
  v58[0] = v9;
  v58[1] = v9;
  v57[3] = v9;
  v57[4] = v9;
  v57[1] = v9;
  v57[2] = v9;
  v56[4] = v9;
  v57[0] = v9;
  v56[2] = v9;
  v56[3] = v9;
  v56[0] = v9;
  v56[1] = v9;
  void v55[3] = v9;
  v55[4] = v9;
  v55[1] = v9;
  v55[2] = v9;
  v55[0] = v9;
  if (!sub_100034B44( (uint64_t)v58,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  16,  8,  0,  0LL,  (uint64_t)sub_10003C1E4)) {
    sub_100036C00((uint64_t)v58, 0LL, 0);
  }
  unint64_t v10 = sub_100035838((uint64_t)v57, v8, 0LL, 0LL, 0);
  if ((_DWORD)v10
    || (unint64_t v10 = sub_10002930C( (uint64_t)v57,  (uint64_t (*)(void, void, void, void, uint64_t))sub_10003FD54,  (uint64_t)v58,  0),  (_DWORD)v10))
  {
    uint64_t v14 = v10;
    uint64_t v23 = strerror(v10);
    sub_100040B90( "error copying on-disk free queue tree into reordered tree in memory: %s\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v23);
    uint64_t v31 = 923LL;
    goto LABEL_27;
  }

  uint64_t v52 = v4;
  __int128 v54 = -1431655766;
  __int128 v53 = v2;
  unint64_t v11 = sub_100035838((uint64_t)v56, (uint64_t)v58, 0LL, 0LL, 0);
  if ((_DWORD)v11)
  {
    uint64_t v14 = v11;
LABEL_25:
    uint64_t v32 = strerror(v14);
    sub_100040B90("unable to init iterators for free queue tree repair: %s\n", v33, v34, v35, v36, v37, v38, v39, v32);
    uint64_t v31 = 924LL;
    goto LABEL_27;
  }

  uint64_t v12 = sub_100035838((uint64_t)v55, (uint64_t)v3, 0LL, 0LL, 0);
  if ((_DWORD)v12)
  {
    uint64_t v14 = v12;
    if (*(void *)&v56[0]) {
      (*(void (**)(_OWORD *))&v56[0])(v56);
    }
    goto LABEL_25;
  }

  uint64_t v13 = sub_1000293A8( (uint64_t)v56,  (uint64_t)v55,  (uint64_t (*)(__int128 *, __int128 *, int *, uint64_t))sub_10003FDB8,  (uint64_t)&v52);
  if (!(_DWORD)v13)
  {
    sub_100036CD8((uint64_t)v58, 0LL);
    goto LABEL_16;
  }

  uint64_t v14 = v13;
  __int128 v40 = strerror(v13);
  sub_100040B90("error iterating trees during free queue tree repair: %s\n", v41, v42, v43, v44, v45, v46, v47, v40);
  uint64_t v31 = 925LL;
LABEL_27:
  sub_100044E7C((char *)v31, v14);
  sub_100036CD8((uint64_t)v58, 0LL);
  return v14;
}

  sub_1000414C4();
  sub_10001CB48();
  if (v33) {
    free(v33);
  }
  if (v34) {
    free(v34);
  }
  sub_10002955C(v2);
  if (v527[1]) {
    free(v527[1]);
  }
  if (v526[1]) {
    free(v526[1]);
  }
  uint64_t v36 = sub_10003C22C();
  if (byte_10008DB68) {
    sub_10001B98C((uint64_t)v36, v37, v38, v39, v40, v41, v42, v43);
  }
  return v35;
}
  }

  unsigned int v22 = a1;
  uint64_t v23 = 307;
LABEL_4:
  sub_1000432C4(v22, v23, v16, v17, v18, v19, v20, v21, v42);
  return 8LL;
}

LABEL_27:
  uint64_t v31 = v28;
LABEL_28:
  if (v51) {
    free(v51);
  }
  return v31;
}

        __int128 v42 = *(unsigned int *)(v33 + 36);
        uint64_t v43 = v35 * v42;
        if (*(v34 - 2) != v35 * v42)
        {
          sub_100040B90( "spaceman chunk %llu disk address out of order: 0x%llx, expected 0x%llx\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v35);
          uint64_t v62 = 92LL;
          uint64_t v63 = 581LL;
          goto LABEL_60;
        }

        if (v75 == v35) {
          __int16 v44 = (v76 - v43);
        }
        else {
          __int16 v44 = v42;
        }
        if ((*(_DWORD *)(v34 - 1) & 0xFFFFF) != (_DWORD)v44)
        {
          sub_100040B90( "spaceman chunk %llu wrong number of blocks: %u, expected %u\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v35);
          uint64_t v62 = 92LL;
          uint64_t v63 = 582LL;
          goto LABEL_60;
        }

        unsigned __int16 v45 = *((_DWORD *)v34 - 1);
        __int16 v46 = *(void *)&v45 & 0xFFFFFLL;
        if ((v45 & 0xFFFFFu) > v44)
        {
          sub_100040C68("spaceman chunk %llu free count %u > block count %u\n", v22, v23, v24, v25, v26, v27, v28, v35);
          sub_100044E7C((char *)0x247, -7);
          goto LABEL_50;
        }

        unsigned __int16 v47 = a1[1];
        unsigned int v24 = *(void *)(v47 + 1248);
        if (!v24)
        {
          *a6 += v46;
          goto LABEL_50;
        }

        if (v32 == 1) {
          v43 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v47 + 36)));
        }
        int v78 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v48 = sub_10004A6C4(v43, v44, *(void *)(v47 + 1240), v24, &v78);
        if (!v48)
        {
          uint64_t v59 = *((_DWORD *)v34 - 1) & 0xFFFFF;
          uint64_t v60 = a6;
          uint64_t v61 = *a6;
LABEL_49:
          *uint64_t v60 = v61 + v59;
          goto LABEL_50;
        }

        uint64_t v49 = v48;
        if (v48 >= (*(_DWORD *)(v34 - 1) & 0xFFFFFu)) {
          goto LABEL_50;
        }
        unsigned int v24 = *v34;
        if (!*v34)
        {
          uint64_t v59 = *((_DWORD *)v34 - 1) & 0xFFFFF;
          uint64_t v60 = a6;
          uint64_t v61 = *a6 - v48;
          goto LABEL_49;
        }

        uint64_t v80 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
        BOOL v50 = sub_100022BD0(a1, 0LL, 0x40000000, v24, 0LL, 0x20000000, 8, 0, &v80, 0LL, 0);
        if ((_DWORD)v50)
        {
          uint64_t v62 = v50;
          goto LABEL_61;
        }

        __int16 v58 = sub_10000822C((uint64_t)v80, 0, 0LL, *(_DWORD *)(v34 - 1) & 0xFFFFF);
        if ((*((_DWORD *)v34 - 1) & 0xFFFFF) != v58)
        {
          sub_100040C68( "spaceman chunk %llu wrong free count: %u, expected %u\n",  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v35);
          sub_100044E7C((char *)0x388, -7);
        }

        *a6 = *a6 + v58 - sub_10000822C((uint64_t)v80, 0, v78 - v43, v78 - v43 + v49);
        free(v80);
        uint64_t v32 = a2;
LABEL_50:
        if (!*v34 && (*((_DWORD *)v34 - 1) & 0xFFFFF) != (_DWORD)v44)
        {
          sub_100040C68( "spaceman chunk %llu free count %u of unallocated bitmap != block count %u\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v35);
          sub_100044E7C((char *)0x38A, -7);
        }

        v34 += 4;
        ++v35;
        if (!--v31)
        {
          unsigned int v29 = v77;
          unint64_t v10 = a3;
          unint64_t v9 = a4;
          unint64_t v8 = v65;
          break;
        }
      }
    }

    free(v29);
    uint64_t v77 = 0LL;
    ++v12;
    ++v73;
    uint64_t v14 = v69;
    if (v12 == v68) {
      return 0LL;
    }
  }

  sub_100040B90("spaceman cib out of order: %u, expected %u\n", v22, v23, v24, v25, v26, v27, v28, *((_DWORD *)v77 + 8));
  uint64_t v62 = 92LL;
  uint64_t v63 = 584LL;
LABEL_60:
  sub_100044E7C((char *)v63, 92);
LABEL_61:
  if (v77) {
    free(v77);
  }
  return v62;
}

uint64_t sub_100034008( uint64_t a1, uint64_t a2, __int128 *a3, void *a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, _OWORD *a11, uint64_t a12, unsigned __int8 a13)
{
  uint64_t v99 = a7;
  uint64_t v100 = a8;
  uint64_t v113 = a6;
  size_t v109 = a5;
  uint64_t v110 = a4;
  uint64_t v98 = a3;
  uint64_t v124 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v125 = (const void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v123 = 0LL;
  unsigned __int16 v122 = -21846;
  __int16 v121 = -21846;
  unsigned __int16 v120 = 0;
  __int16 v16 = *(_WORD *)(a2 + 32);
  sub_100030B3C(a2, a12, 0, (uint64_t *)&v125, &v122, (uint64_t *)&v124, &v121);
  bzero(v126, 0x580uLL);
  size_t v17 = 112LL * *(unsigned int *)(a2 + 36);
  __chkstk_darwin(v18);
  if (v20)
  {
    *(void *)&__int128 v21 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
    size_t v22 = v17;
    uint64_t v23 = &v97[v17 / 0xFFFFFFFFFFFFFFF8LL];
    do
    {
      v23[5] = v21;
      v23[6] = v21;
      v23[3] = v21;
      void v23[4] = v21;
      v23[1] = v21;
      v23[2] = v21;
      *uint64_t v23 = v21;
      v23 += 7;
      v22 -= 112LL;
    }

    while (v22);
  }

  v97[1] = v19;
  int v24 = v16 & 0x10;
  uint64_t v25 = *(unsigned int *)(a2 + 36);
  uint64_t v26 = __chkstk_darwin(&v97[v17 / 0xFFFFFFFFFFFFFFF8LL]);
  uint64_t v28 = (void *)((char *)v97 - v27);
  uint64_t v29 = 4 * v25;
  uint64_t v111 = (void *)v26;
  if ((_DWORD)v25)
  {
    uint64_t v30 = memset((char *)v97 - v27, 170, 8 * v25);
    __chkstk_darwin(v30);
    uint64_t v106 = (char *)v97 - ((v29 + 15) & 0x7FFFFFFF0LL);
    memset(v106, 170, 4 * v25);
    uint64_t v31 = v111;
  }

  else
  {
    uint64_t v31 = (void *)__chkstk_darwin(v26);
    uint64_t v106 = (char *)v97 - ((v29 + 15) & 0x7FFFFFFF0LL);
  }

  int v112 = v24 << 25;
  bzero(v31, v17);
  uint64_t v32 = (int *)v111;
  int v33 = v124;
  uint64_t v34 = *v124;
  v111[1] = *v124;
  if (*(_DWORD *)(a12 + 40))
  {
    *((void *)v32 + 1) = *(void *)(a12 + 64) + v34;
    memcpy(v32 + 4, v33 + 1, *(unsigned int *)(a12 + 44));
    uint64_t v32 = (int *)v111;
  }

  int v35 = a10;
  uint64_t v105 = a9;
  uint64_t v36 = v109;
  int v37 = v110;
  *((_OWORD *)v32 + 5) = *v109;
  *((void *)v32 + 12) = *((void *)v36 + 2);
  *((_BYTE *)v32 + 104) = v37 != 0LL;
  bzero(v28, 8 * v25);
  *uint64_t v28 = v37;
  uint64_t v110 = v28;
  if (v25 >= 2)
  {
    LODWORD(v109) = a10;
    uint64_t v38 = v32 + 28;
    uint64_t v39 = 1LL;
    do
    {
      sub_100030B3C(a2, a12, v39, (uint64_t *)&v125, &v122, (uint64_t *)&v124, &v121);
      *uint64_t v38 = v39;
      *((_BYTE *)v38 + 104) = 1;
      __int128 v40 = v124;
      uint64_t v41 = *v124;
      *((void *)v38 + 1) = *v124;
      if (*(_DWORD *)(a12 + 40))
      {
        v41 += *(void *)(a12 + 64);
        *((void *)v38 + 1) = v41;
        memcpy(v38 + 4, v40 + 1, *(unsigned int *)(a12 + 44));
      }

      unsigned int v42 = sub_1000225C8( *(uint64_t **)a1,  *(void *)(a1 + 8),  *(_DWORD *)(a1 + 40),  v41,  v113,  v112,  3,  *(_DWORD *)(a1 + 48),  (uint64_t)(v38 + 20));
      unint64_t v43 = v39 + 1;
      if (v42)
      {
        unsigned int v44 = v42;
        if (v43 >= *(unsigned int *)(a2 + 36))
        {
          unsigned __int16 v45 = (const void *)v105;
          uint64_t v123 = (const void *)v105;
          unsigned __int16 v120 = a10;
          unsigned int v46 = (unsigned __int16)a10;
        }

        else
        {
          sub_100030B3C(a2, a12, v39 + 1, (uint64_t *)&v123, &v120, 0LL, 0LL);
          unsigned __int16 v45 = v123;
          unsigned int v46 = v120;
        }

        uint64_t v47 = sub_100008B08( a1,  a12,  *((void *)v38 + 1),  *(void *)(a2 + 16),  (unsigned __int16)(*(_WORD *)(a2 + 34) - 1),  v125,  v122,  v45,  v46,  v44);
        if ((_DWORD)v47)
        {
LABEL_63:
          uint64_t v74 = v47;
          goto LABEL_64;
        }

        *((_BYTE *)v38 + 104) = 0;
        *((void *)v38 + 10) = 0x7FFFFFFFFFFFFFFFLL;
      }

      v38 += 28;
      ++v39;
    }

    while (v43 < *(unsigned int *)(a2 + 36));
    LODWORD(v25) = *(_DWORD *)(a2 + 36);
    uint64_t v28 = v110;
    uint64_t v32 = (int *)v111;
    int v35 = (int)v109;
  }

  qsort(v32 + 28, (v25 - 1), 0x70uLL, (int (__cdecl *)(const void *, const void *))sub_1000348A0);
  unint64_t v48 = *(unsigned int *)(a2 + 36);
  if (!(_DWORD)v48) {
    goto LABEL_32;
  }
  uint64_t v49 = 0LL;
  BOOL v50 = v32;
  uint64_t v51 = v106;
  do
  {
    uint64_t v52 = *v50;
    v50 += 28;
    *(_DWORD *)&v51[4 * v52] = v49++;
  }

  while (v48 != v49);
  if (v48 < 2)
  {
LABEL_32:
    uint64_t v60 = 1LL;
LABEL_33:
    sub_100030B3C(a2, a12, 0, (uint64_t *)&v125, &v122, 0LL, 0LL);
    unsigned int v61 = *(_DWORD *)(a2 + 36);
    if (!v61)
    {
      uint64_t v74 = 0LL;
      goto LABEL_68;
    }

    signed int v62 = 0;
    size_t v109 = a11;
    unsigned int v101 = (unsigned __int16)v35;
    int v102 = a13;
    uint64_t v63 = 1LL;
    unsigned int v108 = v122;
    uint64_t v107 = (uint64_t)v125;
    uint64_t v64 = v111;
    uint64_t v65 = v60;
    uint64_t v104 = a12;
    do
    {
      int v66 = *(_DWORD *)&v106[4 * v62];
      uint64_t v67 = v110[v62];
      if (v67 || !LOBYTE(v64[14 * v66 + 13]))
      {
        uint64_t v68 = v63;
        signed int v69 = v62 + 1;
        if (v61 <= v62 + 1)
        {
          uint64_t v70 = v105;
          uint64_t v123 = (const void *)v105;
          unsigned int v71 = v101;
          unsigned __int16 v120 = v101;
        }

        else
        {
          sub_100030B3C(a2, v104, v62 + 1, (uint64_t *)&v123, &v120, 0LL, 0LL);
          uint64_t v64 = v111;
          uint64_t v70 = (uint64_t)v123;
          unsigned int v71 = v120;
        }

        *(_WORD *)size_t v109 = *(_WORD *)(a2 + 34) - 1;
        if (LOBYTE(v64[14 * v66 + 13]))
        {
          uint64_t v72 = v62;
          uint64_t v73 = &v64[14 * v66];
          __int128 v118 = *v98;
          uint64_t v119 = *((void *)v98 + 2);
          __int128 v116 = *((_OWORD *)v73 + 5);
          uint64_t v117 = v73[12];
          BYTE1(v96) = v102;
          LOBYTE(v96) = 0;
          uint64_t v74 = sub_10003262C( a1,  a2,  &v118,  v67,  &v116,  v73 + 1,  v113,  v99,  v100,  v107,  v108,  v70,  v71,  v109,  v104,  v96);
          uint64_t v28 = v110;
          free((void *)v110[v72]);
          v28[v72] = 0LL;
          if ((_DWORD)v74) {
            goto LABEL_68;
          }
          uint64_t v70 = (uint64_t)v123;
          unsigned int v71 = v120;
          uint64_t v64 = v111;
        }

        unsigned int v61 = *(_DWORD *)(a2 + 36);
        unsigned int v108 = v71;
        uint64_t v107 = v70;
        signed int v62 = v69;
        uint64_t v63 = v68;
      }

      if (v63 < v61)
      {
        uint64_t v103 = v65;
        uint64_t v75 = &v64[14 * (int)v63];
        int v77 = *((unsigned __int8 *)v75 + 104);
        uint64_t v76 = v75 + 13;
        if (v77)
        {
          uint64_t v78 = SLODWORD(v64[14 * (int)v63]);
          uint64_t v79 = &v64[14 * (int)v63];
          uint64_t v82 = v79[1];
          uint64_t v81 = v79 + 1;
          uint64_t v80 = v82;
          int v83 = (v63 - 1) & 7;
          int v84 = v63;
          unsigned int v85 = sub_100023F78( *(uint64_t **)a1,  *(void *)(a1 + 8),  *(_DWORD *)(a1 + 40),  v80,  v113,  v112,  3,  *(_DWORD *)(a1 + 48),  (uint64_t)&v126[11 * v83],  (uint64_t **)&v110[v78],  (uint64_t)(v81 + 9),  v102);
          LODWORD(v63) = v84;
          uint64_t v64 = v111;
          if (v85)
          {
            unsigned int v86 = v85;
            *(void *)&__int128 v118 = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&__int128 v116 = 0xAAAAAAAAAAAAAAAALL;
            unsigned __int16 v115 = -21846;
            unsigned __int16 v114 = -21846;
            uint64_t v87 = v104;
            sub_100030B3C(a2, v104, v78, (uint64_t *)&v118, &v115, 0LL, 0LL);
            unsigned int v88 = v101;
            unsigned __int16 v89 = (const void *)v105;
            if (*(_DWORD *)(a2 + 36) > (v78 + 1))
            {
              sub_100030B3C(a2, v87, v78 + 1, (uint64_t *)&v116, &v114, 0LL, 0LL);
              unsigned __int16 v89 = (const void *)v116;
              unsigned int v88 = v114;
            }

            uint64_t v47 = sub_100008B08( a1,  v87,  *v81,  *(void *)(a2 + 16),  (unsigned __int16)(*(_WORD *)(a2 + 34) - 1),  (const void *)v118,  v115,  v89,  v88,  v86);
            if ((_DWORD)v47) {
              goto LABEL_63;
            }
            _BYTE *v76 = 0;
            uint64_t v64 = v111;
            LODWORD(v63) = v84;
          }
        }

        uint64_t v63 = (v63 + 1);
        unsigned int v61 = *(_DWORD *)(a2 + 36);
        uint64_t v65 = v103;
      }

      if (v65 < v61)
      {
        if (LOBYTE(v64[14 * (int)v65 + 13]))
        {
          uint64_t v90 = v63;
          int v91 = (v65 - 1) & 7;
          uint64_t v47 = sub_100023F40( *(uint64_t **)a1,  *(void *)(a1 + 8),  *(_DWORD *)(a1 + 40),  v64[14 * (int)v65 + 1],  v113,  v112,  3,  *(_DWORD *)(a1 + 48),  (uint64_t)&v126[11 * v91]);
          if ((_DWORD)v47) {
            goto LABEL_63;
          }
          unsigned int v61 = *(_DWORD *)(a2 + 36);
          uint64_t v64 = v111;
          uint64_t v63 = v90;
        }

        uint64_t v65 = (v65 + 1);
      }
    }

    while (v62 < v61);
    uint64_t v74 = 0LL;
LABEL_64:
    uint64_t v28 = v110;
    goto LABEL_68;
  }

  LODWORD(v109) = v35;
  __int128 v53 = (unsigned __int8 *)(v32 + 54);
  __int128 v54 = v126;
  unint64_t v55 = 1LL;
  __int128 v56 = (unsigned __int8 *)(v32 + 54);
  while (1)
  {
    int v57 = *v56;
    v56 += 112;
    if (!v57) {
      goto LABEL_29;
    }
    uint64_t v58 = sub_100023F40( *(uint64_t **)a1,  *(void *)(a1 + 8),  *(_DWORD *)(a1 + 40),  *((void *)v53 - 12),  v113,  v112,  3,  *(_DWORD *)(a1 + 48),  (uint64_t)v54);
    if ((_DWORD)v58) {
      break;
    }
    unint64_t v48 = *(unsigned int *)(a2 + 36);
LABEL_29:
    unint64_t v59 = v55 + 1;
    if (v55 <= 7)
    {
      v54 += 11;
      __int128 v53 = v56;
      ++v55;
      if (v59 < v48) {
        continue;
      }
    }

    uint64_t v60 = v59;
    LOWORD(v35) = (_WORD)v109;
    goto LABEL_33;
  }

  uint64_t v74 = v58;
LABEL_68:
  unint64_t v92 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v92)
  {
    for (unint64_t i = 0LL; i < v92; ++i)
    {
      __int128 v94 = (void *)v28[i];
      if (v94)
      {
        free(v94);
        unint64_t v92 = *(unsigned int *)(a2 + 36);
      }
    }
  }

  return v74;
}

uint64_t sub_1000348A0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(a2 + 80);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t sub_1000348B8(unsigned __int8 *a1, uint64_t a2)
{
  int v22 = (int)a1;
  if (a2 >= 1)
  {
    int v2 = 0;
    uint64_t v3 = a1;
    unint64_t i = (unint64_t)&a1[a2];
    BOOL v5 = a1 + 16;
    int v6 = (_DWORD)a1 + 17;
    unint64_t v21 = (unint64_t)&a1[a2];
    while (1)
    {
      unint64_t v7 = (unint64_t)&v5[-i];
      if (v7 <= 1) {
        uint64_t v8 = 1LL;
      }
      else {
        uint64_t v8 = v7;
      }
      else {
        int v9 = (int)v5;
      }
      unint64_t v10 = v3 + 16;
      else {
        unint64_t v11 = (unsigned __int8 *)i;
      }
      uint64_t v12 = v3;
      if (v3 < v11) {
        break;
      }
LABEL_19:
      if (v2 == 1)
      {
        fwrite(". . .\n", 6uLL, 1uLL, __stderrp);
        int v2 = 2;
      }

uint64_t sub_100034B44( uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, uint64_t a12, uint64_t a13)
{
  uint64_t result = 22LL;
  if (a4 <= 0x7FFFFFF)
  {
    if (a4 != 0x80000000 && a4) {
      return result;
    }
LABEL_7:
    uint64_t result = 0LL;
    *(void *)a1 = a2;
    *(void *)(a1 + 8) = a3;
    *(_DWORD *)(a1 + 40) = a4;
    *(_DWORD *)(a1 + 44) = a5;
    *(_DWORD *)(a1 + 48) = a6;
    *(_DWORD *)(a1 + 52) = a7;
    *(_DWORD *)(a1 + 24) = a8;
    *(_DWORD *)(a1 + 28) = a9;
    *(_DWORD *)(a1 + 32) = a10;
    *(_DWORD *)(a1 + 36) = a11;
    *(void *)(a1 + 56) = a12;
    *(void *)(a1 + --*(_DWORD *)(result + 16) = a13;
    return result;
  }

  if (a4 == 0x40000000 || a4 == 0x8000000) {
    goto LABEL_7;
  }
  return result;
}

uint64_t sub_100034BB4( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned int *a5, unsigned int a6, void *a7, unsigned int *a8)
{
  if (*(_DWORD *)(a1 + 44) == 2) {
    return sub_100034BEC(a1, a2, a3, a4, a5, a6, a7, a8, 0LL, 0);
  }
  else {
    return 22LL;
  }
}

uint64_t sub_100034BEC( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned int *a5, unsigned int a6, void *a7, unsigned int *a8, void **a9, unsigned __int16 a10)
{
  uint64_t v12 = a3;
  uint64_t v13 = a2;
  int v15 = a9;
  int v63 = -1431655766;
  int v64 = -1431655766;
  int v62 = 0;
  unsigned int v50 = a3 - 1;
  BOOL v52 = (a3 - 1) < 2;
  BOOL v53 = a3 == -2;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  uint64_t v54 = 0LL;
  __int128 __src = 0LL;
  uint64_t v16 = *(void *)(a1 + 56);
  if (a9) {
    *a9 = 0LL;
  }
  uint64_t v17 = sub_10002B658(a1, &__src, *(unsigned int *)(a1 + 40), a2, v16);
  if ((_DWORD)v17)
  {
LABEL_46:
    if (v15)
    {
      free(*v15);
      *int v15 = 0LL;
    }

    goto LABEL_48;
  }

  unsigned __int16 v51 = 0;
  unsigned __int16 v18 = -4081;
  while (1)
  {
    int v19 = v15;
    uint64_t v20 = v13;
    uint64_t v21 = v12;
    int v22 = a4;
    int v23 = a5;
    int v24 = (unsigned __int16 *)__src;
    uint64_t v25 = *(void *)(a1 + 56);
    uint64_t v26 = sub_100036DB8((unsigned int *)a1, (uint64_t)__src, v16 == v25, v18);
    if ((_DWORD)v26)
    {
      uint64_t v17 = v26;
      int v15 = v19;
      goto LABEL_46;
    }

    uint64_t v27 = v16;
    unsigned int v28 = v24[17];
    if (v28 < a10) {
      return 22LL;
    }
    BOOL v46 = v27 == v25;
    a5 = v23;
    a4 = v22;
    uint64_t v12 = v21;
    uint64_t v13 = v20;
    int v15 = v19;
    if (v46)
    {
      uint64_t v29 = *(unsigned int *)(a1 + 24);
      __int128 v56 = *(_OWORD *)((char *)v24 + v29 - 40);
      *(void *)&__int128 v57 = *(unsigned int *)(a1 + 36) | 0xAAAAAAAA00000000LL;
      *((void *)&v57 + 1) = v27;
      uint64_t v30 = sub_100036F54((uint64_t)v19, v28 - a10 + 1, v29);
      if ((_DWORD)v30) {
        goto LABEL_45;
      }
      int v24 = (unsigned __int16 *)__src;
    }

    if (v19)
    {
      uint64_t v31 = (void *)*((void *)*v19 + 2 * (int)(v28 - a10) + 1);
      if (v31) {
        memcpy(v31, v24, *(unsigned int *)(a1 + 24));
      }
    }

    while (v28 > a10)
    {
      uint64_t v32 = sub_100036FF8(a1, (uint64_t)&v56, (uint64_t)__src, (uint64_t)a4, *a5, &v63, &v64);
      uint64_t v17 = v32;
      signed int v33 = v63;
      if (v15) {
        *((_DWORD *)*v15 + 4 * (int)(v28 - a10) + 4) = v63;
      }
      if ((_DWORD)v32) {
        goto LABEL_46;
      }
      uint64_t v34 = __src;
      if (v53 && v33 > 0 || v52 && v33 < *((_DWORD *)__src + 9) - 1)
      {
        uint64_t v30 = sub_100037038((uint64_t)&v56, (uint64_t)__src, v52 - v53 + v33, &v54);
        if ((_DWORD)v30) {
          goto LABEL_45;
        }
        unsigned __int16 v51 = v28 - 1;
        uint64_t v34 = __src;
      }

      uint64_t v30 = sub_1000370F0((unsigned int *)a1, v13, &v56, (uint64_t)v34, v33, 0, (uint64_t *)&__src);
      if ((_DWORD)v30) {
        goto LABEL_45;
      }
      unsigned int v28 = *((unsigned __int16 *)__src + 17);
      if (v15)
      {
        int v35 = (void *)*((void *)*v15 + 2 * (int)(v28 - a10) + 1);
        if (v35) {
          memcpy(v35, __src, *(unsigned int *)(a1 + 24));
        }
      }
    }

    uint64_t v30 = sub_1000371B0(a1, (uint64_t)&v56, (uint64_t)__src, (uint64_t)a4, *a5, &v63, &v64);
    if ((_DWORD)v30)
    {
LABEL_45:
      uint64_t v17 = v30;
      goto LABEL_46;
    }

    int v36 = v64;
    if (v64)
    {
      if ((_DWORD)v12 == -2)
      {
        int v37 = v63--;
        int v36 = v37 > 0;
      }

      else
      {
        if ((_DWORD)v12 != 2) {
          goto LABEL_55;
        }
        int v36 = ++v63 < *((_DWORD *)__src + 9);
      }

      int v64 = v36;
    }

    if (!(_DWORD)v12 || v36) {
      break;
    }
    if (v12 >= 0xFFFFFFFE)
    {
      unsigned int v38 = v63 - 1;
      if (v63 >= 1) {
        goto LABEL_58;
      }
    }

    if (v50 <= 1 && v63 < *((_DWORD *)__src + 9))
    {
      unsigned int v38 = v63;
      goto LABEL_58;
    }

    uint64_t v16 = v54;
    if (!v54) {
      goto LABEL_56;
    }
    uint64_t v54 = 0LL;
    uint64_t v17 = sub_10002B658(a1, &__src, *(unsigned int *)(a1 + 40), v13, v16);
    BOOL v52 = 0;
    BOOL v53 = 0;
    unsigned __int16 v18 = v51;
    if ((_DWORD)v17) {
      goto LABEL_46;
    }
  }

  if (!v36)
  {
LABEL_56:
    uint64_t v17 = 2LL;
    goto LABEL_46;
  }

LABEL_55:
  unsigned int v38 = v63;
LABEL_58:
  if (v15) {
    *((_DWORD *)*v15 + 4 * (int)(v28 - a10) + 4) = v38;
  }
  unsigned int v61 = (void *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v59 = -1431655766;
  uint64_t v40 = sub_1000372D4((uint64_t)&v56, (uint64_t)__src, v38, &v61, &v59);
  uint64_t v17 = v40;
  if (!(_DWORD)v12 || (_DWORD)v40)
  {
    if ((_DWORD)v40) {
      goto LABEL_46;
    }
  }

  else
  {
    uint64_t v41 = *(void *)(a1 + 8);
    if (v41) {
      uint64_t v42 = *(void *)(v41 + 40);
    }
    else {
      uint64_t v42 = 0LL;
    }
    uint64_t v17 = (*(uint64_t (**)(uint64_t, void *, void, void *, void, int *))(a1 + 16))( v42,  v61,  v59,  a4,  *a5,  &v62);
    if ((_DWORD)v17) {
      goto LABEL_46;
    }
    if ((_DWORD)v12 == -2 && (v62 & 0x80000000) == 0)
    {
      uint64_t v17 = 92LL;
      goto LABEL_46;
    }

    BOOL v43 = (_DWORD)v12 == 1;
    if (v62 >= 0) {
      BOOL v43 = 0;
    }
    BOOL v44 = (_DWORD)v12 == 2 && v62 < 1;
    BOOL v45 = v44;
    BOOL v46 = v62 > 0 && (_DWORD)v12 == -1;
    uint64_t v17 = 92LL;
    if (v46 || v43 || v45) {
      goto LABEL_46;
    }
  }

  *(void *)uint64_t v60 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v58 = -1431655766;
  uint64_t v17 = sub_10003735C((uint64_t)&v56, (uint64_t)__src, v38, v60, &v58);
  if ((_DWORD)v17) {
    goto LABEL_46;
  }
  *a5 = a6;
  uint64_t v17 = sub_10003744C(v61, v59, *(const void **)v60, v58, a4, a5, a7, a8);
  if ((_DWORD)v17) {
    goto LABEL_46;
  }
LABEL_48:
  if (__src && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(__src);
  }
  return v17;
}

  free(v18);
  return v27;
}

uint64_t sub_10003510C(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, void *a5, unsigned int *a6)
{
  if (*(_DWORD *)(a1 + 44) == 2) {
    return sub_10003512C(a1, a2, a3, a4, a5, a6, 0LL, 0);
  }
  else {
    return 22LL;
  }
}

uint64_t sub_10003512C( uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, void *a5, unsigned int *a6, void **a7, unsigned int a8)
{
  __int128 __src = 0LL;
  if (a7) {
    *a7 = 0LL;
  }
  int v37 = (__int128 *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v15 = sub_100037698(a1, a2, 0, &__src, &v37);
  if ((_DWORD)v15) {
    goto LABEL_4;
  }
  if ((*((_WORD *)__src + 16) & 2) != 0 && !*((_DWORD *)__src + 9))
  {
    uint64_t v15 = 2LL;
    goto LABEL_4;
  }

  unsigned int v16 = *((unsigned __int16 *)__src + 17);
  if (v16 < a8) {
    return 22LL;
  }
  __int128 v34 = *v37;
  uint64_t v18 = *(void *)(a1 + 56);
  unint64_t v35 = *(unsigned int *)(a1 + 36) | 0xAAAAAAAA00000000LL;
  uint64_t v36 = v18;
  uint64_t v15 = sub_100036F54((uint64_t)a7, v16 - a8 + 1, *(_DWORD *)(a1 + 24));
  if ((_DWORD)v15) {
    goto LABEL_4;
  }
  if (a7)
  {
    int v19 = (void *)*((void *)*a7 + 2 * (int)(v16 - a8) + 1);
    if (v19) {
      memcpy(v19, __src, *(unsigned int *)(a1 + 24));
    }
  }

  if (v16 > a8)
  {
    while (1)
    {
      uint64_t v20 = sub_1000370F0((unsigned int *)a1, a2, &v34, (uint64_t)__src, 0, 0, (uint64_t *)&__src);
      if ((_DWORD)v20) {
        break;
      }
      unsigned int v21 = *((unsigned __int16 *)__src + 17);
      if (a7)
      {
        int v22 = (void *)*((void *)*a7 + 2 * (int)(v21 - a8) + 1);
        if (v22) {
          memcpy(v22, __src, *(unsigned int *)(a1 + 24));
        }
      }

      if (v21 <= a8) {
        goto LABEL_24;
      }
    }

    uint64_t v15 = v20;
    goto LABEL_4;
  }

uint64_t sub_100035394( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned int a5, unsigned int a6, void *a7, int a8)
{
  if (a5 > a6) {
    return 34LL;
  }
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = a3;
  *(_DWORD *)(a1 + 64) = a6;
  *(_DWORD *)(a1 + 68) = a8;
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = sub_100035444;
  *(_DWORD *)(a1 + 32) = a5;
  *(void *)(a1 + --*(_DWORD *)(result + 16) = a4;
  *(void *)(a1 + 24) = a7;
  *(_BYTE *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 36) = a8;
  if (*(_DWORD *)(a2 + 44) == 2)
  {
    uint64_t result = sub_100034BEC(a2, a3, 1LL, a4, (unsigned int *)(a1 + 32), a6, a7, (unsigned int *)(a1 + 36), 0LL, 0);
    if ((_DWORD)result)
    {
      *(_BYTE *)(a1 + 40) = 1;
      if ((_DWORD)result == 2) {
        return 0LL;
      }
      else {
        return result;
      }
    }
  }

  else
  {
    *(_BYTE *)(a1 + 40) = 1;
    return 22LL;
  }

  return result;
}

uint64_t sub_100035444(uint64_t a1)
{
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 68);
  int v2 = (unsigned int *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 48);
  if (*(_DWORD *)(v3 + 44) == 2)
  {
    uint64_t result = sub_100034BEC( v3,  *(void *)(a1 + 56),  2LL,  *(void **)(a1 + 16),  (unsigned int *)(a1 + 32),  *(_DWORD *)(a1 + 64),  *(void **)(a1 + 24),  v2,  0LL,  0);
    if ((_DWORD)result)
    {
      *(_BYTE *)(a1 + 40) = 1;
      if ((_DWORD)result == 2) {
        return 0LL;
      }
      else {
        return result;
      }
    }
  }

  else
  {
    *(_BYTE *)(a1 + 40) = 1;
    return 22LL;
  }

  return result;
}

uint64_t sub_1000354C8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, unsigned int a6, unsigned int a7)
{
  size_t v14 = *(unsigned int *)(a2 + 24);
  uint64_t v15 = ((uint64_t (*)(void))__chkstk_darwin)();
  uint64_t v16 = (v14 + 15) & 0x1FFFFFFF0LL;
  uint64_t v17 = (char *)&v24 - v16;
  if ((_DWORD)v14)
  {
    uint64_t v18 = memset((char *)&v24 - v16, 170, v14);
    __chkstk_darwin(v18);
    int v19 = (char *)&v24 - v16;
    memset(v19, 170, v14);
  }

  else
  {
    __chkstk_darwin(v15);
    int v19 = (char *)&v24 - v16;
  }

  unsigned int v24 = v14;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + --*(_DWORD *)(result + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)a1 = sub_100035754;
  *(void *)(a1 + 8) = sub_10003577C;
  *(_BYTE *)(a1 + 40) = 1;
  if (*(_DWORD *)(a2 + 44) != 2) {
    return 22LL;
  }
  if (a5)
  {
    memcpy(v17, a5, a6);
    unsigned int v25 = a6;
    uint64_t v20 = sub_100034BEC(a2, a3, a4, v17, &v25, v14, v19, &v24, (void **)(a1 + 72), a7);
    if ((_DWORD)v20 != 2) {
      goto LABEL_15;
    }
    uint64_t v22 = sub_100034BEC(a2, a3, 1LL, v17, &v25, v14, v19, &v24, (void **)(a1 + 72), a7);
  }

  else
  {
    unsigned int v25 = v14;
    uint64_t v22 = sub_10003512C(a2, a3, v17, &v25, v19, &v24, (void **)(a1 + 72), a7);
  }

  uint64_t v20 = v22;
LABEL_15:
  if ((_DWORD)v20 == 2) {
    return 0LL;
  }
  if ((_DWORD)v20
    || (uint64_t v23 = *(void *)(a1 + 72) + 16LL * **(int **)(a1 + 72),
        *(void *)(a1 + 48) = a2,
        *(void *)(a1 + 56) = a3,
        *(void *)(a1 + 64) = *(void *)(v23 - 8) + *(unsigned int *)(a2 + 24) - 40LL,
        uint64_t v20 = sub_1000357BC(a1),
        (_DWORD)v20))
  {
    free(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = 0LL;
  }

  else
  {
    *(_BYTE *)(a1 + 40) = 0;
  }

  return v20;
}

void sub_100035754(uint64_t a1)
{
  *(void *)(a1 + 72) = 0LL;
}

uint64_t sub_10003577C(uint64_t a1)
{
  return 0LL;
}

uint64_t sub_1000357BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 72);
  __int128 v7 = *(_OWORD *)*(void *)(a1 + 64);
  int v4 = *(_DWORD *)(v2 + 36);
  uint64_t v5 = *(void *)(v2 + 56);
  int v9 = -1431655766;
  uint64_t v10 = v5;
  int v8 = v4;
  uint64_t result = sub_1000372D4( (uint64_t)&v7,  *(void *)(v3 + 8),  *(_DWORD *)(v3 + 16),  (void *)(a1 + 16),  (_DWORD *)(a1 + 32));
  if (!(_DWORD)result) {
    return sub_10003735C( (uint64_t)&v7,  *(void *)(v3 + 8),  *(_DWORD *)(v3 + 16),  (void *)(a1 + 24),  (unsigned int *)(a1 + 36));
  }
  return result;
}

uint64_t sub_100035838(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, unsigned int a5)
{
  return sub_1000354C8(a1, a2, a3, 1LL, a4, a5, 0);
}

BOOL sub_10003584C( uint64_t a1, unsigned __int16 *a2, int a3, const void *a4, unsigned int a5, const void *a6, unsigned int a7)
{
  if (a4)
  {
    unsigned __int16 v12 = a2[16];
    uint64_t v13 = &a2[2 * a3 + 28];
    if ((v12 & 4) == 0) {
      uint64_t v13 = &a2[4 * a3 + 28];
    }
    unsigned int v44 = *v13;
    if ((v12 & 4) != 0) {
      int v14 = *(_DWORD *)(a1 + 8);
    }
    else {
      LOWORD(v14) = a2[4 * a3 + 29];
    }
    if ((*(_DWORD *)a1 & 0x40) != 0) {
      unsigned int v15 = a5;
    }
    else {
      unsigned int v15 = (a5 + 7) & 0xFFFFFFF8;
    }
    unsigned int v17 = (unsigned __int16)v14;
    int v18 = ((unsigned __int16)v14 + 7) & 0x1FFF8;
    if ((*(_DWORD *)a1 & 0x40) != 0) {
      unsigned int v16 = v17;
    }
    else {
      unsigned int v16 = v18;
    }
  }

  else
  {
    unsigned int v15 = 0;
    unsigned int v16 = 0;
    unsigned int v17 = 0;
    unsigned int v44 = 0xFFFF;
  }

  if (a6)
  {
    if ((a2[16] & 4) != 0) {
      int v19 = &a2[2 * a3 + 29];
    }
    else {
      int v19 = &a2[4 * a3 + 30];
    }
    unsigned int v20 = *v19;
    unsigned int v21 = sub_100035C54(a1, (uint64_t)a2, a3);
    unsigned int v22 = v21;
    if (a7 == 65534)
    {
      unsigned int v23 = 0;
    }

    else
    {
      unsigned int v23 = (a7 + 7) & 0xFFFFFFF8;
      if ((*(_BYTE *)a1 & 0x40) != 0) {
        unsigned int v23 = a7;
      }
    }

    v15 += v23;
    if (v21 == 65534)
    {
      int v24 = 0;
    }

    else
    {
      int v24 = (v21 + 7) & 0x1FFF8;
      if ((*(_BYTE *)a1 & 0x40) != 0) {
        int v24 = v21;
      }
    }

    v16 += v24;
  }

  else
  {
    unsigned int v22 = 0;
    unsigned int v20 = 0xFFFF;
  }

  unsigned int v25 = sub_100035CCC((_BYTE *)a1, a2, 0) + v16;
  if (v15 <= v25)
  {
    unsigned int __n = a7;
    if (a4)
    {
      sub_100035D38(a1, a2, 0, v44, v17);
      unsigned int v26 = a5;
      unsigned int v27 = sub_100035E48((int *)a1, a2, 0, a5);
      if (v27)
      {
        unsigned int v26 = 0;
      }

      else if ((*(_BYTE *)a1 & 0x40) == 0)
      {
        unsigned int v26 = (a5 + 7) & 0xFFFFFFF8;
      }
    }

    else
    {
      unsigned int v26 = 0;
      unsigned int v27 = 0LL;
    }

    if (a6)
    {
      sub_100035D38(a1, a2, 1, v20, v22);
      unsigned __int16 v28 = sub_100035E48((int *)a1, a2, 1, __n);
      if (!v28)
      {
        if (__n == 65534)
        {
          unsigned int v31 = 0;
        }

        else
        {
          unsigned int v31 = (__n + 7) & 0xFFFFFFF8;
          if ((*(_BYTE *)a1 & 0x40) != 0) {
            unsigned int v31 = __n;
          }
        }

        uint64_t v30 = a6;
        uint64_t v29 = 0LL;
        v26 += v31;
LABEL_45:
        if (v26 <= a2[23])
        {
LABEL_56:
          if (a4)
          {
            unsigned int v34 = sub_1000363C8((int *)a1, a2, 0, a5, v27);
            __int16 v35 = v34;
            uint64_t v36 = a2 + 28;
            memcpy((char *)a2 + a2[21] + v34 + 56, a4, a5);
            if ((a2[16] & 4) != 0)
            {
              v36[2 * a3] = v35;
            }

            else
            {
              int v37 = &v36[4 * a3];
              *int v37 = v35;
              v37[1] = a5;
            }

            uint64_t v30 = a6;
          }

          if (v30)
          {
            unsigned int v38 = sub_1000363C8((int *)a1, a2, 1, __n, v29);
            __int16 v39 = v38;
            if (v38 <= 0xFFFD)
            {
              uint64_t v40 = -40LL;
              if ((a2[16] & 1) == 0) {
                uint64_t v40 = 0LL;
              }
              memcpy((char *)a2 + *(unsigned int *)(a1 + 4) + v40 - v38, a6, __n);
            }

            uint64_t v41 = a2 + 28;
            if ((a2[16] & 4) != 0)
            {
              v41[2 * a3 + 1] = v39;
            }

            else
            {
              uint64_t v42 = &v41[4 * a3];
              v42[2] = v39;
              v42[3] = __n;
            }
          }

          return v15 <= v25;
        }

        if (a4)
        {
          uint64_t v32 = a2 + 28;
          if ((a2[16] & 4) != 0)
          {
            v32[2 * a3] = -1;
            if (!v30)
            {
LABEL_55:
              sub_100035FC4(a1, (uint64_t)a2, 0);
              unsigned int v27 = 0LL;
              uint64_t v29 = 0LL;
              goto LABEL_56;
            }

uint64_t sub_100035C54(uint64_t a1, uint64_t a2, int a3)
{
  __int16 v3 = *(_WORD *)(a2 + 32);
  uint64_t v4 = a2 + 56;
  if ((v3 & 4) != 0)
  {
    uint64_t v5 = (unsigned __int16 *)(v4 + 4LL * a3 + 2);
    LODWORD(v4) = *(_DWORD *)(a1 + 12);
  }

  else
  {
    v4 += 8LL * a3;
    uint64_t v5 = (unsigned __int16 *)(v4 + 4);
    LOWORD(v4) = *(_WORD *)(v4 + 6);
  }

  int v6 = *v5;
  if (v6 == 65534)
  {
    LOWORD(v4) = -2;
  }

  else if (v6 == 0xFFFF)
  {
    LOWORD(v4) = 0;
  }

  else if ((v3 & 2) == 0)
  {
    if ((v3 & 8) != 0) {
      LOWORD(v4) = *(_WORD *)(a1 + 16) + 8;
    }
    else {
      LOWORD(v4) = 8;
    }
  }

  return (unsigned __int16)v4;
}

uint64_t sub_100035CCC(_BYTE *a1, _WORD *a2, int a3)
{
  uint64_t v3 = (unsigned __int16)a2[25] + (unsigned __int16)a2[23] + (unsigned __int16)a2[27];
  if ((a2[16] & 4) != 0 && (*a1 & 4) == 0) {
    return v3;
  }
  unsigned int v4 = (unsigned __int16)a2[21];
  unsigned int v5 = sub_100037830((uint64_t)a1, (uint64_t)a2, a3);
  unsigned int v6 = v5 - v4;
  if (v5 < v4) {
    return (_DWORD)v3 - v5 + v4;
  }
  if (v5 <= v4) {
    return v3;
  }
  BOOL v7 = v3 >= v6;
  unsigned int v8 = v3 - v6;
  if (v7) {
    return v8;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_100035D38(uint64_t result, _WORD *a2, int a3, unsigned int a4, unsigned int a5)
{
  if (a4 <= 0xFFFD)
  {
    int v5 = (unsigned __int16)a2[22];
    uint64_t v6 = *(unsigned int *)(result + 4);
    int v7 = (unsigned __int16)a2[23];
    unsigned int v8 = (a5 + 7) & 0xFFFFFFF8;
    if ((*(_BYTE *)result & 0x40) != 0) {
      unsigned int v8 = a5;
    }
    if (a3 || v8 + a4 != v5)
    {
      if (a3 == 1
        && (_DWORD)v6
         - (unsigned __int16)a2[21]
         - (v5
          + v7)
         + (((unsigned __int16)a2[16] << 31 >> 31) & 0xFFFFFFD8)
         - 56 == a4)
      {
        a2[23] = v7 + v8;
      }

      else
      {
        int v9 = a2 + 24;
        uint64_t v10 = 26LL;
        if (a3) {
          int v9 = a2 + 26;
        }
        else {
          uint64_t v10 = 24LL;
        }
        v9[1] += v8;
        if (v8 >= 4)
        {
          if (a3)
          {
            unint64_t v11 = (char *)a2 + v6;
            uint64_t v12 = -40LL;
            if ((a2[16] & 1) == 0) {
              uint64_t v12 = 0LL;
            }
            uint64_t v13 = &v11[v12 - a4];
          }

          else
          {
            uint64_t v13 = (char *)a2 + (unsigned __int16)a2[21] + a4 + 56;
          }

          *((_WORD *)v13 + 1) = v8;
          *(_WORD *)uint64_t v13 = a2[v10];
          a2[v10] = a4;
        }
      }
    }

    else
    {
      a2[23] = v7 + v8;
      a2[22] = v5 - v8;
    }
  }

  return result;
}

unsigned __int16 *sub_100035E48(int *a1, unsigned __int16 *a2, int a3, unsigned int a4)
{
  uint64_t result = 0LL;
  if (a4 && a4 != 65534)
  {
    uint64_t v6 = 24LL;
    if (a3)
    {
      uint64_t v6 = 26LL;
      int v7 = a2 + 26;
    }

    else
    {
      int v7 = a2 + 24;
    }

    int v8 = *a1;
    unsigned int v9 = (a4 + 7) & 0xFFFFFFF8;
    if ((*a1 & 0x40) != 0) {
      unsigned int v9 = a4;
    }
    if (v9 <= v7[1])
    {
      unsigned int v10 = a2[v6];
      if (v10 != 0xFFFF)
      {
        uint64_t result = 0LL;
        unsigned int v11 = -1;
        while (1)
        {
          if (a3)
          {
            if (v10 < 4) {
              return result;
            }
            uint64_t v12 = a1[1];
            int v13 = a2[16];
            if ((_DWORD)v12 - a2[23] - (a2[21] + a2[22]) + ((v13 << 31 >> 31) & 0xFFFFFFD8) - 56 < v10) {
              return result;
            }
            int v14 = (char *)a2 + v12;
            uint64_t v15 = (v13 & 1) != 0 ? -40LL : 0LL;
            unsigned int v16 = (unsigned __int16 *)&v14[v15 - v10];
            unsigned int v17 = v16[1];
            if (v17 < 4) {
              return result;
            }
            unsigned int v18 = (v17 + 7) & 0x1FFF8;
            if ((v8 & 0x40) != 0) {
              unsigned int v18 = v16[1];
            }
            if (v18 > v10) {
              return result;
            }
          }

          else
          {
            unsigned int v19 = a2[22];
            unsigned int v20 = v19 - v10;
            if (v19 <= v10) {
              return result;
            }
            if (v20 < 4) {
              return result;
            }
            unsigned int v16 = (unsigned __int16 *)((char *)a2 + a2[21] + v10 + 56);
            unsigned int v17 = v16[1];
            if (v17 < 4) {
              return result;
            }
            unsigned int v21 = (v17 + 7) & 0x1FFF8;
            if ((v8 & 0x40) != 0) {
              unsigned int v21 = v16[1];
            }
            if (v21 > v20) {
              return result;
            }
          }

          if (v9 <= v17 && v11 > v17)
          {
            uint64_t result = v7;
            unsigned int v11 = v17;
          }

          unsigned int v10 = *v16;
          int v7 = v16;
          if (v10 == 0xFFFF) {
            return result;
          }
        }
      }
    }

    return 0LL;
  }

  return result;
}

void sub_100035FC4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = calloc(*(unsigned int *)(a2 + 36), 6uLL);
  int v7 = (char *)v6;
  size_t v8 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v8)
  {
    uint64_t v9 = 0LL;
    unsigned int v10 = v6 + 2;
    uint64_t v11 = 60LL;
    uint64_t v12 = 58LL;
    do
    {
      *(v10 - 2) = v9;
      if ((*(_WORD *)(a2 + 32) & 4) != 0) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v11;
      }
      *(v10 - 1) = *(_WORD *)(a2 + v13);
      int v14 = sub_100035C54(a1, a2, v9);
      if (v14 == 65534)
      {
        __int16 v15 = 0;
      }

      else if ((*(_BYTE *)a1 & 0x40) != 0)
      {
        __int16 v15 = v14;
      }

      else
      {
        __int16 v15 = (v14 + 7) & 0xFFF8;
      }

      *unsigned int v10 = v15;
      v10 += 3;
      ++v9;
      v11 += 8LL;
      v12 += 4LL;
    }

    while (v8 != v9);
  }

  else
  {
    size_t v8 = 0LL;
  }

  qsort(v7, v8, 6uLL, (int (__cdecl *)(const void *, const void *))sub_1000378A4);
  __int16 v16 = *(_WORD *)(a2 + 32);
  uint64_t v17 = -40LL;
  if ((v16 & 1) == 0) {
    uint64_t v17 = 0LL;
  }
  __base = v7;
  if (*(_DWORD *)(a2 + 36))
  {
    int v58 = a3;
    unint64_t v18 = 0LL;
    LODWORD(v19) = 0;
    uint64_t v20 = a2 + *(unsigned int *)(a1 + 4) + v17;
    unsigned int v21 = v7;
    uint64_t v22 = a2 + 56;
    unsigned int v23 = (unsigned __int16 *)(v21 + 4);
    do
    {
      unint64_t v24 = *(v23 - 1);
      if (v24 <= 0xFFFD)
      {
        size_t v25 = *v23;
        uint64_t v19 = (v19 + v25);
        memmove((void *)(v20 - v19), (const void *)(v20 - v24), v25);
        uint64_t v26 = *(v23 - 2);
        __int16 v16 = *(_WORD *)(a2 + 32);
        if ((v16 & 4) != 0)
        {
          *(_WORD *)(v22 + 4 * v26 + 2) = v19;
        }

        else
        {
          __int16 v27 = sub_100035C54(a1, a2, *(v23 - 2));
          uint64_t v28 = v22 + 8 * v26;
          *(_WORD *)(v28 + 4) = v19;
          *(_WORD *)(v28 + 6) = v27;
        }
      }

      ++v18;
      unint64_t v29 = *(unsigned int *)(a2 + 36);
      v23 += 3;
    }

    while (v18 < v29);
    a3 = v58;
  }

  else
  {
    LOWORD(v19) = 0;
    LODWORD(v29) = 0;
  }

  *(_WORD *)(a2 + 46) = v19;
  if ((v16 & 4) == 0 || (*(_BYTE *)a1 & 4) != 0) {
    unsigned int v30 = sub_100037830(a1, a2, a3);
  }
  else {
    unsigned int v30 = *(unsigned __int16 *)(a2 + 42);
  }
  unsigned int v31 = (char *)__base;
  if ((_DWORD)v29)
  {
    uint64_t v32 = 0LL;
    signed int v33 = (_WORD *)(a2 + 56);
    int v34 = *(_DWORD *)a1;
    size_t v35 = v29;
    uint64_t v36 = __base + 2;
    int v37 = (_WORD *)(a2 + 56);
    do
    {
      *(v36 - 2) = v32;
      if ((*(_WORD *)(a2 + 32) & 4) != 0) {
        unsigned int v38 = v37;
      }
      else {
        unsigned int v38 = v33;
      }
      *(v36 - 1) = *v38;
      if ((*(_WORD *)(a2 + 32) & 4) != 0) {
        int v39 = *(_DWORD *)(a1 + 8);
      }
      else {
        LOWORD(v39) = v33[1];
      }
      if ((v34 & 0x40) == 0) {
        LOWORD(v39) = (v39 + 7) & 0xFFF8;
      }
      *uint64_t v36 = v39;
      v36 += 3;
      ++v32;
      v37 += 2;
      v33 += 4;
    }

    while (v29 != v32);
  }

  else
  {
    size_t v35 = 0LL;
  }

  qsort(__base, v35, 6uLL, (int (__cdecl *)(const void *, const void *))sub_1000378A4);
  unint64_t v40 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v40)
  {
    uint64_t v41 = 0LL;
    uint64_t v42 = __base + 2;
    unsigned int v43 = v30;
    while (v43 > *(v42 - 1) + *(unsigned __int16 *)(a2 + 42))
    {
      int v44 = *v42;
      v42 += 3;
      v43 += v44;
      if (v40 == ++v41)
      {
        unint64_t v45 = *(unsigned int *)(a2 + 36);
        goto LABEL_49;
      }
    }

    unint64_t v45 = v41;
LABEL_49:
    if ((int)v45 >= 1)
    {
      uint64_t v46 = a2 + 56;
      unint64_t v47 = v45 + 1;
      LODWORD(v48) = v43;
      do
      {
        uint64_t v49 = &v31[6 * (v47 - 2)];
        size_t v50 = *((unsigned __int16 *)v49 + 2);
        uint64_t v48 = (v48 - v50);
        memmove( (void *)(v46 + v48),  (const void *)(v46 + *(unsigned __int16 *)(a2 + 42) + *((unsigned __int16 *)v49 + 1)),  v50);
        uint64_t v51 = *(unsigned __int16 *)v49;
        if ((*(_WORD *)(a2 + 32) & 4) != 0) {
          uint64_t v52 = 4 * v51;
        }
        else {
          uint64_t v52 = 8 * v51;
        }
        *(_WORD *)(v46 + v52) = v48 - v30;
        --v47;
        unsigned int v31 = (char *)__base;
      }

      while (v47 > 1);
      unint64_t v40 = *(unsigned int *)(a2 + 36);
    }
  }

  else
  {
    unint64_t v45 = 0LL;
    unint64_t v40 = 0LL;
    unsigned int v43 = v30;
  }

  if (v45 < v40)
  {
    uint64_t v53 = a2 + 56;
    uint64_t v54 = &v31[6 * v45 + 4];
    do
    {
      uint64_t v55 = *((unsigned __int16 *)v54 - 1);
      if (v55 != 0xFFFF)
      {
        memmove( (void *)(v53 + v43),  (const void *)(v53 + *(unsigned __int16 *)(a2 + 42) + v55),  *(unsigned __int16 *)v54);
        uint64_t v56 = *((unsigned __int16 *)v54 - 2);
        if ((*(_WORD *)(a2 + 32) & 4) != 0) {
          uint64_t v57 = 4 * v56;
        }
        else {
          uint64_t v57 = 8 * v56;
        }
        *(_WORD *)(v53 + v57) = v43 - v30;
        v43 += *(unsigned __int16 *)v54;
        unint64_t v40 = *(unsigned int *)(a2 + 36);
      }

      ++v45;
      v54 += 6;
    }

    while (v45 < v40);
  }

  *(_WORD *)(a2 + 42) = v30;
  *(_WORD *)(a2 + 44) = v43 - v30;
  *(_WORD *)(a2 + 46) = *(_WORD *)(a1 + 4)
                      - (v43
                       + *(_WORD *)(a2 + 46))
  *(void *)(a2 + 48) = 0xFFFF0000FFFFLL;
  free(v31);
}

uint64_t sub_1000363C8(int *a1, _WORD *a2, int a3, unsigned int a4, _WORD *a5)
{
  if (a4)
  {
    if (a4 == 65534)
    {
      LOWORD(v5) = -2;
    }

    else
    {
      int v6 = *a1;
      unsigned int v7 = a4 + 7;
      if (a5)
      {
        unsigned int v8 = v7 & 0xFFFFFFF8;
        if ((v6 & 0x40) != 0) {
          unsigned int v8 = a4;
        }
        uint64_t v9 = a2 + 26;
        if (!a3) {
          uint64_t v9 = a2 + 24;
        }
        uint64_t v5 = (unsigned __int16)*a5;
        if (a3)
        {
          uint64_t v10 = -40LL;
          if ((a2[16] & 1) == 0) {
            uint64_t v10 = 0LL;
          }
          uint64_t v11 = (_WORD *)((char *)a2 + a1[1] + v10 - v5);
        }

        else
        {
          uint64_t v11 = (_WORD *)((char *)a2 + (unsigned __int16)a2[21] + v5 + 56);
        }

        v9[1] -= v8;
        unsigned int v14 = (unsigned __int16)v11[1] - v8;
        if (v14 < 4)
        {
          *a5 = *v11;
        }

        else
        {
          v11[1] = v14;
          if (a3) {
            unsigned int v14 = -v14;
          }
          LOWORD(v5) = v5 + v14;
        }
      }

      else
      {
        __int16 v12 = v7 & 0xFFF8;
        if ((v6 & 0x40) != 0) {
          __int16 v12 = a4;
        }
        unsigned __int16 v13 = a2[23] - v12;
        a2[23] = v13;
        if (a3)
        {
          LODWORD(v5) = a1[1]
                      - (unsigned __int16)a2[22]
                      - ((unsigned __int16)a2[21]
                       + v13)
        }

        else
        {
          LOWORD(v5) = a2[22];
          a2[22] = v5 + v12;
        }
      }
    }
  }

  else
  {
    LOWORD(v5) = -1;
  }

  return (unsigned __int16)v5;
}

uint64_t sub_1000364F0(_DWORD *a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5, uint64_t a6)
{
  if (a1[11] != 2) {
    return 22LL;
  }
  unsigned int v7 = a5;
  uint64_t v9 = a3;
  uint64_t v36 = 0LL;
  __int128 __src = 0LL;
  size_t v35 = 0LL;
  if (a3)
  {
    if (a5) {
      goto LABEL_4;
    }
LABEL_12:
    unsigned int v7 = &unk_10006B3AE;
    if ((_DWORD)a6 != 65534 && (_DWORD)a6) {
      return 14LL;
    }
    goto LABEL_4;
  }

  if ((_DWORD)a4) {
    return 14LL;
  }
  uint64_t v9 = &unk_10006B3AD;
  if (!a5) {
    goto LABEL_12;
  }
LABEL_4:
  unsigned int v38 = (__int128 *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v12 = sub_100037698(a1, a2, 1LL, &__src, &v38);
  if ((_DWORD)v12) {
    goto LABEL_42;
  }
  if ((*((_WORD *)__src + 16) & 8) != 0)
  {
    uint64_t v12 = 45LL;
    goto LABEL_42;
  }

  int v13 = *(_DWORD *)v38;
  int v14 = *((_DWORD *)v38 + 1);
  int v16 = *((_DWORD *)v38 + 2);
  int v15 = *((_DWORD *)v38 + 3);
  int v17 = a1[9];
  if (v16)
  {
    if (v16 != (_DWORD)a4)
    {
LABEL_41:
      uint64_t v12 = 22LL;
      goto LABEL_42;
    }
  }

  else if (!(_DWORD)a4 || ((v14 - 160) >> 2) - v17 - 8 < a4)
  {
    goto LABEL_41;
  }

  if (v15 && v15 != (_DWORD)a6 && ((v13 & 4) == 0 || (_DWORD)a6 != 65534 && (_DWORD)a6)) {
    goto LABEL_41;
  }
  int v18 = (a4 + 7) & 0xFFFFFFF8;
  if ((v13 & 0x40) != 0) {
    int v18 = a4;
  }
  int v19 = (a6 + 7) & 0xFFFFFFF8;
  if ((v13 & 0x40) != 0) {
    int v19 = a6;
  }
  if ((_DWORD)a6 == 65534) {
    int v19 = 0;
  }
  unsigned int v20 = v19 + v18;
  unsigned int v21 = v14 - 160;
  unsigned int v22 = (v21 >> 2) - v17 - 8;
  unsigned int v23 = v16 - 1;
  if ((v13 & 0x40) != 0) {
    unsigned int v24 = *((_DWORD *)v38 + 2);
  }
  else {
    unsigned int v24 = (v16 + 7) & 0xFFFFFFF8;
  }
  unsigned int v25 = (v15 + 7) & 0xFFFFFFF8;
  if ((*(_DWORD *)v38 & 0x40) != 0) {
    unsigned int v25 = *((_DWORD *)v38 + 3);
  }
  if (v23 >= v22) {
    unsigned int v24 = v22;
  }
  unsigned int v26 = v24 + v25;
  if (v15) {
    unsigned int v27 = v26;
  }
  else {
    unsigned int v27 = v21;
  }
  if (v20 > v27)
  {
    uint64_t v12 = 34LL;
    goto LABEL_42;
  }

  uint64_t v12 = sub_1000378BC((uint64_t)a1, a2, v38, (uint64_t)__src, v9, a4, v7, a6, &v36, &v35, &v34);
  if ((_DWORD)v12)
  {
LABEL_42:
    uint64_t v28 = v35;
    if (v35) {
      goto LABEL_43;
    }
    goto LABEL_45;
  }

  if (!v36 || (uint64_t v28 = v35, v32 = sub_100037C1C((uint64_t)a1, a2, v38, (uint64_t)__src, v36, v35), !(_DWORD)v32))
  {
    signed int v33 = v38;
    sub_100037E18((uint64_t)a1, a2, (char *)__src, v30, v31);
    uint64_t v12 = 0LL;
    goto LABEL_42;
  }

  uint64_t v12 = v32;
  if (v28)
  {
LABEL_43:
    if (a1[10] != 0x8000000) {
      free(v28);
    }
  }

uint64_t sub_1000367BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  if (*(_DWORD *)(a1 + 44) == 2) {
    return sub_1000367D4(a1, a2, a3, a4, a5);
  }
  else {
    return 22LL;
  }
}

uint64_t sub_1000367D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  signed int v33 = (__int128 *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v28 = 0LL;
  __int128 __src = 0LL;
  uint64_t v10 = sub_100037698(a1, a2, 1LL, &__src, &v33);
  if ((_DWORD)v10) {
    goto LABEL_2;
  }
  uint64_t v11 = __src;
  if (*((unsigned __int16 *)__src + 17) >= a5)
  {
    if ((*((_WORD *)__src + 16) & 8) != 0)
    {
      uint64_t v10 = 45LL;
      goto LABEL_2;
    }

    char v27 = -86;
    __int128 v30 = *v33;
    uint64_t v13 = *(void *)(a1 + 56);
    unint64_t v31 = *(unsigned int *)(a1 + 36) | 0xAAAAAAAA00000000LL;
    uint64_t v32 = v13;
    uint64_t v14 = sub_100038F10(a1, a2, v33, (uint64_t)__src, a3, a4, &v28, &v27, a5);
    int v17 = v28;
    if ((_DWORD)v14)
    {
      uint64_t v10 = v14;
    }

    else
    {
      if (v28)
      {
        uint64_t v18 = sub_100037C1C(a1, a2, v33, (uint64_t)__src, v28, 0LL);
        if ((_DWORD)v18)
        {
          uint64_t v10 = v18;
LABEL_34:
          if (*(_DWORD *)(a1 + 40) != 0x8000000) {
            free(v17);
          }
LABEL_2:
          uint64_t v11 = __src;
          if (!__src) {
            return v10;
          }
          goto LABEL_6;
        }
      }

      int v19 = (unsigned __int16 *)__src;
      while (1)
      {
        int v20 = *((_DWORD *)v19 + 9);
        if (v20 != 1) {
          goto LABEL_29;
        }
        if ((v19[16] & 2) != 0) {
          goto LABEL_32;
        }
        int v21 = v19[17];
        unsigned int v22 = v33;
        __int128 v35 = *v33;
        int v23 = *(_DWORD *)(a1 + 36);
        uint64_t v24 = *(void *)(a1 + 56);
        int v37 = -1431655766;
        uint64_t v38 = v24;
        int v36 = v23;
        BOOL v34 = 0LL;
        uint64_t v25 = sub_1000370F0((unsigned int *)a1, a2, &v35, (uint64_t)v19, 0, 1, (uint64_t *)&v34);
        if ((_DWORD)v25) {
          break;
        }
        if (sub_100035CCC(&v35, v34, 0) >= 0x28)
        {
          sub_100038DE4((uint64_t)&v35, (uint64_t)v19, 0);
          if (v19[17] == 1) {
            char v26 = 3;
          }
          else {
            char v26 = 1;
          }
          sub_100038D38((unsigned int *)&v35, (uint64_t)v19, v26, v19[17] - 1);
          sub_100038B20(&v35, (uint64_t)v34, v19, 0, -1, 0, 0LL, 0, 0LL, 0);
          sub_10002BBB8(a1, *(unsigned int *)(a1 + 40), *((void *)v34 + 2), *((void *)v34 + 1));
          if (*(_DWORD *)(a1 + 40) != 0x8000000) {
            free(v34);
          }
          --*((void *)v22 + 4);
        }

        int v19 = (unsigned __int16 *)__src;
        if (*((unsigned __int16 *)__src + 17) == v21)
        {
          int v20 = *((_DWORD *)__src + 9);
LABEL_29:
          if (!v20 && (v19[16] & 2) == 0)
          {
            sub_100038D38((unsigned int *)&v30, (uint64_t)v19, 3, 0);
            int v19 = (unsigned __int16 *)__src;
          }

LABEL_32:
          sub_100037E18(a1, a2, (char *)v19, v15, v16);
          uint64_t v10 = 0LL;
          int v17 = v28;
          goto LABEL_33;
        }
      }

      uint64_t v10 = v25;
      if (v34 && *(_DWORD *)(a1 + 40) != 0x8000000) {
        free(v34);
      }
    }

  if ((void)v43) {
    ((void (*)(__int128 *))v43)(&v43);
  }
  if ((_DWORD)v15 == -1) {
    return 0LL;
  }
  else {
    return v15;
  }
}

uint64_t sub_100036AC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 44) == 2) {
    return sub_1000367D4(a1, a2, a3, a4, 0);
  }
  else {
    return 22LL;
  }
}

uint64_t sub_100036AE0(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(_DWORD *)(a1 + 44) != 2) {
    return 22LL;
  }
  unsigned int v7 = 0LL;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = sub_100037698(a1, a2, 0LL, &v7, &v8);
  if (!(_DWORD)v5) {
    *a3 = *(void *)(v8 + 24);
  }
  if (v7 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v7);
  }
  return v5;
}

uint64_t sub_100036B70(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(_DWORD *)(a1 + 44) != 2) {
    return 22LL;
  }
  unsigned int v7 = 0LL;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = sub_100037698(a1, a2, 0LL, &v7, &v8);
  if (!(_DWORD)v5) {
    *a3 = *(void *)(v8 + 32);
  }
  if (v7 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v7);
  }
  return v5;
}

uint64_t sub_100036C00(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(_DWORD *)(a1 + 44) == 2) {
    return sub_100036C18(a1, a2, a3);
  }
  else {
    return 22LL;
  }
}

uint64_t sub_100036C18(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  __int128 __src = 0LL;
  if (*(void *)(a1 + 56)) {
    return 17LL;
  }
  unsigned int v10 = a3;
  uint64_t v11 = *(void *)(a1 + 24);
  int v12 = *(_DWORD *)(a1 + 32);
  uint64_t result = sub_1000389F8(a1, a2, &v10, 3, 0, &__src);
  if (!(_DWORD)result)
  {
    unint64_t v8 = (char *)__src;
    ++*(void *)((char *)__src + *(unsigned int *)(a1 + 24) - 8);
    sub_100037E18(a1, a2, v8, v6, v7);
    *(void *)(a1 + 56) = *((void *)v8 + 1);
    if (*(_DWORD *)(a1 + 40) != 0x8000000) {
      free(v8);
    }
    return 0LL;
  }

  return result;
}

uint64_t sub_100036CD8(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 44) != 2) {
    return 22LL;
  }
  int8x16_t v7 = 0LL;
  if (!*(void *)(a1 + 56)) {
    return 0LL;
  }
  uint64_t v11 = (__int128 *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = sub_100037698(a1, a2, 1, &v7, &v11);
  if (!(_DWORD)v4)
  {
    __int128 v8 = *v11;
    uint64_t v5 = *(void *)(a1 + 56);
    unint64_t v9 = *(unsigned int *)(a1 + 36) | 0xAAAAAAAA00000000LL;
    uint64_t v10 = v5;
    uint64_t v4 = sub_1000391D0(a1, a2, &v8, (uint64_t)v7);
    if (!(_DWORD)v4) {
      *(void *)(a1 + 56) = 0LL;
    }
  }

  if (v7 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v7);
  }
  return v4;
}

uint64_t sub_100036DB8(unsigned int *a1, uint64_t a2, int a3, int a4)
{
  unsigned int v4 = *(unsigned __int16 *)(a2 + 32);
  if ((v4 & 0x10) != 0)
  {
    int v5 = 0;
    int v6 = 0;
    if ((a3 & 1) != 0)
    {
      if ((v4 & 1) == 0)
      {
LABEL_4:
        int v7 = 0;
        int v8 = v5 + 1;
        goto LABEL_24;
      }

      goto LABEL_12;
    }
  }

  else
  {
    int v9 = *(_DWORD *)(a2 + 28);
    unsigned int v10 = a1[12];
    BOOL v22 = v9 == v10;
    int v5 = v9 != v10;
    int v11 = *(unsigned __int16 *)(a2 + 24);
    if (v22) {
      int v12 = 1;
    }
    else {
      int v12 = 2;
    }
    if (a3)
    {
      if (v11 != 2) {
        int v5 = v12;
      }
      if ((v4 & 1) == 0) {
        goto LABEL_4;
      }
LABEL_12:
      uint64_t v13 = a1[6];
      uint64_t v14 = a2 + v13;
      int v15 = *(_DWORD *)(a2 + v13 - 40);
      if (*(_DWORD *)(a2 + v13 - 36) != (_DWORD)v13) {
        ++v5;
      }
      int v16 = *(_DWORD *)(v14 - 32);
      int v17 = *(_DWORD *)(v14 - 28);
      if (v16 != a1[7]) {
        ++v5;
      }
      if (v17 != a1[8]) {
        ++v5;
      }
      int v8 = v5 + (((v15 & 0x80) == 0) ^ (a1[13] == 0)) + (((v15 & 0x100) == 0) ^ (a1[13] == 0));
      int v7 = -40;
      goto LABEL_24;
    }

    if (v11 == 3) {
      int v6 = v5;
    }
    else {
      int v6 = v12;
    }
  }

  int v8 = v6 + (v4 & 1);
  int v7 = -40;
  if ((v4 & 1) == 0) {
    int v7 = 0;
  }
LABEL_24:
  int v18 = (a1[13] != 0) ^ ((v4 & 8) >> 3);
  int v19 = (v4 >> 3) & 1 ^ ((v4 & 0x10) >> 4);
  int v20 = (*(_WORD *)(a2 + 34) == 0) ^ ((v4 & 2) >> 1);
  unsigned int v21 = a1[6] + v7 - 56;
  BOOL v22 = (v4 & 4) == 0;
  if ((v4 & 4) != 0) {
    int v23 = 3;
  }
  else {
    int v23 = 7;
  }
  if (v22) {
    char v24 = 3;
  }
  else {
    char v24 = 2;
  }
  BOOL v25 = a4 == 61455 || *(unsigned __int16 *)(a2 + 34) == a4;
  int v26 = v8 + v19 + v18 + v20;
  if (!v25) {
    ++v26;
  }
  unsigned int v27 = *(unsigned __int16 *)(a2 + 42);
  if (*(_WORD *)(a2 + 40)) {
    ++v26;
  }
  if ((v23 & v27) != 0) {
    ++v26;
  }
  if (*(_DWORD *)(a2 + 36) <= v27 >> v24) {
    int v28 = v26;
  }
  else {
    int v28 = v26 + 1;
  }
  BOOL v29 = v21 >= v27;
  unsigned int v30 = v21 - v27;
  unsigned int v31 = *(unsigned __int16 *)(a2 + 44);
  if (!v29) {
    ++v28;
  }
  BOOL v29 = v30 >= v31;
  unsigned int v32 = v30 - v31;
  if (!v29) {
    ++v28;
  }
  else {
    int v33 = -1;
  }
  if (v28 == v33) {
    return 0LL;
  }
  else {
    return 92LL;
  }
}

uint64_t sub_100036F54(uint64_t result, int a2, unsigned int a3)
{
  if (result)
  {
    int v5 = (void *)result;
    uint64_t v6 = (16LL * a2) | 8;
    int v7 = calloc(1uLL, v6 + a3 * a2);
    *int v5 = v7;
    if (v7)
    {
      *(_DWORD *)int v7 = a2;
      v7[1] = (char *)v7 + v6;
      if (a2 >= 2)
      {
        uint64_t v8 = 0LL;
        do
        {
          *(void *)(*v5 + v8 + 24) = *(void *)(*v5 + v8 + 8) + a3;
          v8 += 16LL;
        }

        while (16LL * a2 - 16 != v8);
      }

      return 0LL;
    }

    else
    {
      return 12LL;
    }
  }

  return result;
}

uint64_t sub_100036FF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, int *a7)
{
  uint64_t result = sub_1000371B0(a1, a2, a3, a4, a5, a6, a7);
  if (!(_DWORD)result && !*a7 && *a6 >= 1) {
    --*a6;
  }
  return result;
}

uint64_t sub_100037038(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  if ((*(_WORD *)(a2 + 32) & 8) != 0) {
    int v7 = *(_DWORD *)(a1 + 16) + 8;
  }
  else {
    int v7 = 8;
  }
  int v11 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v10 = -1431655766;
  uint64_t result = sub_10003735C(a1, a2, a3, &v11, &v10);
  if (!(_DWORD)result)
  {
    uint64_t result = 92LL;
    if (v11)
    {
      if (v10 == v7)
      {
        uint64_t v9 = *v11;
        *a4 = *v11;
        uint64_t result = 0LL;
        if ((*(_WORD *)(a2 + 32) & 8) != 0) {
          *a4 = *(void *)(a1 + 24) + v9;
        }
      }
    }
  }

  return result;
}

uint64_t sub_1000370F0( unsigned int *a1, uint64_t a2, _DWORD *a3, uint64_t a4, unsigned int a5, int a6, uint64_t *a7)
{
  __int16 v12 = *(_WORD *)(a4 + 34);
  uint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100037038((uint64_t)a3, a4, a5, &v15);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10002B658(a1, a7, a1[10], a2, v15);
    if (!(_DWORD)result)
    {
      uint64_t v14 = *a7;
      uint64_t result = sub_100036DB8(a1, v14, 0, (unsigned __int16)(v12 - 1));
      if (!(_DWORD)result)
      {
        if (!a6) {
          return 0LL;
        }
        uint64_t result = sub_100037508(a3, v14);
        if (!(_DWORD)result) {
          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t sub_1000371B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, int *a7)
{
  int v9 = *(_DWORD *)(a3 + 36) - 1;
  if (v9 < 0)
  {
    int v21 = 0;
    int v15 = 0;
LABEL_18:
    uint64_t result = 0LL;
    *a6 = v15;
    *a7 = v21;
  }

  else
  {
    int v15 = 0;
    int v24 = -1431655766;
    unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
    unsigned int v22 = -1431655766;
    while (1)
    {
      int v16 = v9 + v15;
      if (v9 + v15 < 0 != __OFADD__(v9, v15)) {
        ++v16;
      }
      int v17 = v16 >> 1;
      uint64_t result = sub_1000372D4(a2, a3, v16 >> 1, &v23, &v22);
      if ((_DWORD)result) {
        break;
      }
      uint64_t v19 = *(void *)(a1 + 8);
      uint64_t v20 = v19 ? *(void *)(v19 + 40) : 0LL;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t, void, int *))(a1 + 16))( v20,  a4,  a5,  v23,  v22,  &v24);
      if ((_DWORD)result) {
        break;
      }
      if (!v24)
      {
        int v21 = 1;
        int v15 = v17;
        goto LABEL_18;
      }

      if (v24 < 0) {
        int v9 = v17 - 1;
      }
      else {
        int v15 = v17 + 1;
      }
      if (v15 > v9)
      {
        int v21 = 0;
        goto LABEL_18;
      }
    }
  }

  return result;
}

uint64_t sub_1000372D4(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, _DWORD *a5)
{
  if ((a3 & 0x80000000) != 0 || *(_DWORD *)(a2 + 36) <= a3) {
    return 22LL;
  }
  __int16 v5 = *(_WORD *)(a2 + 32);
  uint64_t v6 = a2 + 56;
  int v7 = (unsigned __int16 *)(a2 + 56 + 4LL * a3);
  if ((v5 & 4) == 0) {
    int v7 = (unsigned __int16 *)(a2 + 56 + 8LL * a3);
  }
  unsigned int v8 = *v7;
  unsigned int v9 = *(unsigned __int16 *)(a2 + 44);
  BOOL v10 = v9 >= v8;
  unsigned int v11 = v9 - v8;
  if (v11 == 0 || !v10) {
    return 92LL;
  }
  *a4 = v6 + *(unsigned __int16 *)(a2 + 42) + v8;
  if ((v5 & 4) != 0) {
    LODWORD(v6) = *(_DWORD *)(a1 + 8);
  }
  else {
    LOWORD(v6) = *(_WORD *)(v6 + 8LL * a3 + 2);
  }
  uint64_t result = 0LL;
  *a5 = (unsigned __int16)v6;
  return result;
}

uint64_t sub_10003735C(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, unsigned int *a5)
{
  if ((a3 & 0x80000000) != 0) {
    return 22LL;
  }
  if (*(_DWORD *)(a2 + 36) <= a3) {
    return 22LL;
  }
  int v5 = *(unsigned __int16 *)(a2 + 32);
  uint64_t v6 = (unsigned __int16 *)(a2 + 56 + 8LL * a3 + 4);
  if ((v5 & 4) != 0) {
    uint64_t v6 = (unsigned __int16 *)(a2 + 56 + 4LL * a3 + 2);
  }
  uint64_t v7 = *v6;
  uint64_t v8 = *(unsigned int *)(a1 + 4);
  unsigned int v9 = v8
     + ((v5 << 31 >> 31) & 0xFFFFFFD8)
     - (*(unsigned __int16 *)(a2 + 42)
      + *(unsigned __int16 *)(a2 + 44)
  uint64_t v12 = a2 + v8;
  BOOL v13 = (v5 & 1) == 0;
  uint64_t v14 = -40LL;
  if (v13) {
    uint64_t v14 = 0LL;
  }
  uint64_t v15 = v12 + v14 - v7;
  *a4 = v15;
  unsigned int v16 = sub_100035C54(a1, a2, a3);
  unsigned int v17 = v16;
  uint64_t result = 0LL;
  *a5 = v17;
  return result;
}

uint64_t sub_10003744C( void *__src, size_t __n, const void *a3, unsigned int a4, void *__dst, _DWORD *a6, void *a7, unsigned int *a8)
{
  int v13 = __n;
  if (a4 == 65534)
  {
    unsigned int v14 = 0;
  }

  else
  {
    if (!a3 && a4) {
      return 92LL;
    }
    unsigned int v14 = a4;
    if (*a8 < a4) {
      return 34LL;
    }
  }

  memcpy(__dst, __src, __n);
  memcpy(a7, a3, v14);
  uint64_t result = 0LL;
  *a6 = v13;
  *a8 = a4;
  return result;
}

uint64_t sub_100037508(_DWORD *a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 44);
  int v3 = *(unsigned __int16 *)(a2 + 32);
  unsigned int v4 = a1[1]
     - *(unsigned __int16 *)(a2 + 46)
     - (v2
      + *(unsigned __int16 *)(a2 + 42))
     + ((v3 << 31 >> 31) & 0xFFFFFFD8)
     - 56;
  if ((v3 & 2) != 0)
  {
    unsigned int v6 = a1[3];
    if (v6)
    {
      int v5 = (*(unsigned __int8 *)a1 >> 2) & 1;
      if ((v3 & 4) == 0) {
        goto LABEL_6;
      }
    }

    else
    {
      LOBYTE(v5) = 1;
      if ((v3 & 4) == 0)
      {
LABEL_6:
        uint64_t v7 = *(unsigned int *)(a2 + 36);
        if ((_DWORD)v7)
        {
          for (unint64_t i = (unsigned __int16 *)(a2 + 62); ; i += 4)
          {
            unsigned int v9 = *(i - 3);
            if (v2 <= v9) {
              break;
            }
            unsigned int v10 = *(i - 2);
            if ((*a1 & 0x40) == 0) {
              unsigned int v10 = (v10 + 7) & 0x1FFF8;
            }
            if (v10 > v2 - v9) {
              break;
            }
            unsigned int v11 = *(i - 1);
            char v12 = v11 > 0xFFFD ? v5 : 0;
            if ((v12 & 1) == 0)
            {
              if (v4 < v11) {
                break;
              }
              unsigned int v13 = (*a1 & 0x40) != 0 ? *i : (*i + 7) & 0x1FFF8;
              if (v13 > v11) {
                break;
              }
            }

            if (!--v7) {
              return v7;
            }
          }

          return 92LL;
        }

        return v7;
      }
    }

    unsigned int v14 = a1[2];
    goto LABEL_28;
  }

  if ((v3 & 4) == 0)
  {
    LOBYTE(v5) = 0;
    goto LABEL_6;
  }

  unsigned int v14 = a1[2];
  LOBYTE(v5) = 0;
  if ((v3 & 8) != 0) {
    unsigned int v6 = a1[4] + 8;
  }
  else {
    unsigned int v6 = 8;
  }
LABEL_28:
  uint64_t v15 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v15)
  {
    for (j = (unsigned __int16 *)(a2 + 58); ; j += 2)
    {
      unsigned int v17 = *(j - 1);
      if (v2 <= v17) {
        break;
      }
      unsigned int v18 = (*a1 & 0x40) != 0 ? v14 : (v14 + 7) & 0xFFFFFFF8;
      if (v18 > v2 - v17) {
        break;
      }
      unsigned int v19 = *j;
      if (v19 > 0xFFFD) {
        char v20 = v5;
      }
      else {
        char v20 = 0;
      }
      if ((v20 & 1) == 0)
      {
        unsigned int v21 = (*a1 & 0x40) != 0 ? v6 : (v6 + 7) & 0xFFFFFFF8;
        uint64_t v7 = 92LL;
        if (v4 < v19 || v21 > v19) {
          return v7;
        }
      }

      if (!--v15) {
        return 0LL;
      }
    }

    return 92LL;
  }

  return 0LL;
}

uint64_t sub_100037698(uint64_t a1, uint64_t a2, int a3, void **a4, void *a5)
{
  uint64_t result = sub_10002B658((uint64_t **)a1, a4, *(_DWORD *)(a1 + 40), a2, *(void *)(a1 + 56));
  if (!(_DWORD)result)
  {
    unsigned int v10 = (char *)*a4;
    uint64_t result = sub_100036DB8((unsigned int *)a1, (uint64_t)v10, 1, 61455);
    if (!(_DWORD)result)
    {
      unsigned int v11 = &v10[*(unsigned int *)(a1 + 24)];
      __int128 v13 = *(_OWORD *)(v11 - 40);
      uint64_t v12 = *(void *)(a1 + 56);
      unint64_t v14 = *(unsigned int *)(a1 + 36) | 0xAAAAAAAA00000000LL;
      uint64_t v15 = v12;
      if (!a3 || (uint64_t result = sub_100037508(&v13, (uint64_t)v10), !(_DWORD)result))
      {
        uint64_t result = 0LL;
        if (a5) {
          *a5 = v11 - 40;
        }
      }
    }
  }

  return result;
}

uint64_t sub_10003775C(uint64_t a1, int a2)
{
  unsigned int v2 = *(_DWORD **)(a1 + 72);
  if (*v2 <= a2) {
    return 2LL;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  __int128 v12 = *(_OWORD *)*(void *)(a1 + 64);
  int v5 = *(_DWORD *)(v4 + 36);
  uint64_t v6 = *(void *)(v4 + 56);
  int v14 = -1431655766;
  uint64_t v15 = v6;
  int v13 = v5;
  uint64_t v7 = &v2[4 * a2];
  uint64_t v9 = *((void *)v7 + 1);
  uint64_t v8 = (uint64_t *)(v7 + 2);
  LODWORD(v6) = *((_DWORD *)v8 + 2) + 1;
  *((_DWORD *)v8 + 2) = v6;
  if ((_DWORD)v6 != *(_DWORD *)(v9 + 36)) {
    return 0LL;
  }
  uint64_t v10 = a2 + 1LL;
  uint64_t result = sub_10003775C(a1, v10);
  if (!(_DWORD)result)
  {
    *((_DWORD *)v8 + 2) = 0;
    uint64_t result = sub_1000370F0( *(unsigned int **)(a1 + 48),  *(void *)(a1 + 56),  &v12,  *(void *)(*(void *)(a1 + 72) + 16 * v10 + 8),  *(_DWORD *)(*(void *)(a1 + 72) + 16 * v10 + 16),  0,  v8);
    if (!(_DWORD)result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100037830(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v3 = (a3 + *(_DWORD *)(a2 + 36) + 7) & 0xFFFFFFF8;
  __int16 v4 = *(_WORD *)(a2 + 32);
  if ((v4 & 4) == 0) {
    return 8 * v3;
  }
  if ((v4 & 2) != 0)
  {
    int v6 = *(_DWORD *)(a1 + 12);
  }

  else if ((v4 & 8) != 0)
  {
    int v6 = *(_DWORD *)(a1 + 16) + 8;
  }

  else
  {
    int v6 = 8;
  }

  if (((((unint64_t)*(unsigned int *)(a1 + 4) - 56)
       / ((unint64_t)(v6 + *(_DWORD *)(a1 + 8)) + 4)) & 0xFFFFFFFE) > v3)
  if ((*(_BYTE *)a1 & 4) == 0) {
  return 4 * v3;
  }
}

uint64_t sub_1000378A4(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 2);
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_1000378BC( uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, const void *a5, uint64_t a6, const void *a7, uint64_t a8, void **a9, void **a10, BOOL *a11)
{
  int v43 = -1431655766;
  unsigned int v44 = -1431655766;
  *a10 = 0LL;
  *a9 = 0LL;
  int v17 = *(_DWORD *)(a1 + 36);
  uint64_t v18 = *(void *)(a1 + 56);
  int v37 = -1431655766;
  uint64_t v38 = v18;
  int v36 = v17;
  uint64_t v42 = 0LL;
  unint64_t v40 = 0LL;
  uint64_t v41 = 0LL;
  unsigned __int8 v39 = 0;
  __int128 v35 = *a3;
  if ((*(_BYTE *)(a4 + 32) & 2) != 0)
  {
    uint64_t v20 = sub_1000371B0(a1, (uint64_t)&v35, a4, (uint64_t)a5, a6, (int *)&v44, &v43);
    if ((_DWORD)v20) {
      goto LABEL_9;
    }
    int v30 = v44;
    if (v43)
    {
      if (!sub_10003584C((uint64_t)&v35, (unsigned __int16 *)a4, v44, a5, a6, a7, a8))
      {
        uint64_t v20 = sub_100038378(a1, a3, a4, v30, 1, a5, a6, a7, a8, a9, a10);
        if ((_DWORD)v20) {
          goto LABEL_9;
        }
      }

      unsigned int v33 = v30;
      int v25 = 0;
      unint64_t v23 = 0LL;
      int v24 = 0LL;
    }

    else
    {
      if ((sub_1000381DC((int *)&v35, a4, v44, a5, a6, a7, a8) & 1) == 0)
      {
        uint64_t v20 = sub_100038378(a1, a3, a4, v30, 0, a5, a6, a7, a8, a9, a10);
        if ((_DWORD)v20) {
          goto LABEL_9;
        }
      }

      unsigned int v33 = v30;
      int v25 = 0;
      unint64_t v23 = 0LL;
      int v24 = 0LL;
      ++*((void *)a3 + 3);
    }
  }

  else
  {
    uint64_t v20 = sub_100036FF8(a1, (uint64_t)&v35, a4, (uint64_t)a5, a6, (int *)&v44, &v43);
    if ((_DWORD)v20) {
      goto LABEL_9;
    }
    unsigned int v21 = v44;
    uint64_t v20 = sub_1000370F0((unsigned int *)a1, a2, &v35, a4, v44, 1, (uint64_t *)&v42);
    if ((_DWORD)v20) {
      goto LABEL_9;
    }
    unsigned int v33 = v21;
    uint64_t v22 = sub_1000378BC(a1, a2, a3, v42, a5, a6, a7, a8, &v41, &v40, &v39);
    unint64_t v23 = v40;
    if ((_DWORD)v22
      || (int v24 = v41,
          int v25 = v39,
          uint64_t v22 = sub_100037EF4(a1, a3, a4, v33, (uint64_t)v42, (uint64_t)v41, (uint64_t)v40, v39, a9),
          (_DWORD)v22))
    {
      uint64_t v20 = v22;
      if (!v23) {
        goto LABEL_9;
      }
      goto LABEL_37;
    }
  }

  __int16 v31 = *(_WORD *)(a4 + 32);
  if ((v31 & 1) == 0 && ((v31 & 2) != 0 || v24 || v23 || v25)) {
    sub_100037E18(a1, a2, (char *)a4, v26, v27);
  }
  if (*a9) {
    sub_100037E18(a1, a2, (char *)*a9, v26, v27);
  }
  if (*a10) {
    sub_100037E18(a1, a2, (char *)*a10, v26, v27);
  }
  if (v33) {
    BOOL v32 = 0;
  }
  else {
    BOOL v32 = (*(_WORD *)(a4 + 32) & 2 | v25) != 0;
  }
  uint64_t v20 = 0LL;
  *a11 = v32;
  if (v23)
  {
LABEL_37:
    if (*(_DWORD *)(a1 + 40) != 0x8000000) {
      free(v23);
    }
  }

LABEL_9:
  if (v41 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v41);
  }
  if (v42 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v42);
  }
  return v20;
}

  if (v64) {
    free(v64);
  }
  return v12;
}

uint64_t sub_100037C1C(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, _WORD *a5, _WORD *a6)
{
  v29[0] = 0LL;
  v29[1] = a5;
  _OWORD v29[2] = a6;
  __int128 v25 = *a3;
  int v10 = *(_DWORD *)(a1 + 36);
  uint64_t v11 = *(void *)(a1 + 56);
  int v27 = -1431655766;
  uint64_t v28 = v11;
  int v26 = v10;
  uint64_t v12 = sub_1000389F8(a1, *(void *)(a4 + 16), (unsigned int *)&v25, *(_WORD *)(a4 + 32) & 2, *(_WORD *)(a4 + 34), v29);
  int v13 = v29[0];
  if ((_DWORD)v12)
  {
LABEL_2:
    if (v13)
    {
      sub_10002BBB8(a1, *(unsigned int *)(a1 + 40), v13[2], v13[1]);
      if (*(_DWORD *)(a1 + 40) != 0x8000000) {
        free(v13);
      }
    }
  }

  else
  {
    sub_100038B20(&v25, a4, v29[0], 0, -1, 0, 0LL, 0, 0LL, 0);
    sub_100037E18(a1, a2, (char *)v13, v14, v15);
    sub_100038D38((unsigned int *)&v25, a4, 1, *(_WORD *)(a4 + 34) + 1);
    uint64_t v16 = 0LL;
    unsigned int v17 = WORD4(v25);
    do
    {
      uint64_t v18 = v29[v16];
      if (!v18) {
        break;
      }
      if (!*((_DWORD *)v18 + 9))
      {
        uint64_t v12 = 22LL;
        goto LABEL_2;
      }

      unsigned int v19 = (unsigned __int16)v18[28];
      unsigned int v20 = (unsigned __int16)v18[22];
      BOOL v21 = v20 >= v19;
      unsigned int v22 = v20 - v19;
      if (v22 == 0 || !v21) {
        goto LABEL_18;
      }
      unsigned int v23 = v17;
      if ((v18[16] & 4) == 0) {
        unsigned int v23 = (unsigned __int16)v18[29];
      }
      if (v22 < v23)
      {
LABEL_18:
        uint64_t v12 = 92LL;
        goto LABEL_2;
      }

      sub_1000381DC( (int *)&v25,  a4,  v16++,  (char *)v18 + (unsigned __int16)v18[21] + (unsigned __int16)v18[28] + 56,  v23,  v18 + 4,  8u);
    }

    while (v16 != 3);
    ++*((void *)a3 + 4);
    if (*(_DWORD *)(a1 + 40) != 0x8000000) {
      free(v13);
    }
    return 0LL;
  }

  return v12;
}

uint64_t sub_100037E18(uint64_t a1, uint64_t a2, char *__src, int8x16_t a4, int8x16_t a5)
{
  int v8 = *(_DWORD *)(a1 + 40);
  if (v8)
  {
LABEL_2:
    int v9 = 0x8000000;
    if (v8 == 0x8000000) {
      return sub_10002B81C((uint64_t **)a1, __src, v9, a2, *((void *)__src + 1));
    }
    goto LABEL_7;
  }

  int v10 = *(void **)(a1 + 8);
  if (!v10 || (unint64_t v11 = v10[8]) == 0 || *((void *)__src + 2) > v11)
  {
LABEL_7:
    sub_10003A1B8( (unint64_t *)__src,  (uint32x4_t *)(__src + 8),  (*(_DWORD *)(a1 + 24) - 8),  0LL,  a4,  a5);
    int v9 = *(_DWORD *)(a1 + 40);
    return sub_10002B81C((uint64_t **)a1, __src, v9, a2, *((void *)__src + 1));
  }

  uint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = v10[7];
  if (!v13) {
    uint64_t v13 = *(void *)(v10[5] + 16LL);
  }
  uint64_t result = sub_10002B9C4((uint64_t **)a1, 0LL, 0, v13, *((void *)__src + 1), &v14);
  if (!(_DWORD)result)
  {
    *((void *)__src + 2) = v13;
    int v8 = *(_DWORD *)(a1 + 40);
    goto LABEL_2;
  }

  return result;
}

uint64_t sub_100037EF4( uint64_t a1, __int128 *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, void **a9)
{
  *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v55[1] = v12;
  v55[2] = v12;
  __int128 v54 = v12;
  v55[0] = v12;
  int v13 = *((_DWORD *)a2 + 2);
  if (a8)
  {
    if (!*(_DWORD *)(a5 + 36)) {
      return 22LL;
    }
    unsigned int v14 = *(unsigned __int16 *)(a5 + 56);
    unsigned int v15 = *(unsigned __int16 *)(a5 + 44);
    BOOL v16 = v15 >= v14;
    unsigned int v17 = v15 - v14;
    if (v17 == 0 || !v16) {
      return 92LL;
    }
    if ((*(_WORD *)(a5 + 32) & 4) != 0) {
      int v18 = *((_DWORD *)a2 + 2);
    }
    else {
      LOWORD(v18) = *(_WORD *)(a5 + 58);
    }
    __int128 v54 = a5 + 56 + *(unsigned __int16 *)(a5 + 42) + (unint64_t)*(unsigned __int16 *)(a5 + 56);
    *(void *)&v55[0] = (unsigned __int16)v18;
    *((void *)&v55[0] + 1) = a4 | 0xAAAAAA0100000000LL;
    unsigned int v19 = 1;
  }

  else
  {
    unsigned int v19 = 0;
  }

  unint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  if (!a6) {
    goto LABEL_20;
  }
  if (!*(_DWORD *)(a6 + 36)) {
    return 22LL;
  }
  unsigned int v20 = *(unsigned __int16 *)(a6 + 56);
  unsigned int v21 = *(unsigned __int16 *)(a6 + 44);
  BOOL v16 = v21 >= v20;
  unsigned int v22 = v21 - v20;
  if (v22 == 0 || !v16) {
    return 92LL;
  }
  unsigned __int16 v23 = (*(_WORD *)(a6 + 32) & 4) != 0 ? v13 : *(_WORD *)(a6 + 58);
  if (v22 < v23) {
    return 92LL;
  }
  uint64_t v24 = a6 + 56 + *(unsigned __int16 *)(a6 + 42) + *(unsigned __int16 *)(a6 + 56);
  unint64_t v48 = *(void *)(a6 + 8);
  uint64_t v25 = v19++;
  int v26 = &v55[2 * v25 - 1];
  *(void *)int v26 = v24;
  *((void *)v26 + 1) = &v48;
  *((_DWORD *)v26 + 4) = v23;
  *((_DWORD *)v26 + 5) = 8;
  *((void *)v26 + 3) = (a4 + 1) | 0xAAAAAA0000000000LL;
LABEL_20:
  unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
  if (a7)
  {
    if (*(_DWORD *)(a7 + 36))
    {
      unsigned int v27 = *(unsigned __int16 *)(a7 + 56);
      unsigned int v28 = *(unsigned __int16 *)(a7 + 44);
      BOOL v16 = v28 >= v27;
      unsigned int v29 = v28 - v27;
      if (v29 == 0 || !v16) {
        return 92LL;
      }
      if ((*(_WORD *)(a7 + 32) & 4) == 0) {
        LOWORD(v13) = *(_WORD *)(a7 + 58);
      }
      uint64_t v31 = a7 + 56 + *(unsigned __int16 *)(a7 + 42) + *(unsigned __int16 *)(a7 + 56);
      unint64_t v47 = *(void *)(a7 + 8);
      uint64_t v32 = v19++;
      unsigned int v33 = &v55[2 * v32 - 1];
      *(void *)unsigned int v33 = v31;
      *((void *)v33 + 1) = &v47;
      *((_DWORD *)v33 + 4) = (unsigned __int16)v13;
      *((_DWORD *)v33 + 5) = 8;
      *((void *)v33 + 3) = (a4 + 2) | 0xAAAAAA0000000000LL;
      goto LABEL_30;
    }

    return 22LL;
  }

uint64_t sub_1000381DC( int *a1, uint64_t a2, int a3, const void *a4, unsigned int a5, const void *a6, unsigned int a7)
{
  int v13 = ((*a1 & 4) == 0) & (*(unsigned __int16 *)(a2 + 32) >> 2);
  if ((*a1 & 0x40) != 0) {
    unsigned int v14 = a5;
  }
  else {
    unsigned int v14 = (a5 + 7) & 0xFFFFFFF8;
  }
  unsigned int v15 = (a7 + 7) & 0xFFFFFFF8;
  if ((*a1 & 0x40) != 0) {
    unsigned int v15 = a7;
  }
  if (a7 == 65534) {
    unsigned int v16 = 0;
  }
  else {
    unsigned int v16 = v15;
  }
  unsigned int v17 = sub_100035CCC(a1, (_WORD *)a2, 1);
  uint64_t result = 0LL;
  if (v17 >= v16 + v14)
  {
    unsigned int v19 = a6;
    unsigned int v20 = sub_100035E48(a1, (unsigned __int16 *)a2, 0, a5);
    uint64_t v25 = a4;
    if (v20) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = v14;
    }
    unsigned int v22 = sub_100035E48(a1, (unsigned __int16 *)a2, 1, a7);
    if (v22) {
      unsigned int v23 = 0;
    }
    else {
      unsigned int v23 = v16;
    }
    if (v21 + v23 > *(unsigned __int16 *)(a2 + 46)
      || (uint64_t v24 = v22, (v13 & 1) == 0) && sub_100037830((uint64_t)a1, a2, 1) > *(unsigned __int16 *)(a2 + 42))
    {
      sub_100035FC4((uint64_t)a1, a2, 1);
      unsigned int v20 = 0LL;
      uint64_t v24 = 0LL;
    }

    sub_1000388A8((uint64_t)a1, a2, a3, v25, a5, v20, v19, a7, v24);
    return 1LL;
  }

  return result;
}

uint64_t sub_100038378( uint64_t a1, _OWORD *a2, uint64_t a3, int a4, int a5, const void *a6, unsigned int a7, const void *a8, unsigned int a9, void **a10, void **a11)
{
  unsigned int v16 = a2;
  uint64_t v17 = a1;
  int v18 = a11;
  __int128 v72 = *a2;
  int v19 = *(_DWORD *)(a1 + 36);
  uint64_t v20 = *(void *)(a1 + 56);
  int v74 = -1431655766;
  uint64_t v75 = v20;
  int v73 = v19;
  *a11 = 0LL;
  *a10 = 0LL;
  uint64_t v21 = sub_1000389F8(a1, *(void *)(a3 + 16), (unsigned int *)&v72, *(_WORD *)(a3 + 32) & 2, *(_WORD *)(a3 + 34), a10);
  if ((_DWORD)v21)
  {
LABEL_2:
    if (*v18)
    {
      sub_10002BBB8(v17, *(_DWORD *)(v17 + 40), *((void *)*v18 + 2), *((void *)*v18 + 1));
      if (*(_DWORD *)(v17 + 40) != 0x8000000) {
        free(*v18);
      }
      *int v18 = 0LL;
    }

    if (*a10)
    {
      sub_10002BBB8(v17, *(_DWORD *)(v17 + 40), *((void *)*a10 + 2), *((void *)*a10 + 1));
      if (*(_DWORD *)(v17 + 40) != 0x8000000) {
        free(*a10);
      }
      *a10 = 0LL;
    }

    return v21;
  }

  if (a6)
  {
    unsigned int v22 = (a7 + 7) & 0xFFFFFFF8;
    if ((v72 & 0x40) != 0) {
      unsigned int v22 = a7;
    }
    unsigned int v68 = v22;
    if (a5)
    {
      if ((*(_WORD *)(a3 + 32) & 4) != 0) {
        unsigned __int16 v23 = WORD4(v72);
      }
      else {
        unsigned __int16 v23 = *(_WORD *)(a3 + 8LL * a4 + 58);
      }
      if ((v72 & 0x40) != 0) {
        int v24 = v23;
      }
      else {
        int v24 = (v23 + 7) & 0x1FFF8;
      }
      int v67 = v24;
      goto LABEL_23;
    }
  }

  else
  {
    unsigned int v68 = 0;
  }

  int v67 = 0;
LABEL_23:
  uint64_t v62 = v17;
  if (a8)
  {
    if (a9 == 65534)
    {
      unsigned int v25 = 0;
    }

    else
    {
      unsigned int v25 = (a9 + 7) & 0xFFFFFFF8;
      if ((v72 & 0x40) != 0) {
        unsigned int v25 = a9;
      }
    }

    v68 += v25;
    if (a5)
    {
      int v26 = sub_100035C54((uint64_t)&v72, a3, a4);
      if (v26 == 65534)
      {
        int v27 = 0;
      }

      else
      {
        int v27 = (v26 + 7) & 0x1FFF8;
        if ((v72 & 0x40) != 0) {
          int v27 = v26;
        }
      }

      v67 += v27;
    }
  }

  int v28 = *(_DWORD *)(a3 + 36);
  int v70 = v28 - 1;
  if (v28 - 1 < 0)
  {
LABEL_95:
    int v18 = a11;
    uint64_t v17 = v62;
    uint64_t v21 = sub_1000389F8( v62,  *(void *)(a3 + 16),  (unsigned int *)&v72,  *(_WORD *)(a3 + 32) & 2,  *(_WORD *)(a3 + 34),  a11);
    if (!(_DWORD)v21)
    {
      sub_100038B20(&v72, a3, *a11, a5 + a4, a4, a5, a6, a7, a8, a9);
      sub_100038B20(&v72, a3, *a10, a5 + a4 - 1, a4, a5, a6, a7, a8, a9);
      uint64_t v21 = 0LL;
      uint64_t v56 = *((void *)v16 + 4) + 2LL;
      goto LABEL_101;
    }

    goto LABEL_2;
  }

  int v58 = a8;
  unsigned int v59 = a6;
  unsigned int v60 = a7;
  unsigned int v61 = v16;
  int v29 = 0;
  int v30 = 0;
  unsigned int v64 = 0;
  int v65 = WORD4(v72);
  char v69 = v72;
  signed int v66 = -1;
  int v31 = 1;
  unsigned int v63 = -1;
  do
  {
    int v32 = v70 + v29;
    if (a4 - v28 == v29)
    {
      if ((a5 & 1) != 0) {
        goto LABEL_90;
      }
    }

    else
    {
      if (v32 >= a4) {
        unsigned int v33 = v70 + v29;
      }
      else {
        unsigned int v33 = v32 + 1;
      }
      int v34 = v65;
      if ((*(_WORD *)(a3 + 32) & 4) == 0) {
        int v34 = *(unsigned __int16 *)(a3 + 56 + 8LL * v33 + 2);
      }
      int v35 = sub_100035C54((uint64_t)&v72, a3, v33);
      if ((v69 & 0x40) != 0) {
        int v36 = v34;
      }
      else {
        int v36 = (v34 + 7) & 0x1FFF8;
      }
      int v37 = (v35 + 7) & 0x1FFF8;
      if ((v69 & 0x40) != 0) {
        int v37 = v35;
      }
      if (v35 == 65534) {
        int v37 = 0;
      }
      v30 += v36 + v37;
    }

    if (a4 - v28 + 1 == v29) {
      int v38 = a5;
    }
    else {
      int v38 = 0;
    }
    if (v32 >= a4) {
      int v39 = a5;
    }
    else {
      int v39 = 0;
    }
    if (v32 < a4) {
      int v40 = a5;
    }
    else {
      int v40 = 0;
    }
    if (v32 < a4) {
      int v41 = 1;
    }
    else {
      int v41 = v38;
    }
    int v42 = v31 - v40;
    unsigned int v43 = sub_100035CCC(&v72, (_WORD *)a3, v29 - v39) + v30;
    unsigned int v44 = sub_100035CCC(&v72, *a10, v42) - v30;
    if (v41) {
      unsigned int v45 = v44;
    }
    else {
      unsigned int v45 = v43;
    }
    unsigned int v46 = v45 + v67;
    BOOL v52 = v46 >= v68;
    unsigned int v47 = v46 - v68;
    if (v52)
    {
      if ((v69 & 2) != 0)
      {
        unsigned int v54 = v64;
        BOOL v55 = v47 > v64;
        if (v47 > v64) {
          unsigned int v54 = v47;
        }
        unsigned int v64 = v54;
        signed int v53 = v66;
        if (v55) {
          signed int v53 = v70 + v29;
        }
      }

      else
      {
        if (v41) {
          unsigned int v48 = v43;
        }
        else {
          unsigned int v48 = v47;
        }
        if (v41) {
          unsigned int v44 = v47;
        }
        if (v48 <= v44) {
          unsigned int v49 = v44;
        }
        else {
          unsigned int v49 = v48;
        }
        if (v48 < v44) {
          unsigned int v44 = v48;
        }
        unsigned int v50 = v49 - v44;
        unsigned int v51 = v63;
        BOOL v52 = v50 >= v63;
        if (v50 < v63) {
          unsigned int v51 = v50;
        }
        unsigned int v63 = v51;
        signed int v53 = v66;
        if (!v52) {
          signed int v53 = v70 + v29;
        }
      }

      signed int v66 = v53;
    }

LABEL_90:
    --v29;
    ++v31;
  }

  while (v28 + v29 > 0);
  unsigned int v16 = v61;
  a7 = v60;
  a8 = v58;
  a6 = v59;
  if (v66 == -1) {
    goto LABEL_95;
  }
  sub_100038B20(&v72, a3, *a10, v66, a4, a5, v59, v60, v58, a9);
  if (v66 < a4 || (a5 & 1) != 0)
  {
    if (v66 > a4 && a5) {
      sub_10003584C((uint64_t)&v72, (unsigned __int16 *)a3, a4, v59, v60, v58, a9);
    }
  }

  else
  {
    sub_1000381DC((int *)&v72, a3, a4, v59, v60, v58, a9);
  }

  uint64_t v21 = 0LL;
  uint64_t v56 = *((void *)v61 + 4) + 1LL;
LABEL_101:
  *((void *)v16 + 4) = v56;
  return v21;
}

void *sub_1000388A8( uint64_t a1, uint64_t a2, int a3, const void *a4, unsigned int a5, _WORD *a6, const void *a7, unsigned int a8, _WORD *a9)
{
  unsigned int v16 = sub_1000363C8((int *)a1, (_WORD *)a2, 0, a5, a6);
  unsigned int v17 = sub_1000363C8((int *)a1, (_WORD *)a2, 1, a8, a9);
  uint64_t v18 = a2 + 56;
  memcpy((void *)(a2 + 56 + *(unsigned __int16 *)(a2 + 42) + v16), a4, a5);
  if (a7)
  {
    if (v17 != 0xFFFF && v17 != 65534)
    {
      uint64_t v20 = -40LL;
      if ((*(_WORD *)(a2 + 32) & 1) == 0) {
        uint64_t v20 = 0LL;
      }
      memcpy((void *)(a2 + *(unsigned int *)(a1 + 4) + v20 - v17), a7, a8);
    }
  }

  uint64_t v21 = a3;
  uint64_t v22 = a3 + 1LL;
  uint64_t v23 = (*(_DWORD *)(a2 + 36) - a3);
  if ((*(_WORD *)(a2 + 32) & 4) != 0)
  {
    int v26 = (_WORD *)(v18 + 4LL * a3);
    uint64_t result = memmove((void *)(v18 + 4 * v22), v26, 4 * v23);
    *int v26 = v16;
    v26[1] = v17;
  }

  else
  {
    int v24 = (_WORD *)(v18 + 8LL * a3);
    uint64_t result = memmove((void *)(v18 + 8 * v22), (const void *)(v18 + 8 * v21), 8 * v23);
    *int v24 = v16;
    v24[1] = a5;
    v24[2] = v17;
    v24[3] = a8;
  }

  ++*(_DWORD *)(a2 + 36);
  return result;
}

uint64_t sub_1000389F8(uint64_t a1, uint64_t a2, unsigned int *a3, char a4, __int16 a5, void *a6)
{
  uint64_t v21 = 0LL;
  uint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v12 = sub_10002B9C4((uint64_t **)a1, &v21, *(_DWORD *)(a1 + 40), a2, 0LL, &v22);
  if ((_DWORD)v12)
  {
    if (v21 && *(_DWORD *)(a1 + 40) != 0x8000000) {
      free(v21);
    }
  }

  else
  {
    sub_100038D38(a3, (uint64_t)v21, a4, a5);
    int v13 = v21;
    *((void *)v21 + 1) = v22;
    unint64_t v13[2] = a2;
    __int16 v14 = *((_WORD *)v13 + 16);
    if ((v14 & 1) != 0) {
      int v15 = 2;
    }
    else {
      int v15 = 3;
    }
    int v16 = *(_DWORD *)(a1 + 40);
    if (v16 == 0x8000000) {
      int v17 = -2013265920;
    }
    else {
      int v17 = *(_DWORD *)(a1 + 40);
    }
    int v18 = v17 | v15;
    *((_DWORD *)v13 + 6) = v18;
    if (!v16)
    {
      uint64_t v20 = *(void *)(a1 + 8);
      if (v20)
      {
        if ((*(_BYTE *)(*(void *)(v20 + 40) + 264LL) & 1) == 0) {
          *((_DWORD *)v13 + 6) = v18 | 0x10000000;
        }
      }
    }

    *((_DWORD *)v13 + 7) = *(_DWORD *)(a1 + 48);
    if ((v14 & 1) != 0) {
      *(_OWORD *)((char *)v13 + a3[1] - 40) = *(_OWORD *)a3;
    }
    *a6 = v13;
  }

  return v12;
}

_BYTE *sub_100038B20( _BYTE *result, uint64_t a2, _WORD *a3, signed int a4, int a5, int a6, const void *a7, unsigned int a8, const void *a9, unsigned int a10)
{
  uint64_t v15 = (uint64_t)result;
  if ((a3[16] & 4) == 0 || (*result & 4) != 0)
  {
    unsigned int v16 = *(_DWORD *)(a2 + 36);
    if (a4 < a5) {
      int v17 = a6;
    }
    else {
      int v17 = 0;
    }
    uint64_t result = (_BYTE *)sub_100037830((uint64_t)result, (uint64_t)a3, (v17 << 31 >> 31) - a4 + v16);
    unsigned int v18 = (unsigned __int16)a3[21];
    if (result > v18)
    {
      a3[23] += v18 - (_WORD)result;
      a3[21] = (_WORD)result;
    }
  }

  else
  {
    unsigned int v16 = *(_DWORD *)(a2 + 36);
  }

  if (v16 > a4)
  {
    uint64_t v31 = (uint64_t)a3;
    int v19 = 0;
    unsigned int v20 = a4;
    do
    {
      unsigned int v21 = 0;
      unsigned int v33 = 0LL;
      int v34 = 0LL;
      else {
        unsigned int v22 = v20 + 1;
      }
      uint64_t v32 = 0LL;
      if (v22 < v16)
      {
        sub_1000372D4(v15, a2, v22, &v34, (_DWORD *)&v32 + 1);
        uint64_t result = (_BYTE *)sub_10003735C(v15, a2, v22, &v33, (unsigned int *)&v32);
        unsigned int v21 = v32;
        if ((_DWORD)v32 == 65534 || (_DWORD)v32 == 0) {
          unsigned int v33 = &unk_10006B3AF;
        }
      }

      if (!a6 || a5 - 1 != v20)
      {
        int v24 = v34;
        if (a5 - 1 + a6 == v20)
        {
          if (a7)
          {
            int v24 = a7;
            unsigned int v25 = a8;
          }

          else
          {
            unsigned int v25 = HIDWORD(v32);
          }

          if (a9) {
            int v26 = a9;
          }
          else {
            int v26 = v33;
          }
          if (a9) {
            unsigned int v21 = a10;
          }
        }

        else
        {
          unsigned int v25 = HIDWORD(v32);
          int v26 = v33;
        }

        uint64_t result = sub_1000388A8(v15, v31, v19++, v24, v25, 0LL, v26, v21, 0LL);
      }

      ++v20;
      unsigned int v16 = *(_DWORD *)(a2 + 36);
    }

    while (v20 < v16);
  }

  for (int i = v16 - 1; i >= a4; --i)
  {
    if (i - a5 != -1)
    {
      if (i >= a5) {
        int v28 = i;
      }
      else {
        int v28 = i + 1;
      }
      uint64_t result = sub_100038DE4(v15, a2, v28);
    }
  }

  return result;
}

unsigned int *sub_100038D38(unsigned int *result, uint64_t a2, char a3, __int16 a4)
{
  __int16 v4 = a3 & 0x1B;
  *(_WORD *)(a2 + 32) = v4;
  *(_WORD *)(a2 + 34) = a4;
  *(_DWORD *)(a2 + 36) = 0;
  *(_WORD *)(a2 + 40) = 0;
  *(_WORD *)(a2 + 44) = 0;
  *(void *)(a2 + 48) = 0xFFFF0000FFFFLL;
  unsigned int v5 = result[2];
  if ((a3 & 2) != 0)
  {
    int v6 = result[3];
  }

  else if ((a3 & 8) != 0)
  {
    int v6 = result[4] + 8;
  }

  else
  {
    int v6 = 8;
  }

  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    LOWORD(v8) = 64;
  }

  else
  {
    v4 |= 4u;
    *(_WORD *)(a2 + 32) = v4;
    int v8 = (4 * (((unint64_t)result[1] - 56) / ((unint64_t)(v6 + v5) + 4))) & 0xFFFFFFF8;
  }

  *(_WORD *)(a2 + 42) = v8;
  *(_WORD *)(a2 + 46) = *((_WORD *)result + 2) - v8 + (((__int16)(v4 << 15) >> 15) & 0xFFD8) - 56;
  return result;
}

void *sub_100038DE4(uint64_t a1, uint64_t a2, int a3)
{
  __int16 v6 = *(_WORD *)(a2 + 32);
  uint64_t v7 = a2 + 56;
  uint64_t v8 = a3;
  int v9 = (void *)(a2 + 56 + 4LL * a3);
  int v10 = (void *)(a2 + 56 + 8LL * a3);
  if ((v6 & 4) != 0) {
    unint64_t v11 = (unsigned __int16 *)(a2 + 56 + 4LL * a3);
  }
  else {
    unint64_t v11 = (unsigned __int16 *)(a2 + 56 + 8LL * a3);
  }
  if ((v6 & 4) != 0) {
    int v12 = *(_DWORD *)(a1 + 8);
  }
  else {
    LOWORD(v12) = *(_WORD *)(v7 + 8LL * a3 + 2);
  }
  sub_100035D38(a1, (_WORD *)a2, 0, *v11, (unsigned __int16)v12);
  if ((*(_WORD *)(a2 + 32) & 4) != 0) {
    int v13 = (unsigned __int16 *)(v7 + 4 * v8 + 2);
  }
  else {
    int v13 = (unsigned __int16 *)(v7 + 8 * v8 + 4);
  }
  unsigned int v14 = *v13;
  unsigned int v15 = sub_100035C54(a1, a2, a3);
  sub_100035D38(a1, (_WORD *)a2, 1, v14, v15);
  uint64_t v16 = v8 + 1;
  uint64_t v17 = (*(_DWORD *)(a2 + 36) + ~a3);
  if ((*(_WORD *)(a2 + 32) & 4) != 0)
  {
    uint64_t result = memmove(v9, (const void *)(v7 + 4 * v16), 4 * v17);
    unsigned int v19 = *(_DWORD *)(a2 + 36) - 1;
    *(_DWORD *)(v7 + 4LL * v19) = -1;
  }

  else
  {
    uint64_t result = memmove(v10, (const void *)(v7 + 8 * v16), 8 * v17);
    unsigned int v19 = *(_DWORD *)(a2 + 36) - 1;
    *(void *)(v7 + 8LL * v19) = 0xFFFF0000FFFFLL;
  }

  *(_DWORD *)(a2 + 36) = v19;
  return result;
}

uint64_t sub_100038F10( uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, char **a7, char *a8, unsigned __int16 a9)
{
  unsigned int v46 = -1431655766;
  int v45 = -1431655766;
  *a7 = 0LL;
  int v16 = *(_DWORD *)(a1 + 36);
  uint64_t v17 = *(void *)(a1 + 56);
  int v40 = -1431655766;
  int v39 = v16;
  unsigned int v43 = 0LL;
  unsigned int v44 = 0LL;
  char v42 = 0;
  __int128 v38 = *a3;
  uint64_t v41 = v17;
  unsigned int v18 = *(unsigned __int16 *)(a4 + 34);
  uint64_t v19 = sub_100036FF8(a1, (uint64_t)&v38, a4, a5, a6, (int *)&v46, &v45);
  uint64_t v20 = v19;
  BOOL v21 = v18 > a9;
  int v22 = v21;
  if (!v21)
  {
    if (!(_DWORD)v19)
    {
      if (v45)
      {
        unsigned int v24 = v46;
        sub_100038DE4((uint64_t)&v38, a4, v46);
        if (a9) {
          goto LABEL_12;
        }
        int v29 = (void *)a3 + 3;
LABEL_15:
        int v28 = a8;
        --*v29;
LABEL_16:
        if ((*(_WORD *)(a4 + 32) & 1) == 0)
        {
          BOOL v30 = *(unsigned __int16 *)(a4 + 34) != a9 && v43 == 0LL;
          BOOL v31 = v30 && v42 == 0;
          int v32 = v31 ? v22 : 1;
          if (v32 == 1) {
            sub_100037E18(a1, a2, (char *)a4, v26, v27);
          }
        }

        if (*a7) {
          sub_100037E18(a1, a2, *a7, v26, v27);
        }
        if (v24)
        {
          char v33 = 0;
        }

        else if (*(unsigned __int16 *)(a4 + 34) != a9 && v42 == 0)
        {
          char v33 = v22;
        }

        else
        {
          char v33 = 1;
        }

        uint64_t v20 = 0LL;
        *int v28 = v33;
        goto LABEL_39;
      }

      uint64_t v20 = 2LL;
    }

LABEL_39:
    uint64_t v23 = v43;
    goto LABEL_40;
  }

  if ((_DWORD)v19) {
    goto LABEL_39;
  }
  unsigned int v36 = v46;
  uint64_t v20 = sub_1000370F0((unsigned int *)a1, a2, &v38, a4, v46, 1, (uint64_t *)&v44);
  if ((_DWORD)v20) {
    goto LABEL_39;
  }
  uint64_t v20 = sub_100038F10(a1, a2, a3, v44, a5, a6, &v43, &v42, a9);
  if ((_DWORD)v20) {
    goto LABEL_39;
  }
  if (!*((_DWORD *)v44 + 9))
  {
    unsigned int v24 = v36;
    sub_100038DE4((uint64_t)&v38, a4, v36);
    sub_10002BBB8(a1, *(unsigned int *)(a1 + 40), *((void *)v44 + 2), *((void *)v44 + 1));
    if (*(_DWORD *)(a1 + 40) != 0x8000000) {
      free(v44);
    }
    unsigned int v44 = 0LL;
    int v29 = a3 + 2;
    goto LABEL_15;
  }

  uint64_t v23 = v43;
  unsigned int v24 = v36;
  uint64_t v25 = sub_100037EF4(a1, a3, a4, v36);
  if (!(_DWORD)v25)
  {
LABEL_12:
    int v22 = 0;
    int v28 = a8;
    goto LABEL_16;
  }

  uint64_t v20 = v25;
LABEL_40:
  if (v23 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v23);
  }
  if (v44 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v44);
  }
  return v20;
}

    if (++v19 == v56)
    {
      LODWORD(v5) = 0;
      goto LABEL_50;
    }
  }

  if (!v36) {
    goto LABEL_39;
  }
  char v42 = 0LL;
  unsigned int v43 = 0LL;
  unsigned int v44 = v19 * v57;
  while (2)
  {
    int v45 = a1[3];
    unsigned int v46 = *(void *)(v45 + 152);
    if ((v46 & 0x7FFFFFFFFFFFFFFFuLL) <= v43 + v44)
    {
      unsigned int v5 = 22LL;
      goto LABEL_46;
    }

    unsigned int v47 = *(void *)(v45 + 176);
    if ((v46 & 0x8000000000000000LL) == 0)
    {
      unsigned int v48 = v47 + v43 + v44;
      unsigned int v64 = v48;
LABEL_30:
      if (v42 >= v36 - v43) {
        unsigned int v50 = v36 - v43;
      }
      else {
        unsigned int v50 = v42;
      }
      uint64_t v62 = v43;
      unsigned int v63 = v50;
      unsigned int v61 = v48;
      unsigned int v51 = sub_10003E238((uint64_t)a1, v48, v50, (char *)v18, (char *)v6, (uint64_t)&v60, &v66);
      if (v51) {
        goto LABEL_41;
      }
      sub_1000086AC(v6, v59, v63);
      char v42 = v63;
      v43 += v63;
      if (v43 >= v36) {
        goto LABEL_39;
      }
      continue;
    }

    break;
  }

  unsigned int v49 = sub_10002DC38((uint64_t)a1, v47, v43 + v44, &v64, (unint64_t *)&v63);
  if (!(_DWORD)v49)
  {
    char v42 = v63;
    unsigned int v48 = v64;
    goto LABEL_30;
  }

  unsigned int v5 = v49;
LABEL_46:
  sub_100040B90("error (%d) looking up spaceman IP block address at index %llu\n", v8, v34, v10, v11, v12, v13, v14, v5);
  int v16 = 1276LL;
  uint64_t v17 = v5;
LABEL_7:
  sub_100044E7C((char *)v16, v17);
  return v5;
}

uint64_t sub_1000391D0(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  int v12 = 0LL;
  if ((*(_WORD *)(a4 + 32) & 2) != 0 || !*(_DWORD *)(a4 + 36))
  {
LABEL_7:
    sub_10002BBB8(a1, *(_DWORD *)(a1 + 40), *(void *)(a4 + 16), *(void *)(a4 + 8));
    uint64_t v10 = 0LL;
  }

  else
  {
    unsigned int v8 = 0;
    while (1)
    {
      uint64_t v9 = sub_1000370F0((unsigned int *)a1, a2, a3, a4, v8, 1, (uint64_t *)&v12);
      if ((_DWORD)v9) {
        break;
      }
      uint64_t v9 = sub_1000391D0(a1, a2, a3, v12);
      if ((_DWORD)v9) {
        break;
      }
      if (++v8 >= *(_DWORD *)(a4 + 36)) {
        goto LABEL_7;
      }
    }

    uint64_t v10 = v9;
  }

  if (v12 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v12);
  }
  return v10;
}

uint64_t sub_1000392B0(uint64_t *a1, uint64_t a2)
{
  unsigned int v64 = 0LL;
  uint64_t v4 = sub_100022BD0( a1,  a2,  0x40000000,  *(void *)(*(void *)(a2 + 40) + 976LL),  0LL,  0,  24,  0,  (uint64_t **)&v64,  0LL,  1);
  if ((_DWORD)v4)
  {
    uint64_t v12 = v4;
    sub_100040B90("could not retrieve er_state_phys_t\n", v5, v6, v7, v8, v9, v10, v11, v62);
    uint64_t v13 = 516LL;
    int v14 = v12;
LABEL_8:
    sub_100044E7C((char *)v13, v14);
    goto LABEL_9;
  }

  unsigned int v15 = v64;
  if (*((_DWORD *)v64 + 8) != 1179402562)
  {
    sub_100040B90("er_state magic number is %d, should be %d\n", v5, v6, v7, v8, v9, v10, v11, *((_DWORD *)v64 + 8));
    uint64_t v12 = 92LL;
    uint64_t v13 = 517LL;
    goto LABEL_7;
  }

  unsigned int v16 = *((_DWORD *)v64 + 9);
  if (v16 >= 3)
  {
    sub_100040B90( "er_state->ersb_version is %d, should be at most %d\n",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  *((_DWORD *)v64 + 9));
    uint64_t v12 = 92LL;
    uint64_t v13 = 518LL;
LABEL_7:
    int v14 = 92;
    goto LABEL_8;
  }

  if (v16 != 2)
  {
    if (v16 != 1)
    {
      sub_100040B90("ersb_version is %d, unsupported\n", v5, v6, v7, v8, v9, v10, v11, *((_DWORD *)v64 + 9));
      uint64_t v12 = 92LL;
      uint64_t v13 = 739LL;
      goto LABEL_7;
    }

    uint64_t v12 = sub_1000396C0(*((void *)v64 + 5), v5, v6, v7, v8, v9, v10, v11);
    if (!(_DWORD)v12)
    {
      if ((v15[5] & 0x20) != 0 && !v15[15])
      {
        sub_100040B90( "invalid ersb_flags (0x%llx), ERSB_FLAG_CID_IS_TWEAK is set but ersb_fext_cid == 0\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v15[5]);
        uint64_t v12 = 92LL;
        uint64_t v13 = 716LL;
        goto LABEL_7;
      }

      uint64_t v12 = sub_100039744((uint64_t)a1, v15[6], v19, v20, v21, v22, v23, v24);
      if (!(_DWORD)v12)
      {
        unint64_t v32 = v15[12];
        if (v32 > *(void *)(a1[1] + 40))
        {
          sub_100040B90( "ersb_total_blk_to_encrypt (%llu) exceeds device block count (%llu)\n",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v15[12]);
          uint64_t v12 = 92LL;
          uint64_t v13 = 522LL;
          goto LABEL_7;
        }

        if (v15[11] > v32) {
          sub_100040C68( "ersb_progress (%llu) exceeds ersb_total_blk_to_encrypt (%llu)\n",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v15[11]);
        }
        if ((v15[5] & 8) != 0 && (unsigned __int16)*((_DWORD *)v15 + 28))
        {
          sub_100040B90( "ersb_flags (0x%llx) has ERSB_FLAG_PAUSED on but checksum count is non-zero (%u)\n",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v15[5]);
          uint64_t v12 = 92LL;
          uint64_t v13 = 523LL;
          goto LABEL_7;
        }

        if ((unsigned __int16)*((_DWORD *)v15 + 28) > HIWORD(*((_DWORD *)v15 + 28)))
        {
          sub_100040B90( "checksum_count (%u) exceeds max checksums (%u)\n",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  *((_DWORD *)v15 + 28));
          uint64_t v12 = 92LL;
          uint64_t v13 = 717LL;
          goto LABEL_7;
        }

        uint64_t v61 = sub_1000397A0(a1, a2, v15[13], v15[12]);
        goto LABEL_49;
      }
    }

    goto LABEL_9;
  }

  uint64_t v12 = sub_1000396C0(*((void *)v64 + 5), v5, v6, v7, v8, v9, v10, v11);
  if ((_DWORD)v12) {
    goto LABEL_9;
  }
  uint64_t v12 = sub_100039744((uint64_t)a1, v15[6], v33, v34, v35, v36, v37, v38);
  if ((_DWORD)v12) {
    goto LABEL_9;
  }
  unint64_t v45 = v15[10];
  if (v15[9] > v45)
  {
    sub_100040C68( "ersb_progress (%llu) exceeds ersb_total_blk_to_encrypt (%llu)\n",  v39,  v40,  v45,  v41,  v42,  v43,  v44,  v15[9]);
    unint64_t v45 = v15[10];
  }

  uint64_t v12 = sub_1000397A0(a1, a2, v15[11], v45);
  if ((_DWORD)v12) {
    goto LABEL_9;
  }
  int v65 = 0LL;
  uint64_t v46 = sub_100022BD0(a1, 0LL, 0x40000000, v15[11], 0LL, 0, 25, 0, (uint64_t **)&v65, 0LL, 0);
  if ((_DWORD)v46)
  {
    uint64_t v12 = v46;
    uint64_t v54 = 2863311530LL;
    sub_100040B90("could not retrieve gbitmap from er_state_phys_t\n", v47, v48, v49, v50, v51, v52, v53, v63);
    sub_100044E7C((char *)0x2CE, v12);
    goto LABEL_43;
  }

  unint64_t v55 = *((void *)v65 + 5);
  uint64_t v56 = a1[1];
  unint64_t v57 = *(void *)(v56 + 40);
  unint64_t v58 = v55 / v57;
  if ((v55 / v57) * v57 != v55)
  {
    uint64_t v54 = 2863311530LL;
    sub_100040B90( "bm_bit_count %llu is not an integer multiple of container block count %llu\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  *((void *)v65 + 5));
    uint64_t v60 = 719LL;
    goto LABEL_42;
  }

  uint64_t v12 = 0LL;
  unsigned int v59 = *(_DWORD *)(v56 + 36);
  uint64_t v54 = v59 / v58;
  if ((*(_BYTE *)(v56 + 65) & 1) != 0 && v59 != (_DWORD)v54)
  {
    sub_100040B90( "Fusion with FS block size (%u) != container device block size (%u)\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v59);
    uint64_t v60 = 741LL;
LABEL_42:
    sub_100044E7C((char *)v60, 0);
    uint64_t v12 = 92LL;
  }

LABEL_43:
  if (v65) {
    free(v65);
  }
  if (!(_DWORD)v12)
  {
    if (v15[13])
    {
      if ((v15[5] & 8) != 0)
      {
        sub_100040B90( "ersb_flags (0x%llx) has ERSB_FLAG_PAUSED on but ersb_recovery_extents_count is non-zero (%llu)\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v15[5]);
        uint64_t v12 = 92LL;
        uint64_t v13 = 738LL;
        goto LABEL_7;
      }

      uint64_t v61 = sub_100039A3C(a1, a2, v15, v54, v50, v51, v52, v53);
LABEL_49:
      uint64_t v12 = v61;
      goto LABEL_9;
    }

    if (v15[14])
    {
      sub_100040B90( "ersb_recovery_extents_count == 0, but ersb_recovery_list_oid is non-zero (0x%llx)\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v15[14]);
      uint64_t v12 = 92LL;
      uint64_t v13 = 736LL;
      goto LABEL_7;
    }

    if (v15[15])
    {
      sub_100040B90( "ersb_recovery_extents_count == 0, but ersb_recovery_length is non-zero (%llu)\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v15[15]);
      uint64_t v12 = 92LL;
      uint64_t v13 = 737LL;
      goto LABEL_7;
    }

    uint64_t v12 = 0LL;
  }

    if (v116)
    {
      free(v116);
      __int128 v116 = 0LL;
    }

    uint64_t v48 = sub_10000AC50((uint64_t)v112, (uint64_t **)&v116, &v114);
    if (v48) {
      goto LABEL_52;
    }
    uint64_t v40 = v105;
    uint64_t v42 = v62 + v106;
    uint64_t v44 = v102;
    v41 += v102;
    if (v41 >= v107) {
      goto LABEL_50;
    }
  }

  uint64_t v81 = v47;
  unsigned int v88 = strerror(v47);
  sub_100040B90("error (%s) failed to get cib for chunk index %llu \n", v89, v90, v91, v92, v93, v94, v95, v88);
LABEL_67:
  uint64_t v29 = a2;
  uint64_t v31 = v101;
LABEL_68:
  if (v116)
  {
    free(v116);
    __int128 v116 = 0LL;
  }

  if (v31) {
    free(v31);
  }
  if (v115) {
    free(v115);
  }
  byte_10008CA04[v29] = 0;
  if (v117) {
    return v117;
  }
  else {
    return v81;
  }
}

  if (qword_10008D0D8) {
    free((void *)qword_10008D0D8);
  }
  if (qword_10008D0B8) {
    free((void *)qword_10008D0B8);
  }
}

uint64_t sub_1000396C0( __int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 & 3) == 3LL || (a1 & 3) == 0LL)
  {
    sub_100040B90( "invalid ersb_flags (0x%llx), exactly one of ERSB_FLAG_ENCRYPTING and ERSB_FLAG_DECRYPTING bits must be set\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a1);
    uint64_t v9 = 519LL;
LABEL_10:
    uint64_t v10 = 92LL;
    sub_100044E7C((char *)v9, 92);
    return v10;
  }

  if ((a1 & 0xF00u) >= 0x700uLL)
  {
    sub_100040B90("invalid checksum block size, enum: %llu\n", a2, a3, a4, a5, a6, a7, a8, HIBYTE(a1) & 0xF);
    uint64_t v9 = 715LL;
    goto LABEL_10;
  }

  return 0LL;
}

uint64_t sub_100039744( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(*(void *)(a1 + 8) + 96LL) > a2) {
    return 0LL;
  }
  sub_100040B90( "ersb_snap_xid (%llu) is greater than or equal to container next xid (%llu)\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a2);
  uint64_t v8 = 92LL;
  sub_100044E7C((char *)0x209, 92);
  return v8;
}

uint64_t sub_1000397A0(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v30 = 0LL;
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v29[2] = v7;
  uint64_t v29[3] = v7;
  v29[0] = v7;
  v29[1] = v7;
  uint64_t v8 = sub_100022BD0(a1, a2, 0x40000000, a3, 0LL, 0, 25, 0, &v30, 0LL, 1);
  if ((_DWORD)v8)
  {
    uint64_t v16 = v8;
    sub_100040B90("could not retrieve gbitmap from er_state_phys_t\n", v9, v10, v11, v12, v13, v14, v15, v27);
    uint64_t v17 = 546LL;
LABEL_3:
    int v18 = v16;
LABEL_4:
    sub_100044E7C((char *)v17, v18);
    goto LABEL_5;
  }

  if (v30[5] < a4)
  {
    sub_100040B90( "ersb_total_blk_to_encrypt (%llu) exceeds bm_bit_count (%llu)\n",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  a4);
    uint64_t v16 = 92LL;
    uint64_t v17 = 740LL;
    int v18 = 92;
    goto LABEL_4;
  }

  sub_100034B44( (uint64_t)v29,  (uint64_t)a1,  a2,  0x40000000,  2,  26,  0,  *(_DWORD *)(a1[1] + 36),  8,  8,  0,  v30[4],  (uint64_t)sub_10002D39C);
  uint64_t v16 = sub_100031CD0( (uint64_t)v29,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000398F0,  0LL,  0LL,  1);
  if ((_DWORD)v16)
  {
    sub_100040B90("encryption rolling gbitmap tree is invalid\n", v20, v21, v22, v23, v24, v25, v26, v28);
    uint64_t v17 = 494LL;
    goto LABEL_3;
  }

uint64_t sub_1000398F0( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = 0LL;
  unint64_t v8 = *(void *)a5 & 0x7FFFFFFFFFFFFFFFLL;
  if ((*(void *)a5 & 0x8000000000000000LL) != 0)
  {
    uint64_t v10 = a1[1];
    uint64_t v11 = a1[3];
    if (v11)
    {
      unint64_t v12 = *(void *)(v11 + 48);
      unint64_t v13 = *(void *)(v11 + 96);
    }

    else
    {
      unint64_t v12 = *(void *)(v10 + 40);
      if ((*(_BYTE *)(v10 + 65) & 1) != 0) {
        unint64_t v13 = *(void *)(v10 + 40);
      }
      else {
        unint64_t v13 = 0LL;
      }
    }

    unint64_t v14 = *(unsigned int *)(v10 + 36);
    if (v8 && (v12 >= 2 ? (BOOL v15 = v12 > v8) : (BOOL v15 = 0), v15 ? (v16 = v12 - 1 >= v8) : (v16 = 0), v16)
      || ((unint64_t v17 = 0x4000000000000000uLL >> __clz(__rbit64(v14)), v17 < v8) ? (v18 = v13 >= 2) : (v18 = 0),
          v18 ? (BOOL v19 = (v13 | v17) > v8) : (BOOL v19 = 0),
          v19 && ((v13 - 1) | v17) >= v8))
    {
      if (a2) {
        unint64_t v20 = *(void *)(*(void *)(a2 + 40) + 8LL);
      }
      else {
        unint64_t v20 = 0LL;
      }
      sub_10003D570( (uint64_t)a1,  v8,  1LL,  v20,  0x40000000,  v8,  0LL,  0x1Bu,  &_mh_execute_header,  (unint64_t)&_mh_execute_header >> 32);
      return 0LL;
    }

    else
    {
      sub_100040B90("invalid gbitmap block oid 0x%llx for key 0x%llx\n", a2, a3, a4, (uint64_t)a5, v8, a7, a8, *a5);
      uint64_t v9 = 92LL;
      sub_100044E7C((char *)0x30F, 92);
    }
  }

  else
  {
    uint64_t v9 = sub_100022BD0(a1, a2, 0x40000000, v8, 0LL, 0, 27, 0, (uint64_t **)&v22, 0LL, 1);
    if (v22) {
      free(v22);
    }
  }

  return v9;
}

uint64_t sub_100039A3C( uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8)
{
  uint64_t v60 = 0LL;
  if (!a3[14])
  {
    sub_100040B90( "ersb_recovery_extents_count is non-zero (%llu), but ersb_recovery_list_oid == 0\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  a3[13]);
    uint64_t v17 = 92LL;
    uint64_t v18 = 720LL;
LABEL_11:
    sub_100044E7C((char *)v18, 92);
    BOOL v16 = 0LL;
    goto LABEL_12;
  }

  unint64_t v9 = a3[15];
  if (!v9)
  {
    sub_100040B90( "ersb_recovery_extents_count is non-zero (%llu), but ersb_recovery_length == 0\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  a3[13]);
    uint64_t v17 = 92LL;
    uint64_t v18 = 721LL;
    goto LABEL_11;
  }

  if (v9 > 0x1400000)
  {
    sub_100040C68( "ersb_recovery_length (%llu) exceeds recovery length limit (%llu), some checks will be disabled\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  a3[15]);
    unint64_t v14 = a3 + 13;
    uint64_t v13 = a3[13];
    if ((unint64_t)(48 * v13) <= a3[15])
    {
      uint64_t v58 = 48 * v13;
      uint64_t v59 = a4;
      BOOL v16 = 0LL;
      goto LABEL_18;
    }

    goto LABEL_10;
  }

  unint64_t v14 = a3 + 13;
  uint64_t v13 = a3[13];
  uint64_t v15 = 48 * v13;
  if (48 * v13 > v9)
  {
LABEL_10:
    sub_100040B90( "ersb_recovery_extents_count is %llu, extent descriptor size is %zu, expected descriptors length is %llu > ersb_rec overy_length %llu\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  v13);
    uint64_t v17 = 92LL;
    uint64_t v18 = 722LL;
    goto LABEL_11;
  }

  BOOL v16 = (unint64_t *)calloc(1uLL, a3[15]);
  if (!v16)
  {
    sub_100040B90( "error allocating encryption rolling recovery data buffer, ersb_recovery_length %llu\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  a3[15]);
    uint64_t v17 = 12LL;
    uint64_t v34 = 723LL;
    int v57 = 12;
    goto LABEL_81;
  }

  uint64_t v58 = v15;
  uint64_t v59 = a4;
LABEL_18:
  uint64_t v20 = a3[14];
  if (v20)
  {
    unint64_t v21 = 0LL;
    while (1)
    {
      if (v21 >= a3[15])
      {
        sub_100040B90( "encryption rolling recovery data extends past recovery length, oid 0x%llx, ersb_recovery_length %llu, accumula ted length %llu\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  v20);
        uint64_t v17 = 92LL;
        uint64_t v34 = 728LL;
        goto LABEL_80;
      }

      uint64_t v22 = sub_100022BD0(a1, a2, 0x40000000, v20, 0LL, 0, 28, 0, (uint64_t **)&v60, 0LL, 1);
      if ((_DWORD)v22)
      {
        uint64_t v17 = v22;
        sub_100040B90("could not retrieve erb, oid 0x%llx\n", v23, v24, v25, v26, v27, v28, v29, v20);
        uint64_t v34 = 724LL;
        int v57 = 2;
        goto LABEL_81;
      }

      uint64_t v30 = v60;
      if (v21 != *((void *)v60 + 4))
      {
        sub_100040B90( "encryption rolling recovery block offset mismatch, oid 0x%llx, expected %llu, actual %llu\n",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v20);
        uint64_t v17 = 92LL;
        uint64_t v34 = 725LL;
        goto LABEL_80;
      }

      uint64_t v31 = *(unsigned int *)(a1[1] + 36);
      size_t v32 = v31 - 48 >= a3[15] - v21 ? a3[15] - v21 : v31 - 48;
      if (!v32) {
        break;
      }
      if (v9 <= 0x1400000)
      {
        memcpy((char *)v16 + v21, (char *)v60 + 48, v32);
        uint64_t v30 = v60;
      }

      uint64_t v20 = v30[5];
      v21 += v32;
      free(v30);
      uint64_t v60 = 0LL;
      if (!v20) {
        goto LABEL_32;
      }
    }

    sub_100040B90( "encryption rolling recovery block with data size 0, oid 0x%llx, nx_block_size %u, recovery length %llu\n",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v20);
    uint64_t v17 = 92LL;
    uint64_t v34 = 726LL;
  }

  else
  {
    unint64_t v21 = 0LL;
LABEL_32:
    unint64_t v33 = a3[15];
    if (v21 >= v33)
    {
      uint64_t v35 = a3[5];
      unsigned int v36 = (v35 >> 8) & 0xF;
      if (v36 >= 7)
      {
        sub_100040B90( "checksum block size is invalid, checksum_block_size enum: %llu\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  BYTE1(v35) & 0xF);
        uint64_t v17 = 92LL;
        uint64_t v34 = 729LL;
      }

      else
      {
        if (v9 > 0x1400000 || !*v14)
        {
LABEL_73:
          uint64_t v17 = 0LL;
          goto LABEL_12;
        }

        uint64_t v37 = 0LL;
        unint64_t v38 = qword_10006B3B0[v36];
        uint64_t v39 = v58;
        uint64_t v40 = a1[1];
        unint64_t v41 = *(unsigned int *)(v40 + 36);
        uint64_t v42 = a1[3];
        unint64_t v43 = 0x4000000000000000uLL >> __clz(__rbit64(v41));
        uint64_t v44 = v16 + 3;
        while (1)
        {
          if (v42)
          {
            unint64_t v45 = *(void *)(v42 + 48);
            unint64_t v46 = *(void *)(v42 + 96);
          }

          else
          {
            unint64_t v45 = *(void *)(v40 + 40);
            if ((*(_BYTE *)(v40 + 65) & 1) != 0) {
              unint64_t v46 = *(void *)(v40 + 40);
            }
            else {
              unint64_t v46 = 0LL;
            }
          }

          unint64_t v47 = *(v44 - 2);
          unint64_t v49 = *v44;
          unint64_t v48 = v44[1];
          if (!*v44 || v45 < 2 || v45 <= v49 || (--v45, v45 < v49))
          {
            if (v43 >= v49 || v46 < 2 || (unint64_t v45 = v46 | v43, (v46 | v43) <= v49) || (v46 = (v46 - 1) | v43, v46 < v49))
            {
              sub_100040B90("recovery extent #%llu: invalid fext_pbn (0x%llx)\n", v47, v48, v46, v49, v45, a7, v59, v37);
              uint64_t v17 = 92LL;
              uint64_t v34 = 730LL;
              goto LABEL_80;
            }
          }

          unint64_t v50 = *(v44 - 3);
          unint64_t v51 = *(unsigned __int8 *)(v40 + 65);
          if ((v51 & 1) != 0)
          {
            if (v42)
            {
              unint64_t v45 = *(void *)(v42 + 48);
              unint64_t v52 = *(void *)(v42 + 96);
            }

            else
            {
              unint64_t v45 = *(void *)(v40 + 40);
              unint64_t v52 = v45;
            }

            if (!v50 || (a7 = v45 - v47, v45 <= v47) || v45 <= v50 || a7 < v50)
            {
              if (v43 >= v50
                || (unint64_t v45 = v52 - v47, v52 <= v47)
                || (v52 |= v43, v52 <= v50)
                || (unint64_t v52 = v45 | v43, (v45 | v43) < v50))
              {
                sub_100040B90( "recovery extent #%llu: invalid Fusion prange (0x%llx+%llu)\n",  v47,  v48,  v50,  v52,  v45,  a7,  v59,  v37);
                uint64_t v17 = 92LL;
                uint64_t v34 = 731LL;
                goto LABEL_80;
              }
            }
          }

          else if (!v50 {
                 || (unint64_t v45 = *(void *)(v40 + 40), v51 = v45 * (v41 / v59), v51 <= v50)
          }
                 || v51 <= v47
                 || (v51 -= v47, v51 < v50))
          {
            sub_100040B90( "recovery extent #%llu: invalid prange (0x%llx+%llu), dev_bsize %u\n",  v47,  v48,  v50,  v51,  v45,  a7,  v59,  v37);
            uint64_t v17 = 92LL;
            uint64_t v34 = 732LL;
            goto LABEL_80;
          }

          uint64_t v53 = v48 / v41;
          unint64_t v54 = *(void *)(v40 + 40);
          if (v48 / v41 >= v54)
          {
            sub_100040B90( "recovery extent #%llu: fext_laddr (0x%llx) exceeds nx_block_count (%llu), fs_bsize %u\n",  v47,  v48,  v54,  v53,  v45,  a7,  v59,  v37);
            uint64_t v17 = 92LL;
            uint64_t v34 = 733LL;
            goto LABEL_80;
          }

          uint64_t v55 = 8 * (v47 * v59 / v38);
          uint64_t v56 = v55 + v39;
          if (v55 + v39 > v33)
          {
            sub_100040B90( "recovery extent #%llu: checksums at offset %llu, length %llu exceed ersb_recovery_length %llu\n",  v56,  v55,  v54,  v53,  v45,  a7,  v59,  v37);
            uint64_t v17 = 92LL;
            uint64_t v34 = 734LL;
            goto LABEL_80;
          }

          if ((v35 & 0x20) != 0 && !v44[2]) {
            break;
          }
          v44 += 6;
          ++v37;
          v39 += v55;
          if (*v14 == v37) {
            goto LABEL_73;
          }
        }

        sub_100040B90( "recovery extent #%llu: invalid ersb_flags (0x%llx), ERSB_FLAG_CID_IS_TWEAK is set but fext_cid == 0\n",  v56,  0LL,  v54,  v53,  v45,  a7,  v59,  v37);
        uint64_t v17 = 92LL;
        uint64_t v34 = 735LL;
      }
    }

    else
    {
      sub_100040B90( "missing encryption rolling recovery data, actual length %llu, ersb_recovery_length %llu\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  v21);
      uint64_t v17 = 92LL;
      uint64_t v34 = 727LL;
    }
  }

unint64_t sub_10003A010( uint32x4_t *a1, unint64_t a2, unint64_t a3, int8x16_t a4, int8x16_t a5)
{
  unint64_t v5 = a3;
  unint64_t v6 = HIDWORD(a3);
  if ((a2 & 3) == 0)
  {
    for (i = a2 >> 2; i; unint64_t v6 = v34 + HIDWORD(v34))
    {
      if (i >= 0x16A00) {
        uint64_t v8 = 92672LL;
      }
      else {
        uint64_t v8 = i;
      }
      i -= v8;
      int64x2_t v9 = (int64x2_t)veorq_s8(a4, a4);
      int64x2_t v10 = (int64x2_t)veorq_s8(a5, a5);
      v9.i64[0] = v5;
      v10.i64[0] = v6;
      if (v8 >= 16)
      {
        uint32x4_t v11 = *a1;
        uint32x4_t v12 = a1[1];
        uint32x4_t v13 = a1[2];
        uint32x4_t v14 = a1[3];
        a1 += 4;
        int64x2_t v15 = vshlq_n_s64(v9, 4uLL);
        uint64x2_t v16 = vmull_u32(*(uint32x2_t *)v12.i8, (uint32x2_t)0xB0000000CLL);
        uint64x2_t v17 = vmull_u32(*(uint32x2_t *)v13.i8, (uint32x2_t)0x700000008LL);
        int64x2_t v18 = (int64x2_t)vmlal_u32( vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v11.i8, (uint32x2_t)0xF00000010LL),  *(uint32x2_t *)v14.i8,  (uint32x2_t)0x300000004LL);
        uint64x2_t v19 = vpadalq_u32(vpadalq_u32(vpadalq_u32((uint64x2_t)v9, v11), v12), v13);
        BOOL v20 = v8 < 32;
        for (v8 -= 32LL; !v20; v8 -= 16LL)
        {
          uint64x2_t v21 = vmlal_high_u32(v16, v11, *(uint32x4_t *)qword_100039FD0);
          uint32x4_t v22 = *a1;
          a1 += 4;
          uint32x4_t v11 = v22;
          uint64x2_t v23 = vmlal_high_u32(v17, v12, *(uint32x4_t *)&qword_100039FD0[2]);
          uint32x4_t v12 = a1[-3];
          int64x2_t v24 = (int64x2_t)vpadalq_u32(v19, v14);
          uint64x2_t v25 = vmlal_high_u32((uint64x2_t)vaddq_s64(v18, v15), v13, *(uint32x4_t *)&qword_100039FD0[4]);
          uint32x4_t v13 = a1[-2];
          uint64x2_t v26 = vmlal_high_u32(v21, v14, *(uint32x4_t *)&qword_100039FD0[6]);
          uint32x4_t v14 = a1[-1];
          int64x2_t v15 = vshlq_n_s64(v24, 4uLL);
          uint64x2_t v16 = vmlal_u32(v26, *(uint32x2_t *)v12.i8, (uint32x2_t)0xB0000000CLL);
          uint64x2_t v17 = vmlal_u32(v23, *(uint32x2_t *)v13.i8, (uint32x2_t)0x700000008LL);
          int64x2_t v18 = (int64x2_t)vmlal_u32( vmlal_u32(v25, *(uint32x2_t *)v22.i8, (uint32x2_t)0xF00000010LL),  *(uint32x2_t *)v14.i8,  (uint32x2_t)0x300000004LL);
          uint64x2_t v19 = vpadalq_u32(vpadalq_u32(vpadalq_u32((uint64x2_t)v24, v22), v12), v13);
          BOOL v20 = v8 < 16;
        }

        int64x2_t v9 = (int64x2_t)vpadalq_u32(v19, v14);
        int64x2_t v10 = vaddq_s64( vaddq_s64( (int64x2_t)vmlal_high_u32((uint64x2_t)vaddq_s64(v18, v15), v13, *(uint32x4_t *)&qword_100039FD0[4]),  (int64x2_t)vmlal_high_u32(v17, v12, *(uint32x4_t *)&qword_100039FD0[2])),  (int64x2_t)vmlal_high_u32( vmlal_high_u32(v16, v11, *(uint32x4_t *)qword_100039FD0),  v14,  *(uint32x4_t *)&qword_100039FD0[6]));
      }

      if ((v8 & 8) != 0)
      {
        uint32x4_t v27 = *a1;
        a1 += 2;
        uint32x4_t v28 = a1[-1];
        int64x2_t v29 = vshlq_n_s64(v9, 3uLL);
        int64x2_t v9 = (int64x2_t)vpadalq_u32(vpadalq_u32((uint64x2_t)v9, v27), v28);
        int64x2_t v10 = vaddq_s64( (int64x2_t)vmlal_high_u32( vmlal_high_u32( vmlal_u32( vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v27.i8, (uint32x2_t)0x700000008LL),  *(uint32x2_t *)v28.i8,  (uint32x2_t)0x300000004LL),  v27,  *(uint32x4_t *)&qword_100039FD0[4]),  v28,  *(uint32x4_t *)&qword_100039FD0[6]),  v29);
      }

      if ((v8 & 4) != 0)
      {
        uint32x4_t v30 = *a1++;
        int64x2_t v31 = vshlq_n_s64(v9, 2uLL);
        int64x2_t v9 = (int64x2_t)vpadalq_u32((uint64x2_t)v9, v30);
        int64x2_t v10 = vaddq_s64( (int64x2_t)vmlal_high_u32( vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v30.i8, (uint32x2_t)0x300000004LL),  v30,  *(uint32x4_t *)&qword_100039FD0[6]),  v31);
      }

      uint64_t v32 = v8 & 3;
      a4 = (int8x16_t)vpaddq_s64(v9, v9);
      a5 = (int8x16_t)vpaddq_s64(v10, v10);
      unint64_t v33 = a4.i64[0];
      unint64_t v34 = a5.i64[0];
      if (v32)
      {
        do
        {
          unsigned __int32 v35 = a1->i32[0];
          a1 = (uint32x4_t *)((char *)a1 + 4);
          v33 += v35;
          v34 += v33;
          BOOL v20 = v32-- <= 1;
        }

        while (!v20);
      }

      unint64_t v5 = v33 + HIDWORD(v33);
    }
  }

  unint64_t v36 = v5 + HIDWORD(v5);
  unint64_t v37 = v6 + HIDWORD(v6);
  if (v36 == 0xFFFFFFFF) {
    unint64_t v36 = 0LL;
  }
  if (v37 == 0xFFFFFFFF) {
    unint64_t v37 = 0LL;
  }
  return v36 + (v37 << 32);
}

unint64_t sub_10003A1B8( unint64_t *a1, uint32x4_t *a2, unint64_t a3, unint64_t a4, int8x16_t a5, int8x16_t a6)
{
  unint64_t result = sub_10003A010(a2, a3, a4, a5, a6);
  unint64_t v8 = (HIDWORD(result)
      + result
      - 0xFFFFFFFF
      * ((unint64_t)(((HIDWORD(result) + result) * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) ^ 0xFFFFFFFF;
  *a1 = v8 | ((unint64_t)~((_DWORD)v8
                                + (_DWORD)result
  return result;
}

unint64_t sub_10003A224( void *a1, uint32x4_t *a2, unint64_t a3, unint64_t a4, int8x16_t a5, int8x16_t a6)
{
  unint64_t v7 = sub_10003A010(a2, a3, a4, a5, a6);
  unint64_t v8 = (HIDWORD(v7)
      + v7
      - 0xFFFFFFFF
      * ((unint64_t)(((HIDWORD(v7) + v7) * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) ^ 0xFFFFFFFF;
  return (v8 | ((unint64_t)~((_DWORD)v8
                                  + (_DWORD)v7
}

const char *sub_10003A294(unsigned int a1)
{
  unint64_t result = "unknown";
  if (a1 <= 0x13 && (a1 & 0xFFFFFFFE) != 0xE) {
    return off_10006C680[a1];
  }
  return result;
}

const char *sub_10003A2C4(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)a1 >> 60;
  if ((_DWORD)v2 == 14) {
    LODWORD(v2) = *(unsigned __int8 *)(a1 + 8);
  }
  unint64_t result = "unknown";
  switch((int)v2)
  {
    case 9:
      if ((a2 - 3) >= 0xFFFFFFFE)
      {
        uint64_t v4 = &unk_10006C7C8;
        goto LABEL_19;
      }

      break;
    case 10:
    case 11:
    case 12:
    case 14:
    case 15:
    case 17:
      return result;
    case 13:
      if (a2 == 1) {
        unint64_t result = "FILE_INFO_TAG_EXT_TYPE_SIGNING_ID";
      }
      break;
    case 16:
      if ((a2 - 3) >= 0xFFFFFFFE)
      {
        uint64_t v4 = &unk_10006C7E0;
        goto LABEL_19;
      }

      break;
    case 18:
      if ((a2 - 5) >= 0xFFFFFFFC)
      {
        uint64_t v4 = &unk_10006C7F8;
        goto LABEL_19;
      }

      break;
    case 19:
      if ((a2 - 3) >= 0xFFFFFFFE)
      {
        uint64_t v4 = &unk_10006C820;
        goto LABEL_19;
      }

      break;
    default:
      if ((_DWORD)v2 == 3 && (a2 - 21) >= 0xFFFFFFEC)
      {
        uint64_t v4 = &unk_10006C720;
LABEL_19:
        unint64_t result = (const char *)v4[a2];
      }

      break;
  }

  return result;
}

uint64_t sub_10003A3A0(uint64_t a1, unint64_t *a2, unsigned int a3, unsigned int *a4)
{
  if (!a2) {
    return 22LL;
  }
  if (a3 < 8) {
    return 92LL;
  }
  unint64_t v4 = *a2;
  if (a3 <= 0xB && (v4 & 0xF000000000000000LL) == 0xE000000000000000LL) {
    return 92LL;
  }
  unint64_t v6 = v4 >> 60;
  if ((_DWORD)v6 == 14)
  {
    LODWORD(v6) = *((unsigned __int8 *)a2 + 8);
    if (v6 > 0x13)
    {
      int v10 = 0;
      unsigned int v8 = 8;
      goto LABEL_33;
    }
  }

  int v7 = v6;
  if (((0xC201uLL >> v6) & 1) != 0) {
    unsigned int v8 = 8;
  }
  else {
    unsigned int v8 = dword_10006B430[v6];
  }
  BOOL v9 = v7 != 4 || v8 > a3;
  if (!v9 || v7 == 11 && v8 <= a3)
  {
    int v10 = *((unsigned __int16 *)a2 + 4);
    goto LABEL_33;
  }

  if (v7 != 9)
  {
    int v10 = 0;
    goto LABEL_33;
  }

  if (!a1) {
    return 22LL;
  }
  if ((*(_BYTE *)(a1 + 56) & 9) != 0)
  {
    if (a3 < 0xC) {
      int v10 = 0;
    }
    else {
      int v10 = a2[1] & 0x3FF;
    }
    unsigned int v8 = 12;
  }

  else
  {
    if (a3 < 0xA) {
      int v10 = 0;
    }
    else {
      int v10 = *((unsigned __int16 *)a2 + 4);
    }
    unsigned int v8 = 10;
  }

uint64_t sub_10003A4BC(uint64_t a1, unsigned __int16 *a2, unsigned int a3, unsigned int *a4)
{
  if (!a2) {
    return 22LL;
  }
  uint64_t v4 = *(void *)a1 >> 60;
  if ((_DWORD)v4 == 14)
  {
    LODWORD(v4) = *(unsigned __int8 *)(a1 + 8);
    if (v4 > 0x13)
    {
      unsigned int v5 = 0;
      int v11 = 0;
      BOOL v6 = 0;
LABEL_26:
      switch((int)v4)
      {
        case 1:
          int v12 = a2[24];
          break;
        case 3:
          if (a3 - v5 < 4) {
            goto LABEL_33;
          }
          int v12 = a2[47];
          break;
        case 4:
          int v12 = a2[1];
          break;
        case 5:
          int v12 = a2[4];
          break;
        case 7:
          int v12 = a2[11];
          break;
        case 9:
          if (a3 - v5 < 4) {
            goto LABEL_33;
          }
          int v12 = a2[10];
          break;
        default:
LABEL_33:
          if (v6)
          {
            if (v11 == 2)
            {
              if (a3 - v5 < 4) {
                goto LABEL_19;
              }
              int v12 = a2[14];
            }

            else
            {
              if (v11 != 1) {
                goto LABEL_19;
              }
              int v12 = *((unsigned __int8 *)a2 + 2);
            }
          }

          else
          {
            unsigned int v13 = a3 - v5;
            if (a3 - v5 >= 4 && (_DWORD)v4 == 16)
            {
              int v12 = a2[13];
            }

            else if (v13 >= 4 && (_DWORD)v4 == 18)
            {
              int v12 = a2[27];
            }

            else
            {
              int v12 = 0;
              if (v13 >= 4 && (_DWORD)v4 == 19) {
                int v12 = a2[5];
              }
            }
          }

          break;
      }

      goto LABEL_20;
    }
  }

  unsigned int v5 = dword_10006B480[v4];
  BOOL v6 = v4 == 13;
  if ((_DWORD)v4 == 13)
  {
    uint64_t v7 = HIBYTE(*(void *)(a1 + 8));
    if ((_DWORD)v7 == 2) {
      int v8 = 2;
    }
    else {
      int v8 = HIBYTE(*(void *)(a1 + 8));
    }
    if ((_DWORD)v7 == 2) {
      unsigned int v5 = 26;
    }
    BOOL v9 = (_DWORD)v7 == 1;
    if ((_DWORD)v7 == 1) {
      int v11 = 1;
    }
    else {
      int v11 = v8;
    }
    if (v9) {
      unsigned int v5 = 3;
    }
  }

  else
  {
    int v11 = 0;
  }

  if (v5 <= a3) {
    goto LABEL_26;
  }
LABEL_19:
  int v12 = 0;
LABEL_20:
  if (a4) {
    *a4 = v5;
  }
  if (v12 + v5 <= a3) {
    return 0LL;
  }
  else {
    return 92LL;
  }
}

uint64_t sub_10003A650(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }

      else
      {
        unint64_t v8 = a2[1];
        unint64_t v9 = a4[1];
        BOOL v10 = v8 >= v9;
        int v7 = v8 > v9;
        if (!v10) {
          int v7 = -1;
        }
      }
    }

    else
    {
      int v7 = -1;
    }

    uint64_t result = 0LL;
    *a6 = v7;
  }

  return result;
}

uint64_t sub_10003A6AC( uint64_t a1, unint64_t *a2, unsigned int a3, unint64_t *a4, unsigned int a5, int *a6)
{
  if (a1 && *(_WORD *)(a1 + 24) != 13) {
    return 22LL;
  }
  uint64_t v11 = 22LL;
  if (a3 >= 8 && a5 >= 8)
  {
    unint64_t v13 = *a2 & 0xFFFFFFFFFFFFFFFLL;
    unint64_t v14 = *a4 & 0xFFFFFFFFFFFFFFFLL;
    if (v13 < v14) {
      goto LABEL_10;
    }
    if (v13 <= v14)
    {
      unint64_t v16 = *a2 >> 60;
      if ((_DWORD)v16 == 14) {
        LODWORD(v--*(_DWORD *)(result + 16) = *((unsigned __int8 *)a2 + 8);
      }
      unint64_t v17 = *a4 >> 60;
      if ((_DWORD)v17 == 14) {
        LODWORD(v17) = *((unsigned __int8 *)a4 + 8);
      }
      if (!(_DWORD)v16)
      {
        BOOL v18 = (_DWORD)v17 == 0;
LABEL_24:
        if (v18) {
          int v15 = 0;
        }
        else {
          int v15 = -1;
        }
        goto LABEL_27;
      }

      if ((_DWORD)v17)
      {
        if (v16 < v17)
        {
LABEL_10:
          int v15 = -1;
LABEL_27:
          uint64_t v11 = 0LL;
          *a6 = v15;
          return v11;
        }

        if (v16 <= v17)
        {
          uint64_t v11 = 45LL;
          switch((int)v16)
          {
            case 1:
            case 2:
            case 3:
            case 6:
            case 7:
            case 10:
            case 12:
            case 18:
              goto LABEL_22;
            case 4:
            case 11:
              goto LABEL_40;
            case 5:
              unint64_t v19 = a2[1];
              unint64_t v20 = a4[1];
              if (!v19) {
                goto LABEL_56;
              }
              if (!v20) {
                break;
              }
              goto LABEL_33;
            case 8:
              unint64_t v19 = a2[1];
              unint64_t v20 = a4[1];
              if (v19 == -1LL)
              {
                BOOL v18 = v20 == -1LL;
                goto LABEL_24;
              }

              if (v20 == -1LL) {
                break;
              }
LABEL_33:
              BOOL v21 = v19 > v20;
              if (v19 >= v20) {
                goto LABEL_52;
              }
              goto LABEL_10;
            case 9:
              if (!a1) {
                return 22LL;
              }
              if ((*(_BYTE *)(a1 + 56) & 9) == 0)
              {
LABEL_40:
                uint64_t v26 = (uint64_t)a2 + 10;
                unint64_t v24 = *((unsigned __int16 *)a2 + 4);
                uint64_t v27 = (uint64_t)a4 + 10;
                unint64_t v25 = *((unsigned __int16 *)a4 + 4);
                goto LABEL_41;
              }

              unsigned int v22 = *((_DWORD *)a2 + 2);
              unsigned int v23 = *((_DWORD *)a4 + 2);
              if (v22 >> 10 < v23 >> 10) {
                goto LABEL_10;
              }
              if (v22 >> 10 <= v23 >> 10)
              {
                unint64_t v24 = v22 & 0x3FF;
                unint64_t v25 = v23 & 0x3FF;
                uint64_t v26 = (uint64_t)a2 + 12;
                uint64_t v27 = (uint64_t)a4 + 12;
LABEL_41:
                int v15 = sub_10003A954(v26, v24, v27, v25);
                goto LABEL_27;
              }

              break;
            case 13:
              unint64_t v36 = a2[1];
              unint64_t v37 = HIBYTE(v36);
              unint64_t v38 = a4[1];
              unint64_t v39 = HIBYTE(v38);
              if (!HIBYTE(v36))
              {
                BOOL v18 = v39 == 0;
                goto LABEL_24;
              }

              if (!v39) {
                break;
              }
              if (v37 != v39)
              {
                if (v37 < v39) {
                  int v15 = -1;
                }
                else {
                  int v15 = 1;
                }
                goto LABEL_27;
              }

              unint64_t v40 = v36 & 0xFFFFFFFFFFFFFFLL;
              unint64_t v41 = v38 & 0xFFFFFFFFFFFFFFLL;
              if (v40 == 0xFFFFFFFFFFFFFFLL)
              {
                BOOL v18 = v41 == 0xFFFFFFFFFFFFFFLL;
                goto LABEL_24;
              }

              if (v41 == 0xFFFFFFFFFFFFFFLL) {
                break;
              }
              BOOL v21 = v40 > v41;
              if (v40 < v41) {
                goto LABEL_10;
              }
              goto LABEL_52;
            case 16:
              unint64_t v28 = *(unint64_t *)((char *)a2 + 12);
              unint64_t v20 = *(unint64_t *)((char *)a4 + 12);
              if (!v28)
              {
LABEL_56:
                BOOL v18 = v20 == 0;
                goto LABEL_24;
              }

              if (!v20) {
                break;
              }
              BOOL v29 = v28 > v20;
              if (v28 < v20) {
                goto LABEL_10;
              }
LABEL_50:
              if (v29) {
                break;
              }
              unint64_t v34 = *(unint64_t *)((char *)a2 + 20);
              unint64_t v35 = *(unint64_t *)((char *)a4 + 20);
              BOOL v21 = v34 > v35;
              if (v34 < v35) {
                goto LABEL_10;
              }
LABEL_52:
              if (!v21)
              {
LABEL_22:
                int v15 = 0;
                goto LABEL_27;
              }

              break;
            case 17:
              unint64_t v30 = *(unint64_t *)((char *)a2 + 12);
              unint64_t v31 = *(unint64_t *)((char *)a4 + 12);
              if (v30 < v31) {
                goto LABEL_10;
              }
              if (v30 == v31) {
                goto LABEL_22;
              }
              BOOL v21 = v30 > v31;
              goto LABEL_52;
            case 19:
              unint64_t v32 = *(unint64_t *)((char *)a2 + 12);
              unint64_t v33 = *(unint64_t *)((char *)a4 + 12);
              BOOL v29 = v32 > v33;
              if (v32 < v33) {
                goto LABEL_10;
              }
              goto LABEL_50;
            default:
              return v11;
          }
        }
      }
    }

    int v15 = 1;
    goto LABEL_27;
  }

  return v11;
}

uint64_t sub_10003A954(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a2 >= a4) {
    unint64_t v4 = a4;
  }
  else {
    unint64_t v4 = a2;
  }
  if (!v4 || (unint64_t v5 = v4 - 1, v4 == 1))
  {
LABEL_13:
    if (a2 < a4) {
      return 0xFFFFFFFFLL;
    }
    else {
      return a2 > a4;
    }
  }

  else
  {
    unint64_t v6 = 0LL;
    while (1)
    {
      int v7 = *(unsigned __int8 *)(a1 + v6);
      uint64_t v8 = v7 - *(unsigned __int8 *)(a3 + v6);
      if ((_DWORD)v8) {
        break;
      }
      ++v6;
      if (v7) {
        BOOL v9 = v6 >= v5;
      }
      else {
        BOOL v9 = 1;
      }
      if (v9) {
        goto LABEL_13;
      }
    }
  }

  return v8;
}

uint64_t sub_10003A9B8( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t a6, unint64_t a7)
{
  v52[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  v47[0] = 0LL;
  v47[1] = a3;
  unint64_t v49 = 0xAAAAAAAA00000EE0LL;
  uint64_t v50 = a6;
  __int128 v51 = a7;
  v52[0] = 0LL;
  LOWORD(v52[1]) = a5;
  unint64_t v48 = calloc(1uLL, 0xEE0uLL);
  if (v48)
  {
    uint64_t v18 = sub_10002A1E0(a1, (uint64_t)a2, v47);
    if ((_DWORD)v18)
    {
      uint64_t v26 = v18;
      sub_100040B90("failed to init fsroot tree for lookup in directory\n", v19, v20, v21, v22, v23, v24, v25, v42);
      uint64_t v27 = 1285LL;
    }

    else
    {
      uint64_t v28 = sub_10003ABE0((uint64_t)&v51 + 8, a4);
      if (!(_DWORD)v28)
      {
        while (1)
        {
          unsigned int v37 = DWORD2(v51) - 1;
          if (SDWORD2(v51) < 1) {
            break;
          }
          --DWORD2(v51);
          unint64_t v45 = *((void *)v52[0] + v37) & 0xFFFFFFFFFFFFFFFLL | 0x9000000000000000LL;
          __int16 v46 = 0;
          unint64_t v43 = v45;
          int v44 = 0;
          uint64_t v38 = *(void *)(a2[5] + 56LL);
          if ((v38 & 9) != 0) {
            unint64_t v39 = (unsigned __int8 *)&v43;
          }
          else {
            unint64_t v39 = (unsigned __int8 *)&v45;
          }
          if ((v38 & 9) != 0) {
            uint64_t v40 = 12LL;
          }
          else {
            uint64_t v40 = 10LL;
          }
          uint64_t v41 = sub_10003AC6C(a1, a2, a3, 1, v39, v40, (uint64_t (*)(void))sub_10003AE50, (uint64_t)v47);
          if ((_DWORD)v41) {
            return v41;
          }
        }

        uint64_t v26 = 0LL;
        goto LABEL_8;
      }

      uint64_t v26 = v28;
      sub_100040B90( "failed to allocate dir-stack memory for lookup in directory\n",  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v42);
      uint64_t v27 = 1286LL;
    }

    sub_100044E7C((char *)v27, v26);
LABEL_8:
    if (v48) {
      free(v48);
    }
    goto LABEL_10;
  }

  sub_100040B90("failed to allocate memory for lookup in directory\n", v11, v12, v13, v14, v15, v16, v17, v42);
  uint64_t v26 = 12LL;
  sub_100044E7C((char *)0x504, 12);
LABEL_10:
  if (v52[0]) {
    free(v52[0]);
  }
  return v26;
}

uint64_t sub_10003AB6C( uint64_t a1, void *a2, int a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a3)
  {
    case 1:
    case 11:
      return sub_100029FA4(a1, (uint64_t)a2, a4);
    case 2:
      return sub_10002A054(a1, (uint64_t)a2, a4);
    case 3:
    case 4:
    case 5:
    case 9:
    case 10:
    case 12:
    case 13:
      goto LABEL_2;
    case 6:
    case 7:
    case 18:
    case 19:
      goto LABEL_8;
    case 8:
      uint64_t v9 = a2[6];
      if (!v9) {
        uint64_t v9 = a2[5];
      }
      if ((*(_BYTE *)(v9 + 56) & 0x20) != 0)
      {
        uint64_t result = sub_10002A104(a1, a2, a4, (uint64_t)a4, a5, a6, a7, a8);
      }

      else
      {
LABEL_8:
        if (*(void *)(a2[5] + 1096LL)) {
          uint64_t result = sub_10002A2AC(a1, (uint64_t)a2, a4);
        }
        else {
LABEL_2:
        }
          uint64_t result = sub_10002A1E0(a1, (uint64_t)a2, a4);
      }

      break;
    default:
      uint64_t result = 22LL;
      break;
  }

  return result;
}

uint64_t sub_10003ABE0(uint64_t a1, uint64_t a2)
{
  int v5 = *(_DWORD *)a1;
  int v4 = *(_DWORD *)(a1 + 4);
  if (*(_DWORD *)a1 >= v4)
  {
    if (v5 > 4095) {
      return 12LL;
    }
    int v7 = v4 ? 2 * v4 : 32;
    unint64_t v6 = realloc(*(void **)(a1 + 8), 8LL * v7);
    if (!v6) {
      return 12LL;
    }
    *(void *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 4) = v7;
    int v5 = *(_DWORD *)a1;
  }

  else
  {
    unint64_t v6 = *(void **)(a1 + 8);
  }

  uint64_t v8 = 0LL;
  *(_DWORD *)a1 = v5 + 1;
  v6[v5] = a2;
  return v8;
}

uint64_t sub_10003AC6C( uint64_t a1, void *a2, uint64_t a3, int a4, unsigned __int8 *a5, uint64_t a6, uint64_t (*a7)(void), uint64_t a8)
{
  unsigned int v9 = a6;
  uint64_t v13 = *(void *)a5 >> 60;
  if ((_DWORD)v13 == 14) {
    LODWORD(v13) = a5[8];
  }
  uint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = sub_10003AB6C(a1, a2, v13, &v48, (uint64_t)a5, a6, (uint64_t)a7, a8);
  if ((_DWORD)v14)
  {
    uint64_t v15 = v14;
    char v16 = strerror(v14);
    sub_100040B90("unable to init fsroot tree: %s\n", v17, v18, v19, v20, v21, v22, v23, v16);
    uint64_t v24 = 1085LL;
LABEL_7:
    sub_100044E7C((char *)v24, v15);
    return v15;
  }

  *(void *)&__int128 v25 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v46 = v25;
  __int128 v47 = v25;
  __int128 v44 = v25;
  __int128 v45 = v25;
  __int128 v43 = v25;
  uint64_t v26 = sub_100035838((uint64_t)&v43, v48, a3, a5, v9);
  if ((_DWORD)v26)
  {
    uint64_t v15 = v26;
    char v27 = strerror(v26);
    sub_100040B90("unable to init fsroot tree iterator: %s\n", v28, v29, v30, v31, v32, v33, v34, v27);
    uint64_t v24 = 1086LL;
    goto LABEL_7;
  }

  if ((void)v44)
  {
    uint64_t v36 = *(void *)a5 >> 60;
    if ((_DWORD)v36 == 14) {
      LODWORD(v36) = a5[8];
    }
    uint64_t v37 = *(void *)v44 >> 60;
    if ((_DWORD)v37 == 14) {
      LODWORD(v37) = *(unsigned __int8 *)(v44 + 8);
    }
    BOOL v38 = v36 == v37;
  }

  else
  {
    BOOL v38 = 0;
  }

  LODWORD(v15) = 0;
  if (!BYTE8(v45))
  {
    int v39 = a4 ^ 1;
    if (v38 | v39)
    {
      while (1)
      {
        if (v38)
        {
          int v40 = a7();
          if (v40) {
            break;
          }
        }

        int v40 = (*((uint64_t (**)(__int128 *))&v43 + 1))(&v43);
        if (v40) {
          break;
        }
        if ((void)v44)
        {
          uint64_t v41 = *(void *)a5 >> 60;
          if ((_DWORD)v41 == 14) {
            LODWORD(v41) = a5[8];
          }
          uint64_t v42 = *(void *)v44 >> 60;
          if ((_DWORD)v42 == 14) {
            LODWORD(v42) = *(unsigned __int8 *)(v44 + 8);
          }
          BOOL v38 = v41 == v42;
        }

        else
        {
          BOOL v38 = 0;
        }

        LODWORD(v15) = 0;
        if (BYTE8(v45) || ((v38 | v39) & 1) == 0) {
          goto LABEL_32;
        }
      }

      LODWORD(v15) = v40;
    }
  }

uint64_t sub_10003AE50(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unsigned int v47 = 8;
  uint64_t v7 = *(void *)(a5 + 8);
  uint64_t v8 = *(_WORD **)(a5 + 16);
  uint64_t v48 = *a3 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000LL;
  *(_DWORD *)(a5 + 24) = 3808;
  uint64_t v9 = sub_100034BB4(*(void *)a5, v7, 0LL, &v48, &v47, 8u, v8, (unsigned int *)(a5 + 24));
  if ((_DWORD)v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = 0LL;
    if ((_DWORD)v9 != 2)
    {
      uint64_t v12 = *a3;
      strerror(v9);
      sub_100040B90( "unable to load inode (oid 0x%llx) for lookup in purgatory directory: %s\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v12);
      sub_100044E7C((char *)0x501, v10);
      return v10;
    }
  }

  else
  {
    uint64_t v20 = (*(uint64_t (**)(uint64_t *, void, _WORD *, void, void))(a5 + 32))( &v48,  v47,  v8,  *(unsigned int *)(a5 + 24),  *(void *)(a5 + 40));
    if (!(_DWORD)v20)
    {
      if ((v8[40] & 0xF000) == 0x4000)
      {
        uint64_t v11 = sub_10003ABE0(a5 + 48, *a3);
        if (!(_DWORD)v11) {
          return v11;
        }
        sub_100044E7C((char *)0x503, v11);
        if (!*(_BYTE *)(a5 + 64))
        {
          sub_100040B90( "failed to allocate dir-stack memory for lookup in directory\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v46);
          return v11;
        }

        if (!*(_BYTE *)(a5 + 65))
        {
          char v38 = strerror(v11);
          sub_100040C68( "failed to allocate dir-stack memory for lookup in directory: %s; results may be incomplete\n",
            v39,
            v40,
            v41,
            v42,
            v43,
            v44,
            v45,
            v38);
          uint64_t v11 = 0LL;
          *(_BYTE *)(a5 + 65) = 1;
          return v11;
        }
      }

      return 0LL;
    }

    uint64_t v11 = v20;
    if ((_DWORD)v20 == -1)
    {
      uint64_t v21 = *(void **)(a5 + 56);
      if (v21) {
        free(v21);
      }
      *(void *)(a5 + 48) = 0LL;
      *(void *)(a5 + 56) = 0LL;
      return 0xFFFFFFFFLL;
    }

    else
    {
      uint64_t v29 = *a3;
      strerror(v20);
      sub_100040B90( "failed to run predicate callback on inode (oid 0x%llx) for lookup in directory: %s\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v29);
      sub_100044E7C((char *)0x502, v11);
    }
  }

  return v11;
}

uint64_t sub_10003B000(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t v104 = 0LL;
  unsigned int v101 = 3808;
  unsigned int v102 = 8;
  *a5 = 0;
  if (!a4) {
    return 0LL;
  }
  uint64_t v6 = a4;
  uint64_t v10 = calloc(1uLL, 0xEE0uLL);
  if (!v10)
  {
    sub_100040B90( "failed to allocate memory for file lookup in purgatory directory\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v98);
    uint64_t v27 = 12LL;
    sub_100044E7C((char *)0x32C, 12);
    return v27;
  }

  uint64_t v18 = v10;
  uint64_t v103 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v19 = sub_10002A1E0(a1, a2, &v104);
  if ((_DWORD)v19)
  {
    uint64_t v27 = v19;
    sub_100040B90( "failed to init fsroot tree for file lookup in purgatory directory\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v98);
    sub_100044E7C((char *)0x325, v27);
    goto LABEL_55;
  }

  if ((unint64_t)(v6 - 3) > 0xFFFFFFFFFFFFFFFDLL)
  {
LABEL_54:
    uint64_t v27 = 0LL;
    goto LABEL_55;
  }

  unint64_t v28 = 0LL;
  uint64_t v99 = a3;
  while (1)
  {
    uint64_t v29 = calloc(1uLL, 0x340uLL);
    uint64_t v30 = calloc(1uLL, 0xEE0uLL);
    char v38 = v30;
    if (!v29 || !v30)
    {
      sub_100040B90( "failed to allocate memory for file lookup in purgatory directory\n",  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v98);
      uint64_t v27 = 12LL;
      sub_100044E7C((char *)0x32B, 12);
      if (!v29)
      {
        if (!v38) {
          goto LABEL_16;
        }
LABEL_15:
        free(v38);
        goto LABEL_16;
      }

      goto LABEL_51;
    }

    unint64_t v100 = v28;
    *(void *)&__int128 v39 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v112 = v39;
    __int128 v113 = v39;
    *(_OWORD *)__str = v39;
    __int128 v111 = v39;
    snprintf(__str, 0x40uLL, "0x%llx-dead", v6);
    uint64_t v107 = 0LL;
    unint64_t v40 = *(void *)(*(void *)(a2 + 40) + 56LL);
    unsigned int v106 = 18;
    size_t v41 = strlen(__str);
    *a5 = 0;
    uint64_t v42 = sub_10002A1E0(a1, a2, &v107);
    if ((_DWORD)v42)
    {
      uint64_t v27 = v42;
      sub_100040B90("failed to init fsroot tree for file lookup in directory\n", v43, v44, v45, v46, v47, v48, v49, v98);
      sub_100044E7C((char *)0x329, v27);
      a3 = v99;
      unint64_t v28 = v100;
      goto LABEL_51;
    }

    __int16 v79 = v41 + 1;
    *(void *)uint64_t v29 = 0x9000000000000003LL;
    if ((v40 & 9) != 0)
    {
      int v105 = -1;
      if (sub_1000034D8( (unint64_t)__str,  v41,  (v40 >> 3) & 1,  (void (*)(_OWORD *, uint64_t, uint64_t))sub_10003BE5C,  (uint64_t)&v105))
      {
        a3 = v99;
        unint64_t v28 = v100;
        goto LABEL_46;
      }

      __memcpy_chk(v29 + 3, __str, v41 + 1, 820LL);
      _OWORD v29[2] = v79 & 0x3FF | (v105 << 10);
      int v80 = v41 + 13;
    }

    else
    {
      __memcpy_chk((char *)v29 + 10, __str, v41 + 1, 822LL);
      *((_WORD *)v29 + 4) = v79;
      int v80 = v41 + 11;
    }

    LODWORD(v109) = v80;
    a3 = v99;
    uint64_t v81 = sub_100034BB4(v107, v99, 0LL, v29, (unsigned int *)&v109, 0x340u, v38, &v106);
    unint64_t v28 = v100;
    if ((_DWORD)v81 != 2)
    {
      uint64_t v27 = v81;
      if ((_DWORD)v81)
      {
        strerror(v81);
        sub_100040B90( "unable to load drec (oid 0x%llx) for file lookup in directory\n: %s\n",  v82,  v83,  v84,  v85,  v86,  v87,  v88,  3);
        sub_100044E7C((char *)0x321, v27);
        goto LABEL_51;
      }

      *a5 = 1;
      goto LABEL_47;
    }

uint64_t sub_10003B518(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return sub_100034B44( a1,  a2,  a3,  *(_DWORD *)(*(void *)(a3 + 40) + 120LL) & 0xC0000000,  (unsigned __int16)*(_DWORD *)(*(void *)(a3 + 40) + 120LL),  15,  0,  *(_DWORD *)(*(void *)(a2 + 8) + 36LL),  0,  0,  0,  *(void *)(*(void *)(a3 + 40) + 144LL),  (uint64_t)sub_10003A6AC);
  }
  uint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = sub_100029FA4(a2, a3, &v31);
  if (!(_DWORD)v8)
  {
    uint64_t v9 = malloc(0x340uLL);
    uint64_t v10 = malloc(0xEE0uLL);
    uint64_t v18 = v10;
    if (v9 && v10)
    {
      *uint64_t v9 = a4 & 0xFFFFFFFFFFFFFFFLL | 0x1000000000000000LL;
      unsigned int v29 = 3808;
      unsigned int v30 = 8;
      uint64_t v19 = sub_100034BB4(v31, 0LL, 0LL, v9, &v30, 0x340u, v10, &v29);
      if ((_DWORD)v19)
      {
        uint64_t v8 = v19;
        strerror(v19);
        sub_100040B90( "failed to lookup extentref tree oid at snap_xid %llu : %s\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  a4);
      }

      else
      {
        uint64_t v8 = sub_100034B44( a1,  a2,  a3,  v18[10] & 0xC0000000,  (unsigned __int16)v18[10],  15,  0,  *(_DWORD *)(*(void *)(a2 + 8) + 36LL),  0,  0,  0,  *(void *)v18,  (uint64_t)sub_10003A6AC);
      }
    }

    else
    {
      sub_100040B90("failed to allocate memory for the extentref tree\n", v11, v12, v13, v14, v15, v16, v17, v28);
      uint64_t v8 = 12LL;
      if (!v9)
      {
LABEL_12:
        if (v18) {
          free(v18);
        }
        return v8;
      }
    }

    free(v9);
    goto LABEL_12;
  }

  return v8;
}

uint64_t sub_10003B6C4( unsigned __int16 *a1, unsigned int a2, int a3, void *a4, _WORD *a5, _DWORD *a6, unsigned int *a7)
{
  if (a2 < 4) {
    return 92LL;
  }
  uint64_t v7 = *a1;
  if (!*a1) {
    return 2LL;
  }
  uint64_t v9 = 0LL;
  unsigned int v10 = 0;
  for (unint64_t i = a1 + 3; ; i += 2)
  {
    uint64_t v12 = *i;
    v10 += (v12 + 7) & 0x1FFF8;
    if (v7 == ++v9) {
      return 2LL;
    }
  }

  uint64_t v13 = a1[1];
  if (a4) {
    *a4 = (char *)&a1[2 * v7 + 2] + v10;
  }
  if (a5) {
    *a5 = v12;
  }
  if (a6) {
    *a6 = v9;
  }
  uint64_t result = 0LL;
  if (a7) {
    *a7 = v10;
  }
  return result;
}

uint64_t sub_10003B77C( unsigned __int16 *a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a6;
  unsigned int v9 = a5;
  char v11 = a3;
  unsigned __int16 v13 = (a5 + 7) & 0xFFF8;
  uint64_t v15 = a1 + 2;
  uint64_t v14 = *a1;
  if (*a1)
  {
    uint64_t v16 = a1[1];
    unsigned int v17 = 0;
    uint64_t v18 = a1 + 3;
    uint64_t v19 = *a1;
    do
    {
      int v20 = *v18;
      v18 += 2;
      v17 += (v20 + 7) & 0x1FFF8;
      --v19;
    }

    while (v19);
    if (v17 >= 0x10000)
    {
      sub_100040B90("xf: xf total size (%u) is larger than UINT16_MAX\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, v17);
      uint64_t v21 = 92LL;
      sub_100044E7C((char *)0x43F, 92);
      return v21;
    }
  }

  else
  {
    unsigned int v17 = 0;
    LODWORD(v--*(_DWORD *)(result + 16) = a1[1];
  }

  uint64_t v22 = &v15[2 * v14];
  if (v17 != (_DWORD)v16)
  {
    if (v17 <= v16)
    {
      sub_100040C68("xf: xf_used_data (%u) is larger than expected (%u)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, v16);
      sub_100044E7C((char *)0x440, -11);
      if (sub_1000428C4(qword_10008DB70, "Fix xf_used_data? ", v23, v24, v25, v26, v27, v28, v32))
      {
        bzero((char *)v22 + v17, a1[1] - v17);
        a1[1] = v17;
        LOWORD(v--*(_DWORD *)(result + 16) = v17;
        goto LABEL_14;
      }
    }

    return 92LL;
  }

uint64_t sub_10003B954(unsigned __int16 *a1, unsigned int *a2, int a3)
{
  __dst = 0LL;
  unsigned __int16 v15 = 0;
  unsigned int v13 = 0;
  int v14 = 0;
  uint64_t v6 = a1 + 2;
  uint64_t v5 = *a1;
  uint64_t result = sub_10003B6C4(a1, *a2, a3, &__dst, &v15, &v14, &v13);
  if (!(_DWORD)result)
  {
    uint64_t v8 = (v15 + 7) & 0x1FFF8;
    unint64_t v9 = (a1[1] + 7) & 0x1FFF8;
    unint64_t v10 = v8 + v13;
    if (v9 >= v10)
    {
      memmove(__dst, (char *)__dst + v8, v9 - v10);
      a1[1] -= v8;
      memmove(&v6[2 * v14], &v6[2 * v14 + 2], 4LL * (*a1 + ~v14));
      unsigned __int16 v11 = *a1 - 1;
      *a1 = v11;
      memmove(&v6[2 * v11], &v6[2 * v5], a1[1]);
      int v12 = *a1;
      if (*a1) {
        int v12 = a1[1] + 4 * v12 + 4;
      }
      uint64_t result = 0LL;
      *a2 = v12;
    }

    else
    {
      return 92LL;
    }
  }

  return result;
}

uint64_t sub_10003BA64( int a1, uint64_t a2, uint64_t *a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a1)
  {
    case 9:
      uint64_t v8 = a2 + 18;
      int v9 = 18;
      goto LABEL_9;
    case 10:
    case 11:
    case 12:
    case 14:
    case 15:
    case 17:
      goto LABEL_5;
    case 13:
    case 16:
      uint64_t v8 = a2 + 24;
      int v9 = 24;
      goto LABEL_9;
    case 18:
      uint64_t v8 = a2 + 52;
      int v9 = 52;
      goto LABEL_9;
    case 19:
      uint64_t v8 = a2 + 8;
      int v9 = 8;
      goto LABEL_9;
    default:
      if (a1 == 3)
      {
        uint64_t v8 = a2 + 92;
        int v9 = 92;
LABEL_9:
        uint64_t v10 = 0LL;
        *a3 = v8;
        *a4 = v9;
      }

      else
      {
LABEL_5:
        sub_100040B90("unknown obj type (%u) to add xfields\n", a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, a1);
        uint64_t v10 = 22LL;
        sub_100044E7C((char *)0x565, 22);
      }

      return v10;
  }

uint64_t sub_10003BB1C(const void *a1, int *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t *a6)
{
  return sub_10003BB44(3, a1, a2, a3, a4, a5, (void (*)(uint64_t, const void *, uint64_t))sub_10003BCD0, a6);
}

uint64_t sub_10003BB44( int a1, const void *a2, int *a3, uint64_t a4, const void *a5, uint64_t a6, void (*a7)(uint64_t, const void *, uint64_t), uint64_t *a8)
{
  uint64_t v43 = 0LL;
  uint64_t v16 = sub_10003BCF4(a1, (uint64_t)a2, *a3, a4, a6, &v43, (uint64_t)a7, (uint64_t)a8);
  uint64_t v21 = v16;
  if ((v16 & 0xFFFFFFFD) == 0)
  {
    if ((_DWORD)v16 != 2)
    {
      a7(v43, a5, a6);
      return 0LL;
    }

    uint64_t v45 = 0LL;
    int v44 = 0;
    uint64_t v21 = sub_10003BA64(a1, (uint64_t)a2, (uint64_t *)&v45, &v44, v17, v18, v19, v20);
    if (!(_DWORD)v21)
    {
      int v22 = *a3;
      int v23 = v44;
      unsigned int v24 = a6 + *a3 + 4 * (*a3 == v44) + 4;
      uint64_t v25 = calloc(1uLL, v24);
      *a8 = (uint64_t)v25;
      if (!v25)
      {
        sub_100040B90("failed to allocate memory to add an xfield\n", v26, v27, v28, v29, v30, v31, v32, v41);
        uint64_t v21 = 12LL;
        sub_100044E7C((char *)0x441, 12);
        return v21;
      }

      int v42 = v23;
      memcpy(v25, a2, *a3);
      *a3 = v24;
      uint64_t v21 = sub_10003BA64(a1, *a8, (uint64_t *)&v45, &v44, v33, v34, v35, v36);
      if (!(_DWORD)v21)
      {
        __int128 v39 = (unsigned __int16 *)v45;
        if (v22 == v42) {
          bzero(v45, v24 - v42);
        }
        uint64_t v21 = sub_10003B77C(v39, v24 - v42, a4, a5, a6, 16LL, v37, v38);
        if (!(_DWORD)v21) {
          return 0LL;
        }
      }
    }
  }

  return v21;
}

void *sub_10003BCD0(void *a1, const void *a2, size_t __n)
{
  return memcpy(a1, a2, __n);
}

uint64_t sub_10003BCD8( uint64_t a1, int a2, int a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10003BCF4(3, a1, a2, a3, a4, a5, a7, a8);
}

uint64_t sub_10003BCF4(int a1, uint64_t a2, int a3, int a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  int v9 = a5;
  unsigned __int16 v15 = 0;
  int v14 = 0LL;
  int v13 = 0;
  uint64_t result = sub_10003BA64(a1, a2, (uint64_t *)&v14, &v13, a5, (uint64_t)a6, a7, a8);
  if (!(_DWORD)result)
  {
    if (a3 == v13)
    {
      return 2LL;
    }

    else
    {
      uint64_t result = sub_10003B6C4(v14, a3 - v13, a4, a6, &v15, 0LL, 0LL);
      if (!(_DWORD)result)
      {
        if (v15 == v9) {
          return 0LL;
        }
        else {
          return 34LL;
        }
      }
    }
  }

  return result;
}

uint64_t sub_10003BD8C(const void *a1, int *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = a3;
  return sub_10003BB44( 3,  a1,  a2,  13LL,  &v5,  8LL,  (void (*)(uint64_t, const void *, uint64_t))sub_10003BDD4,  a4);
}

char *sub_10003BDD4( char *result, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8 = __CFADD__(*(void *)result, *a2);
  uint64_t v9 = *(void *)result + *a2;
  *(void *)uint64_t result = v9;
  if (v8)
  {
    uint64_t v10 = result;
    sub_100040C68("sparse bytes overflow (current %llu, update %llu)\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v9);
    uint64_t result = sub_100044E7C((char *)0x442, 92);
    *(void *)uint64_t v10 = -1LL;
  }

  return result;
}

uint64_t sub_10003BE34(const void *a1, int *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t *a6)
{
  return sub_10003BB44(18, a1, a2, a3, a4, a5, (void (*)(uint64_t, const void *, uint64_t))sub_10003BCD0, a6);
}

uint64_t sub_10003BE5C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = off_10008D690(*a3, a1, a2);
  *a3 = result;
  return result;
}

char *sub_10003BE98(unsigned int a1)
{
  if (a1 < 0x15) {
    return off_10006C838[a1];
  }
  uint64_t v1 = byte_10008C9D8;
  snprintf(byte_10008C9D8, 0x20uLL, "Unknown type %d", a1);
  return v1;
}

double sub_10003BEF4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 40);
  dword_10008C9F8 = *(_DWORD *)(v2 + 36);
  unint64_t v4 = sub_10001A774(0x64u, 0x38400000uLL, 0x5A00000uLL);
  if (!sub_100034B44( (uint64_t)dword_10008DFF0,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  32,  16,  0,  0LL,  (uint64_t)sub_10003C158)) {
    sub_100036C00((uint64_t)dword_10008DFF0, 0LL, 0);
  }
  byte_10008CA00 = 1;
  if (!sub_100034B44( (uint64_t)dword_10008E030,  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  24,  16,  0,  0LL,  (uint64_t)sub_10003C188)) {
    sub_100036C00((uint64_t)dword_10008E030, 0LL, 0);
  }
  for (uint64_t i = 0LL; i != 48; i += 16LL)
  {
    if (!sub_100034B44( (uint64_t)&dword_10008E070[i],  0LL,  0LL,  0x8000000,  2,  0,  0,  4096,  16,  8,  0,  0LL,  (uint64_t)sub_10003C1E4)) {
      sub_100036C00((uint64_t)&dword_10008E070[i], 0LL, 0);
    }
  }

  byte_10008CA01 = 1;
  sub_10001D49C((uint64_t)&unk_10008DEB8, v3, v4);
  byte_10008CA02[0] = 0;
  byte_10008CA04[0] = 1;
  if ((*(_BYTE *)(*(void *)(a1 + 8) + 65LL) & 1) != 0)
  {
    sub_10001D49C((uint64_t)&unk_10008DF20, v3, v4);
    byte_10008CA03 = 0;
    byte_10008CA05 = 1;
  }

  sub_10001D49C((uint64_t)&unk_10008DF88, v3, v4);
  bzero(qword_10008CA08, 0x640uLL);
  int v6 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  for (uint64_t j = 184LL; j != 984; j += 8LL)
  {
    uint64_t v9 = *(void *)(v7 + j);
    if (v9)
    {
      uint64_t v10 = 2LL * v6++;
      qword_10008CA08[v10] = v9;
    }
  }

  double result = 0.0;
  xmmword_10008D088 = 0u;
  unk_10008D098 = 0u;
  xmmword_10008D068 = 0u;
  unk_10008D078 = 0u;
  xmmword_10008D048 = 0u;
  unk_10008D058 = 0u;
  return result;
}

uint64_t sub_10003C158(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  *a6 = sub_10003C504(a2, a4);
  return 0LL;
}

uint64_t sub_10003C188(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, int *a6)
{
  if (*a2 > *a4) {
    goto LABEL_4;
  }
  if (*a2 < *a4) {
    goto LABEL_6;
  }
  uint64_t v6 = a2[1];
  uint64_t v7 = a4[1];
  if (v6 > v7)
  {
LABEL_4:
    int v8 = 1;
    goto LABEL_7;
  }

  if (v6 < v7)
  {
LABEL_6:
    int v8 = -1;
    goto LABEL_7;
  }

  unint64_t v10 = a2[2];
  unint64_t v11 = a4[2];
  BOOL v12 = v10 > v11;
  if (v10 >= v11) {
    int v8 = 0;
  }
  else {
    int v8 = -1;
  }
  if (v12) {
    int v8 = 1;
  }
LABEL_7:
  *a6 = v8;
  return 0LL;
}

uint64_t sub_10003C1E4(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, int *a6)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = a4[1];
  if (v6 <= v7)
  {
    if (v6 >= v7)
    {
      if (*a2 <= *a4) {
        int v8 = 0;
      }
      else {
        int v8 = -1;
      }
      if (*a2 < *a4) {
        int v8 = 1;
      }
    }

    else
    {
      int v8 = -1;
    }
  }

  else
  {
    int v8 = 1;
  }

  *a6 = v8;
  return 0LL;
}

_DWORD *sub_10003C22C()
{
  for (uint64_t i = 0LL; i != 312; i += 104LL)
    sub_10001D5BC((uint64_t)&unk_10008DEB8 + i);
  for (uint64_t j = 0LL; j != 48; j += 16LL)
  {
    double result = &dword_10008E070[j];
    if (*(void *)&dword_10008E070[j + 14]) {
      double result = (_DWORD *)sub_100036CD8((uint64_t)result, 0LL);
    }
  }

  return result;
}

uint64_t sub_10003C2B0( uint64_t a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, __int16 a7, __int16 a8)
{
  unint64_t v18 = 0LL;
  uint64_t result = sub_100036AE0((uint64_t)dword_10008DFF0, 0LL, &v18);
  if (byte_10008CA00 == 1 && v18 <= 0x31)
  {
    v17[1] = a2;
    unint64_t v18 = a3;
    int v19 = a4;
    uint64_t v22 = a5;
    uint64_t v23 = a6;
    __int16 v20 = a7;
    __int16 v21 = a8;
    v17[0] = a1;
    return sub_1000364F0(dword_10008DFF0, 0LL, &v18, 32LL, v17, 16LL);
  }

  return result;
}

uint64_t sub_10003C374( unint64_t a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, __int16 a7, __int16 a8, char a9)
{
  unint64_t v28 = 0LL;
  uint64_t v29 = 0LL;
  unint64_t v30 = a3;
  int v31 = a4;
  uint64_t v34 = a5;
  uint64_t v35 = a6;
  __int16 v32 = a7;
  __int16 v33 = a8;
  unsigned int v26 = 16;
  unsigned int v27 = 32;
  __int16 v20 = a8;
  while (1)
  {
    if (a2 + a1 <= v28 || v29 + v28 <= a1) {
      goto LABEL_10;
    }
    a9 = 0;
LABEL_10:
    unsigned int v21 = 16;
    unsigned int v22 = 32;
  }

  if ((a9 & 1) != 0)
  {
    v25[0] = 0LL;
    v25[1] = 0LL;
    unsigned int v23 = 16;
    unsigned int v24 = 32;
  }

  return 1LL;
}

uint64_t sub_10003C504(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 > *(void *)a2) {
    return 1LL;
  }
  if (*(void *)a1 < *(void *)a2) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v2 > v3) {
    return 1LL;
  }
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = *(void *)(a2 + 16);
  if (v4 > v5) {
    return 1LL;
  }
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (!v2)
  {
    unint64_t v14 = *(void *)(a1 + 24);
    unint64_t v15 = *(void *)(a2 + 24);
    if (v14 > v15) {
      return 1LL;
    }
    if (v14 < v15) {
      return 0xFFFFFFFFLL;
    }
  }

  unsigned int v7 = *(unsigned __int16 *)(a1 + 12);
  unsigned int v8 = *(unsigned __int16 *)(a2 + 12);
  if (v7 > v8) {
    return 1LL;
  }
  if (v7 < v8) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v9 = *(unsigned __int16 *)(a1 + 14);
  unsigned int v10 = *(unsigned __int16 *)(a2 + 14);
  BOOL v11 = v9 >= v10;
  BOOL v12 = v9 == v10;
  if (v9 >= v10) {
    unsigned int v13 = 0;
  }
  else {
    unsigned int v13 = -1;
  }
  if (!v12 && v11) {
    return 1LL;
  }
  else {
    return v13;
  }
}

BOOL sub_10003C59C()
{
  uint64_t v1 = 0LL;
  sub_100036AE0((uint64_t)dword_10008DFF0, 0LL, &v1);
  return v1 != 0;
}

uint64_t sub_10003C5D8()
{
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  v12[0] = 0LL;
  v12[1] = 0LL;
  unsigned int v10 = 16;
  unsigned int v11 = 32;
  for (uint64_t result = sub_100034BB4((uint64_t)dword_10008DFF0, 0LL, 1LL, &v13, &v11, 0x20u, v12, &v10);
        !(_DWORD)result;
        uint64_t result = sub_100034BB4((uint64_t)dword_10008DFF0, 0LL, 2LL, &v13, &v9, 0x20u, v12, &v8))
  {
    sub_100040C68( "Overlapping object: (oid : 0x%llx) (type : %u) (subtype : %u), (%llu + %llu)\n",  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v14);
    unsigned int v8 = 16;
    unsigned int v9 = 32;
  }

  return result;
}

uint64_t sub_10003C6A4(uint64_t *a1)
{
  __int128 v219 = 0u;
  __int128 v220 = 0u;
  unint64_t v217 = 0LL;
  unint64_t v218 = 0LL;
  unsigned int v215 = 16;
  unsigned int v216 = 32;
  uint64_t v2 = 0LL;
  do
  {
    if (DWORD2(v219) != 0x40000000 || *((void *)&v220 + 1) != 0LL || WORD6(v219) != 0 || HIWORD(v219) != 15) {
      goto LABEL_60;
    }
    uint64_t v213 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v214 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v212 = 0LL;
    v210[0] = 0LL;
    v210[1] = 0LL;
    int v211 = 0;
    unsigned int v208 = 20;
    unsigned int v209 = 8;
    uint64_t v206 = 0LL;
    uint64_t v207 = 0LL;
    uint64_t v204 = 0LL;
    uint64_t v205 = 0LL;
    uint64_t v202 = 0LL;
    uint64_t v203 = 0LL;
    if (!sub_10003C374(v217, v218, v219, 0x40000000, v220, 0LL, 0, 15, 0))
    {
      __int128 v221 = v219;
      __int128 v222 = v220;
      sub_100036AC4((uint64_t)dword_10008DFF0, 0LL, (uint64_t)&v221, 32LL);
      unint64_t v15 = 0LL;
      goto LABEL_52;
    }

    uint64_t v7 = sub_10001CA50((uint64_t)a1, v219);
    unint64_t v15 = (int8x16_t *)v7;
    if (!v7)
    {
      sub_100040C68( "repair_overlapped_extents: unable to find volume for fs_oid 0x%llx\n",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v219);
      uint64_t v22 = 604LL;
      int v23 = 2;
      goto LABEL_51;
    }

    uint64_t v16 = *((void *)v7 + 5);
    uint64_t v17 = *(void *)(v16 + 976);
    if ((*(_BYTE *)(v16 + 264) & 1) != 0)
    {
      if (v17)
      {
LABEL_26:
        sub_100040B90( "repair_overlapped_extents: encryption is rolling for fs_oid 0x%llx\n",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v219);
        if ((_DWORD)v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = 16LL;
        }
        uint64_t v22 = 605LL;
        int v23 = 16;
        goto LABEL_51;
      }
    }

    else
    {
      if (v17) {
        goto LABEL_26;
      }
      if (v7[8])
      {
        unsigned int v18 = sub_1000416DC((const char **)v7, a1, 2);
        if (v18)
        {
          if ((_DWORD)v2) {
            uint64_t v2 = v2;
          }
          else {
            uint64_t v2 = v18;
          }
          goto LABEL_52;
        }
      }
    }

    unsigned int v24 = sub_10003AB6C((uint64_t)a1, v15, 8, (uint64_t *)&v214, v11, v12, v13, v14);
    if (v24)
    {
      unsigned int v32 = v24;
      sub_100040B90( "repair_overlapped_extents: unable to init fsroot for fs_oid 0x%llx\n",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v219);
      if ((_DWORD)v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v32;
      }
      uint64_t v22 = 606LL;
      goto LABEL_50;
    }

    unsigned int v33 = sub_10002A054((uint64_t)a1, (uint64_t)v15, (uint64_t *)&v213);
    if (v33)
    {
      unsigned int v32 = v33;
      sub_100040B90( "repair_overlapped_extents: unable to init extentref tree for fs_oid 0x%llx\n",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v219);
      if ((_DWORD)v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v32;
      }
      uint64_t v22 = 607LL;
      goto LABEL_50;
    }

    uint64_t v212 = v220 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000LL;
    int v41 = sub_100034BB4((uint64_t)v213, 0LL, 0LL, &v212, &v209, v209, v210, &v208);
    if (v41)
    {
      unsigned int v32 = v41;
      char v187 = v220;
      strerror(v41);
      sub_100040B90( "repair_overlapped_extents: unable to load pext 0x%llx for fs_oid 0x%llx: %s\n",  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v187);
      if ((_DWORD)v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v32;
      }
      uint64_t v22 = 608LL;
      goto LABEL_50;
    }

    int v188 = v211;
    sub_100040B50( "repair_overlapped_extents: allocate space for block_count 0x%llx\n",  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v218);
    int v56 = sub_100002228(a1, v15, 3u, v218, &v207);
    if (v56)
    {
      unsigned int v32 = v56;
      char v64 = v218;
      strerror(v56);
      sub_100040B90( "repair_overlapped_extents: unable to allocate space for block_count 0x%llx: %s\n",  v65,  v66,  v67,  v68,  v69,  v70,  v71,  v64);
      if ((_DWORD)v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v32;
      }
      uint64_t v22 = 609LL;
      goto LABEL_50;
    }

    sub_100040B50( "repair_overlapped_extents: copy paddr 0x%llx to paddr 0x%llx, block_count 0x%llx\n",  v57,  v58,  v59,  v60,  v61,  v62,  v63,  v217);
    int v82 = sub_10002E1E0(a1, v217, v207, v218);
    if (v82)
    {
      unsigned int v90 = v82;
      char v189 = v217;
      strerror(v82);
      sub_100040B90( "repair_overlapped_extents: failed to copy paddr 0x%llx to paddr 0x%llx, block_count 0x%llx: %s\n",  v91,  v92,  v93,  v94,  v95,  v96,  v97,  v189);
      if ((_DWORD)v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v90;
      }
      goto LABEL_52;
    }

    uint64_t v212 = v207 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000LL;
    sub_100040B50("repair_overlapped_extents: insert target pext 0x%llx\n", v83, v84, v85, v86, v87, v88, v89, v207);
    int v98 = sub_1000364F0(v213, 0LL, &v212, v209, v210, v208);
    if (v98)
    {
      unsigned int v32 = v98;
      char v190 = v207;
      strerror(v98);
      sub_100040B90( "repair_overlapped_extents: unable to insert target pext 0x%llx for fs_oid 0x%llx: %s\n",  v99,  v100,  v101,  v102,  v103,  v104,  v105,  v190);
      if ((_DWORD)v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v32;
      }
      uint64_t v22 = 613LL;
LABEL_50:
      int v23 = v32;
LABEL_51:
      sub_100044E7C((char *)v22, v23);
      goto LABEL_52;
    }

    uint64_t v204 = v219;
    uint64_t v205 = v220;
    uint64_t v206 = 0LL;
    unsigned int v200 = 16;
    unsigned int v201 = 24;
    if (sub_100034BB4((uint64_t)dword_10008E030, 0LL, 1LL, &v204, &v201, 0x18u, &v202, &v200))
    {
      int v180 = 0;
LABEL_73:
      uint64_t v212 = v220 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000LL;
      sub_100040B50( "repair_overlapped_extents: remove source pext 0x%llx\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v220);
      int v113 = sub_100036AC4((uint64_t)v213, 0LL, (uint64_t)&v212, v209);
      if (v113)
      {
        int v114 = v113;
        char v184 = v220;
        strerror(v113);
        sub_100040B90( "repair_overlapped_extents: unable to remove source pext 0x%llx for fs_oid 0x%llx (pext leak): %s\n",  v115,  v116,  v117,  v118,  v119,  v120,  v121,  v184);
        if (!(_DWORD)v2) {
          LODWORD(v2) = v114;
        }
        sub_100044E7C((char *)0x269, v114);
      }

      __int128 v221 = v219;
      __int128 v222 = v220;
      sub_100036AC4((uint64_t)dword_10008DFF0, 0LL, (uint64_t)&v221, 32LL);
      unsigned int v122 = sub_10003D008(a1, v15, v217, v218);
      if ((_DWORD)v2) {
        unsigned int v123 = v2;
      }
      else {
        unsigned int v123 = v122;
      }
      if (v122) {
        uint64_t v2 = v123;
      }
      else {
        uint64_t v2 = v2;
      }
      goto LABEL_83;
    }

    int v180 = 0;
    int v134 = 0;
    while (1)
    {
      __int128 v221 = 0uLL;
      *(void *)&__int128 v222 = 0LL;
      unsigned int v197 = 24;
      unsigned int v198 = 16;
      if (v204 != (void)v219 || v205 != (void)v220) {
        break;
      }
      int v185 = v134 + 1;
      int v181 = v134;
      v199[0] = v206 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000LL;
      v199[1] = v203;
      sub_100040B50( "repair_overlapped_extents: load fext 0x%llx 0x%llx\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v206);
      int v135 = sub_100034BB4((uint64_t)v214, 0LL, 0LL, v199, &v198, v198, &v221, &v197);
      if (v135)
      {
        unsigned int v143 = v135;
        char v182 = v206;
        strerror(v135);
        sub_100040B90( "repair_overlapped_extents: unable to load fext 0x%llx 0x%llx for fs_oid 0x%llx: %s\n",  v144,  v145,  v146,  v147,  v148,  v149,  v150,  v182);
        if ((_DWORD)v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = v143;
        }
        uint64_t v151 = 614LL;
      }

      else
      {
        *((void *)&v221 + 1) = v207;
        sub_100040B50( "repair_overlapped_extents: update fext 0x%llx 0x%llx\n",  v136,  v137,  v138,  v139,  v140,  v141,  v142,  v206);
        int v152 = sub_1000364F0(v214, 0LL, v199, v198, &v221, v197);
        if (!v152)
        {
          ++v180;
          int v160 = v181;
          goto LABEL_106;
        }

        unsigned int v143 = v152;
        char v183 = v206;
        strerror(v152);
        sub_100040B90( "repair_overlapped_extents: unable to update fext 0x%llx 0x%llx for fs_oid 0x%llx: %s\n",  v153,  v154,  v155,  v156,  v157,  v158,  v159,  v183);
        if ((_DWORD)v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = v143;
        }
        uint64_t v151 = 615LL;
      }

      sub_100044E7C((char *)v151, v143);
      int v160 = v185;
LABEL_106:
      unsigned int v195 = 16;
      unsigned int v196 = 24;
      int v161 = sub_100034BB4((uint64_t)dword_10008E030, 0LL, 2LL, &v204, &v196, 0x18u, &v202, &v195);
      int v134 = v160;
      if (v161) {
        goto LABEL_116;
      }
    }

    int v160 = v134;
LABEL_116:
    if (!v160) {
      goto LABEL_73;
    }
    int v124 = v188;
    if (v160 != v188)
    {
      uint64_t v212 = v220 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000LL;
      int v211 = v160;
      sub_100040B50( "repair_overlapped_extents: update source pext 0x%llx\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v220);
      int v171 = sub_1000364F0(v213, 0LL, &v212, v209, v210, v208);
      if (v171)
      {
        unsigned int v172 = v171;
        char v186 = v220;
        strerror(v171);
        sub_100040B90( "repair_overlapped_extents: unable to update source pext 0x%llx for fs_oid 0x%llx (refcnt leak): %s\n",  v173,  v174,  v175,  v176,  v177,  v178,  v179,  v186);
        if ((_DWORD)v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = v172;
        }
        sub_100044E7C((char *)0x268, v172);
      }

LABEL_83:
      int v124 = v188;
    }

    if (v180)
    {
      if (v180 != v124)
      {
        uint64_t v212 = v207 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000LL;
        int v211 = v180;
        sub_100040B50( "repair_overlapped_extents: update target pext 0x%llx\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v207);
        int v125 = sub_1000364F0(v213, 0LL, &v212, v209, v210, v208);
        if (v125)
        {
          unsigned int v126 = v125;
          char v191 = v207;
          strerror(v125);
          sub_100040B90( "repair_overlapped_extents: unable to target update target pext 0x%llx for fs_oid 0x%llx (refcnt leak): %s\n",  v127,  v128,  v129,  v130,  v131,  v132,  v133,  v191);
          if ((_DWORD)v2) {
            uint64_t v2 = v2;
          }
          else {
            uint64_t v2 = v126;
          }
          sub_100044E7C((char *)0x26A, v126);
        }
      }

      uint64_t v207 = 0LL;
    }

    else
    {
      uint64_t v212 = v207 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000LL;
      sub_100040B50( "repair_overlapped_extents: remove target pext 0x%llx\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v207);
      int v162 = sub_100036AC4((uint64_t)v213, 0LL, (uint64_t)&v212, v209);
      if (v162)
      {
        unsigned int v163 = v162;
        char v192 = v207;
        strerror(v162);
        sub_100040B90( "repair_overlapped_extents: unable to remove target pext 0x%llx for fs_oid 0x%llx (pext leak): %s\n",  v164,  v165,  v166,  v167,  v168,  v169,  v170,  v192);
        if ((_DWORD)v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = v163;
        }
        sub_100044E7C((char *)0x26B, v163);
      }
    }

    sub_100044E2C();
LABEL_52:
    if (v207)
    {
      sub_100040B50( "repair_overlapped_extents: free space for target_paddr 0x%llx block_count 0x%llx\n",  v19,  v20,  v21,  v11,  v12,  v13,  v14,  v207);
      int v72 = sub_1000032D0(a1, v15, v207, v218);
      if (v72)
      {
        unsigned int v73 = v72;
        char v74 = v207;
        strerror(v72);
        sub_100040B90( "repair_overlapped_extents: unable to free space for target_paddr 0x%llx block_count 0x%llx: %s\n",  v75,  v76,  v77,  v78,  v79,  v80,  v81,  v74);
        if ((_DWORD)v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = v73;
        }
        sub_100044E7C((char *)0x26C, v73);
      }
    }

    if (v15) {
      sub_100041874((uint64_t)v15);
    }
LABEL_60:
    unsigned int v193 = 16;
    unsigned int v194 = 32;
  }

  while (!sub_100034BB4((uint64_t)dword_10008DFF0, 0LL, 2LL, &v219, &v194, 0x20u, &v217, &v193));
  return v2;
}

uint64_t sub_10003D008(uint64_t *a1, int8x16_t *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = a4;
  uint64_t v5 = a3;
  memset(v62, 0, sizeof(v62));
  uint64_t v60 = 0LL;
  uint64_t v61 = 0LL;
  uint64_t v8 = (unsigned int *)&unk_10008C000;
  char v9 = __clz(__rbit64(dword_10008C9F8));
  int v10 = sub_10001DA4C( (uint64_t)&unk_10008DEB8 + 104 * (((unint64_t)(a3 << v9) >> 62) & 1),  ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v9) & a3,  a4,  0);
  if (v10)
  {
    int v11 = v10;
    strerror(v10);
    sub_100040C68( "free_overlapped_range: unable to free space for source_paddr 0x%llx block_count 0x%llx (leak): %s\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v5);
    sub_100044E7C((char *)0x26D, v11);
  }

  uint64_t v59 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v57 = 16;
  unsigned int v58 = 32;
  if (!sub_100034BB4((uint64_t)dword_10008DFF0, 0LL, 1LL, v62, &v58, 0x20u, &v60, &v57))
  {
    unint64_t v19 = v4 + v5;
    do
    {
      if (v19 > v60 && v61 + v60 > (unint64_t)v5)
      {
        if (v5 <= v60) {
          uint64_t v21 = v60;
        }
        else {
          uint64_t v21 = v5;
        }
        if (v19 - v21 >= v60 - v21 + v61) {
          uint64_t v22 = v60 - v21 + v61;
        }
        else {
          uint64_t v22 = v19 - v21;
        }
        sub_10003D370(v21, v22, WORD6(v62[0]), HIWORD(v62[0]), 0);
      }

      unsigned int v55 = 16;
      unsigned int v56 = 32;
    }

    while (!sub_100034BB4((uint64_t)dword_10008DFF0, 0LL, 2LL, v62, &v56, 0x20u, &v60, &v55));
  }

  char v23 = __clz(__rbit64(dword_10008C9F8));
  uint64_t v24 = 0LL;
  if (sub_10001D918( (uint64_t)&unk_10008DEB8 + 104 * (((unint64_t)(v5 << v23) >> 62) & 1),  ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v23) & v5,  v4,  &v59))
  {
    do
    {
      unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
      char v25 = __clz(__rbit64(v8[638]));
      if (((0x4000000000000000uLL >> v25) & v5) != 0) {
        unint64_t v26 = 0x4000000000000000uLL >> v25;
      }
      else {
        unint64_t v26 = 0LL;
      }
      v59 |= v26;
      unint64_t v27 = v4 + v5;
      unint64_t v28 = v4 + v5 - v59;
      if (sub_10001D7F8( (uint64_t)&unk_10008DEB8 + 104 * ((v59 & (0x4000000000000000uLL >> v25)) != 0),  v59 & ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v25),  v28,  &v54))
      {
        unint64_t v36 = 0x4000000000000000uLL >> __clz(__rbit64(v8[638]));
        if ((v36 & v5) == 0) {
          unint64_t v36 = 0LL;
        }
        v54 |= v36;
        unint64_t v28 = v54 - v59;
      }

      sub_100040B50( "free_overlapped_range: free space for source_paddr 0x%llx block_count 0x%llx\n",  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v59);
      int v37 = sub_1000032D0(a1, a2, v59, v28);
      if (v37) {
        BOOL v38 = v37 == 17;
      }
      else {
        BOOL v38 = 1;
      }
      if (!v38)
      {
        unsigned int v39 = v37;
        uint64_t v40 = v8;
        int v41 = a1;
        uint64_t v42 = a2;
        char v43 = v59;
        strerror(v37);
        char v53 = v43;
        a2 = v42;
        a1 = v41;
        uint64_t v8 = v40;
        sub_100040B90( "free_overlapped_range: unable to free space for source_paddr 0x%llx block_count 0x%llx (leak): %s\n",  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v53);
        if ((_DWORD)v24) {
          uint64_t v24 = v24;
        }
        else {
          uint64_t v24 = v39;
        }
        sub_100044E7C((char *)0x26E, v39);
      }

      uint64_t v5 = v59 + v28;
      unint64_t v4 = v27 - (v59 + v28);
      char v51 = __clz(__rbit64(v8[638]));
    }

    while ((sub_10001D918( (uint64_t)&unk_10008DEB8 + 104 * (((unint64_t)(v5 << v51) >> 62) & 1),  ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v51) & v5,  v4,  &v59) & 1) != 0);
  }

  return v24;
}

uint64_t sub_10003D31C(uint64_t a1, void *a2)
{
  uint64_t v2 = 0LL;
  while (1)
  {
    uint64_t v3 = qword_10008CA08[v2];
    if (!v3) {
      return 2LL;
    }
    if (v3 == a1) {
      break;
    }
    v2 += 2LL;
    if (v2 == 200) {
      return 2LL;
    }
  }

  if (v2 == 0x1FFFFFFFELL) {
    return 2LL;
  }
  uint64_t result = 0LL;
  *a2 = qword_10008CA08[v2 + 1];
  return result;
}

uint64_t sub_10003D370(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5)
{
  char v8 = __clz(__rbit64(dword_10008C9F8));
  uint64_t v9 = ((unint64_t)(a1 << v8) >> 62) & 1;
  if (a5) {
    LODWORD(v9) = 2;
  }
  uint64_t v10 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v8;
  if (a5) {
    uint64_t v10 = -1LL;
  }
  uint64_t result = sub_10001DA4C((char *)&unk_10008DEB8 + 104 * v9, v10 & a1, a2, 1LL);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)(qword_10008DB78 + 39)) {
      return sub_10003D428(a3, a4, a2, v12, v13, v14, v15, v16);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10003D428( unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 || (_DWORD)a2 != 15)
  {
    if (a1 || (_DWORD)a2 != 21)
    {
      if (a1 == 1) {
        unsigned int v10 = 1;
      }
      else {
        unsigned int v10 = a2;
      }
      if (a1 > 3) {
        unsigned int v10 = a1;
      }
      if (v10 >= 0x25)
      {
        sub_100040C68("Invalid object type/subtype (type : %u) (subtype : %u)\n", a2, a3, a4, a5, a6, a7, a8, a1);
        uint64_t v9 = 11LL;
      }

      else
      {
        uint64_t v9 = dword_10006B4D8[v10];
      }
    }

    else
    {
      uint64_t v9 = 8LL;
    }
  }

  else
  {
    uint64_t v9 = 10LL;
  }

  *((void *)&xmmword_10008D048 + v9) += a3;
  return 0LL;
}

uint64_t sub_10003D4C8(uint64_t a1, uint64_t a2, int a3)
{
  char v3 = __clz(__rbit64(dword_10008C9F8));
  uint64_t v4 = ((unint64_t)(a1 << v3) >> 62) & 1;
  if (a3) {
    LODWORD(v4) = 2;
  }
  uint64_t v5 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v3;
  if (a3) {
    uint64_t v5 = -1LL;
  }
  return sub_10001DA4C((char *)&unk_10008DEB8 + 104 * v4, v5 & a1, a2, 0LL);
}

uint64_t sub_10003D51C(uint64_t a1, unint64_t a2, int a3)
{
  char v3 = __clz(__rbit64(dword_10008C9F8));
  uint64_t v4 = ((unint64_t)(a1 << v3) >> 62) & 1;
  if (a3) {
    LODWORD(v4) = 2;
  }
  uint64_t v5 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v3;
  if (a3) {
    uint64_t v5 = -1LL;
  }
  return sub_10001DD90((uint64_t)&unk_10008DEB8 + 104 * v4, v5 & a1, a2, 1);
}

uint64_t sub_10003D570( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned int a9, unsigned int a10)
{
  if (*(_BYTE *)(qword_10008DB78 + 40)) {
    return sub_10003C374(a2, a3, a4, a5, a6, a7, a8, a9, 1);
  }
  if (a5 == 0x40000000
    && (a10 & 1) != 0
    && ((a2 << __clz(__rbit64(dword_10008C9F8))) & 0x4000000000000000LL) != 0
    && sub_10001B8BC(a1, a2, a3))
  {
    sub_100040B90( "physical metadata object (0x%llx + %llu) type %u subtype %u) is on Tier2 and inside the MT mapped range\n",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  a2);
    sub_100044E7C((char *)0x36D, 92);
  }

  int v25 = sub_10003D370(a2, a3, a8, a9, (a10 >> 3) & 1);
  if (v25)
  {
    if (v25 != 12)
    {
      if (v25 == 17)
      {
        sub_100044E7C((char *)0x451, 17);
        sub_10003C2B0(a2, a3, a4, a5, a6, a7, a8, a9);
        goto LABEL_14;
      }

      strerror(v25);
      sub_100040C68( "object oid %llu/xid %llu/type 0x%x/subtype 0x%x: unable to mark range %llu+%llu allocated for space verification: %s\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  a6);
    }

    sub_100044E7C((char *)0x437, -7);
    byte_1000706A0 = 0;
  }

uint64_t sub_10003D78C(uint64_t a1)
{
  uint64_t v45 = a1;
  uint64_t v46 = 0xC00000000LL;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(v2 + 104);
  unint64_t v4 = *(void *)(v2 + 112);
  if ((v3 & 0x80000000) != 0)
  {
    if (sub_10002DD38(a1, v4, sub_10003DA80, (uint64_t)&v45))
    {
      byte_1000706A0 = 0;
      sub_100040C68( "object (oid 0x%llx): Unable to mark nx checkpoint desc range (0x%llx + %u) allocated for space verification\n",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  0);
      sub_100044E7C((char *)0x1D1, -7);
    }
  }

  else
  {
    sub_10003D570(a1, v4, v3, 0LL, 0x40000000, v4, 0LL, 0, 0xCu, 1u);
  }

  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = *(unsigned int *)(v12 + 108);
  unint64_t v14 = *(void *)(v12 + 120);
  if ((v13 & 0x80000000) != 0)
  {
    if (sub_10002DD38(a1, v14, sub_10003DA80, (uint64_t)&v45))
    {
      byte_1000706A0 = 0;
      sub_100040C68( "object (oid 0x%llx): Unable to mark nx checkpoint data range (0x%llx + %u) allocated for space verification\n",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  0);
      sub_100044E7C((char *)0x1D2, -7);
    }
  }

  else
  {
    sub_10003D570(v45, v14, v13, 0LL, 0x40000000, v14, 0LL, v46, HIDWORD(v46), 1u);
  }

  uint64_t v46 = 8LL;
  uint64_t v22 = *(void *)(a1 + 24);
  uint64_t v23 = *(unsigned int *)(v22 + 164);
  unint64_t v24 = *(void *)(v22 + 168);
  if ((v23 & 0x80000000) != 0)
  {
    if (sub_10002DD38(a1, v24, sub_10003DA80, (uint64_t)&v45))
    {
      byte_1000706A0 = 0;
      sub_100040C68( "object (oid 0x%llx): Unable to mark spaceman ip bitmap range (0x%llx + %u) allocated for space verification\n",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  0);
      sub_100044E7C((char *)0x1D3, -7);
    }
  }

  else
  {
    sub_10003D570( v45,  v24,  v23,  0LL,  0x40000000,  v24,  0LL,  8u,  &_mh_execute_header,  (unint64_t)&_mh_execute_header >> 32);
  }

  uint64_t v32 = *(void *)(a1 + 24);
  uint64_t v33 = *(void *)(v32 + 152);
  unint64_t v34 = *(void *)(v32 + 176);
  if (v33 < 0)
  {
    uint64_t result = sub_10002DD38(a1, v34, sub_10003DA80, (uint64_t)&v45);
    if ((_DWORD)result)
    {
      byte_1000706A0 = 0;
      sub_100040C68( "object (oid 0x%llx): Unable to mark spaceman ip range (0x%llx + %llu) allocated for space verification\n",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  0);
      uint64_t result = (uint64_t)sub_100044E7C((char *)0x1D4, -7);
    }
  }

  else
  {
    uint64_t result = sub_10003D570(v45, v34, v33, 0LL, 0x40000000, v34, 0LL, v46, HIDWORD(v46), 1u);
  }

  uint64_t v43 = *(void *)(a1 + 8);
  if ((*(_BYTE *)(v43 + 65) & 1) != 0)
  {
    unint64_t v44 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v43 + 36)));
    sub_10003D570( a1,  v44,  1LL,  0LL,  0x40000000,  v44,  0LL,  1u,  &_mh_execute_header,  (unint64_t)&_mh_execute_header >> 32);
    return sub_10003D570( a1,  *(void *)(*(void *)(a1 + 8) + 1368LL),  *(void *)(*(void *)(a1 + 8) + 1376LL),  0LL,  0x40000000,  *(void *)(*(void *)(a1 + 8) + 1368LL),  0LL,  0,  0x16u,  2u);
  }

  return result;
}

uint64_t sub_10003DA80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return 0LL;
}

uint64_t sub_10003DAC4( uint64_t a1, unsigned int a2, int a3, uint64_t a4, char *__s1, char *__s2, unint64_t a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a9, _BYTE *a10, _DWORD *a11)
{
  uint64_t v90 = a4;
  int v88 = a3;
  uint64_t v84 = a11;
  uint64_t v87 = a9;
  uint64_t v17 = memcmp(__s1, __s2, (a7 + 7) >> 3);
  if (!(_DWORD)v17)
  {
    uint64_t v24 = 0LL;
    uint64_t v25 = 0LL;
    uint64_t v26 = 0LL;
    uint64_t v27 = 0LL;
    if (!a8) {
      return 0LL;
    }
LABEL_97:
    uint64_t v69 = v27;
    int v70 = a8(a1, v24, v25, 1LL, v87);
    if (v70) {
      *uint64_t v84 = v70;
    }
    a8(a1, v26, v69, 2LL, v87);
    return 0LL;
  }

  uint64_t v80 = &v72;
  unint64_t v18 = (a7 + 63) >> 6;
  uint64_t v19 = __chkstk_darwin(v17);
  uint64_t v20 = (8 * v18 + 15) & 0x3FFFFFFFFFFFFFF0LL;
  uint64_t v21 = (char *)&v72 - v20;
  if (v22 > 0x3F)
  {
    uint64_t v28 = memset((char *)&v72 - v20, 170, 8 * v18);
    __chkstk_darwin(v28);
    uint64_t v23 = (char *)&v72 - v20;
    memset(v23, 170, 8 * v18);
    uint64_t v29 = 0LL;
    if (v18 <= 1) {
      unint64_t v30 = 1LL;
    }
    else {
      unint64_t v30 = (a7 + 63) >> 6;
    }
    uint64_t v31 = 8 * v30;
    do
    {
      uint64_t v32 = *(void *)&__s1[v29];
      uint64_t v33 = *(void *)&__s2[v29];
      *(void *)&v21[v29] = v32 & ~v33;
      *(void *)&v23[v29] = v33 & ~v32;
      v29 += 8LL;
    }

    while (v31 != v29);
  }

  else
  {
    __chkstk_darwin(v19);
    uint64_t v23 = (char *)&v72 - v20;
  }

  *(void *)&__int128 v94 = 0LL;
  if (!a7)
  {
    if (byte_1000706A0)
    {
      uint64_t v24 = 0LL;
      uint64_t v25 = 0LL;
    }

    else
    {
      uint64_t v25 = 0LL;
      uint64_t v24 = 0LL;
    }

    uint64_t v26 = 0LL;
    uint64_t v27 = 0LL;
LABEL_96:
    if (!a8) {
      return 0LL;
    }
    goto LABEL_97;
  }

  uint64_t v79 = v23;
  uint64_t v86 = a1;
  uint64_t v25 = 0LL;
  uint64_t v89 = 0LL;
  do
  {
    uint64_t v34 = sub_10003E1A8(v90, (uint64_t)v21, (uint64_t *)&v94, a7);
    uint64_t v36 = v34;
    uint64_t v37 = v35;
    if (a10 && v35) {
      *a10 = 1;
    }
    if (a8)
    {
      if (v25)
      {
        if (v25 + v89 == v34)
        {
          v25 += v35;
          continue;
        }

        int v38 = ((uint64_t (*)(uint64_t))a8)(v86);
        if (v38) {
          *uint64_t v84 = v38;
        }
      }

      uint64_t v89 = v36;
      uint64_t v25 = v37;
    }
  }

  while ((unint64_t)v94 < a7);
  if (!byte_1000706A0)
  {
    uint64_t v26 = 0LL;
    uint64_t v27 = 0LL;
    a1 = v86;
    goto LABEL_93;
  }

  uint64_t v27 = 0LL;
  uint64_t v26 = 0LL;
  unint64_t v91 = 0LL;
  if (a2 == 1) {
    int v39 = 2;
  }
  else {
    int v39 = 1;
  }
  unsigned int v82 = v39;
  uint64_t v73 = a2;
  __int128 v78 = xmmword_10006B570;
  uint64_t v77 = 8LL;
  a1 = v86;
  while (1)
  {
    uint64_t v81 = v27;
    uint64_t v40 = sub_10003E1A8(v90, (uint64_t)v79, (uint64_t *)&v91, a7);
    uint64_t v42 = v41;
    __int128 v94 = v78;
    uint64_t v95 = v77;
    uint64_t v43 = calloc(8uLL, 0x18uLL);
    *(void *)&__int128 v94 = v43;
    if (!v43) {
      return 12LL;
    }
    *uint64_t v43 = v40;
    v43[1] = v42;
    char v45 = v88;
    *((_BYTE *)v43 + --*(_DWORD *)(result + 16) = v88;
    HIDWORD(v94) = 1;
    uint64_t v76 = v40;
    if ((v45 & 1) == 0)
    {
      uint64_t v60 = *(void *)(a1 + 24);
      unint64_t v61 = *(void *)(v60 + 152);
      uint64_t v62 = *(void *)(v60 + 176);
      if ((v61 & 0x8000000000000000LL) != 0)
      {
        uint64_t v63 = sub_10002DD38(a1, v62, sub_10003F894, (uint64_t)&v94);
      }

      else
      {
        uint64_t v96 = *(void *)(v60 + 176);
        unint64_t v97 = v61;
        uint64_t v63 = sub_10003F894((uint64_t)v43, v62, (uint64_t)&v96, v44, (uint64_t)&v94);
      }

      uint64_t v54 = v63;
      uint64_t v27 = v81;
      if ((_DWORD)v63)
      {
        uint64_t v48 = 0LL;
        int v49 = 1;
        goto LABEL_65;
      }

      if (SHIDWORD(v94) < 1)
      {
        uint64_t v48 = 0LL;
        uint64_t v54 = 0LL;
        int v49 = 1;
        uint64_t v27 = v81;
        goto LABEL_65;
      }
    }

    uint64_t v74 = v42;
    uint64_t v75 = v26;
    uint64_t v46 = 0LL;
    uint64_t v47 = 0LL;
    uint64_t v48 = 0LL;
    int v49 = 1;
LABEL_32:
    uint64_t v85 = v47;
    int v83 = v49;
    uint64_t v50 = (unint64_t *)(v94 + 24 * v46);
    unint64_t v51 = *v50;
    unint64_t v52 = v50[1];
    uint64_t v96 = 0LL;
    unint64_t v97 = v51;
    uint64_t v93 = 0xAAAAAAAAAAAAAAAALL;
    if (*((_BYTE *)v50 + 16)) {
      unsigned int v53 = 0;
    }
    else {
      unsigned int v53 = v82;
    }
    uint64_t v54 = sub_10003F94C(v53, &v96, &v93, 4294967294LL);
    if ((_DWORD)v54 == 2)
    {
      uint64_t v54 = sub_10003F94C(v53, &v96, &v93, 1LL);
      if ((_DWORD)v54 == 2) {
        goto LABEL_44;
      }
    }

    if ((_DWORD)v54) {
      goto LABEL_55;
    }
    unint64_t v55 = v52 + v51;
    unint64_t v56 = v97;
    if (v97 >= v55) {
      goto LABEL_44;
    }
    char v57 = 0;
    while (1)
    {
      DWORD2(v94) = v46;
      BYTE5(v95) = v88;
      char v92 = -86;
      uint64_t v58 = sub_1000032D8( *(void *)(v94 + 24 * v46),  *(void *)(v94 + 24 * v46 + 8),  v56,  v93,  &v92,  (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t))sub_10003F9E8,  (uint64_t)&v94);
      if ((_DWORD)v58) {
        return v58;
      }
      v57 |= v92 != 0;
      uint64_t v59 = sub_10003F94C(v53, &v96, &v93, 2LL);
      if ((_DWORD)v59) {
        break;
      }
      unint64_t v56 = v97;
      if (v97 >= v55)
      {
        if ((v57 & 1) == 0) {
          goto LABEL_44;
        }
LABEL_50:
        uint64_t v47 = v85;
        int v49 = v83;
LABEL_51:
        if (++v46 >= SHIDWORD(v94)) {
          goto LABEL_64;
        }
        goto LABEL_32;
      }
    }

    uint64_t v54 = v59;
    if ((_DWORD)v59 == 2)
    {
      if ((v57 & 1) != 0) {
        goto LABEL_50;
      }
LABEL_44:
      uint64_t v47 = malloc(0x18uLL);
      if (v47)
      {
        *(_OWORD *)uint64_t v47 = *(_OWORD *)(v94 + 24 * v46);
        uint64_t v47[2] = 0LL;
        int v49 = 0;
        if (v48) {
          v85[2] = v47;
        }
        else {
          uint64_t v48 = (__int128 *)v47;
        }
        goto LABEL_51;
      }

      int v49 = 0;
LABEL_64:
      uint64_t v54 = 0LL;
      a1 = v86;
      uint64_t v26 = v75;
      uint64_t v27 = v81;
      uint64_t v42 = v74;
    }

    else
    {
LABEL_55:
      a1 = v86;
      uint64_t v27 = v81;
      int v49 = v83;
      uint64_t v26 = v75;
      uint64_t v42 = v74;
      if (v48)
      {
        do
        {
          char v64 = (__int128 *)*((void *)v48 + 2);
          free(v48);
          uint64_t v48 = v64;
        }

        while (v64);
        uint64_t v27 = v81;
        int v49 = v83;
      }
    }

uint64_t sub_10003E1A8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *a3;
  uint64_t v13 = 0LL;
  uint64_t v14 = v8;
  if (sub_1000081A8(1, a2, v8, a4 - v8, &v14))
  {
    uint64_t v9 = v14;
  }

  else
  {
    uint64_t v14 = a4;
    uint64_t v9 = a4;
  }

  int v10 = sub_1000081A8(0, a2, v9, a4 - v9, &v13);
  uint64_t v11 = v13;
  if (!v10) {
    uint64_t v11 = a4;
  }
  uint64_t result = v14 + a1;
  *a3 = v11;
  return result;
}

uint64_t sub_10003E238( uint64_t a1, uint64_t a2, unint64_t a3, char *a4, char *a5, uint64_t a6, _DWORD *a7)
{
  uint64_t result = sub_10001D614( (uint64_t)&unk_10008DF88,  a2 & 0xFFFFFFFFFFFFFFC0LL,  (a2 + a3 - (a2 & 0xFFFFFFFFFFFFFFC0LL) + 63) & 0xFFFFFFFFFFFFFFC0LL,  (uint64_t)a4);
  if (!(_DWORD)result)
  {
    sub_1000086AC(a4, (8 * (unint64_t)dword_10008C9F8 + 128) >> 6, a2 & 0x3F);
    return sub_10003DAC4( a1,  2u,  1,  a2,  a4,  a5,  a3,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_10003E300,  a6,  0LL,  a7);
  }

  return result;
}

uint64_t sub_10003E300( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0LL;
  }
  int v11 = a4;
  if ((_DWORD)a4 == 1) {
    uint64_t v14 = "underallocation";
  }
  else {
    uint64_t v14 = "overallocation";
  }
  if ((_DWORD)a4 == 1)
  {
    sub_100040B90( "underallocation detected in internal pool: (0x%llx+%llu) bitmap address (0x%llx)\n",  a2,  a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  a2);
    sub_100044E7C((char *)0x4F4, 92);
  }

  else
  {
    sub_100040C68( "overallocation detected in internal pool: (0x%llx+%llu) bitmap address (0x%llx)\n",  a2,  a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  a2);
    uint64_t v8 = 92LL;
    sub_100044E7C((char *)0x4F5, 92);
    if (!*(_BYTE *)(qword_10008DB78 + 41)) {
      return v8;
    }
  }

  if (!sub_1000428C4( qword_10008DB70,  "Fix %s (0x%llx+%llu) bitmap address (0x%llx)? ",  v15,  v16,  v17,  v18,  v19,  v20,  (char)v14)) {
    return 92LL;
  }
  uint64_t v21 = calloc(1uLL, *(unsigned int *)(a1[1] + 36));
  if (v21)
  {
    uint64_t v29 = v21;
    uint64_t v30 = sub_10002BE74(*a1, *a5);
    if ((_DWORD)v30)
    {
      uint64_t v8 = v30;
      sub_100040B90("Failed to fix %s\n", v31, v32, v33, v34, v35, v36, v37, (char)v14);
      uint64_t v38 = 1271LL;
    }

    else
    {
      uint64_t v39 = a5[2] + a2 - a5[1];
      if (v11 == 1) {
        sub_100007FF8((uint64_t)v29, v39, a3);
      }
      else {
        sub_1000080E0((uint64_t)v29, v39, a3);
      }
      uint64_t v8 = sub_10002BFDC(*a1, *a5);
      if (!(_DWORD)v8)
      {
        free(v29);
        sub_100044E2C();
        return v8;
      }

      sub_100040B90("Failed to fix %s\n", v40, v41, v42, v43, v44, v45, v46, (char)v14);
      uint64_t v38 = 1272LL;
    }

    sub_100044E7C((char *)v38, v8);
    free(v29);
  }

  else
  {
    sub_100040C68("failed to allocate memory for the bitmap block\n", v22, v23, v24, v25, v26, v27, v28, v48);
    uint64_t v8 = 12LL;
    sub_100044E7C((char *)0x4F6, 12);
  }

  return v8;
}

uint64_t sub_10003E508(uint64_t *a1)
{
  unsigned int v66 = 0;
  uint64_t v2 = a1[3];
  uint64_t v3 = *(unsigned int *)(v2 + 328);
  int v4 = dword_10008C9F8;
  LODWORD(v5) = *(_DWORD *)(v2 + 160);
  uint64_t v65 = 0LL;
  uint64_t v6 = calloc(1uLL, dword_10008C9F8);
  uint64_t v7 = calloc(1uLL, dword_10008C9F8 + 16LL);
  if (v6) {
    BOOL v15 = v7 == 0LL;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15)
  {
    sub_100040C68("failed to allocate memory for the bitmap block\n", v8, v9, v10, v11, v12, v13, v14, v55);
    uint64_t v5 = 12LL;
    uint64_t v16 = 1273LL;
    int v17 = 12;
    goto LABEL_7;
  }

  uint64_t v18 = v7;
  if (!(_DWORD)v5) {
    goto LABEL_50;
  }
  unsigned int v19 = 0;
  uint64_t v58 = v2 + v3;
  int v56 = v5;
  int v57 = 8 * v4;
  uint64_t v59 = (8 * v4) >> 6;
  while (1)
  {
    uint64_t v20 = *(unsigned __int16 *)(v58 + 2LL * v19);
    uint64_t v21 = a1[3];
    int v22 = *(_DWORD *)(v21 + 164);
    if ((v22 & 0x7FFFFFFFu) <= v20)
    {
      LODWORD(v5) = 22;
LABEL_49:
      sub_100040B90( "error (%d) looking up spaceman IP bitmap block at index %u\n",  v8,  v20,  v10,  v11,  v12,  v13,  v14,  v5);
      sub_100044E7C((char *)0x4FA, v5);
LABEL_50:
      free(v6);
      free(v18);
      if (v66) {
        return v66;
      }
      else {
        return v5;
      }
    }

    uint64_t v23 = *(void *)(v21 + 168);
    if ((v22 & 0x80000000) == 0)
    {
      uint64_t v24 = v23 + v20;
      uint64_t v65 = v24;
      goto LABEL_15;
    }

    int v25 = sub_10002DC38((uint64_t)a1, v23, v20, &v65, 0LL);
    if (v25)
    {
      LODWORD(v5) = v25;
      goto LABEL_49;
    }

    uint64_t v24 = v65;
LABEL_15:
    int v26 = sub_10002BE74(*a1, v24);
    if (v26)
    {
      LODWORD(v5) = v26;
      sub_100040B90( "error (%d) reading spaceman IP bitmap block at index %u, addr 0x%llx\n",  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v26);
      sub_100044E7C((char *)0x4FB, v5);
      goto LABEL_50;
    }

    bzero(v18, *(unsigned int *)(a1[1] + 36));
    if (v19 == *(_DWORD *)(v2 + 160) - 1)
    {
      uint64_t v35 = *(void *)(v2 + 152);
      unint64_t v36 = (v35 & 0x7FFFFFFFFFFFFFFFuLL) % (8 * *(_DWORD *)(v2 + 32));
    }

    else
    {
      unint64_t v36 = (8 * *(_DWORD *)(v2 + 32));
      uint64_t v35 = *(void *)(v2 + 152);
    }

    uint64_t v63 = 0LL;
    uint64_t v64 = 0LL;
    uint64_t v60 = v65;
    uint64_t v61 = 0LL;
    unint64_t v62 = 0LL;
    if (v35 < 0) {
      break;
    }
    unint64_t v37 = v19 * v57;
    uint64_t v38 = a1[3];
    uint64_t v39 = *(void *)(v38 + 152);
    if ((v39 & 0x7FFFFFFFFFFFFFFFuLL) <= v37)
    {
      uint64_t v53 = 22LL;
LABEL_55:
      sub_100040B90( "error (%d) looking up spaceman IP block address at index %u\n",  v8,  v34,  v10,  v11,  v12,  v13,  v14,  v53);
      sub_100044E7C((char *)0x500, v53);
      return v53;
    }

    uint64_t v40 = *(void *)(v38 + 176);
    if (v39 < 0)
    {
      uint64_t v52 = sub_10002DC38((uint64_t)a1, v40, v19 * v57, &v64, (unint64_t *)&v63);
      if ((_DWORD)v52)
      {
        uint64_t v53 = v52;
        goto LABEL_55;
      }

      uint64_t v41 = v64;
    }

    else
    {
      uint64_t v41 = v40 + v37;
      uint64_t v64 = v41;
    }

    uint64_t v61 = v41;
    int v51 = sub_10003E238((uint64_t)a1, v41, v36, (char *)v18, (char *)v6, (uint64_t)&v60, &v66);
    if (v51)
    {
LABEL_41:
      LODWORD(v5) = v51;
      goto LABEL_50;
    }

uint64_t sub_10003E8B0( uint64_t *a1, uint64_t a2, void *a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), char **a5, int a6)
{
  uint64_t v12 = a1[3];
  unsigned int v117 = 0;
  uint64_t v116 = 0LL;
  int v114 = 0;
  uint64_t v13 = v12 + 48LL * a2;
  unint64_t v14 = *(unsigned int *)(v12 + 36);
  unint64_t v17 = *(void *)(v13 + 48);
  uint64_t v16 = (void *)(v13 + 48);
  unint64_t v15 = v17;
  if (!a4 && !a6) {
    return 0LL;
  }
  unint64_t v107 = v15;
  uint64_t v19 = sub_10003EEA0(a1);
  if ((_DWORD)v19)
  {
    uint64_t v18 = v19;
    char v20 = strerror(v19);
    sub_100040B90("error (%s) failed to populate free queue trees \n", v21, v22, v23, v24, v25, v26, v27, v20);
    sub_100044E7C((char *)0x4FE, v18);
    return v18;
  }

  unint64_t v102 = v14;
  uint64_t v104 = a3;
  *(void *)&__int128 v28 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v112[22] = v28;
  __int128 v113 = v28;
  uint64_t v29 = a2;
  v112[20] = v28;
  v112[21] = v28;
  v112[18] = v28;
  v112[19] = v28;
  v112[16] = v28;
  v112[17] = v28;
  v112[14] = v28;
  v112[15] = v28;
  v112[12] = v28;
  v112[13] = v28;
  v112[10] = v28;
  v112[11] = v28;
  v112[8] = v28;
  v112[9] = v28;
  v112[7] = v28;
  v112[5] = v28;
  v112[6] = v28;
  v112[3] = v28;
  v112[4] = v28;
  v112[1] = v28;
  v112[2] = v28;
  v112[0] = v28;
  size_t v30 = *(unsigned int *)(a1[1] + 36);
  uint64_t v31 = malloc(v30);
  uint64_t v32 = (char *)malloc(v30);
  uint64_t v115 = v32;
  if (!v31 || !v32)
  {
    sub_100040C68( "Space Verification: failed to allocate memory for the bitmap block\n",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v97);
    unsigned int v81 = 12;
    sub_100044E7C((char *)0x1D9, 12);
    goto LABEL_68;
  }

  if (v104) {
    *uint64_t v104 = 0LL;
  }
  int v98 = a6;
  uint64_t v101 = v31;
  unint64_t v40 = v107;
  if (!v107)
  {
    uint64_t v42 = 0LL;
LABEL_50:
    uint64_t v29 = a2;
    if (*(void *)(v12 + 48LL * a2 + 72) == v42)
    {
      unsigned int v81 = 0;
      uint64_t v31 = v101;
      int v82 = v98;
    }

    else
    {
      byte_10008CA02[a2] = 1;
      int v82 = v98;
      if (v98)
      {
        uint64_t v83 = (uint64_t)a1;
        uint64_t v84 = v42;
        unsigned int v85 = sub_10003F198(v83, a2, v42, v35, v36, v37, v38, v39);
        unsigned int v81 = v85;
        uint64_t v31 = v101;
        if (v85) {
          unsigned int v117 = v85;
        }
        uint64_t v42 = v84;
      }

      else
      {
        unsigned int v81 = 0;
        uint64_t v31 = v101;
      }
    }

    uint64_t v86 = 40LL;
    if ((_DWORD)a2) {
      uint64_t v86 = 80LL;
    }
    if (*(void *)(v12 + v86 + 200) > (unint64_t)(*v16 - v42))
    {
      byte_10008CA02[a2] = 1;
      if (v82)
      {
        uint64_t v87 = "main";
        if ((_DWORD)a2) {
          uint64_t v87 = "tier2";
        }
        sub_100040B90( "sm : free queue tree TIER (%s) has sfq_count (%llu) greater than available block count (%llu)\n",  v33,  v42,  v35,  v36,  v37,  v38,  v39,  (char)v87);
        sub_100044E7C((char *)0x307, 92);
        unsigned int v117 = 92;
      }
    }

    goto LABEL_68;
  }

  unint64_t v41 = 0LL;
  uint64_t v42 = 0LL;
  uint64_t v100 = a4;
  unint64_t v43 = &v108;
  if (a5) {
    unint64_t v43 = a5;
  }
  uint64_t v99 = (uint64_t)v43;
  uint64_t v103 = &byte_10008CA02[a2];
  unint64_t v44 = v102;
  while (1)
  {
    uint64_t v106 = v42;
    unint64_t v45 = v41;
    if ((_DWORD)a2) {
      unint64_t v45 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(a1[1] + 36)))) | v41;
    }
    if (v41)
    {
      if (!v115 || BYTE8(v113) == 0) {
        goto LABEL_25;
      }
    }

    int v47 = sub_10000A680(a1, v41 / *(unsigned int *)(v12 + 36), a2, (void **)&v115);
    if (v47) {
      break;
    }
    unsigned int v48 = sub_10000ADC0((uint64_t)v112, a1, (uint64_t)v115, (uint64_t **)&v116, &v114);
    if (v48) {
      goto LABEL_52;
    }
LABEL_25:
    unint64_t v49 = v44;
    uint64_t v31 = v101;
    bzero(v101, *(unsigned int *)(a1[1] + 36));
    unint64_t v105 = v40 - v49;
    if (v40 < v49) {
      unint64_t v49 = v40;
    }
    unsigned int v50 = sub_10001D614( (uint64_t)&unk_10008DEB8 + 104 * a2,  v41,  (v49 + 63) & 0x1FFFFFFC0LL,  (uint64_t)v101);
    if (v50)
    {
      unsigned int v81 = v50;
      uint64_t v29 = a2;
      goto LABEL_68;
    }

    uint64_t v108 = v116;
    int v110 = -1431655766;
    int v109 = v114;
    uint64_t v111 = v115;
    unsigned int v48 = sub_10003DAC4((uint64_t)a1, a2, 0, v45, (char *)v101, v116, v49, v100, v99, v103, &v117);
    if (v48)
    {
LABEL_52:
      unsigned int v81 = v48;
      goto LABEL_67;
    }

    unint64_t v51 = sub_10000822C((uint64_t)v116, 0, 0LL, v49);
    unint64_t v58 = v51;
    if (v104) {
      *v104 += v49 - v51;
    }
    uint64_t v59 = a1[1];
    uint64_t v60 = *(void *)(v59 + 1248);
    if (v60)
    {
      v118[0] = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v61 = sub_10004A6C4(v45, v49, *(void *)(v59 + 1240), v60, v118);
      unint64_t v62 = v58;
      if (v61) {
        unint64_t v62 = v58 - sub_10000822C((uint64_t)v116, 0, v118[0] - v45, v118[0] - v45 + v61);
      }
    }

    else
    {
      unint64_t v62 = v51;
    }

    uint64_t v63 = v115;
    uint64_t v64 = &v115[32 * v114];
    int v66 = *((_DWORD *)v64 + 15);
    uint64_t v65 = v64 + 60;
    uint64_t v67 = v66 & 0xFFFFF;
    if ((v58 & 0xFFFFF) != v67)
    {
      *uint64_t v103 = 1;
      if (v98)
      {
        sub_100040B90( "cib: ci_free_count (%u) is not valid (%llu) (ci_addr 0x%llx)\n",  v52,  v53,  v60,  v54,  v55,  v56,  v57,  v67);
        if (!sub_1000428C4( qword_10008DB70,  "Fix ci_free_count (%u)? ",  v68,  v69,  v70,  v71,  v72,  v73,  *v65))
        {
          int v78 = 92;
          uint64_t v79 = 676LL;
          int v80 = 92;
          goto LABEL_41;
        }

        *(_DWORD *)uint64_t v65 = v58 & 0xFFFFF | (*(_DWORD *)v65 >> 20);
        unsigned int v76 = *(_DWORD *)(a1[1] + 36);
        v118[0] = v63[1];
        v118[1] = v76;
        v118[2] = 0LL;
        int v77 = sub_100023FA8(a1, 0LL, (uint64_t)v63, (uint64_t)v118, v74, v75);
        if (v77)
        {
          int v78 = v77;
          uint64_t v79 = 675LL;
          int v80 = v78;
LABEL_41:
          sub_100044E7C((char *)v79, v80);
          unsigned int v117 = v78;
          goto LABEL_43;
        }

        sub_100044E2C();
      }
    }

uint64_t sub_10003EEA0(uint64_t *a1)
{
  if (byte_10008CA01 != 1) {
    return 0LL;
  }
  uint64_t v2 = 0LL;
  uint64_t v3 = dword_10008E070;
  int v4 = a1 + 57;
  while (1)
  {
    uint64_t v51 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v50[3] = v5;
    v50[4] = v5;
    v50[1] = v5;
    _OWORD v50[2] = v5;
    v50[0] = v5;
    BOOL v49 = v2 == 0;
    uint64_t v6 = sub_100029A94(a1, v2, &v51);
    if ((_DWORD)v6) {
      return v6;
    }
    if (*(void *)(v51 + 56))
    {
      uint64_t v7 = sub_100035838((uint64_t)v50, v51, 0LL, 0LL, 0);
      if ((_DWORD)v7
        || (uint64_t v7 = sub_10002930C( (uint64_t)v50,  (uint64_t (*)(void, void, void, void, uint64_t))sub_10003FAE0,  (uint64_t)&v49,  0),  (_DWORD)v7))
      {
        uint64_t v14 = v7;
        char v15 = strerror(v7);
        sub_100040B90("failed to iterate the spaceman free queue tree: %s\n", v16, v17, v18, v19, v20, v21, v22, v15);
        sub_100044E7C((char *)0x314, v14);
        return v14;
      }

      if ((v49 & 2) != 0) {
        break;
      }
    }

uint64_t sub_10003F198( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = a2;
  uint64_t v11 = 3LL * a2;
  sub_100040B90( "sm: sm_free_count (%llu) is not valid (%llu) (sm_dev %d)\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(*(void *)(a1 + 24) + 48LL * a2 + 72));
  if (sub_1000428C4( qword_10008DB70,  "Fix sm_free_count (%llu)? ",  v12,  v13,  v14,  v15,  v16,  v17,  *(void *)(*(void *)(a1 + 24) + 16 * v11 + 72)))
  {
    uint64_t v19 = *(void *)(a1 + 24);
    *(void *)(v19 + 48LL * v9 + 72) = a3;
    int8x16_t v24 = *(int8x16_t *)(a1 + 88);
    uint64_t v25 = *(void *)(a1 + 104);
    uint64_t v20 = sub_100023FA8((uint64_t *)a1, 0LL, v19, (uint64_t)&v24, v24, v18);
    if (!(_DWORD)v20)
    {
      sub_100044E2C();
      return v20;
    }

    uint64_t v21 = 677LL;
    int v22 = v20;
  }

  else
  {
    uint64_t v20 = 92LL;
    uint64_t v21 = 678LL;
    int v22 = 92;
  }

  sub_100044E7C((char *)v21, v22);
  return v20;
}

uint64_t sub_10003F284(uint64_t *a1)
{
  uint64_t v57 = 0LL;
  uint64_t v58 = 0LL;
  uint64_t v2 = sub_10003EEA0(a1);
  if ((_DWORD)v2)
  {
    uint64_t v3 = v2;
    char v4 = strerror(v2);
    sub_100040B90("error (%s) failed to populate free queue trees \n", v5, v6, v7, v8, v9, v10, v11, v4);
    sub_100044E7C((char *)0x4FF, v3);
  }

  else
  {
    LODWORD(v3) = sub_10003E508(a1);
    if (byte_10008CA04[0] | byte_10008CA02[0] || *(_BYTE *)(qword_10008DB78 + 40)) {
      unsigned int v19 = sub_10003E8B0( a1,  0LL,  &v58,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_10003F498,  0LL,  1);
    }
    else {
      unsigned int v19 = 0;
    }
    if ((*(_BYTE *)(a1[1] + 65) & 1) != 0
      && (byte_10008CA05 | byte_10008CA03 || *(_BYTE *)(qword_10008DB78 + 40)))
    {
      unsigned int v20 = sub_10003E8B0( a1,  1LL,  &v57,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_10003F498,  0LL,  1);
    }

    else
    {
      unsigned int v20 = 0;
    }

    if (*(_BYTE *)(qword_10008DB78 + 39))
    {
      char v22 = v57;
      char v21 = v58;
      sub_10004096C("\nSpace allocation summary:\n\n", v12, v13, v14, v15, v16, v17, v18, v56);
      sub_10004096C("%-20s%-15s\n", v23, v24, v25, v26, v27, v28, v29, (char)"category");
      sub_10004096C("%-20s%-15s\n", v30, v31, v32, v33, v34, v35, v36, (char)"--------");
      uint64_t v44 = 0LL;
      char v45 = 0;
      do
      {
        uint64_t v46 = *(void *)((char *)&xmmword_10008D048 + v44 * 8);
        if (v46)
        {
          v45 += v46;
          sub_10004096C("%-20s%-15llu\n", v37, v38, v39, v40, v41, v42, v43, (char)off_10006C8D8[v44]);
        }

        ++v44;
      }

      while (v44 != 12);
      sub_10004096C("\nTotal blocks marked by fsck: %llu\n", v37, v38, v39, v40, v41, v42, v43, v45);
      sub_10004096C("Total blocks allocated by spaceman: %llu\n\n", v47, v48, v49, v50, v51, v52, v53, v22 + v21);
    }

    if (v19) {
      unsigned int v54 = v19;
    }
    else {
      unsigned int v54 = v20;
    }
    if ((_DWORD)v3) {
      return v3;
    }
    else {
      return v54;
    }
  }

  return v3;
}

uint64_t sub_10003F498( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0LL;
  }
  else {
    uint64_t v14 = "Main";
  }
  uint64_t v15 = *(void *)(*(void *)(a5 + 16) + 32LL * *(unsigned int *)(a5 + 8) + 64);
  if ((_DWORD)a4 == 1) {
    uint64_t v16 = "underallocation";
  }
  else {
    uint64_t v16 = "overallocation";
  }
  if ((_DWORD)a4 == 1)
  {
    sub_100040B90( "underallocation detected on %s device: (0x%llx+%llu) bitmap address (0x%llx)\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)v14);
    sub_100044E7C((char *)0x1DA, 92);
  }

  else
  {
    sub_100040C68( "overallocation detected on %s device: (0x%llx+%llu) bitmap address (0x%llx)\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)v14);
    sub_100044E7C((char *)0x1DB, 92);
    if (!*(_BYTE *)(qword_10008DB78 + 41))
    {
      if (a2 != 1) {
        return 92LL;
      }
      uint64_t v30 = a1[1];
      if ((*(_BYTE *)(v30 + 65) & 1) != 0 || *(_DWORD *)(v30 + 36) != 4096 || !(*(void *)(v30 + 40) >> 29)) {
        return 92LL;
      }
    }
  }

  if (!sub_1000428C4( qword_10008DB70,  "Fix %s (0x%llx+%llu) bitmap address (0x%llx)? ",  v17,  v18,  v19,  v20,  v21,  v22,  (char)v16)) {
    return 92LL;
  }
  uint64_t v8 = sub_100002D04(a1, 0LL, a2, a3, v15, *(void *)a5, *(void **)(a5 + 16), a4, 0, 0);
  if ((_DWORD)v8)
  {
    sub_100040B90("Failed to fix %s\n", v23, v24, v25, v26, v27, v28, v29, (char)v16);
    sub_100044E7C((char *)0x316, v8);
  }

  else
  {
    sub_100044E2C();
  }

  return v8;
}

uint64_t sub_10003F664( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(unint64_t, unint64_t, uint64_t), uint64_t a5)
{
  unint64_t v10 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36LL)))) & a2;
  if (sub_10001D604((uint64_t)&unk_10008DEB8 + 104 * (v10 != 0)))
  {
    unint64_t v18 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36LL)))) & a2;
    unint64_t v19 = v18 + a3;
    unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
    while (v19 > v18 && sub_10001D918((uint64_t)&unk_10008DEB8 + 104 * (v10 != 0), v18, v19 - v18, &v27))
    {
      if (v10)
      {
        unint64_t v20 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36LL)));
        unint64_t v21 = v20 | v27;
        unint64_t v22 = v20 | v26;
      }

      else
      {
        unint64_t v22 = v26;
        unint64_t v21 = v27;
      }

      uint64_t v23 = a4(v21, v22 - v21, a5);
      unint64_t v18 = v26;
      if ((_DWORD)v23) {
        return v23;
      }
    }

    return 0LL;
  }

  else
  {
    sub_100040B90( "unexpected: space verification data structure not initialized",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v26);
    uint64_t v24 = 22LL;
    sub_100044E7C((char *)0x434, 22);
  }

  return v24;
}

uint64_t sub_10003F7CC( uint64_t a1, uint64_t (*a2)(unint64_t, unint64_t, uint64_t), uint64_t a3)
{
  char v6 = 0;
  uint64_t v7 = 0LL;
  uint64_t v8 = *(void *)(a1 + 24);
  char v9 = 1;
  do
  {
    while (1)
    {
      char v10 = v9;
      uint64_t v11 = (v6 & 1) != 0
      uint64_t v12 = *(void *)(v8 + 48 * v7 + 48);
      if (!v12) {
        break;
      }
      uint64_t result = sub_10003F664(a1, v11, v12, a2, a3);
      char v9 = 0;
      char v6 = 1;
      uint64_t v7 = 1LL;
    }

    char v9 = 0;
    uint64_t v7 = 1LL;
    char v6 = 1;
  }

  while ((v10 & 1) != 0);
  return 0LL;
}

uint64_t sub_10003F894(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_DWORD *)(a5 + 8) = 0;
  *(_BYTE *)(a5 + 21) = 1;
  if (*(int *)(a5 + 12) >= 1)
  {
    int v7 = 0;
    char v9 = -86;
    do
    {
      if (!*(_BYTE *)(*(void *)a5 + 24LL * v7 + 16))
      {
        uint64_t result = sub_1000032D8( *(void *)(*(void *)a5 + 24LL * v7),  *(void *)(*(void *)a5 + 24LL * v7 + 8),  *(void *)a3,  *(void *)(a3 + 8),  &v9,  (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t))sub_10003F9E8,  a5);
        if ((_DWORD)result) {
          return result;
        }
        int v7 = *(_DWORD *)(a5 + 8);
        if (!v9) {
          *(_DWORD *)(a5 + 8) = ++v7;
        }
      }
    }

    while (v7 < *(_DWORD *)(a5 + 12));
  }

  return 0LL;
}

uint64_t sub_10003F94C(unsigned int a1, void *a2, void *a3, uint64_t a4)
{
  unsigned int v17 = 16;
  unsigned int v16 = 8;
  uint64_t v5 = sub_100034BB4((uint64_t)&unk_10008E070 + 64 * (unint64_t)a1, 0LL, a4, a2, &v17, 0x10u, a3, &v16);
  uint64_t v6 = v5;
  if ((v5 & 0xFFFFFFFD) != 0)
  {
    uint64_t v7 = a2[1];
    strerror(v5);
    sub_100040B90("Space Verification: failed to lookup paddr (%llu) : error %s\n", v8, v9, v10, v11, v12, v13, v14, v7);
    sub_100044E7C((char *)0x364, v6);
  }

  return v6;
}

uint64_t sub_10003F9E8(uint64_t a1, uint64_t a2, int a3, char **a4)
{
  int v8 = *((_DWORD *)a4 + 2);
  int v9 = v8;
  if (a3)
  {
    uint64_t v10 = *a4;
    *((_BYTE *)a4 + 20) = (*a4)[24 * v8 + 16];
  }

  else
  {
    int v11 = *((_DWORD *)a4 + 3);
    uint64_t v12 = *a4;
    if (v11 == *((_DWORD *)a4 + 4))
    {
      *((_DWORD *)a4 + 4) = 2 * v11;
      uint64_t v12 = (char *)realloc(v12, 48LL * v11);
      if (!v12)
      {
        free(*a4);
        *a4 = 0LL;
        return 12LL;
      }

      *a4 = v12;
      int v11 = *((_DWORD *)a4 + 3);
    }

    memmove(&v12[24 * v8 + 24], &v12[24 * v8], 24LL * (v11 - v8));
    int v8 = *((_DWORD *)a4 + 2);
    ++*((_DWORD *)a4 + 3);
    uint64_t v10 = *a4;
  }

  uint64_t result = 0LL;
  uint64_t v14 = &v10[24 * v9];
  *(void *)uint64_t v14 = a1;
  *((void *)v14 + 1) = a2;
  uint64_t v15 = 20LL;
  if (a3) {
    uint64_t v15 = 21LL;
  }
  v14[16] = *((_BYTE *)a4 + v15);
  *((_DWORD *)a4 + 2) = v8 + 1;
  return result;
}

uint64_t sub_10003FAE0(__int128 *a1, int a2, uint64_t *a3, int a4, int *a5)
{
  uint64_t v5 = 22LL;
  if (a2 == 16 && (a4 & 0xFFFFFFF7) == 0)
  {
    int v7 = *a5;
    __int128 v47 = *a1;
    uint64_t v8 = 1LL;
    if (a3 && a4) {
      uint64_t v8 = *a3;
    }
    uint64_t v46 = v8;
    __int128 v9 = v47;
    __int128 v45 = *a1;
    unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
    if ((v7 & 1) != 0)
    {
      unsigned int v10 = 0;
    }

    else if (((*((void *)&v47 + 1) << __clz(__rbit64(dword_10008C9F8))) & 0x4000000000000000LL) != 0)
    {
      unsigned int v10 = 2;
    }

    else
    {
      unsigned int v10 = 1;
    }

    uint64_t v5 = sub_10003F94C(v10, &v45, &v44, 4294967294LL);
    if ((_DWORD)v5 == 2 && (uint64_t v5 = sub_10003F94C(v10, &v45, &v44, 1LL), (_DWORD)v5 == 2))
    {
      uint64_t v18 = v10;
LABEL_33:
      uint64_t v34 = sub_1000364F0(&dword_10008E070[16 * v18], 0LL, &v47, 16LL, &v46, 8LL);
      uint64_t v5 = v34;
      if ((_DWORD)v34)
      {
        char v35 = BYTE8(v47);
        strerror(v34);
        sub_100040B90( "Space Verification: failed to insert paddr (%llu) error : %s\n",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v35);
        sub_100044E7C((char *)0x365, v5);
      }
    }

    else if (!(_DWORD)v5)
    {
      unint64_t v19 = v9;
      uint64_t v20 = v8;
      uint64_t v21 = *((void *)&v9 + 1);
      do
      {
        if (*((void *)&v45 + 1) >= (unint64_t)(v20 + v21))
        {
          uint64_t v18 = v10;
          goto LABEL_33;
        }

        if (v44 + *((void *)&v45 + 1) > v21)
        {
          sub_100040C68( "found spaceman free queue tree entry (0x%llx+%llu, xid %llu) which overlaps with existing range (0x%llx+%llu)\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  SBYTE8(v9));
          sub_100044E7C((char *)0x1CE, -7);
          *a5 |= 2u;
          else {
            uint64_t v22 = v21;
          }
          if (v21 - v22 + v20 <= *((void *)&v45 + 1) - v22 + v44) {
            uint64_t v20 = *((void *)&v45 + 1) - v22 + v44;
          }
          else {
            v20 += v21 - v22;
          }
          int v23 = sub_100036AC4((uint64_t)&dword_10008E070[16 * (unint64_t)v10], 0LL, (uint64_t)&v45, 16LL);
          if (v23)
          {
            int v24 = v23;
            char v25 = BYTE8(v45);
            strerror(v23);
            sub_100040B90( "Space Verification: failed to remove paddr (%llu) error : %s\n",  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v25);
            sub_100044E7C((char *)0x366, v24);
          }

          *(void *)&__int128 v47 = v19;
          *((void *)&v47 + 1) = v22;
          uint64_t v21 = v22;
          uint64_t v46 = v20;
        }

        uint64_t v33 = sub_10003F94C(v10, &v45, &v44, 2LL);
      }

      while (!(_DWORD)v33);
      uint64_t v5 = v33;
      uint64_t v18 = v10;
      if ((_DWORD)v33 == 2) {
        goto LABEL_33;
      }
    }
  }

  return v5;
}

uint64_t sub_10003FD54(const void *a1, uint64_t a2, uint64_t *a3, int a4, _DWORD *a5)
{
  if ((a4 & 0xFFFFFFF7) != 0) {
    return 22LL;
  }
  v9[1] = v5;
  v9[2] = v6;
  uint64_t v8 = 1LL;
  if (a3)
  {
    if (a4) {
      uint64_t v8 = *a3;
    }
  }

  v9[0] = v8;
  return sub_1000364F0(a5, 0LL, a1, a2, v9, 8LL);
}

uint64_t sub_10003FDB8( uint64_t *a1, uint64_t *a2, int *a3, _DWORD **a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  uint64_t v8 = *a1;
  if (!*a1)
  {
    uint64_t v15 = "unexpected end of iteration while repairing free queue tree\n";
LABEL_14:
    sub_100040B90(v15, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5, v8, a7, (uint64_t)a8, v19);
    return 22LL;
  }

  a8 = (_BYTE *)a1[1];
  uint64_t v10 = *a2;
  if (!*a2)
  {
LABEL_15:
    int v18 = 1;
    uint64_t result = sub_1000251C0(*a4, *((_DWORD *)a4 + 2), 0, 0, 1, (__int128 *)v8, 0x10u, a8, 8u);
    goto LABEL_19;
  }

  uint64_t v11 = (_BYTE *)a2[1];
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v8 + 8);
  if (v12 != v13)
  {
    unint64_t v16 = *(void *)a8;
    goto LABEL_9;
  }

  if (*(void *)v10 == *(void *)v8 && *(void *)v11 == *(void *)a8) {
    return 0LL;
  }
  if (*(void *)v10 <= *(void *)v8)
  {
    unint64_t v16 = *(void *)a8;
    if (*(void *)v11 <= *(void *)a8)
    {
LABEL_9:
      if (v12 <= v13 || v12 - v13 < v16)
      {
        uint64_t v19 = *(void *)(v8 + 8);
        uint64_t v15 = "unexpected on-disk range 0x%llx+%llu xid %llu and in-memory range 0x%llx+%llu xid %llu while repairing free queue tree\n";
        goto LABEL_14;
      }

      goto LABEL_15;
    }
  }

  int v18 = 2;
  uint64_t result = sub_1000251C0(*a4, *((_DWORD *)a4 + 2), 2, 0, 1, (__int128 *)v10, 0x10u, v11, 8u);
LABEL_19:
  if (!(_DWORD)result) {
    *a3 = v18;
  }
  return result;
}

FILE *sub_10003FEEC(const char *a1)
{
  int v1 = open(a1, 777, 438LL);
  if (v1 < 0) {
    return 0LL;
  }
  int v2 = v1;
  v3.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v6.st_blksize = v3;
  *(timespec *)v6.st_qspare = v3;
  v6.st_birthtimespec = v3;
  *(timespec *)&v6.off_t st_size = v3;
  v6.st_mtimespec = v3;
  v6.st_ctimespec = v3;
  *(timespec *)&v6.st_uid = v3;
  v6.st_atimespec = v3;
  *(timespec *)&v6.dev_t st_dev = v3;
  if (!fstat(v1, &v6) && (v6.st_mode & 0xF000) == 0x8000) {
    return fdopen(v2, "a");
  }
  close(v2);
  uint64_t v5 = __error();
  uint64_t result = 0LL;
  *uint64_t v5 = 1;
  return result;
}

void sub_10003FF90()
{
  dword_1000706A8 = 0;
  uint64_t v0 = (FILE *)qword_10008D0A8;
  uint64_t v1 = qword_10008D0B8;
  uint64_t v2 = qword_10008D0D8;
  if (qword_10008D0A8) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = qword_10008D0B8 == 0;
  }
  if (v3 && qword_10008D0D8 == 0) {
    return;
  }
  uint64_t v5 = qword_10008D0B0;
  time_t v17 = time(0LL);
  if (v1)
  {
    stat v6 = ctime(&v17);
    sub_1000402AC(2LL, (uint64_t)&qword_10008D0A8, "fsck_apfs completed at %s\n", v6, 0LL);
  }

  else
  {
    if (!v0) {
      goto LABEL_43;
    }
    if (qword_10008E138) {
      int v7 = (const char *)qword_10008E138;
    }
    else {
      int v7 = "UNKNOWN-DEV";
    }
    uint64_t v8 = ctime(&v17);
    fprintf(v0, "%s: fsck_apfs completed at %s\n", v7, v8);
  }

  if (!v0 || dword_10008E130)
  {
    if (v0)
    {
      if (v2 | v1 && dword_10008E130 != 0)
      {
        pthread_mutex_lock(&stru_1000706B0);
        pthread_cond_broadcast(&stru_10008D0E8);
        pthread_mutex_unlock(&stru_1000706B0);
        pthread_join((pthread_t)qword_10008D118, 0LL);
        pthread_join((pthread_t)qword_10008D120, 0LL);
        if (v2) {
          free((void *)v2);
        }
        qword_10008D0D0 = 0LL;
        qword_10008D0D8 = 0LL;
        qword_10008D0E0 = 0LL;
        if (v1) {
          free((void *)v1);
        }
        qword_10008D0B0 = 0LL;
        qword_10008D0B8 = 0LL;
        qword_10008D0C0 = 0LL;
        fflush(v0);
        fclose(v0);
        qword_10008D0A8 = 0LL;
        goto LABEL_43;
      }
    }

    if (v1)
    {
      if (getuid() || (fflush(__stdoutp), fflush(__stderrp), !fork()))
      {
        memset(__b, 170, sizeof(__b));
        fclose(__stdoutp);
        fclose(__stdinp);
        fclose(__stderrp);
        if (getuid())
        {
          uid_t v10 = getuid();
          uint64_t v11 = getpwuid(v10);
          if (!v11) {
            goto LABEL_43;
          }
          uint64_t v12 = __b;
          snprintf(__b, 0x400uLL, "%s/Library/Logs/fsck_apfs.log", v11->pw_dir);
        }

        else
        {
          uint64_t v12 = "/var/log/fsck_apfs.log";
        }

        char v13 = 1;
        while (1)
        {
          char v14 = v13;
          uint64_t v15 = sub_10003FEEC(v12);
          if (v15)
          {
            if (v5) {
              break;
            }
          }

          if (*__error() == 30)
          {
            sleep(1u);
            char v13 = 0;
            if ((v14 & 1) != 0) {
              continue;
            }
          }

          goto LABEL_43;
        }

        unint64_t v16 = v15;
        fwrite((const void *)v1, v5 - v1, 1uLL, v15);
        fflush(v16);
        fclose(v16);
        qword_10008D0A8 = 0LL;
        free((void *)v1);
        qword_10008D0B0 = 0LL;
        qword_10008D0B8 = 0LL;
        qword_10008D0C0 = 0LL;
      }
    }
  }

  else
  {
    fflush(v0);
    fclose(v0);
    qword_10008D0A8 = 0LL;
  }

uint64_t sub_1000402AC(uint64_t result, uint64_t a2, char *__format, const char *a4, va_list a5)
{
  va_list v18 = 0LL;
  if (*(void *)(a2 + 8) && *(void *)(a2 + 16))
  {
    int v8 = result;
    if ((_DWORD)result == 1) {
      va_list v18 = a5;
    }
    if (dword_10008E130 && *(FILE **)a2 == __stdoutp) {
      pthread_mutex_lock(&stru_1000706B0);
    }
    __int128 v9 = *(char **)(a2 + 8);
    uid_t v10 = *(_BYTE **)(a2 + 16);
    size_t v11 = *(void *)(a2 + 24);
    int64_t v12 = v9 - v10;
    if (v8 == 1) {
      uint64_t result = vsnprintf(*(char **)(a2 + 8), v11 - (v9 - v10), __format, a5);
    }
    else {
      uint64_t result = snprintf(v9, v11 - (v9 - v10), "%s", a4);
    }
    if (v11 - (v9 - v10) >= (int)result)
    {
      v9 += (int)result;
    }

    else
    {
      else {
        int v13 = 4096;
      }
      size_t v14 = v11 + v13;
      if (!(v14 >> 20))
      {
        uint64_t result = (uint64_t)realloc(v10, v14);
        if (result)
        {
          uint64_t v15 = result;
          uint64_t v16 = result + v12;
          if (v8 == 1) {
            uint64_t result = vsnprintf((char *)(result + v12), v14 - v12, __format, v18);
          }
          else {
            uint64_t result = snprintf((char *)(result + v12), v14 - v12, "%s", a4);
          }
          uint64_t v17 = (int)result;
          __int128 v9 = (char *)(v16 + v17);
          uid_t v10 = (_BYTE *)v15;
          size_t v11 = v14;
        }
      }
    }

    *(void *)(a2 + 8) = v9;
    *(void *)(a2 + --*(_DWORD *)(result + 16) = v10;
    *(void *)(a2 + 24) = v11;
    if (dword_10008E130)
    {
      if (*(FILE **)a2 == __stdoutp)
      {
        pthread_cond_signal(&stru_10008D0E8);
        return pthread_mutex_unlock(&stru_1000706B0);
      }
    }
  }

  return result;
}

uint64_t sub_100040480()
{
  uint64_t v0 = qword_10008D0A8;
  setlinebuf(__stdoutp);
  uint64_t result = setlinebuf(__stderrp);
  dword_10008E130 = byte_10008E140;
  if (!v0)
  {
    uint64_t result = (uint64_t)sub_10003FEEC("/var/log/fsck_apfs.log");
    if (result)
    {
      uint64_t v2 = (FILE *)result;
      qword_10008D0A8 = result;
      setlinebuf((FILE *)result);
      if (dword_10008E130)
      {
        BOOL v3 = malloc(0x1000uLL);
        uint64_t result = (uint64_t)malloc(0x1000uLL);
        if (v3 && result)
        {
          *BOOL v3 = 0;
          qword_10008D0B0 = (uint64_t)v3;
          qword_10008D0B8 = (uint64_t)v3;
          qword_10008D0C0 = 4096LL;
          *(_BYTE *)uint64_t result = 0;
          qword_10008D0C8 = (uint64_t)__stdoutp;
          qword_10008D0D0 = result;
          qword_10008D0D8 = result;
          qword_10008D0E0 = 4096LL;
          time_t v7 = time(0LL);
          char v4 = ctime(&v7);
          uint64_t result = sub_1000402AC(2LL, (uint64_t)&qword_10008D0A8, "\nfsck_apfs started at %s", v4, 0LL);
          if (dword_10008E130)
          {
            pthread_cond_init(&stru_10008D0E8, 0LL);
            pthread_create( (pthread_t *)&qword_10008D118,  0LL,  (void *(__cdecl *)(void *))sub_100040634,  &qword_10008D0C8);
            return pthread_create( (pthread_t *)&qword_10008D120,  0LL,  (void *(__cdecl *)(void *))sub_100040634,  &qword_10008D0A8);
          }
        }
      }

      else
      {
        time_t v7 = time(0LL);
        if (qword_10008E138) {
          uint64_t v5 = (const char *)qword_10008E138;
        }
        else {
          uint64_t v5 = "UNKNOWN-DEV";
        }
        stat v6 = ctime(&v7);
        fprintf(v2, "\n%s: fsck_apfs started at %s", v5, v6);
        return fflush(v2);
      }
    }

    else
    {
      dword_10008E130 = 0;
    }
  }

  return result;
}

uint64_t sub_100040634(uint64_t a1)
{
  uint64_t v2 = *(FILE **)a1;
  memset(__b, 170, sizeof(__b));
  BOOL v3 = 0;
  while (dword_1000706A8 || *(void *)(a1 + 8) != *(void *)(a1 + 16))
  {
    pthread_mutex_lock(&stru_1000706B0);
    while (dword_1000706A8 && *(void *)(a1 + 8) == *(void *)(a1 + 16))
    {
      int v4 = pthread_cond_wait(&stru_10008D0E8, &stru_1000706B0);
      if (v4)
      {
        fprintf(__stderrp, "error %d from cond wait\n", v4);
        break;
      }
    }

    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(void *)(a1 + 16);
    unint64_t v7 = v5 - v6;
    if (v5 == v6)
    {
      pthread_mutex_unlock(&stru_1000706B0);
    }

    else
    {
      int v8 = *(const void **)(a1 + 16);
      if (v7 < 0x400)
      {
        __memcpy_chk(__b, v8, v5 - v6, 1024LL);
        uint64_t v9 = v6;
      }

      else
      {
        memcpy(__b, v8, 0x3FFuLL);
        memmove((void *)v6, (const void *)(v6 + 1023), v7 - 1023);
        uint64_t v9 = v5 - 1023;
        unint64_t v7 = 1023LL;
      }

      __b[v7] = 0;
      *(void *)(a1 + 8) = v9;
      *(void *)(a1 + --*(_DWORD *)(result + 16) = v6;
      pthread_mutex_unlock(&stru_1000706B0);
      int v10 = __b[0];
      if (__b[0])
      {
        size_t v11 = __b;
        do
        {
          int64_t v12 = v11++;
          if (v10)
          {
            while (v10 != 10)
            {
              int v13 = *v11++;
              int v10 = v13;
              if (!v13) {
                goto LABEL_19;
              }
            }

            *(v11 - 1) = 0;
            size_t v14 = "\n";
          }

          else
          {
LABEL_19:
            --v11;
            size_t v14 = "";
          }

          if (v2 == __stdoutp || *v12 == 0 || v3) {
            fprintf(v2, "%s%s");
          }
          else {
            fprintf(v2, "%s: %s%s");
          }
          BOOL v3 = *v14 != 10;
          int v10 = *v11;
        }

        while (*v11);
      }

      fflush(v2);
    }
  }

  return 0LL;
}

uint64_t sub_100040874(uint64_t a1, const char *a2)
{
  byte_10008D128 = 0;
  if (dword_10008E130) {
    return sub_1000402AC(2LL, (uint64_t)&qword_10008D0A8, "%s", a2, 0LL);
  }
  uint64_t result = qword_10008D0A8;
  if (qword_10008D0A8)
  {
    fprintf((FILE *)qword_10008D0A8, "%s: ", (const char *)qword_10008E138);
    byte_10008D128 = 1;
    return fputs(a2, (FILE *)qword_10008D0A8);
  }

  return result;
}

uint64_t sub_10004092C(int a1, char *a2)
{
  if (dword_10008E130) {
    return sub_1000402AC(2LL, (uint64_t)&qword_10008D0C8, "%s", a2, 0LL);
  }
  else {
    return fputs(a2, __stdoutp);
  }
}

uint64_t sub_10004096C( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_100040994(a1, &a9);
}

uint64_t sub_100040994(char *__format, va_list a2)
{
  va_list v9 = a2;
  va_list v10 = a2;
  byte_10008D128 = 0;
  if (qword_10008DB78 && *(_DWORD *)(qword_10008DB78 + 32) == 3)
  {
    __s = (char *)0xAAAAAAAAAAAAAAAALL;
    vasprintf(&__s, __format, v10);
    BOOL v3 = __s;
    if (__s)
    {
      size_t v4 = strlen(__s);
      v7[0] = 0xAAAAAAAA00000000LL;
      v7[1] = __s;
      void v7[2] = 0x100000005LL;
      v7[3] = 0xAAAAAAAA00000000LL;
      v7[4] = 0LL;
      if (v4)
      {
        if (__s[v4 - 1] == 10)
        {
          __s[v4 - 1] = 0;
          BOOL v3 = __s;
        }
      }

      sub_100042BA4(qword_10008DB70, (uint64_t)v7, v3, 0LL);
      free(__s);
    }
  }

  else if (dword_10008E130)
  {
    sub_1000402AC(1LL, (uint64_t)&qword_10008D0C8, __format, 0LL, v10);
  }

  else
  {
    vfprintf(__stderrp, __format, v10);
  }

  if (dword_10008E130) {
    return sub_1000402AC(1LL, (uint64_t)&qword_10008D0A8, __format, 0LL, v9);
  }
  uint64_t result = qword_10008D0A8;
  if (qword_10008D0A8)
  {
    if ((byte_10008D128 & 1) != 0)
    {
      if (!strchr(__format, 10)) {
        return vfprintf((FILE *)qword_10008D0A8, __format, v9);
      }
      BOOL v6 = 0;
    }

    else
    {
      fprintf((FILE *)qword_10008D0A8, "%s: ", (const char *)qword_10008E138);
      BOOL v6 = strchr(__format, 10) == 0LL;
    }

    byte_10008D128 = v6;
    return vfprintf((FILE *)qword_10008D0A8, __format, v9);
  }

  return result;
}

char *sub_100040B50( char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (qword_10008DB78)
  {
    if (*(_DWORD *)(qword_10008DB78 + 24)) {
      return (char *)sub_100040994(result, &a9);
    }
  }

  return result;
}

void sub_100040B90( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_100040BC4(const char *a1, const char *a2, va_list a3)
{
  size_t v5 = strlen(a1);
  unsigned int v6 = vsnprintf(0LL, 0LL, a2, a3);
  if ((v6 & 0x80000000) == 0)
  {
    size_t v7 = v5 + v6 + 1;
    int v8 = (char *)malloc(v7);
    va_list v9 = strcpy(v8, a1);
    vsnprintf(&v9[v5], v7 - v5, a2, a3);
    sub_10004096C("%s", v10, v11, v12, v13, v14, v15, v16, (char)v8);
    free(v8);
  }

void sub_100040C68( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v10 = strlen(a1);
  uint64_t v11 = off_10008D690(0LL, a1, v10) & 0x3FF;
  int v12 = byte_10008D129[v11];
  if (v12 <= 49)
  {
    byte_10008D129[v11] = v12 + 1;
    sub_100040BC4("warning: ", a1, &a9);
    if (byte_10008D129[v11] == 50) {
      sub_10004096C( "Too many warnings of this type generated; suppressing subsequent ones.\n",
    }
        v13,
        v14,
        v15,
        v16,
        v17,
        v18,
        v19,
        v20);
  }

char *sub_100040D08( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100040B50(" revision: %u key len: %u", v16, v17, v18, v19, v20, v21, v22, *(_WORD *)(a1 + 16));
}

char *sub_100040DA8( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100040B50( "inum: %8lld version: %u flags: %u current_offset: %8llu current_ns_offset: %8llu\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  *a2);
}

char *sub_100040DE4( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100040B50( "logical addr: %lld  phys-block-num: %lld  len: %lld  flags: %x\n",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  a2[1]);
}

void sub_100040E4C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a3 > 7)
  {
    unsigned int v9 = a5;
    unsigned int v11 = a3;
    unint64_t v14 = *(void *)a2;
    if (a3 <= 0xB && (v14 & 0xF000000000000000LL) == 0xE000000000000000LL)
    {
      sub_100040B50("obj-id: %8lld type: ???\n", a2, a3, a4, a5, a6, a7, a8, v14);
    }

    else
    {
      unint64_t v15 = v14 >> 60;
      if (v14 >> 60 == 14) {
        LODWORD(v15) = *(unsigned __int8 *)(a2 + 8);
      }
      unsigned int v77 = -1431655766;
      unsigned int v78 = -1431655766;
      char v16 = v14;
      sub_10003BE98(v15);
      sub_100040B50("obj-id: %8lld type: %-11s\n", v17, v18, v19, v20, v21, v22, v23, v16);
      if (sub_10003A3A0(*(void *)(a1 + 40), (unint64_t *)a2, v11, &v78)
        || sub_10003A4BC(a2, (unsigned __int16 *)a4, v9, &v77))
      {
        sub_100040B90("key size (%u)/val size (%u) is invalid\n", v24, v25, v26, v27, v28, v29, v30, v11);
      }

      else if (v78 <= v11)
      {
        if (v77 <= v9)
        {
          switch((int)v15)
          {
            case 1:
              sub_100040B50( " extentref_tree_oid: %lld sblock_oid: %lld change_time: %llu create_time: %llu\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(_OWORD *)a4);
              sub_100040B50( " extentref_Tree_type: %u flags: %u name: '%.*s' name_len: %u\n",  v31,  v32,  v33,  v34,  v35,  v36,  v37,  *(_DWORD *)(a4 + 40));
              break;
            case 2:
              sub_100040B50( "refcnt %d len %lld owning_obj_id %lld\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(_DWORD *)(a4 + 16));
              break;
            case 3:
              sub_100040B50( "private-id: %lld parent-id: %lld cr/mtime: %lld/%lld \n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(void *)(a4 + 8));
              if ((*(_WORD *)(a4 + 80) & 0xF000) == 0x4000)
              {
                sub_100040B50("gen-count: %u nchildren: %d \n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a4 + 64));
              }

              else if (*(int *)(a4 + 56) >= 2)
              {
                sub_100040B50("nlink: %d \n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a4 + 56));
              }

              sub_100040B50("def-prot-class: %d \n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a4 + 60));
              if (*(_WORD *)(a4 + 82)) {
                sub_100040B50("pad1: 0x%x \n", v68, v69, v70, v71, v72, v73, v74, *(_WORD *)(a4 + 82));
              }
              if (*(void *)(a4 + 84)) {
                sub_100040B50("uncompressed-size: 0x%llx \n", v68, v69, v70, v71, v72, v73, v74, *(void *)(a4 + 84));
              }
              sub_100040B50( "uid/gid/mode: %d/%d/0x%x bsd_flags: 0x%x internal_flags: 0x%llx name: %s\n",  v68,  v69,  v70,  v71,  v72,  v73,  v74,  *(_DWORD *)(a4 + 72));
              break;
            case 4:
              sub_100040B50("flags: 0x%x data-len: %d name: %.*s\n", v24, v25, v26, v27, v28, v29, v30, *(_WORD *)a4);
              if ((*(_WORD *)a4 & 1) != 0) {
                sub_100040B50( " out-of-line data size: %lld (under obj-id: %lld / crypto-id: %lld)\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  *(void *)(a4 + 12));
              }
              else {
                sub_100040B50(" embedded data size: %d\n", v38, v39, v40, v41, v42, v43, v44, *(_WORD *)(a4 + 2));
              }
              break;
            case 5:
              sub_100040B50( "sib-id: %lld parent-id: %lld name: %.*s\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(void *)(a2 + 8));
              break;
            case 6:
              sub_100040B50("refcnt %d\n", v24, v25, v26, v27, v28, v29, v30, *(_DWORD *)a4);
              break;
            case 7:
              __int128 v75 = *(_OWORD *)(a4 + 4);
              int v76 = *(_DWORD *)(a4 + 20);
              sub_100040B50("refcnt: %d \n", v24, v25, v26, v27, v28, v29, v30, *(_DWORD *)a4);
              sub_100040D08((uint64_t)&v75, v54, v55, v56, v57, v58, v59, v60);
              break;
            case 8:
              sub_100040B50( "logical addr: %lld  phys-block-num: %lld  crypto-id: %lld  len: %lld  flags: %x\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(void *)(a2 + 8));
              break;
            case 9:
              if ((*(_BYTE *)(*(void *)(a1 + 40) + 56LL) & 9) != 0) {
                sub_100040B50( "file-id: %6lld flags: %d date-added: %lld hash: 0x%x name-len: %d name: %.*s\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(void *)a4);
              }
              else {
                sub_100040B50( "file-id: %6lld flags: %d date-added: %lld name-len: %d name: %.*s\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(void *)a4);
              }
              break;
            case 10:
              sub_100040B50( "num children: %lld total size: %lld gen-count: %lld\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(_OWORD *)a4);
              if (*(void *)(a4 + 16)) {
                sub_100040B50(" chained-key: %lld\n", v61, v62, v63, v64, v65, v66, v67, *(void *)(a4 + 16));
              }
              break;
            case 11:
              unint64_t v45 = v11 - 10LL;
              sub_100040B50(" name: '%.*s' name_len: %u snap_xid: %lld\n", v24, v25, v26, v27, v28, v29, v30, v45);
              break;
            case 12:
              sub_100040B50("sib-map: %lld\n", v24, v25, v26, v27, v28, v29, v30, *(void *)a4);
              break;
            case 13:
              unint64_t v46 = *(void *)(a2 + 8);
              if (HIBYTE(v46) == 2)
              {
                sub_100040B50( " type: %u hash: 0x%llx total_count: %llu physical_size: %llu flags: 0x%x\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  2);
              }

              else if (HIBYTE(v46) == 1)
              {
                sub_100040B50(" type: %u logical addr: %lld\n", v24, v25, v26, v27, v28, v29, v30, 1);
              }

              else
              {
                sub_100040B50(" type: %u\n", v24, v25, v26, v27, v28, v29, v30, SHIBYTE(v46));
              }

              break;
            case 16:
              sub_100040B50( " atime: %llu file_id: %llu file_size: %llu dstream_id: %llu flags: 0x%x owning_uid: %u\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(void *)(a2 + 12));
              break;
            case 17:
              sub_100040B50( " file_id: %llu dstream_id: %llu\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(void *)(a2 + 12));
              break;
            case 18:
              sub_100040B50( " descendants: %llu phys_size: %llu resource_fork_size: %llu gen_count: %llu chained_key: %llu flags: 0x%x\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(_OWORD *)a4);
              break;
            case 19:
              sub_100040B50( " private_id: %llu, file_id: %llu\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  *(void *)(a2 + 12));
              break;
            default:
              return;
          }
        }

        else
        {
          sub_100040B90("val size is too small, actual: %u, minimum: %u\n", v24, v25, v26, v27, v28, v29, v30, v9);
        }
      }

      else
      {
        sub_100040B90("key size is too small, actual: %u, minimum: %u\n", v24, v25, v26, v27, v28, v29, v30, v11);
      }
    }
  }

  else
  {
    sub_100040B50("obj-id: ??? type: ???\n", a2, a3, a4, a5, a6, a7, a8, a9);
  }

char *sub_100041404()
{
  IOPMAssertionID AssertionID = 0;
  if (IOPMAssertionCreateWithName(@"PreventUserIdleDisplaySleep", 0xFFu, @"Running FSCK", &AssertionID))
  {
    size_t v7 = "failed!";
  }

  else
  {
    dword_10008D52C = AssertionID;
    size_t v7 = "succeeded.";
  }

  return sub_100040B50("Disabling idle sleep, %s\n", v0, v1, v2, v3, v4, v5, v6, (char)v7);
}

char *sub_100041470()
{
  uint64_t result = (char *)dword_10008D52C;
  if (dword_10008D52C)
  {
    dword_10008D52C = 0;
    IOReturn v1 = IOPMAssertionRelease((IOPMAssertionID)result);
    unsigned int v9 = "failed!";
    if (!v1) {
      unsigned int v9 = "succeeded.";
    }
    return sub_100040B50("Enabling idle sleep, %s\n", v2, v3, v4, v5, v6, v7, v8, (char)v9);
  }

  return result;
}

uint64_t sub_1000414C4()
{
  int v0 = dword_100070EC0;
  if ((dword_100070EC0 & 0x80000000) == 0)
  {
    dword_100070EC0 = -1;
    fcntl(v0, 54, 0LL);
    uint64_t result = close(v0);
  }

  if (dword_10008D530)
  {
    int v2 = dword_10008D530;
    dword_10008D530 = 0;
    return sub_10001A488((io_connect_t *)&v2);
  }

  return result;
}

uint64_t sub_100041530(const char *a1)
{
  uint64_t result = open(a1, 2);
  if ((result & 0x80000000) == 0) {
    return close(result);
  }
  return result;
}

BOOL sub_100041554(const char *a1)
{
  IOReturn v1 = sub_10002A8E0(a1);
  int v2 = IOBSDNameMatching(kIOMasterPortDefault, 0, v1);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v2);
  if (MatchingService)
  {
    io_object_t v4 = MatchingService;
    io_iterator_t iterator = 0;
    IORegistryEntryGetChildIterator(MatchingService, "IOService", &iterator);
    if (iterator)
    {
      io_object_t v5 = IOIteratorNext(iterator);
      if (!v5)
      {
LABEL_8:
        IOObjectRelease(iterator);
        BOOL v11 = 0LL;
LABEL_16:
        IOObjectRelease(v4);
        return v11;
      }

      io_object_t v6 = v5;
      uint64_t v7 = kCFAllocatorDefault;
      while (1)
      {
        CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v6, @"IOMatchCategory", kCFAllocatorDefault, 0);
        if (CFProperty)
        {
          unsigned int v9 = CFProperty;
          int v10 = CFEqual(CFProperty, @"IOStorage");
          CFRelease(v9);
          if (v10) {
            break;
          }
        }

        IOObjectRelease(v6);
        io_object_t v6 = IOIteratorNext(iterator);
        if (!v6) {
          goto LABEL_8;
        }
      }

      IOObjectRelease(iterator);
    }

    else
    {
      uint64_t v7 = kCFAllocatorDefault;
      io_object_t v6 = v4;
    }

    CFTypeRef v12 = IORegistryEntryCreateCFProperty(v6, @"Status", v7, 0);
    if (v12)
    {
      uint64_t v13 = v12;
      BOOL v11 = CFEqual(v12, @"Corrupt") != 0;
      CFRelease(v13);
    }

    else
    {
      BOOL v11 = 0LL;
    }

    IOObjectRelease(v6);
    goto LABEL_16;
  }

  return 0LL;
}

uint64_t sub_1000416DC(const char **a1, void *a2, char a3)
{
  BOOL v6 = sub_10002AA84(*a1);
  BOOL v7 = v6;
  if (v6) {
    int v8 = 16;
  }
  else {
    int v8 = 8;
  }
  if (a2) {
    unsigned int v9 = *(_DWORD *)(a2[1] + 36LL);
  }
  else {
    unsigned int v9 = 0;
  }
  uint64_t v10 = 0LL;
  if (v6) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = 0;
  }
  int v30 = a3 & 3;
  for (char i = 1; ; char i = 0)
  {
    uint64_t v13 = &a1[12 * v10];
    v13[104] = (const char *)v10;
    unint64_t v14 = &a1[v10];
    char v16 = v14[3];
    unint64_t v15 = (uint64_t *)(v14 + 3);
    if (v16)
    {
      uint64_t v17 = sub_10001BC48(v15, (__int128 *)v13 + 48, v8, v11);
      if ((_DWORD)v17) {
        break;
      }
      if (a2) {
        goto LABEL_17;
      }
      goto LABEL_20;
    }

    uint64_t v18 = *a1;
    if (a2)
    {
      uint64_t v17 = sub_10001C478(v18, v30, v15, (__int128 *)v13 + 48, v8, v11);
      if ((_DWORD)v17) {
        break;
      }
LABEL_17:
      if (*v15)
      {
        sub_10002BE5C(*v15);
        sub_100041834(a2, *v15);
      }

      goto LABEL_20;
    }

    uint64_t v17 = sub_10002C8BC(v18, v30, v15);
    if ((_DWORD)v17) {
      break;
    }
LABEL_20:
    char v19 = i & v7;
    uint64_t v10 = 1LL;
    if ((v19 & 1) == 0) {
      return 0LL;
    }
  }

  uint64_t v20 = v17;
  uint64_t v21 = *a1;
  strerror(v17);
  sub_100040B90("device %s failed to open with error: %s\n", v22, v23, v24, v25, v26, v27, v28, (char)v21);
  return v20;
}

void *sub_100041834(void *result, uint64_t a2)
{
  uint64_t v2 = result[1];
  if ((*(_BYTE *)(v2 + 65) & 1) != 0)
  {
    uint64_t v3 = result[3];
    if (v3) {
      return sub_10001BBE8( a2,  *(void *)(v3 + 48),  0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v2 + 36))),  *(void *)(v3 + 96));
    }
  }

  return result;
}

uint64_t sub_100041874(uint64_t a1)
{
  uint64_t v2 = 0LL;
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = a1 + 8 * v2;
    uint64_t v8 = *(void *)(v5 + 24);
    BOOL v7 = (void *)(v5 + 24);
    uint64_t result = v8;
    if (v8)
    {
      uint64_t result = sub_10002BE10(result);
      *BOOL v7 = 0LL;
    }

    char v3 = 0;
    uint64_t v2 = 1LL;
  }

  while ((v4 & 1) != 0);
  return result;
}

uint64_t sub_1000418C4(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v4 = qword_10008DB78;
  if (*(_DWORD *)(qword_10008DB78 + 16) != -1)
  {
    *(_WORD *)a2 = 0;
    *(_BYTE *)(a2 + 2) = 0;
    goto LABEL_3;
  }

  BOOL v7 = (_BYTE *)(a2 + 2);
  uint64_t v8 = (_BYTE *)(a2 + 1);
  int v9 = sub_100041B90( *(const char **)(qword_10008DB78 + 8),  1,  (_BYTE *)a2,  (_BYTE *)(a2 + 1),  (char *)(a2 + 2),  (void **)(a2 + 8));
  if (v9)
  {
    int v17 = v9;
    uint64_t v18 = *(void *)(qword_10008DB78 + 8);
    strerror(v9);
    sub_100040B90("dev_is_mounted(%s) failed with error: %s\n", v19, v20, v21, v22, v23, v24, v25, v18);
    uint64_t v26 = 153LL;
    int v27 = v17;
LABEL_7:
    sub_100044E7C((char *)v26, v27);
    return 66LL;
  }

  if (!*(_BYTE *)a2)
  {
    uint64_t v4 = qword_10008DB78;
LABEL_3:
    if (!*(_BYTE *)(v4 + 37))
    {
      uint64_t v5 = 0LL;
      *(_DWORD *)(a2 + 32) = 18;
      return v5;
    }

    goto LABEL_4;
  }

  uint64_t v29 = qword_10008DB78;
  if (!*v8)
  {
    if (*(_DWORD *)(qword_10008DB78 + 20) == -1)
    {
      *(_BYTE *)(a2 + --*(_DWORD *)(result + 16) = 1;
    }

    else
    {
      int v31 = sub_100041B90( *(const char **)qword_10008DB78,  0,  (_BYTE *)(a2 + 16),  (_BYTE *)(a2 + 17),  (char *)(a2 + 18),  (void **)(a2 + 24));
      if (v31)
      {
        int v32 = v31;
        uint64_t v33 = *(void *)qword_10008DB78;
        strerror(v31);
        sub_100040B90("dev_is_mounted(%s) failed with error: %s\n", v34, v35, v36, v37, v38, v39, v40, v33);
        uint64_t v26 = 155LL;
        int v27 = v32;
        goto LABEL_7;
      }

      if (!*(_BYTE *)(a2 + 16))
      {
        uint64_t v42 = qword_10008DB78;
        if (!*(_BYTE *)(qword_10008DB78 + 37))
        {
          *(_DWORD *)(a2 + 32) = 18;
          *(_BYTE *)(a2 + 40) = 1;
          sub_100040B90( "live repair of a volume in mounted container %s is not supported yet.\n",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  *(void *)(v42 + 8));
          uint64_t v5 = 64LL;
          uint64_t v30 = 158LL;
          int v41 = 64;
          goto LABEL_31;
        }

        if (!*(_BYTE *)(qword_10008DB78 + 36))
        {
          if (*(_BYTE *)(qword_10008DB78 + 38)) {
            goto LABEL_27;
          }
          sub_100040B90( "container %s is mounted with write access; please re-run with -l.\n",
            v10,
            v11,
            v12,
            v13,
            v14,
            v15,
            v16,
            *(void *)(qword_10008DB78 + 8));
          uint64_t v5 = 65LL;
          uint64_t v30 = 589LL;
          goto LABEL_30;
        }

        if (*(_BYTE *)(qword_10008DB78 + 38)) {
          goto LABEL_27;
        }
LABEL_35:
        uint64_t v5 = 0LL;
        *a3 = 1;
        return v5;
      }
    }

    if (!*(_BYTE *)(qword_10008DB78 + 37))
    {
      sub_100040B90( "container %s is mounted with write access.\n",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  *(void *)(qword_10008DB78 + 8));
      uint64_t v5 = 65LL;
      uint64_t v30 = 157LL;
      goto LABEL_30;
    }

    if (!*(_BYTE *)(qword_10008DB78 + 36) || !*(_BYTE *)(a2 + 18) || *(_BYTE *)(qword_10008DB78 + 38))
    {
      if (*(_BYTE *)(qword_10008DB78 + 38))
      {
LABEL_27:
        uint64_t v5 = 0LL;
        *(_DWORD *)(a2 + 32) = 0;
        *(_BYTE *)(a2 + 40) = 1;
        return v5;
      }

      sub_100040B90( "container %s is mounted with write access; please re-run with -l.\n",
        v10,
        v11,
        v12,
        v13,
        v14,
        v15,
        v16,
        *(void *)(qword_10008DB78 + 8));
      uint64_t v5 = 65LL;
      uint64_t v30 = 156LL;
LABEL_30:
      int v41 = 65;
LABEL_31:
      sub_100044E7C((char *)v30, v41);
      return v5;
    }

    goto LABEL_35;
  }

  if (!*(_BYTE *)(qword_10008DB78 + 37))
  {
    if (*v7)
    {
      *(void *)(a2 + 32) = 0x4000000000012LL;
      sub_100040B90( "container %s is mounted. repairs in a mounted container is not supported yet.\n",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  *(void *)(v29 + 8));
      uint64_t v5 = 65LL;
      uint64_t v30 = 857LL;
    }

    else
    {
      sub_100040B90("container %s is mounted.\n", v10, v11, v12, v13, v14, v15, v16, *(void *)(qword_10008DB78 + 8));
      uint64_t v5 = 65LL;
      uint64_t v30 = 154LL;
    }

    goto LABEL_30;
  }

uint64_t sub_100041B90(const char *a1, int a2, _BYTE *a3, _BYTE *a4, char *a5, void **a6)
{
  uint64_t v8 = a4;
  *a3 = 0;
  *a4 = 1;
  *a5 = 0;
  *a6 = 0LL;
  uint64_t v10 = sub_10002A8E0(a1);
  size_t v11 = strlen(v10);
  unsigned int v12 = getfsstat(0LL, 0, 2);
  if ((v12 & 0x80000000) != 0)
  {
    uint64_t v15 = 0LL;
    goto LABEL_34;
  }

  int v13 = 2168 * v12;
  uint64_t v14 = (statfs *)malloc(2168LL * v12);
  uint64_t v15 = v14;
  if (!v14 || (unsigned int v16 = getfsstat(v14, v13, 2), (v16 & 0x80000000) != 0))
  {
LABEL_34:
    uint64_t v34 = *__error();
  }

  else
  {
    if (v16)
    {
      uint64_t v36 = v8;
      uint64_t v37 = a5;
      unint64_t v17 = 0LL;
      uint64_t v18 = 2168LL * v16;
      while (1)
      {
        _X23 = &v15[v17 / 0x878];
        f_mntfromname = v15[v17 / 0x878].f_mntfromname;
        int v21 = strcmp(f_mntfromname, "root_device");
        __asm { PRFM            #0, [X23,#0x1998] }

        if (!v21) {
          f_mntfromname = devname(_X23->f_fsid.val[0], 0x6000u);
        }
        uint64_t v26 = strrchr(f_mntfromname, 64);
        if (v26) {
          int v27 = v26 + 1;
        }
        else {
          int v27 = f_mntfromname;
        }
        uint64_t v28 = sub_10002A8E0(v27);
        if (strncmp(v28, v10, v11)) {
          goto LABEL_31;
        }
        int v29 = v28[v11];
        if (v28[v11])
        {
          if ((a2 & 1) != 0)
          {
            if (v29 != 115) {
              goto LABEL_31;
            }
LABEL_17:
            uint32_t f_flags = v15[v17 / 0x878].f_flags;
            if ((f_flags & 0x4000) == 0) {
              goto LABEL_18;
            }
            goto LABEL_24;
          }

          if (v29 != 115 || (v15[v17 / 0x878].f_flags & 0x40000000) == 0) {
            goto LABEL_31;
          }
        }

        else if (a2)
        {
          goto LABEL_17;
        }

        uint32_t f_flags = v15[v17 / 0x878].f_flags;
        if ((f_flags & 0x40000000) == 0)
        {
LABEL_18:
          char v31 = 0;
          goto LABEL_26;
        }

LABEL_31:
        v17 += 2168LL;
        if (v18 == v17)
        {
          uint64_t v34 = 0LL;
          uint64_t v8 = v36;
          goto LABEL_35;
        }
      }
    }

    uint64_t v34 = 0LL;
  }

LABEL_35:
  if (!*a3) {
    *uint64_t v8 = 0;
  }
  if (v15) {
    free(v15);
  }
  if ((_DWORD)v34 && *a6)
  {
    free(*a6);
    *a6 = 0LL;
  }

  return v34;
}

uint64_t sub_100041DC0(uint64_t *a1, int a2)
{
  int v3 = *(_DWORD *)(qword_10008DB78 + 16);
  if (v3 == -1) {
    int v4 = sub_10001C4D0(*(const char **)(qword_10008DB78 + 8), a2, a1);
  }
  else {
    int v4 = sub_10001C438(v3, a1);
  }
  int v5 = v4;
  if (!v4) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(qword_10008DB78 + 8);
  strerror(v4);
  sub_100040B90("device %s failed to open with error: %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
  sub_100044E7C((char *)0xA3, v5);
  return 66LL;
}

uint64_t sub_100041E50(uint64_t a1, char a2, BOOL *a3)
{
  unsigned int v22 = -1431655766;
  unsigned int v23 = -1431655766;
  sub_10001CB00(a1, &v23, (int *)&v22);
  uint64_t result = 0LL;
  *a3 = 0;
  unsigned int v7 = v23;
  if (v23 < v22)
  {
    while (1)
    {
      uint64_t v8 = sub_10001CA1C(a1, v7);
      uint64_t v9 = *(char **)v8;
      if (!*(void *)v8)
      {
        uint64_t v10 = *(void *)(qword_10008DB78 + 8);
        uint64_t v24 = 0LL;
        asprintf(&v24, "/dev/r%ss%d", (const char *)(v10 + 6), v7 + 1);
        uint64_t v9 = v24;
        *(void *)uint64_t v8 = v24;
        if (!v9)
        {
          sub_100040B90("failed to allocate memory for device path\n", v11, v12, v13, v14, v15, v16, v17, v21);
          sub_100044E7C((char *)0xA4, 12);
          return 71LL;
        }
      }

      if (!*(_BYTE *)(qword_10008DB78 + 36) && !*(_BYTE *)(qword_10008DB78 + 43))
      {
        BOOL v18 = sub_10002AA34(v9);
        BOOL v19 = *a3 || v18;
        *a3 = v19;
        if (v18)
        {
          if (*(_BYTE *)(qword_10008DB78 + 44))
          {
            *strrchr(*(const char **)v8, 115) = 0;
            v8[8] = 1;
            *a3 = 0;
          }

          int v20 = sub_1000416DC((const char **)v8, 0LL, a2);
          if (v20) {
            break;
          }
        }
      }

      if (++v7 >= v22) {
        return 0LL;
      }
    }

    sub_100044E7C((char *)0x9F, v20);
    return 66LL;
  }

  return result;
}

uint64_t sub_100041FC4(uint64_t a1, char a2)
{
  unsigned int v32 = -1431655766;
  unsigned int v33 = -1431655766;
  sub_10001CB00(a1, &v33, (int *)&v32);
  if (dword_10008D530)
  {
    unsigned int v4 = v32;
  }

  else
  {
    int v35 = -1431655766;
    *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v34[4] = v16;
    _OWORD v34[5] = v16;
    v34[2] = v16;
    void v34[3] = v16;
    v34[0] = v16;
    v34[1] = v16;
    uint64_t v17 = *(void *)(a1 + 8);
    BOOL v18 = *(char **)(qword_10008DB78 + 8);
    __int128 v19 = *(_OWORD *)(v17 + 1392);
    v31[0] = *(_OWORD *)(v17 + 1296);
    v31[1] = v19;
    int v20 = sub_10001A378(v18, (a2 & 3) != 0, v31, (io_connect_t *)&dword_10008D530, (uint64_t)v34);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *(void *)(qword_10008DB78 + 8);
      strerror(v20);
      sub_100040B90("failed to enable crypto I/O mode for container %s: %s\n", v23, v24, v25, v26, v27, v28, v29, v22);
      sub_100044E7C((char *)0x3B1, v21);
      return 66LL;
    }

    unsigned int v4 = v32;
    for (i = v33; i < v32; unsigned int v4 = v32)
    {
      sub_10001CA1C(a1, i)[8] = *((_BYTE *)v34 + i) != 0;
      ++i;
    }
  }

  unsigned int v5 = v33;
  if (v33 < v4)
  {
    do
    {
      uint64_t v6 = sub_10001CA1C(a1, v5);
      if (!v6[8])
      {
        unsigned int v7 = v6;
        uint64_t v8 = 0LL;
        char v9 = 1;
        do
        {
          char v10 = v9;
          uint64_t v11 = &v7[8 * v8];
          uint64_t v14 = *((void *)v11 + 3);
          uint64_t v13 = v11 + 24;
          uint64_t v12 = v14;
          if (v14)
          {
            sub_10002BE10(v12);
            *uint64_t v13 = 0LL;
          }

          char v9 = 0;
          uint64_t v8 = 1LL;
        }

        while ((v10 & 1) != 0);
      }

      ++v5;
    }

    while (v5 < v32);
  }

  return 0LL;
}

uint64_t sub_100042178(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4 = *(const char **)(a2 + 24);
  if (!v4) {
    unsigned int v4 = *(const char **)(a2 + 8);
  }
  int v5 = open(v4, 0);
  dword_100070EC0 = v5;
  if (v5 < 0)
  {
    int v17 = *__error();
    strerror(v17);
    sub_100040B90("could not open %s to freeze the volume: %s\n", v18, v19, v20, v21, v22, v23, v24, (char)v4);
    sub_100044E7C((char *)0xA1, v17);
    return 66LL;
  }

  if (a3)
  {
    int v33 = 0;
    uint64_t result = ffsctl(v5, 0x80044A62uLL, &v33, 0);
    if (!(_DWORD)result) {
      return result;
    }
    int v7 = *__error();
    char v8 = strerror(v7);
    sub_100040B90("could not sync and freeze volume: %s\n", v9, v10, v11, v12, v13, v14, v15, v8);
    uint64_t v16 = 1081LL;
  }

  else
  {
    uint64_t result = fcntl(v5, 53, 0LL);
    if (!(_DWORD)result) {
      return result;
    }
    int v7 = *__error();
    char v25 = strerror(v7);
    sub_100040B90("could not freeze volume: %s\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v16 = 162LL;
  }

  sub_100044E7C((char *)v16, v7);
  return 71LL;
}

uint64_t sub_10004227C(uint64_t *a1, int8x16_t *a2)
{
  uint64_t v4 = a2[2].i64[1];
  int8x16_t v7 = a2[5];
  uint64_t v8 = a2[6].i64[0];
  uint64_t result = sub_100023FA8(a1, 0LL, v4, (uint64_t)&v7, v7, v5);
  if (!(_DWORD)result) {
    *(_BYTE *)(qword_10008DB78 + 49) = 1;
  }
  return result;
}

uint64_t sub_1000422F4(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  *a3 = -1LL;
  unsigned int v21 = 8;
  v20[0] = 0xAAAAAAAAAAAAAAAALL;
  v20[1] = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v19 = 16;
  uint64_t v4 = sub_100029C7C(a1, a2, &v22);
  if (!(_DWORD)v4)
  {
    uint64_t v14 = v22;
    uint64_t v15 = 0xFFFFFFFFLL;
    uint64_t v16 = a3;
    unsigned int v17 = 8;
    while (1)
    {
      uint64_t v18 = sub_100034BB4(v14, 0LL, v15, v16, &v21, v17, v20, &v19);
      uint64_t v4 = v18;
      if ((v18 & 0xFFFFFFFD) != 0) {
        break;
      }
      if ((_DWORD)v18) {
        return v4;
      }
      if ((v20[0] & 3) == 0) {
        return 0LL;
      }
      uint64_t v14 = v22;
      unsigned int v17 = v21;
      uint64_t v15 = 4294967294LL;
      uint64_t v16 = a3;
    }
  }

  char v5 = strerror(v4);
  sub_100040B90("unable to lookup latest snap xid: %s\n", v6, v7, v8, v9, v10, v11, v12, v5);
  return v4;
}

void sub_1000423D4(uint64_t a1, const char *a2, va_list a3)
{
  if (!a1) {
    return;
  }
  memset(__b, 170, sizeof(__b));
  int v5 = vsnprintf(__b, 0x400uLL, a2, a3);
  if (v5 < 0x401)
  {
LABEL_10:
    if (*(_BYTE *)(a1 + 56) == 1)
    {
      uint64_t v11 = *(void (**)(uint64_t, _BYTE *))(a1 + 48);
      if (!v11) {
        return;
      }
    }

    else
    {
      uint64_t v11 = *(void (**)(uint64_t, _BYTE *))(a1 + 40);
      if (!v11) {
        return;
      }
    }

    v11(a1, __b);
    return;
  }

  size_t v6 = v5;
  size_t v7 = v5 + 1LL;
  uint64_t v8 = (char *)malloc(v7);
  if (!v8)
  {
    strcpy(__b, "* * * cannot allocate memory * * *\n");
    goto LABEL_10;
  }

  uint64_t v9 = v8;
  if (v7 <= vsnprintf(v8, v6, a2, a3))
  {
    strcpy(__b, " * * * cannot allocate memory * * *\n");
    free(v9);
    goto LABEL_10;
  }

  uint64_t v10 = *(void (**)(uint64_t, char *))(a1 + 40);
  if (v10) {
    v10(a1, v9);
  }
  free(v9);
}

void sub_10004252C( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t sub_100042554(FILE **a1, char *a2)
{
  if (*a1) {
    uint64_t v2 = *a1;
  }
  else {
    uint64_t v2 = __stdoutp;
  }
  fputs(a2, v2);
  return fflush(v2);
}

_BYTE *sub_100042594(char *a1)
{
  if (!a1) {
    return 0LL;
  }
  IOReturn v1 = a1;
  unsigned int v2 = 1;
  do
  {
    a1 = strchr(a1 + 1, 37);
    v2 += 5;
  }

  while (a1);
  size_t v3 = strlen(v1);
  uint64_t v4 = calloc(1uLL, v3 + v2);
  int v5 = v4;
  if (v4)
  {
    char v6 = *v1;
    size_t v7 = v4;
    if (*v1)
    {
      int v8 = 0;
      int v9 = 0;
      uint64_t v10 = v4;
      do
      {
        if (v8)
        {
          unsigned int v11 = v6 - 65;
          BOOL v12 = ((1LL << (v6 - 65)) & 0x94E17D0094407DLL) == 0;
          int v8 = v11 > 0x37 || v12;
          size_t v7 = v10;
        }

        else
        {
          *uint64_t v10 = v6;
          size_t v7 = v10 + 1;
          if (*v1 == 37)
          {
            if (v1[1] == 37)
            {
              int v8 = 0;
              size_t v7 = v10 + 2;
              v10[1] = 37;
              ++v1;
            }

            else
            {
              v7 += sprintf(v10 + 1, "%d$@", ++v9);
              int v8 = 1;
            }
          }

          else
          {
            int v8 = 0;
          }
        }

        int v13 = *++v1;
        char v6 = v13;
        uint64_t v10 = v7;
      }

      while (v13);
    }

    *size_t v7 = 0;
  }

  return v5;
}

FILE **sub_1000426E0()
{
  int v0 = (FILE **)calloc(1uLL, 0x48uLL);
  IOReturn v1 = v0;
  if (v0)
  {
    if (sub_100042744((uint64_t)v0, (uint64_t)&unk_100070188) == -1)
    {
      sub_100042804(v1);
      return 0LL;
    }

    else
    {
      v1[5] = (FILE *)sub_100042554;
    }
  }

  return v1;
}

uint64_t sub_100042744(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0LL;
  if (a1)
  {
    uint64_t v4 = a2;
    if (a2)
    {
      if (!*(void *)(a2 + 8)) {
        return 0LL;
      }
      uint64_t v5 = 0LL;
      char v6 = (uint64_t *)(a2 + 48);
      do
      {
        uint64_t v7 = *v6;
        v6 += 5;
        ++v5;
      }

      while (v7);
      int v8 = realloc(*(void **)(a1 + 32), 8LL * (*(_DWORD *)(a1 + 24) + (int)v5));
      if (v8)
      {
        *(void *)(a1 + 32) = v8;
        int v9 = *(_DWORD *)(a1 + 24);
        uint64_t v10 = 8LL * v9;
        uint64_t v11 = v5;
        do
        {
          *(void *)(*(void *)(a1 + 32) + v10) = v4;
          v10 += 8LL;
          v4 += 40LL;
          --v11;
        }

        while (v11);
        BOOL v12 = *(void **)(a1 + 32);
        int v13 = v9 + v5;
        *(_DWORD *)(a1 + 24) = v13;
        qsort(v12, v13, 8uLL, (int (__cdecl *)(const void *, const void *))sub_100042A20);
        return 0LL;
      }

      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

void sub_100042804(FILE **a1)
{
  if (a1)
  {
    unsigned int v2 = a1[4];
    if (v2) {
      free(v2);
    }
    if (((_BYTE)a1[1] & 1) != 0) {
      fclose(*a1);
    }
    size_t v3 = a1[8];
    if (v3) {
      free(v3);
    }
    free(a1);
  }

uint64_t sub_100042854(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 40) = a2;
  return result;
}

uint64_t sub_100042870(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 48) = a2;
  return result;
}

uint64_t sub_10004288C(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  *(_DWORD *)(a1 + --*(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t sub_1000428A8(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  *(_DWORD *)(a1 + 20) = a2;
  return result;
}

uint64_t sub_1000428C4( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 16) != 1)
  {
    int v29 = *(_DWORD *)(a1 + 20);
    if (v29 == 2) {
      unsigned int v30 = 1;
    }
    else {
      unsigned int v30 = -1;
    }
    if (v29 == 1) {
      return 0LL;
    }
    else {
      return v30;
    }
  }

  unsigned int v11 = 0;
  uint64_t v34 = (char *)0xAAAAAAAAAAAAAAAALL;
  while (1)
  {
    uint64_t v34 = &a9;
    sub_1000423D4(a1, a2, &a9);
    int v18 = *(_DWORD *)(a1 + 20);
    if (v18 == 1)
    {
      uint64_t v28 = 0LL;
      uint64_t v31 = "NO\n";
LABEL_29:
      sub_10004252C(a1, v31, v12, v13, v14, v15, v16, v17, v33);
      return v28;
    }

    if (v18 == 2)
    {
      uint64_t v28 = 1LL;
      uint64_t v31 = "YES\n";
      goto LABEL_29;
    }

    size_t v33 = 0xAAAAAAAAAAAAAAAALL;
    unsigned int v19 = fgetln(__stdinp, &v33);
    if (!v19 || v33 == 0) {
      break;
    }
    int v27 = *v19;
    if (v27 == 10) {
      break;
    }
    if (v27 > 109)
    {
      if (v27 == 110) {
        return 0LL;
      }
      if (v27 == 121) {
        return 1LL;
      }
    }

    else
    {
      if (v27 == 78) {
        return 0LL;
      }
      if (v27 == 89) {
        return 1LL;
      }
    }

uint64_t sub_100042A20(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

uint64_t sub_100042A38(_DWORD *a1, _DWORD **a2)
{
  return (*a1 - **a2);
}

const void **sub_100042A4C(const void **result, int a2)
{
  int __key = a2;
  if (result)
  {
    uint64_t result = (const void **)bsearch( &__key,  result[4],  *((int *)result + 6),  8uLL,  (int (__cdecl *)(const void *, const void *))sub_100042A38);
    if (result) {
      return (const void **)*result;
    }
  }

  return result;
}

char *sub_100042A90(int a1, const char *a2, va_list a3)
{
  int v8 = 0LL;
  uint64_t v7 = 0LL;
  int v3 = a1 - 1;
  if ((a1 - 1) > 8)
  {
    uint64_t v4 = "";
    uint64_t v5 = "";
  }

  else
  {
    uint64_t v4 = off_10006C938[v3];
    uint64_t v5 = (const char *)*((void *)&off_10006C980 + v3);
  }

  vasprintf(&v7, a2, a3);
  if (!v7) {
    return 0LL;
  }
  asprintf(&v8, "%s%s%s\n", v4, v7, v5);
  free(v7);
  return v8;
}

uint64_t sub_100042B28(uint64_t a1, uint64_t a2, const char *a3, va_list a4)
{
  int v5 = *(_DWORD *)(a2 + 16);
  if (v5 == 8) {
    return 0LL;
  }
  char v6 = sub_100042A90(v5, a3, a4);
  if (v6)
  {
    uint64_t v13 = v6;
    sub_10004252C(a1, "%s", v7, v8, v9, v10, v11, v12, (char)v6);
    free(v13);
    return 0LL;
  }

  return 0xFFFFFFFFLL;
}

uint64_t sub_100042BA4(uint64_t a1, uint64_t a2, char *a3, _DWORD *a4)
{
  char v6 = sub_100042594(a3);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = v6;
  sub_10004252C(a1, "<plist version=1.0>\n", v7, v8, v9, v10, v11, v12, v94);
  sub_10004252C(a1, "\t<dict>\n", v14, v15, v16, v17, v18, v19, v95);
  sub_10004252C(a1, "\t\t<key>%s</key> <string>%s</string>\n", v20, v21, v22, v23, v24, v25, (char)"fsck_msg_type");
  if (*(_DWORD *)a2 != 119)
  {
    sub_10004252C(a1, "\t\t<key>%s</key> <integer>%s</integer>\n", v27, v28, v29, v30, v31, v32, (char)"fsck_verbosity");
    sub_10004252C( a1,  "\t\t<key>%s</key> <integer>%u</integer>\n",  v33,  v34,  v35,  v36,  v37,  v38,  (char)"fsck_msg_number");
    sub_10004252C(a1, "\t\t<key>%s</key> <string>%s</string>\n", v39, v40, v41, v42, v43, v44, (char)"fsck_msg_string");
  }

  if (*(int *)(a2 + 24) >= 1)
  {
    sub_10004252C(a1, "\t\t<key>%s</key>\n", v27, v28, v29, v30, v31, v32, (char)"parameters");
    sub_10004252C(a1, "\t\t<array>\n", v45, v46, v47, v48, v49, v50, v97);
    if (*(int *)(a2 + 24) >= 1)
    {
      uint64_t v57 = 0LL;
      do
      {
        switch(*(_DWORD *)(*(void *)(a2 + 32) + 4 * v57))
        {
          case 1:
          case 8:
            uint64_t v58 = a4;
            a4 += 2;
            sub_10004252C(a1, "\t\t\t<integer>%d</integer>\n", v51, v52, v53, v54, v55, v56, *v58);
            break;
          case 2:
            uint64_t v60 = a4;
            a4 += 2;
            sub_10004252C(a1, "\t\t\t<integer>%ld</integer>\n", v51, v52, v53, v54, v55, v56, *v60);
            break;
          case 3:
            uint64_t v61 = (char **)a4;
            a4 += 2;
            uint64_t v62 = sub_100042F68(*v61);
            sub_10004252C(a1, "\t\t\t<string>%s</string>\n", v63, v64, v65, v66, v67, v68, (char)v62);
            goto LABEL_22;
          case 4:
            uint64_t v69 = (char **)a4;
            a4 += 2;
            uint64_t v62 = sub_100042F68(*v69);
            int v76 = "path";
            goto LABEL_19;
          case 5:
            unsigned int v77 = (char **)a4;
            a4 += 2;
            uint64_t v62 = sub_100042F68(*v77);
            int v76 = "file";
            goto LABEL_19;
          case 6:
            unsigned int v78 = (char **)a4;
            a4 += 2;
            uint64_t v62 = sub_100042F68(*v78);
            int v76 = "directory";
            goto LABEL_19;
          case 7:
            uint64_t v79 = (char **)a4;
            a4 += 2;
            uint64_t v62 = sub_100042F68(*v79);
            int v76 = "volumename";
LABEL_19:
            sub_10004252C( a1,  "\t\t\t<dict><key>%s</key> <string>%s</string></dict>\n",  v70,  v71,  v72,  v73,  v74,  v75,  (char)v76);
            goto LABEL_22;
          case 9:
            int v80 = (char **)a4;
            a4 += 2;
            uint64_t v62 = sub_100042F68(*v80);
            sub_10004252C( a1,  "\t\t\t<dict><key>%s</key> <string>%s</string></dict>\n",  v81,  v82,  v83,  v84,  v85,  v86,  (char)"fstype");
LABEL_22:
            free(v62);
            break;
          case 0xA:
            uint64_t v87 = a4;
            a4 += 2;
            sub_10004252C(a1, "\t\t\t<integer>%llu</integer>\n", v51, v52, v53, v54, v55, v56, *v87);
            break;
          default:
            uint64_t v59 = a4;
            a4 += 2;
            sub_10004252C(a1, "\t\t\t<integer>%p</integer>\n", v51, v52, v53, v54, v55, v56, *v59);
            break;
        }

        ++v57;
      }

      while (v57 < *(int *)(a2 + 24));
    }

    sub_10004252C(a1, "\t\t</array>\n", v51, v52, v53, v54, v55, v56, v98);
  }

  sub_10004252C(a1, "\t</dict>\n", v27, v28, v29, v30, v31, v32, v96);
  sub_10004252C(a1, "</plist>\n", v88, v89, v90, v91, v92, v93, v99);
  free(v13);
  return 0LL;
}

char *sub_100042F68(char *result)
{
  if (result)
  {
    IOReturn v1 = result;
    bzero(__s1, 0x1801uLL);
    char v2 = *v1;
    if (*v1)
    {
      int v3 = (unsigned __int8 *)(v1 + 1);
      uint64_t v4 = __s1;
      do
      {
        if (v2 <= 38)
        {
          if (v2 == 34)
          {
            *(_DWORD *)uint64_t v4 = 1869967654;
            *((_WORD *)v4 + 2) = 15220;
            goto LABEL_16;
          }

          if (v2 != 38)
          {
LABEL_17:
            *uint64_t v4 = v2;
            uint64_t v5 = 1LL;
            goto LABEL_18;
          }

          *(_DWORD *)uint64_t v4 = 1886216486;
          v4[4] = 59;
          uint64_t v5 = 5LL;
        }

        else
        {
          switch(v2)
          {
            case '\'':
              *(_DWORD *)uint64_t v4 = 1869635878;
              *((_WORD *)v4 + 2) = 15219;
LABEL_16:
              uint64_t v5 = 6LL;
              goto LABEL_18;
            case '<':
              *(_DWORD *)uint64_t v4 = 997485606;
              break;
            case '>':
              *(_DWORD *)uint64_t v4 = 997484326;
              break;
            default:
              goto LABEL_17;
          }

          uint64_t v5 = 4LL;
        }

uint64_t sub_1000430B4(uint64_t a1, uint64_t a2, char *a3, _DWORD *a4)
{
  int v6 = sub_100042594(a3);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = v6;
  int v14 = *(_DWORD *)(a2 + 16) - 1;
  else {
    int v15 = dword_10006B5D4[v14];
  }
  if (*(_DWORD *)a2 != 119) {
    sub_10004252C(a1, "(%c,%s,%d)\n", v7, v8, v9, v10, v11, v12, v15);
  }
  if (*(int *)(a2 + 24) >= 1)
  {
    uint64_t v17 = 0LL;
    do
    {
      switch(*(_DWORD *)(*(void *)(a2 + 32) + 4 * v17))
      {
        case 1:
          uint64_t v20 = a4;
          a4 += 2;
          sub_10004252C(a1, "%d\n", v7, v8, v9, v10, v11, v12, *v20);
          break;
        case 2:
          uint64_t v21 = a4;
          a4 += 2;
          sub_10004252C(a1, "%ld\n", v7, v8, v9, v10, v11, v12, *v21);
          break;
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
          uint64_t v18 = a4;
          a4 += 2;
          sub_10004252C(a1, "%s\n", v7, v8, v9, v10, v11, v12, *v18);
          break;
        case 8:
          uint64_t v22 = a4;
          a4 += 2;
          sub_10004252C(a1, "(%d %%)\n", v7, v8, v9, v10, v11, v12, *v22);
          break;
        case 0xA:
          uint64_t v23 = a4;
          a4 += 2;
          sub_10004252C(a1, "%llu\n", v7, v8, v9, v10, v11, v12, *v23);
          break;
        default:
          uint64_t v19 = a4;
          a4 += 2;
          sub_10004252C(a1, "%p\n", v7, v8, v9, v10, v11, v12, *v19);
          break;
      }

      ++v17;
    }

    while (v17 < *(int *)(a2 + 24));
  }

  free(v13);
  return 0LL;
}

uint64_t sub_1000432BC()
{
  return 0LL;
}

uint64_t sub_1000432C4( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = sub_100042A4C((const void **)a1, a2);
  if (!v10) {
    sub_10004AB14();
  }
  uint64_t v11 = v10;
  int v12 = *(_DWORD *)(a1 + 16) - 1;
  else {
    uint64_t v13 = *(&off_10006CA10 + v12);
  }
  *(_BYTE *)(a1 + 56) = 1;
  sub_100042B28(a1, (uint64_t)v10, (const char *)v10[1], &a9);
  *(_BYTE *)(a1 + 56) = 0;
  return ((uint64_t (*)(uint64_t, const void **, const void *, char *))v13)(a1, v11, v11[1], &a9);
}

uint64_t sub_100043374( void *a1, uint64_t a2, __int128 *a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, int a8, char a9)
{
  if (!a1) {
    return 22LL;
  }
  unsigned int v11 = a6;
  if (a6 > 0x10000 && (a9 & 1) != 0)
  {
    unsigned int v11 = 0x10000;
  }

  else
  {
    while (a5 > 0x10000 && v11 < 0x10000 || a5 > 0x1000 && v11 < 0x400)
    {
      a5 >>= 1;
      v11 *= 2;
    }

    while (a5 <= 0xFFF && v11 > 0x400 || !HIWORD(a5) && v11 > 0x10000)
    {
      a5 *= 2;
      v11 >>= 1;
    }
  }

  uint64_t result = 34LL;
  if (a5 - 65537 >= 0xFFFF0FFF && v11 <= 0x10000 && v11 >= 0x400)
  {
    unsigned int v18 = *(_DWORD *)(a2 + 100);
    uint64_t v19 = (char *)calloc(1uLL, 0x128uLL);
    if (v19)
    {
      uint64_t v20 = v19;
      *((void *)v19 + 4) = a2;
      *((void *)v19 + 5) = a4;
      *((_DWORD *)v19 + 12) = v18;
      *((void *)v19 + 7) = *(void *)(a2 + 128);
      *((_DWORD *)v19 + 22) = a7;
      if (a3)
      {
        __int128 v21 = *a3;
        *(_OWORD *)(v19 + 2--*(_DWORD *)(result + 16) = a3[1];
        *(_OWORD *)(v19 + 200) = v21;
        __int128 v22 = a3[2];
        __int128 v23 = a3[3];
        __int128 v24 = a3[5];
        *(_OWORD *)(v19 + 264) = a3[4];
        *(_OWORD *)(v19 + 280) = v24;
        *(_OWORD *)(v19 + 248) = v23;
        *(_OWORD *)(v19 + 232) = v22;
      }

      uint64_t v25 = calloc(1uLL, 8LL * a7);
      *((void *)v20 + 10) = v25;
      if (v25)
      {
        size_t v26 = v11 * (unint64_t)a5;
        do
        {
          if (a5 % v18)
          {
            sub_100043608((unsigned int *)v20);
            return 34LL;
          }

          unsigned int v27 = v11;
          unsigned int v28 = a5;
          uint64_t v29 = mmap(0LL, v26, 3, 4098, -1, 0LL);
          uint64_t v30 = v29;
          *((void *)v20 + 17) = v29;
          if (v29 != (_BYTE *)-1LL) {
            break;
          }
          unsigned int v11 = 0;
          a5 = 0x10000;
          BOOL v31 = v26 > 0x400000;
          size_t v26 = 0LL;
        }

        while (v31);
        if (v29 != (_BYTE *)-1LL)
        {
          *((void *)v20 + --*(_DWORD *)(result + 16) = v29;
          if (a8)
          {
            int v32 = getpagesize();
            uint64_t v33 = v27 * v28;
            if ((_DWORD)v33)
            {
              uint64_t v34 = &v30[v33];
              do
              {
                *uint64_t v30 = 0;
                v30 += v32;
              }

              while (v30 < v34);
              uint64_t v30 = (_BYTE *)*((void *)v20 + 17);
            }
          }

          unsigned int v35 = v27 - 1;
          do
          {
            uint64_t v36 = &v30[v28];
            *(void *)uint64_t v30 = v36;
            uint64_t v30 = v36;
            --v35;
          }

          while (v35);
          *uint64_t v36 = 0LL;
          *((_DWORD *)v20 + 36) = v27;
          *((_DWORD *)v20 + 23) = v28;
          *((_DWORD *)v20 + 24) = v27;
          uint64_t v37 = (char *)malloc(0x900uLL);
          if (v37)
          {
            uint64_t v38 = v37;
            bzero(v37, 0x900uLL);
            for (uint64_t i = 0LL; i != 2256; i += 48LL)
              *(void *)&v38[i] = &v38[i + 48];
            uint64_t result = 0LL;
            *((void *)v20 + 21) = v38;
            *((void *)v20 + 19) = v38;
            *a1 = v20;
            *(void *)uint64_t v20 = v20;
            *((void *)v20 + 1) = v20;
            *((void *)v20 + 2) = v20 + 16;
            *((void *)v20 + 3) = v20 + 16;
            return result;
          }
        }
      }

      sub_100043608((unsigned int *)v20);
    }

    return 12LL;
  }

  return result;
}

uint64_t sub_100043608(unsigned int *a1)
{
  if (a1)
  {
    if (*((void *)a1 + 19))
    {
      for (uint64_t i = (uint64_t **)*((void *)a1 + 20); i; uint64_t i = (uint64_t **)*i)
      {
        int v3 = i[5];
        if (v3 && ((_DWORD)i[2] & 0x80000000) != 0) {
          free(v3);
        }
      }

      for (uint64_t j = (uint64_t **)*((void *)a1 + 21); j; uint64_t j = (uint64_t **)*j)
      {
        uint64_t v5 = j[5];
        if (v5 && ((_DWORD)j[2] & 0x80000000) != 0) {
          free(v5);
        }
      }

      free(*((void **)a1 + 19));
    }

    if (*((void *)a1 + 16))
    {
      sub_100043788((uint64_t)a1);
      munmap(*((void **)a1 + 16), a1[24] * a1[23]);
    }

    int v6 = (void *)*((void *)a1 + 10);
    if (v6)
    {
      unint64_t v7 = a1[22];
      if ((_DWORD)v7)
      {
        for (unint64_t k = 0LL; k < v7; ++k)
        {
          uint64_t v9 = *(void **)(*((void *)a1 + 10) + 8 * k);
          if (v9)
          {
            do
            {
              uint64_t v10 = (void *)v9[2];
              free(v9);
              uint64_t v9 = v10;
            }

            while (v10);
            unint64_t v7 = a1[22];
          }
        }

        int v6 = (void *)*((void *)a1 + 10);
      }

      free(v6);
    }

    *((void *)a1 + 36) = 0LL;
    *((_OWORD *)a1 + --*(_DWORD *)(result + 16) = 0u;
    *((_OWORD *)a1 + 17) = 0u;
    *((_OWORD *)a1 + 14) = 0u;
    *((_OWORD *)a1 + 15) = 0u;
    *((_OWORD *)a1 + 12) = 0u;
    *((_OWORD *)a1 + 13) = 0u;
    *((_OWORD *)a1 + 10) = 0u;
    *((_OWORD *)a1 + 11) = 0u;
    *((_OWORD *)a1 + 8) = 0u;
    *((_OWORD *)a1 + 9) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }

  return 0LL;
}

uint64_t sub_100043728(uint64_t a1)
{
  return *(unsigned int *)(a1 + 92);
}

uint64_t sub_100043730(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 92) % a2) {
    return 34LL;
  }
  uint64_t result = 0LL;
  unint64_t v4 = *(void *)(a1 + 56) * (unint64_t)*(unsigned int *)(a1 + 48) / a2;
  *(_DWORD *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = v4;
  return result;
}

void *sub_100043770(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result[7] = a2;
  result[8] = a4;
  result[9] = a3;
  return result;
}

uint64_t sub_10004377C(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t sub_100043788(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 120)) {
    return 16LL;
  }
  unint64_t v3 = *(unsigned int *)(a1 + 88);
  if ((_DWORD)v3)
  {
    for (unint64_t i = 0LL; i < v3; ++i)
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 80) + 8 * i);
      if (v5)
      {
        do
        {
          int v6 = *(_DWORD *)(v5 + 40);
          if ((v6 & 1) != 0)
          {
            if ((v6 & 4) != 0) {
              uint64_t v7 = a1 + 200;
            }
            else {
              uint64_t v7 = 0LL;
            }
            uint64_t result = sub_100044A84(a1, v5, v7);
            if ((_DWORD)result) {
              return result;
            }
            *(_DWORD *)(v5 + 40) &= ~1u;
            --*(_DWORD *)(a1 + 100);
          }

          uint64_t v5 = *(void *)(v5 + 16);
        }

        while (v5);
        unint64_t v3 = *(unsigned int *)(a1 + 88);
      }
    }
  }

  *(_DWORD *)(a1 + 104) = 0;
  (*(void (**)(void, uint64_t))(*(void *)(a1 + 40) + 80LL))(*(void *)(a1 + 32), 1LL);
  return 0LL;
}

uint64_t sub_100043840(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2 / *(unsigned int *)(a1 + 92) * *(unsigned int *)(a1 + 92) % *(unsigned int *)(a1 + 88);
  if (a3) {
    *a3 = 0LL;
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 80) + 8 * v5);
  if (!v6) {
    return 2LL;
  }
  while (*(void *)(v6 + 48) != a2)
  {
    uint64_t v6 = *(void *)(v6 + 16);
    if (!v6) {
      return 2LL;
    }
  }

  if (!*(void *)(v6 + 112))
  {
    uint64_t v7 = 0LL;
    if (!a3) {
      return v7;
    }
    goto LABEL_14;
  }

  uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 48LL))(*(void *)(a1 + 32));
  if ((_DWORD)v7)
  {
    uint64_t v9 = *(void **)(v6 + 56);
    *uint64_t v9 = *(void *)(a1 + 136);
    *(void *)(a1 + 136) = v9;
    ++*(_DWORD *)(a1 + 144);
    *(void *)(v6 + 56) = 0LL;
  }

  free(*(void **)(v6 + 112));
  *(void *)(v6 + 112) = 0LL;
  if (a3)
  {
LABEL_14:
    if (!(_DWORD)v7) {
      *a3 = v6;
    }
  }

  return v7;
}

uint64_t sub_100043910(void *a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 44);
  if (!v2) {
    return 37LL;
  }
  *(_DWORD *)(a2 + 44) = v2 - 1;
  sub_100043944(a1, (uint64_t *)a2, 0);
  return 0LL;
}

void *sub_100043944(void *result, uint64_t *a2, int a3)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    uint64_t v4 = a2[1];
    if (v4)
    {
      *(void *)(v3 + 8) = v4;
      *(void *)a2[1] = v3;
    }
  }

  if (*((_DWORD *)a2 + 11))
  {
    unint64_t v5 = (void *)result[2];
    *a2 = (uint64_t)v5;
    uint64_t v6 = result + 2;
    uint64_t result = v5;
  }

  else if (a3)
  {
    *a2 = (uint64_t)result;
    uint64_t v6 = (void *)result[1];
  }

  else
  {
    uint64_t v6 = result;
    uint64_t result = (void *)*result;
    *a2 = (uint64_t)result;
  }

  a2[1] = (uint64_t)v6;
  result[1] = a2;
  *(void *)a2[1] = a2;
  return result;
}

uint64_t sub_1000439AC( uint64_t a1, unint64_t a2, unsigned int a3, void *a4, uint64_t a5, int a6, _BYTE *a7, uint64_t a8, uint64_t a9)
{
  unint64_t v15 = *(unsigned int *)(a1 + 92);
  if ((a6 & 4) != 0 && (_DWORD)v15 != *(_DWORD *)(a1 + 48)) {
    return 45LL;
  }
  unint64_t v73 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v16 = a2 / v15 * v15;
  uint64_t v17 = (void *)(a1 + 160);
  while (1)
  {
    uint64_t v17 = (void *)*v17;
    if (!v17) {
      break;
    }
    unint64_t v18 = v17[3];
    BOOL v19 = v18 < a2 || v18 >= a2 + a3;
    if (!v19) {
      return 11LL;
    }
  }

  uint64_t v68 = (void *)(a1 + 160);
  unint64_t v69 = a2 % v15;
  uint64_t v21 = sub_100043ED8(a1, v16, &v73, a5, a6, a7, a8 != 0, a9);
  uint64_t v20 = v21;
  if (a8 && !*a7)
  {
    unsigned int v27 = (void *)v73;
    uint64_t v28 = *(void *)(a1 + 32);
    if (!v73)
    {
      unint64_t v29 = *(unsigned int *)(a1 + 88);
      uint64_t v30 = calloc(0x78uLL, 1uLL);
      if (!v30) {
        return 12LL;
      }
      unsigned int v27 = v30;
      unint64_t v31 = v16 % v29;
      v30[6] = v16;
      if (a5) {
        *((_DWORD *)v30 + 10) |= 4u;
      }
      v30[12] = a9;
      *((_DWORD *)v30 + 26) = a6 & 0xFFFEFFFF;
      void v30[3] = 0LL;
      uint64_t v32 = *(void *)(a1 + 80);
      uint64_t v33 = *(void *)(v32 + 8 * v31);
      v30[2] = v33;
      if (v33) {
        *(void *)(v33 + 24) = v30;
      }
      *(void *)(v32 + 8 * v31) = v30;
    }

    uint64_t v34 = v27[7];
    if (v34)
    {
      if (!v27[14]) {
        return 14LL;
      }
      *(void *)(a8 + 112) = v34;
      ++*((_DWORD *)v27 + 11);
      sub_100043944((void *)a1, v27, 0);
      return 0LL;
    }

    unint64_t v36 = *(unsigned int *)(a1 + 48);
    uint64_t v37 = *(void *)(a1 + 56);
    uint64_t v38 = *(void *)(a1 + 64);
    unint64_t v39 = v16 / v36;
    if (v38)
    {
      unint64_t v40 = *(void *)(a1 + 72);
      uint64_t v41 = v40 + v38;
      if (v40 <= v39) {
        uint64_t v37 = v41;
      }
    }

    unint64_t v42 = v37 - 1;
    BOOL v19 = v42 >= v39;
    unint64_t v43 = v42 - v39;
    if (!v19) {
      return 6LL;
    }
    unint64_t v44 = *(_DWORD *)(a1 + 92) / v36;
    if (v43 < v44) {
      unint64_t v45 = v43 + 1;
    }
    else {
      unint64_t v45 = v44;
    }
    uint64_t v46 = sub_100044D00(*(void *)(v28 + 16));
    v27[7] = v46;
    if (v46)
    {
      uint64_t v47 = v46;
      uint64_t v48 = malloc(0x68uLL);
      v27[14] = v48;
      if (v48)
      {
        __int128 v49 = *(_OWORD *)(a8 + 80);
        v48[4] = *(_OWORD *)(a8 + 64);
        v48[5] = v49;
        *((void *)v48 + 12) = *(void *)(a8 + 96);
        __int128 v50 = *(_OWORD *)(a8 + 16);
        *uint64_t v48 = *(_OWORD *)a8;
        v48[1] = v50;
        __int128 v51 = *(_OWORD *)(a8 + 48);
        _OWORD v48[2] = *(_OWORD *)(a8 + 32);
        v48[3] = v51;
        uint64_t v20 = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, void *, uint64_t, uint64_t, _OWORD *, void, _DWORD, void))(*(void *)(a1 + 40) + 40LL))( v28,  v39,  v45,  v47,  a5,  1LL,  v48,  v27[12],  *((_DWORD *)v27 + 26),  0LL);
        if ((_DWORD)v20)
        {
          uint64_t v52 = *(void *)(v28 + 16);
          uint64_t v53 = (void *)v27[7];
          *uint64_t v53 = *(void *)(v52 + 136);
          *(void *)(v52 + 136) = v53;
          ++*(_DWORD *)(v52 + 144);
          v27[7] = 0LL;
          free((void *)v27[14]);
          v27[14] = 0LL;
        }

        else
        {
          *(void *)(a8 + 112) = v27[7];
          ++*((_DWORD *)v27 + 11);
          sub_100043944((void *)a1, v27, 0);
        }

        return v20;
      }

      uint64_t v65 = *(void *)(v28 + 16);
      *uint64_t v47 = *(void *)(v65 + 136);
      *(void *)(v65 + 136) = v47;
      ++*(_DWORD *)(v65 + 144);
      v27[7] = 0LL;
    }

    return 12LL;
  }

  if ((_DWORD)v21) {
    return v20;
  }
  uint64_t v22 = *(void *)(a1 + 168);
  if (!v22) {
    return 55LL;
  }
  *(void *)(a1 + 168) = *(void *)v22;
  *a4 = v22;
  *(void *)uint64_t v22 = 0LL;
  *(void *)(v22 + 8) = 0LL;
  *(_DWORD *)(v22 + --*(_DWORD *)(result + 16) = 0;
  *(void *)(v22 + 24) = a2;
  *(_DWORD *)(v22 + 32) = a3;
  *(void *)(v22 + 40) = 0LL;
  unint64_t v23 = *(unsigned int *)(a1 + 92);
  if (v16 / v23 == (a2 + a3 - 1) / v23)
  {
    unint64_t v24 = v73;
    *(void *)(v22 + 40) = *(void *)(v73 + 56) + v69;
    ++*(_DWORD *)(v24 + 44);
    sub_100043944((void *)a1, (uint64_t *)v24, 0);
LABEL_16:
    uint64_t v25 = v68;
    uint64_t v26 = *v68;
    if (*v68)
    {
      *(void *)uint64_t v22 = v26;
      *(void *)(v22 + 8) = 0LL;
      uint64_t v25 = (void *)(v26 + 8);
    }

    uint64_t v20 = 0LL;
    *uint64_t v25 = v22;
    ++*(_DWORD *)(a1 + 176);
    return v20;
  }

  *(_DWORD *)(v22 + --*(_DWORD *)(result + 16) = 0x80000000;
  char v72 = -86;
  if (a8)
  {
    *(void *)uint64_t v22 = *(void *)(a1 + 168);
    *(void *)(a1 + 168) = v22;
    return 45LL;
  }

  uint64_t v54 = malloc(a3);
  *(void *)(v22 + 40) = v54;
  if (!v54) {
    return 12LL;
  }
  size_t v55 = (v23 - v69);
  unsigned int v56 = a3 - v55;
  unint64_t v57 = v73;
  memcpy(v54, (const void *)(*(void *)(v73 + 56) + v69), v55);
  ++*(_DWORD *)(v57 + 44);
  sub_100043944((void *)a1, (uint64_t *)v57, 0);
  uint64_t v58 = a5;
  if (a3 == (_DWORD)v55)
  {
LABEL_57:
    ++*(_DWORD *)(a1 + 192);
    goto LABEL_16;
  }

  unint64_t v59 = v16 + *(unsigned int *)(a1 + 92);
  while (1)
  {
    uint64_t v60 = sub_100043ED8(a1, v59, &v73, v58, a6, &v72, 0, 0LL);
    if ((_DWORD)v60) {
      break;
    }
    unsigned int v61 = *(_DWORD *)(a1 + 92);
    if (v56 >= v61) {
      size_t v62 = v61;
    }
    else {
      size_t v62 = v56;
    }
    memcpy((void *)(*(void *)(v22 + 40) + v55), *(const void **)(v73 + 56), v62);
    uint64_t v63 = (uint64_t *)v73;
    ++*(_DWORD *)(v73 + 44);
    uint64_t v64 = *(unsigned int *)(a1 + 92);
    sub_100043944((void *)a1, v63, 0);
    if (!v72) {
      *a7 = 0;
    }
    LODWORD(v55) = v62 + v55;
    v59 += v64;
    v56 -= v62;
    uint64_t v58 = a5;
    if (!v56) {
      goto LABEL_57;
    }
  }

  uint64_t v20 = v60;
  free(*(void **)(v22 + 40));
  *(void *)(v22 + 40) = 0LL;
  if (!(_DWORD)v55)
  {
    unint64_t v66 = v59 - *(unsigned int *)(a1 + 92);
    while (1)
    {
      uint64_t v20 = sub_100043ED8(a1, v66, &v73, a5, a6, a7, 0, 0LL);
      if ((_DWORD)v20) {
        break;
      }
      uint64_t v67 = (uint64_t *)v73;
      --*(_DWORD *)(v73 + 44);
      sub_100043944((void *)a1, v67, 0);
    }
  }

  return v20;
}

uint64_t sub_100043ED8( uint64_t a1, unint64_t a2, void *a3, uint64_t a4, int a5, _BYTE *a6, int a7, uint64_t a8)
{
  uint64_t result = 22LL;
  if (!a3 || !a6) {
    return result;
  }
  char v11 = a7;
  unint64_t v16 = a2 % *(unsigned int *)(a1 + 88);
  *a6 = 0;
  *a3 = 0LL;
  uint64_t v17 = *(void *)(a1 + 80);
  unint64_t v18 = *(void **)(v17 + 8 * v16);
  if (v18)
  {
    BOOL v19 = *(void **)(v17 + 8 * v16);
    while (v19[6] != a2)
    {
      BOOL v19 = (void *)v19[2];
      if (!v19) {
        goto LABEL_7;
      }
    }

    if (v18 != v19)
    {
      uint64_t v21 = v19[2];
      if (v21) {
        *(void *)(v21 + 24) = v19[3];
      }
      *(void *)(v19[3] + 16LL) = v21;
    }

    if (v19[7] && !v19[14]) {
      *a6 = 1;
    }
  }

  else
  {
LABEL_7:
    if (a7)
    {
      ++*(_DWORD *)(a1 + 176);
      return 2LL;
    }

    uint64_t v20 = calloc(0x78uLL, 1uLL);
    if (!v20) {
      return 12LL;
    }
    BOOL v19 = v20;
    v20[6] = a2;
    if (a4) {
      *((_DWORD *)v20 + 10) |= 4u;
    }
    v20[12] = a8;
    *((_DWORD *)v20 + 26) = a5 & 0xFFFEFFFF;
    uint64_t v17 = *(void *)(a1 + 80);
  }

  if (*(void **)(v17 + 8 * v16) != v19)
  {
    v19[3] = 0LL;
    uint64_t v22 = *(void *)(v17 + 8 * v16);
    void v19[2] = v22;
    if (v22) {
      *(void *)(v22 + 24) = v19;
    }
    *(void *)(v17 + 8 * v--*(_DWORD *)(result + 16) = v19;
  }

  if ((v11 & 1) != 0) {
    goto LABEL_28;
  }
  if (v19[7])
  {
    if (v19[14]) {
      sub_100043840(a1, a2, 0LL);
    }
    goto LABEL_28;
  }

  unint64_t v23 = sub_100044D00(a1);
  v19[7] = v23;
  if (!v23) {
    return 12LL;
  }
  unint64_t v24 = *(unsigned int *)(a1 + 48);
  unint64_t v25 = a2 / v24;
  uint64_t v26 = *(void *)(a1 + 56);
  uint64_t v27 = *(void *)(a1 + 64);
  if (v27)
  {
    unint64_t v28 = *(void *)(a1 + 72);
    uint64_t v29 = v28 + v27;
    if (v28 <= v25) {
      uint64_t v26 = v29;
    }
  }

  if (v26 - 1 < v25) {
    return 6LL;
  }
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 40LL))(*(void *)(a1 + 32));
  if (!(_DWORD)result)
  {
    ++*(_DWORD *)(a1 + 184);
LABEL_28:
    uint64_t result = 0LL;
    *a3 = v19;
  }

  return result;
}

uint64_t sub_100044108( _DWORD *a1, uint64_t a2, unint64_t a3, int a4, int a5, int a6, uint64_t a7, int a8, uint64_t a9)
{
  unint64_t v16 = a1[23];
  if ((a8 & 4) != 0 && (_DWORD)v16 != a1[12]) {
    return 45LL;
  }
  uint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v29 = a2;
  uint64_t v30 = a3;
  int v31 = a4;
  int v32 = a6;
  char v28 = -86;
  int v17 = a1[30];
  if (v17)
  {
    int v32 = v17 | a6;
  }

  else if ((a6 & 1) == 0)
  {
    if (a1[26])
    {
      uint64_t result = sub_100043788((uint64_t)a1);
      if ((_DWORD)result) {
        return result;
      }
    }
  }

  unint64_t v18 = a3 / v16 * v16;
  uint64_t result = sub_100043ED8((uint64_t)a1, v18, &v33, a7, a8, &v28, 0, a9);
  if ((_DWORD)result) {
    return result;
  }
  int v20 = a3 - v18;
  unsigned int v21 = a1[23];
  if ((int)a3 - (int)v18 + a4 <= v21)
  {
    uint64_t result = sub_1000442D8((uint64_t)a1, (uint64_t)&v29, v33, a5, a7);
    if ((_DWORD)result) {
      return result;
    }
    goto LABEL_22;
  }

  unsigned int v22 = v21 - v20;
  int v31 = v21 - v20;
  uint64_t result = sub_1000442D8((uint64_t)a1, (uint64_t)&v29, v33, a5, a7);
  if ((_DWORD)result) {
    return result;
  }
  unsigned int v23 = a4 - v22;
  if (a4 == v22)
  {
LABEL_22:
    uint64_t result = 0LL;
    ++a1[45];
    return result;
  }

  uint64_t v24 = a1[23];
  unint64_t v25 = v18 + v24;
  while (1)
  {
    int v26 = v23 >= v24 ? v24 : v23;
    sub_100043ED8((uint64_t)a1, v25, &v33, a7, a8, &v28, 0, 0LL);
    uint64_t v27 = *(void *)(v33 + 48);
    int v31 = v26;
    uint64_t v29 = a2 + v22;
    uint64_t v30 = v27;
    uint64_t result = sub_1000442D8((uint64_t)a1, (uint64_t)&v29, v33, a5, a7);
    if ((_DWORD)result) {
      return result;
    }
    v22 += v26;
    uint64_t v24 = a1[23];
    v25 += v24;
    v23 -= v26;
    if (!v23) {
      goto LABEL_22;
    }
  }

uint64_t sub_1000442D8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  unint64_t v10 = *(void *)(a2 + 8) % (unint64_t)*(unsigned int *)(a1 + 92);
  if (*(_DWORD *)(a1 + 120))
  {
    size_t v11 = *(unsigned int *)(a2 + 16);
    int v12 = *(void **)(a3 + 64);
    if (v12)
    {
      uint64_t v13 = *(unsigned int *)(a3 + 80);
      if ((_DWORD)v13)
      {
        size_t v14 = *(void *)(a3 + 72);
        if ((_DWORD)v13 != (_DWORD)v11 || v14 != v10)
        {
          size_t v15 = v14 + v13;
          memcpy(v12, *(const void **)(a3 + 56), v14);
          memcpy( (void *)(*(void *)(a3 + 64) + v15),  (const void *)(*(void *)(a3 + 56) + v15),  *(unsigned int *)(a1 + 92) - v15);
          *(void *)(a3 + 72) = 0LL;
          *(_DWORD *)(a3 + 80) = 0;
        }
      }
    }

    else
    {
      unint64_t v16 = sub_100044D00(a1);
      *(void *)(a3 + 64) = v16;
      if (!v16) {
        return 12LL;
      }
      memcpy((char *)v16 + v10, (const void *)(*(void *)(a3 + 56) + v10), v11);
      *(void *)(a3 + 72) = v10;
      int v17 = *(_DWORD *)(a3 + 40);
      *(_DWORD *)(a3 + 80) = v11;
      *(_DWORD *)(a3 + 84) = v17;
      *(void *)(a3 + 32) = *(void *)(a1 + 112);
      *(void *)(a1 + 112) = a3;
      ++*(_DWORD *)(a1 + 108);
    }
  }

  memcpy((void *)(*(void *)(a3 + 56) + v10), *(const void **)a2, *(unsigned int *)(a2 + 16));
  unint64_t v18 = *(void *)(a2 + 8);
  unint64_t v19 = *(unsigned int *)(a1 + 92);
  unsigned int v20 = *(_DWORD *)(a1 + 48);
  signed int v21 = (v18 % v19) / v20;
  LODWORD(v19) = (v18 + *(unsigned int *)(a2 + 16) - 1) % v19;
  uint64_t v22 = a3 + 88;
  int v23 = v21 >> 3;
  signed int v24 = v19 / v20;
  int v25 = 255 << (v21 & 7);
  if (v21 >> 3 == v24 >> 3)
  {
    unsigned int v26 = (0xFFu >> (~(_BYTE)v24 & 7)) & v25;
  }

  else
  {
    *(_BYTE *)(v22 + v23) |= v25;
    if (v23 + 1 < v24 >> 3) {
      memset((void *)(v23 + a3 + 89), 255, ((v24 >> 3) - v23 - 2) + 1LL);
    }
    unsigned int v26 = 0xFFu >> (~(_BYTE)v24 & 7);
    int v23 = v24 >> 3;
  }

  *(_BYTE *)(v22 + v23) |= v26;
  int v27 = *(_DWORD *)(a2 + 20) & 3;
  if (v27)
  {
    int v28 = *(_DWORD *)(a3 + 40);
    if ((v28 & 1) == 0) {
      ++*(_DWORD *)(a1 + 100);
    }
    *(_DWORD *)(a3 + 40) = v28 | v27;
    goto LABEL_18;
  }

  uint64_t result = sub_100044A84(a1, a3, a5);
  if (!(_DWORD)result)
  {
LABEL_18:
    sub_100043944((void *)a1, (uint64_t *)a3, a4);
    return 0LL;
  }

  return result;
}

uint64_t sub_100044500(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 120)) {
    return 37LL;
  }
  uint64_t result = 0LL;
  *(_DWORD *)(a1 + 120) = 1;
  ++*(_DWORD *)(a1 + 104);
  return result;
}

uint64_t sub_100044530(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 120)) {
    return 37LL;
  }
  uint64_t v1 = *(void *)(a1 + 112);
  if (v1)
  {
    int v2 = *(_DWORD *)(a1 + 144);
    uint64_t v3 = *(void **)(a1 + 136);
    do
    {
      uint64_t v4 = *(void **)(v1 + 64);
      *uint64_t v4 = v3;
      *(void *)(a1 + 136) = v4;
      ++v2;
      *(void *)(v1 + 64) = 0LL;
      *(_DWORD *)(v1 + 84) = 0;
      uint64_t v1 = *(void *)(v1 + 32);
      uint64_t v3 = v4;
    }

    while (v1);
    *(_DWORD *)(a1 + 144) = v2;
  }

  *(void *)(a1 + 1--*(_DWORD *)(result + 16) = 0LL;
  *(void *)(a1 + 108) = 0LL;
  unsigned int v5 = *(_DWORD *)(a1 + 96);
  unsigned int v6 = v5 - *(_DWORD *)(a1 + 100);
  unsigned int v7 = v5 >> 2;
  BOOL v8 = v6 >= 0x101 && v6 >= v7;
  if (v8 && *(_DWORD *)(a1 + 104) < 0x400u) {
    return 0LL;
  }
  uint64_t result = sub_100043788(a1);
  if (!(_DWORD)result) {
    return 84LL;
  }
  return result;
}

uint64_t sub_1000445C8(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 120)) {
    return 22LL;
  }
  uint64_t v2 = *(void *)(a1 + 112);
  if (v2)
  {
    int v3 = -1;
    while (1)
    {
      uint64_t v4 = *(void *)(v2 + 64);
      if (!v4) {
        return 14LL;
      }
      size_t v5 = *(unsigned int *)(v2 + 80);
      unsigned int v6 = *(void **)(v2 + 56);
      if ((_DWORD)v5)
      {
        memcpy((char *)v6 + *(void *)(v2 + 72), (const void *)(v4 + *(void *)(v2 + 72)), v5);
        unsigned int v6 = *(void **)(v2 + 64);
      }

      else
      {
        *(void *)(v2 + 56) = v4;
      }

      *unsigned int v6 = *(void *)(a1 + 136);
      *(void *)(a1 + 136) = v6;
      ++*(_DWORD *)(a1 + 144);
      *(void *)(v2 + 64) = 0LL;
      int v7 = *(_DWORD *)(v2 + 84);
      *(_DWORD *)(v2 + 40) = v7;
      *(_DWORD *)(v2 + 84) = 0;
      if ((v7 & 1) == 0) {
        --*(_DWORD *)(a1 + 100);
      }
      uint64_t v2 = *(void *)(v2 + 32);
      if (!v2) {
        goto LABEL_12;
      }
    }
  }

  else
  {
LABEL_12:
    uint64_t result = 0LL;
    *(void *)(a1 + 1--*(_DWORD *)(result + 16) = 0LL;
    *(void *)(a1 + 108) = 0LL;
    --*(_DWORD *)(a1 + 104);
  }

  return result;
}

double sub_1000446A8(uint64_t a1, uint64_t *a2, int a3)
{
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v6 = a2[3];
  unint64_t v7 = v6 / *(unsigned int *)(a1 + 92) * *(unsigned int *)(a1 + 92);
  char v19 = -86;
  if (!sub_100043ED8(a1, v7, &v20, 0LL, 0, &v19, 0, 0LL))
  {
    if ((a2[2] & 0x80000000) != 0)
    {
      unsigned int v10 = *((_DWORD *)a2 + 8) + v6 - v7 - *(_DWORD *)(a1 + 92);
      size_t v11 = (uint64_t *)v20;
      if ((*(_BYTE *)(v20 + 40) & 2) == 0) {
        --*(_DWORD *)(v20 + 44);
      }
      sub_100043944((void *)a1, v11, a3);
      if (v10)
      {
        unint64_t v12 = v7 + *(unsigned int *)(a1 + 92);
        do
        {
          sub_100043ED8(a1, v12, &v20, 0LL, 0, &v19, 0, 0LL);
          unsigned int v13 = *(_DWORD *)(a1 + 92);
          if (v10 >= v13) {
            unsigned int v14 = v10 - v13;
          }
          else {
            unsigned int v14 = 0;
          }
          size_t v15 = (uint64_t *)v20;
          if ((*(_BYTE *)(v20 + 40) & 2) == 0) {
            --*(_DWORD *)(v20 + 44);
          }
          sub_100043944((void *)a1, v15, a3);
          v12 += *(unsigned int *)(a1 + 92);
          BOOL v16 = v10 > v13;
          unsigned int v10 = v14;
        }

        while (v16);
      }

      free((void *)a2[5]);
    }

    else
    {
      uint64_t v9 = (uint64_t *)v20;
      if ((*(_BYTE *)(v20 + 40) & 2) == 0) {
        --*(_DWORD *)(v20 + 44);
      }
      sub_100043944((void *)a1, v9, a3);
    }

    uint64_t v17 = *a2;
    if (*a2) {
      *(void *)(v17 + 8) = a2[1];
    }
    unint64_t v18 = (void *)a2[1];
    if (v18) {
      *unint64_t v18 = v17;
    }
    double result = 0.0;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
    *a2 = *(void *)(a1 + 168);
    *(void *)(a1 + 168) = a2;
  }

  return result;
}

uint64_t sub_100044860(uint64_t a1, _DWORD *a2)
{
  if (a2[11]) {
    return 16LL;
  }
  uint64_t v4 = *((void *)a2 + 2);
  if (v4) {
    *(void *)(v4 + 24) = *((void *)a2 + 3);
  }
  uint64_t v5 = *((void *)a2 + 3);
  if (v5) {
    unint64_t v6 = (void *)(v5 + 16);
  }
  else {
    unint64_t v6 = (void *)(*(void *)(a1 + 80) + 8 * (*((void *)a2 + 6) % (unint64_t)*(unsigned int *)(a1 + 88)));
  }
  *unint64_t v6 = v4;
  if (!*((void *)a2 + 7) || (uint64_t result = sub_100044900(a1, (uint64_t)a2), !(_DWORD)result))
  {
    *((void *)a2 + 14) = 0LL;
    *((_OWORD *)a2 + 5) = 0u;
    *((_OWORD *)a2 + 6) = 0u;
    *((_OWORD *)a2 + 3) = 0u;
    *((_OWORD *)a2 + 4) = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
    free(a2);
    return 0LL;
  }

  return result;
}

uint64_t sub_100044900(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 40);
  if ((v4 & 4) != 0) {
    uint64_t v5 = a1 + 200;
  }
  else {
    uint64_t v5 = 0LL;
  }
  if ((v4 & 1) != 0 || *(void *)(a2 + 64))
  {
    if (*(_DWORD *)(a1 + 120)) {
      return 16LL;
    }
    if (*(_DWORD *)(a1 + 104))
    {
      uint64_t result = sub_100043788(a1);
      if ((_DWORD)result) {
        return result;
      }
      unsigned int v4 = *(_DWORD *)(a2 + 40);
    }

    else
    {
      uint64_t result = sub_100044A84(a1, a2, v5);
      if ((_DWORD)result) {
        return result;
      }
      unsigned int v4 = *(_DWORD *)(a2 + 40) & 0xFFFFFFFE;
      *(_DWORD *)(a2 + 40) = v4;
      --*(_DWORD *)(a1 + 100);
    }
  }

  uint64_t result = 0LL;
  if ((v4 & 2) == 0)
  {
    unint64_t v7 = *(void **)(a2 + 56);
    *unint64_t v7 = *(void *)(a1 + 136);
    *(void *)(a1 + 136) = v7;
    ++*(_DWORD *)(a1 + 144);
  }

  return result;
}

uint64_t sub_1000449B4(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v11 = a2;
  unint64_t v4 = *(unsigned int *)(a1 + 92);
  if (a2) {
    uint64_t v5 = *(unsigned int *)(a1 + 92);
  }
  else {
    uint64_t v5 = a3 % v4 + a4;
  }
  if (!v5) {
    return 0LL;
  }
  char v10 = -86;
  unint64_t v7 = a3 - a3 % v4;
  while (!a2)
  {
    sub_100043ED8(a1, v7, &v11, 0LL, 0, &v10, 1, 0LL);
    a2 = v11;
    if (v11) {
      break;
    }
LABEL_13:
    a2 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v9 = *(unsigned int *)(a1 + 92);
    v7 += v9;
    v5 -= v9;
    if (!v5) {
      return 0LL;
    }
  }

  if (!*(_DWORD *)(a2 + 44))
  {
    if (*(void *)(a2 + 56))
    {
      uint64_t result = sub_100044900(a1, a2);
      if ((_DWORD)result) {
        return result;
      }
      a2 = v11;
    }

    *(void *)(a2 + 56) = 0LL;
    goto LABEL_13;
  }

  return 16LL;
}

uint64_t sub_100044A84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 48);
  unint64_t v4 = *(unsigned int *)(a1 + 48);
  if (v3 % v4) {
    return 22LL;
  }
  unsigned int v6 = *(_DWORD *)(a1 + 92);
  int v7 = v6 / v4;
  if (v7 < 1) {
    return 0LL;
  }
  uint64_t v11 = *(void *)(a2 + 56);
  unint64_t v12 = (unsigned __int8 *)(a2 + 88);
  do
  {
    uint64_t v13 = 0LL;
    unsigned int v14 = v12;
    while (1)
    {
      unsigned int v16 = *v14++;
      unsigned int v15 = v16;
      if (v16) {
        break;
      }
      v13 += 8LL;
      if (((v7 - 1) & 0xFFFFFFF8) + 8LL == v13) {
        return 0LL;
      }
    }

    if ((v15 & 1) == 0)
    {
      do
      {
        char v17 = v15;
        LODWORD(v13) = v13 + 1;
        v15 >>= 1;
      }

      while ((v17 & 2) == 0);
    }

    uint64_t result = 0LL;
    LODWORD(v18) = 0;
    do
      uint64_t v18 = (v18 + 1);
    while (((v12[((int)v18 + (int)v13) >> 3] >> ((v18 + v13) & 7)) & 1) != 0);
    int v19 = (int)v13 >> 3;
    int v20 = v13 + v18 - 1;
    int v21 = v20 >> 3;
    unsigned int v22 = 0xFFu >> (8 - (v13 & 7));
    if (v20 >> 3 == (int)v13 >> 3)
    {
      int v23 = (510 << (v20 & 7)) | v22;
    }

    else
    {
      v12[v19] &= v22;
      if (v19 + 1 < v21) {
        bzero(&v12[v19 + 1], (v21 - v19 - 2) + 1LL);
      }
      int v23 = 510 << (v20 & 7);
      int v19 = v20 >> 3;
    }

    v12[v19] &= v23;
    uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t, uint64_t, uint64_t, void, void, void))(*(void *)(a1 + 40) + 72LL))( *(void *)(a1 + 32),  (v3 + (*(_DWORD *)(a1 + 48) * v13)) / *(unsigned int *)(a1 + 48),  v18,  v11 + (*(_DWORD *)(a1 + 48) * v13),  a3,  *(void *)(a2 + 96),  *(unsigned int *)(a2 + 104),  0LL);
    if ((_DWORD)result) {
      break;
    }
    ++*(_DWORD *)(a1 + 188);
    int v7 = *(_DWORD *)(a1 + 92) / *(_DWORD *)(a1 + 48);
  }

  while (v7 > 0);
  return result;
}

uint64_t sub_100044C70(uint64_t result)
{
  unint64_t v1 = *(unsigned int *)(result + 88);
  if ((_DWORD)v1)
  {
    uint64_t v2 = result;
    for (unint64_t i = 0LL; i < v1; ++i)
    {
      uint64_t v4 = *(void *)(*(void *)(v2 + 80) + 8 * i);
      if (v4)
      {
        do
        {
          if (*(void *)(v4 + 112))
          {
            uint64_t result = sub_100043840(v2, *(void *)(v4 + 48), 0LL);
            if (!(_DWORD)result)
            {
              int v5 = *(_DWORD *)(v4 + 44);
              if (v5)
              {
                *(_DWORD *)(v4 + 44) = v5 - 1;
                uint64_t result = (uint64_t)sub_100043944((void *)v2, (uint64_t *)v4, 0);
              }
            }
          }

          uint64_t v4 = *(void *)(v4 + 16);
        }

        while (v4);
        unint64_t v1 = *(unsigned int *)(v2 + 88);
      }
    }
  }

  return result;
}

void *sub_100044D00(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 136);
  if (result && *(_DWORD *)(a1 + 144)) {
    goto LABEL_3;
  }
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  while (1)
  {
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = v4[1];
    *(void *)v4[1] = v5;
    if ((v4[5] & 1) == 0 && !*((_DWORD *)v4 + 11)) {
      break;
    }
    uint64_t v6 = *(void *)(a1 + 16);
    *uint64_t v4 = v6;
    v4[1] = a1 + 16;
    *(void *)(v6 + 8) = v4;
    *(void *)v4[1] = v4;
    uint64_t v4 = *(uint64_t **)(a1 + 8);
  }

  sub_100044860(a1, v4);
  uint64_t result = *(void **)(a1 + 136);
  if (result)
  {
LABEL_3:
    int v3 = *(_DWORD *)(a1 + 144);
    if (v3)
    {
      *(void *)(a1 + 136) = *result;
      *(_DWORD *)(a1 + 144) = v3 - 1;
      return result;
    }

    return 0LL;
  }

  return result;
}

time_t sub_100044DB0()
{
  time_t result = time(0LL);
  qword_10008D538 = result;
  qword_10008D540 = (uint64_t)"";
  dword_10008D548 = 1;
  dword_10008D54C = -1;
  dword_10008D550 = 0;
  dword_10008D554 = 1;
  return result;
}

void sub_100044E08()
{
}

uint64_t sub_100044E14(uint64_t result)
{
  dword_10008D548 = result;
  return result;
}

uint64_t sub_100044E20(uint64_t result)
{
  qword_10008D540 = result;
  return result;
}

void sub_100044E2C()
{
}

BOOL sub_100044E40()
{
  int v0 = dword_10008D554;
  if (dword_10008D554 <= 4) {
    ++dword_10008D554;
  }
  return v0 < 5;
}

uint64_t sub_100044E64()
{
  return dword_10008D564;
}

uint64_t sub_100044E70()
{
  return dword_10008D568;
}

char *sub_100044E7C(char *result, int a2)
{
  int v2 = (int)result;
  if (a2) {
    int v3 = a2;
  }
  else {
    int v3 = -1;
  }
  if ((v3 + 11) >= 0xA)
  {
    int v8 = dword_10008D65C;
    uint64_t v9 = dword_10008D65C;
    int v10 = dword_10008D54C;
    if (dword_10008D65C < 1)
    {
      LODWORD(v11) = 0;
    }

    else
    {
      uint64_t v11 = 0LL;
      while (dword_10008D660[v11] != dword_10008D54C)
      {
        if (dword_10008D65C == ++v11)
        {
          LODWORD(v11) = dword_10008D65C;
          goto LABEL_15;
        }
      }

      ++dword_10008D674[v11];
    }

uint64_t sub_100044FEC(FILE *a1, int a2)
{
  int v3 = "";
  int v4 = "n";
  if (a2 != 1) {
    int v4 = "";
  }
  if (a2 == 2) {
    int v4 = "y";
  }
  if (qword_10008D558) {
    int v3 = (const char *)qword_10008D558;
  }
  fprintf(a1, "dev=%s vers=%s default_ans=%s result=%d ", v3, "2317.60.23.0.1", v4, dword_10008D550);
  if (dword_10008D564)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = &dword_10008D598;
    do
    {
      uint64_t v7 = dword_10008D56C[v5];
      if ((int)v7 >= 1)
      {
        fprintf(a1, "wr=%d wl=%d", -2 - v5, *((_DWORD *)&unk_10008D594 + 5 * v5));
        if ((_DWORD)v7 != 1)
        {
          uint64_t v8 = v7 - 1;
          uint64_t v9 = v6;
          do
          {
            int v10 = *v9++;
            fprintf(a1, ":%d", v10);
            --v8;
          }

          while (v8);
        }

        fputc(32, a1);
      }

      ++v5;
      v6 += 5;
    }

    while (v5 != 10);
  }

  if (dword_10008D65C >= 1)
  {
    uint64_t v11 = 0LL;
    do
    {
      fprintf(a1, "pl=%d:%d ", dword_10008D660[v11], dword_10008D674[v11]);
      ++v11;
    }

    while (v11 < dword_10008D65C);
  }

  int v12 = dword_10008D688;
  int v13 = dword_10008D54C;
  int v14 = dword_10008D560;
  time_t v15 = time(0LL);
  return fprintf( a1,  "fp=%d fl=%d repairs=%d time=%ld iter=%d\n",  v12,  v13,  v14,  (v15 - qword_10008D538 + 59) / 60,  dword_10008D554);
}

uint64_t sub_1000451FC( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a2 == 8 && (_DWORD)a4 == 16)
  {
    unint64_t v8 = *a3;
    uint64_t v9 = *(void *)(*a5 + 8LL);
    uint64_t v10 = *(void *)(*a5 + 24LL);
    if (v10)
    {
      unint64_t v11 = *(void *)(v10 + 48);
      unint64_t v12 = *(void *)(v10 + 96);
    }

    else
    {
      unint64_t v11 = *(void *)(v9 + 40);
      if ((*(_BYTE *)(v9 + 65) & 1) != 0) {
        unint64_t v12 = *(void *)(v9 + 40);
      }
      else {
        unint64_t v12 = 0LL;
      }
    }

    unint64_t v14 = *(unsigned int *)(v9 + 36);
    unint64_t v15 = a3[1];
    if (v8 && (v11 > v15 ? (BOOL v16 = v11 > v8) : (BOOL v16 = 0), v16 ? (v17 = v11 - v15 >= v8) : (v17 = 0), v17)
      || ((unint64_t v18 = 0x4000000000000000uLL >> __clz(__rbit64(v14)), v18 < v8) ? (v19 = v12 > v15) : (v19 = 0),
          v19 ? (BOOL v20 = (v12 | v18) > v8) : (BOOL v20 = 0),
          v20 && ((v12 - v15) | v18) >= v8))
    {
      uint64_t v13 = 0LL;
      a5[1] += v15;
    }

    else
    {
      sub_100040B90("invalid range: 0x%llx+%llu\n", a2, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, *a3);
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    sub_100040B90( "unexpected key (%u) / val (%u) size in extent list tree\n",  a2,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  a2);
    uint64_t v13 = 92LL;
    sub_100044E7C((char *)0x218, 92);
  }

  return v13;
}

uint64_t sub_1000452FC( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a2 == 8 && (_DWORD)a4 == 16)
  {
    unint64_t v8 = a5[1];
    unint64_t v9 = a3[1];
    unint64_t v10 = *a5 - *a3;
    if (v10 > v9 - v8) {
      int v11 = 0;
    }
    else {
      int v11 = -1;
    }
    if (v10 < v9 && v9 >= v8) {
      unsigned int v13 = v11;
    }
    else {
      unsigned int v13 = 0;
    }
    if (*a5 >= *a3) {
      return v13;
    }
    else {
      return 0LL;
    }
  }

  else
  {
    sub_100040B90( "unexpected key (%u) / val (%u) size in extent list tree\n",  a2,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  a2);
    uint64_t v14 = 92LL;
    sub_100044E7C((char *)0x219, 92);
  }

  return v14;
}

uint64_t sub_100045380( uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(uint32x2_t **)(a1 + 24);
  uint64_t v9 = v8[4].u32[0];
  uint64_t v10 = *(void *)(a1 + 8);
  if ((_DWORD)v9 != *(_DWORD *)(v10 + 36))
  {
    sub_100040B90( "spaceman block size %u doesn't match NX superblock block size %u\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  v8[4].i32[0]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 131LL;
    goto LABEL_39;
  }

  if (*(void *)&v8[12] + *(void *)&v8[6] != *(void *)(v10 + 40))
  {
    sub_100040B90( "spaceman block count %llu doesn't match NX superblock block count %llu\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  v8[12].i8[0] + v8[6].i8[0]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 132LL;
    goto LABEL_39;
  }

  if (v8[4].i32[1] != 8 * (_DWORD)v9)
  {
    sub_100040B90( "spaceman blocks per chunk %u is inconsistent with block size %u\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  v8[4].i32[1]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 133LL;
    goto LABEL_39;
  }

  if (v8[5].i32[0] != (unint64_t)(v9 - 40) >> 5)
  {
    sub_100040B90( "spaceman chunks per cib %u is inconsistent with block size %u\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  v8[5].i32[0]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 138LL;
    goto LABEL_39;
  }

  if (v8[5].i32[1] != (unint64_t)(v9 - 40) >> 3)
  {
    sub_100040B90( "spaceman cibs per cab %u is inconsistent with block size %u\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  v8[5].i32[1]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 139LL;
    goto LABEL_39;
  }

  uint64_t v13 = 0LL;
  uint64_t v14 = *(unsigned int *)(a1 + 96);
  char v15 = 1;
  BOOL v16 = "main";
  do
  {
    char v17 = v15;
    uint32x2_t v18 = v8[6 * v13 + 6];
    uint32x2_t v19 = v8[6 * v13 + 7];
    unint64_t v20 = v8[4].u32[1];
    unint64_t v21 = *(void *)&v18 / v20;
    if (*(void *)&v18 % v20) {
      ++v21;
    }
    if (*(void *)&v19 != v21)
    {
      sub_100040B90( "spaceman %s chunk count %llu is inconsistent with block count %llu and blocks per chunk %u\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)v16);
      uint64_t v37 = 92LL;
      uint64_t v38 = 134LL;
      goto LABEL_39;
    }

    uint64_t v22 = v8[6 * v13 + 8].u32[0];
    unint64_t v23 = v8[5].u32[0];
    unint64_t v24 = *(void *)&v19 / v23;
    if (*(void *)&v19 % v23) {
      ++v24;
    }
    if (v24 != v22)
    {
      sub_100040B90( "spaceman %s cib count %u is inconsistent with chunk count %llu and chunks per cib %u\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)v16);
      uint64_t v37 = 92LL;
      uint64_t v38 = 135LL;
      goto LABEL_39;
    }

    unsigned __int32 v25 = v8[5].u32[1];
    unsigned int v26 = v22 / v25;
    if (v26 == 1) {
      unsigned int v27 = 0;
    }
    else {
      unsigned int v27 = v26;
    }
    if (v8[6 * v13 + 8].i32[1] != v27)
    {
      sub_100040B90( "spaceman %s cab count %u is inconsistent with cib count %u and cibs per cab %u\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)v16);
      uint64_t v37 = 92LL;
      uint64_t v38 = 140LL;
      goto LABEL_39;
    }

    if (*(void *)&v8[6 * v13 + 9] > *(void *)&v18)
    {
      if ((v17 & 1) != 0) {
        int v28 = "main";
      }
      else {
        int v28 = "tier2";
      }
      sub_100040B90( "spaceman %s free count is too large: %llu > %llu\n",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)v28);
      sub_100044E7C((char *)0x93, -8);
    }

    char v15 = 0;
    BOOL v16 = "tier2";
    uint64_t v13 = 1LL;
  }

  while ((v17 & 1) != 0);
  uint64_t v29 = *(void *)&v8[19] & 0x7FFFFFFFFFFFFFFFLL;
  if (v29 != 3 * (vaddvq_s64((int64x2_t)vaddl_u32(v8[8], v8[14])) + *(void *)&v8[7] + *(void *)&v8[13]))
  {
    sub_100040B90("spaceman ip block count is bad: %lld\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v8[19].i8[0]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 142LL;
    goto LABEL_39;
  }

  if ((v8[4].u32[0] + 8 * ((unint64_t)(v29 + 63) >> 6) - 1) / v8[4].u32[0] != v8[20].i32[0])
  {
    sub_100040B90("spaceman ip bm block count is bad: %d\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v8[20].i32[0]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 143LL;
    goto LABEL_39;
  }

  uint64_t v154 = a1;
  uint64_t v155 = 0LL;
  if (sub_100046230(a1, &v154, a3, a4, a5, a6, a7, a8))
  {
    sub_100040B90( "spaceman IP bitmap range is invalid: 0x%llx+0x%x\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  *(void *)&v8[21]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 144LL;
    goto LABEL_39;
  }

  if (v155 != (v8[20].i32[1] & 0x7FFFFFFF))
  {
    sub_100040B90( "spaceman IP bitmap blocks field is %u, but sum of ranges is %llu\n",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v8[20].i8[4]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 576LL;
    goto LABEL_39;
  }

  uint64_t v155 = 0LL;
  if (sub_100046288( a1,  (uint64_t (*)(void *, uint64_t, void *, uint64_t, uint64_t))sub_1000451FC,  (uint64_t)&v154))
  {
    sub_100040B90( "spaceman IP range is invalid: 0x%llx+0x%llx\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  *(void *)&v8[22]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 145LL;
    goto LABEL_39;
  }

  uint32x2_t v47 = v8[19];
  if ((*(void *)&v47 & 0x7FFFFFFFFFFFFFFFLL) != v155)
  {
    sub_100040B90( "spaceman IP blocks field is %llu, but sum of ranges is %llu\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47.i8[0]);
    uint64_t v37 = 92LL;
    uint64_t v38 = 577LL;
    goto LABEL_39;
  }

  uint64_t v142 = v14;
  if ((*(void *)&v47 & 0x8000000000000000LL) == 0)
  {
    uint64_t v48 = v8[20].u32[1];
    if ((v48 & 0x80000000) == 0)
    {
      uint32x2_t v49 = v8[21];
      uint32x2_t v50 = v8[22];
      if (*(void *)&v49 < *(void *)&v50 + *(void *)&v47 && *(void *)&v50 < *(void *)&v49 + v48)
      {
        sub_100040B90( "spaceman ip bm range (%llu, %llu) overlaps with spaceman ip range (%llu, %llu)\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v49.i8[0]);
        uint64_t v37 = 92LL;
        uint64_t v38 = 146LL;
        goto LABEL_39;
      }
    }
  }

  uint32x2_t v51 = v8[23];
  if (*(void *)&v51 > *(void *)(*(void *)(a1 + 8) + 40LL))
  {
    sub_100040B90( "spaceman fs_reserve_block_count %llu is greater than nx_block_count %llu\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  *(void *)&v8[23]);
    sub_100044E7C((char *)0x2F4, 92);
    uint32x2_t v51 = v8[23];
  }

  if (*(void *)&v8[24] > *(void *)&v51)
  {
    sub_100040C68( "spaceman fs_reserve_alloc_count %llu is greater than sm_fs_reserve_block_count %llu\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  *(void *)&v8[24]);
    sub_100044E7C((char *)0x2F5, -7);
  }

  if ((v8[18].i8[0] & 1) != 0)
  {
    __int32 v53 = v8[42].i32[0];
    if (v53 == 1)
    {
      if (v8[42].i32[1] != 2520)
      {
        sub_100040B90("unexpected spaceman struct size %u != %u\n", v40, v41, v42, v43, v44, v45, v46, v8[42].i32[1]);
        uint64_t v37 = 92LL;
        uint64_t v38 = 603LL;
        goto LABEL_39;
      }
    }

    else
    {
      if (!v53)
      {
        sub_100040B90("spaceman struct is versioned but version is 0\n", v40, v41, v42, v43, v44, v45, v46, v142);
        uint64_t v37 = 92LL;
        uint64_t v38 = 602LL;
        goto LABEL_39;
      }

      sub_100040C68("unknown spaceman struct version %u > %u\n", v40, v41, v42, v43, v44, v45, v46, v8[42].i32[0]);
    }

    char v54 = 0;
    uint64_t v55 = 0LL;
    uint64_t v145 = v8 + 43;
    unsigned int v143 = v8 + 76;
    int v56 = 1;
    unint64_t v57 = "main";
    while (1)
    {
      int v144 = v56;
      uint64_t v58 = &v8[6 * v55];
      uint32x2_t v59 = v58[6];
      uint64_t v151 = v58 + 6;
      if (v59) {
        break;
      }
LABEL_111:
      int v56 = 0;
      char v54 = 1;
      unint64_t v57 = "tier2";
      uint64_t v55 = 1LL;
      if ((v144 & 1) == 0)
      {
        int v52 = 2520;
        goto LABEL_113;
      }
    }

    unint64_t v60 = 0LL;
    uint64_t v149 = &v143[136 * v55];
    uint64_t v148 = -7LL;
    uint64_t v146 = v55;
    while (1)
    {
      uint64_t v61 = (uint64_t)&v145[136 * v55 + 17 * v60];
      __int128 __base = *(_OWORD *)v61;
      __int128 v161 = *(_OWORD *)(v61 + 80);
      __int128 v162 = *(_OWORD *)(v61 + 96);
      __int128 v163 = *(_OWORD *)(v61 + 112);
      uint64_t v164 = *(void *)(v61 + 128);
      __int128 v157 = *(_OWORD *)(v61 + 16);
      __int128 v158 = *(_OWORD *)(v61 + 32);
      __int128 v159 = *(_OWORD *)(v61 + 48);
      __int128 v160 = *(_OWORD *)(v61 + 64);
      BOOL v147 = __base != 0;
      if (__base != 0)
      {
        unint64_t v62 = *((void *)&__base + 1) - __base;
        unint64_t v63 = 0x4000000000000000uLL >> __clz(__rbit64(v8[4].u32[0]));
        uint32x2_t v80 = *v151;
        if ((v54 & 1) == 0) {
          unint64_t v63 = 0LL;
        }
        BOOL v72 = *(void *)&v80 >= v62;
        unint64_t v81 = *(void *)&v80 - v62;
        if (v81 == 0
          || !v72
          || (v63 | *(void *)&v80) <= (unint64_t)__base
          || (v63 | v81) < (unint64_t)__base)
        {
LABEL_70:
          sub_100040C68( "spaceman %s datazone current boundaries (%llu -> %llu) is not a valid address range on disk\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  (char)v57);
          sub_100044E7C((char *)0x3BA, -7);
        }
      }

      uint64_t v64 = 0LL;
      char v65 = 0;
      unint64_t v150 = v60;
      int v152 = (uint64_t *)v60;
      do
      {
        unint64_t v66 = *(void *)((char *)&__base + v64 + 16);
        unint64_t v67 = *(void *)((char *)&v157 + v64 + 8);
        BOOL v68 = *(__int128 *)((char *)&__base + v64 + 16) != 0;
        if (*(__int128 *)((char *)&__base + v64 + 16) != 0)
        {
          unint64_t v69 = v67 - v66;
          if (v67 < v66) {
            goto LABEL_83;
          }
          unint64_t v70 = 0x4000000000000000uLL >> __clz(__rbit64(v8[4].u32[0]));
          uint32x2_t v71 = *v151;
          if ((v54 & 1) == 0) {
            unint64_t v70 = 0LL;
          }
          BOOL v72 = *(void *)&v71 >= v69;
          unint64_t v73 = *(void *)&v71 - v69;
          BOOL v74 = v73 != 0 && v72 && (v70 | *(void *)&v71) > v66;
          if (!v74 || (v70 | v73) < v66)
          {
LABEL_83:
            sub_100040C68( "spaceman %s datazone previous boundaries (%llu -> %llu) is not a valid address range on disk\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  (char)v57);
            sub_100044E7C((char *)0x3BB, -7);
          }
        }

        v65 |= v68;
        v64 += 16LL;
      }

      while (v64 != 112);
      int v75 = (unsigned __int16)v164;
      if ((_WORD)v164) {
        goto LABEL_88;
      }
      unint64_t v77 = v150;
      if (v147 || v65 & 1 | (WORD1(v164) != 0))
      {
        sub_100040C68( "spaceman %s datazone zone id is zero but other fields are initialized\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  (char)v57);
        sub_100044E7C((char *)0x3BD, 92);
        char v76 = 1;
        goto LABEL_89;
      }

      char v76 = 1;
LABEL_91:
      if (v77 <= 6)
      {
        unsigned int v78 = v149;
        uint64_t v79 = v148;
        do
        {
          if ((v76 & 1) == 0 && v75 == v78->u16[0])
          {
            sub_100040C68( "spaceman %s datazone duplicate zone id (%hu) for allocation zones at indices (%hu, %hu)\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  (char)v57);
            sub_100044E7C((char *)0x3BF, -2);
          }

          v78 += 17;
          BOOL v72 = __CFADD__(v79++, 1LL);
        }

        while (!v72);
      }

      unint64_t v60 = v150 + 1;
      ++v148;
      v149 += 17;
      uint64_t v55 = v146;
      if (v150 == 7) {
        goto LABEL_111;
      }
    }

    sub_100040C68("spaceman %s datazone unknown zone id (%hu)\n", v40, v41, v42, v43, v44, v45, v46, (char)v57);
    sub_100044E7C((char *)0x3BC, -2);
LABEL_88:
    char v76 = 0;
    unint64_t v77 = v150;
LABEL_89:
    if (WORD1(v164) >= 7u)
    {
      sub_100040C68( "spaceman %s datazone invalid previous boundary index (%hu)\n",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  (char)v57);
      sub_100044E7C((char *)0x3BE, -2);
    }

    goto LABEL_91;
  }

  int v52 = 336;
LABEL_113:
  LODWORD(__base) = 0;
  DWORD1(__base) = v52;
  __int32 v82 = v8[20].i32[0];
  __int32 v83 = v8[20].i32[1];
  DWORD2(__base) = v8[40].i32[1];
  HIDWORD(__base) = 8 * v82;
  LODWORD(v157) = v8[41].i32[0];
  DWORD1(v157) = 2 * v82;
  DWORD2(v157) = v8[41].i32[1];
  HIDWORD(v157) = 2 * v83;
  LODWORD(v158) = v8[10].i32[0];
  __int32 v84 = v8[8].i32[1];
  if (!v84) {
    __int32 v84 = v8[8].i32[0];
  }
  __int32 v85 = v8[16].i32[0];
  DWORD1(v158) = 8 * v84;
  DWORD2(v158) = v85;
  __int32 v86 = v8[14].i32[1];
  if (!v86) {
    __int32 v86 = v8[14].i32[0];
  }
  HIDWORD(v158) = 8 * v86;
  qsort(&__base, 6uLL, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1000462E8);
  unint64_t v95 = 0LL;
  char v96 = (_DWORD *)&__base + 2;
  do
  {
    unsigned int v97 = *(v96 - 2);
    unsigned int v98 = *(v96 - 1);
    if (v142 < v97 || v98 > v142 - v97)
    {
      sub_100040B90( "spaceman struct range %u+%u lies outside the struct itself (size %u)\n",  v88,  v89,  v90,  v91,  v92,  v93,  v94,  v97);
      uint64_t v37 = 92LL;
      uint64_t v38 = 578LL;
      goto LABEL_39;
    }

    if (v95 <= 4 && v98 > *v96 - v97)
    {
      sub_100040B90("spaceman struct ranges %u+%u and %u+%u overlap\n", v88, v89, v90, v91, v92, v93, v94, v97);
      uint64_t v37 = 92LL;
      uint64_t v38 = 579LL;
      goto LABEL_39;
    }

    v96 += 2;
    ++v95;
  }

  while (v95 != 6);
  int v100 = v8[40].u16[1];
  if (v8[40].u16[0] == 0xFFFF)
  {
    if (v100 != 0xFFFF)
    {
LABEL_131:
      sub_100040B90( "spaceman sm_ip_bm_free_head %u and sm_ip_bm_free_tail %u do not point to a valid list\n",  v88,  v89,  v90,  v91,  v92,  v93,  v94,  v8[40].i16[0]);
      uint64_t v37 = 92LL;
      uint64_t v38 = 760LL;
      goto LABEL_39;
    }
  }

  else if (v100 == 0xFFFF)
  {
    goto LABEL_131;
  }

  __int32 v101 = v8[20].i32[1];
  if ((v101 & 0x7FFF0000) == 0)
  {
    int v152 = &v142;
    unint64_t v102 = (char *)v8 + v8[41].u32[1];
    size_t v103 = 2LL * (v101 & 0x7FFFFFFF);
    __chkstk_darwin(v87);
    uint64_t v104 = (char *)&v142 - ((v103 + 15) & 0x1FFFFFFF0LL);
    if (v105) {
      memset((char *)&v142 - ((v103 + 15) & 0x1FFFFFFF0LL), 170, v103);
    }
    else {
      size_t v103 = 0LL;
    }
    bzero(v104, v103);
    unsigned int v113 = v8[40].u16[0];
    while (1)
    {
      if (v113 == 0xFFFF) {
        goto LABEL_143;
      }
      unsigned int v114 = v113;
      if ((v8[20].i32[1] & 0x7FFFFFFFu) <= v113) {
        break;
      }
      if (*(_WORD *)&v104[2 * v113] == 2)
      {
        sub_100040B90("spaceman ip bm list has a loop\n", v106, v107, v108, v109, v110, v111, v112, v142);
        uint64_t v37 = 92LL;
        uint64_t v141 = 765LL;
        goto LABEL_175;
      }

      *(_WORD *)&v104[2 * v113] = 2;
      unsigned int v113 = *(unsigned __int16 *)&v102[2 * v113];
      if (v113 == 0xFFFF)
      {
        if (v8[40].u16[1] == v114)
        {
LABEL_143:
          unint64_t v115 = v8[20].u32[0];
          if ((_DWORD)v115)
          {
            uint64_t v116 = 0LL;
            unsigned int v117 = (char *)v8 + v8[40].u32[1];
            uint64_t v118 = (char *)v8 + v8[41].u32[0];
            uint64_t v37 = 92LL;
            while (*(void *)&v117[8 * v116] <= *(void *)&v8[2])
            {
              uint64_t v119 = *(unsigned __int16 *)&v118[2 * v116];
              if ((v8[20].i32[1] & 0x7FFFFFFFu) <= v119)
              {
                sub_100040B90( "spaceman ip bitmap block address is invalid: %hu > %u\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  *(_WORD *)&v118[2 * v116]);
                uint64_t v37 = 92LL;
                uint64_t v141 = 150LL;
                goto LABEL_175;
              }

              int v120 = *(unsigned __int16 *)&v104[2 * *(unsigned __int16 *)&v118[2 * v116]];
              if (v120 == 1)
              {
                sub_100040B90( "spaceman ip bitmap %u at index %u was referenced by a previous entry in sm_ip_bitmap \n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  *(_WORD *)&v118[2 * v116]);
                uint64_t v37 = 92LL;
                uint64_t v141 = 780LL;
                goto LABEL_175;
              }

              if (v120 == 2)
              {
                sub_100040B90( "spaceman ip bitmap %u at index %u was on the free list\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  *(_WORD *)&v118[2 * v116]);
                uint64_t v37 = 92LL;
                uint64_t v141 = 770LL;
                goto LABEL_175;
              }

              if (*(__int16 *)&v102[2 * v119] != -1)
              {
                sub_100040B90( "spaceman ip bitmap %u at index %u is not invalidated on the free list\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  *(_WORD *)&v118[2 * v116]);
                sub_100044E7C((char *)0x30B, 92);
                if (!sub_1000428C4( qword_10008DB70,  "Invalidate spaceman ip bm free list at index at index %u? ",  v121,  v122,  v123,  v124,  v125,  v126,  *(_WORD *)&v118[2 * v116])) {
                  return v37;
                }
                *(_WORD *)&v102[2 * *(unsigned __int16 *)&v118[2 * v116]] = -1;
                *a2 = 1;
                unint64_t v115 = v8[20].u32[0];
                uint64_t v119 = *(unsigned __int16 *)&v118[2 * v116];
              }

              *(_WORD *)&v104[2 * v119] = 1;
              if (++v116 >= v115) {
                goto LABEL_153;
              }
            }

            sub_100040B90( "spaceman ip bitmap block xid is invalid: %llu > %llu\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  *(void *)&v117[8 * v116]);
            uint64_t v37 = 92LL;
            uint64_t v141 = 149LL;
          }

          else
          {
LABEL_153:
            uint64_t v127 = v8[20].i32[1] & 0x7FFFFFFF;
            if (!(_DWORD)v127)
            {
LABEL_157:
              uint64_t v129 = 0LL;
              uint64_t v130 = "main";
              char v131 = 1;
              while (1)
              {
                char v132 = v131;
                uint64_t v133 = &v8[6 * v129];
                uint64_t v134 = (uint64_t)v8 + v133[10].u32[0];
                uint64_t v153 = 0LL;
                unsigned int v135 = v133[8].u32[1];
                if (v135)
                {
                  uint64_t v136 = sub_100046300((uint64_t *)a1, v129, v134, v135, &v153, v110, v111, v112);
                  if ((_DWORD)v136) {
                    return v136;
                  }
                }

                else
                {
                  uint64_t v136 = sub_100046504((uint64_t *)a1, v129, v134, 0, v8[6 * v129 + 8].u32[0], &v153, v111, v112);
                  if ((_DWORD)v136) {
                    return v136;
                  }
                }

                if (v153 != *(void *)&v8[6 * v129 + 9])
                {
                  sub_100040C68( "spaceman %s free count %llu does not match sum of free counts %llu\n",  v137,  v138,  v139,  v140,  v110,  v111,  v112,  (char)v130);
                  sub_100044E7C((char *)0x24C, -7);
                }

                char v131 = 0;
                uint64_t v130 = "tier2";
                uint64_t v129 = 1LL;
                if ((v132 & 1) == 0) {
                  return 0LL;
                }
              }
            }

            uint64_t v128 = 0LL;
            while (*(_WORD *)&v104[2 * v128])
            {
              if (v127 == ++v128) {
                goto LABEL_157;
              }
            }

            sub_100040B90( "spaceman ip bitmap block at index [%u] is neither on the sm_ip_bitmap[] nor on the free list\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v128);
            uint64_t v37 = 92LL;
            uint64_t v141 = 773LL;
          }
        }

        else
        {
          sub_100040B90( "spaceman sm_ip_bm_free_tail %u does not point to the last index on the free list %u\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v8[40].i16[1]);
          uint64_t v37 = 92LL;
          uint64_t v141 = 761LL;
        }

LABEL_175:
        sub_100044E7C((char *)v141, 92);
        return v37;
      }
    }

    sub_100040B90( "spaceman sm_ip_bm_free_next index %u does not lie in ip bm range\n",  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v113);
    uint64_t v37 = 92LL;
    uint64_t v141 = 764LL;
    goto LABEL_175;
  }

  sub_100040B90("spaceman sm_ip_bm_block_count %u is too large\n", v88, v89, v90, v91, v92, v93, v94, v8[20].i32[1]);
  uint64_t v37 = 92LL;
  uint64_t v38 = 778LL;
LABEL_39:
  sub_100044E7C((char *)v38, 92);
  return v37;
}

uint64_t sub_100046230( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 24);
  unint64_t v9 = *(unsigned int *)(v8 + 164);
  if ((v9 & 0x80000000) != 0) {
    return sub_10002DD38( a1,  *(void *)(v8 + 168),  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000451FC,  (uint64_t)a2);
  }
  v11[0] = *(void *)(v8 + 168);
  v11[1] = v9;
  return sub_1000451FC(a1, 8LL, v11, 16LL, a2, a6, a7, a8);
}

uint64_t sub_100046288( uint64_t a1, uint64_t (*a2)(void *, uint64_t, void *, uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(v4 + 152);
  uint64_t v6 = *(void *)(v4 + 176);
  if (v5 < 0) {
    return sub_10002DD38(a1, v6, (uint64_t (*)(void, void, void, void, uint64_t))a2, a3);
  }
  uint64_t v9 = 0LL;
  v8[0] = v6;
  v8[1] = v5;
  return a2(&v9, 8LL, v8, 16LL, a3);
}

uint64_t sub_1000462E8(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t sub_100046300( uint64_t *a1, unsigned int a2, uint64_t a3, unsigned int a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v38 = 0LL;
  uint64_t v8 = a1[3];
  if (!a4) {
    return 0LL;
  }
  uint64_t v12 = 0LL;
  int v13 = *(_DWORD *)(v8 + 48LL * a2 + 68) - 1;
  int v14 = *(_DWORD *)(v8 + 48LL * a2 + 64);
  uint64_t v15 = a4;
  while (1)
  {
    uint64_t v16 = *(void *)(a3 + 8 * v12);
    v39[0] = v16;
    v39[1] = 1LL;
    uint64_t v17 = a1[3];
    unint64_t v18 = *(void *)(v17 + 152);
    uint64_t v19 = *(void *)(v17 + 176);
    if ((v18 & 0x8000000000000000LL) != 0)
    {
      int v21 = sub_10002DD38( (uint64_t)a1,  v19,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000452FC,  (uint64_t)v39);
      uint64_t v16 = *(void *)(a3 + 8 * v12);
      if (v21 == -1) {
        goto LABEL_10;
      }
LABEL_9:
      sub_100040C68( "spaceman cab %u address 0x%llx is not in the internal pool\n",  v19,  a3,  v16,  (uint64_t)a5,  a6,  a7,  a8,  v12);
      sub_100044E7C((char *)0x38C, -7);
      uint64_t v16 = *(void *)(a3 + 8 * v12);
      goto LABEL_10;
    }

    unint64_t v20 = v16 - v19;
    if (v16 < v19 || v20 >= v18 || v20 > v18 - 1) {
      goto LABEL_9;
    }
LABEL_10:
    uint64_t v22 = sub_100022BD0(a1, 0LL, 0x40000000, v16, 0LL, 0, 6, 0, (uint64_t **)&v38, 0LL, 1);
    if ((_DWORD)v22)
    {
      uint64_t v34 = v22;
      sub_100040B90("failed to read spaceman cab %u at address 0x%llx\n", v23, v24, v25, v26, v27, v28, v29, v12);
      return v34;
    }

    uint64_t v30 = *((unsigned int *)v38 + 8);
    if (v12 != v30)
    {
      sub_100040B90( "spaceman cab out of order: %u, expected %u\n",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  *((_DWORD *)v38 + 8));
      uint64_t v35 = 586LL;
LABEL_22:
      uint64_t v34 = 92LL;
      sub_100044E7C((char *)v35, 92);
      goto LABEL_24;
    }

    unsigned int v31 = *(_DWORD *)(v8 + 44);
    if ((_DWORD)v30 == v13) {
      uint64_t v32 = v14 - v31 * v13;
    }
    else {
      uint64_t v32 = v31;
    }
    if (*((_DWORD *)v38 + 9) != (_DWORD)v32)
    {
      sub_100040B90("spaceman cab %u wrong number of cibs: %u, expected %u\n", v23, v24, v25, v32, v27, v28, v29, v30);
      uint64_t v35 = 587LL;
      goto LABEL_22;
    }

    uint64_t v33 = sub_100046504(a1, a2, (uint64_t)v38 + 40, v31 * v30, v32, a5, v28, v29);
    if ((_DWORD)v33) {
      break;
    }
    free(v38);
    uint64_t v38 = 0LL;
    if (v15 == ++v12) {
      return 0LL;
    }
  }

  uint64_t v34 = v33;
LABEL_24:
  if (v38) {
    free(v38);
  }
  return v34;
}

uint64_t sub_100046504( uint64_t *a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[3];
  unint64_t v77 = 0LL;
  if (!(_DWORD)a5) {
    return 0LL;
  }
  int v9 = a4;
  uint64_t v10 = a3;
  uint64_t v12 = 0LL;
  uint64_t v13 = v8 + 48LL * a2;
  int v14 = *(_DWORD *)(v13 + 56);
  int v71 = *(_DWORD *)(v13 + 64) - 1;
  uint64_t v68 = a5;
  int v73 = a4;
  uint64_t v65 = v8;
  int v69 = v14;
  while (1)
  {
    uint64_t v15 = *(void *)(v10 + 8 * v12);
    unint64_t v78 = v15;
    uint64_t v79 = 1LL;
    uint64_t v16 = a1[3];
    unint64_t v17 = *(void *)(v16 + 152);
    uint64_t v18 = *(void *)(v16 + 176);
    if ((v17 & 0x8000000000000000LL) != 0)
    {
      int v20 = sub_10002DD38( (uint64_t)a1,  v18,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000452FC,  (uint64_t)&v78);
      uint64_t v15 = *(void *)(v10 + 8 * v12);
      if (v20 == -1) {
        goto LABEL_10;
      }
LABEL_9:
      sub_100040C68( "spaceman cib %u address 0x%llx is not in the internal pool\n",  v18,  a3,  v15,  a5,  (uint64_t)a6,  a7,  a8,  v12 + v9);
      sub_100044E7C((char *)0x38B, -7);
      uint64_t v15 = *(void *)(v10 + 8 * v12);
      goto LABEL_10;
    }

    unint64_t v19 = v15 - v18;
    if (v15 < v18 || v19 >= v17 || v19 > v17 - 1) {
      goto LABEL_9;
    }
LABEL_10:
    uint64_t v21 = sub_100022BD0(a1, 0LL, 0x40000000, v15, 0LL, 0, 7, 0, (uint64_t **)&v77, 0LL, 1);
    if ((_DWORD)v21)
    {
      uint64_t v62 = v21;
      sub_100040B90("failed to read spaceman cib %u at address 0x%llx\n", v22, v23, v24, v25, v26, v27, v28, v12 + v9);
      return v62;
    }

    uint64_t v29 = v77;
    if (*((_DWORD *)v77 + 8) != (_DWORD)v12 + v9) {
      break;
    }
    unsigned int v30 = *(_DWORD *)(v8 + 40);
    if ((_DWORD)v12 + v9 == v71) {
      uint64_t v31 = v14 - v30 * v71;
    }
    else {
      uint64_t v31 = v30;
    }
    if (*((_DWORD *)v77 + 9) != (_DWORD)v31)
    {
      sub_100040B90( "spaceman cib %u wrong number of chunks: %u, expected %u\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v12 + v9);
      uint64_t v62 = 92LL;
      uint64_t v63 = 585LL;
      goto LABEL_60;
    }

    unsigned int v32 = a2;
    if ((_DWORD)v31)
    {
      uint64_t v33 = a1[3];
      uint64_t v76 = *(void *)(v33 + 48LL * a2 + 48);
      uint64_t v75 = *(void *)(v33 + 48LL * a2 + 56) - 1LL;
      uint64_t v34 = (unint64_t *)((char *)v77 + 64);
      uint64_t v35 = v30 * v73;
      while (1)
      {
        if (*(v34 - 3) > *(void *)(v33 + 16))
        {
          sub_100040B90("spaceman chunk %llu xid is invalid: %llu > %llu\n", v22, v23, v24, v25, v26, v27, v28, v35);
          uint64_t v62 = 92LL;
          uint64_t v63 = 580LL;
          goto LABEL_60;
        }

        unint64_t v22 = *v34;
        if (*v34)
        {
          unint64_t v78 = *v34;
          uint64_t v79 = 1LL;
          uint64_t v36 = a1[3];
          unint64_t v37 = *(void *)(v36 + 152);
          uint64_t v38 = *(void *)(v36 + 176);
          if ((v37 & 0x8000000000000000LL) == 0)
          {
            BOOL v39 = __OFSUB__(v22, v38);
            uint64_t v40 = v22 - v38;
            if (v40 < 0 != v39 || v40 >= v37 || v40 > v37 - 1)
            {
LABEL_26:
              sub_100040C68( "spaceman chunk %llu bitmap address 0x%llx is not in the internal pool\n",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v35);
              sub_100044E7C((char *)0x389, -7);
              goto LABEL_27;
            }

uint64_t sub_100046AB8( uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 24);
  if (*(void *)(v10 + 184) != *a2)
  {
    sub_100040C68( "sm_fs_reserve_block_count is not valid (expected %llu, actual %llu)\n",  (uint64_t)a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *a2);
    sub_100044E7C((char *)0x446, -7);
    if (sub_1000428C4( qword_10008DB70,  "Fix sm_fs_reserve_block_count? ",  v11,  v12,  v13,  v14,  v15,  v16,  v24))
    {
      *(void *)(v10 + 184) = *a2;
      *a3 = 1;
    }
  }

  if (*(void *)(v10 + 192) != a2[1])
  {
    sub_100040C68( "sm_fs_reserve_alloc_count is not valid (expected %llu, actual %llu)\n",  (uint64_t)a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  a2[1]);
    sub_100044E7C((char *)0x447, -7);
    if (sub_1000428C4( qword_10008DB70,  "Fix sm_fs_reserve_alloc_count? ",  v17,  v18,  v19,  v20,  v21,  v22,  v25))
    {
      *(void *)(v10 + 192) = a2[1];
      *a3 = 1;
    }
  }

  return 0LL;
}

uint64_t sub_100046BA0(uint64_t *a1, _DWORD *a2)
{
  uint64_t v4 = 0LL;
  unsigned int v5 = 0;
  uint64_t v6 = a1[3];
  v35[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v7 = v6 + 216;
  while (1)
  {
    uint64_t v8 = v7 + v4;
    if (*(void *)(v7 + v4 - 8)) {
      break;
    }
LABEL_21:
    ++v5;
    v4 += 40LL;
    if (v4 == 120) {
      return 0LL;
    }
  }

  uint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  LOBYTE(v35[0]) = v4 == 0;
  HIDWORD(v35[0]) = v4 == 80;
  v35[2] = 0LL;
  uint64_t v36 = 0LL;
  v35[1] = 0LL;
  unint64_t v37 = -1LL;
  uint64_t v9 = sub_100029A94(a1, v5, &v34);
  if ((_DWORD)v9
    || (uint64_t v9 = sub_100031CD0( v34,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100046E00,  (uint64_t)v35,  0LL,  0),  (_DWORD)v9))
  {
    uint64_t v32 = v9;
    sub_100040B90("Spaceman free queue tree of type [%d] is invalid\n", v10, v11, v12, v13, v14, v15, v16, v5);
    return v32;
  }

  unint64_t v17 = *(void *)(v8 - 16);
  if (!LOBYTE(v35[0]) || v17 <= (*(void *)(v6 + 152) & 0x7FFFFFFFFFFFFFFFuLL))
  {
    if (v17 != v36)
    {
      uint64_t v18 = "tier2";
      if (v4 == 40) {
        uint64_t v18 = "main";
      }
      if (!v4) {
        uint64_t v18 = "IP";
      }
      sub_100040C68( "Spaceman free queue tree of type [%s] has sfq_count (%llu) mismatch with cumulative counts in the tree (%llu)\n",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (char)v18);
      sub_100044E7C((char *)0x2F7, 92);
      if (sub_1000428C4( qword_10008DB70,  "Fix spaceman free queue tree sfq_count (oid 0x%llx)? ",  v19,  v20,  v21,  v22,  v23,  v24,  *(void *)(v8 - 8)))
      {
        *(void *)(v8 - --*(_DWORD *)(result + 16) = v36;
        *a2 = 1;
      }
    }

    if (*(void *)(v7 + v4) > v37)
    {
      char v25 = "tier2";
      if (v4 == 40) {
        char v25 = "main";
      }
      if (!v4) {
        char v25 = "IP";
      }
      sub_100040C68( "Spaceman free queue tree of type [%s] has sfq_oldest_xid (%llu) greater than the oldest xid in the free tree (%llu)\n",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (char)v25);
      sub_100044E7C((char *)0x30D, 92);
      if (sub_1000428C4( qword_10008DB70,  "Fix spaceman free queue tree sfq_oldest_xid (oid 0x%llx)? ",  v26,  v27,  v28,  v29,  v30,  v31,  *(void *)(v8 - 8)))
      {
        *(void *)(v7 + v4) = v37;
        *a2 = 1;
      }
    }

    goto LABEL_21;
  }

  sub_100040B90( "Spaceman IP free queue tree has sfq_count (%llu) greater than IP block count (%llu)\n",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  *(void *)(v8 - 16));
  uint64_t v32 = 92LL;
  sub_100044E7C((char *)0x2F6, 92);
  return v32;
}

uint64_t sub_100046E00( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = *a3;
  unint64_t v9 = a3[1];
  if (a5)
  {
    unint64_t v11 = *a5;
    if (!v10) {
      goto LABEL_6;
    }
  }

  else
  {
    unint64_t v11 = 1LL;
    if (!v10)
    {
LABEL_6:
      sub_100040B90( "sfqe_key : (paddr 0x%llx, xid 0x%llx) : invalid xid\n",  a2,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  a3[1]);
      uint64_t v13 = 92LL;
      uint64_t v14 = 752LL;
LABEL_7:
      sub_100044E7C((char *)v14, 92);
      return v13;
    }
  }

  uint64_t v12 = *(void **)(a1 + 24);
  if (v10 > v12[2]) {
    goto LABEL_6;
  }
  if (!*(_BYTE *)a7)
  {
    unint64_t v20 = v12[6 * (*(_DWORD *)(a7 + 4) == 1) + 6];
    unint64_t v21 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36LL)));
    if (*(_DWORD *)(a7 + 4) != 1) {
      unint64_t v21 = 0LL;
    }
    BOOL v23 = v21 < v9 && v20 > v11 && (v21 | v20) > v9;
    if (!v23 || (v21 | (v20 - v11)) < v9)
    {
      sub_100040B90( "sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : Range in free queue tree is not a valid address range on disk\n",  a2,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  v9);
      uint64_t v13 = 92LL;
      uint64_t v14 = 754LL;
      goto LABEL_7;
    }

    unint64_t v27 = a3[1];
    unint64_t v28 = v11;
    unint64_t v24 = v12[19];
    uint64_t v17 = v12[22];
    if ((v24 & 0x8000000000000000LL) != 0)
    {
      if (sub_10002DD38( a1,  v17,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000452FC,  (uint64_t)&v27) != -1) {
        goto LABEL_38;
      }
    }

    else
    {
      unint64_t v25 = v9 - v17;
    }

    sub_100040B90( "sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : Range in free queue tree lies in the internal pool\n",  v17,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  v9);
    uint64_t v13 = 92LL;
    uint64_t v14 = 784LL;
    goto LABEL_7;
  }

  unint64_t v27 = a3[1];
  unint64_t v28 = v11;
  unint64_t v16 = v12[19];
  uint64_t v17 = v12[22];
  if ((v16 & 0x8000000000000000LL) == 0)
  {
    unint64_t v18 = v9 - v17;
    if ((uint64_t)v9 >= v17)
    {
      BOOL v19 = v16 < v11 || v18 >= v16;
      if (!v19 && v18 <= v16 - v11) {
        goto LABEL_38;
      }
    }

LABEL_29:
    sub_100040B90( "sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : Range in ip free queue tree does not lie in the internal pool\n",  v17,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  v9);
    uint64_t v13 = 92LL;
    uint64_t v14 = 753LL;
    goto LABEL_7;
  }

  if (sub_10002DD38( a1,  v17,  (uint64_t (*)(void, void, void, void, uint64_t))sub_1000452FC,  (uint64_t)&v27) != -1) {
    goto LABEL_29;
  }
LABEL_38:
  if (*(void *)(a7 + 8) == v10 && (int64_t)v9 < *(void *)(a7 + 16))
  {
    sub_100040C68( "sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : key out of order (last paddr 0x%llx, last xid 0x%llx)\n",  v17,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  a7,  a8,  v9);
    sub_100044E7C((char *)0x2F3, -7);
  }

  *(void *)(a7 + 8) = v10;
  *(void *)(a7 + --*(_DWORD *)(result + 16) = v11 + v9;
  unint64_t v26 = *(void *)(a7 + 32);
  *(void *)(a7 + 24) += v11;
  uint64_t v13 = 0LL;
  if (v26 > v10) {
    *(void *)(a7 + 32) = v10;
  }
  return v13;
}

uint64_t sub_100047038( uint64_t *a1, uint64_t a2, uint64_t a3, BOOL *a4, void *a5, void *a6, void *a7, unsigned int a8)
{
  BOOL v19 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = sub_100047134(a1, a2, a3, (uint64_t **)&v19);
  if (!(_DWORD)v13)
  {
    uint64_t v14 = v19;
    int v15 = *((_DWORD *)v19 + 9);
    *a4 = (v15 & 1) == 0;
    if (a5) {
      *a5 = v14[2];
    }
    if (a6) {
      *a6 = v14[6];
    }
    uint64_t v13 = 0LL;
    if (!a7 || (v15 & 1) != 0) {
      goto LABEL_12;
    }
    int v16 = *((_DWORD *)v14 + 10) - 1;
    if (v16 <= 4 && ((0x1Du >> v16) & 1) != 0)
    {
      unsigned int v17 = dword_10006B628[v16];
      if (v17 > a8)
      {
        uint64_t v13 = 34LL;
        goto LABEL_12;
      }
    }

    else
    {
      unsigned int v17 = 0;
    }

    memcpy(a7, (char *)v14 + *((unsigned int *)v14 + 11), v17);
    uint64_t v13 = 0LL;
LABEL_12:
    free(v14);
  }

  return v13;
}

uint64_t sub_100047134(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v4 = *(void *)(a2 + 48);
  if (!v4) {
    uint64_t v4 = *(void *)(a2 + 40);
  }
  uint64_t v12 = sub_100022BD0(a1, a2, 0, *(void *)(v4 + 1024), a3, 0, 30, 0, a4, 0LL, 0);
  if ((_DWORD)v12)
  {
    sub_100040B90( "integrity_meta: failed to copy object (0x%llx:0x%llx)\n",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  *(void *)(v4 + 1024));
    sub_100044E7C((char *)0x376, v12);
  }

  return v12;
}

uint64_t sub_1000471C0(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v31 = 0LL;
  unsigned int v4 = *(_DWORD *)(a1[1] + 36);
  uint64_t v12 = sub_100047134(a1, a2, a3, (uint64_t **)&v31);
  if ((_DWORD)v12) {
    return v12;
  }
  uint64_t v13 = v31;
  uint64_t v14 = *((void *)v31 + 1);
  unsigned int v15 = *((_DWORD *)v31 + 8);
  if (v15)
  {
    if (*((_DWORD *)v31 + 9) >= 4u)
    {
      sub_100040C68("integrity_meta: (0x%llx:0x%llx): unknown flags (0x%x)\n", v5, v6, v7, v8, v9, v10, v11, v14);
      sub_100044E7C((char *)0x378, -3);
      uint64_t v13 = v31;
    }

    unsigned int v16 = v13[10];
    if ((v16 | 2) == 2 || v16 >= 6)
    {
      sub_100040B90("integrity_meta: (0x%llx:0x%llx): unknown hash type (%u)\n", v5, v6, v7, v8, v9, v10, v11, v14);
      uint64_t v12 = 92LL;
      uint64_t v18 = 889LL;
    }

    else
    {
      unsigned int v20 = v16 - 1;
      if (v20 > 4) {
        int v21 = 0;
      }
      else {
        int v21 = dword_10006B63C[v20];
      }
      unint64_t v22 = v13[11];
      if (v15 > 2)
      {
        unint64_t v23 = 48LL;
      }

      else
      {
        unint64_t v23 = 128LL;
        if (v13[8] == 1) {
          unint64_t v23 = 48LL;
        }
      }

      if (v23 <= v22)
      {
        if (!sub_100007F14((uint64_t)v13 + v22, 0LL, (8 * v21)))
        {
          if (*((_DWORD *)v31 + 8) < 2u || ((*((_DWORD *)v31 + 9) & 1) == 0) == (*((void *)v31 + 6) == 0LL))
          {
            uint64_t v12 = 0LL;
            *(_DWORD *)(a2 + --*(_DWORD *)(result + 16) = *((_DWORD *)v31 + 10);
            *(_DWORD *)(a2 + 20) = v21;
          }

          else
          {
            sub_100040B90( "integrity_meta: (0x%llx:0x%llx): unexpected flags (0x%x) for xid (%llu)\n",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v14);
            sub_100044E7C((char *)0x3B3, 92);
            uint64_t v12 = 0LL;
          }

          goto LABEL_13;
        }

        sub_100040B90("integrity_meta: (0x%llx:0x%llx): invalid root hash\n", v24, v25, v26, v27, v28, v29, v30, v14);
        uint64_t v12 = 92LL;
        uint64_t v18 = 891LL;
      }

      else
      {
LABEL_26:
        sub_100040B90( "integrity_meta: (0x%llx:0x%llx): invalid root hash offset (%u+%u) > %u\n",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v14);
        uint64_t v12 = 92LL;
        uint64_t v18 = 890LL;
      }
    }
  }

  else
  {
    sub_100040B90( "integrity_meta: (0x%llx:0x%llx): invalid version\n",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  *((void *)v31 + 1));
    uint64_t v12 = 92LL;
    uint64_t v18 = 887LL;
  }

  sub_100044E7C((char *)v18, 92);
LABEL_13:
  if (v31) {
    free(v31);
  }
  return v12;
}

uint64_t sub_1000473D0( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_BYTE *)(a1 + 72)) {
    return 0LL;
  }
  if ((*(_WORD *)(a2 + 32) & 8) != 0)
  {
    unsigned int v13 = a4;
    uint64_t v14 = 0LL;
    switch(*(_DWORD *)(a1 + 40))
    {
      case 1:
        uint64_t v14 = ccsha256_di(0LL);
        break;
      case 3:
        uint64_t v14 = ccsha384_di(0LL);
        break;
      case 4:
        uint64_t v14 = ccsha512_di(0LL);
        break;
      case 5:
        uint64_t v14 = ccsha512_256_di(0LL);
        break;
      default:
        break;
    }

    *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __s2[2] = v15;
    __s2[3] = v15;
    __s2[0] = v15;
    __s2[1] = v15;
    ccdigest(v14, v13, a2, __s2);
    if (memcmp(a3 + 1, __s2, *(unsigned int *)(a1 + 44)))
    {
      sub_100040B90( "hash validation: invalid node hash for node %llu (root oid: %llu, seal xid: %lld, broken xid: %lld)\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  *a3);
      uint64_t v11 = 92LL;
      uint64_t v12 = 928LL;
      goto LABEL_11;
    }

    return 0LL;
  }

  sub_100040B90("hash validation: invalid node %llu (root %llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
  uint64_t v11 = 92LL;
  uint64_t v12 = 927LL;
LABEL_11:
  sub_100044E7C((char *)v12, 92);
  return v11;
}

uint64_t sub_10004751C(uint64_t a1)
{
  unsigned int v529 = -1431655766;
  unsigned int v530 = -1431655766;
  int v2 = sub_10001CA10();
  *(_OWORD *)v527 = 0u;
  __int128 v528 = 0u;
  *(_OWORD *)v526 = 0u;
  int v525 = 0;
  __int16 v524 = 0;
  int v3 = calloc(1uLL, 0x48uLL);
  qword_10008DB78 = (uint64_t)v3;
  if (!v3)
  {
    sub_100040B90("failed to allocate memory for fsck_state\n", v4, v5, v6, v7, v8, v9, v10, v493);
LABEL_14:
    uint64_t v33 = 0LL;
    uint64_t v34 = 0LL;
LABEL_15:
    uint64_t v35 = 71LL;
    goto LABEL_16;
  }

  *(_OWORD *)int v3 = *(_OWORD *)a1;
  __int128 v11 = *(_OWORD *)(a1 + 16);
  __int128 v12 = *(_OWORD *)(a1 + 32);
  __int128 v13 = *(_OWORD *)(a1 + 48);
  v3[8] = *(void *)(a1 + 64);
  *((_OWORD *)v3 + 2) = v12;
  *((_OWORD *)v3 + 3) = v13;
  *((_OWORD *)v3 + 1) = v11;
  int v14 = *(_DWORD *)(qword_10008DB78 + 20);
  BOOL v15 = v14 == -1 && !*(_BYTE *)(qword_10008DB78 + 42) && *(_BYTE *)(qword_10008DB78 + 43) == 0;
  if (!*(_BYTE *)(qword_10008DB78 + 36) && *(_BYTE *)(qword_10008DB78 + 38)) {
    sub_100041404();
  }
  uint64_t v16 = sub_1000426E0();
  if (!v16)
  {
    sub_100040B90("Could not initialize message output\n", v17, v18, v19, v20, v21, v22, v23, v493);
    uint64_t v32 = 151LL;
    goto LABEL_13;
  }

  uint64_t v24 = (uint64_t)v16;
  sub_1000428A8((uint64_t)v16, *(_DWORD *)(qword_10008DB78 + 28));
  sub_10004288C(v24, *(_DWORD *)(qword_10008DB78 + 32));
  if (sub_100042744(v24, (uint64_t)&unk_1000706F0))
  {
    sub_100040B90("Could not initialize APFS-specific messages\n", v25, v26, v27, v28, v29, v30, v31, v493);
    uint64_t v32 = 152LL;
LABEL_13:
    sub_100044E7C((char *)v32, 12);
    goto LABEL_14;
  }

  sub_100042854(v24, (uint64_t)sub_10004092C);
  sub_100042870(v24, (uint64_t)sub_100040874);
  qword_10008DB70 = v24;
  if (v14 == -1) {
    sub_10000CA50(0LL);
  }
  else {
    sub_10000CAA4(0LL);
  }
  sub_100044E20(*(void *)(qword_10008DB78 + 8));
  sub_100044E14(2LL);
  char v523 = 0;
  uint64_t v45 = sub_1000418C4((uint64_t)v2, (uint64_t)v526, &v523);
  if ((_DWORD)v45)
  {
LABEL_32:
    uint64_t v35 = v45;
    uint64_t v33 = 0LL;
    uint64_t v34 = 0LL;
    goto LABEL_16;
  }

  char v502 = v15;
  int v503 = v14;
  uint64_t v52 = (void **)(v2 + 1);
  v505 = v2 + 1;
  while (1)
  {
    if (v523)
    {
      uint64_t v34 = 0LL;
      uint64_t v90 = qword_10008DB78;
      if (*(_BYTE *)(qword_10008DB78 + 36))
      {
        uint64_t v33 = 0LL;
        goto LABEL_86;
      }

      uint64_t v35 = 0LL;
      char v91 = 0;
      int v92 = 106;
      uint64_t v33 = 0LL;
      goto LABEL_328;
    }

    uint64_t v45 = sub_100041DC0(v2, v528);
    if ((_DWORD)v45) {
      goto LABEL_32;
    }
    BOOL v522 = 0;
    uint64_t v45 = sub_100041E50((uint64_t)v2, v528, &v522);
    if ((_DWORD)v45) {
      goto LABEL_32;
    }
    if (BYTE8(v528))
    {
      uint64_t v45 = sub_100042178((uint64_t)v2, (uint64_t)v526, *(unsigned __int8 *)(qword_10008DB78 + 45));
      if ((_DWORD)v45) {
        goto LABEL_32;
      }
    }

    sub_100044E14(3LL);
    uint64_t v34 = sub_10002E4CC(*v2, 0, (_BYTE *)&v524 + 1);
    if (!v34
      || (sub_1000432C4(v24, 201, v53, v54, v55, v56, v57, v58, v493), !HIBYTE(v524))
      && sub_10002E878(*v2, (uint64_t)v34, 0LL, v59, v60, v61, v62, v63))
    {
      uint64_t v88 = v24;
      int v89 = 301;
      goto LABEL_72;
    }

    nullsub_1(v34 + 18);
    sub_100044E14(4LL);
    sub_1000432C4(v24, 222, v53, v54, v55, v56, v57, v58, *((void *)*v52 + 2));
    uint64_t v504 = *((void *)v34 + 8);
    if ((v504 & 0x100) != 0)
    {
      uint64_t v33 = sub_10002E4CC(*v2, 1, &v524);
      if (!v33
        || (sub_1000432C4(v24, 202, v64, v65, v66, v67, v68, v69, v493), !(_BYTE)v524)
        && (sub_10002E878(*v2, (uint64_t)v33, 0LL, v70, v71, v72, v73, v74)
         || sub_10002F2C0((uint64_t)v33, (uint64_t)*v52, 0LL, 1LL, v66, v67, v68, v69)))
      {
LABEL_65:
        uint64_t v85 = v24;
        int v86 = 302;
LABEL_76:
        sub_1000432C4(v85, v86, v64, v65, v66, v67, v68, v69, v493);
LABEL_77:
        char v91 = 0;
        goto LABEL_78;
      }

      int v75 = sub_100029D5C((uint64_t)v2, 0LL);
      if (v75)
      {
        char v458 = strerror(v75);
        sub_100040B90("failed to initialize the Fusion MT tree: %s\n", v459, v460, v461, v462, v463, v464, v465, v458);
        goto LABEL_77;
      }
    }

    else
    {
      uint64_t v33 = 0LL;
    }

    sub_100044E14(5LL);
    if (HIBYTE(v524))
    {
      if (sub_1000428C4( qword_10008DB70,  "Fix corrupt container superblock? ",  v64,  v65,  v66,  v67,  v68,  v69,  v493) != 1) {
        goto LABEL_75;
      }
      uint64_t v76 = (_DWORD *)v2[1];
      unsigned int v77 = v76[9];
      memcpy(v34, v76, 0x588uLL);
      __str[0].i64[0] = 0LL;
      __str[0].i64[1] = v77;
      __str[1].i64[0] = 0LL;
      sub_100044E2C();
    }

    if ((_BYTE)v524)
    {
      if (sub_1000428C4( qword_10008DB70,  "Fix corrupt 2nd-tier device container superblock? ",  v64,  v65,  v66,  v67,  v68,  v69,  v493) != 1) {
        goto LABEL_65;
      }
      uint32x2_t v80 = (unsigned int *)v2[1];
      unint64_t v81 = v80[9];
      memcpy(v33, v80, 0x588uLL);
      *((_BYTE *)v33 + 1295) |= 1u;
      __str[0].i64[0] = 0x4000000000000000uLL >> __clz(__rbit64(v81));
      __str[0].i64[1] = v81;
      __str[1].i64[0] = 0LL;
      sub_100044E2C();
      uint64_t v52 = (void **)(v2 + 1);
    }

    if (*(_BYTE *)(qword_10008DB78 + 36))
    {
      if ((*((_BYTE *)*v52 + 1264) & 1) == 0)
      {
        uint64_t v35 = sub_100049074(v24, v2);
        char v91 = 0;
        goto LABEL_79;
      }

LABEL_75:
      uint64_t v85 = v24;
      int v86 = 301;
      goto LABEL_76;
    }

    if (!(HIBYTE(v524) | v524) || !(BOOL v84 = sub_100041554(*(const char **)(qword_10008DB78 + 8))))
    {
      sub_10003BEF4((uint64_t)v2);
      unint64_t v87 = *(void *)(v2[1] + 1384LL);
      if (v87 > 0x83B5A93981BC1LL)
      {
        memset(__str, 170, 25);
        unint64_t v95 = sub_10001C8A0(v87, __str[0].i8, 25);
        LOBYTE(v103) = (_BYTE)v95;
        if (!v95)
        {
          size_t v103 = __str;
          snprintf(__str[0].i8, 0x19uLL, "%llu", *((void *)*v52 + 173));
        }

        sub_100040C68( "container has been mounted by APFS version %s, which is newer than %s\n",  v96,  v97,  v98,  v99,  v100,  v101,  v102,  (char)v103);
        if (*(_BYTE *)(qword_10008DB78 + 41)) {
          uint64_t v111 = "enabling overallocation repairs because -o was passed; this may cause data loss\n";
        }
        else {
          uint64_t v111 = "disabling overallocation repairs by default; use -o to override\n";
        }
        sub_100040C68(v111, v104, v105, v106, v107, v108, v109, v110, v494);
      }

      else
      {
        *(_BYTE *)(qword_10008DB78 + 41) = 1;
      }

      uint64_t v499 = (uint64_t)(v2 + 57);
      int v119 = sub_100024ED0((uint64_t)(v2 + 57), 0LL);
      if (v119)
      {
LABEL_94:
        sub_100040B90( "failed to initialize tree for container repairs\n",  v112,  v113,  v114,  v115,  v116,  v117,  v118,  v493);
        uint64_t v120 = 926LL;
        int v121 = v119;
LABEL_95:
        sub_100044E7C((char *)v120, v121);
        goto LABEL_15;
      }

      uint64_t v35 = 0LL;
      char v497 = 0;
      v498 = (int8x16_t *)(v2 + 11);
      while (1)
      {
        sub_100044E14(6LL);
        if (*((void *)v34 + 159)) {
          sub_100040C68("found unexpected EFI jumpstart record\n", v122, v123, v124, v125, v126, v127, v128, v493);
        }
        sub_100044E14(7LL);
        unsigned int v135 = v2 + 1;
        if (*(void *)(*v505 + 1256LL))
        {
          v136.i64[0] = 0xAAAAAAAAAAAAAAAALL;
          v136.i64[1] = 0xAAAAAAAAAAAAAAAALL;
          int8x16_t v533 = v136;
          int8x16_t v534 = v136;
          __str[0] = v136;
          __str[1] = v136;
          sub_1000432C4(v24, 218, v129, v130, v131, v132, v133, v134, v493);
          sub_100049220((uint64_t)__str, (uint64_t)v2, *(void *)(v2[1] + 1256LL));
          if (sub_100031CD0( (uint64_t)__str,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000301EC,  0LL,  0LL,  1))
          {
            uint64_t v479 = v24;
            int v480 = 319;
            goto LABEL_379;
          }
        }

        sub_100044E14(8LL);
        if (sub_100029834(v2, 0LL))
        {
          int v92 = 106;
          uint64_t v35 = 8LL;
          goto LABEL_382;
        }

        sub_100044E14(9LL);
        sub_1000432C4(v24, 203, v144, v145, v146, v147, v148, v149, v493);
        if (v503 == -1) {
          sub_10000CA50(v2[3]);
        }
        if (sub_100045380((uint64_t)v2, &v525, v137, v138, v139, v140, v141, v142))
        {
LABEL_350:
          uint64_t v479 = v24;
          int v480 = 303;
          goto LABEL_379;
        }

        sub_100041834(v2, *v2);
        uint64_t v150 = v2[1];
        if ((*(_DWORD *)(v150 + 104) & 0x80000000) != 0
          || (*(_DWORD *)(v150 + 108) & 0x80000000) != 0
          || (uint64_t v151 = v2[3], (*(_DWORD *)(v151 + 164) & 0x80000000) != 0)
          || (*(void *)(v151 + 152) & 0x8000000000000000LL) != 0)
        {
          sub_100044E14(10LL);
          sub_1000432C4(v24, 213, v152, v153, v154, v155, v156, v157, v493);
          if (sub_100030350((uint64_t)v2))
          {
            uint64_t v479 = v24;
            int v480 = 315;
            goto LABEL_379;
          }
        }

        sub_100044E14(11LL);
        sub_1000432C4(v24, 217, v158, v159, v160, v161, v162, v163, v493);
        if (sub_100046BA0(v2, &v525))
        {
          uint64_t v479 = v24;
          int v480 = 318;
          goto LABEL_379;
        }

        if (v525)
        {
          uint64_t v165 = v2[3];
          __str[0] = *v498;
          __str[1].i64[0] = v2[13];
          int v166 = sub_100023FA8(v2, 0LL, v165, (uint64_t)__str, __str[0], v164);
          if (v166)
          {
            int v482 = v166;
            sub_1000432C4(v24, 303, v167, v168, v169, v170, v171, v172, v493);
            uint64_t v483 = 782LL;
            int v484 = v482;
LABEL_376:
            sub_100044E7C((char *)v483, v484);
            goto LABEL_380;
          }

          sub_100044E2C();
          int v525 = 0;
        }

        sub_10003D78C((uint64_t)v2);
        sub_100044E14(12LL);
        sub_1000432C4(v24, 204, v173, v174, v175, v176, v177, v178, v493);
        if (v503 == -1) {
          sub_10001CD90(0, *(void *)(v2[1] + 88LL), *(void *)(v2[4] + 88LL));
        }
        if (sub_10000CB60(v2, 0LL, v46, v47, v48, v49, v50, v51))
        {
          uint64_t v479 = v24;
          int v480 = 305;
          goto LABEL_379;
        }

        if ((v504 & 0x100) != 0)
        {
          unint64_t v179 = *(void *)(v2[3] + 48LL) + 63LL;
          v534.i64[0] = 0LL;
          int8x16_t v533 = 0u;
          memset(__str, 0, sizeof(__str));
          uint64_t v521 = 0xAAAAAAAAAAAAAAAALL;
          sub_100044E14(29LL);
          sub_1000432C4(v24, 212, v180, v181, v182, v183, v184, v185, v493);
          __str[1].i64[0] = (uint64_t)calloc(v179 >> 6, 8uLL);
          if (!__str[1].i64[0])
          {
            sub_100040B90( "failed to allocate %zd bytes for APFS Fusion data\n",  v186,  v187,  v188,  v189,  v190,  v191,  v192,  8 * (v179 >> 6));
            uint64_t v120 = 710LL;
            int v121 = 12;
            goto LABEL_95;
          }

          if (sub_100022BD0( v2,  0LL,  0x80000000,  *(void *)(v2[1] + 1360LL),  0LL,  0,  22,  0,  (uint64_t **)&__str[1].i64[1],  (uint64_t)&v533,  0))
          {
            sub_1000432C4(v24, 313, v193, v194, v195, v196, v197, v198, v493);
            v481 = (void *)__str[1].i64[0];
LABEL_368:
            free(v481);
LABEL_380:
            uint64_t v35 = 8LL;
LABEL_381:
            int v92 = 106;
LABEL_382:
            char v91 = v497;
            goto LABEL_80;
          }

          if (sub_100029D5C((uint64_t)v2, &v521)
            || sub_100031CD0( v521,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10001ACC8,  (uint64_t)__str,  0LL,  1))
          {
            sub_1000432C4(v24, 313, v199, v200, v201, v202, v203, v204, v493);
            free((void *)__str[1].i64[0]);
            v481 = (void *)__str[1].i64[1];
            goto LABEL_368;
          }

          int v205 = sub_10001AFDC(v2, (uint64_t)__str, v199, v200, v201, v202, v203, v204);
          if (!v205)
          {
            unint64_t v206 = sub_10000822C(__str[1].i64[0], 1, 0LL, v179 & 0xFFFFFFFFFFFFFFC0LL);
            if (v206
              && (sub_100040C68( "%lld bytes of space on the main tier are unaccounted for\n",  v207,  v208,  v209,  v210,  v211,  v212,  v213,  v206 * *(_BYTE *)(v2[3] + 32LL)),  sub_100044E7C((char *)0x2C7, -8),  sub_1000428C4( qword_10008DB70,  "Fix orphaned MT mappings? ",  v214,  v215,  v216,  v217,  v218,  v219,  v495)))
            {
              int v205 = sub_100031CD0( v521,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10001B5EC,  (uint64_t)__str,  0LL,  0);
            }

            else
            {
              int v205 = 0;
            }
          }

          free((void *)__str[1].i64[0]);
          free((void *)__str[1].i64[1]);
          if (v205) {
            goto LABEL_353;
          }
          unsigned int v135 = v2 + 1;
        }

        if (*(void *)(*v135 + 1400LL) || *(void *)(*v135 + 1304LL))
        {
          sub_100044E14(30LL);
          sub_1000432C4(v24, 223, v220, v221, v222, v223, v224, v225, v493);
        }

        if (v522)
        {
          uint64_t v233 = sub_100041FC4((uint64_t)v2, v528);
          if ((_DWORD)v233)
          {
            uint64_t v35 = v233;
            goto LABEL_16;
          }
        }

        v520[0] = 0LL;
        v520[1] = 0LL;
        sub_10001CB00((uint64_t)v2, &v530, (int *)&v529);
        uint64_t v234 = v530;
        if (v530 < v529)
        {
          while (1)
          {
            if (!*(void *)(*v135 + 8 * v234 + 184)) {
              goto LABEL_160;
            }
            __int16 v235 = sub_10001CA1C((uint64_t)v2, v234);
            sub_100044E20(*(void *)v235);
            sub_100044E14(13LL);
            sub_1000432C4(v24, 101, v236, v237, v238, v239, v240, v241, *(void *)v235);
            sub_1000432C4(v24, 206, v242, v243, v244, v245, v246, v247, v496);
            v501 = v235 + 704;
            int v248 = sub_100024ED0((uint64_t)(v235 + 704), (uint64_t)v235);
            if (v248)
            {
              int v478 = v248;
              sub_100040B90( "failed to initialize tree for volume repairs\n",  v249,  v250,  v251,  v252,  v253,  v254,  v255,  v493);
              uint64_t v120 = 705LL;
              int v121 = v478;
              goto LABEL_95;
            }

            uint64_t v256 = (uint64_t *)(v235 + 40);
            unint64_t v257 = *(void *)(*v135 + 8 * v234 + 184);
            uint64_t v500 = v234;
            if (*((void *)v235 + 5))
            {
              if (sub_10001CE20(0, v257, 1))
              {
                sub_100040C68( "object (oid 0x%llx): Unable to mark the omap entry of the apfs_sb at index (%u) in use for omap space verification\n",  v258,  v259,  v260,  v261,  v262,  v263,  v264,  *(void *)(*v135 + 8 * v234 + 184));
                sub_100044E7C((char *)0x3DD, -7);
              }
            }

            else if (sub_100022BD0( v2,  0LL,  0,  v257,  0LL,  0,  13,  0,  (uint64_t **)v235 + 5,  (uint64_t)(v235 + 80),  0))
            {
              goto LABEL_147;
            }

            if (v503 != -1) {
              sub_10000CAA4(*v256);
            }
            __int128 v518 = 0u;
            __int128 v519 = 0u;
            uint64_t v516 = 0LL;
            memset(v515, 0, sizeof(v515));
            unint64_t v517 = 16LL;
            uint64_t v271 = *v256;
            LODWORD(v518) = *(_DWORD *)(*v256 + 960);
            sub_100049274(v24, v271);
            if (sub_100049360((uint64_t)v2, *v256, v234, &v525))
            {
LABEL_147:
              uint64_t v272 = v24;
              int v273 = 307;
              goto LABEL_148;
            }

            sub_100044E14(14LL);
            sub_1000432C4(v24, 204, v281, v282, v283, v284, v285, v286, v493);
            if (!*(_BYTE *)(qword_10008DB78 + 42)) {
              sub_10001CD90(1, *(void *)(*v135 + 88LL), *(void *)(*((void *)v235 + 9) + 88LL));
            }
            if (sub_10000CB60(v2, (uint64_t)v235, v287, v288, v289, v290, v291, v292))
            {
              uint64_t v272 = v24;
              int v273 = 305;
              goto LABEL_148;
            }

            unint64_t v293 = *(void *)(*v256 + 1000);
            if (v293)
            {
              int v294 = sub_10001CE20(1, v293, 1);
              if (v294)
              {
                int v302 = v294;
                sub_100040C68( "object (oid 0x%llx): Unable to mark the omap entry of the apfs_snap_meta_ext_oid in use for omap space verification\n",  v295,  v296,  v297,  v298,  v299,  v300,  v301,  *(void *)(*v256 + 1000));
                sub_100044E7C((char *)0x3D5, v302);
              }
            }

            uint64_t v303 = *((void *)v235 + 6);
            if (!v303) {
              uint64_t v303 = *v256;
            }
            sub_100044E14(15LL);
            uint64_t v304 = *v256;
            if ((*(_BYTE *)(*v256 + 264) & 1) == 0 || *(void *)(v304 + 976))
            {
              if (v235[8])
              {
                int v305 = sub_1000416DC((const char **)v235, v2, v528);
                if (v305)
                {
                  sub_100044E7C((char *)0x45F, v305);
                  uint64_t v35 = 66LL;
                  goto LABEL_16;
                }

                uint64_t v304 = *v256;
              }

              if (*(void *)(v304 + 976) && sub_1000392B0(v2, (uint64_t)v235))
              {
                uint64_t v272 = v24;
                int v273 = 314;
                goto LABEL_148;
              }
            }

            sub_100044E14(17LL);
            if (*(void *)(*v256 + 152))
            {
              __str[0].i64[0] = 0xAAAAAAAAAAAAAAAALL;
              sub_100028844();
              sub_1000432C4(v24, 209, v306, v307, v308, v309, v310, v311, v493);
              if (sub_100029FA4((uint64_t)v2, (uint64_t)v235, __str[0].i64)
                || sub_100031CD0( __str[0].i64[0],  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10000E49C,  (uint64_t)v515,  0LL,  1)
                || sub_100028AF4(v501))
              {
                uint64_t v272 = v24;
                int v273 = 310;
                goto LABEL_148;
              }
            }

            sub_100044E14(19LL);
            uint64_t v318 = *v256;
            BOOL v319 = (*(_BYTE *)(*v256 + 264) & 1) != 0 && !*(void *)(v318 + 976) || *((void *)v235 + 3) != 0LL;
            v235[9] = v319;
            char v320 = *(_BYTE *)(qword_10008DB78 + 42);
            LOBYTE(v321) = v320 == 0;
            if (!v320 && !v319)
            {
              if (*((void *)v235 + 6)) {
                uint64_t v318 = *((void *)v235 + 6);
              }
              int v321 = (*(unsigned __int8 *)(v318 + 56) >> 5) & 1;
            }

            v235[10] = v321;
            v235[11] = v320;
            sub_1000432C4(v24, 205, v312, v313, v314, v315, v316, v317, v493);
            __int128 v513 = 0u;
            __int128 v514 = 0u;
            uint64_t v511 = 0LL;
            memset(v510, 0, sizeof(v510));
            unint64_t v512 = 16LL;
            LODWORD(v513) = *(_DWORD *)(*((void *)v235 + 5) + 960LL);
            if (!*(_BYTE *)(qword_10008DB78 + 42) && v516 != v511) {
              sub_100040C68( "omap has %llu snaphots but snap meta tree has %llu\n",  v328,  v265,  v266,  v267,  v268,  v269,  v270,  v511);
            }
            if (v517 < v512) {
              unint64_t v517 = v512;
            }
            if (!*(_BYTE *)(qword_10008DB78 + 42) && sub_100004D24(v2, (uint64_t)v235, (uint64_t)v501))
            {
LABEL_203:
              uint64_t v272 = v24;
              int v273 = 306;
              goto LABEL_148;
            }

            if ((*(_BYTE *)(*v256 + 264) & 1) != 0 && !*(void *)(*v256 + 976) || *((void *)v235 + 3))
            {
              sub_1000050C0((uint64_t)v2, (uint64_t)v235, 0LL);
              uint64_t v329 = *((void *)v235 + 5);
              if (*(void *)(v329 + 1072) || *(void *)(v329 + 1080))
              {
                sub_100044E14(28LL);
                sub_1000432C4(v24, 221, v330, v331, v332, v333, v334, v335, v493);
                if (sub_1000057F4(v2, (int8x16_t *)v235, 0LL))
                {
                  uint64_t v272 = v24;
                  int v273 = 322;
                  goto LABEL_148;
                }
              }
            }

            sub_100044E14(16LL);
            *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&__int128 v336 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v336 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)uuid_string_t out = v336;
            *(_OWORD *)&out[16] = v336;
            uuid_unparse((const unsigned __int8 *)(*v256 + 240), out);
            uint64_t v344 = *v256;
            if ((*(_BYTE *)(*v256 + 56) & 0x10) != 0) {
              break;
            }
            if (*(void *)(v344 + 160))
            {
              v235[9] = 0;
              sub_100040C68( "Volume %s has revert_to_xid set, skipping the fsroot tree.\n",  v337,  v338,  v339,  v340,  v341,  v342,  v343,  (char)out);
LABEL_226:
              int v345 = 0;
              goto LABEL_227;
            }

            if (((*(_BYTE *)(v344 + 264) & 1) == 0 || *(void *)(v344 + 976)) && !*((void *)v235 + 3))
            {
              sub_100040C68( "Volume %s is encrypted and crypto I/O failed/was skipped, skipping the fsroot tree.\n",  v337,  v338,  v339,  v340,  v341,  v342,  v343,  (char)out);
              goto LABEL_226;
            }

            sub_10001E358(v235);
            __str[0].i64[0] = 0xAAAAAAAAAAAAAAAALL;
            sub_1000432C4(v24, 207, v364, v365, v366, v367, v368, v369, v493);
            if (sub_10002A1E0((uint64_t)v2, (uint64_t)v235, __str[0].i64)
              || (sub_1000132EC(__str[0].i64[0], 0LL),
                  sub_100031CD0( __str[0].i64[0],  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10000E49C,  (uint64_t)v515,  0LL,  0))
              || *(void *)(*v256 + 1096)
              && (sub_10002A2AC((uint64_t)v2, (uint64_t)v235, __str[0].i64)
               || sub_100013374((uint64_t)v2, (uint64_t)v235, v501, v266, v267, v268, v269, v270)
               || sub_100031CD0( __str[0].i64[0],  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10000E49C,  (uint64_t)v515,  0LL,  0))
              || v235[9] && sub_10002B08C((uint64_t)v2, (uint64_t)v235)
              || sub_1000133C4(v2, v235, 0LL, v501, v267, v268, v269, v270))
            {
              int v273 = 308;
LABEL_242:
              uint64_t v272 = v24;
              goto LABEL_148;
            }

            if (sub_100005648((uint64_t)v2, (uint64_t)v235, 0LL))
            {
              int v273 = 322;
              goto LABEL_242;
            }

            int v345 = 1;
LABEL_227:
            sub_1000051F4();
            uint64_t v346 = *((void *)v235 + 6);
            if (!v346) {
              uint64_t v346 = *v256;
            }
            if ((*(_BYTE *)(v346 + 56) & 0x20) != 0)
            {
              sub_10001E358(v235);
              __str[0].i64[0] = 0xAAAAAAAAAAAAAAAALL;
              sub_100044E14(26LL);
              sub_1000432C4(v24, 219, v353, v354, v355, v356, v357, v358, v493);
              if (sub_10002A104((uint64_t)v2, v235, __str, v359, v360, v361, v362, v363)
                || sub_100031CD0( __str[0].i64[0],  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10001320C,  (uint64_t)v515,  0LL,  1))
              {
                uint64_t v272 = v24;
                int v273 = 320;
                goto LABEL_148;
              }
            }

            sub_100044E14(18LL);
            sub_1000432C4(v24, 208, v347, v348, v349, v350, v351, v352, v493);
            uint64_t v509 = 0xAAAAAAAAAAAAAAAALL;
            if (sub_10002A054((uint64_t)v2, (uint64_t)v235, &v509)
              || sub_100031CD0( v509,  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10000E49C,  (uint64_t)v515,  0LL,  1))
            {
              uint64_t v272 = v24;
              int v273 = 309;
              goto LABEL_148;
            }

            if ((*(_BYTE *)(*v256 + 56) & 0x40) != 0)
            {
              __str[0].i64[0] = 0xAAAAAAAAAAAAAAAALL;
              sub_100044E14(27LL);
              sub_1000432C4(v24, 220, v376, v377, v378, v379, v380, v381, v493);
              if (sub_100029E0C((uint64_t)v2, (uint64_t)v235, __str[0].i64, v382, v383, v384, v385, v386)
                || sub_100031CD0( __str[0].i64[0],  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100030818,  (uint64_t)v515,  0LL,  1)
                || sub_1000306CC((uint64_t)v2, (uint64_t)v235, v501, v266, v267, v268, v269, v270))
              {
                uint64_t v272 = v24;
                int v273 = 321;
LABEL_148:
                sub_1000432C4(v272, v273, v265, v266, v267, v268, v269, v270, v493);
LABEL_149:
                sub_10001CDE4(1);
                sub_100009144();
                sub_100013338((uint64_t)v235);
                sub_1000051F4();
                v235[11] = 1;
                v235[13] = 1;
                goto LABEL_150;
              }
            }

            if (v345)
            {
              sub_100044E14(31LL);
              sub_1000432C4(v24, 224, v370, v371, v372, v373, v374, v375, v493);
              if (sub_10001D3B0(v2, (uint64_t)v235, 1))
              {
                uint64_t v272 = v24;
                int v273 = 323;
                goto LABEL_148;
              }
            }

            else
            {
              sub_10001CDE4(1);
            }

            sub_100041874((uint64_t)v235);
            sub_100044E14(21LL);
            if (v235[9] && sub_10004A140(*v256, (uint64_t)v515, &v525, v387, v267, v268, v269, v270)
              || !v235[11]
              && sub_10004A42C((uint64_t)v2, (uint64_t *)*v256, v520, &v525, v267, v268, v269, v270))
            {
              goto LABEL_147;
            }

            if ((*(_BYTE *)(*v256 + 264) & 4) != 0
              && (__str[0].i64[0] = 0LL, sub_100036AE0((uint64_t)v501, 0LL, __str), !__str[0].i64[0])
              && (v525
               || v235[12]
               || sub_1000428C4( qword_10008DB70,  "Clear volume inconsistent bit? ",  v388,  v389,  v390,  v391,  v392,  v393,  v493)))
            {
              *(void *)(*v256 + 264) &= ~4uLL;
              int v525 = 1;
            }

            else if (!v525 && !v235[12])
            {
              goto LABEL_150;
            }

            int v400 = sub_10004227C(v2, (int8x16_t *)v235);
            if (v400 && v525)
            {
              sub_1000432C4(v24, 307, v394, v395, v396, v397, v398, v399, v493);
              sub_100044E7C((char *)0xA7, v400);
              goto LABEL_149;
            }

            sub_100044E2C();
            int v525 = 0;
            v235[12] = 0;
            if (v400) {
              goto LABEL_149;
            }
LABEL_150:
            uint64_t v274 = 0LL;
            int v275 = v235[11];
            int v276 = v235[13];
            char v277 = 1;
            do
            {
              char v278 = v277;
              uint64_t v279 = *(void *)&v235[8 * v274 + 24];
              if (v279) {
                sub_10001BC18(v279);
              }
              char v277 = 0;
              uint64_t v274 = 1LL;
            }

            while ((v278 & 1) != 0);
            v502 &= v275 == 0;
            if (v276) {
              uint64_t v35 = 8LL;
            }
            else {
              uint64_t v35 = v35;
            }
            sub_10001BC18(*v2);
            __str[0].i64[0] = 0LL;
            sub_100036AE0((uint64_t)v501, 0LL, __str);
            if (__str[0].i64[0])
            {
              int v280 = 109;
              unsigned int v135 = v2 + 1;
              uint64_t v234 = v500;
            }

            else
            {
              if (v235[13]) {
                int v280 = 108;
              }
              else {
                int v280 = 104;
              }
              uint64_t v234 = v500;
              if (v235[13])
              {
                unsigned int v135 = v2 + 1;
              }

              else
              {
                unsigned int v135 = v2 + 1;
                if (v503 != -1) {
                  goto LABEL_160;
                }
              }
            }

            sub_10004A57C(v24, v280, v235);
LABEL_160:
            sub_100044E20(*(void *)(qword_10008DB78 + 8));
          }

          v235[9] = 0;
          sub_100040C68( "Volume %s is incompletely restored, skipping the fsroot tree.\n",  v337,  v338,  v339,  v340,  v341,  v342,  v343,  (char)out);
          goto LABEL_226;
        }

LABEL_283:
        sub_100044E14(22LL);
        sub_1000432C4(v24, 210, v401, v402, v403, v404, v405, v406, v493);
        if ((v502 & 1) != 0)
        {
          int v418 = sub_100046AB8((uint64_t)v2, v520, &v525, v407, v408, v409, v410, v411);
          if (!v418 && v525)
          {
            uint64_t v420 = v2[3];
            __str[0] = *v498;
            __str[1].i64[0] = v2[13];
            int v418 = sub_100023FA8(v2, 0LL, v420, (uint64_t)__str, __str[0], v419);
          }

          if (v418)
          {
            sub_1000432C4(v24, 303, v412, v413, v414, v415, v416, v417, v493);
            uint64_t v483 = 1098LL;
            int v484 = v418;
            goto LABEL_376;
          }

          if (v525)
          {
            sub_100044E2C();
            int v525 = 0;
          }
        }

        if (v503 == -1)
        {
          if (sub_1000204AC(v2, v421, v137, v138, v139, v140, v141, v142))
          {
LABEL_354:
            uint64_t v479 = v24;
            int v480 = 324;
            goto LABEL_379;
          }
        }

        sub_100044E14(32LL);
        byte_1000706A0 = (byte_1000706A0 != 0) & v502;
        if (sub_100009554(v2))
        {
          uint64_t v479 = v24;
          int v480 = 325;
          goto LABEL_379;
        }

        sub_100044E14(22LL);
        if ((v504 & 0x100) != 0)
        {
          if (byte_1000706A0)
          {
            __str[0].i64[0] = 0xAAAAAAAAAAAAAAAALL;
            if (sub_100029D5C((uint64_t)v2, __str[0].i64)
              || sub_100031CD0( __str[0].i64[0],  0LL,  (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10001AF50,  0LL,  0LL,  0))
            {
LABEL_353:
              uint64_t v479 = v24;
              int v480 = 313;
              goto LABEL_379;
            }
          }
        }

        sub_100044E14(23LL);
        uint64_t v507 = 0LL;
        uint64_t v508 = 0LL;
        uint64_t v506 = 0LL;
        __str[0].i64[0] = 0LL;
        sub_100036AE0(v499, 0LL, __str);
        uint64_t v428 = __str[0].i64[0];
        for (unint64_t i = v530; i < v529; ++i)
        {
          v430 = sub_10001CA1C((uint64_t)v2, i);
          if (*(void *)(v2[1] + 8 * i + 184))
          {
            __str[0].i64[0] = 0LL;
            sub_100036AE0((uint64_t)(v430 + 704), 0LL, __str);
            v428 += __str[0].i64[0];
          }
        }

        if (!v428) {
          goto LABEL_318;
        }
        sub_1000432C4(v24, 216, v422, v423, v424, v425, v426, v427, v493);
        int v438 = sub_1000254BC(v499, v2, 0LL, byte_1000706A0, 0LL, &v508, &v507, &v506);
        unint64_t v439 = v529;
        for (unint64_t j = v530; j < v439; ++j)
        {
          if (*(void *)(*v505 + 8 * j + 184))
          {
            v441 = sub_10001CA1C((uint64_t)v2, j);
            int v442 = sub_1000254BC( (uint64_t)(v441 + 704),  v2,  (uint64_t)v441,  byte_1000706A0,  0LL,  &v508,  &v507,  &v506);
            if (!v438) {
              int v438 = v442;
            }
            unint64_t v439 = v529;
          }
        }

        if (v438)
        {
          if (v506) {
            int v491 = 316;
          }
          else {
            int v491 = 317;
          }
          sub_1000432C4(v24, v491, v432, v433, v434, v435, v436, v437, v493);
          uint64_t v35 = 8LL;
          int v92 = 110;
          goto LABEL_382;
        }

        if (byte_1000706A0) {
          BOOL v443 = 1;
        }
        else {
          BOOL v443 = v508 == 0;
        }
        if (!v443)
        {
          sub_100040B90( "Unable to perform deferred repairs without full space verification\n",  v431,  v432,  v433,  v434,  v435,  v436,  v437,  v493);
          if (*(_DWORD *)(qword_10008DB78 + 20) != -1) {
            sub_100040B90( "Try running fsck against the entire APFS container instead of a volume\n",  v492,  v46,  v47,  v48,  v49,  v50,  v51,  v493);
          }
          goto LABEL_380;
        }

        if (v507)
        {
          if (!sub_100044E40())
          {
            sub_100040B90( "Reached max number of fsck passes during repair\n",  v451,  v452,  v453,  v454,  v455,  v456,  v457,  v493);
            uint64_t v35 = 8LL;
            char v91 = 1;
            goto LABEL_79;
          }

          sub_10004096C("Restarting after deferred repairs...\n", v451, v452, v453, v454, v455, v456, v457, v493);
          sub_10003C22C();
          sub_10003BEF4((uint64_t)v2);
          int v119 = sub_100024ED0(v499, 0LL);
          char v497 = 1;
          if (v119) {
            goto LABEL_94;
          }
        }

        else
        {
LABEL_318:
          sub_100044E14(24LL);
          if (!byte_1000706A0 || !sub_10003C59C()) {
            goto LABEL_365;
          }
          if (*(_BYTE *)(qword_10008DB78 + 40))
          {
            sub_10003C5D8();
            if (sub_1000428C4( qword_10008DB70,  "Fix overlapped extents? ",  v485,  v486,  v487,  v488,  v489,  v490,  v493))
            {
              if (!sub_10003C6A4(v2))
              {
                *(_BYTE *)(qword_10008DB78 + 40) = 0;
LABEL_365:
                sub_100044E14(25LL);
                goto LABEL_381;
              }
            }

            else
            {
              sub_100044E7C((char *)0x1CB, 92);
            }

LABEL_378:
            uint64_t v479 = v24;
            int v480 = 311;
LABEL_379:
            sub_1000432C4(v479, v480, v137, v138, v139, v140, v141, v142, v493);
            goto LABEL_380;
          }

          sub_10004096C("Overlap repair pass...\n", v444, v445, v446, v447, v448, v449, v450, v493);
          *(_BYTE *)(qword_10008DB78 + 40) = 1;
          int v119 = sub_100024ED0(v499, 0LL);
          if (v119) {
            goto LABEL_94;
          }
        }
      }
    }

    __int16 v524 = 0;
    nullsub_1(v84);
    sub_10001CB48();
    if (v33) {
      free(v33);
    }
    free(v34);
    sub_10002955C(v2);
    *(_OWORD *)v527 = 0u;
    __int128 v528 = 0u;
    *(_OWORD *)v526 = 0u;
    sub_100041530(*(const char **)(qword_10008DB78 + 8));
    sub_100044E20(*(void *)(qword_10008DB78 + 8));
    sub_100044E14(2LL);
    char v523 = 0;
    uint64_t v35 = sub_1000418C4((uint64_t)v2, (uint64_t)v526, &v523);
    uint64_t v33 = 0LL;
    uint64_t v34 = 0LL;
    if ((_DWORD)v35) {
      goto LABEL_16;
    }
  }

  uint64_t v88 = v24;
  int v89 = 304;
LABEL_72:
  sub_1000432C4(v88, v89, v53, v54, v55, v56, v57, v58, v493);
  char v91 = 0;
  uint64_t v33 = 0LL;
LABEL_78:
  uint64_t v35 = 8LL;
LABEL_79:
  int v92 = 106;
LABEL_80:
  uint64_t v90 = qword_10008DB78;
  if (!*(_BYTE *)(qword_10008DB78 + 36))
  {
LABEL_328:
    if (v503 == -1)
    {
      if ((_DWORD)v35) {
        int v94 = 127;
      }
      else {
        int v94 = 128;
      }
      uint64_t v493 = *(void *)v90;
      uint64_t v93 = v24;
LABEL_340:
      sub_1000432C4(v93, v94, v46, v47, v48, v49, v50, v51, v493);
    }

    else
    {
      if ((v91 & 1) != 0) {
        int v466 = 105;
      }
      else {
        int v466 = 104;
      }
      if ((_DWORD)v35) {
        int v467 = v92;
      }
      else {
        int v467 = v466;
      }
      v468 = sub_10001CA1C((uint64_t)v2, *(_DWORD *)(v90 + 20));
      sub_10004A57C(v24, v467, v468);
    }

    goto LABEL_341;
  }

  if ((_DWORD)v35)
  {
    if ((_DWORD)v35 == 8) {
      uint64_t v35 = 3LL;
    }
    else {
      uint64_t v35 = v35;
    }
    uint64_t v93 = v24;
    int v94 = 126;
    goto LABEL_340;
  }

uint64_t sub_100049074(uint64_t a1, uint64_t *a2)
{
  int v44 = 0;
  sub_10003BEF4((uint64_t)a2);
  sub_100044E14(12LL);
  sub_1000432C4(a1, 204, v4, v5, v6, v7, v8, v9, v41);
  if (sub_10000CB60(a2, 0LL, v10, v11, v12, v13, v14, v15))
  {
    uint64_t v22 = a1;
    int v23 = 305;
    goto LABEL_4;
  }

  unsigned int v45 = -1431655766;
  unsigned int v46 = -1431655766;
  sub_10001CB00((uint64_t)a2, &v46, (int *)&v45);
  uint64_t v25 = v46;
  if (v46 >= v45) {
    return 0LL;
  }
  while (1)
  {
    if (!*(void *)(a2[1] + 8 * v25 + 184)) {
      goto LABEL_16;
    }
    uint64_t v26 = sub_10001CA1C((uint64_t)a2, v25);
    sub_100044E20(*(void *)v26);
    sub_100044E14(13LL);
    sub_1000432C4(a1, 101, v27, v28, v29, v30, v31, v32, *(void *)v26);
    sub_1000432C4(a1, 206, v33, v34, v35, v36, v37, v38, v43);
    uint64_t v40 = (uint64_t *)(v26 + 40);
    uint64_t v39 = *((void *)v26 + 5);
    if (!v39)
    {
      if (sub_100022BD0( a2,  0LL,  0,  *(void *)(a2[1] + 8 * v25 + 184),  0LL,  0,  13,  0,  (uint64_t **)v26 + 5,  (uint64_t)(v26 + 80),  0)) {
        break;
      }
      uint64_t v39 = *v40;
    }

    sub_100049274(a1, v39);
    if (v44)
    {
      sub_100044E2C();
      int v44 = 0;
    }

uint64_t sub_100049220(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100034B44( a1,  a2,  0LL,  0x40000000,  2,  33,  0,  *(_DWORD *)(*(void *)(a2 + 8) + 36LL),  8,  16,  0,  a3,  (uint64_t)sub_10002D39C);
}

uint64_t sub_100049274(uint64_t a1, uint64_t a2)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[14] = v4;
  v14[15] = v4;
  v14[12] = v4;
  v14[13] = v4;
  v14[10] = v4;
  v14[11] = v4;
  v14[8] = v4;
  _OWORD v14[9] = v4;
  v14[6] = v4;
  v14[7] = v4;
  v14[4] = v4;
  v14[5] = v4;
  v14[2] = v4;
  v14[3] = v4;
  v14[0] = v4;
  v14[1] = v4;
  v13[0] = v4;
  v13[1] = v4;
  v12[0] = v4;
  v12[1] = v4;
  __strlcpy_chk(v14, a2 + 704, 256LL, 256LL);
  __strlcpy_chk(v13, a2 + 272, 32LL, 32LL);
  __strlcpy_chk(v12, a2 + 320, 32LL, 32LL);
  return sub_1000432C4(a1, 124, v5, v6, v7, v8, v9, v10, (char)v14);
}

uint64_t sub_100049360(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v8 = *(void *)(a1 + 8);
  unint64_t v9 = *(void *)(v8 + 96);
  unint64_t v10 = *(void *)(v8 + 40);
  uint64_t v11 = sub_10000E000();
  if (*(_DWORD *)(a2 + 32) != 1112756289)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_magic invalid: %d\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 14LL;
LABEL_24:
    sub_100044E7C((char *)v37, 92);
    return v21;
  }

  unint64_t v19 = v11;
  uint64_t v20 = *(void **)(a1 + 24);
  if (*(_DWORD *)(a2 + 36) != a3)
  {
    sub_100040B90("apfs_fs_index (%d) is not valid (%d)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    sub_100044E7C((char *)0xF, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Fix apfs_fs_index(oid 0x%llx, xid 0x%llx)? ",  v22,  v23,  v24,  v25,  v26,  v27,  *(void *)(a2 + 8))) {
      return v21;
    }
    *(_DWORD *)(a2 + 36) = a3;
    *a4 = 1;
  }

  if ((*(void *)(a2 + 40) & 0xFFFFFFFFFFFFFFE0LL) != 0)
  {
    sub_100040C68( "apfs superblock at index %u: apfs_features has unrecognized features (0x%llX)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x10, -3);
  }

  if ((*(void *)(a2 + 48) & 0xFFFFFFFFFFFFFFF1LL) != 0)
  {
    sub_100040C68( "apfs superblock at index %u: apfs_readonly_compatible_features has unsupported flags: (0x%llX)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v28 = qword_10008DB78;
    *(_DWORD *)(qword_10008DB78 + 28) = 1;
    *(_BYTE *)(v28 + 37) = 1;
    sub_1000428A8(qword_10008DB70, 1);
    sub_100044E7C((char *)0x11, -3);
  }

  uint64_t v29 = *(void *)(a2 + 56);
  if ((v29 & 0xFFFFFFFFFFFFFC00LL) != 0 || (*(void *)(a2 + 56) & 9LL) == 9)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_incompatible_features has unsupported flags: (0x%llX)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 18LL;
    goto LABEL_24;
  }

  if ((v29 & 0x200) != 0 && (*(void *)(a2 + 48) & 2) != 0)
  {
    sub_100040B90( "apfs superblock at index %u: incompatible features set (apfs_readonly_compatible_features: (0x%llX), apfs_incompat ible_features: (0x%llX))\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 1210LL;
    goto LABEL_24;
  }

  if (*(void *)(a2 + 64) > v19)
  {
    sub_100040C68( "apfs superblock at index %u: apfs_unmount_time (%llu) is greater than current time (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x13, -4);
  }

  if (v20)
  {
    if (*(void *)(a2 + 88) > *(void *)(*(void *)(a1 + 8) + 40LL) - (v20[30] + v20[9] + v20[15] + v20[35]))
    {
      sub_100040C68( "apfs superblock at index %u: apfs_fs_alloc_count (%llu) is greater than container wide allocated count (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
      sub_100044E7C((char *)0x308, -7);
    }

    unint64_t v30 = *(void *)(a2 + 72);
    if (v30)
    {
      if (v30 <= *(void *)(*(void *)(a1 + 8) + 40LL))
      {
        if (v30 > v20[23])
        {
          sub_100040C68( "apfs superblock at index %u: apfs_fs_reserve_block_count (%llu) is greater than spaceman reserve block count (%llu) for a guaranteed-minimum space FS\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
          sub_100044E7C((char *)0x14, -7);
          unint64_t v30 = *(void *)(a2 + 72);
        }
      }

      else
      {
        sub_100040B90( "apfs superblock at index %u: apfs_fs_reserve_block_count (%llu) is greater than the container block count (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
        uint64_t v21 = 92LL;
        sub_100044E7C((char *)0x448, 92);
        if (!sub_1000428C4( qword_10008DB70,  "Fix apfs_fs_reserve_block_count(oid 0x%llx, xid 0x%llx)? ",  v31,  v32,  v33,  v34,  v35,  v36,  *(void *)(a2 + 8))) {
          return v21;
        }
        unint64_t v30 = 0LL;
        *(void *)(a2 + 72) = 0LL;
        *a4 = 1;
      }

      if (v30 >= *(void *)(a2 + 88)) {
        unint64_t v30 = *(void *)(a2 + 88);
      }
      if (v30 > v20[24])
      {
        sub_100040C68( "apfs superblock at index %u: apfs reserve alloc count (%llu) is greater than spaceman reserve alloc count (%ll u) for a guaranteed-minimum space FS\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
        sub_100044E7C((char *)0x309, -7);
      }
    }
  }

  unint64_t v39 = *(void *)(a2 + 80);
  if (v39)
  {
    if (*(void *)(a2 + 72) > v39)
    {
      sub_100040B90( "apfs superblock at index %u: apfs_fs_reserve_block_count (%llu) must not be greater than apfs_fs_quota_block_count (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 21LL;
      goto LABEL_24;
    }

    if (v39 > v10)
    {
      sub_100040C68( "apfs superblock at index %u: apfs_fs_quota_block_count (%llu) should not be greater than nx_block_count (%llu) f or an FS with quota\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
      sub_100044E7C((char *)0x16, -7);
      unint64_t v39 = *(void *)(a2 + 80);
    }

    if (*(void *)(a2 + 88) > v39)
    {
      sub_100040B90( "apfs superblock at index %u: apfs_fs_alloc_count (%llu) must not be greater than apfs_fs_quota_block_count (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 23LL;
      goto LABEL_24;
    }
  }

  int v40 = *(_DWORD *)(a2 + 116);
  if ((unsigned __int16)v40 != 2
    || (unsigned int v41 = v40 & 0xC0000000, (v40 & 0xC0000000) != 0x80000000) && v41 && v41 != 0x40000000)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_root_tree_type is invalid: 0x%x\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 24LL;
    goto LABEL_24;
  }

  int v42 = *(_DWORD *)(a2 + 120);
  if ((unsigned __int16)v42 != 2
    || (unsigned int v43 = v42 & 0xC0000000, (v42 & 0xC0000000) != 0x80000000) && v43 && v43 != 0x40000000)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_extentref_tree_type is invalid: 0x%x\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 25LL;
    goto LABEL_24;
  }

  int v44 = *(_DWORD *)(a2 + 124);
  if ((unsigned __int16)v44 != 2
    || (unsigned int v45 = v44 & 0xC0000000, (v44 & 0xC0000000) != 0x80000000) && v45 && v45 != 0x40000000)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_snap_meta_tree_type is invalid: 0x%x\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 26LL;
    goto LABEL_24;
  }

  if (!*(void *)(a2 + 128))
  {
    sub_100040B90( "apfs superblock at index %u: apfs_omap_oid is invalid.\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 27LL;
    goto LABEL_24;
  }

  if (!*(void *)(a2 + 136))
  {
    sub_100040B90( "apfs superblock at index %u: apfs_root_tree_oid is invalid.\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 28LL;
    goto LABEL_24;
  }

  if ((*(void *)(a2 + 56) & 0x100) != 0)
  {
    if ((*(void *)(a2 + 264) & 1) != 0 && !*(void *)(a2 + 976))
    {
      sub_100040B90( "apfs superblock at index %u: apfs_fs_flags (0x%llx) inconsistent with apfs_incompatible_features secondary fsroo t bit (0x%llx)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 1160LL;
      goto LABEL_24;
    }

    if (!*(void *)(a2 + 1096))
    {
      sub_100040B90( "apfs superblock at index %u: apfs_sec_root_tree_oid is invalid\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 1161LL;
      goto LABEL_24;
    }

    if ((unsigned __int16)*(_DWORD *)(a2 + 1104) != 2
      || (unsigned int v54 = *(_DWORD *)(a2 + 1104) & 0xC0000000, v54 != 0x80000000) && v54 && v54 != 0x40000000)
    {
      sub_100040B90( "apfs superblock at index %u: apfs_sec_root_tree_type is invalid\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 1162LL;
      goto LABEL_24;
    }
  }

  else if (*(void *)(a2 + 1096))
  {
    sub_100040C68( "apfs superblock at index %u: apfs_sec_root_tree_oid (%llu) set on incompatible volume\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x48B, -2);
  }

  if (!*(void *)(a2 + 144))
  {
    sub_100040B90( "apfs superblock at index %u: apfs_extentref_tree_oid is invalid.\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 29LL;
    goto LABEL_24;
  }

  unint64_t v46 = *(void *)(a2 + 160);
  if (v46 >= v9)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_revert_to_xid (%llu) should be less than nx_next_xid (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 30LL;
    goto LABEL_24;
  }

  if (v46 && !*(void *)(a2 + 168))
  {
    sub_100040B90( "apfs superblock at index %u: apfs_revert_to_xid is %llu, but sblock oid is invalid\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 31LL;
    goto LABEL_24;
  }

  if (*(void *)(a2 + 232) > *(void *)(a2 + 224))
  {
    sub_100040C68( "apfs superblock at index %u: apfs_total_blocks_freed (%llu) should not be greater than apfs_total_blocks_alloced (%llu)\n",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x20, -7);
  }

  if (uuid_is_null((const unsigned __int8 *)(a2 + 240)))
  {
    sub_100040B90( "apfs superblock at index %u: apfs_vol_uuid is NULL\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 33LL;
    goto LABEL_24;
  }

  if (*(void *)(a2 + 256) > v19)
  {
    sub_100040C68( "apfs superblock at index %u: apfs_last_mod_time (%llu) is greater than current time (%llu)\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x22, -4);
  }

  unint64_t v55 = *(void *)(a2 + 264);
  if (v55 >= 0x1000)
  {
    sub_100040C68( "apfs superblock at index %u: apfs_fs_flags has an unknown flag set 0x%llx\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x23, -3);
    unint64_t v55 = *(void *)(a2 + 264);
  }

  unint64_t v56 = v55 & 0x109;
  if ((*(_BYTE *)(a2 + 48) & 2) == 0 && (v56 == 256) == ((*(void *)(a2 + 56) & 0x40LL) == 0))
  {
    sub_100040B90( "apfs superblock at index %u: apfs_fs_flags (0x%llx) PFK bit inconsistent with apfs_incompatible_features (0x%llx) PFK bit\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 998LL;
    goto LABEL_24;
  }

  if ((v56 & (v56 - 1)) != 0)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_fs_flags has conflicting encryption flags 0x%llx\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 999LL;
    goto LABEL_24;
  }

  if ((v55 & 0x80) != 0 && (*(void *)(a2 + 56) & 0x20LL | *(void *)(a2 + 1024) || *(void *)(a2 + 1032)))
  {
    sub_100040B90( "apfs superblock at index %u: apfs_fs_flags (0x%llx) previously sealed bit inconsistent with apfs_incompatible_feat ures (0x%llx) / apfs_integrity_meta_oid (%llu) / apfs_fext_tree_oid (%llu)\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 951LL;
    goto LABEL_24;
  }

  if ((v55 & 1) == 0 || *(void *)(a2 + 976))
  {
    if ((*(_BYTE *)(a2 + 56) & 0x20) != 0)
    {
      sub_100040B90( "apfs superblock at index %u: apfs_fs_flags (0x%llx) indicates sealed volume is not fully unencrypted\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 917LL;
      goto LABEL_24;
    }

    sub_10004A634((char *)(a2 + 96), a2, v48, v49, v50, v51, v52, v53);
  }

  if (!*(_BYTE *)(a2 + 704))
  {
    sub_100040B90( "apfs superblock at index %u: apfs_volname[0] == 0\n",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 36LL;
    goto LABEL_24;
  }

  if (strnlen((const char *)(a2 + 272), 0x20uLL) == 32)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_formatted_by.id (%.*s) is not NULL terminated.\n",  v57,  v58,  v59,  v60,  v61,  v62,  v63,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    sub_100044E7C((char *)0x25, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Fix apfs_formatted_by.id(oid 0x%llx, xid 0x%llx)? ",  v64,  v65,  v66,  v67,  v68,  v69,  *(void *)(a2 + 8))) {
      return v21;
    }
    *(_BYTE *)(a2 + 303) = 0;
    *a4 = 1;
  }

  if (*(void *)(a2 + 304) > v19)
  {
    sub_100040C68( "apfs superblock at index %u: apfs_formatted_by.timestamp (%llu) is greater than current time (%llu)\n",  v57,  v58,  v59,  v60,  v61,  v62,  v63,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x26, -4);
  }

  if (*(void *)(a2 + 312) > v9)
  {
    sub_100040C68( "apfs superblock at index %u: apfs_formatted_by.last_xid (0x%llx) is greater than nx_next_xid (0x%llx)\n",  v57,  v58,  v59,  v60,  v61,  v62,  v63,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x27, -2);
  }

  uint64_t v70 = 0LL;
  uint64_t v71 = a2 + 320;
  do
  {
    unint64_t v72 = *(void *)(v71 + 32);
    if (!v72) {
      break;
    }
    if (strnlen((const char *)v71, 0x20uLL) == 32)
    {
      uint64_t v80 = v71;
      sub_100040B90( "apfs superblock at index %u: apfs_modified_by[%d].id (%.*s) is not NULL terminated.\n",  v73,  v74,  v75,  v76,  v77,  v78,  v79,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      sub_100044E7C((char *)0x28, 92);
      if (!sub_1000428C4( qword_10008DB70,  "Fix apfs_modified_by[%d].id(oid 0x%llx, xid 0x%llx)? ",  v81,  v82,  v83,  v84,  v85,  v86,  v70)) {
        return v21;
      }
      uint64_t v71 = v80;
      *(_BYTE *)(v80 + 31) = 0;
      *a4 = 1;
      unint64_t v72 = *(void *)(v80 + 32);
    }

    if (v72 > v19)
    {
      sub_100040C68( "apfs superblock at index %u: apfs_modified_by[%d].timestamp (%llu) is greater than current time (%llu)\n",  v73,  v74,  v75,  v76,  v77,  v78,  v79,  *(_DWORD *)(a2 + 36));
      sub_100044E7C((char *)0x29, -4);
    }

    if (*(void *)(v71 + 40) > v9)
    {
      sub_100040C68( "apfs superblock at index %u: apfs_modified_by[%d].last_xid (0x%llx) is greater than nx_next_xid (0x%llx)\n",  v73,  v74,  v75,  v76,  v77,  v78,  v79,  *(_DWORD *)(a2 + 36));
      sub_100044E7C((char *)0x2A, -2);
    }

    ++v70;
    v71 += 48LL;
  }

  while (v70 != 8);
  if (strnlen((const char *)(a2 + 704), 0x100uLL) == 256)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_volname (%.*s) is not NULL terminated.\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    sub_100044E7C((char *)0x2B, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Fix apfs_volname(oid 0x%llx, xid 0x%llx)? ",  v94,  v95,  v96,  v97,  v98,  v99,  *(void *)(a2 + 8))) {
      return v21;
    }
    *(_BYTE *)(a2 + 959) = 0;
    *a4 = 1;
  }

  if (*(_DWORD *)(a2 + 960) <= 2u)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_next_doc_id (%u) should not be less than MIN_DOC_ID (%d)\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    uint64_t v37 = 44LL;
    goto LABEL_24;
  }

  if (*(void *)(a2 + 216) && !*(void *)(a2 + 1000)) {
    sub_100040B50( "apfs_sb: object (oid 0x%llx): apfs_snap_meta_ext_oid invalid\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(void *)(a2 + 8));
  }
  uint64_t v100 = *(void *)(a2 + 56);
  if ((v100 & 0x20) != 0)
  {
    if (!*(void *)(a2 + 1032))
    {
      sub_100040B90( "apfs superblock at index %u: apfs_fext_tree_oid is invalid.\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 909LL;
      goto LABEL_24;
    }

    int v116 = *(_DWORD *)(a2 + 1040);
    if ((unsigned __int16)v116 != 2
      || (unsigned int v117 = v116 & 0xC0000000, (v116 & 0xC0000000) != 0x80000000) && v117 && v117 != 0x40000000)
    {
      sub_100040B90( "apfs superblock at index %u: apfs_fext_tree_type is invalid: %u\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 910LL;
      goto LABEL_24;
    }

    if (!*(void *)(a2 + 1024))
    {
      sub_100040B90( "apfs superblock at index %u: apfs_integrity_meta_oid is invalid.\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 911LL;
      goto LABEL_24;
    }
  }

  if ((v100 & 0x40) != 0)
  {
    if (!*(void *)(a2 + 1048))
    {
      sub_100040B90( "apfs superblock at index %u: apfs_pfkur_tree_oid is invalid.\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 970LL;
      goto LABEL_24;
    }

    int v118 = *(_DWORD *)(a2 + 1044);
    if ((unsigned __int16)v118 != 2
      || (unsigned int v119 = v118 & 0xC0000000, (v118 & 0xC0000000) != 0x80000000) && v119 && v119 != 0x40000000)
    {
      sub_100040B90( "apfs superblock at index %u: apfs_pfkur_tree_type is invalid: 0x%x\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92LL;
      uint64_t v37 = 971LL;
      goto LABEL_24;
    }
  }

  if (*(void *)(a2 + 1056) >= *(void *)(*(void *)(a1 + 8) + 96LL))
  {
    sub_100040C68( "apfs superblock at index %u: apfs_doc_id_index_xid (%llu) is greater than or equal to container nx_next_xid (%llu)\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x40F, -2);
  }

  unsigned int v101 = *(_DWORD *)(a2 + 1064);
  if (v101 >= 0x20)
  {
    sub_100040C68( "apfs superblock at index %u: apfs_doc_id_index_flags has unrecognized flags (0x%x)\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x410, -3);
    unsigned int v101 = *(_DWORD *)(a2 + 1064);
  }

  if ((v101 & 1) == 0)
  {
    if (*(void *)(a2 + 1080))
    {
      sub_100040C68( "apfs superblock at index %u: apfs_prev_doc_id_tree_oid is set (%llu), despite apfs_doc_id_index_flags (0x%x)\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
      sub_100044E7C((char *)0x411, -3);
    }

    if (*(void *)(a2 + 1088))
    {
      sub_100040C68( "apfs superblock at index %u: apfs_doc_id_fixup_cursor is set (%llu), despite apfs_doc_id_index_flags (0x%x)\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
      sub_100044E7C((char *)0x412, -3);
      if (sub_1000428C4( qword_10008DB70,  "Fix apfs_doc_id_fixup_cursor? ",  v102,  v103,  v104,  v105,  v106,  v107,  v120))
      {
        *(void *)(a2 + 1088) = 0LL;
        *a4 = 1;
      }
    }
  }

  if (*(void *)(a2 + 1088) >= *(void *)(a2 + 176))
  {
    sub_100040C68( "apfs superblock at index %u: apfs_doc_id_fixup_cursor (%llu) is greater than or equal to apfs_next_obj_id (%llu)\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
    sub_100044E7C((char *)0x413, -2);
  }

  if (!*(void *)(a2 + 1072) && !*(void *)(a2 + 1080)) {
    return 0LL;
  }
  int v108 = *(_DWORD *)(a2 + 1068);
  if ((unsigned __int16)v108 != 2
    || (uint64_t v21 = 0LL, v109 = v108 & 0xC0000000, (v108 & 0xC0000000) != 0x80000000) && v109 && v109 != 0x40000000)
  {
    sub_100040B90( "apfs superblock at index %u: apfs_doc_id_tree_type is invalid: %u\n",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92LL;
    sub_100044E7C((char *)0x414, 92);
    if (sub_1000428C4( qword_10008DB70,  "Fix apfs_doc_id_tree_type? ",  v110,  v111,  v112,  v113,  v114,  v115,  v121))
    {
      uint64_t v21 = 0LL;
      *(_DWORD *)(a2 + 1068) = 2;
      *a4 = 1;
    }
  }

  return v21;
}

uint64_t sub_10004A140( uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 176) < *(void *)(a2 + 40))
  {
    sub_100040B90( "apfs_next_obj_id is not valid (expected %llu, actual %llu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 40));
    uint64_t v11 = 92LL;
    sub_100044E7C((char *)0x2D, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Fix apfs_next_obj_id(oid 0x%llx, xid 0x%llx)? ",  v12,  v13,  v14,  v15,  v16,  v17,  *(void *)(a1 + 8))) {
      return v11;
    }
    *(void *)(a1 + 176) = *(void *)(a2 + 40);
    *a3 = 1;
  }

  if (*(_DWORD *)(a1 + 960) < *(_DWORD *)(a2 + 48))
  {
    sub_100040B90( "apfs_next_doc_id is not valid (expected %u, actual %u)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a2 + 48));
    uint64_t v11 = 92LL;
    sub_100044E7C((char *)0x415, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Fix apfs_next_doc_id(oid 0x%llx, xid 0x%llx)? ",  v18,  v19,  v20,  v21,  v22,  v23,  *(void *)(a1 + 8))) {
      return v11;
    }
    *(_DWORD *)(a1 + 960) = *(_DWORD *)(a2 + 48);
    *a3 = 1;
  }

  if (*(void *)(a1 + 184) != *(void *)a2)
  {
    sub_100040C68( "apfs_num_files is not valid (expected %llu, actual %llu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(void *)a2);
    sub_100044E7C((char *)0x2E, -8);
    if (sub_1000428C4( qword_10008DB70,  "Fix apfs_num_files(oid 0x%llx, xid 0x%llx)? ",  v24,  v25,  v26,  v27,  v28,  v29,  *(void *)(a1 + 8)))
    {
      *(void *)(a1 + 184) = *(void *)a2;
      *a3 = 1;
    }
  }

  if (*(void *)(a1 + 192) != *(void *)(a2 + 8))
  {
    sub_100040C68( "apfs_num_directories is not valid (expected %llu, actual %llu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 8));
    sub_100044E7C((char *)0x2F, -8);
    if (sub_1000428C4( qword_10008DB70,  "Fix apfs_num_directories(oid 0x%llx, xid 0x%llx)? ",  v30,  v31,  v32,  v33,  v34,  v35,  *(void *)(a1 + 8)))
    {
      *(void *)(a1 + 192) = *(void *)(a2 + 8);
      *a3 = 1;
    }
  }

  if (*(void *)(a1 + 200) != *(void *)(a2 + 16))
  {
    sub_100040C68( "apfs_num_symlinks is not valid (expected %llu, actual %llu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 16));
    sub_100044E7C((char *)0x30, -8);
    if (sub_1000428C4( qword_10008DB70,  "Fix apfs_num_symlinks(oid 0x%llx, xid 0x%llx)? ",  v36,  v37,  v38,  v39,  v40,  v41,  *(void *)(a1 + 8)))
    {
      *(void *)(a1 + 200) = *(void *)(a2 + 16);
      *a3 = 1;
    }
  }

  if (*(void *)(a1 + 208) != *(void *)(a2 + 24))
  {
    sub_100040C68( "apfs_num_other_fsobjects is not valid (expected %llu, actual %llu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 24));
    sub_100044E7C((char *)0x31, -8);
    if (sub_1000428C4( qword_10008DB70,  "Fix apfs_num_other_fsobjects(oid 0x%llx, xid 0x%llx)? ",  v42,  v43,  v44,  v45,  v46,  v47,  *(void *)(a1 + 8)))
    {
      *(void *)(a1 + 208) = *(void *)(a2 + 24);
      *a3 = 1;
    }
  }

  if (*(void *)(a1 + 216) == *(void *)(a2 + 32)) {
    return 0LL;
  }
  sub_100040C68( "apfs_num_snapshots is not valid (expected %llu, actual %llu)\n",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 32));
  sub_100044E7C((char *)0x32, -8);
  if (!sub_1000428C4( qword_10008DB70,  "Fix apfs_num_snapshots(oid 0x%llx, xid 0x%llx)? ",  v48,  v49,  v50,  v51,  v52,  v53,  *(void *)(a1 + 8))) {
    return 0LL;
  }
  uint64_t v11 = 0LL;
  *(void *)(a1 + 2--*(_DWORD *)(result + 16) = *(void *)(a2 + 32);
  *a3 = 1;
  return v11;
}

uint64_t sub_10004A42C( uint64_t a1, uint64_t *a2, uint64_t *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11 = a2[9];
  uint64_t v12 = *a3;
  if (v11 > *(void *)(*(void *)(a1 + 8) + 40LL) - *a3)
  {
    sub_100040B90( "apfs_fs_reserve_block_count brings total reserve block count beyond the container block count (max %llu, actual %llu)\n",  (uint64_t)a2,  (uint64_t)a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  *(_BYTE *)(*(void *)(a1 + 8) + 40LL) - *(_BYTE *)a3);
    uint64_t v13 = 92LL;
    sub_100044E7C((char *)0x449, 92);
    if (!sub_1000428C4( qword_10008DB70,  "Fix apfs_fs_reserve_block_count(oid 0x%llx, xid 0x%llx)? ",  v14,  v15,  v16,  v17,  v18,  v19,  a2[1])) {
      return v13;
    }
    unint64_t v11 = 0LL;
    a2[9] = 0LL;
    *a4 = 1;
    uint64_t v12 = *a3;
  }

  *a3 = v12 + v11;
  unint64_t v35 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = sub_10003D31C(a2[1], &v35);
  if (!(_DWORD)v13)
  {
    unint64_t v27 = a2[11];
    if (v27 != v35)
    {
      sub_100040C68( "apfs_fs_alloc_count is not valid (expected %llu, actual %llu)\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v35);
      sub_100044E7C((char *)0x367, -8);
      if (sub_1000428C4( qword_10008DB70,  "Fix apfs_fs_alloc_count(oid 0x%llx, xid 0x%llx)? ",  v28,  v29,  v30,  v31,  v32,  v33,  a2[1]))
      {
        unint64_t v27 = v35;
        a2[11] = v35;
        *a4 = 1;
      }

      else
      {
        unint64_t v27 = a2[11];
      }
    }

    if (a2[9] < v27) {
      unint64_t v27 = a2[9];
    }
    a3[1] += v27;
  }

  return v13;
}

uint64_t sub_10004A57C(uint64_t a1, int a2, void *a3)
{
  *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uuid_string_t out = v6;
  *(_OWORD *)&out[16] = v6;
  uint64_t v7 = a3[5];
  if (v7) {
    uuid_copy(dst, (const unsigned __int8 *)(v7 + 240));
  }
  else {
    uuid_clear(dst);
  }
  uuid_unparse(dst, out);
  return sub_1000432C4(a1, a2, v8, v9, v10, v11, v12, v13, *a3);
}

char *sub_10004A634( char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_WORD *)result != 5)
  {
    sub_100040C68( "apfs object (oid 0x%llx): crypto major version (%u) is not CP_CURRENT (%u)\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 8));
    time_t result = sub_100044E7C((char *)0xC, -6);
  }

  if (*((_DWORD *)v9 + 1))
  {
    sub_100040C68( "apfs object (oid 0x%llx): cpflags (%u) should be 0\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 8));
    return sub_100044E7C((char *)0xD, -3);
  }

  return result;
}

unint64_t sub_10004A6C4( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5)
{
  unint64_t v5 = a2 + a1;
  unint64_t v6 = a4 + a3;
  if (a2 + a1 > a3)
  {
    BOOL v7 = v6 >= a1;
    BOOL v8 = v6 == a1;
  }

  else
  {
    BOOL v7 = 0;
    BOOL v8 = 0;
  }

  BOOL v9 = !v8 && v7 && v5 >= a1;
  if (!v9 || v6 < a3) {
    return 0LL;
  }
  if (a1 <= a3) {
    unint64_t v11 = a3;
  }
  else {
    unint64_t v11 = a1;
  }
  if (v5 >= v6) {
    unint64_t v5 = a4 + a3;
  }
  if (a5) {
    *a5 = v11;
  }
  return v5 - v11;
}

uint64_t sub_10004A708(unint64_t a1)
{
  if (a1 > 0x8AC7230489E7FFFFLL) {
    return 19LL;
  }
  if (a1 > 0xDE0B6B3A763FFFFLL) {
    return 18LL;
  }
  if (a1 > 0x16345785D89FFFFLL) {
    return 17LL;
  }
  if (a1 > 0x2386F26FC0FFFFLL) {
    return 16LL;
  }
  if (a1 > 0x38D7EA4C67FFFLL) {
    return 15LL;
  }
  if (a1 > 0x5AF3107A3FFFLL) {
    return 14LL;
  }
  if (a1 > 0x9184E729FFFLL) {
    return 13LL;
  }
  if (a1 > 0xE8D4A50FFFLL) {
    return 12LL;
  }
  if (a1 > 0x174876E7FFLL) {
    return 11LL;
  }
  if (a1 > 0x2540BE3FFLL) {
    return 10LL;
  }
  if (a1 > 0x3B9AC9FF) {
    return 9LL;
  }
  if (a1 > 0x5F5E0FF) {
    return 8LL;
  }
  if (a1 > 0x98967F) {
    return 7LL;
  }
  if (a1 > 0xF423F) {
    return 6LL;
  }
  if (a1 >> 5 > 0xC34) {
    return 5LL;
  }
  if (a1 >> 4 > 0x270) {
    return 4LL;
  }
  if (a1 > 0x3E7) {
    return 3LL;
  }
  if (a1 <= 0x63) {
    return a1 > 9;
  }
  return 2LL;
}

uint64_t sub_10004A8D8(uint64_t result)
{
  if ((_DWORD)result)
  {
    int v1 = result;
    if ((result & 0x3FFF | 0xC000) == (_DWORD)result)
    {
      return result & 0x3FFF;
    }

    else if (result >= 0x6B)
    {
      time_t result = 6LL;
      if (v1 <= -536870175)
      {
        switch(v1)
        {
          case -536870195:
LABEL_14:
            time_t result = 13LL;
            break;
          case -536870194:
          case -536870192:
          case -536870191:
          case -536870189:
          case -536870188:
          case -536870186:
          case -536870185:
          case -536870184:
          case -536870182:
            return 94LL;
          case -536870193:
            time_t result = 30LL;
            break;
          case -536870190:
          case -536870187:
            time_t result = 16LL;
            break;
          case -536870183:
            return result;
          case -536870181:
            time_t result = 28LL;
            break;
          default:
            switch(v1)
            {
              case -536870211:
                time_t result = 12LL;
                break;
              case -536870210:
              case -536870209:
                return 94LL;
              case -536870208:
                return result;
              case -536870207:
                goto LABEL_14;
              case -536870206:
                time_t result = 22LL;
                break;
              default:
                if (v1 != -536870198) {
                  return 94LL;
                }
                time_t result = 5LL;
                break;
            }

            break;
        }
      }

      else if (v1 != -536870167 && v1 != -536870172)
      {
        if (v1 == -536870174) {
          return 1LL;
        }
        else {
          return 94LL;
        }
      }
    }
  }

  return result;
}

uint64_t sub_10004A9FC(const void *a1, CC_LONG a2)
{
  *(_OWORD *)md = 0u;
  __int128 v8 = 0u;
  *(void *)&v6.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v6.wbuf[6] = v4;
  *(_OWORD *)&v6.wbuf[10] = v4;
  *(_OWORD *)&v6.hash[6] = v4;
  *(_OWORD *)&v6.wbuf[2] = v4;
  *(_OWORD *)v6.count = v4;
  *(_OWORD *)&v6.hash[2] = v4;
  CC_SHA256_Init(&v6);
  CC_SHA256_Update(&v6, a1, a2);
  CC_SHA256_Final(md, &v6);
  return *((void *)&v8 + 1) & 0x1FFFFFFFFFFFFFLL;
}

void sub_10004AA9C()
{
  __assert_rtn("fsckPrintString", "fsck_messages.c", 733, "(void *)m->msg == (void *)fmt");
}

void sub_10004AAC4()
{
  __assert_rtn("fsckPrintXML", "fsck_messages.c", 864, "(void *)fmt == (void *)m->msg");
}

void sub_10004AAEC()
{
  __assert_rtn("fsckPrintGUI", "fsck_messages.c", 972, "(void *)fmt == (void *)m->msg");
}

void sub_10004AB14()
{
  __assert_rtn("fsckPrint", "fsck_messages.c", 1067, "msg != NULL");
}