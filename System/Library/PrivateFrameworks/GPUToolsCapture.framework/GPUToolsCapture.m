CFStringRef _StringForError(uint64_t a1)
{
  CFStringRef result;
  uint64_t v2;
  uint64_t v3;
  if (a1 <= 511)
  {
    switch(a1)
    {
      case 1LL:
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid filename (%ld)",  1LL);
      case 2LL:
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"data is too large (%ld)",  2LL);
      case 3LL:
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"IO failure (%ld)",  3LL);
      case 4LL:
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"out of memory (%ld)",  4LL);
      case 5LL:
        v3 = 5LL;
        goto LABEL_64;
      case 6LL:
        v3 = 6LL;
LABEL_64:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Unable to connect to the device. (%ld)",  v3);
        break;
      case 7LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"read-only capture archive (%ld)",  7LL);
        break;
      case 8LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"truncated capture archive store (%ld)",  8LL);
        break;
      case 9LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"truncated capture archive index (%ld)",  9LL);
        break;
      case 10LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid capture archive index (%ld)",  10LL);
        break;
      case 11LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"unknown capture archive index version (%ld)",  11LL);
        break;
      case 12LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"file exists in capture archive (%ld)",  12LL);
        break;
      case 13LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"file does not exists in capture archive (%ld)",  13LL);
        break;
      case 14LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"capture archive does not exist (%ld)",  14LL);
        break;
      case 15LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"missing capture archive index (%ld)",  15LL);
        break;
      case 16LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid capture archive metadata (%ld)",  16LL);
        break;
      case 17LL:
      case 27LL:
        return 0LL;
      case 18LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"corrupted capture archive store (%ld)",  18LL);
        break;
      case 19LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"could not write capture archive metadata (%ld)",  19LL);
        break;
      case 20LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"capture archive has been closed (%ld)",  20LL);
        break;
      case 21LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"already tried to launch guest app (%ld)",  21LL);
        break;
      case 22LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid launch dictionary (%ld)",  22LL);
        break;
      case 23LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app not found (%ld)",  23LL);
        break;
      case 24LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app launch timed out (%ld)",  24LL);
        break;
      case 25LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid guest app session (%ld)",  25LL);
        break;
      case 26LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app has not been launched yet (%ld)",  26LL);
        break;
      case 28LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"did not find interpose dylib (%ld)",  28LL);
        break;
      case 29LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"failed to launch guest app (%ld)",  29LL);
        break;
      case 30LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app terminated (%ld)",  30LL);
        break;
      case 31LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"lost transport connection (%ld)",  31LL);
        break;
      case 32LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid transport (%ld)",  32LL);
        break;
      case 33LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"transport is not connected (%ld)",  33LL);
        break;
      case 34LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"message has already been sent (%ld)",  34LL);
        break;
      case 35LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"in-reply-to message has not been sent (%ld)",  35LL);
        break;
      case 36LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"failed to encode message attributes (%ld)",  36LL);
        break;
      case 37LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"connect timed out (%ld)",  37LL);
        break;
      case 38LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"undefined socket path (%ld)",  38LL);
        break;
      case 39LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"socket path is too long (%ld)",  39LL);
        break;
      case 40LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"message originated from this transport (%ld)",  40LL);
        break;
      case 41LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"initialized function stream with immutable data but swapping is required (%ld)",  41LL);
        break;
      case 42LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"transfer refused (%ld)",  42LL);
        break;
      case 43LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"protocol error (%ld)",  43LL);
        break;
      case 44LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"path outside destination root (%ld)",  44LL);
        break;
      case 45LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"transfer aborted (%ld)",  45LL);
        break;
      case 46LL:
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"unknown item type (%ld)",  46LL);
        break;
      default:
        switch(a1)
        {
          case 256LL:
            result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid socket descriptor (%ld)",  256LL);
            break;
          case 257LL:
            result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid socket url (%ld)",  257LL);
            break;
          case 258LL:
            result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"transport source cancelled (%ld)",  258LL);
            break;
          case 259LL:
            result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"corrupt transport message header (%ld)",  259LL);
            break;
          case 260LL:
            result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"corrupt transport message attributes (%ld)",  260LL);
            break;
          case 261LL:
            result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"message too large (%ld)",  261LL);
            break;
          default:
            return 0LL;
        }

        break;
    }

    return result;
  }

  if (a1 <= 2047)
  {
    if (a1 <= 1023)
    {
      v2 = a1 - 512;
      result = @"Device connection lost.";
      switch(v2)
      {
        case 0LL:
          result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app crashed (%ld)",  512LL);
          break;
        case 1LL:
          result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"another capture session is active (%ld)",  513LL);
          break;
        case 2LL:
          result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"capture session is already active (%ld)",  514LL);
          break;
        case 3LL:
          result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"capture session activation failed (%ld)",  515LL);
          break;
        case 4LL:
          result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"inferior already running (%ld)",  516LL);
          break;
        case 5LL:
          result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"GL dispatch table mismatch (%ld)",  517LL);
          break;
        case 6LL:
          result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"inferior and host session ids mismatch (%ld)",  518LL);
          break;
        case 7LL:
          return result;
        default:
          return 0LL;
      }

      return result;
    }

    if (a1 <= 1279)
    {
      switch(a1)
      {
        case 1024LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"truncated data (%ld)",  1024LL);
        case 1025LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid transport message payload (%ld)",  1025LL);
        case 1026LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"unexpected transport message (%ld)",  1026LL);
      }
    }

    else if (a1 > 1791)
    {
      if (a1 == 1792) {
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"no data (%ld)",  1792LL);
      }
      if (a1 == 1793) {
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app session error (%ld)",  1793LL);
      }
    }

    else
    {
      if (a1 == 1280) {
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid function stream header (%ld)",  1280LL);
      }
      if (a1 == 1536) {
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"position does not exist in archive (%ld)",  1536LL);
      }
    }

    return 0LL;
  }

  if (a1 <= 4351)
  {
    if (a1 > 2304)
    {
      switch(a1)
      {
        case 2305LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"no archive data (%ld)",  2305LL);
        case 2306LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"no thumbnail support (%ld)",  2306LL);
        case 4096LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"failed to create core symbolicator (%ld)",  4096LL);
      }
    }

    else
    {
      switch(a1)
      {
        case 2048LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"already replaying (%ld)",  2048LL);
        case 2049LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"no loaded archives (%ld)",  2049LL);
        case 2304LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"no resource streamer (%ld)",  2304LL);
      }
    }

    return 0LL;
  }

  switch(a1)
  {
    case 4608LL:
      result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Cannot find the specified username and host (%ld)",  4608LL);
      break;
    case 4609LL:
      result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Specified remote machine is not available. Please make sure to login with specified user (%ld)",  4609LL);
      break;
    case 4610LL:
      result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Cannot find the target path provided (%ld)",  4610LL);
      break;
    case 4611LL:
      result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Cannot authenticate SSH, make sure the authentication is done right (%ld)",  4611LL);
      break;
    case 4612LL:
      result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Cannot find Xcode.app on the remote machine. Please make sure that Xcode.app is in the Applications folder (%ld)",  4612LL);
      break;
    case 4613LL:
      result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Metal.framework is not available on the remote machine (%ld)",  4613LL);
      break;
    case 4614LL:
      result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Missing environment variables, please make sure all the required environment variables are enabled (%ld)",  4614LL);
      break;
    default:
      if (a1 == 4352)
      {
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Shader profiler failed due to an internal error (%ld)",  4352LL);
      }

      else
      {
        if (a1 != 4353) {
          return 0LL;
        }
        result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Shader profiler does not support multi-context captures (%ld)",  4353LL);
      }

      break;
  }

  return result;
}

void sub_21D4(_Unwind_Exception *a1)
{
  v3 = (void *)std::__hash_table<std::__hash_value_type<long long,objc_object  {objcproto8NSObject}*>,std::__unordered_map_hasher<long long,objc_object  {objcproto8NSObject}*,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,objc_object  {objcproto8NSObject}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto8NSObject}*>>::~__hash_table(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_24B0(_Unwind_Exception *a1)
{
}
}

void sub_278C(_Unwind_Exception *a1)
{
}

void *std::__hash_table<std::__hash_value_type<long long,objc_object {objcproto8NSObject}*>,std::__unordered_map_hasher<long long,objc_object {objcproto8NSObject}*,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,objc_object {objcproto8NSObject}*,std::equal_to,std::hash,true>,std::allocator<objc_object {objcproto8NSObject}*>>::find<long long>( void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0LL;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }

  else
  {
    unint64_t v4 = (*(void *)&v2 - 1LL) & a2;
  }

  v5 = *(void **)(*a1 + 8 * v4);
  if (!v5) {
    return 0LL;
  }
  result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2) {
          return result;
        }
      }

      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(void *)&v2) {
            v7 %= *(void *)&v2;
          }
        }

        else
        {
          v7 &= *(void *)&v2 - 1LL;
        }

        if (v7 != v4) {
          return 0LL;
        }
      }

      result = (void *)*result;
    }

    while (result);
  }

  return result;
}

void std::__hash_table<std::__hash_value_type<long long,objc_object {objcproto8NSObject}*>,std::__unordered_map_hasher<long long,objc_object {objcproto8NSObject}*,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,objc_object {objcproto8NSObject}*,std::equal_to,std::hash,true>,std::allocator<objc_object {objcproto8NSObject}*>>::__rehash<true>( uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2LL;
  }

  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }

  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }

    else
    {
      uint64_t v13 = 1LL << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }

    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      v16 = *(void **)a1;
      *(void *)a1 = 0LL;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0LL;
      return;
    }
  }

  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  v5 = operator new(8 * prime);
  v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0LL;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0LL;
  while (prime != v7);
  v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }

    else
    {
      v9 &= prime - 1;
    }

    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }

        else
        {
          v15 &= prime - 1;
        }

        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }

          void *v8 = *v14;
          void *v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          v14 = v8;
        }

        size_t v15 = v9;
LABEL_31:
        v8 = v14;
        v14 = (void *)*v14;
        size_t v9 = v15;
      }

      while (v14);
    }
  }

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

uint64_t std::__hash_table<std::__hash_value_type<long long,objc_object  {objcproto8NSObject}*>,std::__unordered_map_hasher<long long,objc_object  {objcproto8NSObject}*,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,objc_object  {objcproto8NSObject}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto8NSObject}*>>::~__hash_table( uint64_t a1)
{
  int8x8_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint8x8_t v3 = (void *)*v2;
      operator delete(v2);
      int8x8_t v2 = v3;
    }

    while (v3);
  }

  int8x8_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

LABEL_16:
      abort();
    }

    uint8x8_t v10 = __stderrp;
    unint64_t v11 = @"fail: queue cannot be NULL";
LABEL_15:
    fprintf( v10,  "%s\n",  -[NSString UTF8String]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", v11, a4),  "UTF8String"));
    goto LABEL_16;
  }

  if (!a4)
  {
    if (s_logUsingOsLog)
    {
      v8 = (os_log_s *)gt_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        size_t v9 = "fail: block cannot be NULL";
LABEL_12:
        _os_log_fault_impl(&dword_0, v8, OS_LOG_TYPE_FAULT, v9, buf, 2u);
        abort();
      }

      goto LABEL_16;
    }

    uint8x8_t v10 = __stderrp;
    unint64_t v11 = @"fail: block cannot be NULL";
    goto LABEL_15;
  }

  v12.receiver = self;
  v12.super_class = (Class)&OBJC_CLASS___GTContinuation_capture;
  v6 = -[GTContinuation_capture init](&v12, "init");
  if (v6)
  {
    dispatch_retain((dispatch_object_t)a3);
    v6->queue = (OS_dispatch_queue *)a3;
    v6->block = [a4 copy];
  }

  return v6;
}

      abort();
    }

    size_t v15 = __stderrp;
    v16 = @"fail: queue cannot be NULL";
LABEL_15:
    fprintf( v15,  "%s\n",  -[NSString UTF8String]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", v16, a4),  "UTF8String"));
    goto LABEL_16;
  }

  if (!a4)
  {
    if (s_logUsingOsLog)
    {
      uint64_t v13 = (os_log_s *)gt_default_log();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        v14 = "fail: transport cannot be nil";
LABEL_12:
        _os_log_fault_impl(&dword_0, v13, OS_LOG_TYPE_FAULT, v14, buf, 2u);
        abort();
      }

      goto LABEL_16;
    }

    size_t v15 = __stderrp;
    v16 = @"fail: transport cannot be nil";
    goto LABEL_15;
  }

  v18.receiver = self;
  v18.super_class = (Class)&OBJC_CLASS___GTTransportSource_capture;
  v6 = -[GTTransportSource_capture init](&v18, "init");
  if (v6)
  {
    v6->_transport = (GTTransport_capture *)a4;
    uint64_t v7 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"gputools.%@.%p.%@",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", object_getClassName(v6)),  v6,  @"manager"),  "UTF8String");
    v8 = dispatch_queue_create_with_target_V2(v7, 0LL, (dispatch_queue_t)a3);
    v6->_queue = (OS_dispatch_queue *)v8;
    dispatch_suspend(v8);
    size_t v9 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"gputools.%@.%p.%@",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", object_getClassName(v6)),  v6,  @"message"),  "UTF8String");
    uint8x8_t v10 = dispatch_queue_create_with_target_V2(v9, 0LL, (dispatch_queue_t)a3);
    v6->_mqueue = (OS_dispatch_queue *)v10;
    dispatch_suspend(v10);
    queue = (dispatch_queue_s *)v6->_queue;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = __46__GTTransportSource__initWithQueue_transport___block_invoke;
    block[3] = &unk_20E0C8;
    block[4] = v6;
    dispatch_async(queue, block);
  }

  return v6;
}

    LOBYTE(v7) = 0;
    return v7;
  }

  uint64_t v7 = -[GTTransport_capture _packMessage:error:](self, "_packMessage:error:", a3, a4);
  if (v7)
  {
    isa = self[1].super.isa;
    size_t v9 = BYTE1(self->_interposerVersion);
    if (v9) {
      dispatch_suspend((dispatch_object_t)self->_queue);
    }
    sendQueue = self->_sendQueue;
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472LL;
    v14[2] = __34__GTTransport_relayMessage_error___block_invoke;
    v14[3] = &unk_20D430;
    size_t v15 = v9;
    v14[4] = self;
    v14[5] = a3;
    ((void (*)(OS_dispatch_queue *, void *))isa)(sendQueue, v14);
    LOBYTE(v7) = 1;
  }

  return v7;
}

  v22 = v38;
  *(_DWORD *)(v38 + 8) = -15991;
  v23 = v41;
  if (v41 > 0x28uLL)
  {
    v25 = *(void *)(v37 + 24);
    v26 = v42++;
    v24 = GTTraceMemPool_allocateBytes(v25, v39, v26 | 0x1800000000LL) + 16;
    v23 = v26;
  }

  else
  {
    v24 = (char *)(v22 + v41);
    v41 += 24;
  }

  *(_BYTE *)(v22 + 13) = v23;
  v27 = -[CaptureMTLCommandBuffer traceStream](self, "traceStream");
  if (v27) {
    var0 = v27->var0;
  }
  else {
    var0 = 0LL;
  }
  v29 = (uint64_t *)[v6 traceStream];
  if (v29) {
    v30 = *v29;
  }
  else {
    v30 = 0LL;
  }
  *(void *)v24 = var0;
  *((void *)v24 + 1) = v30;
  *((void *)v24 + 2) = a4;
  s();
  *(void *)v31 = v32;
  *(_BYTE *)(v31 + 8) = v40;
  *(_BYTE *)(v38 + 15) |= 8u;
}

  if ((*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) == 2)
  {
    v17 = location;
    v18 = GTTraceContext_pushEncoderWithStream((uint64_t)v7->_traceContext, (uint64_t)v45);
    baseObject = v7->_baseObject;
    v20 = 8 * length;
    __chkstk_darwin(v18, v21);
    if (length)
    {
      v22 = (void **)v6;
      v23 = &v45[-((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
      v24 = length;
      do
      {
        v25 = *v22++;
        *(void *)v23 = [v25 baseObject];
        v23 += 8;
        --v24;
      }

      while (v24);
    }

    -[MTLVisibleFunctionTableSPI setFunctions:withRange:]( baseObject,  "setFunctions:withRange:",  &v45[-((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8],  v17,  length);
    v26 = v47;
    *(_DWORD *)(v47 + 8) = -15597;
    v27 = v50;
    if (v50 > 0x20uLL)
    {
      v36 = *(void *)(v46 + 24);
      v37 = v51++;
      v28 = GTTraceMemPool_allocateBytes(v36, v48, v37 | 0x2000000000LL) + 16;
      v27 = v37;
    }

    else
    {
      v28 = (char *)(v26 + v50);
      v50 += 32;
    }

    *(_BYTE *)(v26 + 13) = v27;
    v38 = -[CaptureMTLVisibleFunctionTable traceStream](v7, "traceStream");
    if (v38) {
      var0 = v38->var0;
    }
    else {
      var0 = 0LL;
    }
    if ((*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) == 2)
    {
      __chkstk_darwin(v38, v39);
      v41 = StreamArrayURL((uint64_t)v45, &v45[-((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8], (id *)v6, length);
    }

    else
    {
      v41 = 0;
    }

    *(void *)v28 = var0;
    *((void *)v28 + 1) = v17;
    *((void *)v28 + 2) = length;
    v28[24] = v41;
    *(_DWORD *)(v28 + 25) = 0;
    *((_DWORD *)v28 + 7) = 0;
    s();
    *(void *)v42 = v43;
    *(_BYTE *)(v42 + 8) = v49;
    *(_BYTE *)(v47 + 15) |= 8u;
  }

  else
  {
    v29 = v7->_baseObject;
    __chkstk_darwin(self, a2);
    v31 = (v30 + 15) & 0xFFFFFFFFFFFFFFF0LL;
    v32 = &v45[-v31 - 8];
    if (length)
    {
      v33 = &v45[-v31 - 8];
      v34 = length;
      do
      {
        v35 = (id)*v6++;
        *(void *)v33 = [v35 baseObject];
        v33 += 8;
        --v34;
      }

      while (v34);
    }

    -[MTLVisibleFunctionTableSPI setFunctions:withRange:](v29, "setFunctions:withRange:", v32, location, length);
  }

  atomic_store(2u, (unsigned int *)(a1 + 104));
  GTTraceContext_filterDispatchArray((uint64_t)v12);
  *(void *)(v11 + 24) = apr_hash_make(v9);
  v20 = *(void *)(v11 + 16);
  *(void *)(v20 + 24) = 0LL;
  *(void *)(v20 + 32) = 0LL;
  *(void *)(v20 + 16) = v20;
  *(_DWORD *)(v20 + 40) = 0;
  v21 = apr_hash_next((apr_hash_index_t *)(v20 + 16));
  if (v21)
  {
    v22 = v21;
    do
    {
      GTTraceMemPool_buildMemoryMap( *(void *)(*(void *)(*((void *)v22 + 1) + 32LL) + 24LL),  *(apr_hash_t **)(v11 + 24));
      v22 = apr_hash_next(v22);
    }

    while (v22);
  }

  v24 = *(void *)(v11 + 16);
  v23 = *(void *)(v11 + 24);
  v102 = a2;
  v103 = v11;
  v101 = a3;
  if (v12->nelts >= 1)
  {
    v25 = 0LL;
    do
    {
      if (v25 >= 8) {
        v26 = 8LL;
      }
      else {
        v26 = v25;
      }
      v27 = &v12->elts[64 * v25];
      if (*((_DWORD *)v27 + 2) == -7161)
      {
        v28 = v25 >= 8 ? 8 : v25;
        FuncStreamRef = GTTraceFunc_getFuncStreamRef((uint64_t)&v12->elts[64 * v25], v23);
        elts = v12->elts;
        *(void *)buf = FuncStreamRef;
        entry = find_entry(v24, buf, 8uLL, 0LL);
        if (v28)
        {
          v32 = v26 + 1;
          v33 = &elts[64 * (uint64_t)((int)v25 - v28)];
          v34 = *(void *)(*(void *)(*entry + 32LL) + 8LL);
          while (1)
          {
            v35 = &v33[64 * (unint64_t)(v32 - 2)];
            if (*((_DWORD *)v35 + 2) == -7166)
            {
              *(void *)buf = GTTraceFunc_getFuncStreamRef( (uint64_t)&v33[64 * (unint64_t)(v32 - 2)],  v23);
              if (*(void *)(*(void *)(*find_entry(v24, buf, 8uLL, 0LL) + 32LL) + 8LL) == v34) {
                break;
              }
            }
          }

          *(_OWORD *)buf = *(_OWORD *)v35;
          v108 = *((_OWORD *)v35 + 1);
          v109 = *((_OWORD *)v35 + 2);
          v110 = *((_OWORD *)v35 + 3);
          memmove( &v33[64 * (unint64_t)(v32 - 2)],  v35 + 64,  ((v27 - v35) << 26 >> 26) & 0xFFFFFFFFFFFFFFC0LL);
          *(_OWORD *)v27 = *(_OWORD *)buf;
          *((_OWORD *)v27 + 1) = v108;
          *((_OWORD *)v27 + 2) = v109;
          *((_OWORD *)v27 + 3) = v110;
        }
      }

void sub_4FF8(_Unwind_Exception *exception_object)
{
}

void sub_5030(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    if (a2 == 2)
    {
      *(void *)(v2 + 40) = 0LL;
      objc_end_catch();
    }

    JUMPOUT(0x4F8CLL);
  }

  JUMPOUT(0x5020LL);
}

void __clang_call_terminate(void *a1)
{
}

void sub_60B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

LABEL_36:
    LOBYTE(v15) = 0;
    return v15;
  }

  size_t v15 = -[GTTransport_capture _packMessage:error:](self, "_packMessage:error:", a3, a5);
  if (v15)
  {
    v16 = -[GTTransport_capture _nextMessageSerial](self, "_nextMessageSerial");
    if (a4) {
      v17 = (uint64_t)[a4 serial];
    }
    else {
      v17 = 0xFFFFFFFFLL;
    }
    [a3 _setSerial:v16 replySerial:v17 transport:self];
    if (a8)
    {
      v18 = -[GTContinuation_capture initWithQueue:block:]( objc_alloc(&OBJC_CLASS___GTTransportMessageReplyContinuation_capture),  "initWithQueue:block:",  a6,  a8);
      v19 = v18;
      p_invalid = &self->_invalid;
      do
        v21 = __ldaxr((unsigned int *)p_invalid);
      while (__stlxr(v21 + 1, (unsigned int *)p_invalid));
      isa = self[1].super.isa;
      v23 = BYTE1(self->_interposerVersion);
      if (v18)
      {
        if (a7)
        {
          v18->timeout = a7;
          v24 = dispatch_time(0LL, a7);
          queue = (dispatch_queue_s *)self->_queue;
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = __63__GTTransport_send_inReplyTo_error_replyQueue_timeout_handler___block_invoke;
          block[3] = &unk_20D340;
          block[4] = self;
          v40 = v16;
          dispatch_after(v24, queue, block);
        }

        v26 = (dispatch_queue_s *)self->_queue;
        v37[0] = _NSConcreteStackBlock;
        v37[1] = 3221225472LL;
        v37[2] = __63__GTTransport_send_inReplyTo_error_replyQueue_timeout_handler___block_invoke_2;
        v37[3] = &unk_20D3B8;
        v37[4] = self;
        v37[5] = v19;
        v38 = v16;
        dispatch_sync(v26, v37);
        if (!v23) {
          goto LABEL_24;
        }
      }

      else if (!BYTE1(self->_interposerVersion))
      {
LABEL_24:
        v29 = 0;
        goto LABEL_25;
      }
    }

    else
    {
      v27 = &self->_invalid;
      do
        v28 = __ldaxr((unsigned int *)v27);
      while (__stlxr(v28 + 1, (unsigned int *)v27));
      v19 = 0LL;
      isa = self[1].super.isa;
      v29 = BYTE1(self->_interposerVersion);
      if (!v29) {
        goto LABEL_25;
      }
    }

    dispatch_suspend((dispatch_object_t)self->_queue);
    v29 = 1;
LABEL_25:
    sendQueue = self->_sendQueue;
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472LL;
    v34[2] = __63__GTTransport_send_inReplyTo_error_replyQueue_timeout_handler___block_invoke_3;
    v34[3] = &unk_20D408;
    v36 = v29;
    v34[4] = self;
    v34[5] = v19;
    v34[6] = a3;
    v35 = v16;
    ((void (*)(OS_dispatch_queue *, void *))isa)(sendQueue, v34);

    LOBYTE(v15) = 1;
  }

  return v15;
}

    apr_hash_set(v7, v9 + 1, 8LL, v9);
  }

  return v9;
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_73A0(_Unwind_Exception *a1)
{
}

void sub_7458(_Unwind_Exception *a1)
{
}

uint64_t GPUTools::VMBuffer::resize(GPUTools::VMBuffer *this, vm_size_t a2)
{
  vm_address_t v3 = *(void *)this;
  vm_size_t v4 = *((void *)this + 1);
  uint64_t v5 = *((void *)this + 2);
  uint64_t result = GPUTools::VMBuffer::_alloc(this, a2, v5);
  if ((_DWORD)result)
  {
    if (v4 >= *((void *)this + 1)) {
      vm_size_t v7 = *((void *)this + 1);
    }
    else {
      vm_size_t v7 = v4;
    }
    if (vm_copy(mach_task_self_, v3, v7, *(void *)this))
    {
      GPUTools::VMBuffer::_dealloc((vm_address_t *)this);
      return 0LL;
    }

    else
    {
      vm_deallocate(mach_task_self_, v3, vm_page_size + v4 + v4 * v5);
      return 1LL;
    }
  }

  return result;
}

uint64_t GPUTools::VMBuffer::_alloc(GPUTools::VMBuffer *this, vm_size_t a2, uint64_t a3)
{
  int v3 = 0;
  vm_address_t address = 0LL;
  if (3 * vm_page_size <= a2) {
    vm_size_t v4 = (a2 + vm_page_size - 1) & -(uint64_t)vm_page_size;
  }
  else {
    vm_size_t v4 = 3 * vm_page_size;
  }
  vm_size_t v5 = v4 + v4 * a3;
  while (1)
  {
    vm_map_t v6 = mach_task_self_;
    vm_size_t v7 = vm_page_size + v5;
    if (!vm_allocate(mach_task_self_, &address, vm_page_size + v5, 1))
    {
      vm_address_t v8 = address;
      vm_address_t v9 = address + v4;
      target_vm_address_t address = address + v4;
      uint64_t v10 = a3;
      if (a3)
      {
        while (!vm_deallocate(v6, v9, v4)
             && !vm_remap(v6, &target_address, v4, 0LL, 0, v6, address, 0, &cur_protection, &v15, 2u))
        {
          vm_address_t v9 = target_address + v4;
          target_address += v4;
          if (!--v10)
          {
            vm_address_t v8 = address;
            goto LABEL_11;
          }
        }

        goto LABEL_12;
      }

LABEL_11:
      if (!vm_protect(v6, v8 + v7 - vm_page_size, vm_page_size, 0, 0)) {
        break;
      }
    }

  v14 = v11 | (unint64_t)(v13 << 32);
LABEL_12:
  vm_prot_t v15 = v10 + 64;
  while (v10 && (*(_BYTE *)(v15 + ((uint64_t)(HIDWORD(v14) - (int)v14) << 6) + 15) & 8) != 0)
  {
    v16 = (__int128 *)(v15 + ((uint64_t)(HIDWORD(v14) - (int)v14) << 6));
    v17 = apr_array_push(a3);
    v18 = v16[3];
    v20 = *v16;
    v19 = v16[1];
    v17[2] = v16[2];
    v17[3] = v18;
    *v17 = v20;
    v17[1] = v19;
    FuncEnumConstructorType = GetFuncEnumConstructorType(*((_DWORD *)v16 + 2));
    if (IsCommandEncoder(FuncEnumConstructorType))
    {
      bzero(v25, 0x2B90uLL);
      GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v25, (uint64_t *)v16, a2);
      WriteCommandEncoder(a1, a2, a3, v25[1]);
    }

    v22 = atomic_load((unsigned int *)(v10 + 4));
    v23 = v14 + (v22 >> 6);
    v24 = (HIDWORD(v14) + 1);
    v14 = (v24 << 32) | v14;
    if ((_DWORD)v24 == v23 - 1)
    {
      v14 = (v24 << 32) | v24;
      uint64_t v10 = *(void *)(v10 + 40);
      goto LABEL_12;
    }
  }

  if (GetFuncEnumConstructorType(*(_DWORD *)(*(void *)(v8 + 32) + 72LL)) == 17) {
    qsort( &a3->elts[a3->elt_size * (uint64_t)(int)nelts],  a3->nelts - nelts,  a3->elt_size,  (int (__cdecl *)(const void *, const void *))CompareGTTraceFunc);
  }
}

    uint64_t v10 = (unsigned int *)(v2 + 20);
    *(_BYTE *)(v2 + 97) = 1;
LABEL_16:
    atomic_store(4u, v10);
    goto LABEL_17;
  }

  if (v4 == 9) {
    goto LABEL_11;
  }
  if (v4 != 3)
  {
LABEL_13:
    if (v3 != *(_DWORD *)(v2 + 88)) {
      goto LABEL_24;
    }
    if (v4 != 8) {
      goto LABEL_24;
    }
    uint64_t v10 = (unsigned int *)(v2 + 20);
    goto LABEL_16;
  }

  *(_BYTE *)(v2 + 96) = 1;
LABEL_7:
  vm_size_t v7 = g_guestAppClientMTL;
  vm_address_t v8 = (unint64_t *)(g_guestAppClientMTL + 64);
  do
    vm_address_t v9 = __ldaxr(v8);
  while (__stlxr(v9 + 1, v8));
  if ((*(_BYTE *)(v7 + 48) & 1) != 0) {
    GTMTLGuestAppClient_collectFrameProfilingData(v7, v9);
  }
LABEL_24:
  v16 = (unsigned int *)(v2 + 20);
  v17 = atomic_load((unsigned int *)(v2 + 20));
  v18 = *(void *)(v2 + 8LL * v17 + 32);
  *(_DWORD *)buf = v193;
  *(_DWORD *)&buf[4] = v4;
  *(void *)&buf[8] = v195;
  *(void *)&buf[16] = v201;
  *(void *)&buf[24] = v206;
  *(void *)&buf[32] = v202;
  *(void *)&buf[40] = v204;
  *(void *)&buf[48] = v5;
  *(void *)&buf[56] = v203;
  *(void *)&v221 = v205;
  BYTE8(v221) = v198;
  *(_DWORD *)((char *)&v221 + 9) = *(_DWORD *)v214;
  HIDWORD(v221) = *(_DWORD *)&v214[3];
  *(void *)&v222 = v6;
  if (GTCapturePhase_checkTrigger(v18, (int *)buf))
  {
    v19 = atomic_load(v16);
    if (v19 == 1)
    {
      v20 = 0LL;
      v21 = 0;
      v22 = 0;
      v23 = *(void *)(*(void *)(v2 + 40) + 8LL);
      v24 = *(unsigned int *)(v23 + 12);
      while ((unint64_t)(v24 & ~((int)v24 >> 31)) << 6 != v20)
      {
        v25 = *(_DWORD *)(*(void *)(v23 + 24) + v20 + 60);
        if (v25)
        {
          if (v25 == 1) {
            ++v22;
          }
        }

        else
        {
          ++v21;
        }

        v20 += 64LL;
      }

      if (v22 == 1 && v21 + 1 == (_DWORD)v24 && (int)v24 > 0)
      {
        v26 = 0LL;
        v27 = *(void *)(v23 + 24);
        v28 = (int *)(v27 + 4);
        while (1)
        {
          v29 = *v28;
          v28 += 16;
          if (v29 == 3) {
            break;
          }
          if (v24 == ++v26) {
            goto LABEL_50;
          }
        }

        if (*(_DWORD *)(v27 + (v26 << 6)) == 1)
        {
          for (i = 1LL; i != 5; ++i)
          {
            v31 = *(void *)(*(void *)(v2 + 8 * i + 32) + 8LL);
            v32 = *(unsigned int *)(v31 + 12);
            if ((int)v32 >= 1)
            {
              v33 = 0LL;
              v34 = *(void *)(v31 + 24);
              v35 = (int *)(v34 + 4);
              while (1)
              {
                v36 = *v35;
                v35 += 16;
                if (v36 == 3) {
                  break;
                }
                if (v32 == ++v33) {
                  goto LABEL_49;
                }
              }

              *(_DWORD *)(v34 + (v33 << 6)) = v193;
              if (v193 == 3) {
                *(void *)(v34 + (v33 << 6) + _Block_object_dispose(va, 8) = v5;
              }
            }

  if (*(void *)a1)
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLCounterSampleBufferDescriptor setLabel:](v4, "setLabel:", v14);
  }

  -[MTLCounterSampleBufferDescriptor setStorageMode:](v4, "setStorageMode:", *(unsigned __int8 *)(a1 + 44));
  -[MTLCounterSampleBufferDescriptor setSampleCount:](v4, "setSampleCount:", *(unsigned int *)(a1 + 40));

  return v4;
}

  std::mutex::unlock(v10);
}

    a2 = GTMTLSMContext_getObject(a1, v12, a3);
  }

  if (v9 != 22) {
    return result;
  }
LABEL_7:
  uint8x8_t v12 = a2[6];
  if (v12) {
    goto LABEL_11;
  }
  return result;
}

LABEL_12:
    vm_deallocate(mach_task_self_, address, vm_page_size + v5);
    if (++v3 == 5) {
      return 0LL;
    }
  }

  *(void *)this = address;
  *((void *)this + 1) = v4;
  *((void *)this + 2) = a3;
  return 1LL;
}

  if (*(_BYTE *)(a2 + 21))
  {
    *(void *)(result + 8_Block_object_dispose(va, 8) = v11;
    v11 += 8LL;
  }

  v14 = (v12 << 63 >> 63) & 0x28;
  if ((v12 & 2) != 0) {
    v14 = 56LL;
  }
  vm_prot_t v15 = 72LL;
  if ((v12 & 4) != 0) {
    v14 = 72LL;
  }
  if ((v12 & 8) != 0) {
    v14 = 80LL;
  }
  if ((v12 & 0x60) != 0) {
    v14 = 120LL;
  }
  if (v14 <= 0x48) {
    v16 = 72LL;
  }
  else {
    v16 = v14;
  }
  if ((v12 & 0x80) != 0) {
    v14 = v16;
  }
  if (v14 > 0x48) {
    vm_prot_t v15 = v14;
  }
  if ((v12 & 0x100) != 0) {
    v14 = v15;
  }
  *(void *)(result + 96) = v11;
  *(void *)(result + 104) = v11 + v14;
  return result;
}

  if ((*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) == 2)
  {
    GTTraceContext_pushEncoderWithStream((uint64_t)self->_traceContext, (uint64_t)v28);
    baseObject = self->_baseObject;
    v14 = (void *)objc_claimAutoreleasedReturnValue([v6 baseObject]);
    -[MTLVisibleFunctionTableSPI setFunction:atIndex:](baseObject, "setFunction:atIndex:", v14, a4);

    vm_prot_t v15 = v29;
    *(_DWORD *)(v29 + _Block_object_dispose(va, 8) = -15598;
    v16 = v32;
    if (v32 > 0x28uLL)
    {
      v20 = *(void *)(v28[1] + 24LL);
      v21 = v33++;
      v17 = GTTraceMemPool_allocateBytes(v20, v30, v21 | 0x1800000000LL) + 16;
      v16 = v21;
    }

    else
    {
      v17 = (char *)(v15 + v32);
      v32 += 24;
    }

    *(_BYTE *)(v15 + 13) = v16;
    v22 = -[CaptureMTLVisibleFunctionTable traceStream](self, "traceStream");
    if (v22) {
      var0 = v22->var0;
    }
    else {
      var0 = 0LL;
    }
    v24 = (uint64_t *)[v6 traceStream];
    if (v24) {
      v25 = *v24;
    }
    else {
      v25 = 0LL;
    }
    *(void *)v17 = var0;
    *((void *)v17 + 1) = v25;
    *((void *)v17 + 2) = a4;
    s();
    *(void *)v26 = v27;
    *(_BYTE *)(v26 + _Block_object_dispose(va, 8) = v31;
    *(_BYTE *)(v29 + 15) |= 8u;
  }

  else
  {
    v18 = self->_baseObject;
    v19 = (void *)objc_claimAutoreleasedReturnValue([v6 baseObject]);
    -[MTLVisibleFunctionTableSPI setFunction:atIndex:](v18, "setFunction:atIndex:", v19, a4);
  }
}

      ++v9;
    }

    while (v9 < *(int *)(a2 + 12));
  }

  v17 = *v11++;
  LODWORD(v16) = v17;
  v102[0] = v11;
  v16 = v16;
LABEL_15:
  v18 = &__src[502];
  do
  {
    v19 = *v11;
    v20 = v11[1];
    v21 = v11[2];
    v11 += 3;
    v102[0] = v11;
    if (a4)
    {
      *(_DWORD *)(v18 - 3) = v20;
      *((_BYTE *)v18 - 2) = v21;
      *((_BYTE *)v18 - 1) = v19;
      *v18 = 0;
    }

    v18 += 4;
    --v16;
  }

  while (v16);
LABEL_19:
  if ((a4 & 1) != 0) {
    memcpy(v101, __src, 0x2E8uLL);
  }
  v101[159] = *v11;
  v101[161] = v11[1];
  HIDWORD(v101[166]) = *((_DWORD *)v11 + 4);
  LOBYTE(v101[185]) = v11[3];
  BYTE1(v101[185]) = v11[4];
  BYTE5(v101[186]) = v11[5];
  WORD2(v101[167]) = v11[6];
  LOWORD(v101[169]) = v11[7];
  v22 = v11[8];
  v23 = v11 + 9;
  v102[0] = v23;
  if (v22)
  {
    v24 = &v101[93];
    do
    {
      MakeDYMTLRenderPipelineColorAttachmentDescriptor(v102, (uint64_t)v24, a4);
      v24 += 2;
      --v22;
    }

    while (v22);
    v23 = v102[0];
  }

  uint64_t result = strlen((const char *)v23);
  v102[0] = (void *)((char *)v23 + (result & 0xFFFFFFFFFFFFFFF8LL) + 8);
  v26 = *(unsigned __int8 *)v23;
  if (!*(_BYTE *)v23) {
    v23 = 0LL;
  }
  if (v26)
  {
    uint64_t result = strlen((const char *)v23);
    v27 = a3 + 52;
    v28 = a3[52];
    v29 = result + 1;
    if (result != -1LL)
    {
      v30 = (void *)a3[52];
      goto LABEL_32;
    }
  }

  else
  {
    v27 = a3 + 52;
    v28 = a3[52];
  }

  v29 = 0LL;
  v30 = 0LL;
LABEL_32:
  *v27 = v28 + v29;
  if (a4) {
    uint64_t result = (size_t)memcpy(v30, v23, v29);
  }
  v101[150] = v30;
  if (v9 > 6)
  {
    v31 = v102[0];
    BYTE5(v101[185]) = *v102[0];
    if (v9 >= 9)
    {
      BYTE1(v101[188]) = v102[0][1];
      v101[151] = v102[0][2];
      BYTE6(v101[187]) = v102[0][3];
      BYTE5(v101[187]) = v102[0][4];
      BYTE4(v101[187]) = v102[0][5];
      v32 = v102[0][6];
      v102[0] += 6;
      HIBYTE(v101[187]) = v32;
      LOBYTE(v101[188]) = v31[7];
      if (v9 >= 0x12)
      {
        v33 = v31[8];
        v34 = v31 + 9;
        if (v33)
        {
          v35 = (char *)&v101[180] + 7;
          do
          {
            if (a4) {
              *v35 = *v34;
            }
            ++v34;
            ++v35;
            --v33;
          }

          while (v33);
        }

        v38 = *v34;
        v36 = v34 + 1;
        v37 = v38;
        v102[0] = v36;
        if (v38)
        {
          v39 = (char *)&v101[169] + 2;
          do
          {
            v41 = *v36++;
            v40 = v41;
            v102[0] = v36;
            if (a4) {
              *v39 = v40;
            }
            ++v39;
            --v37;
          }

          while (v37);
        }

        if (v9 >= 0x17)
        {
          BYTE3(v101[187]) = *v36;
          if (v9 >= 0x20)
          {
            BYTE3(v101[188]) = v36[1];
            v42 = v36[2];
            v102[0] = v36 + 2;
            LODWORD(v101[166]) = v42;
            if (v9 >= 0x26)
            {
              v101[158] = v36[3];
              if (v9 != 38)
              {
                BYTE6(v101[185]) = v36[4];
                HIBYTE(v101[184]) = v36[5];
                LODWORD(v101[167]) = v36[6];
                HIDWORD(v101[165]) = v36[7];
                HIBYTE(v101[185]) = v36[8];
                BYTE1(v101[186]) = v36[9];
                BYTE2(v101[186]) = v36[10];
                BYTE3(v101[186]) = v36[11];
                BYTE2(v101[188]) = v36[12];
                BYTE6(v101[184]) = v36[13];
                BYTE4(v101[186]) = v36[14];
                BYTE2(v101[185]) = v36[15];
                if (v9 >= 0x29)
                {
                  v101[160] = v36[16];
                  if (v9 != 41)
                  {
                    v101[145] = v36[17];
                    v101[146] = v36[18];
                    BYTE6(v101[186]) = v36[19];
                    LOBYTE(v101[186]) = v36[20];
                    BYTE3(v101[185]) = v36[21];
                    BYTE4(v101[185]) = v36[22];
                    v43 = v36[23];
                    v44 = v36 + 24;
                    v45 = (uint64_t *)((char *)v36 + ((v43 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 192);
                    v102[0] = v45;
                    if (v43) {
                      v46 = (void *)a3[52];
                    }
                    else {
                      v46 = 0LL;
                    }
                    v47 = (char *)(a3[52] + v43);
                    a3[52] = v47;
                    if (a4)
                    {
                      if (v43) {
                        v48 = v44;
                      }
                      else {
                        v48 = 0LL;
                      }
                      uint64_t result = (size_t)memcpy(v46, v48, v43);
                      v47 = (char *)a3[52];
                    }

                    v101[143] = v46;
                    v101[144] = v43;
                    v51 = *v45;
                    v50 = v45 + 1;
                    v49 = v51;
                    v52 = (void *)((char *)v50 + ((v51 + 7) & 0xFFFFFFFFFFFFFFF8LL));
                    v102[0] = v52;
                    if (v51) {
                      v53 = v47;
                    }
                    else {
                      v53 = 0LL;
                    }
                    a3[52] = &v47[v49];
                    if (a4)
                    {
                      if (v49) {
                        v54 = v50;
                      }
                      else {
                        v54 = 0LL;
                      }
                      uint64_t result = (size_t)memcpy(v53, v54, v49);
                    }

                    v101[141] = v53;
                    v101[142] = v49;
                    if (v9 >= 0x33)
                    {
                      v57 = *v52;
                      v56 = v52 + 1;
                      v55 = v57;
                      v102[0] = v56;
                      v101[164] = v57;
                      if (v57)
                      {
                        v58 = 0LL;
                        v59 = (uint64_t *)a3[50];
                        v101[163] = v59;
                        do
                        {
                          v61 = *v56++;
                          v60 = v61;
                          v102[0] = v56;
                          if (a4)
                          {
                            if (a5)
                            {
                              uint64_t result = GetStream_10858(a5, v60);
                              if (result) {
                                v60 = *(void *)result;
                              }
                              else {
                                v60 = 0LL;
                              }
                            }

                            v59 = (uint64_t *)a3[50];
                            *v59 = v60;
                            v55 = v101[164];
                          }

                          a3[50] = ++v59;
                          ++v58;
                        }

                        while (v55 > v58);
                      }

                      else
                      {
                        v101[163] = 0LL;
                      }

                      v62 = *v56;
                      v102[0] = v56 + 1;
                      v101[149] = v62;
                      if (v62)
                      {
                        v63 = 0LL;
                        v64 = (uint64_t *)a3[50];
                        v101[148] = v64;
                        v65 = v56 + 2;
                        do
                        {
                          v66 = *(v65 - 1);
                          v102[0] = v65;
                          if (a4)
                          {
                            if (a5)
                            {
                              uint64_t result = GetStream_10858(a5, v66);
                              if (result) {
                                v66 = *(void *)result;
                              }
                              else {
                                v66 = 0LL;
                              }
                            }

                            v64 = (uint64_t *)a3[50];
                            *v64 = v66;
                            v62 = v101[149];
                          }

                          ++v65;
                          a3[50] = ++v64;
                          ++v63;
                        }

                        while (v62 > v63);
                      }

                      else
                      {
                        v101[148] = 0LL;
                      }

                      if (v9 >= 0x37)
                      {
                        MakeDYMTLLinkedFunctions((size_t)v102, &v101[133], a3, a4, a5);
                        uint64_t result = MakeDYMTLLinkedFunctions((size_t)v102, &v101[109], a3, a4, a5);
                        if (v9 >= 0x3C)
                        {
                          v101[155] = *v102[0];
                          v101[152] = v102[0][1];
                          v67 = v102[0][2];
                          v68 = v102[0] + 3;
                          if (v67)
                          {
                            v69 = &v101[177];
                            do
                            {
                              if (a4) {
                                *v69 = *v68;
                              }
                              ++v68;
                              ++v69;
                              --v67;
                            }

                            while (v67);
                          }

                          v72 = *v68;
                          v71 = v68 + 1;
                          v70 = v72;
                          v102[0] = v71;
                          if (v72)
                          {
                            v73 = (char *)&v101[173] + 1;
                            do
                            {
                              v75 = *v71++;
                              v74 = v75;
                              v102[0] = v71;
                              if (a4) {
                                *v73 = v74;
                              }
                              ++v73;
                              --v70;
                            }

                            while (v70);
                          }

                          v78 = *v71;
                          v77 = v71 + 1;
                          v76 = v78;
                          v102[0] = v77;
                          v101[157] = v78;
                          if (v78)
                          {
                            v79 = 0LL;
                            v80 = (uint64_t *)a3[50];
                            v101[156] = v80;
                            do
                            {
                              v82 = *v77++;
                              v81 = v82;
                              v102[0] = v77;
                              if (a4)
                              {
                                if (a5)
                                {
                                  Stream_10858 = (uint64_t *)GetStream_10858(a5, v81);
                                  if (Stream_10858) {
                                    v81 = *Stream_10858;
                                  }
                                  else {
                                    v81 = 0LL;
                                  }
                                }

                                v80 = (uint64_t *)a3[50];
                                *v80 = v81;
                                v76 = v101[157];
                              }

                              a3[50] = ++v80;
                              ++v79;
                            }

                            while (v76 > v79);
                          }

                          else
                          {
                            v101[156] = 0LL;
                          }

                          v84 = *v77;
                          v102[0] = v77 + 1;
                          v101[154] = v84;
                          if (v84)
                          {
                            v85 = 0LL;
                            v86 = (uint64_t *)a3[50];
                            v101[153] = v86;
                            v87 = v77 + 2;
                            do
                            {
                              v88 = *(v87 - 1);
                              v102[0] = v87;
                              if (a4)
                              {
                                if (a5)
                                {
                                  v89 = (uint64_t *)GetStream_10858(a5, v88);
                                  if (v89) {
                                    v88 = *v89;
                                  }
                                  else {
                                    v88 = 0LL;
                                  }
                                }

                                v86 = (uint64_t *)a3[50];
                                *v86 = v88;
                                v84 = v101[154];
                              }

                              ++v87;
                              a3[50] = ++v86;
                              ++v85;
                            }

                            while (v84 > v85);
                          }

                          else
                          {
                            v101[153] = 0LL;
                          }

                          MakeDYMTLLinkedFunctions((size_t)v102, &v101[125], a3, a4, a5);
                          uint64_t result = MakeDYMTLLinkedFunctions((size_t)v102, &v101[117], a3, a4, a5);
                          if (v9 >= 0x42)
                          {
                            BYTE2(v101[187]) = *v102[0];
                            HIBYTE(v101[186]) = v102[0][1];
                            BYTE1(v101[187]) = v102[0][2];
                            LOBYTE(v101[187]) = v102[0][3];
                            if (v9 >= 0x44)
                            {
                              LODWORD(v101[165]) = v102[0][4];
                              if (v9 != 68)
                              {
                                HIWORD(v101[168]) = v102[0][5];
                                LOWORD(v101[168]) = v102[0][6];
                                WORD2(v101[168]) = v102[0][7];
                                WORD1(v101[168]) = v102[0][8];
                                if (v9 >= 0x4B) {
                                  HIWORD(v101[167]) = v102[0][9];
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  if (BYTE5(v101[185]) == 255) {
    BYTE5(v101[185]) = 0;
  }
  if (LODWORD(v101[166]) == -1)
  {
    BYTE3(v101[188]) = 0;
    LODWORD(v101[166]) = 1;
  }

  v90 = (char *)a3[27];
  a3[27] = v90 + 1512;
  if (a4)
  {
    if (a5)
    {
      v91 = (uint64_t *)GetStream_10858(a5, v101[162]);
      if (v91) {
        v92 = *v91;
      }
      else {
        v92 = 0LL;
      }
      v101[162] = v92;
      v94 = (uint64_t *)GetStream_10858(a5, v101[147]);
      if (v94) {
        v95 = *v94;
      }
      else {
        v95 = 0LL;
      }
      v101[147] = v95;
      v96 = (uint64_t *)GetStream_10858(a5, v101[158]);
      if (v96) {
        v97 = *v96;
      }
      else {
        v97 = 0LL;
      }
      v101[158] = v97;
      v98 = (uint64_t *)GetStream_10858(a5, v101[155]);
      if (v98) {
        v99 = *v98;
      }
      else {
        v99 = 0LL;
      }
      v101[155] = v99;
      v93 = (uint64_t *)GetStream_10858(a5, v101[152]);
      if (!v93)
      {
        v100 = 0LL;
        goto LABEL_153;
      }
    }

    else
    {
      v93 = &v101[152];
    }

    v100 = *v93;
LABEL_153:
    v101[152] = v100;
    return (size_t)memcpy(v90, v101, 0x5E8uLL);
  }

  return result;
}

vm_address_t *GPUTools::VMBuffer::_dealloc(vm_address_t *this)
{
  if (*this)
  {
    uint64_t v1 = this;
    this = (vm_address_t *)vm_deallocate(mach_task_self_, *this, vm_page_size + this[1] + this[1] * this[2]);
    v1[1] = 0LL;
    v1[2] = 0LL;
    *uint64_t v1 = 0LL;
  }

  return this;
}

LABEL_20:
          iov += v18;
          v14 = v7 - ((unint64_t)((char *)iov - (char *)self->_iov) >> 4);
        }

        v17 = *v16;
      }

      while (*v16 == 4);
      if (v17 != 35) {
        break;
      }
      if (LOBYTE(self->super._interposerVersion))
      {
        if (a3) {
          *a3 = -[GTTransport_capture error](self, "error");
        }
        goto LABEL_24;
      }

      -[GTBaseStreamTransport_capture _waitEAGAIN](self, "_waitEAGAIN");
    }

    v22 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v17,  0LL);
    -[GTBaseStreamTransport_capture _scheduleInvalidation:](self, "_scheduleInvalidation:", v22);
    if (a3) {
      *a3 = v22;
    }
    *__error() = v17;
LABEL_24:
    vm_map_t v6 = -1LL;
  }

  v16 = atomic_load((unsigned int *)self->_incomingShmem + 4);
  if (v16 != -1) {
    return;
  }
  vm_size_t v4 = 31LL;
LABEL_23:
  v17 = objc_autoreleasePoolPush();
  -[GTBaseStreamTransport_capture _scheduleInvalidation:]( self,  "_scheduleInvalidation:",  +[GTError_capture errorWithDomain:code:userInfo:]( &OBJC_CLASS___GTError_capture,  "errorWithDomain:code:userInfo:",  @"DYErrorDomain",  v4,  0LL));
  objc_autoreleasePoolPop(v17);
}

      ++v11;
    }

    if (v20 == 32)
    {
      v14 = 1;
      goto LABEL_20;
    }

    if (v20 == 35)
    {
      v16 = 1;
      goto LABEL_20;
    }

LABEL_25:
  -[GTBaseStreamTransport_capture _clearBuffers](self, "_clearBuffers");
  return v6;
}

              vm_size_t v4 = v67;
              int v3 = v68;
              vm_address_t v9 = &CACurrentMediaTime_ptr;
            }

            v52 = v71;
            if (v27 || ((v69 ^ 1) & 1) != 0)
            {
              v55 = v69;
              if (!v27) {
                v55 = 1;
              }
              if ((v55 & 1) != 0)
              {
                v54 = (void *)objc_opt_new(v9[130]);
                v77 = 0LL;
                v56 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  &__kCFBooleanFalse,  1LL,  &v77));
                v57 = v77;
                [v54 setData:v56];

                v52 = v71;
                [v54 setError:v57];
                [v54 setRequestID:v72];
                -[NSMutableArray setObject:atIndexedSubscript:](v73, "setObject:atIndexedSubscript:", v54, v10);
                dispatch_group_leave(v4);

                vm_address_t v9 = &CACurrentMediaTime_ptr;
              }

              else
              {
                v78[0] = _NSConcreteStackBlock;
                v78[1] = 3221225472LL;
                v78[2] = __30__GTMTLCaptureService_update___block_invoke_2;
                v78[3] = &unk_20DA20;
                v27 = v27;
                v79 = v27;
                v82 = v72;
                v80 = v73;
                v83 = v10;
                v81 = v4;
                dispatch_async(&_dispatch_main_q, v78);

                v54 = v79;
              }
            }

            else
            {
              v53 = (void *)objc_claimAutoreleasedReturnValue(+[CALayer layer](&OBJC_CLASS___CALayer, "layer"));
              block[0] = _NSConcreteStackBlock;
              block[1] = 3221225472LL;
              block[2] = __30__GTMTLCaptureService_update___block_invoke;
              block[3] = &unk_20D9F8;
              v27 = v53;
              v85 = v27;
              v86 = v71;
              v89 = v72;
              v87 = v73;
              v90 = v10;
              v88 = v4;
              dispatch_async(&_dispatch_main_q, block);

              v54 = v85;
            }

            v21 = v70;
          }

          else
          {
            v27 = (id)objc_opt_new(v9[130]);
            v76 = 0LL;
            v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  &__kCFBooleanFalse,  1LL,  &v76));
            v52 = v76;
            [v27 setData:v51];

            [v27 setError:v52];
            [v27 setRequestID:v72];
            -[NSMutableArray setObject:atIndexedSubscript:](v73, "setObject:atIndexedSubscript:", v27, v10);
            dispatch_group_leave(v4);
          }
        }

        else
        {
          v47 = (void *)objc_opt_new(v9[130]);
          [v47 setData:0];
          v48 = objc_alloc(&OBJC_CLASS___NSError);
          v97 = NSLocalizedDescriptionKey;
          v98 = @"unknown streamRef";
          v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v98,  &v97,  1LL));
          v50 = -[NSError initWithDomain:code:userInfo:]( v48,  "initWithDomain:code:userInfo:",  NSCocoaErrorDomain,  1LL,  v49);
          [v47 setError:v50];

          v21 = v47;
          [v47 setRequestID:v17];
          -[NSMutableArray setObject:atIndexedSubscript:](v73, "setObject:atIndexedSubscript:", v47, v10);
          dispatch_group_leave(v4);
        }
      }

      else
      {
        v33 = objc_opt_class(&OBJC_CLASS___GTCaptureUpdateConfiguration, v15);
        if ((objc_opt_isKindOfClass(v12, v33) & 1) != 0)
        {
          v34 = v12;
          v16 = (id)objc_claimAutoreleasedReturnValue([v34 configuration]);
          v35 = [v16 enablePresentDownload];
          qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFFFELL | v35;
          v36 = [v16 enableLogErrors];
          v37 = 2LL;
          if (!v36) {
            v37 = 0LL;
          }
          qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFFFDLL | v37;
          v38 = [v16 disableHashResources];
          v39 = 32LL;
          if (v38) {
            v39 = 0LL;
          }
          qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFFDFLL | v39;
          GT_ENV = [v16 waitEventTimeout];
          qword_23A438 = [v16 maxDownloadCommandBuffers];
          v40 = (void *)objc_opt_new(v9[130]);
          v75 = 0LL;
          v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  &__kCFBooleanTrue,  1LL,  &v75));
          v42 = v75;
          [v40 setData:v41];

          [v40 setError:v42];
          v43 = [v34 requestID];

          [v40 setRequestID:v43];
          -[NSMutableArray setObject:atIndexedSubscript:](v73, "setObject:atIndexedSubscript:", v40, v10);
          dispatch_group_leave(v4);

          vm_address_t v9 = &CACurrentMediaTime_ptr;
        }

        else
        {
          v16 = (id)objc_opt_new(v9[130]);
          objc_msgSend(v16, "setRequestID:", objc_msgSend(v12, "requestID"));
          v44 = objc_alloc(&OBJC_CLASS___NSError);
          v95 = NSLocalizedDescriptionKey;
          v96 = @"unknown request";
          v45 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v96,  &v95,  1LL));
          v46 = -[NSError initWithDomain:code:userInfo:]( v44,  "initWithDomain:code:userInfo:",  NSCocoaErrorDomain,  1LL,  v45);
          [v16 setError:v46];

          -[NSMutableArray setObject:atIndexedSubscript:](v73, "setObject:atIndexedSubscript:", v16, v10);
          dispatch_group_leave(v4);
        }
      }

      ++v10;
      v58 = (void *)objc_claimAutoreleasedReturnValue([v3 requests]);
      v59 = [v58 count];
    }

    while ((unint64_t)v59 > v10);
  }

  dispatch_group_wait(v4, 0xFFFFFFFFFFFFFFFFLL);
  v60 = (void *)objc_opt_new(v9[130]);
  v61 = -[NSMutableArray copy](v73, "copy");
  v74 = 0LL;
  v62 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v61,  1LL,  &v74));
  v63 = v74;
  [v60 setData:v62];

  [v60 setError:v63];
  [v60 setRequestID:v66];
  v64 = (void (**)(void, void))objc_claimAutoreleasedReturnValue([v3 completionHandler]);
  ((void (**)(void, void *))v64)[2](v64, v60);

  return 0LL;
}

      v16 = apr_array_push((apr_array_header_t *)tracingRegions);
      v17 = v27;
      void *v16 = v5;
      v16[1] = a2;
      v16[2] = v17;
      v18 = tracedChunks;
      if ((qword_23A448 & 0x2000) != 0)
      {
        entry = find_entry(tracedChunks, &v27, 8uLL, 0LL);
        if (*entry)
        {
          v23 = *(void **)(*entry + 32LL);
          if (v23)
          {
            bzero(v23 + 1, 8LL * *v23);
LABEL_33:
            mprotect((void *)v5, a2, 1);
            return pthread_mutex_unlock(&tracingMutex);
          }
        }

        v24 = (a2 + (vm_page_size << 6) - 1) / (vm_page_size << 6);
        v25 = calloc(1uLL, 8 * v24 + 8);
        *v25 = v24;
        v26 = tracedChunks;
        v19 = apr_palloc((apr_pool_t *)tracingPool, 8uLL);
        *v19 = v27;
        v20 = (apr_hash_t *)v26;
        v21 = v25;
      }

      else
      {
        v19 = apr_palloc((apr_pool_t *)tracingPool, 8uLL);
        *v19 = v27;
        v20 = (apr_hash_t *)v18;
        v21 = &dword_8;
      }

      apr_hash_set(v20, v19, 8LL, v21);
      goto LABEL_33;
    }

    if (!v27) {
      return result;
    }
    uint64_t v10 = (unint64_t *)(v27 + 56);
    unint64_t v11 = atomic_load((unint64_t *)(v27 + 56));
    while (1)
    {
      uint8x8_t v12 = __ldaxr(v10);
      if (v12 != v11) {
        break;
      }
      if (__stlxr(v11 | 8, v10)) {
        goto LABEL_18;
      }
      uint64_t v13 = 1;
LABEL_19:
      unint64_t v11 = v12;
      if ((v13 & 1) != 0) {
        return result;
      }
    }

    __clrex();
LABEL_18:
    uint64_t v13 = 0;
    goto LABEL_19;
  }

  return result;
}

  v30 = 0;
LABEL_26:
  v31 = *(void *)(a3 + 192);
  uint64_t result = v31 + 64;
  *(void *)(a3 + 192) = v31 + 64;
  if (a4)
  {
    if (v27 == 255) {
      LOBYTE(v27) = 0;
    }
    *(void *)v31 = v20;
    *(void *)(v31 + _Block_object_dispose(va, 8) = v8;
    if (v26 == -1) {
      v26 = 0LL;
    }
    *(void *)(v31 + 16) = v26;
    if (v25 == 255) {
      v33 = 0;
    }
    else {
      v33 = v25;
    }
    *(int32x4_t *)(v31 + 24) = v21;
    if (v24 == 255) {
      LOBYTE(v24) = 0;
    }
    if (v22 == 255) {
      LOBYTE(v22) = 0;
    }
    *(_DWORD *)(v31 + 40) = v13;
    *(_DWORD *)(v31 + 44) = v11;
    *(_WORD *)(v31 + 4_Block_object_dispose(va, 8) = v30;
    *(_BYTE *)(v31 + 50) = v24;
    *(_BYTE *)(v31 + 51) = v23;
    *(_BYTE *)(v31 + 52) = v27;
    *(_BYTE *)(v31 + 53) = v29;
    *(_BYTE *)(v31 + 54) = v22;
    *(_BYTE *)(v31 + 55) = v34;
    *(_BYTE *)(v31 + 56) = v36;
    *(_BYTE *)(v31 + 57) = v35;
    *(_BYTE *)(v31 + 5_Block_object_dispose(va, 8) = v10;
    *(_BYTE *)(v31 + 59) = v9;
    *(_BYTE *)(v31 + 60) = v28;
    *(_BYTE *)(v31 + 61) = v37;
    *(_BYTE *)(v31 + 62) = v33;
    *(_BYTE *)(v31 + 63) = v38;
  }

  return result;
}

      v29 = 0LL;
LABEL_27:
      GTTraceFuncToFbuf(a1, a2, v29, 0LL);
      WriteGTMTLSMTexture_properties((void *)a1, v18, v21, v7);
      WriteGTMTLSMTexture_textureViews((uint64_t *)a1, a2, v18);
      v30 = *(void *)a1;
      v31 = *(void *)(a1 + 8);
      *(void *)(v31 + 16) = 0LL;
      *(void *)(v31 + 24) = 0LL;
      *(void *)(v31 + _Block_object_dispose(va, 8) = 0LL;
      *(_DWORD *)(v31 + 32) = 70;
      *(_DWORD *)(v31 + 36) = 67;
      *(void *)v31 = 0xFFFFD00800000028LL;
      *(void *)(v31 + 40) = v30;
      *(_DWORD *)v31 = 48;
      v32 = *(unsigned int **)(a1 + 8);
      v33 = *v32;
      if ((*((_BYTE *)v32 + 33) & 0x10) != 0)
      {
        v35 = *(unsigned int **)(a1 + 8);
        v34 = *v32;
        do
        {
          v35 = (unsigned int *)((char *)v35 + v33);
          v33 = *v35;
          v34 += v33;
        }

        while ((*((_BYTE *)v35 + 33) & 0x20) == 0);
      }

      else
      {
        v34 = *v32;
      }

      fbstream_write(*(void *)(a1 + 24), (uint64_t)v32, v34);
      v16 = *(_DWORD *)(v10 + 12);
      goto LABEL_32;
    }
  }

LABEL_23:
      abort();
    }

    uint8x8_t v12 = __stderrp;
    uint64_t v13 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"fail: url scheme has to be dysmt: %s",  objc_msgSend(objc_msgSend(a3, "absoluteString"), "UTF8String"));
LABEL_22:
    -[NSString UTF8String](v13, "UTF8String");
    fprintf(v12, "%s\n");
    goto LABEL_23;
  }

  if (!objc_msgSend(objc_msgSend(a3, "path"), "length"))
  {
    if (s_logUsingOsLog)
    {
      uint64_t v10 = (os_log_s *)gt_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v16 = objc_msgSend(objc_msgSend(a3, "absoluteString"), "UTF8String");
        vm_size_t v7 = "fail: url path cannot be nil or empty: %s";
LABEL_17:
        vm_address_t v8 = v10;
        vm_address_t v9 = 12;
LABEL_18:
        _os_log_fault_impl(&dword_0, v8, OS_LOG_TYPE_FAULT, v7, buf, v9);
        abort();
      }

      goto LABEL_23;
    }

    uint8x8_t v12 = __stderrp;
    uint64_t v13 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"fail: url path cannot be nil or empty: %s",  objc_msgSend(objc_msgSend(a3, "absoluteString"), "UTF8String"));
    goto LABEL_22;
  }

  queue = (dispatch_queue_s *)self->super.super._queue;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __34__GTSharedMemoryTransport_setUrl___block_invoke;
  block[3] = &unk_20E0F0;
  block[4] = a3;
  block[5] = self;
  dispatch_sync(queue, block);
}

  objc_msgSend( a4,  "setError:",  +[NSError errorWithDomain:code:userInfo:]( NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  *__error(),  0));
  objc_msgSend(a4, "setResult:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 0));
  if (v17 != -1) {
    close(v17);
  }
}

      unint64_t v11 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *(void *)(a1 + 40));
      apr_hash_set(*(apr_hash_t **)(a1 + 48), v11 + 8, 8LL, v11);
      return;
    }

    if (v4 != -15975)
    {
      if (v4 != -15749)
      {
        vm_map_t v6 = -15701;
        goto LABEL_22;
      }

      goto LABEL_24;
    }

    goto LABEL_33;
  }

  if (v4 > -15334)
  {
    if (v4 <= -15309)
    {
      if (v4 != -15333)
      {
        vm_size_t v5 = -15309;
LABEL_10:
        if (v4 != v5) {
          return;
        }
        goto LABEL_19;
      }

      goto LABEL_23;
    }

    if (v4 != -15308)
    {
      vm_map_t v6 = -12544;
LABEL_22:
      if (v4 != v6) {
        return;
      }
      goto LABEL_23;
    }

  v27 = v30;
  v28 = -[NSMutableArray copy](v30, "copy", v30);

  return v28;
}

      objc_autoreleasePoolPop(v4);
      ++v3;
    }

    while (v3 < *(int *)(v2 + 12));
  }

  return arr;
}

LABEL_17:
    if (a6)
    {
      v18 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  *__error(),  0LL);
      LOBYTE(v16) = 0;
      *a6 = v18;
    }

    else
    {
      LOBYTE(v16) = 0;
    }
  }

  return (char)v16;
}

  return v8;
}

  GTTraceContext_pushEncoderWithStream((uint64_t)self->_traceContext, (uint64_t)v30);
  baseObject = self->_baseObject;
  v18 = (void *)objc_claimAutoreleasedReturnValue([v6 baseObject]);
  -[MTLRasterizationRateMapSPI copyParameterDataToBuffer:offset:]( baseObject,  "copyParameterDataToBuffer:offset:",  v18,  a4);

  v19 = v31;
  *(_DWORD *)(v31 + _Block_object_dispose(va, 8) = -15776;
  v20 = v34;
  if (v34 > 0x28uLL)
  {
    v22 = *(void *)(v30[1] + 24LL);
    v23 = v35++;
    v21 = GTTraceMemPool_allocateBytes(v22, v32, v23 | 0x1800000000LL) + 16;
    v20 = v23;
  }

  else
  {
    v21 = (char *)(v19 + v34);
    v34 += 24;
  }

  *(_BYTE *)(v19 + 13) = v20;
  v24 = -[CaptureMTLRasterizationRateMap traceStream](self, "traceStream");
  if (v24) {
    var0 = v24->var0;
  }
  else {
    var0 = 0LL;
  }
  v26 = (uint64_t *)[v6 traceStream];

  if (v26) {
    v27 = *v26;
  }
  else {
    v27 = 0LL;
  }
  *(void *)v21 = var0;
  *((void *)v21 + 1) = v27;
  *((void *)v21 + 2) = a4;
  s();
  *(void *)v28 = v29;
  *(_BYTE *)(v28 + _Block_object_dispose(va, 8) = v33;
  *(_BYTE *)(v31 + 15) |= 8u;
}

  os_unfair_lock_unlock(lock);
  uint64_t v13 = atomic_load((unsigned int *)(*(void *)(a1 + 48) + 20LL));
  vm_prot_t v15 = v191 != 4 && v13 == 4;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v15;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = *(_BYTE *)(*(void *)(a1 + 48) + 97LL);
}

  GTTraceContext_pushEncoderWithStream((uint64_t)self->_traceContext, (uint64_t)v39);
  baseObject = self->_baseObject;
  v25 = (void *)objc_claimAutoreleasedReturnValue([v13 baseObject]);
  v26 = (void *)objc_claimAutoreleasedReturnValue([v12 baseObject]);
  -[MTLIOCommandBufferSPI loadBuffer:offset:size:sourceHandle:sourceHandleOffset:]( baseObject,  "loadBuffer:offset:size:sourceHandle:sourceHandleOffset:",  v25,  a4,  a5,  v26,  a7);

  v27 = v40;
  *(_DWORD *)(v40 + _Block_object_dispose(va, 8) = -15311;
  v28 = v43;
  if (v43 > 0x10uLL)
  {
    v30 = *(void *)(v39[1] + 24LL);
    v31 = v44++;
    v29 = GTTraceMemPool_allocateBytes(v30, v41, v31 | 0x3000000000LL) + 16;
    v28 = v31;
  }

  else
  {
    v29 = (char *)(v27 + v43);
    v43 += 48;
  }

  *(_BYTE *)(v27 + 13) = v28;
  v32 = -[CaptureMTLIOCommandBuffer traceStream](self, "traceStream");
  if (v32) {
    var0 = v32->var0;
  }
  else {
    var0 = 0LL;
  }
  v34 = [v13 traceStream];

  if (v34) {
    v34 = (void *)*v34;
  }
  v35 = (uint64_t *)[v12 traceStream];

  if (v35) {
    v36 = *v35;
  }
  else {
    v36 = 0LL;
  }
  *(void *)v29 = var0;
  *((void *)v29 + 1) = v34;
  *((void *)v29 + 2) = a4;
  *((void *)v29 + 3) = a5;
  *((void *)v29 + 4) = v36;
  *((void *)v29 + 5) = a7;
  s();
  *(void *)v37 = v38;
  *(_BYTE *)(v37 + _Block_object_dispose(va, 8) = v42;
  *(_BYTE *)(v40 + 15) |= 8u;
}
}

void sub_9850( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t smt_poll_thread_entry(void *a1)
{
  uint64_t v2 = (dispatch_queue_s *)a1[1];
  int v3 = (void *)a1[2];
  snprintf(__str, 0x40uLL, "gputools.smt_poll.%p", a1);
  pthread_setname_np(__str);
  while (!*((_BYTE *)a1 + 24))
  {
    dispatch_sync(v2, v3);
    usleep(0x1F40u);
  }

  return 0LL;
}

void sub_AD80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_14:
    abort();
  }

  if (a3 && ![a3 filePathURL])
  {
    if (s_logUsingOsLog)
    {
      uint64_t v10 = (os_log_s *)gt_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        vm_prot_t v15 = objc_msgSend(objc_msgSend(a3, "absoluteString"), "UTF8String");
        vm_size_t v7 = "fail: unix domain socket url must be a file url: %s";
        vm_address_t v8 = v10;
        vm_address_t v9 = 12;
LABEL_11:
        _os_log_fault_impl(&dword_0, v8, OS_LOG_TYPE_FAULT, v7, buf, v9);
        abort();
      }
    }

    else
    {
      uint8x8_t v12 = __stderrp;
      -[NSString UTF8String]( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"fail: unix domain socket url must be a file url: %s",  objc_msgSend(objc_msgSend(a3, "absoluteString"), "UTF8String")),  "UTF8String");
      fprintf(v12, "%s\n");
    }

    goto LABEL_14;
  }

  queue = (dispatch_queue_s *)self->super.super.super._queue;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __38__GTUNIXDomainSocketTransport_setUrl___block_invoke;
  block[3] = &unk_20E0F0;
  block[4] = a3;
  block[5] = self;
  dispatch_sync(queue, block);
}

  if (v19) {
    CaptureMTLBuffer_registerBaseBufferForTracing(v19->_baseObject, (uint64_t)v19->_traceStream, 0);
  }
  GTTraceEncoder_setStream((uint64_t *)&v42, (uint64_t)-[CaptureMTLBuffer traceStream](v19, "traceStream"));
  v25 = v44;
  *(_DWORD *)(v44 + _Block_object_dispose(va, 8) = -16312;
  v26 = v48;
  if (v48 > 0x10uLL)
  {
    v28 = *(void *)(v43 + 24);
    v41 = self;
    v29 = v18;
    v30 = a4;
    v31 = v10;
    v32 = a3;
    v33 = a5;
    v34 = HIBYTE(v48);
    ++HIBYTE(v48);
    v27 = GTTraceMemPool_allocateBytes(v28, v45, v34 | 0x3000000000LL) + 16;
    v26 = v34;
    a5 = v33;
    a3 = v32;
    uint64_t v10 = v31;
    a4 = v30;
    v18 = v29;
    self = v41;
  }

  else
  {
    v27 = (char *)(v25 + v48);
    LOBYTE(v4_Block_object_dispose(va, 8) = v48 + 48;
  }

  *(_BYTE *)(v25 + 13) = v26;
  SaveMTLBufferInfo((uint64_t)&v42, v18);
  v35 = -[CaptureMTLDevice traceStream](self, "traceStream");
  if (v35) {
    var0 = v35->var0;
  }
  else {
    var0 = 0LL;
  }
  v37 = -[CaptureMTLBuffer traceStream](v19, "traceStream");
  if (v37) {
    v38 = v37->var0;
  }
  else {
    v38 = 0LL;
  }
  v39 = TransferBytes((uint64_t)&v42, (uint64_t *)a3, (const void *)a4);
  *(void *)v27 = var0;
  *((void *)v27 + 1) = v38;
  *((void *)v27 + 2) = a4;
  *((void *)v27 + 3) = a5;
  *((void *)v27 + 4) = v10;
  v27[40] = v39;
  *(_DWORD *)(v27 + 41) = 0;
  *((_DWORD *)v27 + 11) = 0;
  *vm_prot_t v15 = v46;
  *((_BYTE *)v15 + _Block_object_dispose(va, 8) = v47;
  *(_BYTE *)(v44 + 15) |= 8u;

  return v19;
}

  if ((qword_23A448 & 0x2000) != 0)
  {
    vm_address_t v8 = *find_entry(tracedChunks, &key, 8uLL, 0LL);
    if (v8) {
      vm_address_t v9 = *(void **)(v8 + 32);
    }
    else {
      vm_address_t v9 = 0LL;
    }
    free(v9);
  }

  apr_hash_set((apr_hash_t *)tracedChunks, &key, 8LL, 0LL);
  return pthread_mutex_unlock(&tracingMutex);
}

  unint64_t v11 = 0LL;
  if (a4)
  {
LABEL_5:
    uint8x8_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a4));
    uint64_t v13 = [v8 initWithFenum:v9 category:v10 customMessage:v11 customRecoverySuggestion:v12];

    if (!a3) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

id DYErrorFromDictionary(NSDictionary *a1)
{
  id result = -[NSDictionary objectForKey:](a1, "objectForKey:", @"error domain");
  if (result) {
    return +[GTError_capture errorWithDomain:code:userInfo:]( GTError_capture,  "errorWithDomain:code:userInfo:",  result,  objc_msgSend(-[NSDictionary objectForKey:](a1, "objectForKey:", @"error code"), "integerValue"),  +[NSDictionary dictionaryWithObject:forKey:]( NSDictionary,  "dictionaryWithObject:forKey:",  -[NSDictionary objectForKey:](a1, "objectForKey:", @"error description"),  NSLocalizedDescriptionKey));
  }
  return result;
}

NSDictionary *DYDictionaryFromError(NSDictionary *result)
{
  if (result) {
    return +[NSDictionary dictionaryWithObjectsAndKeys:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjectsAndKeys:",  -[NSDictionary domain](result, "domain"),  @"error domain",  +[NSNumber numberWithInteger:]( &OBJC_CLASS___NSNumber,  "numberWithInteger:",  -[NSDictionary code](result, "code")),  @"error code",  -[NSDictionary localizedDescription](result, "localizedDescription"),  @"error description",  0LL);
  }
  return result;
}

unint64_t GPUTools::VMBuffer::round_size(unint64_t this)
{
  if (3 * vm_page_size <= this) {
    return (this + vm_page_size - 1) & -(uint64_t)vm_page_size;
  }
  else {
    return 3 * vm_page_size;
  }
}

GPUTools::VMBuffer *GPUTools::VMBuffer::VMBuffer(GPUTools::VMBuffer *this, vm_size_t a2, uint64_t a3)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = 0LL;
  *((void *)this + 5) = 1LL;
  GPUTools::VMBuffer::_dealloc((vm_address_t *)this);
  GPUTools::VMBuffer::_alloc(this, a2, a3);
  return this;
}

{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = 0LL;
  *((void *)this + 5) = 1LL;
  GPUTools::VMBuffer::_dealloc((vm_address_t *)this);
  GPUTools::VMBuffer::_alloc(this, a2, a3);
  return this;
}

uint64_t GPUTools::VMBuffer::alloc(vm_address_t *this, vm_size_t a2, uint64_t a3)
{
  return GPUTools::VMBuffer::_alloc((GPUTools::VMBuffer *)this, a2, a3);
}

void GPUTools::VMBuffer::~VMBuffer(vm_address_t *this)
{
}

{
  GPUTools::VMBuffer::_dealloc(this);
}

vm_address_t *GPUTools::VMBuffer::operator=(vm_address_t *this, uint64_t a2)
{
  if (this != (vm_address_t *)a2)
  {
    GPUTools::VMBuffer::_dealloc(this);
    *(_OWORD *)this = *(_OWORD *)a2;
    *((_OWORD *)this + 1) = *(_OWORD *)(a2 + 16);
    *((_OWORD *)this + 2) = *(_OWORD *)(a2 + 32);
    *(void *)a2 = 0LL;
    *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a2 + 16) = 0LL;
  }

  return this;
}

BOOL GPUTools::VMBuffer::protect_readonly(vm_address_t *this)
{
  return vm_protect(mach_task_self_, *this, this[2] * this[1], 0, 1) == 0;
}

GTBaseSocketTransport_capture *DYCreateTransportSocket(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___GTBaseSocketTransport_capture);
  -[GTBaseSocketTransport_capture runWithSocket:](v2, "runWithSocket:", a1);
  return v2;
}

id DYCreateTransportC(uint64_t a1)
{
  if (!a1)
  {
    if (s_logUsingOsLog)
    {
      vm_address_t v9 = (os_log_s *)gt_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        uint64_t v10 = "fail: [create_transport] GT_HOST_URL environment not set";
        unint64_t v11 = v9;
        uint32_t v12 = 2;
        goto LABEL_24;
      }
    }

    else
    {
      v14 = __stderrp;
      -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"fail: [create_transport] GT_HOST_URL environment not set"),  "UTF8String");
      fprintf(v14, "%s\n");
    }

    goto LABEL_29;
  }

  uint64_t v2 = +[NSString stringWithCString:encoding:](&OBJC_CLASS___NSString, "stringWithCString:encoding:", a1, 4LL);
  if (!v2) {
    __assert_rtn("GTTransport *DYCreateTransportC(const char *)", "", 0, "url_str");
  }
  int v3 = +[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v2);
  if (!v3)
  {
    if (s_logUsingOsLog)
    {
      uint64_t v13 = (os_log_s *)gt_default_log();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        uint64_t v18 = a1;
        uint64_t v10 = "fail: [create_transport] failed to parse GT_HOST_URL: %s";
LABEL_23:
        unint64_t v11 = v13;
        uint32_t v12 = 12;
LABEL_24:
        _os_log_fault_impl(&dword_0, v11, OS_LOG_TYPE_FAULT, v10, buf, v12);
        abort();
      }

LABEL_29:
      abort();
    }

    vm_prot_t v15 = __stderrp;
    v16 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"fail: [create_transport] failed to parse GT_HOST_URL: %s",  a1);
LABEL_28:
    -[NSString UTF8String](v16, "UTF8String");
    fprintf(v15, "%s\n");
    goto LABEL_29;
  }

  vm_size_t v4 = v3;
  vm_size_t v5 = -[NSURL scheme](v3, "scheme");
  if (!-[NSString isEqualToString:](v5, "isEqualToString:", @"null"))
  {
    if (-[NSString isEqualToString:](v5, "isEqualToString:", @"file"))
    {
      vm_size_t v7 = &off_20C4A0;
    }

    else
    {
      if (!-[NSString isEqualToString:](v5, "isEqualToString:", @"dysmt")
        && !-[NSString isEqualToString:](v5, "isEqualToString:", @"dysmtdeferred"))
      {
LABEL_20:
        if (s_logUsingOsLog)
        {
          uint64_t v13 = (os_log_s *)gt_default_log();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            uint64_t v18 = a1;
            uint64_t v10 = "fail: [create_transport] failed to create transport; GT_HOST_URL: %s";
            goto LABEL_23;
          }

          goto LABEL_29;
        }

        vm_prot_t v15 = __stderrp;
        v16 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"fail: [create_transport] failed to create transport; GT_HOST_URL: %s",
                a1);
        goto LABEL_28;
      }

      vm_size_t v7 = &off_20C448;
    }

    id v6 = [objc_alloc(*v7) initWithMode:1];
    [v6 setUrl:v4];
    if (v6) {
      return v6;
    }
    goto LABEL_20;
  }

  return 0LL;
}

          v31 = *(void *)(a1 + 24);
LABEL_30:
          fbstream_write(v31, (uint64_t)v11, v13);
          continue;
        }

        if (v10 == 60)
        {
          *(void *)__str = *(void *)(v9 + 8);
          v16 = *(void *)(*(void *)(*find_entry(a4, __str, 8uLL, 0LL) + 32LL) + 8LL);
          GTResourceDownloaderGetResourceFilename(v9, 1, __str, 0x80uLL);
          v17 = *(unsigned int **)(a1 + 8);
          *((void *)v17 + 3) = 0LL;
          *((void *)v17 + 4) = 0x554300000000LL;
          *((void *)v17 + 1) = 0LL;
          *((void *)v17 + 2) = 0LL;
          *(void *)v17 = 0xFFFFD85800000028LL;
          *((void *)v17 + 5) = v16;
          *v17 = 48;
          AppendString(__str, (int *)v17);
          uint64_t v18 = *v17;
          v19 = ((_DWORD)v18 + 3) & 0xFFFFFFFC;
          bzero((char *)v17 + v18, v19 - v18);
          *v17 = v19;
          unint64_t v11 = *(unsigned int **)(a1 + 8);
          v20 = v11[8];
          v11[8] = v20 | 4;
          uint64_t v13 = *v11;
          if ((v20 & 0x1000) != 0)
          {
            v21 = *v11;
            v22 = v11;
            do
            {
              v22 = (unsigned int *)((char *)v22 + v21);
              v21 = *v22;
              v13 += v21;
            }

            while ((*((_BYTE *)v22 + 33) & 0x20) == 0);
          }

          goto LABEL_29;
        }
      }

      else
      {
        switch(v10)
        {
          case 'P':
            *(void *)__str = *(void *)(v9 + 8);
            v23 = *(void *)(*(void *)(*find_entry(a4, __str, 8uLL, 0LL) + 32LL) + 8LL);
            memset(&v43[1], 0, 24);
            v24 = *(unsigned int *)(v9 + 60);
            v43[0] = v23;
            v43[4] = v24;
            v25 = *(unsigned __int16 *)(v9 + 66);
            v43[5] = *(unsigned __int16 *)(v9 + 64);
            v43[6] = v25;
            v26 = *(unsigned __int16 *)(v9 + 48);
            v43[7] = *(unsigned __int16 *)(v9 + 50);
            v43[8] = v26;
            GTResourceDownloaderGetResourceFilename(v9, 0, __str, 0x80uLL);
            v43[9] = __str;
            v27 = *(void *)(v9 + 68);
            *(void *)&v28 = v27;
            *((void *)&v28 + 1) = HIDWORD(v27);
            v44 = v28;
            v45 = *(unsigned int *)(v9 + 76);
            DYTraceEncode_MTLTexture_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage( (uint64_t)v43,  *(unsigned int **)(a1 + 8),  *(unsigned int *)(a1 + 16),  0LL,  0LL);
            unint64_t v11 = *(unsigned int **)(a1 + 8);
            v11[1] = -10236;
            v29 = v11[8] | a3;
            v30 = v29 | 4;
            v11[8] = v29 | 4;
            if ((*(_BYTE *)(v9 + 47) & 4) != 0)
            {
              v30 = v29 | 6;
              v11[8] = v29 | 6;
            }

            v31 = *(void *)(a1 + 24);
            v32 = *v11;
            if ((v30 & 0x1000) != 0)
            {
              v39 = v11;
              uint64_t v13 = *v11;
              do
              {
                v39 = (unsigned int *)((char *)v39 + v32);
                v32 = *v39;
                v13 += v32;
              }

              while ((*((_BYTE *)v39 + 33) & 0x20) == 0);
            }

            else
            {
              uint64_t v13 = *v11;
            }

            goto LABEL_30;
          case 'S':
            *(void *)__str = *(void *)(v9 + 8);
            v40[0] = *(void *)(*(void *)(*find_entry(a4, __str, 8uLL, 0LL) + 32LL) + 8LL);
            GTResourceDownloaderGetResourceFilename(v9, 0, __str, 0x80uLL);
            v40[1] = __str;
            v40[2] = 0LL;
            v40[3] = *(void *)(v9 + 48);
            DYTraceEncode_MTLVisibleFunctionTable_setFunctions_withRange( (uint64_t)v40,  *(unsigned int **)(a1 + 8),  *(unsigned int *)(a1 + 16),  0LL,  0LL);
            unint64_t v11 = *(unsigned int **)(a1 + 8);
            v33 = v11[8];
            v11[8] = v33 | 4;
            uint64_t v13 = *v11;
            if ((v33 & 0x1000) != 0)
            {
              v34 = *v11;
              v35 = v11;
              do
              {
                v35 = (unsigned int *)((char *)v35 + v34);
                v34 = *v35;
                v13 += v34;
              }

              while ((*((_BYTE *)v35 + 33) & 0x20) == 0);
            }

            goto LABEL_29;
          case 'V':
            *(void *)__str = *(void *)(v9 + 8);
            v41[0] = *(void *)(*(void *)(*find_entry(a4, __str, 8uLL, 0LL) + 32LL) + 8LL);
            GTResourceDownloaderGetResourceFilename(v9, *(_DWORD *)(v9 + 56), __str, 0x80uLL);
            v41[1] = __str;
            v42 = *(_OWORD *)(v9 + 48);
            DYTraceEncode_MTLTexture_restoreIOSurfaceData_length_forPlane( (uint64_t)v41,  *(unsigned int **)(a1 + 8),  *(unsigned int *)(a1 + 16),  0LL,  0LL);
            unint64_t v11 = *(unsigned int **)(a1 + 8);
            uint32_t v12 = v11[8];
            v11[8] = v12 | 4;
            uint64_t v13 = *v11;
            if ((v12 & 0x1000) != 0)
            {
              v14 = *v11;
              vm_prot_t v15 = v11;
              do
              {
                vm_prot_t v15 = (unsigned int *)((char *)v15 + v14);
                v14 = *v15;
                v13 += v14;
              }

              while ((*((_BYTE *)v15 + 33) & 0x20) == 0);
            }

            goto LABEL_29;
        }
      }
    }
  }

  v51 = v62;

  return v51;
}

  objc_autoreleasePoolPop(v4);
}

      mach_msg_destroy(&v27);
      return v17;
    }
  }

  return 4294966989LL;
}

      mach_msg_destroy(&msg);
      return v17;
    }
  }

  return 4294966989LL;
}

void *GTTraceDispatch_create(apr_pool_t *parent, uint64_t a2)
{
  int v3 = newpool;
  id result = apr_palloc(newpool, 0x28uLL);
  if (result)
  {
    result[2] = 0LL;
    result[3] = 0LL;
    result[4] = 0LL;
  }

  void *result = v3;
  result[1] = a2;
  return result;
}

void GTTraceDispatch_destroy(apr_pool_t **a1)
{
}

void GTTraceDispatch_sort(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v94 = v2[68];
  uint64_t v105 = v2[2];
  uint64_t v97 = v2[69];
  uint64_t v100 = v2[71];
  uint64_t v102 = v2[3];
  apr_pool_create_ex(&newpool, *(apr_pool_t **)a1, 0LL, 0LL);
  int v3 = newpool;
  uint64_t v99 = a1;
  vm_size_t v4 = *(void **)(a1 + 8);
  uint64_t v5 = v4[2];
  uint64_t v6 = v4[71];
  vm_size_t v7 = apr_array_make(newpool, 4, 8);
  unint64_t v8 = v4[5] + v4[6] - 1LL;
  GTMTLSMContext_getObjects(*(_DWORD **)(v6 + 128), v8, v7);
  GTMTLSMContext_getObjects(*(_DWORD **)(v6 + 136), v8, v7);
  v95 = v4;
  vm_address_t v9 = (apr_array_header_t *)v4[68];
  uint64_t v10 = apr_array_make(v3, 4, 64);
  if (v7->nelts >= 1)
  {
    uint64_t v11 = 0LL;
    uint64_t v103 = v5;
    do
    {
      uint64_t v12 = *(void *)&v7->elts[8 * v11];
      if (v12) {
        uint64_t v12 = *(void *)(v12 + 8);
      }
      v106[0] = v12;
      entry = find_entry(v5, v106, 8uLL, 0LL);
      if (*entry)
      {
        uint64_t v14 = *(void *)(*entry + 32LL);
        if (v14)
        {
          uint64_t v15 = *(void *)(v14 + 32);
          if (v15)
          {
            unsigned int v16 = 0;
            while (1)
            {
              unsigned int v17 = atomic_load((unsigned int *)(v15 + 4));
              uint64_t v18 = v16 + (v17 >> 6) - 1;
              uint64_t v15 = *(void *)(v15 + 40);
              unsigned int v16 = v18;
              if (!v15)
              {
                unsigned int v16 = v18;
                goto LABEL_14;
              }
            }
          }

          else
          {
            unsigned int v16 = 0;
          }

          uint64_t v18 = 0LL;
LABEL_14:
          unint64_t v19 = v16 | (unint64_t)(v18 << 32);
LABEL_15:
          uint64_t v20 = v15 + 64;
          while (v15 && (*(_BYTE *)(v20 + ((uint64_t)(HIDWORD(v19) - (int)v19) << 6) + 15) & 8) != 0)
          {
            v21 = (__int128 *)(v20 + ((uint64_t)(HIDWORD(v19) - (int)v19) << 6));
            if (*(void *)v21 > v8)
            {
              int v22 = *((_DWORD *)v21 + 2);
              if (v22 == -15490 || v22 == -15975)
              {
                v24 = apr_array_push(v10);
                __int128 v25 = *v21;
                __int128 v26 = v21[1];
                __int128 v27 = v21[3];
                v24[2] = v21[2];
                v24[3] = v27;
                _OWORD *v24 = v25;
                v24[1] = v26;
                if (v8 <= *(void *)v21) {
                  unint64_t v8 = *(void *)v21;
                }
              }
            }

            unsigned int v28 = atomic_load((unsigned int *)(v15 + 4));
            int v29 = v19 + (v28 >> 6);
            uint64_t v30 = (HIDWORD(v19) + 1);
            unint64_t v19 = (v30 << 32) | v19;
            if ((_DWORD)v30 == v29 - 1)
            {
              unint64_t v19 = (v30 << 32) | v30;
              uint64_t v15 = *(void *)(v15 + 40);
              goto LABEL_15;
            }
          }

          uint64_t v5 = v103;
        }
      }

      ++v11;
    }

    while (v11 < v7->nelts);
    int v3 = newpool;
  }

  uint64_t v31 = v99;
  qsort(v10->elts, v10->nelts, v10->elt_size, (int (__cdecl *)(const void *, const void *))CompareGTTraceFunc);
  apr_array_cat(v9, v10);
  v95[6] = v8 - v95[5] + 1;
  v32 = apr_array_make(*(apr_pool_t **)v99, *(_DWORD *)(v94 + 12), *(_DWORD *)(v94 + 8));
  unint64_t v104 = *(void *)(*(void *)(v99 + 8) + 40LL);
  v33 = apr_array_make(v3, *(_DWORD *)(v97 + 12), 16);
  uint64_t v34 = *(unsigned int *)(v97 + 12);
  if ((int)v34 >= 1)
  {
    unint64_t v35 = v34 + 1;
    do
      *(void *)apr_array_push(v33) = *(void *)(*(void *)(v97 + 24) + 8LL * (v35-- - 2));
    while (v35 > 1);
  }

  v36 = GTEventTracker_make(v105, v102, v100, v3);
  v101 = v33;
  if (*(int *)(v97 + 12) >= 1)
  {
    uint64_t v37 = 0LL;
    do
    {
      v106[0] = *(void *)(*(void *)(v97 + 24) + 8 * v37);
      uint64_t v38 = *(void *)(*(void *)(*find_entry(v105, v106, 8uLL, 0LL) + 32LL) + 32LL);
      if (v38)
      {
        unsigned int v39 = 0;
        while (1)
        {
          unsigned int v40 = atomic_load((unsigned int *)(v38 + 4));
          uint64_t v41 = v39 + (v40 >> 6) - 1;
          uint64_t v38 = *(void *)(v38 + 40);
          unsigned int v39 = v41;
          if (!v38)
          {
            unsigned int v39 = v41;
            goto LABEL_43;
          }
        }
      }

      else
      {
        unsigned int v39 = 0;
      }

      uint64_t v41 = 0LL;
LABEL_43:
      unint64_t v42 = v39 | (unint64_t)(v41 << 32);
LABEL_44:
      uint64_t v43 = v38 + 64;
      while (v38 && (*(_BYTE *)(v43 + ((uint64_t)(HIDWORD(v42) - (int)v42) << 6) + 15) & 8) != 0)
      {
        GTEventTracker_processFunction((uint64_t)v36, v43 + ((uint64_t)(HIDWORD(v42) - (int)v42) << 6));
        unsigned int v44 = atomic_load((unsigned int *)(v38 + 4));
        int v45 = v42 + (v44 >> 6);
        uint64_t v46 = (HIDWORD(v42) + 1);
        unint64_t v42 = (v46 << 32) | v42;
        if ((_DWORD)v46 == v45 - 1)
        {
          unint64_t v42 = (v46 << 32) | v46;
          uint64_t v38 = *(void *)(v38 + 40);
          goto LABEL_44;
        }
      }

      ++v37;
      v33 = v101;
    }

    while (v37 < *(int *)(v97 + 12));
  }

  v47 = (uint64_t *)GTEventTracker_makeFrom((uint64_t)v36);
  GTCoreLogTagEnabled(2uLL);
  uint64_t v96 = *(void *)(*(void *)(v99 + 8) + 48LL) + *(void *)(*(void *)(v99 + 8) + 40LL);
  unint64_t v98 = v96 - 1;
  if (v33->nelts)
  {
    while (1)
    {
      uint64_t NextBufferToProcess = FindNextBufferToProcess( (uint64_t)v33,  (uint64_t)v47,  *(void *)(*(void *)(v31 + 8) + 16LL),  *(void *)(*(void *)(v31 + 8) + 24LL));
      if (NextBufferToProcess)
      {
LABEL_60:
        uint64_t v56 = NextBufferToProcess;
      }

      else
      {
        uint64_t nelts = v33->nelts;
        int v50 = nelts + 1;
        uint64_t v51 = 16 * nelts - 16;
        while (--v50 >= 1)
        {
          uint64_t v52 = *find_entry(v105, &v33->elts[v51], 8uLL, 0LL);
          if (v52) {
            uint64_t v53 = *(void *)(v52 + 32);
          }
          else {
            uint64_t v53 = 0LL;
          }
          unint64_t v54 = CommandBufferCommitIndex(v53);
          if (v54 > v104)
          {
            unint64_t v55 = v54;
            ProcessResourceAPIs((uint64_t)v32, v104, v54 - v104, v47, *(void **)(v31 + 8));
            unint64_t v104 = v55;
          }

          v51 -= 16LL;
          uint64_t NextBufferToProcess = FindNextBufferToProcess( (uint64_t)v33,  (uint64_t)v47,  *(void *)(*(void *)(v31 + 8) + 16LL),  *(void *)(*(void *)(v31 + 8) + 24LL));
          if (NextBufferToProcess) {
            goto LABEL_60;
          }
        }

        if (v104 < v98) {
          ProcessResourceAPIs((uint64_t)v32, v104, v96 - v104, v47, *(void **)(v31 + 8));
        }
        uint64_t v56 = FindNextBufferToProcess( (uint64_t)v33,  (uint64_t)v47,  *(void *)(*(void *)(v31 + 8) + 16LL),  *(void *)(*(void *)(v31 + 8) + 24LL));
        unint64_t v104 = v96 - 1;
        if (!v56)
        {
          GTCoreLogTagEnabled(2uLL);
          goto LABEL_112;
        }
      }

      uint64_t v57 = *find_entry(v105, (_BYTE *)v56, 8uLL, 0LL);
      if (!v57) {
        break;
      }
      uint64_t v58 = *(void *)(v57 + 32);
      if (!v58) {
        goto LABEL_67;
      }
      uint64_t v59 = *(void *)(v58 + 32);
      if (!v59 || (*(_BYTE *)(v59 + 79) & 8) == 0) {
        goto LABEL_67;
      }
      uint64_t v60 = v59 + 64;
LABEL_68:
      v61 = GTTraceFunc_targetContext(v60, v102);
      unint64_t v62 = CommandBufferCommitIndex(v58);
      uint64_t v63 = *(void *)(v56 + 8);
      if (!v63)
      {
        unint64_t v64 = v62;
        unint64_t v65 = v104;
        if (v62 > v104)
        {
          ProcessResourceAPIs((uint64_t)v32, v104, v62 - v104, v47, *(void **)(v99 + 8));
          unint64_t v65 = v64;
        }

        unint64_t v104 = v65;
        if (v58 && (uint64_t v66 = *(void *)(v58 + 32)) != 0 && (*(_BYTE *)(v66 + 79) & 8) != 0) {
          v67 = (__int128 *)(v66 + 64);
        }
        else {
          v67 = 0LL;
        }
        v68 = apr_array_push(v32);
        __int128 v69 = v67[3];
        __int128 v71 = *v67;
        __int128 v70 = v67[1];
        v68[2] = v67[2];
        v68[3] = v69;
        _OWORD *v68 = v71;
        v68[1] = v70;
        *(void *)(v56 + _Block_object_dispose(va, 8) = 1LL;
        uint64_t v63 = 1LL;
      }

      uint64_t v72 = *(void *)(v58 + 32);
      if (v72)
      {
        int v73 = 0;
        while (1)
        {
          unsigned int v74 = atomic_load((unsigned int *)(v72 + 4));
          uint64_t v75 = v73 + (v74 >> 6) - 1;
          uint64_t v72 = *(void *)(v72 + 40);
          int v73 = v75;
          if (!v72)
          {
            uint64_t v63 = v75;
            goto LABEL_83;
          }
        }

        LODWORD(v75) = v73;
      }

      else
      {
        LODWORD(v75) = 0;
        uint64_t v63 = 0LL;
      }

LABEL_83:
      uint64_t v76 = v75 | (unint64_t)(v63 << 32);
LABEL_84:
      uint64_t v77 = v72 + 64;
      while (v72)
      {
        uint64_t v78 = v77 + ((uint64_t)(HIDWORD(v76) - (int)v76) << 6);
        GTEventTracker_processFunction((uint64_t)v47, v78);
        int v79 = *(_DWORD *)(v78 + 8);
        if (v79 > -15340)
        {
          BOOL v80 = v79 == -15308;
          int v81 = -15339;
        }

        else
        {
          BOOL v80 = v79 == -15991;
          int v81 = -15749;
        }

        BOOL v82 = v80 || v79 == v81;
        if (v82 && GTEventTracker_isBlocked((uint64_t)v47, (uint64_t)v61))
        {
          *(void *)(v56 + _Block_object_dispose(va, 8) = v76 >> 32;
LABEL_101:
          break;
        }

        v83 = apr_array_push(v32);
        __int128 v84 = *(_OWORD *)(v78 + 48);
        __int128 v86 = *(_OWORD *)v78;
        __int128 v85 = *(_OWORD *)(v78 + 16);
        v83[2] = *(_OWORD *)(v78 + 32);
        v83[3] = v84;
        _OWORD *v83 = v86;
        v83[1] = v85;
        int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v78 + 8));
        if (IsCommandEncoder(FuncEnumConstructorType))
        {
          bzero(v106, 0x2B90uLL);
          GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v106, (uint64_t *)v78, v102);
          WriteCommandEncoder(v105, v102, v32, v106[1]);
        }

        unsigned int v88 = atomic_load((unsigned int *)(v72 + 4));
        int v89 = v76 + (v88 >> 6);
        uint64_t v90 = (HIDWORD(v76) + 1);
        uint64_t v76 = (v90 << 32) | v76;
        if ((_DWORD)v90 == v89 - 1)
        {
          uint64_t v76 = (v90 << 32) | v90;
          uint64_t v72 = *(void *)(v72 + 40);
          goto LABEL_84;
        }
      }

      elts = v101->elts;
      uint64_t elt_size = v101->elt_size;
      uint64_t v93 = v101->nelts - 1LL;
      v101->uint64_t nelts = v93;
      memmove( &elts[(int)elt_size * (uint64_t)(int)((v56 - (uint64_t)elts) >> 4)],  &elts[elt_size + (int)elt_size * (uint64_t)(int)((v56 - (uint64_t)elts) >> 4)],  elt_size * (v93 - (int)((unint64_t)(v56 - (void)elts) >> 4)));
LABEL_103:
      uint64_t v31 = v99;
      v33 = v101;
      if (!v101->nelts) {
        goto LABEL_110;
      }
    }

    uint64_t v58 = 0LL;
LABEL_67:
    uint64_t v60 = 0LL;
    goto LABEL_68;
  }

LABEL_110:
  GTCoreLogTagEnabled(2uLL);
  if (v104 < v98) {
    ProcessResourceAPIs((uint64_t)v32, v104, v96 - v104, v47, *(void **)(v31 + 8));
  }
LABEL_112:
  apr_pool_destroy(newpool);
  *(void *)(v31 + 16) = v32;
}

uint64_t CompareGTTraceFunc(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t FindNextBufferToProcess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(unsigned int *)(a1 + 12);
  uint64_t v9 = 16 * v8;
  int v10 = v8 + 1;
  while (--v10 >= 1)
  {
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *find_entry(a3, (_BYTE *)(v11 + v9 - 16), 8uLL, 0LL);
    if (v12
      && (uint64_t v13 = *(void *)(v12 + 32)) != 0
      && (uint64_t v14 = *(void *)(v13 + 32)) != 0
      && (*(_BYTE *)(v14 + 79) & 8) != 0)
    {
      uint64_t v15 = v14 + 64;
    }

    else
    {
      uint64_t v15 = 0LL;
    }

    v9 -= 16LL;
    unsigned int v16 = GTTraceFunc_targetContext(v15, a4);
  }

  return 0LL;
}

uint64_t ProcessResourceAPIs(uint64_t result, unint64_t a2, uint64_t a3, uint64_t *a4, void *a5)
{
  arr = (apr_array_header_t *)result;
  uint64_t v7 = a5[3];
  uint64_t v8 = a5[68];
  uint64_t v9 = *(unsigned int *)(v8 + 12);
  if ((int)v9 < 1)
  {
    LODWORD(v10) = 0;
  }

  else
  {
    uint64_t v10 = 0LL;
    uint64_t v11 = *(unint64_t **)(v8 + 24);
    while (1)
    {
      unint64_t v12 = *v11;
      v11 += 8;
      if (a2 <= v12) {
        break;
      }
      if (v9 == ++v10) {
        return result;
      }
    }
  }

  if ((int)v10 < (int)v9)
  {
    unint64_t v13 = a2 + a3;
    for (unint64_t i = (unint64_t)v10 << 6; ; i += 64LL)
    {
      uint64_t v15 = *(void *)(v8 + 24);
      uint64_t v16 = v15 + i;
      if (v13 <= *(void *)(v15 + i)) {
        return result;
      }
      FuncStreamRef = GTTraceFunc_getFuncStreamRef(v15 + i, a5[3]);
      uint64_t v18 = a5[2];
      v33 = FuncStreamRef;
      id result = (uint64_t)find_entry(v18, &v33, 8uLL, 0LL);
      if (*(void *)result)
      {
        uint64_t v19 = *(void *)(*(void *)result + 32LL);
        if (v19)
        {
          uint64_t v20 = *(void *)(v19 + 32);
          if (v20)
          {
            if ((*(_BYTE *)(v20 + 79) & 8) != 0) {
              uint64_t v21 = v20 + 64;
            }
            else {
              uint64_t v21 = 0LL;
            }
          }

          else
          {
            uint64_t v21 = 0LL;
          }

          uint64_t v22 = v15 + i;
          int v23 = *(_BYTE *)(v15 + i + 15) & 0x40;
          int v24 = *(_DWORD *)(v15 + i + 8);
          if (v24 != -15490 && v24 != -15975 || v23 == 0) {
            goto LABEL_26;
          }
          __int128 v27 = GTTraceFunc_argumentBytesWithMap((void *)v16, *(unsigned __int8 *)(v22 + 13), v7);
          id result = GTEventTracker_isValueSignaled(a4, *(void *)v27, *((void *)v27 + 1));
          if ((result & 1) == 0) {
            break;
          }
        }
      }

LABEL_40:
      uint64_t v8 = a5[68];
      LODWORD(v10) = v10 + 1;
    }

    GTEventTracker_processFunction((uint64_t)a4, v16);
    int v24 = *(_DWORD *)(v22 + 8);
LABEL_26:
    id result = GetFuncEnumConstructorType(v24);
    if ((_DWORD)result != 25)
    {
      BOOL v28 = (v24 + 6144) > 0x29 || ((0x3806C9D5295uLL >> v24) & 1) == 0;
      if (v28
        && (((v24 + 15345) < 0x39) & (0x17C40BE00017E7FuLL >> (v24 - 15))) == 0
        && (_DWORD)result != 51
        && v24 != -20474
        && v24 != -20457)
      {
        if (v21 && (id result = IsFuncEnumCreateResource(*(_DWORD *)(v21 + 8)), (result & 1) != 0) || v24 == -10168)
        {
          id result = (uint64_t)apr_array_push(arr);
          __int128 v29 = *(_OWORD *)(v16 + 48);
          __int128 v31 = *(_OWORD *)v16;
          __int128 v30 = *(_OWORD *)(v16 + 16);
          *(_OWORD *)(result + 32) = *(_OWORD *)(v16 + 32);
          *(_OWORD *)(result + 4_Block_object_dispose(va, 8) = v29;
          *(_OWORD *)id result = v31;
          *(_OWORD *)(result + 16) = v30;
        }
      }
    }

    goto LABEL_40;
  }

  return result;
}

  v8->uint64_t nelts = 0;
  id result = (uint64_t)GTMTLSMContext_getObjects(*(_DWORD **)(a2 + 40), a3, v8);
  if (v8->nelts >= 1)
  {
    v36 = 0LL;
    do
    {
      uint64_t v37 = *(void **)&v8->elts[8 * v36];
      if (v37) {
        uint64_t v38 = v37[1];
      }
      else {
        uint64_t v38 = 0LL;
      }
      v71[0] = v38;
      id result = (uint64_t)find_entry(a1[2], v71, 8uLL, 0LL);
      if (*(void *)result && *(void *)(*(void *)result + 32LL))
      {
        if (v37[11]) {
          id result = GTResourceTrackerUsingResource(a1[2], 67, v37[5], *a1, a1[1]);
        }
        unsigned int v39 = (uint64_t *)v37[9];
        if (v39)
        {
          unint64_t v42 = *v39;
          uint64_t v41 = v39 + 1;
          unsigned int v40 = v42;
          if ((int)v42 >= 1)
          {
            uint64_t v43 = v40;
            do
            {
              unsigned int v44 = *v41++;
              id result = ResourceTracker_addFunction(a1, (uint64_t *)a2, v44, a3);
              --v43;
            }

            while (v43);
          }
        }

        else
        {
          GTMTLSMComputePipelineState_computePipelineDescriptor((uint64_t *)a2, (uint64_t)v37, __dst, p);
          GTResourceTrackerUsingResource(a1[2], 67, v55[1], *a1, a1[1]);
          ResourceTracker_addFunction(a1, (uint64_t *)a2, v53[12], a3);
          int v45 = v54;
          if (v54)
          {
            uint64_t v46 = (uint64_t *)v53[13];
            do
            {
              v47 = *v46++;
              ResourceTracker_addFunction(a1, (uint64_t *)a2, v47, a3);
              --v45;
            }

            while (v45);
          }

          v48 = v56;
          if (v56)
          {
            v49 = (uint64_t *)v55[2];
            do
            {
              int v50 = *v49++;
              ResourceTracker_addDynamicLibrary(a1, v50);
              --v48;
            }

            while (v48);
          }

          id result = ResourceTracker_addLinkedFunctions((uint64_t)a1, (uint64_t *)a2, v53, a3);
          if (v37[23])
          {
            id result = (uint64_t)GTMTLSMContext_getObject((uint64_t *)a2, v37[5], v37[2]);
            if (result)
            {
              uint64_t v51 = result;
              do
              {
                if (*(_DWORD *)v51 != 29) {
                  break;
                }
                GTResourceTrackerUsingResource(a1[2], 29, *(void *)(v51 + 8), *a1, a1[1]);
                id result = (uint64_t)GTMTLSMContext_getObject((uint64_t *)a2, *(void *)(v51 + 40), *(void *)(v51 + 16));
                uint64_t v51 = result;
              }

              while (result);
            }
          }
        }
      }

      ++v36;
    }

    while (v36 < v8->nelts);
  }

  return result;
}

  return v6;
}
}

  __int128 v31 = 0LL;
  v32 = 0LL;
LABEL_41:
  *__int128 v29 = v30 + v31;
  if (a4) {
    id result = (size_t)memcpy(v32, v28, v31);
  }
  if (v15)
  {
    id result = strlen(v15);
    v33 = (void *)(a3 + 416);
    uint64_t v34 = *(void *)(a3 + 416);
    unint64_t v35 = v18;
    v36 = result + 1;
    if (result != -1LL)
    {
      uint64_t v37 = *(void **)(a3 + 416);
      goto LABEL_48;
    }
  }

  else
  {
    unint64_t v35 = v18;
    v33 = (void *)(a3 + 416);
    uint64_t v34 = *(void *)(a3 + 416);
  }

  v36 = 0LL;
  uint64_t v37 = 0LL;
LABEL_48:
  char *v33 = v34 + v36;
  if (a4) {
    id result = (size_t)memcpy(v37, v15, v36);
  }
  if (v16)
  {
    id result = strlen(v16);
    uint64_t v38 = (void *)(a3 + 416);
    unsigned int v39 = *(void *)(a3 + 416);
    unsigned int v40 = result + 1;
    if (result != -1LL)
    {
      uint64_t v41 = *(void **)(a3 + 416);
      goto LABEL_55;
    }
  }

  else
  {
    uint64_t v38 = (void *)(a3 + 416);
    unsigned int v39 = *(void *)(a3 + 416);
  }

  unsigned int v40 = 0LL;
  uint64_t v41 = 0LL;
LABEL_55:
  *uint64_t v38 = v39 + v40;
  if (a4) {
    id result = (size_t)memcpy(v41, v16, v40);
  }
  if (v17)
  {
    id result = strlen(v17);
    unint64_t v42 = (void *)(a3 + 416);
    uint64_t v43 = *(void *)(a3 + 416);
    unsigned int v44 = result + 1;
    if (result != -1LL)
    {
      int v45 = *(void **)(a3 + 416);
      goto LABEL_62;
    }
  }

  else
  {
    unint64_t v42 = (void *)(a3 + 416);
    uint64_t v43 = *(void *)(a3 + 416);
  }

  unsigned int v44 = 0LL;
  int v45 = 0LL;
LABEL_62:
  *unint64_t v42 = v43 + v44;
  if ((a4 & 1) != 0)
  {
    id result = (size_t)memcpy(v45, v17, v44);
    uint64_t v46 = *(void *)(a3 + 312);
    *(void *)(a3 + 312) = v46 + 112;
    *(_OWORD *)uint64_t v46 = v53;
    *(void *)(v46 + 16) = v47;
    *(_OWORD *)(v46 + 24) = v59;
    *(int16x8_t *)(v46 + 40) = v51;
    *(_WORD *)(v46 + 56) = WORD2(v50);
    *(_WORD *)(v46 + 5_Block_object_dispose(va, 8) = v50;
    *(_DWORD *)(v46 + 60) = 0;
    *(void *)(v46 + 64) = v32;
    *(void *)(v46 + 72) = v37;
    *(void *)(v46 + 80) = v41;
    *(void *)(v46 + 8_Block_object_dispose(va, 8) = v45;
    *(_WORD *)(v46 + 96) = v57;
    *(_WORD *)(v46 + 9_Block_object_dispose(va, 8) = v56;
    *(_WORD *)(v46 + 100) = v55;
    *(_BYTE *)(v46 + 102) = v8;
    *(_BYTE *)(v46 + 103) = BYTE4(v49);
    *(_BYTE *)(v46 + 104) = v7;
    *(_BYTE *)(v46 + 105) = v58;
    *(_BYTE *)(v46 + 106) = v35;
    *(_BYTE *)(v46 + 107) = v54;
    *(_BYTE *)(v46 + 10_Block_object_dispose(va, 8) = v52;
    *(_BYTE *)(v46 + 109) = v49;
    *(_BYTE *)(v46 + 110) = v48;
    *(_BYTE *)(v46 + 111) = 0;
  }

  else
  {
    *(void *)(a3 + 312) += 112LL;
  }

  return result;
}

void WriteCommandEncoder(uint64_t a1, uint64_t a2, apr_array_header_t *a3, uint64_t a4)
{
  v25[0] = a4;
  entry = find_entry(a1, v25, 8uLL, 0LL);
  if (*entry) {
    uint64_t v8 = *(void *)(*entry + 32LL);
  }
  else {
    uint64_t v8 = 0LL;
  }
  uint64_t nelts = a3->nelts;
  uint64_t v10 = *(void *)(v8 + 32);
  if (v10)
  {
    unsigned int v11 = 0;
    while (1)
    {
      unsigned int v12 = atomic_load((unsigned int *)(v10 + 4));
      uint64_t v13 = v11 + (v12 >> 6) - 1;
      uint64_t v10 = *(void *)(v10 + 40);
      unsigned int v11 = v13;
      if (!v10)
      {
        unsigned int v11 = v13;
        goto LABEL_11;
      }
    }

    uint64_t v13 = 1LL;
  }

  else
  {
    unsigned int v11 = 0;
    uint64_t v13 = 0LL;
  }

uint64_t MapPresentToBoundary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a2 + 24) + (a1 << 6);
  if (GetFuncEnumReceiverType(*(_DWORD *)(v8 + 8)) == 25)
  {
    uint64_t v9 = GTTraceFunc_targetContext(v8, a4);
    unint64_t v10 = *(int *)(a2 + 12);
    if (v7 + 1 < v10)
    {
      unsigned int v11 = v9;
      for (uint64_t i = (v7++ << 6) + 72; ; i += 64LL)
      {
        uint64_t v13 = *(void *)(a2 + 24);
        int v14 = *(_DWORD *)(v13 + i);
        if (v14 <= -15909)
        {
          if (v14 == -16361 || v14 == -16202)
          {
LABEL_18:
            if (GTTraceFunc_targetContext(v13 + i - 8, a4) == v11) {
              return v7;
            }
            LODWORD(v10) = *(_DWORD *)(a2 + 12);
          }
        }

        else if (v14 == -15908 || v14 == -15316 || v14 == -15318)
        {
          goto LABEL_18;
        }
      }
    }

    ++v7;
  }

  else if (*(_BYTE *)(v8 + 12))
  {
    uint64_t v20 = *(void *)GTTraceFunc_argumentBytesWithMap((void *)v8, *(unsigned __int8 *)(v8 + 12), a4);
    uint64_t v18 = *find_entry(a3, &v20, 8uLL, 0LL);
    if (v18) {
      uint64_t v18 = *(void *)(v18 + 32);
    }
    if (v18) {
      return v18;
    }
    else {
      return -1LL;
    }
  }

  return v7;
}

void GTTraceDispatch_boundaries(apr_pool_t **a1, uint64_t a2)
{
  int v3 = a1;
  apr_pool_create_ex(&newpool, *a1, 0LL, 0LL);
  vm_size_t v4 = v3[1];
  uint64_t v5 = (const apr_array_header_t *)v3[2];
  uint64_t v6 = *((void *)v4 + 3);
  uint64_t v82 = *((void *)v4 + 2);
  uint64_t v7 = *((void *)v4 + 68);
  uint64_t v8 = apr_array_make(*v3, v5->nelts, v5->elt_size);
  uint64_t nelts = v5->nelts;
  uint64_t v10 = *(void *)(a2 + 48);
  switch(*(_DWORD *)(a2 + 80))
  {
    case 0:
    case 1:
      unsigned int v11 = apr_array_copy(*v3, v5);
      unsigned int v12 = v11;
      if (*(_DWORD *)(a2 + 80) != 1) {
        goto LABEL_60;
      }
      uint64_t v13 = v11->nelts;
      uint64_t v14 = 0LL;
      uint64_t v15 = (int *)(v11->elts + 8);
      while (2)
      {
        int v17 = *v15;
        v15 += 16;
        int v16 = v17;
        if (v17 <= -15909)
        {
          if (v16 != -16361 && v16 != -16202)
          {
LABEL_20:
            if (v13 == ++v14) {
              goto LABEL_60;
            }
            continue;
          }
        }

        else if (v16 != -15908 && v16 != -15316 && v16 != -15318)
        {
          goto LABEL_20;
        }

        break;
      }

      if (--v10) {
        goto LABEL_20;
      }
      IndexOfFirstCommandBufferInQueue = 0LL;
      uint64_t nelts = (v14 + 1);
      goto LABEL_120;
    case 2:
    case 3:
      IndexOfFirstCommandBufferInQueue = (apr_pool_t *)(int)FindIndexOfFirstCommandBufferInQueue( *(char **)(a2 + 8),  (uint64_t)v5,  v6);
      uint64_t nelts = v5->nelts - (void)IndexOfFirstCommandBufferInQueue;
      unsigned int v22 = apr_array_copy(*v3, v5);
      unsigned int v12 = v22;
      if (*(_DWORD *)(a2 + 80) != 3 || v22->nelts < 1) {
        goto LABEL_120;
      }
      int v23 = v3;
      uint64_t v24 = 0LL;
      uint64_t v25 = 0LL;
      __int128 v26 = *(char **)(a2 + 8);
      while (1)
      {
        elts = v12->elts;
        int v28 = *(_DWORD *)&elts[v24 + 8];
        if (v28 <= -15909)
        {
          BOOL v29 = v28 == -16361;
          int v30 = -16202;
        }

        else
        {
          BOOL v29 = v28 == -15908 || v28 == -15316;
          int v30 = -15318;
        }

        if (v29 || v28 == v30)
        {
          __int128 v84 = GTTraceFunc_targetContext((uint64_t)&elts[v24], v6);
          uint64_t v32 = *find_entry(v82, &v84, 8uLL, 0LL);
          if (v32
            && (uint64_t v33 = *(void *)(v32 + 32)) != 0
            && (uint64_t v34 = *(void *)(v33 + 32)) != 0
            && (*(_BYTE *)(v34 + 79) & 8) != 0)
          {
            uint64_t v35 = v34 + 64;
          }

          else
          {
            uint64_t v35 = 0LL;
          }

          if (v26 == GTTraceFunc_targetContext(v35, v6) && !--v10) {
            break;
          }
        }

        ++v25;
        v24 += 64LL;
        if (v25 >= v12->nelts) {
          goto LABEL_119;
        }
      }

      uint64_t nelts = v25 - (void)IndexOfFirstCommandBufferInQueue + 1;
LABEL_119:
      int v3 = v23;
      goto LABEL_120;
    case 4:
      IndexOfFirstCommandBufferInQueue = (apr_pool_t *)(int)FindIndexOfFirstCommandBufferInQueue( *(char **)(a2 + 8),  (uint64_t)v5,  v6);
      uint64_t nelts = v5->nelts - (void)IndexOfFirstCommandBufferInQueue;
      unsigned int v12 = apr_array_copy(*v3, v5);
      goto LABEL_120;
    case 5:
    case 6:
      uint64_t v36 = *(void *)(v7 + 24);
      int v37 = *(_DWORD *)(v36 + 8);
      BOOL v39 = GetFuncEnumReceiverType(v37) == 2 || v37 == -10168 || v37 == -16341;
      BOOL v80 = v3;
      if (!v39)
      {
        int v81 = *(char **)(a2 + 24);
        if (v81)
        {
          uint64_t v42 = 0LL;
          goto LABEL_69;
        }

        __int128 v84 = GTTraceFunc_targetContext(v36, v6);
        uint64_t v42 = *(void *)(*(void *)(*find_entry(v82, &v84, 8uLL, 0LL) + 32LL) + 32LL);
        if (v42)
        {
          unsigned int v71 = 0;
          do
          {
            unsigned int v72 = atomic_load((unsigned int *)(v42 + 4));
            uint64_t v73 = v71 + (v72 >> 6) - 1;
            uint64_t v42 = *(void *)(v42 + 40);
            unsigned int v71 = v73;
          }

          while (v42);
          unsigned int v71 = v73;
        }

        else
        {
          unsigned int v71 = 0;
LABEL_128:
          uint64_t v73 = 0LL;
        }

        uint64_t v43 = 0LL;
        unint64_t v74 = v71 | (unint64_t)(v73 << 32);
        while (1)
        {
          uint64_t v75 = v42 + 64;
          do
          {
            if (!v42) {
              goto LABEL_63;
            }
            if ((*(_BYTE *)(v75 + ((uint64_t)(HIDWORD(v74) - (int)v74) << 6) + 15) & 8) == 0)
            {
              uint64_t v42 = 0LL;
              goto LABEL_63;
            }

            uint64_t v76 = v75 + ((uint64_t)(HIDWORD(v74) - (int)v74) << 6);
            if (IsFuncEnumPresent(*(_DWORD *)(v76 + 8))) {
              uint64_t v43 = (char *)*((void *)GTTraceFunc_argumentBytesWithMap( (void *)v76,  *(unsigned __int8 *)(v76 + 13),  v6)
            }
                            + 1);
            unsigned int v77 = atomic_load((unsigned int *)(v42 + 4));
            int v78 = v74 + (v77 >> 6);
            uint64_t v79 = (HIDWORD(v74) + 1);
            unint64_t v74 = (v79 << 32) | v74;
          }

          while ((_DWORD)v79 != v78 - 1);
          unint64_t v74 = (v79 << 32) | v79;
          uint64_t v42 = *(void *)(v42 + 40);
        }
      }

      ++v10;
      BOOL v40 = IsFuncEnumPresent(v37);
      int v81 = *(char **)(a2 + 24);
      if (!v40 || *(void *)(a2 + 24) != 0LL)
      {
        uint64_t v42 = -1LL;
        goto LABEL_69;
      }

      uint64_t v43 = GTTraceFunc_targetContext(v36, v6);
      uint64_t v42 = -1LL;
LABEL_63:
      __int128 v84 = v43;
      uint64_t v44 = *find_entry(v82, &v84, 8uLL, 0LL);
      if (v44
        && (uint64_t v45 = *(void *)(v44 + 32)) != 0
        && (uint64_t v46 = *(void *)(v45 + 32)) != 0
        && (*(_BYTE *)(v46 + 79) & 8) != 0)
      {
        uint64_t v47 = v46 + 64;
      }

      else
      {
        uint64_t v47 = 0LL;
      }

      int v81 = GTTraceFunc_targetContext(v47, v6);
LABEL_69:
      v48 = apr_hash_make(newpool);
      uint64_t v49 = v5->nelts;
      int v50 = v48;
      uint64_t v51 = 0LL;
      uint64_t v52 = 0LL;
      while (2)
      {
        uint64_t v53 = v5->elts;
        int v54 = *(_DWORD *)&v53[v51 + 8];
        if (v54 <= -15909)
        {
          BOOL v55 = v54 == -16361;
          int v56 = -16202;
        }

        else
        {
          BOOL v55 = v54 == -15908 || v54 == -15316;
          int v56 = -15318;
        }

        if (v55 || v54 == v56)
        {
          apr_hash_set(v50, &v53[v51], 8LL, v52);
          int v54 = *(_DWORD *)&v53[v51 + 8];
        }

        if (IsFuncEnumPresent(v54))
        {
          else {
            uint64_t v58 = GTTraceFunc_targetContext((uint64_t)&v53[v51], v6);
          }
          __int128 v84 = v58;
          uint64_t v60 = *find_entry(v82, &v84, 8uLL, 0LL);
          if (v60
            && (uint64_t v61 = *(void *)(v60 + 32)) != 0
            && (uint64_t v62 = *(void *)(v61 + 32)) != 0
            && (*(_BYTE *)(v62 + 79) & 8) != 0)
          {
            uint64_t v63 = v62 + 64;
          }

          else
          {
            uint64_t v63 = 0LL;
          }

          if (v81 != GTTraceFunc_targetContext(v63, v6)) {
            goto LABEL_102;
          }
        }

        else if (v54 != -16341 && v54 != -10168)
        {
          goto LABEL_102;
        }

        uint64_t v64 = MapPresentToBoundary((uint64_t)v52, (uint64_t)v5, (uint64_t)v50, v6);
        if (v64 == -1) {
          goto LABEL_102;
        }
        uint64_t v49 = v64;
        if (v42 == -1) {
          uint64_t v42 = v64;
        }
        if (--v10)
        {
LABEL_102:
          ++v52;
          uint64_t v49 = v5->nelts;
          v51 += 64LL;
          continue;
        }

        break;
      }

LABEL_105:
      if (v42 == -1) {
        uint64_t v65 = 0LL;
      }
      else {
        uint64_t v65 = v42;
      }
      unsigned int v12 = apr_array_copy(*v80, v5);
      int v66 = *((_DWORD *)v12->elts + 2);
      BOOL v67 = IsFuncEnumPresent(v66);
      uint64_t v69 = v66 == -10168 || v66 == -16341 || v67;
      IndexOfFirstCommandBufferInQueue = (apr_pool_t *)(v65 + v69);
      uint64_t v70 = v49 - (v65 + v69);
      int v3 = v80;
      uint64_t nelts = v70 + 1;
LABEL_120:
      v3[2] = (apr_pool_t *)v12;
      v3[3] = IndexOfFirstCommandBufferInQueue;
      v3[4] = (apr_pool_t *)nelts;
      apr_pool_destroy(newpool);
      return;
    default:
      unsigned int v12 = v8;
LABEL_60:
      IndexOfFirstCommandBufferInQueue = 0LL;
      goto LABEL_120;
  }

  for (n = 0LL; n != 87; ++n)
  {
    v106 = v197[n];
    v107 = *(_DWORD *)(v106 + 12);
    if (v107 >= 1)
    {
      v108 = 0LL;
      v109 = &buf[24 * n];
      do
      {
        v110 = *(unsigned int **)(*(void *)(v106 + 24) + 8 * v108);
        if (v110)
        {
          do
          {
            v111 = atomic_load(v110 + 1);
            *((void *)v109 + 1) += v111;
            *((void *)v109 + 2) += *v110;
            v110 = (unsigned int *)*((void *)v110 + 5);
          }

          while (v110);
          v107 = *(_DWORD *)(v106 + 12);
        }

        ++*(void *)v109;
        ++v108;
      }

      while (v108 < v107);
    }

    v112 = &__base[n];
    *((_DWORD *)v112 + 2) = n;
    *(void *)v112 = *(void *)&v193[24 * n + 12];
  }

  qsort(__base, 0x57uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))CompareKeyValuePair);
  v113 = apr_array_make(v91, 32, 16);
  v114 = apr_hash_make(v91);
  v115 = apr_hash_make(v91);
  v116 = 0LL;
  v117 = (double)v90;
  do
  {
    v118 = DWORD2(__base[v116]);
    v119 = &buf[24 * v118];
    v167 = v116;
    if (s_logUsingOsLog)
    {
      v120 = (os_log_s *)gt_tagged_log(1uLL);
      if (os_log_type_enabled(v120, OS_LOG_TYPE_INFO))
      {
        v121 = "Unknown";
        v122 = &buf[24 * v118];
        v124 = *((void *)v122 + 1);
        v123 = *((double *)v122 + 2);
        v125 = *(void *)v119;
        *(_DWORD *)v180 = 67110658;
        v181 = v118;
        v182 = 2048;
        v183 = v124;
        v184 = 2048;
        v185 = v123;
        v186 = 2048;
        *(double *)v187 = (double)v124 * 100.0 / v117;
        *(_WORD *)&v187[8] = 2048;
        *(double *)&v187[10] = (double)*(unint64_t *)&v123 * 100.0 / v117;
        v188 = 2048;
        v189 = v125;
        v190 = 2080;
        v191 = v121;
        _os_log_impl( &dword_0,  v120,  OS_LOG_TYPE_INFO,  "%d:\t%'zub / %'zub\t|\t%.1f%% / %.1f%%\t|\t(%'zu)\t|\t%s",  v180,  0x44u);
      }
    }

    else
    {
      v126 = "Unknown";
      fprintf( __stdoutp,  "%d:\t%'zub / %'zub\t|\t%.1f%% / %.1f%%\t|\t(%'zu)\t|\t%s\n",  v118,  *(void *)&v193[24 * v118 + 4],  *(void *)&v193[24 * v118 + 12],  (double)*(unint64_t *)&v193[24 * v118 + 4] * 100.0 / v117,  (double)*(unint64_t *)&v193[24 * v118 + 12] * 100.0 / v117,  *(void *)v119,  v126);
    }

    apr_hash_clear(v114);
    apr_hash_clear(v115);
    v127 = v197[v118];
    v128 = *(_DWORD *)(v127 + 12);
    if (v128 >= 1)
    {
      for (iuint64_t i = 0LL; ii < v128; ++ii)
      {
        v130 = *(void *)(*(void *)(v127 + 24) + 8 * ii);
        if (v130)
        {
          do
          {
            v131 = atomic_load((unsigned int *)(v130 + 4));
            v132 = v131 - 64;
            if ((int)(v131 - 64) >= 1)
            {
              v133 = (_DWORD *)(v130 + 64);
              do
              {
                apr_hash_set(v115, v133, 9LL, v133);
                v134 = (v133[3] + 23) & 0xFFFFFFF8;
                v133 = (_DWORD *)((char *)v133 + v134);
                v135 = __OFSUB__(v132, v134);
                v132 -= v134;
              }

              while (!((v132 < 0) ^ v135 | (v132 == 0)));
            }

            v130 = *(void *)(v130 + 40);
          }

          while (v130);
          v128 = *(_DWORD *)(v127 + 12);
        }
      }
    }

    v136 = ht;
    v137 = *(apr_pool_t **)v114;
    *((void *)v115 + 2) = v115;
    *((void *)v115 + 3) = 0LL;
    *((void *)v115 + 4) = 0LL;
    *((_DWORD *)v115 + 10) = 0;
    v138 = apr_hash_next((apr_hash_t *)((char *)v115 + 16));
    if (v138)
    {
      v139 = v138;
      do
      {
        v140 = *(void *)(*((void *)v139 + 1) + 32LL);
        v141 = *find_entry((uint64_t)v136, (_BYTE *)v140, 8uLL, 0LL);
        if (v141)
        {
          v142 = *(void *)(v141 + 32);
          if (v142)
          {
            v143 = (_DWORD *)(v142 + 8);
            v144 = *find_entry((uint64_t)v114, (_BYTE *)(v142 + 8), 4uLL, 0LL);
            if (!v144 || (v145 = *(void **)(v144 + 32)) == 0LL)
            {
              v146 = apr_palloc(v137, 0x10uLL);
              v145 = v146;
              if (v146)
              {
                *v146 = 0LL;
                v146[1] = 0LL;
              }

              *((_DWORD *)v146 + 2) = *v143;
              apr_hash_set(v114, v146 + 1, 4LL, v146);
            }

            *v145 += *(unsigned int *)(v140 + 12);
            ++*((_DWORD *)v145 + 3);
          }
        }

        v139 = apr_hash_next(v139);
      }

      while (v139);
    }

    v113->uint64_t nelts = 0;
    *((void *)v114 + 2) = v114;
    v147 = (apr_hash_t *)((char *)v114 + 16);
    *((void *)v114 + 3) = 0LL;
    *((void *)v114 + 4) = 0LL;
    *((_DWORD *)v114 + 10) = 0;
    while (1)
    {
      v148 = apr_hash_next(v147);
      if (!v148) {
        break;
      }
      *(_OWORD *)apr_array_push(v113) = *(_OWORD *)*(void *)(*((void *)v148 + 1) + 32LL);
      v147 = v148;
    }

    qsort(v113->elts, v113->nelts, v113->elt_size, (int (__cdecl *)(const void *, const void *))CompareKeyValuePair);
    if (v113->nelts >= 1)
    {
      v149 = 0LL;
      v150 = 0LL;
      do
      {
        v151 = &v113->elts[v149];
        v152 = *(void *)v151;
        v153 = *((_DWORD *)v151 + 2);
        v154 = *((_DWORD *)v151 + 3);
        if (s_logUsingOsLog)
        {
          v155 = (os_log_s *)gt_tagged_log(1uLL);
          if (os_log_type_enabled(v155, OS_LOG_TYPE_INFO))
          {
            v156 = GetFuncEnumAsString(v153);
            *(_DWORD *)v180 = 67110146;
            v181 = v153;
            v182 = 2048;
            v183 = v152;
            v184 = 2048;
            v185 = (double)v152 * 100.0 / v117;
            v186 = 1024;
            *(_DWORD *)v187 = v154;
            *(_WORD *)&v187[4] = 2080;
            *(void *)&v187[6] = v156;
            _os_log_impl(&dword_0, v155, OS_LOG_TYPE_INFO, "*\t0x%x:\t%'zub\t|\t%.1f%%\t|\t(%'u)\t|\t%s", v180, 0x2Cu);
          }
        }

        else
        {
          v157 = __stdoutp;
          v158 = GetFuncEnumAsString(v153);
          fprintf( v157,  "*\t0x%x:\t%'zub\t|\t%.1f%%\t|\t(%'u)\t|\t%s\n",  v153,  v152,  (double)v152 * 100.0 / v117,  v154,  v158);
        }

        ++v150;
        v159 = v113->nelts;
        if (v159 >= 5) {
          v159 = 5;
        }
        v149 += 16LL;
      }

      while (v150 < v159);
    }

    v116 = v167 + 1;
  }

  while (v167 != 4);
  pthread_mutex_unlock(v160);
  apr_pool_destroy(newpool);
  return v161;
}

    id result = (uint64_t)SaveFileWithURL(*(void *)(result + 32), *(char **)(a3 + 16), a4, &v49, 1);
    goto LABEL_161;
  }

  if (a2 > -7164)
  {
    if (a2 > -6144)
    {
      switch(a2)
      {
        case -6143:
        case -6131:
        case -6111:
          *(void *)(a3 + 16) = StoreMPSPluginCNNConvolutionDescriptorUsingEncode( *(void *)(result + 32),  *(void *)(a3 + 16),  (uint64_t)a4,  &v49);
          id result = StoreMPSPluginCNNConvolutionDataUsingEncode( v11,  *(unsigned int **)(a3 + 24),  (uint64_t)&v10[-v49],  &v49);
          goto LABEL_285;
        case -6142:
          *(void *)(a3 + 56) = StoreMPSSourceTextureInfoUsingEncode( *(void *)(result + 32),  *(void **)(a3 + 56),  (uint64_t)a4,  &v49);
          id result = StoreMPSDestinationTextureInfoUsingEncode(v11, *(void **)(a3 + 80), (uint64_t)&v10[-v49], &v49);
          *(void *)(a3 + 80) = result;
          return result;
        case -6135:
        case -6126:
        case -6121:
          *(void *)(a3 + 4_Block_object_dispose(va, 8) = StoreMPSSourceTextureInfoUsingEncode( *(void *)(result + 32),  *(void **)(a3 + 48),  (uint64_t)a4,  &v49);
          id result = StoreMPSDestinationTextureInfoUsingEncode(v11, *(void **)(a3 + 64), (uint64_t)&v10[-v49], &v49);
          *(void *)(a3 + 64) = result;
          return result;
        case -6129:
          goto LABEL_74;
        case -6127:
        case -6120:
          id result = StoreMPSPluginCNNConvolutionDataUsingEncode( *(void *)(result + 32),  *(unsigned int **)(a3 + 8),  (uint64_t)a4,  &v49);
          goto LABEL_245;
        case -6125:
          *(void *)(a3 + 56) = StoreMPSSourceTextureInfoUsingEncode( *(void *)(result + 32),  *(void **)(a3 + 56),  (uint64_t)a4,  &v49);
          *(void *)(a3 + 72) = StoreMPSSourceTextureInfoUsingEncode( v11,  *(void **)(a3 + 72),  (uint64_t)&v10[-v49],  &v49);
          goto LABEL_206;
        case -6118:
          *(void *)(a3 + 64) = StoreMPSSourceTextureInfoUsingEncode( *(void *)(result + 32),  *(void **)(a3 + 64),  (uint64_t)a4,  &v49);
          *(void *)(a3 + 8_Block_object_dispose(va, 8) = StoreMPSSourceTextureInfoUsingEncode( v11,  *(void **)(a3 + 88),  (uint64_t)&v10[-v49],  &v49);
          id result = StoreMPSDestinationTextureInfoUsingEncode(v11, *(void **)(a3 + 112), (uint64_t)&v10[-v49], &v49);
          *(void *)(a3 + 112) = result;
          return result;
        case -6117:
          *(void *)(a3 + 56) = StoreMPSSourceTextureInfoUsingEncode( *(void *)(result + 32),  *(void **)(a3 + 56),  (uint64_t)a4,  &v49);
          id result = StoreMPSDestinationTextureInfoUsingEncode(v11, *(void **)(a3 + 72), (uint64_t)&v10[-v49], &v49);
          *(void *)(a3 + 72) = result;
          return result;
        case -6115:
          *(void *)(a3 + 64) = StoreMPSSourceTextureInfoUsingEncode( *(void *)(result + 32),  *(void **)(a3 + 64),  (uint64_t)a4,  &v49);
LABEL_206:
          id result = StoreMPSDestinationTextureInfoUsingEncode(v11, *(void **)(a3 + 88), (uint64_t)&v10[-v49], &v49);
          goto LABEL_209;
        case -6114:
          *(void *)(a3 + 64) = StoreMPSSourceTextureInfoUsingEncode( *(void *)(result + 32),  *(void **)(a3 + 64),  (uint64_t)a4,  &v49);
          id result = StoreMPSSourceTextureInfoUsingEncode(v11, *(void **)(a3 + 88), (uint64_t)&v10[-v49], &v49);
          goto LABEL_209;
        case -6102:
        case -6100:
        case -6099:
        case -6098:
          *(void *)(a3 + 56) = StoreMPSNDArrayStructureUsingEncode( *(void *)(result + 32),  *(void *)(a3 + 56),  (uint64_t)a4,  &v49);
          *(void *)(a3 + 72) = StoreMPSNDArrayStructureUsingEncode( v11,  *(void *)(a3 + 72),  (uint64_t)&v10[-v49],  &v49);
          *(void *)(a3 + 8_Block_object_dispose(va, 8) = StoreMPSNDArrayStructureUsingEncode( v11,  *(void *)(a3 + 88),  (uint64_t)&v10[-v49],  &v49);
          id result = StoreMPSNDArrayStructureUsingEncode(v11, *(void *)(a3 + 104), (uint64_t)&v10[-v49], &v49);
          *(void *)(a3 + 104) = result;
          return result;
        case -6097:
          *(void *)(a3 + 56) = StoreMPSNDArrayStructureUsingEncode( *(void *)(result + 32),  *(void *)(a3 + 56),  (uint64_t)a4,  &v49);
          *(void *)(a3 + 72) = StoreMPSNDArrayStructureUsingEncode( v11,  *(void *)(a3 + 72),  (uint64_t)&v10[-v49],  &v49);
          id result = StoreMPSNDArrayStructureUsingEncode(v11, *(void *)(a3 + 88), (uint64_t)&v10[-v49], &v49);
LABEL_209:
          *(void *)(a3 + 8_Block_object_dispose(va, 8) = result;
          break;
        case -6096:
        case -6095:
          id result = StoreMPSPluginNDArrayConvolutionDescriptorUsingEncode( *(void *)(result + 32),  *(unsigned __int8 **)(a3 + 16),  (uint64_t)a4,  &v49);
          goto LABEL_161;
        default:
          return result;
      }

      return result;
    }

    if (a2 == -7163)
    {
      id result = StoreMTLDeviceDescriptorUsingEncode(*(void *)(result + 32), *(void *)(a3 + 16), (uint64_t)a4, &v49);
      goto LABEL_161;
    }

    if (a2 == -7153) {
      goto LABEL_158;
    }
    if (a2 != -6654) {
      return result;
    }
    id result = StoreMTLDeviceDescriptorUsingEncode(*(void *)(result + 32), *(void *)(a3 + 24), (uint64_t)a4, &v49);
LABEL_285:
    *(void *)(a3 + 24) = result;
    return result;
  }

  if (a2 <= -15261)
  {
    if (a2 <= -15297)
    {
      switch(a2)
      {
        case -15366:
        case -15356:
        case -15355:
          goto LABEL_160;
        case -15364:
          id result = StoreMTLAccelerationStructurePassDescriptorUsingEncode( *(void *)(result + 32),  *(void *)(a3 + 16),  (uint64_t)a4,  &v49,  a6);
          goto LABEL_161;
        case -15363:
          *(void *)(a3 + 24) = UnwrapMTLArray_( *(void *)(result + 32),  *(unint64_t **)(a3 + 24),  (uint64_t)a4,  &v49,  a6);
          uint64_t v35 = *(unsigned __int8 **)(a3 + 32);
          uint64_t v36 = (uint64_t)&v10[-v49];
          int v37 = v11;
          goto LABEL_240;
        case -15362:
          id result = StoreMTLAccelerationStructureDescriptorUsingEncode( *(void *)(result + 32),  *(unsigned __int8 **)(a3 + 24),  (uint64_t)a4,  &v49,  a6);
          goto LABEL_285;
        case -15358:
          id result = StoreMTLAccelerationStructureAllocationDescriptorUsingEncode( *(void *)(result + 32),  *(void *)(a3 + 24),  (uint64_t)a4,  &v49);
          goto LABEL_285;
        case -15350:
          id result = StoreMTLIOCommandQueueDescriptorUsingEncode( *(void *)(result + 32),  *(unsigned int **)(a3 + 16),  (uint64_t)a4,  &v49);
          goto LABEL_161;
        case -15348:
          goto LABEL_218;
        default:
          return result;
      }

      return result;
    }

    if (a2 <= -15282)
    {
      if (a2 != -15296)
      {
        if (a2 != -15294)
        {
          if (a2 != -15282) {
            return result;
          }
          goto LABEL_129;
        }

        goto LABEL_158;
      }

uint64_t FindIndexOfFirstCommandBufferInQueue(char *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0LL;
  }
  int v4 = *(_DWORD *)(a2 + 12);
  if (v4 < 1) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  for (uint64_t i = 0LL; i < v4; ++i)
  {
    uint64_t v9 = *(void *)(a2 + 24) + v7;
    int v10 = *(_DWORD *)(v9 + 8);
    int FuncEnumReceiverType = GetFuncEnumReceiverType(v10);
    else {
      BOOL v12 = 0;
    }
    if (v12)
    {
      if (GTTraceFunc_targetContext(v9, a3) == a1) {
        return i;
      }
      int v4 = *(_DWORD *)(a2 + 12);
    }

    v7 += 64LL;
  }

  return i;
}

void *GTTraceDispatch_serialize(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v313 = *(void *)(*(void *)(a1 + 8) + 24LL);
  uint64_t v315 = a1;
  int v4 = newpool[0];
  uint64_t v5 = apr_hash_make(newpool[0]);
  uint64_t v6 = apr_hash_make(v4);
  p = v4;
  arr = apr_array_make(v4, 8, 16);
  if (*(_DWORD *)(v3 + 12))
  {
    uint64_t v7 = 0LL;
    for (uint64_t i = 0LL; (unint64_t)i < *(int *)(v3 + 12); ++i)
    {
      uint64_t v9 = *(void *)(v3 + 24);
      uint64_t v10 = v9 + v7;
      int v11 = *(_DWORD *)(v9 + v7 + 8);
      if (v11 <= -15909)
      {
        if (v11 != -16361 && v11 != -16202) {
          goto LABEL_13;
        }
      }

      else if (v11 != -15908 && v11 != -15316 && v11 != -15318)
      {
        goto LABEL_13;
      }

      apr_hash_set(v5, (const void *)(v9 + v7), 8LL, i);
      int v11 = *(_DWORD *)(v10 + 8);
LABEL_13:
      if (IsFuncEnumPresent(v11) && GetFuncEnumReceiverType(v11) == 2)
      {
        uint64_t v14 = MapPresentToBoundary((uint64_t)i, v3, (uint64_t)v5, v313);
        if (v14 == -1)
        {
          uint64_t v18 = apr_palloc(v4, 8uLL);
          *uint64_t v18 = i;
          apr_hash_set(v6, v18, 8LL, (char *)&dword_0 + 1);
        }

        else
        {
          uint64_t v15 = v14;
          int v16 = apr_array_push(arr);
          void *v16 = v15;
          v16[1] = i;
        }
      }

      v7 += 64LL;
    }
  }

  size_t nelts = arr->nelts;
  if ((int)nelts <= 0)
  {
    uint64_t v20 = v315;
  }

  else
  {
    qsort(arr->elts, nelts, arr->elt_size, (int (__cdecl *)(const void *, const void *))CompareCommandBufferIndex);
    uint64_t v20 = v315;
    uint64_t v21 = apr_array_make( *(apr_pool_t **)v315,  *(_DWORD *)(*(void *)(v315 + 16) + 12LL),  *(_DWORD *)(*(void *)(v315 + 16) + 8LL));
    *(void *)&__int128 v334 = 0LL;
    *(void *)&v332[0] = 0LL;
    elts = arr->elts;
    *(void *)&key[0] = 0LL;
    if (*(_DWORD *)(v3 + 12))
    {
      unint64_t v23 = 0LL;
      int v24 = 1;
      while (1)
      {
        uint64_t v25 = (__int128 *)(*(void *)(v3 + 24) + (v23 << 6));
        if (v23 == *(void *)elts)
        {
          unint64_t v26 = *(void *)(v315 + 24);
          uint64_t v27 = *(void *)(v315 + 32);
          int v28 = apr_array_push(v21);
          __int128 v29 = v25[3];
          __int128 v31 = *v25;
          __int128 v30 = v25[1];
          v28[2] = v25[2];
          v28[3] = v29;
          *int v28 = v31;
          v28[1] = v30;
          if (v26 > v23)
          {
            uint64_t v32 = &v334;
            goto LABEL_38;
          }

          if (v27 + v26 > v23)
          {
            uint64_t v32 = v332;
LABEL_38:
            ++*(void *)v32;
          }

          uint64_t v42 = *(void *)elts;
          uint64_t v45 = *((void *)elts + 1);
          uint64_t v44 = elts + 8;
          uint64_t v43 = v45;
          if (v42 != v45)
          {
            uint64_t v46 = (__int128 *)(*(void *)(v3 + 24) + (v43 << 6));
            unint64_t v47 = *(void *)&key[0];
            unint64_t v48 = *(void *)(v315 + 24);
            uint64_t v49 = *(void *)(v315 + 32);
            int v50 = apr_array_push(v21);
            __int128 v51 = v46[3];
            __int128 v53 = *v46;
            __int128 v52 = v46[1];
            v50[2] = v46[2];
            v50[3] = v51;
            *int v50 = v53;
            v50[1] = v52;
            if (v48 > v47)
            {
              int v54 = &v334;
              goto LABEL_47;
            }

            if (v49 + v48 > v47)
            {
              int v54 = v332;
LABEL_47:
              ++*(void *)v54;
            }
          }

          apr_hash_set(v6, v44, 8LL, (char *)&dword_0 + 1);
          elts = &arr->elts[16 * v24++];
          goto LABEL_49;
        }

        if (*((_DWORD *)v6 + 12) && (uint64_t v33 = *find_entry((uint64_t)v6, key, 8uLL, 0LL)) != 0 && *(void *)(v33 + 32))
        {
          apr_hash_set(v6, key, 8LL, 0LL);
        }

        else
        {
          unint64_t v34 = *(void *)&key[0];
          unint64_t v35 = *(void *)(v315 + 24);
          uint64_t v36 = *(void *)(v315 + 32);
          int v37 = apr_array_push(v21);
          __int128 v38 = v25[3];
          __int128 v40 = *v25;
          __int128 v39 = v25[1];
          v37[2] = v25[2];
          v37[3] = v38;
          *int v37 = v40;
          v37[1] = v39;
          if (v35 > v34)
          {
            uint64_t v41 = &v334;
LABEL_44:
            ++*(void *)v41;
            goto LABEL_49;
          }

          if (v36 + v35 > v34)
          {
            uint64_t v41 = v332;
            goto LABEL_44;
          }
        }

LABEL_49:
        unint64_t v23 = *(void *)&key[0] + 1LL;
        *(void *)&key[0] = v23;
        if (v23 >= *(int *)(v3 + 12))
        {
          uint64_t v55 = v334;
          uint64_t v56 = *(void *)&v332[0];
          p = newpool[0];
          goto LABEL_53;
        }
      }
    }

    uint64_t v56 = 0LL;
    uint64_t v55 = 0LL;
LABEL_53:
    *(void *)(v315 + 16) = v21;
    *(void *)(v315 + 24) = v55;
    *(void *)(v315 + 32) = v56;
  }

  apr_pool_destroy(p);
  apr_pool_create_ex((apr_pool_t **)&v334, *(apr_pool_t **)v20, 0LL, 0LL);
  uint64_t v57 = *(void **)(v20 + 8);
  uint64_t v58 = *(const apr_array_header_t **)(v20 + 16);
  uint64_t v59 = v57[2];
  uint64_t v60 = v57[71];
  uint64_t v61 = v57[6];
  pa = (apr_pool_t *)v57[5];
  uint64_t v62 = (apr_pool_t *)v334;
  uint64_t v63 = GTResourceTrackerMake(v59, v57[3], (apr_pool_t *)v334);
  uint64_t v65 = *(void *)(v20 + 32);
  uint64_t v64 = (apr_array_header_t *)(v20 + 32);
  if (&v64[-1].elts[v65])
  {
    uint64_t v66 = 0LL;
    unint64_t v67 = 0LL;
    do
    {
      GTResourceTrackerProcessFunction(v63, (uint64_t)&v58->elts[v66]);
      ++v67;
      v66 += 64LL;
    }

    while ((apr_pool_t *)((char *)v64->pool + (unint64_t)v64[-1].elts) > (apr_pool_t *)v67);
  }

  arra = (apr_array_header_t *)((char *)v64 - 8);
  v314 = v64;
  ResourceTracker_processUsedDrawables((uint64_t)v63);
  uint64_t v68 = v63[2];
  uint64_t v69 = apr_array_make(v62, v58->nelts, v58->elt_size);
  uint64_t v70 = apr_array_make(v62, 4, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(v60 + 240), (unint64_t)pa, v70);
  uint64_t v71 = v70->nelts;
  if ((int)v71 >= 1)
  {
    v307 = (char *)pa + v61;
    do
    {
      uint64_t v72 = *(void *)&v70->elts[8 * (v71 - 1)];
      entry = find_entry(v68, (_BYTE *)(v72 + 8), 8uLL, 0LL);
      if (*entry && *(void *)(*entry + 32LL))
      {
        newpool[0] = *(apr_pool_t **)(v72 + 8);
        uint64_t v74 = *find_entry(v59, newpool, 8uLL, 0LL);
        if (!v74)
        {
          id result = apr_array_push(v69);
          __break(1u);
          return result;
        }

        uint64_t v75 = *(void *)(v74 + 32);
        uint64_t v76 = apr_array_push(v69);
        unsigned int v77 = *(_OWORD **)(v75 + 32);
        __int128 v78 = v77[4];
        __int128 v79 = v77[5];
        __int128 v80 = v77[7];
        v76[2] = v77[6];
        v76[3] = v80;
        *uint64_t v76 = v78;
        v76[1] = v79;
        v69->elts[64 * (uint64_t)v69->nelts - 49] = 64;
        int v81 = find_entry(v68, (_BYTE *)(v72 + 48), 8uLL, 0LL);
        if (*v81)
        {
          if (*(void *)(*v81 + 32LL))
          {
            uint64_t v82 = *(void *)(v75 + 32);
            if (v82)
            {
              unsigned int v83 = 0;
              while (1)
              {
                unsigned int v84 = atomic_load((unsigned int *)(v82 + 4));
                uint64_t v85 = v83 + (v84 >> 6) - 1;
                uint64_t v82 = *(void *)(v82 + 40);
                unsigned int v83 = v85;
                if (!v82)
                {
                  unsigned int v83 = v85;
                  goto LABEL_71;
                }
              }
            }

            else
            {
              unsigned int v83 = 0;
            }

            uint64_t v85 = 0LL;
LABEL_71:
            unint64_t v86 = v83 | (unint64_t)(v85 << 32);
            while (1)
            {
              uint64_t v87 = (*(_BYTE *)(v82 + 64 + ((uint64_t)(0xFFFFFFFF00000001LL * v86) >> 32 << 6) + 15) & 8) != 0
              if (*(_DWORD *)(v87 + 8) == -7167) {
                break;
              }
              unsigned int v88 = atomic_load((unsigned int *)(v82 + 4));
              int v89 = v86 + (v88 >> 6);
              uint64_t v90 = (HIDWORD(v86) + 1);
              unint64_t v86 = (v90 << 32) | v86;
              if ((_DWORD)v90 == v89 - 1)
              {
                unint64_t v86 = (v90 << 32) | v90;
                uint64_t v82 = *(void *)(v82 + 40);
              }
            }

            BOOL v91 = (unint64_t)pa <= *(void *)v87 && (unint64_t)v307 > *(void *)v87;
            if (!v91)
            {
              v92 = apr_array_push(v69);
              __int128 v93 = *(_OWORD *)v87;
              __int128 v94 = *(_OWORD *)(v87 + 16);
              __int128 v95 = *(_OWORD *)(v87 + 48);
              v92[2] = *(_OWORD *)(v87 + 32);
              v92[3] = v95;
              _OWORD *v92 = v93;
              v92[1] = v94;
              v69->elts[64 * (uint64_t)v69->nelts - 49] = 64;
            }
          }
        }
      }

      BOOL v91 = v71-- <= 1;
    }

    while (!v91);
  }

  uint64_t v96 = arra;
  uint64_t v97 = arra->pool;
  unint64_t v98 = arra;
  if (!arra->pool)
  {
    unint64_t v98 = v314;
    uint64_t v97 = v314->pool;
  }

  v98->pool = (apr_pool_t *)((char *)v97 + v69->nelts);
  uint64_t v99 = *(apr_pool_t **)v315;
  uint64_t v100 = (apr_array_header_t *)apr_palloc(*(apr_pool_t **)v315, 0x20uLL);
  v100->pool = v99;
  v100->elts = v69->elts;
  *(void *)&v100->uint64_t elt_size = *(void *)&v69->elt_size;
  v100->nalloc = v69->nelts;
  apr_array_cat(v100, v58);
  *(void *)(v315 + 16) = v100;
  apr_pool_destroy((apr_pool_t *)v334);
  apr_pool_create_ex(newpool, *(apr_pool_t **)v315, 0LL, 0LL);
  if (*(void *)(v315 + 32) + *(void *)(v315 + 24))
  {
    uint64_t v281 = 0LL;
    v282 = 0LL;
    uint64_t v283 = *(void *)(v315 + 8);
    uint64_t v284 = *(void *)(v315 + 16);
    uint64_t v285 = *(void *)(v283 + 24);
    v286 = *(uint64_t **)(v283 + 568);
    do
    {
      uint64_t v287 = *(void *)(v284 + 24);
      int v288 = *(_DWORD *)(v287 + v281 + 8);
      if (v288 != -7167
        && (GetFuncEnumReceiverType(*(_DWORD *)(v287 + v281 + 8)) == 80
         || GetFuncEnumConstructorType(v288) == 80))
      {
        FuncStreamRef = GTTraceFunc_getFuncStreamRef(v287 + v281, v285);
        Object = GTMTLSMContext_getObject(v286, (uint64_t)FuncStreamRef, *(void *)(v287 + v281));
        if (Object)
        {
          if (Object[24] || (uint64_t v291 = Object[13]) != 0 && *(_BYTE *)(v291 + 44)) {
            *(_BYTE *)(v287 + v281 + 15) |= 3u;
          }
        }
      }

      v282 = (apr_pool_t *)((char *)v282 + 1);
      uint64_t v96 = arra;
      v281 += 64LL;
    }

    while ((char *)v314->pool + (unint64_t)arra->pool > (char *)v282);
  }

  apr_pool_destroy(newpool[0]);
  uint64_t v101 = a2;
  if (!*(_DWORD *)(*(void *)(v315 + 16) + 12LL)) {
    goto LABEL_293;
  }
  apr_pool_create_ex(&pool, *(apr_pool_t **)v315, 0LL, 0LL);
  uint64_t v102 = *(void **)(v315 + 8);
  uint64_t v297 = v102[64];
  uint64_t v103 = v102[62];
  uint64_t v104 = v102[2];
  uint64_t v105 = v102[3];
  uint64_t v293 = v102[66];
  v106 = (uint64_t *)v102[71];
  uint64_t v303 = v102[4];
  v107 = pool;
  v295 = apr_hash_make(pool);
  ht = apr_hash_make(v107);
  pb = (apr_pool_t *)v104;
  uint64_t v308 = v105;
  v304 = GTEventTracker_make(v104, v105, (uint64_t)v106, v107);
  v306 = *(apr_array_header_t **)(v315 + 16);
  v108 = apr_array_push(v306);
  _OWORD *v108 = 0u;
  v108[1] = 0u;
  v108[2] = 0u;
  v108[3] = 0u;
  v109 = *(apr_pool_t **)(v315 + 24);
  uint64_t v292 = v103;
  v110 = 0LL;
  v300 = 0LL;
  v296 = 0LL;
  uint64_t v112 = v104;
  v111 = v314;
  uint64_t v113 = v308;
  v298 = v106;
  do
  {
    BOOL v114 = v109 > v110;
    v115 = v306->elts;
    uint64_t v116 = (uint64_t)&v115[64 * (void)v110];
    v301 = (char *)(v116 + 15);
    v302 = v306->elts;
    uint64_t v117 = (4 * v114);
    GTEventTracker_processFunction((uint64_t)v304, (uint64_t)&v115[64 * (void)v110]);
    v119 = (int *)(v116 + 8);
    int v118 = *(_DWORD *)(v116 + 8);
    int FuncEnumReceiverType = GetFuncEnumReceiverType(v118);
    unsigned int v305 = v117;
    if (FuncEnumReceiverType != 52 && FuncEnumReceiverType != 27 || !GetFuncEnumConstructorType(v118))
    {
      int v123 = 0;
      goto LABEL_130;
    }

    v319 = GTTraceFunc_getFuncStreamRef(v116, v113);
    uint64_t v121 = *find_entry(v112, &v319, 8uLL, 0LL);
    if (v121) {
      uint64_t v122 = *(void *)(v121 + 32);
    }
    else {
      uint64_t v122 = 0LL;
    }
    unint64_t v124 = CommandBufferCommitIndex(v122);
    v125 = pool;
    v126 = GTResourceTrackerMake(v112, v113, pool);
    GTResourceTrackerProcessCommandBuffer(v126, (uint64_t)v319, 1);
    ResourceTracker_addChainedResources(v126, v106, v124, v125);
    ResourceTracker_addIndirectResources(v126, (_DWORD **)v106, v124, v125);
    for (uint64_t j = 0LL; j != 9; ++j)
    {
      v128 = apr_array_make(v125, 16, 8);
      newpool[j] = (apr_pool_t *)v128;
      if ((j + 1) > 0x24)
      {
        unsigned int v129 = 0;
      }

      else
      {
        unsigned int v129 = dword_1C2CC0[j + 1] - 2;
        if (v129 > 0x51) {
          goto LABEL_106;
        }
      }

      int v130 = byte_1C2D54[v129];
      if ((v130 & 0x80000000) == 0)
      {
        v131 = (_DWORD *)v106[v130 + 1];
        goto LABEL_107;
      }

            ;
          }
        }
      }
    }
  }

  a3[33] += 24LL;
  return result;
}

LABEL_106:
      v131 = 0LL;
LABEL_107:
      GTMTLSMContext_getObjects(v131, v124, v128);
      v128->size_t nelts = GTMTLSMObject_sortUsedResources((uint64_t *)v128->elts, v128->nelts, v126[2]);
    }

    GTResourceTrackerBuildArgumentBuffers((uint64_t)pb, v308, (uint64_t)v319, (_DWORD **)v106, v124, v125);
    v133 = v132;
    v134 = (const void *)SaveDYMTLMutableBufferAncestorMaps( v132[2],  *(void **)(v101 + 8),  *(unsigned int *)(v101 + 16),  (uint64_t)pb);
    if ((unint64_t)v134 > *(unsigned int *)(v101 + 16))
    {
      v135 = apr_palloc(*(apr_pool_t **)(v101 + 40), (apr_size_t)v134);
      *(void *)(v101 + _Block_object_dispose(va, 8) = v135;
      *(_DWORD *)(v101 + 16) = (_DWORD)v134;
      SaveDYMTLMutableBufferAncestorMaps(v133[2], v135, v134, (uint64_t)pb);
    }

    v136 = *(uint64_t **)(v101 + 8);
    HashBytes(v136, (unint64_t)v134, (char *)&v334);
    GTMTLCaptureState_storePointer(v303, (char *)&v334, v136, v134);
    v332[2] = v336;
    v332[3] = v337;
    char v333 = v338;
    v332[0] = v334;
    v332[1] = v335;
    v137 = (const void *)SaveDYMTLIndirectArgumentBufferInfos( v133[1],  *v133,  *(void **)(v101 + 8),  *(unsigned int *)(v101 + 16),  (uint64_t)pb);
    if ((unint64_t)v137 > *(unsigned int *)(v101 + 16))
    {
      v138 = apr_palloc(*(apr_pool_t **)(v101 + 40), (apr_size_t)v137);
      *(void *)(v101 + _Block_object_dispose(va, 8) = v138;
      *(_DWORD *)(v101 + 16) = (_DWORD)v137;
      SaveDYMTLIndirectArgumentBufferInfos(v133[1], *v133, v138, v137, (uint64_t)pb);
    }

    v139 = *(uint64_t **)(v101 + 8);
    HashBytes(v139, (unint64_t)v137, (char *)&v334);
    GTMTLCaptureState_storePointer(v303, (char *)&v334, v139, v137);
    key[2] = v336;
    key[3] = v337;
    char v331 = v338;
    key[0] = v334;
    key[1] = v335;
    v140 = (const void *)SaveResourceMapsData( newpool,  *(void **)(v101 + 8),  *(unsigned int *)(v101 + 16),  (uint64_t)pb);
    if ((unint64_t)v140 > *(unsigned int *)(v101 + 16))
    {
      v141 = apr_palloc(*(apr_pool_t **)(v101 + 40), (apr_size_t)v140);
      *(void *)(v101 + _Block_object_dispose(va, 8) = v141;
      *(_DWORD *)(v101 + 16) = (_DWORD)v140;
      SaveResourceMapsData(newpool, v141, v140, (uint64_t)pb);
    }

    v142 = *(uint64_t **)(v101 + 8);
    HashBytes(v142, (unint64_t)v140, (char *)&v334);
    GTMTLCaptureState_storePointer(v303, (char *)&v334, v142, v140);
    v328[2] = v336;
    v328[3] = v337;
    char v329 = v338;
    v328[0] = v334;
    v328[1] = v335;
    *(void *)&__int128 v334 = v124;
    *((void *)&v334 + 1) = 255LL;
    v143 = find_entry(v308, &v334, 9uLL, 0LL);
    if (*v143)
    {
      uint64_t v144 = *(void *)(*v143 + 32LL);
      uint64_t v117 = v305;
      if (v144)
      {
        v145 = (uint64_t *)(v144 + 16);
        unint64_t v146 = *(unsigned int *)(v144 + 12);
      }

      else
      {
        v145 = 0LL;
        unint64_t v146 = 0LL;
      }
    }

    else
    {
      v145 = 0LL;
      unint64_t v146 = 0LL;
      uint64_t v117 = v305;
    }

    *(void *)&__int128 v334 = v319;
    v318[0] = *(void *)(*(void *)(*find_entry((uint64_t)pb, &v334, 8uLL, 0LL) + 32LL) + 8LL);
    v318[1] = v332;
    v318[2] = key;
    v318[3] = v328;
    if (v145)
    {
      HashBytes(v145, v146, (char *)&v334);
      GTMTLCaptureState_storePointer(v303, (char *)&v334, v145, (const void *)v146);
      v326[2] = v336;
      v326[3] = v337;
      char v327 = v338;
      v326[0] = v334;
      v326[1] = v335;
      v147 = v326;
    }

    else
    {
      v147 = 0LL;
    }

    v318[4] = v147;
    DYTraceEncode_MTLCommandBuffer_indirectArgumentBufferData( (uint64_t)v318,  *(unsigned int **)(v101 + 8),  *(unsigned int *)(v101 + 16),  0LL,  0LL);
    v148 = *(unsigned int **)(v101 + 8);
    uint64_t v149 = *v148;
    if ((*((_BYTE *)v148 + 33) & 0x10) != 0)
    {
      v151 = *(unsigned int **)(v101 + 8);
      unint64_t v150 = *v148;
      do
      {
        v151 = (unsigned int *)((char *)v151 + v149);
        uint64_t v149 = *v151;
        v150 += v149;
      }

      while ((*((_BYTE *)v151 + 33) & 0x20) == 0);
    }

    else
    {
      unint64_t v150 = *v148;
    }

    fbstream_write(*(void *)(v101 + 24), (uint64_t)v148, v150);
    GTTraceFuncToFbuf(v101, *(void *)(v315 + 8), v116, v117);
    uint64_t v152 = *find_entry(v297, &v319, 8uLL, 0LL);
    if (v152) {
      uint64_t v153 = *(void *)(v152 + 32);
    }
    else {
      uint64_t v153 = 0LL;
    }
    uint64_t v113 = v308;
    WriteRestores(v101, v153, v117, (uint64_t)pb);
    int v118 = *v119;
    int v123 = 1;
LABEL_130:
    if (v118 > -15340)
    {
      BOOL v154 = v118 == -15308;
      int v155 = -15339;
    }

    else
    {
      BOOL v154 = v118 == -15991;
      int v155 = -15749;
    }

    BOOL v156 = v154 || v118 == v155;
    uint64_t v157 = v117;
    if (v156)
    {
      if (!GTEventTracker_wasWaitSignaled((uint64_t)v304, v116))
      {
        uint64_t v157 = v117 | 2;
        goto LABEL_155;
      }

      *(void *)&v332[0] = GTTraceFunc_targetContext(v116, v113);
      v158 = v306->elts;
      uint64_t v159 = *find_entry((uint64_t)pb, v332, 8uLL, 0LL);
      if (v159 && (uint64_t v160 = *(void *)(v159 + 32)) != 0)
      {
        uint64_t v299 = v160;
        uint64_t v161 = *(void *)(v160 + 32);
        if (v161 && (*(_BYTE *)(v161 + 79) & 8) != 0)
        {
          uint64_t v162 = v161 + 64;
          goto LABEL_147;
        }
      }

      else
      {
        uint64_t v299 = 0LL;
      }

      uint64_t v162 = 0LL;
LABEL_147:
      uint64_t v163 = (uint64_t)v110 - 1;
      uint64_t v164 = (uint64_t)&v158[64 * ((void)v110 - 1)];
      int v165 = *(_DWORD *)(v162 + 8);
      if (GetFuncEnumConstructorType(v165) == 25)
      {
        if (!IsFuncEnumCommandBufferRelated(*(_DWORD *)&v158[64 * v163 + 8])
          || (v166 = *(char **)&v332[0],
              v166 != GetCommandBufferRef((uint64_t)&v158[64 * ((void)v110 - 1)], (uint64_t)pb, v308)))
        {
          v195 = GTTraceFunc_targetContext(v162, v308);
          __int128 v324 = 0u;
          __int128 v325 = 0u;
          __int128 v322 = 0u;
          __int128 v323 = 0u;
          *(_OWORD *)newpool = 0u;
          GTMTLSMCommandBuffer_processTraceFunc((char *)newpool, (uint64_t *)v162, v308);
          *(void *)&__int128 v334 = v195;
          uint64_t v196 = *(void *)(*(void *)(*find_entry((uint64_t)pb, &v334, 8uLL, 0LL) + 32LL) + 8LL);
          *(void *)&__int128 v334 = *(void *)&v332[0];
          uint64_t v197 = *(void *)(*(void *)(*find_entry((uint64_t)pb, &v334, 8uLL, 0LL) + 32LL) + 8LL);
          *(void *)&__int128 v334 = *(void *)&v332[0];
          uint64_t v198 = *(void *)(*(void *)(*find_entry((uint64_t)pb, &v334, 8uLL, 0LL) + 32LL) + 8LL);
          int v199 = BYTE9(v325);
          uint64_t v200 = a2;
          uint64_t v201 = *(void *)(a2 + 8);
          *(void *)(v201 + 16) = 0LL;
          *(void *)(v201 + 24) = 0LL;
          *(void *)(v201 + _Block_object_dispose(va, 8) = 0LL;
          *(void *)(v201 + 32) = 0x69744300008005LL;
          *(void *)uint64_t v201 = 0xFFFFCF0000000028LL;
          *(void *)(v201 + 40) = v196;
          *(void *)(v201 + 4_Block_object_dispose(va, 8) = v198;
          *(_DWORD *)(v201 + 56) = v199;
          *(_DWORD *)(v201 + 60) = 116;
          *(void *)(v201 + 64) = v197;
          *(_DWORD *)uint64_t v201 = 72;
          v202 = *(unsigned int **)(a2 + 8);
          unint64_t v203 = *v202;
          if ((*((_BYTE *)v202 + 33) & 0x10) != 0)
          {
            uint64_t v204 = *v202;
            v205 = *(unsigned int **)(a2 + 8);
            do
            {
              v205 = (unsigned int *)((char *)v205 + v204);
              uint64_t v204 = *v205;
              v203 += v204;
            }

            while ((*((_BYTE *)v205 + 33) & 0x20) == 0);
          }

          goto LABEL_197;
        }

        int v165 = *(_DWORD *)(v162 + 8);
      }

      if (GetFuncEnumConstructorType(v165) != 51
        || IsFuncIOCommandBufferRelated(*(_DWORD *)&v158[64 * v163 + 8])
        && (v167 = *(char **)&v332[0], v167 == GetIOCommandBufferRef(v164, (uint64_t)pb, v308)))
      {
LABEL_154:
        uint64_t v157 = v305;
        uint64_t v113 = v308;
        uint64_t v101 = a2;
        goto LABEL_155;
      }

      v212 = GTTraceFunc_targetContext(v162, v308);
      __int128 v324 = 0u;
      __int128 v325 = 0u;
      __int128 v322 = 0u;
      __int128 v323 = 0u;
      *(_OWORD *)newpool = 0u;
      GTMTLSMIOCommandBuffer_processTraceFunc((char *)newpool, (uint64_t *)v162, v308);
      *(void *)&__int128 v334 = v212;
      uint64_t v213 = *(void *)(*(void *)(*find_entry((uint64_t)pb, &v334, 8uLL, 0LL) + 32LL) + 8LL);
      *(void *)&__int128 v334 = *(void *)&v332[0];
      uint64_t v214 = *(void *)(*(void *)(*find_entry((uint64_t)pb, &v334, 8uLL, 0LL) + 32LL) + 8LL);
      *(void *)&__int128 v334 = *(void *)&v332[0];
      uint64_t v215 = *(void *)(*(void *)(*find_entry((uint64_t)pb, &v334, 8uLL, 0LL) + 32LL) + 8LL);
      int v216 = BYTE9(v325);
      uint64_t v200 = a2;
      uint64_t v217 = *(void *)(a2 + 8);
      *(void *)(v217 + 16) = 0LL;
      *(void *)(v217 + 24) = 0LL;
      *(void *)(v217 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(v217 + 32) = 0x69744300008005LL;
      *(void *)uint64_t v217 = 0xFFFFCF0100000028LL;
      *(void *)(v217 + 40) = v213;
      *(void *)(v217 + 4_Block_object_dispose(va, 8) = v215;
      *(_DWORD *)(v217 + 56) = v216;
      *(_DWORD *)(v217 + 60) = 116;
      *(void *)(v217 + 64) = v214;
      *(_DWORD *)uint64_t v217 = 72;
      v202 = *(unsigned int **)(a2 + 8);
      unint64_t v203 = *v202;
      if ((*((_BYTE *)v202 + 33) & 0x10) != 0)
      {
        uint64_t v218 = *v202;
        v219 = *(unsigned int **)(a2 + 8);
        do
        {
          v219 = (unsigned int *)((char *)v219 + v218);
          uint64_t v218 = *v219;
          v203 += v218;
        }

        while ((*((_BYTE *)v219 + 33) & 0x20) == 0);
      }

            uint64_t v117 = v124.u8[1];
            v119 = v124.u8[2];
            uint64_t v18 = v124.i64[0] & 0xFFFFFFFFFF000000LL;
            goto LABEL_111;
          default:
            v133 = 0LL;
            uint64_t v122 = 0LL;
            v128 = 0LL;
            v120 = 0LL;
            int v123 = 0LL;
            int v118 = 0LL;
            int v130 = 0LL;
            uint64_t v121 = 0LL;
            v124.i8[0] = 0;
            uint64_t v117 = 0LL;
            v119 = 0LL;
            uint64_t v18 = 0LL;
            v111 = 0LL;
            uint64_t v112 = 0LL;
            v109 = 0LL;
            v110 = 0LL;
            v108 = 0LL;
            int v17 = (const char *)(v10 + 32);
            goto LABEL_111;
        }

        break;
      }
    }

    else
    {
      __int128 v93 = 0LL;
    }

    if (v8 > 0x38)
    {
      LODWORD(v90) = *(_DWORD *)v10;
      LODWORD(v92) = *(_DWORD *)(v10 + 8);
      LOBYTE(v8_Block_object_dispose(va, 8) = *(_BYTE *)(v10 + 16);
      LOBYTE(v89) = *(_BYTE *)(v10 + 24);
      LODWORD(v91) = *(_DWORD *)(v10 + 32);
      if ((a4 & 1) == 0) {
        goto LABEL_193;
      }
      goto LABEL_168;
    }

    LOBYTE(v89) = 0;
    LODWORD(v90) = 0;
    LODWORD(v92) = 0;
    LOBYTE(v8_Block_object_dispose(va, 8) = 0;
    LODWORD(v91) = 1;
    if ((a4 & 1) != 0)
    {
LABEL_168:
      unint64_t v67 = 0;
      uint64_t v66 = 0;
      __int128 v78 = 0;
      __int128 v79 = 0;
      __int128 v80 = 0LL;
      LOBYTE(v81) = 0;
      LOBYTE(v82) = 0;
      LOBYTE(v65) = 0;
      LODWORD(v83) = 0;
      LODWORD(v69) = 0;
      LODWORD(v84) = 0;
      LODWORD(v70) = 0;
      uint64_t v85 = 0LL;
      unint64_t v86 = 0LL;
      LOWORD(v87) = 0;
      goto LABEL_169;
    }
  }

  else if (a4)
  {
    unint64_t v67 = 0;
    uint64_t v66 = 0;
    __int128 v78 = 0;
    __int128 v79 = 0;
    __int128 v80 = 0LL;
    LOBYTE(v81) = 0;
    LOBYTE(v82) = 0;
    LOBYTE(v65) = 0;
    LODWORD(v83) = 0;
    LODWORD(v69) = 0;
    LODWORD(v84) = 0;
    LODWORD(v70) = 0;
    uint64_t v85 = 0LL;
    unint64_t v86 = 0LL;
    LOWORD(v87) = 0;
    LOBYTE(v8_Block_object_dispose(va, 8) = 0;
    LOBYTE(v89) = 0;
    LODWORD(v90) = 0;
    LODWORD(v91) = 0;
    LODWORD(v92) = 0;
    v107 = 0LL;
    __int128 v93 = 0LL;
LABEL_169:
    unint64_t v98 = 0LL;
LABEL_179:
    id result = v104;
LABEL_192:
    uint64_t v102 = a3[10];
    *(_BYTE *)uint64_t v102 = v105;
    *(_BYTE *)(v102 + 1) = result;
    *(_DWORD *)(v102 + 2) = 0;
    *(_WORD *)(v102 + 6) = 0;
    *(void *)(v102 + _Block_object_dispose(va, 8) = v93;
    *(void *)(v102 + 16) = v107;
    *(_DWORD *)(v102 + 24) = v92;
    *(_DWORD *)(v102 + 2_Block_object_dispose(va, 8) = v91;
    *(_DWORD *)(v102 + 32) = v90;
    *(_BYTE *)(v102 + 36) = v89;
    *(_BYTE *)(v102 + 37) = v88;
    *(_WORD *)(v102 + 3_Block_object_dispose(va, 8) = v87;
    *(void *)(v102 + 40) = v86;
    *(void *)(v102 + 4_Block_object_dispose(va, 8) = v85;
    *(void *)(v102 + 56) = v70 | ((unint64_t)v84 << 32);
    *(void *)(v102 + 64) = v69 | ((unint64_t)v83 << 32);
    *(void *)(v102 + 72) = ((unint64_t)v81 << 16) | v80 | ((unint64_t)v82 << 8) | v65;
    *(int32x2_t *)(v102 + 80) = v98;
    *(_DWORD *)(v102 + 8_Block_object_dispose(va, 8) = v79;
    *(_BYTE *)(v102 + 92) = v78;
    *(_BYTE *)(v102 + 93) = v66;
    *(_BYTE *)(v102 + 94) = v67;
    *(_BYTE *)(v102 + 95) = 0;
  }

      v140 = v137 | (unint64_t)(v139 << 32);
LABEL_107:
      v141 = v136 + 64;
      while (v136)
      {
        v142 = HIDWORD(v140) - v140;
        if ((*(_BYTE *)(v141 + ((uint64_t)(HIDWORD(v140) - (int)v140) << 6) + 15) & 8) == 0
          || *(void *)(v141 + ((uint64_t)v142 << 6)) >= v60)
        {
          break;
        }

        v143 = v141 + ((uint64_t)v142 << 6);
        if ((*(_DWORD *)(v143 + 8) | 8) == 0xFFFFC10E)
        {
          *(void *)apr_array_push(v64) = v143;
          size_t nelts = v64->nelts;
          v148 = nelts - 1;
          elts = v64->elts;
          unint64_t v150 = *(unint64_t **)&elts[8 * nelts - 8];
          if ((int)nelts >= 2)
          {
            v151 = *v150;
            while (1)
            {
              elts = v64->elts;
              uint64_t v152 = v148 >> 1;
              uint64_t v153 = *(unint64_t **)&elts[8 * v152];
              v148 = v148;
              if (*v153 <= v151) {
                break;
              }
              *(void *)&elts[8 * v148] = v153;
              BOOL v154 = v148 > 1;
              LODWORD(v14_Block_object_dispose(va, 8) = v148 >> 1;
              if (!v154)
              {
                elts = v64->elts;
                v148 = v152;
                break;
              }
            }
          }

          *(void *)&elts[8 * v148] = v150;
          break;
        }

        uint64_t v144 = atomic_load((unsigned int *)(v136 + 4));
        v145 = (HIDWORD(v140) + 1);
        unint64_t v146 = v140 + (v144 >> 6) - 1;
        v140 = (v145 << 32) | v140;
        if ((_DWORD)v145 == v146)
        {
          v140 = (v145 << 32) | v145;
          v136 = *(void *)(v136 + 40);
          goto LABEL_107;
        }
      }

      ++v66;
    }

    while (v66 < *(int *)(v62 + 12));
    uint64_t v63 = newpool[0];
LABEL_122:
    WriteMakeAliasable(a1, a2, (uint64_t)v64, v60);
    apr_pool_destroy(v63);
LABEL_208:
    if (v1570)
    {
      v265 = atomic_load((unint64_t *)(v1570 + 56));
      uint64_t v266 = v265 & 0xFFFFFFFFFFFFFFE0LL;
      uint64_t v267 = v1571;
      int v268 = v1572;
      if ((v265 & 0xFFFFFFFFFFFFFFE0LL) != 0)
      {
        v269 = *(void *)(a1 + 32);
        v270 = *(void *)(v269 + 440);
        uint64_t v271 = v270 >= v266;
        int v272 = v270 - v266;
        if (v272 != 0 && v271) {
          BOOL v273 = v272 * *(unsigned int *)(v269 + 448) / *(unsigned int *)(v269 + 452);
        }
        else {
          BOOL v273 = 0LL;
        }
      }

      else
      {
        BOOL v273 = -1LL;
      }
    }

    else
    {
      BOOL v273 = -1LL;
      uint64_t v267 = v1571;
      int v268 = v1572;
    }

    int v274 = *(void **)(a1 + 8);
    v274[2] = 0LL;
    v274[3] = 0LL;
    v274[1] = 0LL;
    v274[4] = 0x77754300000046LL;
    *int v274 = 0xFFFFD81D00000028LL;
    v274[5] = v267;
    v274[6] = v273;
    *(_DWORD *)int v274 = 56;
    int v275 = *(unsigned int **)(a1 + 8);
    unsigned int v276 = *v275;
    if ((*((_BYTE *)v275 + 33) & 0x10) != 0)
    {
      uint64_t v278 = *(unsigned int **)(a1 + 8);
      uint64_t v277 = *v275;
      do
      {
        uint64_t v278 = (unsigned int *)((char *)v278 + v276);
        unsigned int v276 = *v278;
        v277 += v276;
      }

      while ((*((_BYTE *)v278 + 33) & 0x20) == 0);
    }

    else
    {
      uint64_t v277 = *v275;
    }

    fbstream_write(*(void *)(a1 + 24), (uint64_t)v275, v277);
    v279 = *(void *)a1;
    v280 = *(void *)(a1 + 8);
    *(void *)(v280 + 16) = 0LL;
    *(void *)(v280 + 24) = 0LL;
    *(void *)(v280 + _Block_object_dispose(va, 8) = 0LL;
    *(_DWORD *)(v280 + 32) = 70;
    *(_DWORD *)(v280 + 36) = 67;
    *(void *)v280 = 0xFFFFD00800000028LL;
    *(void *)(v280 + 40) = v279;
    *(_DWORD *)v280 = 48;
    uint64_t v281 = *(unsigned int **)(a1 + 8);
    v282 = *v281;
    if ((*((_BYTE *)v281 + 33) & 0x10) != 0)
    {
      uint64_t v284 = *(unsigned int **)(a1 + 8);
      uint64_t v283 = *v281;
      do
      {
        uint64_t v284 = (unsigned int *)((char *)v284 + v282);
        v282 = *v284;
        v283 += v282;
      }

      while ((*((_BYTE *)v284 + 33) & 0x20) == 0);
    }

    else
    {
      uint64_t v283 = *v281;
    }

    fbstream_write(*(void *)(a1 + 24), (uint64_t)v281, v283);
    uint64_t v14 = v268 + 1;
  }

  while (v14 < a3[9].nelts);
LABEL_224:
  uint64_t v285 = *(void *)a1;
  v286 = *(void *)(a1 + 8);
  *(void *)(v286 + 16) = 0LL;
  *(void *)(v286 + 24) = 0LL;
  *(void *)(v286 + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(v286 + 32) = 70;
  *(_DWORD *)(v286 + 36) = 67;
  *(void *)v286 = 0xFFFFD00800000028LL;
  *(void *)(v286 + 40) = v285;
  *(_DWORD *)v286 = 48;
  uint64_t v287 = *(unsigned int **)(a1 + 8);
  int v288 = *v287;
  if ((*((_BYTE *)v287 + 33) & 0x10) != 0)
  {
    v290 = *(unsigned int **)(a1 + 8);
    v289 = *v287;
    do
    {
      v290 = (unsigned int *)((char *)v290 + v288);
      int v288 = *v290;
      v289 += v288;
    }

    while ((*((_BYTE *)v290 + 33) & 0x20) == 0);
  }

  else
  {
    v289 = *v287;
  }

  fbstream_write(*(void *)(a1 + 24), (uint64_t)v287, v289);
  uint64_t v291 = *(unsigned int **)(a1 + 8);
  *(void *)__str = *(void *)a1;
  *(void *)&__str[8] = "buffers";
  *(_OWORD *)&__str[16] = 0uLL;
  DYTraceEncode_EnterStateGroup((uint64_t)__str, v291, *(unsigned int *)(a1 + 16), v292, 0LL);
  uint64_t v293 = *(unsigned int **)(a1 + 8);
  v294 = *v293;
  if ((*((_BYTE *)v293 + 33) & 0x10) != 0)
  {
    v296 = *(unsigned int **)(a1 + 8);
    v295 = *v293;
    do
    {
      v296 = (unsigned int *)((char *)v296 + v294);
      v294 = *v296;
      v295 += v294;
    }

    while ((*((_BYTE *)v296 + 33) & 0x20) == 0);
  }

  else
  {
    v295 = *v293;
  }

  fbstream_write(*(void *)(a1 + 24), (uint64_t)v293, v295);
  uint64_t v297 = a3->nelts;
  if (v297 >= 1)
  {
    for (uint64_t i = 0LL; i < v297; ++i)
    {
      uint64_t v299 = *(void *)&a3->elts[8 * i];
      if (!*(void *)(v299 + 48))
      {
        *(void *)__str = *(void *)(v299 + 8);
        v300 = find_entry(v1583, __str, 8uLL, 0LL);
        if (*v300) {
          v302 = *(void **)(*v300 + 32LL);
        }
        else {
          v302 = 0LL;
        }
        uint64_t v303 = *(unsigned int **)(a1 + 8);
        *(void *)__str = *(void *)a1;
        *(void *)&__str[8] = "buffer";
        *(_OWORD *)&__str[16] = (unint64_t)v302[1];
        DYTraceEncode_EnterStateGroup((uint64_t)__str, v303, *(unsigned int *)(a1 + 16), v301, 0LL);
        v304 = *(unsigned int **)(a1 + 8);
        unsigned int v305 = *v304;
        if ((*((_BYTE *)v304 + 33) & 0x10) != 0)
        {
          v307 = *(unsigned int **)(a1 + 8);
          v306 = *v304;
          do
          {
            v307 = (unsigned int *)((char *)v307 + v305);
            unsigned int v305 = *v307;
            v306 += v305;
          }

          while ((*((_BYTE *)v307 + 33) & 0x20) == 0);
        }

        else
        {
          v306 = *v304;
        }

        fbstream_write(*(void *)(a1 + 24), (uint64_t)v304, v306);
        *(void *)__str = *(void *)(v299 + 8);
        uint64_t v308 = find_entry(v1575, __str, 8uLL, 0LL);
        if (*v308) {
          v309 = *(void *)(*v308 + 32LL);
        }
        else {
          v309 = 0LL;
        }
        *(void *)__str = *(void *)(v299 + 8);
        v310 = *(void *)(*(void *)(*find_entry(v1583, __str, 8uLL, 0LL) + 32LL) + 8LL);
        v311 = *(void *)(v299 + 144);
        if (v311)
        {
          v312 = *(void *)(a1 + 8);
          *(void *)__str = *(void *)a1;
          *(void *)&__str[8] = v310;
          uint64_t v313 = v312 + *(unsigned int *)(a1 + 16) - 512;
          *(void *)__s = 512LL;
          *(void *)&__str[16] = StoreIOSurfaceUsingEncode(*(void *)(a1 + 32), v311, v313, __s);
          DYTraceEncode_MTLDevice_newBufferWithIOSurface( (uint64_t)__str,  *(unsigned int **)(a1 + 8),  *(unsigned int *)(a1 + 16),  0LL,  0LL);
          v314 = *(unsigned int **)(a1 + 8);
          uint64_t v315 = v314[8];
          v314[8] = v315 | 4;
          v316 = *v314;
          if ((v315 & 0x1000) != 0)
          {
            v317 = *v314;
            v318 = v314;
            do
            {
              v318 = (unsigned int *)((char *)v318 + v317);
              v317 = *v318;
              v316 += v317;
            }

            while ((*((_BYTE *)v318 + 33) & 0x20) == 0);
          }

          fbstream_write(*(void *)(a1 + 24), (uint64_t)v314, v316);
          *(void *)__str = *(void *)(v299 + 8);
          v319 = v1583;
          v320 = find_entry(v1583, __str, 8uLL, 0LL);
          WriteGTMTLSMBuffer_restore(a1, v309, *(void *)(*(void *)(*v320 + 32LL) + 8LL));
        }

        else
        {
          if (v309)
          {
            *(void *)__s = *(void *)a1;
            v1588[0] = v310;
            GTResourceDownloaderGetResourceFilename(v309, 0, __str, 0x80uLL);
            v321 = *(void *)(v299 + 104);
            v1588[1] = __str;
            v1588[2] = v321;
            v1588[3] = *(unsigned __int16 *)(v299 + 96);
            newpool[0] = *(apr_pool_t **)(v299 + 120);
            v1588[4] = *(void *)(*(void *)(*find_entry(v1583, newpool, 8uLL, 0LL) + 32LL) + 8LL);
            DYTraceEncode_MTLDevice_newBufferWithBytes_length_options( (uint64_t)__s,  *(unsigned int **)(a1 + 8),  *(unsigned int *)(a1 + 16),  0LL,  0LL);
            __int128 v322 = *(unsigned int **)(a1 + 8);
            if (!*(_DWORD *)(a1 + 20)) {
              v322[1] = -10237;
            }
            __int128 v323 = v322[8];
            v322[8] = v323 | 4;
            __int128 v324 = *(void *)(a1 + 24);
            __int128 v325 = *v322;
            if ((v323 & 0x1000) != 0)
            {
              v326 = *v322;
              char v327 = v322;
              do
              {
                char v327 = (unsigned int *)((char *)v327 + v326);
                v326 = *v327;
                v325 += v326;
              }

              while ((*((_BYTE *)v327 + 33) & 0x20) == 0);
            }
          }

          else
          {
            v328 = *(void *)(a1 + 8);
            *(void *)__str = *(void *)a1;
            *(void *)&__str[8] = v310;
            char v329 = *(unsigned __int16 *)(v299 + 96);
            *(void *)&__str[16] = *(void *)(v299 + 104);
            *(void *)&__str[24] = v329;
            *(void *)&__str[32] = 0LL;
            DYTraceEncode_MTLDevice_newBufferWithLength_options(__str, v328, *(unsigned int *)(a1 + 16), 0LL, 0LL);
            __int128 v322 = *(unsigned int **)(a1 + 8);
            v330 = v322[8];
            v322[8] = v330 | 4;
            __int128 v325 = *v322;
            if ((v330 & 0x1000) != 0)
            {
              char v331 = *v322;
              v332 = v322;
              do
              {
                v332 = (unsigned int *)((char *)v332 + v331);
                char v331 = *v332;
                v325 += v331;
              }

              while ((*((_BYTE *)v332 + 33) & 0x20) == 0);
            }

            __int128 v324 = *(void *)(a1 + 24);
          }

          fbstream_write(v324, (uint64_t)v322, v325);
          v319 = v1583;
        }

        WriteGTMTLSMBuffer_properties((void *)a1, v299, (uint64_t)v302, v319);
        WriteGTMTLSMBuffer_debugMarkers(a1, a2, v302);
        WriteGTMTLSMBuffer_resources(a1, a2, v299);
        char v333 = *(void *)a1;
        __int128 v334 = *(void *)(a1 + 8);
        *(void *)(v334 + 16) = 0LL;
        *(void *)(v334 + 24) = 0LL;
        *(void *)(v334 + _Block_object_dispose(va, 8) = 0LL;
        *(_DWORD *)(v334 + 32) = 70;
        *(_DWORD *)(v334 + 36) = 67;
        *(void *)__int128 v334 = 0xFFFFD00800000028LL;
        *(void *)(v334 + 40) = v333;
        *(_DWORD *)__int128 v334 = 48;
        __int128 v335 = *(unsigned int **)(a1 + 8);
        __int128 v336 = *v335;
        if ((*((_BYTE *)v335 + 33) & 0x10) != 0)
        {
          char v338 = *(unsigned int **)(a1 + 8);
          __int128 v337 = *v335;
          do
          {
            char v338 = (unsigned int *)((char *)v338 + v336);
            __int128 v336 = *v338;
            v337 += v336;
          }

          while ((*((_BYTE *)v338 + 33) & 0x20) == 0);
        }

        else
        {
          __int128 v337 = *v335;
        }

        fbstream_write(*(void *)(a1 + 24), (uint64_t)v335, v337);
        uint64_t v297 = a3->nelts;
      }
    }
  }

  v339 = *(void *)a1;
  v340 = *(void *)(a1 + 8);
  *(void *)(v340 + 16) = 0LL;
  *(void *)(v340 + 24) = 0LL;
  *(void *)(v340 + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(v340 + 32) = 70;
  *(_DWORD *)(v340 + 36) = 67;
  *(void *)v340 = 0xFFFFD00800000028LL;
  *(void *)(v340 + 40) = v339;
  *(_DWORD *)v340 = 48;
  v341 = *(unsigned int **)(a1 + 8);
  v342 = *v341;
  if ((*((_BYTE *)v341 + 33) & 0x10) != 0)
  {
    v346 = *(unsigned int **)(a1 + 8);
    v343 = *v341;
    v344 = v1583;
    v345 = v1567;
    do
    {
      v346 = (unsigned int *)((char *)v346 + v342);
      v342 = *v346;
      v343 += v342;
    }

    while ((*((_BYTE *)v346 + 33) & 0x20) == 0);
  }

  else
  {
    v343 = *v341;
    v344 = v1583;
    v345 = v1567;
  }

  fbstream_write(*(void *)(a1 + 24), (uint64_t)v341, v343);
  v347 = *(unsigned int **)(a1 + 8);
  *(void *)__str = *(void *)a1;
  *(void *)&__str[8] = "textures";
  *(_OWORD *)&__str[16] = 0uLL;
  DYTraceEncode_EnterStateGroup((uint64_t)__str, v347, *(unsigned int *)(a1 + 16), v348, 0LL);
  v349 = *(unsigned int **)(a1 + 8);
  v350 = *v349;
  if ((*((_BYTE *)v349 + 33) & 0x10) != 0)
  {
    v352 = *(unsigned int **)(a1 + 8);
    v351 = *v349;
    do
    {
      v352 = (unsigned int *)((char *)v352 + v350);
      v350 = *v352;
      v351 += v350;
    }

    while ((*((_BYTE *)v352 + 33) & 0x20) == 0);
  }

  else
  {
    v351 = *v349;
  }

  fbstream_write(*(void *)(a1 + 24), (uint64_t)v349, v351);
  v353 = a3[1].nelts;
  if (v353 >= 1)
  {
    v354 = 0LL;
    while (1)
    {
      v355 = *(void *)&a3[1].elts[8 * v354];
      if (!*(void *)(v355 + 48) && !*(void *)(v355 + 136) && !*(void *)(v355 + 144) && !*(void *)(v355 + 192))
      {
        v356 = *(void *)(v355 + 104);
        if (!v356 || !*(_BYTE *)(v356 + 44)) {
          break;
        }
      }

LABEL_197:
      fbstream_write(*(void *)(v200 + 24), (uint64_t)v202, v203);
      uint64_t v220 = *(void *)(v299 + 32);
      if (v220)
      {
        unsigned int v221 = 0;
        while (1)
        {
          unsigned int v222 = atomic_load((unsigned int *)(v220 + 4));
          uint64_t v223 = v221 + (v222 >> 6) - 1;
          uint64_t v220 = *(void *)(v220 + 40);
          unsigned int v221 = v223;
          if (!v220)
          {
            unsigned int v221 = v223;
            goto LABEL_204;
          }
        }
      }

      else
      {
        unsigned int v221 = 0;
      }

      uint64_t v223 = 0LL;
LABEL_204:
      unint64_t v224 = v221 | (unint64_t)(v223 << 32);
LABEL_205:
      uint64_t v225 = v220 + 64;
      while (v220)
      {
        uint64_t v226 = v225 + ((uint64_t)(HIDWORD(v224) - (int)v224) << 6);
        if (*(void *)v226 == *(void *)v116) {
          break;
        }
        int v227 = *(_DWORD *)(v226 + 8);
        unsigned int v230 = atomic_load((unsigned int *)(v220 + 4));
        int v231 = v224 + (v230 >> 6);
        uint64_t v232 = (HIDWORD(v224) + 1);
        unint64_t v224 = (v232 << 32) | v224;
        if ((_DWORD)v232 == v231 - 1)
        {
          unint64_t v224 = (v232 << 32) | v232;
          uint64_t v220 = *(void *)(v220 + 40);
          goto LABEL_205;
        }
      }

      goto LABEL_154;
    }

LABEL_155:
    int v168 = *v119;
    BOOL v169 = IsFuncEnumCommandBufferRelated(*v119);
    BOOL v170 = IsFuncIOCommandBufferRelated(v168);
    if (((v123 | (!v169 && !v170)) & 1) == 0)
    {
      uint64_t v171 = v315;
      GTTraceFuncToFbuf(v101, *(void *)(v315 + 8), v116, v157);
      if (v169) {
        goto LABEL_164;
      }
LABEL_157:
      if (v170)
      {
        if (*v119 == -15343) {
          v296 = GTTraceFunc_targetContext(v116, v113);
        }
        uint64_t v112 = (uint64_t)pb;
        IOCommandBufferRef = GetIOCommandBufferRef(v116, (uint64_t)pb, v113);
        uint64_t v173 = (uint64_t)&v306->elts[64 * (unint64_t)((_DWORD)v110 + 1)];
        int v174 = *(_DWORD *)(v173 + 8);
        BOOL v175 = IsFuncEnumCommandBufferRelated(v174);
        BOOL v176 = IsFuncIOCommandBufferRelated(v174);
        v111 = v314;
        if ((v175 || v176) && IOCommandBufferRef != GetIOCommandBufferRef(v173, (uint64_t)pb, v113))
        {
          uint64_t v96 = arra;
          if (v296 != IOCommandBufferRef)
          {
            newpool[0] = (apr_pool_t *)IOCommandBufferRef;
            uint64_t v206 = *(void *)(*(void *)(*find_entry((uint64_t)pb, newpool, 8uLL, 0LL) + 32LL) + 8LL);
            v207 = *(void **)(v101 + 8);
            v207[1] = 0LL;
            v207[2] = 0LL;
            v207[3] = 0LL;
            v207[4] = 0x4300000000LL;
            void *v207 = 0xFFFFC41100000028LL;
            v207[5] = v206;
            *(_DWORD *)v207 = 48;
            v208 = *(unsigned int **)(v101 + 8);
            v208[8] = v305 | 0x8004;
            fbstream_write(*(void *)(v101 + 24), (uint64_t)v208, *v208);
            newpool[0] = (apr_pool_t *)IOCommandBufferRef;
            uint64_t v209 = *(void *)(*(void *)(*find_entry((uint64_t)pb, newpool, 8uLL, 0LL) + 32LL) + 8LL);
            v210 = *(void **)(v101 + 8);
            v210[1] = 0LL;
            v210[2] = 0LL;
            v210[3] = 0LL;
            v210[4] = 0x4300000000LL;
            void *v210 = 0xFFFFC41300000028LL;
            v210[5] = v209;
            *(_DWORD *)v210 = 48;
            v211 = *(unsigned int **)(v101 + 8);
            v211[8] = v305 | 0x8004;
            uint64_t v113 = v308;
            fbstream_write(*(void *)(v101 + 24), (uint64_t)v211, *v211);
          }
        }

        else
        {
          uint64_t v96 = arra;
        }

        goto LABEL_290;
      }

      *(void *)&__int128 v334 = GTTraceFunc_getFuncStreamRef(v116, v113);
      newpool[0] = (apr_pool_t *)v334;
      v179 = find_entry((uint64_t)pb, newpool, 8uLL, 0LL);
      if (*v179)
      {
        uint64_t v180 = *(void *)(*v179 + 32LL);
        uint64_t v96 = arra;
        if (!v180) {
          goto LABEL_288;
        }
        if ((*v119 + 7158) < 3)
        {
          if ((qword_23A448 & 1) != 0)
          {
            v181 = (uint64_t *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)v116,  v302[64 * (void)v110 + 13],  *(void *)(v180 + 24));
            v182 = GTMTLSMContext_getObject(v106, *v181, *(void *)v116);
            if (v182)
            {
              v183 = find_entry(v292, (_BYTE *)v182 + 48, 8uLL, 0LL);
              if (*v183)
              {
                uint64_t v184 = *(void *)(*v183 + 32LL);
                if (v184)
                {
                  v185 = apr_array_make(pool, 1, 8);
                  *(void *)apr_array_push(v185) = v184;
                  WriteRestores(a2, (uint64_t)v185, v305 | 6, (uint64_t)pb);
                }
              }
            }
          }

LABEL_256:
          uint64_t v266 = *(void *)(v180 + 32);
          if (v266)
          {
            uint64_t v101 = a2;
            if ((*(_BYTE *)(v266 + 79) & 8) != 0) {
              uint64_t v267 = v266 + 64;
            }
            else {
              uint64_t v267 = 0LL;
            }
          }

          else
          {
            uint64_t v267 = 0LL;
            uint64_t v101 = a2;
          }

          int v268 = *v119;
          int FuncEnumConstructorType = GetFuncEnumConstructorType(*v119);
          if (FuncEnumConstructorType != 25
            && ((v268 + 6144) > 0x29 || ((0x3806C9D5295uLL >> v268) & 1) == 0)
            && ((v268 + 15345) > 0x38 || ((0x17C40BE00017E7FuLL >> (v268 - 15)) & 1) == 0)
            && FuncEnumConstructorType != 51
            && v267
            && IsFuncEnumCreateResource(*(_DWORD *)(v267 + 8)))
          {
            v270 = (unsigned __int8 *)(v116 + 15);
            if ((*v301 & 1) == 0)
            {
              uint64_t v271 = *find_entry(v293, &v334, 8uLL, 0LL);
              if (v271)
              {
                int v268 = *v119;
                if (*(void *)(v271 + 32))
                {
                  int v272 = v305;
                  v270 = (unsigned __int8 *)(v116 + 15);
LABEL_277:
                  int v274 = (*v270 >> 4) & 4;
                  else {
                    int v275 = v274;
                  }
                  unsigned int v276 = v275 | v272;
                  if (!GTMTLSMContext_getObject(v106, v334, *(void *)v116)) {
                    v276 |= 0x200u;
                  }
                  uint64_t v277 = *find_entry(v293, &v334, 8uLL, 0LL);
                  if (v277) {
                    uint64_t v277 = *(void *)(v277 + 32);
                  }
                  if (v277) {
                    uint64_t v278 = v276;
                  }
                  else {
                    uint64_t v278 = v276 | 6;
                  }
                  GTTraceFuncToFbuf(v101, *(void *)(v171 + 8), v116, v278);
                  goto LABEL_288;
                }
              }

              else
              {
                int v268 = *v119;
              }

              BOOL v273 = NeverIgnoreFenum(v268);
              v270 = (unsigned __int8 *)(v116 + 15);
              if (v273)
              {
                int v272 = v305;
                goto LABEL_277;
              }
            }

            int v272 = v305 | 6;
            goto LABEL_277;
          }

LABEL_288:
          uint64_t v112 = (uint64_t)pb;
          v111 = v314;
          goto LABEL_289;
        }

        if (*v119 != -7167) {
          goto LABEL_256;
        }
        v233 = GTTraceFunc_argumentBytesWithPool( (uint64_t *)v116,  v302[64 * (void)v110 + 13],  *(void *)(v180 + 24));
        *(void *)&v332[0] = *(void *)v233;
        uint64_t v101 = a2;
        if (GTMTLSMContext_getObject(v106, *(uint64_t *)&v332[0], *(void *)v116))
        {
          uint64_t v234 = *find_entry(v293, &v334, 8uLL, 0LL);
          if (v234) {
            uint64_t v234 = *(void *)(v234 + 32);
          }
          if (v234) {
            unsigned int v235 = v305;
          }
          else {
            unsigned int v235 = v305 | 6;
          }
          char v236 = *v301;
          unsigned int v237 = v235 | 4;
          uint64_t v238 = *find_entry((uint64_t)ht, v332, 8uLL, 0LL);
          if (!v238 || !*(void *)(v238 + 32))
          {
            if ((v236 & 0x40) != 0) {
              uint64_t v239 = v237;
            }
            else {
              uint64_t v239 = v235;
            }
            GTTraceFuncToFbuf(a2, *(void *)(v171 + 8), v116, v239);
            apr_hash_set(ht, v332, 8LL, *((const void **)v233 + 1));
          }

          v240 = (uint64_t *)(v233 + 8);
          uint64_t v241 = *find_entry((uint64_t)v295, v233 + 8, 8uLL, 0LL);
          uint64_t v101 = a2;
          if (!v241 || !*(void *)(v241 + 32))
          {
            uint64_t v242 = GTMTLSMContext_lastObject(v106, *v240, 0xFFFFFFFFFFFFFFFFLL);
            uint64_t v243 = v242;
            if (*(void *)(v242 + 112))
            {
              newpool[0] = *(apr_pool_t **)(v242 + 8);
              uint64_t v244 = *(void *)(*(void *)(*find_entry((uint64_t)pb, newpool, 8uLL, 0LL) + 32LL) + 8LL);
              WriteTextureInfo(a2, v243, (uint64_t)pb, v237);
              if (*(void *)(v243 + 72)) {
                v245 = *(const char **)(v243 + 72);
              }
              else {
                v245 = "";
              }
              v246 = *(unsigned int **)(a2 + 8);
              *((void *)v246 + 1) = 0LL;
              *((void *)v246 + 2) = 0LL;
              *((void *)v246 + 3) = 0LL;
              *((void *)v246 + 4) = 0x534300000000LL;
              *(void *)v246 = 0xFFFFC09000000028LL;
              *((void *)v246 + 5) = v244;
              unsigned int *v246 = 48;
              AppendString(v245, (int *)v246);
              uint64_t v247 = *v246;
              uint64_t v248 = ((_DWORD)v247 + 3) & 0xFFFFFFFC;
              bzero((char *)v246 + v247, v248 - v247);
              unsigned int *v246 = v248;
              v249 = *(unsigned int **)(a2 + 8);
              int v250 = v249[8] | v237;
              v249[8] = v250;
              unint64_t v251 = *v249;
              if ((v250 & 0x1000) != 0)
              {
                uint64_t v252 = *v249;
                v253 = v249;
                do
                {
                  v253 = (unsigned int *)((char *)v253 + v252);
                  uint64_t v252 = *v253;
                  v251 += v252;
                }

                while ((*((_BYTE *)v253 + 33) & 0x20) == 0);
              }

              uint64_t v254 = a2;
              fbstream_write(*(void *)(a2 + 24), (uint64_t)v249, v251);
              if (!*(void *)(v243 + 48) && !*(void *)(v243 + 136) && !*(void *)(v243 + 144))
              {
                uint64_t v255 = *(unsigned __int16 *)(v243 + 98);
                v256 = *(void **)(a2 + 8);
                v256[2] = 0LL;
                v256[3] = 0LL;
                v256[1] = 0LL;
                v256[4] = 0x6C754300000000LL;
                void *v256 = 0xFFFFC09800000028LL;
                v256[5] = v244;
                v256[6] = v255;
                *(_DWORD *)v256 = 56;
                v257 = *(unsigned int **)(a2 + 8);
                LODWORD(v255) = v257[8] | v237;
                v257[8] = v255;
                unint64_t v258 = *v257;
                if ((v255 & 0x1000) != 0)
                {
                  uint64_t v259 = *v257;
                  v260 = v257;
                  do
                  {
                    v260 = (unsigned int *)((char *)v260 + v259);
                    uint64_t v259 = *v260;
                    v258 += v259;
                  }

                  while ((*((_BYTE *)v260 + 33) & 0x20) == 0);
                }

                uint64_t v254 = a2;
                fbstream_write(*(void *)(a2 + 24), (uint64_t)v257, v258);
              }

              uint64_t v261 = *(void *)(v254 + 8);
              *(void *)(v261 + 16) = 0LL;
              *(void *)(v261 + 24) = 0LL;
              *(void *)(v261 + _Block_object_dispose(va, 8) = 0LL;
              *(void *)(v261 + 32) = 0x69754300000006LL;
              *(void *)uint64_t v261 = 0xFFFFD80600000028LL;
              *(void *)(v261 + 40) = v244;
              *(_DWORD *)(v261 + 4_Block_object_dispose(va, 8) = 0;
              *(_DWORD *)uint64_t v261 = 52;
              v262 = *(unsigned int **)(v254 + 8);
              LODWORD(v261) = v262[8] | v237;
              v262[8] = v261;
              unint64_t v263 = *v262;
              uint64_t v101 = v254;
              if ((v261 & 0x1000) != 0)
              {
                uint64_t v264 = *v262;
                v265 = v262;
                do
                {
                  v265 = (unsigned int *)((char *)v265 + v264);
                  uint64_t v264 = *v265;
                  v263 += v264;
                }

                while ((*((_BYTE *)v265 + 33) & 0x20) == 0);
              }

              fbstream_write(*(void *)(v254 + 24), (uint64_t)v262, v263);
            }

            apr_hash_set(v295, v240, 8LL, (const void *)v243);
          }
        }
      }

      uint64_t v96 = arra;
      goto LABEL_288;
    }

    unsigned int v305 = v157;
    uint64_t v171 = v315;
    if (!v169) {
      goto LABEL_157;
    }
LABEL_164:
    int v177 = *v119;
    if (*v119 > -15909)
    {
      uint64_t v112 = (uint64_t)pb;
      v111 = v314;
      uint64_t v96 = arra;
      if (v177 != -15908 && v177 != -15316)
      {
        int v178 = -15318;
        goto LABEL_178;
      }

      goto LABEL_179;
    }

    uint64_t v112 = (uint64_t)pb;
    v111 = v314;
    uint64_t v96 = arra;
    if (v177 == -16361) {
      goto LABEL_179;
    }
    int v178 = -16202;
LABEL_178:
    if (v177 == v178) {
LABEL_179:
    }
      v300 = GTTraceFunc_targetContext(v116, v113);
    CommandBufferRef = GetCommandBufferRef(v116, v112, v113);
    uint64_t v187 = (uint64_t)&v306->elts[64 * (unint64_t)((_DWORD)v110 + 1)];
    int v188 = *(_DWORD *)(v187 + 8);
    if (!IsFuncEnumCommandBufferRelated(v188))
    {
      v106 = v298;
      if (v300 != CommandBufferRef) {
        goto LABEL_185;
      }
      goto LABEL_289;
    }

    if (CommandBufferRef == GetCommandBufferRef(v187, v112, v113))
    {
      uint64_t v113 = v308;
      v106 = v298;
    }

    else
    {
      v106 = v298;
      if (v300 != CommandBufferRef)
      {
        int v188 = *(_DWORD *)(v187 + 8);
LABEL_185:
        if (v188)
        {
          newpool[0] = (apr_pool_t *)CommandBufferRef;
          uint64_t v189 = *(void *)(*(void *)(*find_entry(v112, newpool, 8uLL, 0LL) + 32LL) + 8LL);
          v190 = *(void **)(v101 + 8);
          v190[1] = 0LL;
          v190[2] = 0LL;
          v190[3] = 0LL;
          v190[4] = 0x4300000000LL;
          void *v190 = 0xFFFFC01700000028LL;
          v190[5] = v189;
          *(_DWORD *)v190 = 48;
          v191 = *(unsigned int **)(v101 + 8);
          v191[8] = v305 | 0x8004;
          fbstream_write(*(void *)(v101 + 24), (uint64_t)v191, *v191);
          newpool[0] = (apr_pool_t *)CommandBufferRef;
          uint64_t v192 = *(void *)(*(void *)(*find_entry(v112, newpool, 8uLL, 0LL) + 32LL) + 8LL);
          v193 = *(void **)(v101 + 8);
          v193[1] = 0LL;
          v193[2] = 0LL;
          v193[3] = 0LL;
          v193[4] = 0x4300000000LL;
          void *v193 = 0xFFFFC01500000028LL;
          v193[5] = v192;
          *(_DWORD *)v193 = 48;
          v194 = *(unsigned int **)(v101 + 8);
          v194[8] = v305 | 0x8004;
          fbstream_write(*(void *)(v101 + 24), (uint64_t)v194, *v194);
        }
      }

LABEL_289:
      uint64_t v113 = v308;
    }

LABEL_290:
    v110 = (apr_pool_t *)((char *)v110 + 1);
    v109 = v96->pool;
  }

  while ((char *)v111->pool + (unint64_t)v96->pool > (char *)v110);
  v107 = pool;
LABEL_292:
  apr_pool_destroy(v107);
LABEL_293:
  v279 = *(apr_pool_t ***)(v101 + 24);
  apr_pool_cleanup_kill(*v279, v279, (apr_status_t (__cdecl *)(void *))fbstream_cleanup);
  return (void *)fbstream_cleanup((uint64_t)v279);
}

uint64_t CompareCommandBufferIndex(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = *a1;
  BOOL v3 = *a1 > *a2;
  if (*a2 == -1LL) {
    BOOL v3 = 1;
  }
  if (v2 < *a2 || v2 == -1LL) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3;
  }
}

void WriteRestores(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a2 && *(int *)(a2 + 12) >= 1)
  {
    for (uint64_t i = 0LL; i < *(int *)(a2 + 12); ++i)
    {
      uint64_t v9 = *(void *)(*(void *)(a2 + 24) + 8 * i);
      unsigned int v10 = *(unsigned __int8 *)(v9 + 46);
      if (v10 <= 0x4F)
      {
        if (v10 == 22)
        {
          *(void *)__str = *(void *)(v9 + 16);
          v46[0] = *(void *)(*(void *)(*find_entry(a4, __str, 8uLL, 0LL) + 32LL) + 8LL);
          *(void *)__str = *(void *)(v9 + 8);
          v46[1] = *(void *)(*(void *)(*find_entry(a4, __str, 8uLL, 0LL) + 32LL) + 8LL);
          GTResourceDownloaderGetResourceFilename(v9, 0, __str, 0x80uLL);
          v46[2] = __str;
          __int128 v47 = *(_OWORD *)(v9 + 48);
          DYTraceEncode_MTLCommandBuffer_restoreMTLBufferContents( (uint64_t)v46,  *(unsigned int **)(a1 + 8),  *(unsigned int *)(a1 + 16),  0LL,  0LL);
          int v11 = *(unsigned int **)(a1 + 8);
          int v36 = v11[8] | a3;
          v11[8] = v36;
          unint64_t v13 = *v11;
          if ((v36 & 0x1000) != 0)
          {
            uint64_t v37 = *v11;
            __int128 v38 = v11;
            do
            {
              __int128 v38 = (unsigned int *)((char *)v38 + v37);
              uint64_t v37 = *v38;
              v13 += v37;
            }

            while ((*((_BYTE *)v38 + 33) & 0x20) == 0);
          }

char *GetCommandBufferRef(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = GTTraceFunc_targetContext(a1, a3);
  int v7 = *(_DWORD *)(a1 + 8);
  int FuncEnumReceiverType = GetFuncEnumReceiverType(v7);
  if (FuncEnumReceiverType == 25) {
    return v6;
  }
  int v9 = FuncEnumReceiverType;
  if (FuncEnumReceiverType == 51) {
    return v6;
  }
  int FuncEnumConstructorType = GetFuncEnumConstructorType(v7);
  if (v7 == -20457 || v7 == -20474) {
    return (char *)*((void *)GTTraceFunc_argumentBytesWithMap((void *)a1, *(unsigned __int8 *)(a1 + 13), a3) + 1);
  }
  unsigned int v20 = v6;
  uint64_t v13 = *(void *)(*(void *)(*find_entry(a2, &v20, 8uLL, 0LL) + 32LL) + 32LL);
  int v14 = *(_DWORD *)(v13 + 72);
  uint64_t v15 = GTTraceFunc_targetContext(v13 + 64, a3);
  uint64_t v6 = v15;
  if (v14 != -16286) {
    return v6;
  }
  unsigned int v20 = v15;
  uint64_t v16 = *find_entry(a2, &v20, 8uLL, 0LL);
  if (v16
    && (uint64_t v17 = *(void *)(v16 + 32)) != 0
    && (uint64_t v18 = *(void *)(v17 + 32)) != 0
    && (*(_BYTE *)(v18 + 79) & 8) != 0)
  {
    uint64_t v19 = v18 + 64;
  }

  else
  {
    uint64_t v19 = 0LL;
  }

  return GTTraceFunc_targetContext(v19, a3);
}

char *GetIOCommandBufferRef(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = GTTraceFunc_targetContext(a1, a3);
  int v7 = *(_DWORD *)(a1 + 8);
  int FuncEnumReceiverType = GetFuncEnumReceiverType(v7);
  if (FuncEnumReceiverType == 25) {
    return v6;
  }
  int v9 = FuncEnumReceiverType;
  if (FuncEnumReceiverType == 51) {
    return v6;
  }
  int FuncEnumConstructorType = GetFuncEnumConstructorType(v7);
  uint64_t v17 = v6;
  uint64_t v13 = *find_entry(a2, &v17, 8uLL, 0LL);
  if (v13
    && (uint64_t v14 = *(void *)(v13 + 32)) != 0
    && (uint64_t v15 = *(void *)(v14 + 32)) != 0
    && (*(_BYTE *)(v15 + 79) & 8) != 0)
  {
    uint64_t v16 = v15 + 64;
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  return GTTraceFunc_targetContext(v16, a3);
}

BOOL NeverIgnoreFenum(int a1)
{
  return (a1 + 16073) <= 6 && a1 != -16072 || (a1 + 15736) < 2;
}

pthread_mutex_t *GTResourceHarvesterMake(apr_pool_t *a1)
{
  unint64_t v2 = (pthread_mutex_t *)apr_palloc(a1, 0x48uLL);
  pthread_mutex_init(v2, 0LL);
  v2[1].__sig = (uint64_t)apr_hash_make(a1);
  return v2;
}

apr_array_header_t *GTResourceHarvesterGetDownloadRequests(pthread_mutex_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(apr_pool_t **)a1[1].__sig;
  pthread_mutex_lock(a1);
  p = v5;
  uint64_t v6 = apr_array_make(v5, 0, 88);
  if (*(int *)(a3 + 12) >= 1)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    do
    {
      uint64_t v9 = *(void *)(a3 + 24);
      uint64_t v10 = v9 + v7;
      if (*(void *)(v9 + v7 + 24) != 0x7FFFFFFFFFFFFFFFLL)
      {
        int v11 = (int8x16_t *)(v10 + 8);
        uint64_t v12 = *find_entry(a1[1].__sig, (_BYTE *)(v10 + 8), 8uLL, 0LL);
        if (v12 && (uint64_t v13 = *(void *)(v12 + 32)) != 0)
        {
          if (*(void *)(v9 + v7 + 32) != *(void *)v13 && *(_BYTE *)(v9 + v7 + 48))
          {
            uint64_t v14 = v9 + v7;
            uint64_t v15 = *(void *)(v9 + v7);
            uint64_t v16 = *(void *)(v13 + 8);
            int v17 = *(_DWORD *)(v13 + 16);
            *(_DWORD *)(v13 + 16) = v17 + 1;
            int v18 = *(_DWORD *)(v14 + 40);
            uint64_t v19 = (char *)apr_array_push(v6);
            *(void *)uint64_t v19 = v15;
            *((void *)v19 + 1) = v16;
            *((void *)v19 + 3) = 0LL;
            *((void *)v19 + 4) = 0LL;
            *((void *)v19 + 2) = a2;
            *((_DWORD *)v19 + 10) = v17;
            *((_WORD *)v19 + 22) = 0;
            v19[46] = v18;
            *(_OWORD *)(v19 + 47) = 0u;
            *(_OWORD *)(v19 + 63) = 0u;
            *(_OWORD *)(v19 + 72) = 0u;
          }
        }

        else
        {
          unsigned int v20 = apr_palloc(p, 0x18uLL);
          uint64_t v21 = v20;
          if (v20)
          {
            *unsigned int v20 = 0LL;
            v20[1] = 0LL;
            v20[2] = 0LL;
          }

          int8x16_t v29 = *v11;
          *(int8x16_t *)unsigned int v20 = vextq_s8(*v11, *v11, 8uLL);
          uint64_t v22 = v9 + v7;
          uint64_t v23 = *(void *)(v9 + v7);
          *((_DWORD *)v20 + 4) = 1;
          int v24 = *(_DWORD *)(v22 + 40);
          uint64_t v25 = (char *)apr_array_push(v6);
          *(void *)uint64_t v25 = v23;
          *((void *)v25 + 1) = v29.i64[0];
          *((void *)v25 + 3) = 0LL;
          *((void *)v25 + 4) = 0LL;
          *((void *)v25 + 2) = a2;
          *(void *)(v25 + 3_Block_object_dispose(va, 8) = 0LL;
          v25[46] = v24;
          *(_OWORD *)(v25 + 47) = 0u;
          *(_OWORD *)(v25 + 63) = 0u;
          *(_OWORD *)(v25 + 72) = 0u;
          apr_hash_set((apr_hash_t *)a1[1].__sig, v21 + 1, 8LL, v21);
        }
      }

      ++v8;
      v7 += 56LL;
    }

    while (v8 < *(int *)(a3 + 12));
  }

  pthread_mutex_unlock(a1);
  return v6;
}

uint64_t dna1_length()
{
  return 17134LL;
}

void TranslateGTMTLArgument(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v60 = a2;
  id v7 = objc_claimAutoreleasedReturnValue([v60 name]);
  id v8 = [v7 UTF8String];
  id v9 = objc_claimAutoreleasedReturnValue([v60 name]);
  if ([v9 UTF8String])
  {
    id v10 = objc_claimAutoreleasedReturnValue([v60 name]);
    size_t v11 = strlen((const char *)[v10 UTF8String]);
    size_t v12 = v11 + 1;
    if (v11 == -1LL) {
      uint64_t v13 = 0LL;
    }
    else {
      uint64_t v13 = (void *)a3[23];
    }
    a3[23] += v12;
    if ((_DWORD)a4) {
      memcpy(v13, v8, v12);
    }
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  unsigned __int8 v14 = [v60 access];
  unsigned __int8 v15 = [v60 isActive];
  unsigned __int8 v16 = [v60 index];
  unsigned __int8 v17 = [v60 type];
  int v18 = (int *)[v60 type];
  uint64_t v19 = 0LL;
  unsigned __int16 v20 = 0;
  unsigned __int8 v58 = v14;
  uint64_t v59 = v13;
  unsigned __int8 v57 = v16;
  unsigned __int8 v56 = v15;
  unsigned __int8 v55 = v17;
  if ((uint64_t)v18 > 15)
  {
    if (v18 == &dword_10)
    {
      id v43 = v60;
      uint64_t v44 = [v43 imageBlockDataSize];
      unint64_t v45 = v44 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)[v43 aliasImplicitImageBlockRenderTarget] << 32);
      unsigned int v46 = [v43 aliasImplicitImageBlock];
      uint64_t v47 = 0x10000000000LL;
      if (!v46) {
        uint64_t v47 = 0LL;
      }
      uint64_t v23 = v45 | v47;
      unint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v43 imageBlockMasterStructMembers]);
      if (!v48)
      {
LABEL_37:
        uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v43 dataTypeDescription]);
        uint64_t v25 = TranslateGTMTLType(v49, a3, a4);
        unint64_t v24 = 0LL;
LABEL_38:

        unsigned __int16 v20 = 0;
        unsigned __int16 v21 = 0;
        unsigned __int8 v22 = 0;
        uint64_t v19 = 0LL;
        if (!(_DWORD)a4) {
          goto LABEL_29;
        }
        goto LABEL_28;
      }
    }

    else
    {
      if (v18 != (int *)((char *)&dword_10 + 1))
      {
        unsigned __int16 v21 = 0;
        unsigned __int8 v22 = 0;
        uint64_t v23 = 0LL;
        unint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        if (v18 == (int *)((char *)&stru_20.cmd + 3))
        {
          id v31 = v60;
          uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v31 meshVertexStruct]);
          uint64_t v23 = TranslateGTMTLStructType(v32, a3, a4);

          unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v31 meshPrimitiveStruct]);
          uint64_t v19 = TranslateGTMTLStructType(v33, a3, a4);

          unsigned __int16 v20 = (unsigned __int16)[v31 meshVertexCount];
          unsigned __int16 v21 = (unsigned __int16)[v31 meshPrimitiveCount];
          unsigned __int8 v22 = [v31 meshTopologyType];
          uint64_t v34 = [v31 builtInType];
          unsigned __int8 v35 = [v31 builtInDataType];

          uint64_t v25 = 0LL;
          unint64_t v24 = v34 & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)v35 << 8);
          if (!(_DWORD)a4) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }

        goto LABEL_27;
      }

      id v43 = v60;
      unsigned __int8 v50 = [v43 imageBlockKind];
      unint64_t v51 = [v43 imageBlockDataSize] | ((unint64_t)v50 << 48);
      unint64_t v52 = v51 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)[v43 aliasImplicitImageBlockRenderTarget] << 32);
      unsigned int v53 = [v43 aliasImplicitImageBlock];
      uint64_t v54 = 0x10000000000LL;
      if (!v53) {
        uint64_t v54 = 0LL;
      }
      uint64_t v23 = v52 | v54;
      unint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v43 dataTypeDescription]);
      if (v48) {
        goto LABEL_37;
      }
    }

    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v43 imageBlockMasterStructMembers]);
    unint64_t v24 = TranslateGTMTLStructType(v49, a3, a4);
    uint64_t v25 = 0LL;
    goto LABEL_38;
  }

  if (!v18)
  {
    unsigned __int16 v36 = (unsigned __int16)[v60 bufferAlignment];
    unint64_t v37 = [v60 bufferDataSize] | ((unint64_t)v36 << 32);
    unint64_t v38 = v37 & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)[v60 bufferDataType] << 48);
    unsigned int v39 = [v60 isVertexDescriptorBuffer];
    uint64_t v40 = 0x100000000000000LL;
    if (!v39) {
      uint64_t v40 = 0LL;
    }
    unint64_t v24 = v38 | v40;
    goto LABEL_26;
  }

  if (v18 == (int *)((char *)&dword_0 + 1))
  {
    unsigned __int16 v41 = (unsigned __int16)[v60 threadgroupMemoryAlignment];
    unint64_t v24 = [v60 threadgroupMemoryDataSize] | ((unint64_t)v41 << 32);
LABEL_26:
    __int128 v42 = (void *)objc_claimAutoreleasedReturnValue([v60 dataTypeDescription]);
    uint64_t v25 = TranslateGTMTLType(v42, a3, a4);

    unsigned __int16 v20 = 0;
    unsigned __int16 v21 = 0;
    unsigned __int8 v22 = 0;
    uint64_t v19 = 0LL;
    uint64_t v23 = 0LL;
LABEL_27:
    if (!(_DWORD)a4) {
      goto LABEL_29;
    }
LABEL_28:
    *(void *)a1 = v59;
    *(void *)(a1 + _Block_object_dispose(va, 8) = v25;
    *(_BYTE *)(a1 + 16) = v55;
    *(_BYTE *)(a1 + 17) = v58;
    *(_BYTE *)(a1 + 1_Block_object_dispose(va, 8) = v57;
    *(_BYTE *)(a1 + 19) = v56 | 2;
    *(_DWORD *)(a1 + 20) = 0;
    *(void *)(a1 + 24) = v24;
    *(void *)(a1 + 32) = v23;
    *(void *)(a1 + 40) = v19;
    *(_WORD *)(a1 + 4_Block_object_dispose(va, 8) = v20;
    *(_WORD *)(a1 + 50) = v21;
    *(_BYTE *)(a1 + 52) = v22;
    *(_WORD *)(a1 + 53) = 0;
    *(_BYTE *)(a1 + 55) = 0;
    goto LABEL_29;
  }

  unsigned __int16 v21 = 0;
  unsigned __int8 v22 = 0;
  uint64_t v23 = 0LL;
  unint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  unsigned __int8 v26 = [v60 textureDataType];
  unint64_t v27 = [v60 textureType] | ((unint64_t)v26 << 8);
  unint64_t v28 = v27 & 0xFFFFFFFFFF00FFFFLL | ((unint64_t)[v60 arrayLength] << 16);
  unsigned int v29 = [v60 isDepthTexture];
  unsigned __int16 v20 = 0;
  unsigned __int16 v21 = 0;
  unsigned __int8 v22 = 0;
  uint64_t v19 = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v30 = 0x1000000LL;
  if (!v29) {
    uint64_t v30 = 0LL;
  }
  unint64_t v24 = v28 | v30;
  if ((_DWORD)a4) {
    goto LABEL_28;
  }
LABEL_29:
}

uint64_t TranslateGTMTLType(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  uint64_t v6 = v5;
  if (v5)
  {
    id v7 = (char *)[v5 dataType];
    uint64_t v8 = 0LL;
    if ((uint64_t)v7 > 57)
    {
      if (v7 == (_BYTE *)&stru_20.vmaddr + 2)
      {
        uint64_t v8 = a2[19];
        a2[19] = v8 + 16;
        if ((_DWORD)a3)
        {
          *(_BYTE *)uint64_t v8 = 58;
          id v14 = v6;
          *(_BYTE *)(v8 + 10) = [v14 access];
          *(_BYTE *)(v8 + _Block_object_dispose(va, 8) = [v14 textureDataType];
          unsigned __int8 v15 = [v14 textureType];

          *(_BYTE *)(v8 + 9) = v15;
        }
      }

      else if (v7 == (_BYTE *)&stru_20.vmaddr + 4)
      {
        id v9 = v6;
        uint64_t v8 = a2[15];
        a2[15] = v8 + 24;
        size_t v12 = (void *)objc_claimAutoreleasedReturnValue([v9 elementTypeDescription]);
        uint64_t v13 = TranslateGTMTLType(v12, a2, a3);

        if ((_DWORD)a3)
        {
          *(_BYTE *)uint64_t v8 = 60;
          *(_BYTE *)(v8 + 23) = [v9 access];
          *(_WORD *)(v8 + 20) = (unsigned __int16)[v9 alignment];
          *(_DWORD *)(v8 + 16) = [v9 dataSize];
          *(_BYTE *)(v8 + 22) = [v9 elementType];
          *(void *)(v8 + _Block_object_dispose(va, 8) = v13;
        }

        goto LABEL_13;
      }
    }

    else
    {
      if (v7 == (_BYTE *)&dword_0 + 1)
      {
        uint64_t v8 = TranslateGTMTLStructType(v6, a2, a3);
        goto LABEL_17;
      }

      if (v7 == (_BYTE *)&dword_0 + 2)
      {
        id v9 = v6;
        uint64_t v8 = a2[18];
        a2[18] = v8 + 32;
        id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 elementTypeDescription]);
        uint64_t v11 = TranslateGTMTLType(v10, a2, a3);

        if ((_DWORD)a3)
        {
          *(_BYTE *)uint64_t v8 = 2;
          *(_WORD *)(v8 + 20) = (unsigned __int16)[v9 arrayLength];
          *(_BYTE *)(v8 + 24) = [v9 elementType];
          *(_DWORD *)(v8 + 16) = [v9 stride];
          *(_WORD *)(v8 + 22) = (unsigned __int16)[v9 argumentIndexStride];
          *(void *)(v8 + _Block_object_dispose(va, 8) = v11;
          if ((objc_opt_respondsToSelector(v9, "aluType") & 1) != 0) {
            *(_BYTE *)(v8 + 25) = [v9 aluType];
          }
        }

LABEL_13:
      }
    }
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  uint64_t v13 = *a1;
  v21.i64[0] = *(void *)(a3 + 8600);
  id v14 = find_entry(v13, &v21, 8uLL, 0LL);
  if (*v14) {
    unsigned __int8 v15 = *(void *)(*v14 + 32LL);
  }
  else {
    unsigned __int8 v15 = 0LL;
  }
  GTMTLSMRenderPipelineState_resourceAccess(v15, a1[1], &v21);
  unsigned int v29 = vandq_s8(v29, (int8x16_t)vdupq_n_s64(~*(void *)(a3 + 6944)));
  BufferAccess(a1, a3 + 6952, &v29, a4);
  uint64_t v19 = a3 + 7448;
  unsigned __int16 v20 = &v30;
  return TextureAccess(a1, v19, (uint64_t)v20, a4);
}

      if (++v9 >= v7->nelts) {
        return result;
      }
    }

    unsigned __int8 v15 = a1[1];
    id v14 = a1[2];
    unsigned __int8 v16 = *a1;
    unsigned __int8 v17 = 71;
LABEL_12:
    id result = GTResourceTrackerUsingResource(v14, v17, v13, v16, v15);
    goto LABEL_13;
  }

  return result;
}

  id v10 = v7 | (unint64_t)(v9 << 32);
LABEL_14:
  uint64_t v11 = v6 + 64;
  while (1)
  {
    if (!v6
      || (*(_BYTE *)(v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6) + 15) & 8) == 0
      || (size_t v12 = v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6),
          uint64_t v13 = *(void *)(a1 + 8),
          id v14 = *(void *)v12,
          *(void *)v12 >= *(void *)(a1 + 16) + v13))
    {
      unsigned int v29 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xA0uLL);
      uint64_t v30 = v47;
      *unsigned int v29 = v46;
      v29[1] = v30;
      id v31 = v51;
      unsigned int v33 = v48;
      uint64_t v32 = v49;
      v29[4] = v50;
      v29[5] = v31;
      v29[2] = v33;
      v29[3] = v32;
      uint64_t v34 = v55;
      unsigned __int16 v36 = v52;
      unsigned __int8 v35 = v53;
      v29[8] = v54;
      v29[9] = v34;
      v29[6] = v36;
      v29[7] = v35;
      unint64_t v37 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v29 + 8, 8uLL, 0LL);
      if (v37) {
        unint64_t v37 = *(void *)(v37 + 32);
      }
      *((void *)v29 + 4) = v37;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v29 + 8, 8LL, v29);
      id v14 = -1LL;
      goto LABEL_35;
    }

    unsigned __int8 v15 = *(_DWORD *)(v12 + 8);
    if (v15 > -16368)
    {
      if (v15 == -16122 || v15 == -16367)
      {
LABEL_25:
        if (v13 <= v14)
        {
          unsigned __int8 v17 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xA0uLL);
          int v18 = v47;
          *(_OWORD *)unsigned __int8 v17 = v46;
          *((_OWORD *)v17 + 1) = v18;
          uint64_t v19 = v51;
          unsigned __int16 v21 = v48;
          unsigned __int16 v20 = v49;
          *((_OWORD *)v17 + 4) = v50;
          *((_OWORD *)v17 + 5) = v19;
          *((_OWORD *)v17 + 2) = v21;
          *((_OWORD *)v17 + 3) = v20;
          unsigned __int8 v22 = v55;
          unint64_t v24 = v52;
          uint64_t v23 = v53;
          *((_OWORD *)v17 + _Block_object_dispose(va, 8) = v54;
          *((_OWORD *)v17 + 9) = v22;
          *((_OWORD *)v17 + 6) = v24;
          *((_OWORD *)v17 + 7) = v23;
          uint64_t v25 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v17 + 8, 8uLL, 0LL);
          if (v25) {
            uint64_t v25 = *(void *)(v25 + 32);
          }
          v17[4] = v25;
          apr_hash_set(*(apr_hash_t **)(a1 + 32), v17 + 1, 8LL, v17);
          v17[3] = v14;
        }

        goto LABEL_30;
      }

      goto LABEL_30;
    }

    if (v15 == -16372) {
      goto LABEL_25;
    }
    if (v15 == -16370) {
      break;
    }
LABEL_30:
    GTMTLSMBuffer_processTraceFuncWithMap((char *)&v46, *(void *)(a1 + 40), (uint64_t *)v12);
    unsigned __int8 v26 = atomic_load((unsigned int *)(v6 + 4));
    unint64_t v27 = v10 + (v26 >> 6);
    unint64_t v28 = (HIDWORD(v10) + 1);
    id v10 = (v28 << 32) | v10;
    if ((_DWORD)v28 == v27 - 1)
    {
      id v10 = (v28 << 32) | v28;
      uint64_t v6 = *(void *)(v6 + 40);
      goto LABEL_14;
    }
  }

  if (v13 <= v14)
  {
    unsigned int v29 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xA0uLL);
    unint64_t v38 = v47;
    *unsigned int v29 = v46;
    v29[1] = v38;
    unsigned int v39 = v51;
    unsigned __int16 v41 = v48;
    uint64_t v40 = v49;
    v29[4] = v50;
    v29[5] = v39;
    v29[2] = v41;
    v29[3] = v40;
    __int128 v42 = v55;
    uint64_t v44 = v52;
    id v43 = v53;
    v29[8] = v54;
    v29[9] = v42;
    v29[6] = v44;
    v29[7] = v43;
    unint64_t v45 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v29 + 8, 8uLL, 0LL);
    if (v45) {
      unint64_t v45 = *(void *)(v45 + 32);
    }
    *((void *)v29 + 4) = v45;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v29 + 8, 8LL, v29);
LABEL_35:
    *((void *)v29 + 3) = v14;
  }

  id v10 = v7 | (unint64_t)(v9 << 32);
LABEL_14:
  uint64_t v11 = v6 + 64;
  while (1)
  {
    if (!v6
      || (*(_BYTE *)(v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6) + 15) & 8) == 0
      || (size_t v12 = v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6),
          uint64_t v13 = *(void *)(a1 + 8),
          id v14 = *(void *)v12,
          *(void *)v12 >= *(void *)(a1 + 16) + v13))
    {
      uint64_t v32 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xD8uLL);
      unsigned int v33 = v56;
      void *v32 = v55;
      v32[1] = v33;
      uint64_t v34 = v60;
      unsigned __int16 v36 = v57;
      unsigned __int8 v35 = v58;
      v32[4] = v59;
      v32[5] = v34;
      v32[2] = v36;
      v32[3] = v35;
      unint64_t v37 = v64;
      unsigned int v39 = v61;
      unint64_t v38 = v62;
      v32[8] = v63;
      v32[9] = v37;
      v32[6] = v39;
      v32[7] = v38;
      unsigned __int16 v41 = v66;
      uint64_t v40 = v67;
      __int128 v42 = v65;
      *((void *)v32 + 26) = v68;
      v32[11] = v41;
      v32[12] = v40;
      v32[10] = v42;
      id v43 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v32 + 8, 8uLL, 0LL);
      if (v43) {
        id v43 = *(void *)(v43 + 32);
      }
      *((void *)v32 + 4) = v43;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v32 + 8, 8LL, v32);
      id v14 = -1LL;
      goto LABEL_35;
    }

    unsigned __int8 v15 = *(_DWORD *)(v12 + 8);
    if (v15 > -16233)
    {
      if (v15 == -16232 || v15 == -16114)
      {
LABEL_25:
        if (v13 <= v14)
        {
          unsigned __int8 v17 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xD8uLL);
          int v18 = v56;
          *(_OWORD *)unsigned __int8 v17 = v55;
          *((_OWORD *)v17 + 1) = v18;
          uint64_t v19 = v60;
          unsigned __int16 v21 = v57;
          unsigned __int16 v20 = v58;
          *((_OWORD *)v17 + 4) = v59;
          *((_OWORD *)v17 + 5) = v19;
          *((_OWORD *)v17 + 2) = v21;
          *((_OWORD *)v17 + 3) = v20;
          unsigned __int8 v22 = v64;
          unint64_t v24 = v61;
          uint64_t v23 = v62;
          *((_OWORD *)v17 + _Block_object_dispose(va, 8) = v63;
          *((_OWORD *)v17 + 9) = v22;
          *((_OWORD *)v17 + 6) = v24;
          *((_OWORD *)v17 + 7) = v23;
          unsigned __int8 v26 = v66;
          uint64_t v25 = v67;
          unint64_t v27 = v65;
          v17[26] = v68;
          *((_OWORD *)v17 + 11) = v26;
          *((_OWORD *)v17 + 12) = v25;
          *((_OWORD *)v17 + 10) = v27;
          unint64_t v28 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v17 + 8, 8uLL, 0LL);
          if (v28) {
            unint64_t v28 = *(void *)(v28 + 32);
          }
          v17[4] = v28;
          apr_hash_set(*(apr_hash_t **)(a1 + 32), v17 + 1, 8LL, v17);
          v17[3] = v14;
        }

        goto LABEL_30;
      }

      goto LABEL_30;
    }

    if (v15 == -16240) {
      goto LABEL_25;
    }
    if (v15 == -16238) {
      break;
    }
LABEL_30:
    GTMTLSMTexture_processTraceFuncWithMap((char *)&v55, *(void *)(a1 + 40), (uint64_t *)v12);
    unsigned int v29 = atomic_load((unsigned int *)(v6 + 4));
    uint64_t v30 = v10 + (v29 >> 6);
    id v31 = (HIDWORD(v10) + 1);
    id v10 = (v31 << 32) | v10;
    if ((_DWORD)v31 == v30 - 1)
    {
      id v10 = (v31 << 32) | v31;
      uint64_t v6 = *(void *)(v6 + 40);
      goto LABEL_14;
    }
  }

  if (v13 <= v14)
  {
    uint64_t v32 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xD8uLL);
    uint64_t v44 = v56;
    void *v32 = v55;
    v32[1] = v44;
    unint64_t v45 = v60;
    uint64_t v47 = v57;
    unsigned int v46 = v58;
    v32[4] = v59;
    v32[5] = v45;
    v32[2] = v47;
    v32[3] = v46;
    unint64_t v48 = v64;
    unsigned __int8 v50 = v61;
    uint64_t v49 = v62;
    v32[8] = v63;
    v32[9] = v48;
    v32[6] = v50;
    v32[7] = v49;
    unint64_t v52 = v66;
    unint64_t v51 = v67;
    unsigned int v53 = v65;
    *((void *)v32 + 26) = v68;
    v32[11] = v52;
    v32[12] = v51;
    v32[10] = v53;
    uint64_t v54 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v32 + 8, 8uLL, 0LL);
    if (v54) {
      uint64_t v54 = *(void *)(v54 + 32);
    }
    *((void *)v32 + 4) = v54;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v32 + 8, 8LL, v32);
LABEL_35:
    *((void *)v32 + 3) = v14;
  }

  uint64_t v13 = &v8[8 * (uint64_t)*(int *)(a3 + 12)];
  id v14 = v10 | (unint64_t)(v12 << 32);
  while (1)
  {
    do
    {
      else {
        unsigned __int8 v16 = 0LL;
      }
      if (v8 >= v13)
      {
        if (!v16) {
          goto LABEL_53;
        }
        unsigned __int8 v17 = HIDWORD(v14);
        else {
          unsigned __int8 v16 = 0LL;
        }
        unsigned __int16 v21 = atomic_load((unsigned int *)(v9 + 4));
        unsigned __int16 v20 = v14 + (v21 >> 6);
      }

      else
      {
        if (!v16) {
          goto LABEL_27;
        }
        if (*v8 == *(void *)v16)
        {
          v8 += 8;
        }

        else if (*v8 < *(void *)v16)
        {
LABEL_27:
          unsigned __int8 v16 = (uint64_t)v8;
          v8 += 8;
          goto LABEL_34;
        }

        uint64_t v19 = atomic_load((unsigned int *)(v9 + 4));
        unsigned __int16 v20 = v14 + (v19 >> 6);
        unsigned __int8 v17 = HIDWORD(v14);
      }

      unsigned __int8 v22 = (v17 + 1);
      if ((_DWORD)v22 == v20 - 1)
      {
        id v14 = (v22 << 32) | v22;
        id v9 = *(void *)(v9 + 40);
      }

      else
      {
        id v14 = (v22 << 32) | v14;
      }

  id v10 = v7 | (unint64_t)(v9 << 32);
LABEL_14:
  uint64_t v11 = v6 + 64;
  while (1)
  {
    if (!v6
      || (*(_BYTE *)(v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6) + 15) & 8) == 0
      || (size_t v12 = v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6),
          uint64_t v13 = *(void *)(a1 + 8),
          id v14 = *(void *)v12,
          *(void *)v12 >= *(void *)(a1 + 16) + v13))
    {
      uint64_t v30 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xA8uLL);
      uint64_t v32 = v50;
      id v31 = v51;
      *uint64_t v30 = v49;
      v30[1] = v32;
      v30[2] = v31;
      unsigned int v33 = v55;
      unsigned __int8 v35 = v52;
      uint64_t v34 = v53;
      v30[5] = v54;
      v30[6] = v33;
      v30[3] = v35;
      v30[4] = v34;
      unint64_t v37 = v57;
      unsigned __int16 v36 = v58;
      unint64_t v38 = v56;
      *((void *)v30 + 20) = v59;
      v30[8] = v37;
      v30[9] = v36;
      v30[7] = v38;
      unsigned int v39 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v30 + 8, 8uLL, 0LL);
      if (v39) {
        unsigned int v39 = *(void *)(v39 + 32);
      }
      *((void *)v30 + 4) = v39;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v30 + 8, 8LL, v30);
      id v14 = -1LL;
      goto LABEL_35;
    }

    unsigned __int8 v15 = *(_DWORD *)(v12 + 8);
    if (v15 > -15561)
    {
      if (v15 == -15557 || v15 == -15560)
      {
LABEL_25:
        if (v13 <= v14)
        {
          unsigned __int8 v17 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xA8uLL);
          uint64_t v19 = v50;
          int v18 = v51;
          *(_OWORD *)unsigned __int8 v17 = v49;
          *((_OWORD *)v17 + 1) = v19;
          *((_OWORD *)v17 + 2) = v18;
          unsigned __int16 v20 = v55;
          unsigned __int8 v22 = v52;
          unsigned __int16 v21 = v53;
          *((_OWORD *)v17 + 5) = v54;
          *((_OWORD *)v17 + 6) = v20;
          *((_OWORD *)v17 + 3) = v22;
          *((_OWORD *)v17 + 4) = v21;
          unint64_t v24 = v57;
          uint64_t v23 = v58;
          uint64_t v25 = v56;
          v17[20] = v59;
          *((_OWORD *)v17 + _Block_object_dispose(va, 8) = v24;
          *((_OWORD *)v17 + 9) = v23;
          *((_OWORD *)v17 + 7) = v25;
          unsigned __int8 v26 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v17 + 8, 8uLL, 0LL);
          if (v26) {
            unsigned __int8 v26 = *(void *)(v26 + 32);
          }
          v17[4] = v26;
          apr_hash_set(*(apr_hash_t **)(a1 + 32), v17 + 1, 8LL, v17);
          v17[3] = v14;
        }

        goto LABEL_30;
      }

      goto LABEL_30;
    }

    if (v15 == -15570) {
      goto LABEL_25;
    }
    if (v15 == -15568) {
      break;
    }
LABEL_30:
    GTMTLSMIntersectionFunctionTable_processTraceFuncWithMap((char *)&v49, *(void *)(a1 + 40), (uint64_t *)v12);
    unint64_t v27 = atomic_load((unsigned int *)(v6 + 4));
    unint64_t v28 = v10 + (v27 >> 6);
    unsigned int v29 = (HIDWORD(v10) + 1);
    id v10 = (v29 << 32) | v10;
    if ((_DWORD)v29 == v28 - 1)
    {
      id v10 = (v29 << 32) | v29;
      uint64_t v6 = *(void *)(v6 + 40);
      goto LABEL_14;
    }
  }

  if (v13 <= v14)
  {
    uint64_t v30 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xA8uLL);
    unsigned __int16 v41 = v50;
    uint64_t v40 = v51;
    *uint64_t v30 = v49;
    v30[1] = v41;
    v30[2] = v40;
    __int128 v42 = v55;
    uint64_t v44 = v52;
    id v43 = v53;
    v30[5] = v54;
    v30[6] = v42;
    v30[3] = v44;
    v30[4] = v43;
    unsigned int v46 = v57;
    unint64_t v45 = v58;
    uint64_t v47 = v56;
    *((void *)v30 + 20) = v59;
    v30[8] = v46;
    v30[9] = v45;
    v30[7] = v47;
    unint64_t v48 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v30 + 8, 8uLL, 0LL);
    if (v48) {
      unint64_t v48 = *(void *)(v48 + 32);
    }
    *((void *)v30 + 4) = v48;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v30 + 8, 8LL, v30);
LABEL_35:
    *((void *)v30 + 3) = v14;
  }

      if (!*(_DWORD *)(v6 + 88LL * v5 + 40))
      {
        uint64_t v13 = (_WORD *)(v6 + 88LL * v5);
        v13[22] = v8;
        apr_hash_set(ht, v13 + 4, 8LL, v13);
        unint64_t v2 = *(_DWORD *)(a1 + 12);
      }

      id v5 = v8 + v7;
    }

    while ((int)v8 + v7 < v2);
  }

uint64_t TranslateGTMTLStructType(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  uint64_t v6 = v5;
  if (v5)
  {
    uint64_t v7 = a2[16];
    uint64_t v8 = a2[17];
    a2[16] = v7 + 24;
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v5 members]);
    a2[17] += 32 * (void)[v9 count];

    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    obuint64_t j = (id)objc_claimAutoreleasedReturnValue([v6 members]);
    id v33 = [obj countByEnumeratingWithState:&v34 objects:v38 count:16];
    if (v33)
    {
      uint64_t v27 = v7;
      unint64_t v28 = v6;
      int v10 = 0;
      uint64_t v32 = *(void *)v35;
      uint64_t v26 = v8;
      uint64_t v29 = v8 + 25;
      do
      {
        uint64_t v11 = 0LL;
        int v30 = v10;
        size_t v12 = (_BYTE *)(v29 + 32LL * v10);
        do
        {
          if (*(void *)v35 != v32) {
            objc_enumerationMutation(obj);
          }
          id v13 = *(id *)(*((void *)&v34 + 1) + 8LL * (void)v11);
          id v14 = objc_claimAutoreleasedReturnValue([v13 name]);
          id v15 = [v14 UTF8String];
          id v16 = objc_claimAutoreleasedReturnValue([v13 name]);
          if ([v16 UTF8String])
          {
            id v17 = objc_claimAutoreleasedReturnValue([v13 name]);
            size_t v18 = strlen((const char *)[v17 UTF8String]);
            size_t v19 = v18 + 1;
            if (v18 == -1LL) {
              unsigned __int16 v20 = 0LL;
            }
            else {
              unsigned __int16 v20 = (void *)a2[23];
            }
            a2[23] += v19;
            if ((_DWORD)a3) {
              memcpy(v20, v15, v19);
            }
          }

          else
          {
            unsigned __int16 v20 = 0LL;
          }

          unsigned __int16 v21 = (void *)objc_claimAutoreleasedReturnValue([v13 dataTypeDescription]);
          uint64_t v22 = TranslateGTMTLType(v21, a2, a3);

          if ((_DWORD)a3)
          {
            *(void *)(v12 - 25) = v20;
            *(_DWORD *)(v12 - 9) = [v13 offset];
            *(v12 - 1) = [v13 dataType];
            *(_WORD *)(v12 - 5) = (unsigned __int16)[v13 argumentIndex];
            *(_WORD *)(v12 - 3) = (unsigned __int16)[v13 indirectArgumentIndex];
            *(void *)(v12 - 17) = v22;
            if ((objc_opt_respondsToSelector(v13, "aluType") & 1) != 0)
            {
              id v23 = v13;
              *size_t v12 = [v23 aluType];
            }
          }

          uint64_t v11 = (char *)v11 + 1;
          v12 += 32;
        }

        while (v33 != v11);
        int v10 = v30 + (_DWORD)v11;
        id v33 = [obj countByEnumeratingWithState:&v34 objects:v38 count:16];
      }

      while (v33);
      uint64_t v7 = v27;
      uint64_t v6 = v28;
      uint64_t v8 = v26;
    }

    else
    {
      int v10 = 0;
    }

    if ((_DWORD)a3)
    {
      *(_BYTE *)uint64_t v7 = 1;
      if (v10) {
        uint64_t v24 = v8;
      }
      else {
        uint64_t v24 = 0LL;
      }
      *(void *)(v7 + _Block_object_dispose(va, 8) = v24;
      *(_DWORD *)(v7 + 16) = v10;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  return v7;
}

void TranslateGTMTLBinding(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = objc_claimAutoreleasedReturnValue([v7 name]);
  id v9 = [v8 UTF8String];
  id v10 = objc_claimAutoreleasedReturnValue([v7 name]);
  if ([v10 UTF8String])
  {
    id v11 = objc_claimAutoreleasedReturnValue([v7 name]);
    size_t v12 = strlen((const char *)[v11 UTF8String]);
    size_t v13 = v12 + 1;
    if (v12 == -1LL) {
      id v14 = 0LL;
    }
    else {
      id v14 = (void *)a3[23];
    }
    a3[23] += v13;
    if ((_DWORD)a4) {
      memcpy(v14, v9, v13);
    }
  }

  else
  {
    id v14 = 0LL;
  }

  unsigned __int8 v15 = [v7 access];
  unsigned __int8 v16 = [v7 isUsed];
  else {
    char v17 = 0;
  }
  char v54 = v17;
  unsigned __int8 v18 = [v7 index];
  id v53 = [v7 type];
  id v59 = v7;
  size_t v19 = (int *)[v59 type];
  unsigned __int16 v20 = 0;
  uint64_t v21 = 0LL;
  unsigned __int8 v57 = v15;
  unsigned __int8 v58 = v14;
  unsigned __int8 v56 = v16;
  unsigned __int8 v55 = v18;
  if ((uint64_t)v19 <= 15)
  {
    if (v19)
    {
      if (v19 != (int *)((char *)&dword_0 + 1))
      {
        uint64_t v22 = 0LL;
        unsigned __int16 v23 = 0;
        unsigned __int8 v24 = 0;
        unint64_t v25 = 0LL;
        uint64_t v26 = 0LL;
        if (v19 == (int *)((char *)&dword_0 + 2))
        {
          unsigned __int8 v27 = [v59 textureDataType];
          unint64_t v28 = [v59 textureType] | ((unint64_t)v27 << 8);
          unint64_t v29 = v28 & 0xFFFFFFFFFF00FFFFLL | ((unint64_t)[v59 arrayLength] << 16);
          unsigned int v30 = [v59 isDepthTexture];
          uint64_t v21 = 0LL;
          uint64_t v22 = 0LL;
          unsigned __int16 v20 = 0;
          unsigned __int16 v23 = 0;
          unsigned __int8 v24 = 0;
          uint64_t v26 = 0LL;
          uint64_t v31 = 0x1000000LL;
          if (!v30) {
            uint64_t v31 = 0LL;
          }
          unint64_t v25 = v29 | v31;
        }

        goto LABEL_38;
      }

      unsigned __int16 v40 = (unsigned __int16)[v59 threadgroupMemoryAlignment];
      unint64_t v25 = [v59 threadgroupMemoryDataSize] | ((unint64_t)v40 << 32);
    }

    else
    {
      unsigned __int16 v35 = (unsigned __int16)[v59 bufferAlignment];
      unint64_t v36 = [v59 bufferDataSize] | ((unint64_t)v35 << 32);
      unint64_t v37 = v36 & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)[v59 bufferDataType] << 48);
      unsigned int v38 = [v59 isVertexDescriptorBuffer];
      uint64_t v39 = 0x100000000000000LL;
      if (!v38) {
        uint64_t v39 = 0LL;
      }
      unint64_t v25 = v37 | v39;
    }

    unsigned __int16 v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v59, "dataTypeDescription", v53));
    uint64_t v26 = TranslateGTMTLType(v41, a3, a4);

    uint64_t v21 = 0LL;
LABEL_37:
    uint64_t v22 = 0LL;
    unsigned __int16 v20 = 0;
    unsigned __int16 v23 = 0;
    unsigned __int8 v24 = 0;
    goto LABEL_38;
  }

  if (v19 == &dword_10)
  {
    uint64_t v42 = [v59 imageBlockDataSize];
    unint64_t v43 = v42 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)[v59 aliasImplicitImageBlockRenderTarget] << 32);
    unsigned int v44 = [v59 aliasImplicitImageBlock];
    uint64_t v45 = 0x10000000000LL;
    if (!v44) {
      uint64_t v45 = 0LL;
    }
    uint64_t v21 = v43 | v45;
    unsigned int v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v59, "imageBlockMasterStructMembers", v53));
    if (!v46) {
      goto LABEL_35;
    }
    goto LABEL_31;
  }

  if (v19 == (int *)((char *)&dword_10 + 1))
  {
    unsigned __int8 v48 = [v59 imageBlockKind];
    unint64_t v49 = [v59 imageBlockDataSize] | ((unint64_t)v48 << 48);
    unint64_t v50 = v49 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)[v59 aliasImplicitImageBlockRenderTarget] << 32);
    unsigned int v51 = [v59 aliasImplicitImageBlock];
    uint64_t v52 = 0x10000000000LL;
    if (!v51) {
      uint64_t v52 = 0LL;
    }
    uint64_t v21 = v50 | v52;
    unsigned int v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v59, "dataTypeDescription", v53));
    if (v46)
    {
LABEL_35:
      uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v59 dataTypeDescription]);
      uint64_t v26 = TranslateGTMTLType(v47, a3, a4);
      unint64_t v25 = 0LL;
      goto LABEL_36;
    }

LABEL_31:
    uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v59 imageBlockMasterStructMembers]);
    unint64_t v25 = TranslateGTMTLStructType(v47, a3, a4);
    uint64_t v26 = 0LL;
LABEL_36:

    goto LABEL_37;
  }

  uint64_t v22 = 0LL;
  unsigned __int16 v23 = 0;
  unsigned __int8 v24 = 0;
  unint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  if (v19 == (int *)((char *)&stru_20.cmd + 3))
  {
    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v59 meshVertexStruct]);
    uint64_t v21 = TranslateGTMTLStructType(v32, a3, a4);

    id v33 = (void *)objc_claimAutoreleasedReturnValue([v59 meshPrimitiveStruct]);
    uint64_t v22 = TranslateGTMTLStructType(v33, a3, a4);

    unsigned __int16 v20 = (unsigned __int16)[v59 meshVertexCount];
    unsigned __int16 v23 = (unsigned __int16)[v59 meshPrimitiveCount];
    unsigned __int8 v24 = [v59 meshTopologyType];
    uint64_t v34 = [v59 builtInType];
    uint64_t v26 = 0LL;
    unint64_t v25 = v34 & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)[v59 builtInDataType] << 8);
  }

  *(void *)(v50 + 16) = v54;
  unsigned __int16 v40 = (void *)objc_claimAutoreleasedReturnValue([v49 arguments]);
  *(_WORD *)(v50 + 40) = (unsigned __int16)[v40 count];

  unsigned __int16 v41 = (void *)objc_claimAutoreleasedReturnValue([v49 controlDependencies]);
  *(void *)(v50 + 24) = CopyFunctionStitchingFunctionNodeArray(v41, a3, v22, v52, a6);

  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v49 controlDependencies]);
  *(_WORD *)(v50 + 42) = (unsigned __int16)[v42 count];

  entry = find_entry((uint64_t)a3, &v56, 8uLL, 0LL);
  if (*entry)
  {
    unsigned int v44 = *(const void **)(*entry + 32LL);
    uint64_t v45 = (const void **)(v50 + 32);
    if (v44)
    {
      *uint64_t v45 = v44;
      goto LABEL_36;
    }
  }

  else
  {
    uint64_t v45 = (const void **)(v50 + 32);
  }

  unsigned int v46 = *a4;
  *uint64_t v45 = *a4;
  uint64_t v47 = apr_palloc(*a3, 8uLL);
  void *v47 = v56;
  apr_hash_set((apr_hash_t *)a3, v47, 8LL, v46);
  *a4 = (char *)*a4 + 1;
LABEL_36:
  if (MTLFunctionStitchingNodeType == 2) {
    *(_BYTE *)(v50 + 44) = [v49 isEarlyReturn];
  }
}

LABEL_38:
  if ((_DWORD)a4)
  {
    *(void *)a1 = v58;
    *(void *)(a1 + _Block_object_dispose(va, 8) = v26;
    *(_BYTE *)(a1 + 16) = (_BYTE)v53;
    *(_BYTE *)(a1 + 17) = v57;
    *(_BYTE *)(a1 + 1_Block_object_dispose(va, 8) = v55;
    *(_BYTE *)(a1 + 19) = v54 | v56;
    *(_DWORD *)(a1 + 20) = 0;
    *(void *)(a1 + 24) = v25;
    *(void *)(a1 + 32) = v21;
    *(void *)(a1 + 40) = v22;
    *(_WORD *)(a1 + 4_Block_object_dispose(va, 8) = v20;
    *(_WORD *)(a1 + 50) = v23;
    *(_BYTE *)(a1 + 52) = v24;
    *(_WORD *)(a1 + 53) = 0;
    *(_BYTE *)(a1 + 55) = 0;
  }
}

  id v59 = v11;
  unsigned __int8 v24 = v11 + 8;
  if (v11 + 8 <= v60)
  {
    *(void *)((char *)v58 + v11) = 31LL;
    unsigned __int8 v24 = v59 + 8;
  }

  unint64_t v25 = 0LL;
  id v59 = v24;
  do
  {
    uint64_t v26 = v24 + 8;
    if (v24 + 8 <= v60)
    {
      *(void *)((char *)v58 + v24) = *(unsigned __int8 *)(a1 + 920 + v25);
      uint64_t v26 = v59 + 8;
    }

    id v59 = v26;
    ++v25;
    unsigned __int8 v24 = v26;
  }

  while (v25 != 31);
  unsigned __int8 v27 = v26 + 8;
  unint64_t v28 = v60;
  if (v26 + 8 <= v60)
  {
    *(void *)((char *)v58 + v26) = *(unsigned __int8 *)(a1 + 956);
    unint64_t v28 = v60;
    unsigned __int8 v27 = v59 + 8;
  }

  id v59 = v27;
  unint64_t v29 = v27 + 8;
  if (v27 + 8 <= v28)
  {
    *(void *)((char *)v58 + v27) = *(unsigned __int16 *)(a1 + 918);
    unint64_t v29 = v59 + 8;
  }

  id v59 = v29;
  unsigned __int8 v56 = *(void *)(a1 + 880);
  unsigned int v30 = find_entry(a4, &v56, 8uLL, 0LL);
  if (*v30) {
    uint64_t v31 = *(void *)(*v30 + 32LL);
  }
  else {
    uint64_t v31 = 0LL;
  }
  uint64_t v32 = v60;
  id v33 = v59 + 8;
  if (v59 + 8 <= v60)
  {
    *(void *)((char *)v58 + v59) = *(void *)(v31 + 8);
    uint64_t v32 = v60;
    id v33 = v59 + 8;
  }

  id v59 = v33;
  uint64_t v34 = *(void *)(a1 + 864);
  unsigned __int16 v35 = v33 + 8;
  if (v33 + 8 <= v32)
  {
    *(void *)((char *)v58 + v33) = v34;
    unsigned __int16 v35 = v59 + 8;
    uint64_t v34 = *(void *)(a1 + 864);
  }

  id v59 = v35;
  if (v34)
  {
    unint64_t v36 = 0LL;
    do
    {
      unsigned __int8 v55 = *(void *)(*(void *)(a1 + 856) + 8 * v36);
      unint64_t v37 = *find_entry(a4, &v55, 8uLL, 0LL);
      if (v37) {
        unint64_t v37 = *(void *)(v37 + 32);
      }
      unsigned __int16 v35 = v59 + 8;
      if (v59 + 8 <= v60)
      {
        *(void *)((char *)v58 + v59) = *(void *)(v37 + 8);
        unsigned __int16 v35 = v59 + 8;
      }

      id v59 = v35;
      ++v36;
    }

    while (*(void *)(a1 + 864) > v36);
  }

  unsigned int v38 = v35 + 8;
  uint64_t v39 = v60;
  if (v35 + 8 <= v60)
  {
    *(void *)((char *)v58 + v35) = *(void *)(a1 + 904);
    uint64_t v39 = v60;
    unsigned int v38 = v59 + 8;
  }

  id v59 = v38;
  unsigned __int16 v40 = v38 + 8;
  if (v38 + 8 <= v39)
  {
    *(void *)((char *)v58 + v3_Block_object_dispose(va, 8) = *(unsigned __int8 *)(a1 + 957);
    uint64_t v39 = v60;
    unsigned __int16 v40 = v59 + 8;
  }

  id v59 = v40;
  unsigned __int16 v41 = v40 + 8;
  if (v40 + 8 <= v39)
  {
    *(void *)((char *)v58 + v40) = *(unsigned __int16 *)(a1 + 912);
    uint64_t v39 = v60;
    unsigned __int16 v41 = v59 + 8;
  }

  id v59 = v41;
  uint64_t v42 = v41 + 8;
  if (v41 + 8 <= v39)
  {
    *(void *)((char *)v58 + v41) = *(unsigned __int8 *)(a1 + 954);
    uint64_t v39 = v60;
    uint64_t v42 = v59 + 8;
  }

  id v59 = v42;
  unint64_t v43 = v42 + 8;
  if (v42 + 8 <= v39)
  {
    *(void *)((char *)v58 + v42) = *(unsigned __int8 *)(a1 + 953);
    uint64_t v39 = v60;
    unint64_t v43 = v59 + 8;
  }

  id v59 = v43;
  unsigned int v44 = v43 + 8;
  if (v43 + 8 <= v39)
  {
    *(void *)((char *)v58 + v43) = *(unsigned __int8 *)(a1 + 952);
    unsigned int v44 = v59 + 8;
  }

  id v59 = v44;
  WriteGTData(&v58, *(const void **)(a1 + 832), *(void *)(a1 + 840));
  WriteGTData(&v58, *(const void **)(a1 + 816), *(void *)(a1 + 824));
  uint64_t v45 = v60;
  unsigned int v46 = v59 + 8;
  if (v59 + 8 <= v60)
  {
    *(void *)((char *)v58 + v59) = *(unsigned __int16 *)(a1 + 916);
    uint64_t v45 = v60;
    unsigned int v46 = v59 + 8;
  }

  id v59 = v46;
  uint64_t v47 = v46 + 8;
  if (v46 + 8 <= v45)
  {
    *(void *)((char *)v58 + v46) = *(unsigned __int8 *)(a1 + 955);
    uint64_t v47 = v59 + 8;
  }

  id v59 = v47;
  SaveDYMTLLinkedFunctions(&v58, a1 + 752, a4);
  unsigned __int8 v48 = *(void *)(a1 + 896);
  unint64_t v49 = v59 + 8;
  if (v59 + 8 <= v60)
  {
    *(void *)((char *)v58 + v59) = v48;
    unint64_t v49 = v59 + 8;
    unsigned __int8 v48 = *(void *)(a1 + 896);
  }

  id v59 = v49;
  if (v48)
  {
    unint64_t v50 = 0LL;
    do
    {
      char v54 = *(void *)(*(void *)(a1 + 888) + 8 * v50);
      unsigned int v51 = find_entry(a4, &v54, 8uLL, 0LL);
      if (*v51) {
        uint64_t v52 = *(void *)(*v51 + 32LL);
      }
      else {
        uint64_t v52 = 0LL;
      }
      unint64_t v49 = v59 + 8;
      if (v59 + 8 <= v60)
      {
        *(void *)((char *)v58 + v59) = *(void *)(v52 + 8);
        unint64_t v49 = v59 + 8;
      }

      id v59 = v49;
      ++v50;
    }

    while (*(void *)(a1 + 896) > v50);
  }

  id result = v49 + 8;
  if (v49 + 8 <= v60)
  {
    *(void *)((char *)v58 + v49) = *(unsigned __int16 *)(a1 + 914);
    return v59 + 8;
  }

  return result;
}

uint64_t TranslateGTMTLRenderPipelineReflection(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  uint64_t v44 = a2[14];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 vertexBindings]);
  __int16 v45 = TranslateBindings(v6, a2, a3);

  uint64_t v42 = a2[14];
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 fragmentBindings]);
  __int16 v43 = TranslateBindings(v7, a2, a3);

  uint64_t v40 = a2[14];
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v5 vertexBuiltInArguments]);
  __int16 v41 = TranslateArguments(v8, a2, a3);

  if ((objc_opt_respondsToSelector(v5, "imageBlockDataReturn") & 1) != 0
    && (id v9 = (void *)objc_claimAutoreleasedReturnValue([v5 imageBlockDataReturn]), v9, v9))
  {
    uint64_t v10 = a2[14];
    a2[14] = v10 + 56;
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v5 imageBlockDataReturn]);
    uint64_t v39 = v10;
    TranslateGTMTLArgument(v10, v11, a2, a3);
  }

  else
  {
    uint64_t v39 = 0LL;
  }

  if ((objc_opt_respondsToSelector(v5, "tileBindings") & 1) != 0) {
    size_t v12 = (void *)objc_claimAutoreleasedReturnValue([v5 tileBindings]);
  }
  else {
    size_t v12 = &__NSArray0__struct;
  }
  uint64_t v37 = a2[14];
  unint64_t v49 = v12;
  __int16 v38 = TranslateBindings(v12, a2, a3);
  if ((objc_opt_respondsToSelector(v5, "objectBindings") & 1) != 0) {
    size_t v13 = (void *)objc_claimAutoreleasedReturnValue([v5 objectBindings]);
  }
  else {
    size_t v13 = &__NSArray0__struct;
  }
  if ((objc_opt_respondsToSelector(v5, "objectBuiltInArguments") & 1) != 0) {
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v5 objectBuiltInArguments]);
  }
  else {
    id v14 = &__NSArray0__struct;
  }
  if ((objc_opt_respondsToSelector(v5, "meshBindings") & 1) != 0) {
    unsigned __int8 v15 = (void *)objc_claimAutoreleasedReturnValue([v5 meshBindings]);
  }
  else {
    unsigned __int8 v15 = &__NSArray0__struct;
  }
  if ((objc_opt_respondsToSelector(v5, "meshBuiltInArguments") & 1) != 0) {
    unsigned __int8 v16 = (void *)objc_claimAutoreleasedReturnValue([v5 meshBuiltInArguments]);
  }
  else {
    unsigned __int8 v16 = &__NSArray0__struct;
  }
  uint64_t v36 = a2[14];
  unsigned __int8 v48 = v13;
  __int16 v17 = TranslateBindings(v13, a2, a3);
  uint64_t v18 = a2[14];
  uint64_t v47 = v14;
  __int16 v19 = TranslateArguments(v14, a2, a3);
  uint64_t v20 = a2[14];
  unsigned int v46 = v15;
  __int16 v21 = TranslateBindings(v15, a2, a3);
  uint64_t v22 = a2[14];
  __int16 v23 = TranslateArguments(v16, a2, a3);
  if ((_DWORD)a3)
  {
    uint64_t v24 = a2[12];
    uint64_t v25 = v44;
    if (!v45) {
      uint64_t v25 = 0LL;
    }
    uint64_t v26 = v40;
    if (!v41) {
      uint64_t v26 = 0LL;
    }
    *(void *)uint64_t v24 = 0LL;
    *(void *)(v24 + _Block_object_dispose(va, 8) = 0LL;
    uint64_t v27 = v42;
    if (!v43) {
      uint64_t v27 = 0LL;
    }
    uint64_t v28 = v37;
    if (!v38) {
      uint64_t v28 = 0LL;
    }
    *(void *)(v24 + 16) = 0LL;
    *(void *)(v24 + 24) = v25;
    uint64_t v29 = v36;
    if (!v17) {
      uint64_t v29 = 0LL;
    }
    if (v19) {
      uint64_t v30 = v18;
    }
    else {
      uint64_t v30 = 0LL;
    }
    *(void *)(v24 + 32) = v27;
    *(void *)(v24 + 40) = v29;
    if (v21) {
      uint64_t v31 = v20;
    }
    else {
      uint64_t v31 = 0LL;
    }
    if (v23) {
      uint64_t v32 = v22;
    }
    else {
      uint64_t v32 = 0LL;
    }
    *(void *)(v24 + 4_Block_object_dispose(va, 8) = v31;
    *(void *)(v24 + 56) = v28;
    *(void *)(v24 + 64) = v39;
    *(void *)(v24 + 72) = v26;
    *(void *)(v24 + 80) = v30;
    *(void *)(v24 + 8_Block_object_dispose(va, 8) = v32;
    *(_OWORD *)(v24 + 96) = 0u;
    *(_OWORD *)(v24 + 112) = 0u;
    *(_OWORD *)(v24 + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v24 + 144) = 0u;
    *(_OWORD *)(v24 + 160) = 0u;
    *(_OWORD *)(v24 + 176) = 0u;
    *(void *)(v24 + 190) = 0LL;
    *(_OWORD *)(v24 + 214) = 0u;
    id v33 = (_OWORD *)(v24 + 214);
    *((_WORD *)v33 - _Block_object_dispose(va, 8) = v45;
    *((_WORD *)v33 - 7) = v43;
    *((_WORD *)v33 - 6) = v38;
    *((_WORD *)v33 - 5) = v17;
    *((_WORD *)v33 - 4) = v21;
    *((_WORD *)v33 - 3) = v41;
    *((_WORD *)v33 - 2) = v19;
    *((_WORD *)v33 - 1) = v23;
    v33[1] = 0u;
    v33[2] = 0u;
    v33[3] = 0u;
    v33[4] = 0u;
    v33[5] = 0u;
    v33[6] = 0u;
    v33[7] = 0u;
    v33[8] = 0u;
    v33[9] = 0u;
    v33[10] = 0u;
    v33[11] = 0u;
    v33[12] = 0u;
    v33[13] = 0u;
    v33[14] = 0u;
    v33[15] = 0u;
    v33[16] = 0u;
    *(_OWORD *)((char *)v33 + 266) = 0u;
  }

  uint64_t v34 = a2[12];
  a2[12] = v34 + 496;

  return v34;
}

uint64_t TranslateBindings(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  uint64_t v6 = a2[14];
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  id v7 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v18;
    do
    {
      for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v9) {
          objc_enumerationMutation(v5);
        }
        id v11 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)i);
        unint64_t v12 = (unint64_t)[v11 type];
        if (v12 <= 0x23 && ((1LL << v12) & 0x80F03000FLL) != 0)
        {
          uint64_t v14 = a2[14];
          a2[14] = v14 + 56;
          TranslateGTMTLBinding(v14, v11, a2, a3);
        }
      }

      id v8 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }

    while (v8);
  }

  uint64_t v15 = a2[14];

  return -1227133513 * ((unint64_t)(v15 - v6) >> 3);
}

uint64_t TranslateArguments(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  uint64_t v6 = a2[14];
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  id v7 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v18;
    do
    {
      for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v9) {
          objc_enumerationMutation(v5);
        }
        id v11 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)i);
        unint64_t v12 = (unint64_t)[v11 type];
        if (v12 <= 0x23 && ((1LL << v12) & 0x80F03000FLL) != 0)
        {
          uint64_t v14 = a2[14];
          a2[14] = v14 + 56;
          TranslateGTMTLArgument(v14, v11, a2, a3);
        }
      }

      id v8 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }

    while (v8);
  }

  uint64_t v15 = a2[14];

  return -1227133513 * ((unint64_t)(v15 - v6) >> 3);
}

uint64_t TranslateGTMTLComputePipelineReflection(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = a2[14];
  id v6 = a1;
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 builtInArguments]);
  __int16 v8 = TranslateArguments(v7, a2, a3);

  uint64_t v9 = a2[14];
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v6 bindings]);

  __int16 v11 = TranslateBindings(v10, a2, a3);
  if ((_DWORD)a3)
  {
    uint64_t v12 = a2[11];
    if (v8) {
      uint64_t v13 = v5;
    }
    else {
      uint64_t v13 = 0LL;
    }
    if (v11) {
      uint64_t v14 = v9;
    }
    else {
      uint64_t v14 = 0LL;
    }
    *(void *)uint64_t v12 = 0LL;
    *(void *)(v12 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(v12 + 16) = 0LL;
    *(void *)(v12 + 24) = v13;
    *(void *)(v12 + 32) = v14;
    *(_OWORD *)(v12 + 40) = 0u;
    *(_OWORD *)(v12 + 56) = 0u;
    *(_OWORD *)(v12 + 72) = 0u;
    *(_DWORD *)(v12 + 8_Block_object_dispose(va, 8) = 0;
    *(_WORD *)(v12 + 92) = v8;
    *(_WORD *)(v12 + 94) = v11;
    *(_OWORD *)(v12 + 96) = 0u;
    *(_OWORD *)(v12 + 112) = 0u;
    *(_OWORD *)(v12 + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v12 + 144) = 0u;
  }

  uint64_t result = a2[11];
  a2[11] = result + 160;
  return result;
}

void TranslateGTMTLFunctionInfo(void *a1, void *a2, void *a3, void *a4, int a5)
{
  id v9 = a1;
  id v10 = a2;
  id v11 = a3;
  if (!v9) {
    goto LABEL_70;
  }
  id v81 = v11;
  id v12 = v11;
  id v13 = [v12 UTF8String];
  id v14 = v12;
  if (![v14 UTF8String])
  {
    size_t v19 = 0LL;
    unsigned __int8 v16 = a4 + 23;
    __int128 v17 = (char *)a4[23];
    goto LABEL_6;
  }

  size_t v15 = strlen((const char *)[v14 UTF8String]);
  unsigned __int8 v16 = a4 + 23;
  __int128 v17 = (char *)a4[23];
  __int128 v18 = v17;
  size_t v19 = v15 + 1;
  if (v15 == -1LL) {
LABEL_6:
  }
    __int128 v18 = 0LL;
  void *v16 = &v17[v19];
  if (a5) {
    memcpy(v18, v13, v19);
  }
  __int128 v80 = v18;
  id v20 = objc_claimAutoreleasedReturnValue([v10 filePath]);
  id v21 = [v20 UTF8String];
  id v22 = objc_claimAutoreleasedReturnValue([v10 filePath]);
  id v23 = [v22 UTF8String];
  if (!v23)
  {
    size_t v27 = 0LL;
    uint64_t v25 = a4 + 23;
    uint64_t v26 = (char *)a4[23];
    goto LABEL_13;
  }

  obuint64_t j = objc_claimAutoreleasedReturnValue([v10 filePath]);
  size_t v24 = strlen((const char *)[obj UTF8String]);
  uint64_t v25 = a4 + 23;
  uint64_t v26 = (char *)a4[23];
  __dst = v26;
  size_t v27 = v24 + 1;
  if (v24 == -1LL) {
LABEL_13:
  }
    __dst = 0LL;
  *uint64_t v25 = &v26[v27];
  if (a5) {
    memcpy(__dst, v21, v27);
  }
  id v28 = objc_claimAutoreleasedReturnValue([v10 unpackedFilePath]);
  id v29 = [v28 UTF8String];
  id v30 = objc_claimAutoreleasedReturnValue([v10 unpackedFilePath]);
  id v31 = [v30 UTF8String];
  uint64_t v32 = v10;
  id v33 = v31;
  uint64_t v82 = v32;
  if (v31)
  {
    id v5 = objc_claimAutoreleasedReturnValue([v32 unpackedFilePath]);
    size_t v34 = strlen((const char *)[v5 UTF8String]);
    unsigned __int16 v35 = a4 + 23;
    uint64_t v36 = (char *)a4[23];
    unsigned int v83 = v36;
    size_t v37 = v34 + 1;
    if (v34 != -1LL) {
      goto LABEL_21;
    }
  }

  else
  {
    size_t v37 = 0LL;
    unsigned __int16 v35 = a4 + 23;
    uint64_t v36 = (char *)a4[23];
  }

  unsigned int v83 = 0LL;
LABEL_21:
  *unsigned __int16 v35 = &v36[v37];
  if (a5) {
    memcpy(v83, v29, v37);
  }
  unsigned __int16 v79 = (unsigned __int16)[v9 functionType];
  unsigned __int16 v78 = (unsigned __int16)[v9 lineNumber];
  unsigned __int16 v77 = (unsigned __int16)[v9 patchControlPointCount];
  unsigned __int8 v76 = [v9 patchType];
  v98[0] = 0;
  *(_DWORD *)((char *)v98 + 3) = 0;
  if (v33) {

  }
  if (v23) {
  __int16 v38 = (void *)objc_claimAutoreleasedReturnValue([v9 vertexAttributes]);
  }
  unsigned __int8 v39 = [v38 count];

  unsigned __int8 v75 = v39;
  if (v39) {
    uint64_t v74 = a4[20];
  }
  else {
    uint64_t v74 = 0LL;
  }
  __int128 v96 = 0u;
  __int128 v97 = 0u;
  __int128 v94 = 0u;
  __int128 v95 = 0u;
  uint64_t v85 = v9;
  id obja = (id)objc_claimAutoreleasedReturnValue([v9 vertexAttributes]);
  id v40 = [obja countByEnumeratingWithState:&v94 objects:v100 count:16];
  if (v40)
  {
    id v41 = v40;
    uint64_t v42 = *(void *)v95;
    do
    {
      for (uint64_t i = 0LL; i != v41; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v95 != v42) {
          objc_enumerationMutation(obja);
        }
        uint64_t v44 = *(void **)(*((void *)&v94 + 1) + 8LL * (void)i);
        id v45 = objc_claimAutoreleasedReturnValue([v44 name]);
        id v46 = [v45 UTF8String];
        id v47 = objc_claimAutoreleasedReturnValue([v44 name]);
        if ([v47 UTF8String])
        {
          id v48 = objc_claimAutoreleasedReturnValue([v44 name]);
          size_t v49 = strlen((const char *)[v48 UTF8String]);
          size_t v50 = v49 + 1;
          if (v49 == -1LL) {
            unsigned int v51 = 0LL;
          }
          else {
            unsigned int v51 = (void *)a4[23];
          }
          a4[23] += v50;
          if (a5) {
            memcpy(v51, v46, v50);
          }
        }

        else
        {
          unsigned int v51 = 0LL;
        }

        uint64_t v52 = a4[20];
        if (a5)
        {
          *(void *)uint64_t v52 = v51;
          *(_DWORD *)(a4[20] + 8) = [v44 attributeIndex];
          *(_BYTE *)(a4[20] + 12) = [v44 attributeType];
          *(_BYTE *)(a4[20] + 13) = [v44 isActive];
          *(_BYTE *)(a4[20] + 14) = [v44 isPatchData];
          unsigned __int8 v53 = [v44 isPatchControlPointData];
          uint64_t v52 = a4[20];
          *(_BYTE *)(v52 + 15) = v53;
        }

        a4[20] = v52 + 16;
      }

      id v41 = [obja countByEnumeratingWithState:&v94 objects:v100 count:16];
    }

    while (v41);
  }

  char v54 = (void *)objc_claimAutoreleasedReturnValue([v85 stageInputAttributes]);
  unsigned __int8 v55 = [v54 count];

  unsigned __int8 v73 = v55;
  if (v55) {
    uint64_t v71 = a4[21];
  }
  else {
    uint64_t v71 = 0LL;
  }
  __int128 v92 = 0u;
  __int128 v93 = 0u;
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  id objb = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v85, "stageInputAttributes", v71));
  id v56 = [objb countByEnumeratingWithState:&v90 objects:v99 count:16];
  if (v56)
  {
    id v57 = v56;
    uint64_t v58 = *(void *)v91;
    do
    {
      for (uint64_t j = 0LL; j != v57; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v91 != v58) {
          objc_enumerationMutation(objb);
        }
        id v60 = *(void **)(*((void *)&v90 + 1) + 8LL * (void)j);
        id v61 = objc_claimAutoreleasedReturnValue([v60 name]);
        id v62 = [v61 UTF8String];
        id v63 = objc_claimAutoreleasedReturnValue([v60 name]);
        if ([v63 UTF8String])
        {
          id v64 = objc_claimAutoreleasedReturnValue([v60 name]);
          size_t v65 = strlen((const char *)[v64 UTF8String]);
          size_t v66 = v65 + 1;
          if (v65 == -1LL) {
            unint64_t v67 = 0LL;
          }
          else {
            unint64_t v67 = (void *)a4[23];
          }
          a4[23] += v66;
          if (a5) {
            memcpy(v67, v62, v66);
          }
        }

        else
        {
          unint64_t v67 = 0LL;
        }

        uint64_t v68 = a4[21];
        if (a5)
        {
          *(void *)uint64_t v68 = v67;
          *(_DWORD *)(a4[21] + 8) = [v60 attributeIndex];
          *(_BYTE *)(a4[21] + 12) = [v60 attributeType];
          *(_BYTE *)(a4[21] + 13) = [v60 isActive];
          *(_BYTE *)(a4[21] + 14) = [v60 isPatchData];
          unsigned __int8 v69 = [v60 isPatchControlPointData];
          uint64_t v68 = a4[21];
          *(_BYTE *)(v68 + 15) = v69;
        }

        a4[21] = v68 + 16;
      }

      id v57 = [objb countByEnumeratingWithState:&v90 objects:v99 count:16];
    }

    while (v57);
  }

  if (a5)
  {
    uint64_t v70 = a4[3];
    *(void *)uint64_t v70 = v80;
    *(void *)(v70 + _Block_object_dispose(va, 8) = __dst;
    *(void *)(v70 + 16) = v83;
    *(void *)(v70 + 24) = v74;
    *(void *)(v70 + 32) = v72;
    *(_WORD *)(v70 + 40) = v79;
    *(_WORD *)(v70 + 42) = v78;
    *(_WORD *)(v70 + 44) = v77;
    *(_BYTE *)(v70 + 46) = v75;
    *(_BYTE *)(v70 + 47) = v73;
    *(_BYTE *)(v70 + 4_Block_object_dispose(va, 8) = v76;
    *(_DWORD *)(v70 + 49) = v98[0];
    *(_DWORD *)(v70 + 52) = *(_DWORD *)((char *)v98 + 3);
  }

  a4[3] += 56LL;
  id v9 = v85;
  id v11 = v81;
  id v10 = v82;
LABEL_70:
}

void TranslateGTMTLDynamicLibraryInfo(void *a1, void *a2, int a3)
{
  id v5 = a1;
  if (v5)
  {
    id v42 = v5;
    id v6 = v5;
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 exportedFunctions]);
    unsigned __int16 v8 = (unsigned __int16)[v7 count];
    unsigned __int16 v39 = v8;
    if (v8) {
      uint64_t v9 = a2[22];
    }
    else {
      uint64_t v9 = 0LL;
    }
    a2[22] += 8LL * v8;
    id v10 = objc_claimAutoreleasedReturnValue([v6 installName]);
    id v11 = [v10 UTF8String];
    id v12 = objc_claimAutoreleasedReturnValue([v6 installName]);
    if ([v12 UTF8String])
    {
      id v13 = objc_claimAutoreleasedReturnValue([v6 installName]);
      size_t v14 = strlen((const char *)[v13 UTF8String]);
      size_t v15 = v14 + 1;
      if (v14 == -1LL) {
        unsigned __int8 v16 = 0LL;
      }
      else {
        unsigned __int8 v16 = (void *)a2[23];
      }
      __dst = v16;
      a2[23] += v15;
      if (a3) {
        memcpy(v16, v11, v15);
      }
    }

    else
    {
      __dst = 0LL;
    }

    id v17 = objc_claimAutoreleasedReturnValue([v6 libraryPath]);
    id v18 = [v17 UTF8String];
    id v19 = objc_claimAutoreleasedReturnValue([v6 libraryPath]);
    id v41 = v6;
    if ([v19 UTF8String])
    {
      id v20 = objc_claimAutoreleasedReturnValue([v6 libraryPath]);
      size_t v21 = strlen((const char *)[v20 UTF8String]);
      size_t v22 = v21 + 1;
      if (v21 == -1LL) {
        id v23 = 0LL;
      }
      else {
        id v23 = (void *)a2[23];
      }
      a2[23] += v22;
      if (a3) {
        memcpy(v23, v18, v22);
      }
      __int16 v38 = v23;
    }

    else
    {
      __int16 v38 = 0LL;
    }

    __int128 v45 = 0u;
    __int128 v46 = 0u;
    __int128 v43 = 0u;
    __int128 v44 = 0u;
    id v24 = v7;
    id v25 = [v24 countByEnumeratingWithState:&v43 objects:v47 count:16];
    if (v25)
    {
      id v26 = v25;
      int v27 = 0;
      uint64_t v28 = *(void *)v44;
      do
      {
        for (uint64_t i = 0LL; i != v26; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v44 != v28) {
            objc_enumerationMutation(v24);
          }
          id v30 = *(id *)(*((void *)&v43 + 1) + 8LL * (void)i);
          id v31 = [v30 UTF8String];
          id v32 = v30;
          if (![v32 UTF8String])
          {
            size_t v36 = 0LL;
            size_t v34 = (char *)a2[23];
LABEL_30:
            unsigned __int16 v35 = 0LL;
            goto LABEL_31;
          }

          size_t v33 = strlen((const char *)[v32 UTF8String]);
          size_t v34 = (char *)a2[23];
          unsigned __int16 v35 = v34;
          size_t v36 = v33 + 1;
          if (v33 == -1LL) {
            goto LABEL_30;
          }
LABEL_31:
          a2[23] = &v34[v36];
          if (a3)
          {
            memcpy(v35, v31, v36);
            *(void *)(v9 + 8LL * v27++) = v35;
          }
        }

        id v26 = [v24 countByEnumeratingWithState:&v43 objects:v47 count:16];
      }

      while (v26);
    }

    if (a3)
    {
      uint64_t v37 = a2[2];
      *(void *)uint64_t v37 = __dst;
      *(void *)(v37 + _Block_object_dispose(va, 8) = v38;
      *(void *)(v37 + 16) = v9;
      *(_WORD *)(v37 + 24) = v39;
      *(_DWORD *)(v37 + 26) = 0;
      *(_WORD *)(v37 + 30) = 0;
    }

    a2[2] += 32LL;

    id v5 = v42;
  }
}

void TranslateGTMTLBufferInfo(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 8);
  *(void *)(a2 + _Block_object_dispose(va, 8) = v6 + 48;
  if (!a3) {
    goto LABEL_13;
  }
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  id v11 = v5;
  id v7 = v5;
  TranslateGTMTLResourceInfo(v7, v6);
  if ((objc_opt_respondsToSelector(v7, "gpuAddress") & 1) != 0) {
    *(void *)(v6 + 24) = [v7 gpuAddress];
  }
  uint64_t v8 = objc_claimAutoreleasedReturnValue([v7 heap]);
  uint64_t v9 = (void *)v8;
  if (v8 && (objc_opt_respondsToSelector(v8, "gpuAddress") & 1) != 0)
  {
    id v10 = [v9 gpuAddress];
LABEL_9:
    *(void *)(v6 + 32) = v10;
    goto LABEL_10;
  }

  if ((objc_opt_respondsToSelector(v7, "parentGPUAddress") & 1) != 0)
  {
    id v10 = [v7 parentGPUAddress];
    goto LABEL_9;
  }

LABEL_10:
  if ((objc_opt_respondsToSelector(v7, "parentGPUSize") & 1) != 0) {
    *(void *)(v6 + 40) = [v7 parentGPUSize];
  }

  id v5 = v11;
LABEL_13:
}

    if (v7) {
      CaptureMTLBuffer_registerBaseBufferForTracing(*((void **)v7 + 1), *((void *)v7 + 6), 0);
    }
    GTTraceContext_pushEncoderWithStream((uint64_t)self->_traceContext, (uint64_t)v28);
    baseObject = self->_baseObject;
    size_t v14 = (void *)objc_claimAutoreleasedReturnValue([v7 baseObject]);
    -[MTLArgumentEncoder setArgumentBuffer:offset:](baseObject, "setArgumentBuffer:offset:", v14, a4);

    size_t v15 = v29;
    *(_DWORD *)(v29 + _Block_object_dispose(va, 8) = -16061;
    unsigned __int8 v16 = v32;
    if (v32 > 0x28uLL)
    {
      id v20 = *(void *)(v28[1] + 24LL);
      size_t v21 = v33++;
      id v17 = GTTraceMemPool_allocateBytes(v20, v30, v21 | 0x1800000000LL) + 16;
      unsigned __int8 v16 = v21;
    }

    else
    {
      id v17 = (char *)(v15 + v32);
      v32 += 24;
    }

    *(_BYTE *)(v15 + 13) = v16;
    size_t v22 = -[CaptureMTLArgumentEncoder traceStream](self, "traceStream");
    if (v22) {
      var0 = v22->var0;
    }
    else {
      var0 = 0LL;
    }
    id v24 = (uint64_t *)[v7 traceStream];
    if (v24) {
      id v25 = *v24;
    }
    else {
      id v25 = 0LL;
    }
    *(void *)id v17 = var0;
    *((void *)v17 + 1) = v25;
    *((void *)v17 + 2) = a4;
    s();
    *(void *)id v26 = v27;
    *(_BYTE *)(v26 + _Block_object_dispose(va, 8) = v31;
    *(_BYTE *)(v29 + 15) |= 8u;
  }

  else
  {
    id v18 = self->_baseObject;
    id v19 = (void *)objc_claimAutoreleasedReturnValue([v6 baseObject]);
    -[MTLArgumentEncoder setArgumentBuffer:offset:](v18, "setArgumentBuffer:offset:", v19, a4);
  }
}

    if (v9) {
      CaptureMTLBuffer_registerBaseBufferForTracing(*((void **)v9 + 1), *((void *)v9 + 6), 0);
    }
    GTTraceContext_pushEncoderWithStream((uint64_t)self->_traceContext, (uint64_t)v30);
    baseObject = self->_baseObject;
    unsigned __int8 v16 = (void *)objc_claimAutoreleasedReturnValue([v9 baseObject]);
    -[MTLArgumentEncoder setArgumentBuffer:startOffset:arrayElement:]( baseObject,  "setArgumentBuffer:startOffset:arrayElement:",  v16,  a4,  a5);

    id v17 = v31;
    *(_DWORD *)(v31 + _Block_object_dispose(va, 8) = -16033;
    id v18 = v34;
    if (v34 > 0x20uLL)
    {
      size_t v22 = *(void *)(v30[1] + 24LL);
      id v23 = v35++;
      id v19 = GTTraceMemPool_allocateBytes(v22, v32, v23 | 0x2000000000LL) + 16;
      id v18 = v23;
    }

    else
    {
      id v19 = (char *)(v17 + v34);
      v34 += 32;
    }

    *(_BYTE *)(v17 + 13) = v18;
    id v24 = -[CaptureMTLArgumentEncoder traceStream](self, "traceStream");
    if (v24) {
      var0 = v24->var0;
    }
    else {
      var0 = 0LL;
    }
    id v26 = (uint64_t *)[v9 traceStream];
    if (v26) {
      int v27 = *v26;
    }
    else {
      int v27 = 0LL;
    }
    *(void *)id v19 = var0;
    *((void *)v19 + 1) = v27;
    *((void *)v19 + 2) = a4;
    *((void *)v19 + 3) = a5;
    s();
    *(void *)uint64_t v28 = v29;
    *(_BYTE *)(v28 + _Block_object_dispose(va, 8) = v33;
    *(_BYTE *)(v31 + 15) |= 8u;
  }

  else
  {
    id v20 = self->_baseObject;
    size_t v21 = (void *)objc_claimAutoreleasedReturnValue([v8 baseObject]);
    -[MTLArgumentEncoder setArgumentBuffer:startOffset:arrayElement:]( v20,  "setArgumentBuffer:startOffset:arrayElement:",  v21,  a4,  a5);
  }
}

  unsigned __int8 v55 = GTMTLDescriptorAllocator_copyDictionary(v4, v7, a3);
  if (a3)
  {
    id v57 = v55;
    uint64_t v58 = v56;
    *(_OWORD *)(v6 + 104) = 0u;
    *(_OWORD *)(v6 + 8_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *(_OWORD *)(v6 + _Block_object_dispose(va, 8) = 0u;
    *(void *)uint64_t v6 = a1;
    *(void *)(v6 + _Block_object_dispose(va, 8) = IOSurfaceGetAllocSize(a1);
    *(_WORD *)(v6 + 92) = IOSurfaceGetWidth(a1);
    *(_WORD *)(v6 + 94) = IOSurfaceGetHeight(a1);
    *(_WORD *)(v6 + 96) = IOSurfaceGetBytesPerElement(a1);
    *(_DWORD *)(v6 + 80) = IOSurfaceGetBytesPerRow(a1);
    *(_WORD *)(v6 + 9_Block_object_dispose(va, 8) = IOSurfaceGetElementWidth(a1);
    *(_WORD *)(v6 + 100) = IOSurfaceGetElementHeight(a1);
    *(_DWORD *)(v6 + 84) = IOSurfaceGetPixelFormat(a1);
    LODWORD(v101[0]) = 2;
    IOSurfaceGetYCbCrMatrix(a1, v101);
    *(_DWORD *)(v6 + 8_Block_object_dispose(va, 8) = v101[0];
    id v59 = IOSurfaceGetPlaneCount(a1);
    *(_BYTE *)(v6 + 102) = v59;
    if (v59)
    {
      id v60 = 0LL;
      id v61 = (_WORD *)(v6 + 28);
      do
      {
        *(v61 - 4) = IOSurfaceGetWidthOfPlane(a1, v60);
        *(v61 - 3) = IOSurfaceGetHeightOfPlane(a1, v60);
        *(v61 - 2) = IOSurfaceGetBytesPerElementOfPlane(a1, v60);
        *((_DWORD *)v61 - 3) = IOSurfaceGetBytesPerRowOfPlane(a1, v60);
        *(v61 - 1) = IOSurfaceGetElementWidthOfPlane(a1, v60);
        char *v61 = IOSurfaceGetElementHeightOfPlane(a1, v60);
        v61 += 8;
        ++v60;
      }

      while (v60 < *(unsigned __int8 *)(v6 + 102));
    }

    *(void *)(v6 + 104) = v57;
    *(void *)(v6 + 112) = v58;
  }
}

  id v25 = 88LL;
  WriteDynamicBufferString(&v24, *(const char **)a1);
  uint64_t v6 = v26;
  id v7 = v25 + 8;
  if (v25 + 8 <= v26)
  {
    *(void *)(v24 + v25) = *(unsigned __int8 *)(a1 + 54);
    uint64_t v6 = v26;
    id v7 = v25 + 8;
  }

  id v25 = v7;
  uint64_t v8 = v7 + 8;
  if (v7 + 8 <= v6)
  {
    *(void *)(v24 + v7) = *(unsigned __int8 *)(a1 + 51);
    uint64_t v6 = v26;
    uint64_t v8 = v25 + 8;
  }

  id v25 = v8;
  uint64_t v9 = v8 + 8;
  if (v8 + 8 <= v6)
  {
    *(void *)(v24 + v_Block_object_dispose(va, 8) = *(unsigned __int8 *)(a1 + 50);
    uint64_t v6 = v26;
    uint64_t v9 = v25 + 8;
  }

  id v25 = v9;
  id v10 = v9 + 8;
  if (v9 + 8 <= v6)
  {
    *(void *)(v24 + v9) = *(unsigned __int8 *)(a1 + 62);
    uint64_t v6 = v26;
    id v10 = v25 + 8;
  }

  id v25 = v10;
  id v11 = v10 + 8;
  if (v10 + 8 <= v6)
  {
    *(void *)(v24 + v10) = *(void *)(a1 + 16);
    uint64_t v6 = v26;
    id v11 = v25 + 8;
  }

  id v25 = v11;
  id v12 = v11 + 8;
  if (v11 + 8 <= v6)
  {
    *(void *)(v24 + v11) = *(unsigned __int8 *)(a1 + 52);
    uint64_t v6 = v26;
    id v12 = v25 + 8;
  }

  id v25 = v12;
  id v13 = v12 + 8;
  if (v12 + 8 <= v6)
  {
    *(void *)(v24 + v12) = *(unsigned __int8 *)(a1 + 60);
    uint64_t v6 = v26;
    id v13 = v25 + 8;
  }

  id v25 = v13;
  size_t v14 = v13 + 8;
  if (v13 + 8 <= v6)
  {
    *(void *)(v24 + v13) = *(unsigned __int8 *)(a1 + 50);
    uint64_t v6 = v26;
    size_t v14 = v25 + 8;
  }

  id v25 = v14;
  size_t v15 = v14 + 8;
  if (v14 + 8 <= v6)
  {
    *(void *)(v24 + v14) = *(unsigned int *)(a1 + 24);
    uint64_t v6 = v26;
    size_t v15 = v25 + 8;
  }

  id v25 = v15;
  unsigned __int8 v16 = v15 + 8;
  if (v15 + 8 <= v6)
  {
    *(void *)(v24 + v15) = *(unsigned int *)(a1 + 28);
    uint64_t v6 = v26;
    unsigned __int8 v16 = v25 + 8;
  }

  id v25 = v16;
  id v17 = v16 + 8;
  if (v16 + 8 <= v6)
  {
    *(void *)(v24 + v16) = *(unsigned int *)(a1 + 32);
    uint64_t v6 = v26;
    id v17 = v25 + 8;
  }

  id v25 = v17;
  id v18 = v17 + 8;
  if (v17 + 8 <= v6)
  {
    *(void *)(v24 + v17) = *(unsigned int *)(a1 + 36);
    uint64_t v6 = v26;
    id v18 = v25 + 8;
  }

  id v25 = v18;
  id v19 = v18 + 8;
  if (v18 + 8 <= v6)
  {
    *(void *)(v24 + v1_Block_object_dispose(va, 8) = *(unsigned __int8 *)(a1 + 53);
    uint64_t v6 = v26;
    id v19 = v25 + 8;
  }

  id v25 = v19;
  uint64_t result = v19 + 8;
  if (v19 + 8 <= v6)
  {
    *(void *)(v24 + v19) = *(unsigned __int16 *)(a1 + 48);
    return v25 + 8;
  }

  return result;
}

  *dest = 0;
  return dest;
}

  id v10 = 12;
  if (abort_fn) {
    ((void (*)(uint64_t))abort_fn)(12LL);
  }
  return v10;
}

void TranslateGTMTLResourceInfo(void *a1, uint64_t a2)
{
  id v3 = a1;
  if ((objc_opt_respondsToSelector(v3, "allocatedSize") & 1) != 0) {
    *(void *)(a2 + _Block_object_dispose(va, 8) = [v3 allocatedSize];
  }
  if ((objc_opt_respondsToSelector(v3, "allocationID") & 1) != 0) {
    *(void *)a2 = [v3 allocationID];
  }
  if ((objc_opt_respondsToSelector(v3, "responsibleProcess") & 1) != 0) {
    *(_DWORD *)(a2 + 16) = [v3 responsibleProcess];
  }
}

uint64_t CanHarvestTextureAsIOSurfaceUsingCPU(void *a1)
{
  id v1 = a1;
  if (![v1 iosurface]
    || ([v1 isDrawable] & 1) != 0
    || ([v1 isFramebufferOnly] & 1) != 0
    || ((unint64_t)[v1 pixelFormat] & 0xFFFFFFFFFFFFFFFELL) == 0x226)
  {
    uint64_t v2 = 0LL;
  }

  else
  {
    uint64_t v2 = [v1 isShareable] ^ 1;
  }

  return v2;
}

void TranslateGTMTLTextureMipmapLevels(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  buffer = (__IOSurface *)[v5 iosurface];
  unint64_t v6 = (unint64_t)[v5 width];
  unint64_t v7 = (unint64_t)[v5 height];
  unint64_t v8 = (unint64_t)[v5 depth];
  uint64_t v9 = (uint32_t *)[v5 pixelFormat];
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v5 device]);
  id v32 = v9;
  GTMTLPixelFormatGetInfoForDevice((uint64_t)v9, (uint64_t)v34);

  id v30 = [v5 sampleCount];
  int v33 = CanHarvestTextureAsIOSurfaceUsingCPU(v5);
  if (a3)
  {
    id v11 = (int *)(a2 + 8);
    unint64_t v12 = (unint64_t)(v9 - 40);
    unint64_t v13 = (unint64_t)v9 - 550;
    do
    {
      if (v33)
      {
        size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(buffer, (size_t)[v5 iosurfacePlane]);
        size_t v15 = IOSurfaceGetHeightOfPlane(buffer, (size_t)[v5 iosurfacePlane]) * BytesPerRowOfPlane;
        else {
          unint64_t v16 = v15;
        }
        unint64_t v17 = v6;
        LODWORD(v1_Block_object_dispose(va, 8) = v7;
      }

      else
      {
        unint64_t v17 = v6;
        unint64_t v18 = v7;
        uint64_t v19 = 5LL * (void)v30;
        if (v32 != &stru_B8.reserved3)
        {
          if ((v34[9] & 4) != 0)
          {
            unint64_t v17 = (v6 + v36 - 1) / v36;
            uint64_t v19 = v35 * (void)v30;
            unint64_t v18 = (v7 + v37 - 1) / v37;
          }

          else
          {
            uint64_t v19 = v35 * (void)v30;
            unint64_t v17 = v6;
            unint64_t v18 = v7;
          }
        }

        size_t BytesPerRowOfPlane = v19 * v17;
        size_t v15 = v19 * v17 * v18;
        unint64_t v16 = v15 * v8;
      }

      int v20 = v18 * v17;
      int v21 = 5 * v20;
      int v22 = 4 * v20;
      BOOL v23 = BytesPerRowOfPlane >= 4 * v17;
      if (BytesPerRowOfPlane <= 4 * v17) {
        int v24 = 4 * v17;
      }
      else {
        int v24 = BytesPerRowOfPlane;
      }
      if (v23) {
        int v22 = v15;
      }
      if (v13 < 2)
      {
        int v25 = v22;
      }

      else
      {
        int v24 = BytesPerRowOfPlane;
        int v25 = v15;
      }

      if (v13 >= 2) {
        int v21 = v16;
      }
      if (v16 <= 0x10) {
        int v26 = 16;
      }
      else {
        int v26 = v16;
      }
      if (v16 <= 0x20) {
        LODWORD(v16) = 32;
      }
      if (((1LL << v12) & 0x33) == 0) {
        int v26 = v16;
      }
      if (v12 <= 7) {
        int v27 = 0;
      }
      else {
        int v27 = v24;
      }
      if (v12 <= 7) {
        int v28 = 0;
      }
      else {
        int v28 = v25;
      }
      if (v12 <= 7) {
        int v29 = v26;
      }
      else {
        int v29 = v21;
      }
      *(v11 - 2) = v27;
      *(v11 - 1) = v28;
      *id v11 = v29;
      v11 += 4;
      if (v6 <= 1) {
        unint64_t v6 = 1LL;
      }
      else {
        v6 >>= 1;
      }
      if (v7 <= 1) {
        unint64_t v7 = 1LL;
      }
      else {
        v7 >>= 1;
      }
      if (v8 <= 1) {
        unint64_t v8 = 1LL;
      }
      else {
        v8 >>= 1;
      }
      --a3;
    }

    while (a3);
  }
}

void TranslateGTMTLTextureInfo(void *a1, uint64_t a2, int a3)
{
  id v12 = a1;
  uint64_t v5 = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v5 + 88;
  uint64_t v6 = (uint64_t)[v12 mipmapLevelCount];
  unint64_t v7 = v12;
  if (a3)
  {
    *(void *)(v5 + 80) = 0LL;
    *(_OWORD *)(v5 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)uint64_t v5 = 0u;
    id v8 = v12;
    TranslateGTMTLResourceInfo(v8, v5);
    if ((objc_opt_respondsToSelector(v8, "uniqueIdentifier") & 1) != 0) {
      *(void *)(v5 + 40) = [v8 uniqueIdentifier];
    }
    if ((objc_opt_respondsToSelector(v8, "resourceIndex") & 1) != 0) {
      *(void *)(v5 + 56) = [v8 resourceIndex];
    }
    if ((objc_opt_respondsToSelector(v8, "gpuAddress") & 1) != 0) {
      *(void *)(v5 + 64) = [v8 gpuAddress];
    }
    uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 heap]);
    id v10 = (void *)v9;
    if (v9)
    {
      if ((objc_opt_respondsToSelector(v9, "gpuAddress") & 1) != 0)
      {
        *(void *)(v5 + 72) = [v10 gpuAddress];
      }
    }

    if ((objc_opt_respondsToSelector(v8, "compressionFeedback") & 1) != 0) {
      *(_WORD *)(v5 + 80) = (unsigned __int16)[v8 compressionFeedback];
    }
    TranslateGTMTLTextureMipmapLevels(v8, *(void *)(a2 + 104), v6);
    if (v6) {
      uint64_t v11 = *(void *)(a2 + 104);
    }
    else {
      uint64_t v11 = 0LL;
    }
    *(void *)(v5 + 24) = v11;
    *(_BYTE *)(v5 + 32) = v6;
    if ((objc_opt_respondsToSelector(v8, "gpuResourceID") & 1) != 0) {
      *(void *)(v5 + 4_Block_object_dispose(va, 8) = [v8 gpuResourceID];
    }

    unint64_t v7 = v12;
  }

  *(void *)(a2 + 104) += 16 * v6;
}

void TranslateGTMTLIndirectCommandBufferInfo(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v6 + 56;
  if (a3)
  {
    *(void *)(v6 + 4_Block_object_dispose(va, 8) = 0LL;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    id v8 = v5;
    id v7 = v5;
    TranslateGTMTLResourceInfo(v7, v6);
    if ((objc_opt_respondsToSelector(v7, "uniqueIdentifier") & 1) != 0) {
      *(void *)(v6 + 24) = [v7 uniqueIdentifier];
    }
    if ((objc_opt_respondsToSelector(v7, "gpuAddress") & 1) != 0) {
      *(void *)(v6 + 40) = [v7 gpuAddress];
    }
    if ((objc_opt_respondsToSelector(v7, "resourceIndex") & 1) != 0) {
      *(void *)(v6 + 32) = [v7 resourceIndex];
    }
    if ((objc_opt_respondsToSelector(v7, "gpuResourceID") & 1) != 0) {
      *(void *)(v6 + 4_Block_object_dispose(va, 8) = [v7 gpuResourceID];
    }

    id v5 = v8;
  }
}

void TranslateGTMTLVisibleFunctionTableInfo(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v6 + 56;
  if (a3)
  {
    *(void *)(v6 + 4_Block_object_dispose(va, 8) = 0LL;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    id v8 = v5;
    id v7 = v5;
    TranslateGTMTLResourceInfo(v7, v6);
    if ((objc_opt_respondsToSelector(v7, "uniqueIdentifier") & 1) != 0) {
      *(void *)(v6 + 24) = [v7 uniqueIdentifier];
    }
    if ((objc_opt_respondsToSelector(v7, "resourceIndex") & 1) != 0) {
      *(void *)(v6 + 32) = [v7 resourceIndex];
    }
    if ((objc_opt_respondsToSelector(v7, "gpuResourceID") & 1) != 0) {
      *(void *)(v6 + 40) = [v7 gpuResourceID];
    }
    if ((objc_opt_respondsToSelector(v7, "gpuAddress") & 1) != 0) {
      *(void *)(v6 + 4_Block_object_dispose(va, 8) = [v7 gpuAddress];
    }

    id v5 = v8;
  }
}

void TranslateGTMTLIntersectionFunctionTableInfo(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v6 + 48;
  if (a3)
  {
    *(_OWORD *)(v6 + 16) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    id v8 = v5;
    id v7 = v5;
    TranslateGTMTLResourceInfo(v7, v6);
    if ((objc_opt_respondsToSelector(v7, "uniqueIdentifier") & 1) != 0) {
      *(void *)(v6 + 24) = [v7 uniqueIdentifier];
    }
    if ((objc_opt_respondsToSelector(v7, "resourceIndex") & 1) != 0) {
      *(void *)(v6 + 32) = [v7 resourceIndex];
    }
    if ((objc_opt_respondsToSelector(v7, "gpuResourceID") & 1) != 0) {
      *(void *)(v6 + 40) = [v7 gpuResourceID];
    }

    id v5 = v8;
  }
}

void TranslateGTMTLAccelerationStructureInfo(void *a1, uint64_t *a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *a2;
  *a2 += 112LL;
  if (!a3) {
    goto LABEL_29;
  }
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  *(_OWORD *)(v6 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  id v12 = v5;
  id v7 = v5;
  TranslateGTMTLResourceInfo(v7, v6);
  if ((objc_opt_respondsToSelector(v7, "accelerationStructureUniqueIdentifier") & 1) != 0)
  {
    *(void *)(v6 + 24) = [v7 accelerationStructureUniqueIdentifier];
  }

  else if ((objc_opt_respondsToSelector(v7, "bufferOffset") & 1) != 0)
  {
    *(void *)(v6 + 4_Block_object_dispose(va, 8) = [v7 bufferOffset];
  }

  if ((objc_opt_respondsToSelector(v7, "size") & 1) != 0) {
    *(void *)(v6 + 32) = [v7 size];
  }
  if ((objc_opt_respondsToSelector(v7, "resourceIndex") & 1) != 0) {
    *(void *)(v6 + 40) = [v7 resourceIndex];
  }
  if ((objc_opt_respondsToSelector(v7, "resourceOptions") & 1) != 0) {
    *(_WORD *)(v6 + 64) = (unsigned __int16)[v7 resourceOptions];
  }
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 buffer]);
  uint64_t v9 = objc_claimAutoreleasedReturnValue([v7 heap]);
  id v10 = (void *)v9;
  if (v9 && (objc_opt_respondsToSelector(v9, "gpuAddress") & 1) != 0)
  {
    id v11 = [v10 gpuAddress];
LABEL_17:
    *(void *)(v6 + 80) = v11;
    goto LABEL_18;
  }

  if ((objc_opt_respondsToSelector(v8, "parentGPUAddress") & 1) != 0)
  {
    id v11 = [v8 parentGPUAddress];
    goto LABEL_17;
  }

LABEL_18:
  if ((objc_opt_respondsToSelector(v8, "gpuAddress") & 1) != 0) {
    *(void *)(v6 + 72) = [v8 gpuAddress];
  }
  if ((objc_opt_respondsToSelector(v8, "parentGPUSize") & 1) != 0) {
    *(void *)(v6 + 8_Block_object_dispose(va, 8) = [v8 parentGPUSize];
  }
  if ((objc_opt_respondsToSelector(v8, "length") & 1) != 0) {
    *(void *)(v6 + 96) = [v8 length];
  }
  if ((objc_opt_respondsToSelector(v8, "resourceOptions") & 1) != 0) {
    *(_WORD *)(v6 + 104) = (unsigned __int16)[v8 resourceOptions];
  }
  if ((objc_opt_respondsToSelector(v7, "gpuResourceID") & 1) != 0) {
    *(void *)(v6 + 56) = [v7 gpuResourceID];
  }

  id v5 = v12;
LABEL_29:
}

      id v3 = (unsigned int *)((char *)v3 + *v3);
    }

    while (v3 != v5);
  }

void TranslateGTMTLSamplerStateInfo(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void **)(a2 + 64);
  *(void *)(a2 + 64) = v6 + 3;
  if (a3)
  {
    void *v6 = 0LL;
    v6[1] = 0LL;
    v6[2] = 0LL;
    id v8 = v5;
    id v7 = v5;
    if ((objc_opt_respondsToSelector(v7, "uniqueIdentifier") & 1) != 0) {
      void *v6 = [v7 uniqueIdentifier];
    }
    if ((objc_opt_respondsToSelector(v7, "resourceIndex") & 1) != 0) {
      v6[2] = [v7 resourceIndex];
    }
    if ((objc_opt_respondsToSelector(v7, "gpuResourceID") & 1) != 0) {
      v6[1] = [v7 gpuResourceID];
    }

    id v5 = v8;
  }
}

void TranslateGTMTLLibraryInfo(void *a1, uint64_t a2, int a3, const char *a4)
{
  id v28 = a1;
  id v7 = *(char ***)(a2 + 48);
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = v7 + 3;
  if ((objc_opt_respondsToSelector(v28, "libraryIdentifier") & 1) != 0)
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v28 libraryIdentifier]);
    id v9 = objc_claimAutoreleasedReturnValue([v8 UUIDString]);
    id v10 = [v9 UTF8String];
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v28 libraryIdentifier]);
    id v12 = objc_claimAutoreleasedReturnValue([v11 UUIDString]);
    if ([v12 UTF8String])
    {
      __src = v10;
      int v27 = v8;
      unint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v28 libraryIdentifier]);
      int v14 = a3;
      id v15 = objc_claimAutoreleasedReturnValue([v13 UUIDString]);
      size_t v16 = strlen((const char *)[v15 UTF8String]);
      size_t v17 = v16 + 1;
      if (v16 == -1LL) {
        unint64_t v18 = 0LL;
      }
      else {
        unint64_t v18 = *(void **)(a2 + 184);
      }
      *(void *)(a2 + 184) += v17;
      if (v14) {
        memcpy(v18, __src, v17);
      }

      a3 = v14;
      id v8 = v27;
    }

    else
    {
      unint64_t v18 = 0LL;
    }

    if (!a4) {
      goto LABEL_14;
    }
  }

  else
  {
    unint64_t v18 = 0LL;
    if (!a4)
    {
LABEL_14:
      size_t v24 = 0LL;
      int v25 = *(char **)(a2 + 184);
      int v21 = (void *)(a2 + 184);
      int v20 = v25;
      goto LABEL_15;
    }
  }

  size_t v19 = strlen(a4);
  int v22 = *(char **)(a2 + 184);
  int v21 = (void *)(a2 + 184);
  int v20 = v22;
  BOOL v23 = v22;
  size_t v24 = v19 + 1;
  if (v19 == -1LL) {
LABEL_15:
  }
    BOOL v23 = 0LL;
  void *v21 = &v20[v24];
  if (a3)
  {
    memcpy(v23, a4, v24);
    v7[1] = 0LL;
    v7[2] = 0LL;
    *id v7 = 0LL;
    if ((objc_opt_respondsToSelector(v28, "type") & 1) != 0) {
      *((_BYTE *)v7 + 16) = [v28 type];
    }
    *id v7 = v23;
    v7[1] = (char *)v18;
  }
}

void TranslateGTMTLPipelineLibraryInfo(void *a1, void *a2, int a3, const char *a4)
{
  id v6 = a1;
  __int16 v70 = 0;
  int v69 = 0;
  if (!a4)
  {
    obuint64_t j = 0LL;
    size_t v11 = 0LL;
    id v8 = a2 + 23;
    id v9 = (char *)a2[23];
    goto LABEL_5;
  }

  size_t v7 = strlen(a4);
  id v8 = a2 + 23;
  id v9 = (char *)a2[23];
  obuint64_t j = a4;
  id v10 = v9;
  size_t v11 = v7 + 1;
  if (v7 == -1LL) {
LABEL_5:
  }
    id v10 = 0LL;
  void *v8 = &v9[v11];
  if (a3) {
    memcpy(v10, a4, v11);
  }
  size_t v50 = v10;
  id v59 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  unsigned int v51 = v6;
  if ((objc_opt_respondsToSelector(v6, "metallibPaths") & 1) != 0)
  {
    id v12 = (void *)objc_claimAutoreleasedReturnValue([v6 metallibPaths]);
    __int128 v65 = 0u;
    __int128 v66 = 0u;
    __int128 v67 = 0u;
    __int128 v68 = 0u;
    id v13 = [v12 countByEnumeratingWithState:&v65 objects:v76 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v66;
      uint64_t v57 = *(void *)v66;
      do
      {
        for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v66 != v15) {
            objc_enumerationMutation(v12);
          }
          size_t v17 = *(void **)(*((void *)&v65 + 1) + 8LL * (void)i);
          unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a4));
          size_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 stringByDeletingLastPathComponent]);

          int v20 = (void *)objc_claimAutoreleasedReturnValue([v17 stringByDeletingLastPathComponent]);
          if ([v19 isEqualToString:v20])
          {
            -[NSMutableArray addObject:](v59, "addObject:", v17);
          }

          else if (s_logUsingOsLog)
          {
            id v21 = gt_default_log();
            int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            {
              id v26 = [v17 UTF8String];
              *(_DWORD *)buf = 136315394;
              unsigned __int8 v73 = obj;
              __int16 v74 = 2080;
              id v75 = v26;
              _os_log_error_impl( &dword_0,  v22,  OS_LOG_TYPE_ERROR,  "warning: .pipelinelib %s and .metallib %s must be in the same directory",  buf,  0x16u);
            }
          }

          else
          {
            BOOL v23 = __stderrp;
            size_t v24 = v12;
            id v25 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString, "stringWithFormat:", @"warning: .pipelinelib %s and .metallib %s must be in the same directory", a4, [v17 UTF8String]));
            fprintf(v23, "%s\n", (const char *)[v25 UTF8String]);

            id v12 = v24;
            uint64_t v15 = v57;
          }
        }

        id v14 = [v12 countByEnumeratingWithState:&v65 objects:v76 count:16];
      }

      while (v14);
    }
  }

  unsigned __int16 v27 = (unsigned __int16)-[NSMutableArray count](v59, "count");
  uint64_t v28 = a2[22];
  unsigned __int16 v49 = v27;
  a2[22] = v28 + 8LL * v27 + 8LL * v27;
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  if (v27) {
    uint64_t v29 = v28;
  }
  else {
    uint64_t v29 = 0LL;
  }
  if (v27) {
    uint64_t v30 = v28 + 8LL * v27;
  }
  else {
    uint64_t v30 = 0LL;
  }
  uint64_t v52 = v29;
  uint64_t v53 = v30;
  __int128 v63 = 0uLL;
  __int128 v64 = 0uLL;
  id obja = v59;
  int v31 = a3;
  id v60 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v61,  v71,  16LL);
  if (v60)
  {
    int v32 = 0;
    uint64_t v58 = *(void *)v62;
    do
    {
      for (uint64_t j = 0LL; j != v60; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v62 != v58) {
          objc_enumerationMutation(obja);
        }
        id v34 = *(id *)(*((void *)&v61 + 1) + 8LL * (void)j);
        id v35 = [v34 UTF8String];
        id v36 = v34;
        if (![v36 UTF8String])
        {
          size_t v40 = 0LL;
          __int16 v38 = (char *)a2[23];
LABEL_39:
          unsigned __int16 v39 = 0LL;
          goto LABEL_40;
        }

        size_t v37 = strlen((const char *)[v36 UTF8String]);
        __int16 v38 = (char *)a2[23];
        unsigned __int16 v39 = v38;
        size_t v40 = v37 + 1;
        if (v37 == -1LL) {
          goto LABEL_39;
        }
LABEL_40:
        a2[23] = &v38[v40];
        if (v31) {
          memcpy(v39, v35, v40);
        }
        id v41 = objc_claimAutoreleasedReturnValue([v36 lastPathComponent]);
        id v42 = [v41 UTF8String];
        id v43 = objc_claimAutoreleasedReturnValue([v36 lastPathComponent]);
        if ([v43 UTF8String])
        {
          id v44 = objc_claimAutoreleasedReturnValue([v36 lastPathComponent]);
          size_t v45 = strlen((const char *)[v44 UTF8String]);
          size_t v46 = v45 + 1;
          if (v45 == -1LL) {
            id v47 = 0LL;
          }
          else {
            id v47 = (void *)a2[23];
          }
          a2[23] += v46;
          if (v31) {
            memcpy(v47, v42, v46);
          }

          int v31 = a3;
        }

        else
        {
          id v47 = 0LL;
        }

        if (v31)
        {
          *(void *)(v52 + 8LL * v32) = v39;
          *(void *)(v53 + 8LL * v32++) = v47;
        }
      }

      id v60 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v61,  v71,  16LL);
    }

    while (v60);
  }

  if (v31)
  {
    uint64_t v48 = a2[7];
    *(void *)uint64_t v48 = v50;
    *(void *)(v48 + _Block_object_dispose(va, 8) = v52;
    *(void *)(v48 + 16) = v53;
    *(_WORD *)(v48 + 24) = v49;
    *(_DWORD *)(v48 + 26) = v69;
    *(_WORD *)(v48 + 30) = v70;
  }

  a2[7] += 32LL;
}

id DEVICEOBJECT(id a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  while ((objc_opt_respondsToSelector(a1, "baseObject") & 1) != 0)
    a1 = [a1 performSelector:"baseObject"];
  objc_autoreleasePoolPop(v2);
  return a1;
}

void CaptureInit()
{
  v0 = objc_autoreleasePoolPush();
  if (CaptureInterposerInit_onceToken != -1) {
    dispatch_once(&CaptureInterposerInit_onceToken, &__block_literal_global_61);
  }
  objc_autoreleasePoolPop(v0);
}

void CaptureExit()
{
  boundaryTrackerInstance = 0LL;
  GTTraceContext_closeStream(g_ctx, *(void **)(g_ctx + 112));
}

void CaptureInterposerInit()
{
  if (CaptureInterposerInit_onceToken != -1) {
    dispatch_once(&CaptureInterposerInit_onceToken, &__block_literal_global_61);
  }
}

void *GTHarvesterInitMetadata(void *a1, __int16 a2, size_t a3)
{
  int v3 = a3;
  bzero(a1, a3);
  *a1 = 0x63617074757265LL;
  *((_WORD *)a1 + 4) = 2;
  *((_WORD *)a1 + 5) = a2;
  *((_DWORD *)a1 + 3) = v3;
  return a1;
}

uint64_t GTHarvesterGetMetadataSize(uint64_t result)
{
  if (result)
  {
    if (*(_WORD *)(result + 8) == 1) {
      return *(int *)(result + 12) + 16LL;
    }
    else {
      return *(int *)(result + 12);
    }
  }

  return result;
}

void *GTHarvesterGetMetadata(void *a1, unint64_t a2)
{
  uint64_t result = 0LL;
  if (a1 && a2 >= 0x10)
  {
    if (*a1 == 0x63617074757265LL) {
      return a1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

unint64_t GTHarvesterGetDataSize(uint64_t a1, unint64_t a2)
{
  if (a1 && a2 >= 0x10 && *(void *)a1 == 0x63617074757265LL)
  {
    uint64_t v2 = *(int *)(a1 + 12);
    if (*(_WORD *)(a1 + 8) == 1) {
      v2 += 16LL;
    }
    a2 -= v2;
  }

  return a2;
}

uint64_t GTHarvesterGetData(uint64_t result, unint64_t a2)
{
  if (result && a2 >= 0x10 && *(void *)result == 0x63617074757265LL)
  {
    uint64_t v2 = *(int *)(result + 12);
    if (*(_WORD *)(result + 8) == 1) {
      v2 += 16LL;
    }
    result += v2;
  }

  return result;
}

unint64_t GTHarvesterGetTextureMetadataRequiredSize(uint64_t a1)
{
  return (48 * a1 + 279) & 0xFFFFFFFFFFFFFF00LL;
}

uint64_t GTHarvesterGetTexturePlaneCount(uint64_t result)
{
  if (result)
  {
    if (*(_WORD *)(result + 10) == 1) {
      return *(void *)(result + 16);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t GTHarvesterGetTexturePlane(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (*(_WORD *)(result + 10) == 1)
    {
      if (*(void *)(result + 16) >= a2) {
        result += 48 * a2 + 24;
      }
      else {
        return 0LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

__n128 GTHarvesterAddTexturePlane(uint64_t a1, __int128 *a2)
{
  uint64_t v2 = a1 + 48LL * *(void *)(a1 + 16);
  __int128 v4 = *a2;
  __n128 result = (__n128)a2[1];
  *(_OWORD *)(v2 + 56) = a2[2];
  *(_OWORD *)(v2 + 24) = v4;
  *(__n128 *)(v2 + 40) = result;
  ++*(void *)(a1 + 16);
  return result;
}

void GTTraceStore_buildDebugContext(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  if (a3)
  {
    int v3 = a2;
    id v5 = (unsigned int *)((char *)a2 + a3);
    id v6 = (uint64_t *)(a1 + 8);
    do
    {
      int v7 = *((unsigned __int8 *)v3 + 8);
      id v8 = (void *)(a1 + 24LL * *((unsigned __int8 *)v3 + 8));
      uint64_t v9 = v8[5];
      ++v8[4];
      uint64_t v10 = atomic_load(v3 + 1);
      uint64_t v11 = v8[6];
      v8[5] = v9 + v10;
      v8[6] = v11 + *v3;
      id v12 = (uint64_t *)a1;
      if (v7 == 1) {
        goto LABEL_6;
      }
      if (v7 == 3)
      {
        size_t v17 = *(apr_hash_t **)(a1 + 24);
        uint64_t v18 = atomic_load(v3 + 1);
        if ((_DWORD)v18 != 64)
        {
          size_t v19 = v3 + 16;
          int v20 = (unsigned int *)((char *)v3 + v18);
          do
          {
            apr_hash_set(v17, v19, 8LL, v19 + 2);
            size_t v19 = (unsigned int *)((char *)v19 + ((8LL * *((void *)v19 + 1) + 23) & 0xFFFFFFFF8LL));
          }

          while (v19 != v20);
        }

        goto LABEL_18;
      }

      id v12 = v6;
      if (v7 == 2)
      {
LABEL_6:
        id v13 = (apr_hash_t *)*v12;
        uint64_t v14 = *find_entry(*v12, (_BYTE *)v3 + 16, 8uLL, 0LL);
        if (!v14) {
          goto LABEL_14;
        }
        if (!i) {
LABEL_14:
        }
          apr_hash_set(v13, v3 + 4, 8LL, v3);
      }

unint64_t GTTraceStoreDebugDescription(const char *a1, int *a2)
{
  if (s_logUsingOsLog)
  {
    __int128 v4 = (os_log_s *)gt_tagged_log(1uLL);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)v193 = a1;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_INFO, "Trace store at %s:", buf, 0xCu);
    }
  }

  else
  {
    fprintf(__stdoutp, "Trace store at %s:\n", a1);
  }

  apr_pool_create_ex(&newpool, 0LL, 0LL, 0LL);
  __int128 v178 = 0u;
  __int128 v177 = 0u;
  __int128 v176 = 0u;
  __int128 v175 = 0u;
  __int128 v174 = 0u;
  __int128 v173 = 0u;
  id v6 = newpool;
  int v7 = apr_hash_make(newpool);
  BOOL v169 = v7;
  BOOL v170 = apr_hash_make(v6);
  ht = apr_hash_make(v6);
  v172 = apr_hash_make(v6);
  setlocale(0, "");
  uint64_t v160 = (pthread_mutex_t *)(a2 + 66);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 66));
  if (*a2 >= 1)
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    do
    {
      GTTraceStore_buildDebugContext( (uint64_t)&v169,  *(unsigned int **)(*((void *)a2 + 1) + v8),  *(void *)(*((void *)a2 + 1) + v8 + 8));
      ++v9;
      v8 += 16LL;
    }

    while (v9 < *a2);
    int v7 = v169;
  }

  *((void *)v7 + 2) = v7;
  *((void *)v7 + 3) = 0LL;
  huint64_t i = (apr_hash_t *)((char *)v7 + 24);
  int v165 = (apr_hash_t *)((char *)v7 + 16);
  *((void *)v7 + 4) = 0LL;
  *((_DWORD *)v7 + 10) = 0;
  uint64_t v10 = apr_hash_next((apr_hash_t *)((char *)v7 + 16));
  if (v10)
  {
    uint64_t v11 = v10;
    id v12 = ht;
    do
    {
      for (uint64_t i = *(void *)(*((void *)v11 + 1) + 32LL); i; uint64_t i = *(void *)(i + 40))
      {
        unsigned int v14 = atomic_load((unsigned int *)(i + 4));
        if (v14 >= 0x80)
        {
          uint64_t v15 = (char *)(i + 64);
          uint64_t v16 = (int)((v14 >> 6) - 1);
          do
          {
            apr_hash_set(v12, v15, 8LL, v15);
            v15 += 64;
            --v16;
          }

          while (v16);
        }
      }

      uint64_t v11 = apr_hash_next(v11);
    }

    while (v11);
  }

  if (s_logUsingOsLog)
  {
    size_t v17 = (os_log_s *)gt_tagged_log(1uLL);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_0, v17, OS_LOG_TYPE_INFO, "[SUMMARY]", buf, 2u);
    }
  }

  else
  {
    fwrite("[SUMMARY]\n", 0xAuLL, 1uLL, __stdoutp);
  }

  int v168 = v7;
  int64x2_t v18 = 0uLL;
  uint64_t v19 = 32LL;
  int64x2_t v20 = 0uLL;
  int64x2_t v21 = 0uLL;
  do
  {
    int v22 = (const double *)((char *)&v169 + v19);
    v19 += 48LL;
    float64x2x3_t v198 = vld3q_f64(v22);
    int64x2_t v18 = vaddq_s64((int64x2_t)v198.val[0], v18);
    int64x2_t v20 = vaddq_s64((int64x2_t)v198.val[1], v20);
    int64x2_t v21 = vaddq_s64((int64x2_t)v198.val[2], v21);
  }

  while (v19 != 128);
  int64x2_t v163 = v18;
  uint64_t v23 = 0LL;
  unint64_t v161 = vaddvq_s64(v20);
  unint64_t v162 = vaddvq_s64(v21);
  double v24 = (double)v162;
  id v25 = (unint64_t *)&v174;
  do
  {
    if (s_logUsingOsLog)
    {
      id v26 = (os_log_s *)gt_tagged_log(1uLL);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
      {
        uint64_t v28 = *(v25 - 2);
        unint64_t v27 = *(v25 - 1);
        unint64_t v29 = *v25;
        double v30 = (double)*v25 * 100.0;
        int v31 = (&off_20D570)[v23];
        *(_DWORD *)buf = 67110658;
        *(_DWORD *)v193 = v23;
        *(_WORD *)&v193[4] = 2048;
        *(void *)&v193[6] = v27;
        *(_WORD *)&v193[14] = 2048;
        *(void *)&v193[16] = v29;
        *(_WORD *)&v193[24] = 2048;
        *(double *)&v193[26] = (double)v27 * 100.0 / v24;
        *(_WORD *)&v193[34] = 2048;
        *(double *)&v193[36] = v30 / v24;
        *(_WORD *)&v193[44] = 2048;
        *(void *)&v193[46] = v28;
        __int16 v194 = 2080;
        v195 = v31;
        _os_log_impl( &dword_0,  v26,  OS_LOG_TYPE_INFO,  "%d:\t%'zub / %'zub\t|\t%.1f%% / %.1f%%\t|\t(%'zu)\t|\t%s",  buf,  0x44u);
      }
    }

    else
    {
      fprintf( __stdoutp,  "%d:\t%'zub / %'zub\t|\t%.1f%% / %.1f%%\t|\t(%'zu)\t|\t%s\n",  v23,  *(v25 - 1),  *v25,  (double)*(v25 - 1) * 100.0 / v24,  (double)*v25 * 100.0 / v24,  *(v25 - 2),  (&off_20D570)[v23]);
    }

    ++v23;
    v25 += 3;
  }

  while (v23 != 4);
  uint64_t v32 = vaddvq_s64(v163);
  if (s_logUsingOsLog)
  {
    int v33 = (os_log_s *)gt_tagged_log(1uLL);
    id v34 = v168;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134219008;
      *(void *)v193 = v161;
      *(_WORD *)&v193[8] = 2048;
      *(void *)&v193[10] = v162;
      *(_WORD *)&v193[18] = 2048;
      *(double *)&v193[20] = (double)v161 * 100.0 / v24;
      *(_WORD *)&v193[28] = 2048;
      *(double *)&v193[30] = v24 * 100.0 / v24;
      *(_WORD *)&v193[38] = 2048;
      *(void *)&v193[40] = v32;
      _os_log_impl( &dword_0,  v33,  OS_LOG_TYPE_INFO,  "=\t%'zub / %'zub\t|\t%.1f%% / %.1f%%\t|\t(%'zu)\t|\tTOTAL",  buf,  0x34u);
    }
  }

  else
  {
    fprintf( __stdoutp,  "=\t%'zub / %'zub\t|\t%.1f%% / %.1f%%\t|\t(%'zu)\t|\tTOTAL\n",  v161,  v162,  (double)v161 * 100.0 / v24,  v24 * 100.0 / v24,  v32);
    id v34 = v168;
  }

  unint64_t v35 = *((void *)&v175 + 1);
  id v36 = newpool;
  if (s_logUsingOsLog)
  {
    size_t v37 = (os_log_s *)gt_tagged_log(1uLL);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_0, v37, OS_LOG_TYPE_INFO, "[STREAMS BY FENUM]", buf, 2u);
    }
  }

  else
  {
    fwrite("[STREAMS BY FENUM]\n", 0x13uLL, 1uLL, __stdoutp);
  }

  uint64_t v38 = 0LL;
  unsigned int v39 = *((_DWORD *)v34 + 12) / 0x57u;
  do
    v197[v38++] = apr_array_make(v36, v39, 8);
  while (v38 != 87);
  bzero(buf, 0x828uLL);
  *((void *)v34 + 2) = v34;
  *(void *)huint64_t i = 0LL;
  *((void *)hi + 1) = 0LL;
  *((_DWORD *)hi + 4) = 0;
  size_t v40 = apr_hash_next(v165);
  if (v40)
  {
    id v41 = v40;
    do
    {
      uint64_t v42 = *(void *)(*((void *)v41 + 1) + 32LL);
      unsigned int v43 = atomic_load((unsigned int *)(v42 + 4));
      if ((v43 & 0xFFFFFFC0) != 0x40)
      {
        int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v42 + 72));
        *(void *)apr_array_push((apr_array_header_t *)v197[FuncEnumConstructorType]) = v42;
      }

      id v41 = apr_hash_next(v41);
    }

    while (v41);
  }

  for (uint64_t j = 0LL; j != 87; ++j)
  {
    uint64_t v46 = v197[j];
    int v47 = *(_DWORD *)(v46 + 12);
    if (v47 >= 1)
    {
      uint64_t v48 = 0LL;
      unsigned __int16 v49 = &buf[24 * j];
      do
      {
        size_t v50 = *(unsigned int **)(*(void *)(v46 + 24) + 8 * v48);
        if (v50)
        {
          do
          {
            uint64_t v51 = atomic_load(v50 + 1);
            *((void *)v49 + 1) += v51;
            *((void *)v49 + 2) += *v50;
            size_t v50 = (unsigned int *)*((void *)v50 + 5);
          }

          while (v50);
          int v47 = *(_DWORD *)(v46 + 12);
        }

        ++*(void *)v49;
        ++v48;
      }

      while (v48 < v47);
    }

    uint64_t v52 = &__base[j];
    *((_DWORD *)v52 + 2) = j;
    *(void *)uint64_t v52 = *(void *)&v193[24 * j + 12];
  }

  qsort(__base, 0x57uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))CompareKeyValuePair);
  uint64_t v53 = apr_array_make(v36, 32, 16);
  char v54 = apr_hash_make(v36);
  uint64_t v55 = 0LL;
  double v56 = (double)v35;
  do
  {
    int v57 = DWORD2(__base[v55]);
    uint64_t v58 = &buf[24 * v57];
    uint64_t v166 = v55;
    if (s_logUsingOsLog)
    {
      id v59 = (os_log_s *)gt_tagged_log(1uLL);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_INFO))
      {
        id v60 = "Unknown";
        __int128 v61 = &buf[24 * v57];
        unint64_t v63 = *((void *)v61 + 1);
        double v62 = *((double *)v61 + 2);
        uint64_t v64 = *(void *)v58;
        *(_DWORD *)uint64_t v180 = 67110658;
        int v181 = v57;
        __int16 v182 = 2048;
        unint64_t v183 = v63;
        __int16 v184 = 2048;
        double v185 = v62;
        __int16 v186 = 2048;
        *(double *)uint64_t v187 = (double)v63 * 100.0 / v56;
        *(_WORD *)&v187[8] = 2048;
        *(double *)&v187[10] = (double)*(unint64_t *)&v62 * 100.0 / v56;
        __int16 v188 = 2048;
        uint64_t v189 = v64;
        __int16 v190 = 2080;
        v191 = v60;
        _os_log_impl( &dword_0,  v59,  OS_LOG_TYPE_INFO,  "%d:\t%'zub / %'zub\t|\t%.1f%% / %.1f%%\t|\t(%'zu)\t|\t%s",  v180,  0x44u);
      }
    }

    else
    {
      __int128 v65 = "Unknown";
      fprintf( __stdoutp,  "%d:\t%'zub / %'zub\t|\t%.1f%% / %.1f%%\t|\t(%'zu)\t|\t%s\n",  v57,  *(void *)&v193[24 * v57 + 4],  *(void *)&v193[24 * v57 + 12],  (double)*(unint64_t *)&v193[24 * v57 + 4] * 100.0 / v56,  (double)*(unint64_t *)&v193[24 * v57 + 12] * 100.0 / v56,  *(void *)v58,  v65);
    }

    apr_hash_clear(v54);
    uint64_t v66 = v197[v57];
    int v67 = *(_DWORD *)(v66 + 12);
    if (v67 >= 1)
    {
      for (uint64_t k = 0LL; k < v67; ++k)
      {
        uint64_t v69 = *(void *)(*(void *)(v66 + 24) + 8 * k);
        if (v69)
        {
          __int16 v70 = *(apr_pool_t **)v54;
          do
          {
            unsigned int v71 = atomic_load((unsigned int *)(v69 + 4));
            if (v71 >= 0x80)
            {
              uint64_t v72 = (int)((v71 >> 6) - 1);
              unsigned __int8 v73 = (_BYTE *)(v69 + 72);
              do
              {
                uint64_t v74 = *find_entry((uint64_t)v54, v73, 4uLL, 0LL);
                if (!v74 || (id v75 = *(void **)(v74 + 32)) == 0LL)
                {
                  unsigned __int8 v76 = apr_palloc(v70, 0x10uLL);
                  id v75 = v76;
                  if (v76)
                  {
                    *unsigned __int8 v76 = 0LL;
                    v76[1] = 0LL;
                  }

                  *((_DWORD *)v76 + 2) = *(_DWORD *)v73;
                  apr_hash_set(v54, v76 + 1, 4LL, v76);
                }

                *v75 += 64LL;
                ++*((_DWORD *)v75 + 3);
                v73 += 64;
                --v72;
              }

              while (v72);
            }

            uint64_t v69 = *(void *)(v69 + 40);
          }

          while (v69);
          int v67 = *(_DWORD *)(v66 + 12);
        }
      }
    }

    v53->int nelts = 0;
    *((void *)v54 + 2) = v54;
    *((void *)v54 + 3) = 0LL;
    *((void *)v54 + 4) = 0LL;
    *((_DWORD *)v54 + 10) = 0;
    for (m = (apr_hash_t *)((char *)v54 + 16); ; m = v78)
    {
      unsigned __int16 v78 = apr_hash_next(m);
      if (!v78) {
        break;
      }
      *(_OWORD *)apr_array_push(v53) = *(_OWORD *)*(void *)(*((void *)v78 + 1) + 32LL);
    }

    qsort(v53->elts, v53->nelts, v53->elt_size, (int (__cdecl *)(const void *, const void *))CompareKeyValuePair);
    if (v53->nelts >= 1)
    {
      uint64_t v79 = 0LL;
      uint64_t v80 = 0LL;
      do
      {
        id v81 = &v53->elts[v79];
        unint64_t v82 = *(void *)v81;
        int v84 = *((_DWORD *)v81 + 2);
        int v83 = *((_DWORD *)v81 + 3);
        if (s_logUsingOsLog)
        {
          uint64_t v85 = (os_log_s *)gt_tagged_log(1uLL);
          if (os_log_type_enabled(v85, OS_LOG_TYPE_INFO))
          {
            FuncEnumAsString = GetFuncEnumAsString(v84);
            *(_DWORD *)uint64_t v180 = 67110146;
            int v181 = v84;
            __int16 v182 = 2048;
            unint64_t v183 = v82;
            __int16 v184 = 2048;
            double v185 = (double)v82 * 100.0 / v56;
            __int16 v186 = 1024;
            *(_DWORD *)uint64_t v187 = v83;
            *(_WORD *)&v187[4] = 2080;
            *(void *)&v187[6] = FuncEnumAsString;
            _os_log_impl(&dword_0, v85, OS_LOG_TYPE_INFO, "*\t0x%x:\t%'zub\t|\t%.1f%%\t|\t(%'u)\t|\t%s", v180, 0x2Cu);
          }
        }

        else
        {
          uint64_t v87 = __stdoutp;
          unsigned int v88 = GetFuncEnumAsString(v84);
          fprintf(v87, "*\t0x%x:\t%'zub\t|\t%.1f%%\t|\t(%'u)\t|\t%s\n", v84, v82, (double)v82 * 100.0 / v56, v83, v88);
        }

        ++v80;
        int nelts = v53->nelts;
        if (nelts >= 5) {
          int nelts = 5;
        }
        v79 += 16LL;
      }

      while (v80 < nelts);
    }

    uint64_t v55 = v166 + 1;
  }

  while (v166 != 4);
  unint64_t v90 = v177;
  __int128 v91 = newpool;
  if (s_logUsingOsLog)
  {
    __int128 v92 = (os_log_s *)gt_tagged_log(1uLL);
    if (os_log_type_enabled(v92, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_0, v92, OS_LOG_TYPE_INFO, "[MEMORY BY FENUM]", buf, 2u);
    }
  }

  else
  {
    fwrite("[MEMORY BY FENUM]\n", 0x12uLL, 1uLL, __stdoutp);
  }

  uint64_t v93 = 0LL;
  __int128 v94 = v170;
  unsigned int v95 = *((_DWORD *)v170 + 12) / 0x57u;
  do
    v197[v93++] = apr_array_make(v91, v95, 8);
  while (v93 != 87);
  bzero(buf, 0x828uLL);
  *((void *)v94 + 3) = 0LL;
  *((void *)v94 + 4) = 0LL;
  *((void *)v94 + 2) = v94;
  *((_DWORD *)v94 + 10) = 0;
  __int128 v96 = apr_hash_next((apr_hash_t *)((char *)v94 + 16));
  if (v96)
  {
    __int128 v97 = v96;
    unint64_t v98 = (apr_array_header_t *)v197[0];
    uint64_t v99 = (uint64_t)v169;
    while (1)
    {
      uint64_t v100 = *(void *)(*((void *)v97 + 1) + 32LL);
      uint64_t v101 = *find_entry(v99, (_BYTE *)(v100 + 16), 8uLL, 0LL);
      uint64_t v102 = v98;
      if (!v101) {
        goto LABEL_103;
      }
      uint64_t v103 = *(void *)(v101 + 32);
      uint64_t v102 = v98;
      if (!v103) {
        goto LABEL_103;
      }
      unsigned int v104 = atomic_load((unsigned int *)(v103 + 4));
      if ((v104 & 0xFFFFFFC0) != 0x40) {
        break;
      }
LABEL_104:
      __int128 v97 = apr_hash_next(v97);
      if (!v97) {
        goto LABEL_105;
      }
    }

    uint64_t v102 = (apr_array_header_t *)v197[GetFuncEnumConstructorType(*(_DWORD *)(v103 + 72))];
LABEL_103:
    *(void *)apr_array_push(v102) = v100;
    goto LABEL_104;
  }

uint64_t CompareKeyValuePair(void *a1, void *a2)
{
  if (*a1 > *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 != *a2;
  }
}

uint64_t GTMTLCreateIndirectCommandEncoder(uint64_t result, uint64_t a2)
{
  *(void *)&__int128 v2 = -1LL;
  *((void *)&v2 + 1) = -1LL;
  *(_OWORD *)(result + 80) = v2;
  *(_OWORD *)(result + 96) = v2;
  *(_OWORD *)(result + 4_Block_object_dispose(va, 8) = v2;
  *(_OWORD *)(result + 64) = v2;
  *(_OWORD *)(result + 16) = v2;
  *(_OWORD *)(result + 32) = v2;
  *(void *)__n128 result = a2;
  *(void *)(result + _Block_object_dispose(va, 8) = 0LL;
  if (*(_BYTE *)(a2 + 11))
  {
    uint64_t v3 = 8LL;
  }

  else
  {
    *(void *)(result + 16) = 8LL;
    uint64_t v3 = 16LL;
  }

  if (!*(_BYTE *)(a2 + 10))
  {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 18);
    *(void *)(result + 24) = v3;
    *(void *)(result + 32) = v3 + 8 * v4;
    uint64_t v5 = v4 + *(unsigned __int8 *)(a2 + 12);
    uint64_t v6 = v3 + 8 * v5;
    uint64_t v7 = v5 + *(unsigned __int8 *)(a2 + 16);
    *(void *)(result + 40) = v6;
    *(void *)(result + 4_Block_object_dispose(va, 8) = v3 + 8 * v7;
    uint64_t v8 = v7 + *(unsigned __int8 *)(a2 + 15);
    *(void *)(result + 56) = v3 + 8 * v8;
    v3 += 8 * (v8 + *(unsigned __int8 *)(a2 + 13));
  }

  uint64_t v9 = *(unsigned __int8 *)(a2 + 17);
  *(void *)(result + 64) = v3;
  *(void *)(result + 72) = v3 + 8 * v9;
  uint64_t v10 = v9 + *(unsigned __int8 *)(a2 + 14);
  uint64_t v11 = v3 + 8 * v10;
  uint64_t v12 = *(unsigned __int16 *)(a2 + 8);
  *(void *)(result + 80) = v11;
  if (*(_BYTE *)(a2 + 19))
  {
    if ((v12 & 0xF) != 0)
    {
      uint64_t v13 = *(unsigned __int8 *)(a2 + 18);
    }

    else
    {
      if ((v12 & 0x60) == 0) {
        goto LABEL_12;
      }
      uint64_t v13 = *(unsigned __int8 *)(a2 + 13);
    }

    uint64_t v11 = v3 + 8 * (v10 + v13);
  }

double GetExecuteCommandsInBufferArgs@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  switch(*(_DWORD *)(a1 + 8))
  {
    case 0xFFFFC1A4:
    case 0xFFFFC1A6:
      uint64_t v10 = GTTraceFunc_argumentBytesWithMap((void *)a1, *(unsigned __int8 *)(a1 + 13), a2);
      *(_OWORD *)a3 = *(_OWORD *)(v10 + 8);
      uint64_t v9 = *((void *)v10 + 4);
      *(void *)(a3 + 16) = *((void *)v10 + 3);
      unsigned int v8 = v10[40];
      goto LABEL_4;
    case 0xFFFFC1A5:
    case 0xFFFFC1A7:
      uint64_t v6 = GTTraceFunc_argumentBytesWithMap((void *)a1, *(unsigned __int8 *)(a1 + 13), a2);
      uint64_t v7 = GTTraceFunc_argumentBlobWithMap((void *)a1, v6[41], a2);
      *(void *)a3 = *((void *)v6 + 1);
      *(_OWORD *)(a3 + _Block_object_dispose(va, 8) = *(_OWORD *)(v7 + 16);
      unsigned int v8 = v6[40];
      uint64_t v9 = *((void *)v6 + 4);
LABEL_4:
      uint64_t v11 = GTTraceMemoryMap_argumentBlobAtIndex(v8, a2, v9);
      if (v11)
      {
        uint64_t v13 = v11 + 16;
        uint64_t v14 = *(unsigned int *)(v11 + 12);
      }

      else
      {
        uint64_t v13 = 0LL;
        uint64_t v14 = 0LL;
      }

      *(void *)(a3 + 24) = v13;
      *(void *)(a3 + 32) = v14;
      break;
    default:
      *(void *)(a3 + 32) = 0LL;
      double result = 0.0;
      *(_OWORD *)a3 = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      break;
  }

  return result;
}

uint64_t DYMTLDrawRenderCommandEncoder(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v9 = a1;
  id v10 = a5;
  uint64_t v11 = *(void *)(a3 + *(void *)(a2 + 8));
  uint64_t v12 = 1LL;
  uint64_t v13 = 0LL;
  switch(v11)
  {
    case 0LL:
      goto LABEL_31;
    case 1LL:
      [v9 drawPrimitives:*(void *)(a3 + *(void *)(a2 + 96)) vertexStart:*(void *)(a3 + *(void *)(a2 + 96) + 8) vertexCount:*(void *)(a3 + *(void *)(a2 + 96) + 16) instanceCount:*(void *)(a3 + *(void *)(a2 + 96) + 24) baseInstance:*(void *)(a3 + *(void *)(a2 + 96) + 32)];
      break;
    case 2LL:
      int64x2_t v18 = (void *)(a3 + *(void *)(a2 + 96));
      uint64_t v19 = *(void **)(*(void *)a4 + 24LL);
      unint64_t v20 = *(int *)(*(void *)a4 + 12LL);
      unint64_t v21 = v18[3];
      int v22 = GTMTLGPUAddressResource_resourceForGPUAddress(v19, v20, v21);
      if (v22)
      {
        unint64_t v23 = v21 - *v22;
        uint64_t v24 = v22[2];
      }

      else
      {
        unint64_t v23 = 0LL;
        uint64_t v24 = 0LL;
      }

      id ObjectForKey = GetObjectForKey(v10, v24);
      unsigned int v43 = (void *)objc_claimAutoreleasedReturnValue(ObjectForKey);
      uint64_t v12 = v43 != 0LL;
      if (v43) {
        [v9 drawIndexedPrimitives:*v18 indexCount:v18[1] indexType:v18[2] indexBuffer:v43 indexBufferOffset:v23 instanceCount:v18[4] baseVertex:v18[5] baseInstance:v18[6]];
      }
      goto LABEL_19;
    case 3LL:
    case 5LL:
    case 6LL:
    case 7LL:
      break;
    case 4LL:
      id v25 = (void *)(*(void *)(a2 + 96) + a3);
      id v26 = *(void **)(*(void *)a4 + 24LL);
      unint64_t v27 = *(int *)(*(void *)a4 + 12LL);
      unint64_t v28 = v25[6];
      unint64_t v29 = GTMTLGPUAddressResource_resourceForGPUAddress(v26, v27, v28);
      if (v29)
      {
        unint64_t v30 = v28 - *v29;
        uint64_t v31 = v29[2];
      }

      else
      {
        unint64_t v30 = 0LL;
        uint64_t v31 = 0LL;
      }

      id v44 = GetObjectForKey(v10, v31);
      unsigned int v43 = (void *)objc_claimAutoreleasedReturnValue(v44);
      int v45 = v43 != 0LL;
      unsigned int v46 = v31 == 0;
      uint64_t v12 = v45 ^ v46;
      if (v45 != v46) {
        [v9 drawPatches:v25[3] patchStart:v25[4] patchCount:v25[5] patchIndexBuffer:v43 patchIndexBufferOffset:v30 instanceCount:v25[7] baseInstance:v25[8]];
      }
LABEL_19:

      break;
    case 8LL:
      uint64_t v32 = *(void *)(a2 + 96) + a3;
      int v33 = (void *)(v32 + 24);
      unint64_t v34 = *(void *)(v32 + 48);
      unint64_t v35 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a4 + 24LL),  *(int *)(*(void *)a4 + 12LL),  v34);
      if (v35)
      {
        unint64_t v36 = v34 - *v35;
        uint64_t v37 = v35[2];
      }

      else
      {
        unint64_t v36 = 0LL;
        uint64_t v37 = 0LL;
      }

      id v47 = GetObjectForKey(v10, v37);
      uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
      unsigned int v49 = (v48 != 0LL) ^ (v37 == 0);
      size_t v50 = *(void **)(*(void *)a4 + 24LL);
      unint64_t v51 = *(int *)(*(void *)a4 + 12LL);
      unint64_t v52 = v33[4];
      uint64_t v53 = GTMTLGPUAddressResource_resourceForGPUAddress(v50, v51, v52);
      if (v53)
      {
        unint64_t v54 = v52 - *v53;
        uint64_t v55 = v53[2];
      }

      else
      {
        unint64_t v54 = 0LL;
        uint64_t v55 = 0LL;
      }

      id v56 = GetObjectForKey(v10, v55);
      int v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
      if (v57) {
        uint64_t v12 = v49;
      }
      else {
        uint64_t v12 = 0LL;
      }
      if ((_DWORD)v12 == 1) {
        [v9 drawIndexedPatches:*v33 patchStart:v33[1] patchCount:v33[2] patchIndexBuffer:v48 patchIndexBufferOffset:v36 controlPointIndexBuffer:v57 contr olPointIndexBufferOffset:v54 instanceCount:v33[5] baseInstance:v33[6]];
      }

      break;
    default:
      if (v11 == 128)
      {
        uint64_t v38 = (__int128 *)(a3 + *(void *)(a2 + 96));
        uint64_t v39 = *((void *)v38 + 2);
        __int128 v69 = *v38;
        uint64_t v70 = v39;
        uint64_t v40 = *((void *)v38 + 5);
        __int128 v67 = *(__int128 *)((char *)v38 + 24);
        uint64_t v68 = v40;
        uint64_t v41 = *((void *)v38 + 8);
        __int128 v65 = v38[3];
        uint64_t v66 = v41;
        [v9 drawMeshThreadgroups:&v69 threadsPerObjectThreadgroup:&v67 threadsPerMeshThreadgroup:&v65];
      }

      else if (v11 == 256)
      {
        uint64_t v14 = (__int128 *)(a3 + *(void *)(a2 + 96));
        uint64_t v15 = *((void *)v14 + 2);
        __int128 v63 = *v14;
        uint64_t v64 = v15;
        uint64_t v16 = *((void *)v14 + 5);
        __int128 v61 = *(__int128 *)((char *)v14 + 24);
        uint64_t v62 = v16;
        uint64_t v17 = *((void *)v14 + 8);
        __int128 v59 = v14[3];
        uint64_t v60 = v17;
        [v9 drawMeshThreads:&v63 threadsPerObjectThreadgroup:&v61 threadsPerMeshThreadgroup:&v59];
      }

      break;
  }

  uint64_t v13 = v12;
LABEL_31:

  return v13;
}

id GetObjectForKey(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a2));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v4]);

  return v5;
}

uint64_t DYMTLDispatchComputeCommandEncoder(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a3 + *(void *)(a2 + 8));
  if (v7 == 64)
  {
    uint64_t v11 = *(void *)(a2 + 96) + a3;
    uint64_t v12 = *(void *)(v11 + 88);
    __int128 v18 = *(_OWORD *)(v11 + 72);
    uint64_t v19 = v12;
    uint64_t v13 = *(void *)(v11 + 112);
    __int128 v16 = *(_OWORD *)(v11 + 96);
    uint64_t v17 = v13;
    [v5 dispatchThreads:&v18 threadsPerThreadgroup:&v16];
  }

  else
  {
    if (v7 != 32)
    {
      uint64_t v14 = 0LL;
      goto LABEL_7;
    }

    uint64_t v8 = *(void *)(a2 + 96) + a3;
    uint64_t v9 = *(void *)(v8 + 88);
    __int128 v22 = *(_OWORD *)(v8 + 72);
    uint64_t v23 = v9;
    uint64_t v10 = *(void *)(v8 + 112);
    __int128 v20 = *(_OWORD *)(v8 + 96);
    uint64_t v21 = v10;
    [v5 dispatchThreadgroups:&v22 threadsPerThreadgroup:&v20];
  }

  uint64_t v14 = 1LL;
LABEL_7:

  return v14;
}

id GTMTLDecodeIndirectCommandBuffer(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v4,  "device",  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  v10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
                   0LL,
                   0LL,
                   0LL,
                   0LL,
                   0LL,
                   0LL,
                   0LL));
  TranslateGTMTLIndirectCommandBufferDescriptorWithDevice(v3, v5, (uint64_t)&v9, 1);

  id v6 = GTMTLDecodeIndirectCommandBufferInternal(v4, (uint64_t)v10);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);

  return v7;
}

id GTMTLDecodeIndirectCommandBufferInternal(void *a1, uint64_t a2)
{
  id v3 = a1;
  GTMTLCreateIndirectCommandEncoder((uint64_t)&v132, a2);
  int v4 = *(unsigned __int16 *)(a2 + 8);
  if ((v4 & 0xFE70) == 0)
  {
    id v103 = v3;
    id v116 = v3;
    id v6 = [v116 size];
    uint64_t v7 = v145;
    id v112 = v6;
    id v114 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", v145 * (void)v6));
    if (v6)
    {
      uint64_t v8 = 0LL;
      unsigned int v104 = 0LL;
      id v106 = 0LL;
      __int128 v9 = 0LL;
      uint64_t v10 = 0LL;
      double v123 = 0LL;
      uint64_t v102 = 0LL;
      uint64_t v11 = 0LL;
      uint64_t v108 = v7;
      uint64_t v110 = v133;
      do
      {
        uint64_t v12 = objc_autoreleasePoolPush();
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v116 indirectRenderCommandAtIndex:v11]);
        unsigned int v129 = (char *)[v114 mutableBytes];
        uint64_t v14 = &v129[v7 * (void)v11];
        uint64_t v15 = (uint32_t *)[v13 getCommandType];
        *(void *)&v14[v110] = v15;
        if (v15)
        {
          __int128 v16 = v15;
          uint64_t v125 = &v129[v7 * (void)v11];
          uint64_t v127 = v9;
          int v118 = v12;
          v120 = v10;
          uint64_t v17 = v144;
          __int128 v18 = &v14[v144];
          if ((int)((unint64_t)(v144 - v142) >> 3) >= 1)
          {
            uint64_t v19 = 0LL;
            uint64_t v20 = ((unint64_t)(v144 - v142) >> 3);
            uint64_t v21 = &v129[v142 + v8];
            do
            {
              *(void *)&v21[8 * v19] = [v13 getVertexAttributeStrideAtIndex:v19];
              ++v19;
            }

            while (v20 != v19);
          }

          __int128 v22 = v123;
          switch((unint64_t)v16)
          {
            case 1uLL:
              uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v13 drawArguments]);
              *(void *)__int128 v18 = [v23 primitiveType];
              *((void *)v18 + 1) = [v23 vertexStart];
              *((void *)v18 + 2) = [v23 vertexCount];
              *((void *)v18 + 3) = [v23 instanceCount];
              *((void *)v18 + 4) = [v23 baseInstance];
              goto LABEL_34;
            case 2uLL:
              uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v13 drawIndexedArguments]);
              *(void *)__int128 v18 = [v23 primitiveType];
              *((void *)v18 + 1) = [v23 indexCount];
              *((void *)v18 + 2) = [v23 indexType];
              *((void *)v18 + 3) = [v23 indexBufferGPUVirtualAddress];
              *((void *)v18 + 4) = [v23 instanceCount];
              *((void *)v18 + 5) = [v23 baseVertex];
              *((void *)v18 + 6) = [v23 baseInstance];
              if (*((void *)v18 + 2) == -1LL) {
                *((void *)v18 + 2) = *((void *)v102 + 2);
              }
              uint64_t v102 = v18;
              goto LABEL_34;
            case 3uLL:
            case 5uLL:
            case 6uLL:
            case 7uLL:
              goto LABEL_35;
            case 4uLL:
              unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v13 getTessellationFactorArguments]);
              unint64_t v30 = &v125[v17];
              *(void *)&v125[v17] = [v29 virtualAddress];
              *((void *)v18 + 1) = [v29 instanceStride];
              [v29 scale];
              *((_DWORD *)v18 + 4) = v31;

              uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v13 drawPatchesArguments]);
              *((void *)v30 + 3) = [v23 numberOfPatchControlPoints];
              *((void *)v30 + 4) = [v23 patchStart];
              *((void *)v30 + 5) = [v23 patchCount];
              *((void *)v30 + 6) = [v23 patchIndexBufferVirtualAddress];
              *((void *)v30 + 7) = [v23 instanceCount];
              *((void *)v30 + _Block_object_dispose(va, 8) = [v23 baseInstance];
              goto LABEL_34;
            case 8uLL:
              uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v13 getTessellationFactorArguments]);
              int v33 = &v125[v17];
              *(void *)&v125[v17] = [v32 virtualAddress];
              *((void *)v18 + 1) = [v32 instanceStride];
              [v32 scale];
              *((_DWORD *)v18 + 4) = v34;

              uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v13 drawIndexedPatchesArguments]);
              *((void *)v33 + 3) = [v23 numberOfPatchControlPoints];
              *((void *)v33 + 4) = [v23 patchStart];
              *((void *)v33 + 5) = [v23 patchCount];
              *((void *)v33 + 6) = [v23 patchIndexBufferVirtualAddress];
              *((void *)v33 + 7) = [v23 controlPointIndexBufferVirtualAddress];
              *((void *)v33 + _Block_object_dispose(va, 8) = [v23 instanceCount];
              *((void *)v33 + 9) = [v23 baseInstance];
              goto LABEL_34;
            default:
              if (v16 == (uint32_t *)&stru_68.segname[8])
              {
                unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v13 drawMeshThreadgroupsArguments]);
                uint64_t v23 = v35;
                __int128 v22 = v123;
                if (v35)
                {
                  [v35 threadgroupsPerGrid];
                  uint64_t v36 = v154;
                  *(_OWORD *)__int128 v18 = v153;
                  *((void *)v18 + 2) = v36;
                  [v23 threadsPerObjectThreadgroup];
                  uint64_t v37 = v159;
                  *(_OWORD *)(v18 + 24) = v158;
                  *((void *)v18 + 5) = v37;
                  [v23 threadsPerMeshThreadgroup];
                  __int128 v27 = v156;
                  uint64_t v28 = v157;
                }

                else
                {
                  if (s_logUsingOsLog)
                  {
                    id v40 = gt_default_log();
                    uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
                    if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_fault_impl( &dword_0,  v41,  OS_LOG_TYPE_FAULT,  "fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreadgroups",  buf,  2u);
                    }
                  }

                  else
                  {
                    unsigned int v43 = __stderrp;
                    uint64_t v41 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreadgroups"));
                    fprintf(v43, "%s\n", (const char *)-[os_log_s UTF8String](v41, "UTF8String"));
                  }

                  uint64_t v28 = 0LL;
                  *(void *)&__int128 v154 = 0LL;
                  __int128 v27 = 0uLL;
                  __int128 v153 = 0u;
                  *((void *)v18 + 2) = 0LL;
                  *(_OWORD *)__int128 v18 = 0u;
                  uint64_t v159 = 0LL;
                  __int128 v158 = 0u;
                  *((void *)v18 + 5) = 0LL;
                  *(_OWORD *)(v18 + 24) = 0u;
                  uint64_t v157 = 0LL;
                  __int128 v156 = 0u;
                }
              }

              else
              {
                __int128 v22 = v123;
                if (v16 != &stru_B8.reserved2) {
                  goto LABEL_35;
                }
                uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v13 drawMeshThreadsArguments]);
                uint64_t v23 = v24;
                if (v24)
                {
                  [v24 threadsPerGrid];
                  uint64_t v25 = v151;
                  *(_OWORD *)__int128 v18 = v150;
                  *((void *)v18 + 2) = v25;
                  [v23 threadsPerObjectThreadgroup];
                  uint64_t v26 = v149;
                  *(_OWORD *)(v18 + 24) = v148;
                  *((void *)v18 + 5) = v26;
                  [v23 threadsPerMeshThreadgroup];
                  __int128 v27 = v146;
                  uint64_t v28 = v147;
                }

                else
                {
                  if (s_logUsingOsLog)
                  {
                    id v38 = gt_default_log();
                    uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
                    if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_fault_impl( &dword_0,  v39,  OS_LOG_TYPE_FAULT,  "fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreads",  buf,  2u);
                    }
                  }

                  else
                  {
                    uint64_t v42 = __stderrp;
                    uint64_t v39 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreads"));
                    fprintf(v42, "%s\n", (const char *)-[os_log_s UTF8String](v39, "UTF8String"));
                  }

                  uint64_t v28 = 0LL;
                  uint64_t v151 = 0LL;
                  __int128 v27 = 0uLL;
                  __int128 v150 = 0u;
                  *((void *)v18 + 2) = 0LL;
                  *(_OWORD *)__int128 v18 = 0u;
                  uint64_t v149 = 0LL;
                  __int128 v148 = 0u;
                  *((void *)v18 + 5) = 0LL;
                  *(_OWORD *)(v18 + 24) = 0u;
                  uint64_t v147 = 0LL;
                  __int128 v146 = 0u;
                }
              }

              *((_OWORD *)v18 + 3) = v27;
              *((void *)v18 + _Block_object_dispose(va, 8) = v28;
LABEL_34:

LABEL_35:
              id v44 = v132;
              if (!v132[11])
              {
                id v45 = [v13 getPipelineStateUniqueIdentifier];
                id v46 = v106;
                if (v45 != (id)-1LL) {
                  id v46 = v45;
                }
                id v106 = v46;
                *(void *)&v125[v134] = v46;
              }

              uint64_t v10 = v120;
              if (!v44[10])
              {
                uint64_t v121 = v135;
                if (v44[18])
                {
                  unint64_t v47 = 0LL;
                  uint64_t v48 = &v129[v135 + v8];
                  do
                  {
                    if ((objc_opt_respondsToSelector(v13, "getVertexBufferAddressAtIndex:") & 1) != 0) {
                      id v49 = [v13 getVertexBufferAddressAtIndex:v47];
                    }
                    else {
                      id v49 = [v13 getVertexBufferAtIndex:v47];
                    }
                    if (v49 == (id)-1LL) {
                      id v50 = 0LL;
                    }
                    else {
                      id v50 = v49;
                    }
                    if (v49 == (id)-1LL && v104) {
                      id v50 = *(id *)&v104[8 * v47];
                    }
                    *(void *)&v48[8 * v47++] = v50;
                  }

                  while (v47 < v44[18]);
                }

                uint64_t v51 = v136;
                if (v44[12])
                {
                  unint64_t v52 = 0LL;
                  uint64_t v53 = &v129[v136 + v8];
                  do
                  {
                    if ((objc_opt_respondsToSelector(v13, "getFragmentBufferAddressAtIndex:") & 1) != 0) {
                      id v54 = [v13 getFragmentBufferAddressAtIndex:v52];
                    }
                    else {
                      id v54 = [v13 getFragmentBufferAtIndex:v52];
                    }
                    if (v54 == (id)-1LL) {
                      id v55 = 0LL;
                    }
                    else {
                      id v55 = v54;
                    }
                    if (v54 == (id)-1LL && v127) {
                      id v55 = *(id *)&v127[8 * v52];
                    }
                    *(void *)&v53[8 * v52++] = v55;
                  }

                  while (v52 < v44[12]);
                }

                uint64_t v56 = v137;
                if (v44[16])
                {
                  unint64_t v57 = 0LL;
                  uint64_t v58 = &v129[v137 + v8];
                  do
                  {
                    if ((objc_opt_respondsToSelector(v13, "getObjectBufferAddressAtIndex:") & 1) != 0)
                    {
                      id v59 = [v13 getObjectBufferAddressAtIndex:v57];
                      if (v59 == (id)-1LL) {
                        id v60 = 0LL;
                      }
                      else {
                        id v60 = v59;
                      }
                      if (v59 == (id)-1LL && v10) {
                        id v60 = *(id *)&v10[8 * v57];
                      }
                    }

                    else
                    {
                      if (GTMTLDecodeIndirectRenderCommandBuffer_onceToken != -1) {
                        dispatch_once(&GTMTLDecodeIndirectRenderCommandBuffer_onceToken, &__block_literal_global_206);
                      }
                      id v60 = 0LL;
                    }

                    *(void *)&v58[8 * v57++] = v60;
                  }

                  while (v57 < v44[16]);
                }

                unsigned int v104 = &v125[v121];
                uint64_t v127 = &v125[v51];
                uint64_t v10 = &v125[v56];
                __int128 v61 = &v125[v138];
                if (v44[15])
                {
                  uint64_t v62 = v10;
                  unint64_t v63 = 0LL;
                  uint64_t v64 = &v129[v138 + v8];
                  do
                  {
                    if ((objc_opt_respondsToSelector(v13, "getMeshBufferAddressAtIndex:") & 1) != 0)
                    {
                      id v65 = [v13 getMeshBufferAddressAtIndex:v63];
                      if (v65 == (id)-1LL) {
                        id v66 = 0LL;
                      }
                      else {
                        id v66 = v65;
                      }
                      if (v65 == (id)-1LL && v123) {
                        id v66 = *(id *)&v123[8 * v63];
                      }
                    }

                    else
                    {
                      if (GTMTLDecodeIndirectRenderCommandBuffer_onceToken_33 != -1) {
                        dispatch_once(&GTMTLDecodeIndirectRenderCommandBuffer_onceToken_33, &__block_literal_global_35);
                      }
                      id v66 = 0LL;
                    }

                    *(void *)&v64[8 * v63++] = v66;
                  }

                  while (v63 < v44[15]);
                  __int128 v22 = v61;
                  uint64_t v10 = v62;
                }

                else
                {
                  __int128 v22 = &v125[v138];
                }
              }

              if (v44[17])
              {
                unint64_t v67 = 0LL;
                uint64_t v68 = &v129[v140 + v8];
                do
                {
                  *(void *)&v68[8 * v67] = [v13 getObjectThreadgroupMemoryLengthAtIndex:v67];
                  ++v67;
                }

                while (v67 < v44[17]);
              }

              double v123 = v22;
              if (v44[21])
              {
                uint64_t v69 = v143;
                *(void *)&v125[v69] = [v13 hasBarrier];
              }

              uint64_t v7 = v108;
              uint64_t v12 = v118;
              __int128 v9 = v127;
              break;
          }
        }

        objc_autoreleasePoolPop(v12);
        uint64_t v11 = (char *)v11 + 1;
        v8 += v7;
      }

      while (v11 != v112);
    }

    id v5 = [v114 copy];

    uint64_t v70 = v116;
    goto LABEL_138;
  }

  if ((v4 & 0xFFFFFF9F) == 0)
  {
    id v103 = v3;
    id v128 = v3;
    id v71 = [v128 size];
    uint64_t v72 = v145;
    id v105 = objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithLength:]( &OBJC_CLASS___NSMutableData, "dataWithLength:", v145 * (void)v71));
    id v124 = v71;
    v126 = (char *)[v105 mutableBytes];
    if (v71)
    {
      unsigned __int8 v73 = 0LL;
      uint64_t v74 = 0LL;
      uint64_t v111 = v144 + 72;
      id v113 = 0LL;
      id v75 = v132;
      uint64_t v119 = v72;
      uint64_t v122 = v133;
      uint64_t v109 = v134;
      uint64_t v117 = v144;
      id v115 = (id)((unint64_t)(v144 - v142) >> 3);
      unsigned __int8 v76 = &v126[v142];
      uint64_t v107 = v139;
      unsigned __int16 v77 = &v126[v139];
      unsigned __int16 v78 = &v126[v141];
      while (1)
      {
        uint64_t v130 = v73;
        context = objc_autoreleasePoolPush();
        uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue([v128 indirectComputeCommandAtIndex:v74]);
        uint64_t v80 = &v126[v72 * (void)v74];
        id v81 = (uint64_t *)[v79 getCommandType];
        *(void *)&v80[v122] = v81;
        if (v81) {
          break;
        }
        unsigned __int8 v73 = v130;
LABEL_136:

        objc_autoreleasePoolPop(context);
        uint64_t v74 = (char *)v74 + 1;
        v76 += v72;
        v77 += v72;
        v78 += v72;
        if (v74 == v124) {
          goto LABEL_137;
        }
      }

      unint64_t v82 = v81;
      if ((int)v115 >= 1)
      {
        uint64_t v83 = 0LL;
        do
        {
          *(void *)&v76[8 * v83] = [v79 getKernelAttributeStrideAtIndex:v83];
          ++v83;
        }

        while (v115 != v83);
      }

      int v84 = &v80[v117];
      if (v82 == (uint64_t *)&stru_20)
      {
        uint64_t v87 = (void *)objc_claimAutoreleasedReturnValue([v79 dispatchThreadgroupsArguments]);
        unint64_t v86 = v87;
        if (v87)
        {
          [v87 threadgroupsPerGrid];
          goto LABEL_113;
        }
      }

      else
      {
        if (v82 != &stru_20.vmsize)
        {
LABEL_119:
          if (!v75[11])
          {
            id v96 = [v79 getPipelineStateUniqueIdentifier];
            id v97 = v113;
            if (v96 != (id)-1LL) {
              id v97 = v96;
            }
            id v113 = v97;
            *(void *)&v80[v109] = v97;
          }

          uint64_t v72 = v119;
          if (v75[10])
          {
            unsigned __int8 v73 = v130;
          }

          else
          {
            if (v75[13])
            {
              unint64_t v98 = 0LL;
              do
              {
                id v99 = [v79 getKernelBufferAtIndex:v98];
                if (v99 == (id)-1LL)
                {
                  if (v130) {
                    id v99 = *(id *)&v130[8 * v98];
                  }
                  else {
                    id v99 = 0LL;
                  }
                }

                *(void *)&v77[8 * v98++] = v99;
              }

              while (v98 < v75[13]);
            }

            unsigned __int8 v73 = &v80[v107];
            uint64_t v72 = v119;
          }

          if (v75[14])
          {
            unint64_t v100 = 0LL;
            do
            {
              *(void *)&v78[8 * v100] = [v79 getThreadgroupMemoryLengthAtIndex:v100];
              ++v100;
            }

            while (v100 < v75[14]);
          }

          goto LABEL_136;
        }

        uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue([v79 dispatchThreadsArguments]);
        unint64_t v86 = v85;
        if (v85)
        {
          [v85 threadsPerGrid];
LABEL_113:
          [v86 threadsPerThreadgroup];
          __int128 v88 = v158;
          uint64_t v89 = v159;
          __int128 v90 = v156;
          uint64_t v91 = v157;
LABEL_115:
          __int128 v92 = &v80[v111];
          *(_OWORD *)__int128 v92 = v88;
          *((void *)v92 + 2) = v89;
          *(_OWORD *)(v92 + 24) = v90;
          *((void *)v92 + 5) = v91;
          if (v79)
          {
            [v79 getStageInRegion];
            __int128 v93 = v153;
            __int128 v94 = v154;
            __int128 v95 = v155;
          }

          else
          {
            __int128 v154 = 0u;
            __int128 v155 = 0u;
            __int128 v93 = 0uLL;
            __int128 v94 = 0uLL;
            __int128 v95 = 0uLL;
            __int128 v153 = 0u;
          }

          *(_OWORD *)int v84 = v93;
          *((_OWORD *)v84 + 1) = v94;
          *((_OWORD *)v84 + 2) = v95;
          v84[64] = [v79 hasBarrier];

          goto LABEL_119;
        }
      }

      uint64_t v91 = 0LL;
      uint64_t v89 = 0LL;
      uint64_t v159 = 0LL;
      __int128 v88 = 0uLL;
      __int128 v158 = 0u;
      uint64_t v157 = 0LL;
      __int128 v156 = 0u;
      __int128 v90 = 0uLL;
      goto LABEL_115;
    }

LABEL_137:
    id v5 = [v105 copy];
    uint64_t v70 = v128;
LABEL_138:

    id v3 = v103;
    goto LABEL_139;
  }

  id v5 = 0LL;
LABEL_139:

  return v5;
}

        LOBYTE(v36) = 0;
        LOBYTE(v16) = 0;
        v176[0] = 37;
        v176[1] = *fmt;
        uint64_t v83 = 2LL;
      }

      __int128 v177 = (_BYTE *)v83;
      p_n_4 = v176;
LABEL_142:
      __int128 v18 = 32;
LABEL_297:
      uint64_t v41 = flush_func;
LABEL_313:
      uint64_t v42 = v174;
      goto LABEL_384;
    }
  }

  switch(*fmt)
  {
    case 'c':
      LOBYTE(v36) = 0;
      LOBYTE(v16) = 0;
      uint64_t v85 = v178;
      v178 += 8;
      int v84 = *v85;
      goto LABEL_140;
    case 'd':
    case 'i':
      if (v33)
      {
        unint64_t v67 = (unint64_t *)v178;
        v178 += 8;
        uint64_t v68 = v17;
        uint64_t v69 = conv_10_quad(*v67, 0, &v175, (uint64_t)&v184[3], &v177);
        uint64_t v17 = v68;
        p_n_4 = (const char *)v69;
        if ((v68 & 1) != 0) {
          goto LABEL_169;
        }
LABEL_165:
        id v99 = 511LL;
        if (v171 + 1 < 0x200) {
          id v99 = v171;
        }
        goto LABEL_169;
      }

      __int128 v95 = (unsigned int *)v178;
      v178 += 8;
      id v96 = *v95;
      if ((_DWORD)v36) {
        id v97 = (__int16)v96;
      }
      else {
        id v97 = v96;
      }
      unint64_t v98 = v97 >> 31;
      if ((v97 & 0x80000000) != 0) {
        id v97 = -v97;
      }
      __int128 v175 = v98;
      p_n_4 = &v184[3];
      do
      {
        *--p_n_4 = v97 % 0xA + 48;
        unsigned __int8 v76 = v97 > 9;
        v97 /= 0xAu;
      }

      while (v76);
      __int128 v177 = (_BYTE *)(&v184[3] - p_n_4);
      if ((v17 & 1) == 0) {
        goto LABEL_165;
      }
LABEL_169:
      int v168 = v5;
      if (v175)
      {
        unint64_t v100 = 45;
      }

      else if (v15)
      {
        unint64_t v100 = 43;
      }

      else
      {
        unint64_t v100 = 32 * (v14 != 0);
      }

      uint64_t v41 = flush_func;
LABEL_348:
      uint64_t v42 = v174;
      break;
    case 'e':
    case 'f':
      goto LABEL_86;
    case 'g':
      goto LABEL_104;
    case 'h':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'q':
    case 'r':
    case 't':
    case 'v':
    case 'w':
      goto LABEL_137;
    case 'n':
      if (v33)
      {
        LOBYTE(v36) = 0;
        unint64_t v86 = (void **)v178;
        v178 += 8;
        **unint64_t v86 = v8;
      }

      else if ((_DWORD)v36)
      {
        LOBYTE(v36) = 0;
        double v123 = (_WORD **)v178;
        v178 += 8;
        **double v123 = v8;
      }

      else
      {
        uint64_t v139 = (_DWORD **)v178;
        v178 += 8;
        *apr_hash_index_t *v139 = v8;
      }

      LOBYTE(v16) = 1;
      goto LABEL_297;
    case 'o':
      if (v33)
      {
        uint64_t v87 = (unint64_t *)v178;
        v178 += 8;
        __int128 v88 = *v87;
        uint64_t v89 = "0123456789abcdef";
        if (*fmt == 88) {
          uint64_t v89 = "0123456789ABCDEF";
        }
        if (HIDWORD(v88))
        {
          p_n_4 = &v184[3];
          uint64_t v41 = flush_func;
          do
          {
            *--p_n_4 = v89[v88 & 7];
            id v66 = v88 >= 8;
            v88 >>= 3;
          }

          while (v66);
        }

        else
        {
          p_n_4 = &v184[3];
          uint64_t v41 = flush_func;
          do
          {
            *--p_n_4 = v89[v88 & 7];
            id v66 = v88 >= 8;
            LODWORD(v8_Block_object_dispose(va, 8) = v88 >> 3;
          }

          while (v66);
        }
      }

      else
      {
        id v124 = (unsigned int *)v178;
        v178 += 8;
        uint64_t v125 = *v124;
        if ((_DWORD)v36) {
          uint64_t v125 = (unsigned __int16)v125;
        }
        v126 = "0123456789abcdef";
        if (*fmt == 88) {
          v126 = "0123456789ABCDEF";
        }
        p_n_4 = &v184[3];
        BOOL v169 = v125;
        do
        {
          *--p_n_4 = v126[v125 & 7];
          unsigned __int8 v76 = v125 > 7;
          v125 >>= 3;
        }

        while (v76);
        uint64_t v41 = flush_func;
      }

      uint64_t v42 = v174;
      __int128 v177 = (_BYTE *)(&v184[3] - p_n_4);
      if ((v17 & 1) == 0)
      {
        uint64_t v138 = 511LL;
        if (v171 + 1 < 0x200) {
          uint64_t v138 = v171;
        }
        if (&v184[3] - p_n_4 >= v138)
        {
          uint64_t v42 = v174;
        }

        else
        {
          uint64_t v42 = v174;
          do
          {
            *--p_n_4 = 48;
            ++v177;
          }

          while ((unint64_t)v177 < v138);
        }
      }

      if (!v16)
      {
        LOBYTE(v36) = 0;
        goto LABEL_384;
      }

      if (*p_n_4 == 48) {
        goto LABEL_301;
      }
      LOBYTE(v36) = 0;
      LOBYTE(v16) = 0;
      *--p_n_4 = 48;
      uint64_t v133 = v177 + 1;
      goto LABEL_304;
    case 'p':
      uint64_t v39 = *++fmt;
      id v38 = v39;
      uint64_t v10 = v39;
      if (!v39) {
        goto LABEL_3;
      }
      if (v38 <= 83)
      {
        uint64_t v41 = flush_func;
        uint64_t v42 = v174;
        switch(v38)
        {
          case 'A':
            unsigned int v43 = (unsigned int **)v178;
            v178 += 8;
            uint64_t v36 = *v43;
            if (!v36) {
              goto LABEL_211;
            }
            id v44 = bswap32(*v36);
            id v45 = v44;
            id v46 = v184;
            unint64_t v47 = &v184[2];
            uint64_t v48 = &v184[4];
            do
            {
              id v49 = v47;
              id v50 = v46;
              *(v48 - 2) = v45 % 0xA + 48;
              --v48;
              --v47;
              --v46;
              unsigned __int8 v76 = v45 > 9;
              v45 /= 0xAu;
            }

            while (v76);
            *(v48 - 2) = 46;
            uint64_t v51 = BYTE1(v44);
            do
            {
              unint64_t v52 = v50;
              *(v49 - 2) = v51 % 0xA + 48;
              --v49;
              --v50;
              unsigned __int8 v76 = v51 > 9;
              v51 /= 0xAu;
            }

            while (v76);
            *(v49 - 2) = 46;
            uint64_t v53 = BYTE2(v44);
            do
            {
              *(v52 - 2) = v53 % 0xA + 48;
              --v52;
              unsigned __int8 v76 = v53 > 9;
              v53 /= 0xAu;
            }

            while (v76);
            *(v52 - 2) = 46;
            p_n_4 = v52 - 2;
            id v54 = HIBYTE(v44);
            do
            {
              *--p_n_4 = v54 % 0xA + 48;
              unsigned __int8 v76 = v54 > 9;
              v54 /= 0xAu;
            }

            while (v76);
            goto LABEL_307;
          case 'B':
          case 'F':
            goto LABEL_191;
          case 'C':
          case 'D':
          case 'E':
          case 'G':
          case 'H':
            goto LABEL_202;
          case 'I':
            uint64_t v111 = (unsigned int **)v178;
            v178 += 8;
            uint64_t v36 = *v111;
            if (!v36) {
              goto LABEL_211;
            }
            LOBYTE(v36) = 0;
            LOBYTE(v16) = 0;
            p_n_4 = 0LL;
            id v112 = v177;
            id v113 = v171;
            else {
              id v114 = v17;
            }
            goto LABEL_207;
          default:
            uint64_t v41 = flush_func;
            uint64_t v42 = v174;
            if (v38 != 83) {
              goto LABEL_202;
            }
LABEL_191:
            if (v10 == 66)
            {
              id v105 = (unsigned int **)v178;
              v178 += 8;
              id v106 = *v105;
              if (v106)
              {
                uint64_t v107 = *v106;
                goto LABEL_197;
              }
            }

            else
            {
              uint64_t v108 = (apr_off_t **)v178;
              v178 += 8;
              uint64_t v109 = *v108;
              if (v109)
              {
                uint64_t v107 = *v109;
                goto LABEL_197;
              }
            }

            uint64_t v107 = 0LL;
LABEL_197:
            p_n_4 = __s;
            apr_strfsize(v107, __s);
            uint64_t v110 = strlen(__s);
            LOBYTE(v36) = 0;
            LOBYTE(v16) = 0;
            __int128 v177 = (_BYTE *)v110;
            __int128 v18 = 32;
            break;
        }

        goto LABEL_313;
      }

      if (v38 <= 111)
      {
        uint64_t v42 = v174;
        if (v38 == 84)
        {
          id v115 = (unsigned int **)v178;
          v178 += 8;
          uint64_t v36 = *v115;
          uint64_t v41 = flush_func;
          if (!v36)
          {
LABEL_211:
            LOBYTE(v16) = 0;
            __int128 v177 = (_BYTE *)(&dword_4 + 2);
            __int128 v18 = 32;
            p_n_4 = "(null)";
            goto LABEL_384;
          }

          id v116 = v17;
          p_n_4 = (const char *)conv_10_quad(*(void *)v36, 1, __s, (uint64_t)&v184[3], &v177);
          LOBYTE(v36) = 0;
          LOBYTE(v16) = 0;
          id v112 = v177;
          id v113 = v171;
          else {
            id v114 = v116;
          }
LABEL_207:
          unint64_t v35 = v114 == 0;
          uint64_t v42 = v174;
          if (v35) {
            id v112 = (_BYTE *)v113;
          }
          __int128 v177 = v112;
        }

        else
        {
          uint64_t v41 = flush_func;
          if (v38 != 109) {
            goto LABEL_202;
          }
          uint64_t v56 = (apr_status_t **)v178;
          v178 += 8;
          unint64_t v57 = *v56;
          if (v57)
          {
            p_n_4 = &__n_4;
            apr_strerror(*v57, &__n_4, 0x1FFuLL);
            uint64_t v58 = strlen(&__n_4);
            uint64_t v42 = v174;
          }

          else
          {
            uint64_t v58 = 6LL;
            p_n_4 = "(null)";
          }

          LOBYTE(v36) = 0;
          LOBYTE(v16) = 0;
          __int128 v177 = (_BYTE *)v58;
        }

void GTMTLEncodeIndirectCommandBufferWithRange( void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  id v11 = a1;
  id v12 = a7;
  GTMTLCreateIndirectCommandEncoder((uint64_t)&v151, a4);
  int v13 = *(unsigned __int16 *)(a4 + 8);
  if ((v13 & 0xFE70) == 0)
  {
    id v126 = v11;
    id v141 = v11;
    id v125 = v12;
    id v146 = v12;
    uint64_t v139 = a2 + a3;
    if (a2 < a2 + a3)
    {
      uint64_t v43 = v164;
      uint64_t v137 = v152;
      uint64_t v44 = a5 + a2 * v164;
      uint64_t v128 = v164;
      do
      {
        id v45 = objc_autoreleasePoolPush();
        uint64_t v46 = a5 + v43 * a2;
        unint64_t v149 = a2;
        unint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v141 indirectRenderCommandAtIndex:a2]);
        uint64_t v48 = v47;
        uint64_t v49 = *(void *)(v46 + v137);
        switch(v49)
        {
          case 0LL:
            [v47 reset];
            goto LABEL_112;
          case 1LL:
            [v47 drawPrimitives:*(void *)(v46 + v163) vertexStart:*(void *)(v46 + v163 + 8) vertexCount:*(void *)(v46 + v163 + 16) instanceCount:*(void *)(v46 + v163 + 24) baseInstance:*(void *)(v46 + v163 + 32)];
            break;
          case 2LL:
            uint64_t v53 = (void *)(v46 + v163);
            unint64_t v54 = *(void *)(v46 + v163 + 24);
            id v55 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a6 + 24LL),  *(int *)(*(void *)a6 + 12LL),  v54);
            if (v55)
            {
              unint64_t v56 = v54 - *v55;
              uint64_t v57 = v55[2];
            }

            else
            {
              unint64_t v56 = 0LL;
              uint64_t v57 = 0LL;
            }

            id ObjectForKey = GetObjectForKey(v146, v57);
            uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(ObjectForKey);
            if (v74) {
              [v48 drawIndexedPrimitives:*v53 indexCount:v53[1] indexType:v53[2] indexBuffer:v74 indexBufferOffset:v56 instanceCount:v53[4] baseVertex:v53[5] baseInstance:v53[6]];
            }
            else {
              [v48 reset];
            }

            break;
          case 3LL:
          case 5LL:
          case 6LL:
          case 7LL:
            break;
          case 4LL:
            uint64_t v58 = v163;
            id v59 = (void *)(v163 + v46);
            unint64_t v60 = *(void *)(v163 + v46 + 48);
            __int128 v61 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a6 + 24LL),  *(int *)(*(void *)a6 + 12LL),  v60);
            uint64_t v62 = v46;
            if (v61)
            {
              unint64_t v133 = v60 - *v61;
              uint64_t v63 = v61[2];
            }

            else
            {
              unint64_t v133 = 0LL;
              uint64_t v63 = 0LL;
            }

            id v75 = GetObjectForKey(v146, v63);
            unsigned __int8 v76 = (void *)objc_claimAutoreleasedReturnValue(v75);
            BOOL v77 = v63 == 0;
            unsigned __int16 v78 = (unint64_t *)(v62 + v58);
            unint64_t v79 = *v78;
            uint64_t v80 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a6 + 24LL),  *(int *)(*(void *)a6 + 12LL),  *v78);
            uint64_t v81 = v44;
            if (v80)
            {
              unint64_t v82 = v79 - *v80;
              uint64_t v83 = v80[2];
            }

            else
            {
              unint64_t v82 = 0LL;
              uint64_t v83 = 0LL;
            }

            id v90 = GetObjectForKey(v146, v83);
            uint64_t v91 = objc_claimAutoreleasedReturnValue(v90);
            __int128 v92 = (void *)v91;
            if (v91) {
              int v93 = (v76 != 0LL) ^ v77;
            }
            else {
              int v93 = 0;
            }
            if (v93 == 1) {
              [v48 drawPatches:v59[3] patchStart:v59[4] patchCount:v59[5] patchIndexBuffer:v76 patchIndexBufferOffset:v133 instanceCount:v59[7] baseInstance:v59[8] tes sellationFactorBuffer:v91 tessellationFactorBufferOffset:v82 tessellationFactorBufferInstanceStride:v78[1]];
            }
            else {
              [v48 reset];
            }
            uint64_t v43 = v128;
            uint64_t v44 = v81;
            uint64_t v46 = v62;
            goto LABEL_83;
          case 8LL:
            uint64_t v64 = v163;
            uint64_t v65 = v163 + v46;
            unint64_t v66 = *(void *)(v163 + v46 + 48);
            unint64_t v67 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a6 + 24LL),  *(int *)(*(void *)a6 + 12LL),  v66);
            uint64_t v143 = v45;
            uint64_t v68 = v46;
            if (v67)
            {
              unint64_t v134 = v66 - *v67;
              uint64_t v69 = v67[2];
            }

            else
            {
              unint64_t v134 = 0LL;
              uint64_t v69 = 0LL;
            }

            int v84 = (void *)(v65 + 24);
            id v85 = GetObjectForKey(v146, v69);
            unsigned __int8 v76 = (void *)objc_claimAutoreleasedReturnValue(v85);
            BOOL v86 = v69 == 0;
            unint64_t v87 = v84[4];
            __int128 v88 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a6 + 24LL),  *(int *)(*(void *)a6 + 12LL),  v87);
            if (v88)
            {
              unint64_t v130 = v87 - *v88;
              uint64_t v89 = v88[2];
            }

            else
            {
              unint64_t v130 = 0LL;
              uint64_t v89 = 0LL;
            }

            id v94 = GetObjectForKey(v146, v89);
            __int128 v92 = (void *)objc_claimAutoreleasedReturnValue(v94);
            if (v92) {
              int v95 = (v76 != 0LL) ^ v86;
            }
            else {
              int v95 = 0;
            }
            uint64_t v96 = v68 + v64;
            unint64_t v97 = *(void *)(v68 + v64);
            unint64_t v98 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a6 + 24LL),  *(int *)(*(void *)a6 + 12LL),  v97);
            if (v98)
            {
              unint64_t v99 = v97 - *v98;
              uint64_t v100 = v98[2];
            }

            else
            {
              unint64_t v99 = 0LL;
              uint64_t v100 = 0LL;
            }

            id v101 = GetObjectForKey(v146, v100);
            uint64_t v102 = objc_claimAutoreleasedReturnValue(v101);
            id v103 = (void *)v102;
            if (v102) {
              int v104 = v95;
            }
            else {
              int v104 = 0;
            }
            if (v104 == 1) {
              [v48 drawIndexedPatches:*v84 patchStart:v84[1] patchCount:v84[2] patchIndexBuffer:v76 patchIndexBufferOffset:v134 controlPointIndexBuffer :v92 controlPointIndexBufferOffset:v130 instanceCount:v84[5] baseInstance:v84[6] tessellationFactorBuffer:v102 tessellationFactorBuf ferOffset:v99 tessellationFactorBufferInstanceStride:*(void *)(v96 + 8)];
            }
            else {
              [v48 reset];
            }
            uint64_t v43 = v128;
            id v45 = v143;
            uint64_t v46 = v68;

LABEL_83:
            break;
          default:
            if (v49 == 128)
            {
              uint64_t v70 = *(void *)(v46 + v163 + 16);
              __int128 v171 = *(_OWORD *)(v46 + v163);
              *(void *)&__int128 v172 = v70;
              uint64_t v71 = *(void *)(v46 + v163 + 40);
              __int128 v176 = *(_OWORD *)(v46 + v163 + 24);
              uint64_t v177 = v71;
              uint64_t v72 = *(void *)(v46 + v163 + 64);
              __int128 v174 = *(_OWORD *)(v46 + v163 + 48);
              uint64_t v175 = v72;
              [v47 drawMeshThreadgroups:&v171 threadsPerObjectThreadgroup:&v176 threadsPerMeshThreadgroup:&v174];
            }

            else if (v49 == 256)
            {
              uint64_t v50 = *(void *)(v46 + v163 + 16);
              __int128 v169 = *(_OWORD *)(v46 + v163);
              uint64_t v170 = v50;
              uint64_t v51 = *(void *)(v46 + v163 + 40);
              __int128 v167 = *(_OWORD *)(v46 + v163 + 24);
              uint64_t v168 = v51;
              uint64_t v52 = *(void *)(v46 + v163 + 64);
              __int128 v165 = *(_OWORD *)(v46 + v163 + 48);
              uint64_t v166 = v52;
              [v47 drawMeshThreads:&v169 threadsPerObjectThreadgroup:&v167 threadsPerMeshThreadgroup:&v165];
            }

            break;
        }

        id v105 = v151;
        if (!v151[11])
        {
          uint64_t v106 = *(void *)(v46 + v153);
          if (v106)
          {
            uint64_t v107 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(a6, v106);
            id v108 = GetObjectForKey(v146, v107);
            uint64_t v109 = (void *)objc_claimAutoreleasedReturnValue(v108);
            if (v109) {
              [v48 setRenderPipelineState:v109];
            }
          }
        }

        if (v105[19]) {
          uint64_t v110 = v46 + v161;
        }
        else {
          uint64_t v110 = 0LL;
        }
        if (!v105[10])
        {
          uint64_t v131 = v46;
          uint64_t v135 = v44;
          uint64_t v144 = v45;
          uint64_t v111 = v154;
          uint64_t v112 = v105[18];
          id v113 = v48;
          id v114 = v146;
          if (v112)
          {
            uint64_t v115 = 0LL;
            uint64_t v116 = v44 + v111;
            do
            {
              uint64_t v117 = *(void *)(v116 + 8 * v115);
              if (v117)
              {
                int v118 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a6 + 24LL),  *(int *)(*(void *)a6 + 12LL),  *(void *)(v116 + 8 * v115));
                if (v118)
                {
                  uint64_t v119 = v117 - *v118;
                  uint64_t v120 = v118[2];
                }

                else
                {
                  uint64_t v119 = 0LL;
                  uint64_t v120 = 0LL;
                }

                id v121 = GetObjectForKey(v114, v120);
                uint64_t v122 = (void *)objc_claimAutoreleasedReturnValue(v121);
                if (v122)
                {
                  if (v110) {
                    [v113 setVertexBuffer:v122 offset:v119 attributeStride:*(void *)(v110 + 8 * v115) atIndex:v115];
                  }
                  else {
                    [v113 setVertexBuffer:v122 offset:v119 atIndex:v115];
                  }
                }
              }

              ++v115;
            }

            while (v112 != v115);
          }

          uint64_t v46 = v131;
          GTMTLEncodeIndirectBufferBindings(v113, v131 + v155, v105[12], 2LL, a6, v114);
          GTMTLEncodeIndirectBufferBindings(v113, v131 + v156, v105[16], 8LL, a6, v114);
          GTMTLEncodeIndirectBufferBindings(v113, v131 + v157, v105[15], 16LL, a6, v114);
          uint64_t v43 = v128;
          uint64_t v44 = v135;
          id v45 = v144;
        }

        if (v105[17])
        {
          unint64_t v123 = 0LL;
          uint64_t v124 = v44 + v159;
          do
          {
            [v48 setObjectThreadgroupMemoryLength:*(void *)(v124 + 8 * v123) atIndex:v123];
            ++v123;
          }

          while (v123 < v105[17]);
        }

        if (v105[21] && *(void *)(v46 + v162)) {
          [v48 setBarrier];
        }
LABEL_112:

        objc_autoreleasePoolPop(v45);
        a2 = v149 + 1;
        v44 += v43;
      }

      while (v149 + 1 != v139);
    }

    uint64_t v42 = v141;
LABEL_114:

    id v12 = v125;
    id v11 = v126;
    goto LABEL_115;
  }

  if ((v13 & 0xFFFFFF9F) == 0)
  {
    id v126 = v11;
    id v142 = v11;
    id v125 = v12;
    id v14 = v12;
    uint64_t v140 = a2 + a3;
    if (a2 < a2 + a3)
    {
      uint64_t v15 = v164;
      uint64_t v132 = v163;
      __int128 v16 = v151;
      uint64_t v127 = v153;
      uint64_t v129 = v163 + 72;
      uint64_t v136 = v161;
      uint64_t v138 = v152;
      uint64_t v17 = a5 + v158 + a2 * v164;
      uint64_t v18 = a5 + v160 + a2 * v164;
      while (1)
      {
        uint64_t v19 = objc_autoreleasePoolPush();
        uint64_t v20 = a5 + v15 * a2;
        uint64_t v21 = *(void *)(v20 + v138);
        unint64_t v148 = a2;
        __int128 v22 = (void *)objc_claimAutoreleasedReturnValue([v142 indirectComputeCommandAtIndex:a2]);
        uint64_t v23 = v22;
        if (v21 == 64) {
          break;
        }
        if (v21 == 32)
        {
          uint64_t v24 = *(void *)(v20 + v129 + 16);
          __int128 v176 = *(_OWORD *)(v20 + v129);
          uint64_t v177 = v24;
          uint64_t v25 = *(void *)(v20 + v129 + 40);
          __int128 v174 = *(_OWORD *)(v20 + v129 + 24);
          uint64_t v175 = v25;
          [v22 concurrentDispatchThreadgroups:&v176 threadsPerThreadgroup:&v174];
          goto LABEL_11;
        }

        if (v21) {
          goto LABEL_13;
        }
        [v22 reset];
LABEL_33:

        objc_autoreleasePoolPop(v19);
        a2 = v148 + 1;
        v17 += v15;
        v18 += v15;
        if (v148 + 1 == v140) {
          goto LABEL_34;
        }
      }

      uint64_t v26 = *(void *)(v20 + v129 + 16);
      __int128 v169 = *(_OWORD *)(v20 + v129);
      uint64_t v170 = v26;
      uint64_t v27 = *(void *)(v20 + v129 + 40);
      __int128 v167 = *(_OWORD *)(v20 + v129 + 24);
      uint64_t v168 = v27;
      [v22 concurrentDispatchThreads:&v169 threadsPerThreadgroup:&v167];
LABEL_11:
      __int128 v28 = *(_OWORD *)(v20 + v132 + 16);
      __int128 v171 = *(_OWORD *)(v20 + v132);
      __int128 v172 = v28;
      __int128 v173 = *(_OWORD *)(v20 + v132 + 32);
      [v23 setStageInRegion:&v171];
      if (*(_BYTE *)(v20 + v132 + 64)) {
        [v23 setBarrier];
      }
LABEL_13:
      uint64_t v145 = v19;
      if (!v16[11])
      {
        uint64_t v29 = GTMTLIndirectResources_computePipelineIdForUniqueIdentifier(a6, *(void *)(v20 + v127));
        id v30 = GetObjectForKey(v14, v29);
        int v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
        [v23 setComputePipelineState:v31];
      }

      if (v16[19]) {
        uint64_t v32 = v20 + v136;
      }
      else {
        uint64_t v32 = 0LL;
      }
      if (!v16[10])
      {
        unsigned __int8 v33 = v16[13];
        if (v33)
        {
          for (unint64_t i = 0LL; i < v33; ++i)
          {
            uint64_t v35 = *(void *)(v17 + 8 * i);
            if (v35)
            {
              uint64_t v36 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a6 + 24LL),  *(int *)(*(void *)a6 + 12LL),  *(void *)(v17 + 8 * i));
              if (v36)
              {
                uint64_t v37 = v35 - *v36;
                uint64_t v38 = v36[2];
              }

              else
              {
                uint64_t v37 = 0LL;
                uint64_t v38 = 0LL;
              }

              id v39 = GetObjectForKey(v14, v38);
              id v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
              if (v32) {
                [v23 setKernelBuffer:v40 offset:v37 attributeStride:*(void *)(v32 + 8 * i) atIndex:i];
              }
              else {
                [v23 setKernelBuffer:v40 offset:v37 atIndex:i];
              }

              unsigned __int8 v33 = v16[13];
            }
          }
        }
      }

      uint64_t v19 = v145;
      if (v16[14])
      {
        unint64_t v41 = 0LL;
        do
        {
          [v23 setThreadgroupMemoryLength:*(void *)(v18 + 8 * v41) atIndex:v41];
          ++v41;
        }

        while (v41 < v16[14]);
      }

      goto LABEL_33;
    }

LABEL_34:
    uint64_t v42 = v142;
    goto LABEL_114;
  }

    uint64_t v49 = atomic_load((unsigned int *)(v13 + 4));
    uint64_t v50 = v18 + (v49 >> 6);
    uint64_t v51 = (HIDWORD(v18) + 1);
    uint64_t v18 = (v51 << 32) | v18;
    if ((_DWORD)v51 == v50 - 1)
    {
      uint64_t v18 = (v51 << 32) | v51;
      int v13 = *(void *)(v13 + 40);
      goto LABEL_7;
    }
  }

  apr_pool_destroy(p);
  uint64_t v52 = apr_palloc(v54, 0x18uLL);
  v52[2] = v61;
  double result = *(double *)&v60;
  *(_OWORD *)uint64_t v52 = v60;
  return result;
}

      if (*(void *)v16 >= *(void *)(a1 + 16) + *(void *)(a1 + 8))
      {
LABEL_53:
        uint64_t v38 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xD0uLL);
        *uint64_t v38 = v60;
        id v39 = v64;
        unint64_t v41 = v61;
        id v40 = v62;
        v38[3] = v63;
        v38[4] = v39;
        v38[1] = v41;
        v38[2] = v40;
        uint64_t v42 = v68;
        uint64_t v44 = v65;
        uint64_t v43 = v66;
        v38[7] = v67;
        v38[8] = v42;
        v38[5] = v44;
        v38[6] = v43;
        id v45 = v72;
        unint64_t v47 = v69;
        uint64_t v46 = v70;
        v38[11] = v71;
        v38[12] = v45;
        v38[9] = v47;
        v38[10] = v46;
        uint64_t v48 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v38 + 8, 8uLL, 0LL);
        if (v48) {
          uint64_t v48 = *(void *)(v48 + 32);
        }
        *((void *)v38 + 4) = v48;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v38 + 8, 8LL, v38);
        uint64_t v49 = -1LL;
        goto LABEL_56;
      }

      uint64_t v23 = *(_DWORD *)(v16 + 8);
      if (v23 == -10154 || v23 == -10158) {
        uint64_t v24 = (char *)*((void *)GTTraceFunc_argumentBytesWithMap( (void *)v16,  *(unsigned __int8 *)(v16 + 13),  *(void *)(a1 + 40))
      }
                      + 1);
      else {
        uint64_t v24 = GTTraceFunc_targetContext(v16, *(void *)(a1 + 40));
      }
    }

    while (v24 != *((char **)&v60 + 1));
    uint64_t v25 = *(_DWORD *)(v16 + 8);
    if (v25 > -15553)
    {
      if (v25 != -15552 && v25 != -10154 && v25 != -10158) {
        goto LABEL_52;
      }
      goto LABEL_48;
    }

      uint64_t v7 = apr_hash_next(v7);
    }

    while (v7);
  }

  pthread_mutex_unlock((pthread_mutex_t *)a1);
  for (unint64_t i = 0LL; i != 16; ++i)
  {
    id v30 = (void *)(a1 + 24 * i + 128);
    if (*((void *)&v36 + 1))
    {
      int v31 = atomic_load((unsigned int *)(a1 + 24 * i + 144));
      do
        uint64_t v32 = __ldaxr(v37);
      while (__stlxr(v32 + v31, v37));
      unsigned __int8 v33 = atomic_load((unsigned int *)(a1 + 24 * i + 148));
      do
        int v34 = __ldaxr(&v37[1]);
      while (__stlxr(v34 + v33, &v37[1]));
      *(void *)(*((void *)&v36 + 1) + 4apr_pool_create_ex(&newpool, parent, 0LL, 0LL) = *v30;
      if (*(void *)(a1 + 24 * i + 136)) {
        *((void *)&v36 + 1) = *(void *)(a1 + 24 * i + 136);
      }
    }

    else
    {
      uint64_t v36 = *(_OWORD *)v30;
      *(void *)uint64_t v37 = *(void *)(a1 + 24 * i + 144);
    }

    *id v30 = 0LL;
    *(void *)(a1 + 24 * i + 136) = 0LL;
    *(void *)(a1 + 24 * i + 144) = 0LL;
  }

  GTTraceStoreFreeNodes(*(void *)(a1 + 64), (unsigned int *)v36);
  return v4;
}

LABEL_115:
}

void GTMTLEncodeIndirectBufferBindings(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v19 = a1;
  id v11 = a6;
  if (a3)
  {
    uint64_t v12 = 0LL;
    do
    {
      uint64_t v13 = *(void *)(a2 + 8 * v12);
      if (v13)
      {
        id v14 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a5 + 24LL),  *(int *)(*(void *)a5 + 12LL),  *(void *)(a2 + 8 * v12));
        if (v14)
        {
          uint64_t v15 = v13 - *v14;
          uint64_t v16 = v14[2];
        }

        else
        {
          uint64_t v15 = 0LL;
          uint64_t v16 = 0LL;
        }

        id ObjectForKey = GetObjectForKey(v11, v16);
        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(ObjectForKey);
        if (v18)
        {
          switch(a4)
          {
            case 16LL:
              [v19 setMeshBuffer:v18 offset:v15 atIndex:v12];
              break;
            case 8LL:
              [v19 setObjectBuffer:v18 offset:v15 atIndex:v12];
              break;
            case 2LL:
              [v19 setFragmentBuffer:v18 offset:v15 atIndex:v12];
              break;
          }
        }
      }

      ++v12;
    }

    while (a3 != v12);
  }
}

uint64_t GTMTLCaptureStatistics_begin(uint64_t result)
{
  switch(*(_DWORD *)(result + 80))
  {
    case 0:
    case 1:
      goto LABEL_4;
    case 2:
    case 3:
      goto LABEL_2;
    case 4:
      uint64_t v1 = *(void *)result;
      if (*(void *)result) {
        goto LABEL_5;
      }
LABEL_2:
      result += 8LL;
LABEL_4:
      uint64_t v1 = *(void *)result;
LABEL_5:
      g_targetRef = v1;
      atomic_store(0LL, &g_frameCount);
      atomic_store(0LL, &g_frameOther);
      atomic_store(0LL, &g_commitCount);
      atomic_store(0LL, &g_commitOther);
      atomic_store(0LL, &g_resourceCount);
      atomic_store(0LL, &g_resourceDownloaded);
      atomic_store(0LL, &g_GPUDataSize);
      atomic_store(0LL, &g_GPUDataDownloaded);
      return result;
    case 5:
    case 6:
      result += 24LL;
      goto LABEL_4;
    default:
      uint64_t v1 = 0LL;
      goto LABEL_5;
  }

void GTMTLCaptureStatistics_end()
{
  g_targetRef = 0LL;
}

uint64_t GTMTLCaptureStatistics_trackPresent(uint64_t result)
{
  if (g_targetRef == result) {
    uint64_t v1 = &g_frameCount;
  }
  else {
    uint64_t v1 = &g_frameOther;
  }
  do
    unint64_t v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return result;
}

uint64_t GTMTLCaptureStatistics_trackCommit(uint64_t result, uint64_t a2)
{
  BOOL v2 = g_targetRef == result || g_targetRef == a2;
  id v3 = &g_commitOther;
  if (v2) {
    id v3 = &g_commitCount;
  }
  do
    unint64_t v4 = __ldaxr(v3);
  while (__stlxr(v4 + 1, v3));
  return result;
}

uint64_t GTMTLCaptureStatistics_trackResources(uint64_t result)
{
  do
    unint64_t v1 = __ldaxr(&g_resourceCount);
  while (__stlxr(v1 + result, &g_resourceCount));
  return result;
}

uint64_t GTMTLCaptureStatistics_trackResourcesDownloaded(uint64_t result)
{
  do
    unint64_t v1 = __ldaxr(&g_resourceDownloaded);
  while (__stlxr(v1 + result, &g_resourceDownloaded));
  return result;
}

uint64_t GTMTLCaptureStatistics_trackGPUData(uint64_t result)
{
  do
    unint64_t v1 = __ldaxr(&g_GPUDataSize);
  while (__stlxr(v1 + result, &g_GPUDataSize));
  return result;
}

uint64_t GTMTLCaptureStatistics_trackGPUDataDownloaded(uint64_t result)
{
  do
    unint64_t v1 = __ldaxr(&g_GPUDataDownloaded);
  while (__stlxr(v1 + result, &g_GPUDataDownloaded));
  return result;
}

void GTMTLCaptureStatistics_stats(unint64_t *a1@<X8>)
{
  unint64_t v1 = atomic_load(&g_frameCount);
  unint64_t v2 = atomic_load(&g_frameOther);
  *a1 = v1;
  a1[1] = v2;
  unint64_t v3 = atomic_load(&g_commitCount);
  unint64_t v4 = atomic_load(&g_commitOther);
  a1[2] = v3;
  a1[3] = v4;
  unint64_t v5 = atomic_load(&g_resourceCount);
  unint64_t v6 = atomic_load(&g_resourceDownloaded);
  a1[4] = v5;
  a1[5] = v6;
  unint64_t v7 = atomic_load(&g_GPUDataSize);
  unint64_t v8 = atomic_load(&g_GPUDataDownloaded);
  a1[6] = v7;
  a1[7] = v8;
}

LABEL_22:
  return v8;
}

        uint64_t v15 = v8;
        uint64_t v16 = 22LL;
        return GTResourceTrackerUsingResource(v15, v16, v14, a4, a5);
      }

      uint64_t v18 = 0u;
      id v19 = 0LL;
      id v30 = 0u;
      int v31 = 0u;
      __int128 v28 = 0u;
      uint64_t v29 = 0u;
      uint64_t v27 = 0u;
      uint64_t v25 = 0u;
      uint64_t v26 = 0u;
      uint64_t v24 = 0u;
      uint64_t v21 = 0u;
      __int128 v22 = 0u;
      LODWORD(v1_Block_object_dispose(va, 8) = 16;
      uint64_t v20 = -1LL;
      WORD1(v25) = 2;
      uint64_t v23 = 0xFFFFFFFFFFFFFFFFLL;
      double result = (uint64_t)GTMTLSMAccelerationStructure_processTraceFuncWithMap((char *)&v18, a5, (uint64_t *)v13);
      if ((void)v22) {
        double result = GTResourceTrackerUsingResource(v8, 50LL, v22, a4, a5);
      }
      id v14 = v28;
      if ((void)v28) {
        goto LABEL_22;
      }
    }
  }

  return result;
}

id LoadDynamicLibrariesForTileRenderPipelineDescriptor(void *a1)
{
  id v1 = deviceMTLTileRenderPipelineDescriptor(a1);
  unint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 tileFunction]);
  id v4 = DEVICEOBJECT(v3);
  unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);

  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 device]);
  unint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableOrderedSet);
  unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v2 preloadedLibraries]);
  LoadDynamicLibrariesForFunction(v6, v5, v8, v7);
  if ((objc_opt_respondsToSelector(v2, "linkedFunctions") & 1) != 0)
  {
    __int128 v9 = (void *)objc_claimAutoreleasedReturnValue([v2 linkedFunctions]);
    LoadDynamicLibrariesForLinkedFunctions(v6, v9, v8, v7);
  }

  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableOrderedSet array](v7, "array"));

  return v10;
}

void LoadDynamicLibrariesForFunction(void *a1, void *a2, void *a3, void *a4)
{
  id v11 = a1;
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v7
    && (objc_opt_respondsToSelector(v11, "loadDynamicLibrariesForFunction:insertLibraries:error:") & 1) != 0
    && (objc_opt_respondsToSelector(v11, "loadDynamicLibrariesForFunction:insertLibraries:error:") & 1) != 0)
  {
    id v10 = [v11 loadDynamicLibrariesForFunction:v7 insertLibraries:v8 error:0];
    [v9 addObjectsFromArray:v10];
  }
}

void LoadDynamicLibrariesForLinkedFunctions(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  id v11 = (void *)objc_claimAutoreleasedReturnValue([v8 functions]);
  id v12 = [v11 countByEnumeratingWithState:&v34 objects:v40 count:16];
  if (v12)
  {
    id v13 = v12;
    uint64_t v14 = *(void *)v35;
    do
    {
      uint64_t v15 = 0LL;
      do
      {
        if (*(void *)v35 != v14) {
          objc_enumerationMutation(v11);
        }
        LoadDynamicLibrariesForFunction(v7, *(void **)(*((void *)&v34 + 1) + 8LL * (void)v15), v9, v10);
        uint64_t v15 = (char *)v15 + 1;
      }

      while (v13 != v15);
      id v13 = [v11 countByEnumeratingWithState:&v34 objects:v40 count:16];
    }

    while (v13);
  }

  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v8 binaryFunctions]);
  id v17 = [v16 countByEnumeratingWithState:&v30 objects:v39 count:16];
  if (v17)
  {
    id v18 = v17;
    uint64_t v19 = *(void *)v31;
    do
    {
      uint64_t v20 = 0LL;
      do
      {
        if (*(void *)v31 != v19) {
          objc_enumerationMutation(v16);
        }
        LoadDynamicLibrariesForFunction(v7, *(void **)(*((void *)&v30 + 1) + 8LL * (void)v20), v9, v10);
        uint64_t v20 = (char *)v20 + 1;
      }

      while (v18 != v20);
      id v18 = [v16 countByEnumeratingWithState:&v30 objects:v39 count:16];
    }

    while (v18);
  }

  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "privateFunctions", 0));
  id v22 = [v21 countByEnumeratingWithState:&v26 objects:v38 count:16];
  if (v22)
  {
    id v23 = v22;
    uint64_t v24 = *(void *)v27;
    do
    {
      uint64_t v25 = 0LL;
      do
      {
        if (*(void *)v27 != v24) {
          objc_enumerationMutation(v21);
        }
        LoadDynamicLibrariesForFunction(v7, *(void **)(*((void *)&v26 + 1) + 8LL * (void)v25), v9, v10);
        uint64_t v25 = (char *)v25 + 1;
      }

      while (v23 != v25);
      id v23 = [v21 countByEnumeratingWithState:&v26 objects:v38 count:16];
    }

    while (v23);
  }
}

id LoadDynamicLibrariesForRenderPipelineDescriptor(void *a1)
{
  id v1 = deviceMTLRenderPipelineDescriptor(a1);
  unint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 vertexFunction]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v2 fragmentFunction]);
  unint64_t v5 = v4;
  if (v3) {
    id v4 = v3;
  }
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 device]);
  id v7 = objc_alloc_init(&OBJC_CLASS___NSMutableOrderedSet);
  if ((objc_opt_respondsToSelector(v2, "vertexPreloadedLibraries") & 1) != 0) {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v2 vertexPreloadedLibraries]);
  }
  else {
    id v8 = 0LL;
  }
  if ((objc_opt_respondsToSelector(v2, "fragmentPreloadedLibraries") & 1) != 0) {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v2 fragmentPreloadedLibraries]);
  }
  else {
    id v9 = 0LL;
  }
  LoadDynamicLibrariesForFunction(v6, v3, v8, v7);
  LoadDynamicLibrariesForFunction(v6, v5, v9, v7);
  if ((objc_opt_respondsToSelector(v2, "vertexLinkedFunctions") & 1) != 0)
  {
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v2 vertexLinkedFunctions]);
    LoadDynamicLibrariesForLinkedFunctions(v6, v10, v8, v7);
  }

  if ((objc_opt_respondsToSelector(v2, "fragmentLinkedFunctions") & 1) != 0)
  {
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v2 fragmentLinkedFunctions]);
    LoadDynamicLibrariesForLinkedFunctions(v6, v11, v9, v7);
  }

  id v12 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableOrderedSet array](v7, "array"));

  return v12;
}

void CaptureMTLDevice_initIndirectCommandBufferCopy(void *a1)
{
  id v1 = a1;
  unint64_t v2 = v1 + 6;
  dispatch_once_t v3 = v1[6];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __CaptureMTLDevice_initIndirectCommandBufferCopy_block_invoke;
  block[3] = &unk_20E0C8;
  id v8 = v1;
  id v4 = v1;
  unint64_t v6 = v4;
  if (v3 == -1)
  {
    unint64_t v5 = v4;
  }

  else
  {
    dispatch_once(v2, block);
    unint64_t v5 = v8;
  }
}

void WaitForDevice(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void **)(GTTraceContext_getStream(a1, a2) + 16);
  id v3 = v2;
  if (v2)
  {
    id v4 = (os_log_s *)g_signpostLog;
    if (os_signpost_enabled((os_log_t)g_signpostLog))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl( &dword_0,  v4,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Capture-WaitForDevice",  "",  buf,  2u);
    }

    unint64_t v5 = (dispatch_group_s *)objc_claimAutoreleasedReturnValue([v3 dispatchGroup]);
    dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);

    unint64_t v6 = (os_log_s *)g_signpostLog;
    if (os_signpost_enabled((os_log_t)g_signpostLog))
    {
      *(_WORD *)id v7 = 0;
      _os_signpost_emit_with_name_impl( &dword_0,  v6,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Capture-WaitForDevice",  "",  v7,  2u);
    }
  }
}

void DownloadFromDevice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a2;
  id v5 = *(id *)(*(void *)(*find_entry(a1, &v6, 8uLL, 0LL) + 32LL) + 16LL);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v5 downloader]);
  [v4 downloadRequest:a3];
}

void CaptureMTLBuffer_registerBaseBufferForTracing(void *a1, uint64_t a2, int a3)
{
  id v11 = a1;
  if (!ShouldRegisterBufferForTracing(v11))
  {
    uint64_t v6 = v11;
    if (!a2) {
      goto LABEL_11;
    }
    id v7 = (unint64_t *)(a2 + 56);
    unint64_t v8 = atomic_load((unint64_t *)(a2 + 56));
    while (1)
    {
      unint64_t v9 = __ldaxr(v7);
      if (v9 != v8) {
        break;
      }
      if (__stlxr(v8 | 8, v7)) {
        goto LABEL_9;
      }
      int v10 = 1;
LABEL_10:
      unint64_t v8 = v9;
      if (v10) {
        goto LABEL_11;
      }
    }

    __clrex();
LABEL_9:
    int v10 = 0;
    goto LABEL_10;
  }

  id v5 = v11;
  GTMemoryGuard_registerRegion( (unint64_t)[v5 contents],  (vm_size_t)objc_msgSend(v5, "length"),  a2,  a3);
  uint64_t v6 = v11;
LABEL_11:
}

BOOL ShouldRegisterBufferForTracing(void *a1)
{
  id v1 = a1;
  unint64_t v2 = v1;
  if ((qword_23A448 & 0x1000) != 0 && [v1 storageMode] != (char *)&dword_0 + 2)
  {
    id v4 = (void *)objc_claimAutoreleasedReturnValue([v2 heap]);
    BOOL v3 = v4 == 0LL;
  }

  else
  {
    BOOL v3 = 0LL;
  }

  return v3;
}

void CaptureMTLBuffer_registerForTracing(uint64_t a1, int a2)
{
  if (a1) {
    CaptureMTLBuffer_registerBaseBufferForTracing(*(void **)(a1 + 8), *(void *)(a1 + 48), a2);
  }
}

uint64_t GTMTLCaptureEnvironment_init()
{
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFFFELL | GetEnvDefault("MTLCAPTURE_PRESENT_DOWNLOAD", 0LL) & 1;
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFFFDLL | (2 * (GetEnvDefault("MTLCAPTURE_LOG_ERRORS", 0LL) & 1));
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFFDFLL | (32 * (GetEnvDefault("MTLCAPTURE_HASH_DUPLICATE_FILES", 1LL) & 1));
  GT_ENV = GetEnvDefault("MTLCAPTURE_WAIT_EVENT_TIMEOUT", 90LL);
  qword_23A438 = GetEnvDefault("MTLCAPTURE_MAX_DOWNLOAD_COMMAND_BUFFERS", 512LL);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFF7FFLL | ((GetEnvDefault( "MTLCAPTURE_DESTINATION_DEVELOPER_TOOLS_ENABLE",  0LL) & 1) << 11);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFFBFLL | ((GetEnvDefault("MTLCAPTURE_WAIT_FOR_SIGNAL", 0LL) & 1) << 6);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFEFFLL | ((GetEnvDefault("MTLCAPTURE_NO_METALFX_CAPTURE", 0LL) & 1) << 8);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFDFFLL | ((GetEnvDefault( "MTLCAPTURE_DISABLE_HEAP_TEXTURE_COMPRESSION",  0LL) & 1) << 9);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFFFBLL | (4 * (GetEnvDefault("MTLCAPTURE_CAPTURE_ADS_BUFFER_SPI", 0LL) & 1));
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFFEFLL | (16 * (GetEnvDefault("MTLCAPTURE_ADS_EXTRA_BUFFERS", 0LL) & 1));
  qword_23A438 = GetEnvDefault("MTLCAPTURE_MAX_DOWNLOAD_COMMAND_BUFFERS", 512LL);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFFF7LL | (8
                                                      * (GetEnvDefault("MTLCAPTURE_FORCE_RAYTRACING_ENABLE", 0LL) & 1));
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFF7FLL | ((GetEnvDefault("MTLCAPTURE_IS_COMPOSITOR", 0LL) & 1) << 7);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFFBFFLL | ((GetEnvDefault("MTLCAPTURE_ENABLE_DOWNLOADS_AT_EVENTS", 0LL) & 1) << 10);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFEFFFLL | ((GetEnvDefault("MTLCAPTURE_ENABLE_MPROTECT", 0LL) & 1) << 12);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFDFFFLL | ((GetEnvDefault( "MTLCAPTURE_ENABLE_MPROTECT_BUFFER_SPLITTING",  0LL) & 1) << 13);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFFBFFFLL | ((GetEnvDefault("MTLCAPTURE_DISABLE_HEAPS", 0LL) & 1) << 14);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFF7FFFLL | ((GetEnvDefault("MTLCAPTURE_DISABLE_PLACEMENT_HEAPS", 0LL) & 1) << 15);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFEFFFFLL | ((GetEnvDefault( "MTLCAPTURE_FORCE_WAIT_UNTIL_COMPLETED_ON_COMMIT",  0LL) & 1) << 16);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFDFFFFLL | ((GetEnvDefault("MTLCAPTURE_REDIRECT_LOGGING_TO_STREAMS", 0LL) & 1) << 17);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFFBFFFFLL | ((GetEnvDefault("MTLCAPTURE_WITH_F12", 0LL) & 1) << 18);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFF7FFFFLL | ((GetEnvDefault("MTLCAPTURE_SUPPORT_SUPERSEDING_LAYERS", 0LL) & 1) << 19);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFEFFFFFLL | ((GetEnvDefault( "MTLCAPTURE_DOWNLOADER_ENHANCED_COMMAND_BUFFER_ERRORS",  0LL) & 1) << 20);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFDFFFFFLL | ((GetEnvDefault( "MTLCAPTURE_DOWNLOADER_FORCE_SPLIT_COMMAND_ENCODERS",  0LL) & 1) << 21);
  uint64_t result = GetEnvDefault("MTLCAPTURE_ENABLE_DOWNLOADER_FULL_HEAPS", 0LL);
  qword_23A448 = qword_23A448 & 0xFFFFFFFFFFBFFFFFLL | ((unint64_t)(result & 1) << 22);
  return result;
}

uint64_t GetEnvDefault(const char *a1, uint64_t a2)
{
  BOOL v3 = getenv(a1);
  if (v3) {
    return strtol(v3, 0LL, 0);
  }
  else {
    return a2;
  }
}

LABEL_9:
  id v12 = (unint64_t *)[v6 traceStream];
  if (v12)
  {
    id v13 = v12 + 7;
    uint64_t v14 = atomic_load(v12 + 7);
    while (1)
    {
      uint64_t v15 = __ldaxr(v13);
      if (v15 != v14) {
        break;
      }
      if (__stlxr(v14 | 8, v13)) {
        goto LABEL_15;
      }
      uint64_t v16 = 1;
LABEL_16:
      uint64_t v14 = v15;
      if (v16) {
        goto LABEL_17;
      }
    }

    __clrex();
LABEL_15:
    uint64_t v16 = 0;
    goto LABEL_16;
  }

  return a3;
}

  pthread_mutex_unlock(&tracingMutex);
  if (!oldArraySize) {
    return 5LL;
  }
  task_set_exception_ports(mach_task_self_, oldExcMasks, oldExcPorts, oldBehaviors, oldFlavors);
  return 0LL;
}

  uint64_t v19 = (unint64_t *)[v13 traceStream];
  if (v19)
  {
    uint64_t v20 = v19 + 7;
    uint64_t v21 = atomic_load(v19 + 7);
    while (1)
    {
      id v22 = __ldaxr(v20);
      if (v22 != v21) {
        break;
      }
      if (__stlxr(v21 | 8, v20)) {
        goto LABEL_15;
      }
      id v23 = 1;
LABEL_16:
      uint64_t v21 = v22;
      if (v23) {
        goto LABEL_17;
      }
    }

    __clrex();
LABEL_15:
    id v23 = 0;
    goto LABEL_16;
  }

  baseObject = self->_baseObject;
  uint64_t v21 = *(_OWORD *)&a3->var0.var2;
  uint64_t v38 = *(_OWORD *)&a3->var0.var0;
  id v39 = v21;
  id v40 = *(_OWORD *)&a3->var1.var1;
  -[MTLTextureSPI replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:]( baseObject,  "replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:",  &v38,  a4,  a5,  a6,  a7,  a8);
  if ((*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) == 2)
  {
    id v22 = DEVICEOBJECT(self);
    id v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
    uint64_t v38 = *(_OWORD *)&a3->var1.var0;
    *(void *)&id v39 = a3->var1.var2;
    ClientMemorySize = (const void *)GetClientMemorySize(v23, (uint64_t)&v38, a7, a8);

    GTTraceContext_pushEncoderWithStream((uint64_t)self->_traceContext, (uint64_t)&v38);
    uint64_t v24 = v39;
    *(_DWORD *)(v39 + _Block_object_dispose(va, 8) = -16236;
    uint64_t v25 = *(void *)(*((void *)&v38 + 1) + 24LL);
    __int128 v26 = BYTE10(v40);
    ++BYTE10(v40);
    Bytes = GTTraceMemPool_allocateBytes(v25, *((uint64_t *)&v39 + 1), v26 | 0x6800000000LL);
    *(_BYTE *)(v24 + 13) = v26;
    __int128 v28 = -[CaptureMTLTexture traceStream](self, "traceStream");
    if (v28) {
      var0 = v28->var0;
    }
    else {
      var0 = 0LL;
    }
    var2 = a3->var0.var2;
    __int128 v35 = *(_OWORD *)&a3->var1.var0;
    __int128 v36 = *(_OWORD *)&a3->var0.var0;
    __int128 v31 = a3->var1.var2;
    __int128 v32 = TransferBytes((uint64_t)&v38, (uint64_t *)a6, ClientMemorySize);
    *((void *)Bytes + 2) = var0;
    *(_OWORD *)(Bytes + 24) = v36;
    *((void *)Bytes + 5) = var2;
    *((_OWORD *)Bytes + 3) = v35;
    *((void *)Bytes + _Block_object_dispose(va, 8) = v31;
    *((void *)Bytes + 9) = a4;
    *((void *)Bytes + 10) = a5;
    *((void *)Bytes + 11) = a7;
    *((void *)Bytes + 12) = a8;
    *((void *)Bytes + 13) = 0LL;
    Bytes[112] = v32;
    *(_DWORD *)(Bytes + 113) = 0;
    *((_DWORD *)Bytes + 29) = 0;
    s();
    *(void *)__int128 v33 = v34;
    *(_BYTE *)(v33 + _Block_object_dispose(va, 8) = BYTE8(v40);
    *(_BYTE *)(v39 + 15) |= 8u;
  }

  baseObject = self->_baseObject;
  id v17 = *(_OWORD *)&a3->var0.var2;
  __int128 v34 = *(_OWORD *)&a3->var0.var0;
  __int128 v35 = v17;
  __int128 v36 = *(_OWORD *)&a3->var1.var1;
  -[MTLTextureSPI replaceRegion:mipmapLevel:withBytes:bytesPerRow:]( baseObject,  "replaceRegion:mipmapLevel:withBytes:bytesPerRow:",  &v34,  a4,  a5,  a6);
  if ((*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) == 2)
  {
    id v18 = DEVICEOBJECT(self);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
    __int128 v34 = *(_OWORD *)&a3->var1.var0;
    *(void *)&__int128 v35 = a3->var1.var2;
    ClientMemorySize = (const void *)GetClientMemorySize(v19, (uint64_t)&v34, a6, 0LL);

    GTTraceContext_pushEncoderWithStream((uint64_t)self->_traceContext, (uint64_t)&v34);
    uint64_t v21 = v35;
    *(_DWORD *)(v35 + _Block_object_dispose(va, 8) = -16234;
    id v22 = *(void *)(*((void *)&v34 + 1) + 24LL);
    id v23 = BYTE10(v36);
    ++BYTE10(v36);
    Bytes = GTTraceMemPool_allocateBytes(v22, *((uint64_t *)&v35 + 1), v23 | 0x5000000000LL);
    *(_BYTE *)(v21 + 13) = v23;
    uint64_t v25 = -[CaptureMTLTexture traceStream](self, "traceStream");
    if (v25) {
      var0 = v25->var0;
    }
    else {
      var0 = 0LL;
    }
    var2 = a3->var0.var2;
    __int128 v32 = *(_OWORD *)&a3->var1.var0;
    __int128 v33 = *(_OWORD *)&a3->var0.var0;
    __int128 v28 = a3->var1.var2;
    __int128 v29 = TransferBytes((uint64_t)&v34, (uint64_t *)a5, ClientMemorySize);
    *((void *)Bytes + 2) = var0;
    *(_OWORD *)(Bytes + 24) = v33;
    *((void *)Bytes + 5) = var2;
    *((_OWORD *)Bytes + 3) = v32;
    *((void *)Bytes + _Block_object_dispose(va, 8) = v28;
    *((void *)Bytes + 9) = a4;
    *((void *)Bytes + 10) = a6;
    Bytes[88] = v29;
    *(_DWORD *)(Bytes + 89) = 0;
    *((_DWORD *)Bytes + 23) = 0;
    s();
    *(void *)__int128 v30 = v31;
    *(_BYTE *)(v30 + _Block_object_dispose(va, 8) = BYTE8(v36);
    *(_BYTE *)(v35 + 15) |= 8u;
  }

  baseObject = self->_baseObject;
  uint64_t v21 = *(_OWORD *)&a6->var0.var2;
  __int128 v35 = *(_OWORD *)&a6->var0.var0;
  __int128 v36 = v21;
  __int128 v37 = *(_OWORD *)&a6->var1.var1;
  -[MTLTextureSPI getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:]( baseObject,  "getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:",  a3,  a4,  a5,  &v35,  a7,  a8);
  if ((*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) == 2)
  {
    GTTraceContext_pushEncoderWithStream((uint64_t)self->_traceContext, (uint64_t)&v35);
    id v22 = v36;
    *(_DWORD *)(v36 + _Block_object_dispose(va, 8) = -16237;
    id v23 = *(void *)(*((void *)&v35 + 1) + 24LL);
    uint64_t v24 = BYTE10(v37);
    ++BYTE10(v37);
    Bytes = GTTraceMemPool_allocateBytes(v23, *((uint64_t *)&v36 + 1), v24 | 0x6000000000LL);
    *(_BYTE *)(v22 + 13) = v24;
    __int128 v26 = -[CaptureMTLTexture traceStream](self, "traceStream");
    if (v26) {
      var0 = v26->var0;
    }
    else {
      var0 = 0LL;
    }
    __int128 v28 = a6->var0.var0;
    __int128 v33 = *(_OWORD *)&a6->var1.var0;
    __int128 v34 = *(_OWORD *)&a6->var0.var1;
    var2 = a6->var1.var2;
    __int128 v30 = TransferBytes((uint64_t)&v35, (uint64_t *)a3, (char *)&dword_0 + 1);
    *((void *)Bytes + 2) = var0;
    *((void *)Bytes + 3) = a4;
    *((void *)Bytes + 4) = a5;
    *((void *)Bytes + 5) = v28;
    *((_OWORD *)Bytes + 3) = v34;
    *((_OWORD *)Bytes + 4) = v33;
    *((void *)Bytes + 10) = var2;
    *((void *)Bytes + 11) = a7;
    *((void *)Bytes + 12) = a8;
    Bytes[104] = v30;
    *(_DWORD *)(Bytes + 105) = 0;
    *((_DWORD *)Bytes + 27) = 0;
    s();
    *(void *)__int128 v31 = v32;
    *(_BYTE *)(v31 + _Block_object_dispose(va, 8) = BYTE8(v37);
    *(_BYTE *)(v36 + 15) |= 8u;
  }

  baseObject = self->_baseObject;
  id v17 = *(_OWORD *)&a5->var0.var2;
  __int128 v32 = *(_OWORD *)&a5->var0.var0;
  __int128 v33 = v17;
  __int128 v34 = *(_OWORD *)&a5->var1.var1;
  -[MTLTextureSPI getBytes:bytesPerRow:fromRegion:mipmapLevel:]( baseObject,  "getBytes:bytesPerRow:fromRegion:mipmapLevel:",  a3,  a4,  &v32,  a6);
  if ((*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) == 2)
  {
    GTTraceContext_pushEncoderWithStream((uint64_t)self->_traceContext, (uint64_t)&v32);
    id v18 = v33;
    *(_DWORD *)(v33 + _Block_object_dispose(va, 8) = -16235;
    uint64_t v19 = *(void *)(*((void *)&v32 + 1) + 24LL);
    uint64_t v20 = BYTE10(v34);
    ++BYTE10(v34);
    Bytes = GTTraceMemPool_allocateBytes(v19, *((uint64_t *)&v33 + 1), v20 | 0x5000000000LL);
    *(_BYTE *)(v18 + 13) = v20;
    id v22 = -[CaptureMTLTexture traceStream](self, "traceStream");
    if (v22) {
      var0 = v22->var0;
    }
    else {
      var0 = 0LL;
    }
    uint64_t v24 = a5->var0.var0;
    var1 = a5->var0.var1;
    __int128 v31 = *(_OWORD *)&a5->var0.var2;
    __int128 v27 = a5->var1.var1;
    var2 = a5->var1.var2;
    __int128 v28 = TransferBytes((uint64_t)&v32, (uint64_t *)a3, (char *)&dword_0 + 1);
    *((void *)Bytes + 2) = var0;
    *((void *)Bytes + 3) = a4;
    *((void *)Bytes + 4) = v24;
    *((void *)Bytes + 5) = var1;
    *((_OWORD *)Bytes + 3) = v31;
    *((void *)Bytes + _Block_object_dispose(va, 8) = v27;
    *((void *)Bytes + 9) = var2;
    *((void *)Bytes + 10) = a6;
    Bytes[88] = v28;
    *(_DWORD *)(Bytes + 89) = 0;
    *((_DWORD *)Bytes + 23) = 0;
    s();
    *(void *)__int128 v29 = v30;
    *(_BYTE *)(v29 + _Block_object_dispose(va, 8) = BYTE8(v34);
    *(_BYTE *)(v33 + 15) |= 8u;
  }

  id v5 = 88LL;
  id v13 = 88LL;
  if ((_DWORD)v4)
  {
    uint64_t v6 = 0LL;
    id v5 = v13;
    id v7 = v14;
    unint64_t v8 = (unsigned __int16 *)(a1 + 28);
    unint64_t v9 = 88LL;
    do
    {
      int v10 = v9 + 8;
      if (v9 + 8 <= a3)
      {
        *(void *)((char *)a2 + v9) = *(v8 - 4);
        int v10 = v5 + 8;
        a3 = v7;
      }

      if (v10 + 8 <= a3)
      {
        *(void *)((char *)a2 + v10) = *(v8 - 3);
        a3 = v7;
      }

      if (v10 + 16 <= a3)
      {
        *(void *)((char *)a2 + v10 + _Block_object_dispose(va, 8) = *(v8 - 2);
        a3 = v7;
      }

      if (v10 + 24 <= a3)
      {
        *(void *)((char *)a2 + v10 + 16) = *((unsigned int *)v8 - 3);
        a3 = v7;
      }

      if (v10 + 32 <= a3)
      {
        *(void *)((char *)a2 + v10 + 24) = *(v8 - 1);
        a3 = v7;
      }

      id v5 = v10 + 40;
      if (v10 + 40 <= a3) {
        *(void *)((char *)a2 + v10 + 32) = *v8;
      }
      ++v6;
      v8 += 8;
      unint64_t v9 = v10 + 40;
    }

    while (v6 < *v3);
    id v13 = v10 + 40;
  }

  if (v5 + 8 <= a3) {
    *(void *)((char *)a2 + v5) = *(unsigned int *)(a1 + 88);
  }
  id v13 = v5 + 8;
  WriteGTData(&v12, *(const void **)(a1 + 104), *(void *)(a1 + 112));
  return v13;
}

void sub_2D53C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

uint64_t IsEventActuallyShared(uint64_t a1)
{
  int v2 = *(_DWORD *)(*(void *)(a1 + 32) + 72LL);
  uint64_t result = 1LL;
  if (v2 <= -15910)
  {
    if (v2 != -15996)
    {
      if (v2 == -15912) {
        return result;
      }
      return 0LL;
    }

LABEL_7:
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_14;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_14:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_15:
    uint64_t v9 = v4 + 64;
    while (v4 && (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) != 0)
    {
      if ((*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 0x40) == 0)
      {
        int v10 = *(_DWORD *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 8);
        if (v10 == -15907 || v10 == -15488) {
          return 1LL;
        }
      }

      unsigned int v12 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v13 = (HIDWORD(v8) + 1);
      int v14 = v8 + (v12 >> 6) - 1;
      unint64_t v8 = (v13 << 32) | v8;
      if ((_DWORD)v13 == v14)
      {
        unint64_t v8 = (v13 << 32) | v13;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_15;
      }
    }

    return 0LL;
  }

  if (v2 != -15909)
  {
    if (v2 != -15496) {
      return 0LL;
    }
    goto LABEL_7;
  }

  return result;
}

  a2[33] += 24LL;
  apr_pool_destroy(v9);
}

  a2[33] += 24LL;
  apr_pool_destroy(v9);
}

  unint64_t v8 = 40LL;
  __int128 v34 = 40LL;
  if ((_DWORD)v7)
  {
    uint64_t v9 = 0LL;
    unint64_t v8 = 40LL;
    do
    {
      int v10 = *a1;
      id v11 = v8 + 8;
      if (v8 + 8 <= v35)
      {
        *(void *)((char *)v33 + v_Block_object_dispose(va, 8) = *(unsigned __int8 *)(v10 + 40 * v9 + 36);
        id v11 = v34 + 8;
      }

      __int128 v34 = v11;
      WriteDynamicBufferString(&v33, *(const char **)(v10 + 40 * v9));
      unsigned int v12 = v10 + 40 * v9;
      uint64_t v15 = *(unsigned __int16 *)(v12 + 32);
      int v14 = (unsigned __int16 *)(v12 + 32);
      uint64_t v13 = v15;
      uint64_t v16 = v34 + 8;
      if (v34 + 8 <= v35)
      {
        *(void *)((char *)v33 + v34) = v13;
        uint64_t v16 = v34 + 8;
        LODWORD(v13) = *v14;
      }

      __int128 v34 = v16;
      if ((_DWORD)v13)
      {
        id v17 = 0LL;
        id v18 = 0LL;
        do
        {
          EncodeDYMTLFunctionStitchingFunctionNode(&v33, (unsigned __int8 *)(*(void *)(v10 + 40 * v9 + 8) + v17));
          ++v18;
          v17 += 48LL;
        }

        while (v18 < *v14);
      }

      uint64_t v19 = *(unsigned __int8 **)(v10 + 40 * v9 + 16);
      if (v19)
      {
        EncodeDYMTLFunctionStitchingFunctionNode(&v33, v19);
        uint64_t v20 = v34;
      }

      else
      {
        uint64_t v20 = v34 + 8;
        if (v34 + 8 <= v35)
        {
          *(void *)((char *)v33 + v34) = 0LL;
          uint64_t v20 = v34 + 8;
        }

        __int128 v34 = v20;
      }

      uint64_t v21 = v10 + 40 * v9;
      uint64_t v24 = *(unsigned __int16 *)(v21 + 34);
      id v22 = (unsigned __int16 *)(v21 + 34);
      id v23 = v24;
      uint64_t v25 = v20 + 8;
      if (v20 + 8 <= v35)
      {
        *(void *)((char *)v33 + v20) = v23;
        uint64_t v25 = v34 + 8;
        LODWORD(v23) = *v22;
      }

      __int128 v34 = v25;
      if ((_DWORD)v23)
      {
        __int128 v26 = 0LL;
        __int128 v27 = 0LL;
        do
        {
          unint64_t v8 = v25 + 8;
          if (v25 + 8 <= v35)
          {
            *(void *)((char *)v33 + v25) = *(unsigned __int8 *)(*(void *)(v10 + 40 * v9 + 24) + v26);
            unint64_t v8 = v34 + 8;
            LODWORD(v23) = *v22;
          }

          __int128 v34 = v8;
          ++v27;
          v26 += 8LL;
          uint64_t v25 = v8;
        }

        while (v27 < v23);
      }

      else
      {
        unint64_t v8 = v25;
      }

      ++v9;
    }

    while (v9 < *v6);
    a3 = v35;
  }

  __int128 v28 = *((unsigned __int16 *)a1 + 9);
  uint64_t result = v8 + 8;
  if (v8 + 8 <= a3)
  {
    *(void *)((char *)v33 + v_Block_object_dispose(va, 8) = v28;
    uint64_t result = v34 + 8;
    LODWORD(v2_Block_object_dispose(va, 8) = *((unsigned __int16 *)a1 + 9);
  }

  __int128 v34 = result;
  if ((_DWORD)v28)
  {
    __int128 v30 = 0LL;
    do
    {
      __int128 v32 = *(void *)(a1[1] + 8 * v30);
      __int128 v31 = *find_entry(a4, &v32, 8uLL, 0LL);
      if (v31) {
        __int128 v31 = *(void *)(v31 + 32);
      }
      uint64_t result = v34 + 8;
      if (v34 + 8 <= v35)
      {
        *(void *)((char *)v33 + v34) = *(void *)(v31 + 8);
        uint64_t result = v34 + 8;
      }

      __int128 v34 = result;
      ++v30;
    }

    while (v30 < *((unsigned __int16 *)a1 + 9));
  }

  return result;
}

id newDYMTLCaptureScopeInfo(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init(&OBJC_CLASS___DYGTMTLCaptureScopeInfo);
  BOOL v3 = (void *)objc_claimAutoreleasedReturnValue([v1 device]);
  [v2 setDeviceAddress:v3];

  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v1 device]);
  objc_msgSend(v2, "setDeviceStreamRef:", objc_msgSend(v4, "streamReference"));

  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([v1 commandQueue]);
  if (v5)
  {
    unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v1 commandQueue]);
    objc_msgSend(v2, "setCommandQueueStreamRef:", objc_msgSend(v6, "streamReference"));
  }

  else
  {
    [v2 setCommandQueueStreamRef:0];
  }

  [v2 setScopeAddress:v1];
  objc_msgSend(v2, "setScopeStreamRef:", objc_msgSend(v1, "streamReference"));
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v1 label]);
  [v2 setLabel:v7];

  unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[MTLCaptureManager sharedCaptureManager](&OBJC_CLASS___MTLCaptureManager, "sharedCaptureManager"));
  id v9 = (id)objc_claimAutoreleasedReturnValue([v8 defaultCaptureScope]);
  [v2 setIsDefaultCapturable:v9 == v1];

  return v2;
}

void ResidencySetTakeSnapshotInternal(void *a1, char a2)
{
  BOOL v3 = a1;
  id v4 = v3;
  if ((a2 & 1) != 0 || (*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) == 2)
  {
    if (!*((_BYTE *)v3 + 56))
    {
      uint64_t v5 = v3[5];
      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v3[6]));
      id v7 = NSSetDiff(v5, v6);
      unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 allObjects]);

      int v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", *((void *)v4 + 6)));
      id v11 = NSSetDiff((uint64_t)v10, *((void **)v4 + 5));
      unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 allObjects]);

      s();
      uint64_t v15 = v14;
      *(_BYTE *)(v14 + 8) |= 0x80u;
      GTTraceContext_pushEncoderWithStream(*((void *)v4 + 3), (uint64_t)v68);
      uint64_t v16 = v70;
      *(_DWORD *)(v70 + _Block_object_dispose(va, 8) = -15208;
      unsigned __int8 v17 = v74;
      if (v74 > 0x38uLL)
      {
        uint64_t v19 = *(void *)(v69 + 24);
        uint64_t v20 = v75++;
        id v18 = GTTraceMemPool_allocateBytes(v19, v71, v20 | 0x800000000LL) + 16;
        unsigned __int8 v17 = v20;
      }

      else
      {
        id v18 = (char *)(v16 + v74);
        v74 += 8;
      }

      *(_BYTE *)(v16 + 13) = v17;
      uint64_t v21 = (uint64_t *)[v4 traceStream];
      if (v21) {
        uint64_t v22 = *v21;
      }
      else {
        uint64_t v22 = 0LL;
      }
      *(void *)id v18 = v22;
      *(void *)uint64_t v15 = v72;
      *(_BYTE *)(v15 + _Block_object_dispose(va, 8) = v73;
      *(_BYTE *)(v70 + 15) |= 8u;
      if ([*((id *)v4 + 6) count])
      {
        GTTraceContext_pushEncoderWithStream(*((void *)v4 + 3), (uint64_t)v68);
        uint64_t v23 = v70;
        *(_DWORD *)(v70 + _Block_object_dispose(va, 8) = -15211;
        unsigned __int8 v24 = v74;
        if (v74 > 0x28uLL)
        {
          uint64_t v26 = *(void *)(v69 + 24);
          uint64_t v27 = v75++;
          uint64_t v25 = GTTraceMemPool_allocateBytes(v26, v71, v27 | 0x1800000000LL) + 16;
          unsigned __int8 v24 = v27;
        }

        else
        {
          uint64_t v25 = (char *)(v23 + v74);
          v74 += 24;
        }

        *(_BYTE *)(v23 + 13) = v24;
        __int128 v28 = (uint64_t *)[v4 traceStream];
        if (v28) {
          uint64_t v29 = *v28;
        }
        else {
          uint64_t v29 = 0LL;
        }
        id v30 = [*((id *)v4 + 6) count];
        id v31 = [*((id *)v4 + 6) count];
        __chkstk_darwin(v31, v32);
        char v34 = StreamNSArray((uint64_t)v68, &v68[-v33 - 8], *((void **)v4 + 6));
        *(void *)uint64_t v25 = v29;
        *((void *)v25 + 1) = v30;
        v25[16] = v34;
        *(_DWORD *)(v25 + 17) = 0;
        *((_DWORD *)v25 + 5) = 0;
        *(void *)uint64_t v15 = v72;
        *(_BYTE *)(v15 + _Block_object_dispose(va, 8) = v73;
        *(_BYTE *)(v70 + 15) |= 8u;
        GTTraceContext_pushEncoderWithStream(*((void *)v4 + 3), (uint64_t)v68);
        uint64_t v35 = v70;
        *(_DWORD *)(v70 + _Block_object_dispose(va, 8) = -15220;
        unsigned __int8 v36 = v74;
        if (v74 > 0x38uLL)
        {
          uint64_t v38 = *(void *)(v69 + 24);
          uint64_t v39 = v75++;
          __int128 v37 = GTTraceMemPool_allocateBytes(v38, v71, v39 | 0x800000000LL) + 16;
          unsigned __int8 v36 = v39;
        }

        else
        {
          __int128 v37 = (char *)(v35 + v74);
          v74 += 8;
        }

        *(_BYTE *)(v35 + 13) = v36;
        id v40 = (uint64_t *)[v4 traceStream];
        if (v40) {
          uint64_t v41 = *v40;
        }
        else {
          uint64_t v41 = 0LL;
        }
        *(void *)__int128 v37 = v41;
        *(void *)uint64_t v15 = v72;
        *(_BYTE *)(v15 + _Block_object_dispose(va, 8) = v73;
        *(_BYTE *)(v70 + 15) |= 8u;
      }

      if ([v9 count])
      {
        GTTraceContext_pushEncoderWithStream(*((void *)v4 + 3), (uint64_t)v68);
        uint64_t v42 = v70;
        *(_DWORD *)(v70 + _Block_object_dispose(va, 8) = -15211;
        unsigned __int8 v43 = v74;
        if (v74 > 0x28uLL)
        {
          uint64_t v45 = *(void *)(v69 + 24);
          uint64_t v46 = v75++;
          uint64_t v44 = GTTraceMemPool_allocateBytes(v45, v71, v46 | 0x1800000000LL) + 16;
          unsigned __int8 v43 = v46;
        }

        else
        {
          uint64_t v44 = (char *)(v42 + v74);
          v74 += 24;
        }

        *(_BYTE *)(v42 + 13) = v43;
        unint64_t v47 = (uint64_t *)[v4 traceStream];
        if (v47) {
          uint64_t v48 = *v47;
        }
        else {
          uint64_t v48 = 0LL;
        }
        id v49 = [v9 count];
        id v50 = [v9 count];
        __chkstk_darwin(v50, v51);
        char v53 = StreamNSArray((uint64_t)v68, &v68[-v52 - 8], v9);
        *(void *)uint64_t v44 = v48;
        *((void *)v44 + 1) = v49;
        v44[16] = v53;
        *(_DWORD *)(v44 + 17) = 0;
        *((_DWORD *)v44 + 5) = 0;
        *(void *)uint64_t v15 = v72;
        *(_BYTE *)(v15 + _Block_object_dispose(va, 8) = v73;
        *(_BYTE *)(v70 + 15) |= 8u;
      }

      if ([v13 count])
      {
        GTTraceContext_pushEncoderWithStream(*((void *)v4 + 3), (uint64_t)v68);
        uint64_t v54 = v70;
        *(_DWORD *)(v70 + _Block_object_dispose(va, 8) = -15206;
        unsigned __int8 v55 = v74;
        if (v74 > 0x28uLL)
        {
          uint64_t v58 = *(void *)(v69 + 24);
          uint64_t v59 = v75++;
          unint64_t v56 = GTTraceMemPool_allocateBytes(v58, v71, v59 | 0x1800000000LL) + 16;
          unsigned __int8 v55 = v59;
        }

        else
        {
          unint64_t v56 = (char *)(v54 + v74);
          v74 += 24;
        }

        *(_BYTE *)(v54 + 13) = v55;
        unint64_t v60 = (uint64_t *)[v4 traceStream];
        if (v60) {
          uint64_t v61 = *v60;
        }
        else {
          uint64_t v61 = 0LL;
        }
        id v62 = [v13 count];
        id v63 = [v13 count];
        __chkstk_darwin(v63, v64);
        char v66 = StreamNSArray((uint64_t)v68, &v68[-v65 - 8], v13);
        *(void *)unint64_t v56 = v61;
        *((void *)v56 + 1) = v62;
        v56[16] = v66;
        *(_DWORD *)(v56 + 17) = 0;
        *((_DWORD *)v56 + 5) = 0;
        *(void *)uint64_t v15 = v72;
        char v57 = v73;
        *(_BYTE *)(v70 + 15) |= 8u;
      }

      else
      {
        char v57 = *(_BYTE *)(v15 + 8);
      }

      *(_BYTE *)(v15 + _Block_object_dispose(va, 8) = v57 & 0x7F;
      *((_BYTE *)v4 + 56) = 1;
    }
  }

  else
  {
    *((_BYTE *)v3 + 56) = 0;
  }
}

id NSSetDiff(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithSet:](&OBJC_CLASS___NSMutableSet, "setWithSet:", a1));
  [v4 minusSet:v3];

  return v4;
}

void ResidencySetTakeSnapshot(void *a1)
{
}

void ResidencySetTakeSnapshotForce(void *a1)
{
}

BOOL GTCaptureBoundaryCondition_equals(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)a1 == *(_DWORD *)a2
      && *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4)
      && *(void *)(a1 + 8) == *(void *)(a2 + 8)
      && *(void *)(a1 + 16) == *(void *)(a2 + 16)
      && *(void *)(a1 + 24) == *(void *)(a2 + 24)
      && *(void *)(a1 + 32) == *(void *)(a2 + 32)
      && *(void *)(a1 + 40) == *(void *)(a2 + 40)
      && *(unsigned __int8 *)(a1 + 48) == *(unsigned __int8 *)(a2 + 48);
}

void *GTCapturePhase_create(apr_pool_t *a1)
{
  id v2 = apr_palloc(a1, 0x10uLL);
  *id v2 = a1;
  v2[1] = apr_array_make(a1, 0, 64);
  return v2;
}

uint64_t GTCapturePhase_resetHitCount(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  uint64_t v2 = *(unsigned int *)(v1 + 12);
  if ((int)v2 >= 1)
  {
    id v3 = (_DWORD *)(*(void *)(v1 + 24) + 60LL);
    do
    {
      _DWORD *v3 = 0;
      v3 += 16;
      --v2;
    }

    while (v2);
  }

  return result;
}

uint64_t GTCapturePhase_removeAllConditions(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 8) + 12LL) = 0;
  return result;
}

__n128 GTCapturePhase_addCondition(uint64_t a1, __n128 *a2)
{
  id v3 = (__n128 *)apr_array_push(*(apr_array_header_t **)(a1 + 8));
  __n128 result = a2[2];
  __n128 v5 = a2[3];
  __n128 v7 = *a2;
  __n128 v6 = a2[1];
  v3[2] = result;
  v3[3] = v5;
  __n128 *v3 = v7;
  v3[1] = v6;
  return result;
}

BOOL GTCapturePhase_isComplete(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  unint64_t v2 = *(unsigned int *)(v1 + 12);
  if (!(_DWORD)v2) {
    return 1LL;
  }
  id v3 = *(_DWORD **)(v1 + 24);
  if (v3[15] >= v3[14]) {
    return 1LL;
  }
  unint64_t v4 = 0LL;
  __n128 v5 = v3 + 31;
  while (v2 - 1 != v4)
  {
    unsigned int v6 = *(v5 - 1);
    unsigned int v7 = *v5;
    v5 += 16;
    ++v4;
    if (v7 >= v6) {
      return v4 < v2;
    }
  }

  unint64_t v4 = v2;
  return v4 < v2;
}

uint64_t GTCapturePhase_numConditions(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 8) + 12LL);
}

__n128 GTCapturePhase_getCondition@<Q0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 24LL) + ((uint64_t)a2 << 6);
  __int128 v4 = *(_OWORD *)(v3 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v3;
  *(_OWORD *)(a3 + 16) = v4;
  __n128 result = *(__n128 *)(v3 + 32);
  __int128 v6 = *(_OWORD *)(v3 + 48);
  *(__n128 *)(a3 + 32) = result;
  *(_OWORD *)(a3 + 4_Block_object_dispose(va, 8) = v6;
  return result;
}

uint64_t GTCapturePhase_findCondition(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(v2 + 12);
  for (uint64_t i = *(void *)(v2 + 24); !GTCaptureBoundaryCondition_equals(i, a2); i += 64LL)
  {
    if (!--v3) {
      return 0LL;
    }
  }

  return i;
}

uint64_t GTCapturePhase_findConditionWithTriggerType(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(v2 + 12);
  uint64_t v4 = 0LL;
  uint64_t v5 = *(void *)(v2 + 24);
  __int128 v6 = (int *)(v5 + 4);
  while (1)
  {
    int v7 = *v6;
    v6 += 16;
    if (v7 == a2) {
      break;
    }
    if (v3 == ++v4) {
      return 0LL;
    }
  }

  return v5 + (v4 << 6);
}

uint64_t GTCapturePhase_checkTrigger(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(v2 + 12);
  if ((int)v3 >= 1)
  {
    char v4 = 0;
    uint64_t v5 = *(void *)(v2 + 24);
    uint64_t v6 = *((void *)a2 + 4);
    uint64_t v7 = *((void *)a2 + 5);
    uint64_t v8 = *((void *)a2 + 6);
    uint64_t v9 = *((void *)a2 + 7);
    uint64_t v10 = *((void *)a2 + 8);
    int v11 = *((unsigned __int8 *)a2 + 72);
    int v12 = *a2;
    for (uint64_t i = (uint64_t *)(v5 + 32); ; i += 8)
    {
      int v14 = *((_DWORD *)i - 8);
      if (v12 != v14 && v14 != 1) {
        goto LABEL_35;
      }
      int v16 = *((_DWORD *)i - 7);
      uint64_t v18 = *(i - 1);
      uint64_t v17 = *i;
      uint64_t v19 = i[1];
      if (v16)
      {
        if (a2[1] != v16) {
          goto LABEL_35;
        }
      }

      if (v14 == 8)
      {
        if (v18 && v18 != v7) {
          goto LABEL_35;
        }
        if (v17 && v17 != v9) {
          goto LABEL_35;
        }
        BOOL v20 = *((_BYTE *)i + 16) && v11 == 0;
        BOOL v21 = !v20;
        BOOL v22 = v19 == v10 || v19 == 0;
        if (!v22 || !v21) {
          goto LABEL_35;
        }
      }

      else if (v14 == 3)
      {
        if (v16 == 3 && v8 != *(i - 3)) {
          goto LABEL_35;
        }
      }

      else if (v14 == 2 && *(i - 2) != v6)
      {
        goto LABEL_35;
      }

      ++*((_DWORD *)i + 7);
      int v12 = *a2;
      char v4 = 1;
LABEL_35:
      if (!--v3) {
        return v4 & 1;
      }
    }
  }

  char v4 = 0;
  return v4 & 1;
}

id GTMTLQL_EncodeSamplerState(uint64_t a1, void *a2)
{
  id v3 = a2;
  char v4 = [v3 traceStream];
  __int128 v48 = 0u;
  uint64_t v49 = 0LL;
  __int128 v52 = 0u;
  __int128 v51 = 0u;
  LODWORD(v4_Block_object_dispose(va, 8) = 75;
  uint64_t v50 = -1LL;
  uint64_t v54 = 0LL;
  __int128 v53 = 0xFFFFFFFFFFFFFFFFLL;
  uint64_t v5 = v4[4];
  if (v5 && (*(_BYTE *)(v5 + 79) & 8) != 0) {
    uint64_t v6 = v5 + 64;
  }
  else {
    uint64_t v6 = 0LL;
  }
  GTMTLSMSamplerState_processTraceFuncWithPool((char *)&v48, v4[3], v6);
  uint64_t v7 = *(void *)(GTTraceContext_getStream(a1, *((uint64_t *)&v48 + 1)) + 8);
  uint64_t v8 = *(void *)(GTTraceContext_getStream(a1, *((uint64_t *)&v51 + 1)) + 8);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 device]);

  uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
  uint64_t v47 = 0x4005053544DLL;
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", &v47, 8LL);
  uint64_t v42 = v8;
  int v43 = 7;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  int v46 = 0;
  DWORD1(v44) = 2;
  DYTraceEncode_InternalData((uint64_t)&v42, (unsigned int *)&v55, 0x400uLL, v11, 0LL);
  LODWORD(v59) = v59 | 0x46;
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", &v55, v55);
  int v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  &off_212DD0));
  uint64_t v13 = [v9 traceStream];
  if (v13 && (uint64_t v14 = v13[4]) != 0 && (*(_BYTE *)(v14 + 79) & 8) != 0) {
    uint64_t v15 = v14 + 64;
  }
  else {
    uint64_t v15 = 0LL;
  }
  __int128 v38 = 0u;
  uint64_t v39 = 0LL;
  __int128 v41 = 0u;
  LODWORD(v3_Block_object_dispose(va, 8) = 36;
  uint64_t v40 = -1LL;
  GTMTLSMDevice_processTraceFuncWithPool((char *)&v38, *((void *)[v9 traceStream] + 3), v15);
  id v16 = SaveDeviceDescriptor(*((uint64_t *)&v41 + 1), v12);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = *(void *)(GTTraceContext_getStream(a1, (uint64_t)[v9 streamReference]) + 8);
  id v19 = v17;
  BOOL v20 = (const char *)[v19 UTF8String];
  uint64_t v56 = 0LL;
  uint64_t v57 = 0LL;
  uint64_t v58 = 0LL;
  uint64_t v59 = 0x554300000000LL;
  uint64_t v60 = v18;
  unint64_t v55 = 0xFFFFD80100000030LL;
  AppendString(v20, (int *)&v55);
  uint64_t v21 = ((_DWORD)v55 + 3) & 0xFFFFFFFC;
  bzero((char *)&v55 + v55, v21 - v55);
  LODWORD(v55) = v21;
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", &v55, v21);

  uint64_t v22 = v52;
  id v23 = v12;
  unint64_t v24 = EncodeDYMTLSamplerDescriptor(v22, 0LL, 0LL);
  uint64_t v25 = -[NSMutableData initWithLength:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithLength:", v24);
  EncodeDYMTLSamplerDescriptor(v22, (uint64_t)-[NSMutableData mutableBytes](v25, "mutableBytes"), v24);
  uint64_t v26 = HashDataBytes(v25);
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
  id v28 = -[NSMutableData copy](v25, "copy");
  [v23 setObject:v28 forKeyedSubscript:v27];

  v37[0] = v8;
  v37[1] = v7;
  id v29 = v27;
  v37[2] = [v29 UTF8String];
  DYTraceEncode_MTLDevice_newSamplerStateWithDescriptor((uint64_t)v37, (unsigned int *)&v55, 0x400uLL, 0LL, 0LL);
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", &v55, v55);
  if ((void)v53)
  {
    uint64_t v56 = 0LL;
    uint64_t v57 = 0LL;
    uint64_t v58 = 0LL;
    uint64_t v59 = 0x77754300000004LL;
    uint64_t v60 = v7;
    uint64_t v61 = v53;
    unint64_t v55 = 0xFFFFD80E00000038LL;
    -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", &v55, 56LL);
  }

  id v30 = -[NSMutableData copy](v10, "copy");
  [v23 setObject:v30 forKeyedSubscript:@"capture"];

  id v36 = 0LL;
  id v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v23,  1LL,  &v36));
  id v32 = v36;
  uint64_t v33 = v32;
  if (v32)
  {
    char v34 = (void *)objc_claimAutoreleasedReturnValue([v32 localizedDescription]);
    NSLog(@"Failed to encode datatip data: %@", v34);
  }

  return v31;
}

id SaveDeviceDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  unint64_t v4 = EncodeDYMTLDeviceDescriptor(a1, 0LL, 0LL);
  uint64_t v5 = -[NSMutableData initWithLength:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithLength:", v4);
  EncodeDYMTLDeviceDescriptor(a1, -[NSMutableData mutableBytes](v5, "mutableBytes"), v4);
  uint64_t v6 = HashDataBytes(v5);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  id v8 = -[NSMutableData copy](v5, "copy");
  [v3 setObject:v8 forKeyedSubscript:v7];

  return v7;
}

NSString *HashDataBytes(void *a1)
{
  id v1 = a1;
  CC_SHA256([v1 bytes], (CC_LONG)objc_msgSend(v1, "length"), md);
  uint64_t v2 = 0LL;
  id v3 = v8;
  do
  {
    unint64_t v4 = md[v2];
    *(v3 - 1) = byte_1CA4E0[v4 >> 4];
    _BYTE *v3 = byte_1CA4E0[v4 & 0xF];
    v3 += 2;
    ++v2;
  }

  while (v2 != 32);
  v8[63] = 0;
  uint64_t v5 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", &v7);

  return v5;
}

id GTMTLQL_EncodeBuffer(uint64_t a1, void *a2)
{
  id v3 = a2;
  unint64_t v4 = [v3 traceStream];
  __int128 v55 = 0u;
  uint64_t v56 = 0LL;
  __int128 v62 = 0u;
  __int128 v64 = 0u;
  __int128 v65 = 0u;
  __int128 v61 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  LODWORD(v55) = 22;
  uint64_t v57 = -1LL;
  WORD1(v62) = 2;
  __int128 v60 = 0xFFFFFFFFFFFFFFFFLL;
  __int128 v63 = 0xFFFFFFFFFFFFFFFFLL;
  uint64_t v5 = v4[4];
  if (v5 && (*(_BYTE *)(v5 + 79) & 8) != 0) {
    uint64_t v6 = v5 + 64;
  }
  else {
    uint64_t v6 = 0LL;
  }
  GTMTLSMBuffer_processTraceFuncWithPool((char *)&v55, v4[3], v6);
  uint64_t v37 = *(void *)(GTTraceContext_getStream(a1, *((uint64_t *)&v55 + 1)) + 8);
  uint64_t v38 = *(void *)(GTTraceContext_getStream(a1, *((uint64_t *)&v58 + 1)) + 8);
  char v7 = (void *)objc_claimAutoreleasedReturnValue([v3 device]);
  id v8 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
  uint64_t v54 = 0x4005053544DLL;
  -[NSMutableData appendBytes:length:](v8, "appendBytes:length:", &v54, 8LL);
  uint64_t v49 = v38;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  int v53 = 0;
  int v50 = 7;
  DWORD1(v51) = 2;
  DYTraceEncode_InternalData((uint64_t)&v49, (unsigned int *)v66, 0x400uLL, v9, 0LL);
  LODWORD(v67) = v67 | 0x46;
  -[NSMutableData appendBytes:length:](v8, "appendBytes:length:", v66, LODWORD(v66[0]));
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  &off_212DF8));
  uint64_t v11 = [v7 traceStream];
  if (v11 && (uint64_t v12 = v11[4]) != 0 && (*(_BYTE *)(v12 + 79) & 8) != 0) {
    uint64_t v13 = v12 + 64;
  }
  else {
    uint64_t v13 = 0LL;
  }
  __int128 v45 = 0u;
  uint64_t v46 = 0LL;
  __int128 v48 = 0u;
  LODWORD(v45) = 36;
  uint64_t v47 = -1LL;
  GTMTLSMDevice_processTraceFuncWithPool((char *)&v45, *((void *)[v7 traceStream] + 3), v13);
  id v14 = SaveDeviceDescriptor(*((uint64_t *)&v48 + 1), v10);
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  uint64_t v16 = *(void *)(GTTraceContext_getStream(a1, (uint64_t)[v7 streamReference]) + 8);
  id v17 = v15;
  uint64_t v18 = (const char *)[v17 UTF8String];
  memset(&v66[1], 0, 24);
  uint64_t v67 = 0x554300000000LL;
  uint64_t v68 = v16;
  v66[0] = 0xFFFFD80100000030LL;
  AppendString(v18, (int *)v66);
  uint64_t v19 = (LODWORD(v66[0]) + 3) & 0xFFFFFFFC;
  bzero((char *)v66 + LODWORD(v66[0]), v19 - LODWORD(v66[0]));
  LODWORD(v66[0]) = v19;
  -[NSMutableData appendBytes:length:](v8, "appendBytes:length:", v66, v19);

  apr_pool_create_ex(&newpool, 0LL, 0LL, 0LL);
  BOOL v20 = newpool;
  uint64_t v21 = apr_array_make(newpool, 1, 88);
  uint64_t v22 = (char *)apr_array_push(v21);
  id v23 = [v3 streamReference];
  *(void *)uint64_t v22 = v37;
  *((void *)v22 + 1) = v23;
  *((void *)v22 + 3) = 0LL;
  *((void *)v22 + 4) = 0LL;
  *((void *)v22 + 2) = 0LL;
  *(void *)(v22 + 3_Block_object_dispose(va, 8) = 0LL;
  v22[46] = 22;
  *(_OWORD *)(v22 + 47) = 0u;
  *(_OWORD *)(v22 + 63) = 0u;
  *(_OWORD *)(v22 + 72) = 0u;
  unint64_t v24 = GTResourceDownloaderProcessRequest(v20, (uint64_t)v21);
  elts = v24->elts;
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v7 downloader]);
  uint64_t v27 = objc_alloc(&OBJC_CLASS___GTDownloadContext);
  id v28 = (void *)objc_claimAutoreleasedReturnValue([v26 downloadQueue]);
  id v29 = -[GTDownloadContext initWithQueue:forRequest:](v27, "initWithQueue:forRequest:", v28, v24);

  DownloadBuffer(v26, v29, elts);
  apr_pool_destroy(v20);
  *(void *)&__int128 v45 = 0LL;
  *((void *)&v45 + 1) = &v45;
  uint64_t v46 = 0x3032000000LL;
  uint64_t v47 = (uint64_t)__Block_byref_object_copy__2478;
  *(void *)&__int128 v48 = __Block_byref_object_dispose__2479;
  *((void *)&v48 + 1) = 0LL;
  v41[0] = _NSConcreteStackBlock;
  v41[1] = 3221225472LL;
  void v41[2] = __GTMTLQL_EncodeBuffer_block_invoke;
  v41[3] = &unk_20D8C0;
  int v43 = &v45;
  id v30 = v10;
  id v42 = v30;
  -[GTDownloadContext flushWithCallback:](v29, "flushWithCallback:", v41);
  v40[0] = v38;
  v40[1] = v37;
  v40[2] = [*(id *)(*((void *)&v45 + 1) + 40) UTF8String];
  v40[3] = *((void *)&v62 + 1);
  void v40[4] = 0LL;
  v40[5] = 0LL;
  DYTraceEncode_MTLDevice_newBufferWithBytes_length_options((uint64_t)v40, (unsigned int *)v66, 0x400uLL, 0LL, 0LL);
  -[NSMutableData appendBytes:length:](v8, "appendBytes:length:", v66, LODWORD(v66[0]));
  id v31 = -[NSMutableData copy](v8, "copy");
  [v30 setObject:v31 forKeyedSubscript:@"capture"];

  id v39 = 0LL;
  id v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v30,  1LL,  &v39));
  id v33 = v39;
  char v34 = v33;
  if (v33)
  {
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v33 localizedDescription]);
    NSLog(@"Failed to encode datatip data: %@", v35);
  }

  _Block_object_dispose(&v45, 8);
  return v32;
}

void sub_3A884( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

uint64_t __Block_byref_object_copy__2478(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__2479(uint64_t a1)
{
}

id GTMTLQL_EncodeTexture(uint64_t a1, void *a2)
{
  id v3 = a2;
  unint64_t v4 = [v3 traceStream];
  __int128 v82 = 0u;
  uint64_t v83 = 0LL;
  __int128 v89 = 0u;
  __int128 v87 = 0u;
  __int128 v95 = 0u;
  __int128 v94 = 0u;
  __int128 v93 = 0u;
  __int128 v92 = 0u;
  __int128 v91 = 0u;
  __int128 v90 = 0u;
  __int128 v88 = 0u;
  __int128 v86 = 0u;
  __int128 v85 = 0u;
  LODWORD(v82) = 80;
  WORD1(v89) = 2;
  uint64_t v84 = -1LL;
  *(void *)&__int128 v87 = -1LL;
  uint64_t v96 = 0xFFFFFFFFLL;
  uint64_t v5 = v4[4];
  if (v5 && (*(_BYTE *)(v5 + 79) & 8) != 0) {
    uint64_t v6 = v5 + 64;
  }
  else {
    uint64_t v6 = 0LL;
  }
  GTMTLSMTexture_processTraceFuncWithPool((char *)&v82, v4[3], v6);
  uint64_t v7 = *(void *)(GTTraceContext_getStream(a1, *((uint64_t *)&v82 + 1)) + 8);
  uint64_t v8 = *(void *)(GTTraceContext_getStream(a1, *((uint64_t *)&v85 + 1)) + 8);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 device]);
  uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
  uint64_t v81 = 0x4005053544DLL;
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", &v81, 8LL);
  uint64_t v76 = v8;
  __int128 v78 = 0u;
  __int128 v79 = 0u;
  int v80 = 0;
  int v77 = 7;
  DWORD1(v7_Block_object_dispose(va, 8) = 2;
  DYTraceEncode_InternalData((uint64_t)&v76, (unsigned int *)v97, 0x400uLL, v11, 0LL);
  LODWORD(v9_Block_object_dispose(va, 8) = v98 | 0x46;
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", v97, LODWORD(v97[0]));
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  &off_212E20));
  uint64_t v13 = [v9 traceStream];
  if (v13 && (uint64_t v14 = v13[4]) != 0 && (*(_BYTE *)(v14 + 79) & 8) != 0) {
    uint64_t v15 = v14 + 64;
  }
  else {
    uint64_t v15 = 0LL;
  }
  __int128 __str = 0u;
  *(void *)&__int128 v101 = 0LL;
  __int128 v102 = 0u;
  LODWORD(__str) = 36;
  *((void *)&v101 + 1) = -1LL;
  GTMTLSMDevice_processTraceFuncWithPool((char *)&__str, *((void *)[v9 traceStream] + 3), v15);
  id v16 = SaveDeviceDescriptor(*((uint64_t *)&v102 + 1), v12);
  id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = *(void *)(GTTraceContext_getStream(a1, (uint64_t)[v9 streamReference]) + 8);
  id v19 = v17;
  BOOL v20 = (const char *)[v19 UTF8String];
  memset(&v97[1], 0, 24);
  uint64_t v98 = 0x554300000000LL;
  uint64_t v99 = v18;
  v97[0] = 0xFFFFD80100000030LL;
  AppendString(v20, (int *)v97);
  uint64_t v21 = (LODWORD(v97[0]) + 3) & 0xFFFFFFFC;
  bzero((char *)v97 + LODWORD(v97[0]), v21 - LODWORD(v97[0]));
  LODWORD(v97[0]) = v21;
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", v97, v21);

  apr_pool_create_ex(&newpool, 0LL, 0LL, 0LL);
  uint64_t v22 = newpool;
  id v23 = apr_array_make(newpool, 1, 88);
  unint64_t v24 = (char *)apr_array_push(v23);
  id v25 = [v3 streamReference];
  *(void *)unint64_t v24 = v7;
  *((void *)v24 + 1) = v25;
  *((void *)v24 + 3) = 0LL;
  *((void *)v24 + 4) = 0LL;
  *((void *)v24 + 2) = 0LL;
  *(void *)(v24 + 3_Block_object_dispose(va, 8) = 0LL;
  v24[46] = 80;
  *(_OWORD *)(v24 + 47) = 0u;
  *(_OWORD *)(v24 + 63) = 0u;
  *(_OWORD *)(v24 + 72) = 0u;
  p = v22;
  id v26 = v3;
  uint64_t v27 = GTResourceDownloaderProcessRequest(v22, (uint64_t)v23);
  __int128 v58 = v9;
  id v28 = (void *)objc_claimAutoreleasedReturnValue([v9 downloader]);
  id v29 = objc_alloc(&OBJC_CLASS___GTDownloadContext);
  uint64_t v56 = v28;
  id v30 = (void *)objc_claimAutoreleasedReturnValue([v28 downloadQueue]);
  __int128 v59 = -[GTDownloadContext initWithQueue:forRequest:](v29, "initWithQueue:forRequest:", v30, v27);

  uint64_t elts = (uint64_t)v27->elts;
  v74[0] = v8;
  v74[1] = v7;
  v74[2] = "descriptor";
  v74[3] = 0LL;
  DYTraceEncode_MTLDevice_newTextureWithDescriptor((uint64_t)v74, (unsigned int *)v97, 0x400uLL, 0LL, 0LL);
  -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", v97, LODWORD(v97[0]));
  id v32 = objc_autoreleasePoolPush();
  __int128 v60 = v26;
  while ((objc_opt_respondsToSelector(v26, "baseObject") & 1) != 0)
    id v26 = [v26 performSelector:"baseObject"];
  objc_autoreleasePoolPop(v32);
  MTLTextureDescriptorFromTextureWithoutResourceIndex = MakeMTLTextureDescriptorFromTextureWithoutResourceIndex(v26);
  char v34 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptorFromTextureWithoutResourceIndex);
  __int128 v125 = 0u;
  __int128 v126 = 0u;
  __int128 v123 = 0u;
  __int128 v124 = 0u;
  __int128 v121 = 0u;
  __int128 v122 = 0u;
  __int128 v119 = 0u;
  __int128 v120 = 0u;
  __int128 v117 = 0u;
  __int128 v118 = 0u;
  uint64_t v114 = 0LL;
  __int128 v116 = 0u;
  __int128 v112 = 0u;
  __int128 v113 = 0u;
  __int128 v110 = 0u;
  __int128 v111 = 0u;
  __int128 v108 = 0u;
  __int128 v109 = 0u;
  __int128 v106 = 0u;
  __int128 v107 = 0u;
  __int128 v104 = 0u;
  __int128 v105 = 0u;
  __int128 v102 = 0u;
  __int128 v103 = 0u;
  __int128 __str = 0u;
  __int128 v101 = 0u;
  uint64_t v127 = 0LL;
  uint64_t v115 = v73;
  TranslateGTMTLTextureDescriptor(v34, (uint64_t)&__str, 1);
  unint64_t v35 = EncodeDYMTLTextureDescriptor((uint64_t)v73, 0LL, 0LL);
  id v36 = objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithLength:]( &OBJC_CLASS___NSMutableData, "dataWithLength:", v35));
  EncodeDYMTLTextureDescriptor((uint64_t)v73, [v36 mutableBytes], v35);
  [v12 setObject:v36 forKeyedSubscript:@"descriptor"];

  int v37 = *(unsigned __int8 *)(elts + 46);
  if (v37 == 86)
  {
    uint64_t v38 = v56;
    id v39 = v59;
    DownloadIOSurface(v56, v59, (id *)elts);
    v62[0] = _NSConcreteStackBlock;
    v62[1] = 3221225472LL;
    v62[2] = __GTMTLQL_EncodeTexture_block_invoke_2;
    v62[3] = &unk_20D910;
    uint64_t v40 = &v63;
    id v63 = v60;
    id v64 = v12;
    char v66 = v97;
    uint64_t v67 = 1024LL;
    __int128 v65 = v10;
    -[GTDownloadContext flushWithCallback:](v59, "flushWithCallback:", v62);
  }

  else
  {
    uint64_t v38 = v56;
    id v39 = v59;
    if (v37 != 80) {
      goto LABEL_20;
    }
    DownloadTexture(v56, v59, (id *)elts, v27->nelts);
    v71[0] = _NSConcreteStackBlock;
    v71[1] = 3221225472LL;
    v71[2] = __GTMTLQL_EncodeTexture_block_invoke;
    v71[3] = &unk_20D8E8;
    uint64_t v40 = &v72;
    id v72 = v12;
    -[GTDownloadContext flushWithCallback:](v59, "flushWithCallback:", v71);
    if (v27->nelts >= 1)
    {
      uint64_t v41 = 0LL;
      uint64_t v42 = 68LL;
      do
      {
        int v43 = v27->elts;
        GTResourceDownloaderGetResourceFilename(elts, v41, (char *)&__str, 0x80uLL);
        uint64_t v44 = *(unsigned int *)&v43[v42 - 16];
        v68[0] = 0LL;
        v68[1] = v44;
        uint64_t v45 = *(unsigned __int16 *)&v43[v42 - 10];
        v68[2] = *(unsigned __int16 *)&v43[v42 - 12];
        v68[3] = v45;
        uint64_t v46 = *(unsigned __int16 *)&v43[v42 - 4];
        v68[4] = *(unsigned int *)&v43[v42 - 8];
        v68[5] = v46;
        uint64_t v47 = *(unsigned __int16 *)&v43[v42 - 18];
        v68[6] = *(unsigned __int16 *)&v43[v42 - 2];
        v68[7] = v47;
        _BYTE v68[8] = *(unsigned __int16 *)&v43[v42 - 20];
        v68[9] = &__str;
        uint64_t v48 = *(void *)&v43[v42];
        *(void *)&__int128 v49 = v48;
        *((void *)&v49 + 1) = HIDWORD(v48);
        __int128 v69 = v49;
        uint64_t v70 = 0LL;
        DYTraceEncode_MTLTexture_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage( (uint64_t)v68,  (unsigned int *)v97,  0x400uLL,  0LL,  0LL);
        -[NSMutableData appendBytes:length:](v10, "appendBytes:length:", v97, LODWORD(v97[0]));
        ++v41;
        v42 += 88LL;
      }

      while (v41 < v27->nelts);
      id v39 = v59;
    }
  }

LABEL_20:
  apr_pool_destroy(p);
  id v50 = -[NSMutableData copy](v10, "copy");
  [v12 setObject:v50 forKeyedSubscript:@"capture"];

  id v61 = 0LL;
  __int128 v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v12,  1LL,  &v61));
  id v52 = v61;
  int v53 = v52;
  if (v52)
  {
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v52 localizedDescription]);
    NSLog(@"Failed to encode datatip data: %@", v54);
  }

  return v51;
}

id GTMTLGuestAppClient_allCaptureObjects(os_unfair_lock_s *a1)
{
  uint64_t v2 = a1 + 8;
  os_unfair_lock_lock(a1 + 8);
  id v3 = GTMTLGuestAppClient_allCaptureObjectsUnsafe((uint64_t)a1);
  unint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  os_unfair_lock_unlock(v2);
  return v4;
}

id GTMTLGuestAppClient_allCaptureObjectsUnsafe(uint64_t a1)
{
  uint64_t v2 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [*(id *)(a1 + 88) count]);
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  id v3 = *(id *)(a1 + 88);
  id v4 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v18;
    do
    {
      uint64_t v7 = 0LL;
      do
      {
        if (*(void *)v18 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = copyDYMTLCommandQueueInfo(*(void **)(*((void *)&v17 + 1) + 8LL * (void)v7));
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
        -[NSMutableArray addObject:](v2, "addObject:", v9, (void)v17);

        uint64_t v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }

    while (v5);
  }

  id v10 = objc_alloc_init(&OBJC_CLASS___GTCaptureObjects);
  uint64_t v11 = GTMTLGuestAppClient_captureDevicesUnsafe(a1);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  [v10 setDevices:v12];

  [v10 setCommandQueues:v2];
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[GTMTLCaptureScopeInfo allCaptureScopes](&OBJC_CLASS___GTMTLCaptureScopeInfo, "allCaptureScopes"));
  [v10 setCaptureScopes:v13];

  id v14 = AllMetalLayers();
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  [v10 setMetalLayers:v15];

  return v10;
}

id copyDYMTLCommandQueueInfo(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init(&OBJC_CLASS___DYGTMTLCommandQueueInfo);
  objc_msgSend(v2, "setStreamRef:", objc_msgSend(v1, "streamRef"));
  objc_msgSend(v2, "setDeviceAddress:", objc_msgSend(v1, "deviceAddress"));
  objc_msgSend(v2, "setDeviceStreamRef:", objc_msgSend(v1, "deviceStreamRef"));
  objc_msgSend(v2, "setToolsDeviceAddress:", objc_msgSend(v1, "toolsDeviceAddress"));
  objc_msgSend(v2, "setQueueAddress:", objc_msgSend(v1, "queueAddress"));
  objc_msgSend(v2, "setToolsQueueAddress:", objc_msgSend(v1, "toolsQueueAddress"));
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 label]);
  [v2 setLabel:v3];

  [v2 setCanBeCaptured:1];
  [v2 setIsOpenGLQueue:0];
  id v4 = [v1 isInternalQueue];

  [v2 setIsInternalQueue:v4];
  return v2;
}

NSMutableArray *GTMTLGuestAppClient_captureDevicesUnsafe(uint64_t a1)
{
  id v2 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [*(id *)(a1 + 96) count]);
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v3 = *(id *)(a1 + 96);
  id v4 = [v3 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v15;
    do
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v14 + 1) + 8LL * (void)i);
        id v9 = DEVICEOBJECT(v8);
        id v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
        id v11 = newProfileWithMTLDevice(v10);
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

        objc_msgSend(v12, "setStreamRef:", objc_msgSend(v8, "streamReference", (void)v14));
        -[NSMutableArray addObject:](v2, "addObject:", v12);
      }

      id v5 = [v3 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }

    while (v5);
  }

  return v2;
}

id GTMTLGuestAppClient_getTelemetry()
{
  v0 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  for (uint64_t i = 0LL; i != 2048; i += 32LL)
  {
    uint64_t v2 = *(void *)&v45[i];
    if (!v2) {
      break;
    }
    id v3 = objc_alloc_init(&OBJC_CLASS___GTTelemetryLayerObject);
    [v3 setStreamRef:v2];
    [v3 setFrames:*(void *)&v45[i + 24]];
    id v4 = objc_alloc_init(&OBJC_CLASS___GTTelemetryRecordObject);
    [v3 setFps:v4];

    int v5 = *(_DWORD *)&v45[i + 8];
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 fps]);
    LODWORD(v7) = v5;
    [v6 setAverage:v7];

    int v8 = *(_DWORD *)&v45[i + 12];
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v3 fps]);
    LODWORD(v10) = v8;
    [v9 setMin:v10];

    int v11 = *(_DWORD *)&v45[i + 16];
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v3 fps]);
    LODWORD(v13) = v11;
    [v12 setMax:v13];

    -[NSMutableArray addObject:](v0, "addObject:", v3);
  }

  __int128 v14 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  for (uint64_t j = 0LL; j != 128; j += 32LL)
  {
    uint64_t v16 = *(void *)&v45[j + 18432];
    if (!v16) {
      break;
    }
    id v17 = objc_alloc_init(&OBJC_CLASS___GTTelemetryDeviceObject);
    [v17 setStreamRef:v16];
    [v17 setCommits:*(void *)&v45[j + 18456]];
    id v18 = objc_alloc_init(&OBJC_CLASS___GTTelemetryRecordObject);
    [v17 setGpuTime:v18];

    int v19 = *(_DWORD *)&v45[j + 18440];
    __int128 v20 = (void *)objc_claimAutoreleasedReturnValue([v17 gpuTime]);
    LODWORD(v21) = v19;
    [v20 setAverage:v21];

    int v22 = *(_DWORD *)&v45[j + 18444];
    id v23 = (void *)objc_claimAutoreleasedReturnValue([v17 gpuTime]);
    LODWORD(v24) = v22;
    [v23 setMin:v24];

    int v25 = *(_DWORD *)&v45[j + 18448];
    id v26 = (void *)objc_claimAutoreleasedReturnValue([v17 gpuTime]);
    LODWORD(v27) = v25;
    [v26 setMax:v27];

    -[NSMutableArray addObject:](v14, "addObject:", v17);
  }

  id v28 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  for (uint64_t k = 0LL; k != 0x4000; k += 32LL)
  {
    id v30 = &v45[k];
    uint64_t v31 = *(void *)&v45[k + 2048];
    if (!v31) {
      break;
    }
    id v32 = objc_alloc_init(&OBJC_CLASS___GTTelemetryQueueObject);
    [v32 setStreamRef:v31];
    [v32 setCommits:*((void *)v30 + 259)];
    id v33 = objc_alloc_init(&OBJC_CLASS___GTTelemetryRecordObject);
    [v32 setGpuTime:v33];

    int v34 = *((_DWORD *)v30 + 514);
    unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v32 gpuTime]);
    LODWORD(v36) = v34;
    [v35 setAverage:v36];

    int v37 = *((_DWORD *)v30 + 515);
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v32 gpuTime]);
    LODWORD(v39) = v37;
    [v38 setMin:v39];

    int v40 = *((_DWORD *)v30 + 516);
    uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v32 gpuTime]);
    LODWORD(v42) = v40;
    [v41 setMax:v42];

    -[NSMutableArray addObject:](v28, "addObject:", v32);
  }

  id v43 = objc_alloc_init(&OBJC_CLASS___GTTelemetryStatistics);
  [v43 setLayers:v0];
  [v43 setQueues:v28];
  [v43 setDevices:v14];

  return v43;
}

void GTMTLGuestAppClient_reportTelemetry()
{
  if (*(_BYTE *)(g_guestAppClientMTL + 129))
  {
    v0 = *(void **)(g_guestAppClientMTL + 16);
    if (v0)
    {
      id Telemetry = GTMTLGuestAppClient_getTelemetry();
      id v2 = (id)objc_claimAutoreleasedReturnValue(Telemetry);
      [v0 notifyStatistics:v2];
    }
  }

id newDYMTLCommandQueueInfo(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init(&OBJC_CLASS___DYGTMTLCommandQueueInfo);
  objc_msgSend(v2, "setStreamRef:", objc_msgSend(v1, "streamReference"));
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 device]);
  [v2 setDeviceAddress:v3];

  id v4 = (void *)objc_claimAutoreleasedReturnValue([v1 device]);
  int v5 = (void *)objc_claimAutoreleasedReturnValue([v4 baseObject]);
  [v2 setToolsDeviceAddress:v5];

  [v2 setQueueAddress:v1];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v1 baseObject]);
  [v2 setToolsQueueAddress:v6];

  double v7 = (void *)objc_claimAutoreleasedReturnValue([v1 label]);
  [v2 setLabel:v7];

  [v2 setCanBeCaptured:1];
  [v2 setIsOpenGLQueue:0];
  id v8 = objc_claimAutoreleasedReturnValue([v2 label]);
  objc_msgSend(v2, "setIsInternalQueue:", IsAppleInternalLabel((BOOL)objc_msgSend(v8, "UTF8String")));

  return v2;
}

void GTMTLGuestAppClientUpdateCAMetalLayerInfo(uint64_t a1, void *a2)
{
  id v3 = (os_unfair_lock_s *)(a1 + 32);
  id v4 = a2;
  os_unfair_lock_lock(v3);
  id v10 = objc_alloc_init(&OBJC_CLASS___GTCaptureObjects);
  int v5 = GTMTLGuestAppClient_captureDevicesUnsafe(a1);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  [v10 setDevices:v6];

  [v10 setCommandQueues:*(void *)(a1 + 88)];
  double v7 = (void *)objc_claimAutoreleasedReturnValue(+[GTMTLCaptureScopeInfo allCaptureScopes](&OBJC_CLASS___GTMTLCaptureScopeInfo, "allCaptureScopes"));
  [v10 setCaptureScopes:v7];

  [v10 setMetalLayers:v4];
  [*(id *)(a1 + 8) notifyCaptureObjectsChanged:v10];
  id v8 = *(void **)a1;
  id v9 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:objectPayload:",  1550LL,  v4));

  [v8 send:v9 error:0];
  os_unfair_lock_unlock(v3);
}

void GTMTLGuestAppClientUpdateMTLDeviceInfo(uint64_t a1)
{
  id v2 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  id v3 = GTMTLGuestAppClient_captureDevicesUnsafe(a1);
  id v10 = (id)objc_claimAutoreleasedReturnValue(v3);
  id v4 = objc_alloc_init(&OBJC_CLASS___GTCaptureObjects);
  [v4 setDevices:v10];
  [v4 setCommandQueues:*(void *)(a1 + 88)];
  int v5 = (void *)objc_claimAutoreleasedReturnValue(+[GTMTLCaptureScopeInfo allCaptureScopes](&OBJC_CLASS___GTMTLCaptureScopeInfo, "allCaptureScopes"));
  [v4 setCaptureScopes:v5];

  id v6 = AllMetalLayers();
  double v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  [v4 setMetalLayers:v7];

  [*(id *)(a1 + 8) notifyCaptureObjectsChanged:v4];
  id v8 = *(void **)a1;
  id v9 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:objectPayload:",  1551LL,  v10));
  [v8 send:v9 error:0];

  os_unfair_lock_unlock(v2);
}

id GTMTLGuestAppClient_notifyCaptureProgress(id result)
{
  if (*(_BYTE *)(g_guestAppClientMTL + 129)) {
    return [*(id *)(g_guestAppClientMTL + 8) notifyCaptureProgress:result];
  }
  return result;
}

void _sendTimebaseUpdate(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  int v5 = objc_autoreleasePoolPush();
  uint64_t v6 = mach_absolute_time();
  gettimeofday(&v14, 0LL);
  uint64_t v7 = v6 + ((mach_absolute_time() - v6) >> 1);
  v15[0] = @"nanoseconds since epoch timestamp";
  id v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  1000000000 * v14.tv_sec + 1000LL * v14.tv_usec));
  v16[0] = v8;
  v15[1] = @"mach absolute timestamp";
  id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v7));
  v16[1] = v9;
  v15[2] = @"mach timebase numerator";
  id v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  g_DYTimebaseInfo));
  v16[2] = v10;
  v15[3] = @"mach timebase denominator";
  int v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  dword_23A1CC));
  v16[3] = v11;
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v16,  v15,  4LL));

  double v13 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:attributes:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:attributes:",  1539LL,  v12));
  [v3 send:v13 inReplyTo:v4 error:0];

  objc_autoreleasePoolPop(v5);
}

void **GTMTLGuestAppClient_interposeCommonInit()
{
  v0 = objc_autoreleasePoolPush();
  inited = (void **)GTMTLGuestAppClient_initPlatform();
  GTMTLGuestAppClient_sendInferiorLaunchedMessage(inited);
  objc_autoreleasePoolPop(v0);
  return inited;
}

void GTMTLGuestAppClient_sendInferiorLaunchedMessage(void **a1)
{
  id v2 = objc_autoreleasePoolPush();
  mach_timebase_info((mach_timebase_info_t)&g_DYTimebaseInfo);
  _sendTimebaseUpdate(*a1, 0LL);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle mainBundle](&OBJC_CLASS___NSBundle, "mainBundle"));
  id v4 = v3;
  if (v3)
  {
    int v5 = (__CFString *)objc_claimAutoreleasedReturnValue([v3 bundlePath]);
    uint64_t v6 = (__CFString *)objc_claimAutoreleasedReturnValue([v4 executablePath]);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v4 bundleIdentifier]);
    if (v7) {
      id v8 = (__CFString *)objc_claimAutoreleasedReturnValue([v4 bundleIdentifier]);
    }
    else {
      id v8 = &stru_20FCB8;
    }
  }

  else
  {
    uint32_t bufsize = 0;
    uint64_t v9 = _NSGetExecutablePath(0LL, &bufsize);
    id v10 = (char *)GTCoreAlloc(v9, bufsize);
    uint64_t v6 = 0LL;
    id v8 = 0LL;
    int v5 = 0LL;
    if (!_NSGetExecutablePath(v10, &bufsize))
    {
      uint64_t v6 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v10));
      int v5 = (__CFString *)objc_claimAutoreleasedReturnValue(-[__CFString stringByDeletingLastPathComponent](v6, "stringByDeletingLastPathComponent"));
      id v8 = &stru_20FCB8;
    }

    vm_deallocate(mach_task_self_, (vm_address_t)v10, bufsize);
  }

  v21[0] = @"pid";
  int v11 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", getpid());
  uint64_t v12 = objc_claimAutoreleasedReturnValue(v11);
  double v13 = (void *)v12;
  if (v5) {
    timeval v14 = v5;
  }
  else {
    timeval v14 = &stru_20FCB8;
  }
  v22[0] = v12;
  v22[1] = v14;
  v21[1] = @"path";
  v21[2] = @"executable-path";
  v21[3] = @"identifier";
  if (v6) {
    __int128 v15 = v6;
  }
  else {
    __int128 v15 = &stru_20FCB8;
  }
  if (v8) {
    uint64_t v16 = v8;
  }
  else {
    uint64_t v16 = &stru_20FCB8;
  }
  v22[2] = v15;
  v22[3] = v16;
  id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v22,  v21,  4LL));

  id v18 = *a1;
  int v19 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:attributes:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:attributes:",  1536LL,  v17));
  [v18 send:v19 error:0];

  objc_autoreleasePoolPop(v2);
}

BOOL GTMTLGuestAppClient_supportsRemoteCapture(void *a1)
{
  return *a1 != 0LL;
}

id GTMTLGuestAppClient_copyDeviceProfiles(uint64_t a1)
{
  id v2 = objc_autoreleasePoolPush();
  id v3 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  id v4 = [*(id *)(a1 + 80) copy];
  os_unfair_lock_unlock(v3);
  objc_autoreleasePoolPop(v2);
  return v4;
}

void GTMTLGuestAppClientSendMTLCaptureScopeInfo(uint64_t a1, void *a2)
{
  id v3 = (os_unfair_lock_s *)(a1 + 32);
  id v4 = a2;
  os_unfair_lock_lock(v3);
  id v11 = objc_alloc_init(&OBJC_CLASS___GTCaptureObjects);
  int v5 = GTMTLGuestAppClient_captureDevicesUnsafe(a1);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  [v11 setDevices:v6];

  [v11 setCommandQueues:*(void *)(a1 + 88)];
  [v11 setCaptureScopes:v4];
  id v7 = AllMetalLayers();
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  [v11 setMetalLayers:v8];

  [*(id *)(a1 + 8) notifyCaptureObjectsChanged:v11];
  os_unfair_lock_unlock(v3);
  uint64_t v9 = *(void **)a1;
  id v10 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:objectPayload:",  1549LL,  v4));

  [v9 send:v10 error:0];
}

void GTMTLGuestAppClientUpdateMTLCommandQueueInfo(uint64_t a1)
{
  id v2 = objc_autoreleasePoolPush();
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  id v3 = *(void **)(a1 + 8);
  id v4 = GTMTLGuestAppClient_allCaptureObjectsUnsafe(a1);
  int v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  [v3 notifyCaptureObjectsChanged:v5];

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:objectPayload:",  1547LL,  *(void *)(a1 + 88)));
  [*(id *)a1 send:v6 error:0];
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));

  objc_autoreleasePoolPop(v2);
}

void GTMTLGuestAppClientAddMTLCommandQueueInfo(uint64_t a1, void *a2)
{
  id v21 = a2;
  id v3 = objc_autoreleasePoolPush();
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v21 device]);
  id v5 = DEVICEOBJECT(v4);
  id v6 = (id)objc_claimAutoreleasedReturnValue(v5);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  id v7 = (char *)[*(id *)(a1 + 80) count];
  id v8 = 0LL;
  if (v7)
  {
    while (1)
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 80) objectAtIndexedSubscript:v8]);
      id v10 = (id)objc_claimAutoreleasedReturnValue([v9 device]);

      if (v10 == v6) {
        break;
      }
      if (v7 == ++v8) {
        goto LABEL_6;
      }
    }
  }

  if (v8 == v7)
  {
LABEL_6:
    id v11 = DEVICEOBJECT(v6);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
    id v13 = newProfileWithMTLDevice(v12);
    timeval v14 = (void *)objc_claimAutoreleasedReturnValue(v13);

    [v14 setDevice:v6];
    [*(id *)(a1 + 80) addObject:v14];
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));

  id v15 = newDYMTLCommandQueueInfo(v21);
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  [*(id *)(a1 + 88) addObject:v16];
  GTTelemetry_addCommandQueue(v21);
  id v17 = *(void **)(a1 + 8);
  id v18 = GTMTLGuestAppClient_allCaptureObjectsUnsafe(a1);
  int v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
  [v17 notifyCaptureObjectsChanged:v19];

  __int128 v20 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:objectPayload:",  1547LL,  *(void *)(a1 + 88)));
  [*(id *)a1 send:v20 error:0];
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));

  objc_autoreleasePoolPop(v3);
}

void GTMTLGuestAppClientRemoveMTLCommandQueueInfo(uint64_t a1, void *a2)
{
  id v17 = a2;
  id v3 = objc_autoreleasePoolPush();
  id v4 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  id v5 = (char *)[*(id *)(a1 + 88) count];
  if (v5)
  {
    id v6 = v5;
    id v7 = 0LL;
    while (1)
    {
      id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 88) objectAtIndex:v7]);
      id v9 = [v8 streamRef];
      id v10 = [v17 streamReference];

      if (v9 == v10) {
        break;
      }
      if (v6 == ++v7)
      {
        id v7 = v6;
        break;
      }
    }
  }

  else
  {
    id v7 = 0LL;
  }

  id v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 88) lastObject]);
  [*(id *)(a1 + 88) replaceObjectAtIndex:v7 withObject:v11];
  [*(id *)(a1 + 88) removeLastObject];
  GTTelemetry_removeCommandQueue(v17);
  uint64_t v12 = *(void **)(a1 + 8);
  id v13 = GTMTLGuestAppClient_allCaptureObjectsUnsafe(a1);
  timeval v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
  [v12 notifyCaptureObjectsChanged:v14];

  id v15 = *(void **)a1;
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:objectPayload:",  1547LL,  *(void *)(a1 + 88)));
  [v15 send:v16 error:0];

  os_unfair_lock_unlock(v4);
  objc_autoreleasePoolPop(v3);
}

void GTMTLGuestAppClient_addCaptureDevice(uint64_t a1, void *a2)
{
  id v5 = a2;
  id v3 = objc_autoreleasePoolPush();
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v5 baseObject]);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  if ([*(id *)(a1 + 96) containsObject:v5])
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
  }

  else
  {
    [*(id *)(a1 + 96) addObject:v5];
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
    GTMTLGuestAppClientUpdateMTLDeviceInfo(a1);
    GTTelemetry_addDevice(v5);
  }

  objc_autoreleasePoolPop(v3);
}

id GTMTLGuestAppClient_copyCaptureDevices(uint64_t a1)
{
  id v2 = objc_autoreleasePoolPush();
  id v3 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  id v4 = [*(id *)(a1 + 96) copy];
  os_unfair_lock_unlock(v3);
  objc_autoreleasePoolPop(v2);
  return v4;
}

uint64_t GTMTLGuestAppClient_isUsingNewTransport()
{
  return *(unsigned __int8 *)(g_guestAppClientMTL + 129);
}

uint64_t GTMTLGuestAppClient_advanceToNextFrame(uint64_t a1)
{
  id v1 = (unint64_t *)(a1 + 64);
  do
    uint64_t v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  if ((*(_BYTE *)(a1 + 48) & 1) != 0) {
    GTMTLGuestAppClient_collectFrameProfilingData(a1, v2);
  }
  return v2 + 1;
}

void GTMTLGuestAppClient_collectFrameProfilingData(uint64_t a1, uint64_t a2)
{
  id v4 = objc_autoreleasePoolPush();
  uint64_t v5 = mach_absolute_time();
  unint64_t v6 = v5 - *(void *)(a1 + 40);
  if (g_DYTimebaseInfo != dword_23A1CC) {
    unint64_t v6 = __udivti3(g_DYTimebaseInfo * v6, (g_DYTimebaseInfo * (unsigned __int128)v6) >> 64);
  }
  if (v6 >= *(void *)(a1 + 56))
  {
    v35[0] = @"frame index";
    id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a2));
    v36[0] = v7;
    v35[1] = @"frame duration";
    id v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v6));
    v36[1] = v8;
    v35[2] = @"timestamp";
    uint64_t v9 = v5;
    if (g_DYTimebaseInfo != dword_23A1CC) {
      uint64_t v9 = __udivti3( g_DYTimebaseInfo * v5,  (g_DYTimebaseInfo * (unsigned __int128)v5) >> 64);
    }
    id v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v9));
    v36[2] = v10;
    id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v36,  v35,  3LL));
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v11));

    if ((*(_BYTE *)(a1 + 49) & 1) != 0 && *(_DWORD *)(a1 + 36))
    {
      id v28 = v12;
      id v29 = v4;
      id v13 = GTMTLGuestAppClient_copyCaptureDevices(a1);
      timeval v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
      id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v14 count]));
      __int128 v30 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      id v16 = v14;
      id v17 = [v16 countByEnumeratingWithState:&v30 objects:v34 count:16];
      if (v17)
      {
        id v18 = v17;
        uint64_t v19 = *(void *)v31;
        do
        {
          for (uint64_t i = 0LL; i != v18; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v31 != v19) {
              objc_enumerationMutation(v16);
            }
            id v21 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v30 + 1) + 8 * (void)i) baseObject]);
            CFTypeRef CFProperty = IORegistryEntryCreateCFProperty( (io_registry_entry_t)[v21 acceleratorPort],  @"PerformanceStatistics",  kCFAllocatorDefault,  0);
            if (CFProperty)
            {
              id v23 = (void *)CFProperty;
              [v15 addObject:CFProperty];
            }
          }

          id v18 = [v16 countByEnumeratingWithState:&v30 objects:v34 count:16];
        }

        while (v18);
      }

      uint64_t v12 = v28;
      [v28 setObject:v15 forKeyedSubscript:@"PerformanceStatisticsActiveDevices"];
      CFTypeRef v24 = IORegistryEntryCreateCFProperty( *(_DWORD *)(a1 + 36),  @"PerformanceStatistics",  kCFAllocatorDefault,  0);
      if (v24)
      {
        int v25 = (void *)v24;
        [v28 setObject:v24 forKeyedSubscript:@"PerformanceStatistics"];
      }

      id v4 = v29;
    }

    id v26 = *(void **)a1;
    double v27 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:plistPayload:",  1541LL,  v12));
    [v26 send:v27 error:0];

    *(void *)(a1 + 40) = v5;
  }

  objc_autoreleasePoolPop(v4);
}

void FillCaptureDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  id v4 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = 0LL;

  id v54 = (id)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"HostCaptureArchivePath"]);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"sandbox_extensions"]);
  id v53 = v5;
  if (v5) {
    uint64_t v6 = sandbox_extension_consume([v5 UTF8String]);
  }
  else {
    uint64_t v6 = -1LL;
  }
  *(void *)(a1 + 56) = v6;
  id v7 = NSTemporaryDirectory();
  id v52 = (id)objc_claimAutoreleasedReturnValue(v7);

  id v8 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"Serial"]);
  uint64_t v9 = [v8 unsignedIntValue];

  *(void *)(a1 + 32) = v9;
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"TriggerFrame"]);
  *(void *)(a1 + 40) = [v10 unsignedLongLongValue];

  id v11 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"FrameLimit"]);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = [v11 unsignedLongLongValue];

  id v12 = v3;
  __int128 v55 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"IsBoundaryLess"]);
  uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSNumber, v13);
  if ((objc_opt_isKindOfClass(v55, v14) & 1) != 0 && [v55 BOOLValue])
  {
    *(_DWORD *)(a1 + 80) = 0;
    *(_BYTE *)(a1 + 86) = 1;
  }

  else
  {
    id v15 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"CaptureDeviceName"]);
    if (!v15) {
      goto LABEL_21;
    }
    uint64_t v16 = g_guestAppClientMTL;
    locuint64_t k = (os_unfair_lock_s *)(g_guestAppClientMTL + 32);
    os_unfair_lock_lock((os_unfair_lock_t)(g_guestAppClientMTL + 32));
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    __int128 v56 = 0u;
    __int128 v57 = 0u;
    id v17 = *(id *)(v16 + 96);
    id v18 = [v17 countByEnumeratingWithState:&v56 objects:v60 count:16];
    if (v18)
    {
      uint64_t v19 = *(void *)v57;
      while (2)
      {
        for (uint64_t i = 0LL; i != v18; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v57 != v19) {
            objc_enumerationMutation(v17);
          }
          id v21 = *(void **)(*((void *)&v56 + 1) + 8LL * (void)i);
          int v22 = (void *)objc_claimAutoreleasedReturnValue([v21 name]);
          unsigned int v23 = [v22 isEqualToString:v15];

          if (v23)
          {
            id v24 = v21;
            goto LABEL_18;
          }
        }

        id v18 = [v17 countByEnumeratingWithState:&v56 objects:v60 count:16];
        if (v18) {
          continue;
        }
        break;
      }
    }

    id v24 = 0LL;
LABEL_18:

    os_unfair_lock_unlock(lock);
    if (v24)
    {
      *(_DWORD *)(a1 + 80) = *(void *)(a1 + 48) != 0LL;
      int v25 = (uint64_t *)[v24 traceStream];
      if (v25) {
        uint64_t v26 = *v25;
      }
      else {
        uint64_t v26 = 0LL;
      }
      *(void *)a1 = v26;
    }

    else
    {
LABEL_21:
      double v27 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"CaptureLayerAddress"]);
      id v28 = [v27 unsignedLongLongValue];

      if (v28
        && (id MetalLayerWithAddress = FindMetalLayerWithAddress(v28),
            uint64_t v30 = objc_claimAutoreleasedReturnValue(MetalLayerWithAddress),
            (id v24 = (id)v30) != 0LL))
      {
        *(_DWORD *)(a1 + 80) = 6;
        if ((objc_opt_respondsToSelector(v30, "streamReference") & 1) != 0) {
          id v31 = [v24 streamReference];
        }
        else {
          id v31 = 0LL;
        }
        *(void *)(a1 + 24) = v31;
        double v42 = (void *)objc_claimAutoreleasedReturnValue([v24 device]);
        *(void *)a1 = [v42 streamReference];
      }

      else
      {
        __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"CaptureScopeID"]);
        __int128 v49 = v32;
        if (v32) {
          id v24 = (id)objc_claimAutoreleasedReturnValue( +[GTMTLCaptureScopeInfo getInfoWithStreamRef:]( GTMTLCaptureScopeInfo,  "getInfoWithStreamRef:",  [v32 unsignedLongLongValue]));
        }
        else {
          id v24 = 0LL;
        }
        os_unfair_lock_t locka = (os_unfair_lock_t)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"CaptureScopeAddress"]);
        if (!v24 && locka) {
          id v24 = (id)objc_claimAutoreleasedReturnValue( +[GTMTLCaptureScopeInfo getInfoWithAddress:]( &OBJC_CLASS___GTMTLCaptureScopeInfo,  "getInfoWithAddress:",  -[os_unfair_lock_s unsignedLongLongValue](locka, "unsignedLongLongValue")));
        }
        if (v24)
        {
          *(_DWORD *)(a1 + 80) = 4;
          *(void *)(a1 + 16) = [v24 scopeStreamRef];
          *(void *)(a1 + _Block_object_dispose(va, 8) = [v24 commandQueueStreamRef];
          *(void *)a1 = [v24 deviceStreamRef];
        }

        else
        {
          __int128 v33 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"CaptureCommandQueueAddress"]);
          id v34 = [v33 unsignedLongLongValue];

          if (!v34) {
            goto LABEL_53;
          }
          uint64_t v35 = g_guestAppClientMTL;
          uint64_t v48 = (os_unfair_lock_s *)(g_guestAppClientMTL + 32);
          os_unfair_lock_lock((os_unfair_lock_t)(g_guestAppClientMTL + 32));
          __int128 v58 = 0u;
          __int128 v59 = 0u;
          __int128 v56 = 0u;
          __int128 v57 = 0u;
          id v36 = *(id *)(v35 + 88);
          id v37 = [v36 countByEnumeratingWithState:&v56 objects:v60 count:16];
          if (v37)
          {
            uint64_t v38 = *(void *)v57;
            while (2)
            {
              for (uint64_t j = 0LL; j != v37; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v57 != v38) {
                  objc_enumerationMutation(v36);
                }
                int v40 = *(void **)(*((void *)&v56 + 1) + 8LL * (void)j);
                if ([v40 queueAddress] == v34)
                {
                  id v41 = v40;
                  goto LABEL_48;
                }
              }

              id v37 = [v36 countByEnumeratingWithState:&v56 objects:v60 count:16];
              if (v37) {
                continue;
              }
              break;
            }
          }

          id v41 = 0LL;
LABEL_48:

          os_unfair_lock_unlock(v48);
          if (v41)
          {
            if (*(void *)(a1 + 48)) {
              int v43 = 3;
            }
            else {
              int v43 = 2;
            }
            *(_DWORD *)(a1 + 80) = v43;
            *(void *)(a1 + _Block_object_dispose(va, 8) = [v41 streamRef];
            *(void *)a1 = [v41 deviceStreamRef];
          }

          else
          {
LABEL_53:
            *(_DWORD *)(a1 + 80) = 5;
          }
        }
      }
    }
  }

  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"SuspendAfterCompletion"]);
  *(_BYTE *)(a1 + 84) = [v44 BOOLValue];

  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"LockOpenGLAfterCompletion"]);
  *(_BYTE *)(a1 + 85) = [v45 BOOLValue];

  id v46 = v52;
  *(void *)(a1 + 64) = [v46 UTF8String];
  id v47 = v54;
  *(void *)(a1 + 72) = [v47 UTF8String];
  *(_BYTE *)(a1 + 92) = 1;
}

void GTMTLGuestAppClient_processMessage(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_autoreleasePoolPush();
  uint64_t v5 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    uint64_t v6 = v5;
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = GTMessageKindAsString((int)[v3 kind]);
    _os_signpost_emit_with_name_impl( &dword_0,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Capture-ProcessMessage",  "%s",  buf,  0xCu);
  }

  int v7 = [v3 kind];
  if (v7 > 1538)
  {
    if (v7 == 1539)
    {
      _sendTimebaseUpdate(*(void **)a1, v3);
      goto LABEL_29;
    }

    if (v7 != 1794)
    {
      if (v7 == 1793)
      {
        id v9 = v3;
        _setTraceMode(a1, (uint64_t)[v9 uint32ForKey:@"trace mode"]);
        *(_DWORD *)(a1 + 10_Block_object_dispose(va, 8) = [v9 uint64ForKey:@"trace host type"];
        *(void *)(a1 + 56) = [v9 uint64ForKey:@"profiling send period"];
        id v10 = [v9 uint64ForKey:@"profiling flags"];

        *(void *)(a1 + 4_Block_object_dispose(va, 8) = v10;
      }

      goto LABEL_29;
    }

    id v12 = v3;
    uint64_t v13 = [v12 uint32ForKey:@"override_flags"];
    if (*(void *)(a1 + 112) == v13) {
      goto LABEL_26;
    }
    if ((_DWORD)v13)
    {
      if (*(_DWORD *)(a1 + 104) == 7)
      {
LABEL_25:
        *(void *)(a1 + 112) = v13;
LABEL_26:
        if ((v13 & 0x40) != 0)
        {
          [v12 doubleForKey:@"override_scale_tesselation_factor"];
          *(void *)(a1 + 120) = v15;
        }

        goto LABEL_29;
      }

      uint64_t v14 = 7LL;
    }

    else
    {
      uint64_t v14 = 1LL;
    }

    _setTraceMode(a1, v14);
    goto LABEL_25;
  }

  switch(v7)
  {
    case 260:
      __int128 v27 = 0u;
      __int128 v26 = 0u;
      __int128 v25 = 0u;
      __int128 v24 = 0u;
      *(_OWORD *)&buf[8] = 0u;
      uint64_t v8 = 0x800000004LL;
      goto LABEL_13;
    case 264:
      id v28 = 0LL;
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v3 plistPayload]);
      FillCaptureDescriptor((uint64_t)buf, v11);

      if (_sharedCaptureManager)
      {
        GTMTLCaptureManager_updateCaptureDescriptorFromHost((uint64_t)buf);
      }

      else
      {
        __int128 v19 = 0u;
        __int128 v20 = 0u;
        __int128 v17 = 0u;
        __int128 v18 = 0u;
        uint64_t v16 = 0x700000004LL;
        uint64_t v21 = 0LL;
        int v22 = buf;
        GTCaptureBoundaryTracker_handleTrigger((__int128 *)&v16);
      }

      break;
    case 265:
      __int128 v27 = 0u;
      __int128 v26 = 0u;
      __int128 v25 = 0u;
      __int128 v24 = 0u;
      *(_OWORD *)&buf[8] = 0u;
      uint64_t v8 = 0x900000004LL;
LABEL_13:
      *(void *)buf = v8;
      GTCaptureBoundaryTracker_handleTrigger((__int128 *)buf);
      break;
  }

void sub_3FF60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33)
{
}

void _setTraceMode(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 104) = a2;
  uint64_t v2 = *(void **)a1;
  id v4 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a2));
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:objectPayload:",  1796LL,  v4));
  [v2 send:v3 error:0];
}

void GTMTLGuestAppClient_notifyCaptureRequest(uint64_t *a1)
{
  if (*(_BYTE *)(g_guestAppClientMTL + 129))
  {
    uint64_t v2 = objc_alloc(&OBJC_CLASS___GTCaptureDescriptor);
    do
      unsigned int v3 = __ldaxr((unsigned int *)&g_requestID);
    while (__stlxr(v3 + 1, (unsigned int *)&g_requestID));
    uint64_t v5 = -[GTCaptureDescriptor initWithRequestID:](v2, "initWithRequestID:", v3);
    -[GTCaptureDescriptor setTriggerHitsToStart:](v5, "setTriggerHitsToStart:", a1[5]);
    -[GTCaptureDescriptor setTriggerHitsToEnd:](v5, "setTriggerHitsToEnd:", a1[6]);
    -[GTCaptureDescriptor setSuspendAfterCapture:](v5, "setSuspendAfterCapture:", *((unsigned __int8 *)a1 + 84));
    -[GTCaptureDescriptor setIgnoreUnusedResources:](v5, "setIgnoreUnusedResources:", *((unsigned __int8 *)a1 + 91));
    switch(*((_DWORD *)a1 + 20))
    {
      case 0:
        uint64_t v4 = *a1;
        goto LABEL_11;
      case 1:
        uint64_t v4 = *a1;
        break;
      case 2:
        uint64_t v4 = a1[1];
LABEL_11:
        -[GTCaptureDescriptor setTriggerHitsToEnd:](v5, "setTriggerHitsToEnd:", -1LL);
        break;
      case 3:
        uint64_t v4 = a1[1];
        break;
      case 4:
        uint64_t v4 = a1[2];
        break;
      case 5:
      case 6:
        uint64_t v4 = a1[3];
        break;
      default:
        uint64_t v4 = 0LL;
        break;
    }

    -[GTCaptureDescriptor setStreamRef:](v5, "setStreamRef:", v4);
    dispatch_group_wait(*(dispatch_group_t *)(g_guestAppClientMTL + 24), 0xFFFFFFFFFFFFFFFFLL);
    [*(id *)(g_guestAppClientMTL + 8) notifyCaptureRequest:v5];
  }

void GTMTLGuestAppClient_notifyUnsupportedFenum(void *a1)
{
  id v2 = a1;
  unsigned int v3 = objc_autoreleasePoolPush();
  uint64_t v4 = (id *)g_guestAppClientMTL;
  os_unfair_lock_lock((os_unfair_lock_t)(g_guestAppClientMTL + 32));
  if (!*((_BYTE *)v4 + 128))
  {
    objc_storeStrong(v4 + 9, a1);
    [v4[1] notifyUnsupportedFenum:v2];
    if (v4[1]) {
      *((_BYTE *)v4 + 12_Block_object_dispose(va, 8) = 1;
    }
    v60[0] = @"fenum";
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v2 fenum]);
    if (v5) {
      uint64_t v6 = (__CFString *)objc_claimAutoreleasedReturnValue([v2 fenum]);
    }
    else {
      uint64_t v6 = &stru_20FCB8;
    }
    v61[0] = v6;
    v60[1] = @"category";
    id v7 = (id)objc_claimAutoreleasedReturnValue([v2 category]);
    if (v7) {
      uint64_t v8 = (__CFString *)objc_claimAutoreleasedReturnValue([v2 category]);
    }
    else {
      uint64_t v8 = &stru_20FCB8;
    }
    v61[1] = v8;
    v60[2] = @"customMessage";
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v2 customMessage]);
    if (v9) {
      id v10 = (__CFString *)objc_claimAutoreleasedReturnValue([v2 customMessage]);
    }
    else {
      id v10 = &stru_20FCB8;
    }
    v61[2] = v10;
    id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v61,  v60,  3LL));
    if (v9) {

    }
    if (v7) {
    if (v5)
    }

    id v12 = *v4;
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:objectPayload:",  4357LL,  v11));
    id v51 = 0LL;
    [v12 send:v13 error:&v51];
    id v14 = v51;

    if (*v4)
    {
      if (v14)
      {
        if (s_logUsingOsLog)
        {
          id v15 = gt_default_log();
          uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            __int128 v17 = (void *)objc_claimAutoreleasedReturnValue([v2 fenum]);
            if (v17)
            {
              uint64_t v4 = (id *) objc_claimAutoreleasedReturnValue([v2 fenum]);
              __int128 v18 = (const char *)[v4 UTF8String];
            }

            else
            {
              __int128 v18 = "(null)";
            }

            uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v14 localizedDescription]);
            if (v44)
            {
              uint64_t v8 = (__CFString *) objc_claimAutoreleasedReturnValue([v14 localizedDescription]);
              uint64_t v45 = (const char *)-[__CFString UTF8String](v8, "UTF8String");
            }

            else
            {
              uint64_t v45 = "(null)";
            }

            *(_DWORD *)buf = 136315394;
            id v53 = v18;
            __int16 v54 = 2080;
            __int128 v55 = v45;
            _os_log_error_impl( &dword_0,  v16,  OS_LOG_TYPE_ERROR,  "warning: Failed to send kGTMessageGuestAppUnsupportedFenumDetected with fenum %s, error: %s",  buf,  0x16u);
            if (v44) {

            }
            if (v17) {
          }
            }
        }

        else
        {
          uint64_t v48 = __stderrp;
          uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue([v2 fenum]);
          if (v16)
          {
            uint64_t v4 = (id *) objc_claimAutoreleasedReturnValue([v2 fenum]);
            __int128 v19 = (const char *)[v4 UTF8String];
          }

          else
          {
            __int128 v19 = "(null)";
          }

          __int128 v20 = (void *)objc_claimAutoreleasedReturnValue([v14 localizedDescription]);
          if (v20)
          {
            id v7 = objc_claimAutoreleasedReturnValue([v14 localizedDescription]);
            uint64_t v21 = (const char *)[v7 UTF8String];
          }

          else
          {
            uint64_t v21 = "(null)";
          }

          id v22 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"warning: Failed to send kGTMessageGuestAppUnsupportedFenumDetected with fenum %s, error: %s", v19, v21));
          fprintf(v48, "%s\n", (const char *)[v22 UTF8String]);

          if (v20) {
          if (v16)
          }
        }
      }

      else
      {
        *((_BYTE *)v4 + 12_Block_object_dispose(va, 8) = 1;
      }
    }

    if ((qword_23A448 & 2) != 0)
    {
      unsigned int v23 = (void *)objc_claimAutoreleasedReturnValue([v2 asError]);
      __int128 v24 = v23;
      if (s_logUsingOsLog)
      {
        id v25 = gt_default_log();
        __int128 v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
        {
          id v47 = (const char *)[v24 code];
          __int128 v49 = (FILE *) objc_claimAutoreleasedReturnValue([v24 localizedDescription]);
          __int128 v27 = (const char *)-[FILE UTF8String](v49, "UTF8String");
          if (v27) {
            id v28 = v27;
          }
          else {
            id v28 = "(unknown)";
          }
          id v29 = objc_claimAutoreleasedReturnValue([v24 localizedFailureReason]);
          uint64_t v30 = (const char *)[v29 UTF8String];
          if (v30) {
            id v31 = v30;
          }
          else {
            id v31 = "";
          }
          id v32 = objc_claimAutoreleasedReturnValue([v24 localizedRecoverySuggestion]);
          __int128 v33 = (const char *)[v32 UTF8String];
          *(_DWORD *)buf = 134218754;
          id v34 = "none";
          id v53 = v47;
          if (v33) {
            id v34 = v33;
          }
          __int16 v54 = 2080;
          __int128 v55 = v28;
          __int16 v56 = 2080;
          __int128 v57 = v31;
          __int16 v58 = 2080;
          __int128 v59 = v34;
          _os_log_fault_impl( &dword_0,  v26,  OS_LOG_TYPE_FAULT,  "fail: error (%ld): %s %s [recommendation: %s]",  buf,  0x2Au);
        }
      }

      else
      {
        id v50 = __stderrp;
        id v46 = [v23 code];
        __int128 v26 = (os_log_s *) objc_claimAutoreleasedReturnValue([v24 localizedDescription]);
        uint64_t v35 = (const char *)-[os_log_s UTF8String](v26, "UTF8String");
        if (v35) {
          id v36 = v35;
        }
        else {
          id v36 = "(unknown)";
        }
        id v37 = objc_claimAutoreleasedReturnValue([v24 localizedFailureReason]);
        uint64_t v38 = (const char *)[v37 UTF8String];
        if (v38) {
          double v39 = v38;
        }
        else {
          double v39 = "";
        }
        id v40 = objc_claimAutoreleasedReturnValue([v24 localizedRecoverySuggestion]);
        id v41 = (const char *)[v40 UTF8String];
        double v42 = "none";
        if (v41) {
          double v42 = v41;
        }
        id v43 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"fail: error (%ld): %s %s [recommendation: %s]", v46, v36, v39, v42));
        fprintf(v50, "%s\n", (const char *)[v43 UTF8String]);
      }
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(g_guestAppClientMTL + 32));
  objc_autoreleasePoolPop(v3);
}

BOOL GTMTLGuestAppClient_unsupportedFenumDetected()
{
  BOOL v0 = *(void *)(g_guestAppClientMTL + 72) != 0LL;
  os_unfair_lock_unlock((os_unfair_lock_t)(g_guestAppClientMTL + 32));
  return v0;
}

id GTMTLGuestAppClient_getUnsupportedFenumInfo()
{
  id v0 = *(id *)(g_guestAppClientMTL + 72);
  os_unfair_lock_unlock((os_unfair_lock_t)(g_guestAppClientMTL + 32));
  return v0;
}

void SaveMTLComputePipelineReflection(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  if (v9)
  {
    context = objc_autoreleasePoolPush();
    uint64_t v14 = objc_opt_class(&OBJC_CLASS___MTLDebugComputePipelineState, v13);
    if ((objc_opt_isKindOfClass(v9, v14) & 1) != 0)
    {
      uint64_t v15 = objc_claimAutoreleasedReturnValue([v9 reflection]);

      id v10 = (id)v15;
    }

    id v91 = v12;
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v10 performanceStatistics]);
    id v110 = 0LL;
    __int128 v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v16,  1LL,  &v110));
    id v94 = v110;

    __int128 v18 = 0LL;
    if ((objc_opt_respondsToSelector(v10, "pluginReturnData") & 1) != 0)
    {
      __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([v10 pluginReturnData]);
      id PluginReturnData = GetPluginReturnData((uint64_t)v19);
      __int128 v18 = (void *)objc_claimAutoreleasedReturnValue(PluginReturnData);
    }

    __int128 v109 = 0u;
    memset(v108, 0, sizeof(v108));
    __int128 v93 = v10;
    TranslateGTMTLComputePipelineReflection(v10, v108, 0LL);
    id v21 = v17;
    [v21 bytes];
    id v22 = (char *)[v21 length];
    uint64_t v23 = *((void *)&v109 + 1);
    id v24 = v18;
    [v24 bytes];
    id v95 = v24;
    id v25 = &v22[(void)[v24 length] + v23];
    *((void *)&v109 + 1) = v25;
    __int128 v26 = v11;
    if (!v11 && v91)
    {
      __int128 v26 = objc_alloc_init(&OBJC_CLASS___MTLComputePipelineDescriptor);
      -[MTLComputePipelineDescriptor setComputeFunction:](v26, "setComputeFunction:", v91);
    }

    __int128 v90 = v9;
    __int128 v92 = v26;
    if (v26)
    {
      __int128 v27 = (void *)objc_claimAutoreleasedReturnValue([v9 device]);
      id v107 = v94;
      __int128 v26 = (MTLComputePipelineDescriptor *)[v27 loadDynamicLibrariesForComputeDescriptor:v26 error:&v107];
      id v28 = v107;

      id v94 = v28;
    }

    __int128 v105 = 0u;
    __int128 v106 = 0u;
    __int128 v104 = 0u;
    __int128 v103 = 0u;
    id v29 = v26;
    id v30 = -[MTLComputePipelineDescriptor countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v103,  v112,  16LL);
    if (v30)
    {
      id v31 = v30;
      uint64_t v87 = a1;
      unsigned int v32 = 0;
      uint64_t v33 = *(void *)v104;
      do
      {
        for (uint64_t i = 0LL; i != v31; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v104 != v33) {
            objc_enumerationMutation(v29);
          }
          uint64_t v35 = *(void **)(*((void *)&v103 + 1) + 8LL * (void)i);
          id v36 = (void *)objc_claimAutoreleasedReturnValue([v35 libraryPath]);

          if (v36)
          {
            id v37 = objc_claimAutoreleasedReturnValue([v35 libraryPath]);
            [v37 UTF8String];
            id v38 = objc_claimAutoreleasedReturnValue([v35 libraryPath]);
            if ([v38 UTF8String])
            {
              id v39 = objc_claimAutoreleasedReturnValue([v35 libraryPath]);
              v25 += strlen((const char *)[v39 UTF8String]) + 1;
            }

            ++v32;
          }
        }

        id v31 = -[MTLComputePipelineDescriptor countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v103,  v112,  16LL);
      }

      while (v31);
      *((void *)&v109 + 1) = v25;
      a1 = v87;
    }

    else
    {
      unsigned int v32 = 0;
    }

    *(void *)&__int128 v109 = v109 + 16LL * v32;
    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v108, 0x78u);
    uint64_t v40 = TranslateGTMTLComputePipelineReflection(v93, v108, 1LL);
    id v41 = v21;
    id v42 = [v41 bytes];
    __int128 v88 = v41;
    id v43 = (char *)[v41 length];
    uint64_t v44 = v43;
    if (v43) {
      uint64_t v45 = (void *)*((void *)&v109 + 1);
    }
    else {
      uint64_t v45 = 0LL;
    }
    id v46 = &v43[*((void *)&v109 + 1)];
    memcpy(v45, v42, (size_t)v43);
    *(void *)(v40 + 56) = v45;
    *(void *)(v40 + 64) = v44;
    id v47 = v95;
    id v48 = [v47 bytes];
    __int128 v86 = v47;
    __int128 v49 = (char *)[v47 length];
    id v50 = v49;
    if (v49) {
      id v51 = v46;
    }
    else {
      id v51 = 0LL;
    }
    id v52 = &v49[(void)v46];
    *((void *)&v109 + 1) = &v49[(void)v46];
    memcpy(v51, v48, (size_t)v49);
    *(void *)(v40 + 72) = v51;
    *(void *)(v40 + 80) = v50;
    if (v32) {
      uint64_t v53 = v109;
    }
    else {
      uint64_t v53 = 0LL;
    }
    uint64_t v54 = v109 + 8LL * v32;
    if (v32) {
      uint64_t v55 = v109 + 8LL * v32;
    }
    else {
      uint64_t v55 = 0LL;
    }
    *(void *)(v40 + 40) = v53;
    *(void *)(v40 + 4_Block_object_dispose(va, 8) = v55;
    *(void *)&__int128 v109 = v54 + 8LL * v32;
    *(_WORD *)(v40 + 96) = 0;
    __int128 v99 = 0u;
    __int128 v100 = 0u;
    __int128 v101 = 0u;
    __int128 v102 = 0u;
    __int16 v56 = v29;
    id v57 = -[MTLComputePipelineDescriptor countByEnumeratingWithState:objects:count:]( v56,  "countByEnumeratingWithState:objects:count:",  &v99,  v111,  16LL);
    uint64_t v96 = v56;
    if (v57)
    {
      id v58 = v57;
      uint64_t v59 = *(void *)v100;
      do
      {
        for (uint64_t j = 0LL; j != v58; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v100 != v59) {
            objc_enumerationMutation(v56);
          }
          id v61 = *(void **)(*((void *)&v99 + 1) + 8LL * (void)j);
          __int128 v62 = (void *)objc_claimAutoreleasedReturnValue([v61 libraryPath]);

          if (v62)
          {
            id v63 = objc_claimAutoreleasedReturnValue([v61 libraryPath]);
            id v64 = [v63 UTF8String];
            id v65 = objc_claimAutoreleasedReturnValue([v61 libraryPath]);
            if ([v65 UTF8String])
            {
              id v66 = objc_claimAutoreleasedReturnValue([v61 libraryPath]);
              size_t v67 = strlen((const char *)[v66 UTF8String]);
              size_t v68 = v67 + 1;
              if (v67 == -1LL)
              {
                __int128 v69 = 0LL;
                *((void *)&v109 + 1) = v52;
              }

              else
              {
                uint64_t v70 = &v52[v68];
                *((void *)&v109 + 1) = &v52[v68];
                memcpy(v52, v64, v68);
                __int128 v69 = v52;
                id v52 = v70;
                __int16 v56 = v96;
              }

              *(void *)(*(void *)(v40 + 48) + 8LL * *(unsigned __int16 *)(v40 + 96)) = v69;
            }

            else
            {
              *((void *)&v109 + 1) = v52;
              *(void *)(*(void *)(v40 + 48) + 8LL * *(unsigned __int16 *)(v40 + 96)) = 0LL;
            }

            uint64_t v71 = *(unsigned __int16 *)(v40 + 96);
            *(void *)(*(void *)(v40 + 40) + 8 * v71) = 0LL;
            *(_WORD *)(v40 + 96) = v71 + 1;
          }
        }

        id v58 = -[MTLComputePipelineDescriptor countByEnumeratingWithState:objects:count:]( v56,  "countByEnumeratingWithState:objects:count:",  &v99,  v111,  16LL);
      }

      while (v58);
    }

    GTMTLComputePipelineReflection_resourceAccess(v40, (uint64_t)v97);
    __int128 v72 = v97[1];
    *(_OWORD *)(v40 + 104) = v97[0];
    *(_OWORD *)(v40 + 120) = v72;
    *(_OWORD *)(v40 + 136) = v97[2];
    *(void *)(v40 + 152) = v98;
    id v73 = (id)objc_claimAutoreleasedReturnValue(-[MTLComputePipelineDescriptor stageInputDescriptor](v92, "stageInputDescriptor"));
    id v10 = v93;
    if (v73)
    {
      uint64_t v74 = 0LL;
      while (1)
      {
        unsigned __int8 v75 = (void *)objc_claimAutoreleasedReturnValue([v73 attributes]);
        uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue([v75 objectAtIndexedSubscript:v74]);

        if ([v76 format])
        {
          id v77 = [v76 bufferIndex];
          if ((unint64_t)v77 <= 0x1E)
          {
            id v78 = v77;
            __int128 v79 = (void *)objc_claimAutoreleasedReturnValue([v73 layouts]);
            int v80 = (void *)objc_claimAutoreleasedReturnValue([v79 objectAtIndexedSubscript:v78]);
            uint64_t v81 = (char *)[v80 stepFunction];
          }
        }

        if (++v74 == 31) {
          goto LABEL_57;
        }
      }

      id v11 = v92;
      uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue(-[MTLComputePipelineDescriptor stageInputDescriptor](v92, "stageInputDescriptor"));
      uint64_t v85 = (uint64_t)[v84 indexBufferIndex];

      *(void *)(v40 + 104 + 16LL * (int)(v85 >> 6)) |= 1LL << v85;
    }

    else
    {
LABEL_57:

      id v11 = v92;
    }

    id v9 = v90;
    id v82 = DEVICEOBJECT(v90);
    uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue(v82);
    id v12 = v91;
    if ((objc_opt_respondsToSelector(v83, "supportIndirectCommandBuffers") & 1) != 0)
    {
      if ([v83 supportIndirectCommandBuffers])
      {
        *(void *)uint64_t v40 = [v83 uniqueIdentifier];
        *(void *)(v40 + _Block_object_dispose(va, 8) = [v83 resourceIndex];
        if ((objc_opt_respondsToSelector(v83, "gpuResourceID") & 1) != 0) {
          *(void *)(v40 + 16) = [v83 gpuResourceID];
        }
      }
    }

    if ((objc_opt_respondsToSelector(v83, "allocatedSize") & 1) != 0) {
      *(_DWORD *)(v40 + 8_Block_object_dispose(va, 8) = [v83 allocatedSize];
    }

    objc_autoreleasePoolPop(context);
  }
}

id GetPluginReturnData(uint64_t a1)
{
  if (a1)
  {
    id v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization propertyListWithData:options:format:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "propertyListWithData:options:format:error:",  a1,  0LL,  0LL,  0LL));
    id v2 = v1;
    if (v1) {
      unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue([v1 objectForKeyedSubscript:@"metalLib"]);
    }
    else {
      unsigned int v3 = 0LL;
    }
  }

  else
  {
    unsigned int v3 = 0LL;
  }

  return v3;
}

uint64_t AllocatePipelineReflectionWithType(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4 = 0LL;
  int64x2_t v5 = 0uLL;
  int64x2_t v6 = vdupq_n_s64(7uLL);
  int8x16_t v7 = (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFF8LL);
  do
  {
    int64x2_t v5 = vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vaddq_s64(*(int64x2_t *)(a2 + v4), v6), v7), v5);
    v4 += 16LL;
  }

  while (v4 != 192);
  uint64_t v8 = *(void *)(*(void *)(a1 + 8) + 24LL);
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 42);
  *(_BYTE *)(a1 + 42) = v10 + 1;
  Bytes = GTTraceMemPool_allocateBytes(v8, v9, (vaddvq_s64(v5) << 32) | ((unint64_t)a3 << 16) | v10 | 0x100);
  uint64_t v12 = 0LL;
  uint64_t v13 = Bytes + 16;
  do
  {
    if (((*(void *)(a2 + v12) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) != 0) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0LL;
    }
    v13 += (*(void *)(a2 + v12) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    *(void *)(a2 + v12) = v14;
    v12 += 8LL;
  }

  while (v12 != 192);
  return Bytes[8];
}

void SaveMTLRenderPipelineReflection(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v7)
  {
    context = objc_autoreleasePoolPush();
    uint64_t v11 = objc_opt_class(&OBJC_CLASS___MTLDebugRenderPipelineState, v10);
    uint64_t v80 = a1;
    if ((objc_opt_isKindOfClass(v7, v11) & 1) != 0)
    {
      uint64_t v12 = objc_claimAutoreleasedReturnValue([v7 reflection]);

      id v8 = (id)v12;
    }

    uint64_t v85 = v7;
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v8 performanceStatistics]);
    id v98 = 0LL;
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v13,  1LL,  &v98));
    id v82 = v98;

    uint64_t v15 = 0LL;
    uint64_t v16 = 0LL;
    if ((objc_opt_respondsToSelector(v8, "vertexPluginReturnData") & 1) != 0)
    {
      __int128 v17 = (void *)objc_claimAutoreleasedReturnValue([v8 vertexPluginReturnData]);
      id PluginReturnData = GetPluginReturnData((uint64_t)v17);
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(PluginReturnData);

      __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([v8 fragmentPluginReturnData]);
      id v20 = GetPluginReturnData((uint64_t)v19);
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v20);
    }

    __int128 v97 = 0u;
    memset(v96, 0, sizeof(v96));
    TranslateGTMTLRenderPipelineReflection(v8, v96, 0LL);
    id v21 = v14;
    [v21 bytes];
    id v22 = [v21 length];
    uint64_t v23 = *((void *)&v97 + 1);
    id v24 = v16;
    [v24 bytes];
    id v78 = v24;
    id v25 = (char *)[v24 length] + v23;
    id v26 = v15;
    [v26 bytes];
    id v77 = v26;
    __int128 v27 = (char *)[v26 length] + (void)v25 + (unint64_t)v22;
    *((void *)&v97 + 1) = v27;
    __int128 v92 = 0u;
    __int128 v93 = 0u;
    __int128 v94 = 0u;
    __int128 v95 = 0u;
    id v84 = v9;
    id v28 = v9;
    id v29 = [v28 countByEnumeratingWithState:&v92 objects:v100 count:16];
    id v86 = v8;
    if (v29)
    {
      id v30 = v29;
      int v31 = 0;
      uint64_t v32 = *(void *)v93;
      do
      {
        for (uint64_t i = 0LL; i != v30; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v93 != v32) {
            objc_enumerationMutation(v28);
          }
          id v34 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v92 + 1) + 8 * (void)i) libraryPath]);
          uint64_t v35 = v34;
          if (v34)
          {
            id v36 = v34;
            [v36 UTF8String];
            id v37 = v36;
            if ([v37 UTF8String]) {
              size_t v38 = strlen((const char *)[v37 UTF8String]) + 1;
            }
            else {
              size_t v38 = 0LL;
            }
            v27 += v38;
            ++v31;
          }
        }

        id v30 = [v28 countByEnumeratingWithState:&v92 objects:v100 count:16];
      }

      while (v30);
      *((void *)&v97 + 1) = v27;
      id v8 = v86;
    }

    else
    {
      int v31 = 0;
    }

    *(void *)&__int128 v97 = v97 + 16LL * v31;
    *(_BYTE *)(*(void *)(v80 + 16) + 14LL) = AllocatePipelineReflectionWithType(v80, (uint64_t)v96, 0x77u);
    uint64_t v39 = TranslateGTMTLRenderPipelineReflection(v8, v96, 1LL);
    id v40 = v21;
    id v41 = [v40 bytes];
    uint64_t v81 = v40;
    id v42 = (char *)[v40 length];
    id v43 = v42;
    if (v42) {
      uint64_t v44 = (void *)*((void *)&v97 + 1);
    }
    else {
      uint64_t v44 = 0LL;
    }
    uint64_t v45 = &v42[*((void *)&v97 + 1)];
    memcpy(v44, v41, (size_t)v42);
    *(void *)(v39 + 112) = v44;
    *(void *)(v39 + 120) = v43;
    id v46 = v78;
    id v47 = [v46 bytes];
    id v79 = v46;
    id v48 = (char *)[v46 length];
    __int128 v49 = v48;
    if (v48) {
      id v50 = v45;
    }
    else {
      id v50 = 0LL;
    }
    id v51 = &v48[(void)v45];
    memcpy(v50, v47, (size_t)v48);
    *(void *)(v39 + 12_Block_object_dispose(va, 8) = v50;
    *(void *)(v39 + 136) = v49;
    id v52 = v77;
    id v53 = [v52 bytes];
    uint64_t v54 = (char *)[v52 length];
    uint64_t v55 = v54;
    if (v54) {
      __int16 v56 = v51;
    }
    else {
      __int16 v56 = 0LL;
    }
    id v57 = &v54[(void)v51];
    *((void *)&v97 + 1) = &v54[(void)v51];
    memcpy(v56, v53, (size_t)v54);
    *(void *)(v39 + 144) = v56;
    *(void *)(v39 + 152) = v55;
    if (v31) {
      uint64_t v58 = v97;
    }
    else {
      uint64_t v58 = 0LL;
    }
    uint64_t v59 = v97 + 8LL * v31;
    if (v31) {
      uint64_t v60 = v97 + 8LL * v31;
    }
    else {
      uint64_t v60 = 0LL;
    }
    *(void *)(v39 + 96) = v58;
    *(void *)(v39 + 104) = v60;
    *(void *)&__int128 v97 = v59 + 8LL * v31;
    *(_WORD *)(v39 + 214) = 0;
    __int128 v88 = 0u;
    __int128 v89 = 0u;
    __int128 v90 = 0u;
    __int128 v91 = 0u;
    id v61 = v28;
    id v62 = [v61 countByEnumeratingWithState:&v88 objects:v99 count:16];
    if (v62)
    {
      id v63 = v62;
      uint64_t v64 = *(void *)v89;
      do
      {
        for (uint64_t j = 0LL; j != v63; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v89 != v64) {
            objc_enumerationMutation(v61);
          }
          id v66 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v88 + 1) + 8 * (void)j) libraryPath]);
          size_t v67 = v66;
          if (v66)
          {
            id v68 = v66;
            id v69 = [v68 UTF8String];
            id v70 = v68;
            if ([v70 UTF8String]
              && (size_t v71 = strlen((const char *)[v70 UTF8String]),
                  size_t v72 = v71 + 1,
                  v71 != -1LL))
            {
              id v73 = v57;
            }

            else
            {
              size_t v72 = 0LL;
              id v73 = 0LL;
            }

            v57 += v72;
            *((void *)&v97 + 1) = v57;
            memcpy(v73, v69, v72);
            uint64_t v74 = *(unsigned __int16 *)(v39 + 214);
            *(void *)(*(void *)(v39 + 104) + 8 * v74) = v73;
            *(void *)(*(void *)(v39 + 96) + 8 * v74) = 0LL;
            *(_WORD *)(v39 + 214) = v74 + 1;
          }
        }

        id v63 = [v61 countByEnumeratingWithState:&v88 objects:v99 count:16];
      }

      while (v63);
    }

    GTMTLRenderPipelineReflection_resourceAccess(v39, (uint64_t)__src);
    memcpy((void *)(v39 + 216), __src, 0x118uLL);
    id v7 = v85;
    id v75 = DEVICEOBJECT(v85);
    uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue(v75);
    if ([v85 supportIndirectCommandBuffers])
    {
      *(void *)uint64_t v39 = [v76 uniqueIdentifier];
      *(void *)(v39 + _Block_object_dispose(va, 8) = [v76 resourceIndex];
      if ((objc_opt_respondsToSelector(v76, "gpuResourceID") & 1) != 0) {
        *(void *)(v39 + 16) = [v76 gpuResourceID];
      }
    }

    id v8 = v86;
    if ((objc_opt_respondsToSelector(v76, "allocatedSize") & 1) != 0) {
      *(_DWORD *)(v39 + 192) = [v76 allocatedSize];
    }
    *(_WORD *)(v39 + 196) = (unsigned __int16)[v76 imageblockSampleLength];

    objc_autoreleasePoolPop(context);
    id v9 = v84;
  }
}

void SaveMTLFunctionInfo(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  int64x2_t v6 = v8;
  if (v8)
  {
    if (!v5)
    {
      id v5 = v8;
      int64x2_t v6 = v8;
    }

    memset(v9, 0, sizeof(v9));
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 label]);
    TranslateGTMTLFunctionInfo(v8, v5, v7, v9, 0);
    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v9, 0x7Bu);
    TranslateGTMTLFunctionInfo(v8, v5, v7, v9, 1);
  }
}

void SaveMTLDynamicLibraryInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = v3;
    id v5 = DEVICEOBJECT(v3);
    id v6 = (id)objc_claimAutoreleasedReturnValue(v5);

    memset(v7, 0, sizeof(v7));
    TranslateGTMTLDynamicLibraryInfo(v6, v7, 0);
    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v7, 0x7Cu);
    TranslateGTMTLDynamicLibraryInfo(v6, v7, 1);
  }

void SaveMTLBufferInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = v3;
    id v5 = DEVICEOBJECT(v3);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    v8[0] = 0LL;
    __int128 v9 = 0u;
    id v7 = v6;
    v8[1] = 48LL;

    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v8, 0x7Eu);
    TranslateGTMTLBufferInfo(v7, (uint64_t)v8, 1);
  }

void SaveMTLTextureInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = v3;
    id v5 = DEVICEOBJECT(v3);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    uint64_t v12 = 0LL;
    __int128 v14 = 0u;
    uint64_t v9 = 0LL;
    __int128 v11 = 0u;
    memset(v8, 0, sizeof(v8));
    id v7 = v6;
    uint64_t v10 = 88LL;
    uint64_t v13 = 16 * (void)[v7 mipmapLevelCount];

    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v8, 0x7Fu);
    TranslateGTMTLTextureInfo(v7, (uint64_t)v8, 1);
  }

void SaveMTLIndirectCommandBufferInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = v3;
    id v5 = DEVICEOBJECT(v3);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    __int128 v9 = 0u;
    __int128 v10 = 0u;
    memset(v8, 0, sizeof(v8));
    id v7 = v6;
    *(void *)&__int128 v9 = 56LL;

    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v8, 0x80u);
    TranslateGTMTLIndirectCommandBufferInfo(v7, (uint64_t)v8, 1);
  }

void SaveMTLVisibleFunctionTableInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = v3;
    id v5 = DEVICEOBJECT(v3);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    __int128 v9 = 0u;
    memset(v8, 0, sizeof(v8));
    id v7 = v6;
    *(void *)&__int128 v9 = 56LL;

    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v8, 0x81u);
    TranslateGTMTLVisibleFunctionTableInfo(v7, (uint64_t)v8, 1);
  }

void SaveMTLIntersectionFunctionTableInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = v3;
    id v5 = DEVICEOBJECT(v3);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    uint64_t v9 = 0LL;
    __int128 v11 = 0u;
    memset(v8, 0, sizeof(v8));
    id v7 = v6;
    uint64_t v10 = 48LL;

    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v8, 0x82u);
    TranslateGTMTLIntersectionFunctionTableInfo(v7, (uint64_t)v8, 1);
  }

void SaveMTLAccelerationStructureInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = v3;
    id v5 = DEVICEOBJECT(v3);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

    uint64_t v20 = 0LL;
    __int128 v19 = 0u;
    __int128 v18 = 0u;
    __int128 v17 = 0u;
    __int128 v16 = 0u;
    __int128 v15 = 0u;
    __int128 v14 = 0u;
    __int128 v13 = 0u;
    __int128 v12 = 0u;
    __int128 v11 = 0u;
    __int128 v10 = 0u;
    __int128 v9 = 0u;
    id v7 = v6;
    uint64_t v8 = 112LL;

    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)&v8, 0x83u);
    TranslateGTMTLAccelerationStructureInfo(v7, &v8, 1);
  }

void SaveMTLSamplerStateInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = v3;
    id v5 = DEVICEOBJECT(v3);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    __int128 v9 = 0u;
    __int128 v10 = 0u;
    memset(v8, 0, sizeof(v8));
    id v7 = v6;
    *(void *)&__int128 v9 = 24LL;

    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v8, 0x84u);
    TranslateGTMTLSamplerStateInfo(v7, (uint64_t)v8, 1);
  }

void SaveMTLLibraryInfoWithPath(uint64_t a1, void *a2, const char *a3)
{
  id v5 = a2;
  if (v5)
  {
    id v6 = v5;
    id v7 = DEVICEOBJECT(v5);
    id v8 = (id)objc_claimAutoreleasedReturnValue(v7);

    memset(v9, 0, sizeof(v9));
    TranslateGTMTLLibraryInfo(v8, (uint64_t)v9, 0, a3);
    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v9, 0x85u);
    TranslateGTMTLLibraryInfo(v8, (uint64_t)v9, 1, a3);
  }

void SaveMTLPipelineLibraryInfoWithPath(uint64_t a1, void *a2, const char *a3)
{
  id v5 = a2;
  if (v5)
  {
    id v6 = v5;
    id v7 = DEVICEOBJECT(v5);
    id v8 = (id)objc_claimAutoreleasedReturnValue(v7);

    memset(v9, 0, sizeof(v9));
    TranslateGTMTLPipelineLibraryInfo(v8, v9, 0, a3);
    *(_BYTE *)(*(void *)(a1 + 16) + 14LL) = AllocatePipelineReflectionWithType(a1, (uint64_t)v9, 0x8Au);
    TranslateGTMTLPipelineLibraryInfo(v8, v9, 1, a3);
  }

uint64_t SaveDispatchData_(uint64_t a1, dispatch_data_t data)
{
  if (!data) {
    return 0LL;
  }
  dispatch_data_t v3 = dispatch_data_create_map(data, &v6, &size_ptr);
  uint64_t v4 = GTTraceEncoder_storeBlob(a1, v6, size_ptr);

  return v4;
}

uint64_t SaveNSData(uint64_t a1, id a2)
{
  id v3 = a2;
  id v4 = [v3 bytes];
  id v5 = [v3 length];

  return GTTraceEncoder_storeBlob(a1, v4, (uint64_t)v5);
}

const char *SaveNSURL(uint64_t a1, id a2)
{
  __n128 result = (const char *)[a2 fileSystemRepresentation];
  if (result)
  {
    id v4 = (char *)result;
    size_t v5 = strlen(result) + 1;
    return (const char *)GTTraceEncoder_storeBytes(a1, v4, v5);
  }

  return result;
}

uint64_t SaveMTLViewport(uint64_t a1, const void *a2, uint64_t a3)
{
  return GTTraceEncoder_storeBlob(a1, a2, 48 * a3);
}

uint64_t SaveMTLScissorRect(uint64_t a1, const void *a2, uint64_t a3)
{
  return GTTraceEncoder_storeBlob(a1, a2, 32 * a3);
}

uint64_t SaveMTLVertexAmplificationViewMappings(uint64_t a1, const void *a2, uint64_t a3)
{
  if (a2) {
    return GTTraceEncoder_storeBlob(a1, a2, 8 * a3);
  }
  else {
    return 0LL;
  }
}

uint64_t TransferBytes(uint64_t a1, uint64_t *a2, const void *a3)
{
  if ((*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) != 2) {
    return 0LL;
  }
  uint64_t v6 = _sharedCaptureManager;
  HashBytes(a2, (unint64_t)a3, __s);
  GTMTLCaptureState_storePointer(v6, __s, a2, a3);
  _OWORD v8[2] = v12;
  v8[3] = v13;
  char v9 = v14;
  v8[0] = *(_OWORD *)__s;
  v8[1] = v11;
  return GTTraceEncoder_storeBytes(a1, v8, 0x41uLL);
}

uint64_t SaveMTLTextureMipmapInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_msgSend( v3,  "mipmapLevelCount",  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
         0LL,
         0LL,
         0LL,
         0LL,
         0LL,
         0LL);
  *((void *)&v14 + 1) = 16LL;
  *(void *)&__int128 v15 = 16LL * (void)v4;
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)&v13, 0x5Fu, 1u);
  id v6 = v3;
  id v7 = [v6 mipmapLevelCount];
  char v8 = (char)v7;
  uint64_t v9 = *((void *)&v14 + 1);
  uint64_t v10 = v15;
  TranslateGTMTLTextureMipmapLevels(v6, v15, (uint64_t)v7);

  *(_BYTE *)(v9 + _Block_object_dispose(va, 8) = v8;
  if (v8) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0LL;
  }
  *(void *)uint64_t v9 = v11;

  return DescriptorWithCount;
}

uint64_t AllocateDescriptorWithCount(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  do
  {
    v6 += (*(void *)(a2 + v5) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    v5 += 8LL;
  }

  while (v5 != 424);
  uint64_t v7 = *(void *)(*(void *)(a1 + 8) + 24LL);
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = *(unsigned __int8 *)(a1 + 42);
  *(_BYTE *)(a1 + 42) = v9 + 1;
  Bytes = GTTraceMemPool_allocateBytes( v7,  v8,  (v6 << 32) | ((unint64_t)a3 << 16) | ((unint64_t)a4 << 8) | v9);
  uint64_t v11 = 0LL;
  __int128 v12 = Bytes + 16;
  do
  {
    if (((*(void *)(a2 + v11) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) != 0) {
      __int128 v13 = v12;
    }
    else {
      __int128 v13 = 0LL;
    }
    v12 += (*(void *)(a2 + v11) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    *(void *)(a2 + v11) = v13;
    v11 += 8LL;
  }

  while (v11 != 424);
  return Bytes[8];
}

uint64_t SaveMTLArray(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    uint64_t v21 = 0LL;
    __int128 v20 = 0u;
    memset(v19, 0, sizeof(v19));
    *(void *)&__int128 v20 = 8 * (void)[v3 count] + 8;
    uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v19, 0, 1u);
    id v6 = [v4 count];
    uint64_t v7 = v20;
    *(void *)__int128 v20 = v6;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    id v8 = v4;
    id v9 = [v8 countByEnumeratingWithState:&v15 objects:v22 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = (void *)(v7 + 8);
      uint64_t v12 = *(void *)v16;
      do
      {
        for (uint64_t i = 0LL; i != v10; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v16 != v12) {
            objc_enumerationMutation(v8);
          }
          *v11++ = objc_msgSend(*(id *)(*((void *)&v15 + 1) + 8 * (void)i), "streamReference", (void)v15);
        }

        id v10 = [v8 countByEnumeratingWithState:&v15 objects:v22 count:16];
      }

      while (v10);
    }
  }

  else
  {
    uint64_t DescriptorWithCount = 0LL;
  }

  return DescriptorWithCount;
}

uint64_t SaveIOSurfaceRef(uint64_t a1, __IOSurface *a2)
{
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  TranslateGTIOSurface(a2, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x3Fu, 1u);
  TranslateGTIOSurface(a2, (uint64_t)v6, 1);
  return DescriptorWithCount;
}

uint64_t SaveImageFilterFunctionInfo(uint64_t a1, char *a2, int a3)
{
  uint64_t v22 = 0LL;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  memset(v11, 0, sizeof(v11));
  if (a3 >= 1)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = a3;
    uint64_t v7 = (uint64_t *)(a2 + 8);
    do
    {
      uint64_t v8 = *v7;
      v7 += 3;
      v5 += 24 * v8;
      --v6;
    }

    while (v6);
    *(void *)&__int128 v12 = 24LL * a3;
    *((void *)&v16 + 1) = v5;
  }

  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v11, 0x14u, a3);
  TranslateGTMTLImageFilterFunctionInfo(a2, a3, (uint64_t)v11, 1);
  return DescriptorWithCount;
}

uint64_t SaveMTLFunctionDescriptor(uint64_t a1, void *a2, void *a3)
{
  uint64_t v10 = 0LL;
  memset(v9, 0, sizeof(v9));
  id v5 = a3;
  id v6 = a2;
  TranslateGTMTLFunctionDescriptor(v6, v5, v9, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v9, 0x51u, 1u);
  TranslateGTMTLFunctionDescriptor(v6, v5, v9, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLIntersectionFunctionDescriptor(uint64_t a1, void *a2, void *a3)
{
  uint64_t v10 = 0LL;
  memset(v9, 0, sizeof(v9));
  id v5 = a3;
  id v6 = a2;
  TranslateGTMTLIntersectionFunctionDescriptor(v6, v5, v9, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v9, 0x5Du, 1u);
  TranslateGTMTLIntersectionFunctionDescriptor(v6, v5, v9, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLBinaryArchiveDescriptor()
{
  return 0LL;
}

uint64_t SaveMTLFunctionConstantValues(uint64_t a1, void *a2, void *a3)
{
  uint64_t v10 = 0LL;
  memset(v9, 0, sizeof(v9));
  id v5 = a3;
  id v6 = a2;
  TranslateGTMTLFunctionConstantValues(v6, v5, v9, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v9, 0x50u, 1u);
  TranslateGTMTLFunctionConstantValues(v6, v5, v9, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLDeviceDescriptor(uint64_t a1, void *a2)
{
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLDeviceDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x41u, 1u);
  TranslateGTMTLDeviceDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLIndirectCommandBufferDescriptor(uint64_t a1, void *a2, void *a3)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v10 = 0LL;
  memset(v9, 0, sizeof(v9));
  id v5 = a3;
  id v6 = a2;
  TranslateGTMTLIndirectCommandBufferDescriptorWithDevice(v6, v5, (uint64_t)v9, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v9, 0x37u, 1u);
  TranslateGTMTLIndirectCommandBufferDescriptorWithDevice(v6, v5, (uint64_t)v9, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLRenderPassDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLRenderPassDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x22u, 1u);
  TranslateGTMTLRenderPassDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLTextureDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLTextureDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x29u, 1u);
  TranslateGTMTLTextureDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLBufferDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v19 = 0LL;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  *(void *)&__int128 v7 = 40LL;

  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x2Au, 1u);
  TranslateGTMTLBufferDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLRenderPipelineDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLRenderPipelineDescriptor(v3, v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x32u, 1u);
  TranslateGTMTLRenderPipelineDescriptor(v3, v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLMeshRenderPipelineDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLMeshRenderPipelineDescriptor(v3, v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x88u, 1u);
  TranslateGTMTLMeshRenderPipelineDescriptor(v3, v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLDepthStencilDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLDepthStencilDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x34u, 1u);
  TranslateGTMTLDepthStencilDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLSamplerDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLSamplerDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x35u, 1u);
  TranslateGTMTLSamplerDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLHeapDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLHeapDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x36u, 1u);
  TranslateGTMTLHeapDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLComputePipelineDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v24 = 0LL;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  memset(v7, 0, sizeof(v7));
  id v3 = a2;
  TranslateGTMTLComputePipelineDescriptorAuto(v3, v7, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v7, 0x3Du, 1u);
  uint64_t v5 = *((void *)&v8 + 1);
  TranslateGTMTLComputePipelineDescriptorAuto(v3, v7, 1);
  *(_BYTE *)(v5 + 951) = -1;

  return DescriptorWithCount;
}

uint64_t SaveMTLTileRenderPipelineDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLTileRenderPipelineDescriptor(v3, v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x39u, 1u);
  TranslateGTMTLTileRenderPipelineDescriptor(v3, v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLCommandQueueDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLCommandQueueDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x43u, 1u);
  TranslateGTMTLCommandQueueDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLIOCommandQueueDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v26 = 0LL;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  uint64_t v7 = 0LL;
  __int128 v9 = 0u;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  uint64_t v8 = 8LL;

  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x89u, 1u);
  TranslateGTMTLIOCommandQueueDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLCommandBufferDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v25 = 0LL;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  *(void *)&__int128 v7 = 16LL;

  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x4Eu, 1u);
  TranslateGTMTLCommandBufferDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLVisibleFunctionTableDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v26 = 0LL;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v7 = 0u;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  *(void *)&__int128 v7 = 24LL;
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x52u, 1u);
  TranslateGTMTLVisibleFunctionTableDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLRasterizationRateMapDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLRasterizationRateMapDescriptor(v3, v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x45u, 1u);
  TranslateGTMTLRasterizationRateMapDescriptor(v3, v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLCompileOptions(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLCompileOptions(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x49u, 1u);
  TranslateGTMTLCompileOptions(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLAccelerationStructureDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLAccelerationStructureDescriptor(v3, v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x5Bu, 1u);
  TranslateGTMTLAccelerationStructureDescriptor(v3, v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLCaptureDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLCaptureDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x4Du, 1u);
  TranslateGTMTLCaptureDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLBlitPassDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLBlitPassDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x24u, 1u);
  TranslateGTMTLBlitPassDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLComputePassDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLComputePassDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x26u, 1u);
  TranslateGTMTLComputePassDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLResourceStatePassDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLResourceStatePassDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x28u, 1u);
  TranslateGTMTLResourceStatePassDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLAccelerationStructurePassDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLAccelerationStructurePassDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x86u, 1u);
  TranslateGTMTLAccelerationStructurePassDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLIntersectionFunctionTableDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v31 = 0LL;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  *(void *)&__int128 v7 = 16LL;
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x5Cu, 1u);
  TranslateGTMTLIntersectionFunctionTableDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLRenderPipelineFunctionsDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLRenderPipelineFunctionsDescriptor(v3, (uint64_t)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x60u, 1u);
  TranslateGTMTLRenderPipelineFunctionsDescriptor(v3, (uint64_t)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLAccelerationStructureAllocationDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v32 = 0LL;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  id v3 = a2;
  *(void *)&__int128 v7 = 16LL;
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)&v6, 0x87u, 1u);
  TranslateGTMTLAccelerationStructureAllocationDescriptor(v3, (uint64_t)&v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLResidencySetDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLResidencySetDescriptor(v3, (uint64_t *)v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x8Eu, 1u);
  TranslateGTMTLResidencySetDescriptor(v3, (uint64_t *)v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLCounterSampleBufferDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLCounterSampleBufferDescriptor(v3, v6, 0);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x48u, 1u);
  TranslateGTMTLCounterSampleBufferDescriptor(v3, v6, 1);

  return DescriptorWithCount;
}

uint64_t SaveMTLStitchedLibraryDescriptor(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLStitchedLibraryDescriptor(v3, v6, 0LL);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x66u, 1u);
  TranslateGTMTLStitchedLibraryDescriptor(v3, v6, 1LL);

  return DescriptorWithCount;
}

uint64_t SaveMTLStitchedLibraryDescriptorSPI(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  id v3 = a2;
  TranslateGTMTLStitchedLibraryDescriptorSPI(v3, v6, 0LL);
  uint64_t DescriptorWithCount = AllocateDescriptorWithCount(a1, (uint64_t)v6, 0x66u, 1u);
  TranslateGTMTLStitchedLibraryDescriptorSPI(v3, v6, 1LL);

  return DescriptorWithCount;
}

uint64_t GTResourceTrackerGetResourceType(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1;
  entry = find_entry(a2, &v5, 8uLL, 0LL);
  if (*entry && (uint64_t v3 = *(void *)(*entry + 32LL)) != 0) {
    return GetFuncEnumConstructorType(*(_DWORD *)(*(void *)(v3 + 32) + 72LL));
  }
  else {
    return 0LL;
  }
}

uint64_t GTResourceTrackerUsingResource(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = a3;
  if (a3)
  {
    __int128 v8 = (apr_pool_t **)result;
    __n128 result = (uint64_t)find_entry(result, &v17, 8uLL, 0LL);
    if (!*(void *)result || !*(void *)(*(void *)result + 32LL))
    {
      __int128 v9 = apr_palloc(*v8, 0x10uLL);
      *(void *)__int128 v9 = v17;
      apr_hash_set((apr_hash_t *)v8, v9, 8LL, v9);
      *(void *)&__int128 v18 = v17;
      uint64_t v10 = *find_entry(a4, &v18, 8uLL, 0LL);
      if (v10 && (uint64_t v11 = *(void *)(v10 + 32)) != 0)
      {
        uint64_t v12 = *(void *)(v11 + 32);
        if (v12) {
          uint64_t v13 = v12 + 64;
        }
        else {
          uint64_t v13 = 0LL;
        }
      }

      else
      {
        uint64_t v13 = 0LL;
      }

      __n128 result = GetFuncEnumConstructorType(*(_DWORD *)(v13 + 8));
      v9[2] = result;
      if (a2 != 16)
      {
        if (a2 != 80)
        {
          if (a2 != 22) {
            return result;
          }
          __int128 v18 = 0u;
          uint64_t v19 = 0LL;
          __int128 v25 = 0u;
          __int128 v27 = 0u;
          __int128 v28 = 0u;
          __int128 v24 = 0u;
          __int128 v21 = 0u;
          __int128 v22 = 0u;
          LODWORD(v1_Block_object_dispose(va, 8) = 22;
          uint64_t v20 = -1LL;
          WORD1(v25) = 2;
          __int128 v23 = 0xFFFFFFFFFFFFFFFFLL;
          __int128 v26 = 0xFFFFFFFFFFFFFFFFLL;
          GTMTLSMBuffer_processTraceFuncWithMap((char *)&v18, a5, (uint64_t *)v13);
          goto LABEL_14;
        }

        __int128 v18 = 0u;
        uint64_t v19 = 0LL;
        __int128 v30 = 0u;
        __int128 v31 = 0u;
        __int128 v28 = 0u;
        __int128 v29 = 0u;
        __int128 v27 = 0u;
        __int128 v25 = 0u;
        __int128 v26 = 0u;
        __int128 v24 = 0u;
        __int128 v21 = 0u;
        __int128 v22 = 0u;
        LODWORD(v1_Block_object_dispose(va, 8) = 80;
        uint64_t v20 = -1LL;
        WORD1(v25) = 2;
        __int128 v23 = 0xFFFFFFFFFFFFFFFFLL;
        uint64_t v32 = 0xFFFFFFFFLL;
        GTMTLSMTexture_processTraceFuncWithMap((char *)&v18, a5, (uint64_t *)v13);
        uint64_t v14 = v28;
        if ((void)v28)
        {
          __int128 v15 = v8;
          uint64_t v16 = 80LL;
          return GTResourceTrackerUsingResource(v15, v16, v14, a4, a5);
        }

        uint64_t v14 = *((void *)&v27 + 1);
        if (!*((void *)&v27 + 1))
        {
LABEL_14:
          uint64_t v14 = v22;
          __int128 v15 = v8;
          uint64_t v16 = 50LL;
          return GTResourceTrackerUsingResource(v15, v16, v14, a4, a5);
        }

void *GTResourceTrackerResourceWrite(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  __n128 result = tracker_resource_get(a1, a2, a3, a4);
  if (result) {
    result[4] = a4;
  }
  return result;
}

void *tracker_resource_get(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v23 = a3;
  GTResourceTrackerUsingResource(a1[2], a2, a3, *a1, a1[1]);
  uint64_t ParentResource = GetParentResource(*a1, v5, a1[1]);
  if (ParentResource != v5)
  {
    find_entry(*a1, &ParentResource, 8uLL, 0LL);
    uint64_t v5 = ParentResource;
    uint64_t v23 = ParentResource;
  }

  if (!v5) {
    return 0LL;
  }
  uint64_t v7 = (apr_hash_t *)a1[4];
  entry = find_entry((uint64_t)v7, &v23, 8uLL, 0LL);
  if (!*entry || (__int128 v9 = *(void **)(*entry + 32LL)) == 0LL)
  {
    uint64_t v10 = *(apr_pool_t **)v7;
    uint64_t v11 = *a1;
    uint64_t v12 = a1[1];
    uint64_t v24 = v23;
    uint64_t v13 = *find_entry(v11, &v24, 8uLL, 0LL);
    if (v13)
    {
      uint64_t v14 = *(void **)(v13 + 32);
      if (v14)
      {
        uint64_t v15 = v14[4];
        if (v15)
        {
          if ((*(_BYTE *)(v15 + 79) & 8) != 0)
          {
            uint64_t v16 = v15 + 64;
            goto LABEL_14;
          }
        }
      }
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    uint64_t v16 = 0LL;
LABEL_14:
    uint64_t v17 = apr_palloc(v10, 0x38uLL);
    __int128 v9 = v17;
    if (v17)
    {
      *((void *)v17 + 6) = 0LL;
      v17[1] = 0u;
      v17[2] = 0u;
      *uint64_t v17 = 0u;
    }

    *(void *)uint64_t v17 = v14[1];
    *((void *)v17 + 1) = v24;
    int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v16 + 8));
    v9[3] = -1LL;
    *((_DWORD *)v9 + 10) = FuncEnumConstructorType;
    v9[2] = a4;
    v9[4] = -1LL;
    if (FuncEnumConstructorType > 59)
    {
      if (FuncEnumConstructorType != 60)
      {
        if (FuncEnumConstructorType != 80)
        {
          goto LABEL_26;
        }

        __int128 v25 = 0u;
        uint64_t v26 = 0LL;
        __int128 v31 = 0u;
        __int128 v32 = 0u;
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        __int128 v35 = 0u;
        __int128 v36 = 0u;
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        __int128 v29 = 0u;
        __int128 v28 = 0u;
        LODWORD(v25) = 80;
        uint64_t v27 = -1LL;
        WORD1(v32) = 2;
        __int128 v30 = 0xFFFFFFFFFFFFFFFFLL;
        uint64_t v39 = 0xFFFFFFFFLL;
        GTMTLSMTexture_processTraceFuncWithMap((char *)&v25, v12, (uint64_t *)v16);
        if (*((void *)&v32 + 1) && (*(_WORD *)(*((void *)&v32 + 1) + 36LL) & 0xF0) == 0x30) {
          v9[3] = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          LOBYTE(v20) = 0;
        }
LABEL_35:
        *((_BYTE *)v9 + 4_Block_object_dispose(va, 8) = v20;
        goto LABEL_36;
      }

      *__int128 v9 = v14[2];
LABEL_28:
      LOBYTE(v20) = 1;
      goto LABEL_35;
    }

    if (FuncEnumConstructorType == 16)
    {
LABEL_26:
      *__int128 v9 = v14[2];
      goto LABEL_36;
    }

    if (FuncEnumConstructorType == 22)
    {
      __int128 v25 = 0u;
      uint64_t v26 = 0LL;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      __int128 v33 = 0u;
      __int128 v29 = 0u;
      __int128 v28 = 0u;
      LODWORD(v25) = 22;
      uint64_t v27 = -1LL;
      WORD1(v32) = 2;
      __int128 v30 = 0xFFFFFFFFFFFFFFFFLL;
      *(void *)&__int128 v33 = -1LL;
      GTMTLSMBuffer_processTraceFuncWithMap((char *)&v25, v12, (uint64_t *)v16);
      if ((v32 & 0xE0) == 0)
      {
        unsigned int v19 = atomic_load(v14 + 7);
        int v20 = (v19 >> 1) & 1;
        goto LABEL_35;
      }
    }

uint64_t GetParentResource(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a2;
  if (!a2) {
    return v12;
  }
  uint64_t v5 = *find_entry(a1, &v12, 8uLL, 0LL);
  if (v5 && (uint64_t v6 = *(void *)(v5 + 32)) != 0)
  {
    uint64_t v7 = *(void *)(v6 + 32);
    uint64_t v8 = v7 ? v7 + 64 : 0LL;
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  int v9 = *(_DWORD *)(v8 + 8);
  __int128 v13 = 0u;
  uint64_t v14 = 0LL;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v22 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  LODWORD(v13) = 80;
  uint64_t v15 = -1LL;
  WORD1(v20) = 2;
  __int128 v18 = 0xFFFFFFFFFFFFFFFFLL;
  uint64_t v27 = 0xFFFFFFFFLL;
  GTMTLSMTexture_processTraceFuncWithMap((char *)&v13, a3, (uint64_t *)v8);
  uint64_t v10 = v23;
  if ((void)v23) {
    return GetParentResource(a1, v10, a3);
  }
  uint64_t v10 = *((void *)&v22 + 1);
  if (*((void *)&v22 + 1)) {
    return GetParentResource(a1, v10, a3);
  }
  else {
    return v12;
  }
}

void *GTResourceTrackerResourceRead(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = tracker_resource_get(a1, a2, a3, a4);
  int v9 = v8;
  if (v8)
  {
    uint64_t v10 = v8[3];
    if (v10 < 0) {
      uint64_t v10 = a4;
    }
    v8[3] = v10;
    if (*((_BYTE *)v8 + 48))
    {
      uint64_t v11 = tracker_resource_get(a1, a2, a3, a4);
      if (v11) {
        v11[4] = a4;
      }
    }
  }

  return v9;
}

void *GTResourceTrackerResourceForceDownload(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  __n128 result = tracker_resource_get(a1, a2, a3, a4);
  if (result) {
    *((_BYTE *)result + 4_Block_object_dispose(va, 8) = 1;
  }
  return result;
}

void *GTResourceTrackerResourceUsage(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, char a5)
{
  if ((a5 & 2) != 0)
  {
    uint64_t v11 = tracker_resource_get(a1, a2, a3, a4);
    uint64_t v10 = v11;
    if (v11) {
      v11[4] = a4;
    }
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  if ((a5 & 5) != 0)
  {
    uint64_t v12 = GTResourceTrackerResourceRead(a1, a2, a3, a4);
    if (v12) {
      return v12;
    }
  }

  return v10;
}

uint64_t GTResourceTrackerUsingResourceArray( uint64_t result, int a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a4)
  {
    uint64_t v8 = a4;
    uint64_t v11 = result;
    do
    {
      uint64_t v12 = *a3;
      if (*a3)
      {
        if (a2)
        {
          int ResourceType = a2;
        }

        else
        {
          int ResourceType = GTResourceTrackerGetResourceType(*a3, a5);
          uint64_t v12 = *a3;
        }

        __n128 result = GTResourceTrackerUsingResource(v11, ResourceType, v12, a5, a6);
      }

      ++a3;
      --v8;
    }

    while (v8);
  }

  return result;
}

uint64_t *GTResourceTrackerResourceReadArray(uint64_t *result, int a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    uint64_t v6 = a4;
    int v9 = result;
    do
    {
      uint64_t v10 = *a3;
      if (*a3)
      {
        if (a2)
        {
          int ResourceType = a2;
        }

        else
        {
          int ResourceType = GTResourceTrackerGetResourceType(*a3, *v9);
          uint64_t v10 = *a3;
        }

        __n128 result = GTResourceTrackerResourceRead(v9, ResourceType, v10, a5);
      }

      ++a3;
      --v6;
    }

    while (v6);
  }

  return result;
}

uint64_t *GTResourceTrackerResourceReadMTLArray(uint64_t *a1, int a2, uint64_t *a3, uint64_t a4)
{
  return GTResourceTrackerResourceReadArray(a1, a2, a3 + 1, *a3, a4);
}

uint64_t *GTResourceTrackerResourceWriteArray(uint64_t *result, int a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    uint64_t v6 = a4;
    int v9 = result;
    do
    {
      uint64_t v10 = *a3;
      if (*a3)
      {
        if (a2)
        {
          int ResourceType = a2;
        }

        else
        {
          int ResourceType = GTResourceTrackerGetResourceType(*a3, *v9);
          uint64_t v10 = *a3;
        }

        __n128 result = tracker_resource_get(v9, ResourceType, v10, a5);
        if (result) {
          result[4] = a5;
        }
      }

      ++a3;
      --v6;
    }

    while (v6);
  }

  return result;
}

uint64_t *GTResourceTrackerResourceUsageArray(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  if (a3)
  {
    uint64_t v7 = a3;
    int v9 = result;
    do
    {
      __n128 result = (uint64_t *)*a2;
      if (*a2)
      {
        int ResourceType = GTResourceTrackerGetResourceType((uint64_t)result, *v9);
        __n128 result = GTResourceTrackerResourceUsage(v9, ResourceType, *a2, a4, a5);
      }

      ++a2;
      --v7;
    }

    while (v7);
  }

  return result;
}

uint64_t *GTResourceTrackerResourceWriteMTLArray(uint64_t *a1, int a2, uint64_t *a3, uint64_t a4)
{
  return GTResourceTrackerResourceWriteArray(a1, a2, a3 + 1, *a3, a4);
}

void GTResourceTrackerUsingResourceHeap(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a2;
  if (a2)
  {
    GTResourceTrackerUsingResource(a1[2], 50, a2, *a1, a1[1]);
    entry = find_entry(a1[3], &v7, 8uLL, 0LL);
    if (!*entry || !*(void *)(*entry + 32LL))
    {
      uint64_t v6 = apr_palloc(*(apr_pool_t **)a1[3], 0x10uLL);
      void *v6 = v7;
      v6[1] = a3;
      apr_hash_set((apr_hash_t *)a1[3], v6, 8LL, v6);
    }
  }

void ResourceTracker_postAccumulateHeapReads(uint64_t *a1)
{
  if (*(_DWORD *)(a1[3] + 48))
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (apr_hash_index_t *)(*a1 + 16);
    *(void *)(v2 + 24) = 0LL;
    *(void *)(v2 + 32) = 0LL;
    *(void *)(v2 + 16) = v2;
    *(_DWORD *)(v2 + 40) = 0;
    id v4 = apr_hash_next(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      do
      {
        uint64_t v6 = *(void *)(*((void *)v5 + 1) + 32LL);
        if (!v6) {
          goto LABEL_26;
        }
        uint64_t v7 = *(void *)(v6 + 32);
        if (!v7 || (*(_BYTE *)(v7 + 79) & 8) == 0) {
          goto LABEL_26;
        }
        uint64_t v8 = (uint64_t *)(v7 + 64);
        int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v7 + 72));
        switch(FuncEnumConstructorType)
        {
          case 16:
            __int128 v20 = 0u;
            uint64_t v21 = 0LL;
            __int128 v32 = 0u;
            __int128 v33 = 0u;
            __int128 v30 = 0u;
            __int128 v31 = 0u;
            __int128 v28 = 0u;
            __int128 v29 = 0u;
            __int128 v26 = 0u;
            __int128 v27 = 0u;
            __int128 v24 = 0u;
            __int128 v23 = 0u;
            LODWORD(v20) = 16;
            uint64_t v22 = -1LL;
            WORD1(v27) = 2;
            __int128 v25 = 0xFFFFFFFFFFFFFFFFLL;
            GTMTLSMAccelerationStructure_processTraceFuncWithMap((char *)&v20, a1[1], v8);
            if (!(void)v24) {
              goto LABEL_26;
            }
            uint64_t v18 = *find_entry(a1[3], &v24, 8uLL, 0LL);
            if (!v18) {
              goto LABEL_26;
            }
            uint64_t v19 = *(void *)(v18 + 32);
            if (!v19) {
              goto LABEL_26;
            }
            unint64_t v12 = *(void *)(v19 + 8);
            uint64_t v13 = *((void *)&v20 + 1);
            uint64_t v14 = a1;
            int v15 = 16;
            break;
          case 80:
            __int128 v20 = 0u;
            uint64_t v21 = 0LL;
            __int128 v32 = 0u;
            __int128 v33 = 0u;
            __int128 v30 = 0u;
            __int128 v31 = 0u;
            __int128 v28 = 0u;
            __int128 v29 = 0u;
            __int128 v26 = 0u;
            __int128 v27 = 0u;
            __int128 v24 = 0u;
            __int128 v23 = 0u;
            LODWORD(v20) = 80;
            uint64_t v22 = -1LL;
            WORD1(v27) = 2;
            __int128 v25 = 0xFFFFFFFFFFFFFFFFLL;
            uint64_t v34 = 0xFFFFFFFFLL;
            GTMTLSMTexture_processTraceFuncWithMap((char *)&v20, a1[1], v8);
            if (!(void)v24) {
              goto LABEL_26;
            }
            uint64_t v16 = *find_entry(a1[3], &v24, 8uLL, 0LL);
            if (!v16) {
              goto LABEL_26;
            }
            uint64_t v17 = *(void *)(v16 + 32);
            if (!v17) {
              goto LABEL_26;
            }
            unint64_t v12 = *(void *)(v17 + 8);
            uint64_t v13 = *((void *)&v20 + 1);
            uint64_t v14 = a1;
            int v15 = 80;
            break;
          case 22:
            __int128 v20 = 0u;
            uint64_t v21 = 0LL;
            __int128 v27 = 0u;
            __int128 v29 = 0u;
            __int128 v30 = 0u;
            __int128 v26 = 0u;
            __int128 v23 = 0u;
            __int128 v24 = 0u;
            LODWORD(v20) = 22;
            uint64_t v22 = -1LL;
            WORD1(v27) = 2;
            __int128 v25 = 0xFFFFFFFFFFFFFFFFLL;
            __int128 v28 = 0xFFFFFFFFFFFFFFFFLL;
            GTMTLSMBuffer_processTraceFuncWithMap((char *)&v20, a1[1], v8);
            if (!(void)v24) {
              goto LABEL_26;
            }
            uint64_t v10 = *find_entry(a1[3], &v24, 8uLL, 0LL);
            if (!v10) {
              goto LABEL_26;
            }
            uint64_t v11 = *(void *)(v10 + 32);
            if (!v11) {
              goto LABEL_26;
            }
            unint64_t v12 = *(void *)(v11 + 8);
            uint64_t v13 = *((void *)&v20 + 1);
            uint64_t v14 = a1;
            int v15 = 22;
            break;
          default:
            goto LABEL_26;
        }

        GTResourceTrackerResourceRead(v14, v15, v13, v12);
LABEL_26:
        uint64_t v5 = apr_hash_next(v5);
      }

      while (v5);
    }

    apr_hash_clear((apr_hash_t *)a1[3]);
  }

uint64_t IsHeapResourceMadeAliasable(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v19 = a2;
  uint64_t v4 = *(void *)(*(void *)(*find_entry(a1, &v19, 8uLL, 0LL) + 32LL) + 32LL);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_8;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_8:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_9:
  uint64_t v9 = v4 + 64;
  while (v4)
  {
    int v10 = HIDWORD(v8) - v8;
    unint64_t v11 = *(void *)(v9 + ((uint64_t)v10 << 6));
    if (v11 > a3) {
      break;
    }
    int v12 = *(_DWORD *)(v9 + ((uint64_t)v10 << 6) + 8);
    BOOL v14 = v12 == -16122 || v12 == -16114 || v12 == -15651;
    unsigned int v15 = atomic_load((unsigned int *)(v4 + 4));
    int v16 = v8 + (v15 >> 6);
    uint64_t v17 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v17 << 32) | v8;
    if ((_DWORD)v17 == v16 - 1)
    {
      unint64_t v8 = (v17 << 32) | v17;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_9;
    }
  }

  return -1LL;
}

void GTResourceTrackerUsingResourceHeapArray(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    do
    {
      uint64_t v8 = *a2++;
      GTResourceTrackerUsingResourceHeap(a1, v8, a4);
      --v5;
    }

    while (v5);
  }

void *GTResourceTrackerMake(uint64_t a1, uint64_t a2, apr_pool_t *p)
{
  unsigned int v6 = apr_palloc(p, 0x30uLL);
  void *v6 = a1;
  v6[1] = a2;
  _OWORD v6[2] = apr_hash_make(p);
  v6[3] = apr_hash_make(p);
  v6[4] = apr_hash_make(p);
  v6[5] = apr_hash_make(p);
  return v6;
}

void GTResourceTrackerProcessFunction(uint64_t *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 8);
  int FuncEnumConstructorType = GetFuncEnumConstructorType(v4);
  if (IsCommandEncoder(FuncEnumConstructorType))
  {
    bzero(&v80, 0x2B90uLL);
    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v80, (uint64_t *)a2, a1[1]);
    if (v80 <= 64)
    {
      if (v80 != 17 && v80 != 21)
      {
        if (v80 != 28) {
          return;
        }
        goto LABEL_35;
      }
    }

    else
    {
      if (v80 <= 73)
      {
        if (v80 != 65)
        {
          if (v80 != 70) {
            return;
          }
          uint64_t v6 = *a1;
          *(void *)&__int128 v90 = v81;
          uint64_t v7 = *find_entry(v6, &v90, 8uLL, 0LL);
          if (v7
            && (uint64_t v8 = *(void *)(v7 + 32)) != 0
            && (uint64_t v9 = *(void *)(v8 + 32)) != 0
            && (*(_BYTE *)(v9 + 79) & 8) != 0)
          {
            uint64_t v10 = v9 + 64;
          }

          else
          {
            uint64_t v10 = 0LL;
          }

          bzero(&v90, 0x2B90uLL);
          GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v90, (uint64_t *)v10, a1[1]);
          bzero(&v84, 0x2B90uLL);
          if (*(_DWORD *)(v10 + 8) != -16286)
          {
            id v51 = (uint64_t *)*((void *)&v94 + 1);
            uint64_t v52 = renderCommandEncoder_processStreamWithDescriptor(a1, *((uint64_t *)&v94 + 1), (uint64_t)&v90);
            id v82 = v102;
            __int16 v83 = v102[607];
            goto LABEL_110;
          }

          uint64_t v11 = *a1;
          id v82 = (_WORD *)*((void *)&v93 + 1);
          uint64_t v12 = *find_entry(v11, &v82, 8uLL, 0LL);
          if (v12)
          {
            uint64_t v13 = *(void *)(v12 + 32);
            if (v13)
            {
              uint64_t v14 = *(void *)(v13 + 32);
              if (v14)
              {
                if ((*(_BYTE *)(v14 + 79) & 8) != 0)
                {
                  unsigned int v15 = (uint64_t *)(v14 + 64);
LABEL_94:
                  GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v84, v15, a1[1]);
                  uint64_t v69 = *(void *)(v13 + 32);
                  if (v69)
                  {
                    unsigned int v70 = 0;
                    while (1)
                    {
                      unsigned int v71 = atomic_load((unsigned int *)(v69 + 4));
                      uint64_t v72 = v70 + (v71 >> 6) - 1;
                      uint64_t v69 = *(void *)(v69 + 40);
                      unsigned int v70 = v72;
                      if (!v69)
                      {
                        unsigned int v70 = v72;
                        goto LABEL_101;
                      }
                    }

                    uint64_t v72 = 1LL;
                  }

                  else
                  {
                    unsigned int v70 = 0;
                    uint64_t v72 = 0LL;
                  }

LABEL_101:
                  unint64_t v73 = v70 | (unint64_t)(v72 << 32);
LABEL_102:
                  uint64_t v74 = v69 + 64;
                  while (v69 && (*(_BYTE *)(v74 + ((uint64_t)(HIDWORD(v73) - (int)v73) << 6) + 15) & 8) != 0)
                  {
                    uint64_t v75 = v74 + ((uint64_t)(HIDWORD(v73) - (int)v73) << 6);
                    int v76 = GetFuncEnumConstructorType(*(_DWORD *)(v75 + 8));
                    if (!IsCommandEncoder(v76)) {
                      GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v84, (uint64_t *)v75, a1[1]);
                    }
                    unsigned int v77 = atomic_load((unsigned int *)(v69 + 4));
                    int v78 = v73 + (v77 >> 6);
                    uint64_t v79 = (HIDWORD(v73) + 1);
                    unint64_t v73 = (v79 << 32) | v73;
                    if ((_DWORD)v79 == v78 - 1)
                    {
                      unint64_t v73 = (v79 << 32) | v79;
                      uint64_t v69 = *(void *)(v69 + 40);
                      goto LABEL_102;
                    }
                  }

                  id v51 = v88;
                  id v82 = v89;
                  __int16 v83 = v89[64];
                  uint64_t v52 = renderCommandEncoder_processStreamWithDescriptor(a1, (uint64_t)v88, (uint64_t)&v90);
LABEL_110:
                  RenderEncoderWithDescriptor(a1, v51);
                  if ((_DWORD)v90 == 70)
                  {
                    id v66 = (__int128 **)&v82;
                    size_t v67 = a1;
                    uint64_t v68 = (uint64_t)v51;
                    uint64_t v65 = v52;
LABEL_112:
                    RenderEncoderEndEncoding(v67, v68, (uint64_t)v66, v65);
                  }

                  return;
                }
              }
            }
          }

          else
          {
            uint64_t v13 = 0LL;
          }

          unsigned int v15 = 0LL;
          goto LABEL_94;
        }

        uint64_t v32 = *a1;
        *(void *)&__int128 v90 = v81;
        uint64_t v33 = *find_entry(v32, &v90, 8uLL, 0LL);
        if (v33)
        {
          uint64_t v34 = *(void *)(v33 + 32);
          bzero(&v90, 0x2B90uLL);
          if (v34)
          {
            uint64_t v35 = *(void *)(v34 + 32);
            if (v35)
            {
              if ((*(_BYTE *)(v35 + 79) & 8) != 0)
              {
                __int128 v36 = (uint64_t *)(v35 + 64);
LABEL_74:
                GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v90, v36, a1[1]);
                uint64_t v53 = *((void *)&v94 + 1);
                RenderEncoderWithDescriptor(a1, *((uint64_t **)&v94 + 1));
                uint64_t v54 = *(void *)(v34 + 32);
                if (v54)
                {
                  unsigned int v55 = 0;
                  while (1)
                  {
                    unsigned int v56 = atomic_load((unsigned int *)(v54 + 4));
                    uint64_t v57 = v55 + (v56 >> 6) - 1;
                    uint64_t v54 = *(void *)(v54 + 40);
                    unsigned int v55 = v57;
                    if (!v54)
                    {
                      unsigned int v55 = v57;
                      goto LABEL_81;
                    }
                  }

                  uint64_t v57 = 1LL;
                }

                else
                {
                  unsigned int v55 = 0;
                  uint64_t v57 = 0LL;
                }

LABEL_81:
                unint64_t v58 = v55 | (unint64_t)(v57 << 32);
LABEL_82:
                uint64_t v59 = v54 + 64;
                while (v54 && (*(_BYTE *)(v59 + ((uint64_t)(HIDWORD(v58) - (int)v58) << 6) + 15) & 8) != 0)
                {
                  uint64_t v60 = v59 + ((uint64_t)(HIDWORD(v58) - (int)v58) << 6);
                  if ((IsFuncEnumEndEncoding(*(_DWORD *)(v60 + 8)) & 1) != 0)
                  {
                    id v84 = &v95;
                    __int16 v85 = v101;
                    int v86 = 0;
                    __int16 v87 = 0;
                    uint64_t v65 = *(void *)v60;
                    id v66 = &v84;
                    size_t v67 = a1;
                    uint64_t v68 = v53;
                    goto LABEL_112;
                  }

                  GTResourceTrackerProcessResourceUse(a1, v60, *(void *)v60);
                  int v61 = GetFuncEnumConstructorType(*(_DWORD *)(v60 + 8));
                  if (IsCommandEncoder(v61))
                  {
                    bzero(&v84, 0x2B90uLL);
                    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v84, (uint64_t *)v60, a1[1]);
                    renderCommandEncoder_processStreamWithDescriptor(a1, v53, (uint64_t)&v84);
                  }

                  else
                  {
                    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v90, (uint64_t *)v60, a1[1]);
                  }

                  unsigned int v62 = atomic_load((unsigned int *)(v54 + 4));
                  int v63 = v58 + (v62 >> 6);
                  uint64_t v64 = (HIDWORD(v58) + 1);
                  unint64_t v58 = (v64 << 32) | v58;
                  if ((_DWORD)v64 == v63 - 1)
                  {
                    unint64_t v58 = (v64 << 32) | v64;
                    uint64_t v54 = *(void *)(v54 + 40);
                    goto LABEL_82;
                  }
                }

                return;
              }
            }
          }
        }

        else
        {
          bzero(&v90, 0x2B90uLL);
          uint64_t v34 = 0LL;
        }

        __int128 v36 = 0LL;
        goto LABEL_74;
      }

      if (v80 != 74)
      {
        if (v80 != 82) {
          return;
        }
LABEL_35:
        computeCommandEncoder_processStream(a1, v81);
        return;
      }
    }

    defaultCommandEncoder_processStream(a1, v81);
    return;
  }

  if (v4 != -20457 && v4 != -20474)
  {
    GTResourceTrackerProcessResourceUse(a1, a2, *(void *)a2);
    return;
  }

  uint64_t v17 = GTTraceFunc_targetContext(a2, a1[1]);
  int FuncEnumReceiverType = GetFuncEnumReceiverType(*(_DWORD *)(a2 + 8));
  if (FuncEnumReceiverType == 40)
  {
    unint64_t v19 = *(void *)a2;
    uint64_t v26 = *a1;
    *(void *)&__int128 v90 = v17;
    uint64_t v27 = *(void *)(*find_entry(v26, &v90, 8uLL, 0LL) + 32LL);
    __int128 v90 = 0u;
    uint64_t v91 = 0LL;
    uint64_t v100 = 0LL;
    __int128 v99 = 0u;
    __int128 v98 = 0u;
    __int128 v97 = 0u;
    __int128 v96 = 0u;
    __int128 v95 = 0u;
    __int128 v94 = 0u;
    __int128 v93 = 0u;
    LODWORD(v90) = 40;
    uint64_t v92 = -1LL;
    uint64_t v28 = *(void *)(v27 + 32);
    if (v28)
    {
      unsigned int v29 = 0;
      while (1)
      {
        unsigned int v30 = atomic_load((unsigned int *)(v28 + 4));
        uint64_t v31 = v29 + (v30 >> 6) - 1;
        uint64_t v28 = *(void *)(v28 + 40);
        unsigned int v29 = v31;
        if (!v28)
        {
          unsigned int v29 = v31;
          goto LABEL_59;
        }
      }
    }

    else
    {
      unsigned int v29 = 0;
    }

    uint64_t v31 = 0LL;
LABEL_59:
    unint64_t v44 = v29 | (unint64_t)(v31 << 32);
LABEL_60:
    uint64_t v45 = v28 + 64;
    while (v28)
    {
      id v46 = (uint64_t *)(v45 + ((uint64_t)(HIDWORD(v44) - (int)v44) << 6));
      if (*v46 > v19) {
        break;
      }
      GTMTLFXSMTemporalScaler_processTraceFuncWithMap((uint64_t)&v90, a1[1], v46);
      unsigned int v47 = atomic_load((unsigned int *)(v28 + 4));
      int v48 = v44 + (v47 >> 6);
      uint64_t v49 = (HIDWORD(v44) + 1);
      unint64_t v44 = (v49 << 32) | v44;
      if ((_DWORD)v49 == v48 - 1)
      {
        unint64_t v44 = (v49 << 32) | v49;
        uint64_t v28 = *(void *)(v28 + 40);
        goto LABEL_60;
      }
    }

    GTResourceTrackerUsingResource(a1[2], 40, (uint64_t)v17, *a1, a1[1]);
    GTResourceTrackerResourceRead(a1, 80, v95, v19);
    GTResourceTrackerResourceRead(a1, 80, *((uint64_t *)&v95 + 1), v19);
    GTResourceTrackerResourceRead(a1, 80, v96, v19);
    GTResourceTrackerResourceRead(a1, 80, *((uint64_t *)&v96 + 1), v19);
    uint64_t v43 = v97;
  }

  else
  {
    if (FuncEnumReceiverType != 39) {
      return;
    }
    unint64_t v19 = *(void *)a2;
    uint64_t v20 = *a1;
    *(void *)&__int128 v90 = v17;
    uint64_t v21 = *(void *)(*find_entry(v20, &v90, 8uLL, 0LL) + 32LL);
    __int128 v90 = 0u;
    uint64_t v91 = 0LL;
    __int128 v96 = 0u;
    __int128 v95 = 0u;
    __int128 v94 = 0u;
    __int128 v93 = 0u;
    LODWORD(v90) = 39;
    uint64_t v92 = -1LL;
    uint64_t v22 = *(void *)(v21 + 32);
    if (v22)
    {
      unsigned int v23 = 0;
      while (1)
      {
        unsigned int v24 = atomic_load((unsigned int *)(v22 + 4));
        uint64_t v25 = v23 + (v24 >> 6) - 1;
        uint64_t v22 = *(void *)(v22 + 40);
        unsigned int v23 = v25;
        if (!v22)
        {
          unsigned int v23 = v25;
          goto LABEL_49;
        }
      }
    }

    else
    {
      unsigned int v23 = 0;
    }

    uint64_t v25 = 0LL;
LABEL_49:
    unint64_t v37 = v23 | (unint64_t)(v25 << 32);
LABEL_50:
    uint64_t v38 = v22 + 64;
    while (v22)
    {
      uint64_t v39 = (uint64_t *)(v38 + ((uint64_t)(HIDWORD(v37) - (int)v37) << 6));
      if (*v39 > v19) {
        break;
      }
      GTMTLFXSMSpatialScaler_processTraceFuncWithMap((char *)&v90, a1[1], v39);
      unsigned int v40 = atomic_load((unsigned int *)(v22 + 4));
      int v41 = v37 + (v40 >> 6);
      uint64_t v42 = (HIDWORD(v37) + 1);
      unint64_t v37 = (v42 << 32) | v37;
      if ((_DWORD)v42 == v41 - 1)
      {
        unint64_t v37 = (v42 << 32) | v42;
        uint64_t v22 = *(void *)(v22 + 40);
        goto LABEL_50;
      }
    }

    GTResourceTrackerUsingResource(a1[2], 39, (uint64_t)v17, *a1, a1[1]);
    GTResourceTrackerResourceRead(a1, 80, v95, v19);
    uint64_t v43 = *((void *)&v95 + 1);
  }

  id v50 = tracker_resource_get(a1, 80, v43, v19);
  if (v50) {
    v50[4] = v19;
  }
  GTResourceTrackerUsingResource(a1[2], 41, *((uint64_t *)&v94 + 1), *a1, a1[1]);
}

            uint64_t v7 = *((void *)v10 + 2);
            goto LABEL_469;
          case -15465:
LABEL_122:
            uint64_t v74 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            __int128 v88 = tracker_resource_get(a1, 16, *((void *)v74 + 1), a3);
            if (v88) {
              v88[4] = a3;
            }
LABEL_124:
            uint64_t v7 = *((void *)v74 + 2);
            goto LABEL_469;
          case -15459:
          case -15454:
          case -15449:
            goto LABEL_92;
          case -15458:
          case -15453:
          case -15448:
            goto LABEL_93;
          case -15457:
            uint64_t v292 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            uint64_t v293 = a1[2];
            v294 = GTTraceFunc_argumentBytesWithMap((void *)a2, v292[24], a1[1]);
            v295 = *((void *)v292 + 2);
            if (v295)
            {
              v296 = (uint64_t *)v294;
              v298 = *a1;
              uint64_t v297 = a1[1];
              do
              {
                v300 = *v296++;
                uint64_t v299 = v300;
                if (v300) {
                  GTResourceTrackerUsingResource(v293, 60, v299, v298, v297);
                }
                --v295;
              }

              while (v295);
            }

            break;
          case -15456:
          case -15451:
          case -15446:
            goto LABEL_94;
          case -15455:
            v301 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v302 = a1[2];
            uint64_t v303 = GTTraceFunc_argumentBytesWithMap((void *)a2, v301[24], a1[1]);
            v304 = *((void *)v301 + 2);
            if (v304)
            {
              unsigned int v305 = (uint64_t *)v303;
              v307 = *a1;
              v306 = a1[1];
              do
              {
                v309 = *v305++;
                uint64_t v308 = v309;
                if (v309) {
                  GTResourceTrackerUsingResource(v302, 83, v308, v307, v306);
                }
                --v304;
              }

              while (v304);
            }

            break;
          case -15452:
            v310 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v311 = a1[2];
            v312 = GTTraceFunc_argumentBytesWithMap((void *)a2, v310[24], a1[1]);
            uint64_t v313 = *((void *)v310 + 2);
            if (v313)
            {
              v314 = (uint64_t *)v312;
              v316 = *a1;
              uint64_t v315 = a1[1];
              do
              {
                v318 = *v314++;
                v317 = v318;
                if (v318) {
                  GTResourceTrackerUsingResource(v311, 60, v317, v316, v315);
                }
                --v313;
              }

              while (v313);
            }

            break;
          case -15450:
            v319 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v320 = a1[2];
            v321 = GTTraceFunc_argumentBytesWithMap((void *)a2, v319[24], a1[1]);
            __int128 v322 = *((void *)v319 + 2);
            if (v322)
            {
              __int128 v323 = (uint64_t *)v321;
              __int128 v325 = *a1;
              __int128 v324 = a1[1];
              do
              {
                char v327 = *v323++;
                v326 = v327;
                if (v327) {
                  GTResourceTrackerUsingResource(v320, 83, v326, v325, v324);
                }
                --v322;
              }

              while (v322);
            }

            break;
          case -15447:
            v328 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            char v329 = a1[2];
            v330 = GTTraceFunc_argumentBytesWithMap((void *)a2, v328[24], a1[1]);
            char v331 = *((void *)v328 + 2);
            if (v331)
            {
              v332 = (uint64_t *)v330;
              __int128 v334 = *a1;
              char v333 = a1[1];
              do
              {
                __int128 v336 = *v332++;
                __int128 v335 = v336;
                if (v336) {
                  GTResourceTrackerUsingResource(v329, 60, v335, v334, v333);
                }
                --v331;
              }

              while (v331);
            }

            break;
          case -15445:
            __int128 v337 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            char v338 = a1[2];
            v339 = GTTraceFunc_argumentBytesWithMap((void *)a2, v337[24], a1[1]);
            v340 = *((void *)v337 + 2);
            if (v340)
            {
              v341 = (uint64_t *)v339;
              v343 = *a1;
              v342 = a1[1];
              do
              {
                v345 = *v341++;
                v344 = v345;
                if (v345) {
                  GTResourceTrackerUsingResource(v338, 83, v344, v343, v342);
                }
                --v340;
              }

              while (v340);
            }

            break;
          case -15415:
LABEL_216:
            uint64_t v7 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
            goto LABEL_469;
          case -15401:
          case -15391:
            goto LABEL_104;
          case -15399:
            v346 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v347 = a1[2];
            v348 = GTTraceFunc_argumentBytesWithMap((void *)a2, v346[24], a1[1]);
            v349 = *((void *)v346 + 2);
            if (v349)
            {
              v350 = (uint64_t *)v348;
              v352 = *a1;
              v351 = a1[1];
              do
              {
                v354 = *v350++;
                v353 = v354;
                if (v354) {
                  GTResourceTrackerUsingResource(v347, 22, v353, v352, v351);
                }
                --v349;
              }

              while (v349);
            }

            break;
          case -15397:
          case -15396:
          case -15387:
          case -15386:
LABEL_61:
            uint64_t v42 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            uint64_t v18 = a1[1];
            unint64_t v19 = *((void *)v42 + 1);
            uint64_t v20 = *a1;
            uint64_t v21 = a1[2];
LABEL_62:
            uint64_t v22 = 75;
            goto LABEL_415;
          case -15395:
            v355 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v356 = a1[2];
            v357 = GTTraceFunc_argumentBytesWithMap((void *)a2, v355[24], a1[1]);
            v358 = *((void *)v355 + 2);
            if (v358)
            {
              v359 = (uint64_t *)v357;
              v361 = *a1;
              v360 = a1[1];
              do
              {
                v363 = *v359++;
                v362 = v363;
                if (v363) {
                  GTResourceTrackerUsingResource(v356, 75, v362, v361, v360);
                }
                --v358;
              }

              while (v358);
            }

            break;
          case -15394:
            v364 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v365 = a1[2];
            v366 = GTTraceFunc_argumentBytesWithMap((void *)a2, v364[24], a1[1]);
            v367 = *((void *)v364 + 2);
            if (v367)
            {
              v368 = (uint64_t *)v366;
              v370 = *a1;
              v369 = a1[1];
              do
              {
                v372 = *v368++;
                v371 = v372;
                if (v372) {
                  GTResourceTrackerUsingResource(v365, 75, v371, v370, v369);
                }
                --v367;
              }

              while (v367);
            }

            break;
          case -15393:
          case -15383:
LABEL_70:
            uint64_t v52 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            uint64_t v18 = a1[1];
            unint64_t v19 = *((void *)v52 + 1);
            uint64_t v20 = *a1;
            uint64_t v21 = a1[2];
            uint64_t v22 = 80;
            goto LABEL_415;
          case -15392:
            v373 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v374 = a1[2];
            v375 = GTTraceFunc_argumentBytesWithMap((void *)a2, v373[24], a1[1]);
            v376 = *((void *)v373 + 2);
            if (v376)
            {
              v377 = (uint64_t *)v375;
              v379 = *a1;
              v378 = a1[1];
              do
              {
                v381 = *v377++;
                v380 = v381;
                if (v381) {
                  GTResourceTrackerUsingResource(v374, 80, v380, v379, v378);
                }
                --v376;
              }

              while (v376);
            }

            break;
          case -15389:
            v382 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v383 = a1[2];
            v384 = GTTraceFunc_argumentBytesWithMap((void *)a2, v382[24], a1[1]);
            v385 = *((void *)v382 + 2);
            if (v385)
            {
              v386 = (uint64_t *)v384;
              v388 = *a1;
              v387 = a1[1];
              do
              {
                v390 = *v386++;
                v389 = v390;
                if (v390) {
                  GTResourceTrackerUsingResource(v383, 22, v389, v388, v387);
                }
                --v385;
              }

              while (v385);
            }

            break;
          case -15385:
            v391 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v392 = a1[2];
            v393 = GTTraceFunc_argumentBytesWithMap((void *)a2, v391[24], a1[1]);
            v394 = *((void *)v391 + 2);
            if (v394)
            {
              v395 = (uint64_t *)v393;
              v397 = *a1;
              v396 = a1[1];
              do
              {
                v399 = *v395++;
                v398 = v399;
                if (v399) {
                  GTResourceTrackerUsingResource(v392, 75, v398, v397, v396);
                }
                --v394;
              }

              while (v394);
            }

            break;
          case -15384:
            v400 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v401 = a1[2];
            v402 = GTTraceFunc_argumentBytesWithMap((void *)a2, v400[24], a1[1]);
            v403 = *((void *)v400 + 2);
            if (v403)
            {
              v404 = (uint64_t *)v402;
              v406 = *a1;
              v405 = a1[1];
              do
              {
                v408 = *v404++;
                v407 = v408;
                if (v408) {
                  GTResourceTrackerUsingResource(v401, 75, v407, v406, v405);
                }
                --v403;
              }

              while (v403);
            }

            break;
          case -15382:
            v409 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v410 = a1[2];
            v411 = GTTraceFunc_argumentBytesWithMap((void *)a2, v409[24], a1[1]);
            v412 = *((void *)v409 + 2);
            if (v412)
            {
              v413 = (uint64_t *)v411;
              v415 = *a1;
              v414 = a1[1];
              do
              {
                v417 = *v413++;
                v416 = v417;
                if (v417) {
                  GTResourceTrackerUsingResource(v410, 80, v416, v415, v414);
                }
                --v412;
              }

              while (v412);
            }

            break;
          default:
            switch(v6)
            {
              case -15524:
                uint64_t v10 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                uint64_t v53 = tracker_resource_get(a1, 16, *((void *)v10 + 1), a3);
                if (v53) {
                  v53[4] = a3;
                }
                uint64_t v54 = GTTraceFunc_argumentBytesWithMap((void *)a2, v10[32], a1[1]);
                unsigned int v55 = (uint64_t *)(v54 + 8);
                for (uint64_t j = *(void *)v54; j; --j)
                {
                  unint64_t v58 = *v55++;
                  uint64_t v57 = v58;
                  if (v58) {
                    GTResourceTrackerResourceRead(a1, 16, v57, a3);
                  }
                }

                goto LABEL_81;
              case -15523:
                goto LABEL_122;
              case -15522:
                v418 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                GTResourceTrackerResourceRead(a1, 16, *((void *)v418 + 1), a3);
                v419 = GTTraceFunc_argumentBytesWithMap((void *)a2, v418[32], a1[1]);
                v420 = (uint64_t *)(v419 + 8);
                for (uint64_t k = *(void *)v419; k; --k)
                {
                  v423 = *v420++;
                  v422 = v423;
                  if (v423) {
                    GTResourceTrackerResourceRead(a1, 16, v422, a3);
                  }
                }

                uint64_t v26 = *((void *)v418 + 2);
                goto LABEL_237;
              case -15521:
                goto LABEL_236;
              default:
                if (v6 == -15502) {
                  goto LABEL_236;
                }
                break;
            }

            break;
        }
      }

      return;
    }

    if (v6 > -7158)
    {
      switch(v6)
      {
        case -6142:
          int v231 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 7, *(void *)v231, *a1, a1[1]);
          uint64_t v232 = GTTraceFunc_argumentBytesWithMap((void *)a2, v231[40], a1[1]);
          v233 = *((void *)v231 + 6);
          if (v233)
          {
            uint64_t v234 = (uint64_t *)v232;
            do
            {
              char v236 = *v234++;
              unsigned int v235 = v236;
              if (v236) {
                GTResourceTrackerResourceRead(a1, 80, v235, a3);
              }
              --v233;
            }

            while (v233);
          }

          unsigned int v237 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, v231[64], a1[1]);
          GTResourceTrackerResourceWriteArray(a1, 80, v237, *((void *)v231 + 9), a3);
          uint64_t v7 = *((void *)v231 + 13);
          goto LABEL_469;
        case -6141:
        case -6139:
        case -6138:
        case -6134:
        case -6133:
        case -6131:
        case -6129:
        case -6128:
        case -6127:
        case -6124:
        case -6123:
        case -6122:
        case -6120:
        case -6119:
        case -6116:
        case -6111:
        case -6110:
        case -6109:
          return;
        case -6140:
          uint64_t v238 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 11, *v238, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v238[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v238[11], a3);
          uint64_t v239 = tracker_resource_get(a1, 22, v238[15], a3);
          if (v239) {
            v239[4] = a3;
          }
          uint64_t v7 = v238[19];
          goto LABEL_469;
        case -6137:
          v240 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 11, *v240, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v240[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v240[11], a3);
          uint64_t v26 = v240[15];
          goto LABEL_237;
        case -6136:
          uint64_t v241 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 5, *v241, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v241[3], a3);
          uint64_t v242 = v241[4];
          goto LABEL_467;
        case -6135:
          uint64_t v243 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v245 = a1[1];
          uint64_t v244 = a1[2];
          v246 = *v243;
          uint64_t v247 = *a1;
          uint64_t v248 = 8;
          goto LABEL_263;
        case -6132:
          v249 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 10, *v249, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v249[11], a3);
          GTResourceTrackerResourceRead(a1, 22, v249[16], a3);
          uint64_t v26 = v249[21];
          goto LABEL_237;
        case -6130:
          int v250 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 10, *v250, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v250[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v250[11], a3);
          uint64_t v26 = v250[16];
          goto LABEL_237;
        case -6126:
          uint64_t v243 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v245 = a1[1];
          uint64_t v244 = a1[2];
          v246 = *v243;
          uint64_t v247 = *a1;
          uint64_t v248 = 7;
LABEL_263:
          GTResourceTrackerUsingResource(v244, v248, v246, v247, v245);
          GTResourceTrackerResourceRead(a1, 80, v243[5], a3);
          uint64_t v26 = v243[7];
          goto LABEL_57;
        case -6125:
          uint64_t v33 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 4, *v33, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 80, v33[6], a3);
          uint64_t v34 = v33[8];
LABEL_265:
          GTResourceTrackerResourceRead(a1, 80, v34, a3);
          uint64_t v26 = v33[10];
          goto LABEL_57;
        case -6121:
          unint64_t v251 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 7, *v251, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 80, v251[5], a3);
          uint64_t v7 = v251[7];
LABEL_73:
          uint64_t v8 = a1;
          uint64_t v9 = 80;
          goto LABEL_470;
        case -6118:
          uint64_t v252 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 4, *(void *)v252, *a1, a1[1]);
          v253 = GTTraceFunc_argumentBytesWithMap((void *)a2, v252[48], a1[1]);
          uint64_t v254 = *((void *)v252 + 7);
          if (v254)
          {
            uint64_t v255 = (uint64_t *)v253;
            do
            {
              v257 = *v255++;
              v256 = v257;
              if (v257) {
                GTResourceTrackerResourceRead(a1, 80, v256, a3);
              }
              --v254;
            }

            while (v254);
          }

          unint64_t v258 = GTTraceFunc_argumentBytesWithMap((void *)a2, v252[72], a1[1]);
          uint64_t v259 = *((void *)v252 + 10);
          if (v259)
          {
            v260 = (uint64_t *)v258;
            do
            {
              v262 = *v260++;
              uint64_t v261 = v262;
              if (v262) {
                GTResourceTrackerResourceRead(a1, 80, v261, a3);
              }
              --v259;
            }

            while (v259);
          }

          unint64_t v263 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, v252[96], a1[1]);
          GTResourceTrackerResourceWriteArray(a1, 80, v263, *((void *)v252 + 13), a3);
          goto LABEL_300;
        case -6117:
          size_t v67 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 8, *v67, *a1, a1[1]);
          uint64_t v68 = v67[6];
          uint64_t v69 = a1;
          unsigned int v70 = 80;
LABEL_279:
          GTResourceTrackerResourceRead(v69, v70, v68, a3);
          uint64_t v26 = v67[8];
          goto LABEL_57;
        case -6115:
          uint64_t v264 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 8, *(void *)v264, *a1, a1[1]);
          v265 = GTTraceFunc_argumentBytesWithMap((void *)a2, v264[48], a1[1]);
          uint64_t v266 = *((void *)v264 + 7);
          if (v266)
          {
            uint64_t v267 = (uint64_t *)v265;
            do
            {
              v269 = *v267++;
              int v268 = v269;
              if (v269) {
                GTResourceTrackerResourceRead(a1, 80, v268, a3);
              }
              --v266;
            }

            while (v266);
          }

          v270 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, v264[72], a1[1]);
          GTResourceTrackerResourceWriteArray(a1, 80, v270, *((void *)v264 + 10), a3);
          uint64_t v7 = *((void *)v264 + 12);
          goto LABEL_469;
        case -6114:
          uint64_t v252 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 6, *(void *)v252, *a1, a1[1]);
          uint64_t v271 = GTTraceFunc_argumentBytesWithMap((void *)a2, v252[48], a1[1]);
          int v272 = *((void *)v252 + 7);
          if (v272)
          {
            BOOL v273 = (uint64_t *)v271;
            do
            {
              int v275 = *v273++;
              int v274 = v275;
              if (v275) {
                GTResourceTrackerResourceRead(a1, 80, v274, a3);
              }
              --v272;
            }

            while (v272);
          }

          unsigned int v276 = GTTraceFunc_argumentBytesWithMap((void *)a2, v252[72], a1[1]);
          uint64_t v277 = *((void *)v252 + 10);
          if (v277)
          {
            uint64_t v278 = (uint64_t *)v276;
            do
            {
              v280 = *v278++;
              v279 = v280;
              if (v280) {
                GTResourceTrackerResourceRead(a1, 80, v279, a3);
              }
              --v277;
            }

            while (v277);
          }

          GTResourceTrackerResourceRead(a1, 22, *((void *)v252 + 12), a3);
          uint64_t v281 = tracker_resource_get(a1, 22, *((void *)v252 + 12), a3);
          if (v281) {
            v281[4] = a3;
          }
          GTResourceTrackerResourceRead(a1, 22, *((void *)v252 + 13), a3);
          v282 = tracker_resource_get(a1, 22, *((void *)v252 + 13), a3);
          if (v282) {
            v282[4] = a3;
          }
LABEL_300:
          uint64_t v7 = *((void *)v252 + 15);
          goto LABEL_469;
        case -6113:
          uint64_t v157 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 6, *v157, *a1, a1[1]);
          uint64_t v158 = v157[3];
LABEL_302:
          GTResourceTrackerResourceRead(a1, 22, v158, a3);
          uint64_t v7 = v157[4];
          goto LABEL_469;
        case -6112:
          uint64_t v241 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 5, *v241, *a1, a1[1]);
          uint64_t v283 = tracker_resource_get(a1, 22, v241[3], a3);
          if (v283) {
            v283[4] = a3;
          }
          uint64_t v284 = tracker_resource_get(a1, 22, v241[4], a3);
          if (v284) {
            v284[4] = a3;
          }
          goto LABEL_468;
        case -6108:
          uint64_t v159 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 5, *v159, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v159[3], a3);
          uint64_t v160 = v159[5];
LABEL_308:
          GTResourceTrackerResourceRead(a1, 22, v160, a3);
          goto LABEL_309;
        case -6107:
          uint64_t v241 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 6, *v241, *a1, a1[1]);
          uint64_t v242 = v241[3];
LABEL_467:
          GTResourceTrackerResourceRead(a1, 22, v242, a3);
LABEL_468:
          uint64_t v7 = v241[5];
          goto LABEL_469;
        case -6106:
          uint64_t v159 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 5, *v159, *a1, a1[1]);
          uint64_t v285 = tracker_resource_get(a1, 22, v159[3], a3);
          if (v285) {
            v285[4] = a3;
          }
          v286 = tracker_resource_get(a1, 22, v159[5], a3);
          if (v286) {
            v286[4] = a3;
          }
LABEL_309:
          uint64_t v7 = v159[6];
          goto LABEL_469;
        case -6105:
        case -6101:
          unsigned int v23 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 10, *v23, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v23[11], a3);
          GTResourceTrackerResourceRead(a1, 22, v23[16], a3);
          unsigned int v24 = tracker_resource_get(a1, 22, v23[21], a3);
          if (v24) {
            v24[4] = a3;
          }
          uint64_t v7 = v23[26];
          goto LABEL_469;
        case -6104:
          uint64_t v287 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 9, *v287, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v287[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v287[11], a3);
          GTResourceTrackerResourceRead(a1, 22, v287[16], a3);
          uint64_t v26 = v287[20];
          goto LABEL_237;
        case -6103:
          int v288 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 9, *v288, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v288[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v288[11], a3);
          GTResourceTrackerResourceRead(a1, 22, v288[16], a3);
          v289 = tracker_resource_get(a1, 22, v288[20], a3);
          if (v289) {
            v289[4] = a3;
          }
          uint64_t v7 = v288[33];
          goto LABEL_469;
        case -6102:
        case -6100:
          int v78 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          int v80 = a1[1];
          uint64_t v79 = a1[2];
          uint64_t v81 = *v78;
          id v82 = *a1;
          __int16 v83 = 14;
          goto LABEL_116;
        case -6099:
        case -6098:
          int v78 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          int v80 = a1[1];
          uint64_t v79 = a1[2];
          uint64_t v81 = *v78;
          id v82 = *a1;
          __int16 v83 = 13;
LABEL_116:
          GTResourceTrackerUsingResource(v79, v83, v81, v82, v80);
          GTResourceTrackerResourceRead(a1, 22, v78[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v78[8], a3);
          GTResourceTrackerResourceRead(a1, 22, v78[10], a3);
          id v84 = tracker_resource_get(a1, 22, v78[12], a3);
          if (v84) {
            v84[4] = a3;
          }
          uint64_t v7 = v78[15];
          goto LABEL_469;
        case -6097:
          v290 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 12, *v290, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v290[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v290[8], a3);
          uint64_t v291 = tracker_resource_get(a1, 22, v290[10], a3);
          if (v291) {
            v291[4] = a3;
          }
          uint64_t v7 = v290[12];
LABEL_469:
          uint64_t v8 = a1;
          uint64_t v9 = 22;
LABEL_470:
          GTResourceTrackerResourceRead(v8, v9, v7, a3);
          return;
        default:
          if (v6 == -7157) {
            goto LABEL_113;
          }
          unsigned int v40 = -7156;
          goto LABEL_112;
      }
    }

    if (v6 <= -15288)
    {
      if (v6 > -15341)
      {
        switch(v6)
        {
          case -15311:
            goto LABEL_83;
          case -15310:
            v536 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v537 = tracker_resource_get(a1, 80, *((void *)v536 + 1), a3);
            if (v537) {
              *((_BYTE *)v537 + 4_Block_object_dispose(va, 8) = 1;
            }
            uint64_t v26 = *((void *)v536 + 1);
            goto LABEL_57;
          case -15309:
          case -15308:
            goto LABEL_129;
          default:
            if (v6 == -15340 || v6 == -15339) {
              goto LABEL_129;
            }
            break;
        }

        return;
      }

      if (v6 == -15366)
      {
        __int16 v85 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
        GTResourceTrackerResourceRead(a1, 16, *((void *)v85 + 1), a3);
        int v86 = tracker_resource_get(a1, 16, *((void *)v85 + 2), a3);
        if (v86) {
          v86[4] = a3;
        }
        GTResourceTrackerUsingResource(a1[2], 22, *((void *)v85 + 3), *a1, a1[1]);
        __int16 v87 = v85[48];
LABEL_136:
        __int128 v97 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, v87, a1[1]);
        GTResourceTrackerUsingAccelerationStructureDescriptor(a1, v97, a3);
        return;
      }

      if (v6 != -15365)
      {
        if (v6 != -15342) {
          return;
        }
LABEL_83:
        uint64_t v59 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
        uint64_t v60 = tracker_resource_get(a1, 22, *((void *)v59 + 1), a3);
        if (v60) {
          *((_BYTE *)v60 + 4_Block_object_dispose(va, 8) = 1;
        }
        uint64_t v26 = *((void *)v59 + 1);
        goto LABEL_237;
      }

void defaultCommandEncoder_processStream(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v26 = a2;
  uint64_t v5 = *(void *)(*(void *)(*find_entry(v4, &v26, 8uLL, 0LL) + 32LL) + 32LL);
  if (v5)
  {
    unsigned int v6 = 0;
    while (1)
    {
      unsigned int v7 = atomic_load((unsigned int *)(v5 + 4));
      uint64_t v8 = v6 + (v7 >> 6) - 1;
      uint64_t v5 = *(void *)(v5 + 40);
      unsigned int v6 = v8;
      if (!v5)
      {
        unsigned int v6 = v8;
        goto LABEL_8;
      }
    }
  }

  else
  {
    unsigned int v6 = 0;
  }

  uint64_t v8 = 0LL;
LABEL_8:
  unint64_t v9 = v6 | (unint64_t)(v8 << 32);
LABEL_9:
  uint64_t v10 = v5 + 64;
  while (v5 && (*(_BYTE *)(v10 + ((uint64_t)(HIDWORD(v9) - (int)v9) << 6) + 15) & 8) != 0)
  {
    uint64_t v11 = (uint64_t *)(v10 + ((uint64_t)(HIDWORD(v9) - (int)v9) << 6));
    GTResourceTrackerProcessResourceUse(a1, (uint64_t)v11, *v11);
    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v24, v11, a1[1]);
    unsigned int v12 = atomic_load((unsigned int *)(v5 + 4));
    int v13 = v9 + (v12 >> 6);
    uint64_t v14 = (HIDWORD(v9) + 1);
    unint64_t v9 = (v14 << 32) | v9;
    if ((_DWORD)v14 == v13 - 1)
    {
      unint64_t v9 = (v14 << 32) | v14;
      uint64_t v5 = *(void *)(v5 + 40);
      goto LABEL_9;
    }
  }

  switch(v24[0])
  {
    case 0x11:
      uint64_t v18 = v25;
      if (v25)
      {
        for (uint64_t i = 8LL; i != 104; i += 24LL)
        {
          uint64_t v20 = *(void *)(v18 + i);
          if (v20) {
            GTResourceTrackerUsingResource(a1[2], 31, v20, *a1, a1[1]);
          }
        }
      }

      break;
    case 0x15:
      uint64_t v21 = v25;
      if (v25)
      {
        for (uint64_t j = 8LL; j != 104; j += 24LL)
        {
          uint64_t v23 = *(void *)(v21 + j);
          if (v23) {
            GTResourceTrackerUsingResource(a1[2], 31, v23, *a1, a1[1]);
          }
        }
      }

      break;
    case 0x4A:
      uint64_t v15 = v25;
      if (v25)
      {
        for (uint64_t k = 8LL; k != 104; k += 24LL)
        {
          uint64_t v17 = *(void *)(v15 + k);
          if (v17) {
            GTResourceTrackerUsingResource(a1[2], 31, v17, *a1, a1[1]);
          }
        }
      }

      break;
  }

uint64_t computeCommandEncoder_processStream(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v21 = a2;
  uint64_t result = (uint64_t)find_entry(v4, &v21, 8uLL, 0LL);
  uint64_t v6 = *(void *)(*(void *)(*(void *)result + 32LL) + 32LL);
  if (v6)
  {
    unsigned int v7 = 0;
    while (1)
    {
      unsigned int v8 = atomic_load((unsigned int *)(v6 + 4));
      uint64_t v9 = v7 + (v8 >> 6) - 1;
      uint64_t v6 = *(void *)(v6 + 40);
      unsigned int v7 = v9;
      if (!v6)
      {
        unsigned int v7 = v9;
        goto LABEL_8;
      }
    }
  }

  else
  {
    unsigned int v7 = 0;
  }

  uint64_t v9 = 0LL;
LABEL_8:
  unint64_t v10 = v7 | (unint64_t)(v9 << 32);
LABEL_9:
  uint64_t v11 = v6 + 64;
  while (v6 && (*(_BYTE *)(v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6) + 15) & 8) != 0)
  {
    uint64_t v12 = v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6);
    GTResourceTrackerProcessResourceUse(a1, v12, *(void *)v12);
    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v19, (uint64_t *)v12, a1[1]);
    uint64_t result = (uint64_t)ResourceTracker_processCommandEncoder(a1, *(_DWORD *)(v12 + 8), (uint64_t)v19, *(void *)v12);
    unsigned int v13 = atomic_load((unsigned int *)(v6 + 4));
    int v14 = v10 + (v13 >> 6);
    uint64_t v15 = (HIDWORD(v10) + 1);
    unint64_t v10 = (v15 << 32) | v10;
    if ((_DWORD)v15 == v14 - 1)
    {
      unint64_t v10 = (v15 << 32) | v15;
      uint64_t v6 = *(void *)(v6 + 40);
      goto LABEL_9;
    }
  }

  if (v19[0] == 28)
  {
    uint64_t v16 = v20;
    if (v20)
    {
      for (uint64_t i = 8LL; i != 104; i += 24LL)
      {
        uint64_t v18 = *(void *)(v16 + i);
        if (v18) {
          uint64_t result = GTResourceTrackerUsingResource(a1[2], 31, v18, *a1, a1[1]);
        }
      }
    }
  }

  return result;
}

uint64_t renderCommandEncoder_processStreamWithDescriptor(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  uint64_t v26 = *(void *)(a3 + 8);
  uint64_t v7 = *(void *)(*(void *)(*find_entry(v6, &v26, 8uLL, 0LL) + 32LL) + 32LL);
  if (v7)
  {
    unsigned int v8 = 0;
    while (1)
    {
      unsigned int v9 = atomic_load((unsigned int *)(v7 + 4));
      uint64_t v10 = v8 + (v9 >> 6) - 1;
      uint64_t v7 = *(void *)(v7 + 40);
      unsigned int v8 = v10;
      if (!v7)
      {
        unsigned int v8 = v10;
        goto LABEL_8;
      }
    }

    uint64_t v10 = 1LL;
  }

  else
  {
    unsigned int v8 = 0;
    uint64_t v10 = 0LL;
  }

LABEL_8:
  unint64_t v11 = v8 | (unint64_t)(v10 << 32);
LABEL_9:
  uint64_t v12 = v7 + 64;
  while (v7 && (*(_BYTE *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6) + 15) & 8) != 0)
  {
    uint64_t v13 = v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6);
    int v14 = (int *)(v13 + 8);
    char v15 = IsFuncEnumEndEncoding(*(_DWORD *)(v13 + 8));
    uint64_t v16 = *(void *)v13;
    if ((v15 & 1) != 0) {
      return v16;
    }
    GTResourceTrackerProcessResourceUse(a1, v13, v16);
    GTMTLSMCommandEncoder_processTraceFunc(a3, (uint64_t *)v13, a1[1]);
    ResourceTracker_processCommandEncoder(a1, *v14, a3, *(void *)v13);
    if (IsFuncEnumDrawCall(*v14))
    {
      if (*(_DWORD *)a3 == 70) {
        uint64_t v17 = *(unsigned __int8 *)(a3 + 11141);
      }
      else {
        uint64_t v17 = 0LL;
      }
      uint64_t v18 = 0LL;
      uint64_t v19 = *(void *)v13;
      do
      {
        RenderEncoderLoadAttachment(a1, a2 + v18, v19);
        v18 += 64LL;
      }

      while (v18 != 512);
      RenderEncoderLoadAttachment(a1, a2 + 672, v19);
      RenderEncoderLoadAttachment(a1, a2 + 720, v19);
      if (v17)
      {
        uint64_t v20 = *(void *)(a2 + 792);
        if (v20)
        {
          uint64_t v21 = tracker_resource_get(a1, 22, v20, v19);
          if (v21) {
            void v21[4] = v19;
          }
        }
      }

      GTResourceTrackerUsingResource(a1[2], 68, *(void *)(a2 + 784), *a1, a1[1]);
    }

    unsigned int v22 = atomic_load((unsigned int *)(v7 + 4));
    int v23 = v11 + (v22 >> 6);
    uint64_t v24 = (HIDWORD(v11) + 1);
    unint64_t v11 = (v24 << 32) | v11;
    if ((_DWORD)v24 == v23 - 1)
    {
      unint64_t v11 = (v24 << 32) | v24;
      uint64_t v7 = *(void *)(v7 + 40);
      goto LABEL_9;
    }
  }

  return -1LL;
}
  }

  unsigned int v8 = v21;
  *(_DWORD *)(v21 + _Block_object_dispose(va, 8) = -7167;
  unsigned int v9 = v24;
  if (v24 > 0x30uLL)
  {
    unint64_t v11 = *(void *)(v20[1] + 24LL);
    uint64_t v12 = v25++;
    uint64_t v10 = GTTraceMemPool_allocateBytes(v11, v22, v12 | 0x1000000000LL) + 16;
    unsigned int v9 = v12;
  }

  else
  {
    uint64_t v10 = (char *)(v8 + v24);
    v24 += 16;
  }

  *(_BYTE *)(v8 + 13) = v9;
  uint64_t v13 = -[CaptureMTLDrawable traceStream](self, "traceStream");
  if (v13) {
    var0 = v13->var0;
  }
  else {
    var0 = 0LL;
  }
  char v15 = (uint64_t *)[v5 traceStream];
  if (v15) {
    uint64_t v16 = *v15;
  }
  else {
    uint64_t v16 = 0LL;
  }
  *(void *)uint64_t v10 = var0;
  *((void *)v10 + 1) = v16;
  s();
  *(void *)uint64_t v17 = v18;
  *(_BYTE *)(v17 + _Block_object_dispose(va, 8) = v23;
  *(_BYTE *)(v21 + 15) |= 8u;

  return v4;
}

  std::mutex::unlock(v2);
}

  std::mutex::unlock(v2);
}

  uint64_t v10 = v7 | (unint64_t)(v9 << 32);
LABEL_9:
  unint64_t v11 = v6 + 64;
  while (v6 && (*(_BYTE *)(v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6) + 15) & 8) != 0)
  {
    uint64_t v12 = v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6);
    if (*(_DWORD *)(v12 + 8) == -16103)
    {
      uint64_t v13 = GTTraceFunc_argumentBytesWithPool((uint64_t *)v12, *(unsigned __int8 *)(v12 + 13), v5);
      v22[0] = v21;
      v22[1] = GTTraceFunc_argumentBytesWithMap((void *)v12, v13[24], *(void *)(a2 + 24));
      int v23 = *(_OWORD *)(v13 + 8);
      DYTraceEncode_MTLBuffer_addDebugMarker_range( (uint64_t)v22,  *(unsigned int **)(a1 + 8),  *(unsigned int *)(a1 + 16),  0LL,  0LL);
      int v14 = *(unsigned int **)(a1 + 8);
      char v15 = *v14;
      if ((*((_BYTE *)v14 + 33) & 0x10) != 0)
      {
        uint64_t v17 = *(unsigned int **)(a1 + 8);
        uint64_t v16 = *v14;
        do
        {
          uint64_t v17 = (unsigned int *)((char *)v17 + v15);
          char v15 = *v17;
          v16 += v15;
        }

        while ((*((_BYTE *)v17 + 33) & 0x20) == 0);
      }

      else
      {
        uint64_t v16 = *v14;
      }

      fbstream_write(*(void *)(a1 + 24), (uint64_t)v14, v16);
    }

    uint64_t v18 = atomic_load((unsigned int *)(v6 + 4));
    uint64_t v19 = v10 + (v18 >> 6);
    uint64_t v20 = (HIDWORD(v10) + 1);
    uint64_t v10 = (v20 << 32) | v10;
    if ((_DWORD)v20 == v19 - 1)
    {
      uint64_t v10 = (v20 << 32) | v20;
      uint64_t v6 = *(void *)(v6 + 40);
      goto LABEL_9;
    }
  }

    uint64_t v12 = gt_filepath_merge(*(const char **)a1, *(const char **)(*(void *)(v11 + 24) + 8LL * v10), a3);
    uint64_t v13 = open(v12, 0);
    int v14 = v13;
    if (a4)
    {
      if (v13 < 0)
      {
        char v15 = *a4;
        uint64_t v24 = 0u;
        uint64_t v25 = 0u;
        uint64_t v21 = v15;
        unsigned int v22 = 500;
        unsigned int v9 = "0 <= fd";
        goto LABEL_12;
      }
    }

    else if (v13 < 0)
    {
      return 0LL;
    }

    uint64_t v17 = mmap(0LL, *a2, 1, 2, v13, 0LL);
    uint64_t v19 = *a2;
    close(v14);
    uint64_t v20 = apr_palloc(a3, 0x10uLL);
    *uint64_t v20 = v17;
    v20[1] = v19;
    apr_pool_cleanup_register(a3, v20, (apr_status_t (__cdecl *)(void *))GTData_munmap, apr_pool_cleanup_null);
    return v17;
  }

  unsigned int v8 = *a4;
  uint64_t v24 = 0u;
  uint64_t v25 = 0u;
  uint64_t v21 = v8;
  unsigned int v22 = 500;
  unsigned int v9 = "entry->flags & 0x00000002";
LABEL_12:
  int v23 = v9;
  GTError_addError(a4, (uint64_t)&v21);
  return 0LL;
}

    uint64_t v6 = (void *)((char *)p + 112);
    uint64_t v7 = (uint64_t *)*((void *)p + 14);
    if (v7)
    {
      while (1)
      {
        unsigned int v8 = v7;
        uint64_t v7 = (uint64_t *)*v7;
        uint64_t v6 = v8;
        if (!*v8) {
          return;
        }
      }

      void *v6 = *v7;
      *uint64_t v7 = *((void *)p + 5);
      *((void *)p + 5) = v7;
    }
  }

uint64_t RenderEncoderWithDescriptor(uint64_t *a1, uint64_t *a2)
{
  for (uint64_t i = 0LL; i != 64; i += 8LL)
  {
    GTResourceTrackerUsingResource(a1[2], 80, a2[i + 1], *a1, a1[1]);
    GTResourceTrackerUsingResource(a1[2], 80, a2[i], *a1, a1[1]);
  }

  GTResourceTrackerUsingResource(a1[2], 80, a2[85], *a1, a1[1]);
  GTResourceTrackerUsingResource(a1[2], 80, a2[84], *a1, a1[1]);
  GTResourceTrackerUsingResource(a1[2], 80, a2[91], *a1, a1[1]);
  GTResourceTrackerUsingResource(a1[2], 80, a2[90], *a1, a1[1]);
  GTResourceTrackerUsingResource(a1[2], 22, a2[99], *a1, a1[1]);
  uint64_t result = GTResourceTrackerUsingResource(a1[2], 68, a2[98], *a1, a1[1]);
  uint64_t v6 = 0LL;
  uint64_t v7 = a2 + 66;
  do
  {
    uint64_t v8 = v7[v6];
    if (v8) {
      uint64_t result = GTResourceTrackerUsingResource(a1[2], 31, v8, *a1, a1[1]);
    }
    v6 += 5LL;
  }

  while (v6 != 20);
  return result;
}

uint64_t *RenderEncoderEndEncoding(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = 0LL;
  uint64_t v9 = a2;
  do
  {
    uint64_t v10 = *(unsigned __int8 *)(v9 + 27);
    if (v10 == 4) {
      uint64_t v10 = *(void *)(*(void *)a3 + v8);
    }
    RenderEncoderStoreAttachment(a1, (uint64_t *)v9, v10, a4);
    v8 += 8LL;
    v9 += 64LL;
  }

  while (v8 != 64);
  unsigned int v11 = *(unsigned __int8 *)(a2 + 699);
  if (v11 == 4) {
    unsigned int v11 = *(unsigned __int8 *)(a3 + 8);
  }
  RenderEncoderStoreAttachment(a1, (uint64_t *)(a2 + 672), v11, a4);
  unsigned int v12 = *(unsigned __int8 *)(a2 + 747);
  if (v12 == 4) {
    unsigned int v12 = *(unsigned __int8 *)(a3 + 9);
  }
  return RenderEncoderStoreAttachment(a1, (uint64_t *)(a2 + 720), v12, a4);
}

uint64_t *RenderEncoderStoreAttachment(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2[1];
  uint64_t v8 = result;
  switch(a3)
  {
    case 0LL:
    case 1LL:
    case 5LL:
      goto LABEL_5;
    case 2LL:
      goto LABEL_4;
    case 3LL:
      uint64_t v9 = tracker_resource_get(result, 80, v5, a4);
      if (v9) {
        v9[4] = a4;
      }
LABEL_4:
      uint64_t v5 = *a2;
LABEL_5:
      uint64_t result = tracker_resource_get(v8, 80, v5, a4);
      if (result) {
        result[4] = a4;
      }
      break;
    default:
      return result;
  }

  return result;
}

uint64_t *ResourceTracker_processCommandEncoder(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (uint64_t *)IsFuncEnumDrawCall(a2);
  if ((_DWORD)result)
  {
    if (*(_DWORD *)a3 != 70) {
      return result;
    }
    uint64_t v9 = *a1;
    v21.i64[0] = *(void *)(a3 + 8600);
    entry = find_entry(v9, &v21, 8uLL, 0LL);
    if (*entry) {
      uint64_t v11 = *(void *)(*entry + 32LL);
    }
    else {
      uint64_t v11 = 0LL;
    }
    GTMTLSMRenderPipelineState_resourceAccess(v11, a1[1], &v21);
    int8x16_t v21 = vandq_s8(v21, (int8x16_t)vdupq_n_s64(~*(void *)(a3 + 64)));
    BufferAccess(a1, a3 + 80, &v21, a4);
    TextureAccess(a1, a3 + 824, (uint64_t)v22, a4);
    int8x16_t v23 = vandq_s8(v23, (int8x16_t)vdupq_n_s64(~*(void *)(a3 + 1976)));
    BufferAccess(a1, a3 + 1984, &v23, a4);
    TextureAccess(a1, a3 + 2480, (uint64_t)&v24, a4);
    int8x16_t v25 = vandq_s8(v25, (int8x16_t)vdupq_n_s64(~*(void *)(a3 + 3632)));
    BufferAccess(a1, a3 + 3640, &v25, a4);
    TextureAccess(a1, a3 + 4136, (uint64_t)&v26, a4);
    int8x16_t v27 = vandq_s8(v27, (int8x16_t)vdupq_n_s64(~*(void *)(a3 + 5288)));
    BufferAccess(a1, a3 + 5296, &v27, a4);
    uint64_t v19 = a3 + 5792;
    uint64_t v20 = &v28;
    return TextureAccess(a1, v19, (uint64_t)v20, a4);
  }

  if (a2 <= -16080)
  {
    if (a2 != -16327 && a2 != -16220)
    {
      int v12 = -16137;
LABEL_12:
      if (a2 != v12) {
        return result;
      }
      goto LABEL_13;
    }

LABEL_15:
    uint64_t v16 = *a1;
    v21.i64[0] = *(void *)(a3 + 64);
    uint64_t v17 = find_entry(v16, &v21, 8uLL, 0LL);
    if (*v17) {
      uint64_t v18 = *(void *)(*v17 + 32LL);
    }
    else {
      uint64_t v18 = 0LL;
    }
    GTMTLSMComputePipelineState_resourceAccess(v18, a1[1], (uint64_t)&v21);
    int8x16_t v21 = vandq_s8(v21, (int8x16_t)vdupq_n_s64(~*(void *)(a3 + 72)));
    BufferAccess(a1, a3 + 88, &v21, a4);
    uint64_t v19 = a3 + 832;
    uint64_t v20 = (uint64_t *)v22;
    return TextureAccess(a1, v19, (uint64_t)v20, a4);
  }

  if (a2 != -15297)
  {
    int v12 = -15486;
    goto LABEL_12;
  }

  tempAlloc();
  uint64_t v16 = v15;
  uint64_t v17 = GTMemoryGuard_copyTracedChunks(v15, v9);
  CaptureMTLBuffer_registerBaseBufferForTracing(v35, v9, 1);
  if (!*v7 || !v17)
  {
    uint64_t v6 = apr_array_push(a1);
    v6[46] = *(_BYTE *)(a2 + 46);
    *(_OWORD *)uint64_t v6 = *(_OWORD *)a2;
    *((void *)v6 + 2) = *(void *)(a2 + 16);
    goto LABEL_39;
  }

  if (!__CFADD__(v5 - 1, vm_page_size))
  {
    uint64_t v18 = 0LL;
    uint64_t v19 = v17 << 6;
    uint64_t v20 = v17 - 1;
    int8x16_t v21 = (v5 - 1 + vm_page_size) / vm_page_size;
    do
    {
      unsigned int v22 = *v16;
      int8x16_t v23 = v18 >> 6;
      uint64_t v24 = *((void *)*v16 + (v18 >> 6)) & (-1LL << v18);
      int8x16_t v25 = v24 == 0;
      if (v18 >> 6 < v20 && !v24)
      {
        do
        {
          uint64_t v24 = v22[++v23];
          int8x16_t v25 = v24 == 0;
        }

        while (v23 < v20 && !v24);
      }

      uint64_t v26 = v19;
      uint64_t v18 = v19;
      if (!v25)
      {
        int8x16_t v27 = __clz(__rbit64(v24));
        uint64_t v28 = v24 | ~(-1LL << v27);
        int8x16_t v29 = v28 == -1;
        uint64_t v30 = v23;
        if (v23 < v20 && v28 == -1)
        {
          uint64_t v31 = v22 + 1;
          uint64_t v30 = v23;
          do
          {
            uint64_t v28 = v31[v30++];
            int8x16_t v29 = v28 == -1;
          }

          while (v30 < v20 && v28 == -1);
        }

        uint64_t v26 = v27 | (v23 << 6);
        if (v29) {
          uint64_t v18 = v19;
        }
        else {
          uint64_t v18 = __clz(__rbit64(~v28)) + (v30 << 6);
        }
      }

      if (v26 >= v21) {
        break;
      }
      uint64_t v32 = vm_page_size * v26;
      uint64_t v33 = vm_page_size * v18 >= v5 ? v5 : (int)vm_page_size * (int)v18;
      uint64_t v34 = apr_array_push(a1);
      v34[46] = *(_BYTE *)(a2 + 46);
      *(_OWORD *)uint64_t v34 = *(_OWORD *)a2;
      *((void *)v34 + 2) = *(void *)(a2 + 16);
      *((_DWORD *)v34 + 10) = *(_DWORD *)(a2 + 40);
      *((void *)v34 + 6) = v32;
      *((void *)v34 + 7) = v33 - v32;
    }

    while (v18 < v21);
  }

  uint64_t v13 = [v8 initWithFenum:v9 category:v10 customMessage:v11 customRecoverySuggestion:0];
  if (a3) {
LABEL_6:
  }

LABEL_7:
  if (a2) {

  }
  if (a1) {
  GTMTLGuestAppClient_notifyUnsupportedFenum(v13);
  }
  uint64_t v18 = 0u;
  uint64_t v19 = 0u;
  uint64_t v16 = 0u;
  uint64_t v17 = 0u;
  uint64_t v15 = 0u;
  int v14 = 0x900000000LL;
  GTCaptureBoundaryTracker_handleTrigger((__int128 *)&v14);
}

  uint64_t v11 = *(int *)(a2 + 12);
  if ((int)v11 >= 1)
  {
    int v12 = (int *)(*(void *)(a2 + 24) + 8LL);
    do
    {
      uint64_t v13 = *v12;
      v12 += 16;
      if ((IsFuncEnumUseResourceCall(v13) & 1) != 0) {
        return 1LL;
      }
    }

    while (--v11);
  }

  int v14 = a1[2];
  uint64_t v15 = *(unsigned int *)(v14 + 12);
  uint64_t v16 = *(uint64_t **)(v14 + 24);
  uint64_t v17 = v15 - 1;
  do
  {
    uint64_t v18 = *v16++;
    uint64_t v19 = *(_DWORD *)(v18 + 4) + 15690;
    uint64_t result = v19 < 3;
  }

  while (v19 >= 3 && v17-- != 0);
  return result;
}

      *(void *)(*(void *)(a3 + 24) + 8LL * (int)v16) = v11;
      uint64_t v19 = *(void *)(a3 + 24);
      uint64_t v20 = *(int *)(a3 + 8);
      *(_DWORD *)(a3 + 12) = v10;
      uint64_t result = GTTraceFuncToFbuf(v8, a2, *(void *)(v19 + v10 * v20), 0LL);
      uint64_t v4 = *(_DWORD *)(a3 + 12);
    }

    while (v4);
  }

  return result;
}

uint64_t *RenderEncoderLoadAttachment(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    uint64_t v6 = result;
    int v7 = *(unsigned __int8 *)(a2 + 25);
    if (v7 == 2) {
      return GTResourceTrackerResourceRead(result, 80, v4, 0x7FFFFFFFFFFFFFFFLL);
    }
    if (v7 != 1)
    {
      if (*(_BYTE *)(a2 + 25)) {
        return result;
      }
      return GTResourceTrackerResourceRead(result, 80, v4, 0x7FFFFFFFFFFFFFFFLL);
    }

    GTResourceTrackerResourceRead(result, 80, v4, a3);
    uint64_t v8 = *v6;
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t result = find_entry(v8, &v9, 8uLL, 0LL);
    if (*(_DWORD *)(*(void *)(*(void *)(*result + 32) + 32LL) + 72LL) == -16294)
    {
      uint64_t result = tracker_resource_get(v6, 80, *(void *)(a2 + 8), a3);
      *((_BYTE *)result + 4_Block_object_dispose(va, 8) = 1;
    }
  }

  return result;
}

uint64_t *BufferAccess(uint64_t *result, uint64_t a2, void *a3, uint64_t a4)
{
  int v7 = result;
  int v8 = 0;
  do
  {
    unint64_t v9 = *a3 >> v8;
    if (!v9) {
      break;
    }
    int v10 = v8 + __clz(__rbit64(v9));
    uint64_t result = GTResourceTrackerResourceRead(v7, 22, *(void *)(a2 + 8LL * v10), a4);
    int v8 = v10 + 1;
  }

  while (v10 < 63);
  int v11 = 0;
  do
  {
    unint64_t v12 = a3[1] >> v11;
    if (!v12) {
      break;
    }
    int v13 = v11 + __clz(__rbit64(v12));
    uint64_t result = tracker_resource_get(v7, 22, *(void *)(a2 + 8LL * v13), a4);
    if (result) {
      result[4] = a4;
    }
    int v11 = v13 + 1;
  }

  while (v13 < 63);
  return result;
}

uint64_t *TextureAccess(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = result;
  uint64_t v8 = 0LL;
  char v9 = 1;
  do
  {
    int v10 = 0;
    char v11 = v9;
    uint64_t v12 = v8 << 6;
    do
    {
      unint64_t v13 = *(void *)(a3 + 16 * v8) >> v10;
      if (!v13) {
        break;
      }
      int v14 = v10 + __clz(__rbit64(v13));
      uint64_t result = GTResourceTrackerResourceRead(v7, 80, *(void *)(a2 + 8 * (v12 + v14)), a4);
      int v10 = v14 + 1;
    }

    while (v14 < 63);
    int v15 = 0;
    uint64_t v16 = (void *)(a3 + 16 * v8 + 8);
    do
    {
      unint64_t v17 = *v16 >> v15;
      if (!v17) {
        break;
      }
      int v18 = v15 + __clz(__rbit64(v17));
      uint64_t result = tracker_resource_get(v7, 80, *(void *)(a2 + 8 * (v12 + v18)), a4);
      if (result) {
        result[4] = a4;
      }
      int v15 = v18 + 1;
    }

    while (v18 < 63);
    char v9 = 0;
    uint64_t v8 = 1LL;
  }

  while ((v11 & 1) != 0);
  return result;
}

void GTResourceTrackerProcessCommandEncoder(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v13 = a2;
  uint64_t v4 = *(void *)(*(void *)(*find_entry(v3, &v13, 8uLL, 0LL) + 32LL) + 32LL);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_8;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_8:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_9:
  uint64_t v9 = v4 + 64;
  while (v4 && (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) != 0)
  {
    GTResourceTrackerProcessFunction(a1, v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6));
    unsigned int v10 = atomic_load((unsigned int *)(v4 + 4));
    int v11 = v8 + (v10 >> 6);
    uint64_t v12 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v12 << 32) | v8;
    if ((_DWORD)v12 == v11 - 1)
    {
      unint64_t v8 = (v12 << 32) | v12;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_9;
    }
  }

void GTResourceTrackerProcessCommandBuffer(uint64_t *a1, uint64_t a2, char a3)
{
  uint64_t v5 = *a1;
  uint64_t v20 = a2;
  uint64_t v6 = *(void *)(*find_entry(v5, &v20, 8uLL, 0LL) + 32LL);
  uint64_t v7 = *(void *)(v6 + 32);
  if (v7)
  {
    unsigned int v8 = 0;
    while (1)
    {
      unsigned int v9 = atomic_load((unsigned int *)(v7 + 4));
      uint64_t v10 = v8 + (v9 >> 6) - 1;
      uint64_t v7 = *(void *)(v7 + 40);
      unsigned int v8 = v10;
      if (!v7)
      {
        unsigned int v8 = v10;
        goto LABEL_8;
      }
    }
  }

  else
  {
    unsigned int v8 = 0;
  }

  uint64_t v10 = 0LL;
LABEL_8:
  unint64_t v11 = v8 | (unint64_t)(v10 << 32);
LABEL_9:
  uint64_t v12 = v7 + 64;
  while (v7 && (*(_BYTE *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6) + 15) & 8) != 0)
  {
    GTResourceTrackerProcessFunction(a1, v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6));
    unsigned int v13 = atomic_load((unsigned int *)(v7 + 4));
    int v14 = v11 + (v13 >> 6);
    uint64_t v15 = (HIDWORD(v11) + 1);
    unint64_t v11 = (v15 << 32) | v11;
    if ((_DWORD)v15 == v14 - 1)
    {
      unint64_t v11 = (v15 << 32) | v15;
      uint64_t v7 = *(void *)(v7 + 40);
      goto LABEL_9;
    }
  }

  if ((a3 & 1) != 0)
  {
    uint64_t v16 = *a1;
    uint64_t v20 = CommandBufferQueue(v6, a1[1]);
    uint64_t v17 = *find_entry(v16, &v20, 8uLL, 0LL);
    if (v17) {
      uint64_t v18 = *(void *)(v17 + 32);
    }
    else {
      uint64_t v18 = 0LL;
    }
    unint64_t v19 = CommandBufferCommitIndex(v6);
    ResourceTracker_processUsedResidencySets((uint64_t)a1, v19, v18, 0LL);
  }

void ResourceTracker_processUsedResidencySets( uint64_t a1, unint64_t a2, uint64_t a3, apr_pool_t *parent)
{
  if (a3)
  {
    apr_pool_create_ex(&pool, parent, 0LL, 0LL);
    unsigned int v8 = pool;
    unsigned int v9 = (apr_pool_t **)apr_hash_make(pool);
    GatherCommandQueueResidencySetsUpToIndexInternal(v9, a3, *(void *)(a1 + 8), a2, 0LL, 1);
    uint64_t v10 = apr_hash_first(v8, (apr_hash_t *)v9);
    if (v10)
    {
      unint64_t v11 = v10;
      do
      {
        GTResourceTrackerUsingResidencySet((uint64_t *)a1, **(void **)(*((void *)v11 + 1) + 16LL));
        unint64_t v11 = apr_hash_next(v11);
      }

      while (v11);
    }

    apr_pool_destroy(v8);
  }

  if (*(_DWORD *)(*(void *)(a1 + 40) + 48LL))
  {
    apr_pool_create_ex(&newpool, parent, 0LL, 0LL);
    uint64_t v12 = newpool;
    int8x16_t v29 = apr_hash_make(newpool);
    pool = apr_hash_make(v12);
    unsigned int v13 = apr_hash_first(v12, *(apr_hash_t **)(a1 + 40));
    if (v13)
    {
      int v14 = v13;
      do
      {
        uint64_t v15 = *(void *)a1;
        uint64_t v31 = **(void **)(*((void *)v14 + 1) + 16LL);
        uint64_t v16 = *find_entry(v15, &v31, 8uLL, 0LL);
        if (v16) {
          uint64_t v17 = *(void *)(v16 + 32);
        }
        else {
          uint64_t v17 = 0LL;
        }
        char v18 = 1;
        GatherResidencySetAllocationsUpToIndexInternal((uint64_t)&pool, v17, *(void *)(a1 + 8), a2, 0LL, 1);
        unint64_t v19 = pool;
        uint64_t v20 = v29;
        do
        {
          char v21 = v18;
          if ((v18 & 1) != 0) {
            unsigned int v22 = v20;
          }
          else {
            unsigned int v22 = v19;
          }
          for (uint64_t i = apr_hash_first(v12, v22); ; uint64_t i = apr_hash_next(v24))
          {
            uint64_t v24 = i;
            if (!i) {
              break;
            }
            int8x16_t v25 = *(uint64_t **)(*((void *)i + 1) + 16LL);
            if (GTResourceTrackerGetResourceType(*v25, *(void *)a1) == 50)
            {
              GTResourceTrackerUsingResourceHeap((uint64_t *)a1, *v25, a2);
            }

            else
            {
              uint64_t v26 = *(void *)(a1 + 16);
              int ResourceType = GTResourceTrackerGetResourceType(*v25, *(void *)a1);
              GTResourceTrackerUsingResource(v26, ResourceType, *v25, *(void *)a1, *(void *)(a1 + 8));
            }
          }

          char v18 = 0;
        }

        while ((v21 & 1) != 0);
        apr_hash_clear(v20);
        apr_hash_clear(v19);
        int v14 = apr_hash_next(v14);
      }

      while (v14);
    }

    apr_pool_destroy(v12);
    apr_hash_clear(*(apr_hash_t **)(a1 + 40));
  }

void GTResourceTrackerUsingResidencySet(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = a2;
  GTResourceTrackerUsingResource(a1[2], 72, a2, *a1, a1[1]);
  entry = find_entry(a1[5], &v5, 8uLL, 0LL);
  if (!*entry || !*(void *)(*entry + 32LL))
  {
    uint64_t v4 = apr_palloc(*(apr_pool_t **)a1[5], 8uLL);
    *uint64_t v4 = v5;
    apr_hash_set((apr_hash_t *)a1[5], v4, 8LL, v4);
  }

void ResourceTracker_processAccelerationStructureReads(uint64_t a1)
{
  uint64_t v2 = newpool;
  uint64_t v3 = apr_array_make(newpool, 16, 8);
  uint64_t v4 = *(void *)(a1 + 32);
  *(_DWORD *)(v4 + 40) = 0;
  *(void *)(v4 + 16) = v4;
  *(void *)(v4 + 24) = 0LL;
  *(void *)(v4 + 32) = 0LL;
  uint64_t v5 = apr_hash_next((apr_hash_index_t *)(v4 + 16));
  if (v5)
  {
    uint64_t v6 = v5;
    do
    {
      uint64_t v7 = *(void *)(*((void *)v6 + 1) + 32LL);
      if (*(_DWORD *)(v7 + 40) == 16) {
        *(void *)apr_array_push(v3) = v7;
      }
      uint64_t v6 = apr_hash_next(v6);
    }

    while (v6);
  }

  if (v3->nelts >= 1)
  {
    uint64_t v8 = 0LL;
    do
    {
      uint64_t v9 = *(void *)&v3->elts[8 * v8];
      __int128 v21 = 0u;
      uint64_t v22 = 0LL;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v29 = 0u;
      __int128 v30 = 0u;
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      __int128 v25 = 0u;
      __int128 v24 = 0u;
      LODWORD(v21) = 16;
      uint64_t v23 = -1LL;
      WORD1(v2_Block_object_dispose(va, 8) = 2;
      __int128 v26 = 0xFFFFFFFFFFFFFFFFLL;
      uint64_t v10 = *(void *)(*(void *)(*find_entry(*(void *)a1, (_BYTE *)(v9 + 8), 8uLL, 0LL) + 32LL) + 32LL);
      if (v10)
      {
        unsigned int v11 = 0;
        while (1)
        {
          unsigned int v12 = atomic_load((unsigned int *)(v10 + 4));
          uint64_t v13 = v11 + (v12 >> 6) - 1;
          uint64_t v10 = *(void *)(v10 + 40);
          unsigned int v11 = v13;
          if (!v10)
          {
            unsigned int v11 = v13;
            goto LABEL_15;
          }
        }
      }

      else
      {
        unsigned int v11 = 0;
      }

      uint64_t v13 = 0LL;
LABEL_15:
      unint64_t v14 = v11 | (unint64_t)(v13 << 32);
LABEL_16:
      uint64_t v15 = v10 + 64;
      while (v10 && (*(_BYTE *)(v15 + ((uint64_t)(HIDWORD(v14) - (int)v14) << 6) + 15) & 8) != 0)
      {
        uint64_t v16 = v15 + ((uint64_t)(HIDWORD(v14) - (int)v14) << 6);
        GTMTLSMAccelerationStructure_processTraceFuncWithMap((char *)&v21, *(void *)(a1 + 8), (uint64_t *)v16);
        if (*(_DWORD *)(v16 + 8) == -15552 && (void)v29 != 0LL) {
          GTResourceTrackerUsingAccelerationStructureDescriptor((uint64_t *)a1, (uint64_t *)v29, *(void *)v16);
        }
        unsigned int v18 = atomic_load((unsigned int *)(v10 + 4));
        int v19 = v14 + (v18 >> 6);
        uint64_t v20 = (HIDWORD(v14) + 1);
        unint64_t v14 = (v20 << 32) | v14;
        if ((_DWORD)v20 == v19 - 1)
        {
          unint64_t v14 = (v20 << 32) | v20;
          uint64_t v10 = *(void *)(v10 + 40);
          goto LABEL_16;
        }
      }

      ++v8;
    }

    while (v8 < v3->nelts);
    uint64_t v2 = newpool;
  }

  apr_pool_destroy(v2);
}

uint64_t *GTResourceTrackerUsingAccelerationStructureDescriptor(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *(unsigned __int8 *)a2;
  if (v6 == 3)
  {
    GTResourceTrackerResourceRead(result, 22, a2[1], a3);
    GTResourceTrackerResourceRead(v5, 22, a2[3], a3);
    GTResourceTrackerResourceRead(v5, 22, a2[5], a3);
    return GTResourceTrackerResourceRead(v5, 22, a2[7], a3);
  }

  else if (v6 == 2)
  {
    GTResourceTrackerResourceRead(result, 22, a2[2], a3);
    uint64_t result = GTResourceTrackerResourceRead(v5, 22, a2[3], a3);
    if (*((_DWORD *)a2 + 14))
    {
      unint64_t v28 = 0LL;
      do
        uint64_t result = GTResourceTrackerResourceRead(v5, 16, *(void *)(a2[1] + 8 * v28++), a3);
      while (v28 < *((unsigned int *)a2 + 14));
    }
  }

  else if (v6 == 1 && a2[2])
  {
    unint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = a2[1];
      unint64_t v9 = v8 + 136 * v7;
      uint64_t result = GTResourceTrackerResourceRead(v5, 22, *(void *)(v9 + 8), a3);
      switch(*(_BYTE *)(v9 + 36))
      {
        case 1:
          uint64_t v10 = (uint64_t *)(v8 + 136 * v7);
          GTResourceTrackerResourceRead(v5, 22, v10[10], a3);
          GTResourceTrackerResourceRead(v5, 22, v10[5], a3);
          unsigned int v11 = v10 + 7;
          goto LABEL_25;
        case 2:
          unsigned int v11 = (uint64_t *)(v8 + 136 * v7 + 40);
          goto LABEL_25;
        case 3:
          unint64_t v12 = v8 + 136 * v7;
          uint64_t v13 = (uint64_t *)(v12 + 40);
          if (*(void *)(v12 + 88))
          {
            uint64_t v14 = 0LL;
            unint64_t v15 = 0LL;
            do
            {
              GTResourceTrackerResourceRead(v5, 22, *(void *)(v13[5] + v14), a3);
              ++v15;
              v14 += 16LL;
            }

            while (v13[6] > v15);
          }

          uint64_t v16 = *v13;
          unsigned int v11 = v13 + 2;
          GTResourceTrackerResourceRead(v5, 22, v16, a3);
          goto LABEL_25;
        case 4:
          unint64_t v17 = v8 + 136 * v7;
          if (*(void *)(v17 + 48))
          {
            uint64_t v18 = 0LL;
            unint64_t v19 = 0LL;
            uint64_t v20 = (void *)(v17 + 40);
            do
            {
              uint64_t result = GTResourceTrackerResourceRead(v5, 22, *(void *)(*v20 + v18), a3);
              ++v19;
              v18 += 16LL;
            }

            while (v20[1] > v19);
          }

          break;
        case 5:
          __int128 v21 = (uint64_t *)(v8 + 136 * v7);
          GTResourceTrackerResourceRead(v5, 22, v21[5], a3);
          GTResourceTrackerResourceRead(v5, 22, v21[11], a3);
          unsigned int v11 = v21 + 9;
          goto LABEL_25;
        case 6:
          unint64_t v22 = v8 + 136 * v7;
          uint64_t v23 = (void *)(v22 + 40);
          if (*(void *)(v22 + 48))
          {
            uint64_t v24 = 0LL;
            unint64_t v25 = 0LL;
            do
            {
              GTResourceTrackerResourceRead(v5, 22, *(void *)(*v23 + v24), a3);
              ++v25;
              v24 += 16LL;
            }

            while (v23[1] > v25);
          }

          if (v23[7])
          {
            uint64_t v26 = 0LL;
            unint64_t v27 = 0LL;
            do
            {
              GTResourceTrackerResourceRead(v5, 22, *(void *)(v23[6] + v26), a3);
              ++v27;
              v26 += 16LL;
            }

            while (v23[7] > v27);
          }

          unsigned int v11 = v23 + 4;
LABEL_25:
          uint64_t result = GTResourceTrackerResourceRead(v5, 22, *v11, a3);
          break;
        default:
          break;
      }

      ++v7;
    }

    while (a2[2] > v7);
  }

  return result;
}

void ResourceTracker_processUsedDrawables(uint64_t a1)
{
  uint64_t v2 = newpool;
  uint64_t v3 = apr_array_make(newpool, 16, 16);
  uint64_t v4 = apr_hash_make(v2);
  uint64_t v5 = *(void *)(a1 + 16);
  *(_DWORD *)(v5 + 40) = 0;
  *(void *)(v5 + 16) = v5;
  *(void *)(v5 + 24) = 0LL;
  *(void *)(v5 + 32) = 0LL;
  int v6 = apr_hash_next((apr_hash_index_t *)(v5 + 16));
  if (v6)
  {
    unint64_t v7 = v6;
    ht = v4;
    do
    {
      uint64_t v8 = *(_DWORD **)(*((void *)v7 + 1) + 32LL);
      int v9 = v8[2];
      if (v9 == 2)
      {
        uint64_t v13 = *(void *)(*find_entry(*(void *)a1, *(_BYTE **)(*((void *)v7 + 1) + 32LL), 8uLL, 0LL) + 32LL);
        __int128 v56 = 0u;
        uint64_t v57 = 0LL;
        *(void *)&__int128 v60 = 0LL;
        __int128 v59 = 0u;
        LODWORD(v56) = 2;
        uint64_t v58 = -1LL;
        uint64_t v14 = *(void *)(v13 + 32);
        if (v14)
        {
          unsigned int v15 = 0;
          while (1)
          {
            unsigned int v16 = atomic_load((unsigned int *)(v14 + 4));
            uint64_t v17 = v15 + (v16 >> 6) - 1;
            uint64_t v14 = *(void *)(v14 + 40);
            unsigned int v15 = v17;
            if (!v14)
            {
              unsigned int v15 = v17;
              goto LABEL_18;
            }
          }
        }

        else
        {
          unsigned int v15 = 0;
        }

        uint64_t v17 = 0LL;
LABEL_18:
        unint64_t v18 = v15 | (unint64_t)(v17 << 32);
LABEL_19:
        uint64_t v19 = v14 + 64;
        while (v14)
        {
          uint64_t v20 = v19 + ((uint64_t)(HIDWORD(v18) - (int)v18) << 6);
          GTMTLSMDrawable_processTraceFuncWithMap((char *)&v56, *(void *)(a1 + 8), (uint64_t *)v20);
          if (*(_DWORD *)(v20 + 8) == -7167) {
            break;
          }
          unsigned int v21 = atomic_load((unsigned int *)(v14 + 4));
          int v22 = v18 + (v21 >> 6);
          uint64_t v23 = (HIDWORD(v18) + 1);
          unint64_t v18 = (v23 << 32) | v18;
          if ((_DWORD)v23 == v22 - 1)
          {
            unint64_t v18 = (v23 << 32) | v23;
            uint64_t v14 = *(void *)(v14 + 40);
            goto LABEL_19;
          }
        }

        uint64_t v2 = newpool;
        uint64_t v24 = apr_palloc(newpool, 8uLL);
        void *v24 = v60;
        uint64_t v4 = ht;
        apr_hash_set(ht, v24, 8LL, v8);
      }

      else if (v9 == 80)
      {
        uint64_t v10 = *find_entry(*(void *)a1, *(_BYTE **)(*((void *)v7 + 1) + 32LL), 8uLL, 0LL);
        if (v10)
        {
          uint64_t v11 = *(void *)(v10 + 32);
          if (v11)
          {
            uint64_t v12 = *(void *)(v11 + 32);
            if (v12)
            {
              if ((*(_BYTE *)(v12 + 79) & 8) != 0)
              {
                __int128 v56 = 0u;
                uint64_t v57 = 0LL;
                __int128 v68 = 0u;
                __int128 v69 = 0u;
                __int128 v66 = 0u;
                __int128 v67 = 0u;
                __int128 v64 = 0u;
                __int128 v65 = 0u;
                __int128 v63 = 0u;
                __int128 v62 = 0u;
                __int128 v59 = 0u;
                __int128 v60 = 0u;
                LODWORD(v56) = 80;
                uint64_t v58 = -1LL;
                WORD1(v63) = 2;
                __int128 v61 = 0xFFFFFFFFFFFFFFFFLL;
                uint64_t v70 = 0xFFFFFFFFLL;
                GTMTLSMTexture_processTraceFuncWithMap((char *)&v56, *(void *)(a1 + 8), (uint64_t *)(v12 + 64));
                if ((void)v69 || *((void *)&v63 + 1) && *(_BYTE *)(*((void *)&v63 + 1) + 44LL)) {
                  *(_OWORD *)apr_array_push(v3) = *(_OWORD *)v8;
                }
              }
            }
          }
        }
      }

      unint64_t v7 = apr_hash_next(v7);
    }

    while (v7);
  }

  int nelts = v3->nelts;
  if (nelts >= 1)
  {
    int v26 = 0;
    do
    {
      entry = find_entry((uint64_t)v4, &v3->elts[16 * v26], 8uLL, 0LL);
      if (*entry && *(void *)(*entry + 32LL))
      {
        uint64_t v28 = v3->nelts - 1LL;
        v3->int nelts = v28;
        uint64_t elts = v3->elts;
        __int128 v30 = *(_OWORD *)&elts[16 * v26];
        *(_OWORD *)&elts[16 * v26] = *(_OWORD *)&elts[16 * v28];
        *(_OWORD *)&v3->elts[16 * v28] = v30;
      }

      else
      {
        ++v26;
      }

      int nelts = v3->nelts;
    }

    while (v26 < nelts);
  }

  if (nelts)
  {
    uint64_t v31 = *(void *)a1;
    __int128 v32 = (apr_hash_index_t *)(*(void *)a1 + 16LL);
    *(void *)(v31 + 24) = 0LL;
    *(void *)(v31 + 32) = 0LL;
    *(void *)(v31 + 16) = v31;
    *(_DWORD *)(v31 + 40) = 0;
    __int128 v33 = apr_hash_next(v32);
    if (v33)
    {
      __int128 v34 = v33;
      do
      {
        uint64_t v35 = *(void *)(*((void *)v34 + 1) + 32LL);
        if (v35)
        {
          uint64_t v36 = *(void *)(v35 + 32);
          if (v36)
          {
            if ((*(_BYTE *)(v36 + 79) & 8) != 0 && GetFuncEnumConstructorType(*(_DWORD *)(v36 + 72)) == 2)
            {
              __int128 v56 = 0u;
              uint64_t v57 = 0LL;
              *(void *)&__int128 v60 = 0LL;
              __int128 v59 = 0u;
              LODWORD(v56) = 2;
              uint64_t v58 = -1LL;
              GTMTLSMDrawable_processTraceFuncWithMap((char *)&v56, *(void *)(a1 + 8), (uint64_t *)(v36 + 64));
              uint64_t v37 = *(void *)(v35 + 32);
              if (v37)
              {
                unsigned int v38 = 0;
                while (1)
                {
                  unsigned int v39 = atomic_load((unsigned int *)(v37 + 4));
                  uint64_t v40 = v38 + (v39 >> 6) - 1;
                  uint64_t v37 = *(void *)(v37 + 40);
                  unsigned int v38 = v40;
                  if (!v37)
                  {
                    unsigned int v38 = v40;
                    goto LABEL_52;
                  }
                }

                uint64_t v40 = 1LL;
              }

              else
              {
                unsigned int v38 = 0;
                uint64_t v40 = 0LL;
              }

LABEL_52:
              unint64_t v41 = v38 | (unint64_t)(v40 << 32);
LABEL_53:
              uint64_t v42 = v37 + 64;
              while (v37)
              {
                uint64_t v43 = v42 + ((uint64_t)(HIDWORD(v41) - (int)v41) << 6);
                GTMTLSMDrawable_processTraceFuncWithMap((char *)&v56, *(void *)(a1 + 8), (uint64_t *)v43);
                if (*(_DWORD *)(v43 + 8) == -7167) {
                  break;
                }
                unsigned int v44 = atomic_load((unsigned int *)(v37 + 4));
                int v45 = v41 + (v44 >> 6);
                uint64_t v46 = (HIDWORD(v41) + 1);
                unint64_t v41 = (v46 << 32) | v41;
                if ((_DWORD)v46 == v45 - 1)
                {
                  unint64_t v41 = (v46 << 32) | v46;
                  uint64_t v37 = *(void *)(v37 + 40);
                  goto LABEL_53;
                }
              }

              int v47 = v3->nelts;
              if (v47 >= 1)
              {
                int v48 = 0;
                uint64_t v49 = v60;
                uint64_t v50 = *((void *)&v56 + 1);
                do
                {
                  if (*(void *)&v3->elts[16 * v48] == v49)
                  {
                    GTResourceTrackerUsingResource(*(void *)(a1 + 16), 2, v50, *(void *)a1, *(void *)(a1 + 8));
                    uint64_t v51 = v3->nelts - 1LL;
                    v3->int nelts = v51;
                    uint64_t v52 = v3->elts;
                    __int128 v53 = *(_OWORD *)&v52[16 * v48];
                    *(_OWORD *)&v52[16 * v48] = *(_OWORD *)&v52[16 * v51];
                    *(_OWORD *)&v3->elts[16 * v51] = v53;
                    int v47 = v3->nelts;
                  }

                  else
                  {
                    ++v48;
                  }
                }

                while (v48 < v47);
              }
            }
          }
        }

        __int128 v34 = apr_hash_next(v34);
      }

      while (v34);
      uint64_t v2 = newpool;
    }
  }

  apr_pool_destroy(v2);
}

LABEL_53:
        uint64_t v11 = (char *)v11 + 1;
      }

      while (v11 != v7);
      unint64_t v7 = [v5 countByEnumeratingWithState:&v81 objects:v89 count:16];
      if (!v7)
      {
LABEL_55:

        return v61;
      }
    }
  }

  uint64_t v57 = objc_opt_class(&OBJC_CLASS___MTLInstanceAccelerationStructureDescriptor, v4);
  if ((objc_opt_isKindOfClass(v1, v57) & 1) != 0)
  {
    __int128 v59 = v1;
    [v59 setInstanceDescriptorBuffer:0];
    [v59 setInstanceDescriptorBufferOffset:0];
    [v59 setMotionTransformBuffer:0];
    [v59 setMotionTransformBufferOffset:0];
LABEL_60:

    return v1;
  }

  __int128 v60 = objc_opt_class(&OBJC_CLASS___MTLIndirectInstanceAccelerationStructureDescriptor, v58);
  if ((objc_opt_isKindOfClass(v1, v60) & 1) != 0)
  {
    __int128 v59 = v1;
    [v59 setInstanceDescriptorBuffer:0];
    [v59 setInstanceDescriptorBufferOffset:0];
    [v59 setMotionTransformBuffer:0];
    [v59 setMotionTransformBufferOffset:0];
    [v59 setMotionTransformCountBuffer:0];
    [v59 setMotionTransformCountBufferOffset:0];
    [v59 setInstanceCountBuffer:0];
    [v59 setInstanceCountBufferOffset:0];
    goto LABEL_60;
  }

  return v1;
}

    GTMTLSMAccelerationStructure_processTraceFuncWithMap((char *)&v60, *(void *)(a1 + 40), (uint64_t *)v16);
  }

  if (v25 != -15659) {
    goto LABEL_52;
  }
  uint64_t v49 = *(void *)v16;
  if (*(void *)(a1 + 8) <= *(void *)v16)
  {
    unsigned int v38 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xD0uLL);
    *unsigned int v38 = v60;
    uint64_t v50 = v64;
    uint64_t v52 = v61;
    uint64_t v51 = v62;
    v38[3] = v63;
    v38[4] = v50;
    v38[1] = v52;
    v38[2] = v51;
    __int128 v53 = v68;
    unsigned int v55 = v65;
    uint64_t v54 = v66;
    v38[7] = v67;
    v38[8] = v53;
    v38[5] = v55;
    v38[6] = v54;
    __int128 v56 = v72;
    uint64_t v58 = v69;
    uint64_t v57 = v70;
    v38[11] = v71;
    v38[12] = v56;
    v38[9] = v58;
    v38[10] = v57;
    __int128 v59 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v38 + 8, 8uLL, 0LL);
    if (v59) {
      __int128 v59 = *(void *)(v59 + 32);
    }
    *((void *)v38 + 4) = v59;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v38 + 8, 8LL, v38);
LABEL_56:
    *((void *)v38 + 3) = v49;
  }

      if (++v10 >= *(int *)(a3 + 12))
      {
        uint64_t v8 = newpool;
        break;
      }
    }
  }

  apr_pool_destroy(v8);
  return v9;
}

apr_array_header_t *ResourceTracker_harvestResources(uint64_t *a1, apr_pool_t *a2)
{
  uint64_t v4 = a1[4];
  uint64_t v5 = apr_array_make(a2, *(_DWORD *)(v4 + 48), 56);
  *(void *)(v4 + 24) = 0LL;
  *(void *)(v4 + 32) = 0LL;
  *(void *)(v4 + 16) = v4;
  *(_DWORD *)(v4 + 40) = 0;
  int v6 = apr_hash_next((apr_hash_index_t *)(v4 + 16));
  if (v6)
  {
    unint64_t v7 = v6;
    do
    {
      uint64_t v8 = *(__int128 **)(*((void *)v7 + 1) + 32LL);
      __int128 v14 = v8[1];
      __int128 v15 = *v8;
      uint64_t v9 = *((void *)v8 + 4);
      char v10 = *((_BYTE *)v8 + 48);
      uint64_t v11 = *((void *)v8 + 5);
      uint64_t v12 = (char *)apr_array_push(v5);
      *(_OWORD *)uint64_t v12 = v15;
      *((_OWORD *)v12 + 1) = v14;
      *((void *)v12 + 4) = v9;
      *((void *)v12 + 5) = v11;
      v12[48] = v10;
      *(_DWORD *)(v12 + 49) = 0;
      *((_DWORD *)v12 + 13) = 0;
      unint64_t v7 = apr_hash_next(v7);
    }

    while (v7);
  }

  return v5;
}

uint64_t GTResourceTracker_resources(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

BOOL GTResourceTrackerResourceIsGPUOnly(uint64_t a1)
{
  return *(void *)(a1 + 24) == 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t ResourceTracker_addIndirectResources(uint64_t *a1, _DWORD **a2, unint64_t a3, apr_pool_t *p)
{
  unint64_t v7 = apr_array_make(p, 128, 8);
  v7->int nelts = 0;
  GTMTLSMContext_getObjects(a2[3], a3, v7);
  int nelts = v7->nelts;
  if (nelts >= 1)
  {
    for (uint64_t i = 0LL; i < nelts; ++i)
    {
      uint64_t v10 = *(void *)&v7->elts[8 * i];
      if (*(_BYTE *)(*(void *)(v10 + 48) + 62LL))
      {
        GTResourceTrackerUsingResource(a1[2], 75, *(void *)(v10 + 8), *a1, a1[1]);
        int nelts = v7->nelts;
      }
    }
  }

  v7->int nelts = 0;
  GTMTLSMContext_getObjects(a2[4], a3, v7);
  int v11 = v7->nelts;
  if (v11 >= 1)
  {
    for (uint64_t j = 0LL; j < v11; ++j)
    {
      uint64_t v13 = *(void *)&v7->elts[8 * j];
      if (GTMTLSMPipelineState_supportsIndirectCommandBuffers(v13))
      {
        GTResourceTrackerUsingResource(a1[2], 71, *(void *)(v13 + 8), *a1, a1[1]);
        int v11 = v7->nelts;
      }
    }
  }

  v7->int nelts = 0;
  uint64_t result = (uint64_t)GTMTLSMContext_getObjects(a2[5], a3, v7);
  int v15 = v7->nelts;
  if (v15 >= 1)
  {
    for (uint64_t k = 0LL; k < v15; ++k)
    {
      uint64_t v17 = *(void *)&v7->elts[8 * k];
      uint64_t v18 = *(void *)(v17 + 56);
      if (v18)
      {
        if (*(_BYTE *)(v18 + 956))
        {
          uint64_t result = GTResourceTrackerUsingResource(a1[2], 29, *(void *)(v17 + 8), *a1, a1[1]);
          int v15 = v7->nelts;
        }
      }
    }
  }

  return result;
}

void *ResourceTracker_addAccelerationStructures(uint64_t *a1, uint64_t a2, unint64_t a3, apr_pool_t *p)
{
  unint64_t v7 = apr_array_make(p, 128, 8);
  uint64_t result = GTMTLSMContext_getObjects(*(_DWORD **)(a2 + 72), a3, v7);
  int nelts = v7->nelts;
  if (nelts >= 1)
  {
    for (uint64_t i = 0LL; i < nelts; ++i)
    {
      int v11 = *(uint64_t **)(*(void *)&v7->elts[8 * i] + 112LL);
      if (v11)
      {
        uint64_t result = GTResourceTrackerUsingAccelerationStructureDescriptor(a1, v11, a3);
        int nelts = v7->nelts;
      }
    }
  }

  return result;
}

apr_hash_index_t *ResourceTracker_addChainedResources( uint64_t *a1, uint64_t *a2, unint64_t a3, apr_pool_t *pool)
{
  uint64_t v8 = apr_hash_make(pool);
  uint64_t v9 = a1[2];
  *(_DWORD *)(v9 + 40) = 0;
  *(void *)(v9 + 16) = v9;
  *(void *)(v9 + 24) = 0LL;
  *(void *)(v9 + 32) = 0LL;
  uint64_t v10 = apr_hash_next((apr_hash_index_t *)(v9 + 16));
  if (v10)
  {
    int v11 = v10;
    do
    {
      Object = GTMTLSMContext_getObject(a2, **(void **)(*((void *)v11 + 1) + 32LL), a3);
      if (Object)
      {
        BOOL v13 = (*(_DWORD *)Object - 22) > 0x3A
           || ((1LL << (*(_DWORD *)Object - 22)) & 0x400000010000001LL) == 0;
        if (!v13 || *(_DWORD *)Object == 16)
        {
          RootResource = GTMTLSMContext_getRootResource(a2, Object, a3);
          apr_hash_set(v8, RootResource + 1, 8LL, RootResource);
        }
      }

      int v11 = apr_hash_next(v11);
    }

    while (v11);
  }

  unsigned int v16 = (apr_pool_t **)apr_hash_make(pool);
  GTMTLSMContext_buildResourceChildrenMap(a2, a3, v16);
  *((void *)v8 + 3) = 0LL;
  *((void *)v8 + 4) = 0LL;
  *((void *)v8 + 2) = v8;
  *((_DWORD *)v8 + 10) = 0;
  uint64_t result = apr_hash_next((apr_hash_t *)((char *)v8 + 16));
  if (result)
  {
    uint64_t v18 = result;
    do
    {
      AddChainedResourcesRecursive(a1, *(void *)(*((void *)v18 + 1) + 32LL), (uint64_t)v16);
      uint64_t result = apr_hash_next(v18);
      uint64_t v18 = result;
    }

    while (result);
  }

  return result;
}

void *AddChainedResourcesRecursive(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = find_entry(a3, (_BYTE *)(a2 + 8), 8uLL, 0LL);
  if (*result)
  {
    uint64_t v7 = *(void *)(*result + 32LL);
    if (v7)
    {
      if (*(int *)(v7 + 12) >= 1)
      {
        uint64_t v8 = 0LL;
        do
          uint64_t result = (void *)AddChainedResourcesRecursive(a1, *(void *)(*(void *)(v7 + 24) + 8 * v8++), a3);
        while (v8 < *(int *)(v7 + 12));
      }
    }
  }

  return result;
}

uint64_t ResourceTracker_addResourceGroups(uint64_t *a1, uint64_t a2, unint64_t a3, apr_pool_t *p)
{
  uint64_t v7 = apr_array_make(p, 128, 8);
  uint64_t result = (uint64_t)GTMTLSMContext_getObjects(*(_DWORD **)(a2 + 208), a3, v7);
  if (v7->nelts >= 1)
  {
    uint64_t v9 = 0LL;
    do
    {
      uint64_t v10 = *(void *)&v7->elts[8 * v9];
      uint64_t result = GTResourceTrackerUsingResource(a1[2], 73, *(void *)(v10 + 8), *a1, a1[1]);
      if (*(_DWORD *)(v10 + 56))
      {
        unint64_t v11 = 0LL;
        do
        {
          uint64_t v12 = a1[2];
          int ResourceType = GTResourceTrackerGetResourceType(*(void *)(*(void *)(v10 + 48) + 8 * v11), *a1);
          uint64_t result = GTResourceTrackerUsingResource( v12,  ResourceType,  *(void *)(*(void *)(v10 + 48) + 8 * v11++),  *a1,  a1[1]);
        }

        while (v11 < *(unsigned int *)(v10 + 56));
      }

      ++v9;
    }

    while (v9 < v7->nelts);
  }

  return result;
}

uint64_t ResourceTracker_addFunctionHandles(uint64_t *a1, uint64_t a2, unint64_t a3, apr_pool_t *p)
{
  uint64_t v7 = apr_array_make(p, 128, 8);
  uint64_t result = (uint64_t)GTMTLSMContext_getObjects(*(_DWORD **)(a2 + 256), a3, v7);
  if (v7->nelts >= 1)
  {
    uint64_t v9 = 0LL;
    while (1)
    {
      uint64_t v10 = *(void **)&v7->elts[8 * v9];
      uint64_t v11 = v10 ? v10[1] : 0LL;
      GTResourceTrackerUsingResource(a1[2], 44, v11, *a1, a1[1]);
      uint64_t result = GTMTLSMContext_lastObject((uint64_t *)a2, v10[5], a3);
      if (result)
      {
        uint64_t v12 = result;
        GTResourceTrackerUsingResource(a1[2], 43, *(void *)(result + 8), *a1, a1[1]);
        uint64_t result = ResourceTracker_addFunctionParent((uint64_t)a1, (uint64_t *)a2, v12, a3);
      }

      uint64_t v13 = v10[7];
      if (v13) {
        break;
      }
      uint64_t v13 = v10[6];
      if (v13)
      {
        uint64_t v15 = a1[1];
        uint64_t v14 = a1[2];
        uint64_t v16 = *a1;
        int v17 = 29;
        goto LABEL_12;
      }

uint64_t ResourceTracker_addFunctionParent(uint64_t result, uint64_t *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = (uint64_t *)result;
  if (!*(_BYTE *)(a3 + 132))
  {
    uint64_t v6 = *(void *)(a3 + 40);
    return ResourceTracker_addLibrary(v4, v6);
  }

  if (*(void *)(a3 + 104))
  {
    uint64_t result = GTMTLSMContext_lastObject(a2, *(void *)(a3 + 40), a4);
    if (result)
    {
      uint64_t v5 = result;
      uint64_t result = GTResourceTrackerUsingResource(v4[2], 43, *(void *)(result + 8), *v4, v4[1]);
      uint64_t v6 = *(void *)(v5 + 40);
      if (v6) {
        return ResourceTracker_addLibrary(v4, v6);
      }
    }
  }

  return result;
}

uint64_t ResourceTracker_addLibrary(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  *(void *)&__int128 v40 = a2;
  entry = find_entry(v4, &v40, 8uLL, 0LL);
  if (*entry)
  {
    uint64_t v6 = *(void *)(*entry + 32LL);
    __int128 v40 = 0u;
    uint64_t v41 = 0LL;
    uint64_t v51 = 0LL;
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    __int128 v43 = 0u;
    __int128 v44 = 0u;
    LODWORD(v40) = 62;
    uint64_t v42 = -1LL;
    uint64_t v8 = a1 + 1;
    uint64_t v7 = a1[1];
    if (v6 && (uint64_t v9 = *(void *)(v6 + 32)) != 0 && (*(_BYTE *)(v9 + 79) & 8) != 0) {
      uint64_t v10 = (uint64_t *)(v9 + 64);
    }
    else {
      uint64_t v10 = 0LL;
    }
  }

  else
  {
    uint64_t v10 = 0LL;
    __int128 v40 = 0u;
    uint64_t v41 = 0LL;
    uint64_t v51 = 0LL;
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    __int128 v43 = 0u;
    __int128 v44 = 0u;
    LODWORD(v40) = 62;
    uint64_t v42 = -1LL;
    uint64_t v8 = a1 + 1;
    uint64_t v7 = a1[1];
  }

  GTMTLSMLibrary_processTraceFuncWithMap((uint64_t)&v40, v7, v10);
  if (DWORD2(v50))
  {
    unint64_t v11 = 0LL;
    do
    {
      uint64_t v12 = *(void *)(v44 + 8 * v11);
      uint64_t v13 = *a1;
      *(void *)&__int128 v30 = v12;
      uint64_t v14 = *find_entry(v13, &v30, 8uLL, 0LL);
      if (v14)
      {
        uint64_t v15 = *(void *)(v14 + 32);
        __int128 v30 = 0u;
        uint64_t v31 = 0LL;
        uint64_t v39 = 0LL;
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        __int128 v35 = 0u;
        __int128 v36 = 0u;
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        LODWORD(v30) = 43;
        uint64_t v32 = -1LL;
        uint64_t v16 = *v8;
        if (v15 && (uint64_t v17 = *(void *)(v15 + 32)) != 0 && (*(_BYTE *)(v17 + 79) & 8) != 0) {
          uint64_t v18 = (uint64_t *)(v17 + 64);
        }
        else {
          uint64_t v18 = 0LL;
        }
      }

      else
      {
        uint64_t v18 = 0LL;
        __int128 v30 = 0u;
        uint64_t v31 = 0LL;
        uint64_t v39 = 0LL;
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        __int128 v35 = 0u;
        __int128 v36 = 0u;
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        LODWORD(v30) = 43;
        uint64_t v32 = -1LL;
        uint64_t v16 = *v8;
      }

      GTMTLSMFunction_processTraceFuncWithMap((uint64_t)&v30, v16, v18);
      GTResourceTrackerUsingResource(a1[2], 43, v12, *a1, a1[1]);
      GTResourceTrackerUsingResource(a1[2], 62, *((uint64_t *)&v33 + 1), *a1, a1[1]);
      ++v11;
    }

    while (v11 < DWORD2(v50));
  }

  if (HIDWORD(v50))
  {
    unint64_t v19 = 0LL;
    do
    {
      uint64_t v20 = *(void *)(*((void *)&v46 + 1) + 8 * v19);
      uint64_t v21 = *a1;
      *(void *)&__int128 v30 = v20;
      uint64_t v22 = *find_entry(v21, &v30, 8uLL, 0LL);
      if (v22)
      {
        uint64_t v23 = *(void *)(v22 + 32);
        __int128 v30 = 0u;
        uint64_t v31 = 0LL;
        uint64_t v39 = 0LL;
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        __int128 v35 = 0u;
        __int128 v36 = 0u;
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        LODWORD(v30) = 43;
        uint64_t v32 = -1LL;
        uint64_t v24 = *v8;
        if (v23 && (uint64_t v25 = *(void *)(v23 + 32)) != 0 && (*(_BYTE *)(v25 + 79) & 8) != 0) {
          int v26 = (uint64_t *)(v25 + 64);
        }
        else {
          int v26 = 0LL;
        }
      }

      else
      {
        int v26 = 0LL;
        __int128 v30 = 0u;
        uint64_t v31 = 0LL;
        uint64_t v39 = 0LL;
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        __int128 v35 = 0u;
        __int128 v36 = 0u;
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        LODWORD(v30) = 43;
        uint64_t v32 = -1LL;
        uint64_t v24 = *v8;
      }

      GTMTLSMFunction_processTraceFuncWithMap((uint64_t)&v30, v24, v26);
      GTResourceTrackerUsingResource(a1[2], 43, v20, *a1, a1[1]);
      GTResourceTrackerUsingResource(a1[2], 62, *((uint64_t *)&v33 + 1), *a1, a1[1]);
      ++v19;
    }

    while (v19 < HIDWORD(v50));
  }

  if (*((void *)&v47 + 1) && (int)*(void *)(*((void *)&v47 + 1) + 40LL) >= 1)
  {
    uint64_t v27 = 0LL;
    uint64_t v28 = 8LL * *(void *)(*((void *)&v47 + 1) + 40LL);
    do
    {
      ResourceTracker_addDynamicLibrary(a1, *(void *)(*(void *)(*((void *)&v47 + 1) + 32LL) + v27));
      v27 += 8LL;
    }

    while (v28 != v27);
  }

  return GTResourceTrackerUsingResource(a1[2], 62, a2, *a1, a1[1]);
}

uint64_t ResourceTracker_addDynamicLibrary(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  *(void *)&__int128 v11 = a2;
  entry = find_entry(v4, &v11, 8uLL, 0LL);
  if (*entry)
  {
    uint64_t v6 = *(void *)(*entry + 32LL);
    __int128 v11 = 0u;
    uint64_t v12 = 0LL;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v14 = 0u;
    LODWORD(v11) = 37;
    uint64_t v13 = -1LL;
    uint64_t v7 = a1[1];
    if (v6 && (uint64_t v8 = *(void *)(v6 + 32)) != 0 && (*(_BYTE *)(v8 + 79) & 8) != 0) {
      uint64_t v9 = (uint64_t *)(v8 + 64);
    }
    else {
      uint64_t v9 = 0LL;
    }
  }

  else
  {
    uint64_t v9 = 0LL;
    __int128 v11 = 0u;
    uint64_t v12 = 0LL;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v14 = 0u;
    LODWORD(v11) = 37;
    uint64_t v13 = -1LL;
    uint64_t v7 = a1[1];
  }

  GTMTLSMDynamicLibrary_processTraceFuncWithMap((char *)&v11, v7, v9);
  GTResourceTrackerUsingResource(a1[2], 37, a2, *a1, a1[1]);
  if ((void)v15) {
    ResourceTracker_addLibrary(a1);
  }
  return GTResourceTrackerUsingResource(a1[2], 37, a2, *a1, a1[1]);
}

uint64_t ResourceTracker_addLibraries(uint64_t *a1, uint64_t a2, unint64_t a3, apr_pool_t *p)
{
  uint64_t v8 = apr_array_make(p, 128, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(a2 + 32), a3, v8);
  if (v8->nelts >= 1)
  {
    uint64_t v9 = 0LL;
    while (1)
    {
      uint64_t v10 = *(void **)&v8->elts[8 * v9];
      uint64_t v11 = v10 ? v10[1] : 0LL;
      v71[0] = v11;
      entry = find_entry(a1[2], v71, 8uLL, 0LL);
      if (*entry)
      {
        if (*(void *)(*entry + 32LL)) {
          break;
        }
      }

LABEL_39:
      if (++v9 >= v8->nelts) {
        goto LABEL_40;
      }
    }

    if (v10[11]) {
      GTResourceTrackerUsingResource(a1[2], 67, v10[5], *a1, a1[1]);
    }
    int v13 = GTMTLSMRenderPipelineState_renderPipelineDescriptorType((uint64_t *)a2, v10);
    switch(v13)
    {
      case 3:
        uint64_t v32 = (const void *)v10[9];
        if (v32) {
          memcpy(__dst, v32, 0x200uLL);
        }
        ResourceTracker_addFunction(a1, (uint64_t *)a2, (uint64_t)__dst[46], a3);
        ResourceTracker_addFunction(a1, (uint64_t *)a2, (uint64_t)__dst[45], a3);
        ResourceTracker_addFunction(a1, (uint64_t *)a2, (uint64_t)__dst[43], a3);
        ResourceTracker_addLinkedFunctions((uint64_t)a1, (uint64_t *)a2, &__dst[32], a3);
        ResourceTracker_addLinkedFunctions((uint64_t)a1, (uint64_t *)a2, &__dst[24], a3);
        uint64_t v26 = (uint64_t)a1;
        uint64_t v27 = (uint64_t *)a2;
        uint64_t v28 = &__dst[16];
        break;
      case 2:
        GTMTLSMRenderPipelineState_tilePipelineDescriptor((uint64_t *)a2, v10, __dst, p);
        ResourceTracker_addFunction(a1, (uint64_t *)a2, (uint64_t)__dst[15], a3);
        uint64_t v29 = LOWORD(__dst[14]);
        if (LOWORD(__dst[14]))
        {
          __int128 v30 = __dst[13];
          do
          {
            uint64_t v31 = *v30++;
            ResourceTracker_addDynamicLibrary(a1, v31);
            --v29;
          }

          while (v29);
        }

        uint64_t v28 = __dst;
        uint64_t v26 = (uint64_t)a1;
        uint64_t v27 = (uint64_t *)a2;
        break;
      case 1:
        GTMTLSMRenderPipelineState_renderPipelineDescriptor((uint64_t *)a2, v10, (uint64_t)__dst, p);
        ResourceTracker_addFunction(a1, (uint64_t *)a2, v68, a3);
        ResourceTracker_addFunction(a1, (uint64_t *)a2, v59[14], a3);
        ResourceTracker_addFunction(a1, (uint64_t *)a2, v64, a3);
        ResourceTracker_addFunction(a1, (uint64_t *)a2, v61, a3);
        uint64_t v14 = v70;
        if (v70)
        {
          __int128 v15 = v69;
          do
          {
            uint64_t v16 = *v15++;
            ResourceTracker_addDynamicLibrary(a1, v16);
            --v14;
          }

          while (v14);
        }

        uint64_t v17 = v60;
        if (v60)
        {
          __int128 v18 = (uint64_t *)v59[15];
          do
          {
            uint64_t v19 = *v18++;
            ResourceTracker_addDynamicLibrary(a1, v19);
            --v17;
          }

          while (v17);
        }

        uint64_t v20 = v66;
        if (v66)
        {
          uint64_t v21 = v65;
          do
          {
            uint64_t v22 = *v21++;
            ResourceTracker_addDynamicLibrary(a1, v22);
            --v20;
          }

          while (v20);
        }

        uint64_t v23 = v63;
        if (v63)
        {
          uint64_t v24 = v62;
          do
          {
            uint64_t v25 = *v24++;
            ResourceTracker_addDynamicLibrary(a1, v25);
            --v23;
          }

          while (v23);
        }

        GTResourceTrackerUsingResource(a1[2], 67, v67, *a1, a1[1]);
        ResourceTracker_addLinkedFunctions((uint64_t)a1, (uint64_t *)a2, v59, a3);
        ResourceTracker_addLinkedFunctions((uint64_t)a1, (uint64_t *)a2, v55, a3);
        ResourceTracker_addLinkedFunctions((uint64_t)a1, (uint64_t *)a2, v58, a3);
        uint64_t v26 = (uint64_t)a1;
        uint64_t v27 = (uint64_t *)a2;
        uint64_t v28 = (uint64_t **)&v57;
        break;
      default:
LABEL_34:
        if (v10[10])
        {
          Object = GTMTLSMContext_getObject((uint64_t *)a2, v10[5], v10[2]);
          if (Object)
          {
            __int128 v34 = Object;
            do
            {
              if (*(_DWORD *)v34 != 71) {
                break;
              }
              GTResourceTrackerUsingResource(a1[2], 71, v34[1], *a1, a1[1]);
              __int128 v34 = GTMTLSMContext_getObject((uint64_t *)a2, v34[5], v34[2]);
            }

            while (v34);
          }
        }

        goto LABEL_39;
    }

    ResourceTracker_addLinkedFunctions(v26, v27, v28, a3);
    goto LABEL_34;
  }

        goto LABEL_41;
      }

      if (v16 == 4)
      {
        uint64_t v21 = objc_opt_class(&OBJC_CLASS___MTLCaptureScope, v18);
        if ((objc_opt_isKindOfClass(v19, v21) & 1) == 0)
        {
          uint64_t v22 = @"an MTLCaptureScope";
LABEL_59:
          *(void *)&uint64_t v114 = @"Wrong capture object type.";
          __int128 v122 = NSLocalizedDescriptionKey;
          __int128 v123 = NSLocalizedFailureReasonErrorKey;
          __int128 v46 = v22;
          uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Selected capture mode requires the capture object to be %@",  v46));
          *((void *)&v114 + 1) = v47;
          __int128 v124 = NSLocalizedRecoverySuggestionErrorKey;
          uint64_t v48 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Specify %@ object to be captured.",  v46));

          uint64_t v115 = v48;
          __int128 v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v114,  &v122,  3LL));

          ReportError(a4, (uint64_t)MTLCaptureErrorDomain, 3LL, (uint64_t)v49);
          goto LABEL_60;
        }

        goto LABEL_39;
      }

      if ((v16 & 0xFFFFFFFFFFFFFFFDLL) != 0)
      {
LABEL_41:
        __int128 v33 = v6;
        if ((objc_opt_respondsToSelector(v33, "triggerHitsToStart") & 1) != 0)
        {
          if ((objc_opt_respondsToSelector(v33, "triggerHitsToEnd") & 1) != 0)
          {

            __int128 v102 = [v33 triggerHitsToStart];
            *((void *)&v109 + 1) = v102;
            uint64_t v23 = [v33 triggerHitsToEnd];
            *(void *)&id v110 = v23;
            goto LABEL_27;
          }

          __int128 v37 = @"triggerHitsToEnd";
        }

        else
        {
          __int128 v37 = @"triggerHitsToStart";
        }

        __int128 v122 = NSLocalizedDescriptionKey;
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ property is not present in the descriptor.",  v37));
        *(void *)&uint64_t v114 = v52;
        __int128 v123 = NSLocalizedFailureReasonErrorKey;
        __int128 v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Selected capture mode requires the %@ property.",  v37));
        __int128 v124 = NSLocalizedRecoverySuggestionErrorKey;
        *((void *)&v114 + 1) = v53;
        uint64_t v115 = @"Ensure that your capture descriptor implements the MTLCaptureManager(InternalSPI) category.";
        uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v114,  &v122,  3LL));

        ReportError(a4, (uint64_t)MTLCaptureErrorDomain, 3LL, (uint64_t)v54);
        goto LABEL_61;
      }
    }

    else
    {
      uint64_t v20 = v15;
      uint64_t v19 = v20;
      if (!v20)
      {
LABEL_10:
        FillMissingCaptureObjectError(a4);
LABEL_60:

LABEL_61:
        uint64_t v50 = 0LL;
        int v13 = 0;
LABEL_128:

        goto LABEL_6;
      }

      if ([v20 conformsToProtocol:&OBJC_PROTOCOL___MTLDevice])
      {
        uint64_t v16 = 0LL;
      }

      else
      {
        if (([v19 conformsToProtocol:&OBJC_PROTOCOL___MTLCommandQueue] & 1) == 0)
        {
          if (([v19 conformsToProtocol:&OBJC_PROTOCOL___MTLCaptureScope] & 1) == 0)
          {
            __int128 v122 = NSLocalizedDescriptionKey;
            __int128 v34 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"‘%@’ cannot be captured.",  objc_opt_class(v19, v27));
            __int128 v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
            __int128 v123 = NSLocalizedRecoverySuggestionErrorKey;
            *(void *)&uint64_t v114 = v35;
            *((void *)&v114 + 1) = @"Specify an object to be captured like MTLDevice.";
            uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v114,  &v122,  2LL));

            ReportError(a4, (uint64_t)MTLCaptureErrorDomain, 3LL, (uint64_t)v36);
            goto LABEL_60;
          }

          if ((objc_opt_respondsToSelector(v6, "triggerHitsToStart") & 1) != 0) {
            uint64_t v28 = [v6 triggerHitsToStart];
          }
          else {
            uint64_t v28 = &dword_0 + 1;
          }
          __int128 v102 = v28;
          *((void *)&v109 + 1) = v28;
          if ((objc_opt_respondsToSelector(v6, "triggerHitsToEnd") & 1) != 0) {
            uint64_t v23 = [v6 triggerHitsToEnd];
          }
          else {
            uint64_t v23 = &dword_0 + 1;
          }
          *(void *)&id v110 = v23;
          uint64_t v16 = 4LL;
          if (v23)
          {
LABEL_29:
            __int16 v101 = v23;
            __int128 v103 = 0LL;
            switch(v16)
            {
              case 0uLL:
              case 1uLL:
                uint64_t v24 = v15;
                uint64_t v25 = (uint64_t *)[v24 traceStream];
                if (v25) {
                  uint64_t v26 = *v25;
                }
                else {
                  uint64_t v26 = 0LL;
                }
                *(void *)&id v107 = v26;
                uint64_t v42 = (uint64_t *)[v24 traceStream];
                goto LABEL_84;
              case 2uLL:
              case 3uLL:
                uint64_t v29 = v15;
                __int128 v30 = (uint64_t *)[v29 traceStream];
                if (v30) {
                  uint64_t v31 = *v30;
                }
                else {
                  uint64_t v31 = 0LL;
                }
                *((void *)&v107 + 1) = v31;
                uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v29 device]);
                uint64_t v44 = (uint64_t *)[v43 traceStream];
                if (v44) {
                  uint64_t v45 = *v44;
                }
                else {
                  uint64_t v45 = 0LL;
                }
                goto LABEL_57;
              case 4uLL:
                uint64_t v38 = v15;
                uint64_t v39 = (uint64_t *)[v38 traceStream];
                if (v39) {
                  unsigned int v40 = *v39;
                }
                else {
                  unsigned int v40 = 0LL;
                }
                *(void *)&__int128 v108 = v40;
                unsigned __int16 v56 = (void *)objc_claimAutoreleasedReturnValue([v38 device]);
                uint64_t v57 = (uint64_t *)[v56 traceStream];
                if (v57) {
                  uint64_t v58 = *v57;
                }
                else {
                  uint64_t v58 = 0LL;
                }
                *(void *)&id v107 = v58;

                __int128 v59 = (void *)objc_claimAutoreleasedReturnValue([v38 commandQueue]);
                if (v59)
                {
                  unsigned __int16 v60 = (void *)objc_claimAutoreleasedReturnValue([v38 commandQueue]);
                  uint64_t v61 = (uint64_t *)[v60 traceStream];
                  if (v61) {
                    __int128 v62 = *v61;
                  }
                  else {
                    __int128 v62 = 0LL;
                  }
                  *((void *)&v107 + 1) = v62;
                }

                uint64_t v42 = (uint64_t *)[v38 traceStream];
                goto LABEL_84;
              case 6uLL:
                uint64_t v29 = v15;
                if ((objc_opt_respondsToSelector(v29, "streamReference") & 1) != 0) {
                  uint64_t v41 = [v29 streamReference];
                }
                else {
                  uint64_t v41 = 0LL;
                }
                *((void *)&v108 + 1) = v41;
                uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v29 device]);
                unsigned int v55 = (uint64_t *)[v43 traceStream];
                if (v55) {
                  uint64_t v45 = *v55;
                }
                else {
                  uint64_t v45 = 0LL;
                }
LABEL_57:
                *(void *)&id v107 = v45;

                uint64_t v42 = (uint64_t *)[v29 traceStream];
LABEL_84:
                if (v42) {
                  __int128 v103 = *v42;
                }
                else {
                  __int128 v103 = 0LL;
                }

                break;
              default:
                break;
            }

            LODWORD(v112) = v16;
            if ((objc_opt_respondsToSelector(v6, "sessionID") & 1) != 0) {
              unsigned __int16 v63 = [v6 sessionID];
            }
            else {
              unsigned __int16 v63 = 0LL;
            }
            *(void *)&__int128 v109 = v63;
            if ((objc_opt_respondsToSelector(v6, "apiTriggeredCapture") & 1) != 0) {
              uint64_t v64 = [v6 apiTriggeredCapture];
            }
            else {
              uint64_t v64 = 1;
            }
            BYTE9(v112) = v64;
            BYTE10(v112) = self->_traceStream;
            if ((objc_opt_respondsToSelector(v6, "includeBacktrace") & 1) != 0) {
              __int128 v65 = [v6 includeBacktrace];
            }
            else {
              __int128 v65 = 1;
            }
            BYTE12(v112) = v65;
            if ((objc_opt_respondsToSelector(v6, "ignoreUnusedResources") & 1) != 0) {
              unsigned __int16 v66 = [v6 ignoreUnusedResources];
            }
            else {
              unsigned __int16 v66 = 0LL;
            }
            BYTE11(v112) = (_BYTE)v66;
            if ((objc_opt_respondsToSelector(v6, "completionHandler") & 1) != 0
              && (uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v6 completionHandler]),
                  v67,
                  v67))
            {
              v105[0] = _NSConcreteStackBlock;
              v105[1] = 3221225472LL;
              v105[2] = __61__CaptureMTLCaptureManager_startCaptureWithDescriptor_error___block_invoke;
              v105[3] = &unk_20E1D8;
              __int128 v106 = v6;
              __int128 v113 = objc_retainBlock(v105);
            }

            else
            {
              __int128 v113 = 0LL;
            }

            uint64_t v68 = (char *)[v6 destination];
            __int128 v104 = (id)objc_claimAutoreleasedReturnValue([v6 outputURL]);
            if (v68 == (_BYTE *)&dword_0 + 2)
            {
              if (!-[CaptureMTLCaptureManager supportsDestination:](self, "supportsDestination:", 2LL))
              {
                v133[0] = NSLocalizedDescriptionKey;
                int v80 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Capture Destination ‘%@’ is not supported.",  @"GPU Trace Document"));
                v133[1] = NSLocalizedRecoverySuggestionErrorKey;
                v134[0] = v80;
                v134[1] = @"Capture to another destination.";
                uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v134,  v133,  2LL));

                ReportError(a4, (uint64_t)MTLCaptureErrorDomain, 3LL, (uint64_t)v81);
                goto LABEL_125;
              }

              if (!v104)
              {
                v131[0] = NSLocalizedDescriptionKey;
                id v82 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Capture Destination ‘%@’ must write to a file.",  @"GPU Trace Document"));
                v131[1] = NSLocalizedRecoverySuggestionErrorKey;
                v132[0] = v82;
                v132[1] = @"Specify a valid output file path.";
                __int16 v83 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v132,  v131,  2LL));

                ReportError(a4, (uint64_t)MTLCaptureErrorDomain, 3LL, (uint64_t)v83);
                goto LABEL_125;
              }

              unsigned int v71 = (void *)objc_claimAutoreleasedReturnValue([v104 pathExtension]);
              uint64_t v72 = [v71 isEqualToString:@"gputrace"];

              if ((v72 & 1) == 0)
              {
                v129[0] = NSLocalizedDescriptionKey;
                id v84 = (void *)objc_claimAutoreleasedReturnValue([v104 lastPathComponent]);
                __int16 v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"‘%@’ could not be used because the file name is invalid.",  v84));
                v129[1] = NSLocalizedRecoverySuggestionErrorKey;
                v130[0] = v85;
                v130[1] = @"Use ‘.gputrace’ as file name extension.";
                int v86 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v130,  v129,  2LL));

                ReportError(a4, (uint64_t)NSCocoaErrorDomain, 514LL, (uint64_t)v86);
                goto LABEL_125;
              }

              unint64_t v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
              __int128 v99 = (void *)objc_claimAutoreleasedReturnValue([v104 URLByDeletingLastPathComponent]);
              if (v99
                && ([v73 createDirectoryAtURL:v99 withIntermediateDirectories:1 attributes:0 error:a4] & 1) == 0 || !objc_msgSend( v73,  "createDirectoryAtURL:withIntermediateDirectories:attributes:error:",  v104,  0,  0,  a4))
              {

                goto LABEL_125;
              }

              uint64_t v74 = (GTTraceContext *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( NSString, "stringWithUTF8String:", [v104 fileSystemRepresentation]));
              traceContext = self->_traceContext;
              self->_traceContext = v74;

              *(void *)&__int128 v111 = -[GTTraceContext UTF8String](self->_traceContext, "UTF8String");
              *((void *)&v111 + 1) = "";
              if ((objc_opt_respondsToSelector(v6, "suspendAfterCapture") & 1) != 0) {
                int v76 = [v6 suspendAfterCapture];
              }
              else {
                int v76 = 0;
              }
              BYTE4(v112) = v76;

              uint64_t v100 = v76;
            }

            else
            {
              if (v68 != (_BYTE *)&dword_0 + 1)
              {
                v127[0] = NSLocalizedDescriptionKey;
                v127[1] = NSLocalizedRecoverySuggestionErrorKey;
                v128[0] = @"Capture Destination is not valid.";
                v128[1] = @"Capturing to a valid destination.";
                unsigned int v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v128,  v127,  2LL));
                ReportError(a4, (uint64_t)MTLCaptureErrorDomain, 3LL, (uint64_t)v77);

                goto LABEL_125;
              }

              if (!-[CaptureMTLCaptureManager supportsDestination:](self, "supportsDestination:", 1LL))
              {
                v137[0] = NSLocalizedDescriptionKey;
                int v78 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Capture Destination ‘%@’ is not supported.",  @"Developer Tools"));
                v137[1] = NSLocalizedRecoverySuggestionErrorKey;
                v138[0] = v78;
                v138[1] = @"Capture to another destination.";
                uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v138,  v137,  2LL));

                ReportError(a4, (uint64_t)MTLCaptureErrorDomain, 3LL, (uint64_t)v79);
                goto LABEL_125;
              }

              if (v104)
              {
                v135[0] = NSLocalizedDescriptionKey;
                __int128 v69 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Capture Destination ‘%@’ cannot write to a file.",  @"Developer Tools"));
                v135[1] = NSLocalizedRecoverySuggestionErrorKey;
                v136[0] = v69;
                v136[1] = @"Don't specify an output file path.";
                unsigned __int16 v70 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v136,  v135,  2LL));

                ReportError(a4, (uint64_t)MTLCaptureErrorDomain, 3LL, (uint64_t)v70);
LABEL_125:
                int v13 = 0;
                goto LABEL_126;
              }

              BYTE4(v112) = 1;
              GTMTLGuestAppClient_notifyCaptureRequest((uint64_t *)&v107);
              if (*(_BYTE *)(g_guestAppClientMTL + 129))
              {
                dispatch_semaphore_wait((dispatch_semaphore_t)self->_gputracePath, 0xFFFFFFFFFFFFFFFFLL);
                int v13 = 1;
LABEL_126:
                __int16 v87 = v104;
LABEL_127:

                uint64_t v50 = v113;
                goto LABEL_128;
              }

              uint64_t v100 = 1;
            }

            GTTraceContext_pushEncoderWithStream(*(void *)&self->super._isCapturing, (uint64_t)&v122);
            Arguments = GTTraceEncoder_allocateArguments((uint64_t)&v122, -15736, 24LL);
            __int128 v89 = -[CaptureMTLCaptureManager traceStream](self, "traceStream");
            if (v89) {
              var0 = v89->var0;
            }
            else {
              var0 = 0LL;
            }
            if (a4) {
              a4 = (id *)*a4;
            }
            uint64_t v91 = SaveMTLCaptureDescriptor((uint64_t)&v122, v6);
            *(void *)Arguments = var0;
            *((void *)Arguments + 1) = a4;
            Arguments[16] = v91;
            *(_DWORD *)(Arguments + 17) = 0;
            *((_DWORD *)Arguments + 5) = 0;
            uint64_t v92 = -[GTCaptureDescriptor initWithRequestID:]( objc_alloc(&OBJC_CLASS___GTCaptureDescriptor),  "initWithRequestID:",  v63);
            -[GTCaptureDescriptor setTriggerHitsToStart:](v92, "setTriggerHitsToStart:", v102);
            -[GTCaptureDescriptor setTriggerHitsToEnd:](v92, "setTriggerHitsToEnd:", v101);
            -[GTCaptureDescriptor setSuspendAfterCapture:](v92, "setSuspendAfterCapture:", v100);
            -[GTCaptureDescriptor setIgnoreUnusedResources:](v92, "setIgnoreUnusedResources:", v66);
            -[GTCaptureDescriptor setStreamRef:](v92, "setStreamRef:", v103);
            __int128 v93 = (void *)objc_opt_new(&OBJC_CLASS___GTCaptureProgress);
            [v93 setCaptureState:0];
            [v93 setDescriptor:v92];
            if (*(_BYTE *)(g_guestAppClientMTL + 129)) {
              [*(id *)(g_guestAppClientMTL + 8) notifyCaptureProgress:v93];
            }

            if (LOBYTE(self->_traceStream)) {
              __int128 v94 = 4;
            }
            else {
              __int128 v94 = 5;
            }
            __int128 v95 = -[CaptureMTLCaptureManager traceStream](self, "traceStream");
            if (v95) {
              __int128 v96 = v95->var0;
            }
            else {
              __int128 v96 = 0LL;
            }
            memset(v120, 0, sizeof(v120));
            *(void *)&uint64_t v114 = v94 | 0x700000000LL;
            *((void *)&v114 + 1) = v96;
            uint64_t v115 = v125;
            __int128 v116 = 0u;
            __int128 v117 = 0u;
            __int128 v118 = 0u;
            __int128 v119 = 0;
            __int128 v121 = &v107;
            GTCaptureBoundaryTracker_handleTrigger(&v114);
            dispatch_semaphore_signal((dispatch_semaphore_t)qword_23A340);
            if ((void)v109) {
              dispatch_semaphore_signal((dispatch_semaphore_t)self->_gputracePath);
            }
            s();
            *(void *)__int128 v97 = v98;
            *(_BYTE *)(v97 + _Block_object_dispose(va, 8) = v126;
            *((_BYTE *)v124 + 15) |= 8u;
            if (startCaptureWithDescriptor_error__onceToken != -1) {
              dispatch_once(&startCaptureWithDescriptor_error__onceToken, &__block_literal_global_118);
            }
            __int16 v87 = v104;
            int v13 = 1;
            goto LABEL_127;
          }

  if (v10 <= 0x12)
  {
    uint64_t v43 = 0;
    __int128 v46 = 0;
    uint64_t v44 = *((double *)v33 + 10);
    uint64_t v45 = (unsigned __int16 *)(v33 + 14);
    if (v8) {
      goto LABEL_46;
    }
  }

  else
  {
    uint64_t v43 = *((_BYTE *)v33 + 80);
    uint64_t v44 = *((double *)v33 + 11);
    if (v10 < 0x27)
    {
      __int128 v46 = 0;
      uint64_t v45 = (unsigned __int16 *)(v33 + 15);
      if (!v8) {
        goto LABEL_55;
      }
    }

    else
    {
      uint64_t v45 = (unsigned __int16 *)(v33 + 16);
      __int128 v46 = *((_BYTE *)v33 + 120);
      if (!v8) {
        goto LABEL_55;
      }
    }

uint64_t ResourceTracker_addFunction(uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t a4)
{
  uint64_t result = GTMTLSMContext_lastObject(a2, a3, a4);
  if (result)
  {
    uint64_t v8 = result;
    GTResourceTrackerUsingResource(a1[2], 43, *(void *)(result + 8), *a1, a1[1]);
    GTResourceTrackerUsingResource(a1[2], 67, *(void *)(v8 + 48), *a1, a1[1]);
    uint64_t result = ResourceTracker_addFunctionParent((uint64_t)a1, a2, v8, a4);
    uint64_t v9 = *(void *)(v8 + 112);
    if (v9)
    {
      if (*(void *)(v9 + 24))
      {
        unint64_t v10 = 0LL;
        do
        {
          uint64_t result = ResourceTracker_addFunction(a1, a2, *(void *)(*(void *)(v9 + 16) + 8 * v10++), a4);
          uint64_t v9 = *(void *)(v8 + 112);
        }

        while (*(void *)(v9 + 24) > v10);
      }
    }
  }

  return result;
}

uint64_t ResourceTracker_addLinkedFunctions(uint64_t result, uint64_t *a2, void *a3, unint64_t a4)
{
  uint64_t v7 = (uint64_t *)result;
  if (a3[3])
  {
    unint64_t v8 = 0LL;
    do
    {
      uint64_t Object = GTMTLSMContext_lastObject(a2, *(void *)(a3[2] + 8 * v8), a4);
      uint64_t v10 = Object;
      if (Object) {
        uint64_t v11 = *(void *)(Object + 8);
      }
      else {
        uint64_t v11 = 0LL;
      }
      GTResourceTrackerUsingResource(v7[2], 43, v11, *v7, v7[1]);
      uint64_t result = ResourceTracker_addFunctionParent((uint64_t)v7, a2, v10, a4);
      ++v8;
    }

    while (a3[3] > v8);
  }

  if (a3[7])
  {
    unint64_t v12 = 0LL;
    do
    {
      uint64_t v13 = GTMTLSMContext_lastObject(a2, *(void *)(a3[6] + 8 * v12), a4);
      uint64_t v14 = v13;
      if (v13) {
        uint64_t v15 = *(void *)(v13 + 8);
      }
      else {
        uint64_t v15 = 0LL;
      }
      GTResourceTrackerUsingResource(v7[2], 43, v15, *v7, v7[1]);
      uint64_t result = ResourceTracker_addFunctionParent((uint64_t)v7, a2, v14, a4);
      ++v12;
    }

    while (a3[7] > v12);
  }

  if (a3[1])
  {
    unint64_t v16 = 0LL;
    do
    {
      uint64_t v17 = GTMTLSMContext_lastObject(a2, *(void *)(*a3 + 8 * v16), a4);
      uint64_t v18 = v17;
      if (v17) {
        uint64_t v19 = *(void *)(v17 + 8);
      }
      else {
        uint64_t v19 = 0LL;
      }
      GTResourceTrackerUsingResource(v7[2], 43, v19, *v7, v7[1]);
      uint64_t result = ResourceTracker_addFunctionParent((uint64_t)v7, a2, v18, a4);
      ++v16;
    }

    while (a3[1] > v16);
  }

  unint64_t v20 = a3[5];
  if (v20)
  {
    for (unint64_t i = 0LL; i < v20; ++i)
    {
      uint64_t v22 = a3[4];
      uint64_t v23 = v22 + 24 * i;
      int v25 = *(_DWORD *)(v23 + 16);
      uint64_t v24 = (unsigned int *)(v23 + 16);
      if (v25)
      {
        unint64_t v26 = 0LL;
        uint64_t v27 = (void *)(v22 + 24 * i + 8);
        do
        {
          uint64_t v28 = GTMTLSMContext_lastObject(a2, *(void *)(*v27 + 8 * v26), a4);
          uint64_t v29 = v28;
          if (v28) {
            uint64_t v30 = *(void *)(v28 + 8);
          }
          else {
            uint64_t v30 = 0LL;
          }
          GTResourceTrackerUsingResource(v7[2], 43, v30, *v7, v7[1]);
          uint64_t result = ResourceTracker_addFunctionParent((uint64_t)v7, a2, v29, a4);
          ++v26;
        }

        while (v26 < *v24);
        unint64_t v20 = a3[5];
      }
    }
  }

  return result;
}

void GTResourceTrackerUsingResidencySetArray(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    do
    {
      uint64_t v7 = *a2++;
      uint64_t v6 = v7;
      if (v7) {
        GTResourceTrackerUsingResidencySet(a1, v6);
      }
      --v3;
    }

    while (v3);
  }

void GTCaptureBoundaryTracker_init(uint64_t a1)
{
  uint64_t v2 = newpool;
  uint64_t v3 = (char *)apr_palloc(newpool, 0x68uLL);
  uint64_t v4 = (uint64_t)v3;
  if (v3)
  {
    *((_DWORD *)v3 + 25) = 0;
    *(_OWORD *)(v3 + 84) = 0u;
    *(_OWORD *)(v3 + 6_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v3 + 52) = 0u;
    *(_OWORD *)(v3 + 36) = 0u;
    *(_OWORD *)(v3 + 20) = 0u;
  }

  *(void *)uint64_t v3 = a1;
  *((void *)v3 + 1) = v2;
  *((_DWORD *)v3 + 4) = 0;
  *((void *)v3 + 3) = dispatch_queue_create("com.apple.dt.GPUTools.GTCaptureBoundaryTracker", 0LL);
  for (uint64_t i = 32LL; i != 72; i += 8LL)
  {
    uint64_t v6 = apr_palloc(v2, 0x10uLL);
    void *v6 = v2;
    v6[1] = apr_array_make(v2, 0, 64);
    *(void *)(v4 + i) = v6;
  }

  boundaryTrackerInstance = v4;
  GTCaptureBoundaryTracker_reset();
}

void GTCaptureBoundaryTracker_reset()
{
  uint64_t v0 = boundaryTrackerInstance;
  id v1 = (os_unfair_lock_s *)(boundaryTrackerInstance + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(boundaryTrackerInstance + 16));
  atomic_store(0, (unsigned int *)(v0 + 20));
  for (uint64_t i = 32LL; i != 72; i += 8LL)
    *(_DWORD *)(*(void *)(*(void *)(v0 + i) + 8LL) + 12LL) = 0;
  uint64_t v3 = (char *)apr_array_push(*(apr_array_header_t **)(*(void *)(v0 + 32) + 8LL));
  *(void *)uint64_t v3 = 0x700000001LL;
  *(_OWORD *)(v3 + _Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  *((void *)v3 + 7) = 1LL;
  *(_DWORD *)(v0 + 8_Block_object_dispose(va, 8) = 1;
  *(_WORD *)(v0 + 96) = 0;
  *(void *)(v0 + 72) = 0LL;
  *(void *)(v0 + 80) = 0LL;
  atomic_store(0, (unsigned __int8 *)(*(void *)v0 + 120LL));
  os_unfair_lock_unlock(v1);
}

void GTCaptureBoundaryTracker_destroy()
{
  boundaryTrackerInstance = 0LL;
}

void GTCaptureBoundaryTracker_handleTrigger(__int128 *a1)
{
  uint64_t v2 = (void *)boundaryTrackerInstance;
  if (!*((void *)a1 + 2))
  {
    unint64_t v3 = atomic_load((unint64_t *)(*(void *)boundaryTrackerInstance + 72LL));
    if (v3 <= 1) {
      unint64_t v3 = 1LL;
    }
    *((void *)a1 + 2) = v3 - 1;
  }

  uint64_t v29 = 0LL;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x2000000000LL;
  char v32 = 0;
  uint64_t v25 = 0LL;
  unint64_t v26 = &v25;
  uint64_t v27 = 0x2000000000LL;
  char v28 = 0;
  uint64_t v4 = (dispatch_queue_s *)v2[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __GTCaptureBoundaryTracker_handleTrigger_block_invoke;
  block[3] = &unk_20DA90;
  block[5] = &v25;
  block[6] = v2;
  __int128 v5 = *a1;
  __int128 v20 = a1[1];
  __int128 v19 = v5;
  __int128 v6 = a1[2];
  __int128 v7 = a1[3];
  __int128 v8 = a1[4];
  uint64_t v24 = *((void *)a1 + 10);
  __int128 v23 = v8;
  __int128 v22 = v7;
  __int128 v21 = v6;
  void block[4] = &v29;
  dispatch_sync(v4, block);
  if (*((_BYTE *)v30 + 24))
  {
    v2[10] = *((void *)a1 + 2) - v2[9] + 1LL;
    if (*((_BYTE *)v26 + 24))
    {
      if (s_logUsingOsLog)
      {
        uint64_t v9 = (os_log_s *)gt_tagged_log(0LL);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_0, v9, OS_LOG_TYPE_INFO, "🔥 Aborting capture", buf, 2u);
        }
      }

      else
      {
        fwrite("🔥 Aborting capture\n", 0x16uLL, 1uLL, __stdoutp);
      }

      GTMTLCaptureManager_abortActiveCapture(v2[9], v2[10]);
    }

    else
    {
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 0x40000000LL;
      uint64_t v14 = __GTCaptureBoundaryTracker_handleTrigger_block_invoke_2;
      uint64_t v15 = &__block_descriptor_tmp_5;
      unint64_t v16 = v2;
      uint64_t v10 = (unsigned int *)(boundaryTrackerInstance + 92);
      do
        signed int v11 = __ldaxr(v10);
      while (__stlxr(v11, v10));
      if (v11 < 1)
      {
        v14((uint64_t)v13);
      }

      else
      {
        dispatch_queue_global_t global_queue = dispatch_get_global_queue(2LL, 0LL);
        dispatch_async(global_queue, v13);
      }
    }
  }

  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
}

LABEL_50:
  __int128 v37 = atomic_load(v16);
  if (v37 == 3)
  {
    if (v4 == 5)
    {
      uint64_t v39 = g_targetRef == v203 || g_targetRef == v204;
      uint64_t v38 = &g_commitOther;
      if (v39) {
        uint64_t v38 = &g_commitCount;
      }
      goto LABEL_61;
    }

    if (v4 == 3)
    {
      if (g_targetRef == v5) {
        uint64_t v38 = &g_frameCount;
      }
      else {
        uint64_t v38 = &g_frameOther;
      }
      do
LABEL_61:
        unsigned int v40 = __ldaxr(v38);
      while (__stlxr(v40 + 1, v38));
    }
  }

  uint64_t v197 = (v4 - 1);
  uint64_t v196 = (v193 - 1);
  uint64_t v41 = &OBJC_PROTOCOL___CaptureMTLObject;
  v207 = v2;
  int v199 = (unsigned int *)(v2 + 20);
  uint64_t v200 = v6;
  while (2)
  {
    if (GTCapturePhase_isComplete(v18))
    {
      uint64_t v42 = atomic_load(v16);
      if (v42 != 4)
      {
        if (LOBYTE(v41[1].opt_inst_meths))
        {
          uint64_t v43 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
          {
            uint64_t v44 = atomic_load(v16);
            uint64_t v45 = "UNKNOWN";
            __int128 v46 = atomic_load(v16);
            uint64_t v47 = v46 + 1;
            uint64_t v48 = "UNKNOWN";
            if (v47 <= 4) {
              uint64_t v48 = (&off_20DB30)[v47];
            }
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = v45;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v48;
            _os_log_impl(&dword_0, v43, OS_LOG_TYPE_INFO, "⏭️  Capture phase transition: %s ==> %s", buf, 0x16u);
          }
        }

        else
        {
          __int128 v49 = atomic_load(v16);
          uint64_t v50 = "UNKNOWN";
          uint64_t v51 = atomic_load(v16);
          uint64_t v52 = v51 + 1;
          __int128 v53 = "UNKNOWN";
          if (v52 <= 4) {
            __int128 v53 = (&off_20DB30)[v52];
          }
          fprintf(__stdoutp, "⏭️  Capture phase transition: %s ==> %s\n", v50, v53);
        }

        if (LOBYTE(v41[1].opt_inst_meths))
        {
          uint64_t v54 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_0, v54, OS_LOG_TYPE_INFO, "🔫 GTCaptureTrigger", buf, 2u);
          }
        }

        else
        {
          fwrite("🔫 GTCaptureTrigger\n", 0x16uLL, 1uLL, __stdoutp);
        }

        if (LOBYTE(v41[1].opt_inst_meths))
        {
          unsigned int v55 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
          {
            unsigned __int16 v56 = "Instant";
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v56;
            _os_log_impl(&dword_0, v55, OS_LOG_TYPE_INFO, "    type: %s", buf, 0xCu);
          }
        }

        else
        {
          uint64_t v57 = "Instant";
          fprintf(__stdoutp, "    type: %s\n", v57);
        }

        if (LOBYTE(v41[1].opt_inst_meths))
        {
          uint64_t v58 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
          {
            __int128 v59 = "None";
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v59;
            _os_log_impl(&dword_0, v58, OS_LOG_TYPE_INFO, "    object: %s", buf, 0xCu);
          }
        }

        else
        {
          unsigned __int16 v60 = "None";
          fprintf(__stdoutp, "    object: %s\n", v60);
        }

        if (LOBYTE(v41[1].opt_inst_meths))
        {
          uint64_t v61 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 134218240;
            *(void *)&uint8_t buf[4] = v195;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v201;
            _os_log_impl(&dword_0, v61, OS_LOG_TYPE_INFO, "    stream: %llu; function index: %llu", buf, 0x16u);
          }
        }

        else
        {
          fprintf(__stdoutp, "    stream: %llu; function index: %llu\n", v195, v201);
        }

        if (v206)
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v62 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v206;
              _os_log_impl(&dword_0, v62, OS_LOG_TYPE_INFO, "    parent function index: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "    parent function index: %llu\n", v206);
          }
        }

        if (v202)
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            unsigned __int16 v63 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v202;
              _os_log_impl(&dword_0, v63, OS_LOG_TYPE_INFO, "    MTLCaptureScope stream ref: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "    MTLCaptureScope stream ref: %llu\n", v202);
          }
        }

        if (v204)
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            uint64_t v64 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v204;
              _os_log_impl(&dword_0, v64, OS_LOG_TYPE_INFO, "    MTLDevice stream ref: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "    MTLDevice stream ref: %llu\n", v204);
          }
        }

        if (v203)
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v65 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v203;
              _os_log_impl(&dword_0, v65, OS_LOG_TYPE_INFO, "    MTLCommandQueue stream ref: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "    MTLCommandQueue stream ref: %llu\n", v203);
          }
        }

        if (v205)
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            unsigned __int16 v66 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v66, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v205;
              _os_log_impl(&dword_0, v66, OS_LOG_TYPE_INFO, "    MTLCommandBuffer stream ref: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "    MTLCommandBuffer stream ref: %llu\n", v205);
          }
        }

        if (v198)
        {
          if (!LOBYTE(v41[1].opt_inst_meths))
          {
            fwrite("    MTLCommandBuffer is capturing\n", 0x22uLL, 1uLL, __stdoutp);
            if (!v6) {
              goto LABEL_247;
            }
            goto LABEL_131;
          }

          uint64_t v67 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_0, v67, OS_LOG_TYPE_INFO, "    MTLCommandBuffer is capturing", buf, 2u);
          }
        }

        if (!v6) {
          goto LABEL_247;
        }
LABEL_131:
        if (LOBYTE(v41[1].opt_inst_meths))
        {
          uint64_t v68 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_0, v68, OS_LOG_TYPE_INFO, "    captureDescriptor:", buf, 2u);
          }
        }

        else
        {
          fwrite("    captureDescriptor:\n", 0x17uLL, 1uLL, __stdoutp);
        }

        if (LOBYTE(v41[1].opt_inst_meths))
        {
          __int128 v69 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v69, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_0, v69, OS_LOG_TYPE_INFO, "        📜 GTMTLCaptureDescriptorInternal", buf, 2u);
          }
        }

        else
        {
          fwrite("        📜 GTMTLCaptureDescriptorInternal\n", 0x2CuLL, 1uLL, __stdoutp);
        }

        if (*(void *)v6)
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            unsigned __int16 v70 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v70, OS_LOG_TYPE_INFO))
            {
              unsigned int v71 = *(void *)v6;
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v71;
              _os_log_impl(&dword_0, v70, OS_LOG_TYPE_INFO, "        MTLDevice stream ref: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "        MTLDevice stream ref: %llu\n", *(void *)v6);
          }
        }

        if (*(void *)(v6 + 8))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            uint64_t v72 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v72, OS_LOG_TYPE_INFO))
            {
              unint64_t v73 = *(void *)(v6 + 8);
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v73;
              _os_log_impl(&dword_0, v72, OS_LOG_TYPE_INFO, "        MTLCommandQueue stream ref: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "        MTLCommandQueue stream ref: %llu\n", *(void *)(v6 + 8));
          }
        }

        if (*(void *)(v6 + 16))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            uint64_t v74 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v74, OS_LOG_TYPE_INFO))
            {
              uint64_t v75 = *(void *)(v6 + 16);
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v75;
              _os_log_impl(&dword_0, v74, OS_LOG_TYPE_INFO, "        MTLCaptureScope stream ref: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "        MTLCaptureScope stream ref: %llu\n", *(void *)(v6 + 16));
          }
        }

        if (*(void *)(v6 + 24))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            int v76 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
            {
              unsigned int v77 = *(void *)(v6 + 24);
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v77;
              _os_log_impl(&dword_0, v76, OS_LOG_TYPE_INFO, "        CAMetalLayer stream ref: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "        CAMetalLayer stream ref: %llu\n", *(void *)(v6 + 24));
          }
        }

        if (*(void *)(v6 + 32))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            int v78 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v78, OS_LOG_TYPE_INFO))
            {
              uint64_t v79 = *(void *)(v6 + 32);
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v79;
              _os_log_impl(&dword_0, v78, OS_LOG_TYPE_INFO, "        session ID: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "        session ID: %llu\n", *(void *)(v6 + 32));
          }
        }

        if (LOBYTE(v41[1].opt_inst_meths))
        {
          int v80 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v80, OS_LOG_TYPE_INFO))
          {
            uint64_t v81 = *(void *)(v6 + 40);
            *(_DWORD *)buf = 134217984;
            *(void *)&uint8_t buf[4] = v81;
            _os_log_impl(&dword_0, v80, OS_LOG_TYPE_INFO, "        trigger hits to start: %llu", buf, 0xCu);
          }
        }

        else
        {
          fprintf(__stdoutp, "        trigger hits to start: %llu\n", *(void *)(v6 + 40));
        }

        if (LOBYTE(v41[1].opt_inst_meths))
        {
          id v82 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v82, OS_LOG_TYPE_INFO))
          {
            __int16 v83 = *(void *)(v6 + 48);
            *(_DWORD *)buf = 134217984;
            *(void *)&uint8_t buf[4] = v83;
            _os_log_impl(&dword_0, v82, OS_LOG_TYPE_INFO, "        trigger hits to end: %llu", buf, 0xCu);
          }
        }

        else
        {
          fprintf(__stdoutp, "        trigger hits to end: %llu\n", *(void *)(v6 + 48));
        }

        if (*(void *)(v6 + 56))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            id v84 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v84, OS_LOG_TYPE_INFO))
            {
              __int16 v85 = *(void *)(v6 + 56);
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v85;
              _os_log_impl(&dword_0, v84, OS_LOG_TYPE_INFO, "        sandboxExtensionHandle: %llu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "        sandboxExtensionHandle: %llu\n", *(void *)(v6 + 56));
          }
        }

        if (*(void *)(v6 + 64))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            int v86 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v86, OS_LOG_TYPE_INFO))
            {
              __int16 v87 = *(void *)(v6 + 64);
              *(_DWORD *)buf = 136315138;
              *(void *)&uint8_t buf[4] = v87;
              _os_log_impl(&dword_0, v86, OS_LOG_TYPE_INFO, "        localFilePathURL: %s", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "        localFilePathURL: %s\n", *(const char **)(v6 + 64));
          }
        }

        if (*(void *)(v6 + 72))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v88 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v88, OS_LOG_TYPE_INFO))
            {
              __int128 v89 = *(void *)(v6 + 72);
              *(_DWORD *)buf = 136315138;
              *(void *)&uint8_t buf[4] = v89;
              _os_log_impl(&dword_0, v88, OS_LOG_TYPE_INFO, "        hostFilePathURL: %s", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "        hostFilePathURL: %s\n", *(const char **)(v6 + 72));
          }
        }

        if (LOBYTE(v41[1].opt_inst_meths))
        {
          __int128 v90 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v90, OS_LOG_TYPE_INFO))
          {
            uint64_t v91 = *(_DWORD *)(v6 + 80) - 1;
            uint64_t v92 = "DeviceManual";
            if (v91 <= 5) {
              uint64_t v92 = (&off_20DBC0)[v91];
            }
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v92;
            _os_log_impl(&dword_0, v90, OS_LOG_TYPE_INFO, "        captureMode: %s", buf, 0xCu);
          }
        }

        else
        {
          __int128 v93 = *(_DWORD *)(v6 + 80) - 1;
          __int128 v94 = "DeviceManual";
          if (v93 <= 5) {
            __int128 v94 = (&off_20DBC0)[v93];
          }
          fprintf(__stdoutp, "        captureMode: %s\n", v94);
        }

        if (*(_BYTE *)(v6 + 84))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v95 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v95, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_0, v95, OS_LOG_TYPE_INFO, "        suspendAfterCapture: true", buf, 2u);
            }
          }

          else
          {
            fwrite("        suspendAfterCapture: true\n", 0x22uLL, 1uLL, __stdoutp);
          }
        }

        if (*(_BYTE *)(v6 + 86))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v96 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v96, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_0, v96, OS_LOG_TYPE_INFO, "        isBoundaryLess: true", buf, 2u);
            }
          }

          else
          {
            fwrite("        isBoundaryLess: true\n", 0x1DuLL, 1uLL, __stdoutp);
          }
        }

        if (*(_BYTE *)(v6 + 85))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v97 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v97, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_0, v97, OS_LOG_TYPE_INFO, "        lockGraphicsAfterCapture: true", buf, 2u);
            }
          }

          else
          {
            fwrite("        lockGraphicsAfterCapture: true\n", 0x27uLL, 1uLL, __stdoutp);
          }
        }

        if (*(_BYTE *)(v6 + 88))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v98 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v98, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_0, v98, OS_LOG_TYPE_INFO, "        armPreparedCapture: true", buf, 2u);
            }
          }

          else
          {
            fwrite("        armPreparedCapture: true\n", 0x21uLL, 1uLL, __stdoutp);
          }
        }

        if (*(_BYTE *)(v6 + 89))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v99 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v99, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_0, v99, OS_LOG_TYPE_INFO, "        apiTriggeredCapture: true", buf, 2u);
            }
          }

          else
          {
            fwrite("        apiTriggeredCapture: true\n", 0x22uLL, 1uLL, __stdoutp);
          }
        }

        if (*(_BYTE *)(v6 + 90))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            uint64_t v100 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v100, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_0, v100, OS_LOG_TYPE_INFO, "        toolTriggeredCapture: true", buf, 2u);
            }
          }

          else
          {
            fwrite("        toolTriggeredCapture: true\n", 0x23uLL, 1uLL, __stdoutp);
          }
        }

        if (*(_BYTE *)(v6 + 91))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int16 v101 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v101, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_0, v101, OS_LOG_TYPE_INFO, "        ignoreUnusedResources: true", buf, 2u);
            }
          }

          else
          {
            fwrite("        ignoreUnusedResources: true\n", 0x24uLL, 1uLL, __stdoutp);
          }
        }

        if (*(_BYTE *)(v6 + 92))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v102 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v102, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_0, v102, OS_LOG_TYPE_INFO, "        includeBacktrace: true", buf, 2u);
            }
          }

          else
          {
            fwrite("        includeBacktrace: true\n", 0x1FuLL, 1uLL, __stdoutp);
          }
        }

        if (*(_BYTE *)(v6 + 93))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v103 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v103, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_0, v103, OS_LOG_TYPE_INFO, "       useNewArchiveFormat: true", buf, 2u);
            }
          }

          else
          {
            fwrite("       useNewArchiveFormat: true\n", 0x21uLL, 1uLL, __stdoutp);
          }
        }

        if (*(void *)(v6 + 96))
        {
          if (LOBYTE(v41[1].opt_inst_meths))
          {
            __int128 v104 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v104, OS_LOG_TYPE_INFO))
            {
              __int128 v105 = *(void *)(v6 + 96);
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = v105;
              _os_log_impl(&dword_0, v104, OS_LOG_TYPE_INFO, "        captureCompletionHandler: %lu", buf, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "        captureCompletionHandler: %lu\n", *(void *)(v6 + 96));
          }
        }
          }

          signed int v11 = (char *)v11 + 1;
        }

        while (v11 != v251);
        uint64_t v189 = [obj countByEnumeratingWithState:&v274 objects:v324 count:16];
        unint64_t v251 = v189;
        if (!v189)
        {
          __int16 v190 = obj;
          goto LABEL_104;
        }
      }
    }

    __int16 v190 = obj;
    goto LABEL_123;
  }

  v191 = objc_opt_class(&OBJC_CLASS___MTLInstanceAccelerationStructureDescriptor, v9);
  if ((objc_opt_isKindOfClass(v6, v191) & 1) != 0)
  {
    __int16 v190 = v6;
    v193 = [v190 instanceDescriptorStride];
    __int16 v194 = [v190 instanceCount];
    v195 = (void)v194 * (void)v193;
    if ((void)v194 * (void)v193 <= 1uLL) {
      uint64_t v196 = 1LL;
    }
    else {
      uint64_t v196 = (void)v194 * (void)v193;
    }
    uint64_t v197 = [v257 newBufferWithLength:v196 options:0];
    [v197 setLabel:@"gputools.ADSInstanceDescriptorBuffer"];
    v288[0] = @"srcBuffer";
    float64x2x3_t v198 = (void *)objc_claimAutoreleasedReturnValue([v190 instanceDescriptorBuffer]);
    v289[0] = v198;
    v288[1] = @"srcOffset";
    int v199 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v190 instanceDescriptorBufferOffset]));
    v289[1] = v199;
    v289[2] = v197;
    v288[2] = @"dstBuffer";
    v288[3] = @"length";
    uint64_t v200 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v195));
    v289[3] = v200;
    uint64_t v201 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v289,  v288,  4LL));

    __int128 v5 = v256;
    [v256 addObject:v201];
    [v190 setInstanceDescriptorBuffer:v197];
    [v190 setInstanceDescriptorBufferOffset:0];

    v202 = (void *)objc_claimAutoreleasedReturnValue([v190 motionTransformBuffer]);
    if (!v202)
    {
LABEL_104:
      __int128 v6 = v243;
LABEL_123:

      goto LABEL_124;
    }

    unint64_t v203 = [v190 motionTransformCount];
    uint64_t v204 = 48LL * (void)v203;
    else {
      v205 = 48LL * (void)v203;
    }
    uint64_t v206 = [v257 newBufferWithLength:v205 options:0];
    [v206 setLabel:@"gputools.ADSMotionTransformBuffer"];
    v286[0] = @"srcBuffer";
    v207 = (void *)objc_claimAutoreleasedReturnValue([v190 motionTransformBuffer]);
    v287[0] = v207;
    v286[1] = @"srcOffset";
    v208 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v190 motionTransformBufferOffset]));
    v287[1] = v208;
    v287[2] = v206;
    v286[2] = @"dstBuffer";
    v286[3] = @"length";
    uint64_t v209 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v204));
    v287[3] = v209;
    v210 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v287,  v286,  4LL));

    __int128 v5 = v256;
    [v256 addObject:v210];
    [v190 setMotionTransformBuffer:v206];
    [v190 setMotionTransformBufferOffset:0];
LABEL_120:

    __int16 v190 = v6;
    goto LABEL_123;
  }

  v211 = objc_opt_class(&OBJC_CLASS___MTLIndirectInstanceAccelerationStructureDescriptor, v192);
  if ((objc_opt_isKindOfClass(v6, v211) & 1) != 0)
  {
    v212 = v6;
    uint64_t v213 = (void *)objc_claimAutoreleasedReturnValue([v212 instanceDescriptorBuffer]);

    if (v213)
    {
      uint64_t v214 = [v212 maxInstanceCount];
      uint64_t v215 = [v212 instanceDescriptorStride];
      int v216 = (void)v215 * (void)v214;
      if ((void)v215 * (void)v214 <= 1uLL) {
        uint64_t v217 = 1LL;
      }
      else {
        uint64_t v217 = (void)v215 * (void)v214;
      }
      uint64_t v218 = [v257 newBufferWithLength:v217 options:0];
      [v218 setLabel:@"gputools.ADSInstanceDescriptorBuffer"];
      v284[0] = @"srcBuffer";
      v219 = (void *)objc_claimAutoreleasedReturnValue([v212 instanceDescriptorBuffer]);
      v285[0] = v219;
      v284[1] = @"srcOffset";
      uint64_t v220 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v212 instanceDescriptorBufferOffset]));
      v285[1] = v220;
      v285[2] = v218;
      v284[2] = @"dstBuffer";
      v284[3] = @"length";
      unsigned int v221 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v216));
      v285[3] = v221;
      unsigned int v222 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v285,  v284,  4LL));

      __int128 v5 = v256;
      [v256 addObject:v222];
      [v212 setInstanceDescriptorBuffer:v218];
      [v212 setInstanceDescriptorBufferOffset:0];
    }

    uint64_t v223 = (void *)objc_claimAutoreleasedReturnValue([v212 instanceCountBuffer]);

    if (v223)
    {
      unint64_t v224 = [v257 newBufferWithLength:4 options:0];
      [v224 setLabel:@"gputools.ADSInstanceCountBuffer"];
      v282[0] = @"srcBuffer";
      uint64_t v225 = (void *)objc_claimAutoreleasedReturnValue([v212 instanceCountBuffer]);
      v283[0] = v225;
      v282[1] = @"srcOffset";
      uint64_t v226 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v212 instanceCountBufferOffset]));
      v283[1] = v226;
      v283[2] = v224;
      v282[2] = @"dstBuffer";
      v282[3] = @"length";
      int v227 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", 4LL));
      v283[3] = v227;
      v228 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v283,  v282,  4LL));

      __int128 v5 = v256;
      [v256 addObject:v228];
      [v212 setInstanceCountBuffer:v224];
      [v212 setInstanceCountBufferOffset:0];
    }

    v229 = (void *)objc_claimAutoreleasedReturnValue([v212 motionTransformBuffer]);

    if (v229)
    {
      unsigned int v230 = [v212 maxMotionTransformCount];
      int v231 = 48LL * (void)v230;
      else {
        uint64_t v232 = 48LL * (void)v230;
      }
      v233 = [v257 newBufferWithLength:v232 options:0];
      [v233 setLabel:@"gputools.ADSMotionTransformBuffer"];
      v280[0] = @"srcBuffer";
      uint64_t v234 = (void *)objc_claimAutoreleasedReturnValue([v212 motionTransformBuffer]);
      v281[0] = v234;
      v280[1] = @"srcOffset";
      unsigned int v235 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v212 motionTransformBufferOffset]));
      v281[1] = v235;
      v281[2] = v233;
      v280[2] = @"dstBuffer";
      v280[3] = @"length";
      char v236 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v231));
      v281[3] = v236;
      unsigned int v237 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v281,  v280,  4LL));

      __int128 v5 = v256;
      [v256 addObject:v237];
      [v212 setMotionTransformBuffer:v233];
      [v212 setMotionTransformBufferOffset:0];
    }

    uint64_t v238 = (void *)objc_claimAutoreleasedReturnValue([v212 motionTransformCountBuffer]);

    if (!v238)
    {
      __int16 v190 = v212;
      goto LABEL_123;
    }

    uint64_t v206 = [v257 newBufferWithLength:4 options:0];
    [v206 setLabel:@"gputools.ADSMotionTransformCountBuffer"];
    v278[0] = @"srcBuffer";
    uint64_t v239 = (void *)objc_claimAutoreleasedReturnValue([v212 motionTransformCountBuffer]);
    v279[0] = v239;
    v278[1] = @"srcOffset";
    v240 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v212 motionTransformCountBufferOffset]));
    v279[1] = v240;
    v279[2] = v206;
    v278[2] = @"dstBuffer";
    v278[3] = @"length";
    uint64_t v241 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", 4LL));
    v279[3] = v241;
    v210 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v279,  v278,  4LL));

    __int128 v5 = v256;
    [v256 addObject:v210];
    [v212 setMotionTransformCountBuffer:v206];
    [v212 setMotionTransformCountBufferOffset:0];
    goto LABEL_120;
  }

LABEL_247:
        __int128 v106 = atomic_load(v16);
        switch(v106)
        {
          case 0u:
            *(_DWORD *)(v2 + 8_Block_object_dispose(va, 8) = v193;
            switch(*(_DWORD *)(v6 + 80))
            {
              case 0:
              case 2:
                id v107 = (char *)apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 56) + 8LL));
                *(_DWORD *)id v107 = v193;
                *((_DWORD *)v107 + 1) = 8;
                *(_OWORD *)(v107 + _Block_object_dispose(va, 8) = 0u;
                *(_OWORD *)(v107 + 24) = 0u;
                *(_OWORD *)(v107 + 40) = 0u;
                *((void *)v107 + 7) = 1LL;
                break;
              case 1:
                __int128 v116 = *(void *)v6;
                __int128 v117 = *(void *)(v6 + 40);
                __int128 v118 = apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 40) + 8LL));
                *__int128 v118 = 0x400000008LL;
                v118[1] = 0LL;
                v118[2] = 0LL;
                v118[3] = v116;
                v118[4] = 0LL;
                v118[5] = 0LL;
                v118[6] = 0LL;
                v118[7] = v117;
                __int128 v119 = *(void *)(v6 + 48);
                __int128 v120 = (char *)apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 56) + 8LL));
                *(void *)__int128 v120 = 0x500000008LL;
                *((void *)v120 + 1) = 0LL;
                *((void *)v120 + 2) = 0LL;
                *((void *)v120 + 4) = 0LL;
                *((void *)v120 + 5) = 0LL;
                *((void *)v120 + 3) = v116;
                goto LABEL_277;
              case 3:
                __int128 v121 = *(void *)(v6 + 8);
                __int128 v122 = *(void *)(v6 + 40);
                __int128 v123 = apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 40) + 8LL));
                *__int128 v123 = 0x400000008LL;
                v123[1] = 0LL;
                v123[2] = 0LL;
                v123[3] = 0LL;
                v123[4] = v121;
                v123[5] = 0LL;
                v123[6] = 0LL;
                v123[7] = v122;
                __int128 v119 = *(void *)(v6 + 48);
                __int128 v120 = (char *)apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 56) + 8LL));
                *(void *)__int128 v120 = 0x500000008LL;
                *((void *)v120 + 1) = 0LL;
                *((void *)v120 + 2) = 0LL;
                *((void *)v120 + 3) = 0LL;
                *((void *)v120 + 4) = v121;
                *((void *)v120 + 5) = 0LL;
LABEL_277:
                v120[48] = 1;
                *(_DWORD *)(v120 + 49) = 0;
                *((_DWORD *)v120 + 13) = 0;
                goto LABEL_284;
              case 4:
                __int128 v124 = *(void *)(v6 + 16);
                __int128 v125 = *(void *)(v6 + 40);
                __int128 v126 = (char *)apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 40) + 8LL));
                *(void *)__int128 v126 = 0x100000002LL;
                *((void *)v126 + 1) = 0LL;
                *((void *)v126 + 2) = v124;
                *(_OWORD *)(v126 + 24) = 0u;
                *(_OWORD *)(v126 + 40) = 0u;
                *((void *)v126 + 7) = v125;
                __int128 v119 = *(void *)(v6 + 48);
                __int128 v120 = (char *)apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 56) + 8LL));
                *(void *)__int128 v120 = 0x200000002LL;
                *((void *)v120 + 1) = 0LL;
                *((void *)v120 + 2) = v124;
                *(_OWORD *)(v120 + 24) = 0u;
                *(_OWORD *)(v120 + 40) = 0u;
                goto LABEL_284;
              case 5:
                uint64_t v127 = *(void *)(v6 + 40);
                if (*(_BYTE *)(v2 + 96)) {
                  uint64_t v128 = 7;
                }
                else {
                  uint64_t v128 = 1;
                }
                uint64_t v129 = (char *)apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 40) + 8LL));
                *(_DWORD *)uint64_t v129 = v128;
                *((_DWORD *)v129 + 1) = 3;
                *(_OWORD *)(v129 + _Block_object_dispose(va, 8) = 0u;
                *(_OWORD *)(v129 + 24) = 0u;
                *(_OWORD *)(v129 + 40) = 0u;
                *((_DWORD *)v129 + 14) = v127;
                *((_DWORD *)v129 + 15) = 0;
                unint64_t v130 = *(void *)(v6 + 48);
                __int128 v120 = (char *)apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 56) + 8LL));
                *(_DWORD *)__int128 v120 = v128;
                *((_DWORD *)v120 + 1) = 3;
                *(_OWORD *)(v120 + _Block_object_dispose(va, 8) = 0u;
                *(_OWORD *)(v120 + 24) = 0u;
                *(_OWORD *)(v120 + 40) = 0u;
                *((_DWORD *)v120 + 14) = v130;
                goto LABEL_285;
              case 6:
                uint64_t v131 = *(void *)(v6 + 24);
                uint64_t v132 = *(void *)(v6 + 40);
                unint64_t v133 = apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 40) + 8LL));
                _DWORD *v133 = 0x300000003LL;
                v133[1] = v131;
                *((_OWORD *)v133 + 1) = 0u;
                *((_OWORD *)v133 + 2) = 0u;
                v133[6] = 0LL;
                v133[7] = v132;
                __int128 v119 = *(void *)(v6 + 48);
                __int128 v120 = (char *)apr_array_push(*(apr_array_header_t **)(*(void *)(v2 + 56) + 8LL));
                *(void *)__int128 v120 = 0x300000003LL;
                *((void *)v120 + 1) = v131;
                *((_OWORD *)v120 + 1) = 0u;
                *((_OWORD *)v120 + 2) = 0u;
                *((void *)v120 + 6) = 0LL;
LABEL_284:
                *((_DWORD *)v120 + 14) = v119;
LABEL_285:
                *((_DWORD *)v120 + 15) = 0;
                break;
              default:
                break;
            }

            unint64_t v134 = 0LL;
            uint64_t v135 = 0;
            int v231 = 0u;
            uint64_t v232 = 0u;
            v229 = 0u;
            unsigned int v230 = 0u;
            int v227 = 0u;
            v228 = 0u;
            uint64_t v225 = 0u;
            uint64_t v226 = 0u;
            uint64_t v223 = 0u;
            unint64_t v224 = 0u;
            unsigned int v221 = 0u;
            unsigned int v222 = 0u;
            memset(buf, 0, sizeof(buf));
            do
            {
              uint64_t v136 = v135 + snprintf((char *)&buf[(char)v135], 256LL - (char)v135, "%s--", (&off_20DB30)[v134]);
              uint64_t v137 = (char *)&buf[(char)v136];
              uint64_t v138 = 256LL - (char)v136;
              if (*(_DWORD *)(*(void *)(*(void *)(v2 + v134 * 8 + 32) + 8LL) + 12LL)) {
                uint64_t v139 = snprintf(v137, v138, "🛡️ --");
              }
              else {
                uint64_t v139 = snprintf(v137, v138, "➡️ --");
              }
              uint64_t v135 = v136 + v139;
              ++v134;
            }

            while (v134 != 5);
            snprintf((char *)&buf[(char)v135], 256LL - (char)v135, "Postcapture");
            if (s_logUsingOsLog)
            {
              uint64_t v140 = (os_log_s *)gt_tagged_log(0LL);
              if (os_log_type_enabled(v140, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)uint64_t v215 = 136315138;
                *(void *)int v216 = buf;
                _os_log_impl(&dword_0, v140, OS_LOG_TYPE_INFO, "%s", v215, 0xCu);
              }
            }

            else
            {
              fprintf(__stdoutp, "%s\n", (const char *)buf);
            }

            id v141 = 0LL;
            while (1)
            {
              v208 = v141;
              v210 = v2 + 8 * v141 + 32;
              id v142 = *(unsigned int *)(*(void *)(*(void *)v210 + 8LL) + 12LL);
LABEL_368:
              id v141 = v208 + 1;
              uint64_t v2 = v207;
              if (v208 == 4)
              {
                atomic_store(1u, (unsigned int *)(*(void *)v207 + 104LL));
                __int128 v6 = v200;
                GTMTLCaptureManager_activateCaptureWithDescriptor(v200);
                if (!s_logUsingOsLog)
                {
                  fwrite("🚀 Capture activated\n", 0x17uLL, 1uLL, __stdoutp);
                  unint64_t v16 = v199;
                  goto LABEL_374;
                }

                __int128 v173 = (os_log_s *)gt_tagged_log(0LL);
                unint64_t v16 = v199;
                if (!os_log_type_enabled(v173, OS_LOG_TYPE_INFO)) {
                  goto LABEL_374;
                }
                *(_WORD *)buf = 0;
                __int128 v112 = v173;
                __int128 v113 = "🚀 Capture activated";
                goto LABEL_372;
              }
            }

            uint64_t v143 = 0;
            uint64_t v144 = 0LL;
            uint64_t v209 = v142 << 6;
            break;
          case 1u:
            GTTraceStoreDebugDescription("capture start", *(int **)(*(void *)v2 + 64LL));
            if (v204 && !*(void *)_sharedCaptureManager)
            {
              *(void *)_sharedCaptureManager = v204;
              if (v6)
              {
LABEL_253:
                __int128 v108 = *(_BYTE *)(v6 + 92) != 0;
                goto LABEL_269;
              }
            }

            else if (v6)
            {
              goto LABEL_253;
            }

            __int128 v108 = 1;
LABEL_269:
            atomic_store(v108, (unsigned __int8 *)(*(void *)v2 + 120LL));
            GTMTLCaptureManager_startCapture();
            if (LOBYTE(v41[1].opt_inst_meths))
            {
              __int128 v111 = (os_log_s *)gt_tagged_log(0LL);
              if (os_log_type_enabled(v111, OS_LOG_TYPE_INFO))
              {
                *(_WORD *)buf = 0;
                __int128 v112 = v111;
                __int128 v113 = "🟢 Capture started";
LABEL_372:
                _os_log_impl(&dword_0, v112, OS_LOG_TYPE_INFO, v113, buf, 2u);
              }
            }

            else
            {
              fwrite("🟢 Capture started\n", 0x15uLL, 1uLL, __stdoutp);
            }

LABEL_374:
            *(void *)(v2 + 72) = v201;
            do
LABEL_375:
              __int128 v174 = __ldaxr(v16);
            while (__stlxr(v174 + 1, v16));
LABEL_376:
            uint64_t v175 = atomic_load((unsigned int *)(v2 + 20));
            uint64_t v18 = *(void *)(v2 + 8LL * v175 + 32);
            uint64_t v41 = &OBJC_PROTOCOL___CaptureMTLObject;
            continue;
          case 2u:
            if (!v206 || v194 != 3 || v206 > *(void *)(v2 + 72)) {
              goto LABEL_375;
            }
            if (LOBYTE(v41[1].opt_inst_meths))
            {
              __int128 v109 = (os_log_s *)gt_tagged_log(0LL);
              if (os_log_type_enabled(v109, OS_LOG_TYPE_INFO))
              {
                *(_WORD *)buf = 0;
                _os_log_impl( &dword_0,  v109,  OS_LOG_TYPE_INFO,  "🔄 Transition aborted: waiting for a present issued during capture",  buf,  2u);
              }
            }

            else
            {
              fwrite("🔄 Transition aborted: waiting for a present issued during capture\n", 0x45uLL, 1uLL, __stdoutp);
            }

            __int128 v176 = 0LL;
            uint64_t v177 = *(void *)(v2 + 40);
            __int128 v178 = *(void *)(v2 + 48);
            while (2)
            {
              v179 = *(void *)(v177 + 8);
              uint64_t v180 = (int *)(*(void *)(v179 + 24) + (v176 << 6));
              if (v180[1] != 3) {
                goto LABEL_390;
              }
              int v181 = *v180;
              __int16 v182 = v180 + 2;
              unint64_t v183 = *((void *)v180 + 7);
              *(_DWORD *)buf = *v180;
              *(_DWORD *)&uint8_t buf[4] = 3;
              *(_OWORD *)&buf[8] = *(_OWORD *)(v180 + 2);
              *(_OWORD *)&_BYTE buf[24] = *(_OWORD *)(v180 + 6);
              *(_OWORD *)&buf[40] = *(_OWORD *)(v180 + 10);
              *(void *)&buf[56] = v183;
              __int16 v184 = *(apr_array_header_t **)(v178 + 8);
              int nelts = v184->nelts;
              __int16 v186 = 0LL;
              uint64_t elts = v184->elts;
              __int16 v188 = (uint64_t)elts;
              while (!GTCaptureBoundaryCondition_equals(v188, (uint64_t)buf))
              {
                ++v186;
                v188 += 64LL;
                if (nelts == v186) {
                  goto LABEL_388;
                }
              }

              if (elts)
              {
                ++*(_DWORD *)&elts[64 * v186 + 56];
              }

              else
              {
LABEL_388:
                *(_OWORD *)buf = *v182;
                *(_OWORD *)&uint8_t buf[16] = v182[1];
                *(_OWORD *)&buf[32] = v182[2];
                uint64_t v189 = (char *)apr_array_push(v184);
                *(_DWORD *)uint64_t v189 = v181;
                *((_DWORD *)v189 + 1) = 3;
                *(_OWORD *)(v189 + _Block_object_dispose(va, 8) = *(_OWORD *)buf;
                *(_OWORD *)(v189 + 24) = *(_OWORD *)&buf[16];
                *(_OWORD *)(v189 + 40) = *(_OWORD *)&buf[32];
                *((void *)v189 + 7) = 1LL;
              }

              uint64_t v2 = v207;
              unint64_t v16 = v199;
              __int128 v6 = v200;
LABEL_390:
              ++v176;
              continue;
            }

          case 3u:
            if (!v205 || v194 != 5 && v194 != 3)
            {
              atomic_store(0, (unsigned __int8 *)(*(void *)v2 + 120LL));
              goto LABEL_375;
            }

            if (LOBYTE(v41[1].opt_inst_meths))
            {
              id v110 = (os_log_s *)gt_tagged_log(0LL);
              if (os_log_type_enabled(v110, OS_LOG_TYPE_INFO))
              {
                *(_WORD *)buf = 0;
                _os_log_impl( &dword_0,  v110,  OS_LOG_TYPE_INFO,  "🔄 Transition aborted: waiting until command buffer is scheduled",  buf,  2u);
              }
            }

            else
            {
              fwrite("🔄 Transition aborted: waiting until command buffer is scheduled\n", 0x43uLL, 1uLL, __stdoutp);
            }

            uint64_t v114 = *(apr_array_header_t **)(*(void *)(v2 + 56) + 8LL);
            v114->int nelts = 0;
            uint64_t v115 = (char *)apr_array_push(v114);
            *(void *)uint64_t v115 = 0x600000008LL;
            *(_OWORD *)(v115 + _Block_object_dispose(va, 8) = 0u;
            *(_OWORD *)(v115 + 24) = 0u;
            *((void *)v115 + 5) = v205;
            *((void *)v115 + 6) = 0LL;
            *((void *)v115 + 7) = 1LL;
            goto LABEL_376;
          default:
            goto LABEL_375;
        }

        while (1)
        {
          if (s_logUsingOsLog)
          {
            uint64_t v145 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v145, OS_LOG_TYPE_INFO))
            {
              id v146 = "Postcapture";
              uint64_t v147 = "Inactive";
              unint64_t v148 = "Active";
              switch((int)v208)
              {
                case 0:
                  break;
                case 1:
                  uint64_t v147 = "Active";
                  unint64_t v148 = "Precapture";
                  break;
                case 2:
                  uint64_t v147 = "Precapture";
                  unint64_t v148 = "Capture";
                  break;
                case 3:
                  uint64_t v147 = "Capture";
                  unint64_t v148 = "Postcapture";
                  break;
                case 4:
                  goto LABEL_311;
                default:
                  id v146 = "UNKNOWN";
LABEL_311:
                  uint64_t v147 = v146;
                  unint64_t v148 = "UNKNOWN";
                  break;
              }

              *(_DWORD *)uint64_t v215 = 136315650;
              *(void *)int v216 = v147;
              *(_WORD *)&v216[8] = 2080;
              uint64_t v217 = v148;
              uint64_t v218 = 1024;
              v219 = v143;
              _os_log_impl(&dword_0, v145, OS_LOG_TYPE_INFO, "%s--🛡️ --%s Condition #%d", v215, 0x1Cu);
            }
          }

          else
          {
            unint64_t v149 = "Postcapture";
            __int128 v150 = "Inactive";
            uint64_t v151 = "Active";
            switch((int)v208)
            {
              case 0:
                break;
              case 1:
                __int128 v150 = "Active";
                uint64_t v151 = "Precapture";
                break;
              case 2:
                __int128 v150 = "Precapture";
                uint64_t v151 = "Capture";
                break;
              case 3:
                __int128 v150 = "Capture";
                uint64_t v151 = "Postcapture";
                break;
              case 4:
                goto LABEL_307;
              default:
                unint64_t v149 = "UNKNOWN";
LABEL_307:
                __int128 v150 = v149;
                uint64_t v151 = "UNKNOWN";
                break;
            }

            fprintf(__stdoutp, "%s--🛡️ --%s Condition #%d\n", v150, v151, v143);
          }

          uint64_t v152 = (int *)(*(void *)(*(void *)(*(void *)v210 + 8LL) + 24LL) + v144);
          uint64_t v154 = *v152;
          uint64_t v153 = v152[1];
          uint64_t v155 = *((void *)v152 + 1);
          uint64_t v156 = *((void *)v152 + 2);
          uint64_t v157 = *((void *)v152 + 3);
          uint64_t v158 = *((void *)v152 + 4);
          uint64_t v159 = *((void *)v152 + 5);
          uint64_t v213 = *((unsigned __int8 *)v152 + 48);
          v211 = v152[15];
          v212 = v152[14];
          if (s_logUsingOsLog)
          {
            uint64_t v160 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v160, OS_LOG_TYPE_INFO))
            {
              uint64_t v161 = "Instant";
              *(_DWORD *)uint64_t v215 = 136315138;
              *(void *)int v216 = v161;
              _os_log_impl(&dword_0, v160, OS_LOG_TYPE_INFO, "    type: %s", v215, 0xCu);
            }
          }

          else
          {
            uint64_t v162 = "Instant";
            fprintf(__stdoutp, "    type: %s\n", v162);
          }

          if (s_logUsingOsLog)
          {
            uint64_t v163 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v163, OS_LOG_TYPE_INFO))
            {
              uint64_t v164 = "None";
              *(_DWORD *)uint64_t v215 = 136315138;
              *(void *)int v216 = v164;
              _os_log_impl(&dword_0, v163, OS_LOG_TYPE_INFO, "    object: %s", v215, 0xCu);
            }

            if (!v155) {
              goto LABEL_335;
            }
          }

          else
          {
            __int128 v165 = "None";
            fprintf(__stdoutp, "    object: %s\n", v165);
            if (!v155) {
              goto LABEL_335;
            }
          }

          if (!s_logUsingOsLog)
          {
            fprintf(__stdoutp, "    CAMetalLayer stream ref: %llu\n", v155);
            if (!v156) {
              goto LABEL_342;
            }
            goto LABEL_336;
          }

          uint64_t v166 = (os_log_s *)gt_tagged_log(0LL);
          if (os_log_type_enabled(v166, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)uint64_t v215 = 134217984;
            *(void *)int v216 = v155;
            _os_log_impl(&dword_0, v166, OS_LOG_TYPE_INFO, "    CAMetalLayer stream ref: %llu", v215, 0xCu);
          }

LABEL_335:
          if (!v156) {
            goto LABEL_342;
          }
LABEL_336:
          if (s_logUsingOsLog)
          {
            __int128 v167 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v167, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)uint64_t v215 = 134217984;
              *(void *)int v216 = v156;
              _os_log_impl(&dword_0, v167, OS_LOG_TYPE_INFO, "    MTLCaptureScope stream ref: %llu", v215, 0xCu);
            }
          }

          else
          {
            fprintf(__stdoutp, "    MTLCaptureScope stream ref: %llu\n", v156);
          }

LABEL_342:
          if (!v157) {
            goto LABEL_346;
          }
          if (s_logUsingOsLog)
          {
            uint64_t v168 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v168, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)uint64_t v215 = 134217984;
              *(void *)int v216 = v157;
              _os_log_impl(&dword_0, v168, OS_LOG_TYPE_INFO, "    MTLDevice stream ref: %llu", v215, 0xCu);
            }

LABEL_346:
            if (v158) {
              goto LABEL_347;
            }
            goto LABEL_353;
          }

          fprintf(__stdoutp, "    MTLDevice stream ref: %llu\n", v157);
          if (v158)
          {
LABEL_347:
            if (s_logUsingOsLog)
            {
              __int128 v169 = (os_log_s *)gt_tagged_log(0LL);
              if (os_log_type_enabled(v169, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)uint64_t v215 = 134217984;
                *(void *)int v216 = v158;
                _os_log_impl(&dword_0, v169, OS_LOG_TYPE_INFO, "    MTLCommandQueue stream ref: %llu", v215, 0xCu);
              }
            }

            else
            {
              fprintf(__stdoutp, "    MTLCommandQueue stream ref: %llu\n", v158);
            }
          }

LABEL_353:
          if (v159)
          {
            if (s_logUsingOsLog)
            {
              uint64_t v170 = (os_log_s *)gt_tagged_log(0LL);
              if (os_log_type_enabled(v170, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)uint64_t v215 = 134217984;
                *(void *)int v216 = v159;
                _os_log_impl(&dword_0, v170, OS_LOG_TYPE_INFO, "    MTLCommandBuffer stream ref: %llu", v215, 0xCu);
              }
            }

            else
            {
              fprintf(__stdoutp, "    MTLCommandBuffer stream ref: %llu\n", v159);
            }
          }

          if (v213)
          {
            if (s_logUsingOsLog)
            {
              __int128 v171 = (os_log_s *)gt_tagged_log(0LL);
              if (os_log_type_enabled(v171, OS_LOG_TYPE_INFO))
              {
                *(_WORD *)uint64_t v215 = 0;
                _os_log_impl(&dword_0, v171, OS_LOG_TYPE_INFO, "    MTLCommandBuffer is capturing", v215, 2u);
              }
            }

            else
            {
              fwrite("    MTLCommandBuffer is capturing\n", 0x22uLL, 1uLL, __stdoutp);
            }
          }

          if (s_logUsingOsLog)
          {
            __int128 v172 = (os_log_s *)gt_tagged_log(0LL);
            if (os_log_type_enabled(v172, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)uint64_t v215 = 67109376;
              *(_DWORD *)int v216 = v211;
              *(_WORD *)&v216[4] = 1024;
              *(_DWORD *)&v216[6] = v212;
              _os_log_impl(&dword_0, v172, OS_LOG_TYPE_INFO, "    Hit count: %u/%u", v215, 0xEu);
            }
          }

          else
          {
            fprintf(__stdoutp, "    Hit count: %u/%u\n", v211, v212);
          }

          v144 += 64LL;
          ++v143;
          if (v209 == v144) {
            goto LABEL_368;
          }
        }
      }
    }

    break;
  }

const char *GTCaptureObjectTypeAsString(int a1)
{
  else {
    return (&off_20DAD0)[a1 - 1];
  }
}

void GTCaptureBoundaryTracker_commandBufferHandlerBegin()
{
  uint64_t v0 = (unsigned int *)(boundaryTrackerInstance + 92);
  do
    unsigned int v1 = __ldaxr(v0);
  while (__stlxr(v1 + 1, v0));
}

void GTCaptureBoundaryTracker_commandBufferHandlerEnd()
{
  uint64_t v0 = (unsigned int *)(boundaryTrackerInstance + 92);
  do
    unsigned int v1 = __ldaxr(v0);
  while (__stlxr(v1 - 1, v0));
}

BOOL GTCaptureBoundaryTracker_isCaptureActive()
{
  return *(_DWORD *)(boundaryTrackerInstance + 20) != 0;
}

BOOL GTCaptureBoundaryTracker_isCaptureRecordingData()
{
  return (*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) == 2;
}

const char *GTCaptureTriggerTypeAsString(int a1)
{
  else {
    return (&off_20DB58)[a1 - 1];
  }
}

BOOL GTEventTracker_isBlocked(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  entry = find_entry(*(void *)(a1 + 56), &v5, 8uLL, 0LL);
  return *entry && (uint64_t v3 = *(void *)(*entry + 32LL)) != 0 && *(_DWORD *)(v3 + 12) != 0;
}

uint64_t EventValueCompare(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

void *GTEventTracker_make(uint64_t a1, uint64_t a2, uint64_t a3, apr_pool_t *p)
{
  __int128 v8 = apr_palloc(p, 0x50uLL);
  uint64_t v9 = v8;
  if (v8)
  {
    v8[3] = 0u;
    _OWORD v8[4] = 0u;
    v8[1] = 0u;
    _OWORD v8[2] = 0u;
    _OWORD *v8 = 0u;
  }

  *(void *)__int128 v8 = apr_hash_make(p);
  v9[1] = apr_hash_make(p);
  v9[3] = apr_hash_make(p);
  v9[2] = apr_hash_make(p);
  v9[4] = a1;
  v9[5] = a2;
  v9[6] = apr_hash_make(p);
  v9[7] = apr_hash_make(p);
  v9[8] = a3;
  v9[9] = p;
  return v9;
}

_OWORD *GTEventTracker_makeFrom(uint64_t a1)
{
  uint64_t v2 = *(apr_pool_t **)(a1 + 72);
  uint64_t v3 = apr_palloc(v2, 0x50uLL);
  uint64_t v4 = v3;
  if (v3)
  {
    v3[3] = 0u;
    v3[4] = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    _OWORD *v3 = 0u;
  }

  *((void *)v3 + 1) = apr_hash_make(v2);
  *((void *)v4 + 7) = apr_hash_make(v2);
  *(void *)uint64_t v4 = *(void *)a1;
  v4[1] = *(_OWORD *)(a1 + 16);
  v4[2] = *(_OWORD *)(a1 + 32);
  *((void *)v4 + 6) = *(void *)(a1 + 48);
  *((void *)v4 + _Block_object_dispose(va, 8) = *(void *)(a1 + 64);
  *((void *)v4 + 9) = v2;
  return v4;
}

void GTEventTracker_processFunction(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 8);
  if (v4 <= -15491)
  {
    if (v4 <= -15976)
    {
      if ((v4 + 16343) >= 2)
      {
        if (v4 != -15991)
        {
          int v5 = -15990;
          goto LABEL_10;
        }

        goto LABEL_24;
      }

LABEL_24:
    unint64_t v12 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *(void *)(a1 + 40));
    uint64_t v13 = *((void *)v12 + 1);
    unint64_t v14 = *(void *)a2;
    unint64_t v15 = *((void *)v12 + 2);
    uint64_t v35 = *(void *)v12;
    unint64_t v16 = (uint64_t *)apr_palloc(*(apr_pool_t **)(a1 + 72), 8uLL);
    uint64_t *v16 = (uint64_t)GTEventTracker_eventKey(*(uint64_t **)(a1 + 64), v13, v14);
    uint64_t v17 = apr_palloc(*(apr_pool_t **)(a1 + 72), 8uLL);
    *uint64_t v17 = v13;
    apr_hash_set(*(apr_hash_t **)a1, v17, 8LL, v16);
    uint64_t v18 = *find_entry(*(void *)(a1 + 24), v16, 8uLL, 0LL);
    if (!v18 || (__int128 v19 = *(unint64_t **)(v18 + 32)) == 0LL)
    {
      __int128 v19 = (unint64_t *)apr_palloc(*(apr_pool_t **)(a1 + 72), 8uLL);
      *__int128 v19 = -1LL;
      apr_hash_set(*(apr_hash_t **)(a1 + 24), v16, 8LL, v19);
    }

    if (*v19 > v15) {
      *__int128 v19 = v15;
    }
    uint64_t v20 = *find_entry(*(void *)(a1 + 48), &v35, 8uLL, 0LL);
    if (v20)
    {
      __int128 v21 = *(_BYTE **)(v20 + 32);
      if (v21)
      {
        uint64_t v22 = *find_entry(*(void *)(a1 + 8), v16, 8uLL, 0LL);
        __int128 v23 = v22 ? *(unint64_t **)(v22 + 32) : 0LL;
        entry = find_entry(*(void *)(a1 + 16), v16, 8uLL, 0LL);
        if (*entry)
        {
          uint64_t v26 = *(void *)(*entry + 32LL);
          if (v26)
          {
            if (*(int *)(v26 + 12) >= 1)
            {
              unint64_t v27 = **(void **)(v26 + 24);
              BOOL v28 = v27 == *v19;
              if (v27 >= *v19) {
                unint64_t v29 = *v19;
              }
              else {
                unint64_t v29 = v27 - 1;
              }
              if (v28) {
                unint64_t v29 = *v19 - 1;
              }
              if (v29 < v15 && (!v23 || *v23 < v15))
              {
                uint64_t v30 = *find_entry(*(void *)(a1 + 56), v21, 8uLL, 0LL);
                if (!v30 || (uint64_t v31 = *(apr_array_header_t **)(v30 + 32)) == 0LL)
                {
                  uint64_t v31 = apr_array_make(*(apr_pool_t **)(a1 + 72), 4, 24);
                  apr_hash_set(*(apr_hash_t **)(a1 + 56), v21, 8LL, v31);
                }

                uint64_t v32 = *(void *)v21;
                uint64_t v33 = *v16;
                __int128 v34 = apr_array_push(v31);
                *__int128 v34 = v32;
                v34[1] = v33;
                v34[2] = v15;
              }
            }
          }
        }
      }
    }

    return;
  }

  switch(v4)
  {
    case -15490:
LABEL_33:
      uint64_t v24 = (uint64_t *)GTTraceFunc_argumentBytesWithMap( (void *)a2,  *(unsigned __int8 *)(a2 + 13),  *(void *)(a1 + 40));
      unint64_t v8 = *(void *)a2;
      uint64_t v9 = *v24;
      unint64_t v10 = v24[1];
      goto LABEL_34;
    case -15340:
LABEL_19:
      __int128 v7 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *(void *)(a1 + 40));
      unint64_t v8 = *(void *)a2;
      uint64_t v9 = *((void *)v7 + 1);
      unint64_t v10 = *((void *)v7 + 2);
LABEL_34:
      GTEventTracker_processSignal(a1, v9, v8, v10);
      return;
    case -15339:
      goto LABEL_24;
  }

        uint64_t v39 = 0LL;
        unsigned int v40 = v36 | (unint64_t)(v38 << 32);
LABEL_25:
        uint64_t v41 = v35 + 64;
        while (v35 && (*(_BYTE *)(v41 + ((uint64_t)(HIDWORD(v40) - (int)v40) << 6) + 15) & 8) != 0)
        {
          uint64_t v42 = v41 + ((uint64_t)(HIDWORD(v40) - (int)v40) << 6);
          uint64_t v43 = GetFuncEnumConstructorType(*(_DWORD *)(v42 + 8));
          if (IsCommandEncoder(v43))
          {
            bzero(v64, 0x2B90uLL);
            GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v64, (uint64_t *)v42, v58);
            v39 += commandEncoder_processStream_((uint64_t)&v57, v64[1], v39);
          }

          uint64_t v44 = atomic_load((unsigned int *)(v35 + 4));
          uint64_t v45 = v40 + (v44 >> 6);
          __int128 v46 = (HIDWORD(v40) + 1);
          unsigned int v40 = (v46 << 32) | v40;
          if ((_DWORD)v46 == v45 - 1)
          {
            unsigned int v40 = (v46 << 32) | v46;
            uint64_t v35 = *(void *)(v35 + 40);
            goto LABEL_25;
          }
        }

        uint64_t v47 = v60;
        uint64_t v48 = pool;
        BOOL v28 = FilterArgumentBufferAccess(v60, v32, *(int *)(v60 + 12) - v32, pool);
        apr_pool_clear(v48);
        *(_DWORD *)(v47 + 12) = v32 + v28;
        unint64_t v29 = apr_array_push(*((apr_array_header_t **)&v60 + 1));
        *unint64_t v29 = v32;
        uint64_t v17 = a2;
        goto LABEL_33;
      }

      if (v55 == 70) {
        goto LABEL_17;
      }
    }

apr_hash_index_t *GTEventTracker_processSignal( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v8 = apr_palloc(*(apr_pool_t **)(a1 + 72), 8uLL);
  void *v8 = GTEventTracker_eventKey(*(uint64_t **)(a1 + 64), a2, a3);
  uint64_t v9 = apr_palloc(*(apr_pool_t **)(a1 + 72), 8uLL);
  *uint64_t v9 = a2;
  apr_hash_set(*(apr_hash_t **)a1, v9, 8LL, v8);
  uint64_t v10 = *find_entry(*(void *)(a1 + 8), v8, 8uLL, 0LL);
  if (v10) {
    signed int v11 = *(unint64_t **)(v10 + 32);
  }
  else {
    signed int v11 = 0LL;
  }
  uint64_t v12 = *find_entry(*(void *)(a1 + 16), v8, 8uLL, 0LL);
  if (v12)
  {
    uint64_t v13 = *(apr_array_header_t **)(v12 + 32);
    if (v11) {
      goto LABEL_6;
    }
LABEL_18:
    signed int v11 = (unint64_t *)apr_palloc(*(apr_pool_t **)(a1 + 72), 8uLL);
    *signed int v11 = 0LL;
    apr_hash_set(*(apr_hash_t **)(a1 + 8), v8, 8LL, v11);
    if (v13) {
      goto LABEL_7;
    }
    goto LABEL_19;
  }

  uint64_t v13 = 0LL;
  if (!v11) {
    goto LABEL_18;
  }
LABEL_6:
  if (v13) {
    goto LABEL_7;
  }
LABEL_19:
  uint64_t v13 = apr_array_make(*(apr_pool_t **)(a1 + 72), 4, 8);
  apr_hash_set(*(apr_hash_t **)(a1 + 16), v8, 8LL, v13);
LABEL_7:
  if (*v11 < a4) {
    *signed int v11 = a4;
  }
  int nelts = v13->nelts;
  if (!nelts)
  {
    uint64_t v22 = apr_array_push(v13);
LABEL_25:
    *uint64_t v22 = a4;
    goto LABEL_26;
  }

  if (nelts < 1)
  {
    uint64_t elts = v13->elts;
  }

  else
  {
    uint64_t elt_size = v13->elt_size;
    uint64_t elts = v13->elts;
    unsigned int v17 = v13->nelts;
    do
    {
      unsigned int v18 = v17 >> 1;
      __int128 v19 = &elts[(int)(elt_size * (v17 >> 1))];
      unint64_t v20 = *(void *)v19;
      __int128 v21 = &v19[elt_size];
      v17 += ~(v17 >> 1);
      if (v20 < a4) {
        uint64_t elts = v21;
      }
      else {
        unsigned int v17 = v18;
      }
    }

    while ((int)v17 > 0);
  }

  unint64_t v23 = (unint64_t)(elts - v13->elts) >> 3;
  if (nelts <= (int)v23 || *(void *)elts > a4)
  {
    uint64_t v22 = (void *)GTInsert(v13, v23);
    goto LABEL_25;
  }

LABEL_26:
  uint64_t v24 = *(void *)(a1 + 56);
  *(void *)(v24 + 24) = 0LL;
  *(void *)(v24 + 32) = 0LL;
  *(void *)(v24 + 16) = v24;
  *(_DWORD *)(v24 + 40) = 0;
  for (uint64_t result = apr_hash_next((apr_hash_index_t *)(v24 + 16)); result; uint64_t result = apr_hash_next(result))
  {
    uint64_t v26 = *(void *)(*((void *)result + 1) + 32LL);
    if (v26)
    {
      int v27 = *(_DWORD *)(v26 + 12);
      if (v27 >= 1)
      {
        uint64_t v28 = 0LL;
        for (uint64_t i = 0LL; i < v27; ++i)
        {
          uint64_t v30 = *(void *)(v26 + 24);
          uint64_t v31 = v30 + v28;
          if (*(void *)(v30 + v28 + 8) == *v8 && *(void *)(v31 + 16) <= a4)
          {
            uint64_t v32 = (__int128 *)(v30 + 24LL * (v27 - 1));
            __int128 v33 = *v32;
            *(void *)(v31 + 16) = *((void *)v32 + 2);
            *(_OWORD *)uint64_t v31 = v33;
            int v27 = *(_DWORD *)(v26 + 12);
            if (v27) {
              *(_DWORD *)(v26 + 12) = --v27;
            }
          }

          v28 += 24LL;
        }
      }
    }
  }

  return result;
}

  __int128 v21 = *(void *)(v4 + 48);
  uint64_t v61 = v71;
  __int128 v62 = v72;
  unsigned __int16 v63 = v73;
  uint64_t v57 = v67;
  uint64_t v58 = v68;
  __int128 v59 = v69;
  unsigned __int16 v60 = v70;
  *(_OWORD *)&info[0].numer = *(_OWORD *)buf;
  unsigned __int16 v56 = v66;
  GTMTLCaptureState_notifyUsedDataSentWithDictionary(v4, v21, info);
  uint64_t v22 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    LOWORD(info[0].numer) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v22,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CaptureSentAllMetadata",  "",  (uint8_t *)info,  2u);
  }

  unint64_t v23 = *(void **)(v4 + 104);
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:",  267LL));
  [v23 send:v24 error:0];

  GTTraceStoreDebugDescription("before transient stream cleanup", *(int **)(g_ctx + 64));
  GTTraceContextDumpEnd(started);
  uint64_t v25 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    LOWORD(info[0].numer) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v25,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Capture-StopActiveCaptureDumpContext",  "",  (uint8_t *)info,  2u);
  }

  WaitForHarvesting();
  GTMTLCaptureState_notifyAllCaptureDataSent(v4, *(void *)(v4 + 48));
  mach_timebase_info(info);
  mach_absolute_time();
  if (*(_BYTE *)(v4 + 84))
  {
    uint64_t v26 = atomic_load((unint64_t *)(v4 + 432));
    __int128 v53 = v26 != 0;
  }

  else
  {
    __int128 v53 = 0;
  }

  int v27 = (void (**)(id, id))objc_retainBlock(*(id *)(v4 + 96));
  uint64_t v28 = *(id *)(v4 + 424);
  atomic_load((unint64_t *)(v4 + 432));
  GTMTLCaptureState_close(_sharedCaptureManager);
  _sharedCaptureManager = 0LL;
  GTCaptureBoundaryTracker_reset();
  if (v27) {
    v27[2](v27, [v28 UTF8String]);
  }
  g_targetRef = 0LL;
  unint64_t v29 = atomic_load(&g_frameCount);
  uint64_t v30 = atomic_load(&g_frameOther);
  uint64_t v31 = atomic_load(&g_commitCount);
  uint64_t v32 = atomic_load(&g_commitOther);
  __int128 v33 = atomic_load(&g_resourceCount);
  __int128 v34 = atomic_load(&g_resourceDownloaded);
  uint64_t v35 = atomic_load(&g_GPUDataSize);
  uint64_t v50 = v34;
  uint64_t v51 = v35;
  uint64_t v36 = atomic_load(&g_GPUDataDownloaded);
  uint64_t v52 = v36;
  __int128 v37 = (void *)objc_opt_new(&OBJC_CLASS___GTCaptureCompletionState);
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v28));
  [v37 setArchiveURL:v38];

  uint64_t v39 = (void *)objc_opt_new(&OBJC_CLASS___GTCaptureProgress);
  [v39 setCaptureState:2];
  [v39 setCompletionState:v37];
  unsigned int v40 = (void *)objc_opt_new(&OBJC_CLASS___GTCaptureProgressStatistics);
  [v39 setStats:v40];

  uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v39 stats]);
  [v41 setFrameCount:v29];

  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v39 stats]);
  [v42 setFrameOther:v30];

  uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v39 stats]);
  [v43 setCommitCount:v31];

  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v39 stats]);
  [v44 setCommitOther:v32];

  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v39 stats]);
  [v45 setResourceCount:v33];

  __int128 v46 = (void *)objc_claimAutoreleasedReturnValue([v39 stats]);
  [v46 setResourceDownloaded:v50];

  uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v39 stats]);
  [v47 setGPUDataSize:v51];

  uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v39 stats]);
  [v48 setGPUDataDownloaded:v52];

  if (*(_BYTE *)(g_guestAppClientMTL + 129)) {
    [*(id *)(g_guestAppClientMTL + 8) notifyCaptureProgress:v39];
  }

  objc_autoreleasePoolPop(context);
  uint64_t result = GTTraceStoreDebugDescription("after dump", *(int **)(g_ctx + 64));
  if (v53) {
    return task_suspend(mach_task_self_);
  }
  return result;
}

      unint64_t v8 = apr_hash_next(v8);
    }

    while (v8);
  }

  return v7;
}

  uint64_t v25 = gt_filepath_merge(a1, "store0", a2);
  uint64_t v26 = open(v25, 0);
  if (v26 < 0) {
    return 0LL;
  }
  int v27 = v26;
  fstat(v26, &v51);
  uint64_t v28 = mmap(0LL, v51.st_size, 1, 2, v27, 0LL);
  unint64_t v29 = v51.st_size;
  close(v27);
  uint64_t v30 = apr_palloc(a2, 0x70uLL);
  uint64_t v31 = v30;
  if (v30)
  {
    v30[5] = 0u;
    v30[6] = 0u;
    v30[3] = 0u;
    v30[4] = 0u;
    v30[1] = 0u;
    v30[2] = 0u;
    *uint64_t v30 = 0u;
  }

  *(void *)uint64_t v30 = apr_pstrdup(a2, a1);
  v31[1] = a2;
  v31[2] = v8;
  v31[3] = v49.st_size;
  v31[4] = v8 + 5;
  v31[5] = v16;
  v31[6] = v20;
  v31[7] = *((void *)v8 + 1);
  v31[8] = v28;
  v31[9] = v29;
  v31[10] = apr_array_make(a2, 4, 24);
  v31[11] = apr_hash_make(a2);
  if (!apr_pool_create_ex(&newpool, a2, 0LL, 0LL))
  {
    uint64_t v32 = v31 + 12;
    __int128 v33 = newpool;
    __int128 v34 = gt_filepath_merge(a1, "metadata", newpool);
    uint64_t v35 = open(v34, 0);
    if (v35 < 0)
    {
      __int128 *v32 = 0LL;
      v31[13] = 0LL;
    }

    else
    {
      uint64_t v36 = v35;
      fstat(v35, &v51);
      __int128 v37 = (const UInt8 *)apr_palloc(v33, v51.st_size);
      uint64_t v38 = 0LL;
      uint64_t v39 = v51.st_size;
      do
      {
        else {
          unsigned int v40 = v39 - v38;
        }
        uint64_t v41 = read(v36, (void *)&v37[v38], v40);
        if (v41 == -1) {
          uint64_t v42 = 0LL;
        }
        else {
          uint64_t v42 = v41;
        }
        v38 += v42;
      }

      while (v41 != -1 && v38 != v39);
      close(v36);
      uint64_t v44 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v37, v51.st_size, kCFAllocatorNull);
      error = 0LL;
      uint64_t v45 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v44, 0LL, 0LL, &error);
      CFRelease(v44);
      if (error || (Value = (const __CFString *)CFDictionaryGetValue(v45, @"(uuid)")) == 0LL)
      {
        __int128 *v32 = 0LL;
        v31[13] = 0LL;
      }

      else
      {
        uint64_t v48 = CFUUIDCreateFromString(kCFAllocatorDefault, Value);
        *((CFUUIDBytes *)v31 + 6) = CFUUIDGetUUIDBytes(v48);
        CFRelease(v48);
      }

      CFRelease(v45);
    }

    apr_pool_destroy(v33);
  }

  apr_pool_cleanup_register(a2, v31, (apr_status_t (__cdecl *)(void *))GTCaptureArchive_cleanup, apr_pool_cleanup_null);
  return v31;
}

void *GTEventTracker_eventKey(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t result = GTMTLSMContext_getObject(a1, a2, a3);
  if (result)
  {
    int v4 = *(_DWORD *)result;
    if (*(_DWORD *)result == 76 || v4 == 61)
    {
      return (void *)(*((unsigned int *)result + 18) | 0x8000000000000000LL);
    }

    else if (v4 == 38)
    {
      return (void *)(result[1] & 0x7FFFFFFFFFFFFFFFLL);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

BOOL GTEventTracker_wasWaitSignaled(uint64_t a1, uint64_t a2)
{
  BOOL result = 0LL;
  int v5 = *(_DWORD *)(a2 + 8);
  if (v5 > -15340)
  {
    BOOL v6 = v5 == -15308;
    int v7 = -15339;
  }

  else
  {
    BOOL v6 = v5 == -15991;
    int v7 = -15749;
  }

  if (v6 || v5 == v7)
  {
    uint64_t v9 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *(void *)(a1 + 40));
    uint64_t v12 = GTEventTracker_eventKey(*(uint64_t **)(a1 + 64), *((void *)v9 + 1), *(void *)a2);
    entry = find_entry(*(void *)(a1 + 8), &v12, 8uLL, 0LL);
    return *entry && (signed int v11 = *(void **)(*entry + 32LL)) != 0LL && *v11 >= *((void *)v9 + 2);
  }

  return result;
}

BOOL GTEventTracker_isValueSignaled(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v17 = a2;
  uint64_t v5 = *find_entry(*a1, &v17, 8uLL, 0LL);
  if (!v5) {
    return 0LL;
  }
  BOOL v6 = *(_BYTE **)(v5 + 32);
  if (!v6) {
    return 0LL;
  }
  entry = find_entry(a1[2], v6, 8uLL, 0LL);
  if (!*entry) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(*entry + 32LL);
  if (!v8) {
    return 0LL;
  }
  int v9 = *(_DWORD *)(v8 + 12);
  if (v9 < 1) {
    return 0LL;
  }
  uint64_t v10 = *(char **)(v8 + 24);
  uint64_t v11 = *(int *)(v8 + 8);
  while (1)
  {
    unsigned int v12 = v9 >> 1;
    uint64_t v13 = &v10[(int)(v11 * (v9 >> 1))];
    unint64_t v14 = *(void *)v13;
    BOOL result = *(void *)v13 == a3;
    if (*(void *)v13 == a3) {
      break;
    }
    unint64_t v16 = &v13[v11];
    v9 += ~v12;
    if (v14 < a3) {
      uint64_t v10 = v16;
    }
    else {
      int v9 = v12;
    }
    if (v9 <= 0) {
      return 0LL;
    }
  }

  return result;
}

unint64_t CopyResourcesToBuffer( void *a1, void *a2, unint64_t a3, void *a4, uint64_t a5, int a6)
{
  id v39 = a1;
  id v11 = a2;
  id v12 = a4;
  id v13 = v11;
  unint64_t v14 = (char *)[v13 contents];
  if (a6 >= 1)
  {
    unint64_t v15 = v14;
    uint64_t v16 = 0LL;
    uint64_t v17 = 56LL * a6;
    while (1)
    {
      uint64_t v18 = a5 + v16;
      __int128 v19 = &v15[a3];
      __int128 v20 = *(_OWORD *)(a5 + v16);
      __int128 v21 = *(_OWORD *)(a5 + v16 + 16);
      __int128 v22 = *(_OWORD *)(a5 + v16 + 32);
      *((void *)v19 + 6) = *(void *)(a5 + v16 + 48);
      *((_OWORD *)v19 + 1) = v21;
      *((_OWORD *)v19 + 2) = v22;
      *(_OWORD *)__int128 v19 = v20;
      uint64_t v23 = (*(unsigned __int16 *)(a5 + v16 + 18) + a3 + 55) & -(uint64_t)*(unsigned __int16 *)(a5 + v16 + 18);
      int v24 = *(unsigned __int16 *)(a5 + v16 + 16);
      if (v24 == 2) {
        break;
      }
      if (v24 == 1)
      {
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a5 + v16 + 8)));
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:v25]);

        [v39 copyFromBuffer:v26 sourceOffset:*(unsigned int *)(a5 + v16 + 24) toBuffer:v13 destinationOffset:v23 size:*(unsigned int *)(a5 + v16 + 20)];
LABEL_7:
      }

      a3 = (v23 + *(unsigned int *)(a5 + v16 + 20) + 7) & 0xFFFFFFFFFFFFFFF8LL;
      v16 += 56LL;
      if (v17 == v16) {
        goto LABEL_9;
      }
    }

    int v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v18 + 8)));
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:v27]);

    uint64_t v28 = *(unsigned __int16 *)(v18 + 36);
    uint64_t v29 = *(unsigned __int16 *)(v18 + 38);
    uint64_t v30 = *(unsigned int *)(v18 + 40);
    uint64_t v31 = *(unsigned __int16 *)(v18 + 44);
    uint64_t v32 = *(unsigned __int16 *)(v18 + 46);
    uint64_t v33 = *(unsigned __int16 *)(v18 + 24);
    uint64_t v34 = *(unsigned __int8 *)(v18 + 26);
    uint64_t v35 = *(unsigned int *)(v18 + 48);
    uint64_t v36 = *(unsigned int *)(v18 + 52);
    uint64_t v37 = *(unsigned __int8 *)(v18 + 27);
    v41[0] = *(unsigned int *)(v18 + 32);
    v41[1] = v28;
    void v41[2] = v29;
    v40[0] = v30;
    v40[1] = v31;
    v40[2] = v32;
    [v39 copyFromTexture:v26 sourceSlice:v33 sourceLevel:v34 sourceOrigin:v41 sourceSize:v40 toBuffer:v13 destinationOffset:v23 destinationBytesPerRow:v35  destinationBytesPerImage:v36 options:v37];
    goto LABEL_7;
  }

id CreateBuffer(void *a1, NSUInteger a2, char *a3)
{
  id v5 = a1;
  NSUInteger v6 = NSRoundUpToMultipleOfPageSize(a2);
  LODWORD(a3) = mkstemp(a3);
  ftruncate((int)a3, v6);
  int v7 = mmap(0LL, v6, 2, 1, (int)a3, 0LL);
  close((int)a3);
  id v8 = [v5 newBufferWithBytesNoCopy:v7 length:v6 options:262401 deallocator:&__block_literal_global_3408];

  return v8;
}

void DownloadNewArchiveRequests(void *a1, uint64_t a2, uint64_t a3)
{
  id v58 = a1;
  int v4 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  *(int *)(a2 + 12));
  apr_pool_create_ex(&newpool, 0LL, 0LL, 0LL);
  uint64_t v57 = newpool;
  id v5 = apr_array_make(newpool, *(_DWORD *)(a2 + 12), 56);
  NSUInteger v6 = v4;
  int v7 = v6;
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v8 = 0LL;
    int v9 = &CACurrentMediaTime_ptr;
    unsigned __int16 v60 = v5;
    uint64_t v61 = v6;
    uint64_t v59 = a2;
    while (1)
    {
      uint64_t v10 = *(void *)(a2 + 24);
      uint64_t v11 = v10 + 88 * v8;
      id v12 = *(id *)v11;
      uint64_t v64 = (int8x16_t *)(v11 + 8);
      id v13 = (void *)objc_claimAutoreleasedReturnValue([v9[238] numberWithUnsignedLongLong:*(void *)(v11 + 8)]);
      -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v12, v13);

      unsigned int v14 = *(unsigned __int8 *)(v11 + 46);
      if (v14 <= 0x4F)
      {
        if (v14 == 22)
        {
          uint64_t v23 = (char *)apr_array_push(v5);
          uint64_t v24 = *(void *)(v10 + 88 * v8 + 48);
          uint64_t v25 = *(void *)(v10 + 88 * v8 + 56);
          *(int8x16_t *)uint64_t v23 = vextq_s8(*v64, *v64, 8uLL);
          *((_DWORD *)v23 + 4) = 262145;
          *((_DWORD *)v23 + 5) = v25;
          *((_DWORD *)v23 + 6) = v24;
          *(void *)(v23 + 2_Block_object_dispose(va, 8) = 0LL;
          *(void *)(v23 + 44) = 0LL;
          *(void *)(v23 + 36) = 0LL;
          *((_DWORD *)v23 + 13) = 0;
        }

        else if (v14 == 57)
        {
          id v15 = v12;
          unsigned int v16 = [v15 size];
          id v17 = v12;
          uint64_t v18 = v10 + 88 * v8;
          GTMTLCreateIndirectCommandEncoder((uint64_t)&v71, v18 + 48);
          __int128 v19 = (char *)apr_array_push(v5);
          int v20 = v77 * v16;
          int v9 = &CACurrentMediaTime_ptr;
          __int128 v69 = *(_OWORD *)(v18 + 48);
          __int128 v21 = v69;
          uint64_t v22 = *(void *)(v18 + 64);
          id v12 = v17;
          uint64_t v70 = v22;
          *(int8x16_t *)__int128 v19 = vextq_s8(*v64, *v64, 8uLL);
          *((_DWORD *)v19 + 4) = 524291;
          *((_DWORD *)v19 + 5) = v20;
          *((void *)v19 + 5) = v22;
          *(_OWORD *)(v19 + 24) = v21;
        }

        goto LABEL_23;
      }

      if (v14 != 80)
      {
        if (v14 == 86) {
          ProcessIOSurfaceTextureRequest(v5, v12, v10 + 88 * v8);
        }
        goto LABEL_23;
      }

      uint64_t v26 = v7;
      int v27 = v5;
      id v28 = v12;
      unsigned int v66 = [v28 isShareable];
      unsigned int v67 = [v28 isFramebufferOnly] | v66;

      if ((v67 & 1) != 0) {
        goto LABEL_14;
      }
      ProcessIOSurfaceTextureRequest(v27, v28, v10 + 88 * v8);
LABEL_22:

      id v5 = v27;
      int v7 = v26;
LABEL_23:
    }

LABEL_14:
    id v29 = v28;
    uint64_t v30 = objc_claimAutoreleasedReturnValue([v29 device]);
    id v31 = [v29 pixelFormat];
    int8x16_t v78 = 0uLL;
    GTMTLPixelFormatGetInfoForDevice((uint64_t)v31, (uint64_t)&v71);
    unint64_t v32 = 0LL;
    if ((v72 & 0x2000) != 0)
    {
      v78.i64[0] = 4LL;
      unint64_t v32 = 4LL;
    }

    uint64_t v63 = v8;
    __int128 v62 = (void *)v30;
    if ((~(_DWORD)v72 & 0x60) != 0)
    {
      uint64_t v33 = 1LL;
    }

    else
    {
      int8x16_t v78 = vorrq_s8((int8x16_t)vdupq_n_s64(v32), (int8x16_t)xmmword_1CA4A0);
      uint64_t v33 = 2LL;
    }

    [v29 width];
    [v29 height];
    [v29 depth];
    id v65 = [v29 sampleCount];
    uint64_t v34 = 0LL;
    uint64_t v35 = (__int16 *)(v10 + 88 * v63 + 48);
    __int16 v36 = *(_WORD *)(v11 + 50);
    do
    {
      uint64_t v37 = v78.i64[v34];
      GTMTLGetTextureLevelInfoForDeviceWithOptions((uint64_t)v31, (uint64_t)v65, (uint64_t)&v71);
      __int16 v38 = *v35;
      id v39 = (int8x16_t *)apr_array_push(v60);
      __int32 v40 = v76;
      __int32 v41 = v71;
      __int16 v42 = v72;
      __int16 v43 = v74;
      __int16 v44 = v73;
      *id v39 = vextq_s8(*v64, *v64, 8uLL);
      v39[1].i16[0] = 2;
      v39[1].i16[1] = v43;
      v39[1].i32[1] = v40;
      int32x2_t v45 = vmovn_s64(v75);
      v39[1].i16[4] = v38;
      v39[1].i8[10] = v36;
      v39[1].i8[11] = v37;
      v39[1].i8[12] = v34;
      v39[1].i8[13] = 0;
      v39[1].i16[7] = 0;
      v39[2].i64[0] = 0LL;
      v39[2].i32[2] = v41;
      v39[2].i16[6] = v42;
      v39[2].i16[7] = v44;
      *(int32x2_t *)v39[3].i8 = v45;
      ++v34;
    }

    while (v33 != v34);

    uint64_t v26 = v61;
    int v27 = v60;
    a2 = v59;
    uint64_t v8 = v63;
    int v9 = &CACurrentMediaTime_ptr;
    goto LABEL_22;
  }

LABEL_27:
  qsort(v5->elts, v5->nelts, v5->elt_size, (int (__cdecl *)(const void *, const void *))CompareRequestsByDescendingSize);
  uint64_t nelts = v5->nelts;
  if ((int)nelts < 1)
  {
    NSUInteger v47 = 0LL;
  }

  else
  {
    NSUInteger v47 = 0LL;
    uint64_t v48 = (unsigned int *)(v5->elts + 20);
    do
    {
      uint64_t v49 = (*((unsigned __int16 *)v48 - 1) + v47 + 55) & -(uint64_t)*((unsigned __int16 *)v48 - 1);
      unsigned int v50 = *v48;
      v48 += 14;
      NSUInteger v47 = (v50 + v49 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      --nelts;
    }

    while (nelts);
  }

  uint64_t v51 = gt_filepath_merge(*(const char **)(a3 + 64), "gttrace-downloadXXXXXX", v57);
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v58 device]);
  id Buffer = CreateBuffer(v52, v47, v51);
  uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(Buffer);

  unsigned int v55 = (void *)objc_claimAutoreleasedReturnValue([v58 blitCommandEncoder]);
  CopyResourcesToBuffer(v55, v54, 0LL, v7, (uint64_t)v5->elts, v5->nelts);
  [v55 endEncoding];
  apr_pool_destroy(v57);
}

  v4[102] = 0LL;
  GTCaptureBoundaryTracker_reset();
  int32x2_t v45 = (void *)objc_opt_new(&OBJC_CLASS___GTCaptureProgress);
  [v45 setCaptureState:2];
  __int128 v46 = (void *)objc_opt_new(&OBJC_CLASS___GTCaptureCompletionState);
  [v45 setCompletionState:v46];

  NSUInteger v47 = (void *)objc_opt_new(&OBJC_CLASS___GTCaptureProgressStatistics);
  [v45 setStats:v47];

  if (*(_BYTE *)(g_guestAppClientMTL + 129)) {
    [*(id *)(g_guestAppClientMTL + 8) notifyCaptureProgress:v45];
  }
  if (v29) {
    v29[2](v29, 0LL);
  }
}

      uint64_t v30 = 0LL;
LABEL_29:
      GTTraceFuncToFbuf(a1, a2, v30, 0LL);
      WriteGTMTLSMTexture_properties(a1, v17, v21, v7);
      WriteGTMTLSMTexture_textureViews(a1, a2, v17);
      id v31 = *a1;
      unint64_t v32 = a1[1];
      *(void *)(v32 + 16) = 0LL;
      *(void *)(v32 + 24) = 0LL;
      *(void *)(v32 + _Block_object_dispose(va, 8) = 0LL;
      *(_DWORD *)(v32 + 32) = 70;
      *(_DWORD *)(v32 + 36) = 67;
      *(void *)unint64_t v32 = 0xFFFFD00800000028LL;
      *(void *)(v32 + 40) = v31;
      *(_DWORD *)unint64_t v32 = 48;
      uint64_t v33 = (unsigned int *)a1[1];
      uint64_t v34 = *v33;
      if ((*((_BYTE *)v33 + 33) & 0x10) != 0)
      {
        __int16 v36 = (unsigned int *)a1[1];
        uint64_t v35 = *v33;
        do
        {
          __int16 v36 = (unsigned int *)((char *)v36 + v34);
          uint64_t v34 = *v36;
          v35 += v34;
        }

        while ((*((_BYTE *)v36 + 33) & 0x20) == 0);
      }

      else
      {
        uint64_t v35 = *v33;
      }

      fbstream_write(a1[3], (uint64_t)v33, v35);
    }
  }

  uint64_t v37 = *a1;
  __int16 v38 = a1[1];
  *(void *)(v38 + 16) = 0LL;
  *(void *)(v38 + 24) = 0LL;
  *(void *)(v38 + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(v38 + 32) = 70;
  *(_DWORD *)(v38 + 36) = 67;
  *(void *)__int16 v38 = 0xFFFFD00800000028LL;
  *(void *)(v38 + 40) = v37;
  *(_DWORD *)__int16 v38 = 48;
  id v39 = (unsigned int *)a1[1];
  __int32 v40 = *v39;
  if ((*((_BYTE *)v39 + 33) & 0x10) != 0)
  {
    __int16 v42 = (unsigned int *)a1[1];
    __int32 v41 = *v39;
    do
    {
      __int16 v42 = (unsigned int *)((char *)v42 + v40);
      __int32 v40 = *v42;
      v41 += v40;
    }

    while ((*((_BYTE *)v42 + 33) & 0x20) == 0);
  }

  else
  {
    __int32 v41 = *v39;
  }

  fbstream_write(a1[3], (uint64_t)v39, v41);
}

size_t ProcessIOSurfaceTextureRequest(apr_array_header_t *a1, void *a2, uint64_t a3)
{
  int v4 = (__IOSurface *)[a2 iosurface];
  size_t PlaneCount = IOSurfaceGetPlaneCount(v4);
  size_t v6 = 0LL;
  if (PlaneCount <= 1) {
    uint64_t v7 = 1LL;
  }
  else {
    uint64_t v7 = PlaneCount;
  }
  do
  {
    int HeightOfPlane = IOSurfaceGetHeightOfPlane(v4, v6);
    int BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(v4, v6);
    uint64_t v10 = apr_array_push(a1);
    uint64_t v11 = *(void *)(a3 + 8);
    uint64_t v12 = *(void *)(a3 + 16);
    size_t result = IOSurfaceGetWidthOfPlane(v4, v6);
    *uint64_t v10 = v12;
    v10[1] = v11;
    *((_DWORD *)v10 + 4) = 262146;
    *((_DWORD *)v10 + 5) = BytesPerRowOfPlane * HeightOfPlane;
    *((_DWORD *)v10 + 6) = 0;
    *((_BYTE *)v10 + 2_Block_object_dispose(va, 8) = v6;
    *((_BYTE *)v10 + 29) = 0;
    *((_WORD *)v10 + 15) = 0;
    v10[4] = 0LL;
    *((_DWORD *)v10 + 10) = result;
    *((_WORD *)v10 + 22) = HeightOfPlane;
    *((_WORD *)v10 + 23) = 1;
    ++v6;
    *((_DWORD *)v10 + 12) = BytesPerRowOfPlane;
    *((_DWORD *)v10 + 13) = BytesPerRowOfPlane * HeightOfPlane;
  }

  while (v7 != v6);
  return result;
}

uint64_t CompareRequestsByDescendingSize(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 20);
  unsigned int v3 = *(_DWORD *)(a2 + 20);
  BOOL v4 = v2 > v3;
  LODWORD(v5) = v2 != v3;
  if (v4) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v5;
  }
  if (!(_DWORD)v5)
  {
    unsigned int v6 = *(unsigned __int16 *)(a1 + 18);
    unsigned int v7 = *(unsigned __int16 *)(a2 + 18);
    BOOL v4 = v6 > v7;
    LODWORD(v5) = v6 != v7;
    if (v4) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v5;
    }
  }

  return v5;
}

void GTResourceTrackerProcessResourceUse(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a2 + 8);
  if (v6 > -15757)
  {
    if (v6 <= -15367)
    {
      if (v6 <= -15525)
      {
        if (v6 > -15599)
        {
          switch(v6)
          {
            case -15598:
              __int128 v103 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v18 = a1[1];
              uint64_t v19 = *((void *)v103 + 1);
              uint64_t v20 = *a1;
              uint64_t v21 = a1[2];
              int v22 = 44;
              goto LABEL_415;
            case -15597:
              __int128 v104 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v105 = a1[2];
              __int128 v106 = GTTraceFunc_argumentBytesWithMap((void *)a2, v104[24], a1[1]);
              uint64_t v107 = *((void *)v104 + 2);
              if (v107)
              {
                __int128 v108 = (uint64_t *)v106;
                uint64_t v110 = *a1;
                uint64_t v109 = a1[1];
                do
                {
                  uint64_t v112 = *v108++;
                  uint64_t v111 = v112;
                  if (v112) {
                    GTResourceTrackerUsingResource(v105, 44, v111, v110, v109);
                  }
                  --v107;
                }

                while (v107);
              }

              break;
            case -15592:
            case -15591:
LABEL_47:
              uint64_t v35 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v36 = v35[1];
              uint64_t v37 = a1;
              int v38 = 22;
LABEL_214:
              GTResourceTrackerResourceRead(v37, v38, v36, a3);
              uint64_t v26 = v35[3];
              goto LABEL_237;
            case -15588:
              goto LABEL_236;
            case -15583:
LABEL_93:
              id v65 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v18 = a1[1];
              uint64_t v19 = *((void *)v65 + 1);
              uint64_t v20 = *a1;
              uint64_t v21 = a1[2];
              int v22 = 60;
              goto LABEL_415;
            case -15582:
              __int128 v113 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v114 = a1[2];
              uint64_t v115 = GTTraceFunc_argumentBytesWithMap((void *)a2, v113[24], a1[1]);
              uint64_t v116 = *((void *)v113 + 2);
              if (v116)
              {
                __int128 v117 = (uint64_t *)v115;
                uint64_t v119 = *a1;
                uint64_t v118 = a1[1];
                do
                {
                  uint64_t v121 = *v117++;
                  uint64_t v120 = v121;
                  if (v121) {
                    GTResourceTrackerUsingResource(v114, 60, v120, v119, v118);
                  }
                  --v116;
                }

                while (v116);
              }

              break;
            case -15581:
LABEL_94:
              unsigned int v66 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v18 = a1[1];
              uint64_t v19 = *((void *)v66 + 1);
              uint64_t v20 = *a1;
              uint64_t v21 = a1[2];
              int v22 = 83;
              goto LABEL_415;
            case -15580:
              __int128 v122 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v123 = a1[2];
              __int128 v124 = GTTraceFunc_argumentBytesWithMap((void *)a2, v122[24], a1[1]);
              uint64_t v125 = *((void *)v122 + 2);
              if (v125)
              {
                __int128 v126 = (uint64_t *)v124;
                uint64_t v128 = *a1;
                uint64_t v127 = a1[1];
                do
                {
                  uint64_t v130 = *v126++;
                  uint64_t v129 = v130;
                  if (v130) {
                    GTResourceTrackerUsingResource(v123, 83, v129, v128, v127);
                  }
                  --v125;
                }

                while (v125);
              }

              break;
            default:
              return;
          }
        }

        else
        {
          switch(v6)
          {
            case -15647:
              __int128 v93 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              __int128 v94 = tracker_resource_get(a1, 16, *((void *)v93 + 1), a3);
              if (v94) {
                v94[4] = a3;
              }
              GTResourceTrackerUsingResource(a1[2], 22, *((void *)v93 + 2), *a1, a1[1]);
              unsigned int v87 = v93[32];
              goto LABEL_136;
            case -15646:
            case -15645:
              uint64_t v25 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              GTResourceTrackerResourceRead(a1, 16, *((void *)v25 + 1), a3);
              uint64_t v26 = *((void *)v25 + 2);
              int v27 = a1;
              int v28 = 16;
              goto LABEL_238;
            case -15644:
            case -15643:
            case -15642:
            case -15641:
            case -15640:
            case -15639:
            case -15636:
            case -15628:
            case -15627:
            case -15626:
            case -15625:
            case -15624:
              return;
            case -15638:
              __int128 v95 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              GTResourceTrackerResourceRead(a1, 16, *((void *)v95 + 1), a3);
              __int128 v96 = tracker_resource_get(a1, 16, *((void *)v95 + 2), a3);
              if (v96) {
                v96[4] = a3;
              }
              GTResourceTrackerUsingResource(a1[2], 22, *((void *)v95 + 3), *a1, a1[1]);
              unsigned int v87 = v95[40];
              goto LABEL_136;
            case -15637:
LABEL_49:
              id v39 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v18 = a1[1];
              uint64_t v19 = *((void *)v39 + 1);
              uint64_t v20 = *a1;
              uint64_t v21 = a1[2];
              int v22 = 31;
              goto LABEL_415;
            case -15635:
            case -15630:
LABEL_59:
              __int32 v41 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v18 = a1[1];
              uint64_t v19 = *((void *)v41 + 1);
              uint64_t v20 = *a1;
              uint64_t v21 = a1[2];
              int v22 = 41;
              goto LABEL_415;
            case -15634:
LABEL_90:
              uint64_t v62 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
              GTResourceTrackerUsingResourceHeap(a1, v62, a3);
              break;
            case -15633:
              __int128 v98 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              __int128 v99 = GTTraceFunc_argumentBytesWithMap((void *)a2, v98[16], a1[1]);
              uint64_t v100 = *((void *)v98 + 1);
              if (v100)
              {
                __int16 v101 = (uint64_t *)v99;
                do
                {
                  uint64_t v102 = *v101++;
                  GTResourceTrackerUsingResourceHeap(a1, v102, a3);
                  --v100;
                }

                while (v100);
              }

              break;
            case -15632:
LABEL_91:
              uint64_t v63 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              int ResourceType = GTResourceTrackerGetResourceType(*((void *)v63 + 1), *a1);
              GTResourceTrackerResourceUsage(a1, ResourceType, *((void *)v63 + 1), a3, *((_DWORD *)v63 + 4));
              break;
            case -15631:
LABEL_43:
              id v31 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              unsigned int v32 = v31[24];
LABEL_246:
              v229 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, v32, a1[1]);
              GTResourceTrackerResourceUsageArray(a1, v229, *((void *)v31 + 1), a3, *((_DWORD *)v31 + 4));
              break;
            case -15629:
              goto LABEL_236;
            case -15623:
LABEL_92:
              uint64_t v7 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
              uint64_t v8 = a1;
              int v9 = 16;
              goto LABEL_470;
            default:
              switch(v6)
              {
                case -15756:
                  uint64_t v30 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                  GTResourceTrackerUsingResource(a1[2], 31, *((void *)v30 + 1), *a1, a1[1]);
LABEL_161:
                  uint64_t v26 = *((void *)v30 + 4);
                  goto LABEL_237;
                case -15755:
                case -15754:
                case -15750:
                  goto LABEL_49;
                case -15753:
                case -15752:
                case -15751:
                  return;
                case -15749:
                  goto LABEL_129;
                default:
                  switch(v6)
                  {
                    case -15728:
                    case -15726:
                    case -15723:
                    case -15722:
LABEL_72:
                      uint64_t v7 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)a2,  *(unsigned __int8 *)(a2 + 13),  a1[1])
                           + 1);
                      goto LABEL_73;
                    default:
                      return;
                  }
              }
          }
        }
      }

      else
      {
        switch(v6)
        {
          case -15474:
LABEL_95:
            uint64_t v26 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
            goto LABEL_237;
          case -15473:
          case -15472:
          case -15471:
          case -15470:
          case -15469:
LABEL_56:
            uint64_t v26 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
            goto LABEL_57;
          case -15468:
          case -15467:
          case -15464:
          case -15463:
          case -15462:
          case -15461:
          case -15460:
          case -15444:
          case -15443:
          case -15442:
          case -15441:
          case -15440:
          case -15439:
          case -15438:
          case -15437:
          case -15436:
          case -15435:
          case -15434:
          case -15433:
          case -15432:
          case -15431:
          case -15430:
          case -15429:
          case -15428:
          case -15427:
          case -15426:
          case -15425:
          case -15424:
          case -15423:
          case -15422:
          case -15421:
          case -15420:
          case -15419:
          case -15418:
          case -15417:
          case -15416:
          case -15414:
          case -15413:
          case -15412:
          case -15411:
          case -15410:
          case -15409:
          case -15408:
          case -15407:
          case -15406:
          case -15405:
          case -15404:
          case -15403:
          case -15402:
          case -15400:
          case -15398:
          case -15390:
          case -15388:
            return;
          case -15466:
            uint64_t v10 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            uint64_t v11 = tracker_resource_get(a1, 16, *((void *)v10 + 1), a3);
            if (v11) {
              v11[4] = a3;
            }
            uint64_t v12 = GTTraceFunc_argumentBytesWithMap((void *)a2, v10[32], a1[1]);
            id v13 = (uint64_t *)(v12 + 8);
            for (uint64_t i = *(void *)v12; i; --i)
            {
              uint64_t v16 = *v13++;
              uint64_t v15 = v16;
              if (v16) {
                GTResourceTrackerResourceRead(a1, 16, v15, a3);
              }
            }

LABEL_236:
      unsigned int v222 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
      GTResourceTrackerResourceRead(a1, 16, *((void *)v222 + 1), a3);
      uint64_t v26 = *((void *)v222 + 2);
LABEL_237:
      int v27 = a1;
      int v28 = 22;
      goto LABEL_238;
    }

    if (v6 <= -15274)
    {
      if (v6 > -15283)
      {
        if (v6 == -15282)
        {
          id v146 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v147 = a1[2];
          unint64_t v148 = GTTraceFunc_argumentBytesWithMap((void *)a2, v146[24], a1[1]);
          uint64_t v149 = *((void *)v146 + 2);
          if (v149)
          {
            __int128 v150 = (uint64_t *)v148;
            uint64_t v152 = *a1;
            uint64_t v151 = a1[1];
            do
            {
              uint64_t v154 = *v150++;
              uint64_t v153 = v154;
              if (v154) {
                GTResourceTrackerUsingResource(v147, 22, v153, v152, v151);
              }
              --v149;
            }

            while (v149);
          }

          return;
        }

        int v61 = -15275;
      }

      else
      {
        if (v6 == -15287) {
          goto LABEL_236;
        }
        int v61 = -15284;
      }

      if (v6 != v61) {
        return;
      }
LABEL_104:
      uint64_t v73 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
      uint64_t v18 = a1[1];
      uint64_t v19 = *((void *)v73 + 1);
      uint64_t v20 = *a1;
      uint64_t v21 = a1[2];
      int v22 = 22;
    }

    else
    {
      if (v6 <= -15254)
      {
        if (v6 == -15273)
        {
          uint64_t v137 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v138 = a1[2];
          uint64_t v139 = GTTraceFunc_argumentBytesWithMap((void *)a2, v137[24], a1[1]);
          uint64_t v140 = *((void *)v137 + 2);
          if (v140)
          {
            id v141 = (uint64_t *)v139;
            uint64_t v143 = *a1;
            uint64_t v142 = a1[1];
            do
            {
              uint64_t v145 = *v141++;
              uint64_t v144 = v145;
              if (v145) {
                GTResourceTrackerUsingResource(v138, 22, v144, v143, v142);
              }
              --v140;
            }

            while (v140);
          }
        }

        else if (v6 == -15254)
        {
          uint64_t v72 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
          GTResourceTrackerUsingResidencySet(a1, v72);
        }

        return;
      }

      if (v6 == -15253)
      {
        uint64_t v131 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
        uint64_t v132 = GTTraceFunc_argumentBytesWithMap((void *)a2, v131[16], a1[1]);
        uint64_t v133 = *((void *)v131 + 1);
        if (v133)
        {
          unint64_t v134 = (uint64_t *)v132;
          do
          {
            uint64_t v136 = *v134++;
            uint64_t v135 = v136;
            if (v136) {
              GTResourceTrackerUsingResidencySet(a1, v135);
            }
            --v133;
          }

          while (v133);
        }

        return;
      }

      if (v6 == -15217)
      {
LABEL_129:
        uint64_t v91 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
        uint64_t v92 = a1[2];
        int v22 = GTResourceTrackerGetResourceType(*((void *)v91 + 1), *a1);
        uint64_t v19 = *((void *)v91 + 1);
        uint64_t v20 = *a1;
        uint64_t v18 = a1[1];
        uint64_t v21 = v92;
      }

      else
      {
        int v40 = -7158;
LABEL_112:
        if (v6 != v40) {
          return;
        }
LABEL_113:
        uint64_t v76 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
        uint64_t v77 = a1[2];
        uint64_t v19 = *(void *)v76;
LABEL_414:
        uint64_t v20 = *a1;
        uint64_t v18 = a1[1];
        uint64_t v21 = v77;
        int v22 = 2;
      }
    }

LABEL_415:
    GTResourceTrackerUsingResource(v21, v22, v19, v20, v18);
    return;
  }

  if (v6 <= -16157)
  {
    if (v6 <= -16359)
    {
      switch(v6)
      {
        case -20480:
        case -20473:
        case -20471:
        case -20470:
        case -20464:
        case -20456:
          goto LABEL_72;
        case -20479:
        case -20469:
          goto LABEL_59;
        case -20478:
        case -20477:
        case -20475:
        case -20472:
        case -20468:
        case -20467:
        case -20466:
        case -20465:
        case -20463:
        case -20462:
        case -20460:
        case -20459:
        case -20458:
          return;
        case -20476:
        case -20461:
          goto LABEL_56;
        case -20474:
          id v29 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v18 = a1[1];
          uint64_t v19 = *(void *)v29;
          uint64_t v20 = *a1;
          uint64_t v21 = a1[2];
          int v22 = 39;
          goto LABEL_415;
        case -20457:
          __int128 v90 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v18 = a1[1];
          uint64_t v19 = *(void *)v90;
          uint64_t v20 = *a1;
          uint64_t v21 = a1[2];
          int v22 = 40;
          goto LABEL_415;
        default:
          switch(v6)
          {
            case -16382:
LABEL_45:
              uint64_t v33 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v34 = v33[1];
              goto LABEL_265;
            case -16381:
LABEL_96:
              unsigned int v67 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v68 = v67[1];
              __int128 v69 = a1;
              int v70 = 22;
              goto LABEL_279;
            case -16380:
LABEL_97:
              uint64_t v71 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              GTResourceTrackerResourceRead(a1, 80, *((void *)v71 + 1), a3);
LABEL_182:
              uint64_t v26 = *((void *)v71 + 10);
              goto LABEL_237;
            case -16379:
              goto LABEL_56;
            case -16378:
              goto LABEL_95;
            case -16377:
              goto LABEL_47;
            default:
              int v89 = -16359;
LABEL_412:
              if (v6 != v89) {
                return;
              }
LABEL_413:
              v424 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v77 = a1[2];
              uint64_t v19 = *((void *)v424 + 1);
              break;
          }

          goto LABEL_414;
      }
    }

    else
    {
      switch(v6)
      {
        case -16279:
          id v17 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v18 = a1[1];
          uint64_t v19 = *((void *)v17 + 1);
          uint64_t v20 = *a1;
          uint64_t v21 = a1[2];
          int v22 = 71;
          goto LABEL_415;
        case -16278:
        case -16263:
          goto LABEL_104;
        case -16277:
          v425 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v426 = a1[2];
          v427 = GTTraceFunc_argumentBytesWithMap((void *)a2, v425[24], a1[1]);
          uint64_t v428 = *((void *)v425 + 2);
          if (v428)
          {
            v429 = (uint64_t *)v427;
            uint64_t v431 = *a1;
            uint64_t v430 = a1[1];
            do
            {
              uint64_t v433 = *v429++;
              uint64_t v432 = v433;
              if (v433) {
                GTResourceTrackerUsingResource(v426, 22, v432, v431, v430);
              }
              --v428;
            }

            while (v428);
          }

          break;
        case -16276:
        case -16261:
          goto LABEL_70;
        case -16275:
          v434 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v435 = a1[2];
          v436 = GTTraceFunc_argumentBytesWithMap((void *)a2, v434[24], a1[1]);
          uint64_t v437 = *((void *)v434 + 2);
          if (v437)
          {
            v438 = (uint64_t *)v436;
            uint64_t v440 = *a1;
            uint64_t v439 = a1[1];
            do
            {
              uint64_t v442 = *v438++;
              uint64_t v441 = v442;
              if (v442) {
                GTResourceTrackerUsingResource(v435, 80, v441, v440, v439);
              }
              --v437;
            }

            while (v437);
          }

          break;
        case -16274:
        case -16272:
        case -16259:
        case -16257:
          goto LABEL_61;
        case -16273:
          v443 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v444 = a1[2];
          v445 = GTTraceFunc_argumentBytesWithMap((void *)a2, v443[24], a1[1]);
          uint64_t v446 = *((void *)v443 + 2);
          if (v446)
          {
            v447 = (uint64_t *)v445;
            uint64_t v449 = *a1;
            uint64_t v448 = a1[1];
            do
            {
              uint64_t v451 = *v447++;
              uint64_t v450 = v451;
              if (v451) {
                GTResourceTrackerUsingResource(v444, 75, v450, v449, v448);
              }
              --v446;
            }

            while (v446);
          }

          break;
        case -16271:
          v452 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v453 = a1[2];
          v454 = GTTraceFunc_argumentBytesWithMap((void *)a2, v452[24], a1[1]);
          uint64_t v455 = *((void *)v452 + 2);
          if (v455)
          {
            v456 = (uint64_t *)v454;
            uint64_t v458 = *a1;
            uint64_t v457 = a1[1];
            do
            {
              uint64_t v460 = *v456++;
              uint64_t v459 = v460;
              if (v460) {
                GTResourceTrackerUsingResource(v453, 75, v459, v458, v457);
              }
              --v455;
            }

            while (v455);
          }

          break;
        case -16270:
        case -16269:
        case -16268:
        case -16267:
        case -16266:
        case -16265:
        case -16264:
        case -16255:
        case -16253:
        case -16252:
        case -16251:
        case -16250:
        case -16247:
        case -16246:
        case -16245:
        case -16244:
        case -16243:
        case -16242:
        case -16241:
        case -16240:
        case -16239:
        case -16238:
        case -16237:
        case -16236:
        case -16235:
        case -16234:
        case -16233:
        case -16232:
        case -16231:
        case -16230:
        case -16229:
        case -16228:
        case -16227:
        case -16226:
        case -16225:
        case -16224:
        case -16223:
        case -16222:
        case -16221:
        case -16219:
        case -16218:
          return;
        case -16262:
          v461 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v462 = a1[2];
          v463 = GTTraceFunc_argumentBytesWithMap((void *)a2, v461[24], a1[1]);
          uint64_t v464 = *((void *)v461 + 2);
          if (v464)
          {
            v465 = (uint64_t *)v463;
            uint64_t v467 = *a1;
            uint64_t v466 = a1[1];
            do
            {
              uint64_t v469 = *v465++;
              uint64_t v468 = v469;
              if (v469) {
                GTResourceTrackerUsingResource(v462, 22, v468, v467, v466);
              }
              --v464;
            }

            while (v464);
          }

          break;
        case -16260:
          v470 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v471 = a1[2];
          v472 = GTTraceFunc_argumentBytesWithMap((void *)a2, v470[24], a1[1]);
          uint64_t v473 = *((void *)v470 + 2);
          if (v473)
          {
            v474 = (uint64_t *)v472;
            uint64_t v476 = *a1;
            uint64_t v475 = a1[1];
            do
            {
              uint64_t v478 = *v474++;
              uint64_t v477 = v478;
              if (v478) {
                GTResourceTrackerUsingResource(v471, 80, v477, v476, v475);
              }
              --v473;
            }

            while (v473);
          }

          break;
        case -16258:
          v479 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v480 = a1[2];
          v481 = GTTraceFunc_argumentBytesWithMap((void *)a2, v479[24], a1[1]);
          uint64_t v482 = *((void *)v479 + 2);
          if (v482)
          {
            v483 = (uint64_t *)v481;
            uint64_t v485 = *a1;
            uint64_t v484 = a1[1];
            do
            {
              uint64_t v487 = *v483++;
              uint64_t v486 = v487;
              if (v487) {
                GTResourceTrackerUsingResource(v480, 75, v486, v485, v484);
              }
              --v482;
            }

            while (v482);
          }

          break;
        case -16256:
          v488 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v489 = a1[2];
          v490 = GTTraceFunc_argumentBytesWithMap((void *)a2, v488[24], a1[1]);
          uint64_t v491 = *((void *)v488 + 2);
          if (v491)
          {
            v492 = (uint64_t *)v490;
            uint64_t v494 = *a1;
            uint64_t v493 = a1[1];
            do
            {
              uint64_t v496 = *v492++;
              uint64_t v495 = v496;
              if (v496) {
                GTResourceTrackerUsingResource(v489, 75, v495, v494, v493);
              }
              --v491;
            }

            while (v491);
          }

          break;
        case -16254:
          v497 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v18 = a1[1];
          uint64_t v19 = *((void *)v497 + 1);
          uint64_t v20 = *a1;
          uint64_t v21 = a1[2];
          int v22 = 34;
          goto LABEL_415;
        case -16249:
        case -16248:
        case -16217:
LABEL_30:
          uint64_t v7 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 4);
          goto LABEL_469;
        case -16220:
          goto LABEL_216;
        case -16216:
          uint64_t v7 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 2);
          goto LABEL_469;
        case -16215:
          uint64_t v241 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v242 = v241[3];
          goto LABEL_467;
        case -16214:
          v498 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 80, *((void *)v498 + 1), *a1, a1[1]);
          uint64_t v18 = a1[1];
          uint64_t v21 = a1[2];
          uint64_t v19 = *((void *)v498 + 3);
          uint64_t v20 = *a1;
          goto LABEL_62;
        case -16213:
          goto LABEL_129;
        case -16212:
          goto LABEL_56;
        case -16211:
          goto LABEL_45;
        case -16210:
          goto LABEL_96;
        case -16209:
          goto LABEL_97;
        default:
          switch(v6)
          {
            case -16337:
              v499 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v18 = a1[1];
              uint64_t v19 = *((void *)v499 + 1);
              uint64_t v20 = *a1;
              uint64_t v21 = a1[2];
              int v22 = 29;
              goto LABEL_415;
            case -16336:
              goto LABEL_104;
            case -16335:
              v500 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v501 = a1[2];
              v502 = GTTraceFunc_argumentBytesWithMap((void *)a2, v500[24], a1[1]);
              uint64_t v503 = *((void *)v500 + 2);
              if (v503)
              {
                v504 = (uint64_t *)v502;
                uint64_t v506 = *a1;
                uint64_t v505 = a1[1];
                do
                {
                  uint64_t v508 = *v504++;
                  uint64_t v507 = v508;
                  if (v508) {
                    GTResourceTrackerUsingResource(v501, 22, v507, v506, v505);
                  }
                  --v503;
                }

                while (v503);
              }

              break;
            case -16334:
              goto LABEL_70;
            case -16333:
              v509 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v510 = a1[2];
              v511 = GTTraceFunc_argumentBytesWithMap((void *)a2, v509[24], a1[1]);
              uint64_t v512 = *((void *)v509 + 2);
              if (v512)
              {
                v513 = (uint64_t *)v511;
                uint64_t v515 = *a1;
                uint64_t v514 = a1[1];
                do
                {
                  uint64_t v517 = *v513++;
                  uint64_t v516 = v517;
                  if (v517) {
                    GTResourceTrackerUsingResource(v510, 80, v516, v515, v514);
                  }
                  --v512;
                }

                while (v512);
              }

              break;
            case -16332:
            case -16330:
              goto LABEL_61;
            case -16331:
              v518 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v519 = a1[2];
              v520 = GTTraceFunc_argumentBytesWithMap((void *)a2, v518[24], a1[1]);
              uint64_t v521 = *((void *)v518 + 2);
              if (v521)
              {
                v522 = (uint64_t *)v520;
                uint64_t v524 = *a1;
                uint64_t v523 = a1[1];
                do
                {
                  uint64_t v526 = *v522++;
                  uint64_t v525 = v526;
                  if (v526) {
                    GTResourceTrackerUsingResource(v519, 75, v525, v524, v523);
                  }
                  --v521;
                }

                while (v521);
              }

              break;
            case -16329:
              v527 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v528 = a1[2];
              v529 = GTTraceFunc_argumentBytesWithMap((void *)a2, v527[24], a1[1]);
              uint64_t v530 = *((void *)v527 + 2);
              if (v530)
              {
                v531 = (uint64_t *)v529;
                uint64_t v533 = *a1;
                uint64_t v532 = a1[1];
                do
                {
                  uint64_t v535 = *v531++;
                  uint64_t v534 = v535;
                  if (v535) {
                    GTResourceTrackerUsingResource(v528, 75, v534, v533, v532);
                  }
                  --v530;
                }

                while (v530);
              }

              break;
            default:
              int v89 = -16358;
              goto LABEL_412;
          }

          break;
      }
    }
  }

  else
  {
    if (v6 > -16009)
    {
      if (v6 <= -15899)
      {
        switch(v6)
        {
          case -15977:
            uint64_t v71 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            uint64_t v155 = tracker_resource_get(a1, 80, *((void *)v71 + 1), a3);
            if (v155) {
              v155[4] = a3;
            }
            goto LABEL_182;
          case -15976:
            goto LABEL_56;
          case -15975:
          case -15974:
          case -15973:
          case -15972:
          case -15971:
          case -15970:
          case -15969:
          case -15968:
          case -15965:
            return;
          case -15967:
            goto LABEL_129;
          case -15966:
            goto LABEL_90;
          case -15964:
          case -15962:
            uint64_t v7 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
            uint64_t v8 = a1;
            int v9 = 57;
            goto LABEL_470;
          case -15963:
          case -15961:
            uint64_t v74 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 57, *((void *)v74 + 1), a3);
            goto LABEL_124;
          case -15960:
          case -15958:
            uint64_t v26 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
            goto LABEL_184;
          case -15959:
            uint64_t v156 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 57, *((void *)v156 + 1), a3);
            uint64_t v26 = *((void *)v156 + 4);
LABEL_184:
            int v27 = a1;
            int v28 = 57;
            goto LABEL_238;
          default:
            switch(v6)
            {
              case -16008:
                __int128 v172 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                unsigned int v173 = v172[16];
                goto LABEL_199;
              case -16003:
                __int128 v172 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                unsigned int v173 = v172[32];
LABEL_199:
                uint64_t v174 = a1[2];
                uint64_t v175 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, v173, a1[1]);
                GTResourceTrackerUsingResourceArray(v174, 0, v175, *((void *)v172 + 1), *a1, a1[1]);
                break;
              case -15995:
              case -15994:
              case -15993:
              case -15992:
                goto LABEL_56;
              case -15991:
              case -15990:
                goto LABEL_129;
              default:
                return;
            }

            return;
        }
      }

      if (v6 > -15822)
      {
        switch(v6)
        {
          case -15792:
            uint64_t v30 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 80, *((void *)v30 + 1), a3);
            goto LABEL_161;
          case -15791:
          case -15790:
          case -15789:
          case -15788:
          case -15787:
          case -15786:
            return;
          case -15785:
          case -15781:
            goto LABEL_59;
          case -15784:
            uint64_t v161 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 80, *((void *)v161 + 1), a3);
            uint64_t v7 = *((void *)v161 + 3);
            goto LABEL_469;
          case -15783:
          case -15782:
            goto LABEL_72;
          default:
            switch(v6)
            {
              case -15821:
                goto LABEL_90;
              case -15820:
                unint64_t v224 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                uint64_t v225 = GTTraceFunc_argumentBytesWithMap((void *)a2, v224[24], a1[1]);
                uint64_t v226 = *((void *)v224 + 1);
                if (v226)
                {
                  int v227 = (uint64_t *)v225;
                  do
                  {
                    uint64_t v228 = *v227++;
                    GTResourceTrackerUsingResourceHeap(a1, v228, a3);
                    --v226;
                  }

                  while (v226);
                }

                break;
              case -15819:
                goto LABEL_91;
              case -15818:
                id v31 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                unsigned int v32 = v31[32];
                goto LABEL_246;
              default:
                return;
            }

            break;
        }

        return;
      }

      switch(v6)
      {
        case -15898:
          __int128 v176 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v177 = a1[2];
          __int128 v178 = GTTraceFunc_argumentBytesWithMap((void *)a2, v176[16], a1[1]);
          uint64_t v179 = *((void *)v176 + 1);
          if (v179)
          {
            uint64_t v180 = (uint64_t *)v178;
            uint64_t v182 = *a1;
            uint64_t v181 = a1[1];
            do
            {
              uint64_t v184 = *v180++;
              uint64_t v183 = v184;
              if (v184) {
                GTResourceTrackerUsingResource(v177, 73, v183, v182, v181);
              }
              --v179;
            }

            while (v179);
          }

          return;
        case -15897:
          double v185 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v186 = a1[2];
          uint64_t v187 = GTTraceFunc_argumentBytesWithMap((void *)a2, v185[16], a1[1]);
          uint64_t v188 = *((void *)v185 + 1);
          if (v188)
          {
            uint64_t v189 = (uint64_t *)v187;
            uint64_t v191 = *a1;
            uint64_t v190 = a1[1];
            do
            {
              uint64_t v193 = *v189++;
              uint64_t v192 = v193;
              if (v193) {
                GTResourceTrackerUsingResource(v186, 73, v192, v191, v190);
              }
              --v188;
            }

            while (v188);
          }

          return;
        case -15896:
        case -15895:
        case -15894:
        case -15893:
        case -15892:
        case -15891:
        case -15890:
        case -15889:
          return;
        case -15888:
          __int16 v194 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v18 = a1[1];
          uint64_t v19 = *((void *)v194 + 1);
          uint64_t v20 = *a1;
          uint64_t v21 = a1[2];
          int v22 = 64;
          goto LABEL_415;
        case -15887:
          uint64_t v35 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerResourceRead(a1, 80, v35[1], a3);
          uint64_t v36 = v35[2];
          uint64_t v37 = a1;
          int v38 = 80;
          goto LABEL_214;
        case -15886:
        case -15885:
          goto LABEL_59;
        default:
          if (v6 == -15878)
          {
            unsigned int v230 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 80, *((void *)v230 + 1), a3);
            uint64_t v26 = *((void *)v230 + 4);
          }

          else
          {
            if (v6 != -15877) {
              return;
            }
            int64x2_t v75 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 80, *((void *)v75 + 1), a3);
            uint64_t v26 = *((void *)v75 + 2);
          }

          break;
      }

LABEL_57:
      int v27 = a1;
      int v28 = 80;
LABEL_238:
      uint64_t v223 = tracker_resource_get(v27, v28, v26, a3);
      if (v223) {
        v223[4] = a3;
      }
      return;
    }

    if (v6 > -16088)
    {
      switch(v6)
      {
        case -16047:
        case -16043:
          goto LABEL_91;
        case -16046:
        case -16042:
          goto LABEL_43;
        case -16045:
        case -16041:
          goto LABEL_90;
        case -16044:
          uint64_t v162 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v163 = GTTraceFunc_argumentBytesWithMap((void *)a2, v162[16], a1[1]);
          uint64_t v164 = *((void *)v162 + 1);
          if (v164)
          {
            __int128 v165 = (uint64_t *)v163;
            do
            {
              uint64_t v166 = *v165++;
              GTResourceTrackerUsingResourceHeap(a1, v166, a3);
              --v164;
            }

            while (v164);
          }

          break;
        case -16040:
          __int128 v167 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v168 = GTTraceFunc_argumentBytesWithMap((void *)a2, v167[16], a1[1]);
          uint64_t v169 = *((void *)v167 + 1);
          if (v169)
          {
            uint64_t v170 = (uint64_t *)v168;
            do
            {
              uint64_t v171 = *v170++;
              GTResourceTrackerUsingResourceHeap(a1, v171, a3);
              --v169;
            }

            while (v169);
          }

          break;
        default:
          switch(v6)
          {
            case -16087:
              __int16 v43 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v44 = a1[2];
              int32x2_t v45 = GTTraceFunc_argumentBytesWithMap((void *)a2, v43[24], a1[1]);
              uint64_t v46 = *((void *)v43 + 2);
              if (v46)
              {
                NSUInteger v47 = (uint64_t *)v45;
                uint64_t v49 = *a1;
                uint64_t v48 = a1[1];
                do
                {
                  uint64_t v51 = *v47++;
                  uint64_t v50 = v51;
                  if (v51) {
                    GTResourceTrackerUsingResource(v44, 22, v50, v49, v48);
                  }
                  --v46;
                }

                while (v46);
              }

              break;
            case -16086:
              v195 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v196 = a1[2];
              uint64_t v197 = GTTraceFunc_argumentBytesWithMap((void *)a2, v195[24], a1[1]);
              uint64_t v198 = *((void *)v195 + 2);
              if (v198)
              {
                int v199 = (uint64_t *)v197;
                uint64_t v201 = *a1;
                uint64_t v200 = a1[1];
                do
                {
                  uint64_t v203 = *v199++;
                  uint64_t v202 = v203;
                  if (v203) {
                    GTResourceTrackerUsingResource(v196, 80, v202, v201, v200);
                  }
                  --v198;
                }

                while (v198);
              }

              break;
            case -16085:
              uint64_t v204 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v205 = a1[2];
              uint64_t v206 = GTTraceFunc_argumentBytesWithMap((void *)a2, v204[24], a1[1]);
              uint64_t v207 = *((void *)v204 + 2);
              if (v207)
              {
                v208 = (uint64_t *)v206;
                uint64_t v210 = *a1;
                uint64_t v209 = a1[1];
                do
                {
                  uint64_t v212 = *v208++;
                  uint64_t v211 = v212;
                  if (v212) {
                    GTResourceTrackerUsingResource(v205, 75, v211, v210, v209);
                  }
                  --v207;
                }

                while (v207);
              }

              break;
            case -16084:
              uint64_t v213 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v214 = a1[2];
              uint64_t v215 = GTTraceFunc_argumentBytesWithMap((void *)a2, v213[24], a1[1]);
              uint64_t v216 = *((void *)v213 + 2);
              if (v216)
              {
                uint64_t v217 = (uint64_t *)v215;
                uint64_t v219 = *a1;
                uint64_t v218 = a1[1];
                do
                {
                  uint64_t v221 = *v217++;
                  uint64_t v220 = v221;
                  if (v221) {
                    GTResourceTrackerUsingResource(v214, 75, v220, v219, v218);
                  }
                  --v216;
                }

                while (v216);
              }

              break;
            case -16083:
            case -16082:
            case -16081:
            case -16080:
              return;
            case -16079:
              goto LABEL_216;
            default:
              if (v6 == -16017) {
                goto LABEL_216;
              }
              break;
          }

          break;
      }
    }

    else
    {
      switch(v6)
      {
        case -16156:
        case -16155:
          goto LABEL_72;
        case -16148:
          goto LABEL_216;
        case -16147:
          goto LABEL_30;
        case -16146:
          uint64_t v157 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v158 = v157[2];
          goto LABEL_302;
        case -16145:
          uint64_t v159 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v160 = v159[4];
          goto LABEL_308;
        case -16144:
          uint64_t v159 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v159[2], a3);
          uint64_t v160 = v159[4];
          goto LABEL_308;
        case -16142:
          goto LABEL_104;
        case -16140:
          goto LABEL_70;
        case -16139:
        case -16138:
          goto LABEL_61;
        case -16133:
          goto LABEL_413;
        case -16131:
        case -16130:
        case -16129:
        case -16126:
        case -16125:
        case -16124:
          goto LABEL_59;
        default:
          return;
      }
    }
  }

  a3[3] += 64LL;
  return result;
}

uint64_t *GTResourceTrackerProcessIndirectCommandResourceUse(uint64_t *result, uint64_t a2)
{
  unsigned int v2 = result;
  int v3 = *(_DWORD *)(a2 + 8);
  if (v3 <= -15935)
  {
    switch(v3)
    {
      case -15956:
        BOOL v4 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), result[1]);
        size_t result = find_entry(v2[2], v4, 8uLL, 0LL);
        if (!*result || !*(void *)(*result + 32)) {
          return result;
        }
        uint64_t v6 = v2[1];
        uint64_t v5 = v2[2];
        uint64_t v7 = *((void *)v4 + 1);
        uint64_t v8 = *v2;
        int v9 = 71;
        return (uint64_t *)GTResourceTrackerUsingResource(v5, v9, v7, v8, v6);
      case -15955:
      case -15954:
        goto LABEL_9;
      case -15952:
        uint64_t v12 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), result[1]);
        size_t result = find_entry(v2[2], v12, 8uLL, 0LL);
        if (!*result || !*(void *)(*result + 32)) {
          return result;
        }
        GTResourceTrackerUsingResource(v2[2], 22, *((void *)v12 + 4), *v2, v2[1]);
        uint64_t v5 = v2[2];
        uint64_t v7 = *((void *)v12 + 8);
        goto LABEL_26;
      case -15950:
        id v13 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), result[1]);
        size_t result = find_entry(v2[2], v13, 8uLL, 0LL);
        if (!*result || !*(void *)(*result + 32)) {
          return result;
        }
        GTResourceTrackerUsingResource(v2[2], 22, *((void *)v13 + 4), *v2, v2[1]);
        GTResourceTrackerUsingResource(v2[2], 22, *((void *)v13 + 6), *v2, v2[1]);
        uint64_t v5 = v2[2];
        uint64_t v7 = *((void *)v13 + 10);
        goto LABEL_26;
      case -15948:
        unsigned int v14 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), result[1]);
        size_t result = find_entry(v2[2], v14, 8uLL, 0LL);
        if (!*result || !*(void *)(*result + 32)) {
          return result;
        }
        uint64_t v5 = v2[2];
        uint64_t v7 = *((void *)v14 + 4);
        goto LABEL_26;
      default:
        return result;
    }
  }

  if (v3 > -15923)
  {
    if (v3 == -15922)
    {
      uint64_t v16 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), result[1]);
      size_t result = find_entry(v2[2], v16, 8uLL, 0LL);
      if (!*result || !*(void *)(*result + 32)) {
        return result;
      }
      uint64_t v6 = v2[1];
      uint64_t v5 = v2[2];
      uint64_t v7 = *((void *)v16 + 1);
      uint64_t v8 = *v2;
      int v9 = 59;
    }

    else
    {
      if (v3 != -15921) {
        return result;
      }
      uint64_t v11 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), result[1]);
      size_t result = find_entry(v2[2], v11, 8uLL, 0LL);
      if (!*result || !*(void *)(*result + 32)) {
        return result;
      }
      uint64_t v6 = v2[1];
      uint64_t v5 = v2[2];
      uint64_t v7 = *((void *)v11 + 1);
      uint64_t v8 = *v2;
      int v9 = 58;
    }

    return (uint64_t *)GTResourceTrackerUsingResource(v5, v9, v7, v8, v6);
  }

  if (v3 == -15934)
  {
    uint64_t v15 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), result[1]);
    size_t result = find_entry(v2[2], v15, 8uLL, 0LL);
    if (!*result || !*(void *)(*result + 32)) {
      return result;
    }
    uint64_t v6 = v2[1];
    uint64_t v5 = v2[2];
    uint64_t v7 = *((void *)v15 + 1);
    uint64_t v8 = *v2;
    int v9 = 29;
    return (uint64_t *)GTResourceTrackerUsingResource(v5, v9, v7, v8, v6);
  }

  if (v3 != -15933) {
    return result;
  }
LABEL_9:
  uint64_t v10 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), result[1]);
  size_t result = find_entry(v2[2], v10, 8uLL, 0LL);
  if (*result && *(void *)(*result + 32))
  {
    uint64_t v5 = v2[2];
    uint64_t v7 = *((void *)v10 + 1);
LABEL_26:
    uint64_t v8 = *v2;
    uint64_t v6 = v2[1];
    int v9 = 22;
    return (uint64_t *)GTResourceTrackerUsingResource(v5, v9, v7, v8, v6);
  }

  return result;
}

uint64_t catch_mach_exception_raise(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = *(void *)(a5 + 8);
  pthread_mutex_lock(&tracingMutex);
  uint64_t v6 = *(int *)(tracingRegions + 12);
  if ((_DWORD)v6)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = (void *)(*(void *)(tracingRegions + 24) + 8LL);
    while (1)
    {
      unint64_t v9 = *(v8 - 1);
      if (v9 <= v5 && *v8 + v9 > v5) {
        break;
      }
      ++v7;
      v8 += 3;
      if (v6 == v7) {
        goto LABEL_9;
      }
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  if (v7 != v6)
  {
    uint64_t v10 = *(void *)(tracingRegions + 24) + 24 * v7;
    __int128 v19 = *(_OWORD *)v10;
    uint64_t v20 = *(void *)(v10 + 16);
    if ((qword_23A448 & 0x2000) != 0)
    {
      vm_size_t v11 = (v5 - (unint64_t)v19) / vm_page_size;
      uint64_t v13 = *(void *)(*find_entry(tracedChunks, &v20, 8uLL, 0LL) + 32LL) + 8 * (v11 >> 6);
      *(void *)(v13 + 8) |= 1LL << v11;
    }

    else
    {
      vm_size_t v11 = 0LL;
    }

    if (!v20)
    {
LABEL_23:
      if ((qword_23A448 & 0x2000) != 0) {
        vm_size_t v18 = vm_page_size;
      }
      else {
        vm_size_t v18 = *((void *)&v19 + 1);
      }
      mprotect((void *)(v19 + vm_page_size * v11), v18, 3);
      pthread_mutex_unlock(&tracingMutex);
      return 0LL;
    }

    unsigned int v14 = (unint64_t *)(v20 + 56);
    unint64_t v15 = atomic_load((unint64_t *)(v20 + 56));
    while (1)
    {
      unint64_t v16 = __ldaxr(v14);
      if (v16 != v15) {
        break;
      }
      if (__stlxr(v15 | 8, v14)) {
        goto LABEL_21;
      }
      int v17 = 1;
LABEL_22:
      unint64_t v15 = v16;
      if (v17) {
        goto LABEL_23;
      }
    }

    __clrex();
LABEL_21:
    int v17 = 0;
    goto LABEL_22;
  }

uint64_t catch_mach_exception_raise_state()
{
  return 46LL;
}

uint64_t catch_mach_exception_raise_state_identity()
{
  return 46LL;
}

BOOL ChangeProtection(void *a1, size_t a2, int a3)
{
  return mprotect(a1, a2, a3) != -1;
}

unint64_t GTMemoryGuard_registerRegion(unint64_t result, vm_size_t a2, uint64_t a3, int a4)
{
  unint64_t v5 = result;
  uint64_t v27 = a3;
  if (!a3 || (char v6 = atomic_load((unint64_t *)(a3 + 56)), (v6 & 8) == 0))
  {
    if (a4)
    {
      pthread_mutex_lock(&tracingMutex);
      if (!tracingPool) {
        return pthread_mutex_unlock(&tracingMutex);
      }
      uint64_t v7 = *find_entry(tracedChunks, &v27, 8uLL, 0LL);
      if (!v7) {
        return pthread_mutex_unlock(&tracingMutex);
      }
      uint64_t v8 = *(void *)(v7 + 32);
      size_t result = pthread_mutex_unlock(&tracingMutex);
      if (!v8) {
        return result;
      }
    }

    if ((vm_page_mask & v5) == 0 && vm_page_size <= a2)
    {
      pthread_once(&GTMemoryGuard_initialize_onceGuard, (void (*)(void))InitializeMemoryGuardOnce);
      pthread_mutex_lock(&tracingMutex);
      uint64_t v14 = *(int *)(tracingRegions + 12);
      if ((_DWORD)v14)
      {
        unint64_t v15 = (void *)(*(void *)(tracingRegions + 24) + 16LL);
        while (*v15 != v27)
        {
          v15 += 3;
          if (!--v14) {
            goto LABEL_25;
          }
        }

        goto LABEL_33;
      }

apr_hash_t *InitializeMemoryGuardOnce()
{
  mach_port_t v0 = mach_task_self_;
  mach_port_allocate(mach_task_self_, 1u, (mach_port_name_t *)&exceptionPort);
  mach_port_insert_right(v0, exceptionPort, exceptionPort, 0x14u);
  task_swap_exception_ports( v0,  2u,  exceptionPort,  -2147483647,  6,  (exception_mask_array_t)&oldExcMasks,  (mach_msg_type_number_t *)&oldArraySize,  (exception_handler_array_t)&oldExcPorts,  &oldBehaviors,  &oldFlavors);
  pthread_create(&v2, 0LL, (void *(__cdecl *)(void *))MachServer, 0LL);
  pthread_detach(v2);
  apr_pool_create_ex((apr_pool_t **)&tracingPool, 0LL, 0LL, 0LL);
  tracingRegions = (uint64_t)apr_array_make((apr_pool_t *)tracingPool, 1024, 24);
  size_t result = apr_hash_make((apr_pool_t *)tracingPool);
  tracedChunks = (uint64_t)result;
  return result;
}

uint64_t MachServer()
{
  return 0LL;
}

uint64_t GTMemoryGuard_unregisterRegion(uint64_t a1)
{
  uint64_t key = a1;
  pthread_mutex_lock(&tracingMutex);
  uint64_t v2 = tracingRegions;
  if (!tracingRegions) {
    return pthread_mutex_unlock(&tracingMutex);
  }
  int v3 = *(_DWORD *)(tracingRegions + 12);
  unint64_t v4 = 0LL;
  if (v3)
  {
    unint64_t v5 = (void *)(*(void *)(tracingRegions + 24) + 16LL);
    while (*v5 != a1)
    {
      ++v4;
      v5 += 3;
      if (v3 == v4) {
        goto LABEL_14;
      }
    }
  }

  if (v4 != v3)
  {
    if (v4 < v3 - 1LL)
    {
      uint64_t v6 = 24 * v4;
      do
      {
        uint64_t v7 = *(void *)(v2 + 24) + v6;
        ++v4;
        *(_OWORD *)uint64_t v7 = *(_OWORD *)(v7 + 24);
        *(void *)(v7 + 16) = *(void *)(v7 + 40);
        v6 += 24LL;
      }

      while (v4 < *(int *)(v2 + 12) - 1LL);
      int v3 = *(_DWORD *)(v2 + 12);
    }

    if (v3) {
      *(_DWORD *)(v2 + 12) = v3 - 1;
    }
  }

uint64_t GTMemoryGuard_copyTracedChunks(void **a1, uint64_t a2)
{
  uint64_t v9 = a2;
  if ((qword_23A448 & 0x2000) == 0) {
    return 0LL;
  }
  pthread_mutex_lock(&tracingMutex);
  if (!tracingRegions || (uint64_t v3 = *find_entry(tracedChunks, &v9, 8uLL, 0LL)) == 0 || (v4 = *(uint64_t **)(v3 + 32)) == 0LL)
  {
    pthread_mutex_unlock(&tracingMutex);
    return 0LL;
  }

  uint64_t v5 = *v4;
  size_t v6 = 8 * *v4;
  uint64_t v7 = realloc(*a1, v6);
  *a1 = v7;
  memcpy(v7, v4 + 1, v6);
  pthread_mutex_unlock(&tracingMutex);
  return v5;
}

id CreateIndirectRenderCommandBufferSnapshot(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a2;
  id v9 = a1;
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 device]);
  id v11 = DEVICEOBJECT(v8);
  unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

  char v13 = (void *)objc_claimAutoreleasedReturnValue([v12 device]);
  id v14 = [v12 size];
  id v15 = [v13 newIndirectCommandBufferWithDescriptor:v7 maxCommandCount:v14 options:0x800000];

  unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v10 renderFunctionCopyIndirectCommandBuffer]);
  id v17 = [v16 newArgumentEncoderWithBufferIndex:0];

  id v18 = objc_msgSend(v13, "newBufferWithLength:options:", objc_msgSend(v17, "encodedLength"), 0);
  [v17 setArgumentBuffer:v18 offset:0];
  [v17 setIndirectCommandBuffer:v15 atIndex:0];
  [v17 setIndirectCommandBuffer:v12 atIndex:1];
  id v19 = DEVICEOBJECT(v9);
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);

  [v20 useResource:v12 usage:1 stages:1];
  [v20 useResource:v15 usage:2 stages:1];
  [v20 setVertexBuffer:v18 offset:0 atIndex:0];
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v10 renderPipelineCopyIndirectCommandBuffer]);
  [v20 setRenderPipelineState:v21];

  [v20 drawPrimitives:0 vertexStart:0 vertexCount:v14];
  LOBYTE(v14) = [v13 supportsRenderMemoryBarrier];
  unsigned int v22 = [v13 supportsPartialRenderMemoryBarrier];
  if ((v14 & 1) != 0 || v22)
  {
    uint64_t v25 = v12;
    [v20 memoryBarrierWithResources:&v25 count:1 afterStages:1 beforeStages:1];
  }

  id v23 = v18;
  *a4 = v23;

  return v15;
}

void RestoreRenderCommandEncoder(void *a1)
{
  id v1 = a1;
  id v2 = [v1 traceContext];
  uint64_t v3 = [v1 traceStream];
  apr_pool_create_ex(&newpool, 0LL, 0LL, 0LL);
  unint64_t v4 = newpool;
  uint64_t v5 = apr_hash_make(newpool);
  GTTraceMemPool_buildMemoryMap(v3[3], v5);
  size_t v6 = GTTraceContext_copyStreamMap((uint64_t)v2, v4);
  bzero(v30, 0x2B90uLL);
  uint64_t v7 = v3[4];
  if (v7)
  {
    unsigned int v8 = 0;
    while (1)
    {
      unsigned int v9 = atomic_load((unsigned int *)(v7 + 4));
      uint64_t v10 = v8 + (v9 >> 6) - 1;
      uint64_t v7 = *(void *)(v7 + 40);
      unsigned int v8 = v10;
      if (!v7)
      {
        unsigned int v8 = v10;
        goto LABEL_8;
      }
    }
  }

  else
  {
    unsigned int v8 = 0;
  }

  uint64_t v10 = 0LL;
LABEL_8:
  unint64_t v11 = v8 | (unint64_t)(v10 << 32);
LABEL_9:
  uint64_t v12 = v7 + 64;
  while (v7 && (*(_BYTE *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6) + 15) & 8) != 0)
  {
    GTMTLSMCommandEncoder_processTraceFunc( (uint64_t)v30,  (uint64_t *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6)),  (uint64_t)v5);
    unsigned int v13 = atomic_load((unsigned int *)(v7 + 4));
    int v14 = v11 + (v13 >> 6);
    uint64_t v15 = (HIDWORD(v11) + 1);
    unint64_t v11 = (v15 << 32) | v11;
    if ((_DWORD)v15 == v14 - 1)
    {
      unint64_t v11 = (v15 << 32) | v15;
      uint64_t v7 = *(void *)(v7 + 40);
      goto LABEL_9;
    }
  }

  id v29 = v1;
  id v16 = DEVICEOBJECT(v1);
  id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = 0LL;
  char v19 = 1;
  do
  {
    char v20 = v19;
    uint64_t v21 = 1LL << v18;
    uint64_t v22 = v32[v18];
    if ((v30[8] & (1LL << v18)) != 0)
    {
      if (v22) {
        uint64_t v23 = v22 + 16;
      }
      else {
        uint64_t v23 = 0LL;
      }
      vm_size_t v24 = &v30[v18];
      uint64_t v25 = v24[41];
      if ((v31 & v21) != 0) {
        [v17 setVertexBytes:v23 length:v25 attributeStride:v24[72] atIndex:v18];
      }
      else {
        [v17 setVertexBytes:v23 length:v25 atIndex:v18];
      }
    }

    else
    {
      v35[0] = v32[v18];
      id v26 = *(id *)(*(void *)(*find_entry((uint64_t)v6, v35, 8uLL, 0LL) + 32LL) + 8LL);
      if (objc_msgSend(v26, "conformsToProtocol:", &OBJC_PROTOCOL___MTLBuffer, v29))
      {
        uint64_t v27 = &v30[v18];
        uint64_t v28 = v27[41];
        if ((v31 & v21) != 0) {
          [v17 setVertexBuffer:v26 offset:v28 attributeStride:v27[72] atIndex:v18];
        }
        else {
          [v17 setVertexBuffer:v26 offset:v28 atIndex:v18];
        }
      }

      else if ([v26 conformsToProtocol:&OBJC_PROTOCOL___MTLAccelerationStructure])
      {
        [v17 setVertexAccelerationStructure:v26 atBufferIndex:v18];
      }

      else if ([v26 conformsToProtocol:&OBJC_PROTOCOL___MTLIntersectionFunctionTable])
      {
        [v17 setVertexIntersectionFunctionTable:v26 atBufferIndex:v18];
      }

      else if ([v26 conformsToProtocol:&OBJC_PROTOCOL___MTLVisibleFunctionTable])
      {
        [v17 setVertexVisibleFunctionTable:v26 atBufferIndex:v18];
      }
    }

    char v19 = 0;
    uint64_t v18 = 1LL;
  }

  while ((v20 & 1) != 0);
  if (v33)
  {
    v35[0] = v33;
    objc_msgSend( v17,  "setRenderPipelineState:",  *(void *)(*(void *)(*find_entry((uint64_t)v6, v35, 8uLL, 0) + 32) + 8));
  }

  apr_pool_destroy(newpool);
}

pthread_mutex_t *GTMTLCaptureState_createLocalCapture(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = GTMTLCaptureState_create();
  uint64_t v5 = objc_autoreleasePoolPush();
  uint64_t v6 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *(void *)(a1 + 64)));
  uint64_t v7 = *(void **)&v4[6].__opaque[32];
  *(void *)&v4[6].__opaque[32] = v6;

  v4[7].__opaque[0] = 0;
  __int128 v8 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v4->__sig = *(_OWORD *)a1;
  *(_OWORD *)&v4->__opaque[8] = v8;
  __int128 v9 = *(_OWORD *)(a1 + 32);
  __int128 v10 = *(_OWORD *)(a1 + 48);
  __int128 v11 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v4[1].__sig = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v4[1].__opaque[8] = v11;
  *(_OWORD *)&v4->__opaque[24] = v9;
  *(_OWORD *)&v4->__opaque[40] = v10;
  id v12 = objc_retainBlock(*(id *)(a1 + 96));
  unsigned int v13 = *(void **)&v4[1].__opaque[24];
  *(void *)&v4[1].__opaque[24] = v12;

  v4[1].__opaque[21] = GetEnvDefault_4666() != 0LL;
  v4[1].__sig = (uint64_t)[*(id *)&v4[6].__opaque[32] UTF8String];
  *(void *)&v4[3].__opaque[24] = apr_array_make(*(apr_pool_t **)&v4[1].__opaque[48], 128, 32);
  id v14 = objc_claimAutoreleasedReturnValue( [*(id *)&v4[6].__opaque[32] stringByAppendingPathComponent:@"store0"]);
  int v15 = open((const char *)[v14 UTF8String], 514, 438);
  *(_DWORD *)&v4[6].__opaque[24] = v15;
  if (v15 < 0)
  {
    if (s_logUsingOsLog)
    {
      id v16 = gt_default_log();
      id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        vm_size_t v24 = __error();
        uint64_t v25 = strerror(*v24);
        *(_DWORD *)buf = 136315138;
        uint64_t v27 = v25;
        _os_log_error_impl(&dword_0, v17, OS_LOG_TYPE_ERROR, "warning: failed to create store0 (%s)", buf, 0xCu);
      }
    }

    else
    {
      uint64_t v18 = __stderrp;
      char v19 = __error();
      char v20 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"warning: failed to create store0 (%s)",  strerror(*v19));
      id v21 = objc_claimAutoreleasedReturnValue(v20);
      fprintf(v18, "%s\n", (const char *)[v21 UTF8String]);
    }
  }

  pthread_mutex_init((pthread_mutex_t *)((char *)v4 + 232), 0LL);
  if (a2) {
    uint64_t v22 = *(void **)(a2 + 8);
  }
  else {
    uint64_t v22 = 0LL;
  }
  objc_storeStrong((id *)&v4[1].__opaque[40], v22);
  deflateInit_((z_streamp)&v4[4].__opaque[32], -1, "1.2.12", 112);
  *(void *)&v4[6].__opaque[16] = apr_palloc(*(apr_pool_t **)&v4[1].__opaque[48], 0x1000uLL);

  objc_autoreleasePoolPop(v5);
  return v4;
}

pthread_mutex_t *GTMTLCaptureState_create()
{
  mach_port_t v0 = newpool;
  id v1 = (mach_timebase_info *)apr_palloc(newpool, 0x1D0uLL);
  id v2 = (pthread_mutex_t *)v1;
  if (v1)
  {
    *(_OWORD *)&v1[54].numer = 0u;
    *(_OWORD *)&v1[56].numer = 0u;
    *(_OWORD *)&v1[50].numer = 0u;
    *(_OWORD *)&v1[52].numer = 0u;
    *(_OWORD *)&v1[46].numer = 0u;
    *(_OWORD *)&v1[48].numer = 0u;
    *(_OWORD *)&v1[42].numer = 0u;
    *(_OWORD *)&v1[44].numer = 0u;
    *(_OWORD *)&v1[38].numer = 0u;
    *(_OWORD *)&v1[40].numer = 0u;
    *(_OWORD *)&v1[34].numer = 0u;
    *(_OWORD *)&v1[36].numer = 0u;
    *(_OWORD *)&v1[30].numer = 0u;
    *(_OWORD *)&v1[32].numer = 0u;
    *(_OWORD *)&v1[26].numer = 0u;
    *(_OWORD *)&v1[28].numer = 0u;
    *(_OWORD *)&v1[22].numer = 0u;
    *(_OWORD *)&v1[24].numer = 0u;
    *(_OWORD *)&v1[18].numer = 0u;
    *(_OWORD *)&v1[20].numer = 0u;
    *(_OWORD *)&v1[14].numer = 0u;
    *(_OWORD *)&v1[16].numer = 0u;
    *(_OWORD *)&v1[10].numer = 0u;
    *(_OWORD *)&v1[12].numer = 0u;
    *(_OWORD *)&v1[6].numer = 0u;
    *(_OWORD *)&v1[8].numer = 0u;
    *(_OWORD *)&v1[2].numer = 0u;
    *(_OWORD *)&v1[4].numer = 0u;
    *(_OWORD *)&v1->numer = 0u;
  }

  v1[15] = (mach_timebase_info)v0;
  mach_timebase_info(v1 + 56);
  pthread_mutex_init(v2 + 2, 0LL);
  v2[3].__sig = (uint64_t)apr_array_make(v0, 0, 88);
  *(void *)v2[3].__opaque = apr_hash_make(v0);
  *(void *)&v2[3].__opaque[8] = apr_hash_make(v0);
  *(void *)&v2[3].__opaque[16] = apr_hash_make(v0);
  return v2;
}

char *GetEnvDefault_4666()
{
  size_t result = getenv("MTLCAPTURE_NEW_ARCHIVE_FORMAT");
  if (result) {
    return (char *)strtol(result, 0LL, 0);
  }
  return result;
}

pthread_mutex_t *GTMTLCaptureState_createRemoteCapture(uint64_t a1, id *a2)
{
  unint64_t v4 = GTMTLCaptureState_create();
  objc_storeStrong((id *)&v4[1].__opaque[32], *a2);
  __int128 v5 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v4->__sig = *(_OWORD *)a1;
  *(_OWORD *)&v4->__opaque[8] = v5;
  __int128 v6 = *(_OWORD *)(a1 + 32);
  __int128 v7 = *(_OWORD *)(a1 + 48);
  __int128 v8 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v4[1].__sig = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v4[1].__opaque[8] = v8;
  *(_OWORD *)&v4->__opaque[24] = v6;
  *(_OWORD *)&v4->__opaque[40] = v7;
  id v9 = objc_retainBlock(*(id *)(a1 + 96));
  __int128 v10 = *(void **)&v4[1].__opaque[24];
  *(void *)&v4[1].__opaque[24] = v9;

  v4[1].__sig = 0LL;
  v4[1].__opaque[21] = GetEnvDefault_4666() != 0LL;
  return v4;
}

void GTMTLCaptureState_close(uint64_t a1)
{
  if (*(void *)(a1 + 64))
  {
    id v2 = objc_autoreleasePoolPush();
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 232));
    close(*(_DWORD *)(a1 + 416));
    qsort( *(void **)(*(void *)(a1 + 224) + 24LL),  *(int *)(*(void *)(a1 + 224) + 12LL),  *(int *)(*(void *)(a1 + 224) + 8LL),  (int (__cdecl *)(const void *, const void *))GTCaptureFileIndex_compareByName);
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 424) stringByAppendingPathComponent:@"index"]);
    uint64_t v4 = *(void *)(a1 + 224);
    id v5 = v3;
    GTCaptureFileIndex_save(v4, (const char *)[v5 UTF8String]);
    deflateEnd((z_streamp)(a1 + 296));

    objc_autoreleasePoolPop(v2);
  }

  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 128));
  __int128 v6 = *(void **)(a1 + 424);
  *(void *)(a1 + 424) = 0LL;

  __int128 v7 = *(void **)(a1 + 104);
  *(void *)(a1 + 104) = 0LL;

  __int128 v8 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = 0LL;

  id v9 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = 0LL;

  apr_pool_destroy(*(apr_pool_t **)(a1 + 120));
}

uint64_t GTMTLCaptureState_localFilePathURL(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t GTMTLCaptureState_appendDownloadRequests(uint64_t a1, const apr_array_header_t *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 128);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
  apr_array_cat(*(apr_array_header_t **)(a1 + 192), a2);
  return pthread_mutex_unlock(v4);
}

uint64_t GTMTLCaptureState_downloadRequests(uint64_t a1)
{
  return *(void *)(a1 + 192);
}

void GTMTLCaptureState_storeData(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1[8])
  {
    _storeDataLocal((uint64_t)a1, v5, v6);
  }

  else
  {
    v11[1] = @"capture serial";
    v12[0] = v5;
    v11[0] = @"buffer name";
    __int128 v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[4]));
    v12[1] = v7;
    __int128 v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v12,  v11,  2LL));

    id v9 = (void *)a1[13];
    __int128 v10 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:attributes:payload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:attributes:payload:",  258LL,  v8,  v6));
    [v9 send:v10 error:0];
  }
}

void _storeDataLocal(uint64_t a1, void *a2, void *a3)
{
  id v40 = a2;
  id v5 = a3;
  unint64_t v6 = (unint64_t)[v5 length];
  __int128 v7 = *(apr_array_header_t **)(a1 + 224);
  if (v6 >> 15)
  {
    uint64_t v25 = objc_autoreleasePoolPush();
    id v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 424) stringByAppendingPathComponent:v40]);
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](&OBJC_CLASS___NSURL, "fileURLWithPath:", v26));
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    id v29 = (void *)objc_claimAutoreleasedReturnValue([v27 URLByDeletingLastPathComponent]);
    [v28 createDirectoryAtURL:v29 withIntermediateDirectories:1 attributes:0 error:0];

    [v5 writeToFile:v26 atomically:0];
    uint64_t v30 = (pthread_mutex_t *)(a1 + 128);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
    uint64_t v31 = apr_array_push(v7);
    unsigned int v32 = apr_pstrdup(v7->pool, (const char *)[v40 UTF8String]);
    *(void *)uint64_t v31 = v32;
    v31[2] = v6;
    v31[6] = 2;
    if ((qword_23A448 & 0x20) != 0)
    {
      uint64_t v33 = v32;
      uint64_t v34 = v7->nelts - 1LL;
      uint64_t v35 = *(apr_hash_t **)(a1 + 216);
      uint64_t v36 = apr_palloc(v7->pool, 8uLL);
      void *v36 = v34;
      apr_hash_set(v35, v33, -1LL, v36);
    }

    pthread_mutex_unlock(v30);

    objc_autoreleasePoolPop(v25);
  }

  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 232));
    deflateReset((z_streamp)(a1 + 296));
    id v39 = v5;
    *(void *)(a1 + 296) = [v5 bytes];
    int v38 = v6;
    *(_DWORD *)(a1 + 304) = v6;
    off_t v37 = lseek(*(_DWORD *)(a1 + 416), 0LL, 1);
    uint64_t v8 = *(void *)(a1 + 408);
    do
    {
      *(void *)(a1 + 32mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v8;
      *(_DWORD *)(a1 + 32_Block_object_dispose(va, 8) = 4096;
      int v9 = deflate((z_streamp)(a1 + 296), 4);
      uint64_t v10 = 0LL;
      int v11 = *(_DWORD *)(a1 + 416);
      uint64_t v12 = *(void *)(a1 + 320) - v8;
      do
      {
        else {
          size_t v13 = v12 - v10;
        }
        ssize_t v14 = write(v11, (const void *)(v8 + v10), v13);
        if (v14 == -1) {
          ssize_t v15 = 0LL;
        }
        else {
          ssize_t v15 = v14;
        }
        v10 += v15;
      }

      while (v14 != -1 && v10 != v12);
    }

    while (!v9);
    uint64_t v17 = *(void *)(a1 + 336);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 232));
    uint64_t v18 = (pthread_mutex_t *)(a1 + 128);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
    char v19 = apr_array_push(v7);
    char v20 = apr_pstrdup(v7->pool, (const char *)[v40 UTF8String]);
    *char v19 = v20;
    v19[2] = v37;
    *((_DWORD *)v19 + 2) = v38;
    *((_DWORD *)v19 + 3) = v17;
    *((_DWORD *)v19 + 6) = 1;
    if ((qword_23A448 & 0x20) != 0)
    {
      id v21 = v20;
      uint64_t v22 = v7->nelts - 1LL;
      uint64_t v23 = *(apr_hash_t **)(a1 + 216);
      vm_size_t v24 = apr_palloc(v7->pool, 8uLL);
      void *v24 = v22;
      apr_hash_set(v23, v21, -1LL, v24);
    }

    pthread_mutex_unlock(v18);
    id v5 = v39;
  }
}

uint64_t GTMTLCaptureState_getFileSize(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
  uint64_t v5 = *find_entry(*(void *)(a1 + 200), __s, v4, 0LL);
  if (v5) {
    uint64_t v6 = *(void *)(v5 + 32);
  }
  else {
    uint64_t v6 = 0LL;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 128));
  return v6;
}

void GTMTLCaptureState_storePointer(uint64_t a1, char *__s, uint64_t *a3, const void *a4)
{
  if (a1 && a4)
  {
    size_t v8 = strlen(__s);
    int v9 = (pthread_mutex_t *)(a1 + 128);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
    uint64_t v10 = *find_entry(*(void *)(a1 + 200), __s, v8, 0LL);
    if (v10 && *(void *)(v10 + 32))
    {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 128));
    }

    else
    {
      if (__s)
      {
        int v11 = apr_palloc(**(apr_pool_t ***)(a1 + 200), v8 + 1);
        memcpy(v11, __s, v8);
        *((_BYTE *)v11 + v_Block_object_dispose(va, 8) = 0;
      }

      else
      {
        int v11 = 0LL;
      }

      apr_hash_set(*(apr_hash_t **)(a1 + 200), v11, v8, a4);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 128));
      if ((qword_23A448 & 0x20) != 0 && *(void *)(a1 + 64))
      {
        HashBytes(a3, (unint64_t)a4, __sa);
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
        uint64_t v12 = *find_entry(*(void *)(a1 + 208), __sa, 0xFFFFFFFFFFFFFFFFLL, 0LL);
        if (v12 && (size_t v13 = *(char **)(v12 + 32)) != 0LL)
        {
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 128));
          if (*(void *)(a1 + 64) && strcmp(v13, (const char *)v11))
          {
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
            ssize_t v14 = *(apr_array_header_t **)(a1 + 224);
            size_t v15 = strlen(v13);
            uint64_t v16 = *find_entry(*(void *)(a1 + 216), v13, v15, 0LL);
            if (v16
              && (uint64_t v17 = *(void **)(v16 + 32)) != 0LL
              && (uint64_t v18 = (uint64_t)&v14->elts[32 * *v17], !strcmp(*(const char **)v18, v13)))
            {
              unsigned int v32 = apr_array_push(v14);
              __int128 v33 = *(_OWORD *)(v18 + 16);
              _OWORD *v32 = *(_OWORD *)v18;
              v32[1] = v33;
              *(void *)unsigned int v32 = apr_pstrdup(v14->pool, (const char *)v11);
              if ((*((_BYTE *)v32 + 24) & 2) != 0)
              {
                uint64_t v34 = *(void **)(a1 + 424);
                uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v11));
                uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v34 stringByAppendingPathComponent:v35]);

                off_t v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](&OBJC_CLASS___NSURL, "fileURLWithPath:", v36));
                int v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13));
                id v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](&OBJC_CLASS___NSURL, "fileURLWithPath:", v38));

                id v40 = v36;
                symlink(v13, (const char *)[v40 UTF8String]);
              }

              pthread_mutex_unlock(v9);
            }

            else
            {
              pthread_mutex_unlock((pthread_mutex_t *)(a1 + 128));
              if (s_logUsingOsLog)
              {
                id v19 = gt_default_log();
                char v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
                if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136315138;
                  __int16 v43 = v13;
                  _os_log_error_impl(&dword_0, v20, OS_LOG_TYPE_ERROR, "warning: File %s not found\n", buf, 0xCu);
                }
              }

              else
              {
                uint64_t v30 = __stderrp;
                id v31 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"warning: File %s not found\n", v13));
                fprintf(v30, "%s\n", (const char *)[v31 UTF8String]);
              }
            }
          }
        }

        else
        {
          apr_size_t v24 = strlen(__sa) + 1;
          uint64_t v25 = apr_palloc(**(apr_pool_t ***)(a1 + 208), v24);
          memcpy(v25, __sa, v24);
          id v26 = apr_pstrdup(**(apr_pool_t ***)(a1 + 208), (const char *)v11);
          apr_hash_set(*(apr_hash_t **)(a1 + 208), v25, -1LL, v26);
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 128));
          uint64_t v27 = objc_autoreleasePoolPush();
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v11));
          id v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  a3,  a4,  0LL));
          GTMTLCaptureState_storeData((void *)a1, v28, v29);

          objc_autoreleasePoolPop(v27);
        }
      }

      else
      {
        id v21 = objc_autoreleasePoolPush();
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v11));
        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  a3,  a4,  0LL));
        GTMTLCaptureState_storeData((void *)a1, v22, v23);

        objc_autoreleasePoolPop(v21);
      }
    }
  }

void GTMTLCaptureState_notifyCommandBufferCaptured(uint64_t a1)
{
  id v2 = objc_autoreleasePoolPush();
  uint64_t v3 = (unint64_t *)(a1 + 432);
  do
    unint64_t v4 = __ldaxr(v3);
  while (__stlxr(v4 + 1, v3));
  uint64_t v5 = *(void **)(a1 + 104);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v4 + 1));
  __int128 v7 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:objectPayload:",  1548LL,  v6));
  [v5 send:v7 error:0];

  objc_autoreleasePoolPop(v2);
}

uint64_t GTMTLCaptureState_getStartAbsoluteTime(uint64_t a1)
{
  return *(void *)(a1 + 440);
}

unint64_t GTMTLCaptureState_nanoSecondsElapsed(uint64_t a1, uint64_t a2)
{
  return (unint64_t)*(unsigned int *)(a1 + 448) * a2 / *(unsigned int *)(a1 + 452);
}

uint64_t GTMTLCaptureState_setStartAbsoluteTime(uint64_t result, uint64_t a2, void *a3)
{
  *(void *)(result + 44mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = a2;
  *(void *)(result + 44_Block_object_dispose(va, 8) = *a3;
  return result;
}

void GTMTLCaptureState_copyDeviceFilesLocal(uint64_t a1, const char **a2, apr_pool_t **a3)
{
  uint64_t v6 = *a3;
  Data = GTCaptureArchive_readData(a2, a3, "(device info)", *a3, 0LL);
  int v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  Data,  v8,  0LL));
  _storeDataLocal(a1, @"(device info)", v9);

  uint64_t v10 = GTCaptureArchive_readData(a2, a3, "(control device info)", v6, 0LL);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  v10,  v11,  0LL));
  _storeDataLocal(a1, @"(control device info)", v12);

  size_t v13 = GTCaptureArchive_readData(a2, a3, "(device profile)", v6, 0LL);
  size_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  v13,  v14,  0LL));
  _storeDataLocal(a1, @"(device profile)", v15);

  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *a2));
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v16 stringByAppendingPathComponent:@"metadata"]);
  id v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 424) stringByAppendingPathComponent:@"metadata"]);
  uint64_t v20 = 0LL;
  [v17 copyItemAtPath:v18 toPath:v19 error:&v20];
}

void GTMTLCaptureState_notifyUsedDataSentWithDictionary(uint64_t a1, uint64_t a2, void *a3)
{
  v39[0] = &off_212C50;
  v38[0] = @"DYCaptureSession.deviceId";
  v38[1] = @"DYCaptureSession.unusedBufferCount";
  __int128 v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", *a3));
  v39[1] = v33;
  v38[2] = @"DYCaptureSession.unusedTextureCount";
  unsigned int v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[1]));
  v39[2] = v32;
  v38[3] = @"DYCaptureSession.unusedLibraryCount";
  id v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[16]));
  v39[3] = v31;
  v38[4] = @"DYCaptureSession.unusedFunctionCount";
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[15]));
  v39[4] = v30;
  v38[5] = @"DYCaptureSession.unusedRenderPipelineStateCount";
  id v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[4]));
  v39[5] = v29;
  v38[6] = @"DYCaptureSession.unusedComputePipelineStateCount";
  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[5]));
  v39[6] = v28;
  v38[7] = @"DYCaptureSession.unusedDepthStencilStateCount";
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[3]));
  v39[7] = v27;
  v38[8] = @"DYCaptureSession.unusedSamplerStateCount";
  id v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[2]));
  v39[8] = v26;
  v38[9] = @"DYCaptureSession.unusedCommandQueueCount";
  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[12]));
  v39[9] = v25;
  v38[10] = @"DYCaptureSession.unusedIOCommandQueueCount";
  apr_size_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[13]));
  v39[10] = v24;
  v38[11] = @"DYCaptureSession.unusedHeapCount";
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[9]));
  v39[11] = v23;
  v38[12] = @"DYCaptureSession.unusedFenceCount";
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[11]));
  v39[12] = v22;
  v38[13] = @"DYCaptureSession.unusedTextureLayoutCount";
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[14]));
  v39[13] = v5;
  v38[14] = @"DYCaptureSession.unusedEventCount";
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[10]));
  v39[14] = v6;
  v38[15] = @"DYCaptureSession.unusedIndirectCommandBufferCount";
  __int128 v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[7]));
  v39[15] = v7;
  v38[16] = @"DYCaptureSession.unusedAccelerationStructureCount";
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a3[8]));
  v39[16] = v8;
  v39[17] = &off_212C50;
  v38[17] = @"DYCaptureSession.unusedInternalBufferCount";
  v38[18] = @"DYCaptureSession.unusedInternalTextureCount";
  v39[18] = &off_212C50;
  v39[19] = &off_212C50;
  v38[19] = @"DYCaptureSession.unusedInternalLibraryCount";
  v38[20] = @"DYCaptureSession.unusedInternalFunctionCount";
  v39[20] = &off_212C50;
  v39[21] = &off_212C50;
  v38[21] = @"DYCaptureSession.unusedInternalRenderPipelineStateCount";
  v38[22] = @"DYCaptureSession.unusedInternalComputePipelineStateCount";
  v39[22] = &off_212C50;
  v39[23] = &off_212C50;
  v38[23] = @"DYCaptureSession.unusedInternalDepthStencilStateCount";
  v38[24] = @"DYCaptureSession.unusedInternalSamplerStateCount";
  v39[24] = &off_212C50;
  v39[25] = &off_212C50;
  v38[25] = @"DYCaptureSession.unusedInternalCommandQueueCount";
  v38[26] = @"DYCaptureSession.unusedInternalHeapCount";
  v39[26] = &off_212C50;
  v39[27] = &off_212C50;
  v38[27] = @"DYCaptureSession.unusedInternalFenceCount";
  v38[28] = @"DYCaptureSession.unusedInternalTextureLayoutCount";
  v39[28] = &off_212C50;
  v39[29] = &off_212C50;
  v38[29] = @"DYCaptureSession.unusedInternalEventCount";
  v38[30] = @"DYCaptureSession.unusedInternalIndirectCommandBufferCount";
  v39[30] = &off_212C50;
  v39[31] = &off_212C50;
  v38[31] = @"DYCaptureSession.unusedInternalAccelerationStructureCount";
  v38[32] = @"captured frames counter";
  int v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", a2));
  v39[32] = v9;
  v38[33] = @"library link-time versions";
  id v10 = _buildLibraryLinkTimeVersionsDictionary();
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  v39[33] = v11;
  v38[34] = @"queue/thread labels";
  id v12 = _buildQueueThreadLabelsDictionary();
  size_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  v39[34] = v13;
  v38[35] = @"device profile";
  id v14 = GTMTLGuestAppClient_copyDeviceProfiles(g_guestAppClientMTL);
  size_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  v39[35] = v15;
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v39,  v38,  36LL));

  uint64_t v17 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v17,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CaptureSentUsedData",  "",  buf,  2u);
  }

  uint64_t v36 = @"capture serial";
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 32)));
  off_t v37 = v18;
  id v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v37,  &v36,  1LL));

  uint64_t v20 = *(void **)(a1 + 104);
  id v21 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:attributes:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:attributes:objectPayload:",  266LL,  v19,  v16));
  [v20 send:v21 error:0];
}

id _buildLibraryLinkTimeVersionsDictionary()
{
  mach_port_t v0 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( NSMutableDictionary,  "dictionaryWithCapacity:",  [&off_212E70 count]));
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  id v1 = [&off_212E70 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v1)
  {
    id v2 = v1;
    uint64_t v3 = *(void *)v11;
    do
    {
      unint64_t v4 = 0LL;
      do
      {
        if (*(void *)v11 != v3) {
          objc_enumerationMutation(&off_212E70);
        }
        id v5 = *(id *)(*((void *)&v10 + 1) + 8LL * (void)v4);
        uint64_t v6 = +[NSNumber numberWithInt:]( NSNumber,  "numberWithInt:",  NSVersionOfLinkTimeLibrary((const char *)[v5 UTF8String]));
        __int128 v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        [v0 setObject:v7 forKeyedSubscript:v5];

        unint64_t v4 = (char *)v4 + 1;
      }

      while (v2 != v4);
      id v2 = [&off_212E70 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }

    while (v2);
  }

  id v8 = [v0 copy];

  return v8;
}

id _buildQueueThreadLabelsDictionary()
{
  v1[0] = @"queues";
  v1[1] = @"threads";
  v2[0] = &__NSDictionary0__struct;
  v2[1] = &__NSDictionary0__struct;
  return (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v2,  v1,  2LL));
}

void GTMTLCaptureState_notifyAllCaptureDataSent(uint64_t a1, uint64_t a2)
{
  v21[0] = @"captured frames counter";
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", a2));
  v22[0] = v3;
  v21[1] = @"library link-time versions";
  id v4 = _buildLibraryLinkTimeVersionsDictionary();
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v22[1] = v5;
  v21[2] = @"queue/thread labels";
  id v6 = _buildQueueThreadLabelsDictionary();
  __int128 v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  v22[2] = v7;
  v21[3] = @"device profile";
  id v8 = GTMTLGuestAppClient_copyDeviceProfiles(g_guestAppClientMTL);
  int v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  v22[3] = v9;
  void v21[4] = @"LinkedOnApexOrLater";
  __int128 v10 = +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  _CFExecutableLinkedOnOrAfter(1005LL));
  __int128 v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  void v22[4] = v11;
  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v22,  v21,  5LL));

  id v19 = @"capture serial";
  __int128 v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 32)));
  uint64_t v20 = v13;
  id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v20,  &v19,  1LL));

  size_t v15 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    *(_WORD *)uint64_t v18 = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CaptureSentAllData",  "",  v18,  2u);
  }

  uint64_t v16 = *(void **)(a1 + 104);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:attributes:objectPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:attributes:objectPayload:",  263LL,  v14,  v12));
  [v16 send:v17 error:0];
}

void GTMTLCaptureState_dumpDeviceFilesLocal(uint64_t a1, uint64_t a2)
{
  id v4 = objc_autoreleasePoolPush();
  id v5 = newDYDeviceInfo();
  id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  id v7 = GTMTLGuestAppClient_copyDeviceProfiles(g_guestAppClientMTL);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  [v6 setProfiles:v8];

  int v9 = -[NSKeyedArchiver initRequiringSecureCoding:]( objc_alloc(&OBJC_CLASS___NSKeyedArchiver),  "initRequiringSecureCoding:",  1LL);
  -[NSKeyedArchiver encodeObject:forKey:](v9, "encodeObject:forKey:", v6, NSKeyedArchiveRootObjectKey);
  __int128 v10 = (void *)objc_claimAutoreleasedReturnValue(-[NSKeyedArchiver encodedData](v9, "encodedData"));
  _storeDataLocal(a1, @"(device info)", v10);
  _storeDataLocal(a1, @"(control device info)", v10);

  __int128 v11 = -[NSKeyedArchiver initRequiringSecureCoding:]( objc_alloc(&OBJC_CLASS___NSKeyedArchiver),  "initRequiringSecureCoding:",  1LL);
  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v6 profiles]);
  -[NSKeyedArchiver encodeObject:forKey:](v11, "encodeObject:forKey:", v12, NSKeyedArchiveRootObjectKey);

  __int128 v13 = (void *)objc_claimAutoreleasedReturnValue(-[NSKeyedArchiver encodedData](v11, "encodedData"));
  _storeDataLocal(a1, @"(device profile)", v13);

  id v14 = objc_alloc_init(&OBJC_CLASS___NSUUID);
  v26[0] = @"(uuid)";
  size_t v15 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v14, "UUIDString"));
  v27[0] = v15;
  v27[1] = &off_212C50;
  v26[1] = @"DYCaptureSession.capture_version";
  v26[2] = @"DYCaptureSession.interpose_feature_version";
  v27[2] = &off_212C68;
  v27[3] = @"0";
  v26[3] = @"DYCaptureSession.interpose_patch_version";
  v26[4] = @"DYCaptureSession.nativePointerSize";
  v27[4] = &off_212C80;
  v26[5] = @"DYCaptureSession.boundaryLess";
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 86)));
  v27[5] = v16;
  v27[6] = &off_212C98;
  v26[6] = @"DYCaptureSession.graphics_api";
  v26[7] = @"DYCaptureSession.library_link_time_versions";
  id v17 = _buildLibraryLinkTimeVersionsDictionary();
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
  v27[7] = v18;
  v27[8] = &off_212C98;
  v26[8] = @"DYCaptureEngine.captured_frames_count";
  v26[9] = @"DYCaptureEngine.launch_dictionary";
  v27[9] = &__NSDictionary0__struct;
  v26[10] = @"DYCaptureEngine.linked_on_apex_or_later";
  id v19 = +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  _CFExecutableLinkedOnOrAfter(1005LL));
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  v27[10] = v20;
  v26[11] = @"DYCaptureSession.deviceId";
  id v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a2));
  v27[11] = v21;
  v27[12] = &off_212C50;
  v26[12] = @"DYCaptureSession.unusedBufferCount";
  v26[13] = @"DYCaptureSession.unusedTextureCount";
  v27[13] = &off_212C50;
  v27[14] = &off_212C50;
  v26[14] = @"DYCaptureSession.unusedLibraryCount";
  v26[15] = @"DYCaptureSession.unusedFunctionCount";
  v26[16] = @"DYCaptureSession.unusedRenderPipelineStateCount";
  v26[17] = @"DYCaptureSession.unusedComputePipelineStateCount";
  v27[15] = &off_212C50;
  v27[16] = &off_212C50;
  v26[18] = @"DYCaptureSession.unusedDepthStencilStateCount";
  v26[19] = @"DYCaptureSession.unusedSamplerStateCount";
  v27[17] = &off_212C50;
  v27[18] = &off_212C50;
  v26[20] = @"DYCaptureSession.unusedCommandQueueCount";
  v27[19] = &off_212C50;
  v27[20] = &off_212C50;
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v27,  v26,  21LL));

  uint64_t v25 = 0LL;
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  v22,  200LL,  0LL,  &v25));
  apr_size_t v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 424) stringByAppendingPathComponent:@"metadata"]);
  [v23 writeToFile:v24 atomically:0];

  objc_autoreleasePoolPop(v4);
}

const char *GTMTLCaptureModeAsString(int a1)
{
  else {
    return (&off_20DBC0)[a1 - 1];
  }
}

id FindMetalLayerWithAddress(void *a1)
{
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  id v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)s_layerStreamMap, "keyEnumerator", 0));
  id v3 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v11;
    while (2)
    {
      id v6 = 0LL;
      do
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v2);
        }
        id v7 = *(void **)(*((void *)&v10 + 1) + 8LL * (void)v6);
        if (v7 == a1)
        {
          id v8 = v7;
          goto LABEL_11;
        }

        id v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }

  id v8 = 0LL;
LABEL_11:

  os_unfair_lock_unlock(&s_layerMapLock);
  return v8;
}

id AllMetalLayers()
{
  mach_port_t v0 = (void *)objc_claimAutoreleasedReturnValue([(id)s_layerStreamMap keyEnumerator]);
  LayerInfos = MakeLayerInfos(v0);
  id v2 = (void *)objc_claimAutoreleasedReturnValue(LayerInfos);

  os_unfair_lock_unlock(&s_layerMapLock);
  return v2;
}

NSMutableArray *MakeLayerInfos(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  id v3 = v1;
  id v4 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v17;
    do
    {
      id v7 = 0LL;
      do
      {
        if (*(void *)v17 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v16 + 1) + 8LL * (void)v7);
        id v9 = objc_alloc_init(&OBJC_CLASS___DYGTCAMetalLayerInfo);
        __int128 v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "device", (void)v16));
        [v9 setDeviceAddress:v10];

        __int128 v11 = (void *)objc_claimAutoreleasedReturnValue([v8 device]);
        __int128 v12 = (uint64_t *)[v11 traceStream];
        if (v12) {
          uint64_t v13 = *v12;
        }
        else {
          uint64_t v13 = 0LL;
        }
        [v9 setDeviceStreamRef:v13];

        [v9 setLayerAddress:v8];
        objc_msgSend(v9, "setLayerStreamRef:", objc_msgSend(v8, "streamReference"));
        [v8 frame];
        objc_msgSend(v9, "setFrame:");
        id v14 = (void *)objc_claimAutoreleasedReturnValue([v8 name]);
        [v9 setName:v14];

        -[NSMutableArray addObject:](v2, "addObject:", v9);
        id v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }

    while (v5);
  }

  return v2;
}

uint64_t CaptureCA(uint64_t a1)
{
  id v2 = -[NSMapTable initWithKeyOptions:valueOptions:capacity:]( objc_alloc(&OBJC_CLASS___NSMapTable),  "initWithKeyOptions:valueOptions:capacity:",  2LL,  0LL,  8LL);
  id v3 = (void *)s_layerStreamMap;
  s_layerStreamMap = (uint64_t)v2;

  return _objc_addWillInitializeClassFunc(WrapCA, a1);
}

Class WrapCA(uint64_t a1, objc_class *a2)
{
  Class result = NSClassFromString(@"CAMetalLayer");
  if (result == a2)
  {
    id v5 = (objc_class *)objc_opt_class(&OBJC_CLASS___CAMetalLayer, v4);
    uint64_t v6 = NSSelectorFromString(@"init");
    InstanceMethod = class_getInstanceMethod(v5, v6);
    CAMetalLayer_initIMP = (uint64_t (*)(void))method_setImplementation(InstanceMethod, (IMP)CAMetalLayer_init);
    id v9 = (objc_class *)objc_opt_class(&OBJC_CLASS___CAMetalLayer, v8);
    __int128 v10 = NSSelectorFromString(@"shimDrawable:");
    Method v11 = class_getInstanceMethod(v9, v10);
    uint64_t v13 = (objc_class *)objc_opt_class(&OBJC_CLASS___CAMetalLayer, v12);
    if (v11)
    {
      id v14 = NSSelectorFromString(@"shimDrawable:");
      size_t v15 = &CAMetalLayer_shimDrawableIMP;
      __int128 v16 = (id (*)(id, SEL, ...))CAMetalLayer_shimDrawable;
    }

    else
    {
      id v14 = "nextDrawable";
      size_t v15 = (uint64_t *)&CAMetalLayer_nextDrawableIMP;
      __int128 v16 = (id (*)(id, SEL, ...))CAMetalLayer_nextDrawable;
    }

    __int128 v17 = class_getInstanceMethod(v13, v14);
    *size_t v15 = (uint64_t)method_setImplementation(v17, v16);
    __int128 v19 = (objc_class *)objc_opt_class(&OBJC_CLASS___CAMetalLayer, v18);
    uint64_t v20 = NSSelectorFromString(@"dealloc");
    id v21 = class_getInstanceMethod(v19, v20);
    CAMetalLayer_deallocIMP = (uint64_t (*)(void, void))method_setImplementation( v21,  (IMP)CAMetalLayer_dealloc);
    uint64_t v23 = (objc_class *)objc_opt_class(&OBJC_CLASS___CAMetalLayer, v22);
    class_addMethod(v23, "traceContext", (IMP)traceContextIMP, "^{GTTraceContext}@:");
    uint64_t v25 = (objc_class *)objc_opt_class(&OBJC_CLASS___CAMetalLayer, v24);
    class_addMethod(v25, "traceStream", (IMP)traceStreamIMP, "^{GTTraceStream}@:");
    uint64_t v27 = (objc_class *)objc_opt_class(&OBJC_CLASS___CAMetalLayer, v26);
    class_addMethod(v27, "streamReference", (IMP)streamReferenceIMP, "Q@:");
    id v29 = (objc_class *)objc_opt_class(&OBJC_CLASS___CAMetalLayer, v28);
    class_addMethod(v29, "baseObject", (IMP)baseObjectIMP, "@@:");
    id v31 = (objc_class *)objc_opt_class(&OBJC_CLASS___CAMetalLayer, v30);
    class_addMethod(v31, "touch", (IMP)touchIMP, "v@:");
    __int128 v33 = (objc_class *)objc_opt_class(&OBJC_CLASS___CAMetalLayer, v32);
    return (Class)class_addProtocol(v33, (Protocol *)&OBJC_PROTOCOL___CaptureMTLObject);
  }

  return result;
}

id CAMetalLayer_init()
{
  uint64_t inited = CAMetalLayer_initIMP();
  id v1 = (void *)objc_claimAutoreleasedReturnValue(inited);
  OpenLayerStream(v1);
  return v1;
}

CaptureMTLDrawable *CAMetalLayer_shimDrawable(void *a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = OpenLayerStream(a1);
  uint64_t v6 = g_ctx;
  if (v5) {
    uint64_t v7 = *v5;
  }
  else {
    uint64_t v7 = 0LL;
  }
  uint64_t v8 = (unint64_t *)(g_ctx + 72);
  do
    unint64_t v9 = __ldaxr(v8);
  while (__stlxr(v9 + 1, v8));
  uint64_t v23 = v6;
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  unint64_t v26 = v9;
  s();
  Method v11 = v10;
  uint64_t v12 = *v10;
  *__int128 v10 = v13;
  uint64_t v27 = v12;
  char v28 = *((_BYTE *)v10 + 8);
  __int16 v29 = 16400;
  int v30 = 0;
  char v31 = 0;
  *((_BYTE *)v10 + _Block_object_dispose(va, 8) = v28 | 3;
  if (v4) {
    id v14 = -[CaptureMTLDrawable initWithBaseObject:captureContext:]( objc_alloc(&OBJC_CLASS___CaptureMTLDrawable),  "initWithBaseObject:captureContext:",  v4,  v6);
  }
  else {
    id v14 = 0LL;
  }
  GTTraceEncoder_setStream(&v23, (uint64_t)-[CaptureMTLDrawable traceStream](v14, "traceStream"));
  uint64_t v15 = v25;
  *(_DWORD *)(v25 + _Block_object_dispose(va, 8) = -7166;
  char v16 = v29;
  if (v29 > 0x30uLL)
  {
    uint64_t v18 = *(void *)(v24 + 24);
    uint64_t v19 = HIBYTE(v29);
    ++HIBYTE(v29);
    __int128 v17 = GTTraceMemPool_allocateBytes(v18, v26, v19 | 0x1000000000LL) + 16;
    char v16 = v19;
  }

  else
  {
    __int128 v17 = (char *)(v15 + v29);
    LOBYTE(v29) = v29 + 16;
  }

  *(_BYTE *)(v15 + 13) = v16;
  uint64_t v20 = -[CaptureMTLDrawable traceStream](v14, "traceStream");
  if (v20) {
    unint64_t var0 = v20->var0;
  }
  else {
    unint64_t var0 = 0LL;
  }
  *(void *)__int128 v17 = v7;
  *((void *)v17 + 1) = var0;
  *Method v11 = v27;
  *((_BYTE *)v11 + _Block_object_dispose(va, 8) = v28;
  *(_BYTE *)(v25 + 15) |= 8u;

  return v14;
}

CaptureMTLDrawable *CAMetalLayer_nextDrawable(void *a1, uint64_t a2)
{
  id v4 = OpenLayerStream(a1);
  uint64_t v5 = g_ctx;
  if (v4) {
    uint64_t v6 = *v4;
  }
  else {
    uint64_t v6 = 0LL;
  }
  uint64_t v7 = (unint64_t *)(g_ctx + 72);
  do
    unint64_t v8 = __ldaxr(v7);
  while (__stlxr(v8 + 1, v7));
  uint64_t v24 = v5;
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  unint64_t v27 = v8;
  s();
  __int128 v10 = v9;
  uint64_t v11 = *v9;
  *unint64_t v9 = v12;
  uint64_t v28 = v11;
  char v29 = *((_BYTE *)v9 + 8);
  __int16 v30 = 16400;
  int v31 = 0;
  char v32 = 0;
  *((_BYTE *)v9 + _Block_object_dispose(va, 8) = v29 | 3;
  uint64_t DrawableIMP = CAMetalLayer_nextDrawableIMP(a1, a2);
  id v14 = (void *)objc_claimAutoreleasedReturnValue(DrawableIMP);
  if (v14) {
    uint64_t v15 = -[CaptureMTLDrawable initWithBaseObject:captureContext:]( objc_alloc(&OBJC_CLASS___CaptureMTLDrawable),  "initWithBaseObject:captureContext:",  v14,  v5);
  }
  else {
    uint64_t v15 = 0LL;
  }
  GTTraceEncoder_setStream(&v24, (uint64_t)-[CaptureMTLDrawable traceStream](v15, "traceStream"));
  uint64_t v16 = v26;
  *(_DWORD *)(v26 + _Block_object_dispose(va, 8) = -7166;
  char v17 = v30;
  if (v30 > 0x30uLL)
  {
    uint64_t v19 = *(void *)(v25 + 24);
    uint64_t v20 = HIBYTE(v30);
    ++HIBYTE(v30);
    uint64_t v18 = GTTraceMemPool_allocateBytes(v19, v27, v20 | 0x1000000000LL) + 16;
    char v17 = v20;
  }

  else
  {
    uint64_t v18 = (char *)(v16 + v30);
    LOBYTE(v3mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v30 + 16;
  }

  *(_BYTE *)(v16 + 13) = v17;
  id v21 = -[CaptureMTLDrawable traceStream](v15, "traceStream");
  if (v21) {
    unint64_t var0 = v21->var0;
  }
  else {
    unint64_t var0 = 0LL;
  }
  *(void *)uint64_t v18 = v6;
  *((void *)v18 + 1) = var0;
  *__int128 v10 = v28;
  *((_BYTE *)v10 + _Block_object_dispose(va, 8) = v29;
  *(_BYTE *)(v26 + 15) |= 8u;

  return v15;
}

uint64_t CAMetalLayer_dealloc(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v4 = StreamForLayer(v3);
  if (v4)
  {
    uint64_t v5 = v4;
    os_unfair_lock_lock(&s_layerMapLock);
    [(id)s_layerStreamMap removeObjectForKey:v3];
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([(id)s_layerStreamMap keyEnumerator]);
    LayerInfos = MakeLayerInfos(v6);
    unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(LayerInfos);

    os_unfair_lock_unlock(&s_layerMapLock);
    GTMTLGuestAppClientUpdateCAMetalLayerInfo(g_guestAppClientMTL, v8);
    GTTelemetry_removeStreamRef((uint64_t)[v3 streamReference]);
    GTTraceContext_closeStream(g_ctx, v5);
  }

  return CAMetalLayer_deallocIMP(v3, a2);
}

uint64_t traceContextIMP()
{
  return g_ctx;
}

id streamReferenceIMP(void *a1)
{
  id result = StreamForLayer(a1);
  if (result) {
    return *(id *)result;
  }
  return result;
}

id baseObjectIMP(void *a1)
{
  return a1;
}

uint64_t touchIMP(void *a1)
{
  id v1 = (unint64_t *)StreamForLayer(a1);
  uint64_t result = mach_absolute_time();
  if (v1)
  {
    id v3 = v1 + 7;
    unint64_t v4 = atomic_load(v1 + 7);
    while (1)
    {
      unint64_t v5 = __ldaxr(v3);
      if (v5 != v4) {
        break;
      }
      if (__stlxr(v4 & 0x1F | result & 0xFFFFFFFFFFFFFFE0LL, v3)) {
        goto LABEL_7;
      }
      int v6 = 1;
LABEL_8:
      unint64_t v4 = v5;
      if (v6) {
        return result;
      }
    }

    __clrex();
LABEL_7:
    int v6 = 0;
    goto LABEL_8;
  }

  return result;
}

id StreamForLayer(void *a1)
{
  id v1 = a1;
  BOOL v2 = os_unfair_lock_trylock(&s_layerMapLock);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([(id)s_layerStreamMap objectForKey:v1]);

  if (v2) {
    os_unfair_lock_unlock(&s_layerMapLock);
  }
  if (v3) {
    id v4 = [v3 pointerValue];
  }
  else {
    id v4 = 0LL;
  }

  return v4;
}

uint64_t *OpenLayerStream(void *a1)
{
  id v1 = a1;
  BOOL v2 = (uint64_t *)StreamForLayer(v1);
  if (!v2)
  {
    BOOL v2 = (uint64_t *)GTTraceContext_openStream(g_ctx, (unint64_t)v1, (unint64_t)v1);
    os_unfair_lock_lock(&s_layerMapLock);
    id v3 = (void *)s_layerStreamMap;
    id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSValue valueWithPointer:](&OBJC_CLASS___NSValue, "valueWithPointer:", v2));
    [v3 setObject:v4 forKey:v1];

    unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([(id)s_layerStreamMap keyEnumerator]);
    LayerInfos = MakeLayerInfos(v5);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(LayerInfos);

    os_unfair_lock_unlock(&s_layerMapLock);
    GTMTLGuestAppClientUpdateCAMetalLayerInfo(g_guestAppClientMTL, v7);
    GTTelemetry_addStreamRef((uint64_t)[v1 streamReference]);
    id v8 = MTLCreateSystemDefaultDevice();
    uint64_t v9 = g_ctx;
    id v10 = v8;
    if (v2) {
      uint64_t v11 = *v2;
    }
    else {
      uint64_t v11 = 0LL;
    }
    GTTraceContext_pushEncoderWithStream(v9, (uint64_t)v24);
    uint64_t v12 = v25;
    *(_DWORD *)(v25 + _Block_object_dispose(va, 8) = -7163;
    unsigned __int8 v13 = v28;
    if (v28 > 0x28uLL)
    {
      uint64_t v15 = *(void *)(v24[1] + 24LL);
      uint64_t v16 = v29++;
      id v14 = GTTraceMemPool_allocateBytes(v15, v26, v16 | 0x1800000000LL) + 16;
      unsigned __int8 v13 = v16;
    }

    else
    {
      id v14 = (char *)(v12 + v28);
      v28 += 24;
    }

    *(_BYTE *)(v12 + 13) = v13;
    char v17 = (uint64_t *)[v10 traceStream];
    if (v17) {
      uint64_t v18 = *v17;
    }
    else {
      uint64_t v18 = 0LL;
    }
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v10 baseObject]);

    char v20 = SaveMTLDeviceDescriptor((uint64_t)v24, v19);
    *(void *)id v14 = v11;
    *((void *)v14 + 1) = v18;
    v14[16] = v20;
    *(_DWORD *)(v14 + 17) = 0;
    *((_DWORD *)v14 + 5) = 0;

    s();
    *(void *)uint64_t v21 = v22;
    *(_BYTE *)(v21 + _Block_object_dispose(va, 8) = v27;
    *(_BYTE *)(v25 + 15) |= 8u;
  }

  return v2;
}

id ColorSpaceData(CGColorSpace *a1)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  if (!a1) {
    return 0LL;
  }
  BOOL v2 = objc_autoreleasePoolPush();
  id v3 = (void *)CGColorSpaceCopyPropertyList(a1);
  if (v3)
  {
    id v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  v3,  200LL,  0LL,  0LL,  v7,  v8));
    HIDWORD(v_Block_object_dispose(va, 8) = [v4 length];
    unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithBytes:length:]( &OBJC_CLASS___NSMutableData,  "dataWithBytes:length:",  &v7,  16LL));
    [v5 appendData:v4];
  }

  else
  {
    unint64_t v5 = 0LL;
  }

  objc_autoreleasePoolPop(v2);
  return v5;
}

void GTEncodeMetalLayers(uint64_t a1, uint64_t a2)
{
  BOOL v2 = (void *)objc_claimAutoreleasedReturnValue(+[CADisplay mainDisplay](&OBJC_CLASS___CADisplay, "mainDisplay"));
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 currentOrientation]);
  if ([v3 isEqualToString:@"rot0"])
  {
    int v4 = 1;
  }

  else if ([v3 isEqualToString:@"rot90"])
  {
    int v4 = 4;
  }

  else if ([v3 isEqualToString:@"rot180"])
  {
    int v4 = 2;
  }

  else if ([v3 isEqualToString:@"rot270"])
  {
    int v4 = 3;
  }

  else
  {
    int v4 = 1;
  }

  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(v5 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(v5 + 16) = 0LL;
  *(void *)(v5 + 24) = 0LL;
  *(void *)(v5 + 32) = 0x694300000000LL;
  *(void *)uint64_t v5 = 0xFFFFE40D00000028LL;
  *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0LL;
  *(_DWORD *)(v5 + 4_Block_object_dispose(va, 8) = v4;
  *(_DWORD *)uint64_t v5 = 52;
  int v6 = *(unsigned int **)(a1 + 8);
  unsigned int v7 = v6[8];
  _OWORD v6[8] = v7 | 0x10004;
  uint64_t v8 = *v6;
  if ((v7 & 0x1000) != 0)
  {
    id v10 = v6;
    unint64_t v9 = *v6;
    do
    {
      id v10 = (unsigned int *)((char *)v10 + v8);
      uint64_t v8 = *v10;
      v9 += v8;
    }

    while ((*((_BYTE *)v10 + 33) & 0x20) == 0);
  }

  else
  {
    unint64_t v9 = *v6;
  }

  fbstream_write(*(void *)(a1 + 24), (uint64_t)v6, v9);
  os_unfair_lock_lock(&s_layerMapLock);
  uint64_t v11 = objc_alloc(&OBJC_CLASS___NSMutableArray);
  uint64_t v12 = -[NSMutableArray initWithCapacity:](v11, "initWithCapacity:", [(id)s_layerStreamMap count]);
  memset(&v100, 0, 64);
  id v13 = (id)s_layerStreamMap;
  id v14 = [v13 countByEnumeratingWithState:&v100 objects:v101 count:16];
  if (v14)
  {
    id v15 = v14;
    uint64_t v16 = **(void **)&v100.m13;
    do
    {
      for (uint64_t i = 0LL; i != v15; uint64_t i = (char *)i + 1)
      {
        if (**(void **)&v100.m13 != v16) {
          objc_enumerationMutation(v13);
        }
        -[NSMutableArray addObject:](v12, "addObject:", *(void *)(*(void *)&v100.m12 + 8LL * (void)i));
      }

      id v15 = [v13 countByEnumeratingWithState:&v100 objects:v101 count:16];
    }

    while (v15);
  }

  os_unfair_lock_unlock(&s_layerMapLock);
  __int128 v89 = 0u;
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  __int128 v92 = 0u;
  obuint64_t j = v12;
  uint64_t v18 = a2;
  uint64_t v19 = a1;
  id v88 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v89,  v111,  16LL);
  if (v88)
  {
    uint64_t v87 = *(void *)v90;
    double height = CGSizeZero.height;
    do
    {
      uint64_t v21 = 0LL;
      do
      {
        if (*(void *)v90 != v87) {
          objc_enumerationMutation(obj);
        }
        uint64_t v22 = *(void **)(*((void *)&v89 + 1) + 8LL * (void)v21);
        uint64_t v23 = objc_autoreleasePoolPush();
        id v24 = ColorSpaceData((CGColorSpace *)[v22 colorspace]);
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
        id v26 = v22;
        memset(v101, 0, sizeof(v101));
        __int128 v102 = 0u;
        memset(&v103, 0, sizeof(v103));
        __int128 v104 = 0u;
        __int128 v105 = 0u;
        __int128 v106 = 0u;
        __int128 v107 = 0u;
        __int128 v108 = 0u;
        __int128 v109 = 0u;
        uint64_t v110 = 0LL;
        id v27 = (id)objc_claimAutoreleasedReturnValue([v26 device]);
        if (!v27) {
          id v27 = MTLCreateSystemDefaultDevice();
        }
        id v28 = [v27 streamReference];
        *((void *)&v102 + 1) = v28;
        BYTE2(v11mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v26 framebufferOnly];
        LOWORD(v11mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = (unsigned __int16)[v26 pixelFormat];
        [v26 drawableSize];
        double v31 = v30;
        double width = CGSizeZero.width;
        if (CGSizeZero.width == v31 && height == v29)
        {
          objc_msgSend(v26, "bounds", CGSizeZero.width);
          double v35 = v34;
          [v26 contentsScale];
          double v31 = v36 * v35;
          [v26 bounds];
          double v38 = v37;
          [v26 contentsScale];
          double v29 = width * v38;
        }

        *(double *)&__int128 v104 = v31;
        *((double *)&v104 + 1) = v29;
        objc_msgSend(v26, "bounds", width);
        double v40 = v39;
        double v42 = v41;
        *((void *)&v106 + 1) = v43;
        *(void *)&__int128 v107 = v44;
        *((double *)&v107 + 1) = v39;
        *(double *)&__int128 v108 = v41;
        [v26 contentsScale];
        *(void *)&__int128 v106 = v45;
        if (IsCompositorProcess_isCompositorProcess || (Class v48 = NSClassFromString(@"UIScreen")) == 0LL)
        {
          double m14 = 240.0;
          double m13 = 320.0;
        }

        else
        {
          Class v49 = v48;
          id v50 = -[objc_class performSelector:](v48, "performSelector:", sel_getUid("mainScreen"));
          uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
          SEL v52 = NSSelectorFromString(@"bounds");
          __int128 v53 = (void *)objc_claimAutoreleasedReturnValue( -[objc_class instanceMethodSignatureForSelector:]( v49,  "instanceMethodSignatureForSelector:",  v52));
          uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSInvocation invocationWithMethodSignature:]( &OBJC_CLASS___NSInvocation,  "invocationWithMethodSignature:",  v53));

          [v54 setSelector:v52];
          [v54 invokeWithTarget:v51];
          [v54 getReturnValue:&v100];
          if (v100.m13 >= v100.m14) {
            double m13 = v100.m13;
          }
          else {
            double m13 = v100.m14;
          }
          if (v100.m13 >= v100.m14) {
            double m14 = v100.m14;
          }
          else {
            double m14 = v100.m13;
          }

          uint64_t v19 = a1;
          uint64_t v18 = a2;
        }

        id v55 = v26;
        [v55 position];
        CGFloat v57 = v56;
        [v55 position];
        CGFloat v59 = v58;
        [v55 zPosition];
        CATransform3DMakeTranslation(&v100, v57, v59, v60);
        if (v55) {
          [v55 transform];
        }
        else {
          memset(&a, 0, sizeof(a));
        }
        CATransform3D b = v100;
        CATransform3DConcat(&v93, &a, &b);
        uint64_t v61 = objc_claimAutoreleasedReturnValue([v55 superlayer]);
        if (v61)
        {
          uint64_t v62 = (void *)v61;
          do
          {
            [v62 anchorPoint];
            double v64 = v63;
            [v62 bounds];
            double v66 = v65;
            [v62 anchorPoint];
            double v68 = v67;
            [v62 bounds];
            CGFloat v69 = -(v64 * v66);
            CGFloat v71 = -(v68 * v70);
            [v62 anchorPointZ];
            CATransform3DMakeTranslation(&b, v69, v71, -v72);
            CATransform3D v100 = b;
            CATransform3D v97 = v93;
            CATransform3D v96 = b;
            CATransform3DConcat(&b, &v97, &v96);
            CATransform3D v93 = b;
            [v62 transform];
            CATransform3D v97 = v93;
            CATransform3DConcat(&b, &v97, &v95);
            CATransform3D v93 = b;
            [v62 sublayerTransform];
            CATransform3D v97 = v93;
            CATransform3DConcat(&b, &v97, &v94);
            CATransform3D v93 = b;
            [v62 position];
            CGFloat v74 = v73;
            [v62 position];
            CGFloat v76 = v75;
            [v62 zPosition];
            CATransform3DMakeTranslation(&b, v74, v76, v77);
            CATransform3D v100 = b;
            CATransform3D v97 = v93;
            CATransform3D v96 = b;
            CATransform3DConcat(&b, &v97, &v96);
            CATransform3D v93 = b;
            uint64_t v78 = objc_claimAutoreleasedReturnValue([v62 superlayer]);

            uint64_t v62 = (void *)v78;
          }

          while (v78);
        }

        if (v40 >= v42) {
          double v79 = v42;
        }
        else {
          double v79 = v40;
        }
        if (v40 < v42) {
          double v40 = v42;
        }

        CATransform3D v103 = v93;
        *((double *)&v108 + 1) = m13 / v40;
        *(double *)&__int128 v109 = m14 / v79;
        [v55 anchorPoint];
        *(void *)&__int128 v105 = v80;
        *((void *)&v105 + 1) = v81;

        id v82 = v25;
        *((void *)&v109 + 1) = [v82 bytes];
        if (v28 == *(id *)(v18 + 56))
        {
          __int128 v83 = *(_OWORD *)(v19 + 16);
          *(_OWORD *)&v100.m11 = *(_OWORD *)v19;
          *(_OWORD *)&v100.double m13 = v83;
          *(_OWORD *)&v100.m21 = *(_OWORD *)(v19 + 32);
          v100.m23 = *(CGFloat *)(v19 + 48);
          *(void *)&v100.m11 = v55;
          WriteGTMTLSMLayer((uint64_t)&v100, v18, (uint64_t)v101);
        }

        objc_autoreleasePoolPop(v23);
        uint64_t v21 = (char *)v21 + 1;
      }

      while (v21 != v88);
      id v88 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v89,  v111,  16LL);
    }

    while (v88);
  }
}

void *GTMTLDescriptorAllocator_copyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!a2) {
    return 0LL;
  }
  CFErrorRef error = 0LL;
  int v6 = -[NSData initWithBytesNoCopy:length:freeWhenDone:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytesNoCopy:length:freeWhenDone:",  a2,  a3,  0LL);
  unsigned int v7 = (void *)CFPropertyListCreateWithData(0LL, (CFDataRef)v6, 0LL, 0LL, &error);
  if (error)
  {
    uint64_t v8 = CFErrorCopyDescription(error);
    unint64_t v9 = v8;
    if (s_logUsingOsLog)
    {
      id v10 = gt_default_log();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
        *(_DWORD *)buf = 136315138;
        uint64_t v23 = CStringPtr;
        _os_log_error_impl(&dword_0, v11, OS_LOG_TYPE_ERROR, "warning: %s", buf, 0xCu);
      }
    }

    else
    {
      id v13 = __stderrp;
      id v14 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"warning: %s",  CFStringGetCStringPtr(v8, 0x8000100u));
      uint64_t v11 = (os_log_s *) objc_claimAutoreleasedReturnValue(v14);
      fprintf(v13, "%s\n", (const char *)-[os_log_s UTF8String](v11, "UTF8String"));
    }

    CFRelease(v9);
    CFRelease(error);
  }

  if (!v7) {
    return 0LL;
  }
  id v15 = objc_autoreleasePoolPush();
  id v16 = objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver, "archivedDataWithRootObject:requiringSecureCoding:error:", v7, 1LL, 0LL));
  id v17 = [v16 bytes];
  size_t v18 = (size_t)[v16 length];
  if (v18) {
    uint64_t v19 = *(void **)(a1 + 416);
  }
  else {
    uint64_t v19 = 0LL;
  }
  *(void *)(a1 + 416) += v18;
  if (a4) {
    memcpy(v19, v17, v18);
  }

  objc_autoreleasePoolPop(v15);
  return v19;
}

uint64_t GTAccelerationStructureDescriptorDownloader_needsDownloader(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    unsigned int v2 = 0;
    while (1)
    {
      unsigned int v3 = atomic_load((unsigned int *)(v1 + 4));
      uint64_t v4 = v2 + (v3 >> 6) - 1;
      uint64_t v1 = *(void *)(v1 + 40);
      unsigned int v2 = v4;
      if (!v1)
      {
        unsigned int v2 = v4;
        goto LABEL_8;
      }
    }
  }

  else
  {
    unsigned int v2 = 0;
  }

  uint64_t v4 = 0LL;
LABEL_8:
  unint64_t v5 = v2 | (unint64_t)(v4 << 32);
LABEL_9:
  uint64_t v6 = v1 + 64;
  while (v1 && (*(_BYTE *)(v6 + ((uint64_t)(HIDWORD(v5) - (int)v5) << 6) + 15) & 8) != 0)
  {
    int v7 = *(_DWORD *)(v6 + ((uint64_t)(HIDWORD(v5) - (int)v5) << 6) + 8);
    uint64_t result = 1LL;
    BOOL v10 = (v7 + 15524) > 0x3B || ((1LL << (v7 - 92)) & 0xC00000000000003LL) == 0;
    if (!v10 || v7 == -15366) {
      return result;
    }
    unsigned int v12 = atomic_load((unsigned int *)(v1 + 4));
    uint64_t v13 = (HIDWORD(v5) + 1);
    int v14 = v5 + (v12 >> 6) - 1;
    unint64_t v5 = (v13 << 32) | v5;
    if ((_DWORD)v13 == v14)
    {
      unint64_t v5 = (v13 << 32) | v13;
      uint64_t v1 = *(void *)(v1 + 40);
      goto LABEL_9;
    }
  }

  return 0LL;
}

apr_pool_t **GTAccelerationStructureDescriptorDownloader_make( void *a1, void *a2, apr_pool_t *a3, apr_pool_t *a4, apr_pool_t *a5)
{
  id v10 = a2;
  id v11 = DEVICEOBJECT(a1);
  unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  uint64_t v13 = apr_palloc(a5, 0x28uLL);
  int v14 = (apr_pool_t **)v13;
  if (v13)
  {
    *((void *)v13 + 4) = 0LL;
    *(_OWORD *)uint64_t v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
  }

  objc_storeStrong((id *)v13 + 4, a2);
  NSString *v14 = a5;
  v14[1] = a3;
  v14[2] = a4;
  id v15 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  id v16 = v14[3];
  v14[3] = (apr_pool_t *)v15;

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __GTAccelerationStructureDescriptorDownloader_make_block_invoke;
  block[3] = &unk_20E0C8;
  uint64_t v23 = v12;
  uint64_t v17 = s_accelerationStructureDescriptorDownloaderPipelinesToken;
  id v18 = v12;
  uint64_t v19 = v18;
  if (v17 == -1)
  {
    char v20 = v18;
  }

  else
  {
    dispatch_once(&s_accelerationStructureDescriptorDownloaderPipelinesToken, block);
    char v20 = v23;
  }

  return v14;
}

void BuildPipelines(void *a1)
{
  id v1 = a1;
  unsigned int v2 = objc_alloc_init(&OBJC_CLASS___MTLCompileOptions);
  uint64_t v4 = +[NSBundle bundleForClass:]( &OBJC_CLASS___NSBundle,  "bundleForClass:",  objc_opt_class(&OBJC_CLASS___CaptureMTLAccelerationStructure, v3));
  unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  uint64_t v6 = v5;
  if (v5)
  {
    int v7 = (void *)objc_claimAutoreleasedReturnValue([v5 URLForResource:@"default" withExtension:@"metallib"]);
    if (v7)
    {
      id v36 = 0LL;
      id v8 = [v1 newLibraryWithURL:v7 error:&v36];
      id v9 = v36;
      if (v8)
      {
        id v10 = [v8 newFunctionWithName:@"CopyAccelerationStructureState"];
        id v35 = v9;
        id v11 = [v1 newComputePipelineStateWithFunction:v10 error:&v35];
        id v12 = v35;

        if (v11)
        {
          id v34 = v12;
          id v30 = [v8 newFunctionWithName:@"ClearAccelerationStructureChildren"];
          id v13 = objc_msgSend(v1, "newComputePipelineStateWithFunction:error:");
          id v14 = v34;

          if (v13)
          {
            obuint64_t j = v13;
            id v33 = v14;
            id v28 = [v8 newFunctionWithName:@"FillInstanceHeader"];
            id v15 = objc_msgSend(v1, "newComputePipelineStateWithFunction:error:");
            id v16 = v33;

            if (v15)
            {
              id v17 = [v8 newFunctionWithName:@"GetAccelerationStructureChildren"];
              if (v17)
              {
                id v26 = v10;
                id v32 = v16;
                id v18 = [v1 newComputePipelineStateWithFunction:v17 error:&v32];
                id v27 = v32;

                uint64_t v19 = v18;
                if (v18)
                {
                  id v20 = [v8 newFunctionWithName:@"MarkAccelerationStructureChildren"];
                  uint64_t v21 = v20;
                  if (v20)
                  {
                    id v24 = v20;
                    id v25 = v17;
                    id v31 = v27;
                    id v22 = [v1 newComputePipelineStateWithFunction:v20 error:&v31];
                    id v23 = v31;

                    id v10 = v26;
                    if (v22)
                    {
                      objc_storeStrong((id *)&s_downloaderPipelines_0, v15);
                      objc_storeStrong((id *)&s_downloaderPipelines_1, v11);
                      objc_storeStrong((id *)&s_downloaderPipelines_2, obj);
                      objc_storeStrong((id *)&s_downloaderPipelines_3, v19);
                      objc_storeStrong((id *)&s_downloaderPipelines_4, v22);
                    }

                    id v27 = v23;
                    uint64_t v21 = v24;
                    id v17 = v25;
                  }

                  else
                  {
                    id v10 = v26;
                  }
                }

                else
                {
                  id v10 = v26;
                }

                id v16 = v27;
              }
            }

            id v14 = v16;
            id v13 = obj;
          }

          id v12 = v14;
        }

        id v9 = v12;
      }
    }
  }
}

void GTAccelerationStructureDescriptorDownloader_preProcessFunc(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(_DWORD *)(a2 + 8);
  if (v4 > -15524)
  {
    if (v4 != -15523 && v4 != -15466)
    {
      int v5 = -15465;
LABEL_8:
      if (v4 != v5) {
        return;
      }
    }
  }

  else
  {
    if ((v4 + 15646) < 2)
    {
      uint64_t v6 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v3) + 16;
      goto LABEL_11;
    }

    if (v4 != -15647)
    {
      int v5 = -15524;
      goto LABEL_8;
    }
  }

  uint64_t v6 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v3) + 8;
LABEL_11:
  id v7 = AccelerationStructureByStreamRef(a1, *(void *)v6);
  id v8 = (id)objc_claimAutoreleasedReturnValue(v7);
  [*(id *)(a1 + 24) addObject:v8];
}

id AccelerationStructureByStreamRef(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unsigned int v2 = *(void **)(a1 + 32);
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a2));
    int v4 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKey:v3]);
  }

  else
  {
    int v4 = 0LL;
  }

  return v4;
}

void GTAccelerationStructureDescriptorDownloader_allocateStateBuffers(uint64_t a1, void *a2)
{
  id v3 = a2;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v4 = *(id *)(a1 + 24);
  id v5 = [v4 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v15;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v14 + 1) + 8LL * (void)i);
        if (v9)
        {
          id v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((void *)&v14 + 1) + 8 * (void)i), "stateBuffer", (void)v14));
          if (!v10)
          {
            id v11 = [v3 newBufferWithLength:16 options:0];
            id v12 = [v11 contents];
            unsigned int v13 = v12[1] & 0xFFFFFFF0;
            *id v12 = 0;
            v12[1] = v13;
            [v9 setStateBuffer:v11];
          }
        }
      }

      id v6 = [v4 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }

    while (v6);
  }
}

void GTAccelerationStructureDescriptorDownloader_processFunc(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void *)(a1 + 8);
  apr_pool_create_ex(&newpool, *(apr_pool_t **)a1, 0LL, 0LL);
  int v7 = *(_DWORD *)(a2 + 8);
  if (v7 > -15524)
  {
    switch(v7)
    {
      case -15523:
        id v33 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v6);
        id v34 = AccelerationStructureByStreamRef(a1, *((void *)v33 + 1));
        id v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
        id v36 = (void *)objc_claimAutoreleasedReturnValue([v35 captureDescriptor]);
        unint64_t v37 = ((unint64_t)[v36 usage] >> 2) & 1;

        ClearAccelerationStructureChildren(v5, v35, v37);
        break;
      case -15466:
LABEL_26:
        double v38 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v6);
        id v39 = AccelerationStructureByStreamRef(a1, *((void *)v38 + 1));
        id v10 = (void *)objc_claimAutoreleasedReturnValue(v39);
        double v40 = (void *)objc_claimAutoreleasedReturnValue([v10 captureDescriptor]);
        unint64_t v41 = (unint64_t)[v40 usage];

        double v42 = (int *)GTTraceFunc_argumentBytesWithMap((void *)a2, v38[32], v6);
        FillInstanceAccelerationStructureHeader(v5, v10, *v42, (v41 >> 2) & 1);
        goto LABEL_27;
      case -15465:
        id v8 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v6);
        id v9 = AccelerationStructureByStreamRef(a1, *((void *)v8 + 1));
        id v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
        id v11 = GTTraceFunc_argumentBytesWithMap((void *)a2, v8[32], v6);
        ClearAccelerationStructureChildren(v5, v10, (v11[1] >> 2) & 1);
LABEL_27:

        break;
    }
  }

  else
  {
    if ((v7 + 15646) < 2)
    {
      id v12 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v6);
      id v13 = AccelerationStructureByStreamRef(a1, *((void *)v12 + 1));
      id v10 = (void *)objc_claimAutoreleasedReturnValue(v13);
      id v14 = AccelerationStructureByStreamRef(a1, *((void *)v12 + 2));
      uint64_t v15 = objc_claimAutoreleasedReturnValue(v14);
      __int128 v16 = (void *)v15;
      if (v10) {
        BOOL v17 = v15 == 0;
      }
      else {
        BOOL v17 = 1;
      }
      if (!v17)
      {
        id v18 = (void *)objc_claimAutoreleasedReturnValue([v10 stateBuffer]);
        if (v18)
        {
          uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v16 stateBuffer]);

          if (v19)
          {
            int v52 = *(_DWORD *)(a2 + 8) == -15645;
            [v5 insertDebugSignpost:@"CopyAccelerationStructureState"];
            [v5 setComputePipelineState:s_downloaderPipelines_1];
            id v20 = (void *)objc_claimAutoreleasedReturnValue([v10 stateBuffer]);
            [v5 setBuffer:v20 offset:0 atIndex:0];

            uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v16 stateBuffer]);
            [v5 setBuffer:v21 offset:0 atIndex:1];

            [v5 setBytes:&v52 length:4 atIndex:6];
            int64x2_t v46 = vdupq_n_s64(1uLL);
            uint64_t v47 = 1LL;
            int64x2_t v44 = v46;
            uint64_t v45 = 1LL;
            [v5 dispatchThreads:&v46 threadsPerThreadgroup:&v44];
          }
        }
      }

      goto LABEL_27;
    }

    if (v7 == -15647)
    {
      id v22 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v6);
      id v23 = AccelerationStructureByStreamRef(a1, *((void *)v22 + 1));
      id v10 = (void *)objc_claimAutoreleasedReturnValue(v23);
      if (v10)
      {
        id v24 = GTTraceFunc_argumentBytesWithMap((void *)a2, v22[32], v6);
        int v52 = (v24[1] >> 2) & 1;
        [v5 setBytes:&v52 length:4 atIndex:7];
        int v25 = *v24;
        switch(v25)
        {
          case 1:
            ClearAccelerationStructureChildren(v5, v10, v52 != 0);
            break;
          case 2:
            uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v10 stateBuffer]);

            if (v43) {
              FillInstanceAccelerationStructureHeader(v5, v10, *((_DWORD *)v24 + 16), v52 != 0);
            }
            break;
          case 3:
            id v26 = (void *)objc_claimAutoreleasedReturnValue([v10 stateBuffer]);

            if (v26)
            {
              id v27 = AccelerationStructureByStreamRef(a1, *((void *)v24 + 3));
              id v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
              double v29 = v28;
              if (v28)
              {
                id v30 = DEVICEOBJECT(v28);
                id v31 = (void *)objc_claimAutoreleasedReturnValue(v30);

                [v5 insertDebugSignpost:@"BuildInstanceIndirect"];
                [v5 setBuffer:v31 offset:*((void *)v24 + 4) atIndex:4];
                id v32 = (void *)objc_claimAutoreleasedReturnValue([v10 stateBuffer]);
                [v5 setBuffer:v32 offset:0 atIndex:1];

                [v5 setBytes:&v52 length:4 atIndex:7];
                [v5 setComputePipelineState:s_downloaderPipelines_0];
                int64x2_t v50 = vdupq_n_s64(1uLL);
                uint64_t v51 = 1LL;
                int64x2_t v48 = v50;
                uint64_t v49 = 1LL;
                [v5 dispatchThreads:&v50 threadsPerThreadgroup:&v48];
              }
            }

            break;
        }
      }

      goto LABEL_27;
    }

    if (v7 == -15524) {
      goto LABEL_26;
    }
  }

  apr_pool_destroy(newpool);
}

void sub_700D4(_Unwind_Exception *a1)
{
}

void ClearAccelerationStructureChildren(void *a1, void *a2, int a3)
{
  id v5 = a1;
  id v6 = a2;
  int v7 = (void *)objc_claimAutoreleasedReturnValue([v6 stateBuffer]);

  if (v7)
  {
    int v13 = a3;
    int v14 = 1;
    [v5 insertDebugSignpost:@"ClearPrimitiveAccelerationStructureChildren"];
    [v5 setComputePipelineState:s_downloaderPipelines_2];
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v6 stateBuffer]);
    [v5 setBuffer:v8 offset:0 atIndex:1];

    [v5 setBytes:&v14 length:4 atIndex:5];
    [v5 setBytes:&v13 length:4 atIndex:7];
    int64x2_t v11 = vdupq_n_s64(1uLL);
    uint64_t v12 = 1LL;
    int64x2_t v9 = v11;
    uint64_t v10 = 1LL;
    [v5 dispatchThreads:&v11 threadsPerThreadgroup:&v9];
  }
}

void FillInstanceAccelerationStructureHeader(void *a1, void *a2, int a3, int a4)
{
  int v12 = a4;
  int v13 = a3;
  id v5 = a2;
  id v6 = a1;
  [v6 insertDebugSignpost:@"FillInstanceAccelerationStructureHeader"];
  [v6 setComputePipelineState:s_downloaderPipelines_0];
  [v6 setBytes:&v13 length:4 atIndex:4];
  int v7 = (void *)objc_claimAutoreleasedReturnValue([v5 stateBuffer]);

  [v6 setBuffer:v7 offset:0 atIndex:1];
  [v6 setBytes:&v12 length:4 atIndex:7];
  int64x2_t v10 = vdupq_n_s64(1uLL);
  uint64_t v11 = 1LL;
  int64x2_t v8 = v10;
  uint64_t v9 = 1LL;
  [v6 dispatchThreads:&v10 threadsPerThreadgroup:&v8];
}

void GTAccelerationStructureDescriptorDownloader_postProcess( uint64_t a1, void *a2, void *a3, uint64_t a4, char a5, void *a6, uint64_t a7)
{
  id v13 = a2;
  id v14 = a3;
  id v15 = a6;
  if ((a5 & 1) != 0)
  {
    id v16 = [*(id *)(a1 + 24) copy];
    if ([v16 count])
    {
      BOOL v17 = (os_log_s *)g_signpostLog;
      if (os_signpost_enabled((os_log_t)g_signpostLog))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  v17,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "GTAccelerationStructureDescriptorDownloader_postProcess",  "",  buf,  2u);
      }

      signed int v18 = [v16 count];
      uint64_t v19 = v18;
      id v20 = (unint64_t *)(a7 + 72);
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 + v18, v20));
      id v22 = (void *)objc_claimAutoreleasedReturnValue([v15 device]);
      id v23 = (dispatch_group_s *)objc_claimAutoreleasedReturnValue([v22 dispatchGroup]);
      dispatch_group_enter(v23);

      id v24 = (os_log_s *)g_signpostLog;
      if (os_signpost_enabled((os_log_t)g_signpostLog))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  v24,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "GTAccelerationStructureDescriptorDownloader_postProcess",  "",  buf,  2u);
      }

      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472LL;
      v26[2] = __GTAccelerationStructureDescriptorDownloader_postProcess_block_invoke;
      v26[3] = &unk_20DC40;
      unint64_t v30 = v21;
      uint64_t v31 = v19;
      id v27 = v16;
      uint64_t v32 = a7;
      id v28 = v15;
      id v29 = v22;
      id v25 = v22;
      [v13 notifyListener:v14 atValue:a4 block:v26];
    }

    else
    {
      [v13 setSignaledValue:a4 + 1];
    }
  }

  else
  {
    [v13 setSignaledValue:a4 + 1];
  }
}

id GTAccelerationStructureDescriptorDownloader_children(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  id v82 = objc_autoreleasePoolPush();
  LODWORD(a3) = GTAccelerationStructureDescriptorDownloader_childrenCount(v6);
  int64x2_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 objectAtIndexedSubscript:0]);
  unint64_t v9 = 12 * [v8 count];
  id v10 = v6;
  id v11 = v7;
  int v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBuffer]);
  [v12 setLabel:@"com.apple.internal.gputools.DownloadAccelerationStructure"];
  id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 device]);
  id v88 = v10;
  unsigned int v14 = GTAccelerationStructureDescriptorDownloader_childrenCount(v10);
  id v15 = (void *)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:0]);
  id v16 = (void *)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:1]);
  int v86 = v15;
  BOOL v17 = (void *)objc_claimAutoreleasedReturnValue([v15 allValues]);
  uint64_t v87 = v12;
  uint64_t v18 = objc_claimAutoreleasedReturnValue([v12 computeCommandEncoder]);
  double v79 = v11;
  uint64_t v80 = v8;
  __int128 v83 = v13;
  id v84 = (void *)v18;
  __int16 v85 = v16;
  if (v9 < 8 * (unint64_t)a3)
  {
    id v76 = v5;
    CGFloat v77 = v17;
    double v75 = (void *)objc_claimAutoreleasedReturnValue([v16 allKeys]);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v75 sortedArrayUsingSelector:"compare:"]);
    uint64_t v20 = [v19 count];
    id v21 = [v13 newBufferWithLength:8 * v20 options:0];
    id v22 = [v21 contents];
    if (v20)
    {
      id v23 = v22;
      for (uint64_t i = 0LL; i != v20; ++i)
      {
        id v25 = (void *)objc_claimAutoreleasedReturnValue([v19 objectAtIndexedSubscript:i]);
        v23[i] = [v25 longLongValue];
      }
    }

    id v26 = [v13 newBufferWithLength:4 * v20 options:0];
    id v27 = v84;
    id v28 = v19;
    id v29 = v88;
    v100[0] = v14;
    id v30 = v21;
    id v31 = v26;
    if (v14)
    {
      blocuint64_t k = _NSConcreteStackBlock;
      uint64_t v96 = 3221225472LL;
      CATransform3D v97 = __GTAccelerationStructureDescriptorDownloader_markChildren_block_invoke;
      __int128 v98 = &unk_20E0C8;
      id v32 = v27;
      id v33 = v32;
      id v99 = v32;
      if (s_accelerationStructureDescriptorDownloaderPipelinesToken == -1)
      {
        id v34 = v32;
      }

      else
      {
        dispatch_once(&s_accelerationStructureDescriptorDownloaderPipelinesToken, &block);
        id v34 = v99;
      }

      id v35 = [(id)s_downloaderPipelines_4 threadExecutionWidth];
      unsigned int v90 = [v28 count];
      [v33 setComputePipelineState:s_downloaderPipelines_4];
      id v36 = DEVICEOBJECT(v29);
      unint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(v36);
      [v33 setAccelerationStructure:v37 atBufferIndex:8];

      [v33 setBytes:v100 length:4 atIndex:4];
      [v33 setBytes:&v90 length:4 atIndex:12];
      [v33 setBuffer:v30 offset:0 atIndex:10];
      [v33 setBuffer:v31 offset:0 atIndex:11];
      uint64_t v93 = v100[0];
      int64x2_t v94 = vdupq_n_s64(1uLL);
      id v91 = v35;
      int64x2_t v92 = v94;
      [v33 dispatchThreads:&v93 threadsPerThreadgroup:&v91];
    }

    id v89 = v28;
    [v27 endEncoding];
    [v87 commit];
    [v87 waitUntilCompleted];
    double v38 = v86;
    id v39 = v85;
    id v40 = v31;
    id v41 = v30;
    double v42 = [v41 contents];
    id v81 = v40;
    uint64_t v43 = [v81 contents];
    for (uint64_t j = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v20);
          v20;
          --v20)
    {
      if (*v43++)
      {
        int64x2_t v46 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *v42));
        uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v39 objectForKeyedSubscript:v46]);

        if (v47)
        {
          int64x2_t v48 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableSet objectForKeyedSubscript:](v38, "objectForKeyedSubscript:", v47));
          if (v48) {
            -[NSMutableArray addObject:](j, "addObject:", v48);
          }
        }
      }

      ++v42;
    }

    id v49 = -[NSMutableArray copy](j, "copy");

    int64x2_t v50 = v76;
    BOOL v17 = v77;
    uint64_t v51 = v82;
    int v52 = v75;
LABEL_37:

    double v66 = v85;
    id v65 = v89;
    id v67 = v81;
    goto LABEL_38;
  }

  __int128 v53 = (void *)v18;
  if (v14) {
    id v54 = [v13 newBufferWithLength:8 * v14 options:0];
  }
  else {
    id v54 = 0LL;
  }
  int64x2_t v50 = v5;
  uint64_t v51 = v82;
  id v55 = v53;
  id v56 = v17;
  id v57 = v88;
  v100[0] = v14;
  id v58 = v54;
  if (v14)
  {
    uint64_t v78 = v17;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v96 = 3221225472LL;
    CATransform3D v97 = __GTAccelerationStructureDescriptorDownloader_fillChildrenBuffer_block_invoke;
    __int128 v98 = &unk_20E0C8;
    id v59 = v55;
    CGFloat v60 = v59;
    id v99 = v59;
    if (s_accelerationStructureDescriptorDownloaderPipelinesToken == -1)
    {
      uint64_t v61 = v59;
    }

    else
    {
      dispatch_once(&s_accelerationStructureDescriptorDownloaderPipelinesToken, &block);
      uint64_t v61 = v99;
    }

    id v62 = [(id)s_downloaderPipelines_3 threadExecutionWidth];
    [v60 setComputePipelineState:s_downloaderPipelines_3];
    id v63 = DEVICEOBJECT(v57);
    double v64 = (void *)objc_claimAutoreleasedReturnValue(v63);
    [v60 setAccelerationStructure:v64 atBufferIndex:8];

    [v60 setBytes:v100 length:4 atIndex:4];
    [v60 setBuffer:v58 offset:0 atIndex:9];
    uint64_t v93 = v100[0];
    int64x2_t v94 = vdupq_n_s64(1uLL);
    id v91 = v62;
    int64x2_t v92 = v94;
    [v60 dispatchThreads:&v93 threadsPerThreadgroup:&v91];

    uint64_t v51 = v82;
    BOOL v17 = v78;
  }

  [v55 endEncoding];
  [v87 commit];
  [v87 waitUntilCompleted];
  id v65 = v86;
  double v66 = v85;
  id v41 = v85;
  id v67 = v58;
  if ((unint64_t)[v67 length] >= 8 * (unint64_t)v14)
  {
    id v81 = v67;
    double v68 = [v67 contents];
    id v89 = v65;
    double v38 = -[NSMutableSet initWithCapacity:]( [NSMutableSet alloc],  "initWithCapacity:",  [v65 count]);
    if (v14)
    {
      uint64_t v69 = v14;
      do
      {
        if (*v68++)
        {
          CGFloat v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"));
          double v72 = (void *)objc_claimAutoreleasedReturnValue([v41 objectForKeyedSubscript:v71]);

          if (v72)
          {
            double v73 = (void *)objc_claimAutoreleasedReturnValue([v65 objectForKeyedSubscript:v72]);
            if (v73) {
              -[NSMutableSet addObject:](v38, "addObject:", v73);
            }
          }
        }

        --v69;
      }

      while (v69);
    }

    id v49 = (id)objc_claimAutoreleasedReturnValue(-[NSMutableSet allObjects](v38, "allObjects"));
    int v52 = v81;
    goto LABEL_37;
  }

  id v49 = 0LL;
  int v52 = v67;
LABEL_38:

  objc_autoreleasePoolPop(v51);
  return v49;
}

uint64_t GTAccelerationStructureDescriptorDownloader_childrenCount(void *a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([a1 stateBuffer]);
  unsigned int v2 = v1;
  if (v1
    && (unint64_t)[v1 length] >= 0x10
    && (id v3 = (unsigned int *)[v2 contents], (v3[1] & 2) != 0))
  {
    uint64_t v4 = *v3;
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  return v4;
}

void GTAccelerationStructureDescriptorDownloader_destroy(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0LL;

  id v3 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = 0LL;
}

void RegisterAccelerationStructure(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = s_accelerationStructuresToken;
  id v6 = a1;
  if (v5 != -1) {
    dispatch_once(&s_accelerationStructuresToken, &__block_literal_global_5312);
  }
  id v8 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a2));
  id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a3));
  os_unfair_lock_lock((os_unfair_lock_t)&s_accelerationStructuresLock);
  [(id)s_accelerationStructuresByStreamRef setObject:v6 forKey:v8];

  [(id)s_accelerationStructureGPUResourceIDToStreamRef setObject:v8 forKey:v7];
  os_unfair_lock_unlock((os_unfair_lock_t)&s_accelerationStructuresLock);
}

id CaptureAccelerationStructures()
{
  if (s_accelerationStructuresToken != -1) {
    dispatch_once(&s_accelerationStructuresToken, &__block_literal_global_5312);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&s_accelerationStructuresLock);
  mach_port_t v0 = objc_alloc(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v1 = -[NSMutableDictionary initWithCapacity:]( v0,  "initWithCapacity:",  [(id)s_accelerationStructuresByStreamRef count]);
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v2 = (id)s_accelerationStructuresByStreamRef;
  id v3 = [v2 countByEnumeratingWithState:&v13 objects:v18 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v14;
    do
    {
      for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v13 + 1) + 8LL * (void)i);
        id v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)s_accelerationStructuresByStreamRef, "objectForKey:", v7, (void)v13));
        if (v8) {
          -[NSMutableDictionary setObject:forKeyedSubscript:](v1, "setObject:forKeyedSubscript:", v8, v7);
        }
      }

      id v4 = [v2 countByEnumeratingWithState:&v13 objects:v18 count:16];
    }

    while (v4);
  }

  id v9 = [(id)s_accelerationStructureGPUResourceIDToStreamRef copy];
  os_unfair_lock_unlock((os_unfair_lock_t)&s_accelerationStructuresLock);
  id v10 = -[NSMutableDictionary copy](v1, "copy");
  v17[0] = v10;
  v17[1] = v9;
  id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v17, 2LL));

  return v11;
}

id CreateIndirectComputeCommandBufferSnapshot(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a2;
  id v9 = a1;
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 device]);
  id v11 = DEVICEOBJECT(v8);
  int v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

  __int128 v13 = (void *)objc_claimAutoreleasedReturnValue([v12 device]);
  id v14 = [v12 size];
  id v15 = [v13 newIndirectCommandBufferWithDescriptor:v7 maxCommandCount:v14 options:0];

  __int128 v16 = (void *)objc_claimAutoreleasedReturnValue([v10 computeFunctionCopyIndirectCommandBuffer]);
  id v17 = [v16 newArgumentEncoderWithBufferIndex:0];

  id v18 = objc_msgSend(v13, "newBufferWithLength:options:", objc_msgSend(v17, "encodedLength"), 0);
  [v17 setArgumentBuffer:v18 offset:0];
  [v17 setIndirectCommandBuffer:v15 atIndex:0];
  [v17 setIndirectCommandBuffer:v12 atIndex:1];
  id v19 = DEVICEOBJECT(v9);
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);

  [v20 useResource:v12 usage:1];
  [v20 useResource:v15 usage:2];
  [v20 setBuffer:v18 offset:0 atIndex:0];
  id v21 = (void *)objc_claimAutoreleasedReturnValue([v10 computePipelineCopyIndirectCommandBuffer]);
  [v20 setComputePipelineState:v21];
  if ([v13 supportsNonUniformThreadgroupSize])
  {
    id v30 = v14;
    int64x2_t v31 = vdupq_n_s64(1uLL);
    id v28 = [v21 threadExecutionWidth];
    int64x2_t v29 = v31;
    [v20 dispatchThreads:&v30 threadsPerThreadgroup:&v28];
  }

  else
  {
    int64x2_t v27 = vdupq_n_s64(1uLL);
    int64x2_t v24 = v27;
    uint64_t v25 = 1LL;
    id v26 = v14;
    [v20 dispatchThreadgroups:&v26 threadsPerThreadgroup:&v24];
  }

  if ([v13 supportsComputeMemoryBarrier])
  {
    id v32 = v12;
    [v20 memoryBarrierWithResources:&v32 count:1];
  }

  id v22 = v18;
  *a4 = v22;

  return v15;
}

void RestoreComputeCommandEncoder(void *a1)
{
  id v1 = a1;
  id v2 = [v1 traceContext];
  id v3 = [v1 traceStream];
  apr_pool_create_ex(&newpool, 0LL, 0LL, 0LL);
  id v4 = newpool;
  uint64_t v5 = apr_hash_make(newpool);
  GTTraceMemPool_buildMemoryMap(v3[3], v5);
  id v6 = GTTraceContext_copyStreamMap((uint64_t)v2, v4);
  bzero(v28, 0x2B90uLL);
  uint64_t v7 = v3[4];
  if (v7)
  {
    unsigned int v8 = 0;
    while (1)
    {
      unsigned int v9 = atomic_load((unsigned int *)(v7 + 4));
      uint64_t v10 = v8 + (v9 >> 6) - 1;
      uint64_t v7 = *(void *)(v7 + 40);
      unsigned int v8 = v10;
      if (!v7)
      {
        unsigned int v8 = v10;
        goto LABEL_8;
      }
    }
  }

  else
  {
    unsigned int v8 = 0;
  }

  uint64_t v10 = 0LL;
LABEL_8:
  unint64_t v11 = v8 | (unint64_t)(v10 << 32);
LABEL_9:
  uint64_t v12 = v7 + 64;
  while (v7 && (*(_BYTE *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6) + 15) & 8) != 0)
  {
    GTMTLSMCommandEncoder_processTraceFunc( (uint64_t)v28,  (uint64_t *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6)),  (uint64_t)v5);
    unsigned int v13 = atomic_load((unsigned int *)(v7 + 4));
    int v14 = v11 + (v13 >> 6);
    uint64_t v15 = (HIDWORD(v11) + 1);
    unint64_t v11 = (v15 << 32) | v11;
    if ((_DWORD)v15 == v14 - 1)
    {
      unint64_t v11 = (v15 << 32) | v15;
      uint64_t v7 = *(void *)(v7 + 40);
      goto LABEL_9;
    }
  }

  int64x2_t v27 = v1;
  id v16 = DEVICEOBJECT(v1);
  id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = 0LL;
  char v19 = 1;
  do
  {
    char v20 = v19;
    uint64_t v21 = 1LL << v18;
    uint64_t v22 = v32[v18];
    if ((v30 & (1LL << v18)) != 0)
    {
      if (v22) {
        uint64_t v23 = v22 + 16;
      }
      else {
        uint64_t v23 = 0LL;
      }
      uint64_t v24 = v32[v18 + 31];
      if ((v31 & v21) != 0) {
        [v17 setBytes:v23 length:v24 attributeStride:v32[v18 + 62] atIndex:v18];
      }
      else {
        [v17 setBytes:v23 length:v24 atIndex:v18];
      }
    }

    else
    {
      v34[0] = v32[v18];
      id v25 = *(id *)(*(void *)(*find_entry((uint64_t)v6, v34, 8uLL, 0LL) + 32LL) + 8LL);
      if (objc_msgSend(v25, "conformsToProtocol:", &OBJC_PROTOCOL___MTLBuffer, v27))
      {
        uint64_t v26 = v32[v18 + 31];
        if ((v31 & v21) != 0) {
          [v17 setBuffer:v25 offset:v26 attributeStride:v32[v18 + 62] atIndex:v18];
        }
        else {
          [v17 setBuffer:v25 offset:v26 atIndex:v18];
        }
      }

      else if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLAccelerationStructure])
      {
        [v17 setAccelerationStructure:v25 atBufferIndex:v18];
      }

      else if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLVisibleFunctionTable])
      {
        [v17 setVisibleFunctionTable:v25 atBufferIndex:v18];
      }

      else if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLIntersectionFunctionTable])
      {
        [v17 setIntersectionFunctionTable:v25 atBufferIndex:v18];
      }
    }

    char v19 = 0;
    uint64_t v18 = 1LL;
  }

  while ((v20 & 1) != 0);
  if (v29)
  {
    v34[0] = v29;
    objc_msgSend( v17,  "setComputePipelineState:",  *(void *)(*(void *)(*find_entry((uint64_t)v6, v34, 8uLL, 0) + 32) + 8));
  }

  apr_pool_destroy(newpool);
}

BOOL GTMTLGuestAppClient_initGlobalTransportWithHostURL(uint64_t a1)
{
  if (*(void *)g_guestAppClientMTL)
  {
    GTMTLGuestAppClient_sendInferiorLaunchedMessage((void **)g_guestAppClientMTL);
    GTMTLGuestAppClientUpdateMTLDeviceInfo(g_guestAppClientMTL);
    GTMTLGuestAppClientUpdateMTLCommandQueueInfo(g_guestAppClientMTL);
    uint64_t v1 = g_guestAppClientMTL;
    id v2 = AllMetalLayers();
    GTMTLGuestAppClientUpdateCAMetalLayerInfo(v1, v2);
    +[GTMTLCaptureScopeInfo updateAll](&OBJC_CLASS___GTMTLCaptureScopeInfo, "updateAll");
    os_unfair_lock_lock((os_unfair_lock_t)(g_guestAppClientMTL + 32));
    uint64_t v3 = *(void *)(g_guestAppClientMTL + 72);
    os_unfair_lock_unlock((os_unfair_lock_t)(g_guestAppClientMTL + 32));
    if (v3)
    {
      id UnsupportedFenumInfo = GTMTLGuestAppClient_getUnsupportedFenumInfo();
      GTMTLGuestAppClient_notifyUnsupportedFenum(UnsupportedFenumInfo);
    }
  }

  return *(void *)g_guestAppClientMTL != 0LL;
}

void GTMTLGuestAppClient_initTransportWithHostURL(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v3 = DYCreateTransportC(a2);
    *(void *)a1 = v3;
    [v3 setSynchronous:1];
    id v4 = objc_msgSend(*(id *)a1, "newSourceWithQueue:", dispatch_queue_create("gputools.global_sync", 0));
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472LL;
    unint64_t v11 = ___ZL24InitTransportWithHostURLP19GTMTLGuestAppClientPKc_block_invoke;
    uint64_t v12 = &__block_descriptor_40_e36_v16__0__GTTransportMessage_capture_8l;
    uint64_t v13 = a1;
    [v4 setMessageHandler:&block];
    uint64_t v5 = dispatch_semaphore_create(0LL);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    _OWORD v8[2] = ___ZL24InitTransportWithHostURLP19GTMTLGuestAppClientPKc_block_invoke_2;
    v8[3] = &unk_20E0C8;
    _OWORD v8[4] = v5;
    [v4 setRegistrationHandler:v8];
    [v4 resume];
    dispatch_semaphore_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
    objc_msgSend(objc_msgSend(*(id *)a1, "connect"), "BOOLResult");
  }

  else
  {
    *(_BYTE *)(a1 + 129) = 1;
    id v6 = dispatch_group_create();
    *(void *)(a1 + 24) = v6;
    dispatch_group_enter(v6);
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472LL;
    unint64_t v11 = ___ZL16InitNewTransportP19GTMTLGuestAppClient_block_invoke;
    uint64_t v12 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v13 = a1;
    dispatch_async(global_queue, &block);
  }

void ___ZL24InitTransportWithHostURLP19GTMTLGuestAppClientPKc_block_invoke(uint64_t a1, void *a2)
{
}

uint64_t ___ZL24InitTransportWithHostURLP19GTMTLGuestAppClientPKc_block_invoke_2(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void ___ZL16InitNewTransportP19GTMTLGuestAppClient_block_invoke(uint64_t a1)
{
  dispatch_queue_t v2 = dispatch_queue_create("com.apple.gputools.capture", 0LL);
  dispatch_suspend(v2);
  id v3 = (void *)GTTransportServiceDaemonConnectionNew(v2);
  id v4 = [[GTServiceProperties alloc] initWithProtocol:&OBJC_PROTOCOL___GTMTLCaptureService];
  uint64_t v5 = -[GTMTLCaptureService initWithGuestApp:]( objc_alloc(&OBJC_CLASS___GTMTLCaptureService),  "initWithGuestApp:",  *(void *)(a1 + 32));
  id v6 = [[GTMTLCaptureServiceXPCDispatcher alloc] initWithService:v5 properties:v4 notifyConnection:v3];
  [v4 setVersion:3];
  if (registerService([v3 connection], v4))
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v5;
    objc_msgSend(v3, "registerDispatcher:forPort:", v6, objc_msgSend(v4, "servicePort"));
  }

  id v7 = [[GTServiceProperties alloc] initWithProtocol:&OBJC_PROTOCOL___GTMTLTelemetryService];
  unsigned int v8 = -[GTMTLTelemetryService initWithGuestApp:]( objc_alloc(&OBJC_CLASS___GTMTLTelemetryService),  "initWithGuestApp:",  *(void *)(a1 + 32));
  id v9 = [[GTMTLTelemetryServiceXPCDispatcher alloc] initWithService:v8 properties:v7 notifyConnection:v3];
  if (registerService([v3 connection], v7))
  {
    *(void *)(*(void *)(a1 + 32) + 16LL) = v8;
    objc_msgSend(v3, "registerDispatcher:forPort:", v9, objc_msgSend(v7, "servicePort"));
  }

  objc_initWeak(&location, v3);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  v10[2] = ___ZL16InitNewTransportP19GTMTLGuestAppClient_block_invoke_2;
  v10[3] = &unk_20DCF8;
  objc_copyWeak(&v11, &location);
  [v3 activateWithMessageHandler:v10 andErrorHandler:&__block_literal_global_5716];
  dispatch_resume(v2);
  dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 32) + 24LL));
  objc_destroyWeak(&v11);
  objc_destroyWeak(&location);
}

void sub_783CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

id ___ZL16InitNewTransportP19GTMTLGuestAppClient_block_invoke_2(uint64_t a1, uint64_t a2)
{
  id result = objc_loadWeak((id *)(a1 + 32));
  if (result) {
    return [result dispatchMessage:a2 replyConnection:result];
  }
  return result;
}

vm_address_t GTMTLGuestAppClient_initPlatform()
{
  mach_port_t v0 = getenv("GT_HOST_URL_MTL");
  vm_address_t v1 = GTCoreAlloc((uint64_t)v0, 0x88uLL);
  *(_BYTE *)(v1 + 129) = 0;
  GTMTLGuestAppClient_initTransportWithHostURL(v1, (uint64_t)v0);
  dispatch_queue_t v2 = IOServiceMatching("IOAccelerator");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v2);
  if (!MatchingService)
  {
    id v4 = IOServiceMatching("IOAcceleratorES");
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v4);
  }

  *(_DWORD *)(v1 + 36) = MatchingService;
  *(void *)(v1 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  *(void *)(v1 + 8_Block_object_dispose(va, 8) = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  *(void *)(v1 + 96) = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  *(void *)(v1 + 56) = 1000000000LL;
  *(void *)(v1 + 72) = 0LL;
  *(_BYTE *)(v1 + 12_Block_object_dispose(va, 8) = 0;
  return v1;
}

uint64_t GTMTLGuestAppClient_release(vm_address_t a1)
{
  return vm_deallocate(mach_task_self_, a1, 0x88uLL);
}

void TranslateGTMTLRenderPassAttachmentDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  id v8 = a1;
  if (a4)
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v8 texture]);
    *(void *)(a2 + _Block_object_dispose(va, 8) = [v6 streamReference];

    *(_BYTE *)(a2 + 24) = [v8 level];
    *(_WORD *)(a2 + 22) = (unsigned __int16)[v8 slice];
    *(_WORD *)(a2 + 16) = (unsigned __int16)[v8 depthPlane];
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v8 resolveTexture]);
    *(void *)a2 = [v7 streamReference];

    *(_BYTE *)(a2 + 26) = [v8 resolveLevel];
    *(_WORD *)(a2 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = (unsigned __int16)[v8 resolveSlice];
    *(_WORD *)(a2 + 1_Block_object_dispose(va, 8) = (unsigned __int16)[v8 resolveDepthPlane];
    *(_BYTE *)(a2 + 25) = [v8 loadAction];
    *(_BYTE *)(a2 + 27) = [v8 storeAction];
    *(_BYTE *)(a2 + 2_Block_object_dispose(va, 8) = [v8 storeActionOptions];
    if ((objc_opt_respondsToSelector(v8, "yInvert") & 1) != 0) {
      *(_BYTE *)(a2 + 29) = [v8 yInvert];
    }
  }
}

id MakeMTLRenderPassAttachmentDescriptor(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 8);
  id v7 = a3;
  id v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v6));
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v8]);
  [v5 setTexture:v9];

  [v5 setLevel:*(unsigned __int8 *)(a2 + 24)];
  [v5 setSlice:*(unsigned __int16 *)(a2 + 22)];
  [v5 setDepthPlane:*(unsigned __int16 *)(a2 + 16)];
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)a2));
  id v11 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v10]);

  [v5 setResolveTexture:v11];
  [v5 setResolveLevel:*(unsigned __int8 *)(a2 + 26)];
  [v5 setResolveSlice:*(unsigned __int16 *)(a2 + 20)];
  [v5 setResolveDepthPlane:*(unsigned __int16 *)(a2 + 18)];
  [v5 setLoadAction:*(unsigned __int8 *)(a2 + 25)];
  [v5 setStoreAction:*(unsigned __int8 *)(a2 + 27)];
  [v5 setStoreActionOptions:*(unsigned __int8 *)(a2 + 28)];
  if ((objc_opt_respondsToSelector(v5, "yInvert") & 1) != 0) {
    [v5 setYInvert:*(_BYTE *)(a2 + 29) != 0];
  }
  return v5;
}

void TranslateGTMTLRenderPassColorAttachmentDescriptor(void *a1, void *a2, uint64_t a3, int a4)
{
  id v11 = a1;
  TranslateGTMTLRenderPassAttachmentDescriptor(v11, (uint64_t)a2, v6, a4);
  if (a4)
  {
    [v11 clearColor];
    a2[4] = v7;
    a2[5] = v8;
    a2[6] = v9;
    a2[7] = v10;
  }
}

id MakeMTLRenderPassColorAttachmentDescriptor(void *a1, double *a2, void *a3)
{
  id v5 = a1;
  objc_msgSend( MakeMTLRenderPassAttachmentDescriptor(v5, (uint64_t)a2, a3),  "setClearColor:",  a2[4],  a2[5],  a2[6],  a2[7]);
  return v5;
}

void TranslateGTMTLRenderPassDepthAttachmentDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  id v8 = a1;
  TranslateGTMTLRenderPassAttachmentDescriptor(v8, a2, v6, a4);
  if (a4)
  {
    [v8 clearDepth];
    *(void *)(a2 + 32) = v7;
    *(_BYTE *)(a2 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v8 depthResolveFilter];
  }
}

id MakeMTLRenderPassDepthAttachmentDescriptor(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  objc_msgSend( MakeMTLRenderPassAttachmentDescriptor(v5, a2, a3),  "setClearDepth:",  *(double *)(a2 + 32));
  [v5 setDepthResolveFilter:*(unsigned __int8 *)(a2 + 40)];
  return v5;
}

void TranslateGTMTLRenderPassStencilAttachmentDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  id v7 = a1;
  TranslateGTMTLRenderPassAttachmentDescriptor(v7, a2, v6, a4);
  if (a4)
  {
    *(_DWORD *)(a2 + 32) = [v7 clearStencil];
    if ((objc_opt_respondsToSelector(v7, "stencilResolveFilter") & 1) != 0) {
      *(_BYTE *)(a2 + 36) = [v7 stencilResolveFilter];
    }
  }
}

id MakeMTLRenderPassStencilAttachmentDescriptor(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  objc_msgSend( MakeMTLRenderPassAttachmentDescriptor(v5, a2, a3),  "setClearStencil:",  *(unsigned int *)(a2 + 32));
  if ((objc_opt_respondsToSelector(v5, "stencilResolveFilter") & 1) != 0) {
    [v5 setStencilResolveFilter:*(unsigned __int8 *)(a2 + 36)];
  }
  return v5;
}

void TranslateGTMTLRenderPassSampleBufferAttachmentDescriptor(void *a1, void *a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBuffer]);
    a2[2] = [v6 streamReference];

    a2[4] = [v5 startOfVertexSampleIndex];
    a2[1] = [v5 endOfVertexSampleIndex];
    a2[3] = [v5 startOfFragmentSampleIndex];
    id v7 = [v5 endOfFragmentSampleIndex];

    *a2 = v7;
  }

id MakeMTLRenderPassSampleBufferAttachmentDescriptor(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = a2[2];
  id v7 = a3;
  id v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v6));
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v8]);

  [v5 setSampleBuffer:v9];
  [v5 setStartOfVertexSampleIndex:a2[4]];
  [v5 setEndOfVertexSampleIndex:a2[1]];
  [v5 setStartOfFragmentSampleIndex:a2[3]];
  [v5 setEndOfFragmentSampleIndex:*a2];
  return v5;
}

void TranslateGTMTLRenderPassDescriptorAuto(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 240);
  *(void *)(a2 + 24mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v6 + 824;
  if (a3) {
    memcpy((void *)v6, &GTMTLRenderPassDescriptorDefaults, 0x338uLL);
  }
  id v7 = v5;
  uint64_t v8 = 0LL;
  uint64_t v9 = (void *)v6;
  id v31 = v7;
  do
  {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v7 colorAttachments]);
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectAtIndexedSubscript:v8]);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 texture]);

    if (v12)
    {
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v31 colorAttachments]);
      int v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectAtIndexedSubscript:v8]);
      TranslateGTMTLRenderPassColorAttachmentDescriptor(v14, v9, v15, a3);
    }

    ++v8;
    v9 += 8;
    id v7 = v31;
  }

  while (v8 != 8);
  id v16 = (void *)objc_claimAutoreleasedReturnValue([v31 depthAttachment]);
  TranslateGTMTLRenderPassDepthAttachmentDescriptor(v16, v6 + 672, v17, a3);

  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v31 stencilAttachment]);
  TranslateGTMTLRenderPassStencilAttachmentDescriptor(v18, v6 + 720, v19, a3);

  char v20 = v31;
  uint64_t v21 = 0LL;
  uint64_t v22 = (void *)(v6 + 512);
  do
  {
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v20 sampleBufferAttachments]);
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v23 objectAtIndexedSubscript:v21]);
    id v25 = (void *)objc_claimAutoreleasedReturnValue([v24 sampleBuffer]);

    if (v25)
    {
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v31 sampleBufferAttachments]);
      int64x2_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 objectAtIndexedSubscript:v21]);
      TranslateGTMTLRenderPassSampleBufferAttachmentDescriptor(v27, v22, v28, a3);
    }

    ++v21;
    v22 += 5;
    char v20 = v31;
  }

  while (v21 != 4);
  if ((a3 & 1) != 0)
  {
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v31 visibilityResultBuffer]);
    *(void *)(v6 + 792) = [v29 streamReference];

    *(_WORD *)(v6 + 806) = (unsigned __int16)[v31 renderTargetArrayLength];
    if ((objc_opt_respondsToSelector(v31, "imageblockSampleLength") & 1) != 0) {
      *(_WORD *)(v6 + 804) = (unsigned __int16)[v31 imageblockSampleLength];
    }
    if ((objc_opt_respondsToSelector(v31, "threadgroupMemoryLength") & 1) != 0) {
      *(_DWORD *)(v6 + 80mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v31 threadgroupMemoryLength];
    }
    if ((objc_opt_respondsToSelector(v31, "tileWidth") & 1) != 0) {
      *(_WORD *)(v6 + 814) = (unsigned __int16)[v31 tileWidth];
    }
    if ((objc_opt_respondsToSelector(v31, "tileHeight") & 1) != 0) {
      *(_WORD *)(v6 + 812) = (unsigned __int16)[v31 tileHeight];
    }
    if ((objc_opt_respondsToSelector(v31, "renderTargetWidth") & 1) != 0) {
      *(_WORD *)(v6 + 81mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = (unsigned __int16)[v31 renderTargetWidth];
    }
    if ((objc_opt_respondsToSelector(v31, "renderTargetHeight") & 1) != 0) {
      *(_WORD *)(v6 + 80_Block_object_dispose(va, 8) = (unsigned __int16)[v31 renderTargetHeight];
    }
    if ((objc_opt_respondsToSelector(v31, "defaultRasterSampleCount") & 1) != 0) {
      *(_BYTE *)(v6 + 816) = [v31 defaultRasterSampleCount];
    }
    if ((objc_opt_respondsToSelector(v31, "openGLModeEnabled") & 1) != 0) {
      *(_BYTE *)(v6 + 81_Block_object_dispose(va, 8) = [v31 openGLModeEnabled];
    }
    if ((objc_opt_respondsToSelector(v31, "rasterizationRateMap") & 1) != 0)
    {
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v31 rasterizationRateMap]);
      *(void *)(v6 + 784) = [v30 streamReference];
    }

    if ((objc_opt_respondsToSelector(v31, "defaultColorSampleCount") & 1) != 0) {
      *(void *)(v6 + 776) = [v31 defaultColorSampleCount];
    }
    if ((objc_opt_respondsToSelector(v31, "skipEmptyTilesOnClearEnabled") & 1) != 0) {
      *(_BYTE *)(v6 + 82mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v31 skipEmptyTilesOnClearEnabled];
    }
  }
}

MTLRenderPassDescriptor *MakeMTLRenderPassDescriptorAuto(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
  id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 792)));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v5]);
  -[MTLRenderPassDescriptor setVisibilityResultBuffer:](v4, "setVisibilityResultBuffer:", v6);

  uint64_t v7 = 0LL;
  uint64_t v8 = a1;
  do
  {
    if (*(void *)(v8 + 8))
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v4, "colorAttachments"));
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 objectAtIndexedSubscript:v7]);
    }

    ++v7;
    v8 += 64LL;
  }

  while (v7 != 8);
  id v11 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor depthAttachment](v4, "depthAttachment"));

  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor stencilAttachment](v4, "stencilAttachment"));
  -[MTLRenderPassDescriptor setRenderTargetArrayLength:]( v4,  "setRenderTargetArrayLength:",  *(unsigned __int16 *)(a1 + 806));
  if ((objc_opt_respondsToSelector(v4, "imageblockSampleLength") & 1) != 0) {
    -[MTLRenderPassDescriptor setImageblockSampleLength:]( v4,  "setImageblockSampleLength:",  *(unsigned __int16 *)(a1 + 804));
  }
  if ((objc_opt_respondsToSelector(v4, "threadgroupMemoryLength") & 1) != 0) {
    -[MTLRenderPassDescriptor setThreadgroupMemoryLength:]( v4,  "setThreadgroupMemoryLength:",  *(unsigned int *)(a1 + 800));
  }
  if ((objc_opt_respondsToSelector(v4, "tileWidth") & 1) != 0) {
    -[MTLRenderPassDescriptor setTileWidth:](v4, "setTileWidth:", *(unsigned __int16 *)(a1 + 814));
  }
  if ((objc_opt_respondsToSelector(v4, "tileHeight") & 1) != 0) {
    -[MTLRenderPassDescriptor setTileHeight:](v4, "setTileHeight:", *(unsigned __int16 *)(a1 + 812));
  }
  if ((objc_opt_respondsToSelector(v4, "renderTargetWidth") & 1) != 0) {
    -[MTLRenderPassDescriptor setRenderTargetWidth:](v4, "setRenderTargetWidth:", *(unsigned __int16 *)(a1 + 810));
  }
  if ((objc_opt_respondsToSelector(v4, "renderTargetHeight") & 1) != 0) {
    -[MTLRenderPassDescriptor setRenderTargetHeight:](v4, "setRenderTargetHeight:", *(unsigned __int16 *)(a1 + 808));
  }
  if ((objc_opt_respondsToSelector(v4, "defaultRasterSampleCount") & 1) != 0) {
    -[MTLRenderPassDescriptor setDefaultRasterSampleCount:]( v4,  "setDefaultRasterSampleCount:",  *(unsigned __int8 *)(a1 + 816));
  }
  if ((objc_opt_respondsToSelector(v4, "openGLModeEnabled") & 1) != 0) {
    -[MTLRenderPassDescriptor setOpenGLModeEnabled:](v4, "setOpenGLModeEnabled:", *(_BYTE *)(a1 + 818) != 0);
  }
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 784)));
  int v14 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v13]);
  -[MTLRenderPassDescriptor setRasterizationRateMap:](v4, "setRasterizationRateMap:", v14);

  if ((objc_opt_respondsToSelector(v4, "ditherEnabled") & 1) != 0) {
    -[MTLRenderPassDescriptor setDitherEnabled:](v4, "setDitherEnabled:", *(_BYTE *)(a1 + 817) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "defaultColorSampleCount") & 1) != 0) {
    -[MTLRenderPassDescriptor setDefaultColorSampleCount:](v4, "setDefaultColorSampleCount:", *(void *)(a1 + 776));
  }
  uint64_t v15 = 0LL;
  id v16 = (void *)(a1 + 512);
  do
  {
    if (v16[2])
    {
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor sampleBufferAttachments](v4, "sampleBufferAttachments"));
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:v15]);
    }

    ++v15;
    v16 += 5;
  }

  while (v15 != 4);
  if ((objc_opt_respondsToSelector(v4, "skipEmptyTilesOnClearEnabled") & 1) != 0) {
    -[MTLRenderPassDescriptor setSkipEmptyTilesOnClearEnabled:]( v4,  "setSkipEmptyTilesOnClearEnabled:",  *(_BYTE *)(a1 + 820) != 0);
  }

  return v4;
}

void TranslateGTMTLTextureDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 232);
  *(void *)(a2 + 232) = v6 + 56;
  id v9 = v5;
  if (a3)
  {
    *(_OWORD *)uint64_t v6 = GTMTLTextureDescriptorDefaults;
    *(_OWORD *)(v6 + 16) = unk_1C73E0;
    *(_OWORD *)(v6 + 32) = xmmword_1C73F0;
    *(void *)(v6 + 4_Block_object_dispose(va, 8) = 512LL;
    id v7 = v5;
    *(_BYTE *)(v6 + 49) = [v7 textureType];
    *(_WORD *)(v6 + 34) = (unsigned __int16)[v7 pixelFormat];
    *(_DWORD *)(v6 + 24) = [v7 width];
    *(_WORD *)(v6 + 32) = (unsigned __int16)[v7 height];
    *(_WORD *)(v6 + 3mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = (unsigned __int16)[v7 depth];
    *(_BYTE *)(v6 + 45) = [v7 mipmapLevelCount];
    *(_BYTE *)(v6 + 47) = [v7 sampleCount];
    *(_WORD *)(v6 + 2_Block_object_dispose(va, 8) = (unsigned __int16)[v7 arrayLength];
    *(_BYTE *)(v6 + 43) = [v7 framebufferOnly];
    *(_BYTE *)(v6 + 44) = [v7 isDrawable];
    *(_DWORD *)(v6 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v7 usage];
    if ((objc_opt_respondsToSelector(v7, "rotation") & 1) != 0) {
      *(_BYTE *)(v6 + 46) = [v7 rotation];
    }
    *(_WORD *)(v6 + 36) = (unsigned __int16)[v7 resourceOptions];
    *(_BYTE *)(v6 + 3_Block_object_dispose(va, 8) = [v7 allowGPUOptimizedContents];
    if ((objc_opt_respondsToSelector(v7, "resourceIndex") & 1) != 0) {
      *(void *)(v6 + _Block_object_dispose(va, 8) = [v7 resourceIndex];
    }
    *(_BYTE *)(v6 + 42) = [v7 forceResourceIndex];
    if ((objc_opt_respondsToSelector(v7, "swizzleKey") & 1) != 0) {
      *(_DWORD *)(v6 + 16) = [v7 swizzleKey];
    }
    *(void *)uint64_t v6 = [v7 protectionOptions];
    if ((objc_opt_respondsToSelector(v7, "sparseSurfaceDefaultValue") & 1) != 0) {
      *(_BYTE *)(v6 + 4_Block_object_dispose(va, 8) = [v7 sparseSurfaceDefaultValue];
    }
    *(_BYTE *)(v6 + 5mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v7 writeSwizzleEnabled];
    if ((objc_opt_respondsToSelector(v7, "compressionType") & 1) != 0) {
      *(_BYTE *)(v6 + 41) = [v7 compressionType];
    }
    if ((objc_opt_respondsToSelector(v7, "compressionMode") & 1) != 0) {
      *(_BYTE *)(v6 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v7 compressionMode];
    }
  }

  else
  {
    id v8 = v5;
  }
}

MTLTextureDescriptor *MakeMTLTextureDescriptorWithoutResourceIndex(uint64_t a1)
{
  dispatch_queue_t v2 = objc_alloc_init(&OBJC_CLASS___MTLTextureDescriptor);
  -[MTLTextureDescriptor setTextureType:](v2, "setTextureType:", *(unsigned __int8 *)(a1 + 49));
  -[MTLTextureDescriptor setPixelFormat:](v2, "setPixelFormat:", *(unsigned __int16 *)(a1 + 34));
  -[MTLTextureDescriptor setWidth:](v2, "setWidth:", *(unsigned int *)(a1 + 24));
  -[MTLTextureDescriptor setHeight:](v2, "setHeight:", *(unsigned __int16 *)(a1 + 32));
  -[MTLTextureDescriptor setDepth:](v2, "setDepth:", *(unsigned __int16 *)(a1 + 30));
  -[MTLTextureDescriptor setMipmapLevelCount:](v2, "setMipmapLevelCount:", *(unsigned __int8 *)(a1 + 45));
  -[MTLTextureDescriptor setSampleCount:](v2, "setSampleCount:", *(unsigned __int8 *)(a1 + 47));
  -[MTLTextureDescriptor setArrayLength:](v2, "setArrayLength:", *(unsigned __int16 *)(a1 + 28));
  -[MTLTextureDescriptor setFramebufferOnly:](v2, "setFramebufferOnly:", *(_BYTE *)(a1 + 43) != 0);
  -[MTLTextureDescriptor setIsDrawable:](v2, "setIsDrawable:", *(_BYTE *)(a1 + 44) != 0);
  -[MTLTextureDescriptor setUsage:](v2, "setUsage:", *(unsigned int *)(a1 + 20));
  if ((objc_opt_respondsToSelector(v2, "rotation") & 1) != 0) {
    -[MTLTextureDescriptor setRotation:](v2, "setRotation:", *(unsigned __int8 *)(a1 + 46));
  }
  -[MTLTextureDescriptor setResourceOptions:](v2, "setResourceOptions:", *(unsigned __int16 *)(a1 + 36));
  -[MTLTextureDescriptor setAllowGPUOptimizedContents:](v2, "setAllowGPUOptimizedContents:", *(_BYTE *)(a1 + 38) != 0);
  if ((objc_opt_respondsToSelector(v2, "swizzleKey") & 1) != 0) {
    -[MTLTextureDescriptor setSwizzleKey:](v2, "setSwizzleKey:", *(unsigned int *)(a1 + 16));
  }
  if ((objc_opt_respondsToSelector(v2, "sparseSurfaceDefaultValue") & 1) != 0) {
    -[MTLTextureDescriptor setSparseSurfaceDefaultValue:]( v2,  "setSparseSurfaceDefaultValue:",  *(unsigned __int8 *)(a1 + 48));
  }
  -[MTLTextureDescriptor setWriteSwizzleEnabled:](v2, "setWriteSwizzleEnabled:", *(_BYTE *)(a1 + 50) != 0);
  if ((objc_opt_respondsToSelector(v2, "compressionType") & 1) != 0) {
    -[MTLTextureDescriptor setCompressionType:](v2, "setCompressionType:", *(unsigned __int8 *)(a1 + 41));
  }
  if ((objc_opt_respondsToSelector(v2, "compressionMode") & 1) != 0) {
    -[MTLTextureDescriptor setCompressionMode:](v2, "setCompressionMode:", *(unsigned __int8 *)(a1 + 40));
  }
  return v2;
}

id MakeMTLTextureDescriptorWithResourceIndex(uint64_t a1)
{
  MTLTextureDescriptorWithoutResourceIndex = MakeMTLTextureDescriptorWithoutResourceIndex(a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptorWithoutResourceIndex);
  [v3 setForceResourceIndex:*(void *)(a1 + 8) != 0];
  [v3 setResourceIndex:*(void *)(a1 + 8)];
  return v3;
}

void TranslateGTMTLBufferDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 224);
  *(void *)(a2 + 224) = v6 + 40;
  if (a3)
  {
    *(void *)(v6 + 32) = 0LL;
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
    id v7 = v5;
    *(void *)uint64_t v6 = [v5 length];
    *(_WORD *)(v6 + 32) = (unsigned __int16)[v7 resourceOptions];
    *(_BYTE *)(v6 + 34) = [v7 noCopy];
    *(void *)(v6 + 24) = [v7 pinnedGPUAddress];
    *(void *)(v6 + _Block_object_dispose(va, 8) = [v7 parentGPUAddress];
    *(void *)(v6 + 16) = [v7 parentGPUSize];
    id v5 = v7;
  }
}

id MakeMTLBufferDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLBufferDescriptor);
  [v2 setLength:*(void *)a1];
  [v2 setResourceOptions:*(unsigned __int16 *)(a1 + 32)];
  [v2 setNoCopy:*(_BYTE *)(a1 + 34) != 0];
  return v2;
}

id MakeMTLBufferDescriptorWithBufferPinning(void *a1)
{
  id MTLBufferDescriptor = MakeMTLBufferDescriptor((uint64_t)a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(MTLBufferDescriptor);
  [v3 setPinnedGPUAddress:a1[3]];
  [v3 setParentGPUAddress:a1[1]];
  [v3 setParentGPUSize:a1[2]];
  return v3;
}

void TranslateGTMTLVertexBufferLayoutDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    *(void *)a2 = [v5 stride];
    *(_WORD *)(a2 + _Block_object_dispose(va, 8) = (unsigned __int16)[v5 stepRate];
    unsigned __int8 v6 = [v5 stepFunction];

    *(_BYTE *)(a2 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v6;
  }

id MakeMTLVertexBufferLayoutDescriptor(void *a1, uint64_t a2)
{
  id v3 = a1;
  [v3 setStride:*(void *)a2];
  [v3 setStepRate:*(unsigned __int16 *)(a2 + 8)];
  [v3 setStepFunction:*(unsigned __int8 *)(a2 + 10)];
  return v3;
}

void TranslateGTMTLVertexAttributeDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    *(_BYTE *)(a2 + 5) = [v5 format];
    *(_DWORD *)a2 = [v5 offset];
    unsigned __int8 v6 = [v5 bufferIndex];

    *(_BYTE *)(a2 + 4) = v6;
  }

id MakeMTLVertexAttributeDescriptor(void *a1, unsigned int *a2)
{
  id v3 = a1;
  [v3 setFormat:*((unsigned __int8 *)a2 + 5)];
  [v3 setOffset:*a2];
  [v3 setBufferIndex:*((unsigned __int8 *)a2 + 4)];
  return v3;
}

void TranslateGTMTLVertexDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = a2;
  id v16 = a1;
  do
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v16 layouts]);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectAtIndexedSubscript:v6]);
    TranslateGTMTLVertexBufferLayoutDescriptor(v9, v7, v10, a4);

    ++v6;
    v7 += 16LL;
  }

  while (v6 != 31);
  uint64_t v11 = 0LL;
  uint64_t v12 = a2 + 496;
  do
  {
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v16 attributes]);
    int v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectAtIndexedSubscript:v11]);
    TranslateGTMTLVertexAttributeDescriptor(v14, v12, v15, a4);

    ++v11;
    v12 += 8LL;
  }

  while (v11 != 31);
}

id MakeMTLVertexDescriptor(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = 0LL;
  uint64_t v5 = a2;
  do
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 layouts]);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:v4]);

    ++v4;
    v5 += 16LL;
  }

  while (v4 != 31);
  uint64_t v8 = 0LL;
  id v9 = (unsigned int *)(a2 + 496);
  do
  {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v3 attributes]);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectAtIndexedSubscript:v8]);

    ++v8;
    v9 += 2;
  }

  while (v8 != 31);
  return v3;
}

void TranslateGTMTLRenderPipelineColorAttachmentDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    *(_BYTE *)(a2 + 3) = [v5 isBlendingEnabled];
    *(_BYTE *)(a2 + _Block_object_dispose(va, 8) = [v5 sourceRGBBlendFactor];
    *(_BYTE *)(a2 + 5) = [v5 destinationRGBBlendFactor];
    *(_BYTE *)(a2 + 6) = [v5 rgbBlendOperation];
    *(_BYTE *)(a2 + 7) = [v5 sourceAlphaBlendFactor];
    *(_BYTE *)(a2 + 4) = [v5 destinationAlphaBlendFactor];
    *(_BYTE *)(a2 + 2) = [v5 alphaBlendOperation];
    *(_BYTE *)(a2 + 9) = [v5 writeMask];
    unsigned __int16 v6 = (unsigned __int16)[v5 pixelFormat];

    *(_WORD *)a2 = v6;
  }

id MakeMTLRenderPipelineColorAttachmentDescriptor(void *a1, unsigned __int16 *a2)
{
  id v3 = a1;
  [v3 setBlendingEnabled:*((_BYTE *)a2 + 3) != 0];
  [v3 setSourceRGBBlendFactor:*((unsigned __int8 *)a2 + 8)];
  [v3 setDestinationRGBBlendFactor:*((unsigned __int8 *)a2 + 5)];
  [v3 setRgbBlendOperation:*((unsigned __int8 *)a2 + 6)];
  [v3 setSourceAlphaBlendFactor:*((unsigned __int8 *)a2 + 7)];
  [v3 setDestinationAlphaBlendFactor:*((unsigned __int8 *)a2 + 4)];
  [v3 setAlphaBlendOperation:*((unsigned __int8 *)a2 + 2)];
  [v3 setWriteMask:*((unsigned __int8 *)a2 + 9)];
  [v3 setPixelFormat:*a2];
  return v3;
}

void TranslateGTMTLLinkedFunctionsAuto(void *a1, uint64_t *a2, uint64_t a3, int a4)
{
  id v19 = a1;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v19 functions]);
  uint64_t v8 = TranslateNSArray(v7, a3, a4);

  id v9 = (void *)objc_claimAutoreleasedReturnValue([v19 binaryFunctions]);
  uint64_t v10 = TranslateNSArray(v9, a3, a4);

  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v19 privateFunctions]);
  uint64_t v12 = TranslateNSArray(v11, a3, a4);

  if (a4)
  {
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v19 functions]);
    a2[3] = (uint64_t)[v13 count];

    if (a2[3]) {
      uint64_t v14 = v8;
    }
    else {
      uint64_t v14 = 0LL;
    }
    a2[2] = v14;
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v19 binaryFunctions]);
    a2[1] = (uint64_t)[v15 count];

    if (a2[1]) {
      uint64_t v16 = v10;
    }
    else {
      uint64_t v16 = 0LL;
    }
    *a2 = v16;
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v19 privateFunctions]);
    a2[7] = (uint64_t)[v17 count];

    if (a2[7]) {
      uint64_t v18 = v12;
    }
    else {
      uint64_t v18 = 0LL;
    }
    a2[6] = v18;
  }
}

uint64_t TranslateNSArray(void *a1, uint64_t a2, char a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 400);
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v7 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v15;
    do
    {
      uint64_t v10 = 0LL;
      do
      {
        if (*(void *)v15 != v9) {
          objc_enumerationMutation(v5);
        }
        if ((a3 & 1) != 0)
        {
          unsigned int v11 = [*(id *)(*((void *)&v14 + 1) + 8 * (void)v10) streamReference];
          uint64_t v12 = *(void **)(a2 + 400);
          *uint64_t v12 = v11;
        }

        else
        {
          uint64_t v12 = *(void **)(a2 + 400);
        }

        *(void *)(a2 + 40mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v12 + 1;
        uint64_t v10 = (char *)v10 + 1;
      }

      while (v8 != v10);
      id v8 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }

    while (v8);
  }

  return v6;
}

id MakeMTLLinkedFunctionsAuto(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  uint64_t v7 = *(void *)(a2 + 24);
  if (v7)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a2 + 16), v7, v6);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    [v5 setFunctions:v9];
  }

  uint64_t v10 = *(void *)(a2 + 8);
  if (v10)
  {
    id v11 = CreateObjectArrayWithMap(*(uint64_t **)a2, v10, v6);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
    [v5 setBinaryFunctions:v12];
  }

  uint64_t v13 = *(void *)(a2 + 56);
  if (v13)
  {
    id v14 = CreateObjectArrayWithMap(*(uint64_t **)(a2 + 48), v13, v6);
    __int128 v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    [v5 setPrivateFunctions:v15];
  }

  return v5;
}

id CreateObjectArrayWithMap(uint64_t *a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", a2);
  if (a2 >= 1)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = *a1++;
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v8));
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v9]);

      if (v10) {
        -[NSMutableArray addObject:](v6, "addObject:", v10);
      }

      --v7;
    }

    while (v7);
  }

  id v11 = -[NSMutableArray copy](v6, "copy");

  return v11;
}

id TranslateGTMTLPipelineBufferDescriptor(id result, _BYTE *a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id result = [result mutability];
    *a2 = (_BYTE)result;
  }

  return result;
}

id MakeMTLPipelineBufferDescriptor(void *a1, unsigned __int8 *a2)
{
  id v3 = a1;
  [v3 setMutability:*a2];
  return v3;
}

void TranslateGTMTLRenderPipelineDescriptor(void *a1, void *a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = a2[27];
  a2[27] = v6 + 1512;
  if (a3) {
    memcpy((void *)v6, &GTMTLRenderPipelineDescriptorDefaults, 0x5E8uLL);
  }
  id v75 = v5;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v75 vertexDescriptor]);
  TranslateGTMTLVertexDescriptor(v7, v6, v8, a3);

  uint64_t v9 = 0LL;
  uint64_t v10 = v6 + 744;
  do
  {
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v75 colorAttachments]);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:v9]);
    TranslateGTMTLRenderPipelineColorAttachmentDescriptor(v12, v10, v13, a3);

    ++v9;
    v10 += 16LL;
  }

  while (v9 != 8);
  id v14 = objc_claimAutoreleasedReturnValue([v75 label]);
  __int128 v15 = (const char *)[v14 UTF8String];
  __int128 v16 = v15;
  if (v15)
  {
    size_t v17 = strlen(v15);
    uint64_t v18 = a2 + 52;
    uint64_t v19 = a2[52];
    size_t v20 = v17 + 1;
    if (v17 != -1LL)
    {
      uint64_t v21 = (void *)a2[52];
      goto LABEL_10;
    }
  }

  else
  {
    uint64_t v18 = a2 + 52;
    uint64_t v19 = a2[52];
  }

  size_t v20 = 0LL;
  uint64_t v21 = 0LL;
LABEL_10:
  *uint64_t v18 = v19 + v20;
  if (a3) {
    memcpy(v21, v16, v20);
  }

  for (uint64_t i = 0LL; i != 31; ++i)
  {
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v75 vertexBuffers]);
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v23 objectAtIndexedSubscript:i]);
    id v25 = v24;
    if (a3) {
      *(_BYTE *)(v6 + 1447 + i) = [v24 mutability];
    }
  }

  uint64_t v26 = 0LL;
  int64x2_t v27 = v75;
  do
  {
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v27 fragmentBuffers]);
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v28 objectAtIndexedSubscript:v26]);
    uint64_t v30 = v29;
    if (a3) {
      *(_BYTE *)(v6 + 1354 + v26) = [v29 mutability];
    }

    ++v26;
    int64x2_t v27 = v75;
  }

  while (v26 != 31);
  id v31 = (void *)objc_claimAutoreleasedReturnValue([v75 pluginData]);
  id v32 = GTMTLDescriptorAllocator_copyDictionary((uint64_t)a2, v31, a3);
  uint64_t v73 = v33;
  CGFloat v74 = v32;

  id v34 = (void *)objc_claimAutoreleasedReturnValue([v75 driverCompilerOptions]);
  id v35 = GTMTLDescriptorAllocator_copyDictionary((uint64_t)a2, v34, a3);
  uint64_t v37 = v36;

  double v38 = (void *)objc_claimAutoreleasedReturnValue([v75 vertexPreloadedLibraries]);
  uint64_t v71 = TranslateNSArray(v38, (uint64_t)a2, a3);

  id v39 = (void *)objc_claimAutoreleasedReturnValue([v75 fragmentPreloadedLibraries]);
  uint64_t v72 = TranslateNSArray(v39, (uint64_t)a2, a3);

  id v40 = (void *)objc_claimAutoreleasedReturnValue([v75 vertexLinkedFunctions]);
  TranslateGTMTLLinkedFunctions(v40, (uint64_t *)(v6 + 1064), a2, a3);

  id v41 = (void *)objc_claimAutoreleasedReturnValue([v75 fragmentLinkedFunctions]);
  TranslateGTMTLLinkedFunctions(v41, (uint64_t *)(v6 + 872), a2, a3);

  for (uint64_t j = 0LL; j != 31; ++j)
  {
    uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v75 objectBuffers]);
    int64x2_t v44 = (void *)objc_claimAutoreleasedReturnValue([v43 objectAtIndexedSubscript:j]);
    uint64_t v45 = v44;
    if (a3) {
      *(_BYTE *)(v6 + 1416 + j) = [v44 mutability];
    }
  }

  uint64_t v46 = 0LL;
  uint64_t v47 = v75;
  do
  {
    int64x2_t v48 = (void *)objc_claimAutoreleasedReturnValue([v47 meshBuffers]);
    id v49 = (void *)objc_claimAutoreleasedReturnValue([v48 objectAtIndexedSubscript:v46]);
    int64x2_t v50 = v49;
    if (a3) {
      *(_BYTE *)(v6 + 1385 + v46) = [v49 mutability];
    }

    ++v46;
    uint64_t v47 = v75;
  }

  while (v46 != 31);
  uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v75 objectPreloadedLibraries]);
  uint64_t v52 = TranslateNSArray(v51, (uint64_t)a2, a3);

  __int128 v53 = (void *)objc_claimAutoreleasedReturnValue([v75 meshPreloadedLibraries]);
  uint64_t v54 = TranslateNSArray(v53, (uint64_t)a2, a3);

  id v55 = (void *)objc_claimAutoreleasedReturnValue([v75 objectLinkedFunctions]);
  TranslateGTMTLLinkedFunctions(v55, (uint64_t *)(v6 + 1000), a2, a3);

  id v56 = (void *)objc_claimAutoreleasedReturnValue([v75 meshLinkedFunctions]);
  TranslateGTMTLLinkedFunctions(v56, (uint64_t *)(v6 + 936), a2, a3);

  if ((a3 & 1) != 0)
  {
    id v57 = (void *)objc_claimAutoreleasedReturnValue([v75 vertexFunction]);
    *(void *)(v6 + 1296) = [v57 streamReference];

    id v58 = (void *)objc_claimAutoreleasedReturnValue([v75 fragmentFunction]);
    *(void *)(v6 + 1176) = [v58 streamReference];

    *(void *)(v6 + 1272) = [v75 rasterSampleCount];
    *(void *)(v6 + 128_Block_object_dispose(va, 8) = [v75 sampleMask];
    [v75 sampleCoverage];
    *(_DWORD *)(v6 + 1332) = v59;
    *(_BYTE *)(v6 + 148mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v75 isAlphaToCoverageEnabled];
    *(_BYTE *)(v6 + 1481) = [v75 isAlphaToOneEnabled];
    *(_BYTE *)(v6 + 1493) = [v75 isRasterizationEnabled];
    *(_WORD *)(v6 + 134mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = (unsigned __int16)[v75 depthAttachmentPixelFormat];
    *(_WORD *)(v6 + 1352) = (unsigned __int16)[v75 stencilAttachmentPixelFormat];
    *(void *)(v6 + 120mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v21;
    *(_BYTE *)(v6 + 1485) = [v75 inputPrimitiveTopology];
    *(_BYTE *)(v6 + 1505) = [v75 tessellationPartitionMode];
    *(void *)(v6 + 120_Block_object_dispose(va, 8) = [v75 maxTessellationFactor];
    *(_BYTE *)(v6 + 1502) = [v75 isTessellationFactorScaleEnabled];
    *(_BYTE *)(v6 + 1501) = [v75 tessellationFactorFormat];
    *(_BYTE *)(v6 + 150mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v75 tessellationControlPointIndexType];
    *(_BYTE *)(v6 + 1503) = [v75 tessellationFactorStepFunction];
    *(_BYTE *)(v6 + 1504) = [v75 tessellationOutputWindingOrder];
    *(_BYTE *)(v6 + 1499) = [v75 supportIndirectCommandBuffers];
    if ((objc_opt_respondsToSelector(v75, "vertexAmplificationMode") & 1) != 0) {
      *(_BYTE *)(v6 + 1507) = [v75 vertexAmplificationMode];
    }
    if ((objc_opt_respondsToSelector(v75, "maxVertexAmplificationCount") & 1) != 0) {
      *(_DWORD *)(v6 + 132_Block_object_dispose(va, 8) = [v75 maxVertexAmplificationCount];
    }
    if ((objc_opt_respondsToSelector(v75, "pipelineLibrary") & 1) != 0)
    {
      CGFloat v60 = (void *)objc_claimAutoreleasedReturnValue([v75 pipelineLibrary]);
      *(void *)(v6 + 1264) = [v60 streamReference];
    }

    if ((objc_opt_respondsToSelector(v75, "logicOperation") & 1) != 0) {
      *(_BYTE *)(v6 + 1486) = [v75 logicOperation];
    }
    if ((objc_opt_respondsToSelector(v75, "alphaTestFunction") & 1) != 0) {
      *(_BYTE *)(v6 + 1479) = [v75 alphaTestFunction];
    }
    if ((objc_opt_respondsToSelector(v75, "vertexDepthCompareClampMask") & 1) != 0) {
      *(_DWORD *)(v6 + 1336) = [v75 vertexDepthCompareClampMask];
    }
    if ((objc_opt_respondsToSelector(v75, "fragmentDepthCompareClampMask") & 1) != 0) {
      *(_DWORD *)(v6 + 1324) = [v75 fragmentDepthCompareClampMask];
    }
    if ((objc_opt_respondsToSelector(v75, "isLogicOperationEnabled") & 1) != 0) {
      *(_BYTE *)(v6 + 1487) = [v75 isLogicOperationEnabled];
    }
    if ((objc_opt_respondsToSelector(v75, "openGLModeEnabled") & 1) != 0) {
      *(_BYTE *)(v6 + 1489) = [v75 openGLModeEnabled];
    }
    if ((objc_opt_respondsToSelector(v75, "isTwoSideEnabled") & 1) != 0) {
      *(_BYTE *)(v6 + 1506) = [v75 isTwoSideEnabled];
    }
    if ((objc_opt_respondsToSelector(v75, "isAlphaTestEnabled") & 1) != 0) {
      *(_BYTE *)(v6 + 147_Block_object_dispose(va, 8) = [v75 isAlphaTestEnabled];
    }
    if ((objc_opt_respondsToSelector(v75, "clipDistanceEnableMask") & 1) != 0) {
      *(_BYTE *)(v6 + 1482) = [v75 clipDistanceEnableMask];
    }
    if ((objc_opt_respondsToSelector(v75, "resourceIndex") & 1) != 0) {
      *(void *)(v6 + 128mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v75 resourceIndex];
    }
    if ((objc_opt_respondsToSelector(v75, "colorSampleCount") & 1) != 0) {
      *(void *)(v6 + 116mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v75 colorSampleCount];
    }
    if ((objc_opt_respondsToSelector(v75, "sampleCoverageInvert") & 1) != 0) {
      *(_BYTE *)(v6 + 1494) = [v75 sampleCoverageInvert];
    }
    if ((objc_opt_respondsToSelector(v75, "needsCustomBorderColorSamplers") & 1) != 0) {
      *(_BYTE *)(v6 + 148_Block_object_dispose(va, 8) = [v75 needsCustomBorderColorSamplers];
    }
    if ((objc_opt_respondsToSelector(v75, "isDepthStencilWriteDisabled") & 1) != 0) {
      *(_BYTE *)(v6 + 1483) = [v75 isDepthStencilWriteDisabled];
    }
    *(_BYTE *)(v6 + 1484) = [v75 forceSoftwareVertexFetch];
    *(void *)(v6 + 1144) = v74;
    *(void *)(v6 + 1152) = v73;
    *(void *)(v6 + 112_Block_object_dispose(va, 8) = v35;
    *(void *)(v6 + 1136) = v37;
    uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue([v75 vertexPreloadedLibraries]);
    *(void *)(v6 + 1312) = [v61 count];

    uint64_t v62 = v71;
    if (!*(void *)(v6 + 1312)) {
      uint64_t v62 = 0LL;
    }
    *(void *)(v6 + 1304) = v62;
    id v63 = (void *)objc_claimAutoreleasedReturnValue([v75 fragmentPreloadedLibraries]);
    *(void *)(v6 + 1192) = [v63 count];

    uint64_t v64 = v72;
    if (!*(void *)(v6 + 1192)) {
      uint64_t v64 = 0LL;
    }
    *(void *)(v6 + 1184) = v64;
    if ((objc_opt_respondsToSelector(v75, "objectFunction") & 1) != 0)
    {
      id v65 = (void *)objc_claimAutoreleasedReturnValue([v75 objectFunction]);
      *(void *)(v6 + 124mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v65 streamReference];
    }

    if ((objc_opt_respondsToSelector(v75, "meshFunction") & 1) != 0)
    {
      double v66 = (void *)objc_claimAutoreleasedReturnValue([v75 meshFunction]);
      *(void *)(v6 + 1216) = [v66 streamReference];
    }

    id v67 = (void *)objc_claimAutoreleasedReturnValue([v75 objectPreloadedLibraries]);
    *(void *)(v6 + 1256) = [v67 count];

    if (*(void *)(v6 + 1256)) {
      uint64_t v68 = v52;
    }
    else {
      uint64_t v68 = 0LL;
    }
    *(void *)(v6 + 124_Block_object_dispose(va, 8) = v68;
    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v75 meshPreloadedLibraries]);
    *(void *)(v6 + 1232) = [v69 count];

    if (*(void *)(v6 + 1232)) {
      uint64_t v70 = v54;
    }
    else {
      uint64_t v70 = 0LL;
    }
    *(void *)(v6 + 1224) = v70;
    if ((objc_opt_respondsToSelector(v75, "supportAddingVertexBinaryFunctions") & 1) != 0) {
      *(_BYTE *)(v6 + 149_Block_object_dispose(va, 8) = [v75 supportAddingVertexBinaryFunctions];
    }
    if ((objc_opt_respondsToSelector(v75, "supportAddingFragmentBinaryFunctions") & 1) != 0) {
      *(_BYTE *)(v6 + 1495) = [v75 supportAddingFragmentBinaryFunctions];
    }
    if ((objc_opt_respondsToSelector(v75, "supportAddingObjectBinaryFunctions") & 1) != 0) {
      *(_BYTE *)(v6 + 1497) = [v75 supportAddingObjectBinaryFunctions];
    }
    if ((objc_opt_respondsToSelector(v75, "supportAddingMeshBinaryFunctions") & 1) != 0) {
      *(_BYTE *)(v6 + 1496) = [v75 supportAddingMeshBinaryFunctions];
    }
    if ((objc_opt_respondsToSelector(v75, "explicitVisibilityGroupID") & 1) != 0) {
      *(_DWORD *)(v6 + 132mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v75 explicitVisibilityGroupID];
    }
    if ((objc_opt_respondsToSelector(v75, "maxVertexCallStackDepth") & 1) != 0) {
      *(_WORD *)(v6 + 135mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = (unsigned __int16)[v75 maxVertexCallStackDepth];
    }
    if ((objc_opt_respondsToSelector(v75, "maxFragmentCallStackDepth") & 1) != 0) {
      *(_WORD *)(v6 + 1344) = (unsigned __int16)[v75 maxFragmentCallStackDepth];
    }
    if ((objc_opt_respondsToSelector(v75, "maxObjectCallStackDepth") & 1) != 0) {
      *(_WORD *)(v6 + 134_Block_object_dispose(va, 8) = (unsigned __int16)[v75 maxObjectCallStackDepth];
    }
    if ((objc_opt_respondsToSelector(v75, "maxMeshCallStackDepth") & 1) != 0) {
      *(_WORD *)(v6 + 1346) = (unsigned __int16)[v75 maxMeshCallStackDepth];
    }
    if ((objc_opt_respondsToSelector(v75, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
      *(_WORD *)(v6 + 1342) = (unsigned __int16)[v75 maxAccelerationStructureTraversalDepth];
    }
  }
}

void *GTMTLDescriptorAllocator_copyDictionary(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  if (v5)
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    id v14 = 0LL;
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v5,  1LL,  &v14));
    id v8 = v14;
    id v9 = v7;
    id v10 = [v9 bytes];
    size_t v11 = (size_t)[v9 length];

    if (v11) {
      uint64_t v12 = *(void **)(a1 + 416);
    }
    else {
      uint64_t v12 = 0LL;
    }
    *(void *)(a1 + 416) += v11;
    if (a3) {
      memcpy(v12, v10, v11);
    }

    objc_autoreleasePoolPop(v6);
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  return v12;
}

void TranslateGTMTLLinkedFunctions(void *a1, uint64_t *a2, void *a3, int a4)
{
  id v7 = a1;
  int64x2_t v27 = a2;
  TranslateGTMTLLinkedFunctionsAuto(v7, a2, (uint64_t)a3, a4);
  uint64_t v26 = a3[42];
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  obuint64_t j = (id)objc_claimAutoreleasedReturnValue([v7 groups]);
  id v8 = [obj countByEnumeratingWithState:&v29 objects:v33 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v30;
    do
    {
      for (uint64_t i = 0LL; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v30 != v10) {
          objc_enumerationMutation(obj);
        }
        id v12 = *(id *)(*((void *)&v29 + 1) + 8LL * (void)i);
        uint64_t v13 = (const char *)[v12 UTF8String];
        id v14 = v13;
        if (v13)
        {
          size_t v15 = strlen(v13);
          uint64_t v16 = a3[52];
          size_t v17 = v15 + 1;
          if (v15 != -1LL)
          {
            uint64_t v18 = (void *)a3[52];
            goto LABEL_11;
          }
        }

        else
        {
          uint64_t v16 = a3[52];
        }

        size_t v17 = 0LL;
        uint64_t v18 = 0LL;
LABEL_11:
        a3[52] = v16 + v17;
        if (a4) {
          memcpy(v18, v14, v17);
        }
        uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v7 groups]);
        size_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:v12]);
        uint64_t v21 = TranslateNSArray(v20, (uint64_t)a3, a4);

        uint64_t v22 = a3[42];
        a3[42] = v22 + 24;
        if (a4)
        {
          unint64_t v23 = (unint64_t)(a3[50] - v21) >> 3;
          *(_DWORD *)(v22 + 16) = v23;
          if ((_DWORD)v23) {
            uint64_t v24 = v21;
          }
          else {
            uint64_t v24 = 0LL;
          }
          *(void *)uint64_t v22 = v18;
          *(void *)(v22 + _Block_object_dispose(va, 8) = v24;
        }
      }

      id v9 = [obj countByEnumeratingWithState:&v29 objects:v33 count:16];
    }

    while (v9);
  }

  if (a4)
  {
    unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((a3[42] - v26) >> 3);
    v27[4] = v26;
    v27[5] = v25;
  }
}

MTLRenderPipelineDescriptor *MakeMTLRenderPipelineDescriptorWithoutResourceIndex(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLRenderPipelineDescriptor);
  id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 1296)));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v5]);
  -[MTLRenderPipelineDescriptor setVertexFunction:](v4, "setVertexFunction:", v6);

  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 1176)));
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v7]);
  -[MTLRenderPipelineDescriptor setFragmentFunction:](v4, "setFragmentFunction:", v8);

  id v9 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor vertexDescriptor](v4, "vertexDescriptor"));
  -[MTLRenderPipelineDescriptor setRasterSampleCount:](v4, "setRasterSampleCount:", *(void *)(a1 + 1272));
  -[MTLRenderPipelineDescriptor setSampleMask:](v4, "setSampleMask:", *(void *)(a1 + 1288));
  LODWORD(v1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_DWORD *)(a1 + 1332);
  -[MTLRenderPipelineDescriptor setSampleCoverage:](v4, "setSampleCoverage:", v10);
  -[MTLRenderPipelineDescriptor setAlphaToCoverageEnabled:]( v4,  "setAlphaToCoverageEnabled:",  *(_BYTE *)(a1 + 1480) != 0);
  -[MTLRenderPipelineDescriptor setAlphaToOneEnabled:](v4, "setAlphaToOneEnabled:", *(_BYTE *)(a1 + 1481) != 0);
  -[MTLRenderPipelineDescriptor setRasterizationEnabled:](v4, "setRasterizationEnabled:", *(_BYTE *)(a1 + 1493) != 0);
  -[MTLRenderPipelineDescriptor setDepthAttachmentPixelFormat:]( v4,  "setDepthAttachmentPixelFormat:",  *(unsigned __int16 *)(a1 + 1340));
  -[MTLRenderPipelineDescriptor setStencilAttachmentPixelFormat:]( v4,  "setStencilAttachmentPixelFormat:",  *(unsigned __int16 *)(a1 + 1352));
  uint64_t v11 = 0LL;
  id v12 = (unsigned __int16 *)(a1 + 744);
  do
  {
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor colorAttachments](v4, "colorAttachments"));
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectAtIndexedSubscript:v11]);

    ++v11;
    v12 += 8;
  }

  while (v11 != 8);
  if (*(void *)(a1 + 1200))
  {
    size_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLRenderPipelineDescriptor setLabel:](v4, "setLabel:", v15);
  }

  -[MTLRenderPipelineDescriptor setInputPrimitiveTopology:]( v4,  "setInputPrimitiveTopology:",  *(unsigned __int8 *)(a1 + 1485));
  -[MTLRenderPipelineDescriptor setTessellationPartitionMode:]( v4,  "setTessellationPartitionMode:",  *(unsigned __int8 *)(a1 + 1505));
  -[MTLRenderPipelineDescriptor setMaxTessellationFactor:](v4, "setMaxTessellationFactor:", *(void *)(a1 + 1208));
  -[MTLRenderPipelineDescriptor setTessellationFactorScaleEnabled:]( v4,  "setTessellationFactorScaleEnabled:",  *(_BYTE *)(a1 + 1502) != 0);
  -[MTLRenderPipelineDescriptor setTessellationFactorFormat:]( v4,  "setTessellationFactorFormat:",  *(unsigned __int8 *)(a1 + 1501));
  -[MTLRenderPipelineDescriptor setTessellationControlPointIndexType:]( v4,  "setTessellationControlPointIndexType:",  *(unsigned __int8 *)(a1 + 1500));
  -[MTLRenderPipelineDescriptor setTessellationFactorStepFunction:]( v4,  "setTessellationFactorStepFunction:",  *(unsigned __int8 *)(a1 + 1503));
  -[MTLRenderPipelineDescriptor setTessellationOutputWindingOrder:]( v4,  "setTessellationOutputWindingOrder:",  *(unsigned __int8 *)(a1 + 1504));
  for (uint64_t i = 0LL; i != 31; ++i)
  {
    size_t v17 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor vertexBuffers](v4, "vertexBuffers"));
    id v18 = (id)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:i]);
    [v18 setMutability:*(unsigned __int8 *)(a1 + 1447 + i)];
  }

  for (uint64_t j = 0LL; j != 31; ++j)
  {
    size_t v20 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor fragmentBuffers](v4, "fragmentBuffers"));
    id v21 = (id)objc_claimAutoreleasedReturnValue([v20 objectAtIndexedSubscript:j]);
    [v21 setMutability:*(unsigned __int8 *)(a1 + 1354 + j)];
  }

  -[MTLRenderPipelineDescriptor setSupportIndirectCommandBuffers:]( v4,  "setSupportIndirectCommandBuffers:",  *(_BYTE *)(a1 + 1499) != 0);
  if ((objc_opt_respondsToSelector(v4, "vertexAmplificationMode") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setVertexAmplificationMode:]( v4,  "setVertexAmplificationMode:",  *(unsigned __int8 *)(a1 + 1507));
  }
  if ((objc_opt_respondsToSelector(v4, "maxVertexAmplificationCount") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxVertexAmplificationCount:]( v4,  "setMaxVertexAmplificationCount:",  *(unsigned int *)(a1 + 1328));
  }
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 1264)));
  unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v22]);
  -[MTLRenderPipelineDescriptor setPipelineLibrary:](v4, "setPipelineLibrary:", v23);

  if ((objc_opt_respondsToSelector(v4, "logicOperation") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setLogicOperation:](v4, "setLogicOperation:", *(unsigned __int8 *)(a1 + 1486));
  }
  if ((objc_opt_respondsToSelector(v4, "alphaTestFunction") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setAlphaTestFunction:](v4, "setAlphaTestFunction:", *(unsigned __int8 *)(a1 + 1479));
  }
  if ((objc_opt_respondsToSelector(v4, "vertexDepthCompareClampMask") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setVertexDepthCompareClampMask:]( v4,  "setVertexDepthCompareClampMask:",  *(unsigned int *)(a1 + 1336));
  }
  if ((objc_opt_respondsToSelector(v4, "fragmentDepthCompareClampMask") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setFragmentDepthCompareClampMask:]( v4,  "setFragmentDepthCompareClampMask:",  *(unsigned int *)(a1 + 1324));
  }
  if ((objc_opt_respondsToSelector(v4, "isLogicOperationEnabled") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setLogicOperationEnabled:]( v4,  "setLogicOperationEnabled:",  *(_BYTE *)(a1 + 1487) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "openGLModeEnabled") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setOpenGLModeEnabled:](v4, "setOpenGLModeEnabled:", *(_BYTE *)(a1 + 1489) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "isTwoSideEnabled") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setTwoSideEnabled:](v4, "setTwoSideEnabled:", *(_BYTE *)(a1 + 1506) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "isAlphaTestEnabled") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setAlphaTestEnabled:](v4, "setAlphaTestEnabled:", *(_BYTE *)(a1 + 1478) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "clipDistanceEnableMask") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setClipDistanceEnableMask:]( v4,  "setClipDistanceEnableMask:",  *(unsigned __int8 *)(a1 + 1482));
  }
  if ((objc_opt_respondsToSelector(v4, "colorSampleCount") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setColorSampleCount:](v4, "setColorSampleCount:", *(void *)(a1 + 1160));
  }
  if ((objc_opt_respondsToSelector(v4, "sampleCoverageInvert") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setSampleCoverageInvert:](v4, "setSampleCoverageInvert:", *(_BYTE *)(a1 + 1494) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "needsCustomBorderColorSamplers") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setNeedsCustomBorderColorSamplers:]( v4,  "setNeedsCustomBorderColorSamplers:",  *(_BYTE *)(a1 + 1488) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "isDepthStencilWriteDisabled") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setDepthStencilWriteDisabled:]( v4,  "setDepthStencilWriteDisabled:",  *(_BYTE *)(a1 + 1483) != 0);
  }
  -[MTLRenderPipelineDescriptor setForceSoftwareVertexFetch:]( v4,  "setForceSoftwareVertexFetch:",  *(_BYTE *)(a1 + 1484) != 0);
  id Dictionary = GTData_MakeDictionary(*(void *)(a1 + 1144), *(void *)(a1 + 1152));
  unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(Dictionary);
  -[MTLRenderPipelineDescriptor setPluginData:](v4, "setPluginData:", v25);

  id v26 = GTData_MakeDictionary(*(void *)(a1 + 1128), *(void *)(a1 + 1136));
  int64x2_t v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
  -[MTLRenderPipelineDescriptor setDriverCompilerOptions:](v4, "setDriverCompilerOptions:", v27);

  uint64_t v28 = *(void *)(a1 + 1312);
  if (v28)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1304), v28, v3);
    __int128 v30 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLRenderPipelineDescriptor setVertexPreloadedLibraries:](v4, "setVertexPreloadedLibraries:", v30);
  }

  uint64_t v31 = *(void *)(a1 + 1192);
  if (v31)
  {
    id v32 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1184), v31, v3);
    uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
    -[MTLRenderPipelineDescriptor setFragmentPreloadedLibraries:](v4, "setFragmentPreloadedLibraries:", v33);
  }

  id v34 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor vertexLinkedFunctions](v4, "vertexLinkedFunctions"));
  MakeMTLLinkedFunctions(v34, (void *)(a1 + 1064), v3);

  id v35 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor fragmentLinkedFunctions](v4, "fragmentLinkedFunctions"));
  MakeMTLLinkedFunctions(v35, (void *)(a1 + 872), v3);

  uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 1240)));
  uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v36]);
  -[MTLRenderPipelineDescriptor setObjectFunction:](v4, "setObjectFunction:", v37);

  double v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 1216)));
  id v39 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v38]);
  -[MTLRenderPipelineDescriptor setMeshFunction:](v4, "setMeshFunction:", v39);

  for (uint64_t k = 0LL; k != 31; ++k)
  {
    id v41 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor objectBuffers](v4, "objectBuffers"));
    id v42 = (id)objc_claimAutoreleasedReturnValue([v41 objectAtIndexedSubscript:k]);
    [v42 setMutability:*(unsigned __int8 *)(a1 + 1416 + k)];
  }

  for (uint64_t m = 0LL; m != 31; ++m)
  {
    int64x2_t v44 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor meshBuffers](v4, "meshBuffers"));
    id v45 = (id)objc_claimAutoreleasedReturnValue([v44 objectAtIndexedSubscript:m]);
    [v45 setMutability:*(unsigned __int8 *)(a1 + 1385 + m)];
  }

  uint64_t v46 = *(void *)(a1 + 1256);
  if (v46)
  {
    id v47 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1248), v46, v3);
    int64x2_t v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
    -[MTLRenderPipelineDescriptor setObjectPreloadedLibraries:](v4, "setObjectPreloadedLibraries:", v48);
  }

  uint64_t v49 = *(void *)(a1 + 1232);
  if (v49)
  {
    id v50 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1224), v49, v3);
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
    -[MTLRenderPipelineDescriptor setMeshPreloadedLibraries:](v4, "setMeshPreloadedLibraries:", v51);
  }

  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor objectLinkedFunctions](v4, "objectLinkedFunctions"));
  MakeMTLLinkedFunctions(v52, (void *)(a1 + 1000), v3);

  __int128 v53 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor meshLinkedFunctions](v4, "meshLinkedFunctions"));
  MakeMTLLinkedFunctions(v53, (void *)(a1 + 936), v3);

  if ((objc_opt_respondsToSelector(v4, "supportAddingVertexBinaryFunctions") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setSupportAddingVertexBinaryFunctions:]( v4,  "setSupportAddingVertexBinaryFunctions:",  *(_BYTE *)(a1 + 1498) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "supportAddingFragmentBinaryFunctions") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setSupportAddingFragmentBinaryFunctions:]( v4,  "setSupportAddingFragmentBinaryFunctions:",  *(_BYTE *)(a1 + 1495) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "supportAddingObjectBinaryFunctions") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setSupportAddingObjectBinaryFunctions:]( v4,  "setSupportAddingObjectBinaryFunctions:",  *(_BYTE *)(a1 + 1497) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "supportAddingMeshBinaryFunctions") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setSupportAddingMeshBinaryFunctions:]( v4,  "setSupportAddingMeshBinaryFunctions:",  *(_BYTE *)(a1 + 1496) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "explicitVisibilityGroupID") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setExplicitVisibilityGroupID:]( v4,  "setExplicitVisibilityGroupID:",  *(unsigned int *)(a1 + 1320));
  }
  if ((objc_opt_respondsToSelector(v4, "maxVertexCallStackDepth") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxVertexCallStackDepth:]( v4,  "setMaxVertexCallStackDepth:",  *(unsigned __int16 *)(a1 + 1350));
  }
  if ((objc_opt_respondsToSelector(v4, "maxFragmentCallStackDepth") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxFragmentCallStackDepth:]( v4,  "setMaxFragmentCallStackDepth:",  *(unsigned __int16 *)(a1 + 1344));
  }
  if ((objc_opt_respondsToSelector(v4, "maxObjectCallStackDepth") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxObjectCallStackDepth:]( v4,  "setMaxObjectCallStackDepth:",  *(unsigned __int16 *)(a1 + 1348));
  }
  if ((objc_opt_respondsToSelector(v4, "maxMeshCallStackDepth") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxMeshCallStackDepth:]( v4,  "setMaxMeshCallStackDepth:",  *(unsigned __int16 *)(a1 + 1346));
  }
  if ((objc_opt_respondsToSelector(v4, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxAccelerationStructureTraversalDepth:]( v4,  "setMaxAccelerationStructureTraversalDepth:",  *(unsigned __int16 *)(a1 + 1342));
  }
  uint64_t v54 = v4;

  return v54;
}

id GTData_MakeDictionary(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSDictionary, a2);
  uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSNumber, v5);
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSString, v7);
  uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSData, v9);
  id v12 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v4,  v6,  v8,  v10,  objc_opt_class(&OBJC_CLASS___NSNull, v11),  0LL);
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  a1,  a2,  0LL));
  id v24 = 0LL;
  size_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v13,  v14,  &v24));
  id v16 = v24;

  if (v16)
  {
    if (s_logUsingOsLog)
    {
      id v17 = gt_default_log();
      id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        id v19 = objc_claimAutoreleasedReturnValue([v16 localizedDescription]);
        id v20 = [v19 UTF8String];
        *(_DWORD *)buf = 136315138;
        id v26 = v20;
        _os_log_error_impl(&dword_0, v18, OS_LOG_TYPE_ERROR, "warning: %s", buf, 0xCu);
      }
    }

    else
    {
      uint64_t v22 = __stderrp;
      id v18 = (os_log_s *) objc_claimAutoreleasedReturnValue([v16 localizedDescription]);
      id v23 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"warning: %s", -[os_log_s UTF8String](v18, "UTF8String")));
      fprintf(v22, "%s\n", (const char *)[v23 UTF8String]);
    }
  }

  return v15;
}

void MakeMTLLinkedFunctions(void *a1, void *a2, void *a3)
{
  id v14 = a1;
  id v5 = a3;
  if (a2[7] + a2[3] + a2[1] + a2[5])
  {
    id v6 = MakeMTLLinkedFunctionsAuto(v14, (uint64_t)a2, v5);
    if (a2[5])
    {
      uint64_t v7 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  a2[5]);
      if (a2[5])
      {
        uint64_t v8 = 0LL;
        unint64_t v9 = 0LL;
        do
        {
          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)(a2[4] + v8)));
          id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a2[4] + v8 + 8), *(_DWORD *)(a2[4] + v8 + 16), v5);
          id v12 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
          -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v12, v10);

          ++v9;
          v8 += 24LL;
        }

        while (a2[5] > v9);
      }

      id v13 = -[NSMutableDictionary copy](v7, "copy");
      [v14 setGroups:v13];
    }
  }
}

id MakeMTLRenderPipelineDescriptorWithResourceIndex(uint64_t a1, void *a2)
{
  MTLRenderPipelineDescriptorWithoutResourceIndex = MakeMTLRenderPipelineDescriptorWithoutResourceIndex(a1, a2);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPipelineDescriptorWithoutResourceIndex);
  id v5 = v4;
  if (*(_BYTE *)(a1 + 1499)) {
    [v4 setResourceIndex:*(void *)(a1 + 1280)];
  }
  return v5;
}

void TranslateGTMTLMeshRenderPipelineDescriptor(void *a1, void *a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = a2[26];
  a2[26] = v6 + 512;
  if (a3) {
    memcpy((void *)v6, &GTMTLMeshRenderPipelineDescriptorDefaults, 0x200uLL);
  }
  id v7 = v5;
  id v8 = objc_claimAutoreleasedReturnValue([v7 label]);
  unint64_t v9 = (const char *)[v8 UTF8String];
  uint64_t v10 = v9;
  if (v9)
  {
    size_t v11 = strlen(v9);
    id v12 = a2 + 52;
    uint64_t v13 = a2[52];
    size_t v14 = v11 + 1;
    if (v11 != -1LL)
    {
      size_t v15 = (void *)a2[52];
      goto LABEL_8;
    }
  }

  else
  {
    id v12 = a2 + 52;
    uint64_t v13 = a2[52];
  }

  size_t v14 = 0LL;
  size_t v15 = 0LL;
LABEL_8:
  *id v12 = v13 + v14;
  if (a3) {
    memcpy(v15, v10, v14);
  }

  for (uint64_t i = 0LL; i != 31; ++i)
  {
    id v17 = (void *)objc_claimAutoreleasedReturnValue([v7 objectBuffers]);
    id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:i]);
    id v19 = v18;
    if (a3) {
      *(_BYTE *)(v6 + 472 + i) = [v18 mutability];
    }
  }

  for (uint64_t j = 0LL; j != 31; ++j)
  {
    id v21 = (void *)objc_claimAutoreleasedReturnValue([v7 meshBuffers]);
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v21 objectAtIndexedSubscript:j]);
    id v23 = v22;
    if (a3) {
      *(_BYTE *)(v6 + 441 + j) = [v22 mutability];
    }
  }

  for (uint64_t k = 0LL; k != 31; ++k)
  {
    unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v7 fragmentBuffers]);
    id v26 = (void *)objc_claimAutoreleasedReturnValue([v25 objectAtIndexedSubscript:k]);
    int64x2_t v27 = v26;
    if (a3) {
      *(_BYTE *)(v6 + 410 + k) = [v26 mutability];
    }
  }

  uint64_t v28 = 0LL;
  uint64_t v29 = v6;
  do
  {
    __int128 v30 = (void *)objc_claimAutoreleasedReturnValue([v7 colorAttachments]);
    uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v30 objectAtIndexedSubscript:v28]);
    TranslateGTMTLRenderPipelineColorAttachmentDescriptor(v31, v29, v32, a3);

    ++v28;
    v29 += 16LL;
  }

  while (v28 != 8);
  uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v7 objectLinkedFunctions]);
  TranslateGTMTLLinkedFunctions(v33, (uint64_t *)(v6 + 256), a2, a3);

  id v34 = (void *)objc_claimAutoreleasedReturnValue([v7 meshLinkedFunctions]);
  TranslateGTMTLLinkedFunctions(v34, (uint64_t *)(v6 + 192), a2, a3);

  id v35 = (void *)objc_claimAutoreleasedReturnValue([v7 fragmentLinkedFunctions]);
  TranslateGTMTLLinkedFunctions(v35, (uint64_t *)(v6 + 128), a2, a3);

  if ((a3 & 1) != 0)
  {
    *(void *)(v6 + 352) = v15;
    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v7 objectFunction]);
    *(void *)(v6 + 36_Block_object_dispose(va, 8) = [v36 streamReference];

    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v7 meshFunction]);
    *(void *)(v6 + 36mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v37 streamReference];

    double v38 = (void *)objc_claimAutoreleasedReturnValue([v7 fragmentFunction]);
    *(void *)(v6 + 344) = [v38 streamReference];

    if ((objc_opt_respondsToSelector(v7, "maxTotalThreadsPerObjectThreadgroup") & 1) != 0) {
      *(_WORD *)(v6 + 406) = (unsigned __int16)[v7 maxTotalThreadsPerObjectThreadgroup];
    }
    if ((objc_opt_respondsToSelector(v7, "maxTotalThreadsPerMeshThreadgroup") & 1) != 0) {
      *(_WORD *)(v6 + 404) = (unsigned __int16)[v7 maxTotalThreadsPerMeshThreadgroup];
    }
    if ((objc_opt_respondsToSelector(v7, "objectThreadgroupSizeIsMultipleOfThreadExecutionWidth") & 1) != 0) {
      *(_BYTE *)(v6 + 507) = [v7 objectThreadgroupSizeIsMultipleOfThreadExecutionWidth];
    }
    if ((objc_opt_respondsToSelector(v7, "meshThreadgroupSizeIsMultipleOfThreadExecutionWidth") & 1) != 0) {
      *(_BYTE *)(v6 + 506) = [v7 meshThreadgroupSizeIsMultipleOfThreadExecutionWidth];
    }
    *(void *)(v6 + 376) = [v7 payloadMemoryLength];
    if (v7)
    {
      [v7 maxThreadgroupsPerMeshGrid];
      __int128 v39 = v41;
      uint64_t v40 = v42;
    }

    else
    {
      uint64_t v40 = 0LL;
      uint64_t v42 = 0LL;
      __int128 v39 = 0uLL;
      __int128 v41 = 0u;
    }

    *(_OWORD *)(v6 + 32mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v39;
    *(void *)(v6 + 336) = v40;
    *(_BYTE *)(v6 + 50_Block_object_dispose(va, 8) = objc_msgSend(v7, "rasterSampleCount", v41, v42);
    *(_BYTE *)(v6 + 503) = [v7 isAlphaToCoverageEnabled];
    *(_BYTE *)(v6 + 504) = [v7 isAlphaToOneEnabled];
    *(_BYTE *)(v6 + 509) = [v7 isRasterizationEnabled];
    if ((objc_opt_respondsToSelector(v7, "maxVertexAmplificationCount") & 1) != 0) {
      *(_DWORD *)(v6 + 396) = [v7 maxVertexAmplificationCount];
    }
    *(_WORD *)(v6 + 40mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = (unsigned __int16)[v7 depthAttachmentPixelFormat];
    *(_WORD *)(v6 + 40_Block_object_dispose(va, 8) = (unsigned __int16)[v7 stencilAttachmentPixelFormat];
    if ((objc_opt_respondsToSelector(v7, "supportIndirectCommandBuffers") & 1) != 0) {
      *(_BYTE *)(v6 + 51mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v7 supportIndirectCommandBuffers];
    }
    if ((objc_opt_respondsToSelector(v7, "explicitVisibilityGroupID") & 1) != 0) {
      *(_DWORD *)(v6 + 392) = [v7 explicitVisibilityGroupID];
    }
    if ((objc_opt_respondsToSelector(v7, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
      *(_WORD *)(v6 + 402) = (unsigned __int16)[v7 maxAccelerationStructureTraversalDepth];
    }
    *(void *)(v6 + 384) = [v7 resourceIndex];
  }
}

MTLMeshRenderPipelineDescriptor *MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex( uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLMeshRenderPipelineDescriptor);
  if (*(void *)(a1 + 352))
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLMeshRenderPipelineDescriptor setLabel:](v4, "setLabel:", v5);
  }

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 368)));
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v6]);
  -[MTLMeshRenderPipelineDescriptor setObjectFunction:](v4, "setObjectFunction:", v7);

  id v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 360)));
  unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v8]);
  -[MTLMeshRenderPipelineDescriptor setMeshFunction:](v4, "setMeshFunction:", v9);

  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 344)));
  size_t v11 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v10]);
  -[MTLMeshRenderPipelineDescriptor setFragmentFunction:](v4, "setFragmentFunction:", v11);

  if ((objc_opt_respondsToSelector(v4, "maxTotalThreadsPerObjectThreadgroup") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setMaxTotalThreadsPerObjectThreadgroup:]( v4,  "setMaxTotalThreadsPerObjectThreadgroup:",  *(unsigned __int16 *)(a1 + 406));
  }
  if ((objc_opt_respondsToSelector(v4, "maxTotalThreadsPerMeshThreadgroup") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setMaxTotalThreadsPerMeshThreadgroup:]( v4,  "setMaxTotalThreadsPerMeshThreadgroup:",  *(unsigned __int16 *)(a1 + 404));
  }
  if ((objc_opt_respondsToSelector(v4, "objectThreadgroupSizeIsMultipleOfThreadExecutionWidth") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth:]( v4,  "setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth:",  *(_BYTE *)(a1 + 507) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "meshThreadgroupSizeIsMultipleOfThreadExecutionWidth") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth:]( v4,  "setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth:",  *(_BYTE *)(a1 + 506) != 0);
  }
  -[MTLMeshRenderPipelineDescriptor setPayloadMemoryLength:](v4, "setPayloadMemoryLength:", *(void *)(a1 + 376));
  uint64_t v12 = *(void *)(a1 + 336);
  __int128 v30 = *(_OWORD *)(a1 + 320);
  uint64_t v31 = v12;
  -[MTLMeshRenderPipelineDescriptor setMaxThreadgroupsPerMeshGrid:](v4, "setMaxThreadgroupsPerMeshGrid:", &v30);
  for (uint64_t i = 0LL; i != 31; ++i)
  {
    size_t v14 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor objectBuffers](v4, "objectBuffers"));
    size_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 objectAtIndexedSubscript:i]);
    [v15 setMutability:*(unsigned __int8 *)(a1 + 472 + i)];
  }

  for (uint64_t j = 0LL; j != 31; ++j)
  {
    id v17 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor meshBuffers](v4, "meshBuffers"));
    id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:j]);
    [v18 setMutability:*(unsigned __int8 *)(a1 + 441 + j)];
  }

  for (uint64_t k = 0LL; k != 31; ++k)
  {
    id v20 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor fragmentBuffers](v4, "fragmentBuffers"));
    id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 objectAtIndexedSubscript:k]);
    [v21 setMutability:*(unsigned __int8 *)(a1 + 410 + k)];
  }

  -[MTLMeshRenderPipelineDescriptor setRasterSampleCount:](v4, "setRasterSampleCount:", *(unsigned __int8 *)(a1 + 508));
  -[MTLMeshRenderPipelineDescriptor setAlphaToCoverageEnabled:]( v4,  "setAlphaToCoverageEnabled:",  *(_BYTE *)(a1 + 503) != 0);
  -[MTLMeshRenderPipelineDescriptor setAlphaToOneEnabled:](v4, "setAlphaToOneEnabled:", *(_BYTE *)(a1 + 504) != 0);
  -[MTLMeshRenderPipelineDescriptor setRasterizationEnabled:](v4, "setRasterizationEnabled:", *(_BYTE *)(a1 + 509) != 0);
  if ((objc_opt_respondsToSelector(v4, "maxVertexAmplificationCount") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setMaxVertexAmplificationCount:]( v4,  "setMaxVertexAmplificationCount:",  *(unsigned int *)(a1 + 396));
  }
  uint64_t v22 = 0LL;
  id v23 = (unsigned __int16 *)a1;
  do
  {
    id v24 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor colorAttachments](v4, "colorAttachments"));
    unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v24 objectAtIndexedSubscript:v22]);

    ++v22;
    v23 += 8;
  }

  while (v22 != 8);
  -[MTLMeshRenderPipelineDescriptor setDepthAttachmentPixelFormat:]( v4,  "setDepthAttachmentPixelFormat:",  *(unsigned __int16 *)(a1 + 400));
  -[MTLMeshRenderPipelineDescriptor setStencilAttachmentPixelFormat:]( v4,  "setStencilAttachmentPixelFormat:",  *(unsigned __int16 *)(a1 + 408));
  if ((objc_opt_respondsToSelector(v4, "supportIndirectCommandBuffers") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setSupportIndirectCommandBuffers:]( v4,  "setSupportIndirectCommandBuffers:",  *(_BYTE *)(a1 + 510) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "explicitVisibilityGroupID") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setExplicitVisibilityGroupID:]( v4,  "setExplicitVisibilityGroupID:",  *(unsigned int *)(a1 + 392));
  }
  id v26 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor objectLinkedFunctions](v4, "objectLinkedFunctions"));
  MakeMTLLinkedFunctions(v26, (void *)(a1 + 256), v3);

  int64x2_t v27 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor meshLinkedFunctions](v4, "meshLinkedFunctions"));
  MakeMTLLinkedFunctions(v27, (void *)(a1 + 192), v3);

  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor fragmentLinkedFunctions](v4, "fragmentLinkedFunctions"));
  MakeMTLLinkedFunctions(v28, (void *)(a1 + 128), v3);

  if ((objc_opt_respondsToSelector(v4, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setMaxAccelerationStructureTraversalDepth:]( v4,  "setMaxAccelerationStructureTraversalDepth:",  *(unsigned __int16 *)(a1 + 402));
  }

  return v4;
}

id MakeMTLMeshRenderPipelineDescriptorWithResourceIndex(uint64_t a1, void *a2)
{
  MTLMeshRenderPipelineDescriptorWithoutResourceIndex = MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex(a1, a2);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(MTLMeshRenderPipelineDescriptorWithoutResourceIndex);
  id v5 = v4;
  if (*(_BYTE *)(a1 + 510)) {
    [v4 setResourceIndex:*(void *)(a1 + 384)];
  }
  return v5;
}

void TranslateGTMTLStencilDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    *(_BYTE *)(a2 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v5 stencilCompareFunction];
    *(_BYTE *)(a2 + 11) = [v5 stencilFailureOperation];
    *(_BYTE *)(a2 + _Block_object_dispose(va, 8) = [v5 depthFailureOperation];
    *(_BYTE *)(a2 + 9) = [v5 depthStencilPassOperation];
    *(_DWORD *)a2 = [v5 readMask];
    unsigned int v6 = [v5 writeMask];

    *(_DWORD *)(a2 + 4) = v6;
  }

id MakeMTLStencilDescriptor(void *a1, unsigned int *a2)
{
  id v3 = a1;
  [v3 setStencilCompareFunction:*((unsigned __int8 *)a2 + 10)];
  [v3 setStencilFailureOperation:*((unsigned __int8 *)a2 + 11)];
  [v3 setDepthFailureOperation:*((unsigned __int8 *)a2 + 8)];
  [v3 setDepthStencilPassOperation:*((unsigned __int8 *)a2 + 9)];
  [v3 setReadMask:*a2];
  [v3 setWriteMask:a2[1]];
  return v3;
}

void TranslateGTMTLDepthStencilDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 200);
  *(void *)(a2 + 20mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v6 + 48;
  if (a3)
  {
    *(_OWORD *)uint64_t v6 = GTMTLDepthStencilDescriptorDefaults;
    *(_OWORD *)(v6 + 16) = unk_1C7C28;
    *(_OWORD *)(v6 + 32) = xmmword_1C7C38;
  }

  id v24 = v5;
  id v7 = objc_claimAutoreleasedReturnValue([v5 label]);
  id v8 = (const char *)[v7 UTF8String];
  unint64_t v9 = v8;
  if (v8)
  {
    size_t v10 = strlen(v8);
    size_t v11 = (void *)(a2 + 416);
    uint64_t v12 = *(void *)(a2 + 416);
    size_t v13 = v10 + 1;
    if (v10 != -1LL)
    {
      size_t v14 = *(void **)(a2 + 416);
      goto LABEL_8;
    }
  }

  else
  {
    size_t v11 = (void *)(a2 + 416);
    uint64_t v12 = *(void *)(a2 + 416);
  }

  size_t v13 = 0LL;
  size_t v14 = 0LL;
LABEL_8:
  *size_t v11 = v12 + v13;
  if (a3)
  {
    memcpy(v14, v9, v13);

    size_t v15 = (void *)objc_claimAutoreleasedReturnValue([v24 frontFaceStencil]);
    TranslateGTMTLStencilDescriptor(v15, v6 + 16, v16, a3);

    id v17 = (void *)objc_claimAutoreleasedReturnValue([v24 backFaceStencil]);
    TranslateGTMTLStencilDescriptor(v17, v6, v18, a3);

    *(_BYTE *)(v6 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v24 depthCompareFunction];
    *(_BYTE *)(v6 + 41) = [v24 isDepthWriteEnabled];
    id v19 = v24;
    *(void *)(v6 + 32) = v14;
  }

  else
  {

    id v20 = (void *)objc_claimAutoreleasedReturnValue([v24 frontFaceStencil]);
    TranslateGTMTLStencilDescriptor(v20, v6 + 16, v21, 0);

    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v24 backFaceStencil]);
    TranslateGTMTLStencilDescriptor(v22, v6, v23, 0);

    id v19 = v24;
  }
}

MTLDepthStencilDescriptor *MakeMTLDepthStencilDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLDepthStencilDescriptor);
  -[MTLDepthStencilDescriptor setDepthCompareFunction:](v2, "setDepthCompareFunction:", *(unsigned __int8 *)(a1 + 40));
  -[MTLDepthStencilDescriptor setDepthWriteEnabled:](v2, "setDepthWriteEnabled:", *(_BYTE *)(a1 + 41) != 0);
  if (*(void *)(a1 + 32))
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLDepthStencilDescriptor setLabel:](v2, "setLabel:", v3);
  }

  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(-[MTLDepthStencilDescriptor frontFaceStencil](v2, "frontFaceStencil"));

  id v5 = (void *)objc_claimAutoreleasedReturnValue(-[MTLDepthStencilDescriptor backFaceStencil](v2, "backFaceStencil"));
  return v2;
}

void TranslateGTMTLSamplerDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 192);
  *(void *)(a2 + 192) = v6 + 64;
  if (a3)
  {
    *(_OWORD *)uint64_t v6 = GTMTLSamplerDescriptorDefaults;
    *(_OWORD *)(v6 + 16) = unk_1C7C58;
    *(_OWORD *)(v6 + 32) = xmmword_1C7C68;
    *(_OWORD *)(v6 + 4_Block_object_dispose(va, 8) = unk_1C7C78;
  }

  id v17 = v5;
  id v7 = objc_claimAutoreleasedReturnValue([v17 label]);
  id v8 = (const char *)[v7 UTF8String];
  unint64_t v9 = v8;
  if (v8)
  {
    size_t v10 = strlen(v8);
    size_t v11 = (void *)(a2 + 416);
    uint64_t v12 = *(void *)(a2 + 416);
    size_t v13 = v10 + 1;
    if (v10 != -1LL)
    {
      size_t v14 = *(void **)(a2 + 416);
      goto LABEL_8;
    }
  }

  else
  {
    size_t v11 = (void *)(a2 + 416);
    uint64_t v12 = *(void *)(a2 + 416);
  }

  size_t v13 = 0LL;
  size_t v14 = 0LL;
LABEL_8:
  *size_t v11 = v12 + v13;
  if ((a3 & 1) != 0)
  {
    memcpy(v14, v9, v13);

    *(_BYTE *)(v6 + 56) = [v17 minFilter];
    *(_BYTE *)(v6 + 55) = [v17 magFilter];
    *(_BYTE *)(v6 + 57) = [v17 mipFilter];
    *(void *)(v6 + _Block_object_dispose(va, 8) = [v17 maxAnisotropy];
    *(_BYTE *)(v6 + 61) = [v17 sAddressMode];
    *(_BYTE *)(v6 + 63) = [v17 tAddressMode];
    *(_BYTE *)(v6 + 59) = [v17 rAddressMode];
    *(_BYTE *)(v6 + 5_Block_object_dispose(va, 8) = [v17 normalizedCoordinates];
    [v17 lodMinClamp];
    *(_DWORD *)(v6 + 44) = v15;
    [v17 lodMaxClamp];
    *(_DWORD *)(v6 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v16;
    *(void *)uint64_t v6 = v14;
    *(_BYTE *)(v6 + 54) = [v17 lodAverage];
    *(_BYTE *)(v6 + 51) = [v17 compareFunction];
    *(_BYTE *)(v6 + 5mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v17 borderColor];
    *(_BYTE *)(v6 + 62) = [v17 supportArgumentBuffers];
    if ((objc_opt_respondsToSelector(v17, "resourceIndex") & 1) != 0) {
      *(void *)(v6 + 16) = [v17 resourceIndex];
    }
    *(_BYTE *)(v6 + 52) = [v17 forceResourceIndex];
    if ((objc_opt_respondsToSelector(v17, "customBorderColorValue_0") & 1) != 0) {
      *(_DWORD *)(v6 + 24) = [v17 customBorderColorValue];
    }
    if ((objc_opt_respondsToSelector(v17, "customBorderColorValue_1") & 1) != 0) {
      *(_DWORD *)(v6 + 2_Block_object_dispose(va, 8) = [v17 customBorderColorValue];
    }
    if ((objc_opt_respondsToSelector(v17, "customBorderColorValue_2") & 1) != 0) {
      *(_DWORD *)(v6 + 32) = [v17 customBorderColorValue];
    }
    if ((objc_opt_respondsToSelector(v17, "customBorderColorValue_3") & 1) != 0) {
      *(_DWORD *)(v6 + 36) = [v17 customBorderColorValue];
    }
    if ((objc_opt_respondsToSelector(v17, "forceSeamsOnCubemapFiltering") & 1) != 0) {
      *(_BYTE *)(v6 + 53) = [v17 forceSeamsOnCubemapFiltering];
    }
    if ((objc_opt_respondsToSelector(v17, "pixelFormat") & 1) != 0) {
      *(_WORD *)(v6 + 4_Block_object_dispose(va, 8) = (unsigned __int16)[v17 pixelFormat];
    }
  }

  else
  {
  }
}

MTLSamplerDescriptor *MakeMTLSamplerDescriptorWithoutResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLSamplerDescriptor);
  -[MTLSamplerDescriptor setMinFilter:](v2, "setMinFilter:", *(unsigned __int8 *)(a1 + 56));
  -[MTLSamplerDescriptor setMagFilter:](v2, "setMagFilter:", *(unsigned __int8 *)(a1 + 55));
  -[MTLSamplerDescriptor setMipFilter:](v2, "setMipFilter:", *(unsigned __int8 *)(a1 + 57));
  -[MTLSamplerDescriptor setMaxAnisotropy:](v2, "setMaxAnisotropy:", *(void *)(a1 + 8));
  -[MTLSamplerDescriptor setSAddressMode:](v2, "setSAddressMode:", *(unsigned __int8 *)(a1 + 61));
  -[MTLSamplerDescriptor setTAddressMode:](v2, "setTAddressMode:", *(unsigned __int8 *)(a1 + 63));
  -[MTLSamplerDescriptor setRAddressMode:](v2, "setRAddressMode:", *(unsigned __int8 *)(a1 + 59));
  -[MTLSamplerDescriptor setNormalizedCoordinates:](v2, "setNormalizedCoordinates:", *(_BYTE *)(a1 + 58) != 0);
  LODWORD(v3) = *(_DWORD *)(a1 + 44);
  -[MTLSamplerDescriptor setLodMinClamp:](v2, "setLodMinClamp:", v3);
  LODWORD(v4) = *(_DWORD *)(a1 + 40);
  -[MTLSamplerDescriptor setLodMaxClamp:](v2, "setLodMaxClamp:", v4);
  if (*(void *)a1)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLSamplerDescriptor setLabel:](v2, "setLabel:", v5);
  }

  -[MTLSamplerDescriptor setLodAverage:](v2, "setLodAverage:", *(_BYTE *)(a1 + 54) != 0);
  -[MTLSamplerDescriptor setCompareFunction:](v2, "setCompareFunction:", *(unsigned __int8 *)(a1 + 51));
  -[MTLSamplerDescriptor setBorderColor:](v2, "setBorderColor:", *(unsigned __int8 *)(a1 + 50));
  -[MTLSamplerDescriptor setSupportArgumentBuffers:](v2, "setSupportArgumentBuffers:", *(_BYTE *)(a1 + 62) != 0);
  if ((objc_opt_respondsToSelector(v2, "customBorderColorValue_0") & 1) != 0) {
    -[MTLSamplerDescriptor setCustomBorderColorValue_0:](v2, "setCustomBorderColorValue_0:", *(unsigned int *)(a1 + 24));
  }
  if ((objc_opt_respondsToSelector(v2, "customBorderColorValue_1") & 1) != 0) {
    -[MTLSamplerDescriptor setCustomBorderColorValue_1:](v2, "setCustomBorderColorValue_1:", *(unsigned int *)(a1 + 28));
  }
  if ((objc_opt_respondsToSelector(v2, "customBorderColorValue_2") & 1) != 0) {
    -[MTLSamplerDescriptor setCustomBorderColorValue_2:](v2, "setCustomBorderColorValue_2:", *(unsigned int *)(a1 + 32));
  }
  if ((objc_opt_respondsToSelector(v2, "customBorderColorValue_3") & 1) != 0) {
    -[MTLSamplerDescriptor setCustomBorderColorValue_3:](v2, "setCustomBorderColorValue_3:", *(unsigned int *)(a1 + 36));
  }
  if ((objc_opt_respondsToSelector(v2, "forceSeamsOnCubemapFiltering") & 1) != 0) {
    -[MTLSamplerDescriptor setForceSeamsOnCubemapFiltering:]( v2,  "setForceSeamsOnCubemapFiltering:",  *(_BYTE *)(a1 + 53) != 0);
  }
  if ((objc_opt_respondsToSelector(v2, "pixelFormat") & 1) != 0) {
    -[MTLSamplerDescriptor setPixelFormat:](v2, "setPixelFormat:", *(unsigned __int16 *)(a1 + 48));
  }
  return v2;
}

id MakeMTLSamplerDescriptorWithResourceIndex(uint64_t a1)
{
  MTLSamplerDescriptorWithoutResourceIndex = MakeMTLSamplerDescriptorWithoutResourceIndex(a1);
  double v3 = (void *)objc_claimAutoreleasedReturnValue(MTLSamplerDescriptorWithoutResourceIndex);
  [v3 setForceResourceIndex:*(void *)(a1 + 16) != 0];
  [v3 setResourceIndex:*(void *)(a1 + 16)];
  return v3;
}

void TranslateGTMTLHeapDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 184);
  *(void *)(a2 + 184) = v6 + 24;
  id v9 = v5;
  if (a3)
  {
    *(_OWORD *)uint64_t v6 = GTMTLHeapDescriptorDefaults;
    *(void *)(v6 + 16) = 32LL;
    id v7 = v5;
    *(void *)(v6 + _Block_object_dispose(va, 8) = [v7 size];
    if ((objc_opt_respondsToSelector(v7, "type") & 1) != 0) {
      *(_BYTE *)(v6 + 19) = [v7 type];
    }
    if ((objc_opt_respondsToSelector(v7, "resourceOptions") & 1) != 0) {
      *(_WORD *)(v6 + 16) = (unsigned __int16)[v7 resourceOptions];
    }
    if ((objc_opt_respondsToSelector(v7, "sparsePageSize") & 1) != 0) {
      *(_BYTE *)(v6 + 1_Block_object_dispose(va, 8) = [v7 sparsePageSize];
    }
    if ((objc_opt_respondsToSelector(v7, "pinnedGPUAddress") & 1) != 0) {
      *(void *)uint64_t v6 = [v7 pinnedGPUAddress];
    }
  }

  else
  {
    id v8 = v5;
  }
}

MTLHeapDescriptor *MakeMTLHeapDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLHeapDescriptor);
  -[MTLHeapDescriptor setSize:](v2, "setSize:", *(void *)(a1 + 8));
  if ((objc_opt_respondsToSelector(v2, "type") & 1) != 0) {
    -[MTLHeapDescriptor setType:](v2, "setType:", *(unsigned __int8 *)(a1 + 19));
  }
  if ((objc_opt_respondsToSelector(v2, "resourceOptions") & 1) != 0) {
    -[MTLHeapDescriptor setResourceOptions:](v2, "setResourceOptions:", *(unsigned __int16 *)(a1 + 16));
  }
  if ((objc_opt_respondsToSelector(v2, "sparsePageSize") & 1) != 0) {
    -[MTLHeapDescriptor setSparsePageSize:](v2, "setSparsePageSize:", *(unsigned __int8 *)(a1 + 18));
  }
  return v2;
}

id MakeMTLHeapDescriptorWithBufferPinning(void *a1)
{
  MTLHeapDescriptor = MakeMTLHeapDescriptor((uint64_t)a1);
  double v3 = (void *)objc_claimAutoreleasedReturnValue(MTLHeapDescriptor);
  [v3 setPinnedGPUAddress:*a1];
  return v3;
}

void TranslateGTMTLIndirectCommandBufferDescriptorAuto(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 176);
  *(void *)(a2 + 176) = v6 + 24;
  id v9 = v5;
  if (a3)
  {
    *(void *)uint64_t v6 = 0LL;
    *(void *)(v6 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(v6 + 16) = 0LL;
    id v7 = v5;
    *(_WORD *)(v6 + _Block_object_dispose(va, 8) = (unsigned __int16)[v7 commandTypes];
    if ((objc_opt_respondsToSelector(v7, "inheritPipelineState") & 1) != 0) {
      *(_BYTE *)(v6 + 11) = [v7 inheritPipelineState];
    }
    *(_BYTE *)(v6 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v7 inheritBuffers];
    *(_BYTE *)(v6 + 1_Block_object_dispose(va, 8) = [v7 maxVertexBufferBindCount];
    *(_BYTE *)(v6 + 12) = [v7 maxFragmentBufferBindCount];
    if ((objc_opt_respondsToSelector(v7, "maxKernelBufferBindCount") & 1) != 0) {
      *(_BYTE *)(v6 + 13) = [v7 maxKernelBufferBindCount];
    }
    *(void *)uint64_t v6 = [v7 resourceIndex];
    if ((objc_opt_respondsToSelector(v7, "supportRayTracing") & 1) != 0) {
      *(_BYTE *)(v6 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v7 supportRayTracing];
    }
    if ((objc_opt_respondsToSelector(v7, "maxObjectBufferBindCount") & 1) != 0) {
      *(_BYTE *)(v6 + 16) = [v7 maxObjectBufferBindCount];
    }
    if ((objc_opt_respondsToSelector(v7, "maxMeshBufferBindCount") & 1) != 0) {
      *(_BYTE *)(v6 + 15) = [v7 maxMeshBufferBindCount];
    }
    if ((objc_opt_respondsToSelector(v7, "maxObjectThreadgroupMemoryBindCount") & 1) != 0) {
      *(_BYTE *)(v6 + 17) = [v7 maxObjectThreadgroupMemoryBindCount];
    }
    if ((objc_opt_respondsToSelector(v7, "supportDynamicAttributeStride") & 1) != 0) {
      *(_BYTE *)(v6 + 19) = [v7 supportDynamicAttributeStride];
    }
  }

  else
  {
    id v8 = v5;
  }
}

MTLIndirectCommandBufferDescriptor *MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLIndirectCommandBufferDescriptor);
  -[MTLIndirectCommandBufferDescriptor setCommandTypes:](v2, "setCommandTypes:", *(unsigned __int16 *)(a1 + 8));
  if ((objc_opt_respondsToSelector(v2, "inheritPipelineState") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setInheritPipelineState:]( v2,  "setInheritPipelineState:",  *(_BYTE *)(a1 + 11) != 0);
  }
  -[MTLIndirectCommandBufferDescriptor setInheritBuffers:](v2, "setInheritBuffers:", *(_BYTE *)(a1 + 10) != 0);
  -[MTLIndirectCommandBufferDescriptor setMaxVertexBufferBindCount:]( v2,  "setMaxVertexBufferBindCount:",  *(unsigned __int8 *)(a1 + 18));
  -[MTLIndirectCommandBufferDescriptor setMaxFragmentBufferBindCount:]( v2,  "setMaxFragmentBufferBindCount:",  *(unsigned __int8 *)(a1 + 12));
  if ((objc_opt_respondsToSelector(v2, "maxKernelBufferBindCount") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setMaxKernelBufferBindCount:]( v2,  "setMaxKernelBufferBindCount:",  *(unsigned __int8 *)(a1 + 13));
  }
  if ((objc_opt_respondsToSelector(v2, "maxKernelThreadgroupMemoryBindCount") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setMaxKernelThreadgroupMemoryBindCount:]( v2,  "setMaxKernelThreadgroupMemoryBindCount:",  *(unsigned __int8 *)(a1 + 14));
  }
  if ((objc_opt_respondsToSelector(v2, "supportRayTracing") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setSupportRayTracing:](v2, "setSupportRayTracing:", *(_BYTE *)(a1 + 20) != 0);
  }
  if ((objc_opt_respondsToSelector(v2, "maxObjectBufferBindCount") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setMaxObjectBufferBindCount:]( v2,  "setMaxObjectBufferBindCount:",  *(unsigned __int8 *)(a1 + 16));
  }
  if ((objc_opt_respondsToSelector(v2, "maxMeshBufferBindCount") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setMaxMeshBufferBindCount:]( v2,  "setMaxMeshBufferBindCount:",  *(unsigned __int8 *)(a1 + 15));
  }
  if ((objc_opt_respondsToSelector(v2, "maxObjectThreadgroupMemoryBindCount") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setMaxObjectThreadgroupMemoryBindCount:]( v2,  "setMaxObjectThreadgroupMemoryBindCount:",  *(unsigned __int8 *)(a1 + 17));
  }
  if ((objc_opt_respondsToSelector(v2, "supportDynamicAttributeStride") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setSupportDynamicAttributeStride:]( v2,  "setSupportDynamicAttributeStride:",  *(_BYTE *)(a1 + 19) != 0);
  }
  return v2;
}

id MakeMTLIndirectCommandBufferDescriptorWithResourceIndex(void *a1)
{
  MTLIndirectCommandBufferDescriptorWithoutResourceIndex = MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex((uint64_t)a1);
  double v3 = (void *)objc_claimAutoreleasedReturnValue(MTLIndirectCommandBufferDescriptorWithoutResourceIndex);
  [v3 setResourceIndex:*a1];
  return v3;
}

void TranslateGTMTLAttributeDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    *(_BYTE *)(a2 + 5) = [v5 format];
    *(_DWORD *)a2 = [v5 offset];
    unsigned __int8 v6 = [v5 bufferIndex];

    *(_BYTE *)(a2 + 4) = v6;
  }

id MakeMTLAttributeDescriptor(void *a1, unsigned int *a2)
{
  id v3 = a1;
  [v3 setFormat:*((unsigned __int8 *)a2 + 5)];
  [v3 setOffset:*a2];
  [v3 setBufferIndex:*((unsigned __int8 *)a2 + 4)];
  return v3;
}

void TranslateGTMTLBufferLayoutDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    *(void *)a2 = [v5 stride];
    *(_WORD *)(a2 + _Block_object_dispose(va, 8) = (unsigned __int16)[v5 stepRate];
    unsigned __int8 v6 = [v5 stepFunction];

    *(_BYTE *)(a2 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v6;
  }

id MakeMTLBufferLayoutDescriptor(void *a1, uint64_t a2)
{
  id v3 = a1;
  [v3 setStride:*(void *)a2];
  [v3 setStepRate:*(unsigned __int16 *)(a2 + 8)];
  [v3 setStepFunction:*(unsigned __int8 *)(a2 + 10)];
  return v3;
}

void TranslateGTMTLStageInputOutputDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = a2;
  id v17 = a1;
  do
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v17 layouts]);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectAtIndexedSubscript:v6]);
    TranslateGTMTLBufferLayoutDescriptor(v9, v7, v10, a4);

    ++v6;
    v7 += 16LL;
  }

  while (v6 != 31);
  uint64_t v11 = 0LL;
  uint64_t v12 = a2 + 496;
  do
  {
    size_t v13 = (void *)objc_claimAutoreleasedReturnValue([v17 attributes]);
    size_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectAtIndexedSubscript:v11]);
    TranslateGTMTLAttributeDescriptor(v14, v12, v15, a4);

    int v16 = v17;
    ++v11;
    v12 += 8LL;
  }

  while (v11 != 31);
  if ((a4 & 1) != 0)
  {
    *(_BYTE *)(a2 + 745) = [v17 indexType];
    *(_BYTE *)(a2 + 744) = [v17 indexBufferIndex];
    int v16 = v17;
  }
}

id MakeMTLStageInputOutputDescriptor(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = 0LL;
  uint64_t v5 = a2;
  do
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 layouts]);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:v4]);

    ++v4;
    v5 += 16LL;
  }

  while (v4 != 31);
  uint64_t v8 = 0LL;
  id v9 = (unsigned int *)(a2 + 496);
  do
  {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v3 attributes]);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectAtIndexedSubscript:v8]);

    ++v8;
    v9 += 2;
  }

  while (v8 != 31);
  [v3 setIndexType:*(unsigned __int8 *)(a2 + 745)];
  [v3 setIndexBufferIndex:*(unsigned __int8 *)(a2 + 744)];
  return v3;
}

void TranslateGTMTLComputePipelineDescriptorAuto(void *a1, void *a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = a2[21];
  a2[21] = v6 + 960;
  if (a3) {
    memcpy((void *)v6, &GTMTLComputePipelineDescriptorDefaults, 0x3C0uLL);
  }
  id v40 = v5;
  id v7 = objc_claimAutoreleasedReturnValue([v40 label]);
  uint64_t v8 = (const char *)[v7 UTF8String];
  id v9 = v8;
  if (v8)
  {
    size_t v10 = strlen(v8);
    uint64_t v11 = a2 + 52;
    uint64_t v12 = a2[52];
    size_t v13 = v10 + 1;
    if (v10 != -1LL)
    {
      size_t v14 = (void *)a2[52];
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t v11 = a2 + 52;
    uint64_t v12 = a2[52];
  }

  size_t v13 = 0LL;
  size_t v14 = 0LL;
LABEL_8:
  *uint64_t v11 = v12 + v13;
  if (a3) {
    memcpy(v14, v9, v13);
  }

  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v40 stageInputDescriptor]);
  TranslateGTMTLStageInputOutputDescriptor(v15, v6, v16, a3);

  for (uint64_t i = 0LL; i != 31; ++i)
  {
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v40 buffers]);
    id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 objectAtIndexedSubscript:i]);
    id v20 = v19;
    if (a3) {
      *(_BYTE *)(v6 + 920 + i) = [v19 mutability];
    }
  }

  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v40 functionPointers]);
  uint64_t v22 = TranslateNSArray(v21, (uint64_t)a2, a3);

  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v40 pluginData]);
  id v24 = GTMTLDescriptorAllocator_copyDictionary((uint64_t)a2, v23, a3);
  uint64_t v26 = v25;

  int64x2_t v27 = (void *)objc_claimAutoreleasedReturnValue([v40 driverCompilerOptions]);
  uint64_t v28 = GTMTLDescriptorAllocator_copyDictionary((uint64_t)a2, v27, a3);
  uint64_t v30 = v29;

  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v40 linkedFunctions]);
  TranslateGTMTLLinkedFunctions(v31, (uint64_t *)(v6 + 752), a2, a3);

  uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v40 preloadedLibraries]);
  uint64_t v33 = TranslateNSArray(v32, (uint64_t)a2, a3);

  if ((a3 & 1) != 0)
  {
    id v34 = (void *)objc_claimAutoreleasedReturnValue([v40 computeFunction]);
    *(void *)(v6 + 84_Block_object_dispose(va, 8) = [v34 streamReference];

    *(_BYTE *)(v6 + 95_Block_object_dispose(va, 8) = [v40 threadGroupSizeIsMultipleOfThreadExecutionWidth];
    *(void *)(v6 + 872) = v14;
    if ((objc_opt_respondsToSelector(v40, "supportIndirectCommandBuffers") & 1) != 0) {
      *(_BYTE *)(v6 + 956) = [v40 supportIndirectCommandBuffers];
    }
    *(_WORD *)(v6 + 91_Block_object_dispose(va, 8) = (unsigned __int16)[v40 maxTotalThreadsPerThreadgroup];
    if ((objc_opt_respondsToSelector(v40, "pipelineLibrary") & 1) != 0)
    {
      id v35 = (void *)objc_claimAutoreleasedReturnValue([v40 pipelineLibrary]);
      *(void *)(v6 + 88mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v35 streamReference];
    }

    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v40 functionPointers]);
    *(void *)(v6 + 864) = [v36 count];

    if (*(void *)(v6 + 864)) {
      uint64_t v37 = v22;
    }
    else {
      uint64_t v37 = 0LL;
    }
    *(void *)(v6 + 856) = v37;
    if ((objc_opt_respondsToSelector(v40, "resourceIndex") & 1) != 0) {
      *(void *)(v6 + 904) = [v40 resourceIndex];
    }
    if ((objc_opt_respondsToSelector(v40, "textureWriteRoundingMode") & 1) != 0) {
      *(_BYTE *)(v6 + 957) = [v40 textureWriteRoundingMode];
    }
    if ((objc_opt_respondsToSelector(v40, "openGLModeEnabled") & 1) != 0) {
      *(_BYTE *)(v6 + 954) = [v40 openGLModeEnabled];
    }
    if ((objc_opt_respondsToSelector(v40, "openCLModeEnabled") & 1) != 0) {
      *(_BYTE *)(v6 + 953) = [v40 openCLModeEnabled];
    }
    if ((objc_opt_respondsToSelector(v40, "needsCustomBorderColorSamplers") & 1) != 0) {
      *(_BYTE *)(v6 + 952) = [v40 needsCustomBorderColorSamplers];
    }
    *(void *)(v6 + 832) = v24;
    *(void *)(v6 + 84mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v26;
    *(void *)(v6 + 816) = v28;
    *(void *)(v6 + 824) = v30;
    if ((objc_opt_respondsToSelector(v40, "maxCallStackDepth") & 1) != 0) {
      *(_WORD *)(v6 + 916) = (unsigned __int16)[v40 maxCallStackDepth];
    }
    if ((objc_opt_respondsToSelector(v40, "supportAddingBinaryFunctions") & 1) != 0) {
      *(_BYTE *)(v6 + 955) = [v40 supportAddingBinaryFunctions];
    }
    double v38 = (void *)objc_claimAutoreleasedReturnValue([v40 preloadedLibraries]);
    *(void *)(v6 + 896) = [v38 count];

    if (*(void *)(v6 + 896)) {
      uint64_t v39 = v33;
    }
    else {
      uint64_t v39 = 0LL;
    }
    *(void *)(v6 + 88_Block_object_dispose(va, 8) = v39;
    if ((objc_opt_respondsToSelector(v40, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
      *(_WORD *)(v6 + 914) = (unsigned __int16)[v40 maxAccelerationStructureTraversalDepth];
    }
  }
}

MTLComputePipelineDescriptor *MakeMTLComputePipelineDescriptorWithoutResourceIndex(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLComputePipelineDescriptor);
  id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 848)));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v5]);
  -[MTLComputePipelineDescriptor setComputeFunction:](v4, "setComputeFunction:", v6);

  -[MTLComputePipelineDescriptor setThreadGroupSizeIsMultipleOfThreadExecutionWidth:]( v4,  "setThreadGroupSizeIsMultipleOfThreadExecutionWidth:",  *(_BYTE *)(a1 + 958) != 0);
  if (*(void *)(a1 + 872))
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLComputePipelineDescriptor setLabel:](v4, "setLabel:", v7);
  }

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(-[MTLComputePipelineDescriptor stageInputDescriptor](v4, "stageInputDescriptor"));

  for (uint64_t i = 0LL; i != 31; ++i)
  {
    size_t v10 = (void *)objc_claimAutoreleasedReturnValue(-[MTLComputePipelineDescriptor buffers](v4, "buffers"));
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectAtIndexedSubscript:i]);
    [v11 setMutability:*(unsigned __int8 *)(a1 + 920 + i)];
  }

  if ((objc_opt_respondsToSelector(v4, "supportIndirectCommandBuffers") & 1) != 0) {
    -[MTLComputePipelineDescriptor setSupportIndirectCommandBuffers:]( v4,  "setSupportIndirectCommandBuffers:",  *(_BYTE *)(a1 + 956) != 0);
  }
  -[MTLComputePipelineDescriptor setMaxTotalThreadsPerThreadgroup:]( v4,  "setMaxTotalThreadsPerThreadgroup:",  *(unsigned __int16 *)(a1 + 918));
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 880)));
  size_t v13 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v12]);
  -[MTLComputePipelineDescriptor setPipelineLibrary:](v4, "setPipelineLibrary:", v13);

  uint64_t v14 = *(void *)(a1 + 864);
  if (v14)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 856), v14, v3);
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLComputePipelineDescriptor setFunctionPointers:](v4, "setFunctionPointers:", v16);
  }

  if ((objc_opt_respondsToSelector(v4, "textureWriteRoundingMode") & 1) != 0) {
    -[MTLComputePipelineDescriptor setTextureWriteRoundingMode:]( v4,  "setTextureWriteRoundingMode:",  *(unsigned __int8 *)(a1 + 957));
  }
  if ((objc_opt_respondsToSelector(v4, "openGLModeEnabled") & 1) != 0) {
    -[MTLComputePipelineDescriptor setOpenGLModeEnabled:](v4, "setOpenGLModeEnabled:", *(_BYTE *)(a1 + 954) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "openCLModeEnabled") & 1) != 0) {
    -[MTLComputePipelineDescriptor setOpenCLModeEnabled:](v4, "setOpenCLModeEnabled:", *(_BYTE *)(a1 + 953) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "needsCustomBorderColorSamplers") & 1) != 0) {
    -[MTLComputePipelineDescriptor setNeedsCustomBorderColorSamplers:]( v4,  "setNeedsCustomBorderColorSamplers:",  *(_BYTE *)(a1 + 952) != 0);
  }
  id Dictionary = GTData_MakeDictionary(*(void *)(a1 + 832), *(void *)(a1 + 840));
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(Dictionary);
  -[MTLComputePipelineDescriptor setPluginData:](v4, "setPluginData:", v18);

  id v19 = GTData_MakeDictionary(*(void *)(a1 + 816), *(void *)(a1 + 824));
  id v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  -[MTLComputePipelineDescriptor setDriverCompilerOptions:](v4, "setDriverCompilerOptions:", v20);

  if ((objc_opt_respondsToSelector(v4, "maxCallStackDepth") & 1) != 0) {
    -[MTLComputePipelineDescriptor setMaxCallStackDepth:](v4, "setMaxCallStackDepth:", *(unsigned __int16 *)(a1 + 916));
  }
  if ((objc_opt_respondsToSelector(v4, "supportAddingBinaryFunctions") & 1) != 0) {
    -[MTLComputePipelineDescriptor setSupportAddingBinaryFunctions:]( v4,  "setSupportAddingBinaryFunctions:",  *(_BYTE *)(a1 + 955) != 0);
  }
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(-[MTLComputePipelineDescriptor linkedFunctions](v4, "linkedFunctions"));
  MakeMTLLinkedFunctions(v21, (void *)(a1 + 752), v3);

  uint64_t v22 = *(void *)(a1 + 896);
  if (v22)
  {
    id v23 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 888), v22, v3);
    id v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
    -[MTLComputePipelineDescriptor setPreloadedLibraries:](v4, "setPreloadedLibraries:", v24);
  }

  if ((objc_opt_respondsToSelector(v4, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
    -[MTLComputePipelineDescriptor setMaxAccelerationStructureTraversalDepth:]( v4,  "setMaxAccelerationStructureTraversalDepth:",  *(unsigned __int16 *)(a1 + 914));
  }

  return v4;
}

id MakeMTLComputePipelineDescriptorWithResourceIndex(uint64_t a1, void *a2)
{
  MTLComputePipelineDescriptorWithoutResourceIndex = MakeMTLComputePipelineDescriptorWithoutResourceIndex(a1, a2);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(MTLComputePipelineDescriptorWithoutResourceIndex);
  id v5 = v4;
  if (*(_BYTE *)(a1 + 956)) {
    [v4 setResourceIndex:*(void *)(a1 + 904)];
  }
  return v5;
}

id TranslateGTMTLTileRenderPipelineColorAttachmentDescriptor(id result, _WORD *a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id result = [result pixelFormat];
    *a2 = (_WORD)result;
  }

  return result;
}

id MakeMTLTileRenderPipelineColorAttachmentDescriptor(void *a1, unsigned __int16 *a2)
{
  id v3 = a1;
  [v3 setPixelFormat:*a2];
  return v3;
}

void TranslateGTMTLTileRenderPipelineDescriptor(void *a1, void *a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = a2[20];
  a2[20] = v6 + 176;
  if (a3)
  {
    *(_OWORD *)(v6 + 12_Block_object_dispose(va, 8) = xmmword_1C80F8;
    *(_OWORD *)(v6 + 144) = unk_1C8108;
    *(_OWORD *)(v6 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = xmmword_1C8118;
    *(_OWORD *)(v6 + 64) = xmmword_1C80B8;
    *(_OWORD *)(v6 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = unk_1C80C8;
    *(_OWORD *)(v6 + 96) = xmmword_1C80D8;
    *(_OWORD *)(v6 + 112) = unk_1C80E8;
    *(_OWORD *)uint64_t v6 = GTMTLTileRenderPipelineDescriptorDefaults;
    *(_OWORD *)(v6 + 16) = unk_1C8088;
    *(_OWORD *)(v6 + 32) = xmmword_1C8098;
    *(_OWORD *)(v6 + 4_Block_object_dispose(va, 8) = unk_1C80A8;
  }

  id v34 = v5;
  id v7 = objc_claimAutoreleasedReturnValue([v34 label]);
  uint64_t v8 = (const char *)[v7 UTF8String];
  id v9 = v8;
  if (v8)
  {
    size_t v10 = strlen(v8);
    uint64_t v11 = a2 + 52;
    uint64_t v12 = a2[52];
    size_t v13 = v10 + 1;
    if (v10 != -1LL)
    {
      uint64_t v14 = (void *)a2[52];
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t v11 = a2 + 52;
    uint64_t v12 = a2[52];
  }

  size_t v13 = 0LL;
  uint64_t v14 = 0LL;
LABEL_8:
  *uint64_t v11 = v12 + v13;
  if (a3) {
    memcpy(v14, v9, v13);
  }

  for (uint64_t i = 0LL; i != 8; ++i)
  {
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v34 colorAttachments]);
    id v17 = (void *)objc_claimAutoreleasedReturnValue([v16 objectAtIndexedSubscript:i]);
    uint64_t v18 = v17;
    if (a3) {
      *(_WORD *)(v6 + 2 * i + 64) = (unsigned __int16)[v17 pixelFormat];
    }
  }

  uint64_t v19 = 0LL;
  id v20 = v34;
  do
  {
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 tileBuffers]);
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v21 objectAtIndexedSubscript:v19]);
    id v23 = v22;
    if (a3) {
      *(_BYTE *)(v6 + v19 + 136) = [v22 mutability];
    }

    ++v19;
    id v20 = v34;
  }

  while (v19 != 31);
  id v24 = (void *)objc_claimAutoreleasedReturnValue([v34 pluginData]);
  uint64_t v25 = GTMTLDescriptorAllocator_copyDictionary((uint64_t)a2, v24, a3);
  uint64_t v27 = v26;

  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v34 preloadedLibraries]);
  uint64_t v29 = TranslateNSArray(v28, (uint64_t)a2, a3);

  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v34 linkedFunctions]);
  TranslateGTMTLLinkedFunctions(v30, (uint64_t *)v6, a2, a3);

  if ((a3 & 1) != 0)
  {
    *(void *)(v6 + 96) = v14;
    uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v34 tileFunction]);
    *(void *)(v6 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v31 streamReference];

    *(_WORD *)(v6 + 134) = (unsigned __int16)[v34 rasterSampleCount];
    *(_BYTE *)(v6 + 169) = [v34 threadgroupSizeMatchesTileSize];
    *(void *)(v6 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v25;
    *(void *)(v6 + 8_Block_object_dispose(va, 8) = v27;
    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v34 preloadedLibraries]);
    *(void *)(v6 + 112) = [v32 count];

    if (*(void *)(v6 + 112)) {
      uint64_t v33 = v29;
    }
    else {
      uint64_t v33 = 0LL;
    }
    *(void *)(v6 + 104) = v33;
    if ((objc_opt_respondsToSelector(v34, "supportAddingBinaryFunctions") & 1) != 0) {
      *(_BYTE *)(v6 + 16_Block_object_dispose(va, 8) = [v34 supportAddingBinaryFunctions];
    }
    if ((objc_opt_respondsToSelector(v34, "maxCallStackDepth") & 1) != 0) {
      *(_WORD *)(v6 + 13mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = (unsigned __int16)[v34 maxCallStackDepth];
    }
    if ((objc_opt_respondsToSelector(v34, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
      *(_WORD *)(v6 + 12_Block_object_dispose(va, 8) = (unsigned __int16)[v34 maxAccelerationStructureTraversalDepth];
    }
    if ((objc_opt_respondsToSelector(v34, "maxTotalThreadsPerThreadgroup") & 1) != 0) {
      *(_WORD *)(v6 + 132) = (unsigned __int16)[v34 maxTotalThreadsPerThreadgroup];
    }
    if ((objc_opt_respondsToSelector(v34, "colorSampleCount") & 1) != 0) {
      *(_BYTE *)(v6 + 167) = [v34 colorSampleCount];
    }
  }
}

MTLTileRenderPipelineDescriptor *MakeMTLTileRenderPipelineDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLTileRenderPipelineDescriptor);
  if (*(void *)(a1 + 96))
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLTileRenderPipelineDescriptor setLabel:](v4, "setLabel:", v5);
  }

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 120)));
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v6]);
  -[MTLTileRenderPipelineDescriptor setTileFunction:](v4, "setTileFunction:", v7);

  -[MTLTileRenderPipelineDescriptor setRasterSampleCount:](v4, "setRasterSampleCount:", *(unsigned __int16 *)(a1 + 134));
  for (uint64_t i = 0LL; i != 8; ++i)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue(-[MTLTileRenderPipelineDescriptor colorAttachments](v4, "colorAttachments"));
    size_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 objectAtIndexedSubscript:i]);
    [v10 setPixelFormat:*(unsigned __int16 *)(a1 + 2 * i + 64)];
  }

  -[MTLTileRenderPipelineDescriptor setThreadgroupSizeMatchesTileSize:]( v4,  "setThreadgroupSizeMatchesTileSize:",  *(_BYTE *)(a1 + 169) != 0);
  for (uint64_t j = 0LL; j != 31; ++j)
  {
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(-[MTLTileRenderPipelineDescriptor tileBuffers](v4, "tileBuffers"));
    size_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:j]);
    [v13 setMutability:*(unsigned __int8 *)(a1 + j + 136)];
  }

  id Dictionary = GTData_MakeDictionary(*(void *)(a1 + 80), *(void *)(a1 + 88));
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(Dictionary);
  -[MTLTileRenderPipelineDescriptor setPluginData:](v4, "setPluginData:", v15);

  uint64_t v16 = *(void *)(a1 + 112);
  if (v16)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 104), v16, v3);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLTileRenderPipelineDescriptor setPreloadedLibraries:](v4, "setPreloadedLibraries:", v18);
  }

  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(-[MTLTileRenderPipelineDescriptor linkedFunctions](v4, "linkedFunctions"));
  MakeMTLLinkedFunctions(v19, (void *)a1, v3);

  if ((objc_opt_respondsToSelector(v4, "supportAddingBinaryFunctions") & 1) != 0) {
    -[MTLTileRenderPipelineDescriptor setSupportAddingBinaryFunctions:]( v4,  "setSupportAddingBinaryFunctions:",  *(_BYTE *)(a1 + 168) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "maxCallStackDepth") & 1) != 0) {
    -[MTLTileRenderPipelineDescriptor setMaxCallStackDepth:]( v4,  "setMaxCallStackDepth:",  *(unsigned __int16 *)(a1 + 130));
  }
  if ((objc_opt_respondsToSelector(v4, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
    -[MTLTileRenderPipelineDescriptor setMaxAccelerationStructureTraversalDepth:]( v4,  "setMaxAccelerationStructureTraversalDepth:",  *(unsigned __int16 *)(a1 + 128));
  }
  if ((objc_opt_respondsToSelector(v4, "maxTotalThreadsPerThreadgroup") & 1) != 0) {
    -[MTLTileRenderPipelineDescriptor setMaxTotalThreadsPerThreadgroup:]( v4,  "setMaxTotalThreadsPerThreadgroup:",  *(unsigned __int16 *)(a1 + 132));
  }
  if ((objc_opt_respondsToSelector(v4, "colorSampleCount") & 1) != 0) {
    -[MTLTileRenderPipelineDescriptor setColorSampleCount:](v4, "setColorSampleCount:", *(unsigned __int8 *)(a1 + 167));
  }

  return v4;
}

void TranslateGTMTLCommandQueueDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 144);
  *(void *)(a2 + 144) = v6 + 16;
  id v9 = v5;
  if (a3)
  {
    *(_OWORD *)uint64_t v6 = GTMTLCommandQueueDescriptorDefaults;
    id v7 = v5;
    *(_DWORD *)uint64_t v6 = [v7 maxCommandBufferCount];
    if ((objc_opt_respondsToSelector(v7, "qosLevel") & 1) != 0) {
      *(_BYTE *)(v6 + _Block_object_dispose(va, 8) = [v7 qosLevel];
    }
    if ((objc_opt_respondsToSelector(v7, "commitSynchronously") & 1) != 0) {
      *(_BYTE *)(v6 + 4) = [v7 commitSynchronously];
    }
    if ((objc_opt_respondsToSelector(v7, "isOpenGLQueue") & 1) != 0) {
      *(_BYTE *)(v6 + 7) = [v7 isOpenGLQueue];
    }
    if ((objc_opt_respondsToSelector(v7, "disableCrossQueueHazardTracking") & 1) != 0) {
      *(_BYTE *)(v6 + 6) = [v7 disableCrossQueueHazardTracking];
    }
    if ((objc_opt_respondsToSelector(v7, "commitsWithQoS") & 1) != 0) {
      *(_BYTE *)(v6 + 5) = [v7 commitsWithQoS];
    }
  }

  else
  {
    id v8 = v5;
  }
}

MTLCommandQueueDescriptor *MakeMTLCommandQueueDescriptor(unsigned int *a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLCommandQueueDescriptor);
  -[MTLCommandQueueDescriptor setMaxCommandBufferCount:](v2, "setMaxCommandBufferCount:", *a1);
  if ((objc_opt_respondsToSelector(v2, "qosLevel") & 1) != 0) {
    -[MTLCommandQueueDescriptor setQosLevel:](v2, "setQosLevel:", *((unsigned __int8 *)a1 + 8));
  }
  if ((objc_opt_respondsToSelector(v2, "commitSynchronously") & 1) != 0) {
    -[MTLCommandQueueDescriptor setCommitSynchronously:](v2, "setCommitSynchronously:", *((_BYTE *)a1 + 4) != 0);
  }
  if ((objc_opt_respondsToSelector(v2, "isOpenGLQueue") & 1) != 0) {
    -[MTLCommandQueueDescriptor setIsOpenGLQueue:](v2, "setIsOpenGLQueue:", *((_BYTE *)a1 + 7) != 0);
  }
  if ((objc_opt_respondsToSelector(v2, "disableCrossQueueHazardTracking") & 1) != 0) {
    -[MTLCommandQueueDescriptor setDisableCrossQueueHazardTracking:]( v2,  "setDisableCrossQueueHazardTracking:",  *((_BYTE *)a1 + 6) != 0);
  }
  if ((objc_opt_respondsToSelector(v2, "commitsWithQoS") & 1) != 0) {
    -[MTLCommandQueueDescriptor setCommitsWithQoS:](v2, "setCommitsWithQoS:", *((_BYTE *)a1 + 5) != 0);
  }
  return v2;
}

void TranslateGTMTLIOCommandQueueDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 136);
  *(void *)(a2 + 136) = v6 + 8;
  if (a3)
  {
    *(void *)uint64_t v6 = 64LL;
    id v7 = v5;
    *(_DWORD *)uint64_t v6 = [v5 maxCommandBufferCount];
    *(_BYTE *)(v6 + 4) = [v7 priority];
    *(_BYTE *)(v6 + 5) = [v7 type];
    id v5 = v7;
  }
}

MTLIOCommandQueueDescriptor *MakeMTLIOCommandQueueDescriptor(unsigned int *a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLIOCommandQueueDescriptor);
  -[MTLIOCommandQueueDescriptor setMaxCommandBufferCount:](v2, "setMaxCommandBufferCount:", *a1);
  -[MTLIOCommandQueueDescriptor setPriority:](v2, "setPriority:", *((unsigned __int8 *)a1 + 4));
  -[MTLIOCommandQueueDescriptor setType:](v2, "setType:", *((unsigned __int8 *)a1 + 5));
  return v2;
}

void TranslateGTMTLCommandBufferDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a2 + 128);
  *(void *)(a2 + 12_Block_object_dispose(va, 8) = v7 + 16;
  if (a3)
  {
    *(_OWORD *)uint64_t v7 = GTMTLCommandBufferDescriptorDefaults;
    size_t v10 = v5;
    *(_BYTE *)(v7 + _Block_object_dispose(va, 8) = [v5 errorOptions];
    *(_BYTE *)(v7 + 9) = [v10 retainedReferences];
    char v8 = objc_opt_respondsToSelector(v10, "deadlineProfile");
    uint64_t v6 = v10;
    if ((v8 & 1) != 0)
    {
      id v9 = (void *)objc_claimAutoreleasedReturnValue([v10 deadlineProfile]);
      *(void *)uint64_t v7 = [v9 streamReference];

      uint64_t v6 = v10;
    }
  }
}

void TranslateGTMTLVisibleFunctionTableDescriptor(void *a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a2 + 112);
  *(void *)(a2 + 112) = v3 + 24;
  if (a3)
  {
    id v4 = a1;
    *(void *)uint64_t v3 = [v4 functionCount];
    *(void *)(v3 + _Block_object_dispose(va, 8) = [v4 resourceIndex];
    unsigned __int8 v5 = [v4 forceResourceIndex];

    *(_BYTE *)(v3 + 16) = v5;
  }

MTLVisibleFunctionTableDescriptor *MakeMTLVisibleFunctionTableDescriptorWithoutResourceIndex(void *a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLVisibleFunctionTableDescriptor);
  -[MTLVisibleFunctionTableDescriptor setFunctionCount:](v2, "setFunctionCount:", *a1);
  return v2;
}

MTLVisibleFunctionTableDescriptor *MakeMTLVisibleFunctionTableDescriptorWithResourceIndex(void *a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLVisibleFunctionTableDescriptor);
  -[MTLVisibleFunctionTableDescriptor setFunctionCount:](v2, "setFunctionCount:", *a1);
  -[MTLVisibleFunctionTableDescriptor setForceResourceIndex:](v2, "setForceResourceIndex:", a1[1] != 0LL);
  -[MTLVisibleFunctionTableDescriptor setResourceIndex:](v2, "setResourceIndex:", a1[1]);
  return v2;
}

void TranslateGTMTLCompileOptions(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 88);
  *(void *)(a2 + 8_Block_object_dispose(va, 8) = v6 + 64;
  if (a3)
  {
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
  }

  id v31 = v5;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v31 preprocessorMacros]);
  char v8 = GTMTLDescriptorAllocator_copyDictionary(a2, v7, a3);
  uint64_t v10 = v9;

  id v11 = objc_claimAutoreleasedReturnValue([v31 additionalCompilerArguments]);
  uint64_t v12 = (const char *)[v11 UTF8String];
  size_t v13 = v12;
  if (v12)
  {
    size_t v14 = strlen(v12);
    uint64_t v15 = (void *)(a2 + 416);
    uint64_t v16 = *(void *)(a2 + 416);
    size_t v17 = v14 + 1;
    if (v14 != -1LL)
    {
      uint64_t v18 = *(void **)(a2 + 416);
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t v15 = (void *)(a2 + 416);
    uint64_t v16 = *(void *)(a2 + 416);
  }

  size_t v17 = 0LL;
  uint64_t v18 = 0LL;
LABEL_8:
  *uint64_t v15 = v16 + v17;
  if (a3) {
    memcpy(v18, v13, v17);
  }

  id v19 = objc_claimAutoreleasedReturnValue([v31 installName]);
  id v20 = (const char *)[v19 UTF8String];
  uint64_t v21 = v20;
  if (v20)
  {
    size_t v22 = strlen(v20);
    id v23 = (void *)(a2 + 416);
    uint64_t v24 = *(void *)(a2 + 416);
    size_t v25 = v22 + 1;
    if (v22 != -1LL)
    {
      uint64_t v26 = *(void **)(a2 + 416);
      goto LABEL_15;
    }
  }

  else
  {
    id v23 = (void *)(a2 + 416);
    uint64_t v24 = *(void *)(a2 + 416);
  }

  size_t v25 = 0LL;
  uint64_t v26 = 0LL;
LABEL_15:
  *id v23 = v24 + v25;
  if (a3) {
    memcpy(v26, v21, v25);
  }

  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v31 libraries]);
  uint64_t v28 = TranslateNSArray(v27, a2, a3);

  if (a3)
  {
    *(void *)uint64_t v6 = v8;
    *(void *)(v6 + _Block_object_dispose(va, 8) = v10;
    if ((objc_opt_respondsToSelector(v31, "fastMathEnabled") & 1) != 0) {
      *(_BYTE *)(v6 + 57) = [v31 fastMathEnabled];
    }
    *(_BYTE *)(v6 + 56) = [v31 debuggingEnabled];
    *(_DWORD *)(v6 + 4_Block_object_dispose(va, 8) = [v31 languageVersion];
    *(void *)(v6 + 16) = v18;
    if ((objc_opt_respondsToSelector(v31, "preserveInvariance") & 1) != 0) {
      *(_BYTE *)(v6 + 62) = [v31 preserveInvariance];
    }
    *(void *)(v6 + 24) = v26;
    if ((objc_opt_respondsToSelector(v31, "libraryType") & 1) != 0) {
      *(_BYTE *)(v6 + 5_Block_object_dispose(va, 8) = [v31 libraryType];
    }
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v31 libraries]);
    *(void *)(v6 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v29 count];

    if (*(void *)(v6 + 40)) {
      uint64_t v30 = v28;
    }
    else {
      uint64_t v30 = 0LL;
    }
    *(void *)(v6 + 32) = v30;
    if ((objc_opt_respondsToSelector(v31, "sourceLanguage") & 1) != 0) {
      *(_BYTE *)(v6 + 63) = [v31 sourceLanguage];
    }
    if ((objc_opt_respondsToSelector(v31, "optimizationLevel") & 1) != 0) {
      *(_BYTE *)(v6 + 61) = [v31 optimizationLevel];
    }
    if ((objc_opt_respondsToSelector(v31, "compileSymbolVisibility") & 1) != 0) {
      *(_BYTE *)(v6 + 55) = [v31 compileSymbolVisibility];
    }
    if ((objc_opt_respondsToSelector(v31, "allowReferencingUndefinedSymbols") & 1) != 0) {
      *(_BYTE *)(v6 + 54) = [v31 allowReferencingUndefinedSymbols];
    }
    if ((objc_opt_respondsToSelector(v31, "maxTotalThreadsPerThreadgroup") & 1) != 0) {
      *(_WORD *)(v6 + 52) = (unsigned __int16)[v31 maxTotalThreadsPerThreadgroup];
    }
    if ((objc_opt_respondsToSelector(v31, "mathMode") & 1) != 0) {
      *(_BYTE *)(v6 + 6mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v31 mathMode];
    }
  }
}

MTLCompileOptions *MakeMTLCompileOptionsAuto(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLCompileOptions);
  id Dictionary = GTData_MakeDictionary(*(void *)a1, *(void *)(a1 + 8));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(Dictionary);
  -[MTLCompileOptions setPreprocessorMacros:](v4, "setPreprocessorMacros:", v6);

  -[MTLCompileOptions setDebuggingEnabled:](v4, "setDebuggingEnabled:", *(_BYTE *)(a1 + 56) != 0);
  -[MTLCompileOptions setLanguageVersion:](v4, "setLanguageVersion:", *(unsigned int *)(a1 + 48));
  if (*(void *)(a1 + 16))
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLCompileOptions setAdditionalCompilerArguments:](v4, "setAdditionalCompilerArguments:", v7);
  }

  if ((objc_opt_respondsToSelector(v4, "preserveInvariance") & 1) != 0) {
    -[MTLCompileOptions setPreserveInvariance:](v4, "setPreserveInvariance:", *(_BYTE *)(a1 + 62) != 0);
  }
  if (*(void *)(a1 + 24))
  {
    char v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLCompileOptions setInstallName:](v4, "setInstallName:", v8);
  }

  if ((objc_opt_respondsToSelector(v4, "libraryType") & 1) != 0) {
    -[MTLCompileOptions setLibraryType:](v4, "setLibraryType:", *(unsigned __int8 *)(a1 + 58));
  }
  uint64_t v9 = *(void *)(a1 + 40);
  if (v9)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 32), v9, v3);
    id v11 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLCompileOptions setLibraries:](v4, "setLibraries:", v11);
  }

  if ((objc_opt_respondsToSelector(v4, "sourceLanguage") & 1) != 0) {
    -[MTLCompileOptions setSourceLanguage:](v4, "setSourceLanguage:", *(unsigned __int8 *)(a1 + 63));
  }
  if ((objc_opt_respondsToSelector(v4, "optimizationLevel") & 1) != 0) {
    -[MTLCompileOptions setOptimizationLevel:](v4, "setOptimizationLevel:", *(unsigned __int8 *)(a1 + 61));
  }
  if ((objc_opt_respondsToSelector(v4, "compileSymbolVisibility") & 1) != 0) {
    -[MTLCompileOptions setCompileSymbolVisibility:](v4, "setCompileSymbolVisibility:", *(unsigned __int8 *)(a1 + 55));
  }
  if ((objc_opt_respondsToSelector(v4, "allowReferencingUndefinedSymbols") & 1) != 0) {
    -[MTLCompileOptions setAllowReferencingUndefinedSymbols:]( v4,  "setAllowReferencingUndefinedSymbols:",  *(_BYTE *)(a1 + 54) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "maxTotalThreadsPerThreadgroup") & 1) != 0) {
    -[MTLCompileOptions setMaxTotalThreadsPerThreadgroup:]( v4,  "setMaxTotalThreadsPerThreadgroup:",  *(unsigned __int16 *)(a1 + 52));
  }
  if ((objc_opt_respondsToSelector(v4, "mathFloatingPointFunctions") & 1) != 0) {
    -[MTLCompileOptions setMathFloatingPointFunctions:]( v4,  "setMathFloatingPointFunctions:",  *(unsigned __int8 *)(a1 + 59));
  }
  if ((objc_opt_respondsToSelector(v4, "mathMode") & 1) != 0) {
    -[MTLCompileOptions setMathMode:](v4, "setMathMode:", *(unsigned __int8 *)(a1 + 60));
  }

  return v4;
}

void TranslateGTMTLCaptureDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v6 + 24;
  if (a3)
  {
    *(_OWORD *)uint64_t v6 = GTMTLCaptureDescriptorDefaults;
    *(void *)(v6 + 16) = 1LL;
  }

  id v17 = v5;
  id v7 = objc_claimAutoreleasedReturnValue([v5 outputURL]);
  char v8 = (const char *)[v7 fileSystemRepresentation];
  uint64_t v9 = v8;
  if (v8)
  {
    size_t v10 = strlen(v8);
    id v11 = (void *)(a2 + 416);
    uint64_t v12 = *(void *)(a2 + 416);
    size_t v13 = v10 + 1;
    if (v10 != -1LL)
    {
      size_t v14 = *(void **)(a2 + 416);
      goto LABEL_8;
    }
  }

  else
  {
    id v11 = (void *)(a2 + 416);
    uint64_t v12 = *(void *)(a2 + 416);
  }

  size_t v13 = 0LL;
  size_t v14 = 0LL;
LABEL_8:
  *id v11 = v12 + v13;
  if ((a3 & 1) != 0)
  {
    memcpy(v14, v9, v13);

    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v17 captureObject]);
    *(void *)uint64_t v6 = [v15 streamReference];

    *(_BYTE *)(v6 + 16) = [v17 destination];
    uint64_t v16 = v17;
    *(void *)(v6 + _Block_object_dispose(va, 8) = v14;
  }

  else
  {

    uint64_t v16 = v17;
  }
}

void TranslateGTMTLBlitPassSampleBufferAttachmentDescriptor(void *a1, void *a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBuffer]);
    a2[1] = [v6 streamReference];

    a2[2] = [v5 startOfEncoderSampleIndex];
    id v7 = [v5 endOfEncoderSampleIndex];

    *a2 = v7;
  }

id MakeMTLBlitPassSampleBufferAttachmentDescriptor(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = a2[1];
  id v7 = a3;
  char v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v6));
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v8]);

  [v5 setSampleBuffer:v9];
  [v5 setStartOfEncoderSampleIndex:a2[2]];
  [v5 setEndOfEncoderSampleIndex:*a2];
  return v5;
}

void TranslateGTMTLBlitPassDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v6 + 96;
  if (a3)
  {
    *(_OWORD *)(v6 + 64) = 0u;
    *(_OWORD *)(v6 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
  }

  uint64_t v7 = 0LL;
  id v14 = v5;
  do
  {
    char v8 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBufferAttachments]);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectAtIndexedSubscript:v7]);
    size_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);

    if (v10)
    {
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v14 sampleBufferAttachments]);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:v7]);
      TranslateGTMTLBlitPassSampleBufferAttachmentDescriptor(v12, (void *)v6, v13, a3);
    }

    ++v7;
    v6 += 24LL;
    id v5 = v14;
  }

  while (v7 != 4);
}

MTLBlitPassDescriptor *MakeMTLBlitPassDescriptor(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLBlitPassDescriptor);
  for (uint64_t i = 0LL; i != 4; ++i)
  {
    if (a1[1])
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[MTLBlitPassDescriptor sampleBufferAttachments](v4, "sampleBufferAttachments"));
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:i]);
    }

    a1 += 3;
  }

  return v4;
}

void TranslateGTMTLComputePassSampleBufferAttachmentDescriptor(void *a1, void *a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBuffer]);
    a2[1] = [v6 streamReference];

    a2[2] = [v5 startOfEncoderSampleIndex];
    id v7 = [v5 endOfEncoderSampleIndex];

    *a2 = v7;
  }

id MakeMTLComputePassSampleBufferAttachmentDescriptor(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = a2[1];
  id v7 = a3;
  char v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v6));
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v8]);

  [v5 setSampleBuffer:v9];
  [v5 setStartOfEncoderSampleIndex:a2[2]];
  [v5 setEndOfEncoderSampleIndex:*a2];
  return v5;
}

void TranslateGTMTLComputePassDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v6 + 104;
  if (a3)
  {
    *(void *)(v6 + 96) = 0LL;
    *(_OWORD *)(v6 + 64) = 0u;
    *(_OWORD *)(v6 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
  }

  id v7 = v5;
  uint64_t v8 = 0LL;
  uint64_t v9 = (void *)v6;
  id v16 = v7;
  do
  {
    size_t v10 = (void *)objc_claimAutoreleasedReturnValue([v7 sampleBufferAttachments]);
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectAtIndexedSubscript:v8]);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 sampleBuffer]);

    if (v12)
    {
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v16 sampleBufferAttachments]);
      id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectAtIndexedSubscript:v8]);
      TranslateGTMTLComputePassSampleBufferAttachmentDescriptor(v14, v9, v15, a3);
    }

    ++v8;
    v9 += 3;
    id v7 = v16;
  }

  while (v8 != 4);
  if ((a3 & 1) != 0) {
    *(_BYTE *)(v6 + 96) = [v16 dispatchType];
  }
}

MTLComputePassDescriptor *MakeMTLComputePassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLComputePassDescriptor);
  -[MTLComputePassDescriptor setDispatchType:](v4, "setDispatchType:", *(unsigned __int8 *)(a1 + 96));
  for (uint64_t i = 0LL; i != 4; ++i)
  {
    if (*(void *)(a1 + 8))
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[MTLComputePassDescriptor sampleBufferAttachments](v4, "sampleBufferAttachments"));
      id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:i]);
    }

    a1 += 24LL;
  }

  return v4;
}

void TranslateGTMTLResourceStatePassSampleBufferAttachmentDescriptor( void *a1, void *a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBuffer]);
    a2[1] = [v6 streamReference];

    a2[2] = [v5 startOfEncoderSampleIndex];
    id v7 = [v5 endOfEncoderSampleIndex];

    *a2 = v7;
  }

id MakeMTLResourceStatePassSampleBufferAttachmentDescriptor(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = a2[1];
  id v7 = a3;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v6));
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v8]);

  [v5 setSampleBuffer:v9];
  [v5 setStartOfEncoderSampleIndex:a2[2]];
  [v5 setEndOfEncoderSampleIndex:*a2];
  return v5;
}

void TranslateGTMTLResourceStatePassDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 48);
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = v6 + 96;
  if (a3)
  {
    *(_OWORD *)(v6 + 64) = 0u;
    *(_OWORD *)(v6 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
  }

  uint64_t v7 = 0LL;
  id v14 = v5;
  do
  {
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBufferAttachments]);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectAtIndexedSubscript:v7]);
    size_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);

    if (v10)
    {
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v14 sampleBufferAttachments]);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:v7]);
      TranslateGTMTLResourceStatePassSampleBufferAttachmentDescriptor(v12, (void *)v6, v13, a3);
    }

    ++v7;
    v6 += 24LL;
    id v5 = v14;
  }

  while (v7 != 4);
}

MTLResourceStatePassDescriptor *MakeMTLResourceStatePassDescriptor(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLResourceStatePassDescriptor);
  for (uint64_t i = 0LL; i != 4; ++i)
  {
    if (a1[1])
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[MTLResourceStatePassDescriptor sampleBufferAttachments](v4, "sampleBufferAttachments"));
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:i]);
    }

    a1 += 3;
  }

  return v4;
}

void TranslateGTMTLAccelerationStructurePassSampleBufferAttachmentDescriptor( void *a1, void *a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v5 = a1;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBuffer]);
    a2[1] = [v6 streamReference];

    a2[2] = [v5 startOfEncoderSampleIndex];
    id v7 = [v5 endOfEncoderSampleIndex];

    *a2 = v7;
  }

id MakeMTLAccelerationStructurePassSampleBufferAttachmentDescriptor(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = a2[1];
  id v7 = a3;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v6));
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v8]);

  [v5 setSampleBuffer:v9];
  [v5 setStartOfEncoderSampleIndex:a2[2]];
  [v5 setEndOfEncoderSampleIndex:*a2];
  return v5;
}

void TranslateGTMTLAccelerationStructurePassDescriptor(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 40);
  *(void *)(a2 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v6 + 96;
  if (a3)
  {
    *(_OWORD *)(v6 + 64) = 0u;
    *(_OWORD *)(v6 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
  }

  uint64_t v7 = 0LL;
  id v14 = v5;
  do
  {
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBufferAttachments]);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectAtIndexedSubscript:v7]);
    size_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);

    if (v10)
    {
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v14 sampleBufferAttachments]);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:v7]);
      TranslateGTMTLAccelerationStructurePassSampleBufferAttachmentDescriptor(v12, (void *)v6, v13, a3);
    }

    ++v7;
    v6 += 24LL;
    id v5 = v14;
  }

  while (v7 != 4);
}

MTLAccelerationStructurePassDescriptor *MakeMTLAccelerationStructurePassDescriptor(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructurePassDescriptor);
  for (uint64_t i = 0LL; i != 4; ++i)
  {
    if (a1[1])
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[MTLAccelerationStructurePassDescriptor sampleBufferAttachments](v4, "sampleBufferAttachments"));
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:i]);
    }

    a1 += 3;
  }

  return v4;
}

void TranslateGTMTLIntersectionFunctionTableDescriptor(void *a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v3 + 16;
  if (a3)
  {
    id v4 = a1;
    *(_DWORD *)(v3 + _Block_object_dispose(va, 8) = [v4 functionCount];
    *(void *)uint64_t v3 = [v4 resourceIndex];
    unsigned __int8 v5 = [v4 forceResourceIndex];

    *(_BYTE *)(v3 + 12) = v5;
  }

MTLIntersectionFunctionTableDescriptor *MakeMTLIntersectionFunctionTableDescriptorWithoutResourceIndex( uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLIntersectionFunctionTableDescriptor);
  -[MTLIntersectionFunctionTableDescriptor setFunctionCount:](v2, "setFunctionCount:", *(unsigned int *)(a1 + 8));
  return v2;
}

MTLIntersectionFunctionTableDescriptor *MakeMTLIntersectionFunctionTableDescriptorWithResourceIndex( uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLIntersectionFunctionTableDescriptor);
  -[MTLIntersectionFunctionTableDescriptor setFunctionCount:](v2, "setFunctionCount:", *(unsigned int *)(a1 + 8));
  -[MTLIntersectionFunctionTableDescriptor setForceResourceIndex:](v2, "setForceResourceIndex:", *(void *)a1 != 0LL);
  -[MTLIntersectionFunctionTableDescriptor setResourceIndex:](v2, "setResourceIndex:", *(void *)a1);
  return v2;
}

void TranslateGTMTLRenderPipelineFunctionsDescriptor(void *a1, uint64_t a2, int a3)
{
  id v26 = a1;
  unsigned __int8 v5 = *(uint64_t **)(a2 + 24);
  *(void *)(a2 + 24) = v5 + 10;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v26 vertexAdditionalBinaryFunctions]);
  uint64_t v7 = TranslateNSArray(v6, a2, a3);

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v26 fragmentAdditionalBinaryFunctions]);
  uint64_t v9 = TranslateNSArray(v8, a2, a3);

  size_t v10 = (void *)objc_claimAutoreleasedReturnValue([v26 tileAdditionalBinaryFunctions]);
  uint64_t v11 = TranslateNSArray(v10, a2, a3);

  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v26 meshAdditionalBinaryFunctions]);
  uint64_t v13 = TranslateNSArray(v12, a2, a3);

  id v14 = (void *)objc_claimAutoreleasedReturnValue([v26 objectAdditionalBinaryFunctions]);
  uint64_t v15 = TranslateNSArray(v14, a2, a3);

  if (a3)
  {
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v26 vertexAdditionalBinaryFunctions]);
    v5[9] = (uint64_t)[v16 count];

    if (v5[9]) {
      uint64_t v17 = v7;
    }
    else {
      uint64_t v17 = 0LL;
    }
    v5[8] = v17;
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v26 fragmentAdditionalBinaryFunctions]);
    v5[1] = (uint64_t)[v18 count];

    if (v5[1]) {
      uint64_t v19 = v9;
    }
    else {
      uint64_t v19 = 0LL;
    }
    uint64_t *v5 = v19;
    id v20 = (void *)objc_claimAutoreleasedReturnValue([v26 tileAdditionalBinaryFunctions]);
    v5[7] = (uint64_t)[v20 count];

    if (v5[7]) {
      uint64_t v21 = v11;
    }
    else {
      uint64_t v21 = 0LL;
    }
    v5[6] = v21;
    size_t v22 = (void *)objc_claimAutoreleasedReturnValue([v26 meshAdditionalBinaryFunctions]);
    v5[3] = (uint64_t)[v22 count];

    if (v5[3]) {
      uint64_t v23 = v13;
    }
    else {
      uint64_t v23 = 0LL;
    }
    v5[2] = v23;
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v26 objectAdditionalBinaryFunctions]);
    v5[5] = (uint64_t)[v24 count];

    if (v5[5]) {
      uint64_t v25 = v15;
    }
    else {
      uint64_t v25 = 0LL;
    }
    v5[4] = v25;
  }
}

MTLRenderPipelineFunctionsDescriptor *MakeMTLRenderPipelineFunctionsDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLRenderPipelineFunctionsDescriptor);
  uint64_t v5 = *(void *)(a1 + 72);
  if (v5)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 64), v5, v3);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLRenderPipelineFunctionsDescriptor setVertexAdditionalBinaryFunctions:]( v4,  "setVertexAdditionalBinaryFunctions:",  v7);
  }

  uint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    id v9 = CreateObjectArrayWithMap(*(uint64_t **)a1, v8, v3);
    size_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    -[MTLRenderPipelineFunctionsDescriptor setFragmentAdditionalBinaryFunctions:]( v4,  "setFragmentAdditionalBinaryFunctions:",  v10);
  }

  uint64_t v11 = *(void *)(a1 + 56);
  if (v11)
  {
    id v12 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 48), v11, v3);
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    -[MTLRenderPipelineFunctionsDescriptor setTileAdditionalBinaryFunctions:]( v4,  "setTileAdditionalBinaryFunctions:",  v13);
  }

  uint64_t v14 = *(void *)(a1 + 24);
  if (v14)
  {
    id v15 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 16), v14, v3);
    id v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
    -[MTLRenderPipelineFunctionsDescriptor setMeshAdditionalBinaryFunctions:]( v4,  "setMeshAdditionalBinaryFunctions:",  v16);
  }

  uint64_t v17 = *(void *)(a1 + 40);
  if (v17)
  {
    id v18 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 32), v17, v3);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
    -[MTLRenderPipelineFunctionsDescriptor setObjectAdditionalBinaryFunctions:]( v4,  "setObjectAdditionalBinaryFunctions:",  v19);
  }

  return v4;
}

void TranslateGTMTLAccelerationStructureAllocationDescriptor(void *a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3 + 16;
  if (a3)
  {
    id v4 = a1;
    *(_BYTE *)(v3 + 9) = [v4 storageMode];
    *(_BYTE *)(v3 + _Block_object_dispose(va, 8) = [v4 forceResourceIndex];
    id v5 = [v4 resourceIndex];

    *(void *)uint64_t v3 = v5;
  }

id MakeMTLAccelerationStructureAllocationDescriptorWithoutResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureAllocationDescriptor);
  [v2 setStorageMode:*(unsigned __int8 *)(a1 + 9)];
  return v2;
}

id MakeMTLAccelerationStructureAllocationDescriptorWithResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureAllocationDescriptor);
  [v2 setStorageMode:*(unsigned __int8 *)(a1 + 9)];
  [v2 setForceResourceIndex:*(void *)a1 != 0];
  [v2 setResourceIndex:*(void *)a1];
  return v2;
}

void TranslateGTMTLResidencySetDescriptor(void *a1, uint64_t *a2, char a3)
{
  id v5 = a1;
  uint64_t v6 = *a2;
  *a2 += 24LL;
  id v15 = v5;
  id v7 = objc_claimAutoreleasedReturnValue([v15 label]);
  uint64_t v8 = (const char *)[v7 UTF8String];
  id v9 = v8;
  if (v8)
  {
    size_t v10 = strlen(v8);
    uint64_t v11 = a2 + 52;
    uint64_t v12 = a2[52];
    size_t v13 = v10 + 1;
    if (v10 != -1LL)
    {
      uint64_t v14 = (void *)a2[52];
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v11 = a2 + 52;
    uint64_t v12 = a2[52];
  }

  size_t v13 = 0LL;
  uint64_t v14 = 0LL;
LABEL_6:
  *uint64_t v11 = v12 + v13;
  if ((a3 & 1) != 0)
  {
    memcpy(v14, v9, v13);

    *(_BYTE *)(v6 + 16) = [v15 evictsImmediately];
    if ((objc_opt_respondsToSelector(v15, "initialCapacity") & 1) != 0) {
      *(void *)uint64_t v6 = [v15 initialCapacity];
    }
    *(void *)(v6 + _Block_object_dispose(va, 8) = v14;
  }

  else
  {
  }
}

id MakeMTLResidencySetDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLResidencySetDescriptor);
  [v2 setEvictsImmediately:*(_BYTE *)(a1 + 16) != 0];
  if ((objc_opt_respondsToSelector(v2, "initialCapacity") & 1) != 0) {
    [v2 setInitialCapacity:*(void *)a1];
  }
  if (*(void *)(a1 + 8))
  {
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    [v2 setLabel:v3];
  }

  return v2;
}

void MakeGTMTLTextureDescriptor(uint64_t a1, void *a2)
{
  uint64_t v16 = 0LL;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  uint64_t v3 = 0LL;
  __int128 v5 = 0u;
  memset(v2, 0, sizeof(v2));
  uint64_t v4 = a1;
  TranslateGTMTLTextureDescriptor(a2, (uint64_t)v2, 1);
}

id MakeMTLTextureDescriptorFromTextureWithResourceIndex(void *a1)
{
  id v1 = a1;
  MTLTextureDescriptorFromTextureWithoutResourceIndex = MakeMTLTextureDescriptorFromTextureWithoutResourceIndex(v1);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptorFromTextureWithoutResourceIndex);
  id v4 = DEVICEOBJECT(v1);
  __int128 v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  char v6 = objc_opt_respondsToSelector(v5, "resourceIndex");

  if ((v6 & 1) != 0)
  {
    id v7 = [v1 resourceIndex];
    [v3 setResourceIndex:v7];
    [v3 setForceResourceIndex:v7 != (id)_MTLInvalidResourceIndex];
  }

  return v3;
}

MTLTextureDescriptor *MakeMTLTextureDescriptorFromTextureWithoutResourceIndex(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLTextureDescriptor);
  -[MTLTextureDescriptor setTextureType:](v2, "setTextureType:", [v1 textureType]);
  -[MTLTextureDescriptor setPixelFormat:](v2, "setPixelFormat:", [v1 pixelFormat]);
  -[MTLTextureDescriptor setUsage:](v2, "setUsage:", [v1 usage]);
  -[MTLTextureDescriptor setWidth:](v2, "setWidth:", [v1 width]);
  -[MTLTextureDescriptor setHeight:](v2, "setHeight:", [v1 height]);
  -[MTLTextureDescriptor setDepth:](v2, "setDepth:", [v1 depth]);
  -[MTLTextureDescriptor setArrayLength:](v2, "setArrayLength:", [v1 arrayLength]);
  -[MTLTextureDescriptor setStorageMode:](v2, "setStorageMode:", [v1 storageMode]);
  -[MTLTextureDescriptor setSampleCount:](v2, "setSampleCount:", [v1 sampleCount]);
  -[MTLTextureDescriptor setCpuCacheMode:](v2, "setCpuCacheMode:", [v1 cpuCacheMode]);
  -[MTLTextureDescriptor setMipmapLevelCount:](v2, "setMipmapLevelCount:", [v1 mipmapLevelCount]);
  if ((objc_opt_respondsToSelector(v2, "hazardTrackingMode") & 1) != 0) {
    -[MTLTextureDescriptor setHazardTrackingMode:](v2, "setHazardTrackingMode:", [v1 hazardTrackingMode]);
  }
  if ((objc_opt_respondsToSelector(v2, "allowGPUOptimizedContents") & 1) != 0) {
    -[MTLTextureDescriptor setAllowGPUOptimizedContents:]( v2,  "setAllowGPUOptimizedContents:",  [v1 allowGPUOptimizedContents]);
  }
  if ((objc_opt_respondsToSelector(v2, "swizzle") & 1) != 0) {
    -[MTLTextureDescriptor setSwizzle:](v2, "setSwizzle:", [v1 swizzle]);
  }
  if ((objc_opt_respondsToSelector(v2, "swizzleKey") & 1) != 0
    && (objc_opt_respondsToSelector(v1, "swizzleKey") & 1) != 0)
  {
    -[MTLTextureDescriptor setSwizzleKey:](v2, "setSwizzleKey:", [v1 swizzleKey]);
  }

  if ((objc_opt_respondsToSelector(v2, "rotation") & 1) != 0 && (objc_opt_respondsToSelector(v1, "rotation") & 1) != 0) {
    -[MTLTextureDescriptor setRotation:](v2, "setRotation:", [v1 rotation]);
  }
  if ((objc_opt_respondsToSelector(v2, "sparseSurfaceDefaultValue") & 1) != 0
    && (objc_opt_respondsToSelector(v1, "sparseSurfaceDefaultValue") & 1) != 0)
  {
    -[MTLTextureDescriptor setSparseSurfaceDefaultValue:]( v2,  "setSparseSurfaceDefaultValue:",  [v1 sparseSurfaceDefaultValue]);
  }

  if ((objc_opt_respondsToSelector(v2, "compressionType") & 1) != 0
    && (objc_opt_respondsToSelector(v1, "compressionType") & 1) != 0)
  {
    -[MTLTextureDescriptor setCompressionType:](v2, "setCompressionType:", [v1 compressionType]);
  }

  if ((objc_opt_respondsToSelector(v2, "compressionFootprint") & 1) != 0
    && (objc_opt_respondsToSelector(v1, "compressionFootprint") & 1) != 0)
  {
    -[MTLTextureDescriptor setCompressionFootprint:]( v2,  "setCompressionFootprint:",  [v1 compressionFootprint]);
  }

  return v2;
}

void MakeGTMTLSamplerDescriptor(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_claimAutoreleasedReturnValue([v3 label]);
  __int128 v5 = (const char *)[v4 UTF8String];

  if (v5) {
    size_t v6 = strlen(v5);
  }
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  *(void *)&__int128 v23 = a1;
  __chkstk_darwin(v6, v7);
  uint64_t v37 = (char *)&v11 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  TranslateGTMTLSamplerDescriptor(v3, (uint64_t)&v11, 1);
  __int128 v9 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v3,  "label",  (void)v11,  *((void *)&v11 + 1),  (void)v12,  *((void *)&v12 + 1),  (void)v13,  *((void *)&v13 + 1),  (void)v14,  *((void *)&v14 + 1),  (void)v15,  *((void *)&v15 + 1),  (void)v16,  *((void *)&v16 + 1),  (void)v17,  *((void *)&v17 + 1),  (void)v18,  *((void *)&v18 + 1),  (void)v19,  *((void *)&v19 + 1),  (void)v20,  *((void *)&v20 + 1),  (void)v21,  *((void *)&v21 + 1),  (void)v22,  *((void *)&v22 + 1),  (void)v23,  *((void *)&v23 + 1),  (void)v24,  *((void *)&v24 + 1),  (void)v25,  *((void *)&v25 + 1),  (void)v26,  *((void *)&v26 + 1),  (void)v27,  *((void *)&v27 + 1),  (void)v28,  *((void *)&v28 + 1),  (void)v29,  *((void *)&v29 + 1),  (void)v30,  *((void *)&v30 + 1),  (void)v31,  *((void *)&v31 + 1),  (void)v32,  *((void *)&v32 + 1),  (void)v33,  *((void *)&v33 + 1),
                   (void)v34,
                   *((void *)&v34 + 1),
                   (void)v35,
                   *((void *)&v35 + 1),
                   (void)v36,
                   *((void *)&v36 + 1)));

  id v10 = v9;
  *a1 = [v10 UTF8String];
}

void MakeGTMTLIndirectCommandBufferDescriptorFromIndirectCommandBuffer(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v23 = 0LL;
  [v3 getHeader:&v23 headerSize:0];
  id v4 = DEVICEOBJECT(v3);
  __int128 v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  char v6 = objc_opt_respondsToSelector(v5, "resourceIndex");

  id v7 = 0LL;
  if ((v6 & 1) != 0) {
    id v7 = [v3 resourceIndex];
  }
  int v8 = *(_DWORD *)(v23 + 8);
  char v9 = *(_BYTE *)(v23 + 13);
  char v10 = *(_BYTE *)(v23 + 12);
  __int16 v11 = *(_WORD *)(v23 + 15);
  char v21 = *(_BYTE *)(v23 + 18);
  char v22 = *(_BYTE *)(v23 + 21);
  char v19 = *(_BYTE *)(v23 + 22);
  char v20 = *(_BYTE *)(v23 + 17);
  char v17 = *(_BYTE *)(v23 + 20);
  char v18 = *(_BYTE *)(v23 + 14);
  char v16 = *(_BYTE *)(v23 + 19);
  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v3 device]);
  id v13 = DEVICEOBJECT(v12);
  __int128 v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
  unsigned __int8 v15 = [v14 supportsMeshShadersInICB];

  *(void *)a1 = v7;
  *(_WORD *)(a1 + _Block_object_dispose(va, 8) = v8;
  *(_BYTE *)(a1 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v9;
  *(_BYTE *)(a1 + 11) = v10;
  *(_WORD *)(a1 + 12) = v11;
  *(_BYTE *)(a1 + 14) = v22;
  *(_BYTE *)(a1 + 15) = v21;
  *(_BYTE *)(a1 + 16) = v20;
  *(_BYTE *)(a1 + 17) = v19;
  *(_BYTE *)(a1 + 1_Block_object_dispose(va, 8) = v18;
  *(_BYTE *)(a1 + 19) = v17;
  *(_BYTE *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v16;
  *(_BYTE *)(a1 + 21) = v15;
  *(_WORD *)(a1 + 22) = 0;
}

void TranslateGTMTLIndirectCommandBufferDescriptorWithDevice(void *a1, void *a2, uint64_t a3, int a4)
{
  id v13 = a1;
  id v7 = a2;
  uint64_t v8 = *(void *)(a3 + 176);
  TranslateGTMTLIndirectCommandBufferDescriptorAuto(v13, a3, a4);
  if (a4)
  {
    id v9 = DEVICEOBJECT(v7);
    char v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    *(_BYTE *)(v8 + 21) = [v10 supportsMeshShadersInICB];

    __int16 v11 = *(_WORD *)(v8 + 8);
    if ((objc_opt_respondsToSelector(v13, "maxKernelThreadgroupMemoryBindCount") & 1) != 0)
    {
      unsigned __int8 v12 = [v13 maxKernelThreadgroupMemoryBindCount];
    }

    else if ((v11 & 0x60) != 0)
    {
      unsigned __int8 v12 = 31;
    }

    else
    {
      unsigned __int8 v12 = 0;
    }

    *(_BYTE *)(v8 + 14) = v12;
  }
}

id MakeMTLIndirectCommandBufferDescriptorFromIndirectCommandBuffer(void *a1)
{
  MTLIndirectCommandBufferDescriptorWithoutResourceIndex = MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex((uint64_t)v3);
  return (id)objc_claimAutoreleasedReturnValue(MTLIndirectCommandBufferDescriptorWithoutResourceIndex);
}

void TranslateGTMTLRenderPassDescriptor(void *a1, uint64_t a2, int a3)
{
  id v13 = a1;
  uint64_t v5 = *(void *)(a2 + 240);
  TranslateGTMTLRenderPassDescriptorAuto(v13, a2, a3);
  id v6 = [v13 getSamplePositions:0 count:0];
  id v7 = v13;
  uint64_t v8 = *(void *)(a2 + 408);
  *(void *)(a2 + 40_Block_object_dispose(va, 8) = v8 + 8LL * (void)v6;
  if (a3)
  {
    *(void *)(v5 + 76_Block_object_dispose(va, 8) = v6;
    *(void *)(v5 + 76mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v8;
    objc_msgSend(v13, "getSamplePositions:count:");
    id v9 = v13;
    SEL v10 = NSSelectorFromString(@"isDitherEnabled");
    if ((objc_opt_respondsToSelector(v9, v10) & 1) != 0) {
      unsigned __int8 v11 = ((uint64_t (*)(id, SEL))[v9 methodForSelector:v10])(v9, v10);
    }
    else {
      unsigned __int8 v11 = [v9 ditherEnabled];
    }
    unsigned __int8 v12 = v11;

    *(_BYTE *)(v5 + 817) = v12;
    id v7 = v13;
  }
}

id MakeMTLRenderPassDescriptor(uint64_t a1, void *a2)
{
  MTLRenderPassDescriptorAuto = MakeMTLRenderPassDescriptorAuto(a1, a2);
  id v4 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPassDescriptorAuto);
  [v4 setSamplePositions:*(void *)(a1 + 760) count:*(void *)(a1 + 768)];
  return v4;
}

void TranslateGTMTLComputePipelineDescriptor(void *a1, void *a2, int a3)
{
  uint64_t v4 = a2[21];
  TranslateGTMTLComputePipelineDescriptorAuto(a1, a2, a3);
  if (a3) {
    *(_BYTE *)(v4 + 951) = -1;
  }
}

void TranslateGTMTLDeviceDescriptor(void *a1, uint64_t a2, char a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 312);
  *(void *)(a2 + 312) = v6 + 112;
  id v7 = objc_claimAutoreleasedReturnValue([v5 name]);
  uint64_t v8 = (const char *)[v7 UTF8String];
  id v9 = v8;
  if (v8)
  {
    size_t v10 = strlen(v8);
    unsigned __int8 v11 = (void *)(a2 + 416);
    uint64_t v12 = *(void *)(a2 + 416);
    size_t v13 = v10 + 1;
    if (v10 != -1LL)
    {
      __int128 v14 = *(void **)(a2 + 416);
      goto LABEL_6;
    }
  }

  else
  {
    unsigned __int8 v11 = (void *)(a2 + 416);
    uint64_t v12 = *(void *)(a2 + 416);
  }

  size_t v13 = 0LL;
  __int128 v14 = 0LL;
LABEL_6:
  *unsigned __int8 v11 = v12 + v13;
  if ((a3 & 1) != 0)
  {
    memcpy(v14, v9, v13);

    *(_OWORD *)(v6 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
    *(_OWORD *)(v6 + 96) = 0u;
    *(_OWORD *)(v6 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v6 + 64) = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    *(_BYTE *)(v6 + 102) = 3;
    *(void *)(v6 + 64) = v14;
    if (v5)
    {
      [v5 maxThreadsPerThreadgroup];
      *(_WORD *)(v6 + 96) = v23;
      [v5 maxThreadsPerThreadgroup];
      *(_WORD *)(v6 + 9_Block_object_dispose(va, 8) = v22;
      [v5 maxThreadsPerThreadgroup];
      __int16 v15 = v21;
    }

    else
    {
      __int16 v15 = 0;
      *(_DWORD *)(v6 + 96) = 0;
    }

    *(_WORD *)(v6 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v15;
    *(void *)uint64_t v6 = [v5 sharedMemorySize];
    *(void *)(v6 + _Block_object_dispose(va, 8) = [v5 dedicatedMemorySize];
    if ((objc_opt_respondsToSelector(v5, "isPlacementHeapSupported") & 1) != 0) {
      *(_BYTE *)(v6 + 109) = [v5 isPlacementHeapSupported];
    }
    if ((objc_opt_respondsToSelector(v5, "deviceCreationFlags") & 1) != 0) {
      *(void *)(v6 + 16) = [v5 deviceCreationFlags];
    }
    id v16 = DEVICEOBJECT(v5);
    char v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    if ((objc_opt_respondsToSelector(v17, "resourcePatchingTypeForResourceType:") & 1) != 0)
    {
      uint64_t v18 = 0LL;
      int64x2_t v20 = (int64x2_t)xmmword_1CA4D0;
      do
      {
        id v19 = objc_msgSend(v17, "resourcePatchingTypeForResourceType:", v18, *(_OWORD *)&v20);
        *(int8x16_t *)(v6 + 24) = vorrq_s8( vandq_s8( (int8x16_t)vdupq_n_s64((1 << v18++)),  (int8x16_t)vceqq_s64(vdupq_n_s64((unint64_t)v19), v20)),  *(int8x16_t *)(v6 + 24));
      }

      while (v18 != 9);
      *(_BYTE *)(v6 + 11mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 9;
    }
  }

  else
  {
  }
}

void TranslateGTIOSurface(__IOSurface *a1, uint64_t a2, int a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = *(void *)(a2 + 384);
  *(void *)(a2 + 384) = v6 + 120;
  CFDictionaryRef v7 = IOSurfaceCopyAllValues(a1);
  uint64_t v8 = kIOSurfaceCreationProperties;
  id v9 = (void *)objc_claimAutoreleasedReturnValue( -[__CFDictionary objectForKeyedSubscript:]( v7,  "objectForKeyedSubscript:",  kIOSurfaceCreationProperties));
  if ((unint64_t)[v9 count] <= 1)
  {
    size_t PlaneCount = IOSurfaceGetPlaneCount(a1);
    if (PlaneCount)
    {
      size_t v11 = PlaneCount;
      uint64_t v12 = 0LL;
      while (!IOSurfaceGetCompressionTypeOfPlane(a1, v12))
      {
        if (v11 == ++v12) {
          goto LABEL_10;
        }
      }

      uint64_t v62 = v9;
      uint64_t v63 = v8;
      uint64_t v64 = v4;
      int v65 = a3;
      CFDictionaryRef v66 = v7;
      uint64_t v67 = v6;
      BaseAddress = IOSurfaceGetBaseAddress(a1);
      id v82 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v11);
      size_t v13 = 0LL;
      uint64_t v79 = kIOSurfacePlaneCompressionType;
      uint64_t v78 = kIOSurfacePlaneCompressionFootprint;
      uint64_t v77 = kIOSurfacePlaneCompressedTileWidth;
      uint64_t v76 = kIOSurfacePlaneCompressedTileHeight;
      uint64_t v75 = kIOSurfacePlaneBytesPerTileData;
      uint64_t v74 = kIOSurfacePlaneBytesPerCompressedTileHeader;
      uint64_t v73 = kIOSurfacePlaneWidthInCompressedTiles;
      uint64_t v72 = kIOSurfacePlaneHeightInCompressedTiles;
      uint64_t v71 = kIOSurfacePlaneBytesPerRowOfTileData;
      uint64_t v70 = kIOSurfacePlaneCompressedTileHeaderRegionOffset;
      uint64_t v69 = kIOSurfacePlaneCompressedTileDataRegionOffset;
      uint64_t v68 = kIOSurfaceAddressFormat;
      size_t v81 = v11;
      do
      {
        BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(a1, v13);
        uint64_t BaseAddressOfCompressedTileHeaderRegionOfPlane = IOSurfaceGetBaseAddressOfCompressedTileHeaderRegionOfPlane( a1,  v13);
        uint64_t BaseAddressOfCompressedTileDataRegionOfPlane = IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane(a1, v13);
        v100[0] = IOSurfacePropertyKeyPlaneBytesPerElement;
        __int16 v15 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetBytesPerElementOfPlane(a1, v13));
        CATransform3D v97 = (void *)objc_claimAutoreleasedReturnValue(v15);
        v101[0] = v97;
        v100[1] = IOSurfacePropertyKeyPlaneBytesPerRow;
        id v16 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetBytesPerRowOfPlane(a1, v13));
        uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue(v16);
        v101[1] = v96;
        v100[2] = IOSurfacePropertyKeyPlaneElementHeight;
        char v17 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetElementHeightOfPlane(a1, v13));
        CATransform3D v95 = (void *)objc_claimAutoreleasedReturnValue(v17);
        _OWORD v101[2] = v95;
        _DWORD v100[3] = IOSurfacePropertyKeyPlaneElementWidth;
        uint64_t v18 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetElementWidthOfPlane(a1, v13));
        int64x2_t v94 = (void *)objc_claimAutoreleasedReturnValue(v18);
        v101[3] = v94;
        v100[4] = IOSurfacePropertyKeyPlaneHeight;
        id v19 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetHeightOfPlane(a1, v13));
        uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue(v19);
        v101[4] = v93;
        v100[5] = IOSurfacePropertyKeyPlaneWidth;
        int64x2_t v20 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetWidthOfPlane(a1, v13));
        int64x2_t v92 = (void *)objc_claimAutoreleasedReturnValue(v20);
        v101[5] = v92;
        v100[6] = IOSurfacePropertyKeyPlaneOffset;
        id v89 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithLong:]( &OBJC_CLASS___NSNumber,  "numberWithLong:",  BaseAddressOfPlane - BaseAddress));
        v101[6] = v89;
        v100[7] = IOSurfacePropertyKeyPlaneSize;
        __int16 v21 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetSizeOfPlane(a1, v13));
        id v88 = (void *)objc_claimAutoreleasedReturnValue(v21);
        v101[7] = v88;
        v100[8] = v79;
        __int16 v22 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  IOSurfaceGetCompressionTypeOfPlane(a1, v13));
        uint64_t v87 = (void *)objc_claimAutoreleasedReturnValue(v22);
        v101[8] = v87;
        v100[9] = v78;
        __int16 v23 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  IOSurfaceGetCompressionFootprintOfPlane(a1, v13));
        int v86 = (void *)objc_claimAutoreleasedReturnValue(v23);
        v101[9] = v86;
        v100[10] = v77;
        __int128 v24 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetCompressedTileWidthOfPlane(a1, v13));
        __int16 v85 = (void *)objc_claimAutoreleasedReturnValue(v24);
        v101[10] = v85;
        v100[11] = v76;
        __int128 v25 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetCompressedTileHeightOfPlane(a1, v13));
        id v84 = (void *)objc_claimAutoreleasedReturnValue(v25);
        v101[11] = v84;
        v100[12] = v75;
        __int128 v26 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetBytesPerTileDataOfPlane(a1, v13));
        __int128 v83 = (void *)objc_claimAutoreleasedReturnValue(v26);
        v101[12] = v83;
        v100[13] = v74;
        __int128 v27 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetBytesPerCompressedTileHeaderOfPlane(a1, v13));
        __int128 v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
        v101[13] = v28;
        v100[14] = v73;
        __int128 v29 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetWidthInCompressedTilesOfPlane(a1, v13));
        __int128 v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
        v101[14] = v30;
        v100[15] = v72;
        __int128 v31 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetHeightInCompressedTilesOfPlane(a1, v13));
        __int128 v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
        v101[15] = v32;
        v100[16] = v71;
        __int128 v33 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetBytesPerRowOfTileDataOfPlane(a1, v13));
        __int128 v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
        v101[16] = v34;
        v100[17] = v70;
        __int128 v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithLong:]( &OBJC_CLASS___NSNumber,  "numberWithLong:",  BaseAddressOfCompressedTileHeaderRegionOfPlane - (void)BaseAddress));
        v101[17] = v35;
        v100[18] = v69;
        __int128 v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithLong:]( &OBJC_CLASS___NSNumber,  "numberWithLong:",  BaseAddressOfCompressedTileDataRegionOfPlane - (void)BaseAddress));
        v101[18] = v36;
        v100[19] = v68;
        uint64_t v37 = +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  IOSurfaceGetAddressFormatOfPlane(a1, v13));
        double v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
        v101[19] = v38;
        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v101,  v100,  20LL));
        -[NSMutableArray addObject:](v82, "addObject:", v39);

        ++v13;
      }

      while (v81 != v13);
      v98[0] = IOSurfacePropertyKeyAllocSize;
      id v40 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetAllocSize(a1));
      __int128 v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
      v99[0] = v41;
      v98[1] = IOSurfacePropertyKeyWidth;
      uint64_t v42 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetWidth(a1));
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(v42);
      v99[1] = v43;
      _DWORD v98[2] = IOSurfacePropertyKeyHeight;
      int64x2_t v44 = +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  IOSurfaceGetHeight(a1));
      id v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
      v99[2] = v45;
      v98[3] = IOSurfacePropertyKeyPixelFormat;
      uint64_t v46 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  IOSurfaceGetPixelFormat(a1));
      id v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
      v99[3] = v47;
      v98[4] = IOSurfacePropertyKeyPlaneInfo;
      id v48 = -[NSMutableArray copy](v82, "copy");
      v99[4] = v48;
      v98[5] = IOSurfacePropertyKeyPixelSizeCastingAllowed;
      uint64_t v49 = +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  IOSurfaceAllowsPixelSizeCasting(a1));
      id v50 = (void *)objc_claimAutoreleasedReturnValue(v49);
      v99[5] = v50;
      v98[6] = IOSurfacePropertyKeyCacheMode;
      uint64_t v51 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  IOSurfaceGetCacheMode(a1));
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(v51);
      v99[6] = v52;
      uint64_t v53 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v99,  v98,  7LL));

      id v54 = -[__CFDictionary mutableCopy](v66, "mutableCopy");
      [v54 setObject:v53 forKeyedSubscript:v63];
      CFDictionaryRef v7 = (CFDictionaryRef)[v54 copy];

      id v9 = (void *)v53;
      uint64_t v6 = v67;
      a3 = v65;
      uint64_t v4 = v64;
    }
  }

NSMutableDictionary *MakeIOSurface(uint64_t a1)
{
  uint64_t v1 = a1;
  id v2 = &CACurrentMediaTime_ptr;
  if (*(void *)(a1 + 104))
  {
    id v3 = -[NSData initWithBytesNoCopy:length:freeWhenDone:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytesNoCopy:length:freeWhenDone:",  *(void *)(a1 + 104),  *(void *)(a1 + 112),  0LL);
    uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSDictionary, v4);
    uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSArray, v6);
    uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSString, v8);
    uint64_t v61 = objc_opt_class(&OBJC_CLASS___NSNumber, v10);
    id v2 = &CACurrentMediaTime_ptr;
    uint64_t v12 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v5,  v7,  v9,  v61,  objc_opt_class(&OBJC_CLASS___NSData, v11),  0LL);
    size_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    __int128 v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v13,  v3,  0LL));
    uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:kIOSurfaceCreationProperties]);

    uint64_t v1 = a1;
  }

  else
  {
    uint64_t v63 = 0LL;
  }

  __int16 v15 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v16 = (void *)objc_claimAutoreleasedReturnValue([v2[238] numberWithUnsignedLongLong:*(void *)v1]);
  -[NSMutableDictionary setObject:forKeyedSubscript:](v15, "setObject:forKeyedSubscript:", v16, @"address");

  char v17 = (void *)objc_claimAutoreleasedReturnValue([v2[238] numberWithUnsignedShort:*(unsigned __int16 *)(v1 + 92)]);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v15,  "setObject:forKeyedSubscript:",  v17,  IOSurfacePropertyKeyWidth);

  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v2[238] numberWithUnsignedShort:*(unsigned __int16 *)(v1 + 94)]);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v15,  "setObject:forKeyedSubscript:",  v18,  IOSurfacePropertyKeyHeight);

  id v19 = (void *)objc_claimAutoreleasedReturnValue([v2[238] numberWithUnsignedInt:*(unsigned int *)(v1 + 84)]);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v15,  "setObject:forKeyedSubscript:",  v19,  IOSurfacePropertyKeyPixelFormat);

  if (!*(_BYTE *)(v1 + 102))
  {
    int64x2_t v20 = (void *)objc_claimAutoreleasedReturnValue([v2[238] numberWithUnsignedShort:*(unsigned __int16 *)(v1 + 96)]);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v15,  "setObject:forKeyedSubscript:",  v20,  IOSurfacePropertyKeyBytesPerElement);

    __int16 v21 = (void *)objc_claimAutoreleasedReturnValue([v2[238] numberWithUnsignedInt:*(unsigned int *)(v1 + 80)]);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v15,  "setObject:forKeyedSubscript:",  v21,  IOSurfacePropertyKeyBytesPerRow);

    __int16 v22 = (void *)objc_claimAutoreleasedReturnValue([v2[238] numberWithUnsignedShort:*(unsigned __int16 *)(v1 + 98)]);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v15,  "setObject:forKeyedSubscript:",  v22,  IOSurfacePropertyKeyElementWidth);

    __int16 v23 = (void *)objc_claimAutoreleasedReturnValue([v2[238] numberWithUnsignedShort:*(unsigned __int16 *)(v1 + 100)]);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v15,  "setObject:forKeyedSubscript:",  v23,  IOSurfacePropertyKeyElementHeight);
  }

  __int128 v24 = (void *)objc_claimAutoreleasedReturnValue([v2[238] numberWithUnsignedLongLong:*(void *)(v1 + 8)]);
  uint64_t v62 = v15;
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v15,  "setObject:forKeyedSubscript:",  v24,  IOSurfacePropertyKeyAllocSize);

  if (v63)
  {
    v80[0] = IOSurfacePropertyKeyAllocSize;
    v80[1] = IOSurfacePropertyKeyWidth;
    v80[2] = IOSurfacePropertyKeyHeight;
    v80[3] = IOSurfacePropertyKeyBytesPerElement;
    v80[4] = IOSurfacePropertyKeyBytesPerRow;
    v80[5] = IOSurfacePropertyKeyElementWidth;
    v80[6] = IOSurfacePropertyKeyElementHeight;
    v80[7] = IOSurfacePropertyKeyPixelFormat;
    v80[8] = @"IOSurfaceAddress";
    v80[9] = @"IOSurfaceProtectionOptions";
    __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v80, 10LL));
    __int128 v73 = 0u;
    __int128 v74 = 0u;
    __int128 v75 = 0u;
    __int128 v76 = 0u;
    id v26 = v63;
    id v27 = [v26 countByEnumeratingWithState:&v73 objects:v79 count:16];
    if (v27)
    {
      id v28 = v27;
      uint64_t v29 = *(void *)v74;
      do
      {
        for (uint64_t i = 0LL; i != v28; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v74 != v29) {
            objc_enumerationMutation(v26);
          }
          uint64_t v31 = *(void *)(*((void *)&v73 + 1) + 8LL * (void)i);
          if (([v25 containsObject:v31] & 1) == 0)
          {
            __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([v26 objectForKeyedSubscript:v31]);
            -[NSMutableDictionary setObject:forKeyedSubscript:](v62, "setObject:forKeyedSubscript:", v32, v31);
          }
        }

        id v28 = [v26 countByEnumeratingWithState:&v73 objects:v79 count:16];
      }

      while (v28);
    }
  }

  uint64_t v33 = a1;
  if (*(_BYTE *)(a1 + 102))
  {
    v78[0] = IOSurfacePropertyKeyPlaneWidth;
    v78[1] = IOSurfacePropertyKeyPlaneHeight;
    v78[2] = IOSurfacePropertyKeyPlaneBytesPerElement;
    v78[3] = IOSurfacePropertyKeyPlaneBytesPerRow;
    v78[4] = IOSurfacePropertyKeyPlaneElementWidth;
    v78[5] = IOSurfacePropertyKeyPlaneElementHeight;
    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v78, 6LL));
    int v65 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(unsigned __int8 *)(a1 + 102));
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v63 objectForKeyedSubscript:IOSurfacePropertyKeyPlaneInfo]);
    __int128 v35 = &CACurrentMediaTime_ptr;
    if (*(_BYTE *)(a1 + 102))
    {
      unint64_t v36 = 0LL;
      uint64_t v67 = 0LL;
      do
      {
        uint64_t v37 = v33 + 16 * v36;
        int v38 = *(unsigned __int16 *)(v37 + 22);
        int v39 = *(_DWORD *)(v37 + 16);
        id v40 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        __int128 v41 = (void *)objc_claimAutoreleasedReturnValue([v35[238] numberWithUnsignedShort:*(unsigned __int16 *)(v37 + 20)]);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v40,  "setObject:forKeyedSubscript:",  v41,  IOSurfacePropertyKeyPlaneWidth);

        uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v35[238] numberWithUnsignedShort:*(unsigned __int16 *)(v37 + 22)]);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v40,  "setObject:forKeyedSubscript:",  v42,  IOSurfacePropertyKeyPlaneHeight);

        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v35[238] numberWithUnsignedShort:*(unsigned __int16 *)(v37 + 24)]);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v40,  "setObject:forKeyedSubscript:",  v43,  IOSurfacePropertyKeyPlaneBytesPerElement);

        int64x2_t v44 = (void *)objc_claimAutoreleasedReturnValue([v35[238] numberWithUnsignedInt:*(unsigned int *)(v37 + 16)]);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v40,  "setObject:forKeyedSubscript:",  v44,  IOSurfacePropertyKeyPlaneBytesPerRow);

        if (*(_WORD *)(v37 + 26))
        {
          id v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35[238], "numberWithUnsignedShort:"));
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v40,  "setObject:forKeyedSubscript:",  v45,  IOSurfacePropertyKeyPlaneElementWidth);
        }

        if (*(_WORD *)(v37 + 28))
        {
          uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35[238], "numberWithUnsignedShort:"));
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v40,  "setObject:forKeyedSubscript:",  v46,  IOSurfacePropertyKeyPlaneElementHeight);
        }

        uint64_t v47 = (v39 * v38);
        id v48 = (void *)objc_claimAutoreleasedReturnValue([v35[238] numberWithUnsignedInteger:v67]);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v40,  "setObject:forKeyedSubscript:",  v48,  IOSurfacePropertyKeyPlaneOffset);

        uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v35[238] numberWithUnsignedInteger:v47]);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v40,  "setObject:forKeyedSubscript:",  v49,  IOSurfacePropertyKeyPlaneSize);

        if (v68)
        {
          uint64_t v66 = v47;
          __int128 v71 = 0u;
          __int128 v72 = 0u;
          __int128 v69 = 0u;
          __int128 v70 = 0u;
          id v50 = (void *)objc_claimAutoreleasedReturnValue([v68 objectAtIndexedSubscript:v36]);
          id v51 = [v50 countByEnumeratingWithState:&v69 objects:v77 count:16];
          if (v51)
          {
            id v52 = v51;
            uint64_t v53 = *(void *)v70;
            do
            {
              for (uint64_t j = 0LL; j != v52; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v70 != v53) {
                  objc_enumerationMutation(v50);
                }
                uint64_t v55 = *(void *)(*((void *)&v69 + 1) + 8LL * (void)j);
                if (([v34 containsObject:v55] & 1) == 0)
                {
                  uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([v68 objectAtIndexedSubscript:v36]);
                  id v57 = (void *)objc_claimAutoreleasedReturnValue([v56 objectForKeyedSubscript:v55]);
                  -[NSMutableDictionary setObject:forKeyedSubscript:](v40, "setObject:forKeyedSubscript:", v57, v55);
                }
              }

              id v52 = [v50 countByEnumeratingWithState:&v69 objects:v77 count:16];
            }

            while (v52);
          }

          uint64_t v33 = a1;
          __int128 v35 = &CACurrentMediaTime_ptr;
          uint64_t v47 = v66;
        }

        id v58 = -[NSMutableDictionary copy](v40, "copy");
        -[NSMutableArray addObject:](v65, "addObject:", v58);

        v67 += v47;
        ++v36;
      }

      while (v36 < *(unsigned __int8 *)(v33 + 102));
    }

    id v59 = -[NSMutableArray copy](v65, "copy");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v62,  "setObject:forKeyedSubscript:",  v59,  IOSurfacePropertyKeyPlaneInfo);
  }

  return v62;
}

void TranslateGTMTLRasterizationRateMapDescriptor(void *a1, void *a2, int a3)
{
  id v5 = a1;
  uint64_t v6 = a2[13];
  a2[13] = v6 + 40;
  id v7 = objc_claimAutoreleasedReturnValue([v5 label]);
  uint64_t v8 = (const char *)[v7 UTF8String];
  uint64_t v9 = v8;
  if (v8)
  {
    size_t v10 = strlen(v8);
    uint64_t v11 = a2 + 52;
    uint64_t v12 = a2[52];
    size_t v13 = v10 + 1;
    if (v10 != -1LL)
    {
      __int128 v14 = (void *)a2[52];
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v11 = a2 + 52;
    uint64_t v12 = a2[52];
  }

  size_t v13 = 0LL;
  __int128 v14 = 0LL;
LABEL_6:
  *uint64_t v11 = v12 + v13;
  if (a3) {
    memcpy(v14, v9, v13);
  }
  __int128 v32 = v14;

  uint64_t v31 = a2[36];
  __int16 v15 = (char *)[v5 layerCount];
  if (v15)
  {
    id v16 = v15;
    for (uint64_t i = 0LL; i != v16; ++i)
    {
      uint64_t v18 = a2[36];
      a2[36] = v18 + 24;
      id v19 = (void *)objc_claimAutoreleasedReturnValue([v5 layers]);
      int64x2_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 objectAtIndexedSubscript:i]);

      if (v20)
      {
        [v20 sampleCount];
        uint64_t v21 = v33;
        uint64_t v22 = v34;
      }

      else
      {
        uint64_t v22 = 0LL;
        uint64_t v21 = 0LL;
        uint64_t v33 = 0LL;
        uint64_t v34 = 0LL;
        __int16 v35 = 0;
      }

      __int16 v23 = (char *)a2[51];
      __int128 v24 = &v23[4 * v21];
      a2[51] = &v24[4 * v22];
      if (a3)
      {
        memcpy(v23, [v20 horizontalSampleStorage], 4 * v33);
        memcpy(v24, [v20 verticalSampleStorage], 4 * v34);
        *(void *)uint64_t v18 = v23;
        *(void *)(v18 + _Block_object_dispose(va, 8) = v24;
        *(_WORD *)(v18 + 16) = v33;
        *(_WORD *)(v18 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v34;
        *(_WORD *)(v18 + 1_Block_object_dispose(va, 8) = v35;
      }
    }
  }

  if ((a3 & 1) != 0)
  {
    *(void *)(v6 + 32) = 0x20000LL;
    *(_OWORD *)uint64_t v6 = GTMTLRasterizationRateMapDescriptorDefaults;
    *(_OWORD *)(v6 + 16) = unk_1C8168;
    *(void *)uint64_t v6 = v32;
    unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((a2[36] - v31) >> 3);
    if (a2[36] == v31) {
      uint64_t v26 = 0LL;
    }
    else {
      uint64_t v26 = v31;
    }
    *(void *)(v6 + _Block_object_dispose(va, 8) = v26;
    *(void *)(v6 + 16) = v25;
    if (v5)
    {
      [v5 screenSize];
      __int16 v27 = v33;
      __int16 v28 = v34;
      __int16 v29 = v35;
    }

    else
    {
      __int16 v29 = 0;
      __int16 v28 = 0;
      __int16 v27 = 0;
    }

    *(_WORD *)(v6 + 32) = v27;
    *(_WORD *)(v6 + 3mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v28;
    *(_WORD *)(v6 + 2_Block_object_dispose(va, 8) = v29;
    if ((objc_opt_respondsToSelector(v5, "mutability") & 1) != 0) {
      *(_BYTE *)(v6 + 34) = [v5 mutability];
    }
    if ((objc_opt_respondsToSelector(v5, "minFactor") & 1) != 0)
    {
      [v5 minFactor];
      *(_DWORD *)(v6 + 24) = v30;
    }

    if ((objc_opt_respondsToSelector(v5, "skipSampleValidationAndApplySampleAtTileGranularity") & 1) != 0) {
      *(_BYTE *)(v6 + 35) = [v5 skipSampleValidationAndApplySampleAtTileGranularity];
    }
  }
}

id MakeMTLRasterizationRateMapDescriptor(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = 8 * v3;
  __chkstk_darwin(a1, a2);
  id v5 = (char *)v23 - ((8 * v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  bzero(v5, 8 * v3);
  if (*(void *)(a1 + 16))
  {
    v23[1] = v23;
    uint64_t v6 = 0LL;
    unint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = (unsigned __int16 *)(*(void *)(a1 + 8) + v6);
      uint64_t v9 = v8[8];
      uint64_t v10 = v8[10];
      uint64_t v11 = v8[9];
      uint64_t v12 = objc_alloc(&OBJC_CLASS___MTLRasterizationRateLayerDescriptor);
      uint64_t v24 = v9;
      uint64_t v25 = v10;
      uint64_t v26 = v11;
      size_t v13 = -[MTLRasterizationRateLayerDescriptor initWithSampleCount:](v12, "initWithSampleCount:", &v24);
      __int128 v14 = *(void **)&v5[8 * v7];
      *(void *)&v5[8 * v7] = v13;

      memcpy( -[MTLRasterizationRateLayerDescriptor horizontalSampleStorage](v13, "horizontalSampleStorage"),  *(const void **)(*(void *)(a1 + 8) + v6),  4 * v9);
      memcpy( -[MTLRasterizationRateLayerDescriptor verticalSampleStorage](v13, "verticalSampleStorage"),  *(const void **)(*(void *)(a1 + 8) + v6 + 8),  4 * v10);
      ++v7;
      unint64_t v15 = *(void *)(a1 + 16);
      v6 += 24LL;
    }

    while (v7 < v15);
  }

  else
  {
    unint64_t v15 = 0LL;
  }

  uint64_t v16 = *(unsigned __int16 *)(a1 + 30);
  uint64_t v17 = *(unsigned __int16 *)(a1 + 28);
  uint64_t v24 = *(unsigned __int16 *)(a1 + 32);
  uint64_t v25 = v16;
  uint64_t v26 = v17;
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[MTLRasterizationRateMapDescriptor rasterizationRateMapDescriptorWithScreenSize:layerCount:layers:]( &OBJC_CLASS___MTLRasterizationRateMapDescriptor,  "rasterizationRateMapDescriptorWithScreenSize:layerCount:layers:",  &v24,  v15,  (char *)v23 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL)));
  if (*(void *)a1)
  {
    id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    [v18 setLabel:v19];
  }

  if ((objc_opt_respondsToSelector(v18, "mutability") & 1) != 0) {
    [v18 setMutability:*(unsigned __int8 *)(a1 + 34)];
  }
  if ((objc_opt_respondsToSelector(v18, "minFactor") & 1) != 0)
  {
    LODWORD(v2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_DWORD *)(a1 + 24);
    [v18 setMinFactor:v20];
  }

  if ((objc_opt_respondsToSelector(v18, "skipSampleValidationAndApplySampleAtTileGranularity") & 1) != 0) {
    [v18 setSkipSampleValidationAndApplySampleAtTileGranularity:*(_BYTE *)(a1 + 35) != 0];
  }
  if (v3)
  {
    uint64_t v21 = v5 - 8;
    do
    {

      v4 -= 8LL;
    }

    while (v4);
  }

  return v18;
}

void TranslateGTMTLCounterSampleBufferDescriptor(void *a1, void *a2, int a3)
{
  id v5 = a1;
  uint64_t v59 = a2[38];
  a2[38] = v59 + 48;
  id v61 = v5;
  id v6 = objc_claimAutoreleasedReturnValue([v5 label]);
  unint64_t v7 = (const char *)[v6 UTF8String];
  uint64_t v8 = v7;
  if (v7)
  {
    size_t v9 = strlen(v7);
    uint64_t v10 = a2 + 52;
    uint64_t v11 = a2[52];
    size_t v12 = v9 + 1;
    if (v9 != -1LL)
    {
      size_t v13 = (void *)a2[52];
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v10 = a2 + 52;
    uint64_t v11 = a2[52];
  }

  size_t v12 = 0LL;
  size_t v13 = 0LL;
LABEL_6:
  *uint64_t v10 = v11 + v12;
  if (a3) {
    memcpy(v13, v8, v12);
  }
  id v58 = v13;

  __int128 v14 = (void *)objc_claimAutoreleasedReturnValue([v61 counterSet]);
  id v15 = objc_claimAutoreleasedReturnValue([v14 name]);
  uint64_t v16 = (const char *)[v15 UTF8String];
  uint64_t v17 = v16;
  if (v16)
  {
    size_t v18 = strlen(v16);
    id v19 = a2 + 52;
    uint64_t v20 = a2[52];
    size_t v21 = v18 + 1;
    if (v18 != -1LL)
    {
      __dst = (void *)a2[52];
      goto LABEL_13;
    }
  }

  else
  {
    id v19 = a2 + 52;
    uint64_t v20 = a2[52];
  }

  size_t v21 = 0LL;
  __dst = 0LL;
LABEL_13:
  *id v19 = v20 + v21;
  if (a3) {
    memcpy(__dst, v17, v21);
  }

  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v61 counterSet]);
  id v23 = objc_claimAutoreleasedReturnValue([v22 description]);
  uint64_t v24 = (const char *)[v23 UTF8String];
  uint64_t v25 = v24;
  if (v24)
  {
    size_t v26 = strlen(v24);
    __int16 v27 = a2 + 52;
    uint64_t v28 = a2[52];
    size_t v29 = v26 + 1;
    if (v26 != -1LL)
    {
      int v30 = (void *)a2[52];
      goto LABEL_20;
    }
  }

  else
  {
    __int16 v27 = a2 + 52;
    uint64_t v28 = a2[52];
  }

  size_t v29 = 0LL;
  int v30 = 0LL;
LABEL_20:
  *__int16 v27 = v28 + v29;
  if (a3) {
    memcpy(v30, v25, v29);
  }
  id v57 = v30;

  uint64_t v56 = a2[49];
  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v61 counterSet]);
  __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([v31 counters]);
  unsigned int v33 = [v32 count];

  uint64_t v34 = v33;
  if (v33)
  {
    for (uint64_t i = 0LL; v34 != i; ++i)
    {
      unint64_t v36 = (void *)a2[49];
      a2[49] = v36 + 2;
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v61 counterSet]);
      int v38 = (void *)objc_claimAutoreleasedReturnValue([v37 counters]);
      int v39 = (void *)objc_claimAutoreleasedReturnValue([v38 objectAtIndexedSubscript:i]);

      id v40 = objc_claimAutoreleasedReturnValue([v39 name]);
      __int128 v41 = (const char *)[v40 UTF8String];
      uint64_t v42 = v41;
      if (v41)
      {
        size_t v43 = strlen(v41);
        uint64_t v44 = a2[52];
        size_t v45 = v43 + 1;
        if (v43 != -1LL)
        {
          uint64_t v46 = (void *)a2[52];
          goto LABEL_29;
        }
      }

      else
      {
        uint64_t v44 = a2[52];
      }

      size_t v45 = 0LL;
      uint64_t v46 = 0LL;
LABEL_29:
      a2[52] = v44 + v45;
      if (a3) {
        memcpy(v46, v42, v45);
      }

      id v47 = objc_claimAutoreleasedReturnValue([v39 description]);
      id v48 = (const char *)[v47 UTF8String];
      uint64_t v49 = v48;
      if (!v48)
      {
        uint64_t v51 = a2[52];
LABEL_35:
        size_t v52 = 0LL;
        uint64_t v53 = 0LL;
        goto LABEL_36;
      }

      size_t v50 = strlen(v48);
      uint64_t v51 = a2[52];
      size_t v52 = v50 + 1;
      if (v50 == -1LL) {
        goto LABEL_35;
      }
      uint64_t v53 = (void *)a2[52];
LABEL_36:
      a2[52] = v51 + v52;
      if ((a3 & 1) != 0)
      {
        memcpy(v53, v49, v52);

        void *v36 = v46;
        v36[1] = v53;
      }

      else
      {
      }
    }
  }

  if ((a3 & 1) != 0)
  {
    *(void *)(v59 + 32) = 0LL;
    *(void *)(v59 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0LL;
    *(void *)uint64_t v59 = v58;
    *(void *)(v59 + _Block_object_dispose(va, 8) = __dst;
    *(void *)(v59 + 16) = v57;
    *(void *)(v59 + 24) = 0LL;
    unint64_t v54 = (unint64_t)(a2[49] - v56) >> 4;
    *(_DWORD *)(v59 + 32) = v54;
    if ((_DWORD)v54) {
      uint64_t v55 = v56;
    }
    else {
      uint64_t v55 = 0LL;
    }
    *(void *)(v59 + 24) = v55;
    *(_DWORD *)(v59 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v61 sampleCount];
    *(_BYTE *)(v59 + 44) = [v61 storageMode];
  }
}

MTLCounterSampleBufferDescriptor *MakeMTLCounterSampleBufferDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLCounterSampleBufferDescriptor);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *(void *)(a1 + 8)));
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  uint64_t v16 = v3;
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v3 counterSets]);
  id v7 = [v6 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v18;
    while (2)
    {
      for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)i);
        size_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 name]);
        unsigned int v13 = [v5 isEqualToString:v12];

        if (v13)
        {
          -[MTLCounterSampleBufferDescriptor setCounterSet:](v4, "setCounterSet:", v11);
          goto LABEL_11;
        }
      }

      id v8 = [v6 countByEnumeratingWithState:&v17 objects:v21 count:16];
      if (v8) {
        continue;
      }
      break;
    }
  }

char *TranslateGTMTLImageFilterFunctionInfo(char *result, int a2, uint64_t a3, char a4)
{
  if (a2 >= 1)
  {
    uint64_t v6 = a2;
    id v7 = (const void **)(result + 8);
    do
    {
      uint64_t v8 = *(void *)(a3 + 256);
      *(void *)(a3 + 256) = v8 + 24;
      if ((a4 & 1) != 0)
      {
        uint64_t v9 = *(void **)(a3 + 328);
        id result = (char *)memcpy(v9, v7[1], 24LL * (void)*v7);
        *(_BYTE *)uint64_t v8 = *((_BYTE *)v7 - 8);
        uint64_t v10 = *v7;
        if (*v7) {
          uint64_t v11 = v9;
        }
        else {
          uint64_t v11 = 0LL;
        }
        *(void *)(v8 + _Block_object_dispose(va, 8) = v10;
        *(void *)(v8 + 16) = v11;
      }

      else
      {
        uint64_t v10 = *v7;
      }

      *(void *)(a3 + 328) += 24LL * (void)v10;
      v7 += 3;
      --v6;
    }

    while (v6);
  }

  return result;
}

void TranslateGTMTLFunctionConstantValues(void *a1, void *a2, void *a3, int a4)
{
  id v7 = a1;
  id v8 = a2;
  __int16 v27 = (void *)a3[15];
  a3[15] = v27 + 2;
  uint64_t v26 = a3[40];
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  obuint64_t j = v7;
  id v29 = [v7 countByEnumeratingWithState:&v31 objects:v35 count:16];
  if (v29)
  {
    uint64_t v28 = *(void *)v32;
    do
    {
      for (uint64_t i = 0LL; i != v29; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v32 != v28) {
          objc_enumerationMutation(obj);
        }
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( [obj objectForKeyedSubscript:*(void *)(*((void *)&v31 + 1) + 8 * (void)i)]);
        uint64_t v11 = a3[40];
        a3[40] = v11 + 32;
        id v12 = objc_claimAutoreleasedReturnValue([v10 name]);
        unsigned int v13 = (const char *)[v12 UTF8String];
        __int128 v14 = v13;
        if (v13)
        {
          size_t v15 = strlen(v13);
          uint64_t v16 = a3[52];
          size_t v17 = v15 + 1;
          if (v15 != -1LL)
          {
            __int128 v18 = (void *)a3[52];
            goto LABEL_11;
          }
        }

        else
        {
          uint64_t v16 = a3[52];
        }

        size_t v17 = 0LL;
        __int128 v18 = 0LL;
LABEL_11:
        a3[52] = v16 + v17;
        if (a4) {
          memcpy(v18, v14, v17);
        }

        if (v8 && (id v19 = [v8 constantValueWithFunctionConstant:v10]) != 0)
        {
          __int128 v20 = v19;
          size_t v21 = _MTLConstantDataSize([v10 type]);
          uint64_t v22 = (char *)a3[52];
          id v23 = v22;
          if (v21) {
            goto LABEL_19;
          }
        }

        else
        {
          size_t v21 = 0LL;
          __int128 v20 = 0LL;
          uint64_t v22 = (char *)a3[52];
        }

        id v23 = 0LL;
LABEL_19:
        a3[52] = &v22[v21];
        if (a4)
        {
          memcpy(v23, v20, v21);
          *(_WORD *)(v11 + 24) = (unsigned __int16)[v10 index];
          *(void *)(v11 + 16) = v18;
          *(_BYTE *)(v11 + 27) = [v10 type];
          *(_BYTE *)(v11 + 26) = [v10 required];
          *(void *)uint64_t v11 = v23;
          *(void *)(v11 + _Block_object_dispose(va, 8) = v21;
        }
      }

      id v29 = [obj countByEnumeratingWithState:&v31 objects:v35 count:16];
    }

    while (v29);
  }

  if (a4)
  {
    uint64_t v24 = v26;
    uint64_t v25 = (a3[40] - v26) >> 5;
    if (a3[40] == v26) {
      uint64_t v24 = 0LL;
    }
    *__int16 v27 = v24;
    v27[1] = v25;
  }
}

MTLFunctionConstantValues *MakeMTLFunctionConstantValues(void *a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLFunctionConstantValues);
  unint64_t v3 = a1[1];
  if (v3)
  {
    uint64_t v4 = 0LL;
    for (unint64_t i = 0LL; i < v3; ++i)
    {
      uint64_t v6 = *(void *)(*a1 + v4);
      if (v6)
      {
        -[MTLFunctionConstantValues setConstantValue:type:atIndex:]( v2,  "setConstantValue:type:atIndex:",  v6,  *(unsigned __int8 *)(*a1 + v4 + 27),  *(unsigned __int16 *)(*a1 + v4 + 24));
        unint64_t v3 = a1[1];
      }

      v4 += 32LL;
    }
  }

  return v2;
}

void TranslateGTMTLFunctionDescriptor(void *a1, void *a2, void *a3, int a4)
{
  id v32 = a1;
  id v7 = a2;
  uint64_t v8 = a3[12];
  a3[12] = v8 + 48;
  id v9 = objc_claimAutoreleasedReturnValue([v32 name]);
  uint64_t v10 = (const char *)[v9 UTF8String];
  uint64_t v11 = v10;
  if (v10)
  {
    size_t v12 = strlen(v10);
    unsigned int v13 = a3 + 52;
    uint64_t v14 = a3[52];
    size_t v15 = v12 + 1;
    if (v12 != -1LL)
    {
      uint64_t v16 = (void *)a3[52];
      goto LABEL_6;
    }
  }

  else
  {
    unsigned int v13 = a3 + 52;
    uint64_t v14 = a3[52];
  }

  size_t v15 = 0LL;
  uint64_t v16 = 0LL;
LABEL_6:
  *unsigned int v13 = v14 + v15;
  if (a4) {
    memcpy(v16, v11, v15);
  }

  id v17 = objc_claimAutoreleasedReturnValue([v32 specializedName]);
  __int128 v18 = (const char *)[v17 UTF8String];
  id v19 = v18;
  if (v18)
  {
    size_t v20 = strlen(v18);
    size_t v21 = a3 + 52;
    uint64_t v22 = a3[52];
    size_t v23 = v20 + 1;
    if (v20 != -1LL)
    {
      uint64_t v24 = (void *)a3[52];
      goto LABEL_13;
    }
  }

  else
  {
    size_t v21 = a3 + 52;
    uint64_t v22 = a3[52];
  }

  size_t v23 = 0LL;
  uint64_t v24 = 0LL;
LABEL_13:
  void *v21 = v22 + v23;
  if (a4) {
    memcpy(v24, v19, v23);
  }

  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v32 constantValues]);
  if (v25)
  {
    uint64_t v26 = a3[15];
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue([v32 constantValues]);
    TranslateGTMTLFunctionConstantValues(v7, v27, a3, a4);
  }

  else
  {
    uint64_t v26 = 0LL;
  }

  if ((objc_opt_respondsToSelector(v32, "privateFunctions") & 1) != 0)
  {
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v32 privateFunctions]);
    uint64_t v29 = TranslateNSArray(v28, (uint64_t)a3, a4);
    unsigned __int16 v30 = (unsigned __int16)[v28 count];

    uint64_t v31 = v30;
    if (!a4) {
      goto LABEL_25;
    }
  }

  else
  {
    uint64_t v29 = 0LL;
    uint64_t v31 = 0LL;
    if (!a4) {
      goto LABEL_25;
    }
  }

  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  if ((objc_opt_respondsToSelector(v32, "options") & 1) != 0) {
    *(_BYTE *)(v8 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v32 options];
  }
  *(void *)(v8 + 24) = v31;
  *(void *)(v8 + 32) = v24;
  *(void *)uint64_t v8 = v26;
  *(void *)(v8 + _Block_object_dispose(va, 8) = v16;
  *(void *)(v8 + 16) = v29;
LABEL_25:
}

MTLFunctionDescriptor *MakeMTLFunctionDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLFunctionDescriptor);
  -[MTLFunctionDescriptor setOptions:](v4, "setOptions:", *(unsigned __int8 *)(a1 + 40));
  if (*(void *)(a1 + 8))
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLFunctionDescriptor setName:](v4, "setName:", v5);
  }

  if (*(void *)(a1 + 32))
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLFunctionDescriptor setSpecializedName:](v4, "setSpecializedName:", v6);
  }

  if (*(void *)a1)
  {
    MTLFunctionConstantValues = MakeMTLFunctionConstantValues(*(void **)a1);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionConstantValues);
    -[MTLFunctionDescriptor setConstantValues:](v4, "setConstantValues:", v8);
  }

  if (*(void *)(a1 + 24) && (objc_opt_respondsToSelector(v4, "privateFunctions") & 1) != 0)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 16), *(_DWORD *)(a1 + 24), v3);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLFunctionDescriptor setPrivateFunctions:](v4, "setPrivateFunctions:", v10);
  }

  return v4;
}

void TranslateGTMTLAccelerationStructureDescriptor(void *a1, void *a2, int a3)
{
  id v167 = a1;
  uint64_t v5 = a2[10];
  a2[10] = v5 + 96;
  uint64_t v7 = objc_opt_class(&OBJC_CLASS___MTLPrimitiveAccelerationStructureDescriptor, v6);
  if ((objc_opt_isKindOfClass(v167, v7) & 1) == 0)
  {
    uint64_t v139 = objc_opt_class(&OBJC_CLASS___MTLInstanceAccelerationStructureDescriptor, v8);
    if ((objc_opt_isKindOfClass(v167, v139) & 1) != 0)
    {
      id v141 = v167;
      uint64_t v142 = (void *)objc_claimAutoreleasedReturnValue([v141 instancedAccelerationStructures]);
      uint64_t v143 = TranslateNSArray(v142, (uint64_t)a2, a3);

      if (a3)
      {
        uint64_t v144 = (void *)objc_claimAutoreleasedReturnValue([v141 instanceDescriptorBuffer]);
        *(void *)(v5 + 16) = [v144 streamReference];

        *(void *)(v5 + 32) = [v141 instanceDescriptorBufferOffset];
        *(_DWORD *)(v5 + 6mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v141 instanceDescriptorStride];
        *(_DWORD *)(v5 + 64) = [v141 instanceCount];
        uint64_t v145 = (void *)objc_claimAutoreleasedReturnValue([v141 instancedAccelerationStructures]);
        *(_DWORD *)(v5 + 56) = [v145 count];

        *(void *)(v5 + _Block_object_dispose(va, 8) = v143;
        *(_BYTE *)(v5 + 72) = [v141 instanceDescriptorType];
        id v146 = (void *)objc_claimAutoreleasedReturnValue([v141 motionTransformBuffer]);
        *(void *)(v5 + 24) = [v146 streamReference];

        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v141 motionTransformBufferOffset];
        *(_DWORD *)(v5 + 6_Block_object_dispose(va, 8) = [v141 motionTransformCount];
        if ((objc_opt_respondsToSelector(v141, "motionTransformStride") & 1) != 0) {
          *(void *)(v5 + 4_Block_object_dispose(va, 8) = [v141 motionTransformStride];
        }
        if ((objc_opt_respondsToSelector(v141, "motionTransformType") & 1) != 0) {
          *(_BYTE *)(v5 + 73) = [v141 motionTransformType];
        }
        if ((objc_opt_respondsToSelector(v141, "instanceTransformationMatrixLayout") & 1) != 0) {
          *(_BYTE *)(v5 + 74) = [v141 instanceTransformationMatrixLayout];
        }
      }

      char v147 = 2;
    }

    else
    {
      uint64_t v151 = objc_opt_class(&OBJC_CLASS___MTLIndirectInstanceAccelerationStructureDescriptor, v140);
      if ((objc_opt_isKindOfClass(v167, v151) & 1) == 0)
      {
        char v147 = 0;
        if (!a3) {
          goto LABEL_103;
        }
        goto LABEL_102;
      }

      id v152 = v167;
      if (a3)
      {
        uint64_t v153 = v152;
        uint64_t v154 = (void *)objc_claimAutoreleasedReturnValue([v152 instanceDescriptorBuffer]);
        *(void *)(v5 + _Block_object_dispose(va, 8) = [v154 streamReference];

        *(void *)(v5 + 16) = [v153 instanceDescriptorBufferOffset];
        uint64_t v155 = (void *)objc_claimAutoreleasedReturnValue([v153 instanceCountBuffer]);
        *(void *)(v5 + 24) = [v155 streamReference];

        *(void *)(v5 + 32) = [v153 instanceCountBufferOffset];
        uint64_t v156 = (void *)objc_claimAutoreleasedReturnValue([v153 motionTransformBuffer]);
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v156 streamReference];

        *(void *)(v5 + 4_Block_object_dispose(va, 8) = [v153 motionTransformBufferOffset];
        uint64_t v157 = (void *)objc_claimAutoreleasedReturnValue([v153 motionTransformCountBuffer]);
        *(void *)(v5 + 56) = [v157 streamReference];

        *(void *)(v5 + 64) = [v153 motionTransformCountBufferOffset];
        *(_DWORD *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v153 maxInstanceCount];
        *(_DWORD *)(v5 + 84) = [v153 instanceDescriptorStride];
        *(_DWORD *)(v5 + 8_Block_object_dispose(va, 8) = [v153 maxMotionTransformCount];
        *(_BYTE *)(v5 + 92) = [v153 instanceDescriptorType];
        if ((objc_opt_respondsToSelector(v153, "motionTransformStride") & 1) != 0) {
          *(void *)(v5 + 72) = [v153 motionTransformStride];
        }
        if ((objc_opt_respondsToSelector(v153, "motionTransformType") & 1) != 0) {
          *(_BYTE *)(v5 + 93) = [v153 motionTransformType];
        }
        if ((objc_opt_respondsToSelector(v153, "instanceTransformationMatrixLayout") & 1) != 0) {
          *(_BYTE *)(v5 + 94) = [v153 instanceTransformationMatrixLayout];
        }
      }

      char v147 = 3;
    }

    goto LABEL_99;
  }

  uint64_t v162 = v5;
  id v9 = v167;
  uint64_t v166 = a2[37];
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 geometryDescriptors]);
  a2[37] += 136 * (void)[v10 count];

  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 geometryDescriptors]);
  id v12 = [v11 count];

  if (v12)
  {
    unint64_t v13 = 0LL;
    uint64_t v169 = v9;
    int v168 = a3;
    uint64_t v170 = a2;
    do
    {
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "geometryDescriptors", v159));
      id v15 = (id)objc_claimAutoreleasedReturnValue([v14 objectAtIndexedSubscript:v13]);
      unsigned int v16 = [v15 intersectionFunctionTableOffset];
      unsigned __int8 v17 = [v15 opaque];
      unsigned __int8 v18 = [v15 allowDuplicateIntersectionFunctionInvocation];
      id v19 = objc_claimAutoreleasedReturnValue([v15 label]);
      size_t v20 = (const char *)[v19 UTF8String];
      size_t v21 = v20;
      if (v20)
      {
        size_t v22 = strlen(v20);
        uint64_t v23 = a2[52];
        size_t v24 = v22 + 1;
        if (v22 != -1LL)
        {
          uint64_t v187 = (void *)a2[52];
          goto LABEL_9;
        }
      }

      else
      {
        uint64_t v23 = a2[52];
      }

      size_t v24 = 0LL;
      uint64_t v187 = 0LL;
LABEL_9:
      a2[52] = v23 + v24;
      if (a3) {
        memcpy(v187, v21, v24);
      }

      if ((objc_opt_respondsToSelector(v15, "primitiveDataBuffer") & 1) != 0)
      {
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v15 primitiveDataBuffer]);
        uint64_t v27 = [v26 streamReference];

        id v28 = [v15 primitiveDataBufferOffset];
        unsigned int v181 = [v15 primitiveDataStride];
        unsigned int v180 = [v15 primitiveDataElementSize];
      }

      else
      {
        unsigned int v180 = 0;
        unsigned int v181 = 0;
        id v28 = 0LL;
        uint64_t v27 = 0LL;
      }

      uint64_t v29 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureTriangleGeometryDescriptor, v25);
      uint64_t v188 = v14;
      unsigned int v186 = v16;
      unsigned __int8 v184 = v18;
      unsigned __int8 v185 = v17;
      id v182 = v28;
      uint64_t v183 = v27;
      if ((objc_opt_isKindOfClass(v15, v29) & 1) != 0)
      {
        id v31 = v15;
        id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 vertexBuffer]);
        unsigned int v33 = [v32 streamReference];

        uint64_t v178 = (uint64_t)[v31 vertexBufferOffset];
        id v171 = [v31 vertexStride];
        __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v31 indexBuffer]);
        unsigned int v35 = [v34 streamReference];

        unint64_t v36 = (char *)[v31 indexBufferOffset];
        unsigned __int8 v37 = [v31 indexType];
        unint64_t v38 = (unint64_t)[v31 triangleCount];
        unint64_t v39 = v13;
        if ((objc_opt_respondsToSelector(v31, "vertexFormat") & 1) != 0) {
          unsigned __int8 v40 = [v31 vertexFormat];
        }
        else {
          unsigned __int8 v40 = 0;
        }
        uint64_t v189 = v36;
        if ((objc_opt_respondsToSelector(v31, "transformationMatrixBuffer") & 1) != 0)
        {
          uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v31 transformationMatrixBuffer]);
          unint64_t v177 = [v55 streamReference];

          id v176 = [v31 transformationMatrixBufferOffset];
        }

        else
        {
          id v176 = 0LL;
          unint64_t v177 = 0LL;
        }

        if ((objc_opt_respondsToSelector(v31, "transformationMatrixLayout") & 1) != 0) {
          unsigned __int8 v48 = [v31 transformationMatrixLayout];
        }
        else {
          unsigned __int8 v48 = 0;
        }
        unsigned __int8 v47 = v37;
        id v45 = (id)v33;
        uint64_t v179 = v35;

        unint64_t v50 = 0LL;
        id v51 = 0LL;
        id v52 = 0LL;
        unint64_t v53 = 0LL;
        char v54 = 1;
        id v46 = v171;
        int v74 = v168;
LABEL_58:
        unsigned __int8 v49 = v40;
        unint64_t v13 = v39;
        a3 = v74;
        goto LABEL_59;
      }

      uint64_t v41 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureBoundingBoxGeometryDescriptor, v30);
      if ((objc_opt_isKindOfClass(v15, v41) & 1) == 0)
      {
        uint64_t v56 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionTriangleGeometryDescriptor, v42);
        if ((objc_opt_isKindOfClass(v15, v56) & 1) == 0)
        {
          uint64_t v75 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor, v57);
          if ((objc_opt_isKindOfClass(v15, v75) & 1) != 0)
          {
            id v77 = v15;
            uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v77 boundingBoxBuffers]);
            unsigned int v79 = [v78 count];

            uint64_t v80 = a2[43];
            a2[43] = v80 + 16LL * v79;
            if (v79) {
              uint64_t v81 = v80;
            }
            else {
              uint64_t v81 = 0LL;
            }
            uint64_t v189 = (char *)v79;
            if (v79 && a3)
            {
              id v82 = 0LL;
              __int128 v83 = (void *)(v80 + 8);
              do
              {
                id v84 = (void *)objc_claimAutoreleasedReturnValue([v77 boundingBoxBuffers]);
                __int16 v85 = (void *)objc_claimAutoreleasedReturnValue([v84 objectAtIndexedSubscript:v82]);
                int v86 = (void *)objc_claimAutoreleasedReturnValue([v85 buffer]);
                *(v83 - 1) = [v86 streamReference];

                uint64_t v87 = (void *)objc_claimAutoreleasedReturnValue([v77 boundingBoxBuffers]);
                id v88 = (void *)objc_claimAutoreleasedReturnValue([v87 objectAtIndexedSubscript:v82]);
                void *v83 = [v88 offset];
                v83 += 2;

                ++v82;
              }

              while (v189 != v82);
              uint64_t v81 = v80;
            }

            uint64_t v179 = v81;
            id v176 = [v77 boundingBoxStride];
            unint64_t v177 = (unint64_t)[v77 boundingBoxCount];

            unint64_t v38 = 0LL;
            id v45 = 0LL;
            uint64_t v178 = 0LL;
            id v46 = 0LL;
            unsigned __int8 v47 = 0;
            unsigned __int8 v48 = 0;
            unsigned __int8 v49 = 0;
            unint64_t v50 = 0LL;
            id v51 = 0LL;
            id v52 = 0LL;
            unint64_t v53 = 0LL;
            char v54 = 4;
          }

          else
          {
            uint64_t v90 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureCurveGeometryDescriptor, v76);
            if ((objc_opt_isKindOfClass(v15, v90) & 1) != 0)
            {
              id v92 = v15;
              uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue([v92 controlPointBuffer]);
              uint64_t v179 = [v93 streamReference];

              uint64_t v189 = (char *)[v92 controlPointBufferOffset];
              int64x2_t v94 = (void *)objc_claimAutoreleasedReturnValue([v92 radiusBuffer]);
              uint64_t v178 = [v94 streamReference];

              id v173 = [v92 radiusBufferOffset];
              unint64_t v177 = (unint64_t)[v92 controlPointCount];
              id v176 = [v92 controlPointStride];
              unint64_t v95 = (unint64_t)[v92 radiusStride];
              unsigned __int8 v47 = v95;
              unint64_t v160 = v95 >> 8;
              unint64_t v164 = v13;
              unint64_t v96 = v95 >> 16;
              unint64_t v97 = v95 & 0xFFFFFFFFFF000000LL;
              __int128 v98 = (void *)objc_claimAutoreleasedReturnValue([v92 indexBuffer]);
              unint64_t v38 = [v98 streamReference];

              id v45 = [v92 indexBufferOffset];
              id v52 = [v92 segmentCount];
              id v51 = [v92 segmentControlPointCount];
              uint64_t v99 = [v92 controlPointFormat];
              unint64_t v100 = v99 & 0xFFFF00FFFFFFFFFFLL | ((unint64_t)[v92 radiusFormat] << 40);
              unint64_t v101 = v100 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)[v92 indexType] << 32);
              unint64_t v102 = v101 & 0xFFFFFFFFFF00FFFFLL | ((unint64_t)[v92 curveType] << 16);
              unint64_t v103 = v102 & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)[v92 curveBasis] << 8);
              id v159 = [v92 endCaps];

              unint64_t v50 = v97;
              unsigned __int8 v48 = v160;
              unsigned __int8 v49 = v96;
              unint64_t v13 = v164;
              id v46 = v173;
              unint64_t v53 = v103 | ((_DWORD)v159 << 24);
              a3 = v168;
              char v54 = 5;
            }

            else
            {
              uint64_t v107 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionCurveGeometryDescriptor, v91);
              if ((objc_opt_isKindOfClass(v15, v107) & 1) != 0)
              {
                unint64_t v165 = v13;
                id v108 = v15;
                __int128 v109 = (void *)objc_claimAutoreleasedReturnValue([v108 controlPointBuffers]);
                unsigned int v110 = [v109 count];

                uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue([v108 radiusBuffers]);
                unsigned int v112 = [v111 count];

                if (v110) {
                  uint64_t v113 = a2[43];
                }
                else {
                  uint64_t v113 = 0LL;
                }
                uint64_t v189 = (char *)v110;
                int v114 = a3;
                uint64_t v115 = (void *)v112;
                if (v112) {
                  uint64_t v116 = a2[43] + 16LL * v110;
                }
                else {
                  uint64_t v116 = 0LL;
                }
                a2[43] += 16LL * v110 + 16LL * v112;
                if (v114)
                {
                  uint64_t v174 = (void *)v112;
                  if (v110)
                  {
                    __int128 v117 = 0LL;
                    uint64_t v118 = (void *)(v113 + 8);
                    do
                    {
                      uint64_t v119 = (void *)objc_claimAutoreleasedReturnValue([v108 controlPointBuffers]);
                      uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue([v119 objectAtIndexedSubscript:v117]);
                      uint64_t v121 = (void *)objc_claimAutoreleasedReturnValue([v120 buffer]);
                      *(v118 - 1) = [v121 streamReference];

                      __int128 v122 = (void *)objc_claimAutoreleasedReturnValue([v108 controlPointBuffers]);
                      uint64_t v123 = (void *)objc_claimAutoreleasedReturnValue([v122 objectAtIndexedSubscript:v117]);
                      *uint64_t v118 = [v123 offset];
                      v118 += 2;

                      ++v117;
                    }

                    while (v189 != v117);
                  }

                  uint64_t v115 = v174;
                  if (v174)
                  {
                    uint64_t v124 = 0LL;
                    uint64_t v125 = (void *)(v116 + 8);
                    do
                    {
                      __int128 v126 = (void *)objc_claimAutoreleasedReturnValue([v108 radiusBuffers]);
                      uint64_t v127 = (void *)objc_claimAutoreleasedReturnValue([v126 objectAtIndexedSubscript:v124]);
                      uint64_t v128 = (void *)objc_claimAutoreleasedReturnValue([v127 buffer]);
                      *(v125 - 1) = [v128 streamReference];

                      uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue([v108 radiusBuffers]);
                      uint64_t v130 = (void *)objc_claimAutoreleasedReturnValue([v129 objectAtIndexedSubscript:v124]);
                      void *v125 = [v130 offset];
                      v125 += 2;

                      ++v124;
                    }

                    while (v174 != (void *)v124);
                  }
                }

                uint64_t v178 = v116;
                uint64_t v179 = v113;
                unint64_t v177 = (unint64_t)[v108 controlPointCount];
                id v176 = [v108 controlPointStride];
                unint64_t v131 = (unint64_t)[v108 radiusStride];
                unsigned __int8 v47 = v131;
                unint64_t v161 = v131 >> 8;
                unint64_t v175 = v131 >> 16;
                unint64_t v132 = v131 & 0xFFFFFFFFFF000000LL;
                uint64_t v133 = (void *)objc_claimAutoreleasedReturnValue([v108 indexBuffer]);
                unint64_t v38 = [v133 streamReference];

                id v45 = [v108 indexBufferOffset];
                id v52 = [v108 segmentCount];
                uint64_t v134 = [v108 controlPointFormat];
                unint64_t v135 = v134 & 0xFFFF00FFFFFFFFFFLL | ((unint64_t)[v108 radiusFormat] << 40);
                unint64_t v136 = v135 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)[v108 indexType] << 32);
                id v51 = [v108 segmentControlPointCount];
                unint64_t v137 = v136 & 0xFFFFFFFFFF00FFFFLL | ((unint64_t)[v108 curveType] << 16);
                unint64_t v138 = v137 & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)[v108 curveBasis] << 8);
                unint64_t v53 = v138 | ([v108 endCaps] << 24);

                unint64_t v50 = v132;
                unsigned __int8 v48 = v161;
                unsigned __int8 v49 = v175;
                char v54 = 6;
                id v46 = v115;
                a3 = v168;
                unint64_t v13 = v165;
              }

              else
              {
                char v54 = 0;
                uint64_t v179 = 0LL;
                uint64_t v189 = 0LL;
                id v176 = 0LL;
                unint64_t v177 = 0LL;
                unint64_t v38 = 0LL;
                id v45 = 0LL;
                uint64_t v178 = 0LL;
                id v46 = 0LL;
                unsigned __int8 v47 = 0;
                unsigned __int8 v48 = 0;
                unsigned __int8 v49 = 0;
                unint64_t v50 = 0LL;
                id v51 = 0LL;
                id v52 = 0LL;
                unint64_t v53 = 0LL;
              }
            }
          }

          goto LABEL_59;
        }

        id v58 = v15;
        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v58 vertexBuffers]);
        unsigned int v60 = [v59 count];

        id v61 = (char *)v60;
        uint64_t v62 = (void *)a2[43];
        a2[43] = &v62[2 * v60];
        if (v60) {
          id v45 = v62;
        }
        else {
          id v45 = 0LL;
        }
        if (v60 && v168)
        {
          uint64_t v63 = 0LL;
          uint64_t v64 = v62 + 1;
          do
          {
            int v65 = (void *)objc_claimAutoreleasedReturnValue([v58 vertexBuffers]);
            uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v65 objectAtIndexedSubscript:v63]);
            uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v66 buffer]);
            *(v64 - 1) = [v67 streamReference];

            uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v58 vertexBuffers]);
            __int128 v69 = (void *)objc_claimAutoreleasedReturnValue([v68 objectAtIndexedSubscript:v63]);
            *uint64_t v64 = [v69 offset];
            v64 += 2;

            ++v63;
          }

          while (v61 != v63);
          id v45 = v62;
        }

        uint64_t v178 = (uint64_t)v61;
        id v172 = [v58 vertexStride];
        __int128 v70 = (void *)objc_claimAutoreleasedReturnValue([v58 indexBuffer]);
        unsigned int v71 = [v70 streamReference];

        __int128 v72 = (char *)[v58 indexBufferOffset];
        unsigned __int8 v73 = [v58 indexType];
        unint64_t v38 = (unint64_t)[v58 triangleCount];
        unsigned __int8 v163 = v73;
        unint64_t v39 = v13;
        if ((objc_opt_respondsToSelector(v58, "vertexFormat") & 1) != 0) {
          unsigned __int8 v40 = [v58 vertexFormat];
        }
        else {
          unsigned __int8 v40 = 0;
        }
        uint64_t v189 = v72;
        if ((objc_opt_respondsToSelector(v58, "transformationMatrixBuffer") & 1) != 0)
        {
          id v89 = (void *)objc_claimAutoreleasedReturnValue([v58 transformationMatrixBuffer]);
          unint64_t v177 = [v89 streamReference];

          id v176 = [v58 transformationMatrixBufferOffset];
        }

        else
        {
          id v176 = 0LL;
          unint64_t v177 = 0LL;
        }

        if ((objc_opt_respondsToSelector(v58, "transformationMatrixLayout") & 1) != 0) {
          unsigned __int8 v48 = [v58 transformationMatrixLayout];
        }
        else {
          unsigned __int8 v48 = 0;
        }
        uint64_t v179 = v71;

        unint64_t v50 = 0LL;
        id v51 = 0LL;
        id v52 = 0LL;
        unint64_t v53 = 0LL;
        char v54 = 3;
        id v46 = v172;
        int v74 = v168;
        unsigned __int8 v47 = v163;
        goto LABEL_58;
      }

      id v43 = v15;
      uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v43 boundingBoxBuffer]);
      uint64_t v179 = [v44 streamReference];

      uint64_t v189 = (char *)[v43 boundingBoxBufferOffset];
      id v176 = [v43 boundingBoxStride];
      unint64_t v177 = (unint64_t)[v43 boundingBoxCount];

      unint64_t v38 = 0LL;
      id v45 = 0LL;
      uint64_t v178 = 0LL;
      id v46 = 0LL;
      unsigned __int8 v47 = 0;
      unsigned __int8 v48 = 0;
      unsigned __int8 v49 = 0;
      unint64_t v50 = 0LL;
      id v51 = 0LL;
      id v52 = 0LL;
      unint64_t v53 = 0LL;
      char v54 = 2;
LABEL_59:
      if (a3)
      {
        uint64_t v104 = v166 + 136 * v13;
        *(void *)uint64_t v104 = v187;
        *(void *)(v104 + _Block_object_dispose(va, 8) = v183;
        *(void *)(v104 + 16) = v182;
        *(_DWORD *)(v104 + 24) = v181;
        *(_DWORD *)(v104 + 2_Block_object_dispose(va, 8) = v180;
        *(_DWORD *)(v104 + 32) = v186;
        *(_BYTE *)(v104 + 36) = v54;
        *(_BYTE *)(v104 + 37) = v185;
        *(_BYTE *)(v104 + 3_Block_object_dispose(va, 8) = v184;
        *(_BYTE *)(v104 + 39) = 0;
        *(void *)(v104 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v179;
        *(void *)(v104 + 4_Block_object_dispose(va, 8) = v189;
        *(void *)(v104 + 56) = v177;
        *(void *)(v104 + 64) = v176;
        *(void *)(v104 + 72) = v38;
        *(void *)(v104 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v45;
        *(void *)(v104 + 8_Block_object_dispose(va, 8) = v178;
        *(void *)(v104 + 96) = v46;
        *(void *)(v104 + 104) = v50 | v47 | ((unint64_t)v48 << 8) | ((unint64_t)v49 << 16);
        *(void *)(v104 + 112) = v51;
        *(void *)(v104 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v52;
        *(void *)(v104 + 12_Block_object_dispose(va, 8) = v53;
      }

      ++v13;
      id v9 = v169;
      __int128 v105 = (void *)objc_claimAutoreleasedReturnValue([v169 geometryDescriptors]);
      id v106 = [v105 count];

      a2 = v170;
    }

    while ((unint64_t)v106 > v13);
  }

  if ((a3 & 1) != 0)
  {
    unint64_t v148 = (void *)objc_claimAutoreleasedReturnValue([v9 geometryDescriptors]);
    uint64_t v5 = v162;
    *(void *)(v162 + 16) = [v148 count];

    *(void *)(v162 + _Block_object_dispose(va, 8) = v166;
    [v9 motionStartTime];
    *(_DWORD *)(v162 + 32) = v149;
    [v9 motionEndTime];
    *(_DWORD *)(v162 + 24) = v150;
    *(_BYTE *)(v162 + 37) = [v9 motionStartBorderMode];
    *(_BYTE *)(v162 + 36) = [v9 motionEndBorderMode];
    *(_DWORD *)(v162 + 2_Block_object_dispose(va, 8) = [v9 motionKeyframeCount];
    char v147 = 1;
LABEL_99:
    uint64_t v158 = v167;
    goto LABEL_101;
  }

  char v147 = 1;
  uint64_t v158 = v167;
  uint64_t v5 = v162;
LABEL_101:

  if (a3)
  {
LABEL_102:
    *(_BYTE *)uint64_t v5 = v147;
    *(_BYTE *)(v5 + 1) = objc_msgSend(v167, "usage", v159);
  }

LABEL_103:
}

void TranslateGTMTLIntersectionFunctionDescriptor(void *a1, void *a2, void *a3, int a4)
{
  id v28 = a1;
  id v7 = a2;
  uint64_t v8 = a3[1];
  a3[1] = v8 + 48;
  id v9 = objc_claimAutoreleasedReturnValue([v28 name]);
  uint64_t v10 = (const char *)[v9 UTF8String];
  uint64_t v11 = v10;
  if (v10)
  {
    size_t v12 = strlen(v10);
    unint64_t v13 = a3 + 52;
    uint64_t v14 = a3[52];
    size_t v15 = v12 + 1;
    if (v12 != -1LL)
    {
      unsigned int v16 = (void *)a3[52];
      goto LABEL_6;
    }
  }

  else
  {
    unint64_t v13 = a3 + 52;
    uint64_t v14 = a3[52];
  }

  size_t v15 = 0LL;
  unsigned int v16 = 0LL;
LABEL_6:
  *unint64_t v13 = v14 + v15;
  if (a4) {
    memcpy(v16, v11, v15);
  }

  id v17 = objc_claimAutoreleasedReturnValue([v28 specializedName]);
  unsigned __int8 v18 = (const char *)[v17 UTF8String];
  id v19 = v18;
  if (v18)
  {
    size_t v20 = strlen(v18);
    size_t v21 = a3 + 52;
    uint64_t v22 = a3[52];
    size_t v23 = v20 + 1;
    if (v20 != -1LL)
    {
      size_t v24 = (void *)a3[52];
      goto LABEL_13;
    }
  }

  else
  {
    size_t v21 = a3 + 52;
    uint64_t v22 = a3[52];
  }

  size_t v23 = 0LL;
  size_t v24 = 0LL;
LABEL_13:
  void *v21 = v22 + v23;
  if (a4) {
    memcpy(v24, v19, v23);
  }

  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v28 constantValues]);
  if (v25)
  {
    uint64_t v26 = a3[15];
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v28 constantValues]);
    TranslateGTMTLFunctionConstantValues(v7, v27, a3, a4);

    if (!a4) {
      goto LABEL_22;
    }
  }

  else
  {
    uint64_t v26 = 0LL;
    if (!a4) {
      goto LABEL_22;
    }
  }

  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  if ((objc_opt_respondsToSelector(v28, "options") & 1) != 0) {
    *(_BYTE *)(v8 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = [v28 options];
  }
  *(void *)(v8 + 32) = v24;
  *(void *)uint64_t v8 = v26;
  *(void *)(v8 + _Block_object_dispose(va, 8) = v16;
LABEL_22:
}

id MakeMTLAccelerationStructureDescriptor(unsigned __int8 *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  int v5 = *a1;
  switch(v5)
  {
    case 3:
      uint64_t v116 = objc_alloc_init(&OBJC_CLASS___MTLIndirectInstanceAccelerationStructureDescriptor);
      __int128 v117 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 1)));
      uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v117]);
      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceDescriptorBuffer:]( v116,  "setInstanceDescriptorBuffer:",  v118);

      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceDescriptorBufferOffset:]( v116,  "setInstanceDescriptorBufferOffset:",  *((void *)a1 + 2));
      uint64_t v119 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 3)));
      uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v119]);
      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceCountBuffer:]( v116,  "setInstanceCountBuffer:",  v120);

      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceCountBufferOffset:]( v116,  "setInstanceCountBufferOffset:",  *((void *)a1 + 4));
      uint64_t v121 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 5)));
      __int128 v122 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v121]);
      -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformBuffer:]( v116,  "setMotionTransformBuffer:",  v122);

      -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformBufferOffset:]( v116,  "setMotionTransformBufferOffset:",  *((void *)a1 + 6));
      uint64_t v123 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 7)));
      uint64_t v124 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v123]);
      -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformCountBuffer:]( v116,  "setMotionTransformCountBuffer:",  v124);

      unint64_t v101 = v116;
      -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformCountBufferOffset:]( v116,  "setMotionTransformCountBufferOffset:",  *((void *)a1 + 8));
      -[MTLIndirectInstanceAccelerationStructureDescriptor setMaxInstanceCount:]( v116,  "setMaxInstanceCount:",  *((unsigned int *)a1 + 20));
      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceDescriptorStride:]( v116,  "setInstanceDescriptorStride:",  *((unsigned int *)a1 + 21));
      -[MTLIndirectInstanceAccelerationStructureDescriptor setMaxMotionTransformCount:]( v116,  "setMaxMotionTransformCount:",  *((unsigned int *)a1 + 22));
      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceDescriptorType:]( v116,  "setInstanceDescriptorType:",  a1[92]);
      if ((objc_opt_respondsToSelector(v116, "motionTransformStride") & 1) != 0) {
        -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformStride:]( v116,  "setMotionTransformStride:",  *((void *)a1 + 9));
      }
      if ((objc_opt_respondsToSelector(v116, "motionTransformType") & 1) != 0) {
        -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformType:]( v116,  "setMotionTransformType:",  a1[93]);
      }
      if ((objc_opt_respondsToSelector(v116, "instanceTransformationMatrixLayout") & 1) != 0) {
        -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceTransformationMatrixLayout:]( v116,  "setInstanceTransformationMatrixLayout:",  a1[94]);
      }
      break;
    case 2:
      uint64_t v104 = a1[1];
      __int128 v105 = objc_alloc_init(&OBJC_CLASS___MTLInstanceAccelerationStructureDescriptor);
      -[MTLInstanceAccelerationStructureDescriptor setUsage:](v105, "setUsage:", v104);
      id v106 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 2)));
      uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v106]);
      -[MTLInstanceAccelerationStructureDescriptor setInstanceDescriptorBuffer:]( v105,  "setInstanceDescriptorBuffer:",  v107);

      -[MTLInstanceAccelerationStructureDescriptor setInstanceDescriptorBufferOffset:]( v105,  "setInstanceDescriptorBufferOffset:",  *((void *)a1 + 4));
      -[MTLInstanceAccelerationStructureDescriptor setInstanceDescriptorStride:]( v105,  "setInstanceDescriptorStride:",  *((unsigned int *)a1 + 15));
      id v108 = v105;
      -[MTLInstanceAccelerationStructureDescriptor setInstanceCount:]( v105,  "setInstanceCount:",  *((unsigned int *)a1 + 16));
      __int128 v109 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *((unsigned int *)a1 + 14));
      if (*((_DWORD *)a1 + 14))
      {
        unint64_t v110 = 0LL;
        do
        {
          uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*((void *)a1 + 1) + 8 * v110)));
          unsigned int v112 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v111]);
          -[NSMutableArray addObject:](v109, "addObject:", v112);

          ++v110;
        }

        while (v110 < *((unsigned int *)a1 + 14));
      }

      if (-[NSMutableArray count](v109, "count")) {
        uint64_t v113 = v109;
      }
      else {
        uint64_t v113 = 0LL;
      }
      -[MTLInstanceAccelerationStructureDescriptor setInstancedAccelerationStructures:]( v108,  "setInstancedAccelerationStructures:",  v113);
      -[MTLInstanceAccelerationStructureDescriptor setInstanceDescriptorType:]( v108,  "setInstanceDescriptorType:",  a1[72]);
      int v114 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 3)));
      uint64_t v115 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v114]);
      -[MTLInstanceAccelerationStructureDescriptor setMotionTransformBuffer:](v108, "setMotionTransformBuffer:", v115);

      unint64_t v101 = v108;
      -[MTLInstanceAccelerationStructureDescriptor setMotionTransformBufferOffset:]( v108,  "setMotionTransformBufferOffset:",  *((void *)a1 + 5));
      -[MTLInstanceAccelerationStructureDescriptor setMotionTransformCount:]( v108,  "setMotionTransformCount:",  *((unsigned int *)a1 + 17));
      if ((objc_opt_respondsToSelector(v108, "motionTransformStride") & 1) != 0) {
        -[MTLInstanceAccelerationStructureDescriptor setMotionTransformStride:]( v108,  "setMotionTransformStride:",  *((void *)a1 + 6));
      }
      if ((objc_opt_respondsToSelector(v108, "motionTransformType") & 1) != 0) {
        -[MTLInstanceAccelerationStructureDescriptor setMotionTransformType:](v108, "setMotionTransformType:", a1[73]);
      }
      if ((objc_opt_respondsToSelector(v108, "instanceTransformationMatrixLayout") & 1) != 0) {
        -[MTLInstanceAccelerationStructureDescriptor setInstanceTransformationMatrixLayout:]( v108,  "setInstanceTransformationMatrixLayout:",  a1[74]);
      }

      break;
    case 1:
      uint64_t v6 = a1[1];
      id v127 = v3;
      id v136 = v3;
      __int128 v126 = objc_alloc_init(&OBJC_CLASS___MTLPrimitiveAccelerationStructureDescriptor);
      -[MTLPrimitiveAccelerationStructureDescriptor setUsage:](v126, "setUsage:", v6);
      unint64_t v135 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *((void *)a1 + 2));
      if (*((void *)a1 + 2))
      {
        unint64_t v7 = 0LL;
        uint64_t v8 = &CACurrentMediaTime_ptr;
        id v9 = &CACurrentMediaTime_ptr;
        uint64_t v129 = a1;
        do
        {
          uint64_t v10 = *((void *)a1 + 1);
          uint64_t v11 = v10 + 136 * v7;
          id v12 = v136;
          uint64_t v143 = v12;
          switch(*(_BYTE *)(v11 + 36))
          {
            case 1:
              unint64_t v140 = v7;
              uint64_t v13 = v10 + 136 * v7;
              id v14 = v12;
              size_t v15 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureTriangleGeometryDescriptor);
              unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(v13 + 80)]);
              id v17 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v16]);
              -[MTLAccelerationStructureTriangleGeometryDescriptor setVertexBuffer:](v15, "setVertexBuffer:", v17);

              -[MTLAccelerationStructureTriangleGeometryDescriptor setVertexBufferOffset:]( v15,  "setVertexBufferOffset:",  *(void *)(v13 + 88));
              -[MTLAccelerationStructureTriangleGeometryDescriptor setVertexStride:]( v15,  "setVertexStride:",  *(void *)(v13 + 96));
              unsigned __int8 v18 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(v13 + 40)]);
              id v19 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v18]);
              -[MTLAccelerationStructureTriangleGeometryDescriptor setIndexBuffer:](v15, "setIndexBuffer:", v19);

              size_t v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v15;
              -[MTLAccelerationStructureTriangleGeometryDescriptor setIndexBufferOffset:]( v15,  "setIndexBufferOffset:",  *(void *)(v13 + 48));
              -[MTLAccelerationStructureTriangleGeometryDescriptor setIndexType:]( v15,  "setIndexType:",  *(unsigned __int8 *)(v13 + 104));
              -[MTLAccelerationStructureTriangleGeometryDescriptor setTriangleCount:]( v15,  "setTriangleCount:",  *(void *)(v13 + 72));
              if ((objc_opt_respondsToSelector(v15, "vertexFormat") & 1) != 0) {
                -[MTLAccelerationStructureTriangleGeometryDescriptor setVertexFormat:]( v15,  "setVertexFormat:",  *(unsigned __int8 *)(v11 + 106));
              }
              unint64_t v7 = v140;
              if ((objc_opt_respondsToSelector(v15, "transformationMatrixBuffer") & 1) != 0)
              {
                uint64_t v21 = v10 + 136 * v140;
                uint64_t v22 = v20;
                size_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v21 + 56)));
                size_t v24 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v23]);
                -[MTLAccelerationStructureCurveGeometryDescriptor setTransformationMatrixBuffer:]( v22,  "setTransformationMatrixBuffer:",  v24);

                size_t v20 = v22;
                -[MTLAccelerationStructureCurveGeometryDescriptor setTransformationMatrixBufferOffset:]( v22,  "setTransformationMatrixBufferOffset:",  *(void *)(v21 + 64));
              }

              if ((objc_opt_respondsToSelector(v20, "transformationMatrixLayout") & 1) != 0) {
                -[MTLAccelerationStructureCurveGeometryDescriptor setTransformationMatrixLayout:]( v20,  "setTransformationMatrixLayout:",  *(unsigned __int8 *)(v11 + 105));
              }

              uint64_t v8 = &CACurrentMediaTime_ptr;
              id v9 = &CACurrentMediaTime_ptr;
              break;
            case 2:
              uint64_t v25 = (void *)(v10 + 136 * v7);
              uint64_t v26 = v10;
              id v27 = v12;
              uint64_t v28 = v11;
              uint64_t v29 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureBoundingBoxGeometryDescriptor);
              uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:v25[5]]);
              id v31 = v27;
              uint64_t v10 = v26;
              id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 objectForKeyedSubscript:v30]);
              -[MTLAccelerationStructureBoundingBoxGeometryDescriptor setBoundingBoxBuffer:]( v29,  "setBoundingBoxBuffer:",  v32);

              id v9 = &CACurrentMediaTime_ptr;
              size_t v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v29;
              uint64_t v11 = v28;
              -[MTLAccelerationStructureCurveGeometryDescriptor setBoundingBoxBufferOffset:]( v20,  "setBoundingBoxBufferOffset:",  v25[6]);
              -[MTLAccelerationStructureCurveGeometryDescriptor setBoundingBoxStride:]( v20,  "setBoundingBoxStride:",  v25[8]);
              -[MTLAccelerationStructureCurveGeometryDescriptor setBoundingBoxCount:]( v20,  "setBoundingBoxCount:",  v25[7]);
              break;
            case 3:
              uint64_t v130 = v10 + 136 * v7;
              unint64_t v141 = v7;
              uint64_t v137 = v10;
              id v33 = v12;
              unint64_t v132 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureMotionTriangleGeometryDescriptor);
              __int128 v34 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(void *)(v130 + 88));
              if (*(void *)(v130 + 88))
              {
                uint64_t v35 = 0LL;
                unint64_t v36 = 0LL;
                unsigned __int8 v37 = (void *)(v137 + 136 * v7 + 80);
                do
                {
                  id v38 = objc_alloc_init((Class)v9[201]);
                  unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(*v37 + v35)]);
                  unsigned __int8 v40 = (void *)objc_claimAutoreleasedReturnValue([v33 objectForKeyedSubscript:v39]);
                  [v38 setBuffer:v40];

                  uint64_t v8 = &CACurrentMediaTime_ptr;
                  [v38 setOffset:*(void *)(*v37 + v35 + 8)];
                  -[NSMutableArray addObject:](v34, "addObject:", v38);

                  ++v36;
                  v35 += 16LL;
                }

                while (*(void *)(v130 + 88) > v36);
              }

              id v41 = -[NSMutableArray copy](v34, "copy");
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setVertexBuffers:]( v132,  "setVertexBuffers:",  v41);

              uint64_t v42 = v137 + 136 * v7;
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setVertexStride:]( v132,  "setVertexStride:",  *(void *)(v42 + 96));
              id v43 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(v130 + 40)]);
              uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v33 objectForKeyedSubscript:v43]);
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setIndexBuffer:](v132, "setIndexBuffer:", v44);

              size_t v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v132;
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setIndexBufferOffset:]( v132,  "setIndexBufferOffset:",  *(void *)(v42 + 48));
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setIndexType:]( v132,  "setIndexType:",  *(unsigned __int8 *)(v42 + 104));
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setTriangleCount:]( v132,  "setTriangleCount:",  *(void *)(v42 + 72));
              uint64_t v11 = v130;
              if ((objc_opt_respondsToSelector(v132, "vertexFormat") & 1) != 0) {
                -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setVertexFormat:]( v132,  "setVertexFormat:",  *(unsigned __int8 *)(v130 + 106));
              }
              unint64_t v7 = v141;
              if ((objc_opt_respondsToSelector(v132, "transformationMatrixBuffer") & 1) != 0)
              {
                uint64_t v45 = v137 + 136 * v141;
                id v46 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(v45 + 56)]);
                unsigned __int8 v47 = (void *)objc_claimAutoreleasedReturnValue([v33 objectForKeyedSubscript:v46]);
                -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setTransformationMatrixBuffer:]( v132,  "setTransformationMatrixBuffer:",  v47);

                uint64_t v8 = &CACurrentMediaTime_ptr;
                size_t v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v132;
                -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setTransformationMatrixBufferOffset:]( v132,  "setTransformationMatrixBufferOffset:",  *(void *)(v45 + 64));
              }

              a1 = v129;
              if ((objc_opt_respondsToSelector(v20, "transformationMatrixLayout") & 1) != 0) {
                -[MTLAccelerationStructureCurveGeometryDescriptor setTransformationMatrixLayout:]( v20,  "setTransformationMatrixLayout:",  *(unsigned __int8 *)(v130 + 105));
              }

              id v9 = &CACurrentMediaTime_ptr;
              uint64_t v10 = v137;
              break;
            case 4:
              uint64_t v131 = v10 + 136 * v7;
              uint64_t v138 = v10;
              unsigned __int8 v48 = v12;
              uint64_t v133 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor);
              unsigned __int8 v49 = v9;
              unint64_t v50 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(void *)(v131 + 48));
              if (*(void *)(v131 + 48))
              {
                uint64_t v51 = 0LL;
                unint64_t v52 = 0LL;
                unint64_t v53 = (void *)(v131 + 40);
                do
                {
                  id v54 = objc_alloc_init((Class)v49[201]);
                  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(*v53 + v51)]);
                  uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([v48 objectForKeyedSubscript:v55]);
                  [v54 setBuffer:v56];

                  uint64_t v8 = &CACurrentMediaTime_ptr;
                  [v54 setOffset:*(void *)(*v53 + v51 + 8)];
                  -[NSMutableArray addObject:](v50, "addObject:", v54);

                  ++v52;
                  v51 += 16LL;
                }

                while (*(void *)(v131 + 48) > v52);
              }

              id v57 = -[NSMutableArray copy](v50, "copy");
              -[MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor setBoundingBoxBuffers:]( v133,  "setBoundingBoxBuffers:",  v57);

              size_t v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v133;
              uint64_t v10 = v138;
              uint64_t v58 = v138 + 136 * v7;
              -[MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor setBoundingBoxStride:]( v133,  "setBoundingBoxStride:",  *(void *)(v58 + 64));
              -[MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor setBoundingBoxCount:]( v133,  "setBoundingBoxCount:",  *(void *)(v58 + 56));

              a1 = v129;
              id v9 = v49;
              goto LABEL_38;
            case 5:
              uint64_t v59 = v10 + 136 * v7;
              unsigned int v60 = v12;
              size_t v20 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureCurveGeometryDescriptor);
              id v61 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(v59 + 40)]);
              uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([v60 objectForKeyedSubscript:v61]);
              -[MTLAccelerationStructureCurveGeometryDescriptor setControlPointBuffer:]( v20,  "setControlPointBuffer:",  v62);

              -[MTLAccelerationStructureCurveGeometryDescriptor setControlPointBufferOffset:]( v20,  "setControlPointBufferOffset:",  *(void *)(v59 + 48));
              uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v59 + 88)));
              uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v60 objectForKeyedSubscript:v63]);
              -[MTLAccelerationStructureCurveGeometryDescriptor setRadiusBuffer:](v20, "setRadiusBuffer:", v64);

              -[MTLAccelerationStructureCurveGeometryDescriptor setRadiusBufferOffset:]( v20,  "setRadiusBufferOffset:",  *(void *)(v59 + 96));
              -[MTLAccelerationStructureCurveGeometryDescriptor setControlPointCount:]( v20,  "setControlPointCount:",  *(void *)(v59 + 56));
              -[MTLAccelerationStructureCurveGeometryDescriptor setControlPointStride:]( v20,  "setControlPointStride:",  *(void *)(v59 + 64));
              -[MTLAccelerationStructureCurveGeometryDescriptor setRadiusStride:]( v20,  "setRadiusStride:",  *(void *)(v59 + 104));
              int v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v59 + 72)));
              uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v60 objectForKeyedSubscript:v65]);
              -[MTLAccelerationStructureCurveGeometryDescriptor setIndexBuffer:](v20, "setIndexBuffer:", v66);

              uint64_t v8 = &CACurrentMediaTime_ptr;
              uint64_t v11 = v59;
              -[MTLAccelerationStructureCurveGeometryDescriptor setIndexBufferOffset:]( v20,  "setIndexBufferOffset:",  *(void *)(v59 + 80));
              -[MTLAccelerationStructureCurveGeometryDescriptor setSegmentCount:]( v20,  "setSegmentCount:",  *(void *)(v59 + 120));
              -[MTLAccelerationStructureCurveGeometryDescriptor setSegmentControlPointCount:]( v20,  "setSegmentControlPointCount:",  *(void *)(v59 + 112));
              -[MTLAccelerationStructureCurveGeometryDescriptor setControlPointFormat:]( v20,  "setControlPointFormat:",  *(unsigned __int8 *)(v59 + 128));
              -[MTLAccelerationStructureCurveGeometryDescriptor setRadiusFormat:]( v20,  "setRadiusFormat:",  *(unsigned __int8 *)(v59 + 133));
              -[MTLAccelerationStructureCurveGeometryDescriptor setIndexType:]( v20,  "setIndexType:",  *(unsigned __int8 *)(v59 + 132));
              -[MTLAccelerationStructureCurveGeometryDescriptor setCurveType:]( v20,  "setCurveType:",  *(unsigned __int8 *)(v59 + 130));
              -[MTLAccelerationStructureCurveGeometryDescriptor setCurveBasis:]( v20,  "setCurveBasis:",  *(unsigned __int8 *)(v59 + 129));
              uint64_t v67 = *(unsigned __int8 *)(v59 + 131);
              id v9 = &CACurrentMediaTime_ptr;
              -[MTLAccelerationStructureCurveGeometryDescriptor setEndCaps:](v20, "setEndCaps:", v67);
              break;
            case 6:
              uint64_t v131 = v10 + 136 * v7;
              unint64_t v142 = v7;
              uint64_t v139 = v10;
              uint64_t v68 = v12;
              uint64_t v134 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureMotionCurveGeometryDescriptor);
              __int128 v69 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(void *)(v131 + 48));
              if (*(void *)(v131 + 48))
              {
                uint64_t v70 = 0LL;
                unint64_t v71 = 0LL;
                __int128 v72 = (void *)(v131 + 40);
                do
                {
                  id v73 = objc_alloc_init((Class)v9[201]);
                  int v74 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(*v72 + v70)]);
                  uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:v74]);
                  [v73 setBuffer:v75];

                  uint64_t v8 = &CACurrentMediaTime_ptr;
                  [v73 setOffset:*(void *)(*v72 + v70 + 8)];
                  -[NSMutableArray addObject:](v69, "addObject:", v73);

                  ++v71;
                  v70 += 16LL;
                }

                while (*(void *)(v131 + 48) > v71);
              }

              uint64_t v128 = v69;
              uint64_t v76 = objc_alloc(&OBJC_CLASS___NSMutableArray);
              uint64_t v77 = v139 + 136 * v7;
              uint64_t v79 = *(void *)(v77 + 96);
              uint64_t v78 = (unint64_t *)(v77 + 96);
              uint64_t v80 = -[NSMutableArray initWithCapacity:](v76, "initWithCapacity:", v79);
              if (*v78)
              {
                uint64_t v81 = 0LL;
                unint64_t v82 = 0LL;
                __int128 v83 = (void *)(v139 + 136 * v142 + 88);
                do
                {
                  id v84 = objc_alloc_init((Class)v9[201]);
                  __int16 v85 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(*v83 + v81)]);
                  int v86 = (void *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:v85]);
                  [v84 setBuffer:v86];

                  uint64_t v8 = &CACurrentMediaTime_ptr;
                  [v84 setOffset:*(void *)(*v83 + v81 + 8)];
                  -[NSMutableArray addObject:](v80, "addObject:", v84);

                  ++v82;
                  v81 += 16LL;
                }

                while (*v78 > v82);
              }

              id v87 = -[NSMutableArray copy](v128, "copy");
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setControlPointBuffers:]( v134,  "setControlPointBuffers:",  v87);

              id v88 = -[NSMutableArray copy](v80, "copy");
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setRadiusBuffers:](v134, "setRadiusBuffers:", v88);

              uint64_t v89 = v139 + 136 * v142;
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setControlPointCount:]( v134,  "setControlPointCount:",  *(void *)(v89 + 56));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setControlPointStride:]( v134,  "setControlPointStride:",  *(void *)(v89 + 64));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setRadiusStride:]( v134,  "setRadiusStride:",  *(void *)(v89 + 104));
              uint64_t v90 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(v89 + 72)]);
              uint64_t v91 = v68;
              uint64_t v10 = v139;
              id v92 = (void *)objc_claimAutoreleasedReturnValue([v91 objectForKeyedSubscript:v90]);
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setIndexBuffer:](v134, "setIndexBuffer:", v92);

              uint64_t v8 = &CACurrentMediaTime_ptr;
              size_t v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v134;
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setIndexBufferOffset:]( v134,  "setIndexBufferOffset:",  *(void *)(v89 + 80));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setSegmentCount:]( v134,  "setSegmentCount:",  *(void *)(v89 + 120));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setControlPointFormat:]( v134,  "setControlPointFormat:",  *(unsigned __int8 *)(v89 + 128));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setRadiusFormat:]( v134,  "setRadiusFormat:",  *(unsigned __int8 *)(v89 + 133));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setIndexType:]( v134,  "setIndexType:",  *(unsigned __int8 *)(v89 + 132));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setSegmentControlPointCount:]( v134,  "setSegmentControlPointCount:",  *(void *)(v89 + 112));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setCurveType:]( v134,  "setCurveType:",  *(unsigned __int8 *)(v89 + 130));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setCurveBasis:]( v134,  "setCurveBasis:",  *(unsigned __int8 *)(v89 + 129));
              uint64_t v93 = *(unsigned __int8 *)(v89 + 131);
              unint64_t v7 = v142;
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setEndCaps:](v134, "setEndCaps:", v93);

              a1 = v129;
LABEL_38:
              uint64_t v11 = v131;
              break;
            default:
              size_t v20 = 0LL;
              break;
          }

          uint64_t v94 = v10 + 136 * v7;
          -[MTLAccelerationStructureCurveGeometryDescriptor setIntersectionFunctionTableOffset:]( v20,  "setIntersectionFunctionTableOffset:",  *(unsigned int *)(v94 + 32));
          -[MTLAccelerationStructureCurveGeometryDescriptor setOpaque:](v20, "setOpaque:", *(_BYTE *)(v94 + 37) != 0);
          -[MTLAccelerationStructureCurveGeometryDescriptor setAllowDuplicateIntersectionFunctionInvocation:]( v20,  "setAllowDuplicateIntersectionFunctionInvocation:",  *(_BYTE *)(v94 + 38) != 0);
          if (*(void *)v11)
          {
            unint64_t v95 = v20;
            unint64_t v96 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
            -[MTLAccelerationStructureCurveGeometryDescriptor setLabel:](v95, "setLabel:", v96);

            size_t v20 = v95;
          }

          if ((objc_opt_respondsToSelector(v20, "primitiveDataBuffer") & 1) != 0)
          {
            uint64_t v97 = v10 + 136 * v7;
            __int128 v98 = v20;
            uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue([v8[238] numberWithUnsignedLongLong:*(void *)(v97 + 8)]);
            unint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([v143 objectForKeyedSubscript:v99]);
            -[MTLAccelerationStructureCurveGeometryDescriptor setPrimitiveDataBuffer:]( v98,  "setPrimitiveDataBuffer:",  v100);

            uint64_t v8 = &CACurrentMediaTime_ptr;
            size_t v20 = v98;
            -[MTLAccelerationStructureCurveGeometryDescriptor setPrimitiveDataBufferOffset:]( v98,  "setPrimitiveDataBufferOffset:",  *(void *)(v97 + 16));
            -[MTLAccelerationStructureCurveGeometryDescriptor setPrimitiveDataStride:]( v98,  "setPrimitiveDataStride:",  *(unsigned int *)(v97 + 24));
            -[MTLAccelerationStructureCurveGeometryDescriptor setPrimitiveDataElementSize:]( v98,  "setPrimitiveDataElementSize:",  *(unsigned int *)(v97 + 28));
          }

          -[NSMutableArray addObject:](v135, "addObject:", v20);
          ++v7;
        }

        while (*((void *)a1 + 2) > v7);
      }

      unint64_t v101 = v126;
      -[MTLPrimitiveAccelerationStructureDescriptor setGeometryDescriptors:](v126, "setGeometryDescriptors:", v135);
      LODWORD(v102) = *((_DWORD *)a1 + 8);
      -[MTLPrimitiveAccelerationStructureDescriptor setMotionStartTime:](v126, "setMotionStartTime:", v102);
      LODWORD(v103) = *((_DWORD *)a1 + 6);
      -[MTLPrimitiveAccelerationStructureDescriptor setMotionEndTime:](v126, "setMotionEndTime:", v103);
      -[MTLPrimitiveAccelerationStructureDescriptor setMotionKeyframeCount:]( v126,  "setMotionKeyframeCount:",  *((unsigned int *)a1 + 7));
      -[MTLPrimitiveAccelerationStructureDescriptor setMotionStartBorderMode:]( v126,  "setMotionStartBorderMode:",  a1[37]);
      -[MTLPrimitiveAccelerationStructureDescriptor setMotionEndBorderMode:](v126, "setMotionEndBorderMode:", a1[36]);

      uint64_t v4 = v127;
      break;
    default:
      unint64_t v101 = 0LL;
      break;
  }

  return v101;
}

MTLIntersectionFunctionDescriptor *MakeMTLIntersectionFunctionDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLIntersectionFunctionDescriptor);
  -[MTLIntersectionFunctionDescriptor setOptions:](v4, "setOptions:", *(unsigned __int8 *)(a1 + 40));
  if (*(void *)(a1 + 8))
  {
    int v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLIntersectionFunctionDescriptor setName:](v4, "setName:", v5);
  }

  if (*(void *)(a1 + 32))
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLIntersectionFunctionDescriptor setSpecializedName:](v4, "setSpecializedName:", v6);
  }

  if (*(void *)a1)
  {
    MTLFunctionConstantValues = MakeMTLFunctionConstantValues(*(void **)a1);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionConstantValues);
    -[MTLIntersectionFunctionDescriptor setConstantValues:](v4, "setConstantValues:", v8);
  }

  if (*(void *)(a1 + 24) && (objc_opt_respondsToSelector(v4, "privateFunctions") & 1) != 0)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 16), *(_DWORD *)(a1 + 24), v3);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLIntersectionFunctionDescriptor setPrivateFunctions:](v4, "setPrivateFunctions:", v10);
  }

  return v4;
}

void TranslateGTMTLStitchedLibraryDescriptor(void *a1, void *a2, uint64_t a3)
{
  id v17 = a1;
  unsigned __int8 v5 = [v17 options];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v17 functionGraphs]);
  unsigned __int16 v7 = (unsigned __int16)[v6 count];

  if (v7) {
    uint64_t v8 = a2[45];
  }
  else {
    uint64_t v8 = 0LL;
  }
  apr_pool_create_ex(&newpool, 0LL, 0LL, 0LL);
  id v9 = newpool;
  uint64_t v10 = (apr_pool_t **)apr_hash_make(newpool);
  uint64_t v18 = 1LL;
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v17 functionGraphs]);
  CopyFunctionStitchingGraph(v11, v10, (const void **)&v18, a2, a3);

  id v12 = (void *)objc_claimAutoreleasedReturnValue([v17 functions]);
  unsigned __int16 v13 = (unsigned __int16)[v12 count];

  if (!v13)
  {
    uint64_t v15 = 0LL;
    if (!(_DWORD)a3) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  id v14 = (void *)objc_claimAutoreleasedReturnValue([v17 functions]);
  uint64_t v15 = TranslateNSArray(v14, (uint64_t)a2, a3);

  if ((_DWORD)a3)
  {
LABEL_6:
    uint64_t v16 = a2[33];
    *(void *)uint64_t v16 = v8;
    *(void *)(v16 + _Block_object_dispose(va, 8) = v15;
    *(_WORD *)(v16 + 16) = v7;
    *(_WORD *)(v16 + 1_Block_object_dispose(va, 8) = v13;
    *(_BYTE *)(v16 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v5;
    *(_WORD *)(v16 + 21) = 0;
    *(_BYTE *)(v16 + 23) = 0;
  }

void sub_85064(_Unwind_Exception *a1)
{
}

void CopyFunctionStitchingGraph(void *a1, apr_pool_t **a2, const void **a3, void *a4, uint64_t a5)
{
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  obuint64_t j = a1;
  id v44 = [obj countByEnumeratingWithState:&v60 objects:v65 count:16];
  if (v44)
  {
    uint64_t v41 = *(void *)v61;
    uint64_t v42 = a2;
    id v43 = a3;
    do
    {
      uint64_t v9 = 0LL;
      do
      {
        if (*(void *)v61 != v41) {
          objc_enumerationMutation(obj);
        }
        uint64_t v10 = *(void **)(*((void *)&v60 + 1) + 8 * v9);
        char v59 = 0;
        __int16 v58 = 0;
        id v11 = v10;
        uint64_t v52 = v9;
        if (objc_msgSend( v11,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingGraphSPI, v12))) {
          unsigned __int8 v50 = 2;
        }
        else {
          unsigned __int8 v50 = objc_msgSend( v11,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingGraph, v13));
        }

        id v14 = objc_claimAutoreleasedReturnValue([v11 functionName]);
        uint64_t v15 = (const char *)[v14 UTF8String];
        uint64_t v16 = v15;
        if (v15)
        {
          size_t v17 = strlen(v15);
          uint64_t v18 = a4[52];
          size_t v19 = v17 + 1;
          if (v17 != -1LL)
          {
            __dst = (void *)a4[52];
            goto LABEL_14;
          }
        }

        else
        {
          uint64_t v18 = a4[52];
        }

        size_t v19 = 0LL;
        __dst = 0LL;
LABEL_14:
        a4[52] = v18 + v19;
        if ((_DWORD)a5) {
          memcpy(__dst, v16, v19);
        }

        size_t v20 = (void *)objc_claimAutoreleasedReturnValue([v11 nodes]);
        unsigned __int16 v21 = (unsigned __int16)[v20 count];

        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v11 nodes]);
        uint64_t v48 = CopyFunctionStitchingFunctionNodeArray(v22, a2, a3, (uint64_t)a4, a5);

        size_t v23 = (void *)objc_claimAutoreleasedReturnValue([v11 outputNode]);
        if (v23)
        {
          size_t v24 = (void *)objc_claimAutoreleasedReturnValue([v11 outputNode]);
          CopyFunctionStitchingFunctionNode((uint64_t)v57, v24, a2, a3, (uint64_t)a4, a5);

          if ((_DWORD)a5)
          {
            uint64_t v25 = (_OWORD *)a4[46];
            __int128 v26 = v57[1];
            *uint64_t v25 = v57[0];
            v25[1] = v26;
            v25[2] = v57[2];
          }

          uint64_t v47 = a4[46];
          a4[46] = v47 + 48;
        }

        else
        {
          uint64_t v47 = 0LL;
        }

        id v27 = (void *)objc_claimAutoreleasedReturnValue([v11 attributes]);
        unsigned __int16 v28 = (unsigned __int16)[v27 count];

        unsigned __int16 v49 = v21;
        unsigned __int16 v46 = v28;
        if (v28) {
          uint64_t v45 = a4[47];
        }
        else {
          uint64_t v45 = 0LL;
        }
        __int128 v55 = 0u;
        __int128 v56 = 0u;
        __int128 v53 = 0u;
        __int128 v54 = 0u;
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v11 attributes]);
        id v30 = [v29 countByEnumeratingWithState:&v53 objects:v64 count:16];
        if (v30)
        {
          id v31 = v30;
          uint64_t v32 = *(void *)v54;
          do
          {
            for (unint64_t i = 0LL; i != v31; unint64_t i = (char *)i + 1)
            {
              if (*(void *)v54 != v32) {
                objc_enumerationMutation(v29);
              }
              if ((a5 & 1) != 0)
              {
                id v34 = *(id *)(*((void *)&v53 + 1) + 8LL * (void)i);
                if (objc_msgSend( v34,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingAttributeAlwaysInline, v35)))
                {
                  char v37 = 1;
                }

                else if (objc_msgSend( v34,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingAttributeKernel, v36)))
                {
                  char v37 = 2;
                }

                else
                {
                  char v37 = 0;
                }

                id v38 = (_BYTE *)a4[47];
                *v38 += v37;
              }

              else
              {
                id v38 = (_BYTE *)a4[47];
              }

              a4[47] = v38 + 8;
            }

            id v31 = [v29 countByEnumeratingWithState:&v53 objects:v64 count:16];
          }

          while (v31);
        }

        if ((_DWORD)a5)
        {
          uint64_t v39 = a4[45];
          *(void *)uint64_t v39 = __dst;
          *(void *)(v39 + _Block_object_dispose(va, 8) = v48;
          *(void *)(v39 + 16) = v47;
          *(void *)(v39 + 24) = v45;
          *(_WORD *)(v39 + 32) = v49;
          *(_WORD *)(v39 + 34) = v46;
          *(_BYTE *)(v39 + 36) = v50;
          *(_WORD *)(v39 + 37) = v58;
          *(_BYTE *)(v39 + 39) = v59;
        }

        a4[45] += 40LL;
        uint64_t v9 = v52 + 1;
        a3 = v43;
        a2 = v42;
      }

      while ((id)(v52 + 1) != v44);
      id v44 = [obj countByEnumeratingWithState:&v60 objects:v65 count:16];
    }

    while (v44);
  }
}

uint64_t CopyFunctionStitchingFunctionNodeArray( void *a1, apr_pool_t **a2, const void **a3, uint64_t a4, uint64_t a5)
{
  id v9 = a1;
  id v10 = [v9 count];
  if (v10) {
    uint64_t v11 = *(void *)(a4 + 368);
  }
  else {
    uint64_t v11 = 0LL;
  }
  *(void *)(a4 + 368) += 48LL * (void)v10;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  id v12 = v9;
  id v13 = [v12 countByEnumeratingWithState:&v22 objects:v26 count:16];
  if (v13)
  {
    id v14 = v13;
    int v15 = 0;
    uint64_t v16 = *(void *)v23;
    do
    {
      for (unint64_t i = 0LL; i != v14; unint64_t i = (char *)i + 1)
      {
        if (*(void *)v23 != v16) {
          objc_enumerationMutation(v12);
        }
        CopyFunctionStitchingFunctionNode( (uint64_t)v21,  *(void **)(*((void *)&v22 + 1) + 8LL * (void)i),  a2,  a3,  a4,  a5);
        if ((_DWORD)a5)
        {
          uint64_t v18 = (_OWORD *)(v11 + 48LL * v15++);
          __int128 v19 = v21[1];
          *uint64_t v18 = v21[0];
          v18[1] = v19;
          v18[2] = v21[2];
        }
      }

      id v14 = [v12 countByEnumeratingWithState:&v22 objects:v26 count:16];
    }

    while (v14);
  }

  return v11;
}

void CopyFunctionStitchingFunctionNode( uint64_t a1, void *a2, apr_pool_t **a3, const void **a4, uint64_t a5, uint64_t a6)
{
  id v9 = a2;
  id v56 = v9;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  unsigned __int8 MTLFunctionStitchingNodeType = GetMTLFunctionStitchingNodeType(v9);
  *(_BYTE *)a1 = MTLFunctionStitchingNodeType;
  id v10 = objc_claimAutoreleasedReturnValue([v9 name]);
  uint64_t v11 = (const char *)[v10 UTF8String];
  id v12 = v11;
  if (v11)
  {
    size_t v13 = strlen(v11);
    id v14 = (void *)(a5 + 416);
    uint64_t v15 = *(void *)(a5 + 416);
    size_t v16 = v13 + 1;
    if (v13 != -1LL)
    {
      size_t v17 = *(void **)(a5 + 416);
      goto LABEL_6;
    }
  }

  else
  {
    id v14 = (void *)(a5 + 416);
    uint64_t v15 = *(void *)(a5 + 416);
  }

  size_t v16 = 0LL;
  size_t v17 = 0LL;
LABEL_6:
  void *v14 = v15 + v16;
  if ((_DWORD)a6) {
    memcpy(v17, v12, v16);
  }
  uint64_t v50 = a1;
  *(void *)(a1 + _Block_object_dispose(va, 8) = v17;

  unsigned __int16 v49 = v9;
  id v18 = (id)objc_claimAutoreleasedReturnValue([v9 arguments]);
  id v19 = [v18 count];
  if (v19) {
    uint64_t v20 = *(void *)(a5 + 368);
  }
  else {
    uint64_t v20 = 0LL;
  }
  uint64_t v54 = v20;
  uint64_t v52 = a5;
  *(void *)(a5 + 368) += 48LL * (void)v19;
  __int128 v67 = 0u;
  __int128 v68 = 0u;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  obuint64_t j = v18;
  id v21 = [obj countByEnumeratingWithState:&v67 objects:v71 count:16];
  __int128 v22 = a4;
  if (v21)
  {
    id v23 = v21;
    int v24 = 0;
    uint64_t v25 = *(void *)v68;
LABEL_13:
    uint64_t v26 = 0LL;
    while (2)
    {
      if (*(void *)v68 != v25) {
        objc_enumerationMutation(obj);
      }
      id v27 = *(void **)(*((void *)&v67 + 1) + 8 * v26);
      v66[0] = 0;
      *(_DWORD *)((char *)v66 + 3) = 0;
      __int128 v64 = 0u;
      __int128 v65 = 0u;
      unsigned int v28 = GetMTLFunctionStitchingNodeType(v27);
      char v29 = v28;
      char v30 = 0;
      unsigned int v31 = v28 - 1;
      unsigned __int8 v32 = 0;
      unsigned __int16 v33 = 0;
      unsigned int v34 = 0;
      switch(v31)
      {
        case 0u:
        case 1u:
        case 0xBu:
          CopyFunctionStitchingFunctionNode(&v57, v27, a3, v22, v52, a6);
          char v29 = v57;
          v66[0] = *(_DWORD *)v58;
          *(_DWORD *)((char *)v66 + 3) = *(_DWORD *)&v58[3];
          unsigned int v34 = *(_DWORD *)&v58[7];
          unsigned __int16 v33 = v59;
          unsigned __int8 v32 = v60;
          char v30 = v61;
          __int128 v64 = v62;
          __int128 v65 = v63;
          if ((_DWORD)a6) {
            goto LABEL_25;
          }
          goto LABEL_26;
        case 2u:
          unsigned __int16 v33 = (unsigned __int16)[v27 argumentIndex];
          char v30 = 0;
          unsigned __int8 v32 = 0;
          unsigned int v34 = 0;
          char v29 = 3;
          goto LABEL_24;
        case 3u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
          unsigned __int16 v33 = (unsigned __int16)[v27 bindIndex];
          char v30 = 0;
          unsigned __int8 v32 = 0;
          unsigned int v34 = 0;
          if (!(_DWORD)a6) {
            goto LABEL_26;
          }
          goto LABEL_25;
        case 4u:
          id v35 = v27;
          unsigned int v34 = [v35 byteOffset];
          unsigned __int16 v36 = (unsigned __int16)[v35 bindIndex];
          unsigned __int8 v32 = [v35 dereference];

          char v30 = 0;
          char v29 = 5;
          unsigned __int16 v33 = v36;
          __int128 v22 = a4;
          if (!(_DWORD)a6) {
            goto LABEL_26;
          }
          goto LABEL_25;
        case 9u:
        case 0xAu:
LABEL_24:
          if ((_DWORD)a6) {
            goto LABEL_25;
          }
          goto LABEL_26;
        default:
          unsigned __int8 v32 = 0;
          unsigned __int16 v33 = 0;
          unsigned int v34 = 0;
          if (!(_DWORD)a6) {
            goto LABEL_26;
          }
LABEL_25:
          uint64_t v37 = v54 + 48LL * v24;
          *(_BYTE *)uint64_t v37 = v29;
          ++v24;
          *(_DWORD *)(v37 + 1) = v66[0];
          *(_DWORD *)(v37 + 4) = *(_DWORD *)((char *)v66 + 3);
          *(_DWORD *)(v37 + _Block_object_dispose(va, 8) = v34;
          *(_WORD *)(v37 + 12) = v33;
          *(_BYTE *)(v37 + 14) = v32;
          *(_BYTE *)(v37 + 15) = v30;
          __int128 v38 = v65;
          *(_OWORD *)(v37 + 16) = v64;
          *(_OWORD *)(v37 + 32) = v38;
LABEL_26:
          if (v23 != (id)++v26) {
            continue;
          }
          id v39 = [obj countByEnumeratingWithState:&v67 objects:v71 count:16];
          id v23 = v39;
          if (!v39) {
            goto LABEL_31;
          }
          goto LABEL_13;
      }
    }
  }

id GetMTLFunctionStitchingNodeType(void *a1)
{
  id v1 = a1;
  if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingBuiltinThreadPositionInThreadgroup, v2)))
  {
    id v4 = &dword_8 + 3;
  }

  else if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingBuiltinThreadPositionInGrid, v3)))
  {
    id v4 = &dword_8 + 2;
  }

  else if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingInputImageblock, v5)))
  {
    id v4 = &dword_8 + 1;
  }

  else if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingInputThreadgroup, v6)))
  {
    id v4 = &dword_8;
  }

  else if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingInputSampler, v7)))
  {
    id v4 = &dword_4 + 3;
  }

  else if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingInputTexture, v8)))
  {
    id v4 = &dword_4 + 2;
  }

  else if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingInputBufferAddress, v9)))
  {
    id v4 = &dword_4 + 1;
  }

  else if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingInputBuffer, v10)))
  {
    id v4 = &dword_4;
  }

  else if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingInputNode, v11)))
  {
    id v4 = &dword_0 + 3;
  }

  else if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingFunctionNodeSPI, v12)))
  {
    id v4 = &dword_0 + 2;
  }

  else if (objc_msgSend( v1,  "isMemberOfClass:",  objc_opt_class(MTLFunctionStitchingEarlyReturnNode, v13)))
  {
    id v4 = &dword_C;
  }

  else
  {
    id v4 = objc_msgSend(v1, "isMemberOfClass:", objc_opt_class(MTLFunctionStitchingFunctionNode, v14));
  }

  return v4;
}

void TranslateGTMTLStitchedLibraryDescriptorSPI(void *a1, void *a2, uint64_t a3)
{
  id v17 = a1;
  unsigned __int8 v5 = [v17 options];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v17 functionGraphs]);
  unsigned __int16 v7 = (unsigned __int16)[v6 count];

  if (v7) {
    uint64_t v8 = a2[45];
  }
  else {
    uint64_t v8 = 0LL;
  }
  apr_pool_create_ex(&newpool, 0LL, 0LL, 0LL);
  uint64_t v9 = newpool;
  uint64_t v10 = (apr_pool_t **)apr_hash_make(newpool);
  uint64_t v18 = 1LL;
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v17 functionGraphs]);
  CopyFunctionStitchingGraph(v11, v10, (const void **)&v18, a2, a3);

  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v17 functions]);
  unsigned __int16 v13 = (unsigned __int16)[v12 count];

  if (!v13)
  {
    uint64_t v15 = 0LL;
    if (!(_DWORD)a3) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v17 functions]);
  uint64_t v15 = TranslateNSArray(v14, (uint64_t)a2, a3);

  if ((_DWORD)a3)
  {
LABEL_6:
    uint64_t v16 = a2[33];
    *(void *)uint64_t v16 = v8;
    *(void *)(v16 + _Block_object_dispose(va, 8) = v15;
    *(_WORD *)(v16 + 16) = v7;
    *(_WORD *)(v16 + 1_Block_object_dispose(va, 8) = v13;
    *(_BYTE *)(v16 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v5;
    *(_WORD *)(v16 + 21) = 0;
    *(_BYTE *)(v16 + 23) = 0;
  }

void sub_85DCC(_Unwind_Exception *a1)
{
}

MTLStitchedLibraryDescriptor *MakeMTLStitchedLibraryDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLStitchedLibraryDescriptor);
  -[MTLStitchedLibraryDescriptor setOptions:](v4, "setOptions:", *(unsigned __int8 *)(a1 + 20));
  id MTLFunctionStitchingGraphArray = MakeMTLFunctionStitchingGraphArray(*(void *)a1, *(unsigned __int16 *)(a1 + 16));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionStitchingGraphArray);
  -[MTLStitchedLibraryDescriptor setFunctionGraphs:](v4, "setFunctionGraphs:", v6);

  id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 8), *(unsigned __int16 *)(a1 + 18), v3);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);

  -[MTLStitchedLibraryDescriptor setFunctions:](v4, "setFunctions:", v8);
  return v4;
}

id MakeMTLFunctionStitchingGraphArray(uint64_t a1, int a2)
{
  uint64_t v32 = a2;
  char v30 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:");
  unsigned __int16 v33 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  if (a2 >= 1)
  {
    uint64_t v4 = 0LL;
    uint64_t v31 = a1;
    while (1)
    {
      uint64_t v5 = a1 + 40 * v4;
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)v5,  v30));
      id MTLFunctionStitchingFunctionNodeArray = MakeMTLFunctionStitchingFunctionNodeArray( *(unsigned __int8 **)(v5 + 8),  *(unsigned __int16 *)(v5 + 32),  v33);
      uint64_t v8 = objc_claimAutoreleasedReturnValue(MTLFunctionStitchingFunctionNodeArray);
      uint64_t v9 = (void *)v8;
      uint64_t v10 = &__NSArray0__struct;
      if (v8) {
        uint64_t v10 = (void *)v8;
      }
      id v11 = v10;

      id MTLFunctionStitchingFunctionNode = MakeMTLFunctionStitchingFunctionNode(*(unsigned __int8 **)(v5 + 16), v33);
      unsigned __int16 v13 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionStitchingFunctionNode);
      uint64_t v14 = *(unsigned __int16 *)(v5 + 34);
      if (*(_WORD *)(v5 + 34))
      {
        uint64_t v15 = *(unsigned __int8 **)(v5 + 24);
        uint64_t v16 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v14);
        while (1)
        {
          int v18 = *v15;
          v15 += 8;
          int v17 = v18;
          if (v18 == 1) {
            break;
          }
          if (v17 == 2)
          {
            id v19 = (Class *)&OBJC_CLASS___MTLFunctionStitchingAttributeKernel_ptr;
LABEL_11:
            id v20 = objc_alloc_init(*v19);
            -[NSMutableArray addObject:](v16, "addObject:", v20);
          }

          if (!--v14)
          {
            id v21 = -[NSMutableArray copy](v16, "copy");

            goto LABEL_15;
          }
        }

        id v19 = (Class *)&OBJC_CLASS___MTLFunctionStitchingAttributeAlwaysInline_ptr;
        goto LABEL_11;
      }

      id v21 = 0LL;
LABEL_15:
      a1 = v31;
      __int128 v22 = &__NSArray0__struct;
      if (v21) {
        __int128 v22 = v21;
      }
      id v23 = v22;

      int v24 = *(unsigned __int8 *)(v31 + 40 * v4 + 36);
      if (v24 == 2) {
        break;
      }
      if (v24 == 1)
      {
        uint64_t v25 = (Class *)&OBJC_CLASS___MTLFunctionStitchingGraph_ptr;
LABEL_21:
        id v26 = [objc_alloc(*v25) initWithFunctionName:v6 nodes:v11 outputNode:v13 attributes:v23];
        -[NSMutableArray addObject:](v30, "addObject:", v26);
      }

      if (++v4 == v32) {
        goto LABEL_23;
      }
    }

    uint64_t v25 = (Class *)&OBJC_CLASS___MTLFunctionStitchingGraphSPI_ptr;
    goto LABEL_21;
  }

id MakeMTLFunctionStitchingFunctionNodeArray(unsigned __int8 *a1, unsigned int a2, void *a3)
{
  id v5 = a3;
  if (a2)
  {
    uint64_t v6 = a2;
    unsigned __int16 v7 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", a2);
    do
    {
      id MTLFunctionStitchingFunctionNode = MakeMTLFunctionStitchingFunctionNode(a1, v5);
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionStitchingFunctionNode);
      -[NSMutableArray addObject:](v7, "addObject:", v9);

      a1 += 48;
      --v6;
    }

    while (v6);
    id v10 = -[NSMutableArray copy](v7, "copy");
  }

  else
  {
    id v10 = 0LL;
  }

  return v10;
}

id MakeMTLFunctionStitchingFunctionNode(unsigned __int8 *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = *((void *)a1 + 4);
    if (!v4
      || (id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 4))),  v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v5]),  v5,  !v6))
    {
      unsigned __int16 v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *((void *)a1 + 1)));
      uint64_t v8 = *((void *)a1 + 2);
      uint64_t v9 = (char *)*((unsigned __int16 *)a1 + 20);
      id v10 = v3;
      if (v9)
      {
        id v11 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v9);
        do
        {
          switch(*(_BYTE *)v8)
          {
            case 1:
            case 2:
            case 0xC:
              uint64_t MTLFunctionStitchingFunctionNode = MakeMTLFunctionStitchingFunctionNode(v8, v10);
              unsigned __int16 v13 = (MTLFunctionStitchingInputNode *)objc_claimAutoreleasedReturnValue(MTLFunctionStitchingFunctionNode);
              goto LABEL_19;
            case 3:
              unsigned __int16 v13 = -[MTLFunctionStitchingInputNode initWithArgumentIndex:]( objc_alloc(&OBJC_CLASS___MTLFunctionStitchingInputNode),  "initWithArgumentIndex:",  *(unsigned __int16 *)(v8 + 12));
              goto LABEL_19;
            case 4:
              uint64_t v14 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingInputBuffer;
              goto LABEL_15;
            case 5:
              unsigned __int16 v13 = (MTLFunctionStitchingInputNode *)[[MTLFunctionStitchingInputBufferAddress alloc] initWithBindIndex:*(unsigned __int16 *)(v8 + 12) byteOffset:*(unsigned int *)(v8 + 8) dereference:*(_BYTE *)(v8 + 14) != 0];
              goto LABEL_19;
            case 6:
              uint64_t v14 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingInputTexture;
              goto LABEL_15;
            case 7:
              uint64_t v14 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingInputSampler;
              goto LABEL_15;
            case 8:
              uint64_t v14 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingInputThreadgroup;
              goto LABEL_15;
            case 9:
              uint64_t v14 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingInputImageblock;
LABEL_15:
              unsigned __int16 v13 = (MTLFunctionStitchingInputNode *)[[v14 alloc] initWithBindIndex:*(unsigned __int16 *)(v8 + 12)];
              goto LABEL_19;
            case 0xA:
              uint64_t v15 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingBuiltinThreadPositionInGrid;
              goto LABEL_18;
            case 0xB:
              uint64_t v15 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingBuiltinThreadPositionInThreadgroup;
LABEL_18:
              unsigned __int16 v13 = (MTLFunctionStitchingInputNode *)objc_alloc_init(v15);
LABEL_19:
              uint64_t v16 = v13;
              -[NSMutableArray addObject:](v11, "addObject:", v13);

              break;
            default:
              break;
          }

          v8 += 48LL;
          --v9;
        }

        while (v9);
        uint64_t v9 = (char *)-[NSMutableArray copy](v11, "copy");
      }

      if (v9) {
        int v17 = v9;
      }
      else {
        int v17 = (char *)&__NSArray0__struct;
      }
      int v18 = v17;

      uint64_t MTLFunctionStitchingFunctionNodeArray = MakeMTLFunctionStitchingFunctionNodeArray( *((void *)a1 + 3),  *((unsigned __int16 *)a1 + 21),  v10);
      uint64_t v20 = objc_claimAutoreleasedReturnValue(MTLFunctionStitchingFunctionNodeArray);
      id v21 = (void *)v20;
      if (v20) {
        __int128 v22 = (void *)v20;
      }
      else {
        __int128 v22 = &__NSArray0__struct;
      }
      id v23 = v22;

      int v24 = *a1;
      switch(v24)
      {
        case 1:
          id v26 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingFunctionNode;
          break;
        case 12:
          id v26 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingEarlyReturnNode;
          break;
        case 2:
          id v25 = [[MTLFunctionStitchingFunctionNodeSPI alloc] initWithName:v7 arguments:v18 controlDependencies:v23 isEarlyReturn:a1[44] != 0];
LABEL_36:
          uint64_t v6 = v25;
          if (v4)
          {
            id v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v4));
            [v10 setObject:v6 forKeyedSubscript:v27];
          }

          goto LABEL_39;
        default:
          uint64_t v6 = 0LL;
LABEL_39:

          goto LABEL_40;
      }

      id v25 = [[v26 alloc] initWithName:v7 arguments:v18 controlDependencies:v23];
      goto LABEL_36;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

id MakeMTLStitchedLibraryDescriptorSPI(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLStitchedLibraryDescriptorSPI);
  [v4 setOptions:*(unsigned __int8 *)(a1 + 20)];
  id MTLFunctionStitchingGraphArray = MakeMTLFunctionStitchingGraphArray(*(void *)a1, *(unsigned __int16 *)(a1 + 16));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionStitchingGraphArray);
  [v4 setFunctionGraphs:v6];

  id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 8), *(unsigned __int16 *)(a1 + 18), v3);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);

  [v4 setFunctions:v8];
  return v4;
}

id newDYDeviceInfo()
{
  id v0 = objc_alloc_init(&OBJC_CLASS___DYGTDeviceInfo);
  [v0 setPlatform:4];
  [v0 setRuntimeIdentifier:3735928559];
  if (gethostname(v41, 0x400uLL)) {
    id v1 = 0LL;
  }
  else {
    id v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v41));
  }
  [v0 setName:v1];

  uint64_t v2 = (void *)MGCopyAnswer(@"HWModelStr", 0LL);
  [v0 setProductType:v2];

  uint64_t v3 = GSSystemRootDirectory();
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue( [v4 stringByAppendingPathComponent:@"/System/Library/CoreServices/SystemVersion.plist"]);
  uint64_t v6 = -[NSDictionary initWithContentsOfFile:](objc_alloc(&OBJC_CLASS___NSDictionary), "initWithContentsOfFile:", v5);
  unsigned __int16 v7 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKey:](v6, "objectForKey:", @"ProductVersion"));
  [v0 setVersion:v7];

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKey:](v6, "objectForKey:", @"ProductBuildVersion"));
  [v0 setBuild:v8];

  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.Metal"));
  id v10 = v9;
  if (v9)
  {
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForInfoDictionaryKey:kCFBundleVersionKey]);
    [v0 setMetalVersion:v11];
  }

  else
  {
    [v0 setMetalVersion:&stru_20FCB8];
  }

  [v0 setNativePointerSize:8];
  id v12 = objc_alloc_init(&OBJC_CLASS___DYGTGPUToolsVersionInfo);
  unsigned __int16 v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.GPUTools"));
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 infoDictionary]);
  id v15 = NewPlistByAnonymizingPlist(v14);
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
  [v12 setInfoPlist:v16];

  int v17 = (void *)objc_claimAutoreleasedReturnValue([v13 URLForResource:@"version" withExtension:@"plist"]);
  if (v17)
  {
    int v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithContentsOfURL:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithContentsOfURL:",  v17));
    id v19 = NewPlistByAnonymizingPlist(v18);
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
    [v12 setVersionPlist:v20];
  }

  else
  {
    [v12 setVersionPlist:0];
  }

  [v12 setInterposeVersionGL:1572864];
  [v12 setInterposeVersionMetal:0];

  [v0 setGputoolsVersionInfo:v12];
  v40.tv_sec = 0LL;
  v40.tv_nsec = 0LL;
  if (gethostuuid((unsigned __int8 *)v41, &v40))
  {
    [v0 setPermanentIdentifier:0];
  }

  else
  {
    id v21 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v41);
    __int128 v22 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v21, "UUIDString"));
    [v0 setPermanentIdentifier:v22];
  }

  if (MGIsQuestionValid(@"main-screen-width"))
  {
    id v23 = (void *)MGCopyAnswer(@"main-screen-width", 0LL);
    unsigned int v24 = [v23 unsignedIntValue];
  }

  else
  {
    unsigned int v24 = 0;
  }

  if (MGIsQuestionValid(@"main-screen-height"))
  {
    id v25 = (void *)MGCopyAnswer(@"main-screen-height", 0LL);
    unsigned int v26 = [v25 unsignedIntValue];
  }

  else
  {
    unsigned int v26 = 0;
  }

  if (MGIsQuestionValid(@"main-screen-scale"))
  {
    id v27 = (void *)MGCopyAnswer(@"main-screen-scale", 0LL);
    unsigned int v28 = [v27 unsignedIntValue];
  }

  else
  {
    unsigned int v28 = 0;
  }

  uint64_t v29 = 0LL;
  if (MGIsQuestionValid(@"main-screen-orientation"))
  {
    char v30 = (void *)MGCopyAnswer(@"main-screen-orientation", 0LL);
    [v30 doubleValue];
    uint64_t v29 = v31;
  }

  if (MGIsQuestionValid(@"main-screen-class"))
  {
    uint64_t v32 = (void *)MGCopyAnswer(@"main-screen-class", 0LL);
    unsigned int v33 = [v32 unsignedIntValue];
  }

  else
  {
    unsigned int v33 = 0;
  }

  uint64_t v35 = v29;
  unsigned int v36 = v24;
  unsigned int v37 = v26;
  unsigned int v38 = v28;
  unsigned int v39 = v33;
  [v0 setMainScreenDescriptor:&v35];
  return v0;
}

id NewPlistByAnonymizingPlist(void *a1)
{
  id v1 = [a1 mutableCopy];
  [v1 removeObjectForKey:@"CFBundleInfoPlistURL"];
  [v1 removeObjectForKey:@"NSBundleInitialPath"];
  [v1 removeObjectForKey:@"NSBundleResolvedPath"];
  id v2 = [v1 copy];

  return v2;
}

id newProfileWithMTLDevice(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init(&OBJC_CLASS___DYGTMTLDeviceProfile);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 name]);
  [v2 setName:v3];

  id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 6LL));
  for (uint64_t i = 0LL; i != 6; ++i)
  {
    uint64_t v6 = newProfileWithMTLDevice_availableFeatures[i];
    if ([v1 supportsFeatureSet:v6])
    {
      unsigned __int16 v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", v6));
      [v4 addObject:v7];
    }
  }

  id v8 = [v4 copy];
  id v25 = v2;
  [v2 setSupportedFeatureSets:v8];

  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  if ([v1 areProgrammableSamplePositionsSupported]
    && [v1 maxCustomSamplePositions])
  {
    size_t v10 = 1LL;
    do
    {
      if ([v1 supportsTextureSampleCount:v10])
      {
        id v11 = (char *)calloc(v10, 8uLL);
        [v1 getDefaultSamplePositions:v11 count:v10];
        id v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        uint64_t v13 = 0LL;
        do
        {
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSValue valueWithPoint:]( &OBJC_CLASS___NSValue,  "valueWithPoint:",  vcvtq_f64_f32(*(float32x2_t *)&v11[8 * v13])));
          -[NSMutableArray addObject:](v12, "addObject:", v14);

          ++v13;
        }

        while (v10 != v13);
        free(v11);
        id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithArray:](&OBJC_CLASS___NSArray, "arrayWithArray:", v12));
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v10));
        [v9 setObject:v15 forKey:v16];
      }
    }

    while ((unint64_t)[v1 maxCustomSamplePositions] > v10++);
  }

  int v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithDictionary:](&OBJC_CLASS___NSDictionary, "dictionaryWithDictionary:", v9));
  [v25 setDefaultSamplePositions:v18];

  if ((objc_opt_respondsToSelector(v1, "supportsFamily:") & 1) != 0)
  {
    id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 12LL));
    for (uint64_t j = 0LL; j != 12; ++j)
    {
      uint64_t v21 = newProfileWithMTLDevice_availableGPUFamilies[j];
      if ([v1 supportsFamily:v21])
      {
        __int128 v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", v21));
        [v19 addObject:v22];
      }
    }

    id v23 = [v19 copy];
    [v25 setSupportedGPUFamilies:v23];
  }

  return v25;
}

id DaemonDeviceCapabilities(void *a1)
{
  id v1 = a1;
  id v2 = MTLCreateSystemDefaultDevice();
  id v3 = newProfileWithMTLDevice(v2);
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);

  id v5 = (void *)objc_claimAutoreleasedReturnValue( [v1 stringByAppendingPathComponent:@"/System/Library/Frameworks/Metal.framework"]);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle bundleWithPath:](&OBJC_CLASS___NSBundle, "bundleWithPath:", v5));

  if (v6)
  {
    unsigned __int16 v7 = (__CFString *)objc_claimAutoreleasedReturnValue([v6 objectForInfoDictionaryKey:kCFBundleVersionKey]);
  }

  else
  {
    unsigned __int16 v7 = &stru_20FCB8;
  }

  *(_OWORD *)values = *(_OWORD *)off_20DD58;
  __int128 v17 = *(_OWORD *)off_20DD68;
  int v18 = @"main-screen-scale";
  CFArrayRef v8 = CFArrayCreate(0LL, (const void **)values, 5LL, &kCFTypeArrayCallBacks);
  uint64_t v9 = (void *)MGCopyMultipleAnswers(v8, 0LL);
  CFRelease(v8);
  uint64_t v13 = v4;
  v14[0] = @"gputools.contexts-info";
  size_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v13, 1LL));
  v15[0] = v10;
  v15[1] = v9;
  v14[1] = @"screen-dimensions";
  v14[2] = @"metal_version";
  v14[3] = @"nativePointerSize";
  v15[2] = v7;
  v15[3] = &off_212CB0;
  id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v15,  v14,  4LL));

  return v11;
}

_UNKNOWN **GPUToolsVersionQuery()
{
  return &off_212E48;
}

id isDesktopReplayer(void *a1)
{
  id v1 = a1;
  else {
    id v2 = [v1 isEqualToString:@"com.apple.DesktopReplayer"];
  }

  return v2;
}

id isMobileReplayer(void *a1)
{
  id v1 = a1;
  else {
    id v2 = [v1 isEqualToString:@"com.apple.MobileReplayer"];
  }

  return v2;
}

id modifyReplayerEnvironment(void *a1)
{
  id v1 = [a1 mutableCopy];
  [v1 removeObjectsForKeys:&off_212E88];
  [v1 removeObjectForKey:@"METAL_DEVICE_WRAPPER_TYPE"];
  id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 dictionaryForKey:@"GPUDebugger.ReplayerEnvironment"]);

  if (v3) {
    [v1 addEntriesFromDictionary:v3];
  }
  id v4 = [v1 copy];

  return v4;
}

id FindDesktopReplayerPath(void *a1)
{
  id v1 = a1;
  id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  bzero(buf, 0x400uLL);
  uint32_t bufsize = 1024;
  if (_NSGetExecutablePath(buf, &bufsize))
  {
    id v3 = 0LL;
  }

  else
  {
    id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", buf));
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 stringByDeletingLastPathComponent]);

    id v3 = (void *)objc_claimAutoreleasedReturnValue( [v5 stringByReplacingOccurrencesOfString:@"GPUToolsTransportAgents.framework/Versions/A/XPCServices/GPUToolsAgentService.xpc/Contents/MacOS" withString:&stru_20FCB8]);
  }

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 stringByAppendingPathComponent:v1]);

  if ([v2 fileExistsAtPath:v6])
  {
    id v7 = v6;
  }

  else
  {
    CFArrayRef v8 = (void *)objc_claimAutoreleasedReturnValue([@"/System/Library/CoreServices/" stringByAppendingPathComponent:v1]);
    if ([v2 fileExistsAtPath:v8])
    {
      id v7 = v8;
    }

    else
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle mainBundle](&OBJC_CLASS___NSBundle, "mainBundle"));
      size_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 bundlePath]);
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 componentsSeparatedByString:@"/"]);

      id v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "subarrayWithRange:", 0, (char *)objc_msgSend(v11, "count") - 3));
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString pathWithComponents:](&OBJC_CLASS___NSString, "pathWithComponents:", v12));
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 stringByAppendingPathComponent:v1]);

      unsigned int v26 = v12;
      id v15 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:0]);
      LODWORD(v12) = [v15 isEqualToString:&stru_20FCB8];

      if ((_DWORD)v12)
      {
        uint64_t v16 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"/%@", v14));

        uint64_t v14 = (void *)v16;
      }

      if (([v2 fileExistsAtPath:v14] & 1) == 0)
      {
        id v25 = v9;
        __int128 v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "subarrayWithRange:", 0, (char *)objc_msgSend(v11, "count") - 4));
        int v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString pathWithComponents:](&OBJC_CLASS___NSString, "pathWithComponents:", v17));
        id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 stringByAppendingPathComponent:@"Developer/Applications"]);

        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v19 stringByAppendingPathComponent:v1]);
        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:0]);
        LODWORD(v1_Block_object_dispose(va, 8) = [v20 isEqualToString:&stru_20FCB8];

        if ((_DWORD)v18)
        {
          uint64_t v21 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"/%@", v14));

          uint64_t v14 = (void *)v21;
        }

        uint64_t v9 = v25;
      }

      if (([v2 fileExistsAtPath:v14] & 1) == 0)
      {
        __int128 v22 = (void *)objc_claimAutoreleasedReturnValue( [@"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/Library/GPUToolsPlatform/" stringByAppendingPathComponent:v1]);

        if ([v2 fileExistsAtPath:v22])
        {
          uint64_t v14 = v22;
        }

        else
        {
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( [@"/Applications/Xcode.app/Contents/Developer/Applications/" stringByAppendingPathComponent:v1]);
        }
      }

      else {
        id v23 = 0LL;
      }
      id v7 = v23;
    }
  }

  return v7;
}

id DaemonCreateGuestAppTransport(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  if (!v1) {
    goto LABEL_29;
  }
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v1 objectForKeyedSubscript:@"environment"]);
  if (v4)
  {
    uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSDictionary, v3);
    if ((objc_opt_isKindOfClass(v4, v5) & 1) == 0)
    {
LABEL_28:

LABEL_29:
      char v30 = 0LL;
      goto LABEL_30;
    }

    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    id v6 = v4;
    id v7 = [v6 countByEnumeratingWithState:&v58 objects:v62 count:16];
    if (v7)
    {
      id v9 = v7;
      uint64_t v10 = *(void *)v59;
LABEL_6:
      uint64_t v11 = 0LL;
      while (1)
      {
        if (*(void *)v59 != v10) {
          objc_enumerationMutation(v6);
        }
        uint64_t v12 = *(void *)(*((void *)&v58 + 1) + 8 * v11);
        uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSString, v8);
        if ((objc_opt_isKindOfClass(v12, v13) & 1) == 0) {
          goto LABEL_27;
        }
        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:v12]);
        uint64_t v16 = objc_opt_class(&OBJC_CLASS___NSString, v15);
        char isKindOfClass = objc_opt_isKindOfClass(v14, v16);

        if ((isKindOfClass & 1) == 0) {
          goto LABEL_27;
        }
        if (v9 == (id)++v11)
        {
          id v9 = [v6 countByEnumeratingWithState:&v58 objects:v62 count:16];
          if (v9) {
            goto LABEL_6;
          }
          break;
        }
      }
    }
  }

  id v6 = (id)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"platformPrefix"]);
  if (v6)
  {
    uint64_t v19 = objc_opt_class(&OBJC_CLASS___NSString, v18);
    if ((objc_opt_isKindOfClass(v6, v19) & 1) == 0)
    {
LABEL_27:

      goto LABEL_28;
    }
  }

  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"shouldLoadCapture"]);
  if (v21)
  {
    uint64_t v22 = objc_opt_class(&OBJC_CLASS___NSNumber, v20);
    if ((objc_opt_isKindOfClass(v21, v22) & 1) == 0)
    {
LABEL_26:

      goto LABEL_27;
    }
  }

  unsigned int v24 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"shouldLoadReplayer"]);
  if (v24)
  {
    uint64_t v25 = objc_opt_class(&OBJC_CLASS___NSNumber, v23);
    if ((objc_opt_isKindOfClass(v24, v25) & 1) == 0)
    {
LABEL_25:

      goto LABEL_26;
    }
  }

  id v27 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"shouldLoadDiagnostics"]);
  if (v27)
  {
    uint64_t v28 = objc_opt_class(&OBJC_CLASS___NSNumber, v26);
    if ((objc_opt_isKindOfClass(v27, v28) & 1) == 0)
    {

      goto LABEL_25;
    }
  }

  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"environment"]);
  char v30 = v29;
  if (v29) {
    uint64_t v31 = (NSMutableDictionary *)[v29 mutableCopy];
  }
  else {
    uint64_t v31 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  2LL);
  }
  unsigned int v33 = v31;
  unsigned int v34 = (void *)objc_claimAutoreleasedReturnValue([v30 objectForKeyedSubscript:@"DYLD_INSERT_LIBRARIES"]);
  uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v34 componentsSeparatedByString:@":"]);
  unsigned int v36 = v35;
  if (v35) {
    unsigned int v37 = (NSMutableArray *)[v35 mutableCopy];
  }
  else {
    unsigned int v37 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 2LL);
  }
  unsigned int v38 = v37;
  unsigned int v39 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"platformPrefix"]);
  timespec v40 = (void *)objc_claimAutoreleasedReturnValue([v30 objectForKeyedSubscript:@"GPUTOOLS_EXTRA_PLUGIN_PATHS"]);
  uint64_t v41 = objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"shouldLoadReplayer"]);
  if (!v41) {
    goto LABEL_37;
  }
  uint64_t v42 = (void *)v41;
  char v57 = v38;
  id v43 = v36;
  id v44 = v33;
  uint64_t v45 = v34;
  unsigned __int16 v46 = v40;
  uint64_t v47 = v39;
  uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"shouldLoadCapture"]);
  unsigned int v49 = [v48 BOOLValue];

  unsigned int v39 = v47;
  timespec v40 = v46;
  unsigned int v34 = v45;
  unsigned int v33 = v44;
  unsigned int v36 = v43;
  unsigned int v38 = v57;

  if (v49)
  {
LABEL_37:
    uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue( [@"/System/Library/PrivateFrameworks/" stringByAppendingPathComponent:@"GPUToolsCapture.framework/GPUToolsCapture"]);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v33,  "setObject:forKeyedSubscript:",  v50,  @"DYMTL_TOOLS_DYLIB_PATH");
  }

  uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"shouldLoadDiagnostics"]);
  unsigned int v52 = [v51 BOOLValue];

  if (v52)
  {
    __int128 v53 = (void *)objc_claimAutoreleasedReturnValue( [@"/System/Library/PrivateFrameworks/" stringByAppendingPathComponent:@"GPUToolsDiagnostics.framework/GPUToolsDiagnostics"]);
  }

  id v54 = [v36 count];
  if (v54 != -[NSMutableArray count](v38, "count"))
  {
    __int128 v55 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v38, "componentsJoinedByString:", @":"));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v33,  "setObject:forKeyedSubscript:",  v55,  @"DYLD_INSERT_LIBRARIES");

    id v56 = -[NSMutableDictionary copy](v33, "copy");
    char v30 = v56;
  }

LABEL_30:
  return v30;
}

void PresentTelemetry(void *a1)
{
  id v1 = a1;
}

void PresentTrigger(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v4 = v3;
  if ((*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) == 2 && (qword_23A448 & 1) != 0)
  {
    id v5 = v3;
    apr_pool_create_ex(&newpool, 0LL, 0LL, 0LL);
    id v6 = [v5 traceContext];
    id v7 = newpool;
    GTTraceContext_copyStreamMap((uint64_t)v6, newpool);
    p = v7;
    uint64_t v8 = apr_hash_make(v7);
    GTTraceMemPool_buildMemoryMap(*((void *)[v5 traceStream] + 3), v8);
    uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v5 layer]);
    id v9 = (uint64_t *)[v48 traceStream];
    if (v9) {
      uint64_t v10 = *v9;
    }
    else {
      uint64_t v10 = 0LL;
    }
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v5 texture]);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 device]);
    uint64_t v13 = apr_array_make(p, 1, 56);
    uint64_t v14 = *((void *)[v11 traceStream] + 1);
    uint64_t v47 = v11;
    uint64_t v15 = (uint64_t *)[v11 traceStream];
    if (v15) {
      uint64_t v16 = *v15;
    }
    else {
      uint64_t v16 = 0LL;
    }
    uint64_t v17 = *(void *)(a2 + 24);
    uint64_t v18 = (char *)apr_array_push(v13);
    *(void *)uint64_t v18 = v14;
    *((void *)v18 + 1) = v16;
    *((void *)v18 + 2) = v17;
    *((void *)v18 + 3) = v17;
    *((void *)v18 + 4) = v17;
    *((void *)v18 + 5) = 80LL;
    v18[48] = 1;
    *(_DWORD *)(v18 + 49) = 0;
    *((_DWORD *)v18 + 13) = 0;
    unsigned int v49 = v5;
    DownloadRequests = GTResourceHarvesterGetDownloadRequests( (pthread_mutex_t *)[v12 harvester],  (uint64_t)objc_msgSend(v5, "streamReference"),  (uint64_t)v13);
    uint64_t v20 = GTResourceDownloaderProcessRequest(p, (uint64_t)DownloadRequests);
    uint64_t v21 = v20;
    if (v20->nelts >= 1)
    {
      uint64_t v22 = 0LL;
      uint64_t v23 = 0LL;
      do
      {
        uint64_t v24 = *(void *)(a2 + 24);
        uint64_t v25 = &v20->elts[v22];
        v25[47] |= 4u;
        *((void *)v25 + 3) = v10;
        *((void *)v25 + 4) = v24;
        ++v23;
        v22 += 88LL;
      }

      while (v23 < v20->nelts);
    }

    GTMTLCaptureState_appendDownloadRequests(_sharedCaptureManager, v20);
    uint64_t v26 = objc_alloc_init(&OBJC_CLASS___GTDownloadPoint);
    id v27 = DEVICEOBJECT(v12);
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
    id v29 = [v28 newCommandQueue];
    id v30 = [v28 newSharedEvent];
    -[GTDownloadPoint setDownloadQueue:](v26, "setDownloadQueue:", v29);
    -[GTDownloadPoint setWaitEvent:](v26, "setWaitEvent:", v30);
    -[GTDownloadPoint setWaitValue:](v26, "setWaitValue:", 1LL);
    -[GTDownloadPoint setDownloadEvent:](v26, "setDownloadEvent:", v30);
    -[GTDownloadPoint setDownloadValue:]( v26,  "setDownloadValue:",  (char *)-[GTDownloadPoint waitValue](v26, "waitValue") + 1);
    objc_msgSend(v30, "setSignaledValue:", -[GTDownloadPoint waitValue](v26, "waitValue"));
    uint64_t v31 = (dispatch_group_s *)objc_claimAutoreleasedReturnValue([v12 dispatchGroup]);
    dispatch_group_enter(v31);

    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v12 captureEventListener]);
    id v33 = -[GTDownloadPoint downloadValue](v26, "downloadValue");
    *(void *)&__int128 v51 = _NSConcreteStackBlock;
    *((void *)&v51 + 1) = 3221225472LL;
    unsigned int v52 = __DownloadDrawable_block_invoke;
    __int128 v53 = &unk_20DD88;
    id v54 = v12;
    id v34 = v12;
    [v30 notifyListener:v32 atValue:v33 block:&v51];

    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v34 downloader]);
    [v35 downloadRequest:v21 atPoint:v26];

    apr_pool_destroy(p);
  }

  unsigned int v36 = (uint64_t *)[v4 traceStream];
  if (v36) {
    uint64_t v37 = *v36;
  }
  else {
    uint64_t v37 = 0LL;
  }
  unsigned int v38 = *(void (**)(uint64_t))(a2 + 24);
  unsigned int v39 = *(void **)(a2 + 32);
  timespec v40 = (void *)objc_claimAutoreleasedReturnValue([v4 layer]);
  uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v40 device]);
  uint64_t v42 = (uint64_t *)[v41 traceStream];
  if (v42) {
    uint64_t v43 = *v42;
  }
  else {
    uint64_t v43 = 0LL;
  }
  id v44 = (void *)objc_claimAutoreleasedReturnValue([v4 layer]);
  uint64_t v45 = (uint64_t *)[v44 traceStream];
  if (v45) {
    uint64_t v46 = *v45;
  }
  else {
    uint64_t v46 = 0LL;
  }

  *(void *)&__int128 v51 = 0x300000003LL;
  *((void *)&v51 + 1) = v37;
  unsigned int v52 = v38;
  __int128 v53 = v39;
  id v54 = 0LL;
  uint64_t v55 = v43;
  uint64_t v56 = v46;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  GTCaptureBoundaryTracker_handleTrigger(&v51);
}

void __DownloadDrawable_block_invoke(uint64_t a1)
{
  id v1 = (dispatch_group_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) dispatchGroup]);
  dispatch_group_leave(v1);
}

id NumberToInt(void *a1)
{
  id v1 = a1;
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSNumber, v2);
  if ((objc_opt_isKindOfClass(v1, v3) & 1) != 0) {
    id v4 = [v1 unsignedLongLongValue];
  }
  else {
    id v4 = 0LL;
  }

  return v4;
}

void RetainObjectForDescriptorDownloader(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = (uint64_t *)[v4 traceStream];
  if (v5) {
    uint64_t v6 = *v5;
  }
  else {
    uint64_t v6 = 0LL;
  }
  id v7 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v6));
  [v3 setObject:v4 forKeyedSubscript:v7];
}

void SetCaptureDescriptor(void *a1, void *a2, int a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a4;
  if (v7)
  {
    [v7 setCaptureDescriptor:v9];
    if (a3)
    {
      id v10 = [v8 traceContext];
      [v8 traceStream];
      GTTraceContext_pushEncoderWithStream((uint64_t)v10, (uint64_t)&v33);
      uint64_t v11 = v35;
      *(_DWORD *)(v35 + _Block_object_dispose(va, 8) = -10154;
      unsigned __int8 v12 = v38;
      if (v38 > 0x28uLL)
      {
        uint64_t v18 = *(void *)(v34 + 24);
        uint64_t v19 = v39++;
        uint64_t v13 = GTTraceMemPool_allocateBytes(v18, v36, v19 | 0x1800000000LL) + 16;
        unsigned __int8 v12 = v19;
      }

      else
      {
        uint64_t v13 = (char *)(v11 + v38);
        v38 += 24;
      }

      *(_BYTE *)(v11 + 13) = v12;
      uint64_t v20 = (uint64_t *)[v8 traceStream];
      if (v20) {
        uint64_t v21 = *v20;
      }
      else {
        uint64_t v21 = 0LL;
      }
      uint64_t v26 = (uint64_t *)[v7 traceStream];
      if (v26) {
        uint64_t v27 = *v26;
      }
      else {
        uint64_t v27 = 0LL;
      }
      char v30 = SaveMTLAccelerationStructureDescriptor((uint64_t)&v33, v9);
      *(void *)uint64_t v13 = v21;
      *((void *)v13 + 1) = v27;
      v13[16] = v30;
      *(_DWORD *)(v13 + 17) = 0;
      *((_DWORD *)v13 + 5) = 0;
      id v29 = v8;
    }

    else
    {
      id v14 = [v7 traceContext];
      [v7 traceStream];
      GTTraceContext_pushEncoderWithStream((uint64_t)v14, (uint64_t)&v33);
      uint64_t v15 = v35;
      *(_DWORD *)(v35 + _Block_object_dispose(va, 8) = -15552;
      unsigned __int8 v16 = v38;
      if (v38 > 0x30uLL)
      {
        uint64_t v22 = *(void *)(v34 + 24);
        uint64_t v23 = v39++;
        uint64_t v17 = GTTraceMemPool_allocateBytes(v22, v36, v23 | 0x1000000000LL) + 16;
        unsigned __int8 v16 = v23;
      }

      else
      {
        uint64_t v17 = (char *)(v15 + v38);
        v38 += 16;
      }

      *(_BYTE *)(v15 + 13) = v16;
      uint64_t v24 = (uint64_t *)[v7 traceStream];
      if (v24) {
        uint64_t v25 = *v24;
      }
      else {
        uint64_t v25 = 0LL;
      }
      char v28 = SaveMTLAccelerationStructureDescriptor((uint64_t)&v33, v9);
      *(void *)uint64_t v17 = v25;
      v17[8] = v28;
      *(_DWORD *)(v17 + 9) = 0;
      *((_DWORD *)v17 + 3) = 0;
      id v29 = v7;
    }

    [v29 traceContext];
    s();
    *(void *)uint64_t v31 = v32;
    *(_BYTE *)(v31 + _Block_object_dispose(va, 8) = v37;
    *(_BYTE *)(v35 + 15) |= 8u;
  }
}

void RetainAccelerationStructureDescriptorObjects(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  uint64_t v9 = objc_opt_class(&OBJC_CLASS___MTLInstanceAccelerationStructureDescriptor, v8);
  if ((objc_opt_isKindOfClass(v7, v9) & 1) != 0)
  {
    id v11 = v7;
    unsigned __int8 v12 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceDescriptorBuffer]);
    [v12 touch];

    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceDescriptorBuffer]);
    if (v5 && v13)
    {
      id v14 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceDescriptorBuffer]);
      [v5 addObject:v14];
    }

    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceDescriptorBuffer]);
    RetainObjectForDescriptorDownloader(v15, v6);

    __int128 v158 = 0u;
    __int128 v159 = 0u;
    __int128 v156 = 0u;
    __int128 v157 = 0u;
    unsigned __int8 v16 = (void *)objc_claimAutoreleasedReturnValue([v11 instancedAccelerationStructures]);
    id v17 = [v16 countByEnumeratingWithState:&v156 objects:v165 count:16];
    if (v17)
    {
      id v18 = v17;
      uint64_t v19 = *(void *)v157;
      do
      {
        for (uint64_t i = 0LL; i != v18; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v157 != v19) {
            objc_enumerationMutation(v16);
          }
          RetainObjectForDescriptorDownloader(*(void **)(*((void *)&v156 + 1) + 8LL * (void)i), v6);
        }

        id v18 = [v16 countByEnumeratingWithState:&v156 objects:v165 count:16];
      }

      while (v18);
    }

    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v11 motionTransformBuffer]);
    [v21 touch];

    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v11 motionTransformBuffer]);
    if (v5 && v22)
    {
      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v11 motionTransformBuffer]);
      [v5 addObject:v23];
    }

    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v11 instancedAccelerationStructures]);
    RetainNSArray(v5, v24);
    goto LABEL_125;
  }

  uint64_t v25 = objc_opt_class(&OBJC_CLASS___MTLPrimitiveAccelerationStructureDescriptor, v10);
  if ((objc_opt_isKindOfClass(v7, v25) & 1) == 0)
  {
    uint64_t v116 = objc_opt_class(&OBJC_CLASS___MTLIndirectInstanceAccelerationStructureDescriptor, v26);
    if ((objc_opt_isKindOfClass(v7, v116) & 1) == 0) {
      goto LABEL_126;
    }
    id v11 = v7;
    __int128 v117 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceDescriptorBuffer]);
    [v117 touch];

    uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceDescriptorBuffer]);
    if (v5 && v118)
    {
      uint64_t v119 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceDescriptorBuffer]);
      [v5 addObject:v119];
    }

    uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue([v11 motionTransformBuffer]);
    [v120 touch];

    uint64_t v121 = (void *)objc_claimAutoreleasedReturnValue([v11 motionTransformBuffer]);
    if (v5 && v121)
    {
      __int128 v122 = (void *)objc_claimAutoreleasedReturnValue([v11 motionTransformBuffer]);
      [v5 addObject:v122];
    }

    uint64_t v123 = (void *)objc_claimAutoreleasedReturnValue([v11 motionTransformCountBuffer]);
    [v123 touch];

    uint64_t v124 = (void *)objc_claimAutoreleasedReturnValue([v11 motionTransformCountBuffer]);
    if (v5 && v124)
    {
      uint64_t v125 = (void *)objc_claimAutoreleasedReturnValue([v11 motionTransformCountBuffer]);
      [v5 addObject:v125];
    }

    __int128 v126 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceCountBuffer]);
    [v126 touch];

    id v127 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceCountBuffer]);
    if (v5 && v127)
    {
      uint64_t v128 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceCountBuffer]);
      [v5 addObject:v128];
    }

    uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceDescriptorBuffer]);
    RetainObjectForDescriptorDownloader(v129, v6);

    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v11 instanceCountBuffer]);
    RetainObjectForDescriptorDownloader(v24, v6);
LABEL_125:

    goto LABEL_126;
  }

  id v130 = v7;
  id v131 = v6;
  __int128 v154 = 0u;
  __int128 v155 = 0u;
  __int128 v152 = 0u;
  __int128 v153 = 0u;
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v7 geometryDescriptors]);
  id v28 = [v27 countByEnumeratingWithState:&v152 objects:v164 count:16];
  if (!v28) {
    goto LABEL_110;
  }
  id v29 = v28;
  char v30 = &CACurrentMediaTime_ptr;
  uint64_t v31 = &CACurrentMediaTime_ptr;
  uint64_t v135 = *(void *)v153;
  uint64_t v133 = v27;
  do
  {
    uint64_t v32 = 0LL;
    id v134 = v29;
    do
    {
      if (*(void *)v153 != v135) {
        objc_enumerationMutation(v27);
      }
      uint64_t v33 = *(void **)(*((void *)&v152 + 1) + 8LL * (void)v32);
      if ((objc_opt_respondsToSelector(v33, "primitiveDataBuffer") & 1) != 0)
      {
        uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v33 primitiveDataBuffer]);
        [v35 touch];

        uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v33 primitiveDataBuffer]);
        if (v5)
        {
          if (v36)
          {
            char v37 = (void *)objc_claimAutoreleasedReturnValue([v33 primitiveDataBuffer]);
            [v5 addObject:v37];
          }
        }
      }

      uint64_t v38 = objc_opt_class(v30[158], v34);
      if ((objc_opt_isKindOfClass(v33, v38) & 1) != 0)
      {
        id v40 = v33;
        uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v40 vertexBuffer]);
        [v41 touch];

        uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v40 vertexBuffer]);
        if (v5 && v42)
        {
          uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v40 vertexBuffer]);
          [v5 addObject:v43];
        }

        id v44 = (void *)objc_claimAutoreleasedReturnValue([v40 indexBuffer]);
        [v44 touch];

        uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v40 indexBuffer]);
        if (v5 && v45)
        {
          uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v40 indexBuffer]);
          [v5 addObject:v46];
        }

        if ((objc_opt_respondsToSelector(v40, "transformationMatrixBuffer") & 1) == 0) {
          goto LABEL_59;
        }
LABEL_54:
        __int128 v67 = (void *)objc_claimAutoreleasedReturnValue([v40 transformationMatrixBuffer]);
        [v67 touch];

        __int128 v68 = (void *)objc_claimAutoreleasedReturnValue([v40 transformationMatrixBuffer]);
        if (v5 && v68)
        {
          uint64_t v52 = objc_claimAutoreleasedReturnValue([v40 transformationMatrixBuffer]);
          goto LABEL_57;
        }

LABEL_59:
        goto LABEL_60;
      }

      uint64_t v47 = objc_opt_class(v31[152], v39);
      if ((objc_opt_isKindOfClass(v33, v47) & 1) != 0)
      {
        id v49 = v33;
        uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v49 boundingBoxBuffer]);
        [v50 touch];

        __int128 v51 = (void *)objc_claimAutoreleasedReturnValue([v49 boundingBoxBuffer]);
        if (v5 && v51)
        {
          uint64_t v52 = objc_claimAutoreleasedReturnValue([v49 boundingBoxBuffer]);
          goto LABEL_57;
        }

        goto LABEL_59;
      }

      uint64_t v53 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionTriangleGeometryDescriptor, v48);
      if ((objc_opt_isKindOfClass(v33, v53) & 1) != 0)
      {
        id v40 = v33;
        __int128 v148 = 0u;
        __int128 v149 = 0u;
        __int128 v150 = 0u;
        __int128 v151 = 0u;
        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v40 vertexBuffers]);
        id v56 = [v55 countByEnumeratingWithState:&v148 objects:v163 count:16];
        if (v56)
        {
          id v57 = v56;
          uint64_t v58 = *(void *)v149;
          do
          {
            for (uint64_t j = 0LL; j != v57; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v149 != v58) {
                objc_enumerationMutation(v55);
              }
              __int128 v60 = *(void **)(*((void *)&v148 + 1) + 8LL * (void)j);
              __int128 v61 = (void *)objc_claimAutoreleasedReturnValue([v60 buffer]);
              [v61 touch];

              __int128 v62 = (void *)objc_claimAutoreleasedReturnValue([v60 buffer]);
              if (v5 && v62)
              {
                __int128 v63 = (void *)objc_claimAutoreleasedReturnValue([v60 buffer]);
                [v5 addObject:v63];
              }
            }

            id v57 = [v55 countByEnumeratingWithState:&v148 objects:v163 count:16];
          }

          while (v57);
        }

        __int128 v64 = (void *)objc_claimAutoreleasedReturnValue([v40 indexBuffer]);
        [v64 touch];

        __int128 v65 = (void *)objc_claimAutoreleasedReturnValue([v40 indexBuffer]);
        if (v5 && v65)
        {
          uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v40 indexBuffer]);
          [v5 addObject:v66];
        }

        uint64_t v27 = v133;
        id v29 = v134;
        char v30 = &CACurrentMediaTime_ptr;
        uint64_t v31 = &CACurrentMediaTime_ptr;
        if ((objc_opt_respondsToSelector(v40, "transformationMatrixBuffer") & 1) == 0) {
          goto LABEL_59;
        }
        goto LABEL_54;
      }

      uint64_t v70 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor, v54);
      if ((objc_opt_isKindOfClass(v33, v70) & 1) != 0)
      {
        id v72 = v33;
        __int128 v144 = 0u;
        __int128 v145 = 0u;
        __int128 v146 = 0u;
        __int128 v147 = 0u;
        __int128 v69 = (void *)objc_claimAutoreleasedReturnValue([v72 boundingBoxBuffers]);
        id v73 = [v69 countByEnumeratingWithState:&v144 objects:v162 count:16];
        if (v73)
        {
          id v74 = v73;
          uint64_t v75 = *(void *)v145;
          do
          {
            for (uint64_t k = 0LL; k != v74; uint64_t k = (char *)k + 1)
            {
              if (*(void *)v145 != v75) {
                objc_enumerationMutation(v69);
              }
              uint64_t v77 = *(void **)(*((void *)&v144 + 1) + 8LL * (void)k);
              uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v77 buffer]);
              [v78 touch];

              uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue([v77 buffer]);
              if (v5 && v79)
              {
                uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue([v77 buffer]);
                [v5 addObject:v80];
              }
            }

            id v74 = [v69 countByEnumeratingWithState:&v144 objects:v162 count:16];
          }

          while (v74);
          uint64_t v27 = v133;
          id v29 = v134;
          char v30 = &CACurrentMediaTime_ptr;
          uint64_t v31 = &CACurrentMediaTime_ptr;
        }

        goto LABEL_58;
      }

      uint64_t v81 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureCurveGeometryDescriptor, v71);
      if ((objc_opt_isKindOfClass(v33, v81) & 1) != 0)
      {
        id v83 = v33;
        id v84 = (void *)objc_claimAutoreleasedReturnValue([v83 controlPointBuffer]);
        [v84 touch];

        __int16 v85 = (void *)objc_claimAutoreleasedReturnValue([v83 controlPointBuffer]);
        if (v5 && v85)
        {
          int v86 = (void *)objc_claimAutoreleasedReturnValue([v83 controlPointBuffer]);
          [v5 addObject:v86];
        }

        id v87 = (void *)objc_claimAutoreleasedReturnValue([v83 radiusBuffer]);
        [v87 touch];

        id v88 = (void *)objc_claimAutoreleasedReturnValue([v83 radiusBuffer]);
        if (v5 && v88)
        {
          uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue([v83 radiusBuffer]);
          [v5 addObject:v89];
        }

        uint64_t v90 = (void *)objc_claimAutoreleasedReturnValue([v83 indexBuffer]);
        [v90 touch];

        uint64_t v91 = (void *)objc_claimAutoreleasedReturnValue([v83 indexBuffer]);
        if (v5 && v91)
        {
          id v92 = v83;
          goto LABEL_108;
        }

        goto LABEL_59;
      }

      uint64_t v93 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionCurveGeometryDescriptor, v82);
      if ((objc_opt_isKindOfClass(v33, v93) & 1) != 0)
      {
        id v94 = v33;
        __int128 v140 = 0u;
        __int128 v141 = 0u;
        __int128 v142 = 0u;
        __int128 v143 = 0u;
        id v132 = v94;
        unint64_t v95 = (void *)objc_claimAutoreleasedReturnValue([v94 controlPointBuffers]);
        id v96 = [v95 countByEnumeratingWithState:&v140 objects:v161 count:16];
        if (v96)
        {
          id v97 = v96;
          uint64_t v98 = *(void *)v141;
          do
          {
            for (uint64_t m = 0LL; m != v97; uint64_t m = (char *)m + 1)
            {
              if (*(void *)v141 != v98) {
                objc_enumerationMutation(v95);
              }
              unint64_t v100 = *(void **)(*((void *)&v140 + 1) + 8LL * (void)m);
              unint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v100 buffer]);
              [v101 touch];

              double v102 = (void *)objc_claimAutoreleasedReturnValue([v100 buffer]);
              if (v5 && v102)
              {
                double v103 = (void *)objc_claimAutoreleasedReturnValue([v100 buffer]);
                [v5 addObject:v103];
              }
            }

            id v97 = [v95 countByEnumeratingWithState:&v140 objects:v161 count:16];
          }

          while (v97);
        }

        __int128 v138 = 0u;
        __int128 v139 = 0u;
        __int128 v136 = 0u;
        __int128 v137 = 0u;
        uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue([v132 radiusBuffers]);
        id v105 = [v104 countByEnumeratingWithState:&v136 objects:v160 count:16];
        if (v105)
        {
          id v106 = v105;
          uint64_t v107 = *(void *)v137;
          do
          {
            for (uint64_t n = 0LL; n != v106; uint64_t n = (char *)n + 1)
            {
              if (*(void *)v137 != v107) {
                objc_enumerationMutation(v104);
              }
              __int128 v109 = *(void **)(*((void *)&v136 + 1) + 8LL * (void)n);
              unint64_t v110 = (void *)objc_claimAutoreleasedReturnValue([v109 buffer]);
              [v110 touch];

              uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue([v109 buffer]);
              if (v5 && v111)
              {
                unsigned int v112 = (void *)objc_claimAutoreleasedReturnValue([v109 buffer]);
                [v5 addObject:v112];
              }
            }

            id v106 = [v104 countByEnumeratingWithState:&v136 objects:v160 count:16];
          }

          while (v106);
        }

        uint64_t v113 = (void *)objc_claimAutoreleasedReturnValue([v132 indexBuffer]);
        [v113 touch];

        int v114 = (void *)objc_claimAutoreleasedReturnValue([v132 indexBuffer]);
        uint64_t v27 = v133;
        id v29 = v134;
        char v30 = &CACurrentMediaTime_ptr;
        uint64_t v31 = &CACurrentMediaTime_ptr;
        if (v5 && v114)
        {
          id v92 = v132;
LABEL_108:
          uint64_t v52 = objc_claimAutoreleasedReturnValue([v92 indexBuffer]);
LABEL_57:
          __int128 v69 = (void *)v52;
          [v5 addObject:v52];
LABEL_58:
        }

        goto LABEL_59;
      }

  if (*(void *)(v12 + 120))
  {
    fbstream_write(*(void *)(a1 + 24), *(void *)(a1 + 8), **(unsigned int **)(a1 + 8));
    id v44 = *(void *)(a1 + 8);
    *(_DWORD *)(v44 + 32) = 0;
    *(_OWORD *)id v44 = 0u;
    *(_OWORD *)(v44 + 16) = 0u;
    uint64_t v45 = *(void *)(a1 + 8);
    *(_DWORD *)(v45 + 32) = 198;
    *(void *)uint64_t v45 = 0xFFFFD01000000024LL;
    uint64_t v46 = *(uint64_t **)(v12 + 112);
    uint64_t v47 = *(const void **)(v12 + 120);
    uint64_t v48 = *(void *)(a1 + 32);
    HashBytes(v46, (unint64_t)v47, __s);
    GTMTLCaptureState_storePointer(v48, __s, v46, v47);
    id v92 = v97;
    uint64_t v93 = v98;
    id v94 = v99;
    uint64_t v90 = *(_OWORD *)__s;
    uint64_t v91 = v96;
    *(void *)__s = v9;
    *(void *)&__s[8] = 116LL;
    *(void *)&id v96 = &v90;
    *((void *)&v96 + 1) = v47;
    DYTraceEncode_InternalData((uint64_t)__s, *(unsigned int **)(a1 + 8), *(unsigned int *)(a1 + 16), v49, 0LL);
  }

  if (*(_WORD *)(v12 + 214))
  {
    uint64_t v50 = 0LL;
    do
    {
      fbstream_write(*(void *)(a1 + 24), *(void *)(a1 + 8), **(unsigned int **)(a1 + 8));
      __int128 v51 = *(void *)(a1 + 8);
      *(_DWORD *)(v51 + 32) = 0;
      *(_OWORD *)__int128 v51 = 0u;
      *(_OWORD *)(v51 + 16) = 0u;
      uint64_t v52 = *(void *)(a1 + 8);
      *(_DWORD *)(v52 + 32) = 198;
      *(void *)uint64_t v52 = 0xFFFFD01000000024LL;
      SaveFileWithURL(*(void *)(a1 + 32), *(char **)(*(void *)(v12 + 104) + 8 * v50), __s, 0LL, 1);
      *(void *)&uint64_t v90 = v9;
      *((void *)&v90 + 1) = 126LL;
      *(void *)&uint64_t v91 = __s;
      *((void *)&v91 + 1) = *(void *)(*(void *)(v12 + 104) + 8 * v50);
      DYTraceEncode_InternalData((uint64_t)&v90, *(unsigned int **)(a1 + 8), *(unsigned int *)(a1 + 16), v53, 0LL);
      ++v50;
    }

    while (v50 < *(unsigned __int16 *)(v12 + 214));
  }

  uint64_t v54 = *(unsigned int **)(a1 + 8);
  uint64_t v55 = v54[8];
  if ((v55 & 0x1000) != 0) {
    id v56 = v55 & 0xFFFFEFFF;
  }
  else {
    id v56 = v55 | 0x2000;
  }
  v54[8] = v56;
  id v57 = *v54;
  if ((v56 & 0x1000) != 0)
  {
    uint64_t v58 = *v54;
    __int128 v59 = v54;
    do
    {
      __int128 v59 = (unsigned int *)((char *)v59 + v58);
      uint64_t v58 = *v59;
      v57 += v58;
    }

    while ((*((_BYTE *)v59 + 33) & 0x20) == 0);
  }

  fbstream_write(*(void *)(a1 + 24), (uint64_t)v54, v57);
  __int128 v60 = *(void *)(a2 + 96);
  if (v60)
  {
    __int128 v61 = *(void **)(a1 + 8);
    v61[2] = 0LL;
    void v61[3] = 0LL;
    v61[1] = 0LL;
    v61[4] = 0x77754300000004LL;
    void *v61 = 0xFFFFD81400000028LL;
    v61[5] = v9;
    v61[6] = v60;
    *(_DWORD *)__int128 v61 = 56;
    __int128 v62 = *(unsigned int **)(a1 + 8);
    __int128 v63 = v62[8] | a4;
    v62[8] = v63;
    __int128 v64 = *v62;
    if ((v63 & 0x1000) != 0)
    {
      __int128 v65 = *v62;
      uint64_t v66 = v62;
      do
      {
        uint64_t v66 = (unsigned int *)((char *)v66 + v65);
        __int128 v65 = *v66;
        v64 += v65;
      }

      while ((*((_BYTE *)v66 + 33) & 0x20) == 0);
    }

    fbstream_write(*(void *)(a1 + 24), (uint64_t)v62, v64);
  }

  __int128 v67 = *(unsigned int *)(a2 + 412);
  if ((_DWORD)v67)
  {
    __int128 v68 = *(void **)(a1 + 8);
    v68[2] = 0LL;
    v68[3] = 0LL;
    v68[1] = 0LL;
    v68[4] = 0x6C754300000006LL;
    void *v68 = 0xFFFFD83800000028LL;
    v68[5] = v9;
    v68[6] = v67;
    *(_DWORD *)__int128 v68 = 56;
    __int128 v69 = *(unsigned int **)(a1 + 8);
    uint64_t v70 = v69[8] | a4;
    v69[8] = v70;
    uint64_t v71 = *v69;
    if ((v70 & 0x1000) != 0)
    {
      id v72 = *v69;
      id v73 = v69;
      do
      {
        id v73 = (unsigned int *)((char *)v73 + v72);
        id v72 = *v73;
        v71 += v72;
      }

      while ((*((_BYTE *)v73 + 33) & 0x20) == 0);
    }

    fbstream_write(*(void *)(a1 + 24), (uint64_t)v69, v71);
  }

  id v74 = *(_DWORD *)(a2 + 408);
  uint64_t v75 = *(void *)(a1 + 8);
  *(void *)(v75 + 16) = 0LL;
  *(void *)(v75 + 24) = 0LL;
  *(void *)(v75 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(v75 + 32) = 0x69754300000006LL;
  *(void *)uint64_t v75 = 0xFFFFD83000000028LL;
  *(void *)(v75 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v9;
  *(_DWORD *)(v75 + 4_Block_object_dispose(va, 8) = v74;
  *(_DWORD *)uint64_t v75 = 52;
  uint64_t v76 = *(unsigned int **)(a1 + 8);
  uint64_t v77 = v76[8] | a4;
  v76[8] = v77;
  uint64_t v78 = *v76;
  if ((v77 & 0x1000) != 0)
  {
    uint64_t v79 = *v76;
    uint64_t v80 = v76;
    do
    {
      uint64_t v80 = (unsigned int *)((char *)v80 + v79);
      uint64_t v79 = *v80;
      v78 += v79;
    }

    while ((*((_BYTE *)v80 + 33) & 0x20) == 0);
  }

  fbstream_write(*(void *)(a1 + 24), (uint64_t)v76, v78);
  uint64_t v81 = *(void *)(a2 + 112);
  if (v81)
  {
    uint64_t v82 = *(void **)(a1 + 8);
    v82[2] = 0LL;
    v82[3] = 0LL;
    v82[1] = 0LL;
    v82[4] = 0x77754300000004LL;
    *uint64_t v82 = 0xFFFFD84B00000028LL;
    v82[5] = v9;
    v82[6] = v81;
    *(_DWORD *)uint64_t v82 = 56;
    id v83 = *(unsigned int **)(a1 + 8);
    id v84 = v83[8] | a4;
    v83[8] = v84;
    __int16 v85 = *v83;
    if ((v84 & 0x1000) != 0)
    {
      int v86 = *v83;
      id v87 = v83;
      do
      {
        id v87 = (unsigned int *)((char *)v87 + v86);
        int v86 = *v87;
        v85 += v86;
      }

      while ((*((_BYTE *)v87 + 33) & 0x20) == 0);
    }

    fbstream_write(*(void *)(a1 + 24), (uint64_t)v83, v85);
  }

LABEL_60:
      uint64_t v32 = (char *)v32 + 1;
    }

    while (v32 != v29);
    id v115 = [v27 countByEnumeratingWithState:&v152 objects:v164 count:16];
    id v29 = v115;
  }

  while (v115);
LABEL_110:

  id v7 = v130;
  id v6 = v131;
LABEL_126:
}

id copyCaptureDescriptor(id *a1, int a2, int a3, void *a4, void *a5, void *a6, void *a7)
{
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = a7;
  id v17 = *a1;
  if (a3)
  {
    if (a2)
    {
      id v18 = [v17 copy];
      *a1 = v18;
      id v19 = v18;
    }

    else
    {
      id v21 = copyAndPatchExtraBuffersInDescriptor(v17, v13, v14);
      id v22 = (id)objc_claimAutoreleasedReturnValue(v21);
      *a1 = v22;
      RetainAccelerationStructureDescriptorObjects(v15, v16, v22);
      id v19 = *a1;
    }
  }

  else
  {
    id v20 = copyAndNullifyReferencesInDescriptor(v17);
    id v19 = (id)objc_claimAutoreleasedReturnValue(v20);
  }

  uint64_t v23 = v19;

  return v23;
}

id copyAndPatchExtraBuffersInDescriptor(void *a1, void *a2, void *a3)
{
  id v257 = a2;
  id v5 = a3;
  id v6 = [a1 copy];
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___MTLPrimitiveAccelerationStructureDescriptor, v7);
  id v243 = v6;
  uint64_t v256 = v5;
  if ((objc_opt_isKindOfClass(v6, v8) & 1) != 0)
  {
    __int128 v276 = 0u;
    __int128 v277 = 0u;
    __int128 v274 = 0u;
    __int128 v275 = 0u;
    obuint64_t j = (id)objc_claimAutoreleasedReturnValue([v6 geometryDescriptors]);
    id v251 = [obj countByEnumeratingWithState:&v274 objects:v324 count:16];
    if (v251)
    {
      uint64_t v250 = *(void *)v275;
      while (1)
      {
        id v11 = 0LL;
        do
        {
          if (*(void *)v275 != v250) {
            objc_enumerationMutation(obj);
          }
          unsigned __int8 v12 = *(void **)(*((void *)&v274 + 1) + 8LL * (void)v11);
          uint64_t v13 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureTriangleGeometryDescriptor, v10);
          if ((objc_opt_isKindOfClass(v12, v13) & 1) != 0)
          {
            if ((objc_opt_respondsToSelector(v12, "primitiveDataBuffer") & 1) != 0)
            {
              id v15 = (void *)objc_claimAutoreleasedReturnValue([v12 primitiveDataBuffer]);

              if (v15)
              {
                id v16 = (void *)objc_claimAutoreleasedReturnValue([v12 primitiveDataBuffer]);
                id v17 = [v16 length];
                int64_t v18 = v17 - (_BYTE *)[v12 primitiveDataBufferOffset];

                id v19 = [v257 newBufferWithLength:v18 options:0];
                [v19 setLabel:@"gputools.ADSPrimitiveDataBuffer"];
                v322[0] = @"srcBuffer";
                id v20 = (void *)objc_claimAutoreleasedReturnValue([v12 primitiveDataBuffer]);
                v323[0] = v20;
                v322[1] = @"srcOffset";
                id v21 = v12;
                id v22 = v11;
                uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v21 primitiveDataBufferOffset]));
                v323[1] = v23;
                v323[2] = v19;
                v322[2] = @"dstBuffer";
                v322[3] = @"length";
                uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v18));
                v323[3] = v24;
                uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v323,  v322,  4LL));

                id v11 = v22;
                unsigned __int8 v12 = v21;

                [v5 addObject:v25];
                [v21 setPrimitiveDataBuffer:v19];
                [v21 setPrimitiveDataBufferOffset:0];
              }
            }

            id v26 = v12;
            uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 vertexBuffer]);

            uint64_t v252 = v12;
            if (v27)
            {
              id v28 = (void *)objc_claimAutoreleasedReturnValue([v26 vertexBuffer]);
              id v29 = [v28 length];
              int64_t v30 = v29 - (_BYTE *)[v26 vertexBufferOffset];

              id v31 = [v257 newBufferWithLength:v30 options:0];
              [v31 setLabel:@"gputools.ADSVertexBuffer"];
              v320[0] = @"srcBuffer";
              uint64_t v32 = v11;
              uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v26 vertexBuffer]);
              v321[0] = v33;
              v320[1] = @"srcOffset";
              uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v26 vertexBufferOffset]));
              v321[1] = v34;
              v321[2] = v31;
              v320[2] = @"dstBuffer";
              v320[3] = @"length";
              uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v30));
              v321[3] = v35;
              uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v321,  v320,  4LL));

              id v11 = v32;
              unsigned __int8 v12 = v252;
              [v5 addObject:v36];
              [v26 setVertexBuffer:v31];
              [v26 setVertexBufferOffset:0];
            }

            char v37 = (void *)objc_claimAutoreleasedReturnValue([v26 indexBuffer]);

            if (v37)
            {
              uint64_t v38 = 3 * (void)[v26 triangleCount];
              id v39 = [v26 indexType];
              char v40 = 1;
              if (v39) {
                char v40 = 2;
              }
              uint64_t v41 = v38 << v40;
              else {
                uint64_t v42 = v38 << v40;
              }
              id v43 = [v257 newBufferWithLength:v42 options:0];
              [v43 setLabel:@"gputools.ADSIndexBuffer"];
              v318[0] = @"srcBuffer";
              id v44 = (void *)objc_claimAutoreleasedReturnValue([v26 indexBuffer]);
              v319[0] = v44;
              v318[1] = @"srcOffset";
              uint64_t v45 = v11;
              uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v26 indexBufferOffset]));
              v319[1] = v46;
              v319[2] = v43;
              v318[2] = @"dstBuffer";
              v318[3] = @"length";
              uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v41));
              v319[3] = v47;
              uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v319,  v318,  4LL));

              id v11 = v45;
              unsigned __int8 v12 = v252;

              [v5 addObject:v48];
              [v26 setIndexBuffer:v43];
              [v26 setIndexBufferOffset:0];
            }

            if ((objc_opt_respondsToSelector(v26, "transformationMatrixBuffer") & 1) == 0) {
              goto LABEL_50;
            }
            id v49 = (void *)objc_claimAutoreleasedReturnValue([v26 transformationMatrixBuffer]);

            if (!v49) {
              goto LABEL_50;
            }
            id v50 = [v257 newBufferWithLength:48 options:0];
            [v50 setLabel:@"gputools.ADSTransformationMatrixBuffer"];
            v316[0] = @"srcBuffer";
            __int128 v51 = (void *)objc_claimAutoreleasedReturnValue([v26 transformationMatrixBuffer]);
            v317[0] = v51;
            v316[1] = @"srcOffset";
            uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v26 transformationMatrixBufferOffset]));
            v317[1] = v52;
            v317[2] = v50;
            v316[2] = @"dstBuffer";
            v316[3] = @"length";
            uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", 48LL));
            v317[3] = v53;
            uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v317,  v316,  4LL));

            [v5 addObject:v54];
            uint64_t v55 = v26;
            id v56 = v50;
            id v57 = v50;
LABEL_47:
            [v55 setTransformationMatrixBuffer:v57];
            [v26 setTransformationMatrixBufferOffset:0];
            goto LABEL_48;
          }

          uint64_t v58 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureBoundingBoxGeometryDescriptor, v14);
          if ((objc_opt_isKindOfClass(v12, v58) & 1) != 0)
          {
            id v60 = v12;
            __int128 v61 = (void *)objc_claimAutoreleasedReturnValue([v60 boundingBoxBuffer]);

            if (v61)
            {
              id v62 = [v60 boundingBoxCount];
              unint64_t v63 = (void)[v60 boundingBoxStride] * (void)v62;
              if (v63 <= 1) {
                uint64_t v64 = 1LL;
              }
              else {
                uint64_t v64 = v63;
              }
              id v65 = [v257 newBufferWithLength:v64 options:0];
              [v65 setLabel:@"gputools.ADSBBoxBuffer"];
              v314[0] = @"srcBuffer";
              uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v60 boundingBoxBuffer]);
              v315[0] = v66;
              v314[1] = @"srcOffset";
              __int128 v67 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v60 boundingBoxBufferOffset]));
              v315[1] = v67;
              v315[2] = v65;
              v314[2] = @"dstBuffer";
              v314[3] = @"length";
              __int128 v68 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v63));
              v315[3] = v68;
              uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v315,  v314,  4LL));

              [v5 addObject:v54];
              id v56 = v65;
              [v60 setBoundingBoxBuffer:v65];
              [v60 setBoundingBoxBufferOffset:0];
              goto LABEL_48;
            }

            goto LABEL_50;
          }

          uint64_t v69 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionTriangleGeometryDescriptor, v59);
          if ((objc_opt_isKindOfClass(v12, v69) & 1) != 0)
          {
            uint64_t v246 = v11;
            v253 = v12;
            id v71 = v12;
            __int128 v270 = 0u;
            __int128 v271 = 0u;
            __int128 v272 = 0u;
            __int128 v273 = 0u;
            id v244 = v71;
            id v72 = (void *)objc_claimAutoreleasedReturnValue([v71 vertexBuffers]);
            id v73 = [v72 countByEnumeratingWithState:&v270 objects:v313 count:16];
            if (v73)
            {
              id v74 = v73;
              uint64_t v75 = *(void *)v271;
              do
              {
                for (uint64_t i = 0LL; i != v74; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v271 != v75) {
                    objc_enumerationMutation(v72);
                  }
                  uint64_t v77 = *(void **)(*((void *)&v270 + 1) + 8LL * (void)i);
                  uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v77 buffer]);
                  uint64_t v79 = [v78 length];
                  int64_t v80 = v79 - (_BYTE *)[v77 offset];

                  id v81 = [v257 newBufferWithLength:v80 options:0];
                  [v81 setLabel:@"gputools.ADSMotionVertexBuffer"];
                  v311[0] = @"srcBuffer";
                  uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v77 buffer]);
                  v312[0] = v82;
                  v311[1] = @"srcOffset";
                  id v83 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v77 offset]));
                  v312[1] = v83;
                  v312[2] = v81;
                  v311[2] = @"dstBuffer";
                  v311[3] = @"length";
                  id v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v80));
                  v312[3] = v84;
                  __int16 v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v312,  v311,  4LL));

                  id v5 = v256;
                  [v256 addObject:v85];
                  [v77 setBuffer:v81];
                  [v77 setOffset:0];
                }

                id v74 = [v72 countByEnumeratingWithState:&v270 objects:v313 count:16];
              }

              while (v74);
            }

            id v26 = v244;
            int v86 = (void *)objc_claimAutoreleasedReturnValue([v244 indexBuffer]);

            if (v86)
            {
              uint64_t v87 = 3 * (void)[v244 triangleCount];
              id v88 = [v244 indexType];
              char v89 = 1;
              if (v88) {
                char v89 = 2;
              }
              uint64_t v90 = v87 << v89;
              else {
                uint64_t v91 = v87 << v89;
              }
              id v92 = [v257 newBufferWithLength:v91 options:0];
              [v92 setLabel:@"gputools.ADSMotionIndexBuffer"];
              v309[0] = @"srcBuffer";
              uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue([v244 indexBuffer]);
              v310[0] = v93;
              v309[1] = @"srcOffset";
              id v94 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v244 indexBufferOffset]));
              v310[1] = v94;
              v310[2] = v92;
              v309[2] = @"dstBuffer";
              v309[3] = @"length";
              unint64_t v95 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v90));
              v310[3] = v95;
              id v96 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v310,  v309,  4LL));

              id v5 = v256;
              [v256 addObject:v96];
              [v244 setIndexBuffer:v92];
              [v244 setIndexBufferOffset:0];
            }

            id v11 = v246;
            unsigned __int8 v12 = v253;
            if ((objc_opt_respondsToSelector(v244, "transformationMatrixBuffer") & 1) == 0) {
              goto LABEL_50;
            }
            id v97 = (void *)objc_claimAutoreleasedReturnValue([v244 transformationMatrixBuffer]);

            if (!v97) {
              goto LABEL_50;
            }
            id v98 = [v257 newBufferWithLength:48 options:0];
            [v98 setLabel:@"gputools.ADSMotionTransformationMatrixBuffer"];
            v307[0] = @"srcBuffer";
            uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue([v244 transformationMatrixBuffer]);
            v308[0] = v99;
            v307[1] = @"srcOffset";
            unint64_t v100 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v244 transformationMatrixBufferOffset]));
            v308[1] = v100;
            v308[2] = v98;
            v307[2] = @"dstBuffer";
            v307[3] = @"length";
            unint64_t v101 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  48LL));
            v308[3] = v101;
            uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v308,  v307,  4LL));

            id v5 = v256;
            [v256 addObject:v54];
            uint64_t v55 = v244;
            id v56 = v98;
            id v57 = v98;
            goto LABEL_47;
          }

          uint64_t v102 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor, v70);
          if ((objc_opt_isKindOfClass(v12, v102) & 1) != 0)
          {
            id v104 = v12;
            __int128 v266 = 0u;
            __int128 v267 = 0u;
            __int128 v268 = 0u;
            __int128 v269 = 0u;
            id v56 = (void *)objc_claimAutoreleasedReturnValue([v104 boundingBoxBuffers]);
            id v105 = [v56 countByEnumeratingWithState:&v266 objects:v306 count:16];
            if (v105)
            {
              id v106 = v105;
              uint64_t v254 = v12;
              uint64_t v247 = v11;
              uint64_t v107 = *(void *)v267;
              do
              {
                for (uint64_t j = 0LL; j != v106; uint64_t j = (char *)j + 1)
                {
                  if (*(void *)v267 != v107) {
                    objc_enumerationMutation(v56);
                  }
                  __int128 v109 = *(void **)(*((void *)&v266 + 1) + 8LL * (void)j);
                  unint64_t v110 = (void *)objc_claimAutoreleasedReturnValue([v109 buffer]);

                  if (v110)
                  {
                    uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue([v109 buffer]);
                    unsigned int v112 = [v111 length];
                    int64_t v113 = v112 - (_BYTE *)[v109 offset];

                    id v114 = [v257 newBufferWithLength:v113 options:0];
                    [v114 setLabel:@"gputools.ADSMotionBBoxBuffer"];
                    v304[0] = @"srcBuffer";
                    id v115 = (void *)objc_claimAutoreleasedReturnValue([v109 buffer]);
                    v305[0] = v115;
                    v304[1] = @"srcOffset";
                    uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v109 offset]));
                    v305[1] = v116;
                    v305[2] = v114;
                    v304[2] = @"dstBuffer";
                    v304[3] = @"length";
                    __int128 v117 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v113));
                    v305[3] = v117;
                    uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v305,  v304,  4LL));

                    id v5 = v256;
                    [v256 addObject:v118];
                    [v109 setBuffer:v114];
                    [v109 setOffset:0];
                  }
                }

                id v106 = [v56 countByEnumeratingWithState:&v266 objects:v306 count:16];
              }

              while (v106);
              id v11 = v247;
              unsigned __int8 v12 = v254;
            }

            goto LABEL_49;
          }

          uint64_t v119 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureCurveGeometryDescriptor, v103);
          if ((objc_opt_isKindOfClass(v12, v119) & 1) != 0)
          {
            id v121 = v12;
            __int128 v122 = (void *)objc_claimAutoreleasedReturnValue([v121 controlPointBuffer]);

            if (v122)
            {
              uint64_t v123 = (void *)objc_claimAutoreleasedReturnValue([v121 controlPointBuffer]);
              uint64_t v124 = [v123 length];
              int64_t v125 = v124 - (_BYTE *)[v121 controlPointBufferOffset];

              id v126 = [v257 newBufferWithLength:v125 options:0];
              [v126 setLabel:@"gputools.ADSCurveControlPointBuffer"];
              v302[0] = @"srcBuffer";
              id v127 = (void *)objc_claimAutoreleasedReturnValue([v121 controlPointBuffer]);
              v303[0] = v127;
              v302[1] = @"srcOffset";
              uint64_t v128 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v121 controlPointBufferOffset]));
              v303[1] = v128;
              v303[2] = v126;
              v302[2] = @"dstBuffer";
              v302[3] = @"length";
              uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v125));
              v303[3] = v129;
              id v130 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v303,  v302,  4LL));

              id v5 = v256;
              [v256 addObject:v130];
              [v121 setControlPointBuffer:v126];
              [v121 setControlPointBufferOffset:0];
            }

            id v131 = (void *)objc_claimAutoreleasedReturnValue([v121 radiusBuffer]);

            if (v131)
            {
              id v132 = (void *)objc_claimAutoreleasedReturnValue([v121 radiusBuffer]);
              uint64_t v133 = [v132 length];
              int64_t v134 = v133 - (_BYTE *)[v121 radiusBufferOffset];

              id v135 = [v257 newBufferWithLength:v134 options:0];
              [v135 setLabel:@"gputools.ADSCurveRadiusBuffer"];
              v300[0] = @"srcBuffer";
              __int128 v136 = (void *)objc_claimAutoreleasedReturnValue([v121 radiusBuffer]);
              v301[0] = v136;
              v300[1] = @"srcOffset";
              __int128 v137 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v121 radiusBufferOffset]));
              v301[1] = v137;
              v301[2] = v135;
              v300[2] = @"dstBuffer";
              v300[3] = @"length";
              __int128 v138 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v134));
              v301[3] = v138;
              __int128 v139 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v301,  v300,  4LL));

              id v5 = v256;
              [v256 addObject:v139];
              [v121 setRadiusBuffer:v135];
              [v121 setRadiusBufferOffset:0];
            }

            __int128 v140 = (void *)objc_claimAutoreleasedReturnValue([v121 indexBuffer]);

            if (v140)
            {
              __int128 v141 = (void *)objc_claimAutoreleasedReturnValue([v121 indexBuffer]);
              __int128 v142 = [v141 length];
              int64_t v143 = v142 - (_BYTE *)[v121 indexBufferOffset];

              id v144 = [v257 newBufferWithLength:v143 options:0];
              [v144 setLabel:@"gputools.ADSCurveIndexBuffer"];
              v298[0] = @"srcBuffer";
              __int128 v145 = (void *)objc_claimAutoreleasedReturnValue([v121 indexBuffer]);
              v299[0] = v145;
              v298[1] = @"srcOffset";
              __int128 v146 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v121 indexBufferOffset]));
              v299[1] = v146;
              v299[2] = v144;
              v298[2] = @"dstBuffer";
              v298[3] = @"length";
              __int128 v147 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v143));
              v299[3] = v147;
              uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v299,  v298,  4LL));

              id v5 = v256;
              [v256 addObject:v54];
              id v56 = v144;
              [v121 setIndexBuffer:v144];
              __int128 v148 = v121;
              goto LABEL_92;
            }

            goto LABEL_50;
          }

          uint64_t v149 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionCurveGeometryDescriptor, v120);
          if ((objc_opt_isKindOfClass(v12, v149) & 1) != 0)
          {
            int v248 = v11;
            uint64_t v255 = v12;
            id v150 = v12;
            __int128 v262 = 0u;
            __int128 v263 = 0u;
            __int128 v264 = 0u;
            __int128 v265 = 0u;
            id v245 = v150;
            __int128 v151 = (void *)objc_claimAutoreleasedReturnValue([v150 controlPointBuffers]);
            id v152 = [v151 countByEnumeratingWithState:&v262 objects:v297 count:16];
            if (v152)
            {
              id v153 = v152;
              uint64_t v154 = *(void *)v263;
              do
              {
                for (uint64_t k = 0LL; k != v153; uint64_t k = (char *)k + 1)
                {
                  if (*(void *)v263 != v154) {
                    objc_enumerationMutation(v151);
                  }
                  __int128 v156 = *(void **)(*((void *)&v262 + 1) + 8LL * (void)k);
                  __int128 v157 = (void *)objc_claimAutoreleasedReturnValue([v156 buffer]);

                  if (v157)
                  {
                    __int128 v158 = (void *)objc_claimAutoreleasedReturnValue([v156 buffer]);
                    __int128 v159 = [v158 length];
                    int64_t v160 = v159 - (_BYTE *)[v156 offset];

                    id v161 = [v257 newBufferWithLength:v160 options:0];
                    [v161 setLabel:@"gputools.ADSMotionCurveControlPointBuffer"];
                    v295[0] = @"srcBuffer";
                    uint64_t v162 = (void *)objc_claimAutoreleasedReturnValue([v156 buffer]);
                    v296[0] = v162;
                    v295[1] = @"srcOffset";
                    unsigned __int8 v163 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v156 offset]));
                    v296[1] = v163;
                    v296[2] = v161;
                    v295[2] = @"dstBuffer";
                    v295[3] = @"length";
                    unint64_t v164 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v160));
                    v296[3] = v164;
                    unint64_t v165 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v296,  v295,  4LL));

                    id v5 = v256;
                    [v256 addObject:v165];
                    [v156 setBuffer:v161];
                    [v156 setOffset:0];
                  }
                }

                id v153 = [v151 countByEnumeratingWithState:&v262 objects:v297 count:16];
              }

              while (v153);
            }

            __int128 v260 = 0u;
            __int128 v261 = 0u;
            __int128 v258 = 0u;
            __int128 v259 = 0u;
            uint64_t v166 = (void *)objc_claimAutoreleasedReturnValue([v245 radiusBuffers]);
            id v167 = [v166 countByEnumeratingWithState:&v258 objects:v294 count:16];
            if (v167)
            {
              id v168 = v167;
              uint64_t v169 = *(void *)v259;
              do
              {
                for (uint64_t m = 0LL; m != v168; uint64_t m = (char *)m + 1)
                {
                  if (*(void *)v259 != v169) {
                    objc_enumerationMutation(v166);
                  }
                  id v171 = *(void **)(*((void *)&v258 + 1) + 8LL * (void)m);
                  id v172 = (void *)objc_claimAutoreleasedReturnValue([v171 buffer]);

                  if (v172)
                  {
                    id v173 = (void *)objc_claimAutoreleasedReturnValue([v171 buffer]);
                    uint64_t v174 = [v173 length];
                    int64_t v175 = v174 - (_BYTE *)[v171 offset];

                    id v176 = [v257 newBufferWithLength:v175 options:0];
                    [v176 setLabel:@"gputools.ADSMotionCurveRadiusBuffer"];
                    v292[0] = @"srcBuffer";
                    unint64_t v177 = (void *)objc_claimAutoreleasedReturnValue([v171 buffer]);
                    v293[0] = v177;
                    v292[1] = @"srcOffset";
                    uint64_t v178 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v171 offset]));
                    v293[1] = v178;
                    v293[2] = v176;
                    v292[2] = @"dstBuffer";
                    v292[3] = @"length";
                    uint64_t v179 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v175));
                    v293[3] = v179;
                    unsigned int v180 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v293,  v292,  4LL));

                    id v5 = v256;
                    [v256 addObject:v180];
                    [v171 setBuffer:v176];
                    [v171 setOffset:0];
                  }
                }

                id v168 = [v166 countByEnumeratingWithState:&v258 objects:v294 count:16];
              }

              while (v168);
            }

            unsigned int v181 = (void *)objc_claimAutoreleasedReturnValue([v245 indexBuffer]);
            id v11 = v248;
            unsigned __int8 v12 = v255;
            if (v181)
            {
              id v182 = (void *)objc_claimAutoreleasedReturnValue([v245 indexBuffer]);
              uint64_t v183 = [v182 length];
              int64_t v184 = v183 - (_BYTE *)[v245 indexBufferOffset];

              id v185 = [v257 newBufferWithLength:v184 options:0];
              [v185 setLabel:@"gputools.ADSMotionCurveRadiusBuffer"];
              v290[0] = @"srcBuffer";
              unsigned int v186 = (void *)objc_claimAutoreleasedReturnValue([v245 indexBuffer]);
              v291[0] = v186;
              v290[1] = @"srcOffset";
              uint64_t v187 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v245 indexBufferOffset]));
              v291[1] = v187;
              v291[2] = v185;
              v290[2] = @"dstBuffer";
              v290[3] = @"length";
              uint64_t v188 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v184));
              v291[3] = v188;
              uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v291,  v290,  4LL));

              id v5 = v256;
              [v256 addObject:v54];
              id v56 = v185;
              [v245 setIndexBuffer:v185];
              __int128 v148 = v245;
LABEL_92:
              [v148 setIndexBufferOffset:0];
LABEL_48:

LABEL_49:
            }

LABEL_124:
  return v6;
}

id copyAndNullifyReferencesInDescriptor(void *a1)
{
  id v1 = [a1 copy];
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___MTLPrimitiveAccelerationStructureDescriptor, v2);
  if ((objc_opt_isKindOfClass(v1, v3) & 1) != 0)
  {
    __int128 v83 = 0u;
    __int128 v84 = 0u;
    __int128 v81 = 0u;
    __int128 v82 = 0u;
    id v61 = v1;
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v1 geometryDescriptors]);
    id v6 = [v5 countByEnumeratingWithState:&v81 objects:v89 count:16];
    if (!v6) {
      goto LABEL_55;
    }
    id v7 = v6;
    uint64_t v8 = &CACurrentMediaTime_ptr;
    uint64_t v9 = &CACurrentMediaTime_ptr;
    uint64_t v10 = *(void *)v82;
    uint64_t v64 = *(void *)v82;
    while (1)
    {
      id v11 = 0LL;
      id v63 = v7;
      do
      {
        if (*(void *)v82 != v10) {
          objc_enumerationMutation(v5);
        }
        unsigned __int8 v12 = *(void **)(*((void *)&v81 + 1) + 8LL * (void)v11);
        if ((objc_opt_respondsToSelector(v12, "primitiveDataBuffer") & 1) != 0)
        {
          [v12 setPrimitiveDataBuffer:0];
          [v12 setPrimitiveDataBufferOffset:0];
          [v12 setPrimitiveDataStride:0];
          [v12 setPrimitiveDataElementSize:0];
        }

        uint64_t v14 = objc_opt_class(v8[158], v13);
        if ((objc_opt_isKindOfClass(v12, v14) & 1) != 0)
        {
          id v16 = v12;
          [v16 setVertexBuffer:0];
          [v16 setVertexBufferOffset:0];
          [v16 setIndexBuffer:0];
          [v16 setIndexBufferOffset:0];
          if ((objc_opt_respondsToSelector(v16, "transformationMatrixBuffer") & 1) == 0) {
            goto LABEL_52;
          }
          goto LABEL_23;
        }

        uint64_t v17 = objc_opt_class(v9[152], v15);
        if ((objc_opt_isKindOfClass(v12, v17) & 1) != 0)
        {
          id v19 = v12;
          [v19 setBoundingBoxBuffer:0];
          [v19 setBoundingBoxBufferOffset:0];
        }

        else
        {
          uint64_t v20 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionTriangleGeometryDescriptor, v18);
          if ((objc_opt_isKindOfClass(v12, v20) & 1) != 0)
          {
            id v22 = v8;
            uint64_t v23 = v5;
            id v16 = v12;
            __int128 v77 = 0u;
            __int128 v78 = 0u;
            __int128 v79 = 0u;
            __int128 v80 = 0u;
            uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v16 vertexBuffers]);
            id v25 = [v24 countByEnumeratingWithState:&v77 objects:v88 count:16];
            if (v25)
            {
              id v26 = v25;
              uint64_t v27 = *(void *)v78;
              do
              {
                for (uint64_t i = 0LL; i != v26; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v78 != v27) {
                    objc_enumerationMutation(v24);
                  }
                  id v29 = *(void **)(*((void *)&v77 + 1) + 8LL * (void)i);
                  [v29 setBuffer:0];
                  [v29 setOffset:0];
                }

                id v26 = [v24 countByEnumeratingWithState:&v77 objects:v88 count:16];
              }

              while (v26);
            }

            [v16 setIndexBuffer:0];
            [v16 setIndexBufferOffset:0];
            id v5 = v23;
            uint64_t v8 = v22;
            id v7 = v63;
            uint64_t v10 = v64;
            uint64_t v9 = &CACurrentMediaTime_ptr;
            if ((objc_opt_respondsToSelector(v16, "transformationMatrixBuffer") & 1) == 0) {
              goto LABEL_52;
            }
LABEL_23:
            [v16 setTransformationMatrixBuffer:0];
            [v16 setTransformationMatrixBufferOffset:0];
            goto LABEL_52;
          }

          uint64_t v30 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor, v21);
          if ((objc_opt_isKindOfClass(v12, v30) & 1) != 0)
          {
            id v32 = v12;
            __int128 v73 = 0u;
            __int128 v74 = 0u;
            __int128 v75 = 0u;
            __int128 v76 = 0u;
            uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v32 boundingBoxBuffers]);
            id v34 = [v33 countByEnumeratingWithState:&v73 objects:v87 count:16];
            if (v34)
            {
              id v35 = v34;
              uint64_t v36 = *(void *)v74;
              do
              {
                for (uint64_t j = 0LL; j != v35; uint64_t j = (char *)j + 1)
                {
                  if (*(void *)v74 != v36) {
                    objc_enumerationMutation(v33);
                  }
                  uint64_t v38 = *(void **)(*((void *)&v73 + 1) + 8LL * (void)j);
                  [v38 setBuffer:0];
                  [v38 setOffset:0];
                }

                id v35 = [v33 countByEnumeratingWithState:&v73 objects:v87 count:16];
              }

              while (v35);
            }

LABEL_51:
            uint64_t v9 = &CACurrentMediaTime_ptr;
            uint64_t v10 = v64;
            goto LABEL_52;
          }

          uint64_t v39 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureCurveGeometryDescriptor, v31);
          if ((objc_opt_isKindOfClass(v12, v39) & 1) == 0)
          {
            uint64_t v42 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionCurveGeometryDescriptor, v40);
            if ((objc_opt_isKindOfClass(v12, v42) & 1) == 0) {
              goto LABEL_53;
            }
            id v43 = v12;
            __int128 v69 = 0u;
            __int128 v70 = 0u;
            __int128 v71 = 0u;
            __int128 v72 = 0u;
            id v62 = v43;
            id v44 = (void *)objc_claimAutoreleasedReturnValue([v43 controlPointBuffers]);
            id v45 = [v44 countByEnumeratingWithState:&v69 objects:v86 count:16];
            if (v45)
            {
              id v46 = v45;
              uint64_t v47 = *(void *)v70;
              do
              {
                for (uint64_t k = 0LL; k != v46; uint64_t k = (char *)k + 1)
                {
                  if (*(void *)v70 != v47) {
                    objc_enumerationMutation(v44);
                  }
                  id v49 = *(void **)(*((void *)&v69 + 1) + 8LL * (void)k);
                  [v49 setBuffer:0];
                  [v49 setOffset:0];
                }

                id v46 = [v44 countByEnumeratingWithState:&v69 objects:v86 count:16];
              }

              while (v46);
            }

            __int128 v67 = 0u;
            __int128 v68 = 0u;
            __int128 v65 = 0u;
            __int128 v66 = 0u;
            id v50 = (void *)objc_claimAutoreleasedReturnValue([v62 radiusBuffers]);
            id v51 = [v50 countByEnumeratingWithState:&v65 objects:v85 count:16];
            if (v51)
            {
              id v52 = v51;
              uint64_t v53 = *(void *)v66;
              do
              {
                for (uint64_t m = 0LL; m != v52; uint64_t m = (char *)m + 1)
                {
                  if (*(void *)v66 != v53) {
                    objc_enumerationMutation(v50);
                  }
                  uint64_t v55 = *(void **)(*((void *)&v65 + 1) + 8LL * (void)m);
                  [v55 setBuffer:0];
                  [v55 setOffset:0];
                }

                id v52 = [v50 countByEnumeratingWithState:&v65 objects:v85 count:16];
              }

              while (v52);
            }

            [v62 setIndexBuffer:0];
            [v62 setIndexBufferOffset:0];
            goto LABEL_51;
          }

          id v41 = v12;
          [v41 setControlPointBuffer:0];
          [v41 setControlPointBufferOffset:0];
          [v41 setRadiusBuffer:0];
          [v41 setRadiusBufferOffset:0];
          [v41 setIndexBuffer:0];
          [v41 setIndexBufferOffset:0];
        }

LABEL_53:
      id v94 = v5[1].inst_meths;
      unint64_t v95 = v94;
      if (v15 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v94))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  v95,  OS_SIGNPOST_INTERVAL_END,  v12,  "Capture-downloadRequest",  "",  buf,  2u);
      }

      objc_autoreleasePoolPop(v6);
    }
  }

  id v96 = (unint64_t *)(*(void *)(a1 + 40) + 144LL);
  id v97 = [v3 usedGPUMemory];
  do
    id v98 = __ldaxr(v96);
  while (__stlxr(v98 - (void)v97, v96));
  [v3 flush];

  objc_autoreleasePoolPop(context);
  uint64_t v99 = [*(id *)(a1 + 32) downloadValue];
  unint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) downloadEvent]);
  [v100 setSignaledValue:v99];

  unint64_t v101 = *(dispatch_group_s **)(a1 + 48);
  if (v101) {
    dispatch_group_leave(v101);
  }
}

uint64_t GTResourceDownloaderRequest_compareType(uint64_t a1, uint64_t a2)
{
  int v3 = ResourceTypeSortOrder(*(unsigned __int8 *)(a2 + 46));
  return v3 - ResourceTypeSortOrder(*(unsigned __int8 *)(a1 + 46));
}

void DownloadHeap(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = (id)*a3;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 backbuffer]);
  id v9 = DEVICEOBJECT(v8);
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);

  uint64_t v12 = a3[6];
  uint64_t v11 = a3[7];
  id v13 = [v10 protectionOptions];
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v5 getGPUBuffer:v11 context:v6]);
  if (!v13)
  {
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v6 blitCommandEncoder]);

    id v16 = (void *)objc_claimAutoreleasedReturnValue([v6 blitCommandEncoder]);
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v14 buffer]);
    objc_msgSend( v16,  "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:",  v10,  v12,  v17,  objc_msgSend(v14, "offset"),  v11);
  }

  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  *(_OWORD *)__int128 __str = 0u;
  __int128 v26 = 0u;
  GTResourceDownloaderGetResourceFilename((uint64_t)a3, 0, __str, 0x80uLL);
  id v18 = objc_claimAutoreleasedReturnValue([v14 buffer]);
  id v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  (char *)[v14 offset] + (void)objc_msgSend(v18, "contents"),  objc_msgSend(v14, "size"),  0));

  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v6 objects]);
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", __str));
  [v20 addObject:v21];

  id v22 = (void *)objc_claimAutoreleasedReturnValue([v6 objects]);
  [v22 addObject:v19];

  id v23 = [v14 size];
  do
    unint64_t v24 = __ldaxr(&g_GPUDataSize);
  while (__stlxr((unint64_t)v23 + v24, &g_GPUDataSize));
}

void DownloadBuffer(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = (id)*a3;
  uint64_t v9 = a3[6];
  uint64_t v8 = a3[7];
  id v10 = [v7 protectionOptions];
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v5 getGPUBuffer:v8 context:v6]);
  if (!v10)
  {
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v6 blitCommandEncoder]);

    id v13 = (void *)objc_claimAutoreleasedReturnValue([v6 blitCommandEncoder]);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v11 buffer]);
    objc_msgSend( v13,  "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:",  v7,  v9,  v14,  objc_msgSend(v11, "offset"),  v8);
  }

  GTResourceDownloaderGetResourceFilename((uint64_t)a3, 0, __str, 0x80uLL);
  id v15 = objc_claimAutoreleasedReturnValue([v11 buffer]);
  id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  (char *)[v11 offset] + (void)objc_msgSend(v15, "contents"),  objc_msgSend(v11, "size"),  0));

  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v6 objects]);
  id v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", __str));
  [v17 addObject:v18];

  id v19 = (void *)objc_claimAutoreleasedReturnValue([v6 objects]);
  [v19 addObject:v16];

  id v20 = [v16 length];
  do
    unint64_t v21 = __ldaxr(&g_GPUDataSize);
  while (__stlxr((unint64_t)v20 + v21, &g_GPUDataSize));
}

void DownloadIOSurface(void *a1, void *a2, id *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = *a3;
  if ([v7 conformsToProtocol:&OBJC_PROTOCOL___MTLTexture])
  {
    uint64_t v31 = (uint64_t)a3;
    id v32 = v7;
    uint64_t v33 = v6;
    id v34 = v5;
    id v37 = v7;
    uint64_t v8 = (__IOSurface *)[v37 iosurface];
    size_t PlaneCount = IOSurfaceGetPlaneCount(v8);
    if (PlaneCount <= 1) {
      uint64_t v10 = 1LL;
    }
    else {
      uint64_t v10 = PlaneCount;
    }
    uint64_t v36 = v10;
    size_t v11 = (48 * v10 + 279) & 0xFFFFFFFFFFFFFF00LL;
    size_t AllocSize = IOSurfaceGetAllocSize(v8);
    size_t v30 = AllocSize + v11;
    id v13 = (void *)GTCoreAlloc(AllocSize, AllocSize + v11);
    bzero(v13, v11);
    *id v13 = 0x63617074757265LL;
    *((_DWORD *)v13 + 2) = 65538;
    *((_DWORD *)v13 + 3) = v11;
    size_t v35 = v11;
    char ProtectionOptions = IOSurfaceGetProtectionOptions(v8);
    uint64_t v15 = 0LL;
    for (size_t i = 0LL; i != v36; ++i)
    {
      size_t HeightOfPlane = IOSurfaceGetHeightOfPlane(v8, i);
      size_t WidthOfPlane = IOSurfaceGetWidthOfPlane(v8, i);
      size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(v8, i);
      size_t SizeOfPlane = IOSurfaceGetSizeOfPlane(v8, i);
      id v21 = [v37 pixelFormat];
      id v22 = &v13[6 * v13[2] + 3];
      *id v22 = v21;
      v22[1] = WidthOfPlane;
      v22[2] = HeightOfPlane;
      v22[3] = 1LL;
      void v22[4] = BytesPerRowOfPlane;
      void v22[5] = SizeOfPlane;
      ++v13[2];
      if ((ProtectionOptions & 1) == 0)
      {
        IOSurfaceLock(v8, 1u, 0LL);
        BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(v8, i);
        memcpy((char *)v13 + v15 + v35, BaseAddressOfPlane, SizeOfPlane);
        IOSurfaceUnlock(v8, 1u, 0LL);
      }

      v15 += SizeOfPlane;
    }

    GTResourceDownloaderGetResourceFilename(v31, *(_DWORD *)(v31 + 56), __str, 0x80uLL);
    unint64_t v24 = -[NSData initWithBytesNoCopy:length:deallocator:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytesNoCopy:length:deallocator:",  v13,  v30,  &__block_literal_global_7393);
    id v6 = v33;
    id v25 = (void *)objc_claimAutoreleasedReturnValue([v33 objects]);
    __int128 v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", __str));
    [v25 addObject:v26];

    __int128 v27 = (void *)objc_claimAutoreleasedReturnValue([v33 objects]);
    [v27 addObject:v24];

    NSUInteger v28 = -[NSData length](v24, "length");
    do
      unint64_t v29 = __ldaxr(&g_GPUDataSize);
    while (__stlxr(v29 + v28, &g_GPUDataSize));

    id v5 = v34;
    id v7 = v32;
  }
}

void DownloadTexture(void *a1, void *a2, id *a3, int a4)
{
  id v103 = a1;
  id v102 = a2;
  id v7 = *a3;
  id v8 = DEVICEOBJECT(v7);
  unint64_t v101 = (void *)objc_claimAutoreleasedReturnValue(v8);

  if (a4 >= 1)
  {
    uint64_t v9 = 0LL;
    uint64_t v100 = a4;
    uint64_t v111 = (uint64_t)a3;
    do
    {
      context = objc_autoreleasePoolPush();
      uint64_t v10 = &a3[11 * v9];
      uint64_t v11 = v9;
      id v12 = v103;
      id v13 = v102;
      id v138 = v101;
      id v14 = v138;
      id v139 = v14;
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 device]);
      id v16 = [v14 pixelFormat];
      id v17 = [v14 sampleCount];
      uint64_t v124 = (char *)[v14 storageMode];
      unsigned int v112 = [v14 isFramebufferOnly];
      id v18 = [v14 protectionOptions];
      uint64_t v19 = *((unsigned __int16 *)v10 + 33);
      uint64_t v117 = *((unsigned int *)v10 + 13);
      uint64_t v116 = *((unsigned __int16 *)v10 + 28);
      uint64_t v115 = *((unsigned __int16 *)v10 + 29);
      uint64_t v128 = *((unsigned __int16 *)v10 + 32);
      uint64_t v129 = *((unsigned int *)v10 + 15);
      uint64_t v133 = v129;
      uint64_t v134 = v128;
      unint64_t v126 = (unint64_t)v16;
      uint64_t v127 = v19;
      uint64_t v135 = v19;
      MTLTextureInfo(v15, (uint64_t)v16, &v133, (uint64_t)v17, (uint64_t)__str);
      uint64_t v121 = *(void *)__str;
      size_t v20 = (48LL * *(void *)__str + 279) & 0xFFFFFFFFFFFFFF00LL;
      size_t v104 = v20;
      __int128 v109 = v12;
      id v21 = v12;
      uint64_t v22 = v11;
      uint64_t v118 = v13;
      id v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "getGPUBuffer:context:", *((unsigned int *)v10
                                                                                                 + 19), v13));
      id v24 = objc_claimAutoreleasedReturnValue([v23 buffer]);
      id v25 = [v24 contents];
      uint64_t v120 = v23;
      __int128 v26 = (char *)[v23 offset] + (void)v25;
      __int128 v27 = v15;

      bzero(v26, v20);
      *(void *)__int128 v26 = 0x63617074757265LL;
      id v28 = v14;
      v26[2] = 65538;
      v26[3] = v20;
      int64_t v125 = v26;
      uint64_t v119 = v10;
      if (v18)
      {
        id v29 = v14;
        id v30 = [v29 pixelFormat];
        id v31 = [v29 width];
        id v32 = [v29 height];
        id v33 = v31;
        uint64_t v10 = v119;
        id v34 = (void *)objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( &OBJC_CLASS___MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  v30,  v33,  v32,  0LL));
        id v35 = [v15 newTextureWithDescriptor:v34];

        id v28 = v35;
        id v138 = v28;

        id v139 = v28;
      }

      uint64_t v110 = v22;
      uint64_t v107 = v14;
      if (v112)
      {
        id v36 = v28;
        id v37 = (void *)objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  [v36 pixelFormat],  objc_msgSend(v36, "width"),  objc_msgSend(v36, "height"),  0));
        [v37 setStorageMode:2];
        id v28 = [v15 newTextureWithDescriptor:v37];
        uint64_t v38 = v111 + 88 * v22;

        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[MTLRenderPassDescriptor renderPassDescriptor]( &OBJC_CLASS___MTLRenderPassDescriptor,  "renderPassDescriptor"));
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v39 colorAttachments]);
        id v41 = (void *)objc_claimAutoreleasedReturnValue([v40 objectAtIndexedSubscript:0]);
        [v41 setTexture:v28];

        uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v39 colorAttachments]);
        id v43 = (void *)objc_claimAutoreleasedReturnValue([v42 objectAtIndexedSubscript:0]);
        [v43 setStoreAction:1];

        id v44 = [v118 newCommandBuffer];
        id v45 = (void *)objc_claimAutoreleasedReturnValue([v44 renderCommandEncoderWithDescriptor:v39]);

        id v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v109, "getFramebufferPipeline:", objc_msgSend(v36, "pixelFormat")));
        [v45 setRenderPipelineState:v46];
        [v45 setFragmentTexture:v36 atIndex:0];
        [v45 drawPrimitives:3 vertexStart:0 vertexCount:3];
        [v45 endEncoding];
        [v44 commit];
        id v138 = v28;

        uint64_t v10 = v119;
        uint64_t v22 = v110;
      }

      uint64_t v47 = v121;
      if ((v126 & 0xFFFFFFFFFFFFFFFELL) == 0x226)
      {
        uint64_t v48 = 94LL;
        if (v126 == 551) {
          uint64_t v48 = 555LL;
        }
        if (v126 == 550) {
          uint64_t v49 = 554LL;
        }
        else {
          uint64_t v49 = v48;
        }
        id v50 = v28;
        id v51 = (void *)objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  v49,  [v50 width],  objc_msgSend(v50, "height"),  0));
        [v51 setStorageMode:2];
        [v51 setUsage:5];
        id v52 = [v15 newTextureWithDescriptor:v51];
        id v53 = v138;
        id v138 = v52;

        uint64_t v54 = v111 + 88 * v22;
        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  10,  [v50 width],  objc_msgSend(v50, "height"),  0));
        [v55 setStorageMode:2];
        [v55 setUsage:5];
        id v105 = [v27 newTextureWithDescriptor:v55];
        id v56 = v139;
        id v139 = v105;

        id v132 = 0LL;
        id v122 = objc_msgSend( v27,  "newLibraryWithSource:options:error:",  @"#include <metal_stdlib>\nusing namespace metal\n;struct VOut { float4 pos [[position]]; float2 uv; };\nvertex VOut Vertex(uint vid [[ vertex_id ]]) {VOut out; out.uv = float2((vid << 1) & 2, vid & 2); out.pos = float4(out.uv * 2.0f + -1.0f, 0.0f, 1.0f); return out; }\nstruct FOut { float4 rt0 [[color(0)]]; float rt1 [[color(1)]]; };\nfragment FOut Fragment(VOut in [[stage_in]], texture2d<float> tex) { FOut out;\nfloat4 texel = tex.read(uint2(tex.get_width() * (in.uv.x), tex.get_height() * (in.uv.y)));out.rt0 = float4(texel.rgb, 0.0);\nout.rt1 = texel.a;\nreturn out; }\n",
                 0LL,
                 &v132);
        id v57 = v132;
        id v113 = [v122 newFunctionWithName:@"Vertex"];
        id v99 = [v122 newFunctionWithName:@"Fragment"];
        uint64_t v58 = objc_opt_new(&OBJC_CLASS___MTLRenderPipelineDescriptor);
        -[MTLRenderPipelineDescriptor setVertexFunction:](v58, "setVertexFunction:", v113);
        -[MTLRenderPipelineDescriptor setFragmentFunction:](v58, "setFragmentFunction:", v99);
        id v59 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor colorAttachments](v58, "colorAttachments"));
        uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v59 objectAtIndexedSubscript:0]);
        [v60 setPixelFormat:v49];

        id v61 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor colorAttachments](v58, "colorAttachments"));
        id v62 = (void *)objc_claimAutoreleasedReturnValue([v61 objectAtIndexedSubscript:1]);
        [v62 setPixelFormat:10];

        id v131 = v57;
        id v63 = [v27 newRenderPipelineStateWithDescriptor:v58 error:&v131];
        id v98 = v131;

        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue( +[MTLRenderPassDescriptor renderPassDescriptor]( &OBJC_CLASS___MTLRenderPassDescriptor,  "renderPassDescriptor"));
        id v65 = v138;
        __int128 v66 = (void *)objc_claimAutoreleasedReturnValue([v64 colorAttachments]);
        __int128 v67 = (void *)objc_claimAutoreleasedReturnValue([v66 objectAtIndexedSubscript:0]);
        [v67 setTexture:v65];

        __int128 v68 = (void *)objc_claimAutoreleasedReturnValue([v64 colorAttachments]);
        __int128 v69 = (void *)objc_claimAutoreleasedReturnValue([v68 objectAtIndexedSubscript:0]);
        [v69 setStoreAction:1];

        __int128 v70 = (void *)objc_claimAutoreleasedReturnValue([v64 colorAttachments]);
        __int128 v71 = (void *)objc_claimAutoreleasedReturnValue([v70 objectAtIndexedSubscript:1]);
        [v71 setTexture:v105];

        __int128 v72 = (void *)objc_claimAutoreleasedReturnValue([v64 colorAttachments]);
        __int128 v73 = (void *)objc_claimAutoreleasedReturnValue([v72 objectAtIndexedSubscript:1]);
        [v73 setStoreAction:1];

        id v74 = [v118 newCommandBuffer];
        __int128 v75 = (void *)objc_claimAutoreleasedReturnValue([v74 renderCommandEncoderWithDescriptor:v64]);

        [v75 setRenderPipelineState:v63];
        [v75 setFragmentTexture:v50 atIndex:0];

        [v75 drawPrimitives:3 vertexStart:0 vertexCount:3];
        [v75 endEncoding];
        [v74 commit];

        uint64_t v10 = v119;
        uint64_t v47 = *(void *)__str;
      }

      id v106 = v27;
      __int128 v76 = (char *)[v120 offset];
      if (v47)
      {
        uint64_t v77 = 0LL;
        id v114 = (unsigned __int16 *)(v10 + 6);
        __int128 v78 = &v76[v104];
        __int128 v79 = &v137;
        do
        {
          __int128 v80 = *((_OWORD *)v79 - 1);
          uint64_t v81 = (uint64_t)&v125[12 * *((void *)v125 + 2) + 6];
          *(void *)uint64_t v81 = v126;
          *(void *)(v81 + _Block_object_dispose(va, 8) = v129;
          *(void *)(v81 + 16) = v128;
          *(void *)(v81 + 24) = v127;
          *(_OWORD *)(v81 + 32) = v80;
          ++*((void *)v125 + 2);
          if (v124 != (_BYTE *)&dword_0 + 3)
          {
            __int128 v123 = v80;
            uint64_t v82 = v47;
            __int128 v83 = (void *)objc_claimAutoreleasedReturnValue([v118 blitCommandEncoder]);

            __int128 v84 = (void *)objc_claimAutoreleasedReturnValue([v118 blitCommandEncoder]);
            uint64_t v85 = (uint64_t)*(&v138 + v77);
            uint64_t v86 = *v114;
            uint64_t v87 = *((unsigned __int16 *)v10 + 25);
            id v88 = (void *)objc_claimAutoreleasedReturnValue([v120 buffer]);
            uint64_t v89 = *v79;
            uint64_t v133 = v117;
            uint64_t v134 = v116;
            uint64_t v135 = v115;
            v130[0] = v129;
            v130[1] = v128;
            v130[2] = v127;
            objc_msgSend( v84,  "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationByte sPerRow:destinationBytesPerImage:options:",  v85,  v86,  v87,  &v133,  v130,  v88,  v78,  v123,  v89);

            uint64_t v10 = v119;
            uint64_t v47 = v82;
          }

          v78 += *(v79 - 3);
          ++v77;
          v79 += 4;
        }

        while (v47 != v77);
      }

      for (uint64_t i = 8LL; i != -8; i -= 8LL)
      a3 = (id *)v111;
      GTResourceDownloaderGetResourceFilename(v111, v110, __str, 0x80uLL);
      id v91 = objc_claimAutoreleasedReturnValue([v120 buffer]);
      id v92 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  (char *)[v120 offset] + (void)objc_msgSend(v91, "contents"),  objc_msgSend(v120, "size"),  0));

      uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue([v118 objects]);
      id v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", __str));
      [v93 addObject:v94];

      unint64_t v95 = (void *)objc_claimAutoreleasedReturnValue([v118 objects]);
      [v95 addObject:v92];

      id v96 = [v92 length];
      do
        unint64_t v97 = __ldaxr(&g_GPUDataSize);
      while (__stlxr((unint64_t)v96 + v97, &g_GPUDataSize));

      objc_autoreleasePoolPop(context);
      uint64_t v9 = v110 + 1;
    }

    while (v110 + 1 != v100);
  }
}

void DownloadAccelerationStructure(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  if (DownloadAccelerationStructure_onceToken != -1) {
    dispatch_once(&DownloadAccelerationStructure_onceToken, &__block_literal_global_187);
  }
  id v7 = (id)*a3;
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 device]);
  id v9 = DEVICEOBJECT(v8);
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);

  id v11 = [v10 newCommandQueue];
  id v12 = (void *)objc_claimAutoreleasedReturnValue([v5 getGPUBuffer:24 context:v6]);
  id v13 = (void *)objc_claimAutoreleasedReturnValue( [v11 commandBufferWithDescriptor:DownloadAccelerationStructure_commandBufferDescriptor]);
  uint64_t v100 = v11;

  id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 accelerationStructureCommandEncoder]);
  id v15 = DEVICEOBJECT(v7);
  id v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
  id v17 = (void *)objc_claimAutoreleasedReturnValue([v12 buffer]);
  objc_msgSend( v14,  "writeAccelerationStructureSerializationData:toBuffer:offset:",  v16,  v17,  objc_msgSend(v12, "offset"));

  [v14 endEncoding];
  [v13 commit];
  [v13 waitUntilCompleted];

  id v18 = objc_claimAutoreleasedReturnValue([v12 buffer]);
  id v19 = [v18 contents];
  size_t v20 = (char *)[v12 offset];
  uint64_t v22 = *(void *)&v20[(void)v19];
  unint64_t v21 = *(void *)&v20[(void)v19 + 8];

  if (v21 >= 0x19 && [v10 isCompatibleWithAccelerationStructure:v22])
  {
    id v97 = v5;
    id v23 = (void *)objc_claimAutoreleasedReturnValue([v5 getGPUBuffer:v21 context:v6]);
    uint64_t v24 = objc_claimAutoreleasedReturnValue([v7 stateBuffer]);
    id v96 = v10;
    id v98 = v23;
    if (!v24) {
      goto LABEL_8;
    }
    id v25 = (void *)v24;
    __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([v7 stateBuffer]);
    id v27 = [v26 length];

    id v28 = objc_claimAutoreleasedReturnValue([v7 stateBuffer]);
    int v29 = *((_DWORD *)[v28 contents] + 1);

    if ((v29 & 1) != 0)
    {
      __int128 v78 = (void *)objc_claimAutoreleasedReturnValue([v6 captureAccelerationStructures]);
      id v79 = GTAccelerationStructureDescriptorDownloader_children(v100, v7, v78);
      __int128 v80 = (void *)objc_claimAutoreleasedReturnValue(v79);

      uint64_t v81 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [v80 count]);
      __int128 v101 = 0u;
      __int128 v102 = 0u;
      __int128 v103 = 0u;
      __int128 v104 = 0u;
      id v37 = v80;
      id v82 = [v37 countByEnumeratingWithState:&v101 objects:v114 count:16];
      if (v82)
      {
        id v83 = v82;
        uint64_t v84 = *(void *)v102;
        do
        {
          for (uint64_t i = 0LL; i != v83; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v102 != v84) {
              objc_enumerationMutation(v37);
            }
            id v86 = DEVICEOBJECT(*(id *)(*((void *)&v101 + 1) + 8LL * (void)i));
            uint64_t v87 = (void *)objc_claimAutoreleasedReturnValue(v86);
            -[NSMutableArray addObject:](v81, "addObject:", v87);
          }

          id v83 = [v37 countByEnumeratingWithState:&v101 objects:v114 count:16];
        }

        while (v83);
      }

      id v88 = (void *)objc_claimAutoreleasedReturnValue([v6 accelerationStructureCommandEncoder]);
      uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue([v6 accelerationStructureCommandEncoder]);
      id v90 = DEVICEOBJECT(v7);
      id v91 = (void *)objc_claimAutoreleasedReturnValue(v90);
      id v36 = v98;
      id v92 = (void *)objc_claimAutoreleasedReturnValue([v98 buffer]);
      objc_msgSend( v89,  "serializeInstanceAccelerationStructure:primitiveAccelerationStructures:toBuffer:serializedBufferOffset:",  v91,  v81,  v92,  objc_msgSend(v98, "offset"));

      id v31 = &CACurrentMediaTime_ptr;
    }

    else
    {
LABEL_8:
      id v30 = (void *)objc_claimAutoreleasedReturnValue([v6 accelerationStructureCommandEncoder]);
      id v31 = &CACurrentMediaTime_ptr;

      id v32 = (void *)objc_claimAutoreleasedReturnValue([v6 accelerationStructureCommandEncoder]);
      id v33 = DEVICEOBJECT(v7);
      id v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
      id v35 = (void *)objc_claimAutoreleasedReturnValue([v23 buffer]);
      objc_msgSend( v32,  "serializePrimitiveAccelerationStructure:toBuffer:serializedBufferOffset:",  v34,  v35,  objc_msgSend(v23, "offset"));

      id v36 = v23;
      id v37 = 0LL;
    }

    GTResourceDownloaderGetResourceFilename((uint64_t)a3, 0, __str, 0x80uLL);
    id v38 = objc_claimAutoreleasedReturnValue([v36 buffer]);
    uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  (char *)[v36 offset] + (void)objc_msgSend(v38, "contents"),  objc_msgSend(v36, "size"),  0));

    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v6 objects]);
    id v41 = (void *)objc_claimAutoreleasedReturnValue([v31[243] stringWithUTF8String:__str]);
    [v40 addObject:v41];

    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v6 objects]);
    [v42 addObject:v39];

    id v43 = [v39 length];
    do
      unint64_t v44 = __ldaxr(&g_GPUDataSize);
    while (__stlxr((unint64_t)v43 + v44, &g_GPUDataSize));

    id v45 = [v7 traceContext];
    uint64_t v46 = a3[6];
    *(void *)__int128 __str = v45;
    uint64_t v106 = 0LL;
    uint64_t v107 = 0LL;
    uint64_t v108 = v46;
    s();
    uint64_t v48 = v47;
    uint64_t v49 = *v47;
    uint64_t *v47 = v50;
    uint64_t v109 = v49;
    char v110 = *((_BYTE *)v47 + 8);
    __int16 v111 = 16400;
    int v112 = 0;
    char v113 = 0;
    id v51 = (void *)objc_claimAutoreleasedReturnValue([v7 stateBuffer]);
    id v52 = v51;
    id v99 = v6;
    if (v51)
    {
      unsigned int v53 = *((_DWORD *)[v51 contents] + 1);
      int8x8_t v95 = vand_s8( (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v53), (uint32x2_t)0xFFFFFFFEFFFFFFFFLL),  (int8x8_t)0x100000001LL);
      int v54 = (v53 >> 3) & 1;
      int v94 = v53 & 1;
    }

    else
    {
      int v54 = 0;
      int v94 = 0;
      int8x8_t v95 = 0LL;
    }

    GTTraceEncoder_setStream((uint64_t *)__str, (uint64_t)[v7 traceStream]);
    uint64_t v55 = v107;
    *(_DWORD *)(v107 + _Block_object_dispose(va, 8) = -10159;
    char v56 = v111;
    if (v111 > 0x28uLL)
    {
      uint64_t v58 = *(void *)(v106 + 24);
      id v93 = v7;
      id v59 = v52;
      uint64_t v60 = a3;
      int v61 = v54;
      uint64_t v62 = HIBYTE(v111);
      ++HIBYTE(v111);
      id v57 = GTTraceMemPool_allocateBytes(v58, v108, v62 | 0x1800000000LL) + 16;
      char v56 = v62;
      int v54 = v61;
      a3 = v60;
      id v52 = v59;
      id v7 = v93;
    }

    else
    {
      id v57 = (char *)(v55 + v111);
      LOBYTE(v111) = v111 + 24;
    }

    *(_BYTE *)(v55 + 13) = v56;
    id v63 = (uint64_t *)[v7 traceStream];
    if (v63) {
      uint64_t v64 = *v63;
    }
    else {
      uint64_t v64 = 0LL;
    }
    id v6 = v99;
    *(void *)id v57 = v64;
    *((_DWORD *)v57 + 2) = v94;
    *(int8x8_t *)(v57 + 12) = v95;
    *((_DWORD *)v57 + 5) = v54;
    [v7 traceContext];
    uint64_t *v48 = v109;
    *((_BYTE *)v48 + _Block_object_dispose(va, 8) = v110;
    *(_BYTE *)(v107 + 15) |= 8u;

    if (v37)
    {
      id v65 = [v37 count];
      __int128 v66 = -[NSMutableData initWithLength:]( objc_alloc(&OBJC_CLASS___NSMutableData), "initWithLength:", 8LL * (void)v65);
      __int128 v67 = -[NSMutableData mutableBytes](v66, "mutableBytes");
      if (v65)
      {
        __int128 v68 = v67;
        for (uint64_t j = 0LL; j != v65; ++j)
        {
          __int128 v70 = (void *)objc_claimAutoreleasedReturnValue([v37 objectAtIndexedSubscript:j]);
          id v71 = DEVICEOBJECT(v70);
          __int128 v72 = (void *)objc_claimAutoreleasedReturnValue(v71);
          v68[(void)j] = v72;
        }
      }

      GTResourceDownloaderGetResourceFilename((uint64_t)a3, 1, __str, 0x80uLL);
      id v6 = v99;
      __int128 v73 = (void *)objc_claimAutoreleasedReturnValue([v99 objects]);
      id v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", __str));
      [v73 addObject:v74];

      __int128 v75 = (void *)objc_claimAutoreleasedReturnValue([v99 objects]);
      [v75 addObject:v66];

      NSUInteger v76 = -[NSMutableData length](v66, "length");
      do
        unint64_t v77 = __ldaxr(&g_GPUDataSize);
      while (__stlxr(v77 + v76, &g_GPUDataSize));
    }

    uint64_t v10 = v96;
    id v5 = v97;
  }
}

uint64_t ResourceTypeSortOrder(int a1)
{
  if (a1 > 59)
  {
    if (a1 > 82)
    {
      if (a1 == 86) {
        return 4LL;
      }
      if (a1 == 83) {
        return 2LL;
      }
    }

    else
    {
      if (a1 == 60) {
        return 1LL;
      }
      if (a1 == 80) {
        return 5LL;
      }
    }

    return 0LL;
  }

  if (a1 == 16) {
    return 6LL;
  }
  if (a1 != 22)
  {
    if (a1 == 57) {
      return 7LL;
    }
    return 0LL;
  }

  return 3LL;
}

uint64_t GTResourceDownloaderRequest_markTextureAsDrawable(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(result + 47) |= 4u;
  *(void *)(result + 24) = a2;
  *(void *)(result + 32) = a3;
  return result;
}

apr_array_header_t *GTResourceDownloaderProcessRequest(apr_pool_t *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  arr = apr_array_make(a1, *(_DWORD *)(a2 + 12), 88);
  if (*(int *)(v2 + 12) >= 1)
  {
    uint64_t v3 = 0LL;
    int64x2_t v147 = vdupq_n_s64(0x20uLL);
    uint64_t v144 = v2;
    do
    {
      uint64_t v4 = objc_autoreleasePoolPush();
      uint64_t v5 = *(void *)(v2 + 24);
      id v6 = (void *)(v5 + 88 * v3);
      id v7 = v6 + 1;
      Streauint64_t m = GTTraceContext_getStream(g_ctx, v6[1]);
      uint64_t Func = GTTraceStream_lastFunc(Stream);
      if ((IsFuncEnumDestructor(*(_DWORD *)(Func + 8)) & 1) == 0)
      {
        uint64_t v10 = v5 + 88 * v3;
        unsigned int v11 = *(unsigned __int8 *)(v10 + 46);
        unsigned int v186 = (char *)(v10 + 46);
        if (v11 <= 0x38)
        {
          switch(v11)
          {
            case 0x10u:
              id v17 = (id)*v6;
              uint64_t v39 = apr_array_push(arr);
              v39[46] = *v186;
              *(_OWORD *)uint64_t v39 = *(_OWORD *)v6;
              uint64_t v40 = v5 + 88 * v3;
              *((void *)v39 + 2) = *(void *)(v40 + 16);
              *((_DWORD *)v39 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_DWORD *)(v40 + 40);
              id v41 = (unint64_t *)((char *)[v17 traceContext] + 72);
              do
                unint64_t v42 = __ldaxr(v41);
              while (__stlxr(v42 + 1, v41));
              *((void *)v39 + 6) = v42;
              goto LABEL_22;
            case 0x16u:
              id v17 = (id)*v6;
              id v43 = DEVICEOBJECT(v17);
              unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(v43);
              ProcessDeviceBuffer(arr, v5 + 88 * v3, v21);
LABEL_21:

LABEL_22:
              break;
            case 0x32u:
              id v17 = (id)*v6;
              unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v17 backbuffer]);
              id v22 = DEVICEOBJECT(v21);
              id v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
              ProcessDeviceBuffer(arr, v5 + 88 * v3, v23);

              goto LABEL_21;
          }
        }

        else
        {
          __int128 v145 = v4;
          uint64_t v146 = v3;
          if (*(unsigned __int8 *)(v10 + 46) > 0x4Fu)
          {
            if (v11 == 80)
            {
              id v44 = (id)*v6;
              id v45 = DEVICEOBJECT(v44);
              uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(v45);

              unsigned int v180 = (uint64_t *)(v5 + 88 * v3);
              int64_t v143 = v46;
              if ((objc_opt_respondsToSelector(v46, "isSparse") & 1) != 0
                && [v46 isSparse])
              {
                uint64_t v183 = v6 + 1;
                uint64_t v177 = v5;
                id v150 = v46;
                id v47 = (id)*v6;
                id v48 = DEVICEOBJECT(v47);
                uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue(v48);

                if ([v49 isSparse])
                {
                  uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v49 device]);
                  id v51 = [v50 newCommandQueue];

                  id v52 = (void *)objc_claimAutoreleasedReturnValue([0 commanndBufferDescriptor]);
                  unsigned int v53 = (void *)objc_claimAutoreleasedReturnValue([v51 commandBufferWithDescriptor:v52]);

                  id v171 = v51;
                  SparseTextureMappingKernelFunctiouint64_t n = GetSparseTextureMappingKernelFunction(v49, v50);
                  id v167 = (void *)objc_claimAutoreleasedReturnValue(SparseTextureMappingKernelFunction);
                  id v55 = objc_msgSend(v50, "newComputePipelineStateWithFunction:error:");
                  char v56 = (void *)objc_claimAutoreleasedReturnValue([v53 computeCommandEncoder]);
                  uint64_t v169 = v53;

                  unint64_t v165 = v55;
                  [v56 setComputePipelineState:v55];
                  [v56 setTexture:v49 atIndex:0];
                  SparseTextureMappingid Buffer = GetSparseTextureMappingBuffer(v49, v50);
                  uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(SparseTextureMappingBuffer);
                  __int128 v195 = 0u;
                  __int128 v196 = 0u;
                  memset(v194, 0, sizeof(v194));
                  id v59 = [v49 textureType];
                  id v60 = [v49 pixelFormat];
                  id v61 = [v49 sampleCount];
                  uint64_t v174 = v50;
                  if (v50)
                  {
                    [v50 sparseTileSizeWithTextureType:v59 pixelFormat:v60 sampleCount:v61];
                  }

                  else
                  {
                    int64x2_t v199 = 0uLL;
                    unint64_t v200 = 0LL;
                  }

                  if ([v49 arrayLength])
                  {
                    uint64_t v94 = 0LL;
                    unint64_t v95 = 0LL;
                    while (![v49 mipmapLevelCount])
                    {
LABEL_79:
                    }

                    unint64_t v96 = 0LL;
                    while (2)
                    {
                      unint64_t v97 = (unint64_t)[v49 width] >> v96;
                      if (v97 <= 1) {
                        LODWORD(v97) = 1;
                      }
                      v194[0].i32[0] = v97;
                      unint64_t v98 = (unint64_t)[v49 height] >> v96;
                      if (v98 <= 1) {
                        LODWORD(v9_Block_object_dispose(va, 8) = 1;
                      }
                      v194[0].i32[1] = v98;
                      unint64_t v99 = (unint64_t)[v49 depth];
                      LODWORD(v101) = v194[0].i32[1];
                      LODWORD(v10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v194[0].i32[0];
                      double v102 = (double)v100 / (double)v199.u32[0];
                      unint64_t v103 = v99 >> v96;
                      if (v99 >> v96 <= 1) {
                        LODWORD(v103) = 1;
                      }
                      v194[0].i32[2] = v103;
                      v194[1].i64[0] = __PAIR64__(v199.u32[2], v199.u32[0]);
                      v194[1].i32[2] = v200;
                      unsigned int v104 = vcvtpd_u64_f64(v102);
                      unsigned int v105 = vcvtpd_u64_f64((double)v101 / (double)v199.u32[2]);
                      *(void *)&__int128 v195 = __PAIR64__(v105, v104);
                      unsigned int v106 = vcvtpd_u64_f64((double)v103 / (double)v200);
                      DWORD2(v195) = v106;
                      if ([v49 textureType] == (char *)&dword_4 + 1)
                      {
                        LODWORD(v196) = v95;
                        DWORD2(v196) = v96;
                        goto LABEL_73;
                      }

                      uint64_t v107 = (char *)[v49 textureType];
                      LODWORD(v196) = v95;
                      DWORD2(v196) = v96;
                      if (v107 == (_BYTE *)&dword_4 + 2) {
LABEL_73:
                      }
                        unint64_t v108 = v95 % 6;
                      else {
                        LODWORD(v10_Block_object_dispose(va, 8) = 0;
                      }
                      unsigned int v109 = v104 * v106 * v105;
                      DWORD1(v196) = v108;
                      HIDWORD(v196) = v109;

                      [v56 setBuffer:v58 offset:v94 atIndex:0];
                      [v56 setBytes:v194 length:64 atIndex:1];
                      if (v96 >= (unint64_t)[v49 firstMipmapInTail])
                      {
                        int64x2_t v197 = vdupq_n_s64(1uLL);
                        uint64_t v198 = 1LL;
                        int64x2_t v192 = v197;
                        uint64_t v193 = 1LL;
                        __int16 v111 = &v197;
                        int v112 = &v192;
                      }

                      else
                      {
                        *(void *)&__int128 v110 = v195;
                        *((void *)&v110 + 1) = DWORD1(v195);
                        __int128 v190 = v110;
                        uint64_t v191 = DWORD2(v195);
                        int64x2_t v188 = v147;
                        uint64_t v189 = 1LL;
                        __int16 v111 = (int64x2_t *)&v190;
                        int v112 = &v188;
                      }

                      [v56 dispatchThreads:v111 threadsPerThreadgroup:v112];
                      v94 += v109;
                      continue;
                    }
                  }

LABEL_80:
                  [v56 endEncoding];
                  [v169 commit];
                  [v169 waitUntilCompleted];

                  uint64_t v4 = v145;
                  uint64_t v3 = v146;
                }

                else
                {
                  uint64_t v58 = 0LL;
                }

                id v62 = v150;
                char v113 = (void *)objc_claimAutoreleasedReturnValue([v150 device]);
                id v164 = [v150 pixelFormat];
                id v163 = [v150 sampleCount];
                id v114 = v58;
                uint64_t v149 = (char *)[v114 contents];
                unint64_t v115 = -1LL;
                do
                  ++v115;
                while (v115 < (unint64_t)[v114 length]);
                id v142 = v114;
                uint64_t v161 = *v183;
                uint64_t v162 = *v180;
                uint64_t v116 = v177 + 88 * v3;
                uint64_t v160 = *(void *)(v116 + 16);
                char v158 = *v186;
                int v159 = *(_DWORD *)(v116 + 40);
                id v148 = [v150 firstMipmapInTail];
                id v117 = [v150 textureType];
                id v118 = [v150 pixelFormat];
                id v119 = [v150 sampleCount];
                if (v113)
                {
                  [v113 sparseTileSizeWithTextureType:v117 pixelFormat:v118 sampleCount:v119];
                }

                else
                {
                  int64x2_t v199 = 0uLL;
                  unint64_t v200 = 0LL;
                }

                if ([v150 arrayLength])
                {
                  unint64_t v166 = 0LL;
                  int v120 = 0;
                  unsigned int v121 = 1;
                  do
                  {
                    if ([v62 mipmapLevelCount])
                    {
                      unint64_t v122 = 0LL;
                      do
                      {
                        unint64_t v123 = (unint64_t)[v62 width];
                        if (v123 >> v122 <= 1) {
                          LODWORD(v124) = 1;
                        }
                        else {
                          unint64_t v124 = v123 >> v122;
                        }
                        unint64_t v125 = (unint64_t)[v62 height];
                        if (v125 >> v122 <= 1) {
                          LODWORD(v126) = 1;
                        }
                        else {
                          unint64_t v126 = v125 >> v122;
                        }
                        unint64_t v127 = (unint64_t)[v62 depth] >> v122;
                        LODWORD(v4) = vcvtpd_u64_f64((double)v124 / (double)v199.u32[0]);
                        if (v127 <= 1) {
                          LODWORD(v127) = 1;
                        }
                        unsigned int v156 = vcvtpd_u64_f64((double)v126 / (double)v199.u32[2]);
                        unsigned int v153 = vcvtpd_u64_f64((double)v127 / (double)v200);
                        int v151 = v120;
                        unint64_t v185 = v122;
                        if (v153)
                        {
                          int v154 = 0;
                          __int16 v155 = v199.i16[4];
                          uint64_t v128 = &v149[v120];
                          int v179 = 2 * ((unint64_t)v148 < v122);
                          __int32 v181 = v199.i32[0];
                          else {
                            uint64_t v129 = v199.u32[0];
                          }
                          else {
                            unsigned __int16 v130 = v199.u16[4];
                          }
                          __int16 v152 = v200;
                          unsigned __int16 v176 = v130;
                          __int16 v173 = v127;
                          uint64_t v168 = (unsigned __int16)v127;
                          uint64_t v170 = v130;
                          do
                          {
                            if (v156)
                            {
                              int v131 = 0;
                              do
                              {
                                int v157 = v131;
                                if ((_DWORD)v4)
                                {
                                  id v132 = 0LL;
                                  int v133 = v131 * (_DWORD)v4;
                                  __int16 v134 = v131 * v155;
                                  do
                                  {
                                    if (v128[v133 + (_DWORD)v132])
                                    {
                                      v197.i64[0] = v129;
                                      v197.i64[1] = v170;
                                      uint64_t v198 = v168;
                                      MTLTextureInfo(v113, (uint64_t)v164, v197.i64, (uint64_t)v163, (uint64_t)v194);
                                      uint64_t v135 = v194[0].i64[0];
                                      unsigned __int32 v136 = (48 * v194[0].i32[0] + 279) & 0xFFFFFF00;
                                      for (uint64_t i = (uint64_t *)&v195; v135; --v135)
                                      {
                                        uint64_t v138 = *i;
                                        i += 4;
                                        v136 += v138;
                                      }

                                      unsigned int v121 = v121 & 0xFFFFFFFD | v179;
                                      int32x2_t v139 = vmovn_s64(*(int64x2_t *)((char *)v194 + 8));
                                      __int128 v140 = (char *)apr_array_push(arr);
                                      *(void *)__int128 v140 = v162;
                                      *((void *)v140 + 1) = v161;
                                      *((void *)v140 + 3) = 0LL;
                                      *((void *)v140 + 4) = 0LL;
                                      *((void *)v140 + 2) = v160;
                                      *((_DWORD *)v140 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v159;
                                      *((_WORD *)v140 + 22) = 0;
                                      v140[46] = v158;
                                      v140[47] = v121;
                                      *((_WORD *)v140 + 24) = v166;
                                      *((_WORD *)v140 + 25) = v185;
                                      *((_DWORD *)v140 + 13) = (_DWORD)v132 * v181;
                                      *((_WORD *)v140 + 2_Block_object_dispose(va, 8) = v134;
                                      *((_WORD *)v140 + 29) = v154 * v152;
                                      *((_DWORD *)v140 + 15) = v129;
                                      *((_WORD *)v140 + 32) = v176;
                                      *((_WORD *)v140 + 33) = v173;
                                      *(int32x2_t *)(v140 + 6_Block_object_dispose(va, 8) = v139;
                                      *((_DWORD *)v140 + 19) = v136;
                                      *((void *)v140 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0LL;
                                    }

                                    id v132 = (char *)v132 + 1;
                                  }

                                  while (v132 != v4);
                                }

                                int v131 = v157 + 1;
                              }

                              while (v157 + 1 != v156);
                            }

                            ++v154;
                          }

                          while (v154 != v153);
                        }

                        int v120 = v156 * (_DWORD)v4 * v153 + v151;
                        unint64_t v122 = v185 + 1;
                        id v62 = v150;
                      }

                      while (v185 + 1 < (unint64_t)[v150 mipmapLevelCount]);
                    }

                    ++v166;
                    uint64_t v4 = v145;
                    uint64_t v3 = v146;
                  }

                  while (v166 < (unint64_t)[v62 arrayLength]);
                }

                uint64_t v2 = v144;
                __int128 v72 = v142;
LABEL_122:
              }

              else if (CanHarvestTextureAsIOSurfaceUsingCPU(v46))
              {
                id v62 = (id)*v6;
                if ([v62 conformsToProtocol:&OBJC_PROTOCOL___MTLTexture])
                {
                  id v62 = v62;
                  id v63 = (__IOSurface *)[v62 iosurface];
                  size_t PlaneCount = IOSurfaceGetPlaneCount(v63);
                  uint64_t v65 = 0LL;
                  uint64_t v66 = 0LL;
                  if (PlaneCount <= 1) {
                    uint64_t v67 = 1LL;
                  }
                  else {
                    uint64_t v67 = PlaneCount;
                  }
                  do
                    v65 += IOSurfaceGetSizeOfPlane(v63, v66++);
                  while (v67 != v66);
                  __int128 v68 = (char *)apr_array_push(arr);
                  id v69 = (id)*v6;
                  int v70 = *(_DWORD *)(v5 + 88 * v3 + 40);
                  __int128 v187 = *(_OWORD *)(v6 + 1);
                  id v71 = [v62 iosurfacePlane];
                  *(void *)__int128 v68 = v69;
                  *(_OWORD *)(v68 + _Block_object_dispose(va, 8) = v187;
                  *((void *)v68 + 3) = 0LL;
                  *((void *)v68 + 4) = 0LL;
                  *((_DWORD *)v68 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v70;
                  *((_DWORD *)v68 + 11) = 5636096;
                  __int128 v72 = v62;
                  *((void *)v68 + 6) = v65;
                  *((void *)v68 + 7) = v71;
                  uint64_t v2 = v144;
                  goto LABEL_122;
                }
              }

              else
              {
                id v62 = v46;
                __int128 v73 = (char *)[v62 mipmapLevelCount];
                id v74 = [v62 arrayLength];
                BOOL IsCube = MTLTextureIsCube(v62);
                uint64_t v76 = 6LL;
                if (!IsCube) {
                  uint64_t v76 = 1LL;
                }
                id v172 = v73;
                if (v73)
                {
                  unint64_t v77 = 0LL;
                  uint64_t v184 = v76 * (void)v74;
                  uint64_t v78 = v5 + 88 * v3;
                  int64_t v175 = (_DWORD *)(v78 + 40);
                  uint64_t v178 = (void *)(v78 + 16);
                  do
                  {
                    else {
                      unint64_t v79 = 1LL;
                    }
                    else {
                      unint64_t v80 = 1LL;
                    }
                    else {
                      unint64_t v81 = 1LL;
                    }
                    if (v184)
                    {
                      for (uint64_t j = 0LL; j != v184; ++j)
                      {
                        id v83 = (char *)apr_array_push(arr);
                        id v84 = v62;
                        id v85 = v62;
                        id v86 = (void *)objc_claimAutoreleasedReturnValue([v85 device]);
                        id v87 = [v85 pixelFormat];
                        id v88 = [v85 sampleCount];
                        v199.i64[0] = v79;
                        v199.i64[1] = v80;
                        unint64_t v200 = v81;
                        MTLTextureInfo(v86, (uint64_t)v87, v199.i64, (uint64_t)v88, (uint64_t)v194);
                        uint64_t v89 = v194[0].i64[0];
                        unsigned __int32 v90 = (48 * v194[0].i32[0] + 279) & 0xFFFFFF00;
                        if (v194[0].i64[0])
                        {
                          id v91 = (int *)&v195;
                          do
                          {
                            int v92 = *v91;
                            v91 += 8;
                            v90 += v92;
                            --v89;
                          }

                          while (v89);
                        }

                        int32x2_t v93 = vmovn_s64(*(int64x2_t *)((char *)v194 + 8));

                        *((_OWORD *)v83 + 1) = 0u;
                        *((_OWORD *)v83 + 2) = 0u;
                        *(_OWORD *)id v83 = 0u;
                        *((_WORD *)v83 + 24) = j;
                        *((_WORD *)v83 + 25) = (_WORD)v77;
                        *(void *)(v83 + 52) = 0LL;
                        *((_DWORD *)v83 + 15) = v79;
                        *((_WORD *)v83 + 32) = v80;
                        *((_WORD *)v83 + 33) = v81;
                        *(int32x2_t *)(v83 + 6_Block_object_dispose(va, 8) = v93;
                        *((_DWORD *)v83 + 19) = v90;
                        *((void *)v83 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0LL;
                        v83[46] = *v186;
                        *(_OWORD *)id v83 = *(_OWORD *)v180;
                        *((void *)v83 + 2) = *v178;
                        *((_DWORD *)v83 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *v175;
                        id v62 = v84;
                      }
                    }

                    ++v77;
                    uint64_t v4 = v145;
                    uint64_t v3 = v146;
                  }

                  while (v77 != v172);
                  uint64_t v2 = v144;
                }
              }

              goto LABEL_23;
            }

            if (v11 == 83)
            {
              id v24 = (id)*v6;
              uint64_t v25 = *v7;
              uint64_t v26 = v5 + 88 * v3;
              uint64_t v27 = *(void *)(v26 + 16);
              int v28 = *(_DWORD *)(v26 + 40);
              id v17 = (id)*v6;
              int v29 = (void *)objc_claimAutoreleasedReturnValue([v17 functionArray]);
              id v30 = [v29 count];

              id v31 = (char *)apr_array_push(arr);
              *(void *)id v31 = v24;
              *((void *)v31 + 1) = v25;
              *((void *)v31 + 3) = 0LL;
              *((void *)v31 + 4) = 0LL;
              *((void *)v31 + 2) = v27;
              *((_DWORD *)v31 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v28;
              uint64_t v2 = v144;
              uint64_t v4 = v145;
              uint64_t v3 = v146;
              *((_DWORD *)v31 + 11) = 5439488;
              *((void *)v31 + 6) = v30;
              *(_OWORD *)(v31 + 56) = 0u;
              *(_OWORD *)(v31 + 72) = 0u;
              goto LABEL_22;
            }
          }

          else
          {
            if (v11 == 57)
            {
              id v17 = (id)*v6;
              id v32 = DEVICEOBJECT(v17);
              id v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
              MakeGTMTLIndirectCommandBufferDescriptorFromIndirectCommandBuffer((uint64_t)&v199, v33);

              GTMTLCreateIndirectCommandEncoder((uint64_t)v194, (uint64_t)&v199);
              id v34 = (int64x2_t *)apr_array_push(arr);
              uint64_t v35 = v5 + 88 * v3;
              uint64_t v36 = *(void *)(v35 + 16);
              LODWORD(v35) = *(_DWORD *)(v35 + 40);
              unsigned __int8 v37 = *v186;
              int64x2_t v38 = *(int64x2_t *)v6;
              int64x2_t v197 = v199;
              uint64_t v198 = v200;
              *id v34 = v38;
              v34[1].i64[1] = 0LL;
              v34[2].i64[0] = 0LL;
              v34[1].i64[0] = v36;
              v34[2].i32[2] = v35;
              v34[2].i16[6] = 0;
              v34[2].i16[7] = v37;
              v34[3] = v197;
              v34[4].i64[0] = v198;
              goto LABEL_22;
            }

            if (v11 == 60)
            {
              id v12 = (id)*v6;
              uint64_t v13 = *v7;
              uint64_t v14 = v5 + 88 * v3;
              uint64_t v15 = *(void *)(v14 + 16);
              int v16 = *(_DWORD *)(v14 + 40);
              id v17 = (id)*v6;
              id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 functionArray]);
              id v19 = [v18 count];

              size_t v20 = apr_array_push(arr);
              *size_t v20 = v12;
              v20[1] = v13;
              v20[3] = 0LL;
              v20[4] = 0LL;
              v20[2] = v15;
              *((_DWORD *)v20 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v16;
              uint64_t v2 = v144;
              uint64_t v4 = v145;
              uint64_t v3 = v146;
              *((_DWORD *)v20 + 11) = 3932160;
              v20[6] = v19;
              v20[7] = 31LL;
              goto LABEL_22;
            }
          }
        }
      }

void ProcessDeviceBuffer(apr_array_header_t *a1, uint64_t a2, void *a3)
{
  id v35 = a3;
  vm_size_t v5 = (vm_size_t)[v35 length];
  if ((qword_23A448 & 0x1000) == 0)
  {
    id v6 = apr_array_push(a1);
    v6[46] = *(_BYTE *)(a2 + 46);
    *(_OWORD *)id v6 = *(_OWORD *)a2;
    *((void *)v6 + 2) = *(void *)(a2 + 16);
    id v7 = (_DWORD *)(a2 + 40);
LABEL_39:
    *((_DWORD *)v6 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *v7;
    *((void *)v6 + 6) = 0LL;
    *((void *)v6 + 7) = v5;
    goto LABEL_40;
  }

  Streauint64_t m = GTTraceContext_getStream(g_ctx, *(void *)(a2 + 8));
  uint64_t v9 = Stream;
  id v7 = (_DWORD *)(a2 + 40);
  if (*(_DWORD *)(a2 + 40))
  {
    if (!Stream) {
      goto LABEL_40;
    }
    char v10 = atomic_load((unint64_t *)(Stream + 56));
    if ((v10 & 8) == 0) {
      goto LABEL_40;
    }
    goto LABEL_8;
  }

  if (Stream)
  {
LABEL_8:
    unsigned int v11 = (unint64_t *)(Stream + 56);
    unint64_t v12 = atomic_load((unint64_t *)(Stream + 56));
    while (1)
    {
      unint64_t v13 = __ldaxr(v11);
      if (v13 != v12) {
        break;
      }
      if (__stlxr(v12 & 0xFFFFFFFFFFFFFFF7LL, v11)) {
        goto LABEL_13;
      }
      int v14 = 1;
LABEL_14:
      unint64_t v12 = v13;
      if (v14) {
        goto LABEL_15;
      }
    }

    __clrex();
LABEL_13:
    int v14 = 0;
    goto LABEL_14;
  }

uint64_t MTLIndirectCommandBuffer_descriptor(uint64_t a1)
{
  __int128 v4 = 0u;
  uint64_t v5 = 0LL;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v7 = 0u;
  LODWORD(v4) = 57;
  uint64_t v6 = -1LL;
  WORD1(v11) = 2;
  __int128 v9 = 0xFFFFFFFFFFFFFFFFLL;
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1 && (*(_BYTE *)(v1 + 79) & 8) != 0) {
    uint64_t v2 = v1 + 64;
  }
  else {
    uint64_t v2 = 0LL;
  }
  GTMTLSMIndirectCommandBuffer_processTraceFuncWithPool((char *)&v4, *(void *)(a1 + 24), v2);
  return *((void *)&v11 + 1);
}

char *AllocateSnapshotMemory(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = (v10[26] * a3);
  uint64_t v6 = *(void *)(*(void *)(a1 + 8) + 24LL);
  uint64_t v7 = *(void *)(a1 + 24);
  uint64_t v8 = *(unsigned __int8 *)(a1 + 42);
  *(_BYTE *)(a1 + 42) = v8 + 1;
  return GTTraceMemPool_allocateBytes(v6, v7, v8 | (v5 << 32) | 0x100);
}

char *AllocateRangeSnapshotMemory(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 8) + 24LL);
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = *(unsigned __int8 *)(a1 + 42);
  *(_BYTE *)(a1 + 42) = v3 + 1;
  return GTTraceMemPool_allocateBytes(v1, v2, v3 | 0x1000000100LL);
}

void *UnwrapArray(void *a1, void **a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = a3;
    uint64_t v6 = a1;
    do
    {
      uint64_t v7 = *a2++;
      *v6++ = [v7 baseObject];
      --v4;
    }

    while (v4);
  }

  return a1;
}

uint64_t StreamArray(uint64_t a1, void *__src, id *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v8 = __src;
    uint64_t v9 = a4;
    do
    {
      __int128 v10 = (uint64_t *)[*a3 traceStream];
      if (v10) {
        uint64_t v11 = *v10;
      }
      else {
        uint64_t v11 = 0LL;
      }
      *v8++ = v11;
      ++a3;
      --v9;
    }

    while (v9);
  }

  return GTTraceEncoder_storeBytes(a1, __src, 8 * a4);
}

uint64_t StreamArrayURL(uint64_t a1, void *a2, id *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v8 = a2;
    uint64_t v9 = a4;
    do
    {
      __int128 v10 = (uint64_t *)[*a3 traceStream];
      if (v10) {
        uint64_t v11 = *v10;
      }
      else {
        uint64_t v11 = 0LL;
      }
      *v8++ = v11;
      ++a3;
      --v9;
    }

    while (v9);
  }

  return GTTraceEncoder_storeBlob(a1, a2, 8 * a4);
}

uint64_t StreamNSArray(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = [v5 count];
  if (v6)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v5 objectAtIndexedSubscript:v7]);
      uint64_t v9 = (uint64_t *)[v8 traceStream];
      if (v9) {
        uint64_t v10 = *v9;
      }
      else {
        uint64_t v10 = 0LL;
      }
      a2[(void)v7] = v10;

      uint64_t v7 = (char *)v7 + 1;
    }

    while (v6 != v7);
  }

  uint64_t v11 = GTTraceEncoder_storeBytes(a1, a2, 8LL * (void)v6);

  return v11;
}

uint64_t StreamMTLNameArray(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 count];
  size_t v5 = 8LL * (void)v4 + 8;
  __chkstk_darwin(v4, v6);
  uint64_t v8 = (unint64_t *)((char *)&v16 - v7);
  id v9 = [v3 count];
  unint64_t *v8 = (unint64_t)v9;
  if (v9)
  {
    unint64_t v10 = 0LL;
    do
    {
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:v10]);
      __int128 v12 = (uint64_t *)[v11 traceStream];
      if (v12) {
        uint64_t v13 = *v12;
      }
      else {
        uint64_t v13 = 0LL;
      }
      v8[v10 + 1] = v13;

      ++v10;
    }

    while (v10 < *v8);
  }

  uint64_t v14 = GTTraceEncoder_storeBytes(a1, v8, v5);

  return v14;
}

void RetainArray(void *a1, id *a2, uint64_t a3)
{
  for (id i = a1; a3; --a3)
  {
    if (*a2)
    {
      objc_msgSend(i, "addObject:");
      [*a2 touch];
    }

    ++a2;
  }
}

void RetainNSArray(void *a1, void *a2)
{
  id v8 = a1;
  id v3 = a2;
  if ([v3 count])
  {
    unint64_t v4 = 0LL;
    do
    {
      size_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:v4]);

      if (v5)
      {
        uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:v4]);
        [v8 addObject:v6];

        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:v4]);
        [v7 touch];
      }

      ++v4;
    }

    while ((unint64_t)[v3 count] > v4);
  }
}

id unwrapNSArray(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v1 count]));
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    id v4 = v2;
    id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v13;
      do
      {
        for (id i = 0LL; i != v6; id i = (char *)i + 1)
        {
          if (*(void *)v13 != v7) {
            objc_enumerationMutation(v4);
          }
          id v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((void *)&v12 + 1) + 8 * (void)i), "baseObject", (void)v12));
          [v3 addObject:v9];
        }

        id v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }

      while (v6);
    }

    id v10 = [v3 copy];
  }

  else
  {
    id v10 = 0LL;
  }

  return v10;
}

id deviceNSArray(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v1 count]));
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    id v4 = v2;
    id v5 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v14;
      do
      {
        for (id i = 0LL; i != v6; id i = (char *)i + 1)
        {
          if (*(void *)v14 != v7) {
            objc_enumerationMutation(v4);
          }
          id v9 = DEVICEOBJECT(*(id *)(*((void *)&v13 + 1) + 8LL * (void)i));
          id v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
          objc_msgSend(v3, "addObject:", v10, (void)v13);
        }

        id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
      }

      while (v6);
    }

    id v11 = [v3 copy];
  }

  else
  {
    id v11 = 0LL;
  }

  return v11;
}

id unwrapMTLLinkedFunctions(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 functions]);
  id v4 = unwrapNSArray(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  [v2 setFunctions:v5];

  id v6 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryFunctions]);
  id v7 = unwrapNSArray(v6);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  [v2 setBinaryFunctions:v8];

  if ((objc_opt_respondsToSelector(v1, "privateFunctions") & 1) != 0)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v1 privateFunctions]);
    id v10 = unwrapNSArray(v9);
    id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    [v2 setPrivateFunctions:v11];
  }

  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v1 groups]);

  if (v12)
  {
    BOOL v25 = v2;
    __int128 v13 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v14 = (void *)objc_claimAutoreleasedReturnValue([v1 groups]);
    id v15 = [v14 countByEnumeratingWithState:&v26 objects:v30 count:16];
    if (v15)
    {
      id v16 = v15;
      uint64_t v17 = *(void *)v27;
      do
      {
        unint64_t v18 = 0LL;
        do
        {
          if (*(void *)v27 != v17) {
            objc_enumerationMutation(v14);
          }
          uint64_t v19 = *(void *)(*((void *)&v26 + 1) + 8LL * (void)v18);
          unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v1 groups]);
          vm_size_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:v19]);
          id v22 = unwrapNSArray(v21);
          unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
          -[NSMutableDictionary setObject:forKey:](v13, "setObject:forKey:", v23, v19);

          unint64_t v18 = (char *)v18 + 1;
        }

        while (v16 != v18);
        id v16 = [v14 countByEnumeratingWithState:&v26 objects:v30 count:16];
      }

      while (v16);
    }

    id v2 = v25;
    [v25 setGroups:v13];
  }

  return v2;
}

id deviceMTLLinkedFunctions(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 functions]);
  id v4 = deviceNSArray(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  [v2 setFunctions:v5];

  id v6 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryFunctions]);
  id v7 = deviceNSArray(v6);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  [v2 setBinaryFunctions:v8];

  if ((objc_opt_respondsToSelector(v1, "privateFunctions") & 1) != 0)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v1 privateFunctions]);
    id v10 = deviceNSArray(v9);
    id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    [v2 setPrivateFunctions:v11];
  }

  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v1 groups]);

  if (v12)
  {
    BOOL v25 = v2;
    __int128 v13 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v14 = (void *)objc_claimAutoreleasedReturnValue([v1 groups]);
    id v15 = [v14 countByEnumeratingWithState:&v26 objects:v30 count:16];
    if (v15)
    {
      id v16 = v15;
      uint64_t v17 = *(void *)v27;
      do
      {
        unint64_t v18 = 0LL;
        do
        {
          if (*(void *)v27 != v17) {
            objc_enumerationMutation(v14);
          }
          uint64_t v19 = *(void *)(*((void *)&v26 + 1) + 8LL * (void)v18);
          unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v1 groups]);
          vm_size_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:v19]);
          id v22 = deviceNSArray(v21);
          unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
          -[NSMutableDictionary setObject:forKey:](v13, "setObject:forKey:", v23, v19);

          unint64_t v18 = (char *)v18 + 1;
        }

        while (v16 != v18);
        id v16 = [v14 countByEnumeratingWithState:&v26 objects:v30 count:16];
      }

      while (v16);
    }

    id v2 = v25;
    [v25 setGroups:v13];
  }

  return v2;
}

id unwrapMTLComputePipelineDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 computeFunction]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 baseObject]);
  [v2 setComputeFunction:v4];

  if ((objc_opt_respondsToSelector(v1, "pipelineLibrary") & 1) != 0)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v1 pipelineLibrary]);
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 baseObject]);
    [v2 setPipelineLibrary:v6];
  }

  if ((objc_opt_respondsToSelector(v1, "functionPointers") & 1) != 0)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v1 functionPointers]);
    id v8 = unwrapNSArray(v7);
    id v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    [v2 setFunctionPointers:v9];
  }

  if ((objc_opt_respondsToSelector(v1, "preloadedLibraries") & 1) != 0)
  {
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v1 preloadedLibraries]);
    id v11 = unwrapNSArray(v10);
    __int128 v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
    [v2 setPreloadedLibraries:v12];
  }

  if ((objc_opt_respondsToSelector(v1, "binaryArchives") & 1) != 0)
  {
    __int128 v13 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
    id v14 = unwrapNSArray(v13);
    id v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    [v2 setBinaryArchives:v15];
  }

  if ((objc_opt_respondsToSelector(v1, "linkedFunctions") & 1) != 0)
  {
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v1 linkedFunctions]);
    id v17 = unwrapMTLLinkedFunctions(v16);
    unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
    [v2 setLinkedFunctions:v18];
  }

  return v2;
}

id deviceMTLComputePipelineDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 computeFunction]);
  id v4 = DEVICEOBJECT(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  [v2 setComputeFunction:v5];

  if ((objc_opt_respondsToSelector(v1, "pipelineLibrary") & 1) != 0)
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v1 pipelineLibrary]);
    id v7 = DEVICEOBJECT(v6);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    [v2 setPipelineLibrary:v8];
  }

  if ((objc_opt_respondsToSelector(v1, "functionPointers") & 1) != 0)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v1 functionPointers]);
    id v10 = deviceNSArray(v9);
    id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    [v2 setFunctionPointers:v11];
  }

  if ((objc_opt_respondsToSelector(v1, "preloadedLibraries") & 1) != 0)
  {
    __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v1 preloadedLibraries]);
    id v13 = deviceNSArray(v12);
    id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    [v2 setPreloadedLibraries:v14];
  }

  if ((objc_opt_respondsToSelector(v1, "binaryArchives") & 1) != 0)
  {
    id v15 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
    id v16 = deviceNSArray(v15);
    id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    [v2 setBinaryArchives:v17];
  }

  if ((objc_opt_respondsToSelector(v1, "linkedFunctions") & 1) != 0)
  {
    unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v1 linkedFunctions]);
    id v19 = deviceMTLLinkedFunctions(v18);
    unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
    [v2 setLinkedFunctions:v20];
  }

  return v2;
}

id deviceMTLComputePipelineDescriptorWithoutResourceIndex(void *a1)
{
  id v1 = deviceMTLComputePipelineDescriptor(a1);
  id v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  [v2 setForceResourceIndex:0];
  [v2 setResourceIndex:_MTLInvalidResourceIndex];
  return v2;
}

id unwrapMTLRenderPipelineDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 vertexFunction]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 baseObject]);
  [v2 setVertexFunction:v4];

  id v5 = (void *)objc_claimAutoreleasedReturnValue([v1 fragmentFunction]);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 baseObject]);
  [v2 setFragmentFunction:v6];

  if ((objc_opt_respondsToSelector(v1, "objectFunction") & 1) != 0)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v1 objectFunction]);
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 baseObject]);
    [v2 setObjectFunction:v8];
  }

  if ((objc_opt_respondsToSelector(v1, "meshFunction") & 1) != 0)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v1 meshFunction]);
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 baseObject]);
    [v2 setMeshFunction:v10];
  }

  if ((objc_opt_respondsToSelector(v1, "pipelineLibrary") & 1) != 0)
  {
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v1 pipelineLibrary]);
    __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v11 baseObject]);
    [v2 setPipelineLibrary:v12];
  }

  if ((objc_opt_respondsToSelector(v1, "vertexPreloadedLibraries") & 1) != 0)
  {
    id v13 = (void *)objc_claimAutoreleasedReturnValue([v1 vertexPreloadedLibraries]);
    id v14 = unwrapNSArray(v13);
    id v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    [v2 setVertexPreloadedLibraries:v15];
  }

  if ((objc_opt_respondsToSelector(v1, "fragmentPreloadedLibraries") & 1) != 0)
  {
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v1 fragmentPreloadedLibraries]);
    id v17 = unwrapNSArray(v16);
    unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
    [v2 setFragmentPreloadedLibraries:v18];
  }

  if ((objc_opt_respondsToSelector(v1, "objectPreloadedLibraries") & 1) != 0)
  {
    id v19 = (void *)objc_claimAutoreleasedReturnValue([v1 objectPreloadedLibraries]);
    id v20 = unwrapNSArray(v19);
    vm_size_t v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
    [v2 setObjectPreloadedLibraries:v21];
  }

  if ((objc_opt_respondsToSelector(v1, "meshPreloadedLibraries") & 1) != 0)
  {
    id v22 = (void *)objc_claimAutoreleasedReturnValue([v1 meshPreloadedLibraries]);
    id v23 = unwrapNSArray(v22);
    unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
    [v2 setMeshPreloadedLibraries:v24];
  }

  if ((objc_opt_respondsToSelector(v1, "vertexLinkedFunctions") & 1) != 0)
  {
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue([v1 vertexLinkedFunctions]);
    id v26 = unwrapMTLLinkedFunctions(v25);
    __int128 v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
    [v2 setVertexLinkedFunctions:v27];
  }

  if ((objc_opt_respondsToSelector(v1, "fragmentLinkedFunctions") & 1) != 0)
  {
    __int128 v28 = (void *)objc_claimAutoreleasedReturnValue([v1 fragmentLinkedFunctions]);
    id v29 = unwrapMTLLinkedFunctions(v28);
    unint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
    [v2 setFragmentLinkedFunctions:v30];
  }

  if ((objc_opt_respondsToSelector(v1, "objectLinkedFunctions") & 1) != 0)
  {
    id v31 = (void *)objc_claimAutoreleasedReturnValue([v1 objectLinkedFunctions]);
    id v32 = unwrapMTLLinkedFunctions(v31);
    int v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
    [v2 setObjectLinkedFunctions:v33];
  }

  if ((objc_opt_respondsToSelector(v1, "meshLinkedFunctions") & 1) != 0)
  {
    id v34 = (void *)objc_claimAutoreleasedReturnValue([v1 meshLinkedFunctions]);
    id v35 = unwrapMTLLinkedFunctions(v34);
    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
    [v2 setMeshLinkedFunctions:v36];
  }

  if ((objc_opt_respondsToSelector(v1, "binaryArchives") & 1) != 0)
  {
    unsigned __int8 v37 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
    id v38 = unwrapNSArray(v37);
    uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
    [v2 setBinaryArchives:v39];
  }

  return v2;
}

id deviceMTLRenderPipelineDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 vertexFunction]);
  id v4 = DEVICEOBJECT(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  [v2 setVertexFunction:v5];

  id v6 = (void *)objc_claimAutoreleasedReturnValue([v1 fragmentFunction]);
  id v7 = DEVICEOBJECT(v6);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  [v2 setFragmentFunction:v8];

  if ((objc_opt_respondsToSelector(v1, "objectFunction") & 1) != 0)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v1 objectFunction]);
    id v10 = DEVICEOBJECT(v9);
    id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    [v2 setObjectFunction:v11];
  }

  if ((objc_opt_respondsToSelector(v1, "meshFunction") & 1) != 0)
  {
    __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v1 meshFunction]);
    id v13 = DEVICEOBJECT(v12);
    id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    [v2 setMeshFunction:v14];
  }

  if ((objc_opt_respondsToSelector(v1, "pipelineLibrary") & 1) != 0)
  {
    id v15 = (void *)objc_claimAutoreleasedReturnValue([v1 pipelineLibrary]);
    id v16 = DEVICEOBJECT(v15);
    id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    [v2 setPipelineLibrary:v17];
  }

  if ((objc_opt_respondsToSelector(v1, "vertexPreloadedLibraries") & 1) != 0)
  {
    unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v1 vertexPreloadedLibraries]);
    id v19 = deviceNSArray(v18);
    id v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
    [v2 setVertexPreloadedLibraries:v20];
  }

  if ((objc_opt_respondsToSelector(v1, "fragmentPreloadedLibraries") & 1) != 0)
  {
    vm_size_t v21 = (void *)objc_claimAutoreleasedReturnValue([v1 fragmentPreloadedLibraries]);
    id v22 = deviceNSArray(v21);
    id v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
    [v2 setFragmentPreloadedLibraries:v23];
  }

  if ((objc_opt_respondsToSelector(v1, "objectPreloadedLibraries") & 1) != 0)
  {
    unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v1 objectPreloadedLibraries]);
    id v25 = deviceNSArray(v24);
    id v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
    [v2 setObjectPreloadedLibraries:v26];
  }

  if ((objc_opt_respondsToSelector(v1, "meshPreloadedLibraries") & 1) != 0)
  {
    __int128 v27 = (void *)objc_claimAutoreleasedReturnValue([v1 meshPreloadedLibraries]);
    id v28 = deviceNSArray(v27);
    id v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
    [v2 setMeshPreloadedLibraries:v29];
  }

  if ((objc_opt_respondsToSelector(v1, "vertexLinkedFunctions") & 1) != 0)
  {
    unint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v1 vertexLinkedFunctions]);
    id v31 = deviceMTLLinkedFunctions(v30);
    id v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
    [v2 setVertexLinkedFunctions:v32];
  }

  if ((objc_opt_respondsToSelector(v1, "fragmentLinkedFunctions") & 1) != 0)
  {
    int v33 = (void *)objc_claimAutoreleasedReturnValue([v1 fragmentLinkedFunctions]);
    id v34 = deviceMTLLinkedFunctions(v33);
    id v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
    [v2 setFragmentLinkedFunctions:v35];
  }

  if ((objc_opt_respondsToSelector(v1, "objectLinkedFunctions") & 1) != 0)
  {
    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v1 objectLinkedFunctions]);
    id v37 = deviceMTLLinkedFunctions(v36);
    id v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
    [v2 setObjectLinkedFunctions:v38];
  }

  if ((objc_opt_respondsToSelector(v1, "meshLinkedFunctions") & 1) != 0)
  {
    uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v1 meshLinkedFunctions]);
    id v40 = deviceMTLLinkedFunctions(v39);
    id v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
    [v2 setMeshLinkedFunctions:v41];
  }

  if ((objc_opt_respondsToSelector(v1, "binaryArchives") & 1) != 0)
  {
    unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
    id v43 = deviceNSArray(v42);
    id v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
    [v2 setBinaryArchives:v44];
  }

  return v2;
}

id deviceMTLRenderPipelineDescriptorWithoutResourceIndex(void *a1)
{
  id v1 = deviceMTLRenderPipelineDescriptor(a1);
  id v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  [v2 setForceResourceIndex:0];
  [v2 setResourceIndex:_MTLInvalidResourceIndex];
  return v2;
}

id unwrapMTLCommandQueueDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  id v3 = v1;
  if (v2)
  {
    if ((objc_opt_respondsToSelector(v1, "logState") & 1) != 0)
    {
      id v4 = (void *)objc_claimAutoreleasedReturnValue([v1 logState]);
      id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 baseObject]);
      [v2 setLogState:v5];
    }

    [v2 setEnableLowLatencyWaitSharedEvent:0];
    [v2 setEnableLowLatencySignalSharedEvent:0];
    id v3 = v2;
  }

  id v6 = v3;

  return v6;
}

id unwrapMTLCommandBufferDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  if ((objc_opt_respondsToSelector(v1, "logState") & 1) != 0)
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 logState]);
    id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 baseObject]);
    [v2 setLogState:v4];
  }

  if ((objc_opt_respondsToSelector(v1, "deadlineProfile") & 1) != 0)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v1 deadlineProfile]);
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 baseObject]);
    [v2 setDeadlineProfile:v6];
  }

  return v2;
}

id unwrapMTLRenderPassDescriptor_(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = [v3 copy];
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v3 visibilityResultBuffer]);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 baseObject]);
  [v5 setVisibilityResultBuffer:v7];

  id v8 = (void *)objc_claimAutoreleasedReturnValue([v3 visibilityResultBuffer]);
  [v8 touch];

  id v9 = (void *)objc_claimAutoreleasedReturnValue([v3 visibilityResultBuffer]);
  if (v4 && v9)
  {
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v3 visibilityResultBuffer]);
    [v4 addObject:v10];
  }

  id v11 = *(id *)[v3 _descriptorPrivate];
  for (uint64_t i = 0LL; i != 8; ++i)
  {
    id v13 = (void *)objc_claimAutoreleasedReturnValue([v11 _descriptorAtIndex:i]);
    id v14 = v13;
    if (v13)
    {
      id v15 = (void *)objc_claimAutoreleasedReturnValue([v13 texture]);
      id v16 = (void *)objc_claimAutoreleasedReturnValue([v15 baseObject]);
      id v17 = (void *)objc_claimAutoreleasedReturnValue([v5 colorAttachments]);
      unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:i]);
      [v18 setTexture:v16];

      id v19 = (void *)objc_claimAutoreleasedReturnValue([v14 resolveTexture]);
      id v20 = (void *)objc_claimAutoreleasedReturnValue([v19 baseObject]);
      vm_size_t v21 = (void *)objc_claimAutoreleasedReturnValue([v5 colorAttachments]);
      id v22 = (void *)objc_claimAutoreleasedReturnValue([v21 objectAtIndexedSubscript:i]);
      [v22 setResolveTexture:v20];

      id v23 = (void *)objc_claimAutoreleasedReturnValue([v14 texture]);
      [v23 touch];

      unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v14 texture]);
      if (v4 && v24)
      {
        id v25 = (void *)objc_claimAutoreleasedReturnValue([v14 texture]);
        [v4 addObject:v25];
      }

      id v26 = (void *)objc_claimAutoreleasedReturnValue([v14 resolveTexture]);
      [v26 touch];

      __int128 v27 = (void *)objc_claimAutoreleasedReturnValue([v14 resolveTexture]);
      if (v4 && v27)
      {
        id v28 = (void *)objc_claimAutoreleasedReturnValue([v14 resolveTexture]);
        [v4 addObject:v28];
      }
    }
  }

  id v29 = (void *)objc_claimAutoreleasedReturnValue([v11 _descriptorAtIndex:8]);
  unint64_t v30 = v29;
  if (v29)
  {
    id v31 = (void *)objc_claimAutoreleasedReturnValue([v29 texture]);
    id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 baseObject]);
    int v33 = (void *)objc_claimAutoreleasedReturnValue([v5 depthAttachment]);
    [v33 setTexture:v32];

    id v34 = (void *)objc_claimAutoreleasedReturnValue([v30 resolveTexture]);
    id v35 = (void *)objc_claimAutoreleasedReturnValue([v34 baseObject]);
    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v5 depthAttachment]);
    [v36 setResolveTexture:v35];

    id v37 = (void *)objc_claimAutoreleasedReturnValue([v30 texture]);
    [v37 touch];

    id v38 = (void *)objc_claimAutoreleasedReturnValue([v30 texture]);
    if (v4 && v38)
    {
      uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v30 texture]);
      [v4 addObject:v39];
    }

    id v40 = (void *)objc_claimAutoreleasedReturnValue([v30 resolveTexture]);
    [v40 touch];

    id v41 = (void *)objc_claimAutoreleasedReturnValue([v30 resolveTexture]);
    if (v4 && v41)
    {
      unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v30 resolveTexture]);
      [v4 addObject:v42];
    }
  }

  id v43 = (void *)objc_claimAutoreleasedReturnValue([v11 _descriptorAtIndex:9]);

  if (v43)
  {
    id v44 = (void *)objc_claimAutoreleasedReturnValue([v43 texture]);
    id v45 = (void *)objc_claimAutoreleasedReturnValue([v44 baseObject]);
    uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v5 stencilAttachment]);
    [v46 setTexture:v45];

    id v47 = (void *)objc_claimAutoreleasedReturnValue([v43 resolveTexture]);
    id v48 = (void *)objc_claimAutoreleasedReturnValue([v47 baseObject]);
    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v5 stencilAttachment]);
    [v49 setResolveTexture:v48];

    uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v43 texture]);
    [v50 touch];

    id v51 = (void *)objc_claimAutoreleasedReturnValue([v43 texture]);
    if (v4 && v51)
    {
      id v52 = (void *)objc_claimAutoreleasedReturnValue([v43 texture]);
      [v4 addObject:v52];
    }

    unsigned int v53 = (void *)objc_claimAutoreleasedReturnValue([v43 resolveTexture]);
    [v53 touch];

    int v54 = (void *)objc_claimAutoreleasedReturnValue([v43 resolveTexture]);
    if (v4 && v54)
    {
      id v55 = (void *)objc_claimAutoreleasedReturnValue([v43 resolveTexture]);
      [v4 addObject:v55];
    }
  }

  if ((objc_opt_respondsToSelector(v5, "rasterizationRateMap") & 1) != 0)
  {
    char v56 = (void *)objc_claimAutoreleasedReturnValue([v3 rasterizationRateMap]);
    id v57 = (void *)objc_claimAutoreleasedReturnValue([v56 baseObject]);
    [v5 setRasterizationRateMap:v57];

    uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v3 rasterizationRateMap]);
    [v58 touch];

    id v59 = (void *)objc_claimAutoreleasedReturnValue([v3 rasterizationRateMap]);
    if (v4)
    {
      if (v59)
      {
        id v60 = (void *)objc_claimAutoreleasedReturnValue([v3 rasterizationRateMap]);
        [v4 addObject:v60];
      }
    }
  }

  id v61 = (void *)objc_claimAutoreleasedReturnValue([v3 sampleBufferAttachments]);
  for (uint64_t j = 0LL; j != 4; ++j)
  {
    id v63 = (void *)objc_claimAutoreleasedReturnValue([v61 _descriptorAtIndex:j]);
    uint64_t v64 = v63;
    if (v63)
    {
      uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v63 sampleBuffer]);
      uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v65 baseObject]);
      uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBufferAttachments]);
      __int128 v68 = (void *)objc_claimAutoreleasedReturnValue([v67 objectAtIndexedSubscript:j]);
      [v68 setSampleBuffer:v66];

      id v69 = (void *)objc_claimAutoreleasedReturnValue([v64 sampleBuffer]);
      [v69 touch];

      int v70 = (void *)objc_claimAutoreleasedReturnValue([v64 sampleBuffer]);
      if (v4)
      {
        if (v70)
        {
          id v71 = (void *)objc_claimAutoreleasedReturnValue([v64 sampleBuffer]);
          [v4 addObject:v71];
        }
      }
    }
  }

  return v5;
}

id unwrapMTLBlitPassDescriptor_(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = [v3 copy];
  uint64_t v6 = 0LL;
  id v7 = *(void **)[v3 _descriptorPrivate];
  do
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 _descriptorAtIndex:v6]);
    id v9 = v8;
    if (v8)
    {
      id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 sampleBuffer]);
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 baseObject]);
      __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBufferAttachments]);
      id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:v6]);
      [v13 setSampleBuffer:v11];

      id v14 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
      [v14 touch];

      id v15 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
      if (v4)
      {
        if (v15)
        {
          id v16 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
          [v4 addObject:v16];
        }
      }
    }

    ++v6;
  }

  while (v6 != 4);

  return v5;
}

id unwrapMTLComputePassDescriptor_(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = [v3 copy];
  uint64_t v6 = 0LL;
  id v7 = (void *)*((void *)[v3 _descriptorPrivate] + 1);
  do
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 _descriptorAtIndex:v6]);
    id v9 = v8;
    if (v8)
    {
      id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 sampleBuffer]);
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 baseObject]);
      __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBufferAttachments]);
      id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:v6]);
      [v13 setSampleBuffer:v11];

      id v14 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
      [v14 touch];

      id v15 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
      if (v4)
      {
        if (v15)
        {
          id v16 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
          [v4 addObject:v16];
        }
      }
    }

    ++v6;
  }

  while (v6 != 4);

  return v5;
}

id unwrapMTLResourceStatePassDescriptor_(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = [v3 copy];
  uint64_t v6 = 0LL;
  id v7 = *(void **)[v3 _descriptorPrivate];
  do
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 _descriptorAtIndex:v6]);
    id v9 = v8;
    if (v8)
    {
      id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 sampleBuffer]);
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 baseObject]);
      __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBufferAttachments]);
      id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:v6]);
      [v13 setSampleBuffer:v11];

      id v14 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
      [v14 touch];

      id v15 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
      if (v4)
      {
        if (v15)
        {
          id v16 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
          [v4 addObject:v16];
        }
      }
    }

    ++v6;
  }

  while (v6 != 4);

  return v5;
}

id unwrapMTLStitchedLibraryDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 functions]);
  id v4 = unwrapNSArray(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  [v2 setFunctions:v5];

  if ((objc_opt_respondsToSelector(v2, "binaryArchives") & 1) != 0)
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
    id v7 = unwrapNSArray(v6);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    [v2 setBinaryArchives:v8];
  }

  return v2;
}

id unwrapMTLStitchedLibraryDescriptorSPI(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 functions]);
  id v4 = unwrapNSArray(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  [v2 setFunctions:v5];

  if ((objc_opt_respondsToSelector(v2, "binaryArchives") & 1) != 0)
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
    id v7 = unwrapNSArray(v6);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    [v2 setBinaryArchives:v8];
  }

  return v2;
}

id unwrapMTLAccelerationStructureDescriptor(void *a1)
{
  id v1 = a1;
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___MTLInstanceAccelerationStructureDescriptor, v2);
  if ((objc_opt_isKindOfClass(v1, v3) & 1) == 0)
  {
    uint64_t v15 = objc_opt_class(&OBJC_CLASS___MTLPrimitiveAccelerationStructureDescriptor, v4);
    if ((objc_opt_isKindOfClass(v1, v15) & 1) == 0)
    {
      uint64_t v98 = objc_opt_class(&OBJC_CLASS___MTLIndirectInstanceAccelerationStructureDescriptor, v16);
      if ((objc_opt_isKindOfClass(v1, v98) & 1) != 0)
      {
        id v6 = [v1 copy];
        unint64_t v99 = (void *)objc_claimAutoreleasedReturnValue([v6 instanceDescriptorBuffer]);
        unint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([v99 baseObject]);
        [v6 setInstanceDescriptorBuffer:v100];

        unint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v6 instanceCountBuffer]);
        double v102 = (void *)objc_claimAutoreleasedReturnValue([v101 baseObject]);
        [v6 setInstanceCountBuffer:v102];

        unint64_t v103 = (void *)objc_claimAutoreleasedReturnValue([v6 motionTransformBuffer]);
        unsigned int v104 = (void *)objc_claimAutoreleasedReturnValue([v103 baseObject]);
        [v6 setMotionTransformBuffer:v104];

        unsigned int v105 = (void *)objc_claimAutoreleasedReturnValue([v6 motionTransformCountBuffer]);
        unsigned int v106 = (void *)objc_claimAutoreleasedReturnValue([v105 baseObject]);
        [v6 setMotionTransformCountBuffer:v106];
      }

      else
      {
        id v6 = v1;
      }

      goto LABEL_70;
    }

    id v108 = v1;
    id v6 = [v1 copy];
    id v17 = (void *)objc_claimAutoreleasedReturnValue([v6 geometryDescriptors]);
    id v18 = [v17 mutableCopy];

    id v19 = (void *)objc_claimAutoreleasedReturnValue([v6 geometryDescriptors]);
    id v20 = [v19 count];

    if (!v20)
    {
LABEL_68:
      [v6 setGeometryDescriptors:v18];

      id v1 = v108;
      goto LABEL_70;
    }

    unint64_t v21 = 0LL;
    id v109 = v18;
    id v110 = v6;
    while (1)
    {
      id v22 = (void *)objc_claimAutoreleasedReturnValue([v6 geometryDescriptors]);
      id v23 = (id)objc_claimAutoreleasedReturnValue([v22 objectAtIndexedSubscript:v21]);
      uint64_t v25 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureTriangleGeometryDescriptor, v24);
      if ((objc_opt_isKindOfClass(v23, v25) & 1) != 0)
      {
        id v27 = [v23 copy];
        id v28 = (void *)objc_claimAutoreleasedReturnValue([v27 vertexBuffer]);
        id v29 = (void *)objc_claimAutoreleasedReturnValue([v28 baseObject]);
        [v27 setVertexBuffer:v29];

        unint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v27 indexBuffer]);
        id v31 = (void *)objc_claimAutoreleasedReturnValue([v30 baseObject]);
        [v27 setIndexBuffer:v31];

        if ((objc_opt_respondsToSelector(v27, "transformationMatrixBuffer") & 1) != 0)
        {
          id v32 = (void *)objc_claimAutoreleasedReturnValue([v27 transformationMatrixBuffer]);
          int v33 = (void *)objc_claimAutoreleasedReturnValue([v32 baseObject]);
          [v27 setTransformationMatrixBuffer:v33];
          goto LABEL_13;
        }

        goto LABEL_14;
      }

      uint64_t v34 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureBoundingBoxGeometryDescriptor, v26);
      if ((objc_opt_isKindOfClass(v23, v34) & 1) != 0)
      {
        id v27 = [v23 copy];
        id v32 = (void *)objc_claimAutoreleasedReturnValue([v27 boundingBoxBuffer]);
        int v33 = (void *)objc_claimAutoreleasedReturnValue([v32 baseObject]);
        [v27 setBoundingBoxBuffer:v33];
LABEL_13:

LABEL_14:
        if ((objc_opt_respondsToSelector(v27, "primitiveDataBuffer") & 1) != 0)
        {
          uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v27 primitiveDataBuffer]);
          id v37 = (void *)objc_claimAutoreleasedReturnValue([v36 baseObject]);
          [v27 setPrimitiveDataBuffer:v37];
        }

        goto LABEL_63;
      }

      uint64_t v38 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionTriangleGeometryDescriptor, v35);
      if ((objc_opt_isKindOfClass(v23, v38) & 1) != 0)
      {
        __int16 v111 = v22;
        id v27 = [v23 copy];
        id v40 = (void *)objc_claimAutoreleasedReturnValue([v27 indexBuffer]);
        id v41 = (void *)objc_claimAutoreleasedReturnValue([v40 baseObject]);
        [v27 setIndexBuffer:v41];

        __int128 v122 = 0u;
        __int128 v123 = 0u;
        __int128 v120 = 0u;
        __int128 v121 = 0u;
        unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v27 vertexBuffers]);
        id v43 = [v42 countByEnumeratingWithState:&v120 objects:v124 count:16];
        if (v43)
        {
          id v44 = v43;
          uint64_t v45 = *(void *)v121;
          do
          {
            for (uint64_t i = 0LL; i != v44; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v121 != v45) {
                objc_enumerationMutation(v42);
              }
              id v47 = *(void **)(*((void *)&v120 + 1) + 8LL * (void)i);
              id v48 = (void *)objc_claimAutoreleasedReturnValue([v47 buffer]);
              uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v48 baseObject]);
              [v47 setBuffer:v49];
            }

            id v44 = [v42 countByEnumeratingWithState:&v120 objects:v124 count:16];
          }

          while (v44);
        }

        if ((objc_opt_respondsToSelector(v27, "transformationMatrixBuffer") & 1) != 0)
        {
          uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v27 transformationMatrixBuffer]);
          id v51 = (void *)objc_claimAutoreleasedReturnValue([v50 baseObject]);
          [v27 setTransformationMatrixBuffer:v51];
        }

        id v18 = v109;
        id v6 = v110;
        if ((objc_opt_respondsToSelector(v27, "primitiveDataBuffer") & 1) != 0)
        {
          id v52 = (void *)objc_claimAutoreleasedReturnValue([v27 primitiveDataBuffer]);
          unsigned int v53 = (void *)objc_claimAutoreleasedReturnValue([v52 baseObject]);
          [v27 setPrimitiveDataBuffer:v53];
        }

        goto LABEL_62;
      }

      uint64_t v54 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor, v39);
      if ((objc_opt_isKindOfClass(v23, v54) & 1) != 0)
      {
        __int16 v111 = v22;
        id v27 = [v23 copy];
        __int128 v120 = 0u;
        __int128 v121 = 0u;
        __int128 v122 = 0u;
        __int128 v123 = 0u;
        char v56 = (void *)objc_claimAutoreleasedReturnValue([v27 boundingBoxBuffers]);
        id v57 = [v56 countByEnumeratingWithState:&v120 objects:v124 count:16];
        if (v57)
        {
          id v58 = v57;
          uint64_t v59 = *(void *)v121;
          do
          {
            for (uint64_t j = 0LL; j != v58; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v121 != v59) {
                objc_enumerationMutation(v56);
              }
              id v61 = *(void **)(*((void *)&v120 + 1) + 8LL * (void)j);
              id v62 = (void *)objc_claimAutoreleasedReturnValue([v61 buffer]);
              id v63 = (void *)objc_claimAutoreleasedReturnValue([v62 baseObject]);
              [v61 setBuffer:v63];
            }

            id v58 = [v56 countByEnumeratingWithState:&v120 objects:v124 count:16];
          }

          while (v58);
        }

        if ((objc_opt_respondsToSelector(v27, "primitiveDataBuffer") & 1) == 0) {
          goto LABEL_61;
        }
        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v27 primitiveDataBuffer]);
        uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v64 baseObject]);
        [v27 setPrimitiveDataBuffer:v65];
      }

      else
      {
        uint64_t v66 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureCurveGeometryDescriptor, v55);
        if ((objc_opt_isKindOfClass(v23, v66) & 1) != 0)
        {
          __int128 v68 = v22;
          id v27 = [v23 copy];
          id v69 = (void *)objc_claimAutoreleasedReturnValue([v27 controlPointBuffer]);
          int v70 = (void *)objc_claimAutoreleasedReturnValue([v69 baseObject]);
          [v27 setControlPointBuffer:v70];

          id v71 = (void *)objc_claimAutoreleasedReturnValue([v27 radiusBuffer]);
          __int128 v72 = (void *)objc_claimAutoreleasedReturnValue([v71 baseObject]);
          [v27 setRadiusBuffer:v72];

          __int128 v73 = (void *)objc_claimAutoreleasedReturnValue([v27 indexBuffer]);
          id v74 = (void *)objc_claimAutoreleasedReturnValue([v73 baseObject]);
          [v27 setIndexBuffer:v74];

          if ((objc_opt_respondsToSelector(v27, "primitiveDataBuffer") & 1) != 0)
          {
            __int128 v75 = (void *)objc_claimAutoreleasedReturnValue([v27 primitiveDataBuffer]);
            uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue([v75 baseObject]);
            [v27 setPrimitiveDataBuffer:v76];
          }

          id v22 = v68;
          goto LABEL_63;
        }

        uint64_t v77 = objc_opt_class(&OBJC_CLASS___MTLAccelerationStructureMotionCurveGeometryDescriptor, v67);
        if ((objc_opt_isKindOfClass(v23, v77) & 1) == 0)
        {
          id v27 = v23;
          goto LABEL_63;
        }

        __int16 v111 = v22;
        id v27 = [v23 copy];
        __int128 v116 = 0u;
        __int128 v117 = 0u;
        __int128 v118 = 0u;
        __int128 v119 = 0u;
        uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v27 controlPointBuffers]);
        id v79 = [v78 countByEnumeratingWithState:&v116 objects:v124 count:16];
        if (v79)
        {
          id v80 = v79;
          uint64_t v81 = *(void *)v117;
          do
          {
            for (uint64_t k = 0LL; k != v80; uint64_t k = (char *)k + 1)
            {
              if (*(void *)v117 != v81) {
                objc_enumerationMutation(v78);
              }
              id v83 = *(void **)(*((void *)&v116 + 1) + 8LL * (void)k);
              id v84 = (void *)objc_claimAutoreleasedReturnValue([v83 buffer]);
              id v85 = (void *)objc_claimAutoreleasedReturnValue([v84 baseObject]);
              [v83 setBuffer:v85];
            }

            id v80 = [v78 countByEnumeratingWithState:&v116 objects:v124 count:16];
          }

          while (v80);
        }

        __int128 v114 = 0u;
        __int128 v115 = 0u;
        __int128 v112 = 0u;
        __int128 v113 = 0u;
        id v86 = (void *)objc_claimAutoreleasedReturnValue([v27 radiusBuffers]);
        id v87 = [v86 countByEnumeratingWithState:&v112 objects:&v120 count:16];
        if (v87)
        {
          id v88 = v87;
          uint64_t v89 = *(void *)v113;
          do
          {
            for (uint64_t m = 0LL; m != v88; uint64_t m = (char *)m + 1)
            {
              if (*(void *)v113 != v89) {
                objc_enumerationMutation(v86);
              }
              id v91 = *(void **)(*((void *)&v112 + 1) + 8LL * (void)m);
              int v92 = (void *)objc_claimAutoreleasedReturnValue([v91 buffer]);
              int32x2_t v93 = (void *)objc_claimAutoreleasedReturnValue([v92 baseObject]);
              [v91 setBuffer:v93];
            }

            id v88 = [v86 countByEnumeratingWithState:&v112 objects:&v120 count:16];
          }

          while (v88);
        }

        if ((objc_opt_respondsToSelector(v27, "primitiveDataBuffer") & 1) != 0)
        {
          uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue([v27 primitiveDataBuffer]);
          unint64_t v95 = (void *)objc_claimAutoreleasedReturnValue([v94 baseObject]);
          [v27 setPrimitiveDataBuffer:v95];
        }

        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v27 indexBuffer]);
        uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v64 baseObject]);
        [v27 setIndexBuffer:v65];
      }

LABEL_61:
      id v18 = v109;
      id v6 = v110;
LABEL_62:
      id v22 = v111;
LABEL_63:

      [v18 setObject:v27 atIndexedSubscript:v21];
      ++v21;
      unint64_t v96 = (void *)objc_claimAutoreleasedReturnValue([v6 geometryDescriptors]);
      id v97 = [v96 count];
    }
  }

  id v5 = v1;
  id v6 = [v5 copy];
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 instancedAccelerationStructures]);

  if (!v7) {
    [v6 setInstancedAccelerationStructures:0];
  }
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v6 instanceDescriptorBuffer]);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 baseObject]);
  [v6 setInstanceDescriptorBuffer:v9];

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v6 instancedAccelerationStructures]);
  id v11 = unwrapNSArray(v10);
  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  [v6 setInstancedAccelerationStructures:v12];

  id v13 = (void *)objc_claimAutoreleasedReturnValue([v6 motionTransformBuffer]);
  id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 baseObject]);
  [v6 setMotionTransformBuffer:v14];

LABEL_70:
  return v6;
}

id unwrapMTLFunctionDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  if ((objc_opt_respondsToSelector(v1, "binaryArchives") & 1) != 0)
  {
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
    id v4 = unwrapNSArray(v3);
    id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
    [v2 setBinaryArchives:v5];
  }

  if ((objc_opt_respondsToSelector(v1, "privateFunctions") & 1) != 0)
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v1 privateFunctions]);
    id v7 = unwrapNSArray(v6);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    [v2 setPrivateFunctions:v8];
  }

  return v2;
}

id unwrapMTLVisibleFunctionTableDescriptor(void *a1)
{
  return [a1 copy];
}

id unwrapMTLIntersectionFunctionTableDescriptor(void *a1)
{
  return [a1 copy];
}

id unwrapMTLTileRenderPipelineDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 tileFunction]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 baseObject]);
  [v2 setTileFunction:v4];

  if ((objc_opt_respondsToSelector(v1, "preloadedLibraries") & 1) != 0)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v1 preloadedLibraries]);
    id v6 = unwrapNSArray(v5);
    id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    [v2 setPreloadedLibraries:v7];
  }

  if ((objc_opt_respondsToSelector(v1, "linkedFunctions") & 1) != 0)
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v1 linkedFunctions]);
    id v9 = unwrapMTLLinkedFunctions(v8);
    id v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    [v2 setLinkedFunctions:v10];
  }

  if ((objc_opt_respondsToSelector(v1, "binaryArchives") & 1) != 0)
  {
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
    id v12 = unwrapNSArray(v11);
    id v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    [v2 setBinaryArchives:v13];
  }

  return v2;
}

id deviceMTLTileRenderPipelineDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 tileFunction]);
  id v4 = DEVICEOBJECT(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  [v2 setTileFunction:v5];

  if ((objc_opt_respondsToSelector(v1, "preloadedLibraries") & 1) != 0)
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v1 preloadedLibraries]);
    id v7 = deviceNSArray(v6);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    [v2 setPreloadedLibraries:v8];
  }

  if ((objc_opt_respondsToSelector(v1, "linkedFunctions") & 1) != 0)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v1 linkedFunctions]);
    id v10 = deviceMTLLinkedFunctions(v9);
    id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    [v2 setLinkedFunctions:v11];
  }

  if ((objc_opt_respondsToSelector(v1, "binaryArchives") & 1) != 0)
  {
    id v12 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
    id v13 = deviceNSArray(v12);
    id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    [v2 setBinaryArchives:v14];
  }

  return v2;
}

id unwrapMTLCompileOptions(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 libraries]);
  id v4 = [v3 count];

  if (v4)
  {
    id v5 = objc_alloc(&OBJC_CLASS___NSMutableArray);
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v1 libraries]);
    id v7 = -[NSMutableArray initWithCapacity:](v5, "initWithCapacity:", [v6 count]);

    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    id v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "libraries", 0));
    id v9 = [v8 countByEnumeratingWithState:&v15 objects:v19 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v16;
      do
      {
        id v12 = 0LL;
        do
        {
          if (*(void *)v16 != v11) {
            objc_enumerationMutation(v8);
          }
          id v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v15 + 1) + 8 * (void)v12) baseObject]);
          -[NSMutableArray addObject:](v7, "addObject:", v13);

          id v12 = (char *)v12 + 1;
        }

        while (v10 != v12);
        id v10 = [v8 countByEnumeratingWithState:&v15 objects:v19 count:16];
      }

      while (v10);
    }

    [v2 setLibraries:v7];
  }

  return v2;
}

id unwrapMTLRenderPipelineFunctionsDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 vertexAdditionalBinaryFunctions]);
  id v4 = unwrapNSArray(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  [v2 setVertexAdditionalBinaryFunctions:v5];

  id v6 = (void *)objc_claimAutoreleasedReturnValue([v1 fragmentAdditionalBinaryFunctions]);
  id v7 = unwrapNSArray(v6);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  [v2 setFragmentAdditionalBinaryFunctions:v8];

  id v9 = (void *)objc_claimAutoreleasedReturnValue([v1 tileAdditionalBinaryFunctions]);
  id v10 = unwrapNSArray(v9);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  [v2 setTileAdditionalBinaryFunctions:v11];

  id v12 = (void *)objc_claimAutoreleasedReturnValue([v1 objectAdditionalBinaryFunctions]);
  id v13 = unwrapNSArray(v12);
  id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
  [v2 setObjectAdditionalBinaryFunctions:v14];

  __int128 v15 = (void *)objc_claimAutoreleasedReturnValue([v1 meshAdditionalBinaryFunctions]);
  id v16 = unwrapNSArray(v15);
  __int128 v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  [v2 setMeshAdditionalBinaryFunctions:v17];

  return v2;
}

id deviceMTLMeshRenderPipelineDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 objectFunction]);
  id v4 = DEVICEOBJECT(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  [v2 setObjectFunction:v5];

  id v6 = (void *)objc_claimAutoreleasedReturnValue([v1 meshFunction]);
  id v7 = DEVICEOBJECT(v6);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  [v2 setMeshFunction:v8];

  id v9 = (void *)objc_claimAutoreleasedReturnValue([v1 fragmentFunction]);
  id v10 = DEVICEOBJECT(v9);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  [v2 setFragmentFunction:v11];

  id v12 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
  id v13 = deviceNSArray(v12);
  id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
  [v2 setBinaryArchives:v14];

  __int128 v15 = (void *)objc_claimAutoreleasedReturnValue([v2 objectLinkedFunctions]);
  id v16 = deviceMTLLinkedFunctions(v15);
  __int128 v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  [v2 setObjectLinkedFunctions:v17];

  __int128 v18 = (void *)objc_claimAutoreleasedReturnValue([v2 meshLinkedFunctions]);
  id v19 = deviceMTLLinkedFunctions(v18);
  id v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  [v2 setMeshLinkedFunctions:v20];

  unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v2 fragmentLinkedFunctions]);
  id v22 = deviceMTLLinkedFunctions(v21);
  id v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
  [v2 setFragmentLinkedFunctions:v23];

  return v2;
}

id unwrapMTLMeshRenderPipelineDescriptor(void *a1)
{
  id v1 = a1;
  id v2 = [v1 copy];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 objectFunction]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 baseObject]);
  [v2 setObjectFunction:v4];

  id v5 = (void *)objc_claimAutoreleasedReturnValue([v1 meshFunction]);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 baseObject]);
  [v2 setMeshFunction:v6];

  id v7 = (void *)objc_claimAutoreleasedReturnValue([v1 fragmentFunction]);
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 baseObject]);
  [v2 setFragmentFunction:v8];

  id v9 = (void *)objc_claimAutoreleasedReturnValue([v1 binaryArchives]);
  id v10 = unwrapNSArray(v9);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  [v2 setBinaryArchives:v11];

  id v12 = (void *)objc_claimAutoreleasedReturnValue([v2 objectLinkedFunctions]);
  id v13 = unwrapMTLLinkedFunctions(v12);
  id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
  [v2 setObjectLinkedFunctions:v14];

  __int128 v15 = (void *)objc_claimAutoreleasedReturnValue([v2 meshLinkedFunctions]);
  id v16 = unwrapMTLLinkedFunctions(v15);
  __int128 v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  [v2 setMeshLinkedFunctions:v17];

  __int128 v18 = (void *)objc_claimAutoreleasedReturnValue([v2 fragmentLinkedFunctions]);
  id v19 = unwrapMTLLinkedFunctions(v18);
  id v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  [v2 setFragmentLinkedFunctions:v20];

  return v2;
}

id deviceMTLMeshRenderPipelineDescriptorWithoutResourceIndex(void *a1)
{
  id v1 = deviceMTLMeshRenderPipelineDescriptor(a1);
  id v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  [v2 setForceResourceIndex:0];
  [v2 setResourceIndex:_MTLInvalidResourceIndex];
  return v2;
}

id unwrapMTLAccelerationStructurePassDescriptor_(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = [v3 copy];
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v3 sampleBufferAttachments]);
  for (uint64_t i = 0LL; i != 4; ++i)
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:i]);
    id v9 = v8;
    if (v8)
    {
      id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 sampleBuffer]);
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 baseObject]);
      id v12 = (void *)objc_claimAutoreleasedReturnValue([v5 sampleBufferAttachments]);
      id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:i]);
      [v13 setSampleBuffer:v11];

      id v14 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
      [v14 touch];

      __int128 v15 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
      if (v4)
      {
        if (v15)
        {
          id v16 = (void *)objc_claimAutoreleasedReturnValue([v9 sampleBuffer]);
          [v4 addObject:v16];
        }
      }
    }
  }

  return v5;
}

id unwrapMTLGenericBVHBuffersSPI(void *a1)
{
  id v1 = [a1 copy];
  id v2 = (void *)objc_claimAutoreleasedReturnValue([v1 headerBuffer]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 baseObject]);
  [v1 setHeaderBuffer:v3];

  id v4 = (void *)objc_claimAutoreleasedReturnValue([v1 innerNodeBuffer]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 baseObject]);
  [v1 setInnerNodeBuffer:v5];

  id v6 = (void *)objc_claimAutoreleasedReturnValue([v1 leafNodeBuffer]);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 baseObject]);
  [v1 setLeafNodeBuffer:v7];

  id v8 = (void *)objc_claimAutoreleasedReturnValue([v1 primitiveBuffer]);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 baseObject]);
  [v1 setPrimitiveBuffer:v9];

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v1 geometryBuffer]);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 baseObject]);
  [v1 setGeometryBuffer:v11];

  id v12 = (void *)objc_claimAutoreleasedReturnValue([v1 instanceTransformBuffer]);
  id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 baseObject]);
  [v1 setInstanceTransformBuffer:v13];

  id v14 = (void *)objc_claimAutoreleasedReturnValue([v1 perPrimitiveDataBuffer]);
  __int128 v15 = (void *)objc_claimAutoreleasedReturnValue([v14 baseObject]);
  [v1 setPerPrimitiveDataBuffer:v15];

  return v1;
}

void CaptureMTLDeviceStoreMetadata(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v3 = a2;
    id v4 = (uint64_t *)[v3 traceStream];
    if (v4) {
      uint64_t v5 = *v4;
    }
    else {
      uint64_t v5 = 0LL;
    }
    id v6 = DEVICEOBJECT(v3);
    id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);

    GTTraceContext_pushEncoderWithStream(a1, (uint64_t)v16);
    uint64_t v8 = v17;
    *(_DWORD *)(v17 + _Block_object_dispose(va, 8) = -10239;
    unsigned __int8 v9 = v20;
    if (v20 > 0x30uLL)
    {
      uint64_t v11 = *(void *)(v16[1] + 24LL);
      uint64_t v12 = v21++;
      id v10 = GTTraceMemPool_allocateBytes(v11, v18, v12 | 0x1000000000LL) + 16;
      unsigned __int8 v9 = v12;
    }

    else
    {
      id v10 = (char *)(v8 + v20);
      v20 += 16;
    }

    *(_BYTE *)(v8 + 13) = v9;
    char v13 = SaveMTLDeviceDescriptor((uint64_t)v16, v7);
    *(void *)id v10 = v5;
    v10[8] = v13;
    *(_DWORD *)(v10 + 9) = 0;
    *((_DWORD *)v10 + 3) = 0;
    s();
    *(void *)uint64_t v14 = v15;
    *(_BYTE *)(v14 + _Block_object_dispose(va, 8) = v19;
    *(_BYTE *)(v17 + 15) |= 8u;
  }

uint64_t CaptureRespondsToSelector(uint64_t a1, const char *a2)
{
  char v3 = objc_opt_respondsToSelector();
  if ((v3 & 1) == 0
    && (sel_getUid("baseObject") == a2
     || sel_getUid("streamReference") == a2
     || sel_getUid("traceStream") == a2
     || sel_getUid("traceContext") == a2
     || sel_getUid("touch") == a2))
  {
    char v3 = 1;
  }

  return v3 & 1;
}

uint64_t CaptureConformsToProtocol(void *a1, void *a2)
{
  char v3 = a2;
  unsigned int v4 = [a1 conformsToProtocol:v3];

  if (&OBJC_PROTOCOL___CaptureMTLObject == v3) {
    return 1LL;
  }
  else {
    return v4;
  }
}

uint64_t CaptureFindFuncSnapshot(void *a1, uint64_t a2)
{
  id v5 = [a1 streamReference];
  entry = find_entry(a2, &v5, 8uLL, 0LL);
  if (*entry) {
    return *(void *)(*entry + 32LL);
  }
  else {
    return 0LL;
  }
}

void *CaptureCreateFuncSnapshot(void *a1, apr_hash_t *a2, apr_pool_t *a3)
{
  id v5 = [a1 streamReference];
  id v6 = apr_palloc(a3, 0x18uLL);
  void *v6 = v5;
  apr_hash_set(a2, v6, 8LL, v6);
  return v6;
}

void CaptureRemoveFuncSnapshot(void *a1, apr_hash_t *a2)
{
  id key = [a1 streamReference];
  entry = find_entry((uint64_t)a2, &key, 8uLL, 0LL);
  if (*entry)
  {
    if (*(void *)(*entry + 32LL)) {
      apr_hash_set(a2, &key, 8LL, 0LL);
    }
  }

apr_hash_index_t *CaptureClearFuncSnapshot(apr_hash_index_t *result, uint64_t a2)
{
  if (result == (apr_hash_index_t *)((char *)&dword_0 + 1))
  {
    *(void *)(a2 + 24) = 0LL;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 16) = a2;
    *(_DWORD *)(a2 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0;
    id result = apr_hash_next((apr_hash_index_t *)(a2 + 16));
    if (result)
    {
      char v3 = result;
      do
      {
        apr_hash_set((apr_hash_t *)a2, *(const void **)(*((void *)v3 + 1) + 16LL), 8LL, 0LL);
        id result = apr_hash_next(v3);
        char v3 = result;
      }

      while (result);
    }
  }

  return result;
}

CaptureMTLDevice *DYMTLWrapDeviceWithDebugLayer(void *a1)
{
  id v1 = a1;
  if (CaptureInterposerInit_onceToken != -1) {
    dispatch_once(&CaptureInterposerInit_onceToken, &__block_literal_global_61);
  }
  if (DYMTLWrapDeviceWithDebugLayer_onceToken != -1) {
    dispatch_once(&DYMTLWrapDeviceWithDebugLayer_onceToken, &__block_literal_global_7888);
  }
  if (isDebugDevice && isShaderValDevice)
  {
    id v2 = WrapGPUDebugDevice(v1);
    char v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    id v4 = WrapDebugDevice(v3);
    id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  }

  else
  {
    if (isDebugDevice)
    {
      id v6 = WrapDebugDevice(v1);
      uint64_t v7 = objc_claimAutoreleasedReturnValue(v6);
    }

    else
    {
      id v5 = v1;
      if (!isShaderValDevice) {
        goto LABEL_15;
      }
      id v8 = WrapGPUDebugDevice(v1);
      uint64_t v7 = objc_claimAutoreleasedReturnValue(v8);
    }

    id v5 = (void *)v7;
    char v3 = v1;
  }

  if (isShaderValDevice) {
    GTMTLCaptureManager_notifyUnsupportedFenumWithMsg( 0LL,  (uint64_t)"Metal Shader Validation",  0LL,  (uint64_t)"To enable capturing, disable Metal Shader Validation and relaunch your application.");
  }
LABEL_15:
  unsigned __int8 v9 = objc_alloc(&OBJC_CLASS___CaptureMTLDevice);
  id v10 = -[CaptureMTLDevice initWithBaseObject:captureContext:](v9, "initWithBaseObject:captureContext:", v5, g_ctx);
  CaptureMTLDeviceStoreMetadata(g_ctx, v10);
  if ((qword_23A448 & 0x40) != 0) {
    dispatch_semaphore_wait((dispatch_semaphore_t)qword_23A340, 0xFFFFFFFFFFFFFFFFLL);
  }

  return v10;
}

id WrapGPUDebugDevice(void *a1)
{
  id v1 = a1;
  unsigned __int8 v2 = [v1 supportsFamily:1006];
  id v3 = v1;
  if ((v2 & 1) == 0 && (id v4 = NSClassFromString(@"MTLLegacySVDevice")) != 0LL
    || (id v4 = NSClassFromString(@"MTLGPUDebugDevice"), v5 = v3, v4))
  {
    id v5 = [[v4 alloc] initWithBaseObject:v3 parent:0];
  }

  return v5;
}

id WrapDebugDevice(void *a1)
{
  id v1 = a1;
  id v2 = [[MTLDebugDevice alloc] initWithBaseObject:v1 parent:0];

  return v2;
}

IMP CaptureMTLInit(uint64_t a1, uint64_t a2)
{
  id v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___MTLCaptureManager, a2);
  ClassMethod = class_getClassMethod(v2, "sharedCaptureManager");
  IMP result = method_setImplementation(ClassMethod, (IMP)MTLCaptureManager_sharedCaptureManager);
  MTLCaptureManager_sharedCaptureManagerIMP = (uint64_t)result;
  return result;
}

id MTLCaptureManager_sharedCaptureManager()
{
  if (MTLCaptureManager_sharedCaptureManager_onceToken != -1) {
    dispatch_once(&MTLCaptureManager_sharedCaptureManager_onceToken, &__block_literal_global_104);
  }
  return (id)MTLCaptureManager_sharedCaptureManager_sharedCaptureManager;
}

void MTLTextureInfo(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  id v9 = a1;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  if ((unint64_t)(a2 - 250) <= 0xB && ((1LL << (a2 + 6)) & 0xC0D) != 0)
  {
    GTMTLPixelFormatGetInfoForDevice(a2, (uint64_t)&v36);
    LODWORD(v1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = (v37 >> 3) & 4;
    if (a2 == 250) {
      uint64_t v10 = 2LL;
    }
    else {
      uint64_t v10 = v10;
    }
    int v11 = v37 & 0x40;
    unint64_t v12 = ((unint64_t)v37 >> 6) & 1;
    uint64_t v13 = a3[1];
    uint64_t v14 = *a3 * a4;
    uint64_t v15 = (v10 | v12) * v14;
    *(void *)(a5 + _Block_object_dispose(va, 8) = v15;
    *(void *)(a5 + 16) = v13 * (unint64_t)v15;
    if ((_DWORD)v10)
    {
      uint64_t v16 = v14 * v10 * v13;
      *(void *)(a5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v14 * v10;
      *(void *)(a5 + 4_Block_object_dispose(va, 8) = v16;
      uint64_t v17 = a3[2] * v16;
      *(void *)(a5 + 56) = v12;
      *(void *)(a5 + 24) = v17;
      *(void *)(a5 + 32) = v17;
      uint64_t v18 = 1LL;
      *(void *)a5 = 1LL;
      if (!v11) {
        goto LABEL_17;
      }
      goto LABEL_12;
    }

    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    if (v11)
    {
LABEL_12:
      BOOL v27 = (_DWORD)v10 == 0;
      id v28 = (void *)(a5 + 32 * v18);
      uint64_t v29 = v13 * v14;
      uint64_t v30 = a3[2] * v13 * v14;
      v28[4] = v30;
      v28[5] = v14;
      unsigned int v31 = !v27;
      v28[6] = v29;
      v28[7] = 2LL * v31;
      *(void *)(a5 + 24) = v17 + v30;
      uint64_t v26 = v18 + 1;
      goto LABEL_16;
    }
  }

  else
  {
    if ((unint64_t)(a2 - 550) < 2)
    {
      uint64_t v19 = *a3;
      uint64_t v20 = a3[1];
      uint64_t v21 = 4 * *a3;
      *(void *)(a5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v21;
      *(void *)(a5 + 4_Block_object_dispose(va, 8) = v20 * v21;
      uint64_t v22 = a3[2];
      uint64_t v23 = v22 * v20 * v21;
      uint64_t v24 = v20 * v19;
      *(void *)(a5 + 72) = v19;
      *(void *)(a5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v24;
      uint64_t v25 = v22 * v24;
      *(void *)(a5 + 64) = v25;
      *(void *)(a5 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a5 + 16) = 0LL;
      *(void *)(a5 + 24) = v23 + v25;
      *(void *)(a5 + 32) = v23;
      uint64_t v26 = 2LL;
LABEL_16:
      *(void *)a5 = v26;
      goto LABEL_17;
    }

    GTMTLPixelFormatGetInfoForDevice(a2, (uint64_t)v39);
    if ((v40 & 0x400) != 0)
    {
      unint64_t v32 = (v42 + *a3 - 1) / v42 * v41;
      unint64_t v33 = (v43 + a3[1] - 1) / v43 * v32;
      unint64_t v34 = a3[2] * v33;
      *(void *)(a5 + 56) = ((unint64_t)v40 >> 11) & 4;
      unint64_t v35 = v33;
    }

    else
    {
      GTMTLGetTextureLevelInfoForDeviceWithOptions(a2, a4, (uint64_t)&v36);
      unint64_t v32 = v38;
      unint64_t v33 = a3[1] * v38;
      unint64_t v34 = a3[2] * v33;
      unint64_t v35 = a3[1] * v38;
    }

    *(void *)(a5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v32;
    *(void *)(a5 + 4_Block_object_dispose(va, 8) = v33;
    *(void *)(a5 + 24) = v34;
    *(void *)(a5 + 32) = v34;
    *(void *)(a5 + _Block_object_dispose(va, 8) = v32;
    *(void *)(a5 + 16) = v35;
    *(void *)a5 = 1LL;
  }

BOOL MTLTextureIsCube(void *a1)
{
  id v1 = a1;
  id v2 = (char *)[v1 textureType];
  id v3 = (char *)[v1 textureType];

  return v2 == (_BYTE *)&dword_4 + 1 || v3 == (_BYTE *)&dword_4 + 2;
}

int64x2_t MTLTextureMipmapSize@<Q0>(uint64x2_t *a1@<X0>, unint64_t a2@<X1>, int64x2_t *a3@<X8>)
{
  unint64_t v3 = (unint64_t)a1[1].i64[0] >> a2;
  if (v3 <= 1) {
    unint64_t v3 = 1LL;
  }
  int8x16_t v4 = (int8x16_t)vshlq_u64(*a1, (uint64x2_t)vnegq_s64(vdupq_n_s64(a2)));
  int8x16_t v5 = (int8x16_t)vcgtq_u64((uint64x2_t)v4, (uint64x2_t)vdupq_n_s64(1uLL));
  int64x2_t result = vsubq_s64((int64x2_t)vandq_s8(v4, v5), (int64x2_t)vmvnq_s8(v5));
  *a3 = result;
  a3[1].i64[0] = v3;
  return result;
}

id GetSparseTextureMappingKernelFunction(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  GTMTLPixelFormatGetInfoForDevice((uint64_t)[v4 pixelFormat], (uint64_t)v19);
  id v5 = [v4 textureType];

  int v6 = v20;
  if ((unint64_t)v5 > 7)
  {
    id v8 = 0LL;
  }

  else
  {
    if ((v20 & 0x20) != 0) {
      uint64_t v7 = @"depth";
    }
    else {
      uint64_t v7 = @"texture";
    }
    id v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  *((void *)&off_20DF70 + (void)v5),  v7));
    int v6 = v20;
  }

  id v9 = @"uint";
  if ((v6 & 0x280000) == 0) {
    id v9 = 0LL;
  }
  uint64_t v10 = @"int";
  if ((v6 & 0x140000) == 0) {
    uint64_t v10 = v9;
  }
  BOOL v11 = (v6 & 0x30000) == 0;
  unint64_t v12 = @"float";
  if (v11) {
    unint64_t v12 = (__CFString *)v10;
  }
  uint64_t v18 = 0LL;
  uint64_t v13 = v12;
  id v14 = objc_msgSend( v3,  "newLibraryWithSource:options:error:",  @"#include <metal_stdlib>\nusing namespace metal;\n\nstruct inputData\n{\n    uint3 textureSize;\n    uint3 tileSize;\n    uint3 textureSizeInTiles;\n\n    uint slice;\n    uint face;\n    uint mipmap;\n    uint maxTileNumber;\n};\ntemplate<typename T> uint3 createSampleCoord(T value) { return uint3(value.x,value.y,value.z); }\ntemplate<> uint3 createSampleCoord(uint value){ return uint3(value,0,0); }\ntemplate<> uint3 createSampleCoord(uint2 value) { return uint3(value.x,value.y,0); }\n\n#define KERNEL_COPY_MAPPING_STATE_READ(TEXTURE_TYPE, RETURN_TYPE, TEXTURE_DIM, GID_TYPE, ...) \\\nkernel void kernel_copy_mapping_state_read_##TEXTURE_TYPE##_##RETURN_TYPE(TEXTURE_TYPE<RETURN_TYPE, access::read> sparse [[texture(0)]],\\\n                                                                           device uint8_t* outputBuffer [[buffer(0)]],\\\n                                                                           constant inputData *metadata [[buffer(1)]],\\\n                                                                           GID_TYPE gid [[thread_position_in_grid]])\\\n{\\\n   uint3 tid = createSampleCoord(gid);\\\n   uint3 sampleLoc = tid * metadata->tileSize;\\\n   uint outputBufferLoc = tid.x + tid.y*(metadata->textureSizeInTiles.x) + tid.z*(metadata->textureSizeInTiles.x * metadata->textureSizeInTiles.y);\\\n   if (outputBufferLoc < metadata->maxTileNumber)\\\n   {\\\n       if (sparse.sparse_read(sampleLoc.TEXTURE_DIM,##__VA_ARGS__).resident())\\\n       {\\\n           outputBuffer[outputBufferLoc] = 1;\\\n       }\\\n   }\\\n}\\\n\n#define KERNEL_COPY_MAPPING(RETURN_TYPE) \\\nKERNEL_COPY_MAPPING_STATE_READ(texture2d,         RETURN_TYPE, xy, uint2, metadata->mipmap); \\\nKERNEL_COPY_MAPPING_STATE_READ(texture2d_array,   RETURN_TYPE, xy, uint2,metadata->slice,metadata->mipmap); \\\nKERNEL_COPY_MAPPING_STATE_READ(texture3d,         RETURN_TYPE, xyz, uint3,metadata->mipmap); \\\nKERNEL_COPY_MAPPING_STATE_READ(texturecube,       RETURN_TYPE, xy, uint2,metadata->face,metadata->mipmap); \\\nKERNEL_COPY_MAPPING_STATE_READ(texturecube_array, RETURN_TYPE, xy, uint2,metadata->face,metadata->slice,metadata->mipmap); \\\nKERNEL_COPY_MAPPING_STATE_READ(texture2d_ms,      RETURN_TYPE, xy, uint2,metadata->mipmap); \\\n\n#define KERNEL_COPY_MAPPING_DEPTH()\\\nKERNEL_COPY_MAPPING_STATE_READ(depth2d,         float, xy, uint2,metadata->mipmap); \\\nKERNEL_COPY_MAPPING_STATE_READ(depthcube,       float, xy, uint2,metadata->face,metadata->mipmap); \\\nKERNEL_COPY_MAPPING_STATE_READ(depthcube_array, float, xy, uint2,metadata->face,metadata->slice,metadata->mipmap); \\\nKERNEL_COPY_MAPPING_STATE_READ(depth2d_ms,      float, xy, uint2,metadata->mipmap); \\\nKERNEL_COPY_MAPPING_STATE_READ(depth2d_array,        float, xy, uint2,metadata->slice,metadata->mipmap); \\\n\n//Generate functions for all of the Metal texture data types.\nKERNEL_COPY_MAPPING(half)\nKERNEL_COPY_MAPPING(float)\nKERNEL_COPY_MAPPING(short)\nKERNEL_COPY_MAPPING(ushort)\nKERNEL_COPY_MAPPING(int)\nKERNEL_COPY_MAPPING(uint)\nKERNEL_COPY_MAPPING_DEPTH()\n",
          0LL,
          &v18);
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"kernel_copy_mapping_state_read_%@_%@",  v8,  v13,  v18));

  id v16 = [v14 newFunctionWithName:v15];
  return v16;
}

id GetSparseTextureMappingBuffer(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = 0LL;
  if ([v3 arrayLength])
  {
    unint64_t v6 = 0LL;
    do
    {
      if ([v3 mipmapLevelCount])
      {
        unint64_t v7 = 0LL;
        do
        {
          unint64_t v8 = (unint64_t)[v3 width];
          if (v8 >> v7 <= 1) {
            LODWORD(v9) = 1;
          }
          else {
            unint64_t v9 = v8 >> v7;
          }
          unint64_t v10 = (unint64_t)[v3 height];
          if (v10 >> v7 <= 1) {
            LODWORD(v11) = 1;
          }
          else {
            unint64_t v11 = v10 >> v7;
          }
          unint64_t v12 = (unint64_t)[v3 depth];
          if (v12 >> v7 <= 1) {
            LODWORD(v13) = 1;
          }
          else {
            unint64_t v13 = v12 >> v7;
          }
          id v14 = [v3 textureType];
          id v15 = [v3 pixelFormat];
          id v16 = [v3 sampleCount];
          if (v4)
          {
            [v4 sparseTileSizeWithTextureType:v14 pixelFormat:v15 sampleCount:v16];
            unsigned int v18 = v22;
            unsigned int v17 = v23;
            unsigned int v19 = v24;
          }

          else
          {
            unsigned int v19 = 0;
            unsigned int v17 = 0;
            unsigned int v18 = 0;
          }

          v5 += vcvtpd_u64_f64((double)v11 / (double)v17)
          ++v7;
        }

        while (v7 < (unint64_t)[v3 mipmapLevelCount]);
      }

      ++v6;
    }

    while (v6 < (unint64_t)[v3 arrayLength]);
  }

  id v20 = [v4 newBufferWithLength:v5 options:0];

  return v20;
}

uint64_t mach_exc_server_routine(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  else {
    return 0LL;
  }
}

uint64_t _Xmach_exception_raise(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(_DWORD *)a1 & 0x80000000) != 0)
  {
    int v7 = *(_DWORD *)(a1 + 24);
    uint64_t result = 4294966992LL;
    if (v7 == 2)
    {
      unsigned int v8 = *(_DWORD *)(a1 + 4);
      if (v8 >= 0x44 && v8 <= 0x54)
      {
        if (*(unsigned __int16 *)(a1 + 38) << 16 == 1114112 && *(unsigned __int16 *)(a1 + 50) << 16 == 1114112)
        {
          unsigned int v9 = *(_DWORD *)(a1 + 64);
          if (v9 <= 2 && v9 <= (v8 - 68) >> 3 && v8 == 8 * v9 + 68) {
            uint64_t result = catch_mach_exception_raise(4294966992LL, a2, a3, a4, a1 + 68);
          }
        }

        else
        {
          uint64_t result = 4294966996LL;
        }
      }
    }
  }

  else
  {
    uint64_t result = 4294966992LL;
  }

  *(_DWORD *)(a2 + 32) = result;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *_Xmach_exception_raise_state(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0) {
    goto LABEL_17;
  }
  unsigned int v2 = result[1];
  BOOL v3 = v2 < 0x30 || v2 > 0x1480;
  if (v3) {
    goto LABEL_17;
  }
  unsigned int v4 = result[9];
  if (v4 > 2) {
    goto LABEL_17;
  }
  unsigned int v5 = 2 * v4;
  BOOL v6 = v4 <= (v2 - 48) >> 3 && v2 >= 8 * v4 + 48;
  if (v6
    && (unsigned int v7 = result[v5 + 11], v7 <= 0x510)
    && ((v8 = v2 - v5 * 4, BOOL v3 = v7 > (v8 - 48) >> 2, v9 = 4 * v7 + 48, !v3) ? (v10 = v8 == v9) : (v10 = 0), v10))
  {
    *(_DWORD *)(a2 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 1296;
    int v11 = 46;
  }

  else
  {
LABEL_17:
    int v11 = -304;
  }

  *(_DWORD *)(a2 + 32) = v11;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t _Xmach_exception_raise_state_identity(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0)
  {
LABEL_2:
    int v2 = -304;
    goto LABEL_3;
  }

  int v2 = -304;
  if (*(_DWORD *)(result + 24) == 2)
  {
    unsigned int v3 = *(_DWORD *)(result + 4);
    if (v3 >= 0x4C && v3 <= 0x149C)
    {
      if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
      {
        int v2 = -300;
        goto LABEL_3;
      }

      unsigned int v5 = *(_DWORD *)(result + 64);
      if (v5 > 2) {
        goto LABEL_2;
      }
      int v2 = -304;
      if (v5 <= (v3 - 76) >> 3)
      {
        unsigned int v6 = 8 * v5;
        if (v3 >= 8 * v5 + 76)
        {
          unsigned int v7 = *(_DWORD *)(result + v6 + 72);
          if (v7 <= 0x510)
          {
            unsigned int v8 = v3 - v6;
            if (v7 <= (v8 - 76) >> 2 && v8 == 4 * v7 + 76)
            {
              *(_DWORD *)(a2 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 1296;
              int v2 = 46;
              goto LABEL_3;
            }
          }

          goto LABEL_2;
        }
      }
    }
  }

LABEL_3:
  *(_DWORD *)(a2 + 32) = v2;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t mach_exc_server(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v3;
  int v4 = a1[5];
  if ((v4 - 2410) >= 0xFFFFFFFB
    && (unsigned int v5 = (void (*)(void))*(&catch_mach_exc_subsystem + 5 * (v4 - 2405) + 5)) != 0LL)
  {
    v5();
    return 1LL;
  }

  else
  {
    uint64_t result = 0LL;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }

  return result;
}

double GTResourceTrackerBuildArgumentBuffers( uint64_t a1, uint64_t a2, uint64_t a3, _DWORD **a4, unint64_t a5, apr_pool_t *a6)
{
  uint64_t v57 = a1;
  uint64_t v58 = a2;
  pool = 0LL;
  *(void *)&__int128 v60 = apr_array_make(a6, 128, 40);
  *((void *)&v60 + 1) = apr_array_make(a6, 32, 16);
  id v61 = apr_array_make(a6, 32, 8);
  unint64_t v12 = p;
  GTMTLSMContext_indirectCommandBufferResources(p, a4, a5, (uint64_t)&v62);
  apr_pool_create_ex(&pool, v12, 0LL, 0LL);
  v64[0] = a3;
  uint64_t v13 = *(void *)(*(void *)(*find_entry(a1, v64, 8uLL, 0LL) + 32LL) + 32LL);
  uint64_t v54 = a6;
  unsigned int v14 = 0;
  if (v13)
  {
    while (1)
    {
      unsigned int v15 = atomic_load((unsigned int *)(v13 + 4));
      uint64_t v16 = v14 + (v15 >> 6) - 1;
      uint64_t v13 = *(void *)(v13 + 40);
      unsigned int v14 = v16;
      if (!v13)
      {
        unsigned int v14 = v16;
        goto LABEL_6;
      }
    }
  }

  uint64_t v16 = 0LL;
LABEL_6:
  uint64_t v17 = a2;
  unint64_t v18 = v14 | (unint64_t)(v16 << 32);
LABEL_7:
  uint64_t v19 = v13 + 64;
  while (v13 && (*(_BYTE *)(v19 + ((uint64_t)(HIDWORD(v18) - (int)v18) << 6) + 15) & 8) != 0)
  {
    uint64_t v20 = v19 + ((uint64_t)(HIDWORD(v18) - (int)v18) << 6);
    int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v20 + 8));
    if (IsCommandEncoder(FuncEnumConstructorType))
    {
      bzero(&v55, 0x2B90uLL);
      GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v55, (uint64_t *)v20, v17);
      if (v55 <= 64)
      {
        if (v55 != 21 && v55 != 28) {
          goto LABEL_34;
        }
LABEL_17:
        uint64_t v22 = v56;
        uint64_t v23 = v60;
        unsigned int v24 = v61;
        uint64_t v25 = *(int *)(v60 + 12);
        uint64_t v26 = apr_hash_make(v61->pool);
        *(void *)apr_array_push(v24) = v26;
        commandEncoder_processStream_((uint64_t)&v57, v22, 0LL);
        BOOL v27 = pool;
        uint64_t v28 = FilterArgumentBufferAccess(v23, v25, *(int *)(v23 + 12) - v25, pool);
        apr_pool_clear(v27);
        *(_DWORD *)(v23 + 12) = v25 + v28;
        uint64_t v29 = apr_array_push(*((apr_array_header_t **)&v60 + 1));
        *uint64_t v29 = v25;
LABEL_33:
        v29[1] = v28;
        goto LABEL_34;
      }

      if (v55 == 65)
      {
        uint64_t v30 = v56;
        uint64_t v31 = v57;
        uint64_t v32 = *(int *)(v60 + 12);
        unint64_t v33 = v61;
        unint64_t v34 = apr_hash_make(v61->pool);
        *(void *)apr_array_push(v33) = v34;
        v64[0] = v30;
        uint64_t v35 = *(void *)(*(void *)(*find_entry(v31, v64, 8uLL, 0LL) + 32LL) + 32LL);
        unsigned int v36 = 0;
        if (v35)
        {
          while (1)
          {
            unsigned int v37 = atomic_load((unsigned int *)(v35 + 4));
            uint64_t v38 = v36 + (v37 >> 6) - 1;
            uint64_t v35 = *(void *)(v35 + 40);
            unsigned int v36 = v38;
            if (!v35)
            {
              unsigned int v36 = v38;
              goto LABEL_24;
            }
          }

          uint64_t v38 = 1LL;
        }

        else
        {
          uint64_t v38 = 0LL;
        }

uint64_t commandEncoder_processStream_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v66 = a2;
  bzero(__src, 0x2B90uLL);
  uint64_t v4 = *(void *)(*(void *)(*find_entry(*(void *)a1, &v66, 8uLL, 0LL) + 32LL) + 32LL);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_8;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_8:
  uint64_t v8 = 0LL;
  unint64_t v9 = v5 | (unint64_t)(v7 << 32);
  uint64_t v63 = a1 + 48;
LABEL_9:
  uint64_t v10 = v4 + 64;
  while (v4)
  {
    int v11 = HIDWORD(v9) - v9;
    uint64_t v12 = v11;
    uint64_t v13 = v10 + ((uint64_t)v11 << 6);
    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)__src, (uint64_t *)v13, *(void *)(a1 + 8));
    uint64_t v14 = v8 + a3;
    int v15 = *(_DWORD *)(v13 + 8);
    if (v15 == -16377)
    {
      uint64_t v16 = GTTraceFunc_argumentBytesWithMap((void *)v13, *(unsigned __int8 *)(v13 + 13), *(void *)(a1 + 8));
      uint64_t v17 = *(void *)(a1 + 40);
      uint64_t v18 = *((void *)v16 + 3);
      *(void *)&v71[0] = *((void *)v16 + 1);
      *((void *)&v71[0] + 1) = v18;
      uint64_t v19 = *(apr_hash_t **)(*(void *)(v17 + 24) + 8LL * *(int *)(v17 + 12) - 8);
      uint64_t v20 = v71;
      uint64_t v21 = &xmmword_1CA4A0;
LABEL_14:
      MTLHarvesterMarkMutableAncestors(v19, (uint64_t)v20, v21, v14);
      LODWORD(v22) = 1;
      goto LABEL_33;
    }

    if (IsFuncEnumDrawCall(*(_DWORD *)(v13 + 8)))
    {
      unsigned int v23 = Draw(a1, __src, v14);
LABEL_32:
      LODWORD(v22) = v23;
      goto LABEL_33;
    }

    if (v15 <= -16080)
    {
      if (v15 == -16327 || v15 == -16220)
      {
LABEL_31:
        unsigned int v23 = Dispatch(a1, (uint64_t)__src, v14);
        goto LABEL_32;
      }

      if (v15 == -16137)
      {
LABEL_24:
        uint64_t v25 = *(void *)a1;
        *(void *)&v71[0] = __src[1075];
        entry = find_entry(v25, v71, 8uLL, 0LL);
        if (*entry) {
          uint64_t v27 = *(void *)(*entry + 32LL);
        }
        else {
          uint64_t v27 = 0LL;
        }
        GTMTLSMRenderPipelineState_resourceAccess(v27, *(void *)(a1 + 8), v67);
        GTMTLRenderPipelineState_rootPipeline((uint64_t)v71, v27, v25, *(void *)(a1 + 8));
        unsigned int v37 = *(apr_hash_t **)(*(void *)(*(void *)(a1 + 40) + 24LL) + 8LL * *(int *)(*(void *)(a1 + 40) + 12LL) - 8);
        ArgumentBufferAccess( *(apr_array_header_t **)(a1 + 24),  (uint64_t)&__src[869],  (uint64_t)&__src[900],  (uint64_t)&__src[868],  &v70,  *(char **)(*(void *)&v71[4] + 120LL),  v14);
        int8x16_t v69 = vandq_s8(v69, (int8x16_t)vdupq_n_s64(~__src[868]));
        uint64_t v19 = v37;
        uint64_t v20 = &__src[869];
        uint64_t v21 = (__int128 *)&v69;
        goto LABEL_14;
      }
    }

    else
    {
      if (v15 == -15297 || v15 == -15486) {
        goto LABEL_24;
      }
    }

    int v32 = v15 + 15964;
    uint64_t v33 = *(void *)a1;
    switch(v32)
    {
      case 0:
      case 2:
        unint64_t v34 = GTTraceFunc_argumentBytesWithMap( (void *)v13,  *(unsigned __int8 *)(v10 + (v12 << 6) + 13),  *(void *)(a1 + 8));
        *(void *)&v71[0] = *((void *)v34 + 1);
        uint64_t v35 = *find_entry(v33, v71, 8uLL, 0LL);
        if (v35) {
          uint64_t v36 = *(void *)(v35 + 32);
        }
        else {
          uint64_t v36 = 0LL;
        }
        uint64_t v41 = GTTraceMemoryMap_argumentBlobAtIndex(v34[40], *(void *)(a1 + 8), *((void *)v34 + 4));
        uint64_t v42 = v41 + 16;
        if (!v41) {
          uint64_t v42 = 0LL;
        }
        uint64_t v62 = v42;
        int v43 = v34 + 16;
        unsigned int v44 = (uint64_t *)(v34 + 24);
        goto LABEL_53;
      case 1:
      case 3:
        uint64_t v38 = GTTraceFunc_argumentBytesWithMap( (void *)v13,  *(unsigned __int8 *)(v10 + (v12 << 6) + 13),  *(void *)(a1 + 8));
        *(void *)&v71[0] = *((void *)v38 + 1);
        uint64_t v39 = *find_entry(v33, v71, 8uLL, 0LL);
        if (v39) {
          uint64_t v36 = *(void *)(v39 + 32);
        }
        else {
          uint64_t v36 = 0LL;
        }
        uint64_t v45 = GTTraceMemoryMap_argumentBlobAtIndex(v38[40], *(void *)(a1 + 8), *((void *)v38 + 4));
        uint64_t v46 = v45 + 16;
        if (!v45) {
          uint64_t v46 = 0LL;
        }
        uint64_t v62 = v46;
        int v43 = GTTraceFunc_argumentBytesWithMap((void *)v13, v38[41], *(void *)(a1 + 8));
        unsigned int v44 = (uint64_t *)(v43 + 8);
LABEL_53:
        uint64_t v40 = *(void *)v43;
        uint64_t v22 = *v44;
        break;
      default:
        uint64_t v36 = 0LL;
        uint64_t v62 = 0LL;
        uint64_t v22 = 0LL;
        uint64_t v40 = 0LL;
        break;
    }

    memset(v71, 0, 24);
    memset(&v71[5], 0, 64);
    memset(&v71[2], 0, 32);
    LODWORD(v71[0]) = 57;
    *((void *)&v71[1] + 1) = -1LL;
    WORD1(v71[6]) = 2;
    void v71[4] = 0xFFFFFFFFFFFFFFFFLL;
    if (v36 && (uint64_t v47 = *(void *)(v36 + 32)) != 0 && (*(_BYTE *)(v47 + 79) & 8) != 0) {
      id v48 = (uint64_t *)(v47 + 64);
    }
    else {
      id v48 = 0LL;
    }
    GTMTLSMIndirectCommandBuffer_processTraceFuncWithMap((char *)v71, *(void *)(a1 + 8), v48);
    GTMTLCreateIndirectCommandEncoder((uint64_t)v67, *((uint64_t *)&v71[6] + 1));
    if (LODWORD(__src[0]) == 70)
    {
      memcpy(v71, __src, sizeof(v71));
      if (!*(_BYTE *)(v67[0] + 10LL))
      {
        unsigned int v53 = *(unsigned __int8 *)(v67[0] + 18LL);
        if (v53 >= 0x40) {
          LOBYTE(v53) = 64;
        }
        *(void *)&v71[4] &= -1LL << v53;
        unsigned int v54 = *(unsigned __int8 *)(v67[0] + 12LL);
        if (v54 >= 0x40) {
          LOBYTE(v54) = 64;
        }
        *((void *)&v71[123] + 1) &= -1LL << v54;
        unsigned int v55 = *(unsigned __int8 *)(v67[0] + 16LL);
        if (v55 >= 0x40) {
          LOBYTE(v55) = 64;
        }
        *(void *)&v71[227] &= -1LL << v55;
        unsigned int v56 = *(unsigned __int8 *)(v67[0] + 15LL);
        if (v56 >= 0x40) {
          LOBYTE(v56) = 64;
        }
        *((void *)&v71[330] + 1) &= -1LL << v56;
      }

      if (v22)
      {
        uint64_t v57 = v40;
        uint64_t v58 = v68;
        uint64_t v59 = v62 + v57 * v68;
        uint64_t v60 = v22;
        do
        {
          ++v14;
          v59 += v58;
          --v60;
        }

        while (v60);
      }

      goto LABEL_33;
    }

    if (LODWORD(__src[0]) == 28)
    {
      memcpy(v71, __src, sizeof(v71));
      if (!*(_BYTE *)(v67[0] + 10LL))
      {
        unsigned int v49 = *(unsigned __int8 *)(v67[0] + 13LL);
        if (v49 >= 0x40) {
          LOBYTE(v49) = 64;
        }
        *((void *)&v71[4] + 1) &= -1LL << v49;
      }

      if (v22)
      {
        uint64_t v50 = v68;
        uint64_t v51 = v62 + v40 * v68;
        uint64_t v52 = v22;
        do
        {
          ++v14;
          v51 += v50;
          --v52;
        }

        while (v52);
      }
    }

    else
    {
LABEL_70:
      LODWORD(v22) = 0;
    }

LABEL_33:
    v8 += (int)v22;
    unsigned int v29 = atomic_load((unsigned int *)(v4 + 4));
    int v30 = v9 + (v29 >> 6);
    uint64_t v31 = (HIDWORD(v9) + 1);
    unint64_t v9 = (v31 << 32) | v9;
    uint64_t v10 = v4 + 64;
    if ((_DWORD)v31 == v30 - 1)
    {
      unint64_t v9 = (v31 << 32) | v31;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_9;
    }
  }

  return v8;
}

      uint64_t v19 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v20 = *(void *)a3;
      uint64_t v21 = *(void *)v19;
      *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v19 + 1);
      *(void *)(v5 + 16) = v20;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v21;
      uint64_t v22 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *(void *)(v5 + 64) = v22;
      if (v22)
      {
        *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v22 + 1);
        *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v22[16];
      }

      double result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v19[24], a2);
      *(void *)(v5 + 72) = result;
      *(void *)(v5 + 8_Block_object_dispose(va, 8) = *(void *)(result + 8);
      *(_DWORD *)(v5 + 156) = *(unsigned __int16 *)(result + 18);
LABEL_36:
      *(_BYTE *)(v5 + 161) = 6;
      return result;
    }

    switch(v6)
    {
      case -15419:
        goto LABEL_33;
      case -10188:
        unsigned int v56 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        double result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v56[8], a2);
        *(void *)(v5 + 12_Block_object_dispose(va, 8) = result;
        break;
      case -10183:
        double result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 8);
        break;
    }
  }

  return result;
}

  uint64_t v36 = *(void *)a1;
  unsigned int v37 = *(void *)(a1 + 8);
  *(void *)(v37 + 16) = 0LL;
  *(void *)(v37 + 24) = 0LL;
  *(void *)(v37 + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(v37 + 32) = 70;
  *(_DWORD *)(v37 + 36) = 67;
  *(void *)unsigned int v37 = 0xFFFFD00800000028LL;
  *(void *)(v37 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v36;
  *(_DWORD *)unsigned int v37 = 48;
  uint64_t v38 = *(unsigned int **)(a1 + 8);
  uint64_t v39 = *v38;
  if ((*((_BYTE *)v38 + 33) & 0x10) != 0)
  {
    uint64_t v41 = *(unsigned int **)(a1 + 8);
    uint64_t v40 = *v38;
    do
    {
      uint64_t v41 = (unsigned int *)((char *)v41 + v39);
      uint64_t v39 = *v41;
      v40 += v39;
    }

    while ((*((_BYTE *)v41 + 33) & 0x20) == 0);
  }

  else
  {
    uint64_t v40 = *v38;
  }

  fbstream_write(*(void *)(a1 + 24), (uint64_t)v38, v40);
  if (v10)
  {
    int v43 = *(unsigned int **)(a1 + 8);
    __int128 v75 = *(void *)a1;
    uint64_t v76 = "acceleration-structures";
    uint64_t v77 = 0LL;
    uint64_t v78 = 0LL;
    DYTraceEncode_EnterStateGroup((uint64_t)&v75, v43, *(unsigned int *)(a1 + 16), v42, 0LL);
    unsigned int v44 = *(unsigned int **)(a1 + 8);
    uint64_t v45 = *v44;
    if ((*((_BYTE *)v44 + 33) & 0x10) != 0)
    {
      uint64_t v47 = *(unsigned int **)(a1 + 8);
      uint64_t v46 = *v44;
      do
      {
        uint64_t v47 = (unsigned int *)((char *)v47 + v45);
        uint64_t v45 = *v47;
        v46 += v45;
      }

      while ((*((_BYTE *)v47 + 33) & 0x20) == 0);
    }

    else
    {
      uint64_t v46 = *v44;
    }

    fbstream_write(*(void *)(a1 + 24), (uint64_t)v44, v46);
    id v48 = *(_DWORD *)(v10 + 12);
    if (v48 >= 1)
    {
      for (uint64_t i = 0LL; i < v48; ++i)
      {
        uint64_t v50 = *(void *)(*(void *)(v10 + 24) + 8 * i);
        if (*(_DWORD *)v50 == 16)
        {
          __int128 v75 = *(void *)(v50 + 8);
          uint64_t v51 = find_entry(v7, &v75, 8uLL, 0LL);
          if (*v51) {
            uint64_t v52 = *(void *)(*v51 + 32LL);
          }
          else {
            uint64_t v52 = 0LL;
          }
          __int128 v75 = *(void *)(v50 + 8);
          unsigned int v53 = *(void *)(*(void *)(*find_entry(v7, &v75, 8uLL, 0LL) + 32LL) + 8LL);
          unsigned int v54 = *(unsigned int **)(a1 + 8);
          __int128 v75 = *(void *)a1;
          uint64_t v76 = "acceleration-structure";
          uint64_t v77 = v53;
          uint64_t v78 = 0LL;
          DYTraceEncode_EnterStateGroup((uint64_t)&v75, v54, *(unsigned int *)(a1 + 16), v55, 0LL);
          unsigned int v56 = *(unsigned int **)(a1 + 8);
          uint64_t v57 = *v56;
          if ((*((_BYTE *)v56 + 33) & 0x10) != 0)
          {
            uint64_t v59 = *(unsigned int **)(a1 + 8);
            uint64_t v58 = *v56;
            do
            {
              uint64_t v59 = (unsigned int *)((char *)v59 + v57);
              uint64_t v57 = *v59;
              v58 += v57;
            }

            while ((*((_BYTE *)v59 + 33) & 0x20) == 0);
          }

          else
          {
            uint64_t v58 = *v56;
          }

          fbstream_write(*(void *)(a1 + 24), (uint64_t)v56, v58);
          if (v52 && (uint64_t v60 = *(void *)(v52 + 32)) != 0 && (*(_BYTE *)(v60 + 79) & 8) != 0) {
            id v61 = v60 + 64;
          }
          else {
            id v61 = 0LL;
          }
          GTTraceFuncToFbuf(a1, a2, v61, 0LL);
          WriteGTMTLSMAccelerationStructure_properties(a1, v50, v52, v7, v62);
          uint64_t v63 = *(void *)a1;
          uint64_t v64 = *(void *)(a1 + 8);
          *(void *)(v64 + 16) = 0LL;
          *(void *)(v64 + 24) = 0LL;
          *(void *)(v64 + _Block_object_dispose(va, 8) = 0LL;
          *(_DWORD *)(v64 + 32) = 70;
          *(_DWORD *)(v64 + 36) = 67;
          *(void *)uint64_t v64 = 0xFFFFD00800000028LL;
          *(void *)(v64 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v63;
          *(_DWORD *)uint64_t v64 = 48;
          uint64_t v65 = *(unsigned int **)(a1 + 8);
          uint64_t v66 = *v65;
          if ((*((_BYTE *)v65 + 33) & 0x10) != 0)
          {
            uint64_t v68 = *(unsigned int **)(a1 + 8);
            uint64_t v67 = *v65;
            do
            {
              uint64_t v68 = (unsigned int *)((char *)v68 + v66);
              uint64_t v66 = *v68;
              v67 += v66;
            }

            while ((*((_BYTE *)v68 + 33) & 0x20) == 0);
          }

          else
          {
            uint64_t v67 = *v65;
          }

          fbstream_write(*(void *)(a1 + 24), (uint64_t)v65, v67);
          id v48 = *(_DWORD *)(v10 + 12);
        }
      }
    }

    int8x16_t v69 = *(void *)a1;
    uint64_t v70 = *(void *)(a1 + 8);
    *(void *)(v70 + 16) = 0LL;
    *(void *)(v70 + 24) = 0LL;
    *(void *)(v70 + _Block_object_dispose(va, 8) = 0LL;
    *(_DWORD *)(v70 + 32) = 70;
    *(_DWORD *)(v70 + 36) = 67;
    *(void *)uint64_t v70 = 0xFFFFD00800000028LL;
    *(void *)(v70 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v69;
    *(_DWORD *)uint64_t v70 = 48;
    id v71 = *(unsigned int **)(a1 + 8);
    __int128 v72 = *v71;
    if ((*((_BYTE *)v71 + 33) & 0x10) != 0)
    {
      id v74 = *(unsigned int **)(a1 + 8);
      __int128 v73 = *v71;
      do
      {
        id v74 = (unsigned int *)((char *)v74 + v72);
        __int128 v72 = *v74;
        v73 += v72;
      }

      while ((*((_BYTE *)v74 + 33) & 0x20) == 0);
    }

    else
    {
      __int128 v73 = *v71;
    }

    fbstream_write(*(void *)(a1 + 24), (uint64_t)v71, v73);
  }

uint64_t FilterArgumentBufferAccess(uint64_t a1, uint64_t a2, uint64_t a3, apr_pool_t *pool)
{
  uint64_t v8 = apr_hash_make(pool);
  if ((int)a3 >= 1)
  {
    unint64_t v9 = v8;
    uint64_t v10 = (int)a2 + (int)a3;
    uint64_t v11 = 40 * v10;
    do
    {
      uint64_t v12 = *(void *)(a1 + 24);
      uint64_t v13 = v12 + v11 - 40;
      __int128 v22 = *(_OWORD *)v13;
      *(void *)&v23[0] = 0LL;
      *(_OWORD *)((char *)v23 + _Block_object_dispose(va, 8) = *(_OWORD *)(v12 + v11 - 16);
      uint64_t v14 = *find_entry((uint64_t)v9, &v22, 0x28uLL, 0LL);
      if (v14 && *(void *)(v14 + 32))
      {
        uint64_t v15 = *(void *)(a1 + 24) + 40 * (--a3 + a2);
        __int128 v16 = *(_OWORD *)v15;
        __int128 v17 = *(_OWORD *)(v15 + 16);
        *(void *)(v13 + 32) = *(void *)(v15 + 32);
        *(_OWORD *)uint64_t v13 = v16;
        *(_OWORD *)(v13 + 16) = v17;
      }

      else
      {
        uint64_t v18 = apr_palloc(pool, 0x28uLL);
        uint64_t v19 = *(void *)&v23[1];
        __int128 v20 = v23[0];
        *uint64_t v18 = v22;
        v18[1] = v20;
        *((void *)v18 + 4) = v19;
        apr_hash_set(v9, v18, 40LL, v18);
      }

      --v10;
      v11 -= 40LL;
    }

    while (v10 > (int)a2);
  }

  return a3;
}

void MTLHarvesterMarkMutableAncestors(apr_hash_t *a1, uint64_t a2, void *a3, uint64_t a4)
{
  int v8 = 0;
  unint64_t v9 = 0LL;
  uint64_t v10 = *(apr_pool_t **)a1;
  do
  {
    unint64_t v11 = a3[1] >> v8;
    if (!v11) {
      break;
    }
    int v12 = v8 + __clz(__rbit64(v11));
    uint64_t v22 = *(void *)(a2 + 8LL * v12);
    uint64_t v13 = *find_entry((uint64_t)a1, &v22, 8uLL, 0LL);
    if (v13)
    {
      uint64_t v14 = *(apr_hash_t **)(v13 + 32);
      if (v14) {
        continue;
      }
    }

    uint64_t v14 = apr_hash_make(v10);
    uint64_t v15 = apr_palloc(v10, 8uLL);
    *uint64_t v15 = v22;
    apr_hash_set(a1, v15, 8LL, v14);
    int v16 = 0;
    do
    {
      unint64_t v17 = *a3 >> v16;
      if (!v17) {
        break;
      }
      int v18 = v16 + __clz(__rbit64(v17));
      uint64_t v21 = *(void *)(a2 + 8LL * v18);
      uint64_t v19 = *find_entry((uint64_t)v14, &v21, 8uLL, 0LL);
      if (!v19 || !*(void *)(v19 + 32))
      {
        if (!v9)
        {
          unint64_t v9 = apr_palloc(v10, 8uLL);
          *unint64_t v9 = a4;
        }

        __int128 v20 = apr_palloc(v10, 8uLL);
        *__int128 v20 = v21;
        apr_hash_set(v14, v20, 8LL, v9);
      }

      int v16 = v18 + 1;
    }

    while (v18 < 63);
    int v8 = v12 + 1;
  }

  while (v12 < 63);
}

uint64_t Draw(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)a1;
  v26[0] = a2[1075];
  entry = find_entry(v6, v26, 8uLL, 0LL);
  if (*entry) {
    uint64_t v8 = *(void *)(*entry + 32LL);
  }
  else {
    uint64_t v8 = 0LL;
  }
  GTMTLSMRenderPipelineState_resourceAccess(v8, *(void *)(a1 + 8), v18);
  unint64_t v9 = *(apr_hash_t **)(*(void *)(*(void *)(a1 + 40) + 24LL) + 8LL * *(int *)(*(void *)(a1 + 40) + 12LL) - 8);
  int v10 = GTMTLRenderPipelineState_descriptorType(v8, v6, *(void *)(a1 + 8));
  if (v10 == 3)
  {
    GTMTLRenderPipelineState_rootPipeline((uint64_t)v26, v8, v6, *(void *)(a1 + 8));
    uint64_t v15 = v28;
    ArgumentBufferAccess( *(apr_array_header_t **)(a1 + 24),  (uint64_t)(a2 + 455),  (uint64_t)(a2 + 486),  (uint64_t)(a2 + 454),  &v23,  *(char **)(v28 + 368),  a3);
    v22[0] = vandq_s8(v22[0], (int8x16_t)vdupq_n_s64(~a2[454]));
    MTLHarvesterMarkMutableAncestors(v9, (uint64_t)(a2 + 455), v22, a3);
    ArgumentBufferAccess( *(apr_array_header_t **)(a1 + 24),  (uint64_t)(a2 + 662),  (uint64_t)(a2 + 693),  (uint64_t)(a2 + 661),  v25,  *(char **)(v15 + 360),  a3);
    v24[0] = vandq_s8(v24[0], (int8x16_t)vdupq_n_s64(~a2[661]));
    MTLHarvesterMarkMutableAncestors(v9, (uint64_t)(a2 + 662), v24, a3);
    int v16 = *(apr_array_header_t **)(a1 + 24);
    uint64_t v13 = (uint64_t)(a2 + 248);
    uint64_t v14 = v20;
    ArgumentBufferAccess( v16,  (uint64_t)(a2 + 248),  (uint64_t)(a2 + 279),  (uint64_t)(a2 + 247),  &v21,  *(char **)(v15 + 344),  a3);
    v20[0] = vandq_s8(v20[0], (int8x16_t)vdupq_n_s64(~a2[247]));
    goto LABEL_8;
  }

  if (v10 == 1)
  {
    GTMTLRenderPipelineState_rootPipeline((uint64_t)v26, v8, v6, *(void *)(a1 + 8));
    unint64_t v11 = v27;
    ArgumentBufferAccess( *(apr_array_header_t **)(a1 + 24),  (uint64_t)(a2 + 10),  (uint64_t)(a2 + 41),  (uint64_t)(a2 + 8),  &v19,  v27[162],  a3);
    v18[0] = vandq_s8(v18[0], (int8x16_t)vdupq_n_s64(~a2[8]));
    MTLHarvesterMarkMutableAncestors(v9, (uint64_t)(a2 + 10), v18, a3);
    ArgumentBufferAccess( *(apr_array_header_t **)(a1 + 24),  (uint64_t)(a2 + 248),  (uint64_t)(a2 + 279),  (uint64_t)(a2 + 247),  &v21,  v11[147],  a3);
    v20[0] = vandq_s8(v20[0], (int8x16_t)vdupq_n_s64(~a2[247]));
    MTLHarvesterMarkMutableAncestors(v9, (uint64_t)(a2 + 248), v20, a3);
    ArgumentBufferAccess( *(apr_array_header_t **)(a1 + 24),  (uint64_t)(a2 + 455),  (uint64_t)(a2 + 486),  (uint64_t)(a2 + 454),  &v23,  v11[155],  a3);
    v22[0] = vandq_s8(v22[0], (int8x16_t)vdupq_n_s64(~a2[454]));
    MTLHarvesterMarkMutableAncestors(v9, (uint64_t)(a2 + 455), v22, a3);
    int v12 = *(apr_array_header_t **)(a1 + 24);
    uint64_t v13 = (uint64_t)(a2 + 662);
    uint64_t v14 = v24;
    ArgumentBufferAccess(v12, (uint64_t)(a2 + 662), (uint64_t)(a2 + 693), (uint64_t)(a2 + 661), v25, v11[152], a3);
    v24[0] = vandq_s8(v24[0], (int8x16_t)vdupq_n_s64(~a2[661]));
LABEL_8:
    MTLHarvesterMarkMutableAncestors(v9, v13, v14, a3);
    return 1LL;
  }

  return 0LL;
}

apr_array_header_t *ArgumentBufferAccess( apr_array_header_t *arr, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, char *a6, uint64_t a7)
{
  uint64_t v13 = arr;
  int v14 = 0;
  do
  {
    unint64_t v15 = *a5 >> v14;
    if (!v15) {
      break;
    }
    int v16 = __clz(__rbit64(v15));
    int v18 = v14 + v16;
    char v17 = (v14 + v16 < 0) ^ __OFADD__(v14, v16);
    int v19 = v14 + v16 + 63;
    if (!v17) {
      int v19 = v18;
    }
    if (((*(void *)(a4 + 8LL * (v19 >> 6)) >> (v18 - (v19 & 0xC0u))) & 1) == 0)
    {
      arr = (apr_array_header_t *)apr_array_push(v13);
      arr->pool = *(apr_pool_t **)(a2 + 8LL * v18);
      *(void *)&arr->uint64_t elt_size = *(void *)(a3 + 8LL * v18);
      *(void *)&arr->nalloc = a7;
      arr->uint64_t elts = a6;
      arr[1].pool = (apr_pool_t *)v18;
    }

    int v14 = v18 + 1;
  }

  while (v18 < 63);
  return arr;
}

char *Dispatch(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)a1;
  v11[0].i64[0] = *(void *)(a2 + 64);
  entry = find_entry(v6, v11, 8uLL, 0LL);
  if (*entry) {
    uint64_t v8 = *(void *)(*entry + 32LL);
  }
  else {
    uint64_t v8 = 0LL;
  }
  GTMTLSMComputePipelineState_resourceAccess(v8, *(void *)(a1 + 8), (uint64_t)v11);
  double result = (char *)GTMTLComputePipelineState_computeFunction(v8, v6, *(void *)(a1 + 8));
  if (result)
  {
    int v10 = *(apr_hash_t **)(*(void *)(*(void *)(a1 + 40) + 24LL) + 8LL * *(int *)(*(void *)(a1 + 40) + 12LL) - 8);
    ArgumentBufferAccess(*(apr_array_header_t **)(a1 + 24), a2 + 88, a2 + 336, a2 + 72, &v12, result, a3);
    v11[0] = vandq_s8(v11[0], (int8x16_t)vdupq_n_s64(~*(void *)(a2 + 72)));
    MTLHarvesterMarkMutableAncestors(v10, a2 + 88, v11, a3);
    return (_BYTE *)(&dword_0 + 1);
  }

  return result;
}

void CreateCommandBufferEpilogue(void *a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __CreateCommandBufferEpilogue_block_invoke;
  block[3] = &unk_20E0C8;
  id v6 = a1;
  uint64_t v1 = CreateCommandBufferEpilogue_onceToken;
  id v2 = v6;
  id v4 = v2;
  if (v1 == -1)
  {
    id v3 = v2;
  }

  else
  {
    dispatch_once(&CreateCommandBufferEpilogue_onceToken, block);
    id v3 = v6;
  }
}

IMP __CreateCommandBufferEpilogue_block_invoke(uint64_t a1)
{
  IMP result = (IMP)objc_opt_respondsToSelector(*(void *)(a1 + 32), "encodeWaitForEvent:value:timeout:");
  if ((result & 1) != 0)
  {
    id v4 = (objc_class *)objc_opt_class(*(void *)(a1 + 32), v3);
    InstanceMethod = class_getInstanceMethod(v4, "encodeWaitForEvent:value:");
    return method_setImplementation(InstanceMethod, (IMP)MTLCommandBuffer_encodeWaitForEventWithValue);
  }

  return result;
}

id MTLCommandBuffer_encodeWaitForEventWithValue(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return [a1 encodeWaitForEvent:a3 value:a4 timeout:(GT_ENV + 5)];
}

void CommandQueueTakeSnapshot(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  char v3 = *((_BYTE *)v1 + 88);
  if ((*(_DWORD *)(boundaryTrackerInstance + 20) & 0xFFFFFFFE) != 2)
  {
    if (*((_BYTE *)v1 + 88))
    {
      unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v1 + 9) allObjects]);
      id v10 = [v9 copy];
      unint64_t v11 = (void *)*((void *)v2 + 10);
      *((void *)v2 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v10;

      char v3 = 0;
    }

    goto LABEL_22;
  }

  if (!*((_BYTE *)v1 + 88))
  {
    if ([*((id *)v1 + 9) count])
    {
      s();
      uint64_t v5 = v4;
      *(_BYTE *)(v4 + 8) |= 0x80u;
      if (*((void *)v2 + 10))
      {
        GTTraceContext_pushEncoderWithStream(*((void *)v2 + 3), (uint64_t)v38);
        uint64_t v6 = v40;
        *(_DWORD *)(v40 + _Block_object_dispose(va, 8) = -15249;
        unsigned __int8 v7 = v44;
        if (v44 > 0x28uLL)
        {
          uint64_t v12 = *(void *)(v39 + 24);
          uint64_t v13 = v45++;
          uint64_t v8 = GTTraceMemPool_allocateBytes(v12, v41, v13 | 0x1800000000LL) + 16;
          unsigned __int8 v7 = v13;
        }

        else
        {
          uint64_t v8 = (char *)(v6 + v44);
          v44 += 24;
        }

        *(_BYTE *)(v6 + 13) = v7;
        int v14 = (uint64_t *)[v2 traceStream];
        if (v14) {
          uint64_t v15 = *v14;
        }
        else {
          uint64_t v15 = 0LL;
        }
        id v16 = [*((id *)v2 + 10) count];
        id v17 = [*((id *)v2 + 10) count];
        __chkstk_darwin(v17, v18);
        char v20 = StreamNSArray((uint64_t)v38, &v38[-v19 - 8], *((void **)v2 + 10));
        *(void *)uint64_t v8 = v15;
        *((void *)v8 + 1) = v16;
        v8[16] = v20;
        *(_DWORD *)(v8 + 17) = 0;
        *((_DWORD *)v8 + 5) = 0;
        *(void *)uint64_t v5 = v42;
        *(_BYTE *)(v5 + _Block_object_dispose(va, 8) = v43;
        *(_BYTE *)(v40 + 15) |= 8u;
      }

      GTTraceContext_pushEncoderWithStream(*((void *)v2 + 3), (uint64_t)v38);
      uint64_t v21 = v40;
      *(_DWORD *)(v40 + _Block_object_dispose(va, 8) = -15251;
      unsigned __int8 v22 = v44;
      if (v44 > 0x28uLL)
      {
        uint64_t v24 = *(void *)(v39 + 24);
        uint64_t v25 = v45++;
        uint64_t v23 = GTTraceMemPool_allocateBytes(v24, v41, v25 | 0x1800000000LL) + 16;
        unsigned __int8 v22 = v25;
      }

      else
      {
        uint64_t v23 = (char *)(v21 + v44);
        v44 += 24;
      }

      *(_BYTE *)(v21 + 13) = v22;
      uint64_t v26 = (uint64_t *)[v2 traceStream];
      if (v26) {
        uint64_t v27 = *v26;
      }
      else {
        uint64_t v27 = 0LL;
      }
      id v28 = [*((id *)v2 + 9) count];
      unsigned int v29 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v2 + 9) allObjects]);
      id v30 = [v29 count];
      __chkstk_darwin(v30, v31);
      uint64_t v33 = &v38[-v32 - 8];
      unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v2 + 9) allObjects]);
      char v35 = StreamNSArray((uint64_t)v38, v33, v34);
      *(void *)uint64_t v23 = v27;
      *((void *)v23 + 1) = v28;
      v23[16] = v35;
      *(_DWORD *)(v23 + 17) = 0;
      *((_DWORD *)v23 + 5) = 0;

      *(void *)uint64_t v5 = v42;
      char v36 = v43;
      *(_BYTE *)(v40 + 15) |= 8u;
      *(_BYTE *)(v5 + _Block_object_dispose(va, 8) = v36 & 0x7F;
    }

    char v3 = 1;
LABEL_22:
    *((_BYTE *)v2 + 8_Block_object_dispose(va, 8) = v3;
  }
}

void AddResidencySet(void *a1, void *a2)
{
  uint64_t v6 = a1;
  id v3 = a2;
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___CaptureMTLResidencySet, v4);
  if ((objc_opt_isKindOfClass(v3, v5) & 1) != 0)
  {
    [v6[9] addObject:v3];
    ResidencySetTakeSnapshotInternal(v3, 0);
  }
}

uint64_t __Block_byref_object_copy__8446(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(a2 + 40);
  *(void *)(a2 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0LL;
  return result;
}

void __Block_byref_object_dispose__8447(uint64_t a1)
{
}

void CommandQueueCaptureResidencySetSnapshots(void *a1)
{
  id v1 = a1;
  CommandQueueTakeSnapshot(v1);
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  id v2 = v1[9];
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
    do
    {
      uint64_t v6 = 0LL;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        ResidencySetTakeSnapshotInternal(*(void **)(*((void *)&v7 + 1) + 8LL * (void)v6), 0);
        uint64_t v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
    }

    while (v4);
  }
}

apr_array_header_t *CaptureMTLCommandQueue_enqueuedCommandBufferRefs(void *a1, id a2, apr_pool_t *a3)
{
  id v5 = a1;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 enqueuedCommandBuffers]);
  if ([v6 count])
  {
    __int128 v7 = apr_array_make(a3, (int)[v6 count], 8);
    if ([v6 count])
    {
      unint64_t v8 = 0LL;
      do
      {
        __int128 v9 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:v8]);
        if ([v9 streamReference] != a2 && (objc_msgSend(v9, "isCommited") & 1) == 0)
        {
          id v10 = [v9 streamReference];
          *(void *)apr_array_push(v7) = v10;
        }

        ++v8;
      }

      while ((unint64_t)[v6 count] > v8);
    }
  }

  else
  {
    __int128 v7 = 0LL;
  }

  return v7;
}

LABEL_67:
          __int128 v122 = NSLocalizedDescriptionKey;
          __int128 v123 = NSLocalizedRecoverySuggestionErrorKey;
          *(void *)&__int128 v114 = @"The value of triggerHitsToEnd cannot be 0.";
          *((void *)&v114 + 1) = @"Set triggerHitsToEnd to the amount of times the end condition needs to be met to end the capture.";
          uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v114,  &v122,  2LL));
          ReportError(a4, (uint64_t)MTLCaptureErrorDomain, 3LL, (uint64_t)v51);

          goto LABEL_61;
        }

        id v16 = 2LL;
      }
    }

    double v102 = 0LL;
    uint64_t v23 = 0LL;
LABEL_27:
    if ((v16 & 0xFFFFFFFFFFFFFFFDLL) == 0 || v23) {
      goto LABEL_29;
    }
    goto LABEL_67;
  }

  v139[0] = NSLocalizedDescriptionKey;
  v139[1] = NSLocalizedRecoverySuggestionErrorKey;
  v140[0] = @"Already capturing.";
  v140[1] = @"Stop running capture before starting a new one.";
  __int128 v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v140,  v139,  2LL));
  ReportError(a4, (uint64_t)MTLCaptureErrorDomain, 2LL, (uint64_t)v7);

LABEL_5:
  uint64_t v13 = 0;
LABEL_6:

  return v13;
}

void sub_A9094( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
}

void ReportError(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  a2,  a3,  a4));
  uint64_t v6 = v5;
  if ((qword_23A448 & 2) != 0)
  {
    if (s_logUsingOsLog)
    {
      id v7 = gt_default_log();
      unint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        id v9 = [v6 code];
        id v10 = objc_claimAutoreleasedReturnValue([v6 localizedDescription]);
        unint64_t v11 = (const char *)[v10 UTF8String];
        if (v11) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = "(unknown)";
        }
        id v13 = objc_claimAutoreleasedReturnValue([v6 localizedFailureReason]);
        int v14 = (const char *)[v13 UTF8String];
        if (v14) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = "";
        }
        id v16 = objc_claimAutoreleasedReturnValue([v6 localizedRecoverySuggestion]);
        id v17 = (const char *)[v16 UTF8String];
        *(_DWORD *)buf = 134218754;
        uint64_t v18 = "none";
        id v31 = v9;
        if (v17) {
          uint64_t v18 = v17;
        }
        __int16 v32 = 2080;
        uint64_t v33 = v12;
        __int16 v34 = 2080;
        char v35 = v15;
        __int16 v36 = 2080;
        unsigned int v37 = v18;
        _os_log_fault_impl(&dword_0, v8, OS_LOG_TYPE_FAULT, "fail: error (%ld): %s %s [recommendation: %s]", buf, 0x2Au);
      }
    }

    else
    {
      uint64_t v19 = __stderrp;
      id v20 = [v5 code];
      unint64_t v8 = (os_log_s *) objc_claimAutoreleasedReturnValue([v6 localizedDescription]);
      uint64_t v21 = (const char *)-[os_log_s UTF8String](v8, "UTF8String");
      if (v21) {
        unsigned __int8 v22 = v21;
      }
      else {
        unsigned __int8 v22 = "(unknown)";
      }
      id v23 = objc_claimAutoreleasedReturnValue([v6 localizedFailureReason]);
      uint64_t v24 = (const char *)[v23 UTF8String];
      if (v24) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = "";
      }
      id v26 = objc_claimAutoreleasedReturnValue([v6 localizedRecoverySuggestion]);
      uint64_t v27 = (const char *)[v26 UTF8String];
      id v28 = "none";
      if (v27) {
        id v28 = v27;
      }
      id v29 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"fail: error (%ld): %s %s [recommendation: %s]", v20, v22, v25, v28));
      fprintf(v19, "%s\n", (const char *)[v29 UTF8String]);
    }
  }

  if (a1) {
    *a1 = v6;
  }
}

void FillMissingCaptureObjectError(void *a1)
{
  v3[0] = NSLocalizedDescriptionKey;
  v3[1] = NSLocalizedRecoverySuggestionErrorKey;
  v4[0] = @"Capture Object property is not set.";
  v4[1] = @"Specify an object to be captured like MTLDevice.";
  id v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v4,  v3,  2LL));
  ReportError(a1, (uint64_t)MTLCaptureErrorDomain, 3LL, (uint64_t)v2);
}

void FinishCapture()
{
  id v0 = (void *)objc_claimAutoreleasedReturnValue( +[CaptureMTLCaptureManager sharedCaptureManager]( &OBJC_CLASS___CaptureMTLCaptureManager,  "sharedCaptureManager"));
  unsigned int v1 = [v0 isCapturing];

  if (v1)
  {
    id v2 = (void *)objc_claimAutoreleasedReturnValue( +[CaptureMTLCaptureManager sharedCaptureManager]( &OBJC_CLASS___CaptureMTLCaptureManager,  "sharedCaptureManager"));
    [v2 stopCapture];
  }

  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[CaptureMTLCaptureManager toolsCaptureManager]( &OBJC_CLASS___CaptureMTLCaptureManager,  "toolsCaptureManager"));
  unsigned int v4 = [v3 isCapturing];

  if (v4)
  {
    id v5 = (id)objc_claimAutoreleasedReturnValue( +[CaptureMTLCaptureManager toolsCaptureManager]( &OBJC_CLASS___CaptureMTLCaptureManager,  "toolsCaptureManager"));
    [v5 stopCapture];
  }

void GTMTLCaptureManager_init()
{
  dispatch_semaphore_t v0 = dispatch_semaphore_create(0LL);
  unsigned int v1 = (void *)qword_23A338;
  qword_23A338 = (uint64_t)v0;

  dispatch_semaphore_t v2 = dispatch_semaphore_create(0LL);
  id v3 = (void *)qword_23A340;
  qword_23A340 = (uint64_t)v2;
}

uint64_t GTMTLCaptureManager_activeCaptureState()
{
  return _sharedCaptureManager;
}

uint64_t GTMTLCaptureManager_signalCaptureTrigger()
{
  return dispatch_semaphore_signal((dispatch_semaphore_t)qword_23A340);
}

uint64_t GTMTLCaptureManager_waitForCaptureTrigger()
{
  if ((qword_23A448 & 0x40) != 0) {
    return dispatch_semaphore_wait((dispatch_semaphore_t)qword_23A340, 0xFFFFFFFFFFFFFFFFLL);
  }
  return result;
}

id GTMTLCaptureManager_supportsRemoteCapture()
{
  if (*(void *)g_guestAppClientMTL || (qword_23A448 & 0x800) != 0) {
    return &dword_0 + 1;
  }
  else {
    return [*(id *)(g_guestAppClientMTL + 8) hasObservers];
  }
}

void GTMTLCaptureManager_startCapture()
{
  dispatch_semaphore_t v0 = objc_autoreleasePoolPush();
  uint64_t v1 = _sharedCaptureManager;
  *(void *)(v1 + 44mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = mach_absolute_time();
  GTMTLCaptureStatistics_begin(v1);
  dispatch_semaphore_t v2 = (void **)g_guestAppClientMTL;
  v11[0] = @"capture serial";
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v1 + 32)));
  v12[0] = v3;
  v12[1] = &off_212CF8;
  v11[1] = @"version";
  void v11[2] = @"nativePointerSize";
  void v12[2] = &off_212D10;
  int8x16_t v11[3] = @"BoundaryLess";
  unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(v1 + 86)));
  v12[3] = v4;
  v12[4] = &off_212D28;
  v11[4] = @"interpose-feature-version";
  v11[5] = @"interpose-patch-version";
  v12[5] = @"0";
  id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v12,  v11,  6LL));

  uint64_t v6 = *v2;
  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:attributes:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:attributes:",  257LL,  v5));
  [v6 send:v7 error:0];

  unint64_t v8 = (void *)objc_opt_new(&OBJC_CLASS___GTCaptureProgress);
  [v8 setCaptureState:3];
  if (*(_BYTE *)(g_guestAppClientMTL + 129)) {
    [*(id *)(g_guestAppClientMTL + 8) notifyCaptureProgress:v8];
  }
  id v9 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    *(_WORD *)id v10 = 0;
    _os_signpost_emit_with_name_impl(&dword_0, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "StartCapture", "", v10, 2u);
  }

  objc_autoreleasePoolPop(v0);
}

unint64_t GTMTLCaptureManager_stopActiveCapture(unint64_t a1, uint64_t a2)
{
  uint64_t v4 = _sharedCaptureManager;
  id v5 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v5,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "StopActiveCapture",  "",  buf,  2u);
  }

  context = objc_autoreleasePoolPush();
  int v6 = *(unsigned __int8 *)(v4 + 91);
  if (*(void *)v4) {
    WaitForDevice(g_ctx, *(void *)v4);
  }
  id v7 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = a1 + a2;
    _os_signpost_emit_with_name_impl( &dword_0,  v7,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Capture-StopActiveCaptureDumpContext",  "Index: %llu",  buf,  0xCu);
  }

  uint64_t started = GTTraceDump_startContext(g_ctx, (void *)v4, a1, a2);
  if (*(_BYTE *)(v4 + 93))
  {
    mach_timebase_info(info);
    uint64_t v9 = *(void *)(v4 + 440);
    uint64_t v10 = *(void *)(v4 + 16);
    if (!v10)
    {
      uint64_t v10 = *(void *)(v4 + 8);
      if (!v10) {
        uint64_t v10 = *(void *)v4;
      }
    }

    uint64_t v11 = *(void *)(started + 16);
    uint64_t v12 = *(const char **)(v4 + 64);
    *(void *)buf = a1;
    *(void *)&buf[8] = a2;
    *(void *)&__int128 v66 = v9;
    *((mach_timebase_info *)&v66 + 1) = info[0];
    *(void *)&__int128 v67 = v10;
    GTTraceDump_writeNewArchive(v11, buf, v12);
  }

  if (*(int *)(*(void *)(started + 552) + 12LL) < 1)
  {
    GTTraceContextDumpEmptyCapture(started);
    uint64_t v73 = 0LL;
    __int128 v71 = 0u;
    __int128 v72 = 0u;
    __int128 v69 = 0u;
    __int128 v70 = 0u;
    __int128 v67 = 0u;
    __int128 v68 = 0u;
    *(_OWORD *)buf = 0u;
    __int128 v66 = 0u;
    goto LABEL_26;
  }

  GTTraceDump_writeStartup0(started, *(apr_pool_t **)(started + 32), *(apr_pool_t **)started);
  id v13 = *(apr_pool_t **)(started + 32);
  int v14 = *(apr_pool_t **)started;
  uint64_t v15 = *(void *)(started + 16);
  id v16 = apr_palloc(*(apr_pool_t **)started, 0x100000uLL);
  *(void *)buf = *(void *)(started + 56);
  *(void *)buf = *(void *)(*(void *)(*find_entry(v15, buf, 8uLL, 0LL) + 32LL) + 8LL);
  *(void *)&buf[8] = v16;
  *(void *)&__int128 v66 = 0x100000LL;
  id v17 = fbstream_open(v13, (uint64_t)"startup-1-platform", v14);
  *((void *)&v66 + 1) = v17;
  __int128 v67 = (unint64_t)v13;
  LOBYTE(v6_Block_object_dispose(va, 8) = *(_BYTE *)(started + 488);
  *(_DWORD *)((char *)&v68 + 1) = 0;
  DWORD1(v6_Block_object_dispose(va, 8) = 0;
  GTEncodeMetalLayers((uint64_t)buf, started);
  apr_pool_cleanup_kill(*v17, v17, (apr_status_t (__cdecl *)(void *))fbstream_cleanup);
  fbstream_cleanup((uint64_t)v17);
  GTTraceDump_writeDeviceResources(started, *(apr_pool_t **)(started + 32), *(apr_pool_t **)started);
  GTTraceDump_writeDelta(started, *(apr_pool_t **)(started + 32), *(apr_pool_t **)started);
  strcpy((char *)buf, "temporary data");
  GTMTLCaptureState_storePointer(*(void *)(started + 32), "gttrace-dump", (uint64_t *)buf, (char *)&dword_C + 3);
  strcpy((char *)buf, "dummy data");
  int v64 = 0;
  info[0] = (mach_timebase_info)4LL;
  if (!sysctlbyname("sysctl.proc_translated", &v64, (size_t *)info, 0LL, 0LL) && v64) {
    GTMTLCaptureState_storePointer(*(void *)(started + 32), "is_rosetta", (uint64_t *)buf, (char *)&dword_8 + 3);
  }
  if ((GTCorePlatform_isAlmond() & 1) != 0)
  {
    uint64_t v18 = "is_almond";
  }

  else
  {
    uint64_t v18 = "is_catalyst";
  }

  GTMTLCaptureState_storePointer(*(void *)(started + 32), v18, (uint64_t *)buf, (char *)&dword_8 + 3);
LABEL_24:
  WaitForDevice(*(void *)(started + 8), *(void *)(started + 56));
  GTTraceDump_writeCapture(started, *(apr_pool_t **)(started + 32), *(apr_pool_t **)started);
  GTTraceDump_writeUnsortedCapture(started, *(apr_pool_t **)(started + 32), *(apr_pool_t **)started);
  uint64_t v73 = 0LL;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v67 = 0u;
  __int128 v68 = 0u;
  *(_OWORD *)buf = 0u;
  __int128 v66 = 0u;
  if (!v6)
  {
    UnusedDownloadRequest = GTTraceContextDumpGetUnusedDownloadRequest(started);
    id v20 = GTResourceDownloaderProcessRequest(*(apr_pool_t **)started, (uint64_t)UnusedDownloadRequest);
    DownloadFromDevice(*(void *)(started + 16), *(void *)(started + 56), (uint64_t)v20);
    apr_hash_clear(*(apr_hash_t **)(started + 496));
    DownloadsByResource((uint64_t)v20, *(apr_hash_t **)(started + 496));
    GTTraceDump_writeUnusedDeviceResources(started, *(apr_pool_t **)(started + 32), *(apr_pool_t **)started);
    GTTraceContextDumpUnusedCount(started, (uint64_t)buf);
  }

void GTTraceContextDumpEnd(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 64)) {
    GTMTLCaptureState_dumpDeviceFilesLocal(v2, *(void *)(a1 + 56));
  }
  GTTraceDump_endContext(a1);
}

void WaitForHarvesting()
{
  id v0 = GTMTLGuestAppClient_copyCaptureDevices(g_guestAppClientMTL);
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  uint64_t v2 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v2,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Capture-StopActiveCaptureHarvesterWait",  "",  buf,  2u);
  }

  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  id v3 = v1;
  id v4 = [v3 countByEnumeratingWithState:&v11 objects:v16 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v12;
    do
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        unint64_t v8 = *(void **)(*((void *)&v11 + 1) + 8LL * (void)i);
        uint64_t v9 = (dispatch_group_s *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "dispatchGroup", (void)v11));
        dispatch_group_wait(v9, 0xFFFFFFFFFFFFFFFFLL);

        [v8 invalidateHarvester];
      }

      id v5 = [v3 countByEnumeratingWithState:&v11 objects:v16 count:16];
    }

    while (v5);
  }

  uint64_t v10 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v10,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Capture-StopActiveCaptureHarvesterWait",  "",  buf,  2u);
  }
}

void GTMTLCaptureManager_abortActiveCapture(unint64_t a1, uint64_t a2)
{
  id v4 = &unk_23A000;
  uint64_t v5 = _sharedCaptureManager;
  uint64_t v6 = objc_autoreleasePoolPush();
  id UnsupportedFenumInfo = GTMTLGuestAppClient_getUnsupportedFenumInfo();
  unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(UnsupportedFenumInfo);
  uint64_t v9 = v8;
  uint64_t v10 = &OBJC_PROTOCOL___CaptureMTLObject;
  if (v8)
  {
    __int128 v11 = (void *)objc_claimAutoreleasedReturnValue([v8 asError]);
    __int128 v12 = v11;
    if (s_logUsingOsLog)
    {
      id v13 = gt_default_log();
      __int128 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      {
        id v59 = [v12 code];
        __int128 v61 = (FILE *) objc_claimAutoreleasedReturnValue([v12 localizedDescription]);
        id v57 = -[FILE UTF8String](v61, "UTF8String");
        id v48 = objc_claimAutoreleasedReturnValue([v12 localizedFailureReason]);
        unsigned int v49 = (const char *)[v48 UTF8String];
        if (v49) {
          unint64_t v50 = v49;
        }
        else {
          unint64_t v50 = "";
        }
        unint64_t v51 = v6;
        id v52 = objc_claimAutoreleasedReturnValue([v12 localizedRecoverySuggestion]);
        BOOL v53 = (const char *)[v52 UTF8String];
        *(_DWORD *)buf = 134218754;
        unsigned int v54 = "none";
        *(void *)&uint8_t buf[4] = v59;
        if (v53) {
          unsigned int v54 = v53;
        }
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v57;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&_BYTE buf[24] = v50;
        LOWORD(v64) = 2080;
        *(void *)((char *)&v64 + 2) = v54;
        _os_log_fault_impl( &dword_0,  v14,  OS_LOG_TYPE_FAULT,  "fail: Capture aborted (%ld): %s %s [recommendation: %s]",  buf,  0x2Au);

        uint64_t v6 = v51;
        uint64_t v10 = &OBJC_PROTOCOL___CaptureMTLObject;

        id v4 = (void *)&unk_23A000;
      }
    }

    else
    {
      __int128 v60 = __stderrp;
      id v56 = [v11 code];
      id v58 = objc_claimAutoreleasedReturnValue([v12 localizedDescription]);
      uint64_t v15 = v6;
      id v16 = [v58 UTF8String];
      id v17 = objc_claimAutoreleasedReturnValue([v12 localizedFailureReason]);
      uint64_t v18 = (const char *)[v17 UTF8String];
      if (v18) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = "";
      }
      id v20 = objc_claimAutoreleasedReturnValue([v12 localizedRecoverySuggestion]);
      uint64_t v21 = (const char *)[v20 UTF8String];
      unsigned __int8 v22 = "none";
      if (v21) {
        unsigned __int8 v22 = v21;
      }
      id v55 = v16;
      uint64_t v6 = v15;
      id v23 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"fail: Capture aborted (%ld): %s %s [recommendation: %s]", v56, v55, v19, v22));
      fprintf(v60, "%s\n", (const char *)[v23 UTF8String]);

      id v4 = &unk_23A000;
      uint64_t v10 = &OBJC_PROTOCOL___CaptureMTLObject;
    }
  }

  uint64_t started = GTTraceDump_startContext(g_ctx, (void *)v5, a1, a2);
  GTTraceContextDumpEmptyCapture(started);
  uint64_t v25 = *(void *)(v5 + 48);
  uint64_t v70 = 0LL;
  __int128 v68 = 0u;
  __int128 v69 = 0u;
  __int128 v66 = 0u;
  __int128 v67 = 0u;
  __int128 v64 = 0u;
  __int128 v65 = 0u;
  memset(buf, 0, sizeof(buf));
  GTMTLCaptureState_notifyUsedDataSentWithDictionary(v5, v25, buf);
  unint64_t v26 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v26,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CaptureSentAllMetadata",  "",  buf,  2u);
  }

  uint64_t v27 = *(void **)(v5 + 104);
  id v28 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:",  267LL));
  [v27 send:v28 error:0];

  GTTraceContextDumpEnd(started);
  WaitForHarvesting();
  GTMTLCaptureState_notifyAllCaptureDataSent(v5, *(void *)(v5 + 48));

  objc_autoreleasePoolPop(v6);
  unint64_t v29 = (void (**)(id, void))objc_retainBlock(*(id *)(v5 + 96));
  id v30 = *(id *)(v5 + 424);
  GTMTLCaptureState_close(v4[102]);
  if (v30)
  {
    if (LOBYTE(v10[1].opt_inst_meths))
    {
      id v31 = gt_default_log();
      unint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
        id v33 = [v30 UTF8String];
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = v33;
        _os_log_impl(&dword_0, v32, OS_LOG_TYPE_INFO, "Capture aborted, removing archive: %s", buf, 0xCu);
      }
    }

    else
    {
      unint64_t v34 = __stdoutp;
      unint64_t v32 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString, "stringWithFormat:", @"Capture aborted, removing archive: %s", [v30 UTF8String]));
      fprintf(v34, "%s\n", (const char *)-[os_log_s UTF8String](v32, "UTF8String"));
    }

    unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    id v62 = 0LL;
    unsigned __int8 v36 = [v35 removeItemAtPath:v30 error:&v62];
    id v37 = v62;

    if ((v36 & 1) != 0) {
      goto LABEL_26;
    }
    if (LOBYTE(v10[1].opt_inst_meths))
    {
      id v38 = gt_default_log();
      id v39 = (id)objc_claimAutoreleasedReturnValue(v38);
      if (!os_log_type_enabled((os_log_t)v39, OS_LOG_TYPE_INFO))
      {
LABEL_25:

LABEL_26:
        goto LABEL_27;
      }

      id v40 = [v30 UTF8String];
      id v41 = objc_claimAutoreleasedReturnValue([v37 localizedDescription]);
      id v42 = [v41 UTF8String];
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = v40;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v42;
      _os_log_impl(&dword_0, (os_log_t)v39, OS_LOG_TYPE_INFO, "Remove archive %s failed: %s", buf, 0x16u);
    }

    else
    {
      char v43 = __stdoutp;
      id v44 = [v30 UTF8String];
      id v39 = objc_claimAutoreleasedReturnValue([v37 localizedDescription]);
      id v41 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString, "stringWithFormat:", @"Remove archive %s failed: %s", v44, [v39 UTF8String]));
      fprintf(v43, "%s\n", (const char *)[v41 UTF8String]);
    }

    goto LABEL_25;
  }

void GTMTLCaptureManager_activateCaptureWithDescriptor(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 89))
  {
    RemoteCapture = GTMTLCaptureState_createRemoteCapture(a1, (id *)g_guestAppClientMTL);
    _sharedCaptureManager = (uint64_t)RemoteCapture;
    uint64_t v3 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *(void *)(a1 + 64)));
    id v4 = *(void **)&RemoteCapture[6].__opaque[32];
    *(void *)&RemoteCapture[6].__opaque[32] = v3;

    RemoteCapture[7].__opaque[0] = strcmp(*(const char **)(a1 + 64), *(const char **)(a1 + 72)) == 0;
    uint64_t v5 = _sharedCaptureManager;
    unint64_t v6 = atomic_load(&qword_23A348);
    while (1)
    {
      unint64_t v7 = *(void *)(v5 + 32);
      if (v6 >= v7) {
        return;
      }
      unint64_t v8 = __ldaxr(&qword_23A348);
      if (v8 != v6) {
        break;
      }
      if (__stlxr(v7, &qword_23A348)) {
        goto LABEL_10;
      }
      int v9 = 1;
LABEL_11:
      unint64_t v6 = v8;
      if (v9) {
        return;
      }
    }

    __clrex();
LABEL_10:
    int v9 = 0;
    goto LABEL_11;
  }

  if (*(void *)(a1 + 64))
  {
    _sharedCaptureManager = (uint64_t)GTMTLCaptureState_createLocalCapture(a1, g_guestAppClientMTL);
  }

  else
  {
    uint64_t v10 = (id *)g_guestAppClientMTL;
    __int128 v11 = *(_OWORD *)(a1 + 48);
    __int128 v25 = *(_OWORD *)(a1 + 32);
    __int128 v26 = v11;
    __int128 v12 = *(_OWORD *)(a1 + 80);
    __int128 v27 = *(_OWORD *)(a1 + 64);
    __int128 v28 = v12;
    __int128 v13 = *(_OWORD *)(a1 + 16);
    __int128 v23 = *(_OWORD *)a1;
    __int128 v24 = v13;
    id v29 = objc_retainBlock(*(id *)(a1 + 96));
    do
    {
      unint64_t v14 = __ldaxr(&qword_23A348);
      unint64_t v15 = v14 + 1;
    }

    while (__stlxr(v14 + 1, &qword_23A348));
    *(void *)&__int128 v25 = v14 + 1;
    _sharedCaptureManager = (uint64_t)GTMTLCaptureState_createRemoteCapture((uint64_t)&v23, v10);
    if (*v10)
    {
      id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v15,  v23,  v24));
      v33[0] = v16;
      v32[0] = @"Serial";
      v32[1] = @"TriggerFrame";
      id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 40)));
      v33[1] = v17;
      v33[2] = &off_212CF8;
      v32[2] = @"FrameLimit";
      v32[3] = @"TriggerOnNextGLCommand";
      v33[3] = &__kCFBooleanTrue;
      v33[4] = &__kCFBooleanTrue;
      v32[4] = @"LockOpenGLAfterCompletion";
      v32[5] = @"SuspendAfterCompletion";
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(a1 + 84)));
      v33[5] = v18;
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v33,  v32,  6LL));

      id v30 = @"capture serial";
      id v31 = v16;
      id v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v31,  &v30,  1LL));
      id v21 = *v10;
      unsigned __int8 v22 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_capture messageWithKind:attributes:plistPayload:]( &OBJC_CLASS___GTTransportMessage_capture,  "messageWithKind:attributes:plistPayload:",  264LL,  v20,  v19));
      [v21 send:v22 error:0];

      dispatch_semaphore_wait((dispatch_semaphore_t)qword_23A338, 0xFFFFFFFFFFFFFFFFLL);
    }
  }

void sub_AF420( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21)
{
}

uint64_t GTMTLCaptureManager_updateCaptureDescriptorFromHost(uint64_t result)
{
  uint64_t v1 = _sharedCaptureManager;
  if (*(void *)(result + 32) == *(void *)(_sharedCaptureManager + 32))
  {
    uint64_t v2 = result;
    *(_WORD *)(_sharedCaptureManager + 84) = *(_WORD *)(result + 84);
    *(_BYTE *)(v1 + 87) = *(_BYTE *)(result + 87);
    uint64_t v3 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *(void *)(result + 64)));
    id v4 = *(void **)(v1 + 424);
    *(void *)(v1 + 424) = v3;

    uint64_t v5 = *(const char **)(v2 + 64);
    *(void *)(v1 + 56) = *(void *)(v2 + 56);
    *(_BYTE *)(v1 + 456) = strcmp(v5, *(const char **)(v2 + 72)) == 0;
    unint64_t result = dispatch_semaphore_signal((dispatch_semaphore_t)qword_23A338);
    uint64_t v1 = _sharedCaptureManager;
  }

  unint64_t v6 = atomic_load(&qword_23A348);
  do
  {
    unint64_t v7 = *(void *)(v1 + 32);
    if (v6 >= v7) {
      break;
    }
    unint64_t v8 = __ldaxr(&qword_23A348);
    if (v8 != v6)
    {
      __clrex();
LABEL_9:
      int v9 = 0;
      goto LABEL_10;
    }

    if (__stlxr(v7, &qword_23A348)) {
      goto LABEL_9;
    }
    int v9 = 1;
LABEL_10:
    unint64_t v6 = v8;
  }

  while (!v9);
  return result;
}

void GTMTLCaptureManager_advanceToNextFrame()
{
  uint64_t v0 = g_guestAppClientMTL;
  uint64_t v1 = (unint64_t *)(g_guestAppClientMTL + 64);
  do
    uint64_t v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  if ((*(_BYTE *)(v0 + 48) & 1) != 0) {
    GTMTLGuestAppClient_collectFrameProfilingData(v0, v2);
  }
}

void GTMTLCaptureManager_notifyUnsupportedFenumWithMsg(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v8 = objc_alloc(&OBJC_CLASS___GTUnsupportedFenumInfo);
  if (a1)
  {
    int v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
    if (a2) {
      goto LABEL_3;
    }
  }

  else
  {
    int v9 = 0LL;
    if (a2)
    {
LABEL_3:
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
      if (a3) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }

  uint64_t v10 = 0LL;
  if (a3)
  {
LABEL_4:
    __int128 v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a3));
    if (a4) {
      goto LABEL_5;
    }
    goto LABEL_15;
  }

void GTMTLCaptureManager_notifyUnsupportedFenum(uint64_t a1, uint64_t a2)
{
}

uint64_t GetClientMemorySize(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v6 = a1;
  id v7 = [v6 pixelFormat];
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v6 device]);
  GTMTLGetTextureLevelInfoForDeviceWithOptions((uint64_t)v7, (uint64_t)[v6 sampleCount], (uint64_t)v11);

  int v9 = (char *)[v6 textureType];
  if (v9 != (_BYTE *)&dword_4 + 3 || !a4)
  {
    if (a3)
    {
LABEL_6:
      a4 = v12 * a3;
      return v13 * a4;
    }

LABEL_5:
    a3 = v14;
    goto LABEL_6;
  }

  return v13 * a4;
}

    uint64_t v10 = 0LL;
    goto LABEL_9;
  }

  int v9 = objc_msgSend(v7, "newBufferWithLength:options:", a2, objc_msgSend(v7, "resourceOptions"));
LABEL_7:
  uint64_t v10 = v9;
  if (v9) {
    [v9 setLabel:v8];
  }
LABEL_9:

  return v10;
}

    __int128 v17 = 0LL;
    goto LABEL_9;
  }

  __int128 v16 = [v13 newTextureWithDescriptor:v15];
LABEL_7:
  __int128 v17 = v16;
  if (v16) {
    [v16 setLabel:v14];
  }
LABEL_9:

  return v17;
}

uint64_t mach_exception_raise(mach_port_t a1, int a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  int v14 = 2;
  int v15 = a2;
  int v17 = 1245184;
  int v18 = a3;
  int v19 = 1245184;
  NDR_record_t v20 = NDR_record;
  int v21 = a4;
  if (a6 > 2) {
    return 4294966989LL;
  }
  int v9 = 8 * a6;
  __memcpy_chk(&v23, a5, 8 * a6, 16LL);
  unsigned int v22 = a6;
  mach_port_t reply_port = mig_get_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  *(void *)&msg.msgh_voucher_port = 0x96500000000LL;
  if (&_voucher_mach_msg_set)
  {
    voucher_mach_msg_set(&msg);
    mach_port_t reply_port = msg.msgh_local_port;
  }

  uint64_t v11 = mach_msg(&msg, 3, v9 + 68, 0x2Cu, reply_port, 0, 0);
  uint64_t v6 = v11;
  if ((v11 - 268435458) <= 0xE && ((1 << (v11 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    return v6;
  }

  if ((_DWORD)v11)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    return v6;
  }

  if (msg.msgh_id == 71)
  {
    uint64_t v6 = 4294966988LL;
LABEL_19:
    mach_msg_destroy(&msg);
    return v6;
  }

  if (msg.msgh_id != 2505)
  {
    uint64_t v6 = 4294966995LL;
    goto LABEL_19;
  }

  uint64_t v6 = 4294966996LL;
  if ((msg.msgh_bits & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (msg.msgh_size != 36) {
    goto LABEL_19;
  }
  if (msg.msgh_remote_port) {
    goto LABEL_19;
  }
  uint64_t v6 = v16;
  if (v16) {
    goto LABEL_19;
  }
  return v6;
}

uint64_t mach_exception_raise_state( mach_port_t a1, unsigned int a2, uint64_t a3, unsigned int a4, unsigned int *a5, const void *a6, unsigned int a7, void *a8, mach_msg_size_t *a9)
{
  NDR_record_t v28 = NDR_record;
  unsigned int v29 = a2;
  if (a4 <= 2)
  {
    uint64_t v15 = 8 * a4;
    __memcpy_chk(&v31, a3, v15, 5208LL);
    unsigned int v30 = a4;
    unsigned int v16 = (char *)&v27 + v15;
    *(_DWORD *)((char *)&v27 + v15 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *a5;
    if (a7 <= 0x510)
    {
      int v19 = v16 - 16;
      int v20 = v15 + 4 * a7;
      memcpy(v16 + 48, a6, 4 * a7);
      *((_DWORD *)v19 + 15) = a7;
      mach_port_t reply_port = mig_get_reply_port();
      v27.msgh_remote_port = a1;
      v27.msgh_local_port = reply_port;
      v27.msgh_bits = 5395;
      *(void *)&v27.msgh_voucher_port = 0x96600000000LL;
      if (&_voucher_mach_msg_set)
      {
        voucher_mach_msg_set(&v27);
        mach_port_t reply_port = v27.msgh_local_port;
      }

      uint64_t v22 = mach_msg(&v27, 3, v20 + 48, 0x1474u, reply_port, 0, 0);
      uint64_t v17 = v22;
      if ((v22 - 268435458) <= 0xE && ((1 << (v22 - 2)) & 0x4003) != 0)
      {
        mig_put_reply_port(v27.msgh_local_port);
        return v17;
      }

      if ((_DWORD)v22)
      {
        mig_dealloc_reply_port(v27.msgh_local_port);
        return v17;
      }

      if (v27.msgh_id == 71)
      {
        uint64_t v17 = 4294966988LL;
      }

      else if (v27.msgh_id == 2506)
      {
        if ((v27.msgh_bits & 0x80000000) == 0)
        {
          if (v27.msgh_size - 5229 <= 0xFFFFEBBE)
          {
            if (v27.msgh_remote_port) {
              BOOL v23 = 1;
            }
            else {
              BOOL v23 = v29 == 0;
            }
            if (!v23 && v27.msgh_size == 36) {
              uint64_t v17 = v29;
            }
            else {
              uint64_t v17 = 4294966996LL;
            }
            goto LABEL_29;
          }

          if (!v27.msgh_remote_port)
          {
            uint64_t v17 = v29;
            if (v29) {
              goto LABEL_29;
            }
            mach_msg_size_t v25 = v31;
            if (v31 <= 0x510 && v31 <= (v27.msgh_size - 44) >> 2)
            {
              size_t v26 = 4LL * v31;
              if (v27.msgh_size == 4 * v31 + 44)
              {
                *a5 = v30;
                memcpy(a8, &v32, v26);
                uint64_t v17 = 0LL;
                *a9 = v25;
                return v17;
              }
            }
          }
        }

        uint64_t v17 = 4294966996LL;
      }

      else
      {
        uint64_t v17 = 4294966995LL;
      }

uint64_t mach_exception_raise_state_identity( mach_port_t a1, int a2, mach_msg_size_t a3, int a4, uint64_t a5, unsigned int a6, int *a7, const void *a8, unsigned int a9, void *a10, mach_msg_size_t *a11)
{
  int v28 = 2;
  int v29 = a2;
  int v31 = 1245184;
  mach_msg_size_t v32 = a3;
  v33[1] = 1245184;
  NDR_record_t v34 = NDR_record;
  int v35 = a4;
  if (a6 <= 2)
  {
    uint64_t v15 = 8 * a6;
    __memcpy_chk(&v37, a5, v15, 5208LL);
    unsigned int v36 = a6;
    unsigned int v16 = (char *)&msg + v15;
    *(_DWORD *)((char *)&msg + v15 + 6_Block_object_dispose(va, 8) = *a7;
    if (a9 <= 0x510)
    {
      int v19 = v16 - 16;
      int v20 = v15 + 4 * a9;
      memcpy(v16 + 76, a8, 4 * a9);
      *((_DWORD *)v19 + 22) = a9;
      mach_port_t reply_port = mig_get_reply_port();
      msg.msgh_remote_port = a1;
      msg.msgh_local_port = reply_port;
      msg.msgh_bits = -2147478253;
      *(void *)&msg.msgh_voucher_port = 0x96700000000LL;
      if (&_voucher_mach_msg_set)
      {
        voucher_mach_msg_set(&msg);
        mach_port_t reply_port = msg.msgh_local_port;
      }

      uint64_t v22 = mach_msg(&msg, 3, v20 + 76, 0x1474u, reply_port, 0, 0);
      uint64_t v17 = v22;
      if ((v22 - 268435458) <= 0xE && ((1 << (v22 - 2)) & 0x4003) != 0)
      {
        mig_put_reply_port(msg.msgh_local_port);
        return v17;
      }

      if ((_DWORD)v22)
      {
        mig_dealloc_reply_port(msg.msgh_local_port);
        return v17;
      }

      if (msg.msgh_id == 71)
      {
        uint64_t v17 = 4294966988LL;
      }

      else if (msg.msgh_id == 2507)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size - 5229 <= 0xFFFFEBBE)
          {
            if (msg.msgh_remote_port) {
              BOOL v23 = 1;
            }
            else {
              BOOL v23 = v30 == 0;
            }
            if (!v23 && msg.msgh_size == 36) {
              uint64_t v17 = v30;
            }
            else {
              uint64_t v17 = 4294966996LL;
            }
            goto LABEL_29;
          }

          if (!msg.msgh_remote_port)
          {
            uint64_t v17 = v30;
            if (v30) {
              goto LABEL_29;
            }
            mach_msg_size_t v25 = v32;
            if (v32 <= 0x510 && v32 <= (msg.msgh_size - 44) >> 2)
            {
              size_t v26 = 4LL * v32;
              if (msg.msgh_size == 4 * v32 + 44)
              {
                *a7 = v31;
                memcpy(a10, v33, v26);
                uint64_t v17 = 0LL;
                *a11 = v25;
                return v17;
              }
            }
          }
        }

        uint64_t v17 = 4294966996LL;
      }

      else
      {
        uint64_t v17 = 4294966995LL;
      }

void GTMTLTelemetryEnvironment_init()
{
  uint64_t v0 = getenv("MTLTELEMETRY_REPORT_FREQUENCY");
  if (v0) {
    float v1 = strtof(v0, 0LL);
  }
  else {
    float v1 = 0.2;
  }
  GT_TELEMETRY_ENV = LODWORD(v1);
}

void GTTelemetry_init()
{
  if (GTTelemetry_init::onceToken != -1) {
    dispatch_once(&GTTelemetry_init::onceToken, &__block_literal_global_10499);
  }
}

void GTTelemetry_addLayer(void *a1)
{
}

void GTTelemetry_addStreamRef(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(telemetry + 8);
  std::mutex::lock((std::mutex *)(telemetry + 8));
  uint64_t v3 = (void *)telemetry;
  uint64_t v5 = *(void **)(telemetry + 208);
  unint64_t v4 = *(void *)(telemetry + 216);
  if ((unint64_t)v5 >= v4)
  {
    id v7 = *(void **)(telemetry + 200);
    unint64_t v8 = 0xF0B7672A07A44C6BLL * (v5 - v7) + 1;
    if (v8 > 0x7A44C6AFC2DD9CLL) {
      abort();
    }
    unint64_t v9 = 0xF0B7672A07A44C6BLL * ((uint64_t)(v4 - (void)v7) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3D226357E16ECELL) {
      unint64_t v10 = 0x7A44C6AFC2DD9CLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x7A44C6AFC2DD9CLL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v11 = (char *)operator new(536 * v10);
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    uint64_t v12 = &v11[8 * (v5 - v7)];
    uint64_t v13 = &v11[536 * v10];
    uint64_t v6 = v12 + 536;
    *(void *)uint64_t v12 = a1;
    bzero(v12 + 8, 0x210uLL);
    if (v5 != v7)
    {
      do
      {
        v5 -= 67;
        v12 -= 536;
        memcpy(v12, v5, 0x218uLL);
      }

      while (v5 != v7);
      uint64_t v5 = (void *)v3[25];
    }

    v3[25] = v12;
    v3[26] = v6;
    v3[27] = v13;
    if (v5) {
      operator delete(v5);
    }
  }

  else
  {
    void *v5 = a1;
    uint64_t v6 = v5 + 67;
    bzero(v5 + 1, 0x210uLL);
  }

  v3[26] = v6;
  std::mutex::unlock(v2);
}

void GTTelemetry_addDevice(void *a1)
{
  id v14 = a1;
  id v1 = [v14 streamReference];
  uint64_t v2 = (std::mutex *)(telemetry + 136);
  std::mutex::lock((std::mutex *)(telemetry + 136));
  uint64_t v3 = (void *)telemetry;
  uint64_t v5 = *(char **)(telemetry + 256);
  unint64_t v4 = *(void *)(telemetry + 264);
  if ((unint64_t)v5 >= v4)
  {
    id v7 = *(char **)(telemetry + 248);
    unint64_t v8 = 0xF83E0F83E0F83E1LL * ((v5 - v7) >> 4) + 1;
    if (v8 > 0x7C1F07C1F07C1FLL) {
      abort();
    }
    unint64_t v9 = 0xF83E0F83E0F83E1LL * ((uint64_t)(v4 - (void)v7) >> 4);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3E0F83E0F83E0FLL) {
      unint64_t v10 = 0x7C1F07C1F07C1FLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x7C1F07C1F07C1FLL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v11 = (char *)operator new(528 * v10);
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    uint64_t v12 = &v11[16 * ((v5 - v7) >> 4)];
    uint64_t v13 = &v11[528 * v10];
    uint64_t v6 = v12 + 528;
    *(void *)uint64_t v12 = v1;
    bzero(v12 + 8, 0x208uLL);
    if (v5 != v7)
    {
      do
      {
        v5 -= 528;
        v12 -= 528;
        memcpy(v12, v5, 0x210uLL);
      }

      while (v5 != v7);
      uint64_t v5 = (char *)v3[31];
    }

    v3[31] = v12;
    v3[32] = v6;
    v3[33] = v13;
    if (v5) {
      operator delete(v5);
    }
  }

  else
  {
    *(void *)uint64_t v5 = v1;
    uint64_t v6 = v5 + 528;
    bzero(v5 + 8, 0x208uLL);
  }

  v3[32] = v6;
  std::mutex::unlock(v2);
}

void GTTelemetry_addCommandQueue(void *a1)
{
  id v14 = a1;
  id v1 = [v14 streamReference];
  uint64_t v2 = (std::mutex *)(telemetry + 72);
  std::mutex::lock((std::mutex *)(telemetry + 72));
  uint64_t v3 = (void *)telemetry;
  uint64_t v5 = *(char **)(telemetry + 232);
  unint64_t v4 = *(void *)(telemetry + 240);
  if ((unint64_t)v5 >= v4)
  {
    id v7 = *(char **)(telemetry + 224);
    unint64_t v8 = 0xF83E0F83E0F83E1LL * ((v5 - v7) >> 4) + 1;
    if (v8 > 0x7C1F07C1F07C1FLL) {
      abort();
    }
    unint64_t v9 = 0xF83E0F83E0F83E1LL * ((uint64_t)(v4 - (void)v7) >> 4);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3E0F83E0F83E0FLL) {
      unint64_t v10 = 0x7C1F07C1F07C1FLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x7C1F07C1F07C1FLL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v11 = (char *)operator new(528 * v10);
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    uint64_t v12 = &v11[16 * ((v5 - v7) >> 4)];
    uint64_t v13 = &v11[528 * v10];
    uint64_t v6 = v12 + 528;
    *(void *)uint64_t v12 = v1;
    bzero(v12 + 8, 0x208uLL);
    if (v5 != v7)
    {
      do
      {
        v5 -= 528;
        v12 -= 528;
        memcpy(v12, v5, 0x210uLL);
      }

      while (v5 != v7);
      uint64_t v5 = (char *)v3[28];
    }

    v3[28] = v12;
    v3[29] = v6;
    v3[30] = v13;
    if (v5) {
      operator delete(v5);
    }
  }

  else
  {
    *(void *)uint64_t v5 = v1;
    uint64_t v6 = v5 + 528;
    bzero(v5 + 8, 0x208uLL);
  }

  v3[29] = v6;
  std::mutex::unlock(v2);
}

void GTTelemetry_removeLayer(void *a1)
{
}

void GTTelemetry_removeStreamRef(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(telemetry + 8);
  std::mutex::lock((std::mutex *)(telemetry + 8));
  uint64_t v3 = telemetry;
  unint64_t v4 = *(char **)(telemetry + 200);
  uint64_t v5 = *(char **)(telemetry + 208);
  if (v5 != v4)
  {
    unint64_t v6 = (v5 - v4) / 536;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    while (*(void *)v4 != a1)
    {
      v4 += 536;
      if (!--v6) {
        goto LABEL_8;
      }
    }

    memcpy(v4, v5 - 536, 0x218uLL);
    *(void *)(v3 + 208) -= 536LL;
  }

void GTTelemetry_removeCommandQueue(void *a1)
{
  id v1 = [a1 streamReference];
  uint64_t v2 = (std::mutex *)(telemetry + 72);
  std::mutex::lock((std::mutex *)(telemetry + 72));
  uint64_t v3 = telemetry;
  unint64_t v4 = *(id **)(telemetry + 224);
  uint64_t v5 = *(char **)(telemetry + 232);
  if (v5 != (char *)v4)
  {
    unint64_t v6 = (v5 - (char *)v4) / 528;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    while (*v4 != v1)
    {
      v4 += 66;
      if (!--v6) {
        goto LABEL_8;
      }
    }

    memcpy(v4, v5 - 528, 0x210uLL);
    *(void *)(v3 + 232) -= 528LL;
  }

void GTTelemetry_trackPresent(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 layer]);
  id v3 = [v2 streamReference];

  if ((objc_opt_respondsToSelector(v1, "addPresentedHandler:") & 1) != 0)
  {
    id v4 = DEVICEOBJECT(v1);
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    _OWORD v6[2] = __GTTelemetry_trackPresent_block_invoke;
    v6[3] = &__block_descriptor_40_e23_v16__0___MTLDrawable__8l;
    v6[4] = v3;
    [v5 addPresentedHandler:v6];
  }
}

void GTTelemetry_trackStreamRefPresent(uint64_t a1, CFTimeInterval a2)
{
  id v4 = (std::mutex *)(telemetry + 8);
  std::mutex::lock((std::mutex *)(telemetry + 8));
  for (uint64_t i = *(void *)(telemetry + 200); i != *(void *)(telemetry + 208); i += 536LL)
  {
    if (*(void *)i == a1)
    {
      uint64_t v6 = *(void *)(i + 8);
      *(void *)(i + _Block_object_dispose(va, 8) = v6 + 1;
      if (a2 <= 0.0) {
        a2 = CACurrentMediaTime();
      }
      float v7 = (a2 - *(double *)(i + 24)) * 1000.0;
      CHistoryRecord::Add(i + 32, v6, v7);
      *(CFTimeInterval *)(i + 24) = a2;
      break;
    }
  }

  std::mutex::unlock(v4);
}

uint64_t CHistoryRecord::Add(uint64_t this, unsigned int a2, float a3)
{
  int v3 = 0;
  unsigned int v4 = a2 % 0x78;
  float v5 = 999.99;
  float v6 = 0.0;
  if (a3 > 999.99 || a3 < 0.0) {
    a3 = 0.0;
  }
  *(_DWORD *)this = v4;
  uint64_t v8 = this + 4LL * v4;
  float v9 = *(float *)(this + 8) + (float)(a3 - *(float *)(v8 + 16));
  *(float *)(this + 4) = a3;
  *(float *)(this + _Block_object_dispose(va, 8) = v9;
  *(float *)(v8 + 16) = a3;
  *(float *)(this + 12) = v9 / 120.0;
  for (uint64_t i = 16LL; i != 496; i += 4LL)
  {
    float v11 = *(float *)(this + i);
    float v12 = fminf(v5, v11);
    float v13 = fmaxf(v6, v11);
    if (v11 > 0.0)
    {
      float v6 = v13;
      ++v3;
      float v5 = v12;
    }
  }

  float v14 = 0.0;
  if (v3) {
    float v14 = v5;
  }
  else {
    float v6 = 0.0;
  }
  *(float *)(this + 50mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v6;
  *(float *)(this + 496) = v14;
  return this;
}

void GTTelemetry_trackCommit(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 device]);
  id v3 = [v2 streamReference];

  unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue([v1 commandQueue]);
  id v5 = [v4 streamReference];

  id v6 = DEVICEOBJECT(v1);
  float v7 = (void *)objc_claimAutoreleasedReturnValue(v6);

  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  _OWORD v8[2] = __GTTelemetry_trackCommit_block_invoke;
  v8[3] = &__block_descriptor_48_e28_v16__0___MTLCommandBuffer__8l;
  _OWORD v8[4] = v3;
  void v8[5] = v5;
  [v7 addCompletedHandler:v8];
}

LABEL_6:
  std::mutex::unlock(v3);
  unint64_t v10 = (std::mutex *)(telemetry + 72);
  std::mutex::lock((std::mutex *)(telemetry + 72));
  float v12 = *(void *)(telemetry + 224);
  float v11 = *(void *)(telemetry + 232);
  if (v12 != v11)
  {
    while (*(void *)v12 != *(void *)(a1 + 40))
    {
      v12 += 528LL;
      if (v12 == v11) {
        goto LABEL_11;
      }
    }

    float v13 = *(_DWORD *)(v12 + 8);
    [v17 GPUEndTime];
    uint64_t v15 = v14;
    [v17 GPUStartTime];
    *(float *)&unsigned int v16 = (v15 - v16) * 1000.0;
    CHistoryRecord::Add(v12 + 24, v13, *(float *)&v16);
    ++*(void *)(v12 + 8);
  }

void GTTelemetry_stats(char *a1@<X8>)
{
  uint64_t v2 = (std::mutex *)(telemetry + 8);
  std::mutex::lock((std::mutex *)(telemetry + 8));
  uint64_t v3 = *(void *)(telemetry + 200);
  unint64_t v4 = 64LL;
  if (0xF0B7672A07A44C6BLL * ((*(void *)(telemetry + 208) - v3) >> 3) < 0x40) {
    unint64_t v4 = 0xF0B7672A07A44C6BLL * ((*(void *)(telemetry + 208) - v3) >> 3);
  }
  if (v4)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 32 * v4;
    do
    {
      float v7 = &a1[v5];
      uint64_t v8 = *(void *)(v3 + 8);
      *(void *)float v7 = *(void *)v3;
      *((void *)v7 + 3) = v8;
      *((_DWORD *)v7 + 5) = v8 - *(_DWORD *)(v3 + 16);
      *((_DWORD *)v7 + 2) = *(_DWORD *)(v3 + 44);
      *(void *)(v7 + 12) = *(void *)(v3 + 528);
      *(void *)(v3 + 16) = v8;
      v5 += 32LL;
      v3 += 536LL;
    }

    while (v6 != v5);
  }

  std::mutex::unlock(v2);
  float v9 = (std::mutex *)(telemetry + 72);
  std::mutex::lock((std::mutex *)(telemetry + 72));
  uint64_t v10 = *(void *)(telemetry + 224);
  uint64_t v11 = 512LL;
  if (v11)
  {
    uint64_t v12 = 0LL;
    uint64_t v13 = 32 * v11;
    do
    {
      float v14 = &a1[v12];
      uint64_t v15 = *(void *)(v10 + 8);
      *((void *)v14 + 256) = *(void *)v10;
      *((void *)v14 + 259) = v15;
      *((_DWORD *)v14 + 517) = v15 - *(_DWORD *)(v10 + 16);
      *((_DWORD *)v14 + 514) = *(_DWORD *)(v10 + 36);
      *(void *)&a1[v12 + 2060] = *(void *)(v10 + 520);
      *(void *)(v10 + 16) = v15;
      v12 += 32LL;
      v10 += 528LL;
    }

    while (v13 != v12);
  }

  std::mutex::unlock(v9);
  unsigned int v16 = (std::mutex *)(telemetry + 136);
  std::mutex::lock((std::mutex *)(telemetry + 136));
  uint64_t v17 = *(void *)(telemetry + 248);
  uint64_t v18 = 4LL;
  if (v18)
  {
    uint64_t v19 = 0LL;
    uint64_t v20 = 32 * v18;
    do
    {
      int v21 = &a1[v19];
      uint64_t v22 = *(void *)(v17 + 8);
      *((void *)v21 + 2304) = *(void *)v17;
      *((void *)v21 + 2307) = v22;
      *(_DWORD *)&a1[v19 + 18452] = v22 - *(_DWORD *)(v17 + 16);
      *(_DWORD *)&a1[v19 + 18440] = *(_DWORD *)(v17 + 36);
      *(void *)&a1[v19 + 18444] = *(void *)(v17 + 520);
      *(void *)(v17 + 16) = v22;
      v19 += 32LL;
      v17 += 528LL;
    }

    while (v20 != v19);
  }

  std::mutex::unlock(v16);
  ++*(void *)telemetry;
}

void *GTMTLSMContext_getObject(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v8 = a2;
  entry = find_entry(*a1, &v8, 8uLL, 0LL);
  if (!*entry) {
    return 0LL;
  }
  uint64_t v5 = *(void **)(*entry + 32LL);
  if (!v5) {
    return 0LL;
  }
  unint64_t result = 0LL;
  do
  {
    if (v5[2] > a3 || (float v7 = v5, v5[3] <= a3))
    {
      if (result) {
        return result;
      }
      float v7 = 0LL;
    }

    uint64_t v5 = (void *)v5[4];
    unint64_t result = v7;
  }

  while (v5);
  return result;
}

uint64_t GTMTLSMContext_lastObject(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = a2;
  entry = find_entry(*a1, &v6, 8uLL, 0LL);
  if (!*entry) {
    return 0LL;
  }
  for (uint64_t result = *(void *)(*entry + 32LL); result; uint64_t result = *(void *)(result + 32))
  {
    if (*(void *)(result + 16) <= a3) {
      break;
    }
  }

  return result;
}

uint64_t GTMTLSMContext_getDrawableTexture(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v9 = *(void *)(a2 + 48);
  entry = find_entry(*a1, &v9, 8uLL, 0LL);
  if (!*entry) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(*entry + 32LL);
  if (!v6) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    if (*(void *)(a2 + 16) > a3 || (uint64_t v8 = v6, *(void *)(v6 + 24) <= a3))
    {
      if (result) {
        return result;
      }
      uint64_t v8 = 0LL;
    }

    uint64_t v6 = *(void *)(v6 + 32);
    uint64_t result = v8;
  }

  while (v6);
  return result;
}

uint64_t GTMTLSMContext_getObjectTypeArray(uint64_t a1, int a2)
{
  else {
    return *(void *)(a1 + 8LL * byte_1C2D54[a2 - 2] + 8);
  }
}

_DWORD *GTMTLSMContext_getObjects(_DWORD *result, unint64_t a2, apr_array_header_t *arr)
{
  int v3 = result[3];
  if (v3 >= 1)
  {
    uint64_t v6 = result;
    for (uint64_t i = 0LL; i < v3; ++i)
    {
      uint64_t v8 = *(void **)(*((void *)v6 + 3) + 8 * i);
      if (v8[2] > a2) {
        break;
      }
      if (v8[3] > a2)
      {
        uint64_t v9 = 0LL;
        do
        {
          if (v8[2] > a2 || (uint64_t v10 = v8, v8[3] <= a2))
          {
            if (v9) {
              break;
            }
            uint64_t v10 = 0LL;
          }

          uint64_t v8 = (void *)v8[4];
          uint64_t v9 = v10;
        }

        while (v8);
        uint64_t result = apr_array_push(arr);
        *(void *)uint64_t result = v9;
        int v3 = *((_DWORD *)v6 + 3);
      }
    }
  }

  return result;
}

_DWORD *GTMTLSMContext_getBuffers(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 8), a2, a3);
}

_DWORD *GTMTLSMContext_getComputePipelineStates(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 40), a2, a3);
}

_DWORD *GTMTLSMContext_getDepthStencilStates(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 152), a2, a3);
}

_DWORD *GTMTLSMContext_getDrawables(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 240), a2, a3);
}

_DWORD *GTMTLSMContext_getEvents(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 120), a2, a3);
}

_DWORD *GTMTLSMContext_getLateEvalEvents(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 136), a2, a3);
}

_DWORD *GTMTLSMContext_getSharedEvents(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 128), a2, a3);
}

_DWORD *GTMTLSMContext_getFences(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 112), a2, a3);
}

_DWORD *GTMTLSMContext_getFunctions(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 224), a2, a3);
}

_DWORD *GTMTLSMContext_getHeaps(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 80), a2, a3);
}

_DWORD *GTMTLSMContext_getIndirectCommandBuffers(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 48), a2, a3);
}

_DWORD *GTMTLSMContext_getIndirectRenderCommands(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 168), a2, a3);
}

_DWORD *GTMTLSMContext_getIndirectComputeCommands(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 176), a2, a3);
}

_DWORD *GTMTLSMContext_getLibraries(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 88), a2, a3);
}

void *GTMTLSMContext_lastLibraries(void *result, unint64_t a2, apr_array_header_t *arr)
{
  uint64_t v3 = result[11];
  if (*(int *)(v3 + 12) >= 1)
  {
    uint64_t v6 = 0LL;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(v3 + 24) + 8 * v6);
      if (*(void *)(v7 + 16) > a2) {
        break;
      }
      uint64_t result = apr_array_push(arr);
      void *result = v7;
      ++v6;
    }

    while (v6 < *(int *)(v3 + 12));
  }

  return result;
}

_DWORD *GTMTLSMContext_getDynamicLibraries(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 96), a2, a3);
}

_DWORD *GTMTLSMContext_getPipelineLibraries(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 104), a2, a3);
}

_DWORD *GTMTLSMContext_getRenderPipelineStates(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 32), a2, a3);
}

_DWORD *GTMTLSMContext_getSamplerStates(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 24), a2, a3);
}

_DWORD *GTMTLSMContext_getTextures(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 16), a2, a3);
}

_DWORD *GTMTLSMContext_getIOCommandQueues(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 192), a2, a3);
}

_DWORD *GTMTLSMContext_getCommandQueues(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 184), a2, a3);
}

_DWORD *GTMTLSMContext_getRasterizationRateMaps(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 200), a2, a3);
}

_DWORD *GTMTLSMContext_getCounterSampleBuffers(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 160), a2, a3);
}

_DWORD *GTMTLSMContext_getFilters(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 216), a2, a3);
}

_DWORD *GTMTLSMContext_getResourceGroups(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 208), a2, a3);
}

_DWORD *GTMTLSMContext_getMotionPipelineStates(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 144), a2, a3);
}

_DWORD *GTMTLSMContext_getAccelerationStructures(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 72), a2, a3);
}

_DWORD *GTMTLSMContext_getIntersectionFunctionTables( uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 64), a2, a3);
}

_DWORD *GTMTLSMContext_getVisibleFunctionTables(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 56), a2, a3);
}

_DWORD *GTMTLSMContext_getResidencySets(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 280), a2, a3);
}

_DWORD *GTMTLSMContext_getFunctionHandles(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 256), a2, a3);
}

_DWORD *GTMTLSMContext_getSpatialScalers(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 264), a2, a3);
}

_DWORD *GTMTLSMContext_getTemporalScalers(uint64_t a1, unint64_t a2, apr_array_header_t *a3)
{
  return GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 272), a2, a3);
}

void *GTMTLSMContext_getRootResource(uint64_t *a1, void *Object, unint64_t a3)
{
  while (1)
  {
    int v6 = *(_DWORD *)Object;
    if (*(_DWORD *)Object == 16) {
      break;
    }
    if (v6 == 80)
    {
      uint64_t v7 = Object[17];
      if (v7) {
        goto LABEL_11;
      }
      uint64_t v7 = Object[18];
      if (v7) {
        goto LABEL_11;
      }
    }

    else if (v6 != 22)
    {
      return Object;
    }

    uint64_t v7 = Object[6];
    if (!v7) {
      return Object;
    }
LABEL_11:
    uint64_t Object = GTMTLSMContext_getObject(a1, v7, a3);
  }

  uint64_t v7 = Object[6];
  if (v7) {
    goto LABEL_11;
  }
  uint64_t v7 = Object[18];
  if (v7) {
    goto LABEL_11;
  }
  return Object;
}

apr_hash_index_t *GTMTLSMContext_removeDuplicatesFromChildrenMap(uint64_t a1)
{
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 16) = a1;
  *(_DWORD *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0;
  uint64_t result = apr_hash_next((apr_hash_index_t *)(a1 + 16));
  if (result)
  {
    uint64_t v2 = result;
    do
    {
      uint64_t v3 = *(void *)(*((void *)v2 + 1) + 32LL);
      size_t v4 = *(unsigned int *)(v3 + 12);
      if ((int)v4 >= 2)
      {
        qsort( *(void **)(v3 + 24),  v4,  *(int *)(v3 + 8),  (int (__cdecl *)(const void *, const void *))GTMTLSMObjectPtr_compare);
        uint64_t v5 = *(unsigned int *)(v3 + 12);
        if ((int)v5 < 2)
        {
          int v10 = 1;
        }

        else
        {
          int v6 = *(uint64_t **)(v3 + 24);
          uint64_t v7 = v6 + 1;
          uint64_t v8 = *v6;
          uint64_t v9 = v5 - 1;
          int v10 = 1;
          do
          {
            uint64_t v11 = v8;
            uint64_t v8 = *v7;
            if (*v7 != v11)
            {
              uint64_t v12 = v6[v10];
              v6[v10++] = v8;
              *uint64_t v7 = v12;
            }

            ++v7;
            --v9;
          }

          while (v9);
        }

        *(_DWORD *)(v3 + 12) = v10;
      }

      uint64_t result = apr_hash_next(v2);
      uint64_t v2 = result;
    }

    while (result);
  }

  return result;
}

uint64_t GTMTLSMObjectPtr_compare(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 != *a2;
  }
}

void GTMTLSMContext_buildResourceChildrenMap2(uint64_t *a1, uint64_t a2, unint64_t a3, apr_hash_t *a4)
{
  int v6 = *(apr_pool_t **)a4;
  uint64_t v7 = apr_array_make(*(apr_pool_t **)a2, 4, 8);
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v8 = v7;
    uint64_t v9 = 0LL;
    do
    {
      uint64_t v10 = *(void *)(*(void *)(a2 + 24) + 8 * v9);
      uint64_t v11 = *find_entry((uint64_t)a4, (_BYTE *)(v10 + 8), 8uLL, 0LL);
      if (!v11 || !*(void *)(v11 + 32))
      {
        v8->uint64_t nelts = 0;
        AddObjectAncestors(a1, (void *)v10, a3, v8);
        if (v8->nelts >= 2)
        {
          uint64_t v12 = 1LL;
          while (1)
          {
            uint64_t v13 = *(void *)&v8->elts[8 * v12];
            uint64_t v14 = *find_entry((uint64_t)a4, (_BYTE *)(v13 + 8), 8uLL, 0LL);
            if (v14)
            {
              uint64_t v15 = *(apr_array_header_t **)(v14 + 32);
              if (v15) {
                break;
              }
            }

            unsigned int v16 = apr_array_make(v6, 1, 8);
            *(void *)apr_array_push(v16) = v10;
            apr_hash_set(a4, (const void *)(v13 + 8), 8LL, v16);
            ++v12;
            uint64_t v10 = v13;
            if (v12 >= v8->nelts) {
              goto LABEL_12;
            }
          }

          *(void *)apr_array_push(v15) = v10;
        }
      }

void *AddObjectAncestors(uint64_t *a1, void *a2, unint64_t a3, apr_array_header_t *a4)
{
  while (1)
  {
    uint64_t result = apr_array_push(a4);
    void *result = a2;
    int v9 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 == 16)
    {
      uint64_t v10 = a2[18];
      if (v10)
      {
        uint64_t Object = GTMTLSMContext_getObject(a1, v10, a3);
        uint64_t result = (void *)AddObjectAncestors(a1, Object, a3, a4);
      }

      goto LABEL_7;
    }

    if (v9 != 80) {
      break;
    }
    uint64_t v12 = a2[17];
    if (!v12)
    {
      uint64_t v12 = a2[18];
      if (!v12) {
        goto LABEL_7;
      }
    }

apr_hash_index_t *GTMTLSMContext_buildResourceChildrenMap(uint64_t *a1, unint64_t a2, apr_pool_t **a3)
{
  int v6 = newpool;
  int v7 = *(_DWORD *)(a1[1] + 12);
  if (v7 <= *(_DWORD *)(a1[2] + 12)) {
    int v7 = *(_DWORD *)(a1[2] + 12);
  }
  if (v7 <= *(_DWORD *)(a1[9] + 12)) {
    int v8 = *(_DWORD *)(a1[9] + 12);
  }
  else {
    int v8 = v7;
  }
  int v9 = apr_array_make(newpool, v8, 8);
  GTMTLSMContext_getObjects((_DWORD *)a1[1], a2, v9);
  GTMTLSMContext_buildResourceChildrenMap2(a1, (uint64_t)v9, a2, (apr_hash_t *)a3);
  v9->uint64_t nelts = 0;
  GTMTLSMContext_getObjects((_DWORD *)a1[2], a2, v9);
  GTMTLSMContext_buildResourceChildrenMap2(a1, (uint64_t)v9, a2, (apr_hash_t *)a3);
  v9->uint64_t nelts = 0;
  GTMTLSMContext_getObjects((_DWORD *)a1[9], a2, v9);
  GTMTLSMContext_buildResourceChildrenMap2(a1, (uint64_t)v9, a2, (apr_hash_t *)a3);
  apr_pool_destroy(v6);
  return GTMTLSMContext_removeDuplicatesFromChildrenMap((uint64_t)a3);
}

void *GTMTLSMContext_buildLibraryFunctionsMap(uint64_t a1, unint64_t a2, apr_pool_t **a3)
{
  int v6 = *a3;
  apr_pool_create_ex(&newpool, *a3, 0LL, 0LL);
  int v7 = apr_array_make(newpool, *(_DWORD *)(*(void *)(a1 + 224) + 12LL), 8);
  uint64_t result = GTMTLSMContext_getObjects(*(_DWORD **)(a1 + 224), a2, v7);
  if (v7->nelts >= 1)
  {
    uint64_t v9 = 0LL;
    do
    {
      uint64_t v10 = *(void *)&v7->elts[8 * v9];
      uint64_t v11 = *find_entry((uint64_t)a3, (_BYTE *)(v10 + 40), 8uLL, 0LL);
      if (!v11 || (uint64_t v12 = *(apr_array_header_t **)(v11 + 32)) == 0LL)
      {
        uint64_t v12 = apr_array_make(v6, 1, 8);
        apr_hash_set((apr_hash_t *)a3, (const void *)(v10 + 40), 8LL, v12);
      }

      uint64_t result = apr_array_push(v12);
      void *result = v10;
      ++v9;
    }

    while (v9 < v7->nelts);
  }

  return result;
}

uint64_t GTMTLSMContext_maxCommandBufferCount(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 184);
  uint64_t v2 = *(unsigned int *)(v1 + 12);
  uint64_t v3 = *(uint64_t **)(v1 + 24);
  uint64_t result = 64LL;
  do
  {
    uint64_t v5 = *v3++;
    result += *(unsigned int *)(v5 + 64);
    --v2;
  }

  while (v2);
  return result;
}

void GTMTLSMContext_getTextureDescriptor(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, int *a5)
{
  *(void *)(a4 + 4_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  uint64_t Object = GTMTLSMContext_getObject(a1, a2, a3);
  if (!Object)
  {
    if (!a5) {
      return;
    }
    int v16 = *a5;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    int v29 = v16;
    int v30 = 500;
    uint64_t v17 = "texture != ((void *)0)";
    goto LABEL_14;
  }

  uint64_t v10 = Object;
  unint64_t v11 = Object[18];
  if (!v11)
  {
    unint64_t v18 = Object[13];
    if (v18)
    {
      __int128 v19 = *(_OWORD *)v18;
      __int128 v20 = *(_OWORD *)(v18 + 16);
      __int128 v21 = *(_OWORD *)(v18 + 32);
      *(void *)(a4 + 4_Block_object_dispose(va, 8) = *(void *)(v18 + 48);
      *(_OWORD *)(a4 + 16) = v20;
      *(_OWORD *)(a4 + 32) = v21;
      *(_OWORD *)a4 = v19;
      return;
    }

    uint64_t v22 = Object[24];
    if (v22)
    {
      *(_BYTE *)(a4 + 49) = 2;
      *(_BYTE *)(a4 + 47) = 1;
      *(_DWORD *)(a4 + 2_Block_object_dispose(va, 8) = 65537;
      *(_WORD *)(a4 + 44) = 257;
      *(_DWORD *)(a4 + 16) = 84148994;
      BOOL v23 = GTMTLSMContext_getObject(a1, v22, Object[2]);
      if (a5)
      {
        if (!v23)
        {
          int v28 = *a5;
          __int128 v32 = 0u;
          __int128 v33 = 0u;
          int v29 = v28;
          int v30 = 500;
          uint64_t v17 = "drawable != ((void *)0)";
          goto LABEL_14;
        }

        __int128 v24 = GTMTLSMContext_getObject(a1, v23[5], v23[2]);
        if (!v24)
        {
          int v25 = *a5;
          __int128 v32 = 0u;
          __int128 v33 = 0u;
          int v29 = v25;
          int v30 = 500;
          uint64_t v17 = "layer != ((void *)0)";
          goto LABEL_14;
        }
      }

      else
      {
        if (!v23) {
          return;
        }
        __int128 v24 = GTMTLSMContext_getObject(a1, v23[5], v23[2]);
        if (!v24) {
          return;
        }
      }

      *(_WORD *)(a4 + 34) = *((_WORD *)v24 + 136);
      *(_DWORD *)(a4 + 24) = (unint64_t)*((double *)v24 + 22);
      *(_WORD *)(a4 + 32) = (unint64_t)*((double *)v24 + 23);
      BOOL v27 = *((_BYTE *)v24 + 274) != 0;
      *(_BYTE *)(a4 + 43) = *((_BYTE *)v24 + 274);
      *(_DWORD *)(a4 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 4 * v27;
      return;
    }

    if (!a5) {
      return;
    }
    int v26 = *a5;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    int v29 = v26;
    int v30 = 500;
    uint64_t v17 = "0";
LABEL_14:
    int v31 = v17;
    GTError_addError(a5, (uint64_t)&v29);
    return;
  }

  GTMTLSMContext_getTextureDescriptor(a1, v11, a3, a4, a5);
  *(_WORD *)(a4 + 34) = *((_WORD *)v10 + 76);
  int v12 = *((unsigned __int8 *)v10 + 158);
  *(_BYTE *)(a4 + 49) = v12;
  if (*((_BYTE *)v10 + 160)) {
    *(_BYTE *)(a4 + 45) = *((_BYTE *)v10 + 160);
  }
  int v13 = *((_DWORD *)v10 + 52);
  if (v13 != -1) {
    *(_DWORD *)(a4 + 16) = v13;
  }
  unsigned int v14 = *((unsigned __int16 *)v10 + 78);
  if (*((_WORD *)v10 + 78))
  {
    if ((v12 - 5) > 1)
    {
      *(_WORD *)(a4 + 2_Block_object_dispose(va, 8) = v14;
    }

    else
    {
      int v15 = *((unsigned __int16 *)v10 + 78) / 6;
      if (v14 < 6) {
        LOWORD(v15) = 1;
      }
      *(_WORD *)(a4 + 2_Block_object_dispose(va, 8) = v15;
    }
  }

void *GTMTLSMContext_getTextureInfo(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  while (1)
  {
    uint64_t result = GTMTLSMContext_getObject(a1, a2, a3);
    if (!result) {
      break;
    }
    int v6 = result;
    uint64_t result = (void *)result[16];
    if (result) {
      break;
    }
    a2 = v6[18];
    if (!a2) {
      return 0LL;
    }
  }

  return result;
}

void *GTMTLSMContext_resourcesAllocated( void *result, unint64_t a2, uint64_t a3, apr_array_header_t *arr)
{
  int v6 = result;
  uint64_t v7 = 0LL;
  unint64_t v8 = a2 + a3;
  do
  {
    uint64_t v9 = v6[v7 + 1];
    int v10 = *(_DWORD *)(v9 + 12);
    if (v10 >= 1)
    {
      for (uint64_t i = 0LL; i < v10; ++i)
      {
        uint64_t v12 = *(void *)(*(void *)(v9 + 24) + 8 * i);
        unint64_t v13 = *(void *)(v12 + 16);
        if (a2 <= v13 && v8 > v13)
        {
          uint64_t result = apr_array_push(arr);
          void *result = v12;
          int v10 = *(_DWORD *)(v9 + 12);
        }
      }
    }

    ++v7;
  }

  while (v7 != 35);
  return result;
}

void *GTMTLSMContext_resourcesDeallocated( void *result, unint64_t a2, uint64_t a3, apr_array_header_t *arr)
{
  int v6 = result;
  uint64_t v7 = 0LL;
  unint64_t v8 = a2 + a3;
  do
  {
    uint64_t v9 = v6[v7 + 1];
    int v10 = *(_DWORD *)(v9 + 12);
    if (v10 >= 1)
    {
      for (uint64_t i = 0LL; i < v10; ++i)
      {
        uint64_t v12 = *(void *)(*(void *)(v9 + 24) + 8 * i);
        unint64_t v13 = *(void *)(v12 + 16);
        if (a2 > v13 || v8 <= v13)
        {
          unint64_t v15 = *(void *)(v12 + 24);
          if (a2 <= v15 && v8 > v15)
          {
            uint64_t result = apr_array_push(arr);
            void *result = v12;
            int v10 = *(_DWORD *)(v9 + 12);
          }
        }
      }
    }

    ++v7;
  }

  while (v7 != 35);
  return result;
}

uint64_t *GTMTLSMComputePipelineState_computePipelineDescriptor( uint64_t *result, uint64_t a2, void *a3, apr_pool_t *a4)
{
  int v6 = *(const void **)(a2 + 56);
  if (v6) {
    return (uint64_t *)memcpy(a3, v6, 0x3C0uLL);
  }
  if (*(void *)(a2 + 48))
  {
    uint64_t result = (uint64_t *)memcpy(a3, &GTMTLComputePipelineDescriptorDefaults, 0x3C0uLL);
    a3[106] = *(void *)(a2 + 48);
LABEL_5:
    a3[113] = *(void *)(a2 + 104);
    return result;
  }

  uint64_t v7 = *(void *)(a2 + 40);
  if (v7 && *(void *)(a2 + 184))
  {
    uint64_t v9 = result;
    uint64_t Object = GTMTLSMContext_getObject(result, v7, *(void *)(a2 + 16));
    uint64_t result = (uint64_t *)GTMTLSMComputePipelineState_computePipelineDescriptor(v9, Object, a3, a4);
    uint64_t v11 = **(void **)(a2 + 184);
    if (v11)
    {
      uint64_t v12 = a3[95] + v11;
      uint64_t result = (uint64_t *)apr_palloc(a4, 8 * v12);
      if (a3[95])
      {
        unint64_t v13 = 0LL;
        uint64_t v14 = a3[94];
        do
        {
          result[v13] = *(void *)(v14 + 8 * v13);
          ++v13;
        }

        while (a3[95] > v13);
      }

      unint64_t v15 = *(unint64_t **)(a2 + 184);
      if (*v15)
      {
        unint64_t v16 = 0LL;
        do
        {
          result[v16 + a3[95]] = v15[v16 + 1];
          ++v16;
        }

        while (*v15 > v16);
      }

      a3[94] = result;
      a3[95] = v12;
    }

    goto LABEL_5;
  }

  if (*(_DWORD *)(a2 + 4) == -16101)
  {
    uint64_t result = (uint64_t *)memcpy(a3, &GTMTLComputePipelineDescriptorDefaults, 0x3C0uLL);
    goto LABEL_5;
  }

  return result;
}

uint64_t GTMTLSMRenderPipelineState_renderPipelineDescriptorType(uint64_t *a1, void *a2)
{
  uint64_t v2 = a2;
  if (a1)
  {
    uint64_t v4 = a2[5];
    for (unint64_t i = v2[2]; ; unint64_t i = Object[2])
    {
      uint64_t Object = GTMTLSMContext_getObject(a1, v4, i);
      if (!Object || *(_DWORD *)Object != 71) {
        break;
      }
      uint64_t v2 = Object;
      uint64_t v4 = Object[5];
    }
  }

  if (v2[6]) {
    return 1LL;
  }
  if (v2[8]) {
    return 2LL;
  }
  if (v2[9]) {
    return 3LL;
  }
  return 0LL;
}

uint64_t *GTMTLSMRenderPipelineState_anyRenderPipelineDescriptor( uint64_t *a1, void *a2, _DWORD *a3, apr_pool_t *a4)
{
  uint64_t result = (uint64_t *)GTMTLSMRenderPipelineState_renderPipelineDescriptorType(a1, a2);
  *a3 = (_DWORD)result;
  switch((_DWORD)result)
  {
    case 3:
      uint64_t v9 = (const void *)a2[9];
      if (v9) {
        return (uint64_t *)memcpy(a3 + 2, v9, 0x200uLL);
      }
      break;
    case 2:
      return GTMTLSMRenderPipelineState_tilePipelineDescriptor(a1, a2, (uint64_t **)a3 + 1, a4);
    case 1:
      return (uint64_t *)GTMTLSMRenderPipelineState_renderPipelineDescriptor(a1, a2, (uint64_t)(a3 + 2), a4);
  }

  return result;
}

_DWORD *GTMTLSMRenderPipelineState_renderPipelineDescriptor( uint64_t *a1, void *a2, uint64_t a3, apr_pool_t *a4)
{
  int v6 = (const void *)a2[6];
  if (v6) {
    return memcpy((void *)a3, v6, 0x5E8uLL);
  }
  uint64_t result = GTMTLSMContext_getObject(a1, a2[5], a2[2]);
  if (result && *result == 71)
  {
    uint64_t result = (_DWORD *)GTMTLSMRenderPipelineState_renderPipelineDescriptor(a1, result, a3, a4);
    int v10 = (void *)a2[10];
    uint64_t v11 = v10[9];
    if (v11)
    {
      uint64_t v12 = (unsigned __int16)(*(_WORD *)(a3 + 1072) + v11);
      uint64_t result = apr_palloc(a4, 8 * v12);
      if (*(void *)(a3 + 1072))
      {
        unint64_t v13 = 0LL;
        uint64_t v14 = *(void *)(a3 + 1064);
        do
        {
          *(void *)&result[2 * v13] = *(void *)(v14 + 8 * v13);
          ++v13;
        }

        while (*(void *)(a3 + 1072) > v13);
      }

      int v10 = (void *)a2[10];
      if (v10[9])
      {
        unint64_t v15 = 0LL;
        uint64_t v16 = v10[8];
        do
        {
          *(void *)&result[2 * v15 + 2 * *(void *)(a3 + 1072)] = *(void *)(v16 + 8 * v15);
          ++v15;
        }

        while (v10[9] > v15);
      }

      *(void *)(a3 + 1064) = result;
      *(void *)(a3 + 1072) = v12;
    }

    uint64_t v17 = v10[1];
    if (v17)
    {
      uint64_t v18 = (unsigned __int16)(*(_DWORD *)(a3 + 880) + v17);
      uint64_t result = apr_palloc(a4, 8 * v18);
      if (*(void *)(a3 + 880))
      {
        unint64_t v19 = 0LL;
        uint64_t v20 = *(void *)(a3 + 872);
        do
        {
          *(void *)&result[2 * v19] = *(void *)(v20 + 8 * v19);
          ++v19;
        }

        while (*(void *)(a3 + 880) > v19);
      }

      __int128 v21 = (uint64_t *)a2[10];
      if (v21[1])
      {
        unint64_t v22 = 0LL;
        uint64_t v23 = *v21;
        do
        {
          *(void *)&result[2 * v22 + 2 * *(void *)(a3 + 880)] = *(void *)(v23 + 8 * v22);
          ++v22;
        }

        while (v21[1] > v22);
      }

      *(void *)(a3 + 872) = result;
      *(void *)(a3 + 88mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v18;
    }

    *(void *)(a3 + 128mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = a2[13];
  }

  return result;
}

uint64_t *GTMTLSMRenderPipelineState_tilePipelineDescriptor( uint64_t *result, void *a2, uint64_t **a3, apr_pool_t *a4)
{
  uint64_t v5 = (__int128 *)a2[8];
  if (v5)
  {
    __int128 v6 = *v5;
    __int128 v7 = v5[2];
    *((_OWORD *)a3 + 1) = v5[1];
    *((_OWORD *)a3 + 2) = v7;
    *(_OWORD *)a3 = v6;
    __int128 v8 = v5[3];
    __int128 v9 = v5[4];
    __int128 v10 = v5[6];
    *((_OWORD *)a3 + 5) = v5[5];
    *((_OWORD *)a3 + 6) = v10;
    *((_OWORD *)a3 + 3) = v8;
    *((_OWORD *)a3 + 4) = v9;
    __int128 v11 = v5[7];
    __int128 v12 = v5[8];
    __int128 v13 = v5[10];
    *((_OWORD *)a3 + 9) = v5[9];
    *((_OWORD *)a3 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v13;
    *((_OWORD *)a3 + 7) = v11;
    *((_OWORD *)a3 + _Block_object_dispose(va, 8) = v12;
  }

  else
  {
    uint64_t v16 = result;
    uint64_t result = GTMTLSMContext_getObject(result, a2[5], a2[2]);
    if (result && *(_DWORD *)result == 71)
    {
      GTMTLSMRenderPipelineState_tilePipelineDescriptor(v16, result, a3, a4);
      uint64_t v17 = (uint64_t *)(unsigned __int16)(*(_DWORD *)(a2[10] + 56LL) + *((_WORD *)a3 + 4));
      uint64_t result = (uint64_t *)apr_palloc(a4, 8LL * (void)v17);
      if (a3[1])
      {
        unint64_t v18 = 0LL;
        unint64_t v19 = *a3;
        do
        {
          result[v18] = v19[v18];
          ++v18;
        }

        while ((unint64_t)a3[1] > v18);
      }

      uint64_t v20 = a2[10];
      if (*(void *)(v20 + 56))
      {
        unint64_t v21 = 0LL;
        uint64_t v22 = *(void *)(v20 + 48);
        do
        {
          result[(void)a3[1] + v21] = *(void *)(v22 + 8 * v21);
          ++v21;
        }

        while (*(void *)(v20 + 56) > v21);
      }

      *a3 = result;
      a3[1] = v17;
    }
  }

  return result;
}

void *GTMTLSMRenderPipelineState_meshPipelineDescriptor(int a1, uint64_t a2, void *__dst)
{
  uint64_t v3 = *(const void **)(a2 + 72);
  if (v3) {
    return memcpy(__dst, v3, 0x200uLL);
  }
  return result;
}

uint64_t GTMTLSMRenderPipelineState_fragmentFunction(uint64_t *a1, void *a2)
{
  if (a2[11]) {
    return 0LL;
  }
  uint64_t Object = a2;
  while (1)
  {
    uint64_t v5 = Object[6];
    if (v5)
    {
      uint64_t v7 = v5 + 1176;
      return *(void *)v7;
    }

    uint64_t v6 = Object[9];
    if (v6) {
      break;
    }
    uint64_t Object = GTMTLSMContext_getObject(a1, Object[5], Object[2]);
    if (Object[11]) {
      return 0LL;
    }
  }

  uint64_t v7 = v6 + 344;
  return *(void *)v7;
}

uint64_t GTMTLSMComputePipelineState_computeFunction(uint64_t *a1, void *a2)
{
  uint64_t result = a2[6];
  if (!result)
  {
    uint64_t Object = a2;
    while (1)
    {
      uint64_t v5 = Object[7];
      if (v5) {
        break;
      }
      uint64_t Object = GTMTLSMContext_getObject(a1, Object[5], Object[2]);
      uint64_t result = Object[6];
      if (result) {
        return result;
      }
    }

    return *(void *)(v5 + 848);
  }

  return result;
}

void *GTMTLSMPipelineState_isVisibleFunctionTableCompatible(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  if (*(void *)(a3 + 128) != v3)
  {
    uint64_t v6 = a2;
    while (*(void *)(a3 + 120) != v3)
    {
      if (*(_DWORD *)v6 == 29)
      {
        uint64_t result = GTMTLSMContext_getObject(a1, v6[5], v6[2]);
        if (!result) {
          return result;
        }
        uint64_t v6 = result;
        if (*(_DWORD *)result != 29) {
          return 0LL;
        }
      }

      else
      {
        if (*(_DWORD *)v6 != 71) {
          return 0LL;
        }
        uint64_t result = GTMTLSMContext_getObject(a1, v6[5], v6[2]);
        if (!result) {
          return result;
        }
        uint64_t v6 = result;
        if (*(_DWORD *)result != 71) {
          return 0LL;
        }
      }

      uint64_t v3 = v6[1];
      if (*(void *)(a3 + 128) == v3) {
        return (void *)(&dword_0 + 1);
      }
    }
  }

  return (void *)(&dword_0 + 1);
}

void *GTMTLSMPipelineState_isIntersectionFunctionTableCompatible(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  if (*(void *)(a3 + 128) != v3)
  {
    uint64_t v6 = a2;
    while (*(void *)(a3 + 120) != v3)
    {
      if (*(_DWORD *)v6 == 29)
      {
        uint64_t result = GTMTLSMContext_getObject(a1, v6[5], v6[2]);
        if (!result) {
          return result;
        }
        uint64_t v6 = result;
        if (*(_DWORD *)result != 29) {
          return 0LL;
        }
      }

      else
      {
        if (*(_DWORD *)v6 != 71) {
          return 0LL;
        }
        uint64_t result = GTMTLSMContext_getObject(a1, v6[5], v6[2]);
        if (!result) {
          return result;
        }
        uint64_t v6 = result;
        if (*(_DWORD *)result != 71) {
          return 0LL;
        }
      }

      uint64_t v3 = v6[1];
      if (*(void *)(a3 + 128) == v3) {
        return (void *)(&dword_0 + 1);
      }
    }
  }

  return (void *)(&dword_0 + 1);
}

BOOL GTMTLSMPipelineState_supportsIndirectCommandBuffers(uint64_t a1)
{
  if (*(_DWORD *)a1 == 29)
  {
    uint64_t v3 = *(void *)(a1 + 56);
    if (v3)
    {
      int v2 = *(unsigned __int8 *)(v3 + 956);
      return v2 != 0;
    }
  }

  else if (*(_DWORD *)a1 == 71)
  {
    uint64_t v1 = *(void *)(a1 + 48);
    if (v1)
    {
      int v2 = *(unsigned __int8 *)(v1 + 1499);
      return v2 != 0;
    }

    uint64_t v4 = *(void *)(a1 + 72);
    if (v4)
    {
      int v2 = *(unsigned __int8 *)(v4 + 510);
      return v2 != 0;
    }
  }

  return 0LL;
}

uint64_t GTMTLSMObject_sortUsedResources(uint64_t *a1, int a2, uint64_t a3)
{
  if (a2 < 1) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  uint64_t v6 = a2;
  uint64_t v7 = a1;
  do
  {
    uint64_t v8 = *v7;
    if (*v7) {
      uint64_t v8 = *(void *)(v8 + 8);
    }
    uint64_t v12 = v8;
    entry = find_entry(a3, &v12, 8uLL, 0LL);
    if (*entry && *(void *)(*entry + 32LL))
    {
      uint64_t v10 = *v7;
      *uint64_t v7 = a1[(int)v5];
      a1[(int)v5] = v10;
      uint64_t v5 = (v5 + 1);
    }

    ++v7;
    --v6;
  }

  while (v6);
  return v5;
}

uint64_t GTMTLSMSamplerState_sortIndirectResources(uint64_t *a1, int a2)
{
  if (a2 < 1) {
    return 0LL;
  }
  uint64_t v2 = 0LL;
  uint64_t v3 = a2;
  uint64_t v4 = a1;
  do
  {
    uint64_t v5 = *v4;
    if (*(_BYTE *)(*(void *)(*v4 + 48) + 62LL))
    {
      *uint64_t v4 = a1[(int)v2];
      a1[(int)v2] = v5;
      uint64_t v2 = (v2 + 1);
    }

    ++v4;
    --v3;
  }

  while (v3);
  return v2;
}

uint64_t GTMTLSMPipelineState_sortIndirectResources(uint64_t *a1, int a2)
{
  if (a2 < 1) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  do
  {
    uint64_t v6 = *v5;
    if (GTMTLSMPipelineState_supportsIndirectCommandBuffers(*v5))
    {
      uint64_t *v5 = a1[(int)v3];
      a1[(int)v3] = v6;
      uint64_t v3 = (v3 + 1);
    }

    ++v5;
    --v4;
  }

  while (v4);
  return v3;
}

apr_array_header_t *GTMTLSMBuffer_gpuAddressArray(uint64_t *a1, int a2, apr_pool_t *p)
{
  LODWORD(v3) = a2;
  uint64_t v5 = apr_array_make(p, a2, 24);
  if ((int)v3 >= 1)
  {
    uint64_t v3 = v3;
    do
    {
      uint64_t v6 = *a1++;
      uint64_t v7 = (int8x16_t *)apr_array_push(v5);
      *uint64_t v7 = vextq_s8(*(int8x16_t *)(v6 + 104), *(int8x16_t *)(v6 + 104), 8uLL);
      v7[1].i64[0] = *(void *)(v6 + 8);
      --v3;
    }

    while (v3);
  }

  qsort(v5->elts, v5->nelts, v5->elt_size, (int (__cdecl *)(const void *, const void *))GTMTLGPUAddressResource_compare);
  return v5;
}

apr_array_header_t *GTMTLSMTexture_uniqueIdentifierArray(void *a1, int a2, apr_pool_t *p)
{
  LODWORD(v3) = a2;
  uint64_t v5 = apr_array_make(p, a2, 32);
  if ((int)v3 >= 1)
  {
    uint64_t v3 = v3;
    do
    {
      uint64_t v6 = (void *)*a1++;
      uint64_t v7 = apr_array_push(v5);
      uint64_t v8 = v6[1];
      *uint64_t v7 = v6[21];
      v7[1] = v8;
      v7[2] = v6[25];
      --v3;
    }

    while (v3);
  }

  return v5;
}

apr_array_header_t *GTMTLSMSamplerState_uniqueIdentifierArray(void *a1, int a2, apr_pool_t *p)
{
  LODWORD(v3) = a2;
  uint64_t v5 = apr_array_make(p, a2, 32);
  if ((int)v3 >= 1)
  {
    uint64_t v3 = v3;
    do
    {
      uint64_t v6 = (void *)*a1++;
      uint64_t v7 = apr_array_push(v5);
      uint64_t v8 = v6[1];
      uint64_t v9 = v6[9];
      *uint64_t v7 = v6[8];
      v7[1] = v8;
      v7[2] = v9;
      --v3;
    }

    while (v3);
  }

  return v5;
}

apr_array_header_t *GTMTLSMRenderPipelineState_uniqueIdentifierArray(void *a1, int a2, apr_pool_t *p)
{
  LODWORD(v3) = a2;
  uint64_t v5 = apr_array_make(p, a2, 32);
  if ((int)v3 >= 1)
  {
    uint64_t v3 = v3;
    do
    {
      uint64_t v6 = (void *)*a1++;
      uint64_t v7 = apr_array_push(v5);
      uint64_t v8 = v6[1];
      *uint64_t v7 = v6[12];
      v7[1] = v8;
      v7[2] = v6[14];
      --v3;
    }

    while (v3);
  }

  return v5;
}

apr_array_header_t *GTMTLSMComputePipelineState_uniqueIdentifierArray(void *a1, int a2, apr_pool_t *p)
{
  LODWORD(v3) = a2;
  uint64_t v5 = apr_array_make(p, a2, 32);
  if ((int)v3 >= 1)
  {
    uint64_t v3 = v3;
    do
    {
      uint64_t v6 = (void *)*a1++;
      uint64_t v7 = apr_array_push(v5);
      uint64_t v8 = v6[1];
      *uint64_t v7 = v6[12];
      v7[1] = v8;
      v7[2] = v6[14];
      --v3;
    }

    while (v3);
  }

  return v5;
}

apr_array_header_t *GTMTLSMIndirectCommandBuffer_uniqueIdentifierArray(void *a1, int a2, apr_pool_t *p)
{
  LODWORD(v3) = a2;
  uint64_t v5 = apr_array_make(p, a2, 32);
  if ((int)v3 >= 1)
  {
    uint64_t v3 = v3;
    do
    {
      uint64_t v6 = (void *)*a1++;
      uint64_t v7 = apr_array_push(v5);
      uint64_t v8 = v6[1];
      uint64_t v9 = v6[16];
      *uint64_t v7 = v6[15];
      v7[1] = v8;
      v7[2] = v9;
      --v3;
    }

    while (v3);
  }

  return v5;
}

void GTMTLSMContext_indirectCommandBufferResources( apr_pool_t *p@<X2>, _DWORD **a2@<X0>, unint64_t a3@<X1>, uint64_t a4@<X8>)
{
  uint64_t v8 = apr_array_make(p, 128, 8);
  GTMTLSMContext_getObjects(a2[1], a3, v8);
  uint64_t v9 = GTMTLSMBuffer_gpuAddressArray((uint64_t *)v8->elts, v8->nelts, p);
  *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a4 + 16) = 0LL;
  *(void *)a4 = v9;
  uint64_t v10 = apr_hash_make(p);
  *(void *)(a4 + 24) = v10;
  __int128 v11 = apr_hash_make(p);
  *(void *)(a4 + 32) = v11;
  *(_OWORD *)(a4 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a4 + 56) = 0u;
  *(_OWORD *)(a4 + 72) = 0u;
  v8->uint64_t nelts = 0;
  GTMTLSMContext_getObjects(a2[4], a3, v8);
  uint64_t elts = (uint64_t *)v8->elts;
  int v13 = GTMTLSMPipelineState_sortIndirectResources(elts, v8->nelts);
  v8->uint64_t nelts = v13;
  uint64_t v14 = GTMTLSMRenderPipelineState_uniqueIdentifierArray(elts, v13, p);
  uint64_t nelts = v14->nelts;
  if ((int)nelts >= 1)
  {
    uint64_t v16 = v14->elts;
    do
    {
      apr_hash_set(v10, v16, 8LL, v16);
      v16 += 32;
      --nelts;
    }

    while (nelts);
  }

  v8->uint64_t nelts = 0;
  GTMTLSMContext_getObjects(a2[5], a3, v8);
  uint64_t v17 = (uint64_t *)v8->elts;
  int v18 = GTMTLSMPipelineState_sortIndirectResources(v17, v8->nelts);
  v8->uint64_t nelts = v18;
  unint64_t v19 = GTMTLSMComputePipelineState_uniqueIdentifierArray(v17, v18, p);
  uint64_t v20 = v19->nelts;
  if ((int)v20 >= 1)
  {
    unint64_t v21 = v19->elts;
    do
    {
      apr_hash_set(v11, v21, 8LL, v21);
      v21 += 32;
      --v20;
    }

    while (v20);
  }

apr_array_header_t *GTMTLSMContext_intersectionFunctionTableBufferResources( uint64_t *a1, int a2, uint64_t *a3, int a4, apr_pool_t *p)
{
  LODWORD(v5) = a4;
  LODWORD(v7) = a2;
  uint64_t v9 = apr_array_make(p, a4 + a2, 24);
  if ((int)v7 >= 1)
  {
    uint64_t v7 = v7;
    do
    {
      uint64_t v10 = *a1++;
      __int128 v11 = (int8x16_t *)apr_array_push(v9);
      *__int128 v11 = vextq_s8(*(int8x16_t *)(v10 + 104), *(int8x16_t *)(v10 + 104), 8uLL);
      v11[1].i64[0] = *(void *)(v10 + 8);
      --v7;
    }

    while (v7);
  }

  if ((int)v5 >= 1)
  {
    uint64_t v5 = v5;
    do
    {
      uint64_t v12 = *a3++;
      int v13 = apr_array_push(v9);
      *int v13 = *(void *)(v12 + 160);
      v13[1] = 8LL;
      void v13[2] = *(void *)(v12 + 8);
      --v5;
    }

    while (v5);
  }

  return v9;
}

void GTMTLSMContext_getHeapResourcesWithType( uint64_t a1, uint64_t a2, unint64_t a3, int a4, apr_array_header_t *a5, apr_pool_t *parent)
{
  if (a4 == 16 || a4 == 80 || a4 == 22)
  {
    newpool = 0LL;
    apr_pool_create_ex(&newpool, parent, 0LL, 0LL);
    __int128 v11 = 0LL;
    if ((a4 - 2) <= 0x51)
    {
      if (byte_1C2D54[a4 - 2] < 0) {
        __int128 v11 = 0LL;
      }
      else {
        __int128 v11 = *(_DWORD **)(a1 + 8LL * byte_1C2D54[a4 - 2] + 8);
      }
    }

    uint64_t v12 = newpool;
    int v13 = apr_array_make(newpool, 128, 8);
    GTMTLSMContext_getObjects(v11, a3, v13);
    int nelts = v13->nelts;
    if (nelts)
    {
      for (unint64_t i = 0LL; i < nelts; ++i)
      {
        uint64_t v16 = *(void *)&v13->elts[8 * i];
        if (*(void *)(v16 + 48) == a2)
        {
          *(void *)apr_array_push(a5) = v16;
          int nelts = v13->nelts;
        }
      }
    }

    apr_pool_destroy(v12);
  }

void GTMTLSMContext_getHeapTextures( uint64_t a1, uint64_t a2, unint64_t a3, apr_array_header_t *a4, apr_pool_t *parent)
{
}

void GTMTLSMContext_getHeapBuffers( uint64_t a1, uint64_t a2, unint64_t a3, apr_array_header_t *a4, apr_pool_t *parent)
{
}

void GTMTLSMContext_getHeapAccelerationStructures( uint64_t a1, uint64_t a2, unint64_t a3, apr_array_header_t *a4, apr_pool_t *parent)
{
}

BOOL GTMTLSMContext_hasArgumentBuffers(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[4];
  uint64_t v5 = *(unsigned int *)(v4 + 12);
  if ((int)v5 >= 1)
  {
    uint64_t v6 = *(void *)(v4 + 24);
    do
    {
      uint64_t v7 = *(void **)v6;
      if (*(void *)(*(void *)v6 + 168LL) || v7[28] || v7[35] || v7[42] || v7[49]) {
        return 1LL;
      }
      v6 += 8LL;
    }

    while (--v5);
  }

  uint64_t v8 = a1[5];
  uint64_t v9 = *(unsigned int *)(v8 + 12);
  if ((int)v9 >= 1)
  {
    uint64_t v10 = *(void *)(v8 + 24);
    while (!*(void *)(*(void *)v10 + 168LL))
    {
      v10 += 8LL;
      if (!--v9) {
        goto LABEL_15;
      }
    }

    return 1LL;
  }

uint64_t DumpResourceToStateMirrorType(int a1)
{
  else {
    return dword_1C2CC0[a1 + 1];
  }
}

uint64_t StateMirrorToDumpResourceType(int a1)
{
  else {
    return byte_1C2D54[a1 - 2];
  }
}

char *GTMTLSMIOCommandBuffer_processTraceFunc(char *result, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a2 + 2);
  switch(v5)
  {
    case -15343:
      *((void *)result + 3) = *a2;
      break;
    case -15313:
      uint64_t v9 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
      BOOL result = GTTraceFunc_argumentBytesWithMap(a2, v9[8], a3);
      *((void *)v4 + 7) = result;
      break;
    case -15333:
      BOOL result = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
      *(_OWORD *)uint64_t v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
      *((_OWORD *)v4 + 2) = 0u;
      *((_OWORD *)v4 + 3) = 0u;
      *((_OWORD *)v4 + 4) = 0u;
      uint64_t v7 = *((void *)result + 1);
      if (v7)
      {
        *(_DWORD *)uint64_t v4 = 51;
        uint64_t v8 = *a2;
        *((void *)v4 + 1) = v7;
        *((void *)v4 + 2) = v8;
        *((void *)v4 + 3) = -1LL;
        v4[73] = 1;
        *((void *)v4 + 6) = *(void *)result;
      }

      break;
  }

  return result;
}

char *GTMTLSMCommandBuffer_processTraceFunc(char *result, uint64_t *a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *((_DWORD *)a2 + 2);
  if (v6 > -16203)
  {
    if (v6 <= -15702)
    {
      BOOL v9 = v6 == -16202;
      int v10 = -15908;
    }

    else
    {
      if (v6 == -15701)
      {
        BOOL result = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(_OWORD *)int v5 = 0u;
        *((_OWORD *)v5 + 1) = 0u;
        *((_OWORD *)v5 + 2) = 0u;
        *((_OWORD *)v5 + 3) = 0u;
        *((_OWORD *)v5 + 4) = 0u;
        uint64_t v14 = *((void *)result + 1);
        if (v14)
        {
          *(_DWORD *)int v5 = 25;
          uint64_t v15 = *a2;
          *((void *)v5 + 1) = v14;
          *((void *)v5 + 2) = v15;
          *((void *)v5 + 3) = -1LL;
          *((void *)v5 + 6) = *(void *)result;
          BOOL result = GTTraceFunc_argumentBytesWithMap(a2, result[16], a3);
          *((void *)v5 + _Block_object_dispose(va, 8) = result;
          if (result) {
            v5[73] = result[9];
          }
        }

        return result;
      }

      BOOL v9 = v6 == -15318;
      int v10 = -15316;
    }

    if (!v9 && v6 != v10) {
      return result;
    }
LABEL_20:
    *((void *)result + 3) = *a2;
    return result;
  }

  if (v6 <= -16362)
  {
    if (v6 == -16365)
    {
      uint64_t v16 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
      BOOL result = GTTraceFunc_argumentBytesWithMap(a2, v16[8], a3);
      *((void *)v5 + 7) = result;
    }

    else if (v6 == -16364)
    {
      BOOL result = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
      v5[72] = *((_DWORD *)result + 2);
    }

    return result;
  }

  switch(v6)
  {
    case -16361:
      goto LABEL_20;
    case -16343:
      BOOL result = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
      *(_OWORD *)int v5 = 0u;
      *((_OWORD *)v5 + 1) = 0u;
      *((_OWORD *)v5 + 2) = 0u;
      *((_OWORD *)v5 + 3) = 0u;
      *((_OWORD *)v5 + 4) = 0u;
      uint64_t v12 = *((void *)result + 1);
      if (v12)
      {
        *(_DWORD *)int v5 = 25;
        uint64_t v13 = *a2;
        *((void *)v5 + 1) = v12;
        *((void *)v5 + 2) = v13;
        *((void *)v5 + 3) = -1LL;
        v5[73] = 1;
        goto LABEL_24;
      }

      break;
    case -16342:
      BOOL result = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
      *(_OWORD *)int v5 = 0u;
      *((_OWORD *)v5 + 1) = 0u;
      *((_OWORD *)v5 + 2) = 0u;
      *((_OWORD *)v5 + 3) = 0u;
      *((_OWORD *)v5 + 4) = 0u;
      uint64_t v7 = *((void *)result + 1);
      if (v7)
      {
        *(_DWORD *)int v5 = 25;
        uint64_t v8 = *a2;
        *((void *)v5 + 1) = v7;
        *((void *)v5 + 2) = v8;
        *((void *)v5 + 3) = -1LL;
LABEL_24:
        *((void *)v5 + 6) = *(void *)result;
      }

      break;
  }

  return result;
}

void GTMTLSMCommandEncoder_processTraceFunc(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 8616;
  int v7 = *((_DWORD *)a2 + 2);
  if (v7 <= -16088)
  {
    if (v7 <= -16163)
    {
      switch(v7)
      {
        case -16354:
          uint64_t v12 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          bzero((void *)a1, 0x2B90uLL);
          uint64_t v13 = *((void *)v12 + 1);
          if (!v13) {
            return;
          }
          int v14 = 21;
          goto LABEL_433;
        case -16353:
          uint64_t v239 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          bzero((void *)a1, 0x2B90uLL);
          uint64_t v240 = *((void *)v239 + 1);
          if (!v240) {
            return;
          }
          *(_DWORD *)a1 = 70;
          uint64_t v241 = *a2;
          *(void *)(a1 + _Block_object_dispose(va, 8) = v240;
          *(void *)(a1 + 16) = v241;
          *(void *)(a1 + 24) = -1LL;
          *(void *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)v239;
          uint64_t v242 = GTTraceFunc_argumentBytesWithMap(a2, v239[16], a3);
          uint64_t v243 = a1 + 56;
          goto LABEL_276;
        case -16352:
          id v244 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          bzero((void *)a1, 0x2B90uLL);
          uint64_t v245 = *((void *)v244 + 1);
          if (v245)
          {
            *(_DWORD *)a1 = 28;
            uint64_t v246 = *a2;
            *(void *)(a1 + _Block_object_dispose(va, 8) = v245;
            *(void *)(a1 + 16) = v246;
            *(void *)(a1 + 24) = -1LL;
            *(void *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)v244;
            bzero((void *)(a1 + 56), 0x888uLL);
            memset_pattern16((void *)(a1 + 2240), &unk_1CA4F0, 0x100uLL);
            *(void *)(a1 + 824) = -1LL;
            *(void *)&__int128 v247 = -1LL;
            *((void *)&v247 + 1) = -1LL;
            *(_OWORD *)(a1 + 792) = v247;
            *(_OWORD *)(a1 + 80_Block_object_dispose(va, 8) = v247;
            *(_OWORD *)(a1 + 76mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v247;
            *(_OWORD *)(a1 + 776) = v247;
            *(_OWORD *)(a1 + 72_Block_object_dispose(va, 8) = v247;
            *(_OWORD *)(a1 + 744) = v247;
            *(_OWORD *)(a1 + 696) = v247;
            *(_OWORD *)(a1 + 712) = v247;
            *(_OWORD *)(a1 + 664) = v247;
            *(_OWORD *)(a1 + 68mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v247;
            *(_OWORD *)(a1 + 632) = v247;
            *(_OWORD *)(a1 + 64_Block_object_dispose(va, 8) = v247;
            *(_OWORD *)(a1 + 60mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v247;
            *(_OWORD *)(a1 + 616) = v247;
            *(_OWORD *)(a1 + 584) = v247;
            *(_BYTE *)(a1 + 2304) = -1;
          }

          return;
        case -16351:
          int v248 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          bzero((void *)a1, 0x2B90uLL);
          uint64_t v249 = *((void *)v248 + 1);
          if (v249)
          {
            *(_DWORD *)a1 = 65;
            uint64_t v250 = *a2;
            *(void *)(a1 + _Block_object_dispose(va, 8) = v249;
            *(void *)(a1 + 16) = v250;
            *(void *)(a1 + 24) = -1LL;
            *(void *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)v248;
            id v251 = GTTraceFunc_argumentBytesWithMap(a2, v248[16], a3);
            *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = 0u;
            *(_OWORD *)(a1 + 144) = 0u;
            *(_OWORD *)(a1 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
            *(_OWORD *)(a1 + 176) = 0u;
            *(void *)(a1 + 192) = 0LL;
            *(void *)(a1 + 56) = v251;
            memset_pattern16((void *)(a1 + 64), &unk_1CA500, 0x40uLL);
            *(_WORD *)(a1 + 192) = 1028;
          }

          return;
        case -16350:
        case -16349:
        case -16348:
        case -16347:
        case -16346:
        case -16345:
        case -16344:
        case -16343:
        case -16342:
        case -16341:
        case -16340:
        case -16338:
        case -16327:
        case -16326:
        case -16324:
        case -16323:
        case -16322:
        case -16321:
        case -16320:
        case -16319:
        case -16318:
        case -16317:
        case -16316:
        case -16315:
        case -16314:
        case -16313:
        case -16312:
        case -16311:
        case -16310:
        case -16309:
        case -16308:
        case -16307:
        case -16306:
        case -16305:
        case -16304:
        case -16303:
        case -16302:
        case -16301:
        case -16300:
        case -16299:
        case -16298:
        case -16297:
        case -16296:
        case -16295:
        case -16294:
        case -16293:
        case -16292:
        case -16291:
        case -16290:
        case -16289:
        case -16287:
        case -16284:
        case -16283:
        case -16282:
        case -16280:
        case -16251:
        case -16250:
        case -16249:
        case -16248:
        case -16245:
        case -16244:
        case -16243:
        case -16242:
        case -16241:
        case -16240:
        case -16239:
        case -16238:
        case -16237:
        case -16236:
        case -16235:
        case -16234:
        case -16233:
        case -16232:
        case -16231:
        case -16230:
        case -16229:
        case -16228:
        case -16221:
        case -16220:
        case -16218:
        case -16217:
        case -16216:
        case -16215:
          return;
        case -16339:
        case -16288:
        case -16281:
          goto LABEL_54;
        case -16337:
          *(void *)(a1 + 64) = *((void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3) + 1);
          return;
        case -16336:
          uint64_t v252 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v253 = *((void *)v252 + 3);
          uint64_t v254 = 1LL << v253;
          uint64_t v255 = a1 + 8LL * (int)(v253 >> 6);
          *(void *)(v255 + 72) &= ~v254;
          *(void *)(a1 + 80 + 8LL * *((void *)v252 + 3) + _Block_object_dispose(va, 8) = *((void *)v252 + 1);
          *(void *)(a1 + 80 + 8LL * (int)(*((void *)v252 + 3) >> 6)) &= ~(1LL << *((void *)v252 + 3));
          *(void *)(a1 + 80 + 8LL * *((void *)v252 + 3) + 256) = *((void *)v252 + 2);
          return;
        case -16335:
          uint64_t v256 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          BOOL v27 = v256;
          unint64_t v257 = *((void *)v256 + 1);
          unint64_t v258 = *((void *)v256 + 2) + v257;
          unint64_t v259 = 64LL;
          if (v258 >= 0x40) {
            unint64_t v258 = 64LL;
          }
          char v260 = v258 - v257;
          if (v258 < v257) {
            char v260 = 0;
          }
          uint64_t v261 = ~(-1LL << v260);
          if (v257 <= v258) {
            char v262 = v257 & 0x3F;
          }
          else {
            char v262 = 0;
          }
          __int128 v264 = (uint64_t *)(a1 + 80);
          uint64_t v263 = *(void *)(a1 + 80);
          *(void *)(a1 + 72) &= ~(v261 << v262);
          unint64_t v265 = *((void *)v256 + 1);
          if (*((void *)v256 + 2) + v265 < 0x40) {
            unint64_t v259 = *((void *)v256 + 2) + v265;
          }
          char v266 = v259 - v265;
          if (v259 < v265) {
            char v266 = 0;
          }
          uint64_t v267 = ~(-1LL << v266);
          if (v265 <= v259) {
            char v268 = v265 & 0x3F;
          }
          else {
            char v268 = 0;
          }
          *__int128 v264 = v263 & ~(v267 << v268);
          uint64_t v269 = *((void *)v256 + 1);
          __int128 v270 = GTTraceFunc_argumentBytesWithMap(a2, v256[24], a3);
          if ((int)*((void *)v27 + 2) >= 1)
          {
            __int128 v271 = &v264[v269 + 1];
            uint64_t v272 = *((void *)v27 + 2);
            do
            {
              uint64_t v273 = *(void *)v270;
              v270 += 8;
              *v271++ = v273;
              --v272;
            }

            while (v272);
          }

          uint64_t v162 = a1 + 8LL * *((void *)v27 + 1) + 336;
          goto LABEL_352;
        case -16334:
          __int128 v274 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v274 + 2) + 832) = *((void *)v274 + 1);
          return;
        case -16333:
          __int128 v275 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          __int128 v276 = v275;
          unint64_t v277 = *((void *)v275 + 1);
          unint64_t v278 = *((void *)v275 + 2) + v277;
          if (v278 >= 0x40) {
            unint64_t v278 = 64LL;
          }
          char v279 = v278 - v277;
          if (v278 < v277) {
            char v279 = 0;
          }
          uint64_t v280 = ~(-1LL << v279);
          if (v277 <= v278) {
            char v281 = v277 & 0x3F;
          }
          else {
            char v281 = 0;
          }
          *(void *)(a1 + 80) &= ~(v280 << v281);
          uint64_t v282 = *((void *)v275 + 1);
          uint64_t v283 = GTTraceFunc_argumentBytesWithMap(a2, v275[24], a3);
          if ((int)*((void *)v276 + 2) >= 1)
          {
            uint64_t v284 = (void *)(a1 + 8 * v282 + 832);
            uint64_t v285 = *((void *)v276 + 2);
            do
            {
              uint64_t v286 = *(void *)v283;
              v283 += 8;
              *v284++ = v286;
              --v285;
            }

            while (v285);
          }

          return;
        case -16332:
          uint64_t v287 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v287 + 2) + 1856) = *((void *)v287 + 1);
          return;
        case -16331:
          int v288 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          v289 = v288;
          unint64_t v290 = *((void *)v288 + 1);
          unint64_t v291 = *((void *)v288 + 2) + v290;
          if (v291 >= 0x40) {
            unint64_t v291 = 64LL;
          }
          char v292 = v291 - v290;
          if (v291 < v290) {
            char v292 = 0;
          }
          uint64_t v293 = ~(-1LL << v292);
          if (v290 <= v291) {
            char v294 = v290 & 0x3F;
          }
          else {
            char v294 = 0;
          }
          *(void *)(a1 + 80) &= ~(v293 << v294);
          uint64_t v295 = *((void *)v288 + 1);
          v296 = GTTraceFunc_argumentBytesWithMap(a2, v288[24], a3);
          if ((int)*((void *)v289 + 2) >= 1)
          {
            uint64_t v297 = (void *)(a1 + 8 * v295 + 1856);
            uint64_t v298 = *((void *)v289 + 2);
            do
            {
              uint64_t v299 = *(void *)v296;
              v296 += 8;
              *v297++ = v299;
              --v298;
            }

            while (v298);
          }

          return;
        case -16330:
          uint64_t v300 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v300 + 2) + 1856) = *((void *)v300 + 1);
          *(_DWORD *)(a1 + 1984 + 4LL * *((void *)v300 + 2) + 192) = *((_DWORD *)v300 + 6);
          *(_DWORD *)(a1 + 1984 + 4LL * *((void *)v300 + 2) + 256) = *((_DWORD *)v300 + 7);
          return;
        case -16329:
          v301 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          id v171 = v301;
          unint64_t v302 = *((void *)v301 + 1);
          unint64_t v303 = *((void *)v301 + 2) + v302;
          if (v303 >= 0x40) {
            unint64_t v303 = 64LL;
          }
          char v304 = v303 - v302;
          if (v303 < v302) {
            char v304 = 0;
          }
          uint64_t v305 = ~(-1LL << v304);
          if (v302 <= v303) {
            char v306 = v302 & 0x3F;
          }
          else {
            char v306 = 0;
          }
          *(void *)(a1 + 80) &= ~(v305 << v306);
          uint64_t v307 = *((void *)v301 + 1);
          uint64_t v308 = GTTraceFunc_argumentBytesWithMap(a2, v301[24], a3);
          if ((int)*((void *)v171 + 2) >= 1)
          {
            uint64_t v309 = (void *)(a1 + 8 * v307 + 1856);
            uint64_t v310 = *((void *)v171 + 2);
            do
            {
              uint64_t v311 = *(void *)v308;
              v308 += 8;
              *v309++ = v311;
              --v310;
            }

            while (v310);
          }

          uint64_t v312 = a1 + 1984;
          uint64_t v313 = (void *)(a1 + 1984 + 4LL * *((void *)v171 + 1) + 192);
          v314 = GTTraceFunc_argumentBytesWithMap(a2, v171[25], a3);
          memcpy(v313, v314, 4LL * *((void *)v171 + 2));
          uint64_t v162 = v312 + 4LL * *((void *)v171 + 1) + 256;
          goto LABEL_512;
        case -16328:
          uint64_t v315 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(_DWORD *)(a1 + 4LL * *((void *)v315 + 2) + 204mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v315 + 1);
          return;
        case -16325:
        case -16285:
        case -16246:
          goto LABEL_65;
        case -16286:
          uint64_t v316 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          bzero((void *)a1, 0x2B90uLL);
          uint64_t v317 = *((void *)v316 + 1);
          if (!v317) {
            return;
          }
          *(_DWORD *)a1 = 70;
          uint64_t v318 = *a2;
          *(void *)(a1 + _Block_object_dispose(va, 8) = v317;
          *(void *)(a1 + 16) = v318;
          *(void *)(a1 + 24) = -1LL;
          *(void *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)v316;
          uint64_t v243 = a1 + 56;
          uint64_t v242 = 0LL;
LABEL_276:
          GTMTLSMRenderCommandEncoder_init(v243, (uint64_t)v242);
          return;
        case -16279:
          return;
        case -16278:
          v319 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v320 = *((void *)v319 + 3);
          uint64_t v321 = 1LL << v320;
          uint64_t v322 = a1 + 56 + 8LL * (int)(v320 >> 6);
          *(void *)(v322 + 8) &= ~v321;
          *(void *)(a1 + 80 + 8LL * *((void *)v319 + 3)) = *((void *)v319 + 1);
          unint64_t v323 = *((void *)v319 + 3);
          uint64_t v324 = 1LL << v323;
          uint64_t v325 = a1 + 56 + 8LL * (int)(v323 >> 6);
          *(void *)(v325 + 16) &= ~v324;
          uint64_t v326 = *((void *)v319 + 2);
          uint64_t v327 = a1 + 80 + 8LL * *((void *)v319 + 3);
          goto LABEL_448;
        case -16277:
          v328 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          BOOL v27 = v328;
          unint64_t v329 = *((void *)v328 + 1);
          unint64_t v330 = *((void *)v328 + 2) + v329;
          if (v330 >= 0x40) {
            unint64_t v330 = 64LL;
          }
          char v331 = v330 - v329;
          if (v330 < v329) {
            char v331 = 0;
          }
          uint64_t v332 = ~(-1LL << v331);
          if (v329 <= v330) {
            char v333 = v329 & 0x3F;
          }
          else {
            char v333 = 0;
          }
          uint64_t v334 = *(void *)(a1 + 72);
          *(void *)(a1 + 64) &= ~(v332 << v333);
          unint64_t v335 = *((void *)v328 + 1);
          unint64_t v336 = *((void *)v328 + 2) + v335;
          if (v336 >= 0x40) {
            unint64_t v336 = 64LL;
          }
          char v337 = v336 - v335;
          if (v336 < v335) {
            char v337 = 0;
          }
          uint64_t v338 = ~(-1LL << v337);
          if (v335 <= v336) {
            char v339 = v335 & 0x3F;
          }
          else {
            char v339 = 0;
          }
          *(void *)(a1 + 72) = v334 & ~(v338 << v339);
          uint64_t v340 = *((void *)v328 + 1);
          v341 = GTTraceFunc_argumentBytesWithMap(a2, v328[24], a3);
          if ((int)*((void *)v27 + 2) >= 1)
          {
            uint64_t v342 = (void *)(a1 + 8 * v340 + 80);
            uint64_t v343 = *((void *)v27 + 2);
            do
            {
              uint64_t v344 = *(void *)v341;
              v341 += 8;
              *v342++ = v344;
              --v343;
            }

            while (v343);
          }

          uint64_t v162 = a1 + 8LL * *((void *)v27 + 1) + 328;
          goto LABEL_352;
        case -16276:
          uint64_t v345 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v345 + 2) + 824) = *((void *)v345 + 1);
          return;
        case -16275:
          v346 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v347 = v346;
          unint64_t v348 = *((void *)v346 + 1);
          unint64_t v349 = *((void *)v346 + 2) + v348;
          if (v349 >= 0x40) {
            unint64_t v349 = 64LL;
          }
          char v350 = v349 - v348;
          if (v349 < v348) {
            char v350 = 0;
          }
          uint64_t v351 = ~(-1LL << v350);
          if (v348 <= v349) {
            char v352 = v348 & 0x3F;
          }
          else {
            char v352 = 0;
          }
          *(void *)(a1 + 72) &= ~(v351 << v352);
          uint64_t v353 = *((void *)v346 + 1);
          uint64_t v354 = GTTraceFunc_argumentBytesWithMap(a2, v346[24], a3);
          if ((int)*((void *)v347 + 2) >= 1)
          {
            v355 = (void *)(a1 + 8 * v353 + 824);
            uint64_t v356 = *((void *)v347 + 2);
            do
            {
              uint64_t v357 = *(void *)v354;
              v354 += 8;
              *v355++ = v357;
              --v356;
            }

            while (v356);
          }

          return;
        case -16274:
          uint64_t v358 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v358 + 2) + 184_Block_object_dispose(va, 8) = *((void *)v358 + 1);
          return;
        case -16273:
          v359 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v360 = v359;
          unint64_t v361 = *((void *)v359 + 1);
          unint64_t v362 = *((void *)v359 + 2) + v361;
          if (v362 >= 0x40) {
            unint64_t v362 = 64LL;
          }
          char v363 = v362 - v361;
          if (v362 < v361) {
            char v363 = 0;
          }
          uint64_t v364 = ~(-1LL << v363);
          if (v361 <= v362) {
            char v365 = v361 & 0x3F;
          }
          else {
            char v365 = 0;
          }
          *(void *)(a1 + 72) &= ~(v364 << v365);
          uint64_t v366 = *((void *)v359 + 1);
          uint64_t v367 = GTTraceFunc_argumentBytesWithMap(a2, v359[24], a3);
          if ((int)*((void *)v360 + 2) >= 1)
          {
            v368 = (void *)(a1 + 8 * v366 + 1848);
            uint64_t v369 = *((void *)v360 + 2);
            do
            {
              uint64_t v370 = *(void *)v367;
              v367 += 8;
              *v368++ = v370;
              --v369;
            }

            while (v369);
          }

          return;
        case -16272:
          uint64_t v371 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 56 + 8LL * *((void *)v371 + 2) + 1792) = *((void *)v371 + 1);
          *(_DWORD *)(a1 + 56 + 4LL * *((void *)v371 + 2) + 10036) = *((_DWORD *)v371 + 6);
          *(_DWORD *)(a1 + 56 + 4LL * *((void *)v371 + 2) + 1010mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((_DWORD *)v371 + 7);
          return;
        case -16271:
          uint64_t v372 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          id v171 = v372;
          unint64_t v373 = *((void *)v372 + 1);
          unint64_t v374 = *((void *)v372 + 2) + v373;
          if (v374 >= 0x40) {
            unint64_t v374 = 64LL;
          }
          char v375 = v374 - v373;
          if (v374 < v373) {
            char v375 = 0;
          }
          uint64_t v376 = ~(-1LL << v375);
          if (v373 <= v374) {
            char v377 = v373 & 0x3F;
          }
          else {
            char v377 = 0;
          }
          *(void *)(a1 + 72) &= ~(v376 << v377);
          uint64_t v378 = *((void *)v372 + 1);
          uint64_t v379 = GTTraceFunc_argumentBytesWithMap(a2, v372[24], a3);
          if ((int)*((void *)v171 + 2) >= 1)
          {
            uint64_t v380 = (void *)(a1 + 8 * v378 + 1848);
            uint64_t v381 = *((void *)v171 + 2);
            do
            {
              uint64_t v382 = *(void *)v379;
              v379 += 8;
              *v380++ = v382;
              --v381;
            }

            while (v381);
          }

          uint64_t v383 = a1 + 56;
          v384 = (void *)(a1 + 56 + 4LL * *((void *)v171 + 1) + 10036);
          uint64_t v385 = GTTraceFunc_argumentBytesWithMap(a2, v171[25], a3);
          memcpy(v384, v385, 4LL * *((void *)v171 + 2));
          uint64_t v180 = v383 + 4LL * *((void *)v171 + 1);
          uint64_t v181 = 10100LL;
          goto LABEL_511;
        case -16270:
          v386 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 860_Block_object_dispose(va, 8) = 1LL;
          __int128 v387 = *(_OWORD *)(v386 + 24);
          __int128 v388 = *(_OWORD *)(v386 + 40);
          *(_OWORD *)uint64_t v6 = *(_OWORD *)(v386 + 8);
          *(_OWORD *)(v6 + 16) = v387;
          *(_OWORD *)(v6 + 32) = v388;
          return;
        case -16269:
          return;
        case -16268:
          return;
        case -16267:
          return;
        case -16266:
          uint64_t v389 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(_DWORD *)(a1 + 10056) = *((_DWORD *)v389 + 2);
          *(_DWORD *)(a1 + 1006mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((_DWORD *)v389 + 3);
          *(_DWORD *)(a1 + 10064) = *((_DWORD *)v389 + 4);
          return;
        case -16265:
          uint64_t v390 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 9384) = 1LL;
          __int128 v391 = *(_OWORD *)(v390 + 24);
          *(_OWORD *)(a1 + 9392) = *(_OWORD *)(v390 + 8);
          *(_OWORD *)(a1 + 940_Block_object_dispose(va, 8) = v391;
          return;
        case -16264:
          return;
        case -16263:
          uint64_t v144 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v392 = *((void *)v144 + 3);
          uint64_t v393 = 1LL << v392;
          uint64_t v394 = a1 + 8LL * (int)(v392 >> 6);
          *(void *)(v394 + 1976) &= ~v393;
          uint64_t v148 = *((void *)v144 + 1);
          uint64_t v198 = a1 + 1984;
          goto LABEL_447;
        case -16262:
          v395 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          BOOL v27 = v395;
          unint64_t v396 = *((void *)v395 + 1);
          unint64_t v397 = *((void *)v395 + 2) + v396;
          if (v397 >= 0x40) {
            unint64_t v397 = 64LL;
          }
          char v398 = v397 - v396;
          if (v397 < v396) {
            char v398 = 0;
          }
          uint64_t v399 = ~(-1LL << v398);
          if (v396 <= v397) {
            char v400 = v396 & 0x3F;
          }
          else {
            char v400 = 0;
          }
          *(void *)(a1 + 1976) &= ~(v399 << v400);
          uint64_t v401 = *((void *)v395 + 1);
          v402 = GTTraceFunc_argumentBytesWithMap(a2, v395[24], a3);
          if ((int)*((void *)v27 + 2) >= 1)
          {
            uint64_t v403 = (void *)(a1 + 8 * v401 + 1984);
            uint64_t v404 = *((void *)v27 + 2);
            do
            {
              uint64_t v405 = *(void *)v402;
              v402 += 8;
              *v403++ = v405;
              --v404;
            }

            while (v404);
          }

          uint64_t v162 = a1 + 8LL * *((void *)v27 + 1) + 2232;
LABEL_352:
          unsigned int v406 = v27[25];
LABEL_496:
          v572 = GTTraceFunc_argumentBytesWithMap(a2, v406, a3);
          size_t v573 = 8LL * *((void *)v27 + 2);
          goto LABEL_513;
        case -16261:
          uint64_t v407 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v407 + 2) + 248mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v407 + 1);
          return;
        case -16260:
          uint64_t v408 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v409 = *((void *)v408 + 1);
          uint64_t v410 = GTTraceFunc_argumentBytesWithMap(a2, v408[24], a3);
          if ((int)*((void *)v408 + 2) >= 1)
          {
            v411 = (void *)(a1 + 8 * v409 + 2480);
            uint64_t v412 = *((void *)v408 + 2);
            do
            {
              uint64_t v413 = *(void *)v410;
              v410 += 8;
              *v411++ = v413;
              --v412;
            }

            while (v412);
          }

          return;
        case -16259:
          uint64_t v414 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v414 + 2) + 3504) = *((void *)v414 + 1);
          return;
        case -16258:
          uint64_t v415 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v416 = *((void *)v415 + 1);
          uint64_t v417 = GTTraceFunc_argumentBytesWithMap(a2, v415[24], a3);
          if ((int)*((void *)v415 + 2) >= 1)
          {
            v418 = (void *)(a1 + 8 * v416 + 3504);
            uint64_t v419 = *((void *)v415 + 2);
            do
            {
              uint64_t v420 = *(void *)v417;
              v417 += 8;
              *v418++ = v420;
              --v419;
            }

            while (v419);
          }

          return;
        case -16257:
          v421 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 56 + 8LL * *((void *)v421 + 2) + 344_Block_object_dispose(va, 8) = *((void *)v421 + 1);
          *(_DWORD *)(a1 + 56 + 4LL * *((void *)v421 + 2) + 10164) = *((_DWORD *)v421 + 6);
          *(_DWORD *)(a1 + 56 + 4LL * *((void *)v421 + 2) + 1022_Block_object_dispose(va, 8) = *((_DWORD *)v421 + 7);
          return;
        case -16256:
          id v171 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v422 = *((void *)v171 + 1);
          uint64_t v423 = GTTraceFunc_argumentBytesWithMap(a2, v171[24], a3);
          if ((int)*((void *)v171 + 2) >= 1)
          {
            v424 = (void *)(a1 + 8 * v422 + 3504);
            uint64_t v425 = *((void *)v171 + 2);
            do
            {
              uint64_t v426 = *(void *)v423;
              v423 += 8;
              *v424++ = v426;
              --v425;
            }

            while (v425);
          }

          uint64_t v427 = a1 + 56;
          uint64_t v428 = (void *)(a1 + 56 + 4LL * *((void *)v171 + 1) + 10164);
          v429 = GTTraceFunc_argumentBytesWithMap(a2, v171[25], a3);
          memcpy(v428, v429, 4LL * *((void *)v171 + 2));
          uint64_t v180 = v427 + 4LL * *((void *)v171 + 1);
          uint64_t v181 = 10228LL;
LABEL_511:
          uint64_t v162 = v180 + v181;
LABEL_512:
          v572 = GTTraceFunc_argumentBytesWithMap(a2, v171[26], a3);
          size_t v573 = 4LL * *((void *)v171 + 2);
LABEL_513:
          v601 = (void *)v162;
LABEL_514:
          memcpy(v601, v572, v573);
          return;
        case -16255:
          uint64_t v430 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(_DWORD *)(a1 + 1006_Block_object_dispose(va, 8) = *((_DWORD *)v430 + 2);
          *(_DWORD *)(a1 + 10072) = *((_DWORD *)v430 + 3);
          *(_DWORD *)(a1 + 10076) = *((_DWORD *)v430 + 4);
          *(_DWORD *)(a1 + 1008mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((_DWORD *)v430 + 5);
          return;
        case -16254:
          return;
        case -16253:
          int v431 = *((_DWORD *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3) + 2);
          *(_DWORD *)(a1 + 1008_Block_object_dispose(va, 8) = v431;
          *(_DWORD *)(a1 + 10084) = v431;
          return;
        case -16252:
          uint64_t v432 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(_BYTE *)(v6 + 2525) = *((void *)v432 + 1);
          *(_DWORD *)(a1 + 11132) = *((void *)v432 + 2);
          return;
        case -16247:
          return;
        case -16227:
          uint64_t v433 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v434 = *((void *)v433 + 2);
          uint64_t v435 = 1LL << v434;
          uint64_t v436 = a1 + 8LL * (int)(v434 >> 6);
          *(void *)(v436 + 72) |= v435;
          *(void *)(a1 + 80 + 8LL * *((void *)v433 + 2) + _Block_object_dispose(va, 8) = GTTraceFunc_argumentBytesWithMap( a2,  v433[24],  a3);
          *(void *)(a1 + 80 + 8LL * (int)(*((void *)v433 + 2) >> 6)) &= ~(1LL << *((void *)v433 + 2));
          *(void *)(a1 + 80 + 8LL * *((void *)v433 + 2) + 256) = *((void *)v433 + 1);
          return;
        case -16226:
          uint64_t v437 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v437 + 2) + 336) = *((void *)v437 + 1);
          return;
        case -16225:
          id v163 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v438 = *((void *)v163 + 2);
          uint64_t v439 = 1LL << v438;
          uint64_t v440 = a1 + 56 + 8LL * (int)(v438 >> 6);
          *(void *)(v440 + 8) |= v439;
          uint64_t v441 = GTTraceFunc_argumentBytesWithMap(a2, v163[24], a3);
          uint64_t v214 = a1 + 80;
          *(void *)(a1 + 80 + 8LL * *((void *)v163 + 2)) = v441;
          unint64_t v442 = *((void *)v163 + 2);
          uint64_t v443 = 1LL << v442;
          uint64_t v444 = a1 + 56 + 8LL * (int)(v442 >> 6);
          *(void *)(v444 + 16) &= ~v443;
          goto LABEL_444;
        case -16224:
          v445 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v445 + 2) + 32_Block_object_dispose(va, 8) = *((void *)v445 + 1);
          return;
        case -16223:
          id v163 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v446 = *((void *)v163 + 2);
          uint64_t v447 = 1LL << v446;
          uint64_t v448 = a1 + 8LL * (int)(v446 >> 6);
          *(void *)(v448 + 1976) |= v447;
          id v167 = GTTraceFunc_argumentBytesWithMap(a2, v163[24], a3);
          uint64_t v214 = a1 + 1984;
          goto LABEL_443;
        case -16222:
          uint64_t v449 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v449 + 2) + 2232) = *((void *)v449 + 1);
          return;
        case -16219:
          uint64_t v450 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(_DWORD *)(a1 + 10084) = *((_DWORD *)v450 + 2);
          *(_DWORD *)(a1 + 1008_Block_object_dispose(va, 8) = *((_DWORD *)v450 + 3);
          return;
        case -16214:
          uint64_t v451 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 56 + 8LL * *((void *)v451 + 2) + 2424) = *((void *)v451 + 1);
          *(void *)(a1 + 56 + 8LL * *((void *)v451 + 4) + 344_Block_object_dispose(va, 8) = *((void *)v451 + 3);
          return;
        default:
          if (v7 == -16384) {
            goto LABEL_54;
          }
          if (v7 != -16376) {
            return;
          }
          goto LABEL_65;
      }
    }

    switch(v7)
    {
      case -16162:
        unsigned int v19 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(void *)(a1 + 8LL * *((void *)v19 + 2) + 64) = *((void *)v19 + 1);
        break;
      case -16161:
        *(_BYTE *)(a1 + 192) = *((void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3) + 1);
        break;
      case -16160:
        *(_BYTE *)(a1 + 193) = *((void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3) + 1);
        break;
      case -16159:
        uint64_t v503 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(void *)(a1 + 8LL * *((void *)v503 + 2) + 992_Block_object_dispose(va, 8) = *((void *)v503 + 1);
        break;
      case -16158:
        *(_BYTE *)(a1 + 11142) = *((void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3) + 1);
        break;
      case -16157:
        *(_BYTE *)(a1 + 11143) = *((void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3) + 1);
        break;
      case -16156:
      case -16155:
      case -16154:
      case -16153:
      case -16152:
      case -16151:
      case -16150:
      case -16147:
      case -16146:
      case -16145:
      case -16144:
      case -16137:
      case -16136:
      case -16135:
      case -16134:
      case -16133:
        return;
      case -16149:
        v504 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(_DWORD *)(a1 + 2164) = *((void *)v504 + 1);
        *(_DWORD *)(a1 + 216_Block_object_dispose(va, 8) = *((void *)v504 + 2);
        break;
      case -16148:
        uint64_t v505 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(void *)(a1 + 992mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v505 + 1);
        *(_DWORD *)(a1 + 10744) = *((void *)v505 + 2);
        *(_DWORD *)(a1 + 1074_Block_object_dispose(va, 8) = *((void *)v505 + 3);
        break;
      case -16143:
        id v163 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        unint64_t v506 = *((void *)v163 + 2);
        uint64_t v507 = 1LL << v506;
        uint64_t v508 = a1 + 8LL * (int)(v506 >> 6);
        *(void *)(v508 + 6944) |= v507;
        id v167 = GTTraceFunc_argumentBytesWithMap(a2, v163[24], a3);
        uint64_t v168 = 6952LL;
LABEL_442:
        uint64_t v214 = a1 + v168;
LABEL_443:
        *(void *)(v214 + 8LL * *((void *)v163 + 2)) = v167;
LABEL_444:
        *(void *)(v214 + 8LL * *((void *)v163 + 2) + 24_Block_object_dispose(va, 8) = *((void *)v163 + 1);
        break;
      case -16142:
        uint64_t v144 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        unint64_t v509 = *((void *)v144 + 3);
        uint64_t v510 = 1LL << v509;
        uint64_t v511 = a1 + 8LL * (int)(v509 >> 6);
        *(void *)(v511 + 6944) &= ~v510;
        uint64_t v148 = *((void *)v144 + 1);
        uint64_t v149 = 6952LL;
LABEL_446:
        uint64_t v198 = a1 + v149;
LABEL_447:
        *(void *)(v198 + 8LL * *((void *)v144 + 3)) = v148;
        uint64_t v326 = *((void *)v144 + 2);
        uint64_t v327 = v198 + 8LL * *((void *)v144 + 3);
LABEL_448:
        *(void *)(v327 + 24_Block_object_dispose(va, 8) = v326;
        break;
      case -16141:
        uint64_t v512 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(void *)(a1 + 8LL * *((void *)v512 + 2) + 720mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v512 + 1);
        break;
      case -16140:
        v513 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(void *)(a1 + 8LL * *((void *)v513 + 2) + 744_Block_object_dispose(va, 8) = *((void *)v513 + 1);
        break;
      case -16139:
        uint64_t v514 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(void *)(a1 + 8LL * *((void *)v514 + 2) + 8472) = *((void *)v514 + 1);
        break;
      case -16138:
        uint64_t v515 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(void *)(a1 + 56 + 8LL * *((void *)v515 + 2) + 8416) = *((void *)v515 + 1);
        *(_DWORD *)(a1 + 56 + 4LL * *((void *)v515 + 2) + 1054_Block_object_dispose(va, 8) = *((_DWORD *)v515 + 6);
        *(_DWORD *)(a1 + 56 + 4LL * *((void *)v515 + 2) + 10612) = *((_DWORD *)v515 + 7);
        break;
      case -16132:
        *(_DWORD *)(a1 + 10732) = *((_DWORD *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3) + 2);
        break;
      default:
        if (v7 == -16100)
        {
          id v57 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v58 = *((void *)v57 + 3);
          *(_OWORD *)(a1 + 1984) = *(_OWORD *)(v57 + 8);
          *(void *)(a1 + 200mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v58;
          uint64_t v59 = *((void *)v57 + 6);
          *(_OWORD *)(a1 + 200_Block_object_dispose(va, 8) = *((_OWORD *)v57 + 2);
          *(void *)(a1 + 2024) = v59;
        }

        break;
    }
  }

  else
  {
    if (v7 > -15460)
    {
      switch(v7)
      {
        case -15459:
        case -15458:
        case -15456:
          uint64_t v8 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v9 = *((void *)v8 + 2);
          uint64_t v10 = 1LL << v9;
          uint64_t v11 = a1 + 56 + 8LL * (int)(v9 >> 6);
          *(void *)(v11 + 1920) &= ~v10;
          *(void *)(a1 + 56 + 8LL * *((void *)v8 + 2) + 192_Block_object_dispose(va, 8) = *((void *)v8 + 1);
          break;
        case -15457:
          __int128 v60 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          __int128 v61 = v60;
          unint64_t v62 = *((void *)v60 + 1);
          unint64_t v63 = *((void *)v60 + 2) + v62;
          if (v63 >= 0x40) {
            unint64_t v63 = 64LL;
          }
          char v64 = v63 - v62;
          if (v63 < v62) {
            char v64 = 0;
          }
          uint64_t v65 = ~(-1LL << v64);
          if (v62 <= v63) {
            char v66 = v62 & 0x3F;
          }
          else {
            char v66 = 0;
          }
          *(void *)(a1 + 1976) &= ~(v65 << v66);
          uint64_t v67 = *((void *)v60 + 1);
          __int128 v68 = GTTraceFunc_argumentBytesWithMap(a2, v60[24], a3);
          if ((int)*((void *)v61 + 2) >= 1)
          {
            __int128 v69 = (void *)(a1 + 8 * v67 + 1984);
            uint64_t v70 = *((void *)v61 + 2);
            do
            {
              uint64_t v71 = *(void *)v68;
              v68 += 8;
              *v69++ = v71;
              --v70;
            }

            while (v70);
          }

          break;
        case -15455:
          __int128 v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v73 = v72;
          unint64_t v74 = *((void *)v72 + 1);
          unint64_t v75 = *((void *)v72 + 2) + v74;
          if (v75 >= 0x40) {
            unint64_t v75 = 64LL;
          }
          char v76 = v75 - v74;
          if (v75 < v74) {
            char v76 = 0;
          }
          uint64_t v77 = ~(-1LL << v76);
          if (v74 <= v75) {
            char v78 = v74 & 0x3F;
          }
          else {
            char v78 = 0;
          }
          *(void *)(a1 + 1976) &= ~(v77 << v78);
          uint64_t v79 = *((void *)v72 + 1);
          id v80 = GTTraceFunc_argumentBytesWithMap(a2, v72[24], a3);
          if ((int)*((void *)v73 + 2) >= 1)
          {
            uint64_t v81 = (void *)(a1 + 8 * v79 + 1984);
            uint64_t v82 = *((void *)v73 + 2);
            do
            {
              uint64_t v83 = *(void *)v80;
              v80 += 8;
              *v81++ = v83;
              --v82;
            }

            while (v82);
          }

          break;
        case -15454:
        case -15453:
        case -15451:
          id v40 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v41 = *((void *)v40 + 2);
          uint64_t v42 = 1LL << v41;
          uint64_t v43 = a1 + 56 + 8LL * (int)(v41 >> 6);
          *(void *)(v43 + 6888) &= ~v42;
          *(void *)(a1 + 56 + 8LL * *((void *)v40 + 2) + 6896) = *((void *)v40 + 1);
          break;
        case -15452:
          id v84 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          id v85 = v84;
          unint64_t v86 = *((void *)v84 + 1);
          unint64_t v87 = *((void *)v84 + 2) + v86;
          if (v87 >= 0x40) {
            unint64_t v87 = 64LL;
          }
          char v88 = v87 - v86;
          if (v87 < v86) {
            char v88 = 0;
          }
          uint64_t v89 = ~(-1LL << v88);
          if (v86 <= v87) {
            char v90 = v86 & 0x3F;
          }
          else {
            char v90 = 0;
          }
          *(void *)(a1 + 6944) &= ~(v89 << v90);
          uint64_t v91 = *((void *)v84 + 1);
          int v92 = GTTraceFunc_argumentBytesWithMap(a2, v84[24], a3);
          if ((int)*((void *)v85 + 2) >= 1)
          {
            int32x2_t v93 = (void *)(a1 + 8 * v91 + 6952);
            uint64_t v94 = *((void *)v85 + 2);
            do
            {
              uint64_t v95 = *(void *)v92;
              v92 += 8;
              *v93++ = v95;
              --v94;
            }

            while (v94);
          }

          break;
        case -15450:
          unint64_t v96 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          id v97 = v96;
          unint64_t v98 = *((void *)v96 + 1);
          unint64_t v99 = *((void *)v96 + 2) + v98;
          if (v99 >= 0x40) {
            unint64_t v99 = 64LL;
          }
          char v100 = v99 - v98;
          if (v99 < v98) {
            char v100 = 0;
          }
          uint64_t v101 = ~(-1LL << v100);
          if (v98 <= v99) {
            char v102 = v98 & 0x3F;
          }
          else {
            char v102 = 0;
          }
          *(void *)(a1 + 6944) &= ~(v101 << v102);
          uint64_t v103 = *((void *)v96 + 1);
          unsigned int v104 = GTTraceFunc_argumentBytesWithMap(a2, v96[24], a3);
          if ((int)*((void *)v97 + 2) >= 1)
          {
            unsigned int v105 = (void *)(a1 + 8 * v103 + 6952);
            uint64_t v106 = *((void *)v97 + 2);
            do
            {
              uint64_t v107 = *(void *)v104;
              v104 += 8;
              *v105++ = v107;
              --v106;
            }

            while (v106);
          }

          break;
        case -15449:
        case -15448:
        case -15446:
          id v44 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v45 = *((void *)v44 + 2);
          uint64_t v46 = 1LL << v45;
          uint64_t v47 = a1 + 56 + 8LL * (int)(v45 >> 6);
          *(void *)(v47 + 8) &= ~v46;
          *(void *)(a1 + 56 + 8LL * *((void *)v44 + 2) + 24) = *((void *)v44 + 1);
          unint64_t v48 = *((void *)v44 + 2);
          uint64_t v49 = 1LL << v48;
          uint64_t v50 = a1 + 56 + 8LL * (int)(v48 >> 6);
          *(void *)(v50 + 16) &= ~v49;
          break;
        case -15447:
          id v108 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          id v109 = v108;
          unint64_t v110 = *((void *)v108 + 1);
          unint64_t v111 = *((void *)v108 + 2) + v110;
          if (v111 >= 0x40) {
            unint64_t v111 = 64LL;
          }
          char v112 = v111 - v110;
          if (v111 < v110) {
            char v112 = 0;
          }
          uint64_t v113 = ~(-1LL << v112);
          if (v110 <= v111) {
            char v114 = v110 & 0x3F;
          }
          else {
            char v114 = 0;
          }
          uint64_t v115 = *(void *)(a1 + 72);
          *(void *)(a1 + 64) &= ~(v113 << v114);
          unint64_t v116 = *((void *)v108 + 1);
          unint64_t v117 = *((void *)v108 + 2) + v116;
          if (v117 >= 0x40) {
            unint64_t v117 = 64LL;
          }
          char v118 = v117 - v116;
          if (v117 < v116) {
            char v118 = 0;
          }
          uint64_t v119 = ~(-1LL << v118);
          if (v116 <= v117) {
            char v120 = v116 & 0x3F;
          }
          else {
            char v120 = 0;
          }
          *(void *)(a1 + 72) = v115 & ~(v119 << v120);
          uint64_t v121 = *((void *)v108 + 1);
          __int128 v122 = GTTraceFunc_argumentBytesWithMap(a2, v108[24], a3);
          if ((int)*((void *)v109 + 2) >= 1)
          {
            __int128 v123 = (void *)(a1 + 8 * v121 + 80);
            uint64_t v124 = *((void *)v109 + 2);
            do
            {
              uint64_t v125 = *(void *)v122;
              v122 += 8;
              *v123++ = v125;
              --v124;
            }

            while (v124);
          }

          break;
        case -15445:
          unint64_t v126 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v127 = v126;
          unint64_t v128 = *((void *)v126 + 1);
          unint64_t v129 = *((void *)v126 + 2) + v128;
          if (v129 >= 0x40) {
            unint64_t v129 = 64LL;
          }
          char v130 = v129 - v128;
          if (v129 < v128) {
            char v130 = 0;
          }
          uint64_t v131 = ~(-1LL << v130);
          if (v128 <= v129) {
            char v132 = v128 & 0x3F;
          }
          else {
            char v132 = 0;
          }
          uint64_t v133 = *(void *)(a1 + 72);
          *(void *)(a1 + 64) &= ~(v131 << v132);
          unint64_t v134 = *((void *)v126 + 1);
          unint64_t v135 = *((void *)v126 + 2) + v134;
          if (v135 >= 0x40) {
            unint64_t v135 = 64LL;
          }
          char v136 = v135 - v134;
          if (v135 < v134) {
            char v136 = 0;
          }
          uint64_t v137 = ~(-1LL << v136);
          if (v134 <= v135) {
            char v138 = v134 & 0x3F;
          }
          else {
            char v138 = 0;
          }
          *(void *)(a1 + 72) = v133 & ~(v137 << v138);
          uint64_t v139 = *((void *)v126 + 1);
          __int128 v140 = GTTraceFunc_argumentBytesWithMap(a2, v126[24], a3);
          if ((int)*((void *)v127 + 2) >= 1)
          {
            __int128 v141 = (void *)(a1 + 8 * v139 + 80);
            uint64_t v142 = *((void *)v127 + 2);
            do
            {
              uint64_t v143 = *(void *)v140;
              v140 += 8;
              *v141++ = v143;
              --v142;
            }

            while (v142);
          }

          break;
        case -15444:
        case -15443:
        case -15442:
        case -15441:
        case -15440:
        case -15439:
        case -15438:
        case -15437:
        case -15436:
        case -15435:
        case -15434:
        case -15433:
        case -15432:
        case -15431:
        case -15430:
        case -15429:
        case -15428:
        case -15427:
        case -15426:
        case -15425:
        case -15424:
        case -15423:
        case -15422:
        case -15421:
        case -15420:
        case -15419:
        case -15418:
        case -15417:
        case -15416:
        case -15415:
        case -15414:
        case -15413:
        case -15412:
        case -15411:
        case -15410:
        case -15409:
        case -15408:
        case -15407:
        case -15406:
        case -15405:
        case -15404:
        case -15403:
        case -15402:
          return;
        case -15401:
          uint64_t v144 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v145 = *((void *)v144 + 3);
          uint64_t v146 = 1LL << v145;
          uint64_t v147 = a1 + 8LL * (int)(v145 >> 6);
          *(void *)(v147 + 5288) &= ~v146;
          uint64_t v148 = *((void *)v144 + 1);
          uint64_t v149 = 5296LL;
          goto LABEL_446;
        case -15400:
          id v150 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v150 + 2) + 5544) = *((void *)v150 + 1);
          break;
        case -15399:
          int v151 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          BOOL v27 = v151;
          unint64_t v152 = *((void *)v151 + 1);
          unint64_t v153 = *((void *)v151 + 2) + v152;
          if (v153 >= 0x40) {
            unint64_t v153 = 64LL;
          }
          char v154 = v153 - v152;
          if (v153 < v152) {
            char v154 = 0;
          }
          uint64_t v155 = ~(-1LL << v154);
          if (v152 <= v153) {
            char v156 = v152 & 0x3F;
          }
          else {
            char v156 = 0;
          }
          *(void *)(a1 + 5288) &= ~(v155 << v156);
          uint64_t v157 = *((void *)v151 + 1);
          char v158 = GTTraceFunc_argumentBytesWithMap(a2, v151[24], a3);
          if ((int)*((void *)v27 + 2) >= 1)
          {
            int v159 = (void *)(a1 + 8 * v157 + 5296);
            uint64_t v160 = *((void *)v27 + 2);
            do
            {
              uint64_t v161 = *(void *)v158;
              v158 += 8;
              *v159++ = v161;
              --v160;
            }

            while (v160);
          }

          uint64_t v38 = a1 + 8LL * *((void *)v27 + 1);
          uint64_t v39 = 5544LL;
          goto LABEL_164;
        case -15398:
          id v163 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v164 = *((void *)v163 + 2);
          uint64_t v165 = 1LL << v164;
          uint64_t v166 = a1 + 8LL * (int)(v164 >> 6);
          *(void *)(v166 + 5288) |= v165;
          id v167 = GTTraceFunc_argumentBytesWithMap(a2, v163[24], a3);
          uint64_t v168 = 5296LL;
          goto LABEL_442;
        case -15397:
          uint64_t v169 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v169 + 2) + 6816) = *((void *)v169 + 1);
          break;
        case -15396:
          uint64_t v170 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 56 + 8LL * *((void *)v170 + 2) + 676mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v170 + 1);
          *(_DWORD *)(a1 + 56 + 4LL * *((void *)v170 + 2) + 1042mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((_DWORD *)v170 + 6);
          *(_DWORD *)(a1 + 56 + 4LL * *((void *)v170 + 2) + 10484) = *((_DWORD *)v170 + 7);
          break;
        case -15395:
          id v171 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v172 = *((void *)v171 + 1);
          __int16 v173 = GTTraceFunc_argumentBytesWithMap(a2, v171[24], a3);
          if ((int)*((void *)v171 + 2) >= 1)
          {
            uint64_t v174 = (void *)(a1 + 8 * v172 + 6816);
            uint64_t v175 = *((void *)v171 + 2);
            do
            {
              uint64_t v176 = *(void *)v173;
              v173 += 8;
              *v174++ = v176;
              --v175;
            }

            while (v175);
          }

          uint64_t v177 = a1 + 56;
          uint64_t v178 = (void *)(a1 + 56 + 4LL * *((void *)v171 + 1) + 10420);
          int v179 = GTTraceFunc_argumentBytesWithMap(a2, v171[25], a3);
          memcpy(v178, v179, 4LL * *((void *)v171 + 2));
          uint64_t v180 = v177 + 4LL * *((void *)v171 + 1);
          uint64_t v181 = 10484LL;
          goto LABEL_511;
        case -15394:
          id v182 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v183 = *((void *)v182 + 1);
          uint64_t v184 = GTTraceFunc_argumentBytesWithMap(a2, v182[24], a3);
          if ((int)*((void *)v182 + 2) >= 1)
          {
            unint64_t v185 = (void *)(a1 + 8 * v183 + 6816);
            uint64_t v186 = *((void *)v182 + 2);
            do
            {
              uint64_t v187 = *(void *)v184;
              v184 += 8;
              *v185++ = v187;
              --v186;
            }

            while (v186);
          }

          break;
        case -15393:
          int64x2_t v188 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v188 + 2) + 5792) = *((void *)v188 + 1);
          break;
        case -15392:
          uint64_t v189 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v190 = *((void *)v189 + 1);
          uint64_t v191 = GTTraceFunc_argumentBytesWithMap(a2, v189[24], a3);
          if ((int)*((void *)v189 + 2) >= 1)
          {
            int64x2_t v192 = (void *)(a1 + 8 * v190 + 5792);
            uint64_t v193 = *((void *)v189 + 2);
            do
            {
              uint64_t v194 = *(void *)v191;
              v191 += 8;
              *v192++ = v194;
              --v193;
            }

            while (v193);
          }

          break;
        case -15391:
          uint64_t v144 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v195 = *((void *)v144 + 3);
          uint64_t v196 = 1LL << v195;
          uint64_t v197 = a1 + 8LL * (int)(v195 >> 6);
          *(void *)(v197 + 3632) &= ~v196;
          uint64_t v148 = *((void *)v144 + 1);
          uint64_t v198 = a1 + 3640;
          goto LABEL_447;
        case -15390:
          int64x2_t v199 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v199 + 2) + 388_Block_object_dispose(va, 8) = *((void *)v199 + 1);
          break;
        case -15389:
          unint64_t v200 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          BOOL v27 = v200;
          unint64_t v201 = *((void *)v200 + 1);
          unint64_t v202 = *((void *)v200 + 2) + v201;
          if (v202 >= 0x40) {
            unint64_t v202 = 64LL;
          }
          char v203 = v202 - v201;
          if (v202 < v201) {
            char v203 = 0;
          }
          uint64_t v204 = ~(-1LL << v203);
          if (v201 <= v202) {
            char v205 = v201 & 0x3F;
          }
          else {
            char v205 = 0;
          }
          *(void *)(a1 + 3632) &= ~(v204 << v205);
          uint64_t v206 = *((void *)v200 + 1);
          uint64_t v207 = GTTraceFunc_argumentBytesWithMap(a2, v200[24], a3);
          if ((int)*((void *)v27 + 2) >= 1)
          {
            v208 = (void *)(a1 + 8 * v206 + 3640);
            uint64_t v209 = *((void *)v27 + 2);
            do
            {
              uint64_t v210 = *(void *)v207;
              v207 += 8;
              *v208++ = v210;
              --v209;
            }

            while (v209);
          }

          uint64_t v162 = a1 + 8LL * *((void *)v27 + 1) + 3888;
          goto LABEL_352;
        case -15388:
          id v163 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          unint64_t v211 = *((void *)v163 + 2);
          uint64_t v212 = 1LL << v211;
          uint64_t v213 = a1 + 8LL * (int)(v211 >> 6);
          *(void *)(v213 + 3632) |= v212;
          id v167 = GTTraceFunc_argumentBytesWithMap(a2, v163[24], a3);
          uint64_t v214 = a1 + 3640;
          goto LABEL_443;
        case -15387:
          id v215 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v215 + 2) + 516mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v215 + 1);
          break;
        case -15386:
          uint64_t v216 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 56 + 8LL * *((void *)v216 + 2) + 5104) = *((void *)v216 + 1);
          *(_DWORD *)(a1 + 56 + 4LL * *((void *)v216 + 2) + 10292) = *((_DWORD *)v216 + 6);
          *(_DWORD *)(a1 + 56 + 4LL * *((void *)v216 + 2) + 10356) = *((_DWORD *)v216 + 7);
          break;
        case -15385:
          id v171 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v217 = *((void *)v171 + 1);
          id v218 = GTTraceFunc_argumentBytesWithMap(a2, v171[24], a3);
          if ((int)*((void *)v171 + 2) >= 1)
          {
            uint64_t v219 = (void *)(a1 + 8 * v217 + 5160);
            uint64_t v220 = *((void *)v171 + 2);
            do
            {
              uint64_t v221 = *(void *)v218;
              v218 += 8;
              *v219++ = v221;
              --v220;
            }

            while (v220);
          }

          uint64_t v222 = a1 + 56;
          uint64_t v223 = (void *)(a1 + 56 + 4LL * *((void *)v171 + 1) + 10292);
          id v224 = GTTraceFunc_argumentBytesWithMap(a2, v171[25], a3);
          memcpy(v223, v224, 4LL * *((void *)v171 + 2));
          uint64_t v180 = v222 + 4LL * *((void *)v171 + 1);
          uint64_t v181 = 10356LL;
          goto LABEL_511;
        case -15384:
          uint64_t v225 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v226 = *((void *)v225 + 1);
          int v227 = GTTraceFunc_argumentBytesWithMap(a2, v225[24], a3);
          if ((int)*((void *)v225 + 2) >= 1)
          {
            uint64_t v228 = (void *)(a1 + 8 * v226 + 5160);
            uint64_t v229 = *((void *)v225 + 2);
            do
            {
              uint64_t v230 = *(void *)v227;
              v227 += 8;
              *v228++ = v230;
              --v229;
            }

            while (v229);
          }

          break;
        case -15383:
          uint64_t v231 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(void *)(a1 + 8LL * *((void *)v231 + 2) + 4136) = *((void *)v231 + 1);
          break;
        case -15382:
          uint64_t v232 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          uint64_t v233 = *((void *)v232 + 1);
          uint64_t v234 = GTTraceFunc_argumentBytesWithMap(a2, v232[24], a3);
          if ((int)*((void *)v232 + 2) >= 1)
          {
            uint64_t v235 = (void *)(a1 + 8 * v233 + 4136);
            uint64_t v236 = *((void *)v232 + 2);
            do
            {
              uint64_t v237 = *(void *)v234;
              v234 += 8;
              *v235++ = v237;
              --v236;
            }

            while (v236);
          }

          break;
        case -15381:
          uint64_t v238 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(_DWORD *)(a1 + 4LL * *((void *)v238 + 2) + 1100mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v238 + 1);
          break;
        default:
          switch(v7)
          {
            case -15284:
              uint64_t v20 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              unint64_t v21 = *((void *)v20 + 4);
              uint64_t v22 = 1LL << v21;
              uint64_t v23 = a1 + 56 + 8LL * (int)(v21 >> 6);
              *(void *)(v23 + 16) &= ~v22;
              *(void *)(a1 + 80 + 8LL * *((void *)v20 + 4) + _Block_object_dispose(va, 8) = *((void *)v20 + 1);
              *(void *)(a1 + 80 + 8LL * (int)(*((void *)v20 + 4) >> 6)) |= 1LL << *((void *)v20 + 4);
              *(void *)(a1 + 80 + 8LL * *((void *)v20 + 4) + 256) = *((void *)v20 + 2);
              uint64_t v24 = *((void *)v20 + 3);
              uint64_t v25 = a1 + 56 + 8LL * *((void *)v20 + 4);
              goto LABEL_474;
            case -15283:
              uint64_t v516 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              *(void *)(a1 + 56 + 8LL * *((void *)v516 + 3) + 28mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v516 + 1);
              uint64_t v24 = *((void *)v516 + 2);
              uint64_t v25 = a1 + 56 + 8LL * *((void *)v516 + 3);
              goto LABEL_474;
            case -15282:
              uint64_t v517 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              BOOL v27 = v517;
              unint64_t v518 = *((void *)v517 + 1);
              unint64_t v519 = *((void *)v517 + 2) + v518;
              unint64_t v520 = 64LL;
              if (v519 >= 0x40) {
                unint64_t v519 = 64LL;
              }
              char v521 = v519 - v518;
              if (v519 < v518) {
                char v521 = 0;
              }
              uint64_t v522 = ~(-1LL << v521);
              if (v518 <= v519) {
                char v523 = v518 & 0x3F;
              }
              else {
                char v523 = 0;
              }
              uint64_t v525 = (uint64_t *)(a1 + 80);
              uint64_t v524 = *(void *)(a1 + 80);
              *(void *)(a1 + 72) &= ~(v522 << v523);
              unint64_t v526 = *((void *)v517 + 1);
              if (*((void *)v517 + 2) + v526 < 0x40) {
                unint64_t v520 = *((void *)v517 + 2) + v526;
              }
              char v527 = v520 - v526;
              if (v520 < v526) {
                char v527 = 0;
              }
              uint64_t v528 = ~(-1LL << v527);
              if (v526 <= v520) {
                char v529 = v526 & 0x3F;
              }
              else {
                char v529 = 0;
              }
              *uint64_t v525 = (v528 << v529) | v524;
              uint64_t v530 = *((void *)v517 + 1);
              v531 = GTTraceFunc_argumentBytesWithMap(a2, v517[24], a3);
              if ((int)*((void *)v27 + 2) >= 1)
              {
                uint64_t v532 = &v525[v530 + 1];
                uint64_t v533 = *((void *)v27 + 2);
                do
                {
                  uint64_t v534 = *(void *)v531;
                  v531 += 8;
                  *v532++ = v534;
                  --v533;
                }

                while (v533);
              }

              uint64_t v535 = a1 + 56;
              v536 = (void *)(a1 + 56 + 8LL * *((void *)v27 + 1) + 280);
              v537 = GTTraceFunc_argumentBytesWithMap(a2, v27[25], a3);
              memcpy(v536, v537, 8LL * *((void *)v27 + 2));
              uint64_t v162 = v535 + 8LL * *((void *)v27 + 1) + 528;
              goto LABEL_495;
            case -15281:
              v538 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              unint64_t v539 = *((void *)v538 + 3);
              uint64_t v540 = 1LL << v539;
              uint64_t v541 = a1 + 56 + 8LL * (int)(v539 >> 6);
              *(void *)(v541 + 16) |= v540;
              *(void *)(a1 + 80 + 8LL * *((void *)v538 + 3) + _Block_object_dispose(va, 8) = GTTraceFunc_argumentBytesWithMap( a2,  v538[32],  a3);
              *(void *)(a1 + 80 + 8LL * (int)(*((void *)v538 + 3) >> 6)) |= 1LL << *((void *)v538 + 3);
              *(void *)(a1 + 80 + 8LL * *((void *)v538 + 3) + 256) = *((void *)v538 + 1);
              uint64_t v24 = *((void *)v538 + 2);
              uint64_t v25 = a1 + 56 + 8LL * *((void *)v538 + 3);
LABEL_474:
              *(void *)(v25 + 52_Block_object_dispose(va, 8) = v24;
              return;
            case -15280:
            case -15279:
            case -15278:
            case -15277:
            case -15276:
              return;
            case -15275:
              v542 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              unint64_t v543 = *((void *)v542 + 4);
              uint64_t v544 = 1LL << v543;
              uint64_t v545 = a1 + 56 + 8LL * (int)(v543 >> 6);
              *(void *)(v545 + 8) &= ~v544;
              *(void *)(a1 + 80 + 8LL * *((void *)v542 + 4)) = *((void *)v542 + 1);
              unint64_t v546 = *((void *)v542 + 4);
              uint64_t v547 = 1LL << v546;
              uint64_t v548 = a1 + 56 + 8LL * (int)(v546 >> 6);
              *(void *)(v548 + 16) |= v547;
              *(void *)(a1 + 80 + 8LL * *((void *)v542 + 4) + 24_Block_object_dispose(va, 8) = *((void *)v542 + 2);
              uint64_t v549 = *((void *)v542 + 3);
              uint64_t v550 = a1 + 56 + 8LL * *((void *)v542 + 4);
              goto LABEL_498;
            case -15274:
              v551 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              *(void *)(a1 + 56 + 8LL * *((void *)v551 + 3) + 272) = *((void *)v551 + 1);
              uint64_t v549 = *((void *)v551 + 2);
              uint64_t v550 = a1 + 56 + 8LL * *((void *)v551 + 3);
              goto LABEL_498;
            case -15273:
              v552 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              BOOL v27 = v552;
              unint64_t v553 = *((void *)v552 + 1);
              unint64_t v554 = *((void *)v552 + 2) + v553;
              if (v554 >= 0x40) {
                unint64_t v554 = 64LL;
              }
              char v555 = v554 - v553;
              if (v554 < v553) {
                char v555 = 0;
              }
              uint64_t v556 = ~(-1LL << v555);
              if (v553 <= v554) {
                char v557 = v553 & 0x3F;
              }
              else {
                char v557 = 0;
              }
              uint64_t v558 = *(void *)(a1 + 72);
              *(void *)(a1 + 64) &= ~(v556 << v557);
              unint64_t v559 = *((void *)v552 + 1);
              unint64_t v560 = *((void *)v552 + 2) + v559;
              if (v560 >= 0x40) {
                unint64_t v560 = 64LL;
              }
              char v561 = v560 - v559;
              if (v560 < v559) {
                char v561 = 0;
              }
              uint64_t v562 = ~(-1LL << v561);
              if (v559 <= v560) {
                char v563 = v559 & 0x3F;
              }
              else {
                char v563 = 0;
              }
              *(void *)(a1 + 72) = (v562 << v563) | v558;
              uint64_t v564 = *((void *)v552 + 1);
              v565 = GTTraceFunc_argumentBytesWithMap(a2, v552[24], a3);
              if ((int)*((void *)v27 + 2) >= 1)
              {
                v566 = (void *)(a1 + 8 * v564 + 80);
                uint64_t v567 = *((void *)v27 + 2);
                do
                {
                  uint64_t v568 = *(void *)v565;
                  v565 += 8;
                  *v566++ = v568;
                  --v567;
                }

                while (v567);
              }

              uint64_t v569 = a1 + 56;
              v570 = (void *)(a1 + 56 + 8LL * *((void *)v27 + 1) + 272);
              v571 = GTTraceFunc_argumentBytesWithMap(a2, v27[25], a3);
              memcpy(v570, v571, 8LL * *((void *)v27 + 2));
              uint64_t v162 = v569 + 8LL * *((void *)v27 + 1) + 520;
LABEL_495:
              unsigned int v406 = v27[26];
              goto LABEL_496;
            case -15272:
              v574 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              unint64_t v575 = *((void *)v574 + 3);
              uint64_t v576 = 1LL << v575;
              uint64_t v577 = a1 + 56 + 8LL * (int)(v575 >> 6);
              *(void *)(v577 + 8) |= v576;
              *(void *)(a1 + 80 + 8LL * *((void *)v574 + 3)) = GTTraceFunc_argumentBytesWithMap( a2,  v574[32],  a3);
              unint64_t v578 = *((void *)v574 + 3);
              uint64_t v579 = 1LL << v578;
              uint64_t v580 = a1 + 56 + 8LL * (int)(v578 >> 6);
              *(void *)(v580 + 16) |= v579;
              *(void *)(a1 + 80 + 8LL * *((void *)v574 + 3) + 24_Block_object_dispose(va, 8) = *((void *)v574 + 1);
              uint64_t v549 = *((void *)v574 + 2);
              uint64_t v550 = a1 + 56 + 8LL * *((void *)v574 + 3);
LABEL_498:
              *(void *)(v550 + 52mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v549;
              return;
            default:
              if (v7 != -15364) {
                return;
              }
              uint64_t v15 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              bzero((void *)a1, 0x2B90uLL);
              uint64_t v16 = *((void *)v15 + 1);
              if (!v16) {
                return;
              }
              int v17 = 17;
              break;
          }

          goto LABEL_385;
      }

      return;
    }

    if (v7 <= -15891)
    {
      if (v7 <= -16029)
      {
        switch(v7)
        {
          case -16087:
            int v26 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            BOOL v27 = v26;
            unint64_t v28 = *((void *)v26 + 1);
            unint64_t v29 = *((void *)v26 + 2) + v28;
            if (v29 >= 0x40) {
              unint64_t v29 = 64LL;
            }
            char v30 = v29 - v28;
            if (v29 < v28) {
              char v30 = 0;
            }
            uint64_t v31 = ~(-1LL << v30);
            if (v28 <= v29) {
              char v32 = v28 & 0x3F;
            }
            else {
              char v32 = 0;
            }
            *(void *)(a1 + 6944) &= ~(v31 << v32);
            uint64_t v33 = *((void *)v26 + 1);
            NDR_record_t v34 = GTTraceFunc_argumentBytesWithMap(a2, v26[24], a3);
            if ((int)*((void *)v27 + 2) >= 1)
            {
              int v35 = (void *)(a1 + 8 * v33 + 6952);
              uint64_t v36 = *((void *)v27 + 2);
              do
              {
                uint64_t v37 = *(void *)v34;
                v34 += 8;
                *v35++ = v37;
                --v36;
              }

              while (v36);
            }

            uint64_t v38 = a1 + 8LL * *((void *)v27 + 1);
            uint64_t v39 = 7200LL;
LABEL_164:
            uint64_t v162 = v38 + v39;
            goto LABEL_352;
          case -16086:
            v581 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            uint64_t v582 = *((void *)v581 + 1);
            v583 = GTTraceFunc_argumentBytesWithMap(a2, v581[24], a3);
            if ((int)*((void *)v581 + 2) >= 1)
            {
              v584 = (void *)(a1 + 8 * v582 + 7448);
              uint64_t v585 = *((void *)v581 + 2);
              do
              {
                uint64_t v586 = *(void *)v583;
                v583 += 8;
                *v584++ = v586;
                --v585;
              }

              while (v585);
            }

            break;
          case -16085:
            v587 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            uint64_t v588 = *((void *)v587 + 1);
            v589 = GTTraceFunc_argumentBytesWithMap(a2, v587[24], a3);
            if ((int)*((void *)v587 + 2) >= 1)
            {
              v590 = (void *)(a1 + 8 * v588 + 8472);
              uint64_t v591 = *((void *)v587 + 2);
              do
              {
                uint64_t v592 = *(void *)v589;
                v589 += 8;
                *v590++ = v592;
                --v591;
              }

              while (v591);
            }

            break;
          case -16084:
            id v171 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            uint64_t v593 = *((void *)v171 + 1);
            v594 = GTTraceFunc_argumentBytesWithMap(a2, v171[24], a3);
            if ((int)*((void *)v171 + 2) >= 1)
            {
              v595 = (void *)(a1 + 8 * v593 + 8472);
              uint64_t v596 = *((void *)v171 + 2);
              do
              {
                uint64_t v597 = *(void *)v594;
                v594 += 8;
                *v595++ = v597;
                --v596;
              }

              while (v596);
            }

            uint64_t v598 = a1 + 56;
            v599 = (void *)(a1 + 56 + 4LL * *((void *)v171 + 1) + 10548);
            v600 = GTTraceFunc_argumentBytesWithMap(a2, v171[25], a3);
            memcpy(v599, v600, 4LL * *((void *)v171 + 2));
            uint64_t v180 = v598 + 4LL * *((void *)v171 + 1);
            uint64_t v181 = 10612LL;
            goto LABEL_511;
          case -16077:
            v602 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            *(void *)(a1 + 860_Block_object_dispose(va, 8) = *((void *)v602 + 1);
            v572 = GTTraceFunc_argumentBytesWithMap(a2, v602[16], a3);
            v601 = (void *)(a1 + 8616);
            size_t v573 = 48LL * *((void *)v602 + 1);
            goto LABEL_514;
          case -16076:
            v603 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            *(void *)(a1 + 9384) = *((void *)v603 + 1);
            v572 = GTTraceFunc_argumentBytesWithMap(a2, v603[16], a3);
            v601 = (void *)(a1 + 9392);
            size_t v573 = 32LL * *((void *)v603 + 1);
            goto LABEL_514;
          case -16074:
            v604 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            *(_DWORD *)(a1 + 56 + 4LL * *((void *)v604 + 3) + 10696) = *((void *)v604 + 1);
            *(_DWORD *)(a1 + 56 + 4LL * *((void *)v604 + 3) + 1082mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v604 + 2);
            break;
          default:
            return;
        }
      }

      else
      {
        switch(v7)
        {
          case -16028:
            uint64_t v18 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            *(void *)(a1 + 8LL * *((void *)v18 + 2) + 12_Block_object_dispose(va, 8) = *((void *)v18 + 1);
            break;
          case -16027:
            break;
          case -16026:
            break;
          case -16025:
          case -16024:
          case -16023:
          case -16019:
          case -16018:
          case -16016:
          case -16015:
            return;
          case -16022:
            uint64_t v496 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            *(void *)(a1 + 8LL * *((void *)v496 + 2) + 9992) = *((void *)v496 + 1);
            break;
          case -16021:
            break;
          case -16020:
            break;
          case -16017:
            v497 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            *(void *)(a1 + 2032) = *((void *)v497 + 1);
            *(_DWORD *)(a1 + 2172) = *((void *)v497 + 2);
            break;
          case -16014:
            v498 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            bzero((void *)a1, 0x2B90uLL);
            uint64_t v499 = *((void *)v498 + 1);
            if (v499)
            {
              *(_DWORD *)a1 = 28;
              uint64_t v500 = *a2;
              *(void *)(a1 + _Block_object_dispose(va, 8) = v499;
              *(void *)(a1 + 16) = v500;
              *(void *)(a1 + 24) = -1LL;
              *(void *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)v498;
              bzero((void *)(a1 + 56), 0x888uLL);
              memset_pattern16((void *)(a1 + 2240), &unk_1CA4F0, 0x100uLL);
              *(void *)(a1 + 824) = -1LL;
              *(void *)&__int128 v501 = -1LL;
              *((void *)&v501 + 1) = -1LL;
              *(_OWORD *)(a1 + 792) = v501;
              *(_OWORD *)(a1 + 80_Block_object_dispose(va, 8) = v501;
              *(_OWORD *)(a1 + 76mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v501;
              *(_OWORD *)(a1 + 776) = v501;
              *(_OWORD *)(a1 + 72_Block_object_dispose(va, 8) = v501;
              *(_OWORD *)(a1 + 744) = v501;
              *(_OWORD *)(a1 + 696) = v501;
              *(_OWORD *)(a1 + 712) = v501;
              *(_OWORD *)(a1 + 664) = v501;
              *(_OWORD *)(a1 + 68mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v501;
              *(_OWORD *)(a1 + 632) = v501;
              *(_OWORD *)(a1 + 64_Block_object_dispose(va, 8) = v501;
              *(_OWORD *)(a1 + 60mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v501;
              *(_OWORD *)(a1 + 616) = v501;
              *(_OWORD *)(a1 + 584) = v501;
              *(_BYTE *)(a1 + 2304) = *((void *)v498 + 2);
            }

            break;
          case -16013:
            uint64_t v12 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
            bzero((void *)a1, 0x2B90uLL);
            uint64_t v13 = *((void *)v12 + 1);
            if (v13)
            {
              int v14 = 82;
              goto LABEL_433;
            }

            break;
          default:
            if (v7 == -15984)
            {
              v605 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              *(_BYTE *)(v6 + 253mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((_DWORD *)v605 + 4);
              *(_DWORD *)(a1 + 1074mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v605 + 1);
            }

            else if (v7 == -15970)
            {
              *(_BYTE *)(a1 + 11146) = *((_DWORD *)GTTraceFunc_argumentBytesWithMap( a2,  *((unsigned __int8 *)a2 + 13),  a3)
                                       + 2);
            }

            break;
        }
      }
    }

    else
    {
      if (v7 > -15649)
      {
        if (v7 > -15588)
        {
          switch(v7)
          {
            case -15587:
              uint64_t v15 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              bzero((void *)a1, 0x2B90uLL);
              uint64_t v16 = *((void *)v15 + 1);
              if (!v16) {
                return;
              }
              int v17 = 21;
              goto LABEL_385;
            case -15586:
              uint64_t v15 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              bzero((void *)a1, 0x2B90uLL);
              uint64_t v452 = *((void *)v15 + 1);
              if (!v452) {
                return;
              }
              *(_DWORD *)a1 = 28;
              uint64_t v453 = *a2;
              *(void *)(a1 + _Block_object_dispose(va, 8) = v452;
              *(void *)(a1 + 16) = v453;
              *(void *)(a1 + 24) = -1LL;
              *(void *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)v15;
              bzero((void *)(a1 + 56), 0x888uLL);
              memset_pattern16((void *)(a1 + 2240), &unk_1CA4F0, 0x100uLL);
              *(void *)(a1 + 824) = -1LL;
              *(void *)&__int128 v454 = -1LL;
              *((void *)&v454 + 1) = -1LL;
              *(_OWORD *)(a1 + 792) = v454;
              *(_OWORD *)(a1 + 80_Block_object_dispose(va, 8) = v454;
              *(_OWORD *)(a1 + 76mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v454;
              *(_OWORD *)(a1 + 776) = v454;
              *(_OWORD *)(a1 + 72_Block_object_dispose(va, 8) = v454;
              *(_OWORD *)(a1 + 744) = v454;
              *(_OWORD *)(a1 + 696) = v454;
              *(_OWORD *)(a1 + 712) = v454;
              *(_OWORD *)(a1 + 664) = v454;
              *(_OWORD *)(a1 + 68mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v454;
              *(_OWORD *)(a1 + 632) = v454;
              *(_OWORD *)(a1 + 64_Block_object_dispose(va, 8) = v454;
              *(_OWORD *)(a1 + 60mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v454;
              *(_OWORD *)(a1 + 616) = v454;
              *(_OWORD *)(a1 + 584) = v454;
              *(_BYTE *)(a1 + 2304) = -1;
              goto LABEL_386;
            case -15585:
              uint64_t v15 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              bzero((void *)a1, 0x2B90uLL);
              uint64_t v16 = *((void *)v15 + 1);
              if (!v16) {
                return;
              }
              int v17 = 74;
LABEL_385:
              *(_DWORD *)a1 = v17;
              uint64_t v455 = *a2;
              *(void *)(a1 + _Block_object_dispose(va, 8) = v16;
              *(void *)(a1 + 16) = v455;
              *(void *)(a1 + 24) = -1LL;
              *(void *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)v15;
LABEL_386:
              *(void *)(a1 + 56) = GTTraceFunc_argumentBytesWithMap(a2, v15[16], a3);
              break;
            case -15583:
            case -15581:
              goto LABEL_50;
            case -15582:
              v456 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              uint64_t v457 = v456;
              unint64_t v458 = *((void *)v456 + 1);
              unint64_t v459 = *((void *)v456 + 2) + v458;
              unint64_t v460 = 64LL;
              if (v459 >= 0x40) {
                unint64_t v459 = 64LL;
              }
              char v461 = v459 - v458;
              if (v459 < v458) {
                char v461 = 0;
              }
              uint64_t v462 = ~(-1LL << v461);
              if (v458 <= v459) {
                char v463 = v458 & 0x3F;
              }
              else {
                char v463 = 0;
              }
              uint64_t v466 = *(void *)(a1 + 80);
              v465 = (uint64_t *)(a1 + 80);
              uint64_t v464 = v466;
              *(v465 - 1) &= ~(v462 << v463);
              unint64_t v467 = *((void *)v456 + 1);
              if (*((void *)v456 + 2) + v467 < 0x40) {
                unint64_t v460 = *((void *)v456 + 2) + v467;
              }
              char v468 = v460 - v467;
              if (v460 < v467) {
                char v468 = 0;
              }
              uint64_t v469 = ~(-1LL << v468);
              if (v467 <= v460) {
                char v470 = v467 & 0x3F;
              }
              else {
                char v470 = 0;
              }
              uint64_t *v465 = v464 & ~(v469 << v470);
              uint64_t v471 = *((void *)v456 + 1);
              v472 = GTTraceFunc_argumentBytesWithMap(a2, v456[24], a3);
              if ((int)*((void *)v457 + 2) >= 1)
              {
                uint64_t v473 = &v465[v471 + 1];
                uint64_t v474 = *((void *)v457 + 2);
                do
                {
                  uint64_t v475 = *(void *)v472;
                  v472 += 8;
                  *v473++ = v475;
                  --v474;
                }

                while (v474);
              }

              return;
            case -15580:
              uint64_t v476 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              uint64_t v477 = v476;
              unint64_t v478 = *((void *)v476 + 1);
              unint64_t v479 = *((void *)v476 + 2) + v478;
              unint64_t v480 = 64LL;
              if (v479 >= 0x40) {
                unint64_t v479 = 64LL;
              }
              char v481 = v479 - v478;
              if (v479 < v478) {
                char v481 = 0;
              }
              uint64_t v482 = ~(-1LL << v481);
              if (v478 <= v479) {
                char v483 = v478 & 0x3F;
              }
              else {
                char v483 = 0;
              }
              uint64_t v486 = *(void *)(a1 + 80);
              uint64_t v485 = (uint64_t *)(a1 + 80);
              uint64_t v484 = v486;
              *(v485 - 1) &= ~(v482 << v483);
              unint64_t v487 = *((void *)v476 + 1);
              if (*((void *)v476 + 2) + v487 < 0x40) {
                unint64_t v480 = *((void *)v476 + 2) + v487;
              }
              char v488 = v480 - v487;
              if (v480 < v487) {
                char v488 = 0;
              }
              uint64_t v489 = ~(-1LL << v488);
              if (v487 <= v480) {
                char v490 = v487 & 0x3F;
              }
              else {
                char v490 = 0;
              }
              *uint64_t v485 = v484 & ~(v489 << v490);
              uint64_t v491 = *((void *)v476 + 1);
              v492 = GTTraceFunc_argumentBytesWithMap(a2, v476[24], a3);
              if ((int)*((void *)v477 + 2) >= 1)
              {
                uint64_t v493 = &v485[v491 + 1];
                uint64_t v494 = *((void *)v477 + 2);
                do
                {
                  uint64_t v495 = *(void *)v492;
                  v492 += 8;
                  *v493++ = v495;
                  --v494;
                }

                while (v494);
              }

              return;
            default:
              return;
          }

          return;
        }

        if (v7 != -15648)
        {
          if (v7 != -15642)
          {
            if (v7 == -15623)
            {
LABEL_50:
              unint64_t v51 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
              unint64_t v52 = *((void *)v51 + 2);
              uint64_t v53 = 1LL << v52;
              uint64_t v54 = a1 + 8LL * (int)(v52 >> 6);
              *(void *)(v54 + 72) &= ~v53;
              *(void *)(a1 + 80 + 8LL * *((void *)v51 + 2) + _Block_object_dispose(va, 8) = *((void *)v51 + 1);
              *(void *)(a1 + 80 + 8LL * (int)(*((void *)v51 + 2) >> 6)) &= ~(1LL << *((void *)v51 + 2));
            }

            return;
          }

LABEL_65:
          *(void *)(a1 + 24) = *a2;
          return;
        }

LABEL_54:
        id v55 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(void *)(a1 + 4_Block_object_dispose(va, 8) = GTTraceFunc_argumentBytesWithMap(a2, v55[8], a3);
        return;
      }

      if (v7 <= -15823)
      {
        if (v7 > -15885)
        {
          if (v7 == -15884) {
            goto LABEL_65;
          }
          if (v7 != -15870) {
            return;
          }
          uint64_t v12 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          bzero((void *)a1, 0x2B90uLL);
          uint64_t v13 = *((void *)v12 + 1);
          if (!v13) {
            return;
          }
          int v14 = 74;
          goto LABEL_433;
        }

        if (v7 == -15890) {
          goto LABEL_54;
        }
        if (v7 == -15888) {
          *(void *)(a1 + 56) = *((void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3) + 1);
        }
      }

      else
      {
        if (v7 > -15795)
        {
          if (v7 == -15794) {
            goto LABEL_54;
          }
          if (v7 == -15789) {
            goto LABEL_65;
          }
          if (v7 != -15673) {
            return;
          }
          uint64_t v12 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          bzero((void *)a1, 0x2B90uLL);
          uint64_t v13 = *((void *)v12 + 1);
          if (!v13) {
            return;
          }
          int v14 = 17;
LABEL_433:
          *(_DWORD *)a1 = v14;
          uint64_t v502 = *a2;
          *(void *)(a1 + _Block_object_dispose(va, 8) = v13;
          *(void *)(a1 + 16) = v502;
          *(void *)(a1 + 24) = -1LL;
          *(void *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)v12;
          return;
        }

        if (v7 == -15822)
        {
          v606 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(_DWORD *)(a1 + 1112_Block_object_dispose(va, 8) = *((void *)v606 + 1);
          *(void *)(a1 + 9912) = GTTraceFunc_argumentBytesWithMap(a2, v606[16], a3);
        }

        else if (v7 == -15812)
        {
          id v56 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(_BYTE *)(v6 + 2524) = *((void *)v56 + 1);
          *(_DWORD *)(a1 + 11124) = *((void *)v56 + 2);
        }
      }
    }
  }

void *GTMTLSMBuilder_commitObject(uint64_t a1, void *a2)
{
  uint64_t v4 = a2 + 1;
  uint64_t v5 = *find_entry(*(void *)(a1 + 32), (_BYTE *)a2 + 8, 8uLL, 0LL);
  if (v5) {
    uint64_t v5 = *(void *)(v5 + 32);
  }
  a2[4] = v5;
  apr_hash_set(*(apr_hash_t **)(a1 + 32), v4, 8LL, a2);
  return a2;
}

BOOL GTMTLSMBuilder_streamIntersectionRange(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0LL;
  }
  uint64_t v5 = *(void *)(a3 + 32);
  if (v5 && (*(_BYTE *)(v5 + 79) & 8) != 0) {
    uint64_t v6 = (void *)(v5 + 64);
  }
  else {
    uint64_t v6 = 0LL;
  }
  uint64_t Func = GTTraceStream_lastFunc(a3);
  if (*v6 >= a1 + a2) {
    return 0LL;
  }
  unint64_t v9 = (unint64_t *)Func;
  return !IsFuncEnumDestructor(*(_DWORD *)(Func + 8)) || a1 <= *v9;
}

uint64_t GTMTLSMBuilder_getStreamObjectType(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 32)) != 0 && (*(_BYTE *)(v1 + 79) & 8) != 0) {
    return GetFuncEnumConstructorType(*(_DWORD *)(v1 + 72));
  }
  else {
    return 0LL;
  }
}

void GTMTLSMBuilder_buffer(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v46 = 0u;
  *(void *)&__int128 v47 = 0LL;
  __int128 v52 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v51 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  LODWORD(v46) = 22;
  *((void *)&v47 + 1) = -1LL;
  WORD1(v52) = 2;
  __int128 v50 = 0xFFFFFFFFFFFFFFFFLL;
  __int128 v53 = 0xFFFFFFFFFFFFFFFFLL;
  *((void *)&v48 + 1) = *(void *)a1;
  ++*(_DWORD *)(a1 + 48);
  if (a2 && (uint64_t v4 = *(void *)(a2 + 32)) != 0 && (*(_BYTE *)(v4 + 79) & 8) != 0) {
    uint64_t v5 = (uint64_t *)(v4 + 64);
  }
  else {
    uint64_t v5 = 0LL;
  }
  GTMTLSMBuffer_processTraceFuncWithMap((char *)&v46, *(void *)(a1 + 40), v5);
  uint64_t v6 = *(void *)(a2 + 32);
  if (v6)
  {
    unsigned int v7 = 0;
    while (1)
    {
      unsigned int v8 = atomic_load((unsigned int *)(v6 + 4));
      uint64_t v9 = v7 + (v8 >> 6) - 1;
      uint64_t v6 = *(void *)(v6 + 40);
      unsigned int v7 = v9;
      if (!v6)
      {
        unsigned int v7 = v9;
        goto LABEL_13;
      }
    }

    uint64_t v9 = 1LL;
  }

  else
  {
    unsigned int v7 = 0;
    uint64_t v9 = 0LL;
  }

void GTMTLSMBuilder_texture(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v55 = 0u;
  *(void *)&__int128 v56 = 0LL;
  __int128 v66 = 0u;
  __int128 v67 = 0u;
  __int128 v64 = 0u;
  __int128 v65 = 0u;
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v58 = 0u;
  __int128 v57 = 0u;
  LODWORD(v55) = 80;
  *((void *)&v56 + 1) = -1LL;
  WORD1(v61) = 2;
  __int128 v59 = 0xFFFFFFFFFFFFFFFFLL;
  uint64_t v68 = 0xFFFFFFFFLL;
  *((void *)&v57 + 1) = *(void *)a1;
  ++*(_DWORD *)(a1 + 52);
  if (a2 && (uint64_t v4 = *(void *)(a2 + 32)) != 0 && (*(_BYTE *)(v4 + 79) & 8) != 0) {
    uint64_t v5 = (uint64_t *)(v4 + 64);
  }
  else {
    uint64_t v5 = 0LL;
  }
  GTMTLSMTexture_processTraceFuncWithMap((char *)&v55, *(void *)(a1 + 40), v5);
  uint64_t v6 = *(void *)(a2 + 32);
  if (v6)
  {
    unsigned int v7 = 0;
    while (1)
    {
      unsigned int v8 = atomic_load((unsigned int *)(v6 + 4));
      uint64_t v9 = v7 + (v8 >> 6) - 1;
      uint64_t v6 = *(void *)(v6 + 40);
      unsigned int v7 = v9;
      if (!v6)
      {
        unsigned int v7 = v9;
        goto LABEL_13;
      }
    }

    uint64_t v9 = 1LL;
  }

  else
  {
    unsigned int v7 = 0;
    uint64_t v9 = 0LL;
  }

void GTMTLSMBuilder_counterSampleBuffer(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v21 = 0u;
    *(void *)&__int128 v22 = 0LL;
    __int128 v23 = 0u;
    LODWORD(v21) = 31;
    *((void *)&v22 + 1) = -1LL;
    *((void *)&v23 + 1) = *(void *)a1;
    uint64_t v24 = 0LL;
    ++*(_DWORD *)(a1 + 124);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        uint64_t v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
        __int128 v17 = v22;
        _OWORD *v16 = v21;
        v16[1] = v17;
        void v16[2] = v23;
        *((void *)v16 + 6) = v24;
        uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v18) {
          uint64_t v18 = *(void *)(v18 + 32);
        }
        *((void *)v16 + 4) = v18;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -15867) {
        break;
      }
      GTMTLSMCounterSampleBuffer_processTraceFuncWithMap((char *)&v21, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      uint64_t v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
      __int128 v19 = v22;
      _OWORD *v16 = v21;
      v16[1] = v19;
      void v16[2] = v23;
      *((void *)v16 + 6) = v24;
      uint64_t v20 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v20) {
        uint64_t v20 = *(void *)(v20 + 32);
      }
      *((void *)v16 + 4) = v20;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_indirectCommandBuffer(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v35 = 0u;
  *(void *)&__int128 v36 = 0LL;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v37 = 0u;
  LODWORD(v35) = 57;
  *((void *)&v36 + 1) = -1LL;
  WORD1(v41) = 2;
  __int128 v39 = 0xFFFFFFFFFFFFFFFFLL;
  ++*(_DWORD *)(a1 + 68);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (1)
  {
    if (!v4
      || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
      || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
          unint64_t v11 = *(void *)(a1 + 8),
          unint64_t v12 = *(void *)v10,
          *(void *)v10 >= *(void *)(a1 + 16) + v11))
    {
      uint64_t v24 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x90uLL);
      __int128 v25 = v42;
      v24[6] = v41;
      v24[7] = v25;
      v24[8] = v43;
      __int128 v26 = v38;
      void v24[2] = v37;
      int8x16_t v24[3] = v26;
      __int128 v27 = v40;
      v24[4] = v39;
      v24[5] = v27;
      __int128 v28 = v36;
      _OWORD *v24 = v35;
      v24[1] = v28;
      uint64_t v29 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v24 + 8, 8uLL, 0LL);
      if (v29) {
        uint64_t v29 = *(void *)(v29 + 32);
      }
      *((void *)v24 + 4) = v29;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v24 + 8, 8LL, v24);
      unint64_t v12 = -1LL;
      goto LABEL_29;
    }

    int v13 = *(_DWORD *)(v10 + 8);
    if (v13 == -15925 || v13 == -15919)
    {
      if (v11 <= v12)
      {
        uint64_t v15 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x90uLL);
        __int128 v16 = v42;
        *((_OWORD *)v15 + 6) = v41;
        *((_OWORD *)v15 + 7) = v16;
        *((_OWORD *)v15 + _Block_object_dispose(va, 8) = v43;
        __int128 v17 = v38;
        *((_OWORD *)v15 + 2) = v37;
        *((_OWORD *)v15 + 3) = v17;
        __int128 v18 = v40;
        *((_OWORD *)v15 + 4) = v39;
        *((_OWORD *)v15 + 5) = v18;
        __int128 v19 = v36;
        *(_OWORD *)uint64_t v15 = v35;
        *((_OWORD *)v15 + 1) = v19;
        uint64_t v20 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v15 + 8, 8uLL, 0LL);
        if (v20) {
          uint64_t v20 = *(void *)(v20 + 32);
        }
        void v15[4] = v20;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v15 + 1, 8LL, v15);
        v15[3] = v12;
      }

      goto LABEL_24;
    }

    if (v13 == -15923) {
      break;
    }
LABEL_24:
    GTMTLSMIndirectCommandBuffer_processTraceFuncWithMap((char *)&v35, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v21 = atomic_load((unsigned int *)(v4 + 4));
    int v22 = v8 + (v21 >> 6);
    uint64_t v23 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v23 << 32) | v8;
    if ((_DWORD)v23 == v22 - 1)
    {
      unint64_t v8 = (v23 << 32) | v23;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  if (v11 <= v12)
  {
    uint64_t v24 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x90uLL);
    __int128 v30 = v42;
    v24[6] = v41;
    v24[7] = v30;
    v24[8] = v43;
    __int128 v31 = v38;
    void v24[2] = v37;
    int8x16_t v24[3] = v31;
    __int128 v32 = v40;
    v24[4] = v39;
    v24[5] = v32;
    __int128 v33 = v36;
    _OWORD *v24 = v35;
    v24[1] = v33;
    uint64_t v34 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v24 + 8, 8uLL, 0LL);
    if (v34) {
      uint64_t v34 = *(void *)(v34 + 32);
    }
    *((void *)v24 + 4) = v34;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v24 + 8, 8LL, v24);
LABEL_29:
    *((void *)v24 + 3) = v12;
  }

void GTMTLSMBuilder_heap(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v29 = 0u;
  *(void *)&__int128 v30 = 0LL;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v31 = 0u;
  LODWORD(v29) = 50;
  *((void *)&v30 + 1) = -1LL;
  uint64_t v34 = 2LL;
  ++*(_DWORD *)(a1 + 84);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (1)
  {
    if (!v4
      || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
      || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
          unint64_t v11 = *(void *)(a1 + 8),
          unint64_t v12 = *(void *)v10,
          *(void *)v10 >= *(void *)(a1 + 16) + v11))
    {
      int v22 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x58uLL);
      __int128 v23 = v32;
      v22[2] = v31;
      int8x16_t v22[3] = v23;
      void v22[4] = v33;
      *((void *)v22 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v34;
      __int128 v24 = v30;
      *int v22 = v29;
      v22[1] = v24;
      uint64_t v25 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v22 + 8, 8uLL, 0LL);
      if (v25) {
        uint64_t v25 = *(void *)(v25 + 32);
      }
      *((void *)v22 + 4) = v25;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v22 + 8, 8LL, v22);
      unint64_t v12 = -1LL;
      goto LABEL_31;
    }

    int v13 = *(_DWORD *)(v10 + 8);
    if (v13 > -10209)
    {
      goto LABEL_26;
    }

    if (v13 == -16119 || v13 == -16115)
    {
LABEL_22:
      if (v11 <= v12)
      {
        uint64_t v15 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x58uLL);
        __int128 v16 = v32;
        *((_OWORD *)v15 + 2) = v31;
        *((_OWORD *)v15 + 3) = v16;
        *((_OWORD *)v15 + 4) = v33;
        v15[10] = v34;
        __int128 v17 = v30;
        *(_OWORD *)uint64_t v15 = v29;
        *((_OWORD *)v15 + 1) = v17;
        uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v15 + 8, 8uLL, 0LL);
        if (v18) {
          uint64_t v18 = *(void *)(v18 + 32);
        }
        void v15[4] = v18;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v15 + 1, 8LL, v15);
        v15[3] = v12;
      }

      goto LABEL_26;
    }

    if (v13 == -16118) {
      break;
    }
LABEL_26:
    GTMTLSMHeap_processTraceFuncWithMap((char *)&v29, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v19 = atomic_load((unsigned int *)(v4 + 4));
    int v20 = v8 + (v19 >> 6);
    uint64_t v21 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v21 << 32) | v8;
    if ((_DWORD)v21 == v20 - 1)
    {
      unint64_t v8 = (v21 << 32) | v21;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  if (v11 <= v12)
  {
    int v22 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x58uLL);
    __int128 v26 = v32;
    v22[2] = v31;
    int8x16_t v22[3] = v26;
    void v22[4] = v33;
    *((void *)v22 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v34;
    __int128 v27 = v30;
    *int v22 = v29;
    v22[1] = v27;
    uint64_t v28 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v22 + 8, 8uLL, 0LL);
    if (v28) {
      uint64_t v28 = *(void *)(v28 + 32);
    }
    *((void *)v22 + 4) = v28;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v22 + 8, 8LL, v22);
LABEL_31:
    *((void *)v22 + 3) = v12;
  }

void GTMTLSMBuilder_depthStencilState(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v21 = 0u;
    *(void *)&__int128 v22 = 0LL;
    uint64_t v24 = 0LL;
    __int128 v23 = 0u;
    LODWORD(v21) = 34;
    *((void *)&v22 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 120);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
        __int128 v17 = v22;
        _OWORD *v16 = v21;
        v16[1] = v17;
        void v16[2] = v23;
        *((void *)v16 + 6) = v24;
        uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v18) {
          uint64_t v18 = *(void *)(v18 + 32);
        }
        *((void *)v16 + 4) = v18;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -16320) {
        break;
      }
      GTMTLSMDepthStencilState_processTraceFuncWithMap((char *)&v21, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
      __int128 v19 = v22;
      _OWORD *v16 = v21;
      v16[1] = v19;
      void v16[2] = v23;
      *((void *)v16 + 6) = v24;
      uint64_t v20 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v20) {
        uint64_t v20 = *(void *)(v20 + 32);
      }
      *((void *)v16 + 4) = v20;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_samplerState(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v23 = 0u;
    *(void *)&__int128 v24 = 0LL;
    __int128 v26 = 0u;
    __int128 v25 = 0u;
    LODWORD(v23) = 75;
    *((void *)&v24 + 1) = -1LL;
    uint64_t v28 = 0LL;
    __int128 v27 = 0xFFFFFFFFFFFFFFFFLL;
    ++*(_DWORD *)(a1 + 56);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x58uLL);
        __int128 v17 = v26;
        void v16[2] = v25;
        v16[3] = v17;
        void v16[4] = v27;
        *((void *)v16 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v28;
        __int128 v18 = v24;
        _OWORD *v16 = v23;
        v16[1] = v18;
        uint64_t v19 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v19) {
          uint64_t v19 = *(void *)(v19 + 32);
        }
        *((void *)v16 + 4) = v19;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -16241) {
        break;
      }
      GTMTLSMSamplerState_processTraceFuncWithMap((char *)&v23, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x58uLL);
      __int128 v20 = v26;
      void v16[2] = v25;
      v16[3] = v20;
      void v16[4] = v27;
      *((void *)v16 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v28;
      __int128 v21 = v24;
      _OWORD *v16 = v23;
      v16[1] = v21;
      uint64_t v22 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v22) {
        uint64_t v22 = *(void *)(v22 + 32);
      }
      *((void *)v16 + 4) = v22;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_event(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v25 = 0u;
  *(void *)&__int128 v26 = 0LL;
  uint64_t v28 = 0LL;
  __int128 v27 = 0u;
  LODWORD(v25) = 38;
  *((void *)&v26 + 1) = -1LL;
  ++*(_DWORD *)(a1 + 104);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (1)
  {
    if (!v4
      || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
      || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
          unint64_t v11 = *(void *)(a1 + 8),
          unint64_t v12 = *(void *)v10,
          *(void *)v10 >= *(void *)(a1 + 16) + v11))
    {
      __int128 v20 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
      __int128 v21 = v26;
      *__int128 v20 = v25;
      v20[1] = v21;
      v20[2] = v27;
      *((void *)v20 + 6) = v28;
      uint64_t v22 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v20 + 8, 8uLL, 0LL);
      if (v22) {
        uint64_t v22 = *(void *)(v22 + 32);
      }
      *((void *)v20 + 4) = v22;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v20 + 8, 8LL, v20);
      unint64_t v12 = -1LL;
      goto LABEL_26;
    }

    int v13 = *(_DWORD *)(v10 + 8);
    if (v13 == -15880)
    {
      if (v11 <= v12)
      {
        int v14 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
        __int128 v15 = v26;
        *(_OWORD *)int v14 = v25;
        *((_OWORD *)v14 + 1) = v15;
        *((_OWORD *)v14 + 2) = v27;
        v14[6] = v28;
        uint64_t v16 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v14 + 8, 8uLL, 0LL);
        if (v16) {
          uint64_t v16 = *(void *)(v16 + 32);
        }
        void v14[4] = v16;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v14 + 1, 8LL, v14);
        v14[3] = v12;
      }

      goto LABEL_21;
    }

    if (v13 == -15879) {
      break;
    }
LABEL_21:
    GTMTLSMEvent_processTraceFuncWithMap((char *)&v25, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v17 = atomic_load((unsigned int *)(v4 + 4));
    int v18 = v8 + (v17 >> 6);
    uint64_t v19 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v19 << 32) | v8;
    if ((_DWORD)v19 == v18 - 1)
    {
      unint64_t v8 = (v19 << 32) | v19;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  if (v11 <= v12)
  {
    __int128 v20 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
    __int128 v23 = v26;
    *__int128 v20 = v25;
    v20[1] = v23;
    v20[2] = v27;
    *((void *)v20 + 6) = v28;
    uint64_t v24 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v20 + 8, 8uLL, 0LL);
    if (v24) {
      uint64_t v24 = *(void *)(v24 + 32);
    }
    *((void *)v20 + 4) = v24;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v20 + 8, 8LL, v20);
LABEL_26:
    *((void *)v20 + 3) = v12;
  }

void GTMTLSMBuilder_sharedEvent(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v28 = 0u;
  *(void *)&__int128 v29 = 0LL;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v30 = 0u;
  LODWORD(v2_Block_object_dispose(va, 8) = 76;
  *((void *)&v29 + 1) = -1LL;
  ++*(_DWORD *)(a1 + 108);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (1)
  {
    if (!v4
      || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
      || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
          unint64_t v11 = *(void *)(a1 + 8),
          unint64_t v12 = *(void *)v10,
          *(void *)v10 >= *(void *)(a1 + 16) + v11))
    {
      __int128 v21 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x50uLL);
      __int128 v22 = v31;
      v21[2] = v30;
      _OWORD v21[3] = v22;
      void v21[4] = v32;
      __int128 v23 = v29;
      _OWORD *v21 = v28;
      v21[1] = v23;
      uint64_t v24 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v21 + 8, 8uLL, 0LL);
      if (v24) {
        uint64_t v24 = *(void *)(v24 + 32);
      }
      *((void *)v21 + 4) = v24;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v21 + 8, 8LL, v21);
      unint64_t v12 = -1LL;
      goto LABEL_25;
    }

    int v13 = *(_DWORD *)(v10 + 8);
    if ((v13 + 15975) < 2)
    {
      if (v11 <= v12)
      {
        int v14 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x50uLL);
        __int128 v15 = v31;
        *((_OWORD *)v14 + 2) = v30;
        *((_OWORD *)v14 + 3) = v15;
        *((_OWORD *)v14 + 4) = v32;
        __int128 v16 = v29;
        *(_OWORD *)int v14 = v28;
        *((_OWORD *)v14 + 1) = v16;
        uint64_t v17 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v14 + 8, 8uLL, 0LL);
        if (v17) {
          uint64_t v17 = *(void *)(v17 + 32);
        }
        void v14[4] = v17;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v14 + 1, 8LL, v14);
        v14[3] = v12;
      }

      goto LABEL_20;
    }

    if (v13 == -15973) {
      break;
    }
LABEL_20:
    GTMTLSMSharedEvent_processTraceFuncWithMap((char *)&v28, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v18 = atomic_load((unsigned int *)(v4 + 4));
    int v19 = v8 + (v18 >> 6);
    uint64_t v20 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v20 << 32) | v8;
    if ((_DWORD)v20 == v19 - 1)
    {
      unint64_t v8 = (v20 << 32) | v20;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  if (v11 <= v12)
  {
    __int128 v21 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x50uLL);
    __int128 v25 = v31;
    v21[2] = v30;
    _OWORD v21[3] = v25;
    void v21[4] = v32;
    __int128 v26 = v29;
    _OWORD *v21 = v28;
    v21[1] = v26;
    uint64_t v27 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v21 + 8, 8uLL, 0LL);
    if (v27) {
      uint64_t v27 = *(void *)(v27 + 32);
    }
    *((void *)v21 + 4) = v27;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v21 + 8, 8LL, v21);
LABEL_25:
    *((void *)v21 + 3) = v12;
  }

void GTMTLSMBuilder_lateEvalEvent(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v28 = 0u;
  *(void *)&__int128 v29 = 0LL;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v30 = 0u;
  LODWORD(v2_Block_object_dispose(va, 8) = 61;
  *((void *)&v29 + 1) = -1LL;
  ++*(_DWORD *)(a1 + 112);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (1)
  {
    if (!v4
      || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
      || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
          unint64_t v11 = *(void *)(a1 + 8),
          unint64_t v12 = *(void *)v10,
          *(void *)v10 >= *(void *)(a1 + 16) + v11))
    {
      __int128 v21 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x50uLL);
      __int128 v22 = v31;
      v21[2] = v30;
      _OWORD v21[3] = v22;
      void v21[4] = v32;
      __int128 v23 = v29;
      _OWORD *v21 = v28;
      v21[1] = v23;
      uint64_t v24 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v21 + 8, 8uLL, 0LL);
      if (v24) {
        uint64_t v24 = *(void *)(v24 + 32);
      }
      *((void *)v21 + 4) = v24;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v21 + 8, 8LL, v21);
      unint64_t v12 = -1LL;
      goto LABEL_25;
    }

    int v13 = *(_DWORD *)(v10 + 8);
    if ((v13 + 15491) < 2)
    {
      if (v11 <= v12)
      {
        int v14 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x50uLL);
        __int128 v15 = v31;
        *((_OWORD *)v14 + 2) = v30;
        *((_OWORD *)v14 + 3) = v15;
        *((_OWORD *)v14 + 4) = v32;
        __int128 v16 = v29;
        *(_OWORD *)int v14 = v28;
        *((_OWORD *)v14 + 1) = v16;
        uint64_t v17 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v14 + 8, 8uLL, 0LL);
        if (v17) {
          uint64_t v17 = *(void *)(v17 + 32);
        }
        void v14[4] = v17;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v14 + 1, 8LL, v14);
        v14[3] = v12;
      }

      goto LABEL_20;
    }

    if (v13 == -15489) {
      break;
    }
LABEL_20:
    GTMTLSMLateEvalEvent_processTraceFuncWithMap((char *)&v28, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v18 = atomic_load((unsigned int *)(v4 + 4));
    int v19 = v8 + (v18 >> 6);
    uint64_t v20 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v20 << 32) | v8;
    if ((_DWORD)v20 == v19 - 1)
    {
      unint64_t v8 = (v20 << 32) | v20;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  if (v11 <= v12)
  {
    __int128 v21 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x50uLL);
    __int128 v25 = v31;
    v21[2] = v30;
    _OWORD v21[3] = v25;
    void v21[4] = v32;
    __int128 v26 = v29;
    _OWORD *v21 = v28;
    v21[1] = v26;
    uint64_t v27 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v21 + 8, 8uLL, 0LL);
    if (v27) {
      uint64_t v27 = *(void *)(v27 + 32);
    }
    *((void *)v21 + 4) = v27;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v21 + 8, 8LL, v21);
LABEL_25:
    *((void *)v21 + 3) = v12;
  }

void GTMTLSMBuilder_fence(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v21 = 0u;
    *(void *)&__int128 v22 = 0LL;
    uint64_t v24 = 0LL;
    __int128 v23 = 0u;
    LODWORD(v21) = 41;
    *((void *)&v22 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 100);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
        __int128 v17 = v22;
        _OWORD *v16 = v21;
        v16[1] = v17;
        void v16[2] = v23;
        *((void *)v16 + 6) = v24;
        uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v18) {
          uint64_t v18 = *(void *)(v18 + 32);
        }
        *((void *)v16 + 4) = v18;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -16127) {
        break;
      }
      GTMTLSMFence_processTraceFuncWithMap((char *)&v21, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
      __int128 v19 = v22;
      _OWORD *v16 = v21;
      v16[1] = v19;
      void v16[2] = v23;
      *((void *)v16 + 6) = v24;
      uint64_t v20 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v20) {
        uint64_t v20 = *(void *)(v20 + 32);
      }
      *((void *)v16 + 4) = v20;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_renderPipelineState(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    memset(&v19[7], 0, 304);
    memset(&v19[2], 0, 64);
    memset(v19, 0, 24);
    LODWORD(v19[0]) = 71;
    *((void *)&v19[1] + 1) = -1LL;
    v19[6] = 0xFFFFFFFFFFFFFFFFLL;
    ++*(_DWORD *)(a1 + 60);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = (char *)apr_palloc(*(apr_pool_t **)(a1 + 24), 0x1A0uLL);
        memcpy(v16, v19, 0x1A0uLL);
        uint64_t v17 = *find_entry(*(void *)(a1 + 32), v16 + 8, 8uLL, 0LL);
        if (v17) {
          uint64_t v17 = *(void *)(v17 + 32);
        }
        *((void *)v16 + 4) = v17;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -16242) {
        break;
      }
      GTMTLSMRenderPipelineState_processTraceFuncWithMap((char *)v19, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = (char *)apr_palloc(*(apr_pool_t **)(a1 + 24), 0x1A0uLL);
      memcpy(v16, v19, 0x1A0uLL);
      uint64_t v18 = *find_entry(*(void *)(a1 + 32), v16 + 8, 8uLL, 0LL);
      if (v18) {
        uint64_t v18 = *(void *)(v18 + 32);
      }
      *((void *)v16 + 4) = v18;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_computePipelineState(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v37 = 0u;
    *(void *)&__int128 v38 = 0LL;
    uint64_t v49 = 0LL;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    __int128 v44 = 0u;
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    LODWORD(v37) = 29;
    *((void *)&v38 + 1) = -1LL;
    __int128 v43 = 0xFFFFFFFFFFFFFFFFLL;
    ++*(_DWORD *)(a1 + 64);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xC8uLL);
        _OWORD *v16 = v37;
        __int128 v17 = v41;
        __int128 v19 = v38;
        __int128 v18 = v39;
        v16[3] = v40;
        void v16[4] = v17;
        v16[1] = v19;
        void v16[2] = v18;
        __int128 v20 = v45;
        __int128 v22 = v42;
        __int128 v21 = v43;
        v16[7] = v44;
        v16[8] = v20;
        v16[5] = v22;
        v16[6] = v21;
        __int128 v24 = v47;
        __int128 v23 = v48;
        __int128 v25 = v46;
        *((void *)v16 + 24) = v49;
        v16[10] = v24;
        v16[11] = v23;
        v16[9] = v25;
        uint64_t v26 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v26) {
          uint64_t v26 = *(void *)(v26 + 32);
        }
        *((void *)v16 + 4) = v26;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -16321) {
        break;
      }
      GTMTLSMComputePipelineState_processTraceFuncWithMap((char *)&v37, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xC8uLL);
      _OWORD *v16 = v37;
      __int128 v27 = v41;
      __int128 v29 = v38;
      __int128 v28 = v39;
      v16[3] = v40;
      void v16[4] = v27;
      v16[1] = v29;
      void v16[2] = v28;
      __int128 v30 = v45;
      __int128 v32 = v42;
      __int128 v31 = v43;
      v16[7] = v44;
      v16[8] = v30;
      v16[5] = v32;
      v16[6] = v31;
      __int128 v34 = v47;
      __int128 v33 = v48;
      __int128 v35 = v46;
      *((void *)v16 + 24) = v49;
      v16[10] = v34;
      v16[11] = v33;
      v16[9] = v35;
      uint64_t v36 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v36) {
        uint64_t v36 = *(void *)(v36 + 32);
      }
      *((void *)v16 + 4) = v36;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_function(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v41 = 0u;
    *(void *)&__int128 v42 = 0LL;
    uint64_t v49 = 0LL;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    __int128 v43 = 0u;
    __int128 v44 = 0u;
    LODWORD(v41) = 43;
    *((void *)&v42 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 156);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (v4)
    {
      uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6);
      unint64_t v11 = *(void *)(a1 + 8);
      unint64_t v12 = *(void *)v10;
      if (*(void *)v10 >= *(void *)(a1 + 16) + v11) {
        break;
      }
      int v13 = *(_DWORD *)(v10 + 8);
      if (v13 == -16123 || v13 == -10157)
      {
        if (v11 <= v12)
        {
          uint64_t v15 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x88uLL);
          *(_OWORD *)uint64_t v15 = v41;
          __int128 v16 = v45;
          __int128 v18 = v42;
          __int128 v17 = v43;
          *((_OWORD *)v15 + 3) = v44;
          *((_OWORD *)v15 + 4) = v16;
          *((_OWORD *)v15 + 1) = v18;
          *((_OWORD *)v15 + 2) = v17;
          __int128 v20 = v47;
          __int128 v19 = v48;
          __int128 v21 = v46;
          v15[16] = v49;
          *((_OWORD *)v15 + 6) = v20;
          *((_OWORD *)v15 + 7) = v19;
          *((_OWORD *)v15 + 5) = v21;
          uint64_t v22 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v15 + 8, 8uLL, 0LL);
          if (v22) {
            uint64_t v22 = *(void *)(v22 + 32);
          }
          void v15[4] = v22;
          apr_hash_set(*(apr_hash_t **)(a1 + 32), v15 + 1, 8LL, v15);
          v15[3] = v12;
        }
      }

      else if (v13 == -16293)
      {
        uint64_t v26 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x88uLL);
        *uint64_t v26 = v41;
        __int128 v34 = v45;
        __int128 v36 = v42;
        __int128 v35 = v43;
        v26[3] = v44;
        void v26[4] = v34;
        v26[1] = v36;
        v26[2] = v35;
        __int128 v38 = v47;
        __int128 v37 = v48;
        __int128 v39 = v46;
        *((void *)v26 + 16) = v49;
        void v26[6] = v38;
        v26[7] = v37;
        v26[5] = v39;
        uint64_t v40 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v26 + 8, 8uLL, 0LL);
        if (v40) {
          uint64_t v40 = *(void *)(v40 + 32);
        }
        *((void *)v26 + 4) = v40;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v26 + 8, 8LL, v26);
        goto LABEL_29;
      }

      GTMTLSMFunction_processTraceFuncWithMap((uint64_t)&v41, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v23 = atomic_load((unsigned int *)(v4 + 4));
      int v24 = v8 + (v23 >> 6);
      uint64_t v25 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v25 << 32) | v8;
      if ((_DWORD)v25 == v24 - 1)
      {
        unint64_t v8 = (v25 << 32) | v25;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    uint64_t v26 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x88uLL);
    *uint64_t v26 = v41;
    __int128 v27 = v45;
    __int128 v29 = v42;
    __int128 v28 = v43;
    v26[3] = v44;
    void v26[4] = v27;
    v26[1] = v29;
    v26[2] = v28;
    __int128 v31 = v47;
    __int128 v30 = v48;
    __int128 v32 = v46;
    *((void *)v26 + 16) = v49;
    void v26[6] = v31;
    v26[7] = v30;
    v26[5] = v32;
    uint64_t v33 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v26 + 8, 8uLL, 0LL);
    if (v33) {
      uint64_t v33 = *(void *)(v33 + 32);
    }
    *((void *)v26 + 4) = v33;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v26 + 8, 8LL, v26);
    unint64_t v12 = -1LL;
LABEL_29:
    *((void *)v26 + 3) = v12;
  }

void GTMTLSMBuilder_library(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v47 = 0u;
    *(void *)&__int128 v48 = 0LL;
    uint64_t v57 = 0LL;
    __int128 v55 = 0u;
    __int128 v56 = 0u;
    __int128 v53 = 0u;
    __int128 v54 = 0u;
    __int128 v51 = 0u;
    __int128 v52 = 0u;
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    LODWORD(v47) = 62;
    *((void *)&v48 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 88);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (v4)
    {
      uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6);
      unint64_t v11 = *(void *)(a1 + 8);
      unint64_t v12 = *(void *)v10;
      if (*(void *)v10 >= *(void *)(a1 + 16) + v11) {
        break;
      }
      int v13 = *(_DWORD *)(v10 + 8);
      if (v13 == -16292)
      {
        if (v11 <= v12)
        {
          int v14 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xA8uLL);
          __int128 v16 = v48;
          __int128 v15 = v49;
          *(_OWORD *)int v14 = v47;
          *((_OWORD *)v14 + 1) = v16;
          *((_OWORD *)v14 + 2) = v15;
          __int128 v17 = v53;
          __int128 v19 = v50;
          __int128 v18 = v51;
          *((_OWORD *)v14 + 5) = v52;
          *((_OWORD *)v14 + 6) = v17;
          *((_OWORD *)v14 + 3) = v19;
          *((_OWORD *)v14 + 4) = v18;
          __int128 v21 = v55;
          __int128 v20 = v56;
          __int128 v22 = v54;
          v14[20] = v57;
          *((_OWORD *)v14 + _Block_object_dispose(va, 8) = v21;
          *((_OWORD *)v14 + 9) = v20;
          *((_OWORD *)v14 + 7) = v22;
          uint64_t v23 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v14 + 8, 8uLL, 0LL);
          if (v23) {
            uint64_t v23 = *(void *)(v23 + 32);
          }
          void v14[4] = v23;
          apr_hash_set(*(apr_hash_t **)(a1 + 32), v14 + 1, 8LL, v14);
          v14[3] = v12;
        }
      }

      else if (v13 == -16291)
      {
        __int128 v36 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xA8uLL);
        __int128 v38 = v48;
        __int128 v37 = v49;
        _OWORD *v36 = v47;
        v36[1] = v38;
        v36[2] = v37;
        __int128 v39 = v53;
        __int128 v41 = v50;
        __int128 v40 = v51;
        v36[5] = v52;
        v36[6] = v39;
        void v36[3] = v41;
        v36[4] = v40;
        __int128 v43 = v55;
        __int128 v42 = v56;
        __int128 v44 = v54;
        *((void *)v36 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v57;
        v36[8] = v43;
        v36[9] = v42;
        v36[7] = v44;
        entry = find_entry(*(void *)(a1 + 32), (_BYTE *)v36 + 8, 8uLL, 0LL);
        uint64_t v46 = *entry;
        if (*entry) {
          uint64_t v46 = *(void *)(v46 + 32);
        }
        *((void *)v36 + 4) = v46;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v36 + 8, 8LL, v36);
        goto LABEL_26;
      }

      GTMTLSMLibrary_processTraceFuncWithMap((uint64_t)&v47, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v24 = atomic_load((unsigned int *)(v4 + 4));
      int v25 = v8 + (v24 >> 6);
      uint64_t v26 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v26 << 32) | v8;
      if ((_DWORD)v26 == v25 - 1)
      {
        unint64_t v8 = (v26 << 32) | v26;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    __int128 v36 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xA8uLL);
    __int128 v28 = v48;
    __int128 v27 = v49;
    _OWORD *v36 = v47;
    v36[1] = v28;
    v36[2] = v27;
    __int128 v29 = v53;
    __int128 v31 = v50;
    __int128 v30 = v51;
    v36[5] = v52;
    v36[6] = v29;
    void v36[3] = v31;
    v36[4] = v30;
    __int128 v33 = v55;
    __int128 v32 = v56;
    __int128 v34 = v54;
    *((void *)v36 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v57;
    v36[8] = v33;
    v36[9] = v32;
    v36[7] = v34;
    uint64_t v35 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v36 + 8, 8uLL, 0LL);
    if (v35) {
      uint64_t v35 = *(void *)(v35 + 32);
    }
    *((void *)v36 + 4) = v35;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v36 + 8, 8LL, v36);
    unint64_t v12 = -1LL;
LABEL_26:
    *((void *)v36 + 3) = v12;
  }

void GTMTLSMBuilder_dynamicLibrary(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v32 = 0u;
    *(void *)&__int128 v33 = 0LL;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v34 = 0u;
    LODWORD(v32) = 37;
    *((void *)&v33 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 92);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (v4)
    {
      uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6);
      unint64_t v11 = *(void *)(a1 + 8);
      unint64_t v12 = *(void *)v10;
      if (*(void *)v10 >= *(void *)(a1 + 16) + v11) {
        break;
      }
      int v13 = *(_DWORD *)(v10 + 8);
      if (v13 == -15676)
      {
        if (v11 <= v12)
        {
          int v14 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x70uLL);
          __int128 v15 = v37;
          *((_OWORD *)v14 + 4) = v36;
          *((_OWORD *)v14 + 5) = v15;
          *((_OWORD *)v14 + 6) = v38;
          __int128 v16 = v33;
          *(_OWORD *)int v14 = v32;
          *((_OWORD *)v14 + 1) = v16;
          __int128 v17 = v35;
          *((_OWORD *)v14 + 2) = v34;
          *((_OWORD *)v14 + 3) = v17;
          uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v14 + 8, 8uLL, 0LL);
          if (v18) {
            uint64_t v18 = *(void *)(v18 + 32);
          }
          void v14[4] = v18;
          apr_hash_set(*(apr_hash_t **)(a1 + 32), v14 + 1, 8LL, v14);
          v14[3] = v12;
        }
      }

      else if (v13 == -15675)
      {
        uint64_t v26 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x70uLL);
        __int128 v27 = v37;
        void v26[4] = v36;
        v26[5] = v27;
        void v26[6] = v38;
        __int128 v28 = v33;
        *uint64_t v26 = v32;
        v26[1] = v28;
        __int128 v29 = v35;
        v26[2] = v34;
        v26[3] = v29;
        entry = find_entry(*(void *)(a1 + 32), (_BYTE *)v26 + 8, 8uLL, 0LL);
        uint64_t v31 = *entry;
        if (*entry) {
          uint64_t v31 = *(void *)(v31 + 32);
        }
        *((void *)v26 + 4) = v31;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v26 + 8, 8LL, v26);
        goto LABEL_26;
      }

      GTMTLSMDynamicLibrary_processTraceFuncWithMap((char *)&v32, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v19 = atomic_load((unsigned int *)(v4 + 4));
      int v20 = v8 + (v19 >> 6);
      uint64_t v21 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v21 << 32) | v8;
      if ((_DWORD)v21 == v20 - 1)
      {
        unint64_t v8 = (v21 << 32) | v21;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    uint64_t v26 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x70uLL);
    __int128 v22 = v37;
    void v26[4] = v36;
    v26[5] = v22;
    void v26[6] = v38;
    __int128 v23 = v33;
    *uint64_t v26 = v32;
    v26[1] = v23;
    __int128 v24 = v35;
    v26[2] = v34;
    v26[3] = v24;
    uint64_t v25 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v26 + 8, 8uLL, 0LL);
    if (v25) {
      uint64_t v25 = *(void *)(v25 + 32);
    }
    *((void *)v26 + 4) = v25;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v26 + 8, 8LL, v26);
    unint64_t v12 = -1LL;
LABEL_26:
    *((void *)v26 + 3) = v12;
  }

void GTMTLSMBuilder_pipelineLibrary(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v28 = 0u;
  *(void *)&__int128 v29 = 0LL;
  uint64_t v33 = 0LL;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v30 = 0u;
  LODWORD(v2_Block_object_dispose(va, 8) = 67;
  *((void *)&v29 + 1) = -1LL;
  ++*(_DWORD *)(a1 + 96);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (1)
  {
    if (!v4
      || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
      || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
          unint64_t v11 = *(void *)(a1 + 8),
          unint64_t v12 = *(void *)v10,
          *(void *)v10 >= *(void *)(a1 + 16) + v11))
    {
      uint64_t v21 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x58uLL);
      __int128 v22 = v31;
      v21[2] = v30;
      _OWORD v21[3] = v22;
      void v21[4] = v32;
      *((void *)v21 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v33;
      __int128 v23 = v29;
      _OWORD *v21 = v28;
      v21[1] = v23;
      uint64_t v24 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v21 + 8, 8uLL, 0LL);
      if (v24) {
        uint64_t v24 = *(void *)(v24 + 32);
      }
      *((void *)v21 + 4) = v24;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v21 + 8, 8LL, v21);
      unint64_t v12 = -1LL;
      goto LABEL_26;
    }

    int v13 = *(_DWORD *)(v10 + 8);
    if (v13 == -15743)
    {
      if (v11 <= v12)
      {
        int v14 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x58uLL);
        __int128 v15 = v31;
        *((_OWORD *)v14 + 2) = v30;
        *((_OWORD *)v14 + 3) = v15;
        *((_OWORD *)v14 + 4) = v32;
        v14[10] = v33;
        __int128 v16 = v29;
        *(_OWORD *)int v14 = v28;
        *((_OWORD *)v14 + 1) = v16;
        uint64_t v17 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v14 + 8, 8uLL, 0LL);
        if (v17) {
          uint64_t v17 = *(void *)(v17 + 32);
        }
        void v14[4] = v17;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v14 + 1, 8LL, v14);
        v14[3] = v12;
      }

      goto LABEL_21;
    }

    if (v13 == -15742) {
      break;
    }
LABEL_21:
    GTMTLSMPipelineLibrary_processTraceFuncWithMap((char *)&v28, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v18 = atomic_load((unsigned int *)(v4 + 4));
    int v19 = v8 + (v18 >> 6);
    uint64_t v20 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v20 << 32) | v8;
    if ((_DWORD)v20 == v19 - 1)
    {
      unint64_t v8 = (v20 << 32) | v20;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  if (v11 <= v12)
  {
    uint64_t v21 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x58uLL);
    __int128 v25 = v31;
    v21[2] = v30;
    _OWORD v21[3] = v25;
    void v21[4] = v32;
    *((void *)v21 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v33;
    __int128 v26 = v29;
    _OWORD *v21 = v28;
    v21[1] = v26;
    uint64_t v27 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v21 + 8, 8uLL, 0LL);
    if (v27) {
      uint64_t v27 = *(void *)(v27 + 32);
    }
    *((void *)v21 + 4) = v27;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v21 + 8, 8LL, v21);
LABEL_26:
    *((void *)v21 + 3) = v12;
  }

void GTMTLSMBuilder_ioCommandQueue(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v23 = 0u;
    *(void *)&__int128 v24 = 0LL;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    LODWORD(v23) = 52;
    *((void *)&v24 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 140);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x40uLL);
        __int128 v17 = v24;
        _OWORD *v16 = v23;
        v16[1] = v17;
        __int128 v18 = v26;
        void v16[2] = v25;
        v16[3] = v18;
        uint64_t v19 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v19) {
          uint64_t v19 = *(void *)(v19 + 32);
        }
        *((void *)v16 + 4) = v19;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -15332) {
        break;
      }
      GTMTLSMIOCommandQueue_processTraceFuncWithMap((char *)&v23, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x40uLL);
      __int128 v20 = v24;
      _OWORD *v16 = v23;
      v16[1] = v20;
      __int128 v21 = v26;
      void v16[2] = v25;
      v16[3] = v21;
      uint64_t v22 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v22) {
        uint64_t v22 = *(void *)(v22 + 32);
      }
      *((void *)v16 + 4) = v22;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_commandQueue(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v28 = 0u;
  *(void *)&__int128 v29 = 0LL;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v30 = 0u;
  LODWORD(v2_Block_object_dispose(va, 8) = 27;
  *((void *)&v29 + 1) = -1LL;
  BYTE12(v32) = 1;
  WORD4(v32) = 769;
  ++*(_DWORD *)(a1 + 136);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (1)
  {
    if (!v4
      || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
      || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
          unint64_t v11 = *(void *)(a1 + 8),
          unint64_t v12 = *(void *)v10,
          *(void *)v10 >= *(void *)(a1 + 16) + v11))
    {
      __int128 v21 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x50uLL);
      __int128 v22 = v31;
      v21[2] = v30;
      _OWORD v21[3] = v22;
      void v21[4] = v32;
      __int128 v23 = v29;
      _OWORD *v21 = v28;
      v21[1] = v23;
      uint64_t v24 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v21 + 8, 8uLL, 0LL);
      if (v24) {
        uint64_t v24 = *(void *)(v24 + 32);
      }
      *((void *)v21 + 4) = v24;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v21 + 8, 8LL, v21);
      unint64_t v12 = -1LL;
      goto LABEL_25;
    }

    int v13 = *(_DWORD *)(v10 + 8);
    if ((v13 + 16349) < 5)
    {
      if (v11 <= v12)
      {
        int v14 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x50uLL);
        __int128 v15 = v31;
        *((_OWORD *)v14 + 2) = v30;
        *((_OWORD *)v14 + 3) = v15;
        *((_OWORD *)v14 + 4) = v32;
        __int128 v16 = v29;
        *(_OWORD *)int v14 = v28;
        *((_OWORD *)v14 + 1) = v16;
        uint64_t v17 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v14 + 8, 8uLL, 0LL);
        if (v17) {
          uint64_t v17 = *(void *)(v17 + 32);
        }
        void v14[4] = v17;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v14 + 1, 8LL, v14);
        v14[3] = v12;
      }

      goto LABEL_20;
    }

    if (v13 == -16344) {
      break;
    }
LABEL_20:
    GTMTLSMCommandQueue_processTraceFuncWithMap((char *)&v28, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v18 = atomic_load((unsigned int *)(v4 + 4));
    int v19 = v8 + (v18 >> 6);
    uint64_t v20 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v20 << 32) | v8;
    if ((_DWORD)v20 == v19 - 1)
    {
      unint64_t v8 = (v20 << 32) | v20;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  if (v11 <= v12)
  {
    __int128 v21 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x50uLL);
    __int128 v25 = v31;
    v21[2] = v30;
    _OWORD v21[3] = v25;
    void v21[4] = v32;
    __int128 v26 = v29;
    _OWORD *v21 = v28;
    v21[1] = v26;
    uint64_t v27 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v21 + 8, 8uLL, 0LL);
    if (v27) {
      uint64_t v27 = *(void *)(v27 + 32);
    }
    *((void *)v21 + 4) = v27;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v21 + 8, 8LL, v21);
LABEL_25:
    *((void *)v21 + 3) = v12;
  }

void GTMTLSMBuilder_rasterizationRateMap(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v28 = 0u;
  *(void *)&__int128 v29 = 0LL;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  LODWORD(v2_Block_object_dispose(va, 8) = 68;
  *((void *)&v29 + 1) = -1LL;
  ++*(_DWORD *)(a1 + 144);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (1)
  {
    if (!v4
      || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
      || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
          unint64_t v11 = *(void *)(a1 + 8),
          unint64_t v12 = *(void *)v10,
          *(void *)v10 >= *(void *)(a1 + 16) + v11))
    {
      __int128 v21 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x40uLL);
      __int128 v22 = v29;
      _OWORD *v21 = v28;
      v21[1] = v22;
      __int128 v23 = v31;
      v21[2] = v30;
      _OWORD v21[3] = v23;
      uint64_t v24 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v21 + 8, 8uLL, 0LL);
      if (v24) {
        uint64_t v24 = *(void *)(v24 + 32);
      }
      *((void *)v21 + 4) = v24;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v21 + 8, 8LL, v21);
      unint64_t v12 = -1LL;
      goto LABEL_26;
    }

    int v13 = *(_DWORD *)(v10 + 8);
    if (v13 == -15411)
    {
      if (v11 <= v12)
      {
        int v14 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x40uLL);
        __int128 v15 = v29;
        *(_OWORD *)int v14 = v28;
        *((_OWORD *)v14 + 1) = v15;
        __int128 v16 = v31;
        *((_OWORD *)v14 + 2) = v30;
        *((_OWORD *)v14 + 3) = v16;
        uint64_t v17 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v14 + 8, 8uLL, 0LL);
        if (v17) {
          uint64_t v17 = *(void *)(v17 + 32);
        }
        void v14[4] = v17;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v14 + 1, 8LL, v14);
        v14[3] = v12;
      }

      goto LABEL_21;
    }

    if (v13 == -15801) {
      break;
    }
LABEL_21:
    GTMTLSMRasterizationRateMap_processTraceFuncWithMap((char *)&v28, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v18 = atomic_load((unsigned int *)(v4 + 4));
    int v19 = v8 + (v18 >> 6);
    uint64_t v20 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v20 << 32) | v8;
    if ((_DWORD)v20 == v19 - 1)
    {
      unint64_t v8 = (v20 << 32) | v20;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  if (v11 <= v12)
  {
    __int128 v21 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x40uLL);
    __int128 v25 = v29;
    _OWORD *v21 = v28;
    v21[1] = v25;
    __int128 v26 = v31;
    v21[2] = v30;
    _OWORD v21[3] = v26;
    uint64_t v27 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v21 + 8, 8uLL, 0LL);
    if (v27) {
      uint64_t v27 = *(void *)(v27 + 32);
    }
    *((void *)v21 + 4) = v27;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v21 + 8, 8LL, v21);
LABEL_26:
    *((void *)v21 + 3) = v12;
  }

void GTMTLSMBuilder_resourceGroup(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v23 = 0u;
    *(void *)&__int128 v24 = 0LL;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    LODWORD(v23) = 73;
    *((void *)&v24 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 148);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x40uLL);
        __int128 v17 = v24;
        _OWORD *v16 = v23;
        v16[1] = v17;
        __int128 v18 = v26;
        void v16[2] = v25;
        v16[3] = v18;
        uint64_t v19 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v19) {
          uint64_t v19 = *(void *)(v19 + 32);
        }
        *((void *)v16 + 4) = v19;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -15769) {
        break;
      }
      GTMTLSMResourceGroup_processTraceFuncWithMap((char *)&v23, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x40uLL);
      __int128 v20 = v24;
      _OWORD *v16 = v23;
      v16[1] = v20;
      __int128 v21 = v26;
      void v16[2] = v25;
      v16[3] = v21;
      uint64_t v22 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v22) {
        uint64_t v22 = *(void *)(v22 + 32);
      }
      *((void *)v16 + 4) = v22;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_filter(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v29 = 0u;
    *(void *)&__int128 v30 = 0LL;
    uint64_t v35 = 0LL;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    LODWORD(v29) = 15;
    *((void *)&v30 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 152);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x68uLL);
        __int128 v18 = v30;
        __int128 v17 = v31;
        _OWORD *v16 = v29;
        v16[1] = v18;
        void v16[2] = v17;
        __int128 v20 = v33;
        __int128 v19 = v34;
        __int128 v21 = v32;
        *((void *)v16 + 12) = v35;
        void v16[4] = v20;
        v16[5] = v19;
        v16[3] = v21;
        uint64_t v22 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v22) {
          uint64_t v22 = *(void *)(v22 + 32);
        }
        *((void *)v16 + 4) = v22;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -6139) {
        break;
      }
      GTMTLSMFilter_processTraceFuncWithMap((uint64_t)&v29, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x68uLL);
      __int128 v24 = v30;
      __int128 v23 = v31;
      _OWORD *v16 = v29;
      v16[1] = v24;
      void v16[2] = v23;
      __int128 v26 = v33;
      __int128 v25 = v34;
      __int128 v27 = v32;
      *((void *)v16 + 12) = v35;
      void v16[4] = v26;
      v16[5] = v25;
      v16[3] = v27;
      uint64_t v28 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v28) {
        uint64_t v28 = *(void *)(v28 + 32);
      }
      *((void *)v16 + 4) = v28;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_indirectComputeCommand(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v21 = 0u;
    *(void *)&__int128 v22 = 0LL;
    uint64_t v24 = 0LL;
    __int128 v23 = 0u;
    LODWORD(v21) = 58;
    *((void *)&v22 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 132);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
        __int128 v17 = v22;
        _OWORD *v16 = v21;
        v16[1] = v17;
        void v16[2] = v23;
        *((void *)v16 + 6) = v24;
        uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v18) {
          uint64_t v18 = *(void *)(v18 + 32);
        }
        *((void *)v16 + 4) = v18;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -15935) {
        break;
      }
      GTMTLSMIndirectComputeCommand_processTraceFuncWithMap((char *)&v21, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
      __int128 v19 = v22;
      _OWORD *v16 = v21;
      v16[1] = v19;
      void v16[2] = v23;
      *((void *)v16 + 6) = v24;
      uint64_t v20 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v20) {
        uint64_t v20 = *(void *)(v20 + 32);
      }
      *((void *)v16 + 4) = v20;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_indirectRenderCommand(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v21 = 0u;
    *(void *)&__int128 v22 = 0LL;
    uint64_t v24 = 0LL;
    __int128 v23 = 0u;
    LODWORD(v21) = 59;
    *((void *)&v22 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 128);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
        __int128 v17 = v22;
        _OWORD *v16 = v21;
        v16[1] = v17;
        void v16[2] = v23;
        *((void *)v16 + 6) = v24;
        uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v18) {
          uint64_t v18 = *(void *)(v18 + 32);
        }
        *((void *)v16 + 4) = v18;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -15957) {
        break;
      }
      GTMTLSMIndirectRenderCommand_processTraceFuncWithMap((char *)&v21, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
      __int128 v19 = v22;
      _OWORD *v16 = v21;
      v16[1] = v19;
      void v16[2] = v23;
      *((void *)v16 + 6) = v24;
      uint64_t v20 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v20) {
        uint64_t v20 = *(void *)(v20 + 32);
      }
      *((void *)v16 + 4) = v20;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_drawable(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v21 = 0u;
    *(void *)&__int128 v22 = 0LL;
    uint64_t v24 = 0LL;
    __int128 v23 = 0u;
    LODWORD(v21) = 2;
    *((void *)&v22 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 164);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
        __int128 v17 = v22;
        _OWORD *v16 = v21;
        v16[1] = v17;
        void v16[2] = v23;
        *((void *)v16 + 6) = v24;
        uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v18) {
          uint64_t v18 = *(void *)(v18 + 32);
        }
        *((void *)v16 + 4) = v18;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -7161) {
        break;
      }
      GTMTLSMDrawable_processTraceFuncWithMap((char *)&v21, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
      __int128 v19 = v22;
      _OWORD *v16 = v21;
      v16[1] = v19;
      void v16[2] = v23;
      *((void *)v16 + 6) = v24;
      uint64_t v20 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v20) {
        uint64_t v20 = *(void *)(v20 + 32);
      }
      *((void *)v16 + 4) = v20;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_layer(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  memset(&v23[2], 0, 248);
  memset(v23, 0, 24);
  LODWORD(v23[0]) = 3;
  *((void *)&v23[1] + 1) = -1LL;
  ++*(_DWORD *)(a1 + 168);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (v4)
  {
    uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6);
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v12 = *(void *)v10;
    if (*(void *)v10 >= *(void *)(a1 + 16) + v11) {
      break;
    }
    int v13 = *(_DWORD *)(v10 + 8);
    if ((v13 + 7165) <= 0xB)
    {
      if (((1 << (v13 - 3)) & 0x86B) != 0) {
        goto LABEL_28;
      }
      if (v13 == -7163)
      {
        if (v11 > v12 || *((void *)&v23[0] + 1) == 0LL) {
          goto LABEL_32;
        }
LABEL_29:
        __int128 v16 = (char *)apr_palloc(*(apr_pool_t **)(a1 + 24), 0x118uLL);
        memcpy(v16, v23, 0x118uLL);
        uint64_t v17 = *find_entry(*(void *)(a1 + 32), v16 + 8, 8uLL, 0LL);
        if (v17) {
          uint64_t v17 = *(void *)(v17 + 32);
        }
        *((void *)v16 + 4) = v17;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v16 + 8, 8LL, v16);
        *((void *)v16 + 3) = v12;
        goto LABEL_32;
      }
    }

    if (v13 != -8183 && v13 != -8181) {
      goto LABEL_32;
    }
LABEL_28:
    if (v11 <= v12) {
      goto LABEL_29;
    }
LABEL_32:
    GTMTLSMLayer_processTraceFuncWithMap((uint64_t)v23, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v18 = atomic_load((unsigned int *)(v4 + 4));
    int v19 = v8 + (v18 >> 6);
    uint64_t v20 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v20 << 32) | v8;
    if ((_DWORD)v20 == v19 - 1)
    {
      unint64_t v8 = (v20 << 32) | v20;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  __int128 v21 = (char *)apr_palloc(*(apr_pool_t **)(a1 + 24), 0x118uLL);
  memcpy(v21, v23, 0x118uLL);
  uint64_t v22 = *find_entry(*(void *)(a1 + 32), v21 + 8, 8uLL, 0LL);
  if (v22) {
    uint64_t v22 = *(void *)(v22 + 32);
  }
  *((void *)v21 + 4) = v22;
  apr_hash_set(*(apr_hash_t **)(a1 + 32), v21 + 8, 8LL, v21);
  *((void *)v21 + 3) = -1LL;
}

void GTMTLSMBuilder_motionEstimationPipeline(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v21 = 0u;
    *(void *)&__int128 v22 = 0LL;
    uint64_t v24 = 0LL;
    __int128 v23 = 0u;
    LODWORD(v21) = 64;
    *((void *)&v22 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 116);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
        __int128 v17 = v22;
        _OWORD *v16 = v21;
        v16[1] = v17;
        void v16[2] = v23;
        *((void *)v16 + 6) = v24;
        uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v18) {
          uint64_t v18 = *(void *)(v18 + 32);
        }
        *((void *)v16 + 4) = v18;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -15893) {
        break;
      }
      GTMTLSMMotionEstimationPipelineState_processTraceFuncWithMap((char *)&v21, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
      __int128 v19 = v22;
      _OWORD *v16 = v21;
      v16[1] = v19;
      void v16[2] = v23;
      *((void *)v16 + 6) = v24;
      uint64_t v20 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v20) {
        uint64_t v20 = *(void *)(v20 + 32);
      }
      *((void *)v16 + 4) = v20;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_accelerationStructure(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v60 = 0u;
  *(void *)&__int128 v61 = 0LL;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v67 = 0u;
  __int128 v68 = 0u;
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  __int128 v63 = 0u;
  __int128 v62 = 0u;
  LODWORD(v6mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 16;
  *((void *)&v61 + 1) = -1LL;
  WORD1(v66) = 2;
  __int128 v64 = 0xFFFFFFFFFFFFFFFFLL;
  ++*(_DWORD *)(a1 + 80);
  if (a2 && (uint64_t v6 = *(void *)(a2 + 32)) != 0 && (*(_BYTE *)(v6 + 79) & 8) != 0) {
    uint64_t v7 = (uint64_t *)(v6 + 64);
  }
  else {
    uint64_t v7 = 0LL;
  }
  GTMTLSMAccelerationStructure_processTraceFuncWithMap((char *)&v60, *(void *)(a1 + 40), v7);
  unint64_t v8 = *(void **)(a3 + 24);
  uint64_t v9 = *(void *)(a2 + 32);
  if (v9)
  {
    unsigned int v10 = 0;
    while (1)
    {
      unsigned int v11 = atomic_load((unsigned int *)(v9 + 4));
      uint64_t v12 = v10 + (v11 >> 6) - 1;
      uint64_t v9 = *(void *)(v9 + 40);
      unsigned int v10 = v12;
      if (!v9)
      {
        unsigned int v10 = v12;
        goto LABEL_13;
      }
    }

    uint64_t v12 = 1LL;
  }

  else
  {
    unsigned int v10 = 0;
    uint64_t v12 = 0LL;
  }

LABEL_48:
    uint64_t v26 = *(void *)v16;
    if (*(void *)(a1 + 8) <= *(void *)v16)
    {
      __int128 v27 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xD0uLL);
      *(_OWORD *)__int128 v27 = v60;
      __int128 v28 = v64;
      __int128 v30 = v61;
      __int128 v29 = v62;
      *((_OWORD *)v27 + 3) = v63;
      *((_OWORD *)v27 + 4) = v28;
      *((_OWORD *)v27 + 1) = v30;
      *((_OWORD *)v27 + 2) = v29;
      __int128 v31 = v68;
      __int128 v33 = v65;
      __int128 v32 = v66;
      *((_OWORD *)v27 + 7) = v67;
      *((_OWORD *)v27 + _Block_object_dispose(va, 8) = v31;
      *((_OWORD *)v27 + 5) = v33;
      *((_OWORD *)v27 + 6) = v32;
      __int128 v34 = v72;
      __int128 v36 = v69;
      __int128 v35 = v70;
      *((_OWORD *)v27 + 11) = v71;
      *((_OWORD *)v27 + 12) = v34;
      *((_OWORD *)v27 + 9) = v36;
      *((_OWORD *)v27 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v35;
      uint64_t v37 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v27 + 8, 8uLL, 0LL);
      if (v37) {
        uint64_t v37 = *(void *)(v37 + 32);
      }
      v27[4] = v37;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), v27 + 1, 8LL, v27);
      v27[3] = v26;
    }

void GTMTLSMBuilder_intersectionFunctionTable(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  __int128 v49 = 0u;
  *(void *)&__int128 v50 = 0LL;
  uint64_t v59 = 0LL;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v54 = 0u;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  LODWORD(v49) = 60;
  *((void *)&v50 + 1) = -1LL;
  WORD1(v55) = 2;
  __int128 v53 = 0xFFFFFFFFFFFFFFFFLL;
  ++*(_DWORD *)(a1 + 76);
  if (a2 && (uint64_t v4 = *(void *)(a2 + 32)) != 0 && (*(_BYTE *)(v4 + 79) & 8) != 0) {
    unsigned int v5 = (uint64_t *)(v4 + 64);
  }
  else {
    unsigned int v5 = 0LL;
  }
  GTMTLSMIntersectionFunctionTable_processTraceFuncWithMap((char *)&v49, *(void *)(a1 + 40), v5);
  uint64_t v6 = *(void *)(a2 + 32);
  if (v6)
  {
    unsigned int v7 = 0;
    while (1)
    {
      unsigned int v8 = atomic_load((unsigned int *)(v6 + 4));
      uint64_t v9 = v7 + (v8 >> 6) - 1;
      uint64_t v6 = *(void *)(v6 + 40);
      unsigned int v7 = v9;
      if (!v6)
      {
        unsigned int v7 = v9;
        goto LABEL_13;
      }
    }

    uint64_t v9 = 1LL;
  }

  else
  {
    unsigned int v7 = 0;
    uint64_t v9 = 0LL;
  }

void GTMTLSMBuilder_functionHandle(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v22 = 0u;
    *(void *)&__int128 v23 = 0LL;
    uint64_t v26 = 0LL;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    LODWORD(v22) = 44;
    *((void *)&v23 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 172);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (v4)
    {
      uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6);
      uint64_t v11 = *(void *)v10;
      if (*(void *)v10 >= *(void *)(a1 + 16) + *(void *)(a1 + 8)) {
        break;
      }
      if (*(_DWORD *)(v10 + 8) == -15610)
      {
        int v15 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x48uLL);
        __int128 v19 = v25;
        v15[2] = v24;
        v15[3] = v19;
        *((void *)v15 + _Block_object_dispose(va, 8) = v26;
        __int128 v20 = v23;
        *int v15 = v22;
        v15[1] = v20;
        uint64_t v21 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v15 + 8, 8uLL, 0LL);
        if (v21) {
          uint64_t v21 = *(void *)(v21 + 32);
        }
        *((void *)v15 + 4) = v21;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v15 + 8, 8LL, v15);
        goto LABEL_23;
      }

      GTMTLSMFunctionHandle_processTraceFuncWithMap((char *)&v22, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v12 = atomic_load((unsigned int *)(v4 + 4));
      int v13 = v8 + (v12 >> 6);
      uint64_t v14 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v14 << 32) | v8;
      if ((_DWORD)v14 == v13 - 1)
      {
        unint64_t v8 = (v14 << 32) | v14;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    int v15 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x48uLL);
    __int128 v16 = v25;
    v15[2] = v24;
    v15[3] = v16;
    *((void *)v15 + _Block_object_dispose(va, 8) = v26;
    __int128 v17 = v23;
    *int v15 = v22;
    v15[1] = v17;
    uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v15 + 8, 8uLL, 0LL);
    if (v18) {
      uint64_t v18 = *(void *)(v18 + 32);
    }
    *((void *)v15 + 4) = v18;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v15 + 8, 8LL, v15);
    uint64_t v11 = -1LL;
LABEL_23:
    *((void *)v15 + 3) = v11;
  }

void GTMTLSMBuilder_visibleFunctionTable(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  ++*(_DWORD *)(a1 + 72);
  __int128 v47 = 0u;
  *(void *)&__int128 v48 = 0LL;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v49 = 0u;
  LODWORD(v47) = 83;
  *((void *)&v48 + 1) = -1LL;
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (v4)
  {
    uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6);
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v12 = *(void *)v10;
    if (*(void *)v10 >= *(void *)(a1 + 16) + v11) {
      break;
    }
    int v13 = *(_DWORD *)(v10 + 8);
    if (v13 <= -15600)
    {
      if (v13 == -15607) {
        goto LABEL_21;
      }
      if (v13 == -15605)
      {
        int v28 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xB0uLL);
        __int128 v39 = v48;
        __int128 v38 = v49;
        *int v28 = v47;
        v28[1] = v39;
        v28[2] = v38;
        __int128 v40 = v53;
        __int128 v42 = v50;
        __int128 v41 = v51;
        v28[5] = v52;
        v28[6] = v40;
        v28[3] = v42;
        v28[4] = v41;
        __int128 v43 = v57;
        __int128 v45 = v54;
        __int128 v44 = v55;
        v28[9] = v56;
        v28[10] = v43;
        v28[7] = v45;
        v28[8] = v44;
        uint64_t v46 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v28 + 8, 8uLL, 0LL);
        if (v46) {
          uint64_t v46 = *(void *)(v46 + 32);
        }
        *((void *)v28 + 4) = v46;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v28 + 8, 8LL, v28);
        goto LABEL_31;
      }
    }

    else if (v13 == -15596 || v13 == -15599)
    {
LABEL_21:
      if (v11 <= v12)
      {
        int v15 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xB0uLL);
        __int128 v17 = v48;
        __int128 v16 = v49;
        *(_OWORD *)int v15 = v47;
        *((_OWORD *)v15 + 1) = v17;
        *((_OWORD *)v15 + 2) = v16;
        __int128 v18 = v53;
        __int128 v20 = v50;
        __int128 v19 = v51;
        *((_OWORD *)v15 + 5) = v52;
        *((_OWORD *)v15 + 6) = v18;
        *((_OWORD *)v15 + 3) = v20;
        *((_OWORD *)v15 + 4) = v19;
        __int128 v21 = v57;
        __int128 v23 = v54;
        __int128 v22 = v55;
        *((_OWORD *)v15 + 9) = v56;
        *((_OWORD *)v15 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v21;
        *((_OWORD *)v15 + 7) = v23;
        *((_OWORD *)v15 + _Block_object_dispose(va, 8) = v22;
        uint64_t v24 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v15 + 8, 8uLL, 0LL);
        if (v24) {
          uint64_t v24 = *(void *)(v24 + 32);
        }
        void v15[4] = v24;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v15 + 1, 8LL, v15);
        v15[3] = v12;
      }
    }

    GTMTLSMVisibleFunctionTable_processTraceFuncWithMap((char *)&v47, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v25 = atomic_load((unsigned int *)(v4 + 4));
    int v26 = v8 + (v25 >> 6);
    uint64_t v27 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v27 << 32) | v8;
    if ((_DWORD)v27 == v26 - 1)
    {
      unint64_t v8 = (v27 << 32) | v27;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  int v28 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0xB0uLL);
  __int128 v30 = v48;
  __int128 v29 = v49;
  *int v28 = v47;
  v28[1] = v30;
  v28[2] = v29;
  __int128 v31 = v53;
  __int128 v33 = v50;
  __int128 v32 = v51;
  v28[5] = v52;
  v28[6] = v31;
  v28[3] = v33;
  v28[4] = v32;
  __int128 v34 = v57;
  __int128 v36 = v54;
  __int128 v35 = v55;
  v28[9] = v56;
  v28[10] = v34;
  v28[7] = v36;
  v28[8] = v35;
  uint64_t v37 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v28 + 8, 8uLL, 0LL);
  if (v37) {
    uint64_t v37 = *(void *)(v37 + 32);
  }
  *((void *)v28 + 4) = v37;
  apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v28 + 8, 8LL, v28);
  unint64_t v12 = -1LL;
LABEL_31:
  *((void *)v28 + 3) = v12;
}

void GTMTLSMBuilder_device(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    __int128 v21 = 0u;
    *(void *)&__int128 v22 = 0LL;
    __int128 v23 = 0u;
    LODWORD(v21) = 36;
    *((void *)&v22 + 1) = -1LL;
    ++*(_DWORD *)(a1 + 160);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (1)
    {
      if (!v4
        || (*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0
        || (uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6),
            unint64_t v11 = *(void *)(a1 + 8),
            unint64_t v12 = *(void *)v10,
            *(void *)v10 >= *(void *)(a1 + 16) + v11))
      {
        __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x30uLL);
        __int128 v17 = v22;
        _OWORD *v16 = v21;
        v16[1] = v17;
        void v16[2] = v23;
        uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
        if (v18) {
          uint64_t v18 = *(void *)(v18 + 32);
        }
        *((void *)v16 + 4) = v18;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
        unint64_t v12 = -1LL;
        goto LABEL_20;
      }

      if (*(_DWORD *)(v10 + 8) == -16317) {
        break;
      }
      GTMTLSMDevice_processTraceFuncWithMap((char *)&v21, *(void *)(a1 + 40), v10);
      unsigned int v13 = atomic_load((unsigned int *)(v4 + 4));
      int v14 = v8 + (v13 >> 6);
      uint64_t v15 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v15 << 32) | v8;
      if ((_DWORD)v15 == v14 - 1)
      {
        unint64_t v8 = (v15 << 32) | v15;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    if (v11 <= v12)
    {
      __int128 v16 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x30uLL);
      __int128 v19 = v22;
      _OWORD *v16 = v21;
      v16[1] = v19;
      void v16[2] = v23;
      uint64_t v20 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v16 + 8, 8uLL, 0LL);
      if (v20) {
        uint64_t v20 = *(void *)(v20 + 32);
      }
      *((void *)v16 + 4) = v20;
      apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v16 + 8, 8LL, v16);
LABEL_20:
      *((void *)v16 + 3) = v12;
    }
  }

void GTMTLSMBuilder_spatialScaler(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    ++*(_DWORD *)(a1 + 176);
    __int128 v31 = 0u;
    *(void *)&__int128 v32 = 0LL;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    LODWORD(v31) = 39;
    *((void *)&v32 + 1) = -1LL;
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (v4)
    {
      uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6);
      unint64_t v11 = *(void *)(a1 + 8);
      unint64_t v12 = *(void *)v10;
      if (*(void *)v10 >= *(void *)(a1 + 16) + v11) {
        break;
      }
      int v13 = *(_DWORD *)(v10 + 8);
      if ((v13 + 20480) >= 5)
      {
        if (v13 == -20475)
        {
          __int128 v22 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x60uLL);
          __int128 v27 = v34;
          v22[2] = v33;
          int8x16_t v22[3] = v27;
          __int128 v28 = v36;
          void v22[4] = v35;
          void v22[5] = v28;
          __int128 v29 = v32;
          *__int128 v22 = v31;
          v22[1] = v29;
          uint64_t v30 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v22 + 8, 8uLL, 0LL);
          if (v30) {
            uint64_t v30 = *(void *)(v30 + 32);
          }
          *((void *)v22 + 4) = v30;
          apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v22 + 8, 8LL, v22);
          goto LABEL_25;
        }
      }

      else if (v11 <= v12)
      {
        int v14 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x60uLL);
        __int128 v15 = v34;
        *((_OWORD *)v14 + 2) = v33;
        *((_OWORD *)v14 + 3) = v15;
        __int128 v16 = v36;
        *((_OWORD *)v14 + 4) = v35;
        *((_OWORD *)v14 + 5) = v16;
        __int128 v17 = v32;
        *(_OWORD *)int v14 = v31;
        *((_OWORD *)v14 + 1) = v17;
        uint64_t v18 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v14 + 8, 8uLL, 0LL);
        if (v18) {
          uint64_t v18 = *(void *)(v18 + 32);
        }
        void v14[4] = v18;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v14 + 1, 8LL, v14);
        v14[3] = v12;
      }

      GTMTLFXSMSpatialScaler_processTraceFuncWithMap((char *)&v31, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v19 = atomic_load((unsigned int *)(v4 + 4));
      int v20 = v8 + (v19 >> 6);
      uint64_t v21 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v21 << 32) | v8;
      if ((_DWORD)v21 == v20 - 1)
      {
        unint64_t v8 = (v21 << 32) | v21;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    __int128 v22 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x60uLL);
    __int128 v23 = v34;
    v22[2] = v33;
    int8x16_t v22[3] = v23;
    __int128 v24 = v36;
    void v22[4] = v35;
    void v22[5] = v24;
    __int128 v25 = v32;
    *__int128 v22 = v31;
    v22[1] = v25;
    uint64_t v26 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v22 + 8, 8uLL, 0LL);
    if (v26) {
      uint64_t v26 = *(void *)(v26 + 32);
    }
    *((void *)v22 + 4) = v26;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v22 + 8, 8LL, v22);
    unint64_t v12 = -1LL;
LABEL_25:
    *((void *)v22 + 3) = v12;
  }

void GTMTLSMBuilder_temporalScaler(uint64_t a1, uint64_t a2)
{
  if (!GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2)) {
    return;
  }
  ++*(_DWORD *)(a1 + 180);
  __int128 v36 = 0u;
  *(void *)&__int128 v37 = 0LL;
  uint64_t v45 = 0LL;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v38 = 0u;
  LODWORD(v36) = 40;
  *((void *)&v37 + 1) = -1LL;
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unsigned int v5 = 0;
    while (1)
    {
      unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
      uint64_t v7 = v5 + (v6 >> 6) - 1;
      uint64_t v4 = *(void *)(v4 + 40);
      unsigned int v5 = v7;
      if (!v4)
      {
        unsigned int v5 = v7;
        goto LABEL_9;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
  }

  uint64_t v7 = 0LL;
LABEL_9:
  unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
  uint64_t v9 = v4 + 64;
  while (v4)
  {
    uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6);
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v12 = *(void *)v10;
    if (*(void *)v10 >= *(void *)(a1 + 16) + v11) {
      break;
    }
    int v13 = *(_DWORD *)(v10 + 8);
    if (v13 <= -20458)
    {
      if (v13 == -20473) {
        goto LABEL_15;
      }
      if (v13 == -20475)
      {
        __int128 v29 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x98uLL);
        __int128 v30 = v43;
        v29[6] = v42;
        v29[7] = v30;
        v29[8] = v44;
        *((void *)v29 + 1_Block_object_dispose(va, 8) = v45;
        __int128 v31 = v39;
        v29[2] = v38;
        v29[3] = v31;
        __int128 v32 = v41;
        v29[4] = v40;
        v29[5] = v32;
        __int128 v33 = v37;
        *__int128 v29 = v36;
        v29[1] = v33;
        entry = find_entry(*(void *)(a1 + 32), (_BYTE *)v29 + 8, 8uLL, 0LL);
        uint64_t v35 = *entry;
        if (*entry) {
          uint64_t v35 = *(void *)(v35 + 32);
        }
        *((void *)v29 + 4) = v35;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v29 + 8, 8LL, v29);
        goto LABEL_33;
      }
    }

    else if ((v13 + 20457) < 2 || v13 == -18430)
    {
LABEL_15:
      if (v11 <= v12)
      {
        int v14 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x98uLL);
        __int128 v15 = v43;
        *((_OWORD *)v14 + 6) = v42;
        *((_OWORD *)v14 + 7) = v15;
        *((_OWORD *)v14 + _Block_object_dispose(va, 8) = v44;
        v14[18] = v45;
        __int128 v16 = v39;
        *((_OWORD *)v14 + 2) = v38;
        *((_OWORD *)v14 + 3) = v16;
        __int128 v17 = v41;
        *((_OWORD *)v14 + 4) = v40;
        *((_OWORD *)v14 + 5) = v17;
        __int128 v18 = v37;
        *(_OWORD *)int v14 = v36;
        *((_OWORD *)v14 + 1) = v18;
        uint64_t v19 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v14 + 8, 8uLL, 0LL);
        if (v19) {
          uint64_t v19 = *(void *)(v19 + 32);
        }
        void v14[4] = v19;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), v14 + 1, 8LL, v14);
        v14[3] = v12;
      }
    }

    GTMTLFXSMTemporalScaler_processTraceFuncWithMap((uint64_t)&v36, *(void *)(a1 + 40), (uint64_t *)v10);
    unsigned int v20 = atomic_load((unsigned int *)(v4 + 4));
    int v21 = v8 + (v20 >> 6);
    uint64_t v22 = (HIDWORD(v8) + 1);
    unint64_t v8 = (v22 << 32) | v8;
    if ((_DWORD)v22 == v21 - 1)
    {
      unint64_t v8 = (v22 << 32) | v22;
      uint64_t v4 = *(void *)(v4 + 40);
      goto LABEL_10;
    }
  }

  __int128 v29 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x98uLL);
  __int128 v24 = v43;
  v29[6] = v42;
  v29[7] = v24;
  v29[8] = v44;
  *((void *)v29 + 1_Block_object_dispose(va, 8) = v45;
  __int128 v25 = v39;
  v29[2] = v38;
  v29[3] = v25;
  __int128 v26 = v41;
  v29[4] = v40;
  v29[5] = v26;
  __int128 v27 = v37;
  *__int128 v29 = v36;
  v29[1] = v27;
  uint64_t v28 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v29 + 8, 8uLL, 0LL);
  if (v28) {
    uint64_t v28 = *(void *)(v28 + 32);
  }
  *((void *)v29 + 4) = v28;
  apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v29 + 8, 8LL, v29);
  unint64_t v12 = -1LL;
LABEL_33:
  *((void *)v29 + 3) = v12;
}

void GTMTLSMBuilder_residencySet(uint64_t a1, uint64_t a2)
{
  if (GTMTLSMBuilder_streamIntersectionRange(*(void *)(a1 + 8), *(void *)(a1 + 16), a2))
  {
    ++*(_DWORD *)(a1 + 184);
    __int128 v20 = 0u;
    *(void *)&__int128 v21 = 0LL;
    uint64_t v23 = 0LL;
    __int128 v22 = 0u;
    LODWORD(v2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 72;
    *((void *)&v21 + 1) = -1LL;
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unsigned int v5 = 0;
      while (1)
      {
        unsigned int v6 = atomic_load((unsigned int *)(v4 + 4));
        uint64_t v7 = v5 + (v6 >> 6) - 1;
        uint64_t v4 = *(void *)(v4 + 40);
        unsigned int v5 = v7;
        if (!v4)
        {
          unsigned int v5 = v7;
          goto LABEL_9;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
    }

    uint64_t v7 = 0LL;
LABEL_9:
    unint64_t v8 = v5 | (unint64_t)(v7 << 32);
LABEL_10:
    uint64_t v9 = v4 + 64;
    while (v4)
    {
      uint64_t v10 = v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6);
      uint64_t v11 = *(void *)v10;
      if (*(void *)v10 >= *(void *)(a1 + 16) + *(void *)(a1 + 8)) {
        break;
      }
      if (*(_DWORD *)(v10 + 8) == -15231)
      {
        __int128 v15 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
        __int128 v18 = v21;
        *__int128 v15 = v20;
        v15[1] = v18;
        v15[2] = v22;
        *((void *)v15 + 6) = v23;
        uint64_t v19 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v15 + 8, 8uLL, 0LL);
        if (v19) {
          uint64_t v19 = *(void *)(v19 + 32);
        }
        *((void *)v15 + 4) = v19;
        apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v15 + 8, 8LL, v15);
        goto LABEL_23;
      }

      GTMTLSMResidencySet_processTraceFuncWithMap((char *)&v20, *(void *)(a1 + 40), (uint64_t *)v10);
      unsigned int v12 = atomic_load((unsigned int *)(v4 + 4));
      int v13 = v8 + (v12 >> 6);
      uint64_t v14 = (HIDWORD(v8) + 1);
      unint64_t v8 = (v14 << 32) | v8;
      if ((_DWORD)v14 == v13 - 1)
      {
        unint64_t v8 = (v14 << 32) | v14;
        uint64_t v4 = *(void *)(v4 + 40);
        goto LABEL_10;
      }
    }

    __int128 v15 = apr_palloc(*(apr_pool_t **)(a1 + 24), 0x38uLL);
    __int128 v16 = v21;
    *__int128 v15 = v20;
    v15[1] = v16;
    v15[2] = v22;
    *((void *)v15 + 6) = v23;
    uint64_t v17 = *find_entry(*(void *)(a1 + 32), (_BYTE *)v15 + 8, 8uLL, 0LL);
    if (v17) {
      uint64_t v17 = *(void *)(v17 + 32);
    }
    *((void *)v15 + 4) = v17;
    apr_hash_set(*(apr_hash_t **)(a1 + 32), (char *)v15 + 8, 8LL, v15);
    uint64_t v11 = -1LL;
LABEL_23:
    *((void *)v15 + 3) = v11;
  }

uint64_t GTMTLSMBuilder_compareStreams(void **a1, void **a2)
{
  uint64_t v2 = *a1;
  if (*a1) {
    uint64_t v2 = (void *)*v2;
  }
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = (void *)*v3;
  }
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t *GTMTLSMContext_buildDeviceMirrorWithIgnoreFlags( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, apr_pool_t *pool, int a8, int *a9)
{
  v65[0] = a4;
  v65[1] = a5;
  v65[2] = a6;
  v65[3] = pool;
  __int128 v66 = apr_hash_make(pool);
  uint64_t v67 = a2;
  uint64_t v14 = apr_array_make(pool, *(_DWORD *)(a1 + 48), 8);
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 16) = a1;
  *(_DWORD *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0;
  __int128 v15 = apr_hash_next((apr_hash_index_t *)(a1 + 16));
  if (v15)
  {
    __int128 v16 = v15;
    do
    {
      uint64_t v17 = *(void *)(*((void *)v16 + 1) + 32LL);
      *(void *)apr_array_push(v14) = v17;
      __int128 v16 = apr_hash_next(v16);
    }

    while (v16);
  }

  qsort( v14->elts,  v14->nelts,  v14->elt_size,  (int (__cdecl *)(const void *, const void *))GTMTLSMBuilder_compareStreams);
  uint64_t v64 = 0LL;
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  __int128 v61 = 0u;
  __id key = &v60;
  uint64_t v60 = a4;
  __int128 v18 = (uint64_t *)bsearch( &__key,  v14->elts,  v14->nelts,  v14->elt_size,  (int (__cdecl *)(const void *, const void *))GTMTLSMBuilder_compareStreams);
  if (v18)
  {
    uint64_t v19 = v18 + 1;
    int v20 = *(_DWORD *)(*(void *)(*v18 + 32) + 72LL);
    if (a9)
    {
      if (v20 != -10239)
      {
        unsigned int v21 = *a9;
        __int128 v57 = 0u;
        __int128 v58 = 0u;
        uint64_t v55 = v21 | 0x1F400000000LL;
        __int128 v56 = "func->fenum == kDYFEMTLDevice_deviceReference";
        GTError_addError(a9, (uint64_t)&v55);
        return 0LL;
      }
    }

    else if (v20 != -10239)
    {
      return 0LL;
    }

    uint64_t v22 = (uint64_t)&v14->elts[8 * v14->nelts];
    GTMTLSMBuilder_device((uint64_t)v65, *v18);
    if (v19 != (uint64_t *)v22)
    {
      int v54 = a8;
      do
      {
        uint64_t v23 = *v19;
        if (*v19)
        {
          uint64_t v24 = *(void *)(v23 + 32);
          if (v24)
          {
            int v25 = *(unsigned __int8 *)(v24 + 79);
            if ((v25 & 8) != 0 && (v25 & a8) == 0)
            {
              int v26 = *(_DWORD *)(v24 + 72);
              if (v26 == -7163)
              {
                int v27 = 30;
                uint64_t v28 = GTTraceFunc_argumentBytesWithPool( (uint64_t *)(v24 + 64),  *(unsigned __int8 *)(v24 + 77),  *(void *)(v23 + 24))
                    + 8;
              }

              else
              {
                unsigned int v29 = GetFuncEnumConstructorType(*(_DWORD *)(v24 + 72)) - 2;
                if (v29 > 0x51) {
                  int v27 = 255;
                }
                else {
                  int v27 = byte_1C2D54[v29];
                }
                uint64_t v30 = *(void *)(v23 + 24);
                if (v26 == -15913 || v26 == -15914) {
                else
                }
                  uint64_t v28 = GTTraceFunc_argumentBytesWithPool((uint64_t *)(v24 + 64), *(unsigned __int8 *)(v24 + 77), v30);
              }

              uint64_t v31 = *(void *)v28;
              uint64_t v55 = *(void *)v28;
              if (v27 == 29
                || v31 == a4
                || (uint64_t v32 = *find_entry((uint64_t)v66, &v55, 8uLL, 0LL)) != 0 && *(void *)(v32 + 32))
              {
                switch((char)v27)
                {
                  case 0:
                    GTMTLSMBuilder_buffer((uint64_t)v65, v23);
                    break;
                  case 1:
                    GTMTLSMBuilder_texture((uint64_t)v65, v23);
                    break;
                  case 2:
                    GTMTLSMBuilder_samplerState((uint64_t)v65, v23);
                    break;
                  case 3:
                    GTMTLSMBuilder_renderPipelineState((uint64_t)v65, v23);
                    break;
                  case 4:
                    GTMTLSMBuilder_computePipelineState((uint64_t)v65, v23);
                    break;
                  case 5:
                    GTMTLSMBuilder_indirectCommandBuffer((uint64_t)v65, v23);
                    break;
                  case 6:
                    GTMTLSMBuilder_visibleFunctionTable((uint64_t)v65, v23);
                    break;
                  case 7:
                    GTMTLSMBuilder_intersectionFunctionTable((uint64_t)v65, v23);
                    break;
                  case 8:
                    GTMTLSMBuilder_accelerationStructure((uint64_t)v65, v23, a3);
                    break;
                  case 9:
                    GTMTLSMBuilder_heap((uint64_t)v65, v23);
                    break;
                  case 10:
                    GTMTLSMBuilder_library((uint64_t)v65, v23);
                    break;
                  case 11:
                    GTMTLSMBuilder_dynamicLibrary((uint64_t)v65, v23);
                    break;
                  case 12:
                    GTMTLSMBuilder_pipelineLibrary((uint64_t)v65, v23);
                    break;
                  case 13:
                    GTMTLSMBuilder_fence((uint64_t)v65, v23);
                    break;
                  case 14:
                    GTMTLSMBuilder_event((uint64_t)v65, v23);
                    break;
                  case 15:
                    GTMTLSMBuilder_sharedEvent((uint64_t)v65, v23);
                    break;
                  case 16:
                    GTMTLSMBuilder_lateEvalEvent((uint64_t)v65, v23);
                    break;
                  case 17:
                    GTMTLSMBuilder_motionEstimationPipeline((uint64_t)v65, v23);
                    break;
                  case 18:
                    GTMTLSMBuilder_depthStencilState((uint64_t)v65, v23);
                    break;
                  case 19:
                    GTMTLSMBuilder_counterSampleBuffer((uint64_t)v65, v23);
                    break;
                  case 20:
                    GTMTLSMBuilder_indirectRenderCommand((uint64_t)v65, v23);
                    break;
                  case 21:
                    GTMTLSMBuilder_indirectComputeCommand((uint64_t)v65, v23);
                    break;
                  case 22:
                    GTMTLSMBuilder_commandQueue((uint64_t)v65, v23);
                    break;
                  case 23:
                    GTMTLSMBuilder_ioCommandQueue((uint64_t)v65, v23);
                    break;
                  case 24:
                    GTMTLSMBuilder_rasterizationRateMap((uint64_t)v65, v23);
                    break;
                  case 25:
                    GTMTLSMBuilder_resourceGroup((uint64_t)v65, v23);
                    break;
                  case 26:
                    GTMTLSMBuilder_filter((uint64_t)v65, v23);
                    break;
                  case 27:
                    GTMTLSMBuilder_function((uint64_t)v65, v23);
                    break;
                  case 29:
                    GTMTLSMBuilder_drawable((uint64_t)v65, v23);
                    break;
                  case 30:
                    GTMTLSMBuilder_layer((uint64_t)v65, v23);
                    break;
                  case 31:
                    GTMTLSMBuilder_functionHandle((uint64_t)v65, v23);
                    break;
                  case 32:
                    GTMTLSMBuilder_spatialScaler((uint64_t)v65, v23);
                    break;
                  case 33:
                    GTMTLSMBuilder_temporalScaler((uint64_t)v65, v23);
                    break;
                  case 34:
                    GTMTLSMBuilder_residencySet((uint64_t)v65, v23);
                    break;
                  default:
                    break;
                }
              }

              a8 = v54;
            }
          }
        }

        ++v19;
      }

      while (v19 != (uint64_t *)v22);
    }
  }

  __int128 v33 = (char *)apr_palloc(pool, 0x120uLL);
  __int128 v34 = (uint64_t *)v33;
  if (v33)
  {
    *(_OWORD *)(v33 + _Block_object_dispose(va, 8) = 0u;
    *((void *)v33 + 35) = 0LL;
    *(_OWORD *)(v33 + 24_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v33 + 264) = 0u;
    *(_OWORD *)(v33 + 216) = 0u;
    *(_OWORD *)(v33 + 232) = 0u;
    *(_OWORD *)(v33 + 184) = 0u;
    *(_OWORD *)(v33 + 20mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
    *(_OWORD *)(v33 + 152) = 0u;
    *(_OWORD *)(v33 + 16_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v33 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
    *(_OWORD *)(v33 + 136) = 0u;
    *(_OWORD *)(v33 + 8_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v33 + 104) = 0u;
    *(_OWORD *)(v33 + 56) = 0u;
    *(_OWORD *)(v33 + 72) = 0u;
    *(_OWORD *)(v33 + 24) = 0u;
    *(_OWORD *)(v33 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  }

  uint64_t v35 = 0LL;
  *(void *)__int128 v33 = v66;
  do
  {
    v34[v35 + 1] = (uint64_t)apr_array_make(pool, v68[v35], 8);
    ++v35;
  }

  while (v35 != 35);
  uint64_t v36 = *v34;
  __int128 v37 = (apr_hash_index_t *)(*v34 + 16);
  *(void *)(v36 + 24) = 0LL;
  *(void *)(v36 + 32) = 0LL;
  *(void *)(v36 + 16) = v36;
  *(_DWORD *)(v36 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0;
  __int128 v38 = apr_hash_next(v37);
  if (v38)
  {
    __int128 v39 = v38;
    do
    {
      __int128 v40 = *(_DWORD **)(*((void *)v39 + 1) + 32LL);
      unsigned int v41 = *v40 - 2;
      if (v41 <= 0x51)
      {
        uint64_t v42 = byte_1C2D54[v41];
        if (v42 != -1) {
          *(void *)apr_array_push((apr_array_header_t *)v34[v42 + 1]) = v40;
        }
      }

      __int128 v39 = apr_hash_next(v39);
    }

    while (v39);
  }

  uint64_t v43 = v34[30];
  uint64_t v44 = *(unsigned int *)(v43 + 12);
  if ((int)v44 >= 1)
  {
    unint64_t v45 = v44 + 1;
    do
    {
      uint64_t v46 = (v45 - 2);
      __int128 v47 = *(void **)(*(void *)(v43 + 24) + 8LL * v46);
      if (a9 && !v47[5])
      {
        unsigned int v48 = *a9;
        __int128 v57 = 0uLL;
        __int128 v58 = 0uLL;
        uint64_t v55 = v48 | 0x1F400000000LL;
        __int128 v56 = "smDrawable->layer";
        GTError_addError(a9, (uint64_t)&v55);
      }

      uint64_t v55 = v47[6];
      uint64_t v49 = *find_entry(*v34, &v55, 8uLL, 0LL);
      if (!v49 || !*(void *)(v49 + 32))
      {
        apr_hash_set((apr_hash_t *)*v34, v47 + 1, 8LL, 0LL);
        int v50 = *(_DWORD *)(v43 + 12);
        *(void *)(*(void *)(v43 + 24) + 8 * v46) = *(void *)(*(void *)(v43 + 24) + 8LL * (v50 - 1));
        if (v50) {
          *(_DWORD *)(v43 + 12) = v50 - 1;
        }
      }

      --v45;
    }

    while (v45 > 1);
  }

  for (uint64_t i = 1LL; i != 36; ++i)
    qsort( *(void **)(v34[i] + 24),  *(int *)(v34[i] + 12),  *(int *)(v34[i] + 8),  (int (__cdecl *)(const void *, const void *))GTMTLSMObject_compare);
  return v34;
}

uint64_t GTMTLSMObject_compare(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(*(void *)a1 + 16LL);
  unint64_t v3 = *(void *)(*(void *)a2 + 16LL);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

double GTMTLSMBuffer_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + memset(v68, 0, 144) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 22;
  *(void *)(a1 + 24) = -1LL;
  *(_WORD *)(a1 + 9_Block_object_dispose(va, 8) = 2;
  *(void *)(a1 + 64) = -1LL;
  *(void *)(a1 + 112) = -1LL;
  return result;
}

double GTMTLSMTexture_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 196) = 0u;
  *(_OWORD *)(a1 + 18mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  *(_OWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 80;
  *(void *)(a1 + 24) = -1LL;
  *(_WORD *)(a1 + 9_Block_object_dispose(va, 8) = 2;
  *(void *)(a1 + 64) = -1LL;
  *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0xFFFFFFFFLL;
  return result;
}

double GTMTLSMCounterSampleBuffer_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 31;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMDrawable_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 2;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMLayer_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 276) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 244) = 0u;
  *(_OWORD *)(a1 + 22_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_OWORD *)(a1 + 196) = 0u;
  *(_OWORD *)(a1 + 18mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  *(_OWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 26mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)a1 = 3;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMIndirectCommandBuffer_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 57;
  *(void *)(a1 + 24) = -1LL;
  *(_WORD *)(a1 + 9_Block_object_dispose(va, 8) = 2;
  *(void *)(a1 + 64) = -1LL;
  return result;
}

double GTMTLSMHeap_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + 84) = 0;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 50;
  *(void *)(a1 + 24) = -1LL;
  *(_WORD *)(a1 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 2;
  return result;
}

double GTMTLSMDepthStencilState_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 34;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMSamplerState_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_DWORD *)(a1 + 84) = 0;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 75;
  *(void *)(a1 + 24) = -1LL;
  *(void *)(a1 + 64) = -1LL;
  return result;
}

double GTMTLSMEvent_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 38;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMSharedEvent_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 76;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMLateEvalEvent_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 61;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMFence_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 41;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMRenderPipelineState_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 40mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 244) = 0u;
  *(_OWORD *)(a1 + 22_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_OWORD *)(a1 + 196) = 0u;
  *(_OWORD *)(a1 + 18mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  *(_OWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 372) = 0u;
  *(_OWORD *)(a1 + 38_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 34mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 356) = 0u;
  *(_OWORD *)(a1 + 30_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 324) = 0u;
  *(_OWORD *)(a1 + 276) = 0u;
  *(_OWORD *)(a1 + 292) = 0u;
  *(_OWORD *)(a1 + 26mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)a1 = 71;
  *(void *)(a1 + 24) = -1LL;
  *(void *)(a1 + 96) = -1LL;
  return result;
}

double GTMTLSMComputePipelineState_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_DWORD *)(a1 + 196) = 0;
  *(_OWORD *)(a1 + 18mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  *(_OWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 29;
  *(void *)(a1 + 24) = -1LL;
  *(void *)(a1 + 96) = -1LL;
  return result;
}

double GTMTLSMMotionEstimationPipelineState_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 64;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMFunction_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 132) = 0;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 43;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMLibrary_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 164) = 0;
  *(_OWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 62;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMDynamicLibrary_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 37;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMPipelineLibrary_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 84) = 0;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 67;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMCommandQueue_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 27;
  *(void *)(a1 + 24) = -1LL;
  *(_BYTE *)(a1 + 76) = 1;
  *(_WORD *)(a1 + 72) = 769;
  return result;
}

double GTMTLSMIOCommandQueue_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 52;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMDevice_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 36;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMIndirectComputeCommand_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 58;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMIndirectRenderCommand_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 59;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMRasterizationRateMap_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 68;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMResourceGroup_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 73;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMAccelerationStructure_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 18mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  *(_OWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 16;
  *(void *)(a1 + 24) = -1LL;
  *(_WORD *)(a1 + 9_Block_object_dispose(va, 8) = 2;
  *(void *)(a1 + 64) = -1LL;
  return result;
}

double GTMTLSMIntersectionFunctionTable_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_DWORD *)(a1 + 164) = 0;
  *(_OWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 60;
  *(void *)(a1 + 24) = -1LL;
  *(_WORD *)(a1 + 9_Block_object_dispose(va, 8) = 2;
  *(void *)(a1 + 64) = -1LL;
  return result;
}

void GTMTLSMIntersectionFunctionTableStateful_init(uint64_t a1)
{
  *(_DWORD *)a1 = 60;
  *(void *)(a1 + 24) = -1LL;
  *(_WORD *)(a1 + 9_Block_object_dispose(va, 8) = 2;
  *(void *)(a1 + 64) = -1LL;
}

double GTMTLSMFilter_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 15;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMFunctionHandle_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 44;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMVisibleFunctionTable_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 83;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMVisibleFunctionTableStateful_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  *(_OWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 83;
  *(void *)(a1 + 24) = -1LL;
  *(_WORD *)(a1 + 9_Block_object_dispose(va, 8) = 2;
  *(void *)(a1 + 64) = -1LL;
  return result;
}

double GTMTLFXSMSpatialScaler_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 39;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLFXSMTemporalScaler_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 10mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 40;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

double GTMTLSMResidencySet_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_DWORD *)a1 = 72;
  *(void *)(a1 + 24) = -1LL;
  return result;
}

apr_hash_t *GTMTLSMResidencySetAllocations_init(apr_hash_t **a1, apr_pool_t *pool)
{
  a1[1] = apr_hash_make(pool);
  double result = apr_hash_make(pool);
  *a1 = result;
  return result;
}

void GTMTLSMResidencySetAllocations_reset(apr_hash_t **a1)
{
}

double GTMTLSMIOCommandBuffer_init(_OWORD *a1)
{
  double result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

double GTMTLSMCommandBuffer_init(_OWORD *a1)
{
  double result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

void GTMTLSMCommandEncoder_init(void *a1)
{
}

BOOL GTMTLSMCommandEncoder_hasEnded(uint64_t a1, unint64_t a2)
{
  return *(void *)(a1 + 24) <= a2;
}

__n128 GTMTLSMRenderCommandEncoder_init(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  memset_pattern16((void *)(a1 + 10100), &unk_1CA4F0, 0x40uLL);
  memset_pattern16((void *)(a1 + 10228), &unk_1CA4F0, 0x40uLL);
  memset_pattern16((void *)(a1 + 10612), &unk_1CA4F0, 0x40uLL);
  *(void *)(a1 + 10676) = 0x3F8000003F800000LL;
  *(void *)(a1 + 1106_Block_object_dispose(va, 8) = 0x100000001LL;
  memset_pattern16((void *)(a1 + 9872), &unk_1CA500, 0x40uLL);
  *(void *)(a1 + 76mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = -1LL;
  result.n128_u64[0] = -1LL;
  result.n128_u64[1] = -1LL;
  *(__n128 *)(a1 + 72_Block_object_dispose(va, 8) = result;
  *(__n128 *)(a1 + 744) = result;
  *(__n128 *)(a1 + 696) = result;
  *(__n128 *)(a1 + 712) = result;
  *(__n128 *)(a1 + 664) = result;
  *(__n128 *)(a1 + 68mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
  *(__n128 *)(a1 + 632) = result;
  *(__n128 *)(a1 + 64_Block_object_dispose(va, 8) = result;
  *(__n128 *)(a1 + 60mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
  *(__n128 *)(a1 + 616) = result;
  *(__n128 *)(a1 + 56_Block_object_dispose(va, 8) = result;
  *(__n128 *)(a1 + 584) = result;
  *(__n128 *)(a1 + 536) = result;
  *(__n128 *)(a1 + 552) = result;
  *(__n128 *)(a1 + 52mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
  *(_WORD *)(a1 + 11086) = 1028;
  return result;
}

__n128 GTMTLSMComputeCommandEncoder_init(__n128 *a1)
{
  a1[48].n128_u64[0] = -1LL;
  result.n128_u64[0] = -1LL;
  result.n128_u64[1] = -1LL;
  a1[46] = result;
  a1[47] = result;
  a1[44] = result;
  a1[45] = result;
  a1[42] = result;
  a1[43] = result;
  a1[40] = result;
  a1[41] = result;
  a1[38] = result;
  a1[39] = result;
  a1[36] = result;
  a1[37] = result;
  a1[34] = result;
  a1[35] = result;
  a1[33] = result;
  a1[140].n128_u8[8] = -1;
  return result;
}

void GTMTLSMParallelCommandEncoder_init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 136) = 0LL;
  *(_OWORD *)(a1 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)a1 = a2;
  memset_pattern16((void *)(a1 + 8), &unk_1CA500, 0x40uLL);
  *(_WORD *)(a1 + 136) = 1028;
}

double GTMTLSMCommandEncoder_renderCommandEncoder(uint64_t a1, unint64_t a2, unint64_t a3)
{
  *(void *)(a1 + 8552) = 1LL;
  *(double *)(a1 + 8576) = (double)a2;
  double result = (double)a3;
  *(double *)(a1 + 8584) = (double)a3;
  *(void *)(a1 + 860mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0x3FF0000000000000LL;
  *(void *)(a1 + 932_Block_object_dispose(va, 8) = 1LL;
  *(void *)(a1 + 9352) = a2;
  *(void *)(a1 + 936mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = a3;
  return result;
}

uint64_t GTMTLSMCommandEncoder_renderPassDescriptor(uint64_t a1)
{
  if (*(_DWORD *)a1 == 70 || *(_DWORD *)a1 == 65) {
    return *(void *)(a1 + 56);
  }
  else {
    return 0LL;
  }
}

uint64_t GTMTLSMRenderCommandEncoder_loadIndirectCommand(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a3 + a2[1]);
  if (!v4) {
    return 0LL;
  }
  uint64_t v9 = (_BYTE *)*a2;
  if (*(_BYTE *)(*a2 + 11LL)
    || (uint64_t result = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(a4, *(void *)(a3 + a2[2])),
        (*(void *)(a1 + 8544) = result) != 0LL))
  {
    if (!v9[10])
    {
      unsigned int v11 = v9[18];
      if (v11 >= 0x40) {
        char v12 = 64;
      }
      else {
        char v12 = v9[18];
      }
      *(void *)(a1 + 8) &= -1LL << v12;
      if (v11)
      {
        unint64_t v13 = 0LL;
        uint64_t v14 = a3 + a2[3];
        do
        {
          unint64_t v15 = *(void *)(v14 + 8 * v13);
          __int128 v16 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a4 + 24LL),  *(int *)(*(void *)a4 + 12LL),  v15);
          if (v16)
          {
            unint64_t v17 = v15 - *v16;
            uint64_t v18 = v16[2];
          }

          else
          {
            unint64_t v17 = 0LL;
            uint64_t v18 = 0LL;
          }

          uint64_t v19 = a1 + 8 * v13;
          *(void *)(v19 + 24) = v18;
          *(void *)(v19 + 272) = v17;
          ++v13;
        }

        while (v13 < v9[18]);
      }

      unsigned int v20 = v9[12];
      if (v20 >= 0x40) {
        char v21 = 64;
      }
      else {
        char v21 = v9[12];
      }
      *(void *)(a1 + 1920) &= -1LL << v21;
      if (v20)
      {
        unint64_t v22 = 0LL;
        uint64_t v23 = a3 + a2[4];
        do
        {
          unint64_t v24 = *(void *)(v23 + 8 * v22);
          int v25 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a4 + 24LL),  *(int *)(*(void *)a4 + 12LL),  v24);
          if (v25)
          {
            unint64_t v26 = v24 - *v25;
            uint64_t v27 = v25[2];
          }

          else
          {
            unint64_t v26 = 0LL;
            uint64_t v27 = 0LL;
          }

          uint64_t v28 = a1 + 8 * v22;
          *(void *)(v28 + 192_Block_object_dispose(va, 8) = v27;
          *(void *)(v28 + 2176) = v26;
          ++v22;
        }

        while (v22 < v9[12]);
      }

      unsigned int v29 = v9[16];
      if (v29 >= 0x40) {
        char v30 = 64;
      }
      else {
        char v30 = v9[16];
      }
      *(void *)(a1 + 3576) &= -1LL << v30;
      if (v29)
      {
        unint64_t v31 = 0LL;
        uint64_t v32 = a3 + a2[5];
        do
        {
          unint64_t v33 = *(void *)(v32 + 8 * v31);
          __int128 v34 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a4 + 24LL),  *(int *)(*(void *)a4 + 12LL),  v33);
          if (v34)
          {
            unint64_t v35 = v33 - *v34;
            uint64_t v36 = v34[2];
          }

          else
          {
            unint64_t v35 = 0LL;
            uint64_t v36 = 0LL;
          }

          uint64_t v37 = a1 + 8 * v31;
          *(void *)(v37 + 3584) = v36;
          *(void *)(v37 + 3832) = v35;
          ++v31;
        }

        while (v31 < v9[16]);
      }

      unsigned int v38 = v9[15];
      if (v38 >= 0x40) {
        char v39 = 64;
      }
      else {
        char v39 = v9[15];
      }
      *(void *)(a1 + 5232) &= -1LL << v39;
      if (v38)
      {
        __int128 v40 = (unint64_t *)(a3 + a2[6]);
        unsigned int v41 = (unint64_t *)(a1 + 5488);
        uint64_t v42 = 655LL;
        do
        {
          unint64_t v44 = *v40++;
          unint64_t v43 = v44;
          unint64_t v45 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a4 + 24LL),  *(int *)(*(void *)a4 + 12LL),  v44);
          if (v45)
          {
            unint64_t v46 = v43 - *v45;
            unint64_t v47 = v45[2];
          }

          else
          {
            unint64_t v46 = 0LL;
            unint64_t v47 = 0LL;
          }

          *(v41 - 31) = v47;
          *v41++ = v46;
          unint64_t v48 = v42 - 654;
          ++v42;
        }

        while (v48 < v9[15]);
      }
    }

    uint64_t v49 = v9[17];
    if (v9[17])
    {
      int v50 = (uint64_t *)(a3 + a2[8]);
      __int128 v51 = (_DWORD *)(a1 + 10944);
      do
      {
        uint64_t v52 = *v50++;
        *v51++ = v52;
        --v49;
      }

      while (v49);
    }

    if (v9[19])
    {
      uint64_t v53 = v9[18];
      char v54 = v53 >= 0x40 ? 64 : v9[18];
      *(void *)(a1 + 16) |= ~(-1LL << v54);
      if (v53)
      {
        uint64_t v55 = (uint64_t *)(a3 + a2[10]);
        __int128 v56 = (void *)(a1 + 520);
        do
        {
          uint64_t v57 = *v55++;
          *v56++ = v57;
          --v53;
        }

        while (v53);
      }
    }

    if (v4 == 8 || v4 == 4)
    {
      uint64_t v58 = a3 + a2[12];
      uint64_t v59 = *(void **)(*(void *)a4 + 24LL);
      unint64_t v60 = *(int *)(*(void *)a4 + 12LL);
      unint64_t v61 = *(void *)v58;
      __int128 v62 = GTMTLGPUAddressResource_resourceForGPUAddress(v59, v60, *(void *)v58);
      if (v62)
      {
        int v63 = v61 - *(_DWORD *)v62;
        uint64_t v64 = v62[2];
      }

      else
      {
        int v63 = 0;
        uint64_t v64 = 0LL;
      }

      *(void *)(a1 + 9864) = v64;
      *(_DWORD *)(a1 + 1068_Block_object_dispose(va, 8) = v63;
      *(_DWORD *)(a1 + 10692) = *(void *)(v58 + 8);
      *(_DWORD *)(a1 + 10676) = *(_DWORD *)(v58 + 16);
      return v4 != 8 || v64 != 0;
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

uint64_t GTMTLSMComputeCommandEncoder_loadIndirectCommand(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a3 + a2[1]);
  if (!v4) {
    return 0LL;
  }
  uint64_t v9 = (_BYTE *)*a2;
  if (*(_BYTE *)(*a2 + 11LL) {
    || (uint64_t result = GTMTLIndirectResources_computePipelineIdForUniqueIdentifier(a4, *(void *)(a3 + a2[2])),
  }
        (*(void *)(a1 + _Block_object_dispose(va, 8) = result) != 0LL))
  {
    if (!v9[10])
    {
      unsigned int v11 = v9[13];
      char v12 = v11 >= 0x40 ? 64 : v9[13];
      *(void *)(a1 + 16) &= -1LL << v12;
      if (v11)
      {
        unint64_t v13 = 0LL;
        uint64_t v14 = a3 + a2[7];
        do
        {
          unint64_t v15 = *(void *)(v14 + 8 * v13);
          __int128 v16 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a4 + 24LL),  *(int *)(*(void *)a4 + 12LL),  v15);
          if (v16)
          {
            unint64_t v17 = v15 - *v16;
            uint64_t v18 = v16[2];
          }

          else
          {
            unint64_t v17 = 0LL;
            uint64_t v18 = 0LL;
          }

          uint64_t v19 = a1 + 8 * v13;
          *(void *)(v19 + 32) = v18;
          *(void *)(v19 + 28mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v17;
          ++v13;
        }

        while (v13 < v9[13]);
      }
    }

    if (v9[19])
    {
      uint64_t v20 = v9[13];
      char v21 = v20 >= 0x40 ? 64 : v9[13];
      *(void *)(a1 + 24) |= ~(-1LL << v21);
      if (v20)
      {
        unint64_t v22 = (uint64_t *)(a3 + a2[10]);
        uint64_t v23 = (void *)(a1 + 528);
        do
        {
          uint64_t v24 = *v22++;
          *v23++ = v24;
          --v20;
        }

        while (v20);
      }
    }

    uint64_t v25 = v9[14];
    if (v9[14])
    {
      unint64_t v26 = (uint64_t *)(a3 + a2[9]);
      uint64_t v27 = (_DWORD *)(a1 + 1984);
      do
      {
        uint64_t v28 = *v26++;
        *v27++ = v28;
        --v25;
      }

      while (v25);
    }

    if (v4 == 32 || v4 == 64)
    {
      unsigned int v29 = (__int128 *)(a3 + a2[12]);
      __int128 v30 = *v29;
      *(void *)(a1 + 1944) = *((void *)v29 + 2);
      *(_OWORD *)(a1 + 192_Block_object_dispose(va, 8) = v30;
      __int128 v31 = *(__int128 *)((char *)v29 + 24);
      *(void *)(a1 + 196_Block_object_dispose(va, 8) = *((void *)v29 + 5);
      *(_OWORD *)(a1 + 1952) = v31;
    }

    return 1LL;
  }

  return result;
}

char *GTMTLSMBuffer_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  BOOL v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 <= -15779)
  {
    if (v6 <= -16313)
    {
      switch(v6)
      {
        case -16372:
          uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[8], a2);
          *((void *)v5 + 9) = result;
          break;
        case -16371:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((_DWORD *)v5 + 22) = *((_DWORD *)result + 2);
          break;
        case -16370:
          *((void *)result + 3) = *a3;
          break;
        case -16369:
        case -16368:
          return result;
        case -16367:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v28 = *((void *)result + 2);
          if (v28 != 1) {
            *((_WORD *)v5 + 49) = v28;
          }
          break;
        default:
          if (v6 == -16314 || v6 == -16313) {
            goto LABEL_35;
          }
          break;
      }

      return result;
    }

    if (v6 > -16123)
    {
      switch(v6)
      {
        case -16122:
          result[100] = 1;
          break;
        case -16117:
          unsigned int v29 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v30 = *a3;
          uint64_t v31 = *((void *)v29 + 2);
          *((void *)v5 + 1) = *((void *)v29 + 1);
          *((void *)v5 + 2) = v30;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((void *)v29 + 3);
          *((void *)v5 + 13) = v31;
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 19) = result;
          if (result)
          {
            uint64_t v32 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v33 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v32;
            *((_DWORD *)v5 + 22) = v33;
            *((void *)v5 + 14) = *((void *)result + 3);
            *((_OWORD *)v5 + _Block_object_dispose(va, 8) = *((_OWORD *)result + 2);
          }

          *((void *)v5 + 6) = *(void *)v29;
          break;
        case -15914:
          unint64_t v8 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v9 = *a3;
          uint64_t v10 = *(void *)v8;
          *((void *)v5 + 1) = *((void *)v8 + 1);
          *((void *)v5 + 2) = v9;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          *((void *)v5 + 5) = *((void *)v8 + 2);
          *((void *)v5 + 15) = v10;
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          uint64_t v11 = *((void *)result + 3);
          *((void *)v5 + 13) = *((void *)result + 2);
          *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = v11;
          break;
      }

      return result;
    }

    if (v6 != -16312)
    {
      if (v6 != -16163) {
        return result;
      }
      uint64_t v18 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v19 = *a3;
      *((void *)v5 + 1) = *((void *)v18 + 1);
      *((void *)v5 + 2) = v19;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      uint64_t v20 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *((void *)v5 + 19) = v20;
      if (v20)
      {
        uint64_t v21 = *((void *)v20 + 1);
        *((void *)v5 + 7) = *(void *)v20;
        int v22 = *((_DWORD *)v20 + 4);
        *((_DWORD *)v5 + 21) = v21;
        *((_DWORD *)v5 + 22) = v22;
        *((void *)v5 + 14) = *((void *)v20 + 3);
        *((_OWORD *)v5 + _Block_object_dispose(va, 8) = *((_OWORD *)v20 + 2);
      }

      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v18[16], a2);
      *((void *)v5 + 1_Block_object_dispose(va, 8) = result;
      if (result) {
        uint64_t v23 = *((void *)result + 1);
      }
      else {
        uint64_t v23 = 0LL;
      }
      *((void *)v5 + 13) = v23;
      goto LABEL_58;
    }

LABEL_35:
    uint64_t v18 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v24 = *a3;
    uint64_t v25 = *((void *)v18 + 2);
    *((void *)v5 + 1) = *((void *)v18 + 1);
    *((void *)v5 + 2) = v24;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((void *)v18 + 3);
    *((void *)v5 + 13) = v25;
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    *((void *)v5 + 19) = result;
    if (result)
    {
      uint64_t v26 = *((void *)result + 1);
      *((void *)v5 + 7) = *(void *)result;
      int v27 = *((_DWORD *)result + 4);
      *((_DWORD *)v5 + 21) = v26;
      *((_DWORD *)v5 + 22) = v27;
      *((void *)v5 + 14) = *((void *)result + 3);
      *((_OWORD *)v5 + _Block_object_dispose(va, 8) = *((_OWORD *)result + 2);
    }

    uint64_t v18 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v24 = *(void *)a3;
    uint64_t v25 = *((void *)v18 + 2);
    *((void *)v5 + 1) = *((void *)v18 + 1);
    *((void *)v5 + 2) = v24;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
    *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((void *)v18 + 3);
    *((void *)v5 + 13) = v25;
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
    *((void *)v5 + 19) = result;
    if (result)
    {
      uint64_t v26 = *((void *)result + 1);
      *((void *)v5 + 7) = *(void *)result;
      int v27 = *((_DWORD *)result + 4);
      *((_DWORD *)v5 + 21) = v26;
      *((_DWORD *)v5 + 22) = v27;
      *((void *)v5 + 14) = *((void *)result + 3);
      *((_OWORD *)v5 + _Block_object_dispose(va, 8) = *((_OWORD *)result + 2);
    }

      ++v25;
    }

    while ((uint64_t)v25 < v12->nelts);
    a2 = v102;
    uint64_t v11 = v103;
    uint64_t v24 = *(void *)(v103 + 16);
    uint64_t v23 = *(void *)(v103 + 24);
  }

  *(void *)(v11 + 544) = v12;
  uint64_t v36 = OrderDispatchCommandBuffers(v24, v23, (uint64_t)v12, v9);
  uint64_t v37 = ActiveCommandQueues(*(void *)(v11 + 16), (uint64_t)v36, v9);
  uint64_t v38 = ActiveDevices(*(void *)(v11 + 16), *(void *)(v11 + 24), (uint64_t)v37, v9);
  *(void *)(v11 + 552) = v36;
  int nelts = v38->nelts;
  if (!(_DWORD)nelts)
  {
    *(void *)(v11 + 56) = 0LL;
    goto LABEL_114;
  }

  __int128 v40 = *(void *)(v11 + 16);
  unsigned int v41 = *(void *)(v11 + 24);
  uint64_t v42 = *a2;
  unint64_t v44 = 0LL;
  while (*(void *)&v38->elts[8 * v44] != v42)
  {
    if (nelts == ++v44) {
      goto LABEL_48;
    }
  }

  if ((int)nelts <= (int)v44)
  {
LABEL_48:
    unint64_t v45 = a2[1];
    if (!v45) {
      goto LABEL_61;
    }
    unint64_t v46 = v37->nelts;
    unint64_t v47 = 0LL;
    while (*(void *)&v37->elts[8 * v47] != v45)
    {
      if (v46 == ++v47) {
        goto LABEL_61;
      }
    }

    if ((int)v46 > (int)v47)
    {
      *(void *)buf = a2[1];
      unint64_t v48 = find_entry(v40, buf, 8uLL, 0LL);
      if (*v48
        && (uint64_t v49 = *(void *)(*v48 + 32LL)) != 0
        && (int v50 = *(void *)(v49 + 32)) != 0
        && (*(_BYTE *)(v50 + 79) & 8) != 0)
      {
        __int128 v51 = (uint64_t *)(v50 + 64);
      }

      else
      {
        __int128 v51 = 0LL;
      }

      *(_OWORD *)buf = 0u;
      *(void *)&id v108 = 0LL;
      unint64_t v110 = 0u;
      unint64_t v111 = 0u;
      id v109 = 0u;
      *(_DWORD *)buf = 27;
      *((void *)&v108 + 1) = -1LL;
      BYTE12(v111) = 1;
      WORD4(v111) = 769;
      GTMTLSMCommandQueue_processTraceFuncWithMap((char *)buf, v41, v51);
      uint64_t v42 = *((void *)&v109 + 1);
    }

    else
    {
LABEL_61:
      uint64_t v42 = *(void *)v38->elts;
    }
  }

  *(void *)(v11 + 56) = v42;
  if (!v42) {
    goto LABEL_114;
  }
  if (v37->nelts < 1)
  {
    uint64_t v53 = 0;
  }

  else
  {
    uint64_t v52 = 0LL;
    uint64_t v53 = 0;
    do
    {
      char v54 = *(void *)&v37->elts[8 * v52];
      uint64_t v55 = *(void *)(v11 + 16);
      *(void *)buf = v54;
      __int128 v56 = find_entry(v55, buf, 8uLL, 0LL);
      if (*v56 && (uint64_t v57 = *(void *)(*v56 + 32LL)) != 0)
      {
        uint64_t v58 = *(void *)(v57 + 32);
        if (v58) {
          uint64_t v59 = v58 + 64;
        }
        else {
          uint64_t v59 = 0LL;
        }
      }

      else
      {
        uint64_t v59 = 0LL;
      }

      unint64_t v60 = v11;
      unint64_t v61 = *(void *)(v11 + 56);
      __int128 v62 = *(void *)(v60 + 24);
      if (*(_DWORD *)(v59 + 8) == -15350)
      {
        *(_OWORD *)buf = 0uLL;
        *(void *)&id v108 = 0LL;
        id v109 = 0uLL;
        unint64_t v110 = 0uLL;
        *(_DWORD *)buf = 52;
        *((void *)&v108 + 1) = -1LL;
        GTMTLSMIOCommandQueue_processTraceFuncWithMap((char *)buf, v62, (uint64_t *)v59);
      }

      else
      {
        *(_OWORD *)buf = 0uLL;
        *(void *)&id v108 = 0LL;
        unint64_t v110 = 0uLL;
        unint64_t v111 = 0uLL;
        id v109 = 0uLL;
        *(_DWORD *)buf = 27;
        *((void *)&v108 + 1) = -1LL;
        BYTE12(v111) = 1;
        WORD4(v111) = 769;
        GTMTLSMCommandQueue_processTraceFuncWithMap((char *)buf, v62, (uint64_t *)v59);
      }

      if (v61 == *((void *)&v109 + 1)) {
        *(void *)&v37->elts[8 * v53++] = v54;
      }
      uint64_t v11 = v103;
      ++v52;
    }

    while (v52 < v37->nelts);
  }

  v37->int nelts = v53;
  if (v36->nelts < 1)
  {
    uint64_t v64 = 0;
    __int128 v65 = v101;
  }

  else
  {
    int v63 = 0LL;
    uint64_t v64 = 0;
    __int128 v65 = v101;
    do
    {
      __int128 v66 = *(void *)&v36->elts[8 * v63];
      uint64_t v67 = *(void *)(v11 + 16);
      *(void *)buf = v66;
      __int128 v68 = *(void *)(*find_entry(v67, buf, 8uLL, 0LL) + 32LL);
      __int128 v69 = *(void *)(v68 + 32);
      if (v69 && (*(_BYTE *)(v69 + 79) & 8) != 0) {
        __int128 v70 = v69 + 64;
      }
      else {
        __int128 v70 = 0LL;
      }
      __int128 v71 = CommandQueueForCommandBuffer(*(void *)(v68 + 24), v70);
      __int128 v72 = v37->nelts;
      if ((int)v72 >= 1)
      {
        uint64_t v73 = 0LL;
        while (*(void *)&v37->elts[8 * v73] != v71)
        {
          if (v72 == ++v73) {
            goto LABEL_92;
          }
        }
      }

LABEL_58:
    *((void *)v5 + 5) = *(void *)v18;
    return result;
  }

  if (v6 > -10224)
  {
    if (v6 <= -10204)
    {
      if (v6 == -10223)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 21) = *((void *)result + 1);
      }

      else if (v6 == -10210)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
      }

      return result;
    }

    if (v6 == -10203)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 7) = *((void *)result + 1);
      return result;
    }

    if (v6 != -10187)
    {
      if (v6 != -10186) {
        return result;
      }
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      __int128 v12 = *(_OWORD *)(result + 8);
      goto LABEL_28;
    }

    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v34 = *((void *)result + 1);
LABEL_54:
    *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v34;
    return result;
  }

  if (v6 <= -10238)
  {
    if (v6 != -15778)
    {
      if (v6 != -15509) {
        return result;
      }
      unint64_t v13 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v14 = *a3;
      *((void *)v5 + 1) = *((void *)v13 + 1);
      *((void *)v5 + 2) = v14;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      unint64_t v15 = GTTraceFunc_argumentBytesWithMap(a3, v13[16], a2);
      *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)v15 + 16);
      *((void *)v5 + 13) = *(void *)v15;
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *((void *)v5 + 19) = result;
      if (!result) {
        return result;
      }
      uint64_t v16 = *((void *)result + 1);
      *((void *)v5 + 7) = *(void *)result;
      int v17 = *((_DWORD *)result + 4);
      *((_DWORD *)v5 + 21) = v16;
      *((_DWORD *)v5 + 22) = v17;
      *((void *)v5 + 14) = *((void *)result + 3);
      __int128 v12 = *((_OWORD *)result + 2);
LABEL_28:
      *((_OWORD *)v5 + _Block_object_dispose(va, 8) = v12;
      return result;
    }

    unint64_t v35 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v36 = *a3;
    uint64_t v37 = *((void *)v35 + 2);
    *((void *)v5 + 1) = *((void *)v35 + 1);
    *((void *)v5 + 2) = v36;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((void *)v35 + 3);
    *((void *)v5 + 13) = v37;
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    *((void *)v5 + 19) = result;
    if (result)
    {
      uint64_t v38 = *((void *)result + 1);
      *((void *)v5 + 7) = *(void *)result;
      int v39 = *((_DWORD *)result + 4);
      *((_DWORD *)v5 + 21) = v38;
      *((_DWORD *)v5 + 22) = v39;
      *((void *)v5 + 14) = *((void *)result + 3);
      *((_OWORD *)v5 + _Block_object_dispose(va, 8) = *((_OWORD *)result + 2);
    }

    *((void *)v5 + 6) = *(void *)v35;
    uint64_t v34 = *((void *)v35 + 4);
    goto LABEL_54;
  }

  switch(v6)
  {
    case -10237:
      goto LABEL_35;
    case -10235:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((_DWORD *)v5 + 23) = *((_DWORD *)result + 2);
      break;
    case -10228:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 14) = *((void *)result + 1);
      break;
  }

  return result;
}

    *((void *)v5 + 5) = *(void *)v18;
    return result;
  }

  if (v6 > -10224)
  {
    if (v6 <= -10204)
    {
      if (v6 == -10223)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_DWORD *)v5 + 21) = *((void *)result + 1);
      }

      else if (v6 == -10210)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
      }

      return result;
    }

    if (v6 == -10203)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + 7) = *((void *)result + 1);
      return result;
    }

    if (v6 != -10187)
    {
      if (v6 != -10186) {
        return result;
      }
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      __int128 v12 = *(_OWORD *)(result + 8);
      goto LABEL_28;
    }

    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v34 = *((void *)result + 1);
LABEL_54:
    *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v34;
    return result;
  }

  if (v6 <= -10238)
  {
    if (v6 != -15778)
    {
      if (v6 != -15509) {
        return result;
      }
      unint64_t v13 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v14 = *(void *)a3;
      *((void *)v5 + 1) = *((void *)v13 + 1);
      *((void *)v5 + 2) = v14;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      unint64_t v15 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v13[16], a2);
      *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)v15 + 16);
      *((void *)v5 + 13) = *(void *)v15;
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *((void *)v5 + 19) = result;
      if (!result) {
        return result;
      }
      uint64_t v16 = *((void *)result + 1);
      *((void *)v5 + 7) = *(void *)result;
      int v17 = *((_DWORD *)result + 4);
      *((_DWORD *)v5 + 21) = v16;
      *((_DWORD *)v5 + 22) = v17;
      *((void *)v5 + 14) = *((void *)result + 3);
      __int128 v12 = *((_OWORD *)result + 2);
LABEL_28:
      *((_OWORD *)v5 + _Block_object_dispose(va, 8) = v12;
      return result;
    }

    unint64_t v35 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v36 = *(void *)a3;
    uint64_t v37 = *((void *)v35 + 2);
    *((void *)v5 + 1) = *((void *)v35 + 1);
    *((void *)v5 + 2) = v36;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
    *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((void *)v35 + 3);
    *((void *)v5 + 13) = v37;
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
    *((void *)v5 + 19) = result;
    if (result)
    {
      uint64_t v38 = *((void *)result + 1);
      *((void *)v5 + 7) = *(void *)result;
      int v39 = *((_DWORD *)result + 4);
      *((_DWORD *)v5 + 21) = v38;
      *((_DWORD *)v5 + 22) = v39;
      *((void *)v5 + 14) = *((void *)result + 3);
      *((_OWORD *)v5 + _Block_object_dispose(va, 8) = *((_OWORD *)result + 2);
    }

    *((void *)v5 + 6) = *(void *)v35;
    uint64_t v34 = *((void *)v35 + 4);
    goto LABEL_54;
  }

  switch(v6)
  {
    case -10237:
      goto LABEL_35;
    case -10235:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((_DWORD *)v5 + 23) = *((_DWORD *)result + 2);
      break;
    case -10228:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + 14) = *((void *)result + 1);
      break;
  }

  return result;
}

char *GTMTLSMTexture_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  BOOL v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -15914)
  {
    if (v6 <= -10228)
    {
      if (v6 > -15690)
      {
        if (v6 > -10235)
        {
          if (v6 == -10234)
          {
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            *((_DWORD *)v5 + 23) = *((_DWORD *)result + 2);
          }

          else if (v6 == -10231)
          {
            __int128 v69 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v69[8], a2);
            *((void *)v5 + 14) = result;
          }

          return result;
        }

        if (v6 == -15689)
        {
          uint64_t v36 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v103 = *a3;
          *((void *)v5 + 1) = *((void *)v36 + 1);
          *((void *)v5 + 2) = v103;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 16) = result;
          if (result)
          {
            uint64_t v104 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v105 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v104;
            *((_DWORD *)v5 + 22) = v105;
            uint64_t v107 = *((void *)result + 6);
            uint64_t v106 = *((void *)result + 7);
            *((void *)v5 + 21) = *((void *)result + 5);
            *((void *)v5 + 22) = v106;
            *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
            *((void *)v5 + 14) = result + 24;
            *((void *)v5 + 25) = v107;
          }

          *((_WORD *)v5 + 76) = *((void *)v36 + 2);
          v5[158] = *((void *)v36 + 3);
          v5[159] = *((void *)v36 + 4);
          v5[160] = *((void *)v36 + 5);
          *((_WORD *)v5 + 77) = *((void *)v36 + 6);
          *((_WORD *)v5 + 7_Block_object_dispose(va, 8) = *((void *)v36 + 7);
        }

        else
        {
          if (v6 != -15688) {
            return result;
          }
          uint64_t v36 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v37 = *a3;
          *((void *)v5 + 1) = *((void *)v36 + 1);
          *((void *)v5 + 2) = v37;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 16) = result;
          if (result)
          {
            uint64_t v38 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v39 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v38;
            *((_DWORD *)v5 + 22) = v39;
            uint64_t v41 = *((void *)result + 6);
            uint64_t v40 = *((void *)result + 7);
            *((void *)v5 + 21) = *((void *)result + 5);
            *((void *)v5 + 22) = v40;
            *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
            *((void *)v5 + 14) = result + 24;
            *((void *)v5 + 25) = v41;
          }

          *((_WORD *)v5 + 76) = *((void *)v36 + 2);
          v5[158] = *((void *)v36 + 3);
          v5[159] = *((void *)v36 + 4);
          v5[160] = *((void *)v36 + 5);
          *((_WORD *)v5 + 77) = *((void *)v36 + 6);
          *((_WORD *)v5 + 7_Block_object_dispose(va, 8) = *((void *)v36 + 7);
          *((_DWORD *)v5 + 52) = *((_DWORD *)v36 + 18);
        }

        *((void *)v5 + 1_Block_object_dispose(va, 8) = *(void *)v36;
        uint64_t v56 = *((void *)v36 + 8);
      }

      else
      {
        if (v6 <= -15776)
        {
          if (v6 == -15913)
          {
            char v90 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v91 = *a3;
            *((void *)v5 + 1) = *((void *)v90 + 1);
            *((void *)v5 + 2) = v91;
            *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
            int v92 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *((void *)v5 + 16) = v92;
            if (v92)
            {
              uint64_t v93 = *((void *)v92 + 1);
              *((void *)v5 + 7) = *(void *)v92;
              int v94 = *((_DWORD *)v92 + 4);
              *((_DWORD *)v5 + 21) = v93;
              *((_DWORD *)v5 + 22) = v94;
              uint64_t v96 = *((void *)v92 + 6);
              uint64_t v95 = *((void *)v92 + 7);
              *((void *)v5 + 21) = *((void *)v92 + 5);
              *((void *)v5 + 22) = v95;
              *((_WORD *)v5 + 106) = *((_WORD *)v92 + 40);
              *((void *)v5 + 14) = v92 + 24;
              *((void *)v5 + 25) = v96;
            }

            *((void *)v5 + 5) = *((void *)v90 + 2);
            *((void *)v5 + 23) = *(void *)v90;
            id v97 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v97[24], a2);
            *((void *)v5 + 13) = result;
            return result;
          }

          if (v6 != -15777) {
            return result;
          }
          uint64_t v21 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v22 = *a3;
          *((void *)v5 + 1) = *((void *)v21 + 1);
          *((void *)v5 + 2) = v22;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t v23 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 16) = v23;
          if (v23)
          {
            uint64_t v24 = *((void *)v23 + 1);
            *((void *)v5 + 7) = *(void *)v23;
            int v25 = *((_DWORD *)v23 + 4);
            *((_DWORD *)v5 + 21) = v24;
            *((_DWORD *)v5 + 22) = v25;
            uint64_t v27 = *((void *)v23 + 6);
            uint64_t v26 = *((void *)v23 + 7);
            *((void *)v5 + 21) = *((void *)v23 + 5);
            *((void *)v5 + 22) = v26;
            *((_WORD *)v5 + 106) = *((_WORD *)v23 + 40);
            *((void *)v5 + 14) = v23 + 24;
            *((void *)v5 + 25) = v27;
          }

          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v21[24], a2);
          *((void *)v5 + 13) = result;
          *((void *)v5 + 6) = *(void *)v21;
          uint64_t v28 = *((void *)v21 + 2);
LABEL_91:
          *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v28;
          return result;
        }

        if (v6 == -15775)
        {
          __int128 v70 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v121 = *a3;
          *((void *)v5 + 1) = *((void *)v70 + 1);
          *((void *)v5 + 2) = v121;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 16) = result;
          if (result)
          {
            uint64_t v122 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v123 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v122;
            *((_DWORD *)v5 + 22) = v123;
            uint64_t v125 = *((void *)result + 6);
            uint64_t v124 = *((void *)result + 7);
            *((void *)v5 + 21) = *((void *)result + 5);
            *((void *)v5 + 22) = v124;
            *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
            *((void *)v5 + 14) = result + 24;
            *((void *)v5 + 25) = v125;
          }

          *((_WORD *)v5 + 76) = *((void *)v70 + 2);
          v5[158] = *((void *)v70 + 3);
          v5[159] = *((void *)v70 + 4);
          v5[160] = *((void *)v70 + 5);
          *((_WORD *)v5 + 77) = *((void *)v70 + 6);
          *((_WORD *)v5 + 7_Block_object_dispose(va, 8) = *((void *)v70 + 7);
          *((_DWORD *)v5 + 52) = *((_DWORD *)v70 + 16);
          goto LABEL_117;
        }

        if (v6 != -15690) {
          return result;
        }
        uint64_t v57 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v58 = *a3;
        *((void *)v5 + 1) = *((void *)v57 + 1);
        *((void *)v5 + 2) = v58;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 16) = result;
        if (result)
        {
          uint64_t v59 = *((void *)result + 1);
          *((void *)v5 + 7) = *(void *)result;
          int v60 = *((_DWORD *)result + 4);
          *((_DWORD *)v5 + 21) = v59;
          *((_DWORD *)v5 + 22) = v60;
          uint64_t v61 = *((void *)result + 6);
          *((void *)v5 + 21) = *((void *)result + 5);
          *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
          *((void *)v5 + 14) = result + 24;
          *((void *)v5 + 25) = v61;
        }

        *((_WORD *)v5 + 76) = *((void *)v57 + 2);
        *((void *)v5 + 1_Block_object_dispose(va, 8) = *(void *)v57;
        uint64_t v56 = *((void *)v57 + 3);
      }
    }

    else
    {
      if (v6 <= -10205)
      {
        if (v6 > -10213)
        {
          if (v6 == -10212)
          {
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
          }

          else if (v6 == -10205)
          {
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            *((_WORD *)v5 + 106) = *((_DWORD *)result + 2);
          }
        }

        else if (v6 == -10227)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 21) = *((void *)result + 1);
        }

        else if (v6 == -10222)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((_DWORD *)v5 + 21) = *((_DWORD *)result + 2);
        }

        return result;
      }

      if (v6 > -10186)
      {
        if (v6 != -10185)
        {
          if (v6 == -10164)
          {
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            *((void *)v5 + 25) = *((void *)result + 1);
          }

          else if (v6 == -7167)
          {
            uint64_t v14 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v15 = *a3;
            *((void *)v5 + 1) = *((void *)v14 + 1);
            *((void *)v5 + 2) = v15;
            *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *((void *)v5 + 16) = result;
            if (result)
            {
              uint64_t v16 = *((void *)result + 1);
              *((void *)v5 + 7) = *(void *)result;
              int v17 = *((_DWORD *)result + 4);
              *((_DWORD *)v5 + 21) = v16;
              *((_DWORD *)v5 + 22) = v17;
              uint64_t v19 = *((void *)result + 6);
              uint64_t v18 = *((void *)result + 7);
              *((void *)v5 + 21) = *((void *)result + 5);
              *((void *)v5 + 22) = v18;
              *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
              *((void *)v5 + 14) = result + 24;
              *((void *)v5 + 25) = v19;
            }

            *((void *)v5 + 24) = *(void *)v14;
          }

          return result;
        }

        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v28 = *((void *)result + 1);
        goto LABEL_91;
      }

      if (v6 == -10204)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((void *)v5 + 7) = *((void *)result + 1);
        return result;
      }

      if (v6 != -10198) {
        return result;
      }
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v56 = *((void *)result + 1);
    }

    *((void *)v5 + 22) = v56;
    return result;
  }

  if (v6 <= -16197)
  {
    if (v6 > -16241)
    {
      switch(v6)
      {
        case -16240:
          uint64_t v20 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v20[8], a2);
          *((void *)v5 + 9) = result;
          break;
        case -16239:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((_DWORD *)v5 + 22) = *((_DWORD *)result + 2);
          break;
        case -16238:
          *((void *)result + 3) = *a3;
          break;
        case -16233:
          __int128 v70 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v71 = *a3;
          *((void *)v5 + 1) = *((void *)v70 + 1);
          *((void *)v5 + 2) = v71;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 16) = result;
          if (result)
          {
            uint64_t v72 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v73 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v72;
            *((_DWORD *)v5 + 22) = v73;
            uint64_t v75 = *((void *)result + 6);
            uint64_t v74 = *((void *)result + 7);
            *((void *)v5 + 21) = *((void *)result + 5);
            *((void *)v5 + 22) = v74;
            *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
            *((void *)v5 + 14) = result + 24;
            *((void *)v5 + 25) = v75;
          }

          *((_WORD *)v5 + 76) = *((void *)v70 + 2);
          goto LABEL_117;
        case -16232:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v76 = *((void *)result + 2);
          if (v76 != 1) {
            *((_WORD *)v5 + 49) = v76;
          }
          break;
        default:
          return result;
      }

      return result;
    }

    if (v6 != -16368)
    {
      if (v6 != -16310)
      {
        if (v6 != -16294) {
          return result;
        }
        uint64_t v42 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v43 = *a3;
        *((void *)v5 + 1) = *((void *)v42 + 1);
        *((void *)v5 + 2) = v43;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        unint64_t v44 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 16) = v44;
        if (v44)
        {
          uint64_t v45 = *((void *)v44 + 1);
          *((void *)v5 + 7) = *(void *)v44;
          int v46 = *((_DWORD *)v44 + 4);
          *((_DWORD *)v5 + 21) = v45;
          *((_DWORD *)v5 + 22) = v46;
          uint64_t v48 = *((void *)v44 + 6);
          uint64_t v47 = *((void *)v44 + 7);
          *((void *)v5 + 21) = *((void *)v44 + 5);
          *((void *)v5 + 22) = v47;
          *((_WORD *)v5 + 106) = *((_WORD *)v44 + 40);
          *((void *)v5 + 14) = v44 + 24;
          *((void *)v5 + 25) = v48;
        }

        *((void *)v5 + 13) = GTTraceFunc_argumentBytesWithMap(a3, v42[24], a2);
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v42[25], a2);
        *((void *)v5 + 15) = result;
        *((void *)v5 + 19) = *((void *)v42 + 2);
        goto LABEL_109;
      }

      uint64_t v42 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v108 = *a3;
      *((void *)v5 + 1) = *((void *)v42 + 1);
      *((void *)v5 + 2) = v108;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      id v109 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *((void *)v5 + 16) = v109;
      if (v109)
      {
        uint64_t v110 = *((void *)v109 + 1);
        *((void *)v5 + 7) = *(void *)v109;
        int v111 = *((_DWORD *)v109 + 4);
        *((_DWORD *)v5 + 21) = v110;
        *((_DWORD *)v5 + 22) = v111;
        uint64_t v113 = *((void *)v109 + 6);
        uint64_t v112 = *((void *)v109 + 7);
        *((void *)v5 + 21) = *((void *)v109 + 5);
        *((void *)v5 + 22) = v112;
        *((_WORD *)v5 + 106) = *((_WORD *)v109 + 40);
        *((void *)v5 + 14) = v109 + 24;
        *((void *)v5 + 25) = v113;
      }

      unsigned int v55 = v42[24];
      goto LABEL_108;
    }

    goto LABEL_67;
  }

  if (v6 <= -16099)
  {
    if (v6 <= -16115)
    {
      if (v6 != -16196)
      {
        if (v6 == -16116)
        {
          unsigned int v29 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v30 = *a3;
          *((void *)v5 + 1) = *((void *)v29 + 1);
          *((void *)v5 + 2) = v30;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t v31 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 16) = v31;
          if (v31)
          {
            uint64_t v32 = *((void *)v31 + 1);
            *((void *)v5 + 7) = *(void *)v31;
            int v33 = *((_DWORD *)v31 + 4);
            *((_DWORD *)v5 + 21) = v32;
            *((_DWORD *)v5 + 22) = v33;
            uint64_t v35 = *((void *)v31 + 6);
            uint64_t v34 = *((void *)v31 + 7);
            *((void *)v5 + 21) = *((void *)v31 + 5);
            *((void *)v5 + 22) = v34;
            *((_WORD *)v5 + 106) = *((_WORD *)v31 + 40);
            *((void *)v5 + 14) = v31 + 24;
            *((void *)v5 + 25) = v35;
          }

          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v29[16], a2);
          *((void *)v5 + 13) = result;
          *((void *)v5 + 6) = *(void *)v29;
        }

        return result;
      }

      __int128 v70 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v98 = *a3;
      *((void *)v5 + 1) = *((void *)v70 + 1);
      *((void *)v5 + 2) = v98;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *((void *)v5 + 16) = result;
      if (result)
      {
        uint64_t v99 = *((void *)result + 1);
        *((void *)v5 + 7) = *(void *)result;
        int v100 = *((_DWORD *)result + 4);
        *((_DWORD *)v5 + 21) = v99;
        *((_DWORD *)v5 + 22) = v100;
        uint64_t v102 = *((void *)result + 6);
        uint64_t v101 = *((void *)result + 7);
        *((void *)v5 + 21) = *((void *)result + 5);
        *((void *)v5 + 22) = v101;
        *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
        *((void *)v5 + 14) = result + 24;
        *((void *)v5 + 25) = v102;
      }

      *((_WORD *)v5 + 76) = *((void *)v70 + 2);
      v5[158] = *((void *)v70 + 3);
      v5[159] = *((void *)v70 + 4);
      v5[160] = *((void *)v70 + 5);
      *((_WORD *)v5 + 77) = *((void *)v70 + 6);
      *((_WORD *)v5 + 7_Block_object_dispose(va, 8) = *((void *)v70 + 7);
LABEL_117:
      *((void *)v5 + 1_Block_object_dispose(va, 8) = *(void *)v70;
      return result;
    }

    if (v6 == -16114)
    {
      result[100] = 1;
      return result;
    }

    if (v6 != -16104) {
      return result;
    }
LABEL_67:
    __int128 v62 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v63 = *a3;
    *((void *)v5 + 1) = *((void *)v62 + 1);
    *((void *)v5 + 2) = v63;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    uint64_t v64 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    *((void *)v5 + 16) = v64;
    if (v64)
    {
      uint64_t v65 = *((void *)v64 + 1);
      *((void *)v5 + 7) = *(void *)v64;
      int v66 = *((_DWORD *)v64 + 4);
      *((_DWORD *)v5 + 21) = v65;
      *((_DWORD *)v5 + 22) = v66;
      uint64_t v68 = *((void *)v64 + 6);
      uint64_t v67 = *((void *)v64 + 7);
      *((void *)v5 + 21) = *((void *)v64 + 5);
      *((void *)v5 + 22) = v67;
      *((_WORD *)v5 + 106) = *((_WORD *)v64 + 40);
      *((void *)v5 + 14) = v64 + 24;
      *((void *)v5 + 25) = v68;
    }

    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v62[32], a2);
    *((void *)v5 + 13) = result;
    *((void *)v5 + 17) = *(void *)v62;
    *((_DWORD *)v5 + 3_Block_object_dispose(va, 8) = *((void *)v62 + 2);
    *((_DWORD *)v5 + 39) = *((void *)v62 + 3);
    return result;
  }

  if (v6 > -16032)
  {
    if (v6 == -16031)
    {
      uint64_t v42 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v77 = *a3;
      *((void *)v5 + 1) = *((void *)v42 + 1);
      *((void *)v5 + 2) = v77;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      char v78 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *((void *)v5 + 16) = v78;
      if (v78)
      {
        uint64_t v79 = *((void *)v78 + 1);
        *((void *)v5 + 7) = *(void *)v78;
        int v80 = *((_DWORD *)v78 + 4);
        *((_DWORD *)v5 + 21) = v79;
        *((_DWORD *)v5 + 22) = v80;
        uint64_t v82 = *((void *)v78 + 6);
        uint64_t v81 = *((void *)v78 + 7);
        *((void *)v5 + 21) = *((void *)v78 + 5);
        *((void *)v5 + 22) = v81;
        *((_WORD *)v5 + 106) = *((_WORD *)v78 + 40);
        *((void *)v5 + 14) = v78 + 24;
        *((void *)v5 + 25) = v82;
      }

      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v42[41], a2);
      *((void *)v5 + 13) = result;
      *((_DWORD *)v5 + 3_Block_object_dispose(va, 8) = *((void *)v42 + 3);
      uint64_t v83 = *((void *)v42 + 4);
    }

    else
    {
      if (v6 != -16030)
      {
        if (v6 == -15980)
        {
          uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v8 = *a3;
          *((void *)v5 + 1) = *((void *)v7 + 1);
          *((void *)v5 + 2) = v8;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t v9 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 16) = v9;
          if (v9)
          {
            uint64_t v10 = *((void *)v9 + 1);
            *((void *)v5 + 7) = *(void *)v9;
            int v11 = *((_DWORD *)v9 + 4);
            *((_DWORD *)v5 + 21) = v10;
            *((_DWORD *)v5 + 22) = v11;
            uint64_t v13 = *((void *)v9 + 6);
            uint64_t v12 = *((void *)v9 + 7);
            *((void *)v5 + 21) = *((void *)v9 + 5);
            *((void *)v5 + 22) = v12;
            *((_WORD *)v5 + 106) = *((_WORD *)v9 + 40);
            *((void *)v5 + 14) = v9 + 24;
            *((void *)v5 + 25) = v13;
          }

          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[24], a2);
          *((void *)v5 + 13) = result;
          *((void *)v5 + 5) = *(void *)v7;
          v5[214] = 1;
        }

        return result;
      }

      uint64_t v42 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v84 = *a3;
      *((void *)v5 + 1) = *((void *)v42 + 1);
      *((void *)v5 + 2) = v84;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      id v85 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *((void *)v5 + 16) = v85;
      if (v85)
      {
        uint64_t v86 = *((void *)v85 + 1);
        *((void *)v5 + 7) = *(void *)v85;
        int v87 = *((_DWORD *)v85 + 4);
        *((_DWORD *)v5 + 21) = v86;
        *((_DWORD *)v5 + 22) = v87;
        uint64_t v89 = *((void *)v85 + 6);
        uint64_t v88 = *((void *)v85 + 7);
        *((void *)v5 + 21) = *((void *)v85 + 5);
        *((void *)v5 + 22) = v88;
        *((_WORD *)v5 + 106) = *((_WORD *)v85 + 40);
        *((void *)v5 + 14) = v85 + 24;
        *((void *)v5 + 25) = v89;
      }

      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v42[49], a2);
      *((void *)v5 + 13) = result;
      *((_DWORD *)v5 + 3_Block_object_dispose(va, 8) = *((void *)v42 + 4);
      uint64_t v83 = *((void *)v42 + 5);
    }

    *((_DWORD *)v5 + 39) = v83;
LABEL_109:
    *((void *)v5 + 5) = *(void *)v42;
    return result;
  }

  if (v6 != -16098)
  {
    if (v6 != -16096) {
      return result;
    }
    uint64_t v42 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v49 = *a3;
    *((void *)v5 + 1) = *((void *)v42 + 1);
    *((void *)v5 + 2) = v49;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    int v50 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    *((void *)v5 + 16) = v50;
    if (v50)
    {
      uint64_t v51 = *((void *)v50 + 1);
      *((void *)v5 + 7) = *(void *)v50;
      int v52 = *((_DWORD *)v50 + 4);
      *((_DWORD *)v5 + 21) = v51;
      *((_DWORD *)v5 + 22) = v52;
      uint64_t v54 = *((void *)v50 + 6);
      uint64_t v53 = *((void *)v50 + 7);
      *((void *)v5 + 21) = *((void *)v50 + 5);
      *((void *)v5 + 22) = v53;
      *((_WORD *)v5 + 106) = *((_WORD *)v50 + 40);
      *((void *)v5 + 14) = v50 + 24;
      *((void *)v5 + 25) = v54;
    }

    unsigned int v55 = v42[33];
LABEL_108:
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v55, a2);
    *((void *)v5 + 13) = result;
    goto LABEL_109;
  }

  char v114 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
  uint64_t v115 = *a3;
  *((void *)v5 + 1) = *((void *)v114 + 1);
  *((void *)v5 + 2) = v115;
  *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
  unint64_t v116 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
  *((void *)v5 + 16) = v116;
  if (v116)
  {
    uint64_t v117 = *((void *)v116 + 1);
    *((void *)v5 + 7) = *(void *)v116;
    int v118 = *((_DWORD *)v116 + 4);
    *((_DWORD *)v5 + 21) = v117;
    *((_DWORD *)v5 + 22) = v118;
    uint64_t v120 = *((void *)v116 + 6);
    uint64_t v119 = *((void *)v116 + 7);
    *((void *)v5 + 21) = *((void *)v116 + 5);
    *((void *)v5 + 22) = v119;
    *((_WORD *)v5 + 106) = *((_WORD *)v116 + 40);
    *((void *)v5 + 14) = v116 + 24;
    *((void *)v5 + 25) = v120;
  }

  uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v114[40], a2);
  *((void *)v5 + 13) = result;
  *((void *)v5 + 17) = *(void *)v114;
  *((_DWORD *)v5 + 3_Block_object_dispose(va, 8) = *((void *)v114 + 2);
  *((_DWORD *)v5 + 39) = *((void *)v114 + 3);
  *((_DWORD *)v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v114 + 4);
  return result;
}

char *GTMTLSMIndirectCommandBuffer_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  BOOL v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -10219)
  {
    if (v6 <= -10210)
    {
      if (v6 == -10218)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((void *)v5 + 15) = *((void *)result + 1);
      }

      else if (v6 == -10215)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 21) = *((void *)result + 1);
      }
    }

    else
    {
      switch(v6)
      {
        case -10209:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
          break;
        case -10202:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 7) = *((void *)result + 1);
          break;
        case -10166:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 16) = *((void *)result + 1);
          break;
      }
    }
  }

  else
  {
    switch(v6)
    {
      case -15925:
        uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[8], a2);
        *((void *)v5 + 9) = result;
        break;
      case -15924:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 22) = *((_DWORD *)result + 2);
        break;
      case -15923:
        *((void *)result + 3) = *a3;
        break;
      case -15922:
      case -15921:
        return result;
      case -15920:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v15 = *((void *)result + 2);
        if (v15 != 1) {
          *((_WORD *)v5 + 49) = v15;
        }
        break;
      case -15919:
        result[100] = 1;
        break;
      default:
        if (v6 == -15972 || v6 == -15969)
        {
          uint64_t v8 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v9 = *a3;
          uint64_t v10 = *(void *)v8;
          *((void *)v5 + 1) = *((void *)v8 + 1);
          *((void *)v5 + 2) = v9;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          *((void *)v5 + 5) = v10;
          *((void *)v5 + 13) = GTTraceFunc_argumentBytesWithMap(a3, v8[32], a2);
          uint64_t v11 = *((void *)v8 + 3);
          *((_DWORD *)v5 + 34) = *((void *)v8 + 2);
          *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = v11;
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 14) = result;
          if (result)
          {
            uint64_t v12 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v13 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v12;
            *((_DWORD *)v5 + 22) = v13;
            uint64_t v14 = *((void *)result + 6);
            *((void *)v5 + 15) = *((void *)result + 3);
            *((void *)v5 + 16) = v14;
          }
        }

        break;
    }
  }

  return result;
}

char *GTMTLSMHeap_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  BOOL v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -10212)
  {
    switch(v6)
    {
      case -10211:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
        break;
      case -10208:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 1_Block_object_dispose(va, 8) = *((void *)result + 1);
        break;
      case -10207:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 19) = *((void *)result + 1);
        break;
    }
  }

  else
  {
    switch(v6)
    {
      case -16120:
        uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v8 = *a3;
        uint64_t v9 = *(void *)v7;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v8;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v5 + 5) = v9;
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[16], a2);
        *((void *)v5 + 6) = result;
        break;
      case -16119:
        uint64_t v10 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v10[8], a2);
        *((void *)v5 + 7) = result;
        break;
      case -16118:
        *((void *)result + 3) = *a3;
        break;
      case -16115:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v11 = *((void *)result + 2);
        if (v11 != 1) {
          *((_WORD *)v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v11;
        }
        break;
      default:
        return result;
    }
  }

  return result;
}

char *GTMTLSMDepthStencilState_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a3 + 2);
  if (v5 == -16320)
  {
    *((void *)result + 3) = *a3;
  }

  else if (v5 == -16311)
  {
    uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v8 = *a3;
    uint64_t v9 = *(void *)v7;
    *((void *)v4 + 1) = *((void *)v7 + 1);
    *((void *)v4 + 2) = v8;
    *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
    *((void *)v4 + 5) = v9;
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[16], a2);
    *((void *)v4 + 6) = result;
  }

  return result;
}

char *GTMTLSMSamplerState_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  int v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -10227)
  {
    if (v6 == -10226)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
    }

    else if (v6 == -10163)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 9) = *((void *)result + 1);
    }
  }

  else if (v6 == -16309)
  {
    uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v8 = *a3;
    *((void *)v5 + 1) = *((void *)v7 + 1);
    *((void *)v5 + 2) = v8;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    uint64_t v9 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    *((void *)v5 + 7) = v9;
    if (v9)
    {
      *((void *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v9 + 2);
      *((_OWORD *)v5 + 4) = *(_OWORD *)v9;
    }

    *((void *)v5 + 5) = *(void *)v7;
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[16], a2);
    *((void *)v5 + 6) = result;
  }

  else if (v6 == -16241)
  {
    *((void *)result + 3) = *a3;
  }

  return result;
}

char *GTMTLSMEvent_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a3 + 2);
  switch(v5)
  {
    case -15879:
      *((void *)result + 3) = *a3;
      break;
    case -15880:
      uint64_t v9 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v9[8], a2);
      *((void *)v4 + 6) = result;
      break;
    case -15997:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v7 = *a3;
      uint64_t v8 = *(void *)result;
      *((void *)v4 + 1) = *((void *)result + 1);
      *((void *)v4 + 2) = v7;
      *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
      *((void *)v4 + 5) = v8;
      break;
  }

  return result;
}

char *GTMTLSMSharedEvent_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  int v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 <= -15974)
  {
    switch(v6)
    {
      case -15996:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v11 = *a3;
        uint64_t v12 = *(void *)result;
        *((void *)v5 + 1) = *((void *)result + 1);
        *((void *)v5 + 2) = v11;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v5 + 5) = v12;
        uint64_t v13 = *((void *)result + 2);
        *((_DWORD *)v5 + 1_Block_object_dispose(va, 8) = *((_DWORD *)result + 6);
        *((void *)v5 + 7) = v13;
        *((void *)v5 + _Block_object_dispose(va, 8) = 0LL;
        return result;
      case -15975:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v9 = *((void *)result + 1);
LABEL_17:
        *((void *)v5 + _Block_object_dispose(va, 8) = v9;
        return result;
      case -15974:
        uint64_t v10 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v10[8], a2);
        *((void *)v5 + 6) = result;
        break;
    }
  }

  else
  {
    if (v6 <= -15910)
    {
      if (v6 == -15973)
      {
        *((void *)result + 3) = *a3;
        return result;
      }

      if (v6 != -15912) {
        return result;
      }
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v7 = *a3;
      uint64_t v8 = *(void *)result;
      *((void *)v5 + 1) = *((void *)result + 1);
      *((void *)v5 + 2) = v7;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      *((void *)v5 + 5) = v8;
      *((_DWORD *)v5 + 1_Block_object_dispose(va, 8) = *((_DWORD *)result + 6);
      uint64_t v9 = *((void *)result + 2);
      goto LABEL_17;
    }

    if (v6 == -15909)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v14 = *a3;
      uint64_t v15 = *(void *)result;
      *((void *)v5 + 1) = *((void *)result + 1);
      *((void *)v5 + 2) = v14;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      *((void *)v5 + 5) = v15;
      *((_DWORD *)v5 + 1_Block_object_dispose(va, 8) = *((_DWORD *)result + 8);
      *(_OWORD *)(v5 + 56) = *((_OWORD *)result + 1);
    }

    else if (v6 == -15907)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 7) = *((void *)result + 1);
    }
  }

  return result;
}

char *GTMTLSMLateEvalEvent_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  int v5 = result;
  switch(*((_DWORD *)a3 + 2))
  {
    case 0xFFFFC378:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v6 = *a3;
      uint64_t v7 = *(void *)result;
      *((void *)v5 + 1) = *((void *)result + 1);
      *((void *)v5 + 2) = v6;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      *((void *)v5 + 5) = v7;
      *((void *)v5 + _Block_object_dispose(va, 8) = 0LL;
      break;
    case 0xFFFFC37D:
      uint64_t v8 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v8[8], a2);
      *((void *)v5 + 6) = result;
      break;
    case 0xFFFFC37E:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
      break;
    case 0xFFFFC37F:
      *((void *)result + 3) = *a3;
      break;
    default:
      return result;
  }

  return result;
}

char *GTMTLSMFence_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  int v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  switch(v6)
  {
    case -16136:
      uint64_t v9 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v9[8], a2);
      *((void *)v5 + 6) = result;
      break;
    case -16127:
      *((void *)result + 3) = *a3;
      break;
    case -16128:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v7 = *a3;
      uint64_t v8 = *(void *)result;
      *((void *)v5 + 1) = *((void *)result + 1);
      *((void *)v5 + 2) = v7;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      *((void *)v5 + 5) = v8;
      break;
  }

  return result;
}

char *GTMTLSMCounterSampleBuffer_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  if (*((_DWORD *)a3 + 2) == -15848)
  {
    int v5 = result;
    int v6 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v7 = *a3;
    uint64_t v8 = *(void *)v6;
    *((void *)v5 + 1) = *((void *)v6 + 1);
    *((void *)v5 + 2) = v7;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    *((void *)v5 + 5) = v8;
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v6[24], a2);
    *((void *)v5 + 6) = result;
  }

  return result;
}

char *GTMTLSMRenderPipelineState_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  int v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -15462)
  {
    if (v6 > -10221)
    {
      if (v6 <= -10185)
      {
        if (v6 == -10220)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 12) = *((void *)result + 1);
        }

        else if (v6 == -10192)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((_DWORD *)v5 + 102) = *((_DWORD *)result + 2);
        }
      }

      else
      {
        switch(v6)
        {
          case -10184:
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            *((_DWORD *)v5 + 103) = *((void *)result + 1);
            break;
          case -10172:
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            *((void *)v5 + 5mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)result + 1);
            break;
          case -10165:
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            *((void *)v5 + 14) = *((void *)result + 1);
            break;
        }
      }
    }

    else
    {
      switch(v6)
      {
        case -15406:
        case -15405:
          uint64_t v13 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v14 = *a3;
          uint64_t v15 = *(void *)v13;
          *((void *)v5 + 1) = *((void *)v13 + 1);
          *((void *)v5 + 2) = v14;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          *((void *)v5 + 5) = v15;
          uint64_t v16 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 7) = v16;
          if (v16)
          {
            int v17 = v16;
            memcpy(v5 + 120, v16 + 216, 0x118uLL);
            *((_OWORD *)v5 + 6) = *(_OWORD *)v17;
            *((_DWORD *)v5 + 102) = *((_DWORD *)v17 + 48);
            *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v17 + 98);
            *((void *)v5 + 14) = *((void *)v17 + 2);
          }

          unsigned int v18 = v13[24];
          goto LABEL_31;
        case -15404:
        case -15403:
          uint64_t v30 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v31 = *a3;
          uint64_t v32 = *(void *)v30;
          *((void *)v5 + 1) = *((void *)v30 + 1);
          *((void *)v5 + 2) = v31;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          *((void *)v5 + 5) = v32;
          int v33 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 7) = v33;
          if (v33)
          {
            uint64_t v34 = v33;
            memcpy(v5 + 120, v33 + 216, 0x118uLL);
            *((_OWORD *)v5 + 6) = *(_OWORD *)v34;
            *((_DWORD *)v5 + 102) = *((_DWORD *)v34 + 48);
            *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v34 + 98);
            *((void *)v5 + 14) = *((void *)v34 + 2);
          }

          unsigned int v18 = v30[32];
LABEL_31:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v18, a2);
          *((void *)v5 + 9) = result;
          break;
        default:
          if (v6 == -15461)
          {
            uint64_t v40 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v41 = *a3;
            uint64_t v42 = *(void *)v40;
            *((void *)v5 + 1) = *((void *)v40 + 1);
            *((void *)v5 + 2) = v41;
            *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
            *((void *)v5 + 5) = v42;
            uint64_t v43 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *((void *)v5 + 7) = v43;
            if (v43)
            {
              unint64_t v44 = v43;
              memcpy(v5 + 120, v43 + 216, 0x118uLL);
              *((_OWORD *)v5 + 6) = *(_OWORD *)v44;
              *((_DWORD *)v5 + 102) = *((_DWORD *)v44 + 48);
              *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v44 + 98);
              *((void *)v5 + 14) = *((void *)v44 + 2);
            }

            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v40[24], a2);
            *((void *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
          }

          break;
      }
    }
  }

  else if (v6 > -16092)
  {
    switch(v6)
    {
      case -16091:
      case -16089:
        uint64_t v19 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v20 = *a3;
        uint64_t v21 = *(void *)v19;
        *((void *)v5 + 1) = *((void *)v19 + 1);
        *((void *)v5 + 2) = v20;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v5 + 5) = v21;
        uint64_t v22 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 7) = v22;
        if (v22)
        {
          uint64_t v23 = v22;
          memcpy(v5 + 120, v22 + 216, 0x118uLL);
          *((_OWORD *)v5 + 6) = *(_OWORD *)v23;
          *((_DWORD *)v5 + 102) = *((_DWORD *)v23 + 48);
          *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v23 + 98);
          *((void *)v5 + 14) = *((void *)v23 + 2);
        }

        unsigned int v24 = v19[24];
        goto LABEL_35;
      case -16090:
      case -16088:
        uint64_t v35 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v36 = *a3;
        uint64_t v37 = *(void *)v35;
        *((void *)v5 + 1) = *((void *)v35 + 1);
        *((void *)v5 + 2) = v36;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v5 + 5) = v37;
        uint64_t v38 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 7) = v38;
        if (v38)
        {
          int v39 = v38;
          memcpy(v5 + 120, v38 + 216, 0x118uLL);
          *((_OWORD *)v5 + 6) = *(_OWORD *)v39;
          *((_DWORD *)v5 + 102) = *((_DWORD *)v39 + 48);
          *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v39 + 98);
          *((void *)v5 + 14) = *((void *)v39 + 2);
        }

        unsigned int v24 = v35[32];
LABEL_35:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v24, a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = result;
        break;
      default:
        if (v6 == -15738)
        {
          uint64_t v45 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v46 = *a3;
          uint64_t v47 = *(void *)v45;
          *((void *)v5 + 1) = *((void *)v45 + 1);
          *((void *)v5 + 2) = v46;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          *((void *)v5 + 5) = v47;
          uint64_t v48 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 7) = v48;
          if (v48)
          {
            uint64_t v49 = v48;
            memcpy(v5 + 120, v48 + 216, 0x118uLL);
            *((_OWORD *)v5 + 6) = *(_OWORD *)v49;
            *((_DWORD *)v5 + 102) = *((_DWORD *)v49 + 48);
            *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v49 + 98);
            *((void *)v5 + 14) = *((void *)v49 + 2);
          }

          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v45[32], a2);
          *((void *)v5 + 11) = result;
        }

        break;
    }
  }

  else
  {
    switch(v6)
    {
      case -16303:
      case -16301:
        uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v8 = *a3;
        uint64_t v9 = *(void *)v7;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v8;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v5 + 5) = v9;
        uint64_t v10 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 7) = v10;
        if (v10)
        {
          uint64_t v11 = v10;
          memcpy(v5 + 120, v10 + 216, 0x118uLL);
          *((_OWORD *)v5 + 6) = *(_OWORD *)v11;
          *((_DWORD *)v5 + 102) = *((_DWORD *)v11 + 48);
          *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v11 + 98);
          *((void *)v5 + 14) = *((void *)v11 + 2);
        }

        unsigned int v12 = v7[24];
        goto LABEL_27;
      case -16302:
      case -16300:
        int v25 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v26 = *a3;
        uint64_t v27 = *(void *)v25;
        *((void *)v5 + 1) = *((void *)v25 + 1);
        *((void *)v5 + 2) = v26;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v5 + 5) = v27;
        uint64_t v28 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 7) = v28;
        if (v28)
        {
          unsigned int v29 = v28;
          memcpy(v5 + 120, v28 + 216, 0x118uLL);
          *((_OWORD *)v5 + 6) = *(_OWORD *)v29;
          *((_DWORD *)v5 + 102) = *((_DWORD *)v29 + 48);
          *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v29 + 98);
          *((void *)v5 + 14) = *((void *)v29 + 2);
        }

        unsigned int v12 = v25[32];
LABEL_27:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v12, a2);
        *((void *)v5 + 6) = result;
        break;
      default:
        if (v6 == -16242) {
          *((void *)result + 3) = *a3;
        }
        break;
    }
  }

  return result;
}

char *GTMTLSMComputePipelineState_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  int v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -16102)
  {
    if (v6 > -10215)
    {
      if (v6 > -10172)
      {
        if (v6 == -10171)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 22) = *((void *)result + 1);
        }

        else if (v6 == -10162)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 14) = *((void *)result + 1);
        }
      }

      else if (v6 == -10214)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((void *)v5 + 12) = *((void *)result + 1);
      }

      else if (v6 == -10191)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)result + 2);
      }
    }

    else if (v6 > -15741)
    {
      if (v6 == -15740)
      {
        uint64_t v42 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v43 = *a3;
        uint64_t v44 = *(void *)v42;
        *((void *)v5 + 1) = *((void *)v42 + 1);
        *((void *)v5 + 2) = v43;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v5 + 5) = v44;
        uint64_t v45 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = v45;
        if (v45)
        {
          __int128 v46 = *(_OWORD *)(v45 + 104);
          __int128 v47 = *(_OWORD *)(v45 + 120);
          __int128 v48 = *(_OWORD *)(v45 + 136);
          *((void *)v5 + 21) = *((void *)v45 + 19);
          *(_OWORD *)(v5 + 152) = v48;
          *(_OWORD *)(v5 + 136) = v47;
          *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v46;
          *((_OWORD *)v5 + 6) = *(_OWORD *)v45;
          *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)v45 + 22);
          *((void *)v5 + 14) = *((void *)v45 + 2);
        }

        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v42[32], a2);
        *((void *)v5 + 11) = result;
      }

      else if (v6 == -15541)
      {
        uint64_t v21 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v22 = *a3;
        uint64_t v23 = *(void *)v21;
        *((void *)v5 + 1) = *((void *)v21 + 1);
        *((void *)v5 + 2) = v22;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v5 + 5) = v23;
        unsigned int v24 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = v24;
        if (v24)
        {
          __int128 v25 = *(_OWORD *)(v24 + 104);
          __int128 v26 = *(_OWORD *)(v24 + 120);
          __int128 v27 = *(_OWORD *)(v24 + 136);
          *((void *)v5 + 21) = *((void *)v24 + 19);
          *(_OWORD *)(v5 + 152) = v27;
          *(_OWORD *)(v5 + 136) = v26;
          *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v25;
          *((_OWORD *)v5 + 6) = *(_OWORD *)v24;
          *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)v24 + 22);
          *((void *)v5 + 14) = *((void *)v24 + 2);
        }

        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v21[24], a2);
        *((void *)v5 + 23) = result;
      }
    }

    else if (v6 == -16101)
    {
      uint64_t v35 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v36 = *a3;
      uint64_t v37 = *(void *)v35;
      *((void *)v5 + 1) = *((void *)v35 + 1);
      *((void *)v5 + 2) = v36;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      *((void *)v5 + 5) = v37;
      uint64_t v38 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *((void *)v5 + _Block_object_dispose(va, 8) = v38;
      if (v38)
      {
        __int128 v39 = *(_OWORD *)(v38 + 104);
        __int128 v40 = *(_OWORD *)(v38 + 120);
        __int128 v41 = *(_OWORD *)(v38 + 136);
        *((void *)v5 + 21) = *((void *)v38 + 19);
        *(_OWORD *)(v5 + 152) = v41;
        *(_OWORD *)(v5 + 136) = v40;
        *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v39;
        *((_OWORD *)v5 + 6) = *(_OWORD *)v38;
        *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)v38 + 22);
        *((void *)v5 + 14) = *((void *)v38 + 2);
      }

      *((void *)v5 + 9) = GTTraceFunc_argumentBytesWithMap(a3, v35[24], a2);
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v35[25], a2);
      *((void *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
    }

    else if (v6 == -15989)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 13) = *((void *)result + 1);
    }
  }

  else
  {
    switch(v6)
    {
      case -16299:
      case -16298:
      case -16297:
      case -16296:
        uint64_t v15 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v16 = *a3;
        uint64_t v17 = *(void *)v15;
        *((void *)v5 + 1) = *((void *)v15 + 1);
        *((void *)v5 + 2) = v16;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v5 + 5) = v17;
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = result;
        if (result)
        {
          __int128 v18 = *(_OWORD *)(result + 104);
          __int128 v19 = *(_OWORD *)(result + 120);
          __int128 v20 = *(_OWORD *)(result + 136);
          *((void *)v5 + 21) = *((void *)result + 19);
          *(_OWORD *)(v5 + 152) = v20;
          *(_OWORD *)(v5 + 136) = v19;
          *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v18;
          *((_OWORD *)v5 + 6) = *(_OWORD *)result;
          *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)result + 22);
          *((void *)v5 + 14) = *((void *)result + 2);
        }

        *((void *)v5 + 6) = *((void *)v15 + 2);
        break;
      default:
        switch(v6)
        {
          case -16200:
          case -16198:
            uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v8 = *a3;
            uint64_t v9 = *(void *)v7;
            *((void *)v5 + 1) = *((void *)v7 + 1);
            *((void *)v5 + 2) = v8;
            *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
            *((void *)v5 + 5) = v9;
            uint64_t v10 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *((void *)v5 + _Block_object_dispose(va, 8) = v10;
            if (v10)
            {
              __int128 v11 = *(_OWORD *)(v10 + 104);
              __int128 v12 = *(_OWORD *)(v10 + 120);
              __int128 v13 = *(_OWORD *)(v10 + 136);
              *((void *)v5 + 21) = *((void *)v10 + 19);
              *(_OWORD *)(v5 + 152) = v13;
              *(_OWORD *)(v5 + 136) = v12;
              *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v11;
              *((_OWORD *)v5 + 6) = *(_OWORD *)v10;
              *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)v10 + 22);
              *((void *)v5 + 14) = *((void *)v10 + 2);
            }

            unsigned int v14 = v7[24];
            goto LABEL_31;
          case -16199:
          case -16197:
            uint64_t v28 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v29 = *a3;
            uint64_t v30 = *(void *)v28;
            *((void *)v5 + 1) = *((void *)v28 + 1);
            *((void *)v5 + 2) = v29;
            *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
            *((void *)v5 + 5) = v30;
            uint64_t v31 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *((void *)v5 + _Block_object_dispose(va, 8) = v31;
            if (v31)
            {
              __int128 v32 = *(_OWORD *)(v31 + 104);
              __int128 v33 = *(_OWORD *)(v31 + 120);
              __int128 v34 = *(_OWORD *)(v31 + 136);
              *((void *)v5 + 21) = *((void *)v31 + 19);
              *(_OWORD *)(v5 + 152) = v34;
              *(_OWORD *)(v5 + 136) = v33;
              *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v32;
              *((_OWORD *)v5 + 6) = *(_OWORD *)v31;
              *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)v31 + 22);
              *((void *)v5 + 14) = *((void *)v31 + 2);
            }

            unsigned int v14 = v28[32];
LABEL_31:
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v14, a2);
            *((void *)v5 + 6) = *((void *)result + 106);
            *((void *)v5 + 7) = result;
            break;
          default:
            if (v6 == -16321) {
              *((void *)result + 3) = *a3;
            }
            break;
        }

        break;
    }
  }

  return result;
}

char *GTMTLSMMotionEstimationPipelineState_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a3 + 2);
  if (v5 == -15893)
  {
    *((void *)result + 3) = *a3;
  }

  else if (v5 == -15891)
  {
    uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v8 = *a3;
    uint64_t v9 = *(void *)v7;
    *((void *)v4 + 1) = *((void *)v7 + 1);
    *((void *)v4 + 2) = v8;
    *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
    *((void *)v4 + 5) = v9;
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[16], a2);
    *((void *)v4 + 6) = result;
  }

  return result;
}

uint64_t GTMTLSMFunction_processTraceFuncWithMap(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -15731)
  {
    if (v6 > -15551)
    {
      switch(v6)
      {
        case -15430:
        case -15428:
          goto LABEL_20;
        case -15429:
        case -15427:
          goto LABEL_22;
        default:
          if (v6 == -15550)
          {
            uint64_t v57 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v58 = *a3;
            uint64_t v59 = *(void *)v57;
            *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v57 + 1);
            *(void *)(v5 + 16) = v58;
            *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
            *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v59;
            int v60 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v60;
            if (v60) {
              uint64_t v61 = *(void *)v60;
            }
            else {
              uint64_t v61 = 0LL;
            }
            *(void *)(v5 + 64) = v61;
            unsigned int v62 = v57[24];
            goto LABEL_83;
          }

          if (v6 != -10157) {
            return result;
          }
          unsigned int v41 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2)[16];
          break;
      }
    }

    else
    {
      if (v6 > -15609)
      {
        if (v6 != -15608)
        {
          if (v6 == -15551)
          {
            uint64_t v21 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v22 = *a3;
            uint64_t v23 = *(void *)v21;
            *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v21 + 1);
            *(void *)(v5 + 16) = v22;
            *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
            *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v23;
            unsigned int v24 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v24;
            if (v24) {
              uint64_t v25 = *(void *)v24;
            }
            else {
              uint64_t v25 = 0LL;
            }
            *(void *)(v5 + 64) = v25;
            unsigned int v62 = v21[32];
LABEL_83:
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v62, a2);
            *(void *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
          }

          return result;
        }
      }

      else
      {
        if (v6 == -15730)
        {
LABEL_22:
          __int128 v12 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v17 = *a3;
          uint64_t v18 = *(void *)v12;
          *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v12 + 1);
          *(void *)(v5 + 16) = v17;
          *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
          *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v18;
          __int128 v19 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v19;
          if (v19) {
            uint64_t v20 = *(void *)v19;
          }
          else {
            uint64_t v20 = 0LL;
          }
          *(void *)(v5 + 64) = v20;
          *(_BYTE *)(v5 + 132) = 1;
          unsigned int v42 = v12[24];
          if (g_loadURLAsMemHeader) {
            uint64_t v43 = GTTraceFunc_argumentBlobWithMap(a3, v42, a2);
          }
          else {
            uint64_t v43 = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v42, a2);
          }
          *(void *)(v5 + 8_Block_object_dispose(va, 8) = v43;
          unsigned int v44 = v12[25];
          if (g_loadURLAsMemHeader) {
            uint64_t result = GTTraceFunc_argumentBlobWithMap(a3, v44, a2);
          }
          else {
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v44, a2);
          }
          *(void *)(v5 + 96) = result;
          goto LABEL_60;
        }

        if (v6 != -15609) {
          return result;
        }
      }

      __int128 v26 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v27 = *a3;
      uint64_t v28 = *(void *)v26;
      *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v26 + 1);
      *(void *)(v5 + 16) = v27;
      *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v28;
      uint64_t v29 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v29;
      if (v29) {
        uint64_t v30 = *(void *)v29;
      }
      else {
        uint64_t v30 = 0LL;
      }
      *(void *)(v5 + 64) = v30;
      unsigned int v41 = v26[24];
    }

    uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v41, a2);
    *(void *)(v5 + 112) = result;
    return result;
  }

  if (v6 <= -16083)
  {
    if (v6 <= -16124)
    {
      if (v6 == -16293)
      {
        *(void *)(result + 24) = *a3;
      }

      else if (v6 == -16290)
      {
        uint64_t v31 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v32 = *a3;
        uint64_t v33 = *(void *)v31;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v31 + 1);
        *(void *)(v5 + 16) = v32;
        *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v33;
        __int128 v34 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v34;
        if (v34) {
          uint64_t v35 = *(void *)v34;
        }
        else {
          uint64_t v35 = 0LL;
        }
        *(void *)(v5 + 64) = v35;
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v31[16], a2);
        *(void *)(v5 + 56) = result;
      }
    }

    else if (v6 == -16123)
    {
      uint64_t v45 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v45[8], a2);
      *(void *)(v5 + 64) = result;
    }

    else if (v6 == -16107 || v6 == -16106)
    {
      uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v8 = *a3;
      uint64_t v9 = *(void *)v7;
      *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v7 + 1);
      *(void *)(v5 + 16) = v8;
      *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v9;
      uint64_t v10 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v10;
      if (v10) {
        uint64_t v11 = *(void *)v10;
      }
      else {
        uint64_t v11 = 0LL;
      }
      *(void *)(v5 + 64) = v11;
      *(void *)(v5 + 56) = GTTraceFunc_argumentBytesWithMap(a3, v7[24], a2);
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v7[25], a2);
      *(void *)(v5 + 72) = result;
    }

    return result;
  }

  if (v6 > -16039)
  {
    if (v6 == -16038)
    {
      __int128 v46 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v47 = *a3;
      uint64_t v48 = *(void *)v46;
      *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v46 + 1);
      *(void *)(v5 + 16) = v47;
      *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v48;
      uint64_t v49 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v49;
      if (v49) {
        uint64_t v50 = *(void *)v49;
      }
      else {
        uint64_t v50 = 0LL;
      }
      *(void *)(v5 + 64) = v50;
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v46[16], a2);
      *(void *)(v5 + 56) = result;
      *(_BYTE *)(v5 + 131) = 1;
      return result;
    }

    if (v6 == -15830)
    {
      uint64_t v51 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v52 = *a3;
      uint64_t v53 = *(void *)v51;
      *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v51 + 1);
      *(void *)(v5 + 16) = v52;
      *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v53;
      uint64_t v54 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v54;
      if (v54) {
        uint64_t v55 = *(void *)v54;
      }
      else {
        uint64_t v55 = 0LL;
      }
      *(void *)(v5 + 64) = v55;
      *(void *)(v5 + 56) = GTTraceFunc_argumentBytesWithMap(a3, v51[18], a2);
      *(_BYTE *)(v5 + 132) = 1;
      unsigned int v63 = v51[16];
      if (g_loadURLAsMemHeader) {
        uint64_t result = GTTraceFunc_argumentBlobWithMap(a3, v63, a2);
      }
      else {
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v63, a2);
      }
      *(void *)(v5 + 104) = result;
      *(_BYTE *)(v5 + 13mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v51[17];
      return result;
    }

    if (v6 != -15731) {
      return result;
    }
LABEL_20:
    __int128 v12 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v13 = *a3;
    uint64_t v14 = *(void *)v12;
    *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v12 + 1);
    *(void *)(v5 + 16) = v13;
    *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
    *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v14;
    uint64_t v15 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v15;
    if (v15) {
      uint64_t v16 = *(void *)v15;
    }
    else {
      uint64_t v16 = 0LL;
    }
    *(void *)(v5 + 64) = v16;
    *(_BYTE *)(v5 + 132) = 1;
    unsigned int v56 = v12[24];
    if (g_loadURLAsMemHeader) {
      uint64_t result = GTTraceFunc_argumentBlobWithMap(a3, v56, a2);
    }
    else {
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v56, a2);
    }
    *(void *)(v5 + 8_Block_object_dispose(va, 8) = result;
LABEL_60:
    *(_WORD *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v12 + 2);
    return result;
  }

  if (v6 == -16082 || v6 == -16081)
  {
    uint64_t v36 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v37 = *a3;
    uint64_t v38 = *(void *)v36;
    *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v36 + 1);
    *(void *)(v5 + 16) = v37;
    *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
    *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v38;
    __int128 v39 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v39;
    if (v39) {
      uint64_t v40 = *(void *)v39;
    }
    else {
      uint64_t v40 = 0LL;
    }
    *(void *)(v5 + 64) = v40;
    *(void *)(v5 + 56) = GTTraceFunc_argumentBytesWithMap(a3, v36[32], a2);
    uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v36[33], a2);
    *(void *)(v5 + 72) = result;
    *(void *)(v5 + 4_Block_object_dispose(va, 8) = *((void *)v36 + 2);
  }

  return result;
}

char *GTMTLSMIndirectComputeCommand_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a3 + 2);
  if (v5 == -15935)
  {
    *((void *)result + 3) = *a3;
  }

  else if (v5 == -15921)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v6 = *a3;
    uint64_t v7 = *(void *)result;
    *((void *)v4 + 1) = *((void *)result + 1);
    *((void *)v4 + 2) = v6;
    *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
    uint64_t v8 = *((void *)result + 2);
    *((void *)v4 + 5) = v7;
    *((void *)v4 + 6) = v8;
  }

  return result;
}

char *GTMTLSMIndirectRenderCommand_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a3 + 2);
  if (v5 == -15957)
  {
    *((void *)result + 3) = *a3;
  }

  else if (v5 == -15922)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v6 = *a3;
    uint64_t v7 = *(void *)result;
    *((void *)v4 + 1) = *((void *)result + 1);
    *((void *)v4 + 2) = v6;
    *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
    uint64_t v8 = *((void *)result + 2);
    *((void *)v4 + 5) = v7;
    *((void *)v4 + 6) = v8;
  }

  return result;
}

uint64_t GTMTLSMLibrary_processTraceFuncWithMap(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 <= -16030)
  {
    if (v6 > -16293)
    {
      if (v6 <= -16096)
      {
        if (v6 == -16292)
        {
          uint64_t v57 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v57[8], a2);
          *(void *)(v5 + 112) = result;
        }

        else if (v6 == -16291)
        {
          *(void *)(result + 24) = *a3;
        }
      }

      else
      {
        switch(v6)
        {
          case -16095:
            uint64_t v50 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v51 = *a3;
            uint64_t v52 = *(void *)v50;
            *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v50 + 1);
            *(void *)(v5 + 16) = v51;
            *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
            *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v52;
            uint64_t v53 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *(void *)(v5 + 64) = v53;
            if (v53)
            {
              *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v53 + 1);
              *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v53[16];
            }

            *(_BYTE *)(v5 + 161) = 0;
            unsigned int v34 = v50[24];
LABEL_63:
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v34, a2);
            *(void *)(v5 + 96) = result;
            uint64_t v54 = *(void **)(v5 + 64);
            if (v54) {
              uint64_t v54 = (void *)*v54;
            }
            *(void *)(v5 + memset(v68, 0, 144) = v54;
            break;
          case -16083:
            uint64_t v55 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v55[8], a2);
            *(void *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
            break;
          case -16039:
LABEL_23:
            uint64_t v14 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v15 = *a3;
            uint64_t v16 = *(void *)v14;
            *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v14 + 1);
            *(void *)(v5 + 16) = v15;
            *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
            *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v16;
            uint64_t v17 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *(void *)(v5 + 64) = v17;
            if (v17)
            {
              *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v17 + 1);
              *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v17[16];
            }

            *(_BYTE *)(v5 + 161) = 1;
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v14[24], a2);
            *(void *)(v5 + 96) = result;
            uint64_t v18 = *(void **)(v5 + 64);
            if (v18) {
              uint64_t v18 = (void *)*v18;
            }
            *(void *)(v5 + 136) = v18;
            break;
        }
      }
    }

    else
    {
      switch(v6)
      {
        case -16308:
          uint64_t v30 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v31 = *a3;
          uint64_t v32 = *(void *)v30;
          *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v30 + 1);
          *(void *)(v5 + 16) = v31;
          *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
          *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v32;
          uint64_t v33 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *(void *)(v5 + 64) = v33;
          if (v33)
          {
            *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v33 + 1);
            *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v33[16];
          }

          *(_BYTE *)(v5 + 161) = 0;
          unsigned int v34 = v30[16];
          goto LABEL_63;
        case -16307:
          goto LABEL_23;
        case -16306:
          uint64_t v35 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v36 = *a3;
          uint64_t v37 = *(void *)v35;
          *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v35 + 1);
          *(void *)(v5 + 16) = v36;
          *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
          *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v37;
          uint64_t v38 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *(void *)(v5 + 64) = v38;
          if (v38)
          {
            *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v38 + 1);
            *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v38[16];
          }

          *(_BYTE *)(v5 + 161) = 3;
          unsigned int v39 = v35[24];
          if (g_loadURLAsMemHeader) {
            uint64_t result = GTTraceFunc_argumentBlobWithMap(a3, v39, a2);
          }
          else {
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v39, a2);
          }
          *(void *)(v5 + 96) = result;
          break;
        case -16305:
        case -16304:
          uint64_t v8 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v9 = *a3;
          uint64_t v10 = *(void *)v8;
          *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v8 + 1);
          *(void *)(v5 + 16) = v9;
          *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
          *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v10;
          uint64_t v11 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *(void *)(v5 + 64) = v11;
          if (v11)
          {
            *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v11 + 1);
            *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v11[16];
          }

          *(_BYTE *)(v5 + 161) = 2;
          unsigned int v12 = v8[24];
          if (g_loadURLAsMemHeader) {
            uint64_t v13 = GTTraceFunc_argumentBlobWithMap(a3, v12, a2);
          }
          else {
            uint64_t v13 = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v12, a2);
          }
          *(void *)(v5 + 96) = v13;
          uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v8[25], a2);
          *(void *)(v5 + 104) = result;
          break;
        default:
          return result;
      }
    }
  }

  else
  {
    if (v6 <= -15435)
    {
      if (v6 <= -15848)
      {
        if (v6 != -16029 && v6 != -16018) {
          return result;
        }
        uint64_t v23 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v24 = *a3;
        uint64_t v25 = *(void *)v23;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v23 + 1);
        *(void *)(v5 + 16) = v24;
        *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v25;
        __int128 v26 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *(void *)(v5 + 64) = v26;
        if (v26)
        {
          *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v26 + 1);
          *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v26[16];
        }

        *(_BYTE *)(v5 + 161) = 4;
        uint64_t v27 = GTTraceFunc_argumentBytesWithMap(a3, v23[24], a2);
        if (v27)
        {
          uint64_t v28 = *(void *)v27;
          *(void *)(v5 + 4_Block_object_dispose(va, 8) = v27 + 8;
          *(_DWORD *)(v5 + 152) = v28;
        }

        unsigned int v29 = v23[25];
      }

      else
      {
        if (v6 != -15847)
        {
          if (v6 == -15693)
          {
            unsigned int v44 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v45 = *a3;
            uint64_t v46 = *(void *)v44;
            *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v44 + 1);
            *(void *)(v5 + 16) = v45;
            *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
            *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v46;
            uint64_t v47 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *(void *)(v5 + 64) = v47;
            if (v47)
            {
              *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v47 + 1);
              *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v47[16];
            }

            *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = GTTraceFunc_argumentBytesWithMap(a3, v44[24], a2);
            uint64_t v48 = GTTraceFunc_argumentBytesWithMap(a3, v44[25], a2);
            uint64_t v49 = *(void *)v48;
            uint64_t result = (uint64_t)(v48 + 8);
            *(void *)(v5 + 8_Block_object_dispose(va, 8) = result;
            *(_DWORD *)(v5 + 156) = v49;
            goto LABEL_35;
          }

          int v7 = -15435;
          goto LABEL_17;
        }

        uint64_t v40 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v41 = *a3;
        uint64_t v42 = *(void *)v40;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v40 + 1);
        *(void *)(v5 + 16) = v41;
        *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v42;
        uint64_t v43 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *(void *)(v5 + 64) = v43;
        if (v43)
        {
          *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v43 + 1);
          *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v43[16];
        }

        *(_BYTE *)(v5 + 161) = 5;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = GTTraceFunc_argumentBytesWithMap(a3, v40[32], a2);
        *(_DWORD *)(v5 + 152) = *((void *)v40 + 2);
        unsigned int v29 = v40[33];
      }

      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v29, a2);
      *(void *)(v5 + 56) = result;
      return result;
    }

    if (v6 <= -15420)
    {
      if (v6 != -15434 && v6 != -15421)
      {
        int v7 = -15420;
LABEL_17:
        if (v6 != v7) {
          return result;
        }
      }

LABEL_32:
      __int128 v19 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v20 = *a3;
      uint64_t v21 = *(void *)v19;
      *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v19 + 1);
      *(void *)(v5 + 16) = v20;
      *(_DWORD *)(v5 + 4) = *((_DWORD *)a3 + 2);
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v21;
      uint64_t v22 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *(void *)(v5 + 64) = v22;
      if (v22)
      {
        *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v22 + 1);
        *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v22[16];
      }

      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v19[24], a2);
      *(void *)(v5 + 72) = result;
      *(void *)(v5 + 8_Block_object_dispose(va, 8) = *(void *)(result + 8);
      *(_DWORD *)(v5 + 156) = *(unsigned __int16 *)(result + 18);
LABEL_35:
      *(_BYTE *)(v5 + 161) = 6;
      return result;
    }

    switch(v6)
    {
      case -15419:
        goto LABEL_32;
      case -10188:
        unsigned int v56 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v56[8], a2);
        *(void *)(v5 + 12_Block_object_dispose(va, 8) = result;
        break;
      case -10183:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 8);
        break;
    }
  }

  return result;
}

char *GTMTLSMDynamicLibrary_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -15676)
  {
    if (v6 == -15675)
    {
      *((void *)result + 3) = *a3;
    }

    else if (v6 == -15613)
    {
      uint64_t v8 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v9 = *a3;
      uint64_t v10 = *(void *)v8;
      *((void *)v5 + 1) = *((void *)v8 + 1);
      *((void *)v5 + 2) = v9;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      *((void *)v5 + 5) = v10;
      uint64_t v11 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      if (v11)
      {
        *((void *)v5 + 9) = *(void *)v11;
        *(_OWORD *)(v5 + 8_Block_object_dispose(va, 8) = *(_OWORD *)(v11 + 8);
        *((_WORD *)v5 + 52) = *((_WORD *)v11 + 12);
      }

      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v8[24], a2);
      *((void *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
    }
  }

  else if (v6 == -15695)
  {
    unsigned int v12 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v13 = *a3;
    uint64_t v14 = *(void *)v12;
    *((void *)v5 + 1) = *((void *)v12 + 1);
    *((void *)v5 + 2) = v13;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    *((void *)v5 + 5) = v14;
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    if (result)
    {
      *((void *)v5 + 9) = *(void *)result;
      *(_OWORD *)(v5 + 8_Block_object_dispose(va, 8) = *(_OWORD *)(result + 8);
      *((_WORD *)v5 + 52) = *((_WORD *)result + 12);
    }

    *((void *)v5 + 6) = *((void *)v12 + 2);
  }

  else if (v6 == -15676)
  {
    int v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[8], a2);
    *((void *)v5 + _Block_object_dispose(va, 8) = result;
  }

  return result;
}

char *GTMTLSMPipelineLibrary_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -15745)
  {
    if (v6 == -15744)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      v5[82] = *((_DWORD *)result + 2);
    }

    else if (v6 == -15743)
    {
      uint64_t v10 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v10[8], a2);
      *((void *)v5 + 7) = result;
    }
  }

  else if (v6 == -16291)
  {
    *((void *)result + 3) = *a3;
  }

  else if (v6 == -16075)
  {
    int v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v8 = *a3;
    uint64_t v9 = *(void *)v7;
    *((void *)v5 + 1) = *((void *)v7 + 1);
    *((void *)v5 + 2) = v8;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    *((void *)v5 + 5) = v9;
    *((void *)v5 + 6) = GTTraceFunc_argumentBytesWithMap(a3, v7[24], a2);
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    if (result)
    {
      *((_WORD *)v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((_WORD *)result + 12);
      *((_OWORD *)v5 + 4) = *(_OWORD *)(result + 8);
    }
  }

  return result;
}

char *GTMTLSMIOCommandQueue_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a3 + 2);
  if (v5 == -15332)
  {
    *((void *)result + 3) = *a3;
  }

  else if (v5 == -15350)
  {
    int v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v8 = *a3;
    uint64_t v9 = *(void *)v7;
    *((void *)v4 + 1) = *((void *)v7 + 1);
    *((void *)v4 + 2) = v8;
    *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
    *((void *)v4 + 5) = v9;
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[24], a2);
    *((void *)v4 + 7) = result;
  }

  return result;
}

char *GTMTLSMCommandQueue_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  int v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 <= -16316)
  {
    switch(v6)
    {
      case -16349:
        int v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[8], a2);
        *((void *)v5 + 6) = result;
        break;
      case -16348:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 17) = *((_DWORD *)result + 2);
        break;
      case -16347:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        v5[75] = *((_DWORD *)result + 2);
        break;
      case -16346:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        v5[76] = *((_DWORD *)result + 2);
        break;
      case -16345:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        v5[74] = *((_DWORD *)result + 2);
        break;
      case -16344:
        *((void *)result + 3) = *a3;
        break;
      default:
        if (v6 == -16316)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v12 = *a3;
          uint64_t v13 = *(void *)result;
          *((void *)v5 + 1) = *((void *)result + 1);
          *((void *)v5 + 2) = v12;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          *((void *)v5 + 5) = v13;
          int v11 = 64;
LABEL_12:
          *((_DWORD *)v5 + 16) = v11;
        }

        break;
    }
  }

  else
  {
    switch(v6)
    {
      case -15809:
      case -15808:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        v5[73] = *((void *)result + 1);
        break;
      case -15807:
        return result;
      case -15806:
      case -15805:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        v5[72] = *((void *)result + 1);
        break;
      default:
        if (v6 == -16315)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v14 = *a3;
          uint64_t v15 = *(void *)result;
          *((void *)v5 + 1) = *((void *)result + 1);
          *((void *)v5 + 2) = v14;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          *((void *)v5 + 5) = v15;
          *((_DWORD *)v5 + 16) = *((void *)result + 2);
        }

        else if (v6 == -16165)
        {
          uint64_t v8 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v9 = *a3;
          uint64_t v10 = *(void *)v8;
          *((void *)v5 + 1) = *((void *)v8 + 1);
          *((void *)v5 + 2) = v9;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          *((void *)v5 + 5) = v10;
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v8[16], a2);
          *((void *)v5 + 7) = result;
          int v11 = *(_DWORD *)result;
          goto LABEL_12;
        }

        break;
    }
  }

  return result;
}

char *GTMTLSMRasterizationRateMap_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a3 + 2);
  switch(v5)
  {
    case -15801:
      *((void *)result + 3) = *a3;
      break;
    case -15411:
      uint64_t v10 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v10[8], a2);
      *((void *)v4 + 6) = result;
      break;
    case -15793:
      int v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v8 = *a3;
      uint64_t v9 = *(void *)v7;
      *((void *)v4 + 1) = *((void *)v7 + 1);
      *((void *)v4 + 2) = v8;
      *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
      *((void *)v4 + 5) = v9;
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[16], a2);
      *((void *)v4 + 6) = result;
      *((_DWORD *)v4 + 14) = *((_DWORD *)result + 6);
      v4[60] = result[34];
      break;
  }

  return result;
}

char *GTMTLSMDevice_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  if (v5 == -10239)
  {
    int v7 = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    *((void *)v4 + 1) = *(void *)v7;
    uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, v7[8], a2);
    *((void *)v4 + 5) = result;
  }

  else if (v5 == -16317)
  {
    *((void *)result + 3) = *(void *)a3;
  }

  return result;
}

uint64_t GTMTLSMFilter_processTraceFuncWithMap(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 <= -6123)
  {
    switch(v6)
    {
      case -6143:
LABEL_5:
        uint64_t v10 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v11 = *a3;
        uint64_t v12 = *(void *)v10;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v10 + 1);
        *(void *)(v5 + 16) = v11;
        uint64_t v13 = *((unsigned int *)a3 + 2);
        *(_DWORD *)(v5 + 4) = v13;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v13;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v12;
        *(void *)(v5 + 56) = GTTraceFunc_argumentBytesWithMap(a3, v10[16], a2);
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v10[24], a2);
        *(void *)(v5 + 64) = result;
        break;
      case -6141:
LABEL_9:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v18 = *a3;
        uint64_t v19 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v18;
        uint64_t v20 = *((unsigned int *)a3 + 2);
        *(_DWORD *)(v5 + 4) = v20;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v20;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v19;
        *(void *)(v5 + 56) = *(void *)(result + 16);
        *(void *)(v5 + 64) = *(void *)(result + 24);
        *(void *)(v5 + 72) = *(void *)(result + 32);
        *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 40);
        break;
      case -6139:
        *(void *)(result + 24) = *a3;
        break;
      case -6134:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v28 = *a3;
        uint64_t v29 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v28;
        uint64_t v30 = *((unsigned int *)a3 + 2);
        *(_DWORD *)(v5 + 4) = v30;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v30;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v29;
        *(_BYTE *)(v5 + 96) = *(_DWORD *)(result + 16);
        *(void *)(v5 + 56) = *(void *)(result + 24);
        *(void *)(v5 + 64) = *(void *)(result + 32);
        *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 40);
        uint64_t v24 = *(void *)(result + 48);
LABEL_14:
        *(void *)(v5 + 8_Block_object_dispose(va, 8) = v24;
        break;
      case -6133:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v31 = *a3;
        uint64_t v32 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v31;
        uint64_t v33 = *((unsigned int *)a3 + 2);
        *(_DWORD *)(v5 + 4) = v33;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v33;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v32;
        *(void *)(v5 + 56) = *(int *)(result + 16);
        *(_DWORD *)(v5 + 64) = *(_DWORD *)(result + 20);
        *(_DWORD *)(v5 + 6_Block_object_dispose(va, 8) = *(_DWORD *)(result + 24);
        *(_DWORD *)(v5 + 72) = *(_DWORD *)(result + 28);
        break;
      case -6131:
        unsigned int v34 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v35 = *a3;
        uint64_t v36 = *(void *)v34;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v34 + 1);
        *(void *)(v5 + 16) = v35;
        uint64_t v37 = *((unsigned int *)a3 + 2);
        *(_DWORD *)(v5 + 4) = v37;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v37;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v36;
        *(void *)(v5 + 56) = GTTraceFunc_argumentBytesWithMap(a3, v34[16], a2);
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v34[24], a2);
        *(void *)(v5 + 64) = result;
        *(_BYTE *)(v5 + 72) = *((_DWORD *)v34 + 8);
        break;
      case -6129:
        uint64_t v38 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v39 = *a3;
        uint64_t v40 = *(void *)v38;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v38 + 1);
        *(void *)(v5 + 16) = v39;
        uint64_t v41 = *((unsigned int *)a3 + 2);
        *(_DWORD *)(v5 + 4) = v41;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v41;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v40;
        *(void *)(v5 + 56) = *((int *)v38 + 4);
        unsigned int v42 = v38[24];
        if (g_loadURLAsMemHeader) {
          uint64_t result = GTTraceFunc_argumentBlobWithMap(a3, v42, a2);
        }
        else {
          uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v42, a2);
        }
        *(void *)(v5 + 72) = result;
        *(void *)(v5 + 64) = *((void *)v38 + 4);
        break;
      default:
        return result;
    }
  }

  else
  {
    switch(v6)
    {
      case -6122:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v21 = *a3;
        uint64_t v22 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v21;
        uint64_t v23 = *((unsigned int *)a3 + 2);
        *(_DWORD *)(v5 + 4) = v23;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v23;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v22;
        *(_BYTE *)(v5 + 96) = *(_DWORD *)(result + 16);
        *(_BYTE *)(v5 + 97) = *(_DWORD *)(result + 20);
        *(void *)(v5 + 56) = *(void *)(result + 24);
        *(void *)(v5 + 64) = *(void *)(result + 32);
        *(void *)(v5 + 72) = *(void *)(result + 40);
        *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 48);
        uint64_t v24 = *(void *)(result + 56);
        goto LABEL_14;
      case -6121:
      case -6120:
      case -6118:
      case -6117:
      case -6115:
      case -6114:
      case -6113:
      case -6112:
        return result;
      case -6119:
      case -6110:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v7 = *a3;
        uint64_t v8 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v7;
        uint64_t v9 = *((unsigned int *)a3 + 2);
        *(_DWORD *)(v5 + 4) = v9;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v9;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v8;
        break;
      case -6116:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v25 = *a3;
        uint64_t v26 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v25;
        uint64_t v27 = *((unsigned int *)a3 + 2);
        *(_DWORD *)(v5 + 4) = v27;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v27;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v26;
        *(void *)(v5 + 56) = *(void *)(result + 16);
        *(void *)(v5 + 64) = *(void *)(result + 24);
        *(void *)(v5 + 72) = *(void *)(result + 32);
        *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 40);
        *(void *)(v5 + 8_Block_object_dispose(va, 8) = *(void *)(result + 48);
        *(void *)(v5 + 96) = *(void *)(result + 56);
        break;
      case -6111:
        goto LABEL_5;
      case -6109:
        goto LABEL_9;
      default:
        if (v6 == -6096 || v6 == -6095)
        {
          uint64_t v14 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v15 = *a3;
          uint64_t v16 = *(void *)v14;
          *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v14 + 1);
          *(void *)(v5 + 16) = v15;
          uint64_t v17 = *((unsigned int *)a3 + 2);
          *(_DWORD *)(v5 + 4) = v17;
          *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v17;
          *(void *)(v5 + 4_Block_object_dispose(va, 8) = v16;
          uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v14[16], a2);
          *(void *)(v5 + 56) = result;
        }

        break;
    }
  }

  return result;
}

char *GTMTLSMResourceGroup_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a3 + 2);
  if (v5 == -15769)
  {
    *((void *)result + 3) = *a3;
  }

  else if (v5 == -15900)
  {
    uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v8 = *a3;
    uint64_t v9 = *(void *)v7;
    *((void *)v4 + 1) = *((void *)v7 + 1);
    *((void *)v4 + 2) = v8;
    *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
    *((void *)v4 + 5) = v9;
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[24], a2);
    *((void *)v4 + 6) = result;
    *((_DWORD *)v4 + 14) = *((void *)v7 + 2);
  }

  return result;
}

char *GTMTLSMDrawable_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a3 + 2);
  if (v5 > -7162)
  {
    if (v5 == -7161)
    {
      *((void *)result + 3) = *a3;
    }

    else if (v5 == -6655)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v8 = *a3;
      *((void *)v4 + 1) = *((void *)result + 1);
      *((void *)v4 + 2) = v8;
      *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
    }
  }

  else if (v5 == -7167)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    *((void *)v4 + 6) = *((void *)result + 1);
  }

  else if (v5 == -7166)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v6 = *a3;
    uint64_t v7 = *(void *)result;
    *((void *)v4 + 1) = *((void *)result + 1);
    *((void *)v4 + 2) = v6;
    *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
    *((void *)v4 + 5) = v7;
  }

  return result;
}

uint64_t GTMTLSMLayer_processTraceFuncWithMap(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  switch(v6)
  {
    case -7165:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *(_WORD *)(v5 + 272) = *(void *)(result + 8);
      break;
    case -7164:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *(void *)(v5 + 176) = *(void *)(result + 8);
      *(void *)(v5 + 184) = *(void *)(result + 16);
      break;
    case -7163:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v7 = *a3;
      uint64_t v8 = *(void *)(result + 8);
      *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)result;
      *(void *)(v5 + 16) = v7;
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v8;
      break;
    case -7162:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      for (uint64_t i = 0LL; i != 32; i += 8LL)
        *(void *)(v5 + 216 + i) = *(void *)(result + 8 + i);
      goto LABEL_14;
    case -7161:
    case -7158:
    case -7157:
    case -7156:
    case -7155:
      return result;
    case -7160:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *(_BYTE *)(v5 + 274) = *(_DWORD *)(result + 8);
      break;
    case -7159:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      for (uint64_t j = 0LL; j != 32; j += 8LL)
        *(void *)(v5 + 216 + j) = *(void *)(result + 8 + j);
LABEL_14:
      *(void *)(v5 + 20_Block_object_dispose(va, 8) = *(void *)(result + 40);
      break;
    case -7154:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *(_BYTE *)(v5 + 275) = *(_DWORD *)(result + 8);
      break;
    case -7153:
      unsigned int v11 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2)[8];
      if (g_loadURLAsMemHeader) {
        uint64_t result = GTTraceFunc_argumentBlobWithMap(a3, v11, a2);
      }
      else {
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, v11, a2);
      }
      *(void *)(v5 + 264) = result;
      break;
    default:
      if (v6 == -8183)
      {
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        for (uint64_t k = 0LL; k != 128; k += 8LL)
          *(void *)(v5 + 48 + k) = *(void *)(result + 8 + k);
        *(_OWORD *)(v5 + 24_Block_object_dispose(va, 8) = *(_OWORD *)(result + 136);
      }

      else if (v6 == -8181)
      {
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *(void *)(v5 + 192) = *(void *)(result + 8);
        *(void *)(v5 + 20mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 16);
      }

      break;
  }

  return result;
}

char *GTMTLSMAccelerationStructure_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 <= -10198)
  {
    if (v6 > -15507)
    {
      switch(v6)
      {
        case -15359:
          uint64_t v8 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v9 = *a3;
          *((void *)v5 + 1) = *((void *)v8 + 1);
          *((void *)v5 + 2) = v9;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v10 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            uint64_t v11 = *((void *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            *((void *)v5 + 23) = v11;
            uint64_t v12 = *((void *)result + 9);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v12;
            __int128 v13 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v13;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v12 - v13;
            *((_DWORD *)v5 + 21) = v10;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 5) = *(void *)v8;
          uint64_t v14 = *((void *)v8 + 2);
          *((void *)v5 + 25) = *((void *)v8 + 3);
          uint64_t v15 = *((void *)v8 + 4);
          *((void *)v5 + 1_Block_object_dispose(va, 8) = v14;
          *((void *)v5 + 19) = v15;
          return result;
        case -15358:
          goto LABEL_31;
        case -15357:
          return result;
        case -15356:
          unsigned int v42 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v43 = *a3;
          *((void *)v5 + 1) = *((void *)v42 + 1);
          *((void *)v5 + 2) = v43;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v44 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            uint64_t v45 = *((void *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            *((void *)v5 + 23) = v45;
            uint64_t v46 = *((void *)result + 5);
            *((void *)v5 + 25) = *((void *)result + 6);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            uint64_t v47 = *((void *)result + 9);
            *((void *)v5 + 19) = v46;
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v47;
            __int128 v48 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v48;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v47 - v48;
            *((_DWORD *)v5 + 21) = v44;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          goto LABEL_62;
        case -15355:
          unsigned int v42 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v49 = *a3;
          *((void *)v5 + 1) = *((void *)v42 + 1);
          *((void *)v5 + 2) = v49;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v50 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v51 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v50;
            *((_DWORD *)v5 + 22) = v51;
            uint64_t v52 = *((void *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            uint64_t v53 = *((void *)result + 6);
            *((void *)v5 + 19) = *((void *)result + 5);
            *((void *)v5 + 23) = v52;
            *((void *)v5 + 25) = v53;
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            *((_OWORD *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_OWORD *)(result + 72);
            uint64_t v54 = *((void *)result + 12);
            *((void *)v5 + 22) = *((void *)result + 11);
            *((void *)v5 + 24) = v54;
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v42 + 2);
LABEL_62:
          *((void *)v5 + 6) = *(void *)v42;
          return result;
        case -15354:
          uint64_t v33 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v55 = *a3;
          *((void *)v5 + 1) = *((void *)v33 + 1);
          *((void *)v5 + 2) = v55;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v56 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            uint64_t v57 = *((void *)result + 5);
            *((void *)v5 + 25) = *((void *)result + 6);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            uint64_t v58 = *((void *)result + 9);
            *((void *)v5 + 19) = v57;
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v58;
            __int128 v59 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v59;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v58 - v59;
            *((_DWORD *)v5 + 21) = v56;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 6) = *(void *)v33;
          goto LABEL_66;
        case -15353:
          int v60 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v61 = *a3;
          *((void *)v5 + 1) = *((void *)v60 + 1);
          *((void *)v5 + 2) = v61;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v62 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v63 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v62;
            *((_DWORD *)v5 + 22) = v63;
            *((void *)v5 + 16) = *((void *)result + 3);
            uint64_t v64 = *((void *)result + 6);
            *((void *)v5 + 19) = *((void *)result + 5);
            *((void *)v5 + 25) = v64;
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            *((_OWORD *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_OWORD *)(result + 72);
            uint64_t v65 = *((void *)result + 12);
            *((void *)v5 + 22) = *((void *)result + 11);
            *((void *)v5 + 24) = v65;
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 6) = *(void *)v60;
          uint64_t v66 = *((void *)v60 + 2);
          *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v60 + 3);
          *((void *)v5 + 23) = v66;
          return result;
        case -15352:
          uint64_t v67 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v68 = *a3;
          *((void *)v5 + 1) = *((void *)v67 + 1);
          *((void *)v5 + 2) = v68;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v69 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v70 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v69;
            *((_DWORD *)v5 + 22) = v70;
            *((void *)v5 + 16) = *((void *)result + 3);
            *((void *)v5 + 25) = *((void *)result + 6);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            *((_OWORD *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_OWORD *)(result + 72);
            uint64_t v71 = *((void *)result + 12);
            *((void *)v5 + 22) = *((void *)result + 11);
            *((void *)v5 + 24) = v71;
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 6) = *(void *)v67;
          uint64_t v72 = *((void *)v67 + 2);
          *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v67 + 3);
          *((void *)v5 + 23) = v72;
          uint64_t v39 = *((void *)v67 + 4);
          goto LABEL_73;
        case -15351:
          int v73 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v74 = *a3;
          *((void *)v5 + 1) = *((void *)v73 + 1);
          *((void *)v5 + 2) = v74;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v75 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            *((void *)v5 + 25) = *((void *)result + 6);
            uint64_t v76 = *((void *)result + 9);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v76;
            __int128 v77 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v77;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v76 - v77;
            *((_DWORD *)v5 + 21) = v75;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 6) = *(void *)v73;
          goto LABEL_80;
        default:
          if (v6 == -15506)
          {
            int v73 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v78 = *a3;
            *((void *)v5 + 1) = *((void *)v73 + 1);
            *((void *)v5 + 2) = v78;
            *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *((void *)v5 + 15) = result;
            if (result)
            {
              uint64_t v79 = *((void *)result + 1);
              *((void *)v5 + 7) = *(void *)result;
              *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
              *((void *)v5 + 16) = *((void *)result + 3);
              *((void *)v5 + 25) = *((void *)result + 6);
              uint64_t v80 = *((void *)result + 9);
              *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
              *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v80;
              __int128 v81 = *((_OWORD *)result + 5);
              *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v81;
              *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v80 - v81;
              *((_DWORD *)v5 + 21) = v79;
              *((void *)v5 + 24) = *((void *)result + 12);
              *((void *)v5 + 17) = *((void *)result + 7);
            }

            *((void *)v5 + 5) = *(void *)v73;
LABEL_80:
            uint64_t v82 = *((void *)v73 + 3);
            *((void *)v5 + 23) = *((void *)v73 + 2);
            *((void *)v5 + 19) = v82;
          }

          else if (v6 == -15464)
          {
            uint64_t v24 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            uint64_t v25 = *a3;
            *((void *)v5 + 1) = *((void *)v24 + 1);
            *((void *)v5 + 2) = v25;
            *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
            *((void *)v5 + 15) = result;
            if (result)
            {
              uint64_t v26 = *((void *)result + 1);
              *((void *)v5 + 7) = *(void *)result;
              *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
              uint64_t v27 = *((void *)result + 4);
              *((void *)v5 + 16) = *((void *)result + 3);
              uint64_t v28 = *((void *)result + 5);
              *((void *)v5 + 23) = v27;
              *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
              uint64_t v29 = *((void *)result + 9);
              *((void *)v5 + 19) = v28;
              *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v29;
              __int128 v30 = *((_OWORD *)result + 5);
              *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v30;
              *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v29 - v30;
              *((_DWORD *)v5 + 21) = v26;
              *((void *)v5 + 24) = *((void *)result + 12);
              *((void *)v5 + 17) = *((void *)result + 7);
            }

            *((void *)v5 + 5) = *(void *)v24;
            uint64_t v31 = *((void *)v24 + 3);
            *((void *)v5 + 1_Block_object_dispose(va, 8) = *((void *)v24 + 2);
            *((void *)v5 + 25) = v31;
          }

          break;
      }
    }

    else if (v6 > -15616)
    {
      switch(v6)
      {
        case -15615:
LABEL_31:
          uint64_t v17 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v18 = *a3;
          *((void *)v5 + 1) = *((void *)v17 + 1);
          *((void *)v5 + 2) = v18;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v19 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            uint64_t v20 = *((void *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            *((void *)v5 + 23) = v20;
            uint64_t v21 = *((void *)result + 5);
            *((void *)v5 + 25) = *((void *)result + 6);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            uint64_t v22 = *((void *)result + 9);
            *((void *)v5 + 19) = v21;
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v22;
            __int128 v23 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v23;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v22 - v23;
            *((_DWORD *)v5 + 21) = v19;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 5) = *(void *)v17;
          break;
        case -15614:
          uint64_t v33 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v34 = *a3;
          *((void *)v5 + 1) = *((void *)v33 + 1);
          *((void *)v5 + 2) = v34;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v35 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            uint64_t v36 = *((void *)result + 5);
            *((void *)v5 + 25) = *((void *)result + 6);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            uint64_t v37 = *((void *)result + 9);
            *((void *)v5 + 19) = v36;
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v37;
            __int128 v38 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v38;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v37 - v38;
            *((_DWORD *)v5 + 21) = v35;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 5) = *(void *)v33;
LABEL_66:
          *((void *)v5 + 23) = *((void *)v33 + 2);
          break;
        case -15552:
          uint64_t v16 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v16[8], a2);
          *((void *)v5 + 14) = result;
          if (result)
          {
            v5[104] = (*result & 0xFE) == 2;
            v5[105] = 1;
            v5[107] = (result[1] & 4) != 0;
          }

          break;
      }
    }

    else
    {
      switch(v6)
      {
        case -15661:
          uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[8], a2);
          *((void *)v5 + 9) = result;
          break;
        case -15660:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((_DWORD *)v5 + 22) = *((_DWORD *)result + 2);
          break;
        case -15659:
          *((void *)result + 3) = *a3;
          break;
        case -15651:
          result[100] = 1;
          break;
        case -15650:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v32 = *((void *)result + 2);
          if (v32 != 1) {
            *((_WORD *)v5 + 49) = v32;
          }
          break;
        default:
          return result;
      }
    }

    return result;
  }

  if (v6 > -10174)
  {
    if (v6 <= -10160)
    {
      switch(v6)
      {
        case -10173:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
          break;
        case -10170:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v39 = *((void *)result + 1);
LABEL_73:
          *((void *)v5 + 19) = v39;
          break;
        case -10169:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)result + 1);
          break;
        case -10167:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 17) = *((void *)result + 1);
          break;
        default:
          return result;
      }

      return result;
    }

    if (v6 == -10159)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      int16x8_t v41 = *(int16x8_t *)(result + 8);
    }

    else
    {
      if (v6 != -10158)
      {
        if (v6 == -10154)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          if (*((void *)v5 + 1) == *((void *)result + 1))
          {
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, result[16], a2);
            *((void *)v5 + 14) = result;
          }
        }

        return result;
      }

      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      if (*((void *)v5 + 1) != *((void *)result + 1)) {
        return result;
      }
      int16x8_t v41 = *((int16x8_t *)result + 1);
    }

    *(int16x4_t *)v41.i8 = vmovn_s32((int32x4_t)v41);
    *((_DWORD *)v5 + 26) = vmovn_s16(v41).u32[0];
    return result;
  }

  if (v6 <= -10196)
  {
    if (v6 == -10197)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 7) = *((void *)result + 1);
    }

    else
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((_DWORD *)v5 + 21) = *((void *)result + 1);
    }
  }

  else
  {
    switch(v6)
    {
      case -10195:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 23) = *((_DWORD *)result + 2);
        break;
      case -10182:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_OWORD *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_OWORD *)(result + 8);
        uint64_t v40 = *((void *)result + 4);
        *((void *)v5 + 22) = *((void *)result + 3);
        *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = v40;
        *((_OWORD *)v5 + 12) = *(_OWORD *)(result + 40);
        break;
      case -10181:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((void *)v5 + 16) = *((void *)result + 1);
        break;
    }
  }

  return result;
}

char *GTMTLSMFunctionHandle_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = result;
  int v5 = *((_DWORD *)a3 + 2);
  if (v5 > -15445)
  {
    switch(v5)
    {
      case -15444:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v14 = *a3;
        uint64_t v15 = *(void *)result;
        *((void *)v4 + 1) = *((void *)result + 1);
        *((void *)v4 + 2) = v14;
        *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v4 + 7) = v15;
        *((void *)v4 + 5) = *((void *)result + 2);
        char v11 = 2;
        break;
      case -15437:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v16 = *a3;
        uint64_t v17 = *(void *)result;
        *((void *)v4 + 1) = *((void *)result + 1);
        *((void *)v4 + 2) = v16;
        *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v4 + 7) = v17;
        *((void *)v4 + 5) = *((void *)result + 2);
        char v11 = 4;
        break;
      case -15436:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v9 = *a3;
        uint64_t v10 = *(void *)result;
        *((void *)v4 + 1) = *((void *)result + 1);
        *((void *)v4 + 2) = v9;
        *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v4 + 7) = v10;
        *((void *)v4 + 5) = *((void *)result + 2);
        char v11 = 1;
        break;
      default:
        return result;
    }

    v4[64] = v11;
  }

  else
  {
    switch(v5)
    {
      case -15620:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v12 = *a3;
        uint64_t v13 = *(void *)result;
        *((void *)v4 + 1) = *((void *)result + 1);
        *((void *)v4 + 2) = v12;
        *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v4 + 5) = *((void *)result + 2);
        *((void *)v4 + 6) = v13;
        break;
      case -15610:
        *((void *)result + 3) = *a3;
        break;
      case -15463:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v6 = *a3;
        uint64_t v7 = *(void *)result;
        *((void *)v4 + 1) = *((void *)result + 1);
        *((void *)v4 + 2) = v6;
        *((_DWORD *)v4 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v4 + 7) = v7;
        uint64_t v8 = *((void *)result + 3);
        *((void *)v4 + 5) = *((void *)result + 2);
        v4[64] = v8;
        break;
    }
  }

  return result;
}

char *GTMTLSMIntersectionFunctionTable_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  int v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -15444)
  {
    if (v6 <= -10181)
    {
      switch(v6)
      {
        case -15443:
          __int128 v30 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v31 = *a3;
          *((void *)v5 + 1) = *((void *)v30 + 1);
          *((void *)v5 + 2) = v31;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t v32 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 14) = v32;
          if (v32)
          {
            uint64_t v33 = *((void *)v32 + 1);
            *((void *)v5 + 7) = *(void *)v32;
            int v34 = *((_DWORD *)v32 + 4);
            *((_DWORD *)v5 + 21) = v33;
            *((_DWORD *)v5 + 22) = v34;
            *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v32 + 24), *(int8x16_t *)(v32 + 24), 8uLL);
            *((void *)v5 + 19) = *((void *)v32 + 5);
          }

          *((void *)v5 + 16) = *(void *)v30;
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v30[16], a2);
          *((void *)v5 + 13) = result;
          char v18 = 2;
          break;
        case -15442:
          uint64_t v25 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v26 = *a3;
          *((void *)v5 + 1) = *((void *)v25 + 1);
          *((void *)v5 + 2) = v26;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t v27 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 14) = v27;
          if (v27)
          {
            uint64_t v28 = *((void *)v27 + 1);
            *((void *)v5 + 7) = *(void *)v27;
            int v29 = *((_DWORD *)v27 + 4);
            *((_DWORD *)v5 + 21) = v28;
            *((_DWORD *)v5 + 22) = v29;
            *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v27 + 24), *(int8x16_t *)(v27 + 24), 8uLL);
            *((void *)v5 + 19) = *((void *)v27 + 5);
          }

          *((void *)v5 + 16) = *(void *)v25;
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v25[16], a2);
          *((void *)v5 + 13) = result;
          char v18 = 4;
          break;
        case -15441:
          uint64_t v13 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          uint64_t v14 = *a3;
          *((void *)v5 + 1) = *((void *)v13 + 1);
          *((void *)v5 + 2) = v14;
          *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
          uint64_t v15 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
          *((void *)v5 + 14) = v15;
          if (v15)
          {
            uint64_t v16 = *((void *)v15 + 1);
            *((void *)v5 + 7) = *(void *)v15;
            int v17 = *((_DWORD *)v15 + 4);
            *((_DWORD *)v5 + 21) = v16;
            *((_DWORD *)v5 + 22) = v17;
            *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v15 + 24), *(int8x16_t *)(v15 + 24), 8uLL);
            *((void *)v5 + 19) = *((void *)v15 + 5);
          }

          *((void *)v5 + 16) = *(void *)v13;
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v13[16], a2);
          *((void *)v5 + 13) = result;
          char v18 = 1;
          break;
        default:
          return result;
      }

      v5[160] = v18;
    }

    else
    {
      switch(v6)
      {
        case -10180:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
          break;
        case -10179:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((_DWORD *)v5 + 21) = *((void *)result + 1);
          break;
        case -10178:
        case -10177:
          return result;
        case -10176:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 7) = *((void *)result + 1);
          break;
        case -10175:
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 1_Block_object_dispose(va, 8) = *((void *)result + 1);
          break;
        default:
          if (v6 == -10161)
          {
            uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
            *((void *)v5 + 19) = *((void *)result + 1);
          }

          break;
      }
    }
  }

  else if (v6 > -15561)
  {
    if (v6 > -15541)
    {
      if (v6 == -15540)
      {
        uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v35 = *a3;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v35;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        uint64_t v36 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 14) = v36;
        if (v36)
        {
          uint64_t v37 = *((void *)v36 + 1);
          *((void *)v5 + 7) = *(void *)v36;
          int v38 = *((_DWORD *)v36 + 4);
          *((_DWORD *)v5 + 21) = v37;
          *((_DWORD *)v5 + 22) = v38;
          *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v36 + 24), *(int8x16_t *)(v36 + 24), 8uLL);
          *((void *)v5 + 19) = *((void *)v36 + 5);
        }

        *((void *)v5 + 15) = *(void *)v7;
LABEL_45:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[16], a2);
        *((void *)v5 + 13) = result;
      }

      else if (v6 == -15462)
      {
        uint64_t v19 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v20 = *a3;
        *((void *)v5 + 1) = *((void *)v19 + 1);
        *((void *)v5 + 2) = v20;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        uint64_t v21 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 14) = v21;
        if (v21)
        {
          uint64_t v22 = *((void *)v21 + 1);
          *((void *)v5 + 7) = *(void *)v21;
          int v23 = *((_DWORD *)v21 + 4);
          *((_DWORD *)v5 + 21) = v22;
          *((_DWORD *)v5 + 22) = v23;
          *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v21 + 24), *(int8x16_t *)(v21 + 24), 8uLL);
          *((void *)v5 + 19) = *((void *)v21 + 5);
        }

        *((void *)v5 + 16) = *(void *)v19;
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v19[24], a2);
        *((void *)v5 + 13) = result;
        v5[160] = *((void *)v19 + 2);
      }
    }

    else if (v6 == -15560)
    {
      result[100] = 1;
    }

    else if (v6 == -15557)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v12 = *((void *)result + 2);
      if (v12 != 1) {
        *((_WORD *)v5 + 49) = v12;
      }
    }
  }

  else
  {
    switch(v6)
    {
      case -15577:
        uint64_t v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v8 = *a3;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v8;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        uint64_t v9 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 14) = v9;
        if (v9)
        {
          uint64_t v10 = *((void *)v9 + 1);
          *((void *)v5 + 7) = *(void *)v9;
          int v11 = *((_DWORD *)v9 + 4);
          *((_DWORD *)v5 + 21) = v10;
          *((_DWORD *)v5 + 22) = v11;
          *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v9 + 24), *(int8x16_t *)(v9 + 24), 8uLL);
          *((void *)v5 + 19) = *((void *)v9 + 5);
        }

        *((void *)v5 + 5) = *(void *)v7;
        goto LABEL_45;
      case -15570:
        uint64_t v24 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v24[8], a2);
        *((void *)v5 + 9) = result;
        break;
      case -15569:
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 22) = *((_DWORD *)result + 2);
        break;
      case -15568:
        *((void *)result + 3) = *a3;
        break;
      default:
        return result;
    }
  }

  return result;
}

char *GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithMap( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = *(_DWORD *)(a3 + 8);
  if (v7 <= -15531)
  {
    if (v7 > -15546)
    {
      if (v7 == -15545)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v43 = *((void *)result + 1);
        uint64_t v44 = a1 + 184 + 24LL * *((void *)result + 3);
        *(_DWORD *)uint64_t v44 = v43 != 0;
        *(void *)(v44 + _Block_object_dispose(va, 8) = v43;
        *(void *)(a1 + 184 + 24LL * *((void *)result + 3) + 16) = *((void *)result + 2);
        return result;
      }

      if (v7 == -15544)
      {
        uint64_t v24 = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v25 = GTTraceFunc_argumentBytesWithMap((void *)a3, v24[24], a2);
        uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, v24[25], a2);
        if (*((void *)v24 + 2))
        {
          unint64_t v26 = 0LL;
          do
          {
            uint64_t v27 = *(void *)&v25[8 * v26];
            uint64_t v28 = a1 + 184 + 24 * (v26 + *((void *)v24 + 1));
            *(_DWORD *)uint64_t v28 = v27 != 0;
            *(void *)(v28 + _Block_object_dispose(va, 8) = v27;
            *(void *)(a1 + 184 + 24 * (v26 + *((void *)v24 + 1)) + 16) = *(void *)&result[8 * v26];
            ++v26;
          }

          while (*((void *)v24 + 2) > v26);
        }

        return result;
      }
    }

    else
    {
      if (v7 == -15559)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v38 = *(void *)(a1 + 168);
        if (!v38) {
          return result;
        }
        uint64_t v10 = *((void *)result + 1);
        uint64_t v11 = v38 + 16LL * *((void *)result + 2);
        int v12 = 1;
        goto LABEL_48;
      }

      if (v7 == -15558)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        if (*(void *)(a1 + 168))
        {
          uint64_t v13 = result;
          uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, result[24], a2);
          if (*((void *)v13 + 2))
          {
            unint64_t v14 = 0LL;
            do
            {
              uint64_t v15 = *(void *)(a1 + 168) + 16 * (v14 + *((void *)v13 + 1));
              *(_DWORD *)uint64_t v15 = 1;
              *(void *)(v15 + _Block_object_dispose(va, 8) = *(void *)&result[8 * v14++];
            }

            while (*((void *)v13 + 2) > v14);
          }
        }

        return result;
      }
    }

    return GTMTLSMIntersectionFunctionTable_processTraceFuncWithMap((char *)a1, a2, (uint64_t *)a3);
  }

  if (v7 <= -15259)
  {
    switch(v7)
    {
      case -15530:
        uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v9 = *(void *)(a1 + 168);
        if (!v9) {
          return result;
        }
        uint64_t v10 = *((void *)result + 1);
        uint64_t v11 = v9 + 16LL * *((void *)result + 2);
        int v12 = 2;
        break;
      case -15529:
        uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        if (*(void *)(a1 + 168) && *((void *)result + 3))
        {
          unint64_t v29 = 0LL;
          do
          {
            uint64_t v30 = *((void *)result + 1);
            uint64_t v31 = *(void *)(a1 + 168) + 16 * (v29 + *((void *)result + 2));
            *(_DWORD *)uint64_t v31 = 2;
            *(void *)(v31 + _Block_object_dispose(va, 8) = v30;
            ++v29;
          }

          while (*((void *)result + 3) > v29);
        }

        return result;
      case -15526:
        uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v32 = *((void *)result + 1);
        uint64_t v33 = a1 + 24LL * *((void *)result + 2);
        *(_DWORD *)(v33 + 184) = 2 * (v32 != 0);
        *(void *)(v33 + 192) = v32;
        return result;
      case -15525:
        int v34 = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, v34[24], a2);
        if (*((void *)v34 + 2))
        {
          unint64_t v35 = 0LL;
          do
          {
            uint64_t v36 = *(void *)&result[8 * v35];
            uint64_t v37 = a1 + 24 * (v35 + *((void *)v34 + 1));
            *(_DWORD *)(v37 + 184) = 2 * (v36 != 0);
            *(void *)(v37 + 192) = v36;
            ++v35;
          }

          while (*((void *)v34 + 2) > v35);
        }

        return result;
      default:
        return GTMTLSMIntersectionFunctionTable_processTraceFuncWithMap((char *)a1, a2, (uint64_t *)a3);
    }

    goto LABEL_48;
  }

  if (v7 == -15258)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v39 = *(void *)(a1 + 168);
    if (!v39) {
      return result;
    }
    uint64_t v10 = *((void *)result + 1);
    uint64_t v11 = v39 + 16LL * *((void *)result + 2);
    int v12 = 3;
LABEL_48:
    *(_DWORD *)uint64_t v11 = v12;
    *(void *)(v11 + _Block_object_dispose(va, 8) = v10;
    return result;
  }

  if (v7 == -15257)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    if (*(void *)(a1 + 168) && *((void *)result + 3))
    {
      unint64_t v40 = 0LL;
      do
      {
        uint64_t v41 = *((void *)result + 1);
        uint64_t v42 = *(void *)(a1 + 168) + 16 * (v40 + *((void *)result + 2));
        *(_DWORD *)uint64_t v42 = 3;
        *(void *)(v42 + _Block_object_dispose(va, 8) = v41;
        ++v40;
      }

      while (*((void *)result + 3) > v40);
    }

    return result;
  }

  if (v7 != -10152) {
    return GTMTLSMIntersectionFunctionTable_processTraceFuncWithMap((char *)a1, a2, (uint64_t *)a3);
  }
  uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
  if (a4)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, result[8], a2);
    unint64_t v17 = *(void *)result;
    if (*(void *)result)
    {
      char v18 = result;
      unint64_t v19 = 0LL;
      uint64_t v20 = (_DWORD *)(a1 + 184);
      do
      {
        uint64_t v21 = &v18[8 * v19];
        uint64_t v22 = *((void *)v21 + 1);
        if (v22)
        {
          uint64_t result = (char *)GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a4 + 24LL),  *(int *)(*(void *)a4 + 12LL),  *((void *)v21 + 1));
          if (result)
          {
            uint64_t v23 = *((void *)result + 2);
            if (v23)
            {
              unint64_t v46 = *(void *)result;
              uint64_t v47 = a1 + 24 * v19;
              *(_DWORD *)(v47 + 184) = 1;
              *(void *)(v47 + 192) = v23;
              *(void *)(v47 + 20mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v22 - v46;
              return result;
            }
          }

          uint64_t result = (char *)GTMTLIndirectResources_visibleFunctionTableIdForGPUAddress(a4, v22);
          if (result)
          {
            uint64_t v45 = a1 + 24 * v19;
            *(_DWORD *)(v45 + 184) = 2;
            *(void *)(v45 + 192) = result;
            return result;
          }

          unint64_t v17 = *(void *)v18;
        }

        else
        {
          *uint64_t v20 = 0;
        }

        ++v19;
        v20 += 6;
      }

      while (v17 > v19);
    }
  }

  return result;
}

char *GTMTLSMVisibleFunctionTable_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  int v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  if (v6 > -15439)
  {
    if (v6 > -10178)
    {
      if (v6 > -10161)
      {
        if (v6 == -10160)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 19) = *((void *)result + 1);
        }

        else if (v6 == -10153)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
          *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)result + 1);
        }
      }

      else if (v6 == -10177)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((void *)v5 + 7) = *((void *)result + 1);
      }

      else if (v6 == -10174)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 21) = *((void *)result + 1);
      }

      return result;
    }

    if (v6 != -15438)
    {
      if (v6 == -10193)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((void *)v5 + 17) = *((void *)result + 1);
      }

      else if (v6 == -10178)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
      }

      return result;
    }

    int v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v18 = *a3;
    *((void *)v5 + 1) = *((void *)v7 + 1);
    *((void *)v5 + 2) = v18;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    unint64_t v19 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    *((void *)v5 + 14) = v19;
    if (v19)
    {
      uint64_t v20 = *((void *)v19 + 1);
      *((void *)v5 + 7) = *(void *)v19;
      int v21 = *((_DWORD *)v19 + 4);
      *((_DWORD *)v5 + 21) = v20;
      *((_DWORD *)v5 + 22) = v21;
      *(_OWORD *)(v5 + 136) = *(_OWORD *)(v19 + 24);
      *(_OWORD *)(v5 + 152) = *(_OWORD *)(v19 + 40);
    }

    *((void *)v5 + 16) = *(void *)v7;
    char v16 = 1;
LABEL_40:
    v5[168] = v16;
LABEL_41:
    unsigned int v27 = v7[16];
LABEL_42:
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v27, a2);
    *((void *)v5 + 13) = result;
    return result;
  }

  if (v6 > -15461)
  {
    switch(v6)
    {
      case -15460:
        uint64_t v22 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v23 = *a3;
        *((void *)v5 + 1) = *((void *)v22 + 1);
        *((void *)v5 + 2) = v23;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        uint64_t v24 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 14) = v24;
        if (v24)
        {
          uint64_t v25 = *((void *)v24 + 1);
          *((void *)v5 + 7) = *(void *)v24;
          int v26 = *((_DWORD *)v24 + 4);
          *((_DWORD *)v5 + 21) = v25;
          *((_DWORD *)v5 + 22) = v26;
          *(_OWORD *)(v5 + 136) = *(_OWORD *)(v24 + 24);
          *(_OWORD *)(v5 + 152) = *(_OWORD *)(v24 + 40);
        }

        *((void *)v5 + 16) = *(void *)v22;
        v5[168] = *((void *)v22 + 2);
        unsigned int v27 = v22[24];
        goto LABEL_42;
      case -15440:
        int v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v28 = *a3;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v28;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        unint64_t v29 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 14) = v29;
        if (v29)
        {
          uint64_t v30 = *((void *)v29 + 1);
          *((void *)v5 + 7) = *(void *)v29;
          int v31 = *((_DWORD *)v29 + 4);
          *((_DWORD *)v5 + 21) = v30;
          *((_DWORD *)v5 + 22) = v31;
          *(_OWORD *)(v5 + 136) = *(_OWORD *)(v29 + 24);
          *(_OWORD *)(v5 + 152) = *(_OWORD *)(v29 + 40);
        }

        *((void *)v5 + 16) = *(void *)v7;
        char v16 = 2;
        break;
      case -15439:
        int v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v12 = *a3;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v12;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        uint64_t v13 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
        *((void *)v5 + 14) = v13;
        if (v13)
        {
          uint64_t v14 = *((void *)v13 + 1);
          *((void *)v5 + 7) = *(void *)v13;
          int v15 = *((_DWORD *)v13 + 4);
          *((_DWORD *)v5 + 21) = v14;
          *((_DWORD *)v5 + 22) = v15;
          *(_OWORD *)(v5 + 136) = *(_OWORD *)(v13 + 24);
          *(_OWORD *)(v5 + 152) = *(_OWORD *)(v13 + 40);
        }

        *((void *)v5 + 16) = *(void *)v7;
        char v16 = 4;
        break;
      default:
        return result;
    }

    goto LABEL_40;
  }

  switch(v6)
  {
    case -15607:
      unint64_t v17 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v17[8], a2);
      *((void *)v5 + 9) = result;
      return result;
    case -15605:
      *((void *)result + 3) = *a3;
      return result;
    case -15578:
      int v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      uint64_t v8 = *a3;
      *((void *)v5 + 1) = *((void *)v7 + 1);
      *((void *)v5 + 2) = v8;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      uint64_t v9 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *((void *)v5 + 14) = v9;
      if (v9)
      {
        uint64_t v10 = *((void *)v9 + 1);
        *((void *)v5 + 7) = *(void *)v9;
        int v11 = *((_DWORD *)v9 + 4);
        *((_DWORD *)v5 + 21) = v10;
        *((_DWORD *)v5 + 22) = v11;
        *(_OWORD *)(v5 + 136) = *(_OWORD *)(v9 + 24);
        *(_OWORD *)(v5 + 152) = *(_OWORD *)(v9 + 40);
      }

      *((void *)v5 + 15) = *(void *)v7;
      goto LABEL_41;
  }

  return result;
}

char *GTMTLSMVisibleFunctionTableStateful_processTraceFuncWithMap(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 == -15597)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    if (*(void *)(a1 + 176))
    {
      uint64_t v9 = result;
      uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, result[24], a2);
      if (*((void *)v9 + 2))
      {
        unint64_t v10 = 0LL;
        uint64_t v11 = *(void *)(a1 + 176);
        do
        {
          *(void *)(v11 + 8 * (v10 + *((void *)v9 + 1))) = *(void *)&result[8 * v10];
          ++v10;
        }

        while (*((void *)v9 + 2) > v10);
      }
    }
  }

  else if (v6 == -15598)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v8 = *(void *)(a1 + 176);
    if (v8) {
      *(void *)(v8 + 8LL * *((void *)result + 2)) = *((void *)result + 1);
    }
  }

  else
  {
    return GTMTLSMVisibleFunctionTable_processTraceFuncWithMap((char *)a1, a2, (uint64_t *)a3);
  }

  return result;
}

char *GTMTLFXSMSpatialScaler_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  int v5 = result;
  int v6 = *((_DWORD *)a3 + 2);
  switch(v6)
  {
    case -20480:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
      break;
    case -20479:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 7) = *((void *)result + 1);
      break;
    case -20478:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 11) = *((void *)result + 1);
      break;
    case -20477:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)result + 1);
      break;
    case -20476:
      uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 9) = *((void *)result + 1);
      break;
    case -20475:
      *((void *)result + 3) = *a3;
      break;
    default:
      if (v6 == -18432)
      {
        int v7 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v8 = *a3;
        uint64_t v9 = *(void *)v7;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v8;
        *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
        *((void *)v5 + 5) = v9;
        uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v7[16], a2);
        *((void *)v5 + 6) = result;
        *((_OWORD *)v5 + 5) = *(_OWORD *)result;
      }

      break;
  }

  return result;
}

float32_t GTMTLFXSMTemporalScaler_processTraceFuncWithMap(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v6 = *((_DWORD *)a3 + 2);
  switch(v6)
  {
    case -20473:
      *(void *)(a1 + 64) = *((void *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 1);
      break;
    case -20472:
      *(_BYTE *)(a1 + 14_Block_object_dispose(va, 8) = *((_DWORD *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 2);
      break;
    case -20471:
      *(void *)(a1 + 72) = *((void *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 1);
      break;
    case -20470:
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = *((void *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 1);
      break;
    case -20469:
      *(void *)(a1 + 56) = *((void *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 1);
      break;
    case -20468:
      *(void *)(a1 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 1);
      break;
    case -20467:
      *(void *)(a1 + 112) = *((void *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 1);
      break;
    case -20466:
      v7.i32[0] = *((_DWORD *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 2);
      *(_DWORD *)(a1 + 12_Block_object_dispose(va, 8) = v7.i32[0];
      break;
    case -20465:
      v7.i32[0] = *((_DWORD *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 2);
      *(_DWORD *)(a1 + 132) = v7.i32[0];
      break;
    case -20464:
      *(void *)(a1 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 1);
      break;
    case -20463:
      v7.i32[0] = *((_DWORD *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 2);
      *(_DWORD *)(a1 + 136) = v7.i32[0];
      break;
    case -20462:
      v7.i32[0] = *((_DWORD *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 2);
      *(_DWORD *)(a1 + 14mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v7.i32[0];
      break;
    case -20461:
      *(void *)(a1 + 96) = *((void *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 1);
      break;
    case -20460:
      v7.i32[0] = *((_DWORD *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 2);
      *(_DWORD *)(a1 + memset(v68, 0, 144) = v7.i32[0];
      break;
    case -20459:
      *(_BYTE *)(a1 + 149) = *((_DWORD *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 2);
      break;
    case -20458:
      *(void *)(a1 + 24) = *a3;
      break;
    case -20457:
      *(_BYTE *)(a1 + 149) = 0;
      break;
    case -20456:
      *(void *)(a1 + 104) = *((void *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 1);
      break;
    default:
      if (v6 == -18430)
      {
        *(_BYTE *)(a1 + 15mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2) + 1);
      }

      else if (v6 == -18431)
      {
        uint64_t v8 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        uint64_t v9 = *a3;
        uint64_t v10 = *(void *)v8;
        *(void *)(a1 + _Block_object_dispose(va, 8) = *((void *)v8 + 1);
        *(void *)(a1 + 16) = v9;
        *(_DWORD *)(a1 + 4) = *((_DWORD *)a3 + 2);
        *(void *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v10;
        uint64_t v11 = GTTraceFunc_argumentBytesWithMap(a3, v8[16], a2);
        *(void *)(a1 + 4_Block_object_dispose(va, 8) = v11;
        *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
        uint64x2_t v12 = *((uint64x2_t *)v11 + 1);
        *(uint64x2_t *)(a1 + 112) = v12;
        float32x2_t v7 = vneg_f32(vcvt_f32_f64(vcvtq_f64_u64(v12)));
        *(float32x2_t *)(a1 + 136) = v7;
        *(_DWORD *)(a1 + memset(v68, 0, 144) = 1065353216;
        *(_WORD *)(a1 + 14_Block_object_dispose(va, 8) = 257;
      }

      break;
  }

  return v7.f32[0];
}

char *GTMTLSMResidencySet_processTraceFuncWithMap(char *result, uint64_t a2, uint64_t *a3)
{
  if (*((_DWORD *)a3 + 2) == -15245)
  {
    int v5 = result;
    int v6 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v7 = *a3;
    *((void *)v5 + 1) = *((void *)v6 + 1);
    *((void *)v5 + 2) = v7;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    uint64_t result = GTTraceFunc_argumentBytesWithMap(a3, v6[24], a2);
    *((void *)v5 + 5) = *(void *)v6;
    *((void *)v5 + 6) = result;
  }

  return result;
}

char *GTMTLSMBuffer_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 <= -15779)
  {
    if (v6 <= -16313)
    {
      switch(v6)
      {
        case -16372:
          uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[8], a2);
          *((void *)v5 + 9) = result;
          break;
        case -16371:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((_DWORD *)v5 + 22) = *((_DWORD *)result + 2);
          break;
        case -16370:
          *((void *)result + 3) = *(void *)a3;
          break;
        case -16369:
        case -16368:
          return result;
        case -16367:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v28 = *((void *)result + 2);
          if (v28 != 1) {
            *((_WORD *)v5 + 49) = v28;
          }
          break;
        default:
          if (v6 == -16314 || v6 == -16313) {
            goto LABEL_35;
          }
          break;
      }

      return result;
    }

    if (v6 > -16123)
    {
      switch(v6)
      {
        case -16122:
          result[100] = 1;
          break;
        case -16117:
          unint64_t v29 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v30 = *(void *)a3;
          uint64_t v31 = *((void *)v29 + 2);
          *((void *)v5 + 1) = *((void *)v29 + 1);
          *((void *)v5 + 2) = v30;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((void *)v29 + 3);
          *((void *)v5 + 13) = v31;
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 19) = result;
          if (result)
          {
            uint64_t v32 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v33 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v32;
            *((_DWORD *)v5 + 22) = v33;
            *((void *)v5 + 14) = *((void *)result + 3);
            *((_OWORD *)v5 + _Block_object_dispose(va, 8) = *((_OWORD *)result + 2);
          }

          *((void *)v5 + 6) = *(void *)v29;
          break;
        case -15914:
          uint64_t v8 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v9 = *(void *)a3;
          uint64_t v10 = *(void *)v8;
          *((void *)v5 + 1) = *((void *)v8 + 1);
          *((void *)v5 + 2) = v9;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          *((void *)v5 + 5) = *((void *)v8 + 2);
          *((void *)v5 + 15) = v10;
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          uint64_t v11 = *((void *)result + 3);
          *((void *)v5 + 13) = *((void *)result + 2);
          *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = v11;
          break;
      }

      return result;
    }

    if (v6 != -16312)
    {
      if (v6 != -16163) {
        return result;
      }
      uint64_t v18 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v19 = *(void *)a3;
      *((void *)v5 + 1) = *((void *)v18 + 1);
      *((void *)v5 + 2) = v19;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      uint64_t v20 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *((void *)v5 + 19) = v20;
      if (v20)
      {
        uint64_t v21 = *((void *)v20 + 1);
        *((void *)v5 + 7) = *(void *)v20;
        int v22 = *((_DWORD *)v20 + 4);
        *((_DWORD *)v5 + 21) = v21;
        *((_DWORD *)v5 + 22) = v22;
        *((void *)v5 + 14) = *((void *)v20 + 3);
        *((_OWORD *)v5 + _Block_object_dispose(va, 8) = *((_OWORD *)v20 + 2);
      }

      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v18[16], a2);
      *((void *)v5 + 1_Block_object_dispose(va, 8) = result;
      if (result) {
        uint64_t v23 = *((void *)result + 1);
      }
      else {
        uint64_t v23 = 0LL;
      }
      *((void *)v5 + 13) = v23;
      goto LABEL_58;
    }

char *GTMTLSMTexture_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -15914)
  {
    if (v6 <= -10228)
    {
      if (v6 > -15690)
      {
        if (v6 > -10235)
        {
          if (v6 == -10234)
          {
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            *((_DWORD *)v5 + 23) = *((_DWORD *)result + 2);
          }

          else if (v6 == -10231)
          {
            uint64_t v69 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v69[8], a2);
            *((void *)v5 + 14) = result;
          }

          return result;
        }

        if (v6 == -15689)
        {
          uint64_t v36 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v103 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v36 + 1);
          *((void *)v5 + 2) = v103;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 16) = result;
          if (result)
          {
            uint64_t v104 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v105 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v104;
            *((_DWORD *)v5 + 22) = v105;
            uint64_t v107 = *((void *)result + 6);
            uint64_t v106 = *((void *)result + 7);
            *((void *)v5 + 21) = *((void *)result + 5);
            *((void *)v5 + 22) = v106;
            *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
            *((void *)v5 + 14) = result + 24;
            *((void *)v5 + 25) = v107;
          }

          *((_WORD *)v5 + 76) = *((void *)v36 + 2);
          v5[158] = *((void *)v36 + 3);
          v5[159] = *((void *)v36 + 4);
          v5[160] = *((void *)v36 + 5);
          *((_WORD *)v5 + 77) = *((void *)v36 + 6);
          *((_WORD *)v5 + 7_Block_object_dispose(va, 8) = *((void *)v36 + 7);
        }

        else
        {
          if (v6 != -15688) {
            return result;
          }
          uint64_t v36 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v37 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v36 + 1);
          *((void *)v5 + 2) = v37;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 16) = result;
          if (result)
          {
            uint64_t v38 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v39 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v38;
            *((_DWORD *)v5 + 22) = v39;
            uint64_t v41 = *((void *)result + 6);
            uint64_t v40 = *((void *)result + 7);
            *((void *)v5 + 21) = *((void *)result + 5);
            *((void *)v5 + 22) = v40;
            *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
            *((void *)v5 + 14) = result + 24;
            *((void *)v5 + 25) = v41;
          }

          *((_WORD *)v5 + 76) = *((void *)v36 + 2);
          v5[158] = *((void *)v36 + 3);
          v5[159] = *((void *)v36 + 4);
          v5[160] = *((void *)v36 + 5);
          *((_WORD *)v5 + 77) = *((void *)v36 + 6);
          *((_WORD *)v5 + 7_Block_object_dispose(va, 8) = *((void *)v36 + 7);
          *((_DWORD *)v5 + 52) = *((_DWORD *)v36 + 18);
        }

        *((void *)v5 + 1_Block_object_dispose(va, 8) = *(void *)v36;
        uint64_t v56 = *((void *)v36 + 8);
      }

      else
      {
        if (v6 <= -15776)
        {
          if (v6 == -15913)
          {
            char v90 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v91 = *(void *)a3;
            *((void *)v5 + 1) = *((void *)v90 + 1);
            *((void *)v5 + 2) = v91;
            *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
            int v92 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *((void *)v5 + 16) = v92;
            if (v92)
            {
              uint64_t v93 = *((void *)v92 + 1);
              *((void *)v5 + 7) = *(void *)v92;
              int v94 = *((_DWORD *)v92 + 4);
              *((_DWORD *)v5 + 21) = v93;
              *((_DWORD *)v5 + 22) = v94;
              uint64_t v96 = *((void *)v92 + 6);
              uint64_t v95 = *((void *)v92 + 7);
              *((void *)v5 + 21) = *((void *)v92 + 5);
              *((void *)v5 + 22) = v95;
              *((_WORD *)v5 + 106) = *((_WORD *)v92 + 40);
              *((void *)v5 + 14) = v92 + 24;
              *((void *)v5 + 25) = v96;
            }

            *((void *)v5 + 5) = *((void *)v90 + 2);
            *((void *)v5 + 23) = *(void *)v90;
            id v97 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v97[24], a2);
            *((void *)v5 + 13) = result;
            return result;
          }

          if (v6 != -15777) {
            return result;
          }
          uint64_t v21 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v22 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v21 + 1);
          *((void *)v5 + 2) = v22;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t v23 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 16) = v23;
          if (v23)
          {
            uint64_t v24 = *((void *)v23 + 1);
            *((void *)v5 + 7) = *(void *)v23;
            int v25 = *((_DWORD *)v23 + 4);
            *((_DWORD *)v5 + 21) = v24;
            *((_DWORD *)v5 + 22) = v25;
            uint64_t v27 = *((void *)v23 + 6);
            uint64_t v26 = *((void *)v23 + 7);
            *((void *)v5 + 21) = *((void *)v23 + 5);
            *((void *)v5 + 22) = v26;
            *((_WORD *)v5 + 106) = *((_WORD *)v23 + 40);
            *((void *)v5 + 14) = v23 + 24;
            *((void *)v5 + 25) = v27;
          }

          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v21[24], a2);
          *((void *)v5 + 13) = result;
          *((void *)v5 + 6) = *(void *)v21;
          uint64_t v28 = *((void *)v21 + 2);
LABEL_91:
          *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v28;
          return result;
        }

        if (v6 == -15775)
        {
          int v70 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v121 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v70 + 1);
          *((void *)v5 + 2) = v121;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 16) = result;
          if (result)
          {
            uint64_t v122 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v123 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v122;
            *((_DWORD *)v5 + 22) = v123;
            uint64_t v125 = *((void *)result + 6);
            uint64_t v124 = *((void *)result + 7);
            *((void *)v5 + 21) = *((void *)result + 5);
            *((void *)v5 + 22) = v124;
            *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
            *((void *)v5 + 14) = result + 24;
            *((void *)v5 + 25) = v125;
          }

          *((_WORD *)v5 + 76) = *((void *)v70 + 2);
          v5[158] = *((void *)v70 + 3);
          v5[159] = *((void *)v70 + 4);
          v5[160] = *((void *)v70 + 5);
          *((_WORD *)v5 + 77) = *((void *)v70 + 6);
          *((_WORD *)v5 + 7_Block_object_dispose(va, 8) = *((void *)v70 + 7);
          *((_DWORD *)v5 + 52) = *((_DWORD *)v70 + 16);
          goto LABEL_117;
        }

        if (v6 != -15690) {
          return result;
        }
        uint64_t v57 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v58 = *(void *)a3;
        *((void *)v5 + 1) = *((void *)v57 + 1);
        *((void *)v5 + 2) = v58;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 16) = result;
        if (result)
        {
          uint64_t v59 = *((void *)result + 1);
          *((void *)v5 + 7) = *(void *)result;
          int v60 = *((_DWORD *)result + 4);
          *((_DWORD *)v5 + 21) = v59;
          *((_DWORD *)v5 + 22) = v60;
          uint64_t v61 = *((void *)result + 6);
          *((void *)v5 + 21) = *((void *)result + 5);
          *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
          *((void *)v5 + 14) = result + 24;
          *((void *)v5 + 25) = v61;
        }

        *((_WORD *)v5 + 76) = *((void *)v57 + 2);
        *((void *)v5 + 1_Block_object_dispose(va, 8) = *(void *)v57;
        uint64_t v56 = *((void *)v57 + 3);
      }
    }

    else
    {
      if (v6 <= -10205)
      {
        if (v6 > -10213)
        {
          if (v6 == -10212)
          {
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
          }

          else if (v6 == -10205)
          {
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            *((_WORD *)v5 + 106) = *((_DWORD *)result + 2);
          }
        }

        else if (v6 == -10227)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 21) = *((void *)result + 1);
        }

        else if (v6 == -10222)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((_DWORD *)v5 + 21) = *((_DWORD *)result + 2);
        }

        return result;
      }

      if (v6 > -10186)
      {
        if (v6 != -10185)
        {
          if (v6 == -10164)
          {
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            *((void *)v5 + 25) = *((void *)result + 1);
          }

          else if (v6 == -7167)
          {
            uint64_t v14 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v15 = *(void *)a3;
            *((void *)v5 + 1) = *((void *)v14 + 1);
            *((void *)v5 + 2) = v15;
            *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *((void *)v5 + 16) = result;
            if (result)
            {
              uint64_t v16 = *((void *)result + 1);
              *((void *)v5 + 7) = *(void *)result;
              int v17 = *((_DWORD *)result + 4);
              *((_DWORD *)v5 + 21) = v16;
              *((_DWORD *)v5 + 22) = v17;
              uint64_t v19 = *((void *)result + 6);
              uint64_t v18 = *((void *)result + 7);
              *((void *)v5 + 21) = *((void *)result + 5);
              *((void *)v5 + 22) = v18;
              *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
              *((void *)v5 + 14) = result + 24;
              *((void *)v5 + 25) = v19;
            }

            *((void *)v5 + 24) = *(void *)v14;
          }

          return result;
        }

        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v28 = *((void *)result + 1);
        goto LABEL_91;
      }

      if (v6 == -10204)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((void *)v5 + 7) = *((void *)result + 1);
        return result;
      }

      if (v6 != -10198) {
        return result;
      }
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v56 = *((void *)result + 1);
    }

    *((void *)v5 + 22) = v56;
    return result;
  }

  if (v6 <= -16197)
  {
    if (v6 > -16241)
    {
      switch(v6)
      {
        case -16240:
          uint64_t v20 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v20[8], a2);
          *((void *)v5 + 9) = result;
          break;
        case -16239:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((_DWORD *)v5 + 22) = *((_DWORD *)result + 2);
          break;
        case -16238:
          *((void *)result + 3) = *(void *)a3;
          break;
        case -16233:
          int v70 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v71 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v70 + 1);
          *((void *)v5 + 2) = v71;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 16) = result;
          if (result)
          {
            uint64_t v72 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v73 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v72;
            *((_DWORD *)v5 + 22) = v73;
            uint64_t v75 = *((void *)result + 6);
            uint64_t v74 = *((void *)result + 7);
            *((void *)v5 + 21) = *((void *)result + 5);
            *((void *)v5 + 22) = v74;
            *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
            *((void *)v5 + 14) = result + 24;
            *((void *)v5 + 25) = v75;
          }

          *((_WORD *)v5 + 76) = *((void *)v70 + 2);
          goto LABEL_117;
        case -16232:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v76 = *((void *)result + 2);
          if (v76 != 1) {
            *((_WORD *)v5 + 49) = v76;
          }
          break;
        default:
          return result;
      }

      return result;
    }

    if (v6 != -16368)
    {
      if (v6 != -16310)
      {
        if (v6 != -16294) {
          return result;
        }
        uint64_t v42 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v43 = *(void *)a3;
        *((void *)v5 + 1) = *((void *)v42 + 1);
        *((void *)v5 + 2) = v43;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        uint64_t v44 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 16) = v44;
        if (v44)
        {
          uint64_t v45 = *((void *)v44 + 1);
          *((void *)v5 + 7) = *(void *)v44;
          int v46 = *((_DWORD *)v44 + 4);
          *((_DWORD *)v5 + 21) = v45;
          *((_DWORD *)v5 + 22) = v46;
          uint64_t v48 = *((void *)v44 + 6);
          uint64_t v47 = *((void *)v44 + 7);
          *((void *)v5 + 21) = *((void *)v44 + 5);
          *((void *)v5 + 22) = v47;
          *((_WORD *)v5 + 106) = *((_WORD *)v44 + 40);
          *((void *)v5 + 14) = v44 + 24;
          *((void *)v5 + 25) = v48;
        }

        *((void *)v5 + 13) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v42[24], a2);
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v42[25], a2);
        *((void *)v5 + 15) = result;
        *((void *)v5 + 19) = *((void *)v42 + 2);
        goto LABEL_109;
      }

      uint64_t v42 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v108 = *(void *)a3;
      *((void *)v5 + 1) = *((void *)v42 + 1);
      *((void *)v5 + 2) = v108;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      id v109 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *((void *)v5 + 16) = v109;
      if (v109)
      {
        uint64_t v110 = *((void *)v109 + 1);
        *((void *)v5 + 7) = *(void *)v109;
        int v111 = *((_DWORD *)v109 + 4);
        *((_DWORD *)v5 + 21) = v110;
        *((_DWORD *)v5 + 22) = v111;
        uint64_t v113 = *((void *)v109 + 6);
        uint64_t v112 = *((void *)v109 + 7);
        *((void *)v5 + 21) = *((void *)v109 + 5);
        *((void *)v5 + 22) = v112;
        *((_WORD *)v5 + 106) = *((_WORD *)v109 + 40);
        *((void *)v5 + 14) = v109 + 24;
        *((void *)v5 + 25) = v113;
      }

      unsigned int v55 = v42[24];
      goto LABEL_108;
    }

    goto LABEL_67;
  }

  if (v6 <= -16099)
  {
    if (v6 <= -16115)
    {
      if (v6 != -16196)
      {
        if (v6 == -16116)
        {
          unint64_t v29 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v30 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v29 + 1);
          *((void *)v5 + 2) = v30;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t v31 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 16) = v31;
          if (v31)
          {
            uint64_t v32 = *((void *)v31 + 1);
            *((void *)v5 + 7) = *(void *)v31;
            int v33 = *((_DWORD *)v31 + 4);
            *((_DWORD *)v5 + 21) = v32;
            *((_DWORD *)v5 + 22) = v33;
            uint64_t v35 = *((void *)v31 + 6);
            uint64_t v34 = *((void *)v31 + 7);
            *((void *)v5 + 21) = *((void *)v31 + 5);
            *((void *)v5 + 22) = v34;
            *((_WORD *)v5 + 106) = *((_WORD *)v31 + 40);
            *((void *)v5 + 14) = v31 + 24;
            *((void *)v5 + 25) = v35;
          }

          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v29[16], a2);
          *((void *)v5 + 13) = result;
          *((void *)v5 + 6) = *(void *)v29;
        }

        return result;
      }

      int v70 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v98 = *(void *)a3;
      *((void *)v5 + 1) = *((void *)v70 + 1);
      *((void *)v5 + 2) = v98;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *((void *)v5 + 16) = result;
      if (result)
      {
        uint64_t v99 = *((void *)result + 1);
        *((void *)v5 + 7) = *(void *)result;
        int v100 = *((_DWORD *)result + 4);
        *((_DWORD *)v5 + 21) = v99;
        *((_DWORD *)v5 + 22) = v100;
        uint64_t v102 = *((void *)result + 6);
        uint64_t v101 = *((void *)result + 7);
        *((void *)v5 + 21) = *((void *)result + 5);
        *((void *)v5 + 22) = v101;
        *((_WORD *)v5 + 106) = *((_WORD *)result + 40);
        *((void *)v5 + 14) = result + 24;
        *((void *)v5 + 25) = v102;
      }

      *((_WORD *)v5 + 76) = *((void *)v70 + 2);
      v5[158] = *((void *)v70 + 3);
      v5[159] = *((void *)v70 + 4);
      v5[160] = *((void *)v70 + 5);
      *((_WORD *)v5 + 77) = *((void *)v70 + 6);
      *((_WORD *)v5 + 7_Block_object_dispose(va, 8) = *((void *)v70 + 7);
LABEL_117:
      *((void *)v5 + 1_Block_object_dispose(va, 8) = *(void *)v70;
      return result;
    }

    if (v6 == -16114)
    {
      result[100] = 1;
      return result;
    }

    if (v6 != -16104) {
      return result;
    }
LABEL_67:
    uint64_t v62 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v63 = *(void *)a3;
    *((void *)v5 + 1) = *((void *)v62 + 1);
    *((void *)v5 + 2) = v63;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
    uint64_t v64 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
    *((void *)v5 + 16) = v64;
    if (v64)
    {
      uint64_t v65 = *((void *)v64 + 1);
      *((void *)v5 + 7) = *(void *)v64;
      int v66 = *((_DWORD *)v64 + 4);
      *((_DWORD *)v5 + 21) = v65;
      *((_DWORD *)v5 + 22) = v66;
      uint64_t v68 = *((void *)v64 + 6);
      uint64_t v67 = *((void *)v64 + 7);
      *((void *)v5 + 21) = *((void *)v64 + 5);
      *((void *)v5 + 22) = v67;
      *((_WORD *)v5 + 106) = *((_WORD *)v64 + 40);
      *((void *)v5 + 14) = v64 + 24;
      *((void *)v5 + 25) = v68;
    }

    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v62[32], a2);
    *((void *)v5 + 13) = result;
    *((void *)v5 + 17) = *(void *)v62;
    *((_DWORD *)v5 + 3_Block_object_dispose(va, 8) = *((void *)v62 + 2);
    *((_DWORD *)v5 + 39) = *((void *)v62 + 3);
    return result;
  }

  if (v6 > -16032)
  {
    if (v6 == -16031)
    {
      uint64_t v42 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v77 = *(void *)a3;
      *((void *)v5 + 1) = *((void *)v42 + 1);
      *((void *)v5 + 2) = v77;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      uint64_t v78 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *((void *)v5 + 16) = v78;
      if (v78)
      {
        uint64_t v79 = *((void *)v78 + 1);
        *((void *)v5 + 7) = *(void *)v78;
        int v80 = *((_DWORD *)v78 + 4);
        *((_DWORD *)v5 + 21) = v79;
        *((_DWORD *)v5 + 22) = v80;
        uint64_t v82 = *((void *)v78 + 6);
        uint64_t v81 = *((void *)v78 + 7);
        *((void *)v5 + 21) = *((void *)v78 + 5);
        *((void *)v5 + 22) = v81;
        *((_WORD *)v5 + 106) = *((_WORD *)v78 + 40);
        *((void *)v5 + 14) = v78 + 24;
        *((void *)v5 + 25) = v82;
      }

      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v42[41], a2);
      *((void *)v5 + 13) = result;
      *((_DWORD *)v5 + 3_Block_object_dispose(va, 8) = *((void *)v42 + 3);
      uint64_t v83 = *((void *)v42 + 4);
    }

    else
    {
      if (v6 != -16030)
      {
        if (v6 == -15980)
        {
          uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v8 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v7 + 1);
          *((void *)v5 + 2) = v8;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t v9 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 16) = v9;
          if (v9)
          {
            uint64_t v10 = *((void *)v9 + 1);
            *((void *)v5 + 7) = *(void *)v9;
            int v11 = *((_DWORD *)v9 + 4);
            *((_DWORD *)v5 + 21) = v10;
            *((_DWORD *)v5 + 22) = v11;
            uint64_t v13 = *((void *)v9 + 6);
            uint64_t v12 = *((void *)v9 + 7);
            *((void *)v5 + 21) = *((void *)v9 + 5);
            *((void *)v5 + 22) = v12;
            *((_WORD *)v5 + 106) = *((_WORD *)v9 + 40);
            *((void *)v5 + 14) = v9 + 24;
            *((void *)v5 + 25) = v13;
          }

          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[24], a2);
          *((void *)v5 + 13) = result;
          *((void *)v5 + 5) = *(void *)v7;
          v5[214] = 1;
        }

        return result;
      }

      uint64_t v42 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v84 = *(void *)a3;
      *((void *)v5 + 1) = *((void *)v42 + 1);
      *((void *)v5 + 2) = v84;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      id v85 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *((void *)v5 + 16) = v85;
      if (v85)
      {
        uint64_t v86 = *((void *)v85 + 1);
        *((void *)v5 + 7) = *(void *)v85;
        int v87 = *((_DWORD *)v85 + 4);
        *((_DWORD *)v5 + 21) = v86;
        *((_DWORD *)v5 + 22) = v87;
        uint64_t v89 = *((void *)v85 + 6);
        uint64_t v88 = *((void *)v85 + 7);
        *((void *)v5 + 21) = *((void *)v85 + 5);
        *((void *)v5 + 22) = v88;
        *((_WORD *)v5 + 106) = *((_WORD *)v85 + 40);
        *((void *)v5 + 14) = v85 + 24;
        *((void *)v5 + 25) = v89;
      }

      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v42[49], a2);
      *((void *)v5 + 13) = result;
      *((_DWORD *)v5 + 3_Block_object_dispose(va, 8) = *((void *)v42 + 4);
      uint64_t v83 = *((void *)v42 + 5);
    }

    *((_DWORD *)v5 + 39) = v83;
LABEL_109:
    *((void *)v5 + 5) = *(void *)v42;
    return result;
  }

  if (v6 != -16098)
  {
    if (v6 != -16096) {
      return result;
    }
    uint64_t v42 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v49 = *(void *)a3;
    *((void *)v5 + 1) = *((void *)v42 + 1);
    *((void *)v5 + 2) = v49;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
    uint64_t v50 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
    *((void *)v5 + 16) = v50;
    if (v50)
    {
      uint64_t v51 = *((void *)v50 + 1);
      *((void *)v5 + 7) = *(void *)v50;
      int v52 = *((_DWORD *)v50 + 4);
      *((_DWORD *)v5 + 21) = v51;
      *((_DWORD *)v5 + 22) = v52;
      uint64_t v54 = *((void *)v50 + 6);
      uint64_t v53 = *((void *)v50 + 7);
      *((void *)v5 + 21) = *((void *)v50 + 5);
      *((void *)v5 + 22) = v53;
      *((_WORD *)v5 + 106) = *((_WORD *)v50 + 40);
      *((void *)v5 + 14) = v50 + 24;
      *((void *)v5 + 25) = v54;
    }

    unsigned int v55 = v42[33];
LABEL_108:
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v55, a2);
    *((void *)v5 + 13) = result;
    goto LABEL_109;
  }

  char v114 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
  uint64_t v115 = *(void *)a3;
  *((void *)v5 + 1) = *((void *)v114 + 1);
  *((void *)v5 + 2) = v115;
  *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
  unint64_t v116 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
  *((void *)v5 + 16) = v116;
  if (v116)
  {
    uint64_t v117 = *((void *)v116 + 1);
    *((void *)v5 + 7) = *(void *)v116;
    int v118 = *((_DWORD *)v116 + 4);
    *((_DWORD *)v5 + 21) = v117;
    *((_DWORD *)v5 + 22) = v118;
    uint64_t v120 = *((void *)v116 + 6);
    uint64_t v119 = *((void *)v116 + 7);
    *((void *)v5 + 21) = *((void *)v116 + 5);
    *((void *)v5 + 22) = v119;
    *((_WORD *)v5 + 106) = *((_WORD *)v116 + 40);
    *((void *)v5 + 14) = v116 + 24;
    *((void *)v5 + 25) = v120;
  }

  uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v114[40], a2);
  *((void *)v5 + 13) = result;
  *((void *)v5 + 17) = *(void *)v114;
  *((_DWORD *)v5 + 3_Block_object_dispose(va, 8) = *((void *)v114 + 2);
  *((_DWORD *)v5 + 39) = *((void *)v114 + 3);
  *((_DWORD *)v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v114 + 4);
  return result;
}

char *GTMTLSMIndirectCommandBuffer_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -10219)
  {
    if (v6 <= -10210)
    {
      if (v6 == -10218)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((void *)v5 + 15) = *((void *)result + 1);
      }

      else if (v6 == -10215)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_DWORD *)v5 + 21) = *((void *)result + 1);
      }
    }

    else
    {
      switch(v6)
      {
        case -10209:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
          break;
        case -10202:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 7) = *((void *)result + 1);
          break;
        case -10166:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 16) = *((void *)result + 1);
          break;
      }
    }
  }

  else
  {
    switch(v6)
    {
      case -15925:
        uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[8], a2);
        *((void *)v5 + 9) = result;
        break;
      case -15924:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_DWORD *)v5 + 22) = *((_DWORD *)result + 2);
        break;
      case -15923:
        *((void *)result + 3) = *(void *)a3;
        break;
      case -15922:
      case -15921:
        return result;
      case -15920:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v15 = *((void *)result + 2);
        if (v15 != 1) {
          *((_WORD *)v5 + 49) = v15;
        }
        break;
      case -15919:
        result[100] = 1;
        break;
      default:
        if (v6 == -15972 || v6 == -15969)
        {
          uint64_t v8 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v9 = *(void *)a3;
          uint64_t v10 = *(void *)v8;
          *((void *)v5 + 1) = *((void *)v8 + 1);
          *((void *)v5 + 2) = v9;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          *((void *)v5 + 5) = v10;
          *((void *)v5 + 13) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v8[32], a2);
          uint64_t v11 = *((void *)v8 + 3);
          *((_DWORD *)v5 + 34) = *((void *)v8 + 2);
          *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = v11;
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 14) = result;
          if (result)
          {
            uint64_t v12 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v13 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v12;
            *((_DWORD *)v5 + 22) = v13;
            uint64_t v14 = *((void *)result + 6);
            *((void *)v5 + 15) = *((void *)result + 3);
            *((void *)v5 + 16) = v14;
          }
        }

        break;
    }
  }

  return result;
}

char *GTMTLSMHeap_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -10212)
  {
    switch(v6)
    {
      case -10211:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
        break;
      case -10208:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_DWORD *)v5 + 1_Block_object_dispose(va, 8) = *((void *)result + 1);
        break;
      case -10207:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_DWORD *)v5 + 19) = *((void *)result + 1);
        break;
    }
  }

  else
  {
    switch(v6)
    {
      case -16120:
        uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v8 = *(void *)a3;
        uint64_t v9 = *(void *)v7;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v8;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v5 + 5) = v9;
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[16], a2);
        *((void *)v5 + 6) = result;
        break;
      case -16119:
        uint64_t v10 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v10[8], a2);
        *((void *)v5 + 7) = result;
        break;
      case -16118:
        *((void *)result + 3) = *(void *)a3;
        break;
      case -16115:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v11 = *((void *)result + 2);
        if (v11 != 1) {
          *((_WORD *)v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v11;
        }
        break;
      default:
        return result;
    }
  }

  return result;
}

char *GTMTLSMDepthStencilState_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  if (v5 == -16320)
  {
    *((void *)result + 3) = *(void *)a3;
  }

  else if (v5 == -16311)
  {
    uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v8 = *(void *)a3;
    uint64_t v9 = *(void *)v7;
    *((void *)v4 + 1) = *((void *)v7 + 1);
    *((void *)v4 + 2) = v8;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
    *((void *)v4 + 5) = v9;
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[16], a2);
    *((void *)v4 + 6) = result;
  }

  return result;
}

char *GTMTLSMSamplerState_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -10227)
  {
    if (v6 == -10226)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
    }

    else if (v6 == -10163)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + 9) = *((void *)result + 1);
    }
  }

  else if (v6 == -16309)
  {
    uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v8 = *(void *)a3;
    *((void *)v5 + 1) = *((void *)v7 + 1);
    *((void *)v5 + 2) = v8;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
    uint64_t v9 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
    *((void *)v5 + 7) = v9;
    if (v9)
    {
      *((void *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v9 + 2);
      *((_OWORD *)v5 + 4) = *(_OWORD *)v9;
    }

    *((void *)v5 + 5) = *(void *)v7;
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[16], a2);
    *((void *)v5 + 6) = result;
  }

  else if (v6 == -16241)
  {
    *((void *)result + 3) = *(void *)a3;
  }

  return result;
}

char *GTMTLSMEvent_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  switch(v5)
  {
    case -15879:
      *((void *)result + 3) = *(void *)a3;
      break;
    case -15880:
      uint64_t v9 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v9[8], a2);
      *((void *)v4 + 6) = result;
      break;
    case -15997:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v7 = *(void *)a3;
      uint64_t v8 = *(void *)result;
      *((void *)v4 + 1) = *((void *)result + 1);
      *((void *)v4 + 2) = v7;
      *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
      *((void *)v4 + 5) = v8;
      break;
  }

  return result;
}

char *GTMTLSMSharedEvent_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 <= -15974)
  {
    switch(v6)
    {
      case -15996:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v11 = *(void *)a3;
        uint64_t v12 = *(void *)result;
        *((void *)v5 + 1) = *((void *)result + 1);
        *((void *)v5 + 2) = v11;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v5 + 5) = v12;
        uint64_t v13 = *((void *)result + 2);
        *((_DWORD *)v5 + 1_Block_object_dispose(va, 8) = *((_DWORD *)result + 6);
        *((void *)v5 + 7) = v13;
        *((void *)v5 + _Block_object_dispose(va, 8) = 0LL;
        return result;
      case -15975:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v9 = *((void *)result + 1);
LABEL_17:
        *((void *)v5 + _Block_object_dispose(va, 8) = v9;
        return result;
      case -15974:
        uint64_t v10 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v10[8], a2);
        *((void *)v5 + 6) = result;
        break;
    }
  }

  else
  {
    if (v6 <= -15910)
    {
      if (v6 == -15973)
      {
        *((void *)result + 3) = *(void *)a3;
        return result;
      }

      if (v6 != -15912) {
        return result;
      }
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v7 = *(void *)a3;
      uint64_t v8 = *(void *)result;
      *((void *)v5 + 1) = *((void *)result + 1);
      *((void *)v5 + 2) = v7;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      *((void *)v5 + 5) = v8;
      *((_DWORD *)v5 + 1_Block_object_dispose(va, 8) = *((_DWORD *)result + 6);
      uint64_t v9 = *((void *)result + 2);
      goto LABEL_17;
    }

    if (v6 == -15909)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v14 = *(void *)a3;
      uint64_t v15 = *(void *)result;
      *((void *)v5 + 1) = *((void *)result + 1);
      *((void *)v5 + 2) = v14;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      *((void *)v5 + 5) = v15;
      *((_DWORD *)v5 + 1_Block_object_dispose(va, 8) = *((_DWORD *)result + 8);
      *(_OWORD *)(v5 + 56) = *((_OWORD *)result + 1);
    }

    else if (v6 == -15907)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + 7) = *((void *)result + 1);
    }
  }

  return result;
}

char *GTMTLSMLateEvalEvent_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  switch(*(_DWORD *)(a3 + 8))
  {
    case 0xFFFFC378:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v6 = *(void *)a3;
      uint64_t v7 = *(void *)result;
      *((void *)v5 + 1) = *((void *)result + 1);
      *((void *)v5 + 2) = v6;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      *((void *)v5 + 5) = v7;
      *((void *)v5 + _Block_object_dispose(va, 8) = 0LL;
      break;
    case 0xFFFFC37D:
      uint64_t v8 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v8[8], a2);
      *((void *)v5 + 6) = result;
      break;
    case 0xFFFFC37E:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
      break;
    case 0xFFFFC37F:
      *((void *)result + 3) = *(void *)a3;
      break;
    default:
      return result;
  }

  return result;
}

char *GTMTLSMFence_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  switch(v6)
  {
    case -16136:
      uint64_t v9 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v9[8], a2);
      *((void *)v5 + 6) = result;
      break;
    case -16127:
      *((void *)result + 3) = *(void *)a3;
      break;
    case -16128:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v7 = *(void *)a3;
      uint64_t v8 = *(void *)result;
      *((void *)v5 + 1) = *((void *)result + 1);
      *((void *)v5 + 2) = v7;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      *((void *)v5 + 5) = v8;
      break;
  }

  return result;
}

char *GTMTLSMCounterSampleBuffer_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 8) == -15848)
  {
    int v5 = result;
    int v6 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v7 = *(void *)a3;
    uint64_t v8 = *(void *)v6;
    *((void *)v5 + 1) = *((void *)v6 + 1);
    *((void *)v5 + 2) = v7;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
    *((void *)v5 + 5) = v8;
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v6[24], a2);
    *((void *)v5 + 6) = result;
  }

  return result;
}

char *GTMTLSMRenderPipelineState_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -15462)
  {
    if (v6 > -10221)
    {
      if (v6 <= -10185)
      {
        if (v6 == -10220)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 12) = *((void *)result + 1);
        }

        else if (v6 == -10192)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((_DWORD *)v5 + 102) = *((_DWORD *)result + 2);
        }
      }

      else
      {
        switch(v6)
        {
          case -10184:
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            *((_DWORD *)v5 + 103) = *((void *)result + 1);
            break;
          case -10172:
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            *((void *)v5 + 5mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)result + 1);
            break;
          case -10165:
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            *((void *)v5 + 14) = *((void *)result + 1);
            break;
        }
      }
    }

    else
    {
      switch(v6)
      {
        case -15406:
        case -15405:
          uint64_t v13 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v14 = *(void *)a3;
          uint64_t v15 = *(void *)v13;
          *((void *)v5 + 1) = *((void *)v13 + 1);
          *((void *)v5 + 2) = v14;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          *((void *)v5 + 5) = v15;
          uint64_t v16 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 7) = v16;
          if (v16)
          {
            int v17 = v16;
            memcpy(v5 + 120, v16 + 216, 0x118uLL);
            *((_OWORD *)v5 + 6) = *(_OWORD *)v17;
            *((_DWORD *)v5 + 102) = *((_DWORD *)v17 + 48);
            *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v17 + 98);
            *((void *)v5 + 14) = *((void *)v17 + 2);
          }

          unsigned int v18 = v13[24];
          goto LABEL_31;
        case -15404:
        case -15403:
          uint64_t v30 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v31 = *(void *)a3;
          uint64_t v32 = *(void *)v30;
          *((void *)v5 + 1) = *((void *)v30 + 1);
          *((void *)v5 + 2) = v31;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          *((void *)v5 + 5) = v32;
          int v33 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 7) = v33;
          if (v33)
          {
            uint64_t v34 = v33;
            memcpy(v5 + 120, v33 + 216, 0x118uLL);
            *((_OWORD *)v5 + 6) = *(_OWORD *)v34;
            *((_DWORD *)v5 + 102) = *((_DWORD *)v34 + 48);
            *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v34 + 98);
            *((void *)v5 + 14) = *((void *)v34 + 2);
          }

          unsigned int v18 = v30[32];
LABEL_31:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v18, a2);
          *((void *)v5 + 9) = result;
          break;
        default:
          if (v6 == -15461)
          {
            uint64_t v40 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v41 = *(void *)a3;
            uint64_t v42 = *(void *)v40;
            *((void *)v5 + 1) = *((void *)v40 + 1);
            *((void *)v5 + 2) = v41;
            *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
            *((void *)v5 + 5) = v42;
            uint64_t v43 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *((void *)v5 + 7) = v43;
            if (v43)
            {
              uint64_t v44 = v43;
              memcpy(v5 + 120, v43 + 216, 0x118uLL);
              *((_OWORD *)v5 + 6) = *(_OWORD *)v44;
              *((_DWORD *)v5 + 102) = *((_DWORD *)v44 + 48);
              *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v44 + 98);
              *((void *)v5 + 14) = *((void *)v44 + 2);
            }

            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v40[24], a2);
            *((void *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
          }

          break;
      }
    }
  }

  else if (v6 > -16092)
  {
    switch(v6)
    {
      case -16091:
      case -16089:
        uint64_t v19 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v20 = *(void *)a3;
        uint64_t v21 = *(void *)v19;
        *((void *)v5 + 1) = *((void *)v19 + 1);
        *((void *)v5 + 2) = v20;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v5 + 5) = v21;
        uint64_t v22 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 7) = v22;
        if (v22)
        {
          uint64_t v23 = v22;
          memcpy(v5 + 120, v22 + 216, 0x118uLL);
          *((_OWORD *)v5 + 6) = *(_OWORD *)v23;
          *((_DWORD *)v5 + 102) = *((_DWORD *)v23 + 48);
          *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v23 + 98);
          *((void *)v5 + 14) = *((void *)v23 + 2);
        }

        unsigned int v24 = v19[24];
        goto LABEL_35;
      case -16090:
      case -16088:
        uint64_t v35 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v36 = *(void *)a3;
        uint64_t v37 = *(void *)v35;
        *((void *)v5 + 1) = *((void *)v35 + 1);
        *((void *)v5 + 2) = v36;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v5 + 5) = v37;
        uint64_t v38 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 7) = v38;
        if (v38)
        {
          int v39 = v38;
          memcpy(v5 + 120, v38 + 216, 0x118uLL);
          *((_OWORD *)v5 + 6) = *(_OWORD *)v39;
          *((_DWORD *)v5 + 102) = *((_DWORD *)v39 + 48);
          *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v39 + 98);
          *((void *)v5 + 14) = *((void *)v39 + 2);
        }

        unsigned int v24 = v35[32];
LABEL_35:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v24, a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = result;
        break;
      default:
        if (v6 == -15738)
        {
          uint64_t v45 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v46 = *(void *)a3;
          uint64_t v47 = *(void *)v45;
          *((void *)v5 + 1) = *((void *)v45 + 1);
          *((void *)v5 + 2) = v46;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          *((void *)v5 + 5) = v47;
          uint64_t v48 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 7) = v48;
          if (v48)
          {
            uint64_t v49 = v48;
            memcpy(v5 + 120, v48 + 216, 0x118uLL);
            *((_OWORD *)v5 + 6) = *(_OWORD *)v49;
            *((_DWORD *)v5 + 102) = *((_DWORD *)v49 + 48);
            *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v49 + 98);
            *((void *)v5 + 14) = *((void *)v49 + 2);
          }

          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v45[32], a2);
          *((void *)v5 + 11) = result;
        }

        break;
    }
  }

  else
  {
    switch(v6)
    {
      case -16303:
      case -16301:
        uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v8 = *(void *)a3;
        uint64_t v9 = *(void *)v7;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v8;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v5 + 5) = v9;
        uint64_t v10 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 7) = v10;
        if (v10)
        {
          uint64_t v11 = v10;
          memcpy(v5 + 120, v10 + 216, 0x118uLL);
          *((_OWORD *)v5 + 6) = *(_OWORD *)v11;
          *((_DWORD *)v5 + 102) = *((_DWORD *)v11 + 48);
          *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v11 + 98);
          *((void *)v5 + 14) = *((void *)v11 + 2);
        }

        unsigned int v12 = v7[24];
        goto LABEL_27;
      case -16302:
      case -16300:
        int v25 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v26 = *(void *)a3;
        uint64_t v27 = *(void *)v25;
        *((void *)v5 + 1) = *((void *)v25 + 1);
        *((void *)v5 + 2) = v26;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v5 + 5) = v27;
        uint64_t v28 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 7) = v28;
        if (v28)
        {
          unint64_t v29 = v28;
          memcpy(v5 + 120, v28 + 216, 0x118uLL);
          *((_OWORD *)v5 + 6) = *(_OWORD *)v29;
          *((_DWORD *)v5 + 102) = *((_DWORD *)v29 + 48);
          *((_DWORD *)v5 + 103) = *((unsigned __int16 *)v29 + 98);
          *((void *)v5 + 14) = *((void *)v29 + 2);
        }

        unsigned int v12 = v25[32];
LABEL_27:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v12, a2);
        *((void *)v5 + 6) = result;
        break;
      default:
        if (v6 == -16242) {
          *((void *)result + 3) = *(void *)a3;
        }
        break;
    }
  }

  return result;
}

char *GTMTLSMComputePipelineState_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -16102)
  {
    if (v6 > -10215)
    {
      if (v6 > -10172)
      {
        if (v6 == -10171)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 22) = *((void *)result + 1);
        }

        else if (v6 == -10162)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 14) = *((void *)result + 1);
        }
      }

      else if (v6 == -10214)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((void *)v5 + 12) = *((void *)result + 1);
      }

      else if (v6 == -10191)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)result + 2);
      }
    }

    else if (v6 > -15741)
    {
      if (v6 == -15740)
      {
        uint64_t v42 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v43 = *(void *)a3;
        uint64_t v44 = *(void *)v42;
        *((void *)v5 + 1) = *((void *)v42 + 1);
        *((void *)v5 + 2) = v43;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v5 + 5) = v44;
        uint64_t v45 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = v45;
        if (v45)
        {
          __int128 v46 = *(_OWORD *)(v45 + 104);
          __int128 v47 = *(_OWORD *)(v45 + 120);
          __int128 v48 = *(_OWORD *)(v45 + 136);
          *((void *)v5 + 21) = *((void *)v45 + 19);
          *(_OWORD *)(v5 + 152) = v48;
          *(_OWORD *)(v5 + 136) = v47;
          *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v46;
          *((_OWORD *)v5 + 6) = *(_OWORD *)v45;
          *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)v45 + 22);
          *((void *)v5 + 14) = *((void *)v45 + 2);
        }

        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v42[32], a2);
        *((void *)v5 + 11) = result;
      }

      else if (v6 == -15541)
      {
        uint64_t v21 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v22 = *(void *)a3;
        uint64_t v23 = *(void *)v21;
        *((void *)v5 + 1) = *((void *)v21 + 1);
        *((void *)v5 + 2) = v22;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v5 + 5) = v23;
        unsigned int v24 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = v24;
        if (v24)
        {
          __int128 v25 = *(_OWORD *)(v24 + 104);
          __int128 v26 = *(_OWORD *)(v24 + 120);
          __int128 v27 = *(_OWORD *)(v24 + 136);
          *((void *)v5 + 21) = *((void *)v24 + 19);
          *(_OWORD *)(v5 + 152) = v27;
          *(_OWORD *)(v5 + 136) = v26;
          *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v25;
          *((_OWORD *)v5 + 6) = *(_OWORD *)v24;
          *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)v24 + 22);
          *((void *)v5 + 14) = *((void *)v24 + 2);
        }

        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v21[24], a2);
        *((void *)v5 + 23) = result;
      }
    }

    else if (v6 == -16101)
    {
      uint64_t v35 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v36 = *(void *)a3;
      uint64_t v37 = *(void *)v35;
      *((void *)v5 + 1) = *((void *)v35 + 1);
      *((void *)v5 + 2) = v36;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      *((void *)v5 + 5) = v37;
      uint64_t v38 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *((void *)v5 + _Block_object_dispose(va, 8) = v38;
      if (v38)
      {
        __int128 v39 = *(_OWORD *)(v38 + 104);
        __int128 v40 = *(_OWORD *)(v38 + 120);
        __int128 v41 = *(_OWORD *)(v38 + 136);
        *((void *)v5 + 21) = *((void *)v38 + 19);
        *(_OWORD *)(v5 + 152) = v41;
        *(_OWORD *)(v5 + 136) = v40;
        *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v39;
        *((_OWORD *)v5 + 6) = *(_OWORD *)v38;
        *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)v38 + 22);
        *((void *)v5 + 14) = *((void *)v38 + 2);
      }

      *((void *)v5 + 9) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v35[24], a2);
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v35[25], a2);
      *((void *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
    }

    else if (v6 == -15989)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + 13) = *((void *)result + 1);
    }
  }

  else
  {
    switch(v6)
    {
      case -16299:
      case -16298:
      case -16297:
      case -16296:
        uint64_t v15 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v16 = *(void *)a3;
        uint64_t v17 = *(void *)v15;
        *((void *)v5 + 1) = *((void *)v15 + 1);
        *((void *)v5 + 2) = v16;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v5 + 5) = v17;
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = result;
        if (result)
        {
          __int128 v18 = *(_OWORD *)(result + 104);
          __int128 v19 = *(_OWORD *)(result + 120);
          __int128 v20 = *(_OWORD *)(result + 136);
          *((void *)v5 + 21) = *((void *)result + 19);
          *(_OWORD *)(v5 + 152) = v20;
          *(_OWORD *)(v5 + 136) = v19;
          *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v18;
          *((_OWORD *)v5 + 6) = *(_OWORD *)result;
          *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)result + 22);
          *((void *)v5 + 14) = *((void *)result + 2);
        }

        *((void *)v5 + 6) = *((void *)v15 + 2);
        break;
      default:
        switch(v6)
        {
          case -16200:
          case -16198:
            uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v8 = *(void *)a3;
            uint64_t v9 = *(void *)v7;
            *((void *)v5 + 1) = *((void *)v7 + 1);
            *((void *)v5 + 2) = v8;
            *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
            *((void *)v5 + 5) = v9;
            uint64_t v10 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *((void *)v5 + _Block_object_dispose(va, 8) = v10;
            if (v10)
            {
              __int128 v11 = *(_OWORD *)(v10 + 104);
              __int128 v12 = *(_OWORD *)(v10 + 120);
              __int128 v13 = *(_OWORD *)(v10 + 136);
              *((void *)v5 + 21) = *((void *)v10 + 19);
              *(_OWORD *)(v5 + 152) = v13;
              *(_OWORD *)(v5 + 136) = v12;
              *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v11;
              *((_OWORD *)v5 + 6) = *(_OWORD *)v10;
              *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)v10 + 22);
              *((void *)v5 + 14) = *((void *)v10 + 2);
            }

            unsigned int v14 = v7[24];
            goto LABEL_31;
          case -16199:
          case -16197:
            uint64_t v28 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v29 = *(void *)a3;
            uint64_t v30 = *(void *)v28;
            *((void *)v5 + 1) = *((void *)v28 + 1);
            *((void *)v5 + 2) = v29;
            *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
            *((void *)v5 + 5) = v30;
            uint64_t v31 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *((void *)v5 + _Block_object_dispose(va, 8) = v31;
            if (v31)
            {
              __int128 v32 = *(_OWORD *)(v31 + 104);
              __int128 v33 = *(_OWORD *)(v31 + 120);
              __int128 v34 = *(_OWORD *)(v31 + 136);
              *((void *)v5 + 21) = *((void *)v31 + 19);
              *(_OWORD *)(v5 + 152) = v34;
              *(_OWORD *)(v5 + 136) = v33;
              *(_OWORD *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v32;
              *((_OWORD *)v5 + 6) = *(_OWORD *)v31;
              *((_DWORD *)v5 + 4_Block_object_dispose(va, 8) = *((_DWORD *)v31 + 22);
              *((void *)v5 + 14) = *((void *)v31 + 2);
            }

            unsigned int v14 = v28[32];
LABEL_31:
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v14, a2);
            *((void *)v5 + 6) = *((void *)result + 106);
            *((void *)v5 + 7) = result;
            break;
          default:
            if (v6 == -16321) {
              *((void *)result + 3) = *(void *)a3;
            }
            break;
        }

        break;
    }
  }

  return result;
}

char *GTMTLSMMotionEstimationPipelineState_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  if (v5 == -15893)
  {
    *((void *)result + 3) = *(void *)a3;
  }

  else if (v5 == -15891)
  {
    uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v8 = *(void *)a3;
    uint64_t v9 = *(void *)v7;
    *((void *)v4 + 1) = *((void *)v7 + 1);
    *((void *)v4 + 2) = v8;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
    *((void *)v4 + 5) = v9;
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[16], a2);
    *((void *)v4 + 6) = result;
  }

  return result;
}

uint64_t GTMTLSMFunction_processTraceFuncWithPool(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -15731)
  {
    if (v6 > -15551)
    {
      switch(v6)
      {
        case -15430:
        case -15428:
          goto LABEL_20;
        case -15429:
        case -15427:
          goto LABEL_22;
        default:
          if (v6 == -15550)
          {
            uint64_t v57 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v58 = *(void *)a3;
            uint64_t v59 = *(void *)v57;
            *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v57 + 1);
            *(void *)(v5 + 16) = v58;
            *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
            *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v59;
            int v60 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v60;
            if (v60) {
              uint64_t v61 = *(void *)v60;
            }
            else {
              uint64_t v61 = 0LL;
            }
            *(void *)(v5 + 64) = v61;
            unsigned int v62 = v57[24];
            goto LABEL_89;
          }

          if (v6 != -10157) {
            return result;
          }
          unsigned int v41 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2)[16];
          break;
      }
    }

    else
    {
      if (v6 > -15609)
      {
        if (v6 != -15608)
        {
          if (v6 == -15551)
          {
            uint64_t v21 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v22 = *(void *)a3;
            uint64_t v23 = *(void *)v21;
            *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v21 + 1);
            *(void *)(v5 + 16) = v22;
            *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
            *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v23;
            unsigned int v24 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v24;
            if (v24) {
              uint64_t v25 = *(void *)v24;
            }
            else {
              uint64_t v25 = 0LL;
            }
            *(void *)(v5 + 64) = v25;
            unsigned int v62 = v21[32];
LABEL_89:
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v62, a2);
            *(void *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
          }

          return result;
        }
      }

      else
      {
        if (v6 == -15730)
        {
LABEL_22:
          __int128 v12 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v17 = *(void *)a3;
          uint64_t v18 = *(void *)v12;
          *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v12 + 1);
          *(void *)(v5 + 16) = v17;
          *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
          *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v18;
          __int128 v19 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v19;
          if (v19) {
            uint64_t v20 = *(void *)v19;
          }
          else {
            uint64_t v20 = 0LL;
          }
          *(void *)(v5 + 64) = v20;
          *(_BYTE *)(v5 + 132) = 1;
          unsigned int v42 = v12[24];
          if (g_loadURLAsMemHeader)
          {
            if (v42 < 0x40) {
              uint64_t Header = 0LL;
            }
            else {
              uint64_t Header = GTTraceMemPool_findHeader(a2, *(void *)a3, v42);
            }
          }

          else
          {
            uint64_t Header = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v42, a2);
          }

          *(void *)(v5 + 8_Block_object_dispose(va, 8) = Header;
          unsigned int v56 = v12[25];
          if (g_loadURLAsMemHeader)
          {
            if (v56 < 0x40) {
              uint64_t result = 0LL;
            }
            else {
              uint64_t result = GTTraceMemPool_findHeader(a2, *(void *)a3, v56);
            }
          }

          else
          {
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v12[25], a2);
          }

          *(void *)(v5 + 96) = result;
          goto LABEL_71;
        }

        if (v6 != -15609) {
          return result;
        }
      }

      __int128 v26 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v27 = *(void *)a3;
      uint64_t v28 = *(void *)v26;
      *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v26 + 1);
      *(void *)(v5 + 16) = v27;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v28;
      uint64_t v29 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v29;
      if (v29) {
        uint64_t v30 = *(void *)v29;
      }
      else {
        uint64_t v30 = 0LL;
      }
      *(void *)(v5 + 64) = v30;
      unsigned int v41 = v26[24];
    }

    uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v41, a2);
    *(void *)(v5 + 112) = result;
    return result;
  }

  if (v6 <= -16083)
  {
    if (v6 <= -16124)
    {
      if (v6 == -16293)
      {
        *(void *)(result + 24) = *(void *)a3;
      }

      else if (v6 == -16290)
      {
        uint64_t v31 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v32 = *(void *)a3;
        uint64_t v33 = *(void *)v31;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v31 + 1);
        *(void *)(v5 + 16) = v32;
        *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v33;
        __int128 v34 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v34;
        if (v34) {
          uint64_t v35 = *(void *)v34;
        }
        else {
          uint64_t v35 = 0LL;
        }
        *(void *)(v5 + 64) = v35;
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v31[16], a2);
        *(void *)(v5 + 56) = result;
      }
    }

    else if (v6 == -16123)
    {
      uint64_t v44 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v44[8], a2);
      *(void *)(v5 + 64) = result;
    }

    else if (v6 == -16107 || v6 == -16106)
    {
      uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v8 = *(void *)a3;
      uint64_t v9 = *(void *)v7;
      *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v7 + 1);
      *(void *)(v5 + 16) = v8;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v9;
      uint64_t v10 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v10;
      if (v10) {
        uint64_t v11 = *(void *)v10;
      }
      else {
        uint64_t v11 = 0LL;
      }
      *(void *)(v5 + 64) = v11;
      *(void *)(v5 + 56) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[24], a2);
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[25], a2);
      *(void *)(v5 + 72) = result;
    }

    return result;
  }

  if (v6 > -16039)
  {
    if (v6 == -16038)
    {
      uint64_t v45 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v46 = *(void *)a3;
      uint64_t v47 = *(void *)v45;
      *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v45 + 1);
      *(void *)(v5 + 16) = v46;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v47;
      __int128 v48 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v48;
      if (v48) {
        uint64_t v49 = *(void *)v48;
      }
      else {
        uint64_t v49 = 0LL;
      }
      *(void *)(v5 + 64) = v49;
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v45[16], a2);
      *(void *)(v5 + 56) = result;
      *(_BYTE *)(v5 + 131) = 1;
      return result;
    }

    if (v6 == -15830)
    {
      uint64_t v50 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v51 = *(void *)a3;
      uint64_t v52 = *(void *)v50;
      *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v50 + 1);
      *(void *)(v5 + 16) = v51;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v52;
      uint64_t v53 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v53;
      if (v53) {
        uint64_t v54 = *(void *)v53;
      }
      else {
        uint64_t v54 = 0LL;
      }
      *(void *)(v5 + 64) = v54;
      *(void *)(v5 + 56) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v50[18], a2);
      *(_BYTE *)(v5 + 132) = 1;
      unsigned int v63 = v50[16];
      if (g_loadURLAsMemHeader)
      {
        if (v63 < 0x40) {
          uint64_t result = 0LL;
        }
        else {
          uint64_t result = GTTraceMemPool_findHeader(a2, *(void *)a3, v63);
        }
      }

      else
      {
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v63, a2);
      }

      *(void *)(v5 + 104) = result;
      *(_BYTE *)(v5 + 13mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v50[17];
      return result;
    }

    if (v6 != -15731) {
      return result;
    }
LABEL_20:
    __int128 v12 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v13 = *(void *)a3;
    uint64_t v14 = *(void *)v12;
    *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v12 + 1);
    *(void *)(v5 + 16) = v13;
    *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
    *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v14;
    uint64_t v15 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
    *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v15;
    if (v15) {
      uint64_t v16 = *(void *)v15;
    }
    else {
      uint64_t v16 = 0LL;
    }
    *(void *)(v5 + 64) = v16;
    *(_BYTE *)(v5 + 132) = 1;
    unsigned int v55 = v12[24];
    if (g_loadURLAsMemHeader)
    {
      if (v55 < 0x40) {
        uint64_t result = 0LL;
      }
      else {
        uint64_t result = GTTraceMemPool_findHeader(a2, *(void *)a3, v55);
      }
    }

    else
    {
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v55, a2);
    }

    *(void *)(v5 + 8_Block_object_dispose(va, 8) = result;
LABEL_71:
    *(_WORD *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v12 + 2);
    return result;
  }

  if (v6 == -16082 || v6 == -16081)
  {
    uint64_t v36 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v37 = *(void *)a3;
    uint64_t v38 = *(void *)v36;
    *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v36 + 1);
    *(void *)(v5 + 16) = v37;
    *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
    *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v38;
    __int128 v39 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
    *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v39;
    if (v39) {
      uint64_t v40 = *(void *)v39;
    }
    else {
      uint64_t v40 = 0LL;
    }
    *(void *)(v5 + 64) = v40;
    *(void *)(v5 + 56) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v36[32], a2);
    uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v36[33], a2);
    *(void *)(v5 + 72) = result;
    *(void *)(v5 + 4_Block_object_dispose(va, 8) = *((void *)v36 + 2);
  }

  return result;
}

char *GTMTLSMIndirectComputeCommand_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  if (v5 == -15935)
  {
    *((void *)result + 3) = *(void *)a3;
  }

  else if (v5 == -15921)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v6 = *(void *)a3;
    uint64_t v7 = *(void *)result;
    *((void *)v4 + 1) = *((void *)result + 1);
    *((void *)v4 + 2) = v6;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
    uint64_t v8 = *((void *)result + 2);
    *((void *)v4 + 5) = v7;
    *((void *)v4 + 6) = v8;
  }

  return result;
}

char *GTMTLSMIndirectRenderCommand_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  if (v5 == -15957)
  {
    *((void *)result + 3) = *(void *)a3;
  }

  else if (v5 == -15922)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v6 = *(void *)a3;
    uint64_t v7 = *(void *)result;
    *((void *)v4 + 1) = *((void *)result + 1);
    *((void *)v4 + 2) = v6;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
    uint64_t v8 = *((void *)result + 2);
    *((void *)v4 + 5) = v7;
    *((void *)v4 + 6) = v8;
  }

  return result;
}

uint64_t GTMTLSMLibrary_processTraceFuncWithPool(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 <= -16030)
  {
    if (v6 > -16293)
    {
      if (v6 <= -16096)
      {
        if (v6 == -16292)
        {
          uint64_t v57 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v57[8], a2);
          *(void *)(v5 + 112) = result;
        }

        else if (v6 == -16291)
        {
          *(void *)(result + 24) = *(void *)a3;
        }
      }

      else
      {
        switch(v6)
        {
          case -16095:
            uint64_t v50 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v51 = *(void *)a3;
            uint64_t v52 = *(void *)v50;
            *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v50 + 1);
            *(void *)(v5 + 16) = v51;
            *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
            *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v52;
            uint64_t v53 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *(void *)(v5 + 64) = v53;
            if (v53)
            {
              *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v53 + 1);
              *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v53[16];
            }

            *(_BYTE *)(v5 + 161) = 0;
            unsigned int v34 = v50[24];
LABEL_65:
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v34, a2);
            *(void *)(v5 + 96) = result;
            uint64_t v54 = *(void **)(v5 + 64);
            if (v54) {
              uint64_t v54 = (void *)*v54;
            }
            *(void *)(v5 + memset(v68, 0, 144) = v54;
            break;
          case -16083:
            unsigned int v55 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v55[8], a2);
            *(void *)(v5 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
            break;
          case -16039:
LABEL_24:
            uint64_t v14 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v15 = *(void *)a3;
            uint64_t v16 = *(void *)v14;
            *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v14 + 1);
            *(void *)(v5 + 16) = v15;
            *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
            *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v16;
            uint64_t v17 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *(void *)(v5 + 64) = v17;
            if (v17)
            {
              *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v17 + 1);
              *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v17[16];
            }

            *(_BYTE *)(v5 + 161) = 1;
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v14[24], a2);
            *(void *)(v5 + 96) = result;
            uint64_t v18 = *(void **)(v5 + 64);
            if (v18) {
              uint64_t v18 = (void *)*v18;
            }
            *(void *)(v5 + 136) = v18;
            break;
        }
      }
    }

    else
    {
      switch(v6)
      {
        case -16308:
          uint64_t v30 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v31 = *(void *)a3;
          uint64_t v32 = *(void *)v30;
          *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v30 + 1);
          *(void *)(v5 + 16) = v31;
          *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
          *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v32;
          uint64_t v33 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *(void *)(v5 + 64) = v33;
          if (v33)
          {
            *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v33 + 1);
            *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v33[16];
          }

          *(_BYTE *)(v5 + 161) = 0;
          unsigned int v34 = v30[16];
          goto LABEL_65;
        case -16307:
          goto LABEL_24;
        case -16306:
          uint64_t v35 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v36 = *(void *)a3;
          uint64_t v37 = *(void *)v35;
          *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v35 + 1);
          *(void *)(v5 + 16) = v36;
          *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
          *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v37;
          uint64_t v38 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *(void *)(v5 + 64) = v38;
          if (v38)
          {
            *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v38 + 1);
            *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v38[16];
          }

          *(_BYTE *)(v5 + 161) = 3;
          unsigned int v39 = v35[24];
          if (g_loadURLAsMemHeader)
          {
            if (v39 < 0x40) {
              uint64_t result = 0LL;
            }
            else {
              uint64_t result = GTTraceMemPool_findHeader(a2, *(void *)a3, v39);
            }
          }

          else
          {
            uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v39, a2);
          }

          *(void *)(v5 + 96) = result;
          break;
        case -16305:
        case -16304:
          uint64_t v8 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v9 = *(void *)a3;
          uint64_t v10 = *(void *)v8;
          *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v8 + 1);
          *(void *)(v5 + 16) = v9;
          *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
          *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v10;
          uint64_t v11 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *(void *)(v5 + 64) = v11;
          if (v11)
          {
            *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v11 + 1);
            *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v11[16];
          }

          *(_BYTE *)(v5 + 161) = 2;
          unsigned int v12 = v8[24];
          if (g_loadURLAsMemHeader)
          {
            if (v12 < 0x40) {
              uint64_t Header = 0LL;
            }
            else {
              uint64_t Header = GTTraceMemPool_findHeader(a2, *(void *)a3, v12);
            }
          }

          else
          {
            uint64_t Header = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v12, a2);
          }

          *(void *)(v5 + 96) = Header;
          uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v8[25], a2);
          *(void *)(v5 + 104) = result;
          break;
        default:
          return result;
      }
    }
  }

  else
  {
    if (v6 <= -15435)
    {
      if (v6 <= -15848)
      {
        if (v6 != -16029 && v6 != -16018) {
          return result;
        }
        uint64_t v23 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v24 = *(void *)a3;
        uint64_t v25 = *(void *)v23;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v23 + 1);
        *(void *)(v5 + 16) = v24;
        *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v25;
        __int128 v26 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *(void *)(v5 + 64) = v26;
        if (v26)
        {
          *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v26 + 1);
          *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v26[16];
        }

        *(_BYTE *)(v5 + 161) = 4;
        uint64_t v27 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v23[24], a2);
        if (v27)
        {
          uint64_t v28 = *(void *)v27;
          *(void *)(v5 + 4_Block_object_dispose(va, 8) = v27 + 8;
          *(_DWORD *)(v5 + 152) = v28;
        }

        unsigned int v29 = v23[25];
      }

      else
      {
        if (v6 != -15847)
        {
          if (v6 == -15693)
          {
            uint64_t v44 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v45 = *(void *)a3;
            uint64_t v46 = *(void *)v44;
            *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v44 + 1);
            *(void *)(v5 + 16) = v45;
            *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
            *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v46;
            uint64_t v47 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *(void *)(v5 + 64) = v47;
            if (v47)
            {
              *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v47 + 1);
              *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v47[16];
            }

            *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v44[24], a2);
            __int128 v48 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v44[25], a2);
            uint64_t v49 = *(void *)v48;
            uint64_t result = (uint64_t)(v48 + 8);
            *(void *)(v5 + 8_Block_object_dispose(va, 8) = result;
            *(_DWORD *)(v5 + 156) = v49;
            goto LABEL_36;
          }

          int v7 = -15435;
          goto LABEL_18;
        }

        uint64_t v40 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v41 = *(void *)a3;
        uint64_t v42 = *(void *)v40;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v40 + 1);
        *(void *)(v5 + 16) = v41;
        *(_DWORD *)(v5 + 4) = *(_DWORD *)(a3 + 8);
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v42;
        uint64_t v43 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *(void *)(v5 + 64) = v43;
        if (v43)
        {
          *(void *)(v5 + 12_Block_object_dispose(va, 8) = *((void *)v43 + 1);
          *(_BYTE *)(v5 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v43[16];
        }

        *(_BYTE *)(v5 + 161) = 5;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v40[32], a2);
        *(_DWORD *)(v5 + 152) = *((void *)v40 + 2);
        unsigned int v29 = v40[33];
      }

      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v29, a2);
      *(void *)(v5 + 56) = result;
      return result;
    }

    if (v6 <= -15420)
    {
      if (v6 != -15434 && v6 != -15421)
      {
        int v7 = -15420;
LABEL_18:
        if (v6 != v7) {
          return result;
        }
      }

char *GTMTLSMDynamicLibrary_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -15676)
  {
    if (v6 == -15675)
    {
      *((void *)result + 3) = *(void *)a3;
    }

    else if (v6 == -15613)
    {
      uint64_t v8 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v9 = *(void *)a3;
      uint64_t v10 = *(void *)v8;
      *((void *)v5 + 1) = *((void *)v8 + 1);
      *((void *)v5 + 2) = v9;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      *((void *)v5 + 5) = v10;
      uint64_t v11 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      if (v11)
      {
        *((void *)v5 + 9) = *(void *)v11;
        *(_OWORD *)(v5 + 8_Block_object_dispose(va, 8) = *(_OWORD *)(v11 + 8);
        *((_WORD *)v5 + 52) = *((_WORD *)v11 + 12);
      }

      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v8[24], a2);
      *((void *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = result;
    }
  }

  else if (v6 == -15695)
  {
    unsigned int v12 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v13 = *(void *)a3;
    uint64_t v14 = *(void *)v12;
    *((void *)v5 + 1) = *((void *)v12 + 1);
    *((void *)v5 + 2) = v13;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
    *((void *)v5 + 5) = v14;
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
    if (result)
    {
      *((void *)v5 + 9) = *(void *)result;
      *(_OWORD *)(v5 + 8_Block_object_dispose(va, 8) = *(_OWORD *)(result + 8);
      *((_WORD *)v5 + 52) = *((_WORD *)result + 12);
    }

    *((void *)v5 + 6) = *((void *)v12 + 2);
  }

  else if (v6 == -15676)
  {
    int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[8], a2);
    *((void *)v5 + _Block_object_dispose(va, 8) = result;
  }

  return result;
}

char *GTMTLSMPipelineLibrary_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -15745)
  {
    if (v6 == -15744)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      v5[82] = *((_DWORD *)result + 2);
    }

    else if (v6 == -15743)
    {
      uint64_t v10 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v10[8], a2);
      *((void *)v5 + 7) = result;
    }
  }

  else if (v6 == -16291)
  {
    *((void *)result + 3) = *(void *)a3;
  }

  else if (v6 == -16075)
  {
    int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v8 = *(void *)a3;
    uint64_t v9 = *(void *)v7;
    *((void *)v5 + 1) = *((void *)v7 + 1);
    *((void *)v5 + 2) = v8;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
    *((void *)v5 + 5) = v9;
    *((void *)v5 + 6) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[24], a2);
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
    if (result)
    {
      *((_WORD *)v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((_WORD *)result + 12);
      *((_OWORD *)v5 + 4) = *(_OWORD *)(result + 8);
    }
  }

  return result;
}

char *GTMTLSMIOCommandQueue_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  if (v5 == -15332)
  {
    *((void *)result + 3) = *(void *)a3;
  }

  else if (v5 == -15350)
  {
    int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v8 = *(void *)a3;
    uint64_t v9 = *(void *)v7;
    *((void *)v4 + 1) = *((void *)v7 + 1);
    *((void *)v4 + 2) = v8;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
    *((void *)v4 + 5) = v9;
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[24], a2);
    *((void *)v4 + 7) = result;
  }

  return result;
}

char *GTMTLSMCommandQueue_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 <= -16316)
  {
    switch(v6)
    {
      case -16349:
        int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[8], a2);
        *((void *)v5 + 6) = result;
        break;
      case -16348:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_DWORD *)v5 + 17) = *((_DWORD *)result + 2);
        break;
      case -16347:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        v5[75] = *((_DWORD *)result + 2);
        break;
      case -16346:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        v5[76] = *((_DWORD *)result + 2);
        break;
      case -16345:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        v5[74] = *((_DWORD *)result + 2);
        break;
      case -16344:
        *((void *)result + 3) = *(void *)a3;
        break;
      default:
        if (v6 == -16316)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v12 = *(void *)a3;
          uint64_t v13 = *(void *)result;
          *((void *)v5 + 1) = *((void *)result + 1);
          *((void *)v5 + 2) = v12;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          *((void *)v5 + 5) = v13;
          int v11 = 64;
LABEL_12:
          *((_DWORD *)v5 + 16) = v11;
        }

        break;
    }
  }

  else
  {
    switch(v6)
    {
      case -15809:
      case -15808:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        v5[73] = *((void *)result + 1);
        break;
      case -15807:
        return result;
      case -15806:
      case -15805:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        v5[72] = *((void *)result + 1);
        break;
      default:
        if (v6 == -16315)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v14 = *(void *)a3;
          uint64_t v15 = *(void *)result;
          *((void *)v5 + 1) = *((void *)result + 1);
          *((void *)v5 + 2) = v14;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          *((void *)v5 + 5) = v15;
          *((_DWORD *)v5 + 16) = *((void *)result + 2);
        }

        else if (v6 == -16165)
        {
          uint64_t v8 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v9 = *(void *)a3;
          uint64_t v10 = *(void *)v8;
          *((void *)v5 + 1) = *((void *)v8 + 1);
          *((void *)v5 + 2) = v9;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          *((void *)v5 + 5) = v10;
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v8[16], a2);
          *((void *)v5 + 7) = result;
          int v11 = *(_DWORD *)result;
          goto LABEL_12;
        }

        break;
    }
  }

  return result;
}

char *GTMTLSMRasterizationRateMap_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  switch(v5)
  {
    case -15801:
      *((void *)result + 3) = *(void *)a3;
      break;
    case -15411:
      uint64_t v10 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v10[8], a2);
      *((void *)v4 + 6) = result;
      break;
    case -15793:
      int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v8 = *(void *)a3;
      uint64_t v9 = *(void *)v7;
      *((void *)v4 + 1) = *((void *)v7 + 1);
      *((void *)v4 + 2) = v8;
      *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
      *((void *)v4 + 5) = v9;
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[16], a2);
      *((void *)v4 + 6) = result;
      *((_DWORD *)v4 + 14) = *((_DWORD *)result + 6);
      v4[60] = result[34];
      break;
  }

  return result;
}

char *GTMTLSMDevice_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  if (v5 == -10239)
  {
    int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    *((void *)v4 + 1) = *(void *)v7;
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[8], a2);
    *((void *)v4 + 5) = result;
  }

  else if (v5 == -16317)
  {
    *((void *)result + 3) = *(void *)a3;
  }

  return result;
}

uint64_t GTMTLSMFilter_processTraceFuncWithPool(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 <= -6123)
  {
    switch(v6)
    {
      case -6143:
LABEL_5:
        uint64_t v10 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v11 = *(void *)a3;
        uint64_t v12 = *(void *)v10;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v10 + 1);
        *(void *)(v5 + 16) = v11;
        uint64_t v13 = *(unsigned int *)(a3 + 8);
        *(_DWORD *)(v5 + 4) = v13;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v13;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v12;
        *(void *)(v5 + 56) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v10[16], a2);
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v10[24], a2);
        *(void *)(v5 + 64) = result;
        break;
      case -6141:
LABEL_9:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v18 = *(void *)a3;
        uint64_t v19 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v18;
        uint64_t v20 = *(unsigned int *)(a3 + 8);
        *(_DWORD *)(v5 + 4) = v20;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v20;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v19;
        *(void *)(v5 + 56) = *(void *)(result + 16);
        *(void *)(v5 + 64) = *(void *)(result + 24);
        *(void *)(v5 + 72) = *(void *)(result + 32);
        *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 40);
        break;
      case -6139:
        *(void *)(result + 24) = *(void *)a3;
        break;
      case -6134:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v28 = *(void *)a3;
        uint64_t v29 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v28;
        uint64_t v30 = *(unsigned int *)(a3 + 8);
        *(_DWORD *)(v5 + 4) = v30;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v30;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v29;
        *(_BYTE *)(v5 + 96) = *(_DWORD *)(result + 16);
        *(void *)(v5 + 56) = *(void *)(result + 24);
        *(void *)(v5 + 64) = *(void *)(result + 32);
        *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 40);
        uint64_t v24 = *(void *)(result + 48);
LABEL_14:
        *(void *)(v5 + 8_Block_object_dispose(va, 8) = v24;
        break;
      case -6133:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v31 = *(void *)a3;
        uint64_t v32 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v31;
        uint64_t v33 = *(unsigned int *)(a3 + 8);
        *(_DWORD *)(v5 + 4) = v33;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v33;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v32;
        *(void *)(v5 + 56) = *(int *)(result + 16);
        *(_DWORD *)(v5 + 64) = *(_DWORD *)(result + 20);
        *(_DWORD *)(v5 + 6_Block_object_dispose(va, 8) = *(_DWORD *)(result + 24);
        *(_DWORD *)(v5 + 72) = *(_DWORD *)(result + 28);
        break;
      case -6131:
        unsigned int v34 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v35 = *(void *)a3;
        uint64_t v36 = *(void *)v34;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v34 + 1);
        *(void *)(v5 + 16) = v35;
        uint64_t v37 = *(unsigned int *)(a3 + 8);
        *(_DWORD *)(v5 + 4) = v37;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v37;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v36;
        *(void *)(v5 + 56) = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v34[16], a2);
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v34[24], a2);
        *(void *)(v5 + 64) = result;
        *(_BYTE *)(v5 + 72) = *((_DWORD *)v34 + 8);
        break;
      case -6129:
        uint64_t v38 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v39 = *(void *)a3;
        uint64_t v40 = *(void *)v38;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v38 + 1);
        *(void *)(v5 + 16) = v39;
        uint64_t v41 = *(unsigned int *)(a3 + 8);
        *(_DWORD *)(v5 + 4) = v41;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v41;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v40;
        *(void *)(v5 + 56) = *((int *)v38 + 4);
        unsigned int v42 = v38[24];
        if (g_loadURLAsMemHeader)
        {
          if (v42 < 0x40) {
            uint64_t result = 0LL;
          }
          else {
            uint64_t result = GTTraceMemPool_findHeader(a2, *(void *)a3, v42);
          }
        }

        else
        {
          uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v42, a2);
        }

        *(void *)(v5 + 72) = result;
        *(void *)(v5 + 64) = *((void *)v38 + 4);
        break;
      default:
        return result;
    }
  }

  else
  {
    switch(v6)
    {
      case -6122:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v21 = *(void *)a3;
        uint64_t v22 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v21;
        uint64_t v23 = *(unsigned int *)(a3 + 8);
        *(_DWORD *)(v5 + 4) = v23;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v23;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v22;
        *(_BYTE *)(v5 + 96) = *(_DWORD *)(result + 16);
        *(_BYTE *)(v5 + 97) = *(_DWORD *)(result + 20);
        *(void *)(v5 + 56) = *(void *)(result + 24);
        *(void *)(v5 + 64) = *(void *)(result + 32);
        *(void *)(v5 + 72) = *(void *)(result + 40);
        *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 48);
        uint64_t v24 = *(void *)(result + 56);
        goto LABEL_14;
      case -6121:
      case -6120:
      case -6118:
      case -6117:
      case -6115:
      case -6114:
      case -6113:
      case -6112:
        return result;
      case -6119:
      case -6110:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v7 = *(void *)a3;
        uint64_t v8 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v7;
        uint64_t v9 = *(unsigned int *)(a3 + 8);
        *(_DWORD *)(v5 + 4) = v9;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v9;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v8;
        break;
      case -6116:
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v25 = *(void *)a3;
        uint64_t v26 = *(void *)result;
        *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)(result + 8);
        *(void *)(v5 + 16) = v25;
        uint64_t v27 = *(unsigned int *)(a3 + 8);
        *(_DWORD *)(v5 + 4) = v27;
        *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v27;
        *(void *)(v5 + 4_Block_object_dispose(va, 8) = v26;
        *(void *)(v5 + 56) = *(void *)(result + 16);
        *(void *)(v5 + 64) = *(void *)(result + 24);
        *(void *)(v5 + 72) = *(void *)(result + 32);
        *(void *)(v5 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 40);
        *(void *)(v5 + 8_Block_object_dispose(va, 8) = *(void *)(result + 48);
        *(void *)(v5 + 96) = *(void *)(result + 56);
        break;
      case -6111:
        goto LABEL_5;
      case -6109:
        goto LABEL_9;
      default:
        if (v6 == -6096 || v6 == -6095)
        {
          uint64_t v14 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v15 = *(void *)a3;
          uint64_t v16 = *(void *)v14;
          *(void *)(v5 + _Block_object_dispose(va, 8) = *((void *)v14 + 1);
          *(void *)(v5 + 16) = v15;
          uint64_t v17 = *(unsigned int *)(a3 + 8);
          *(_DWORD *)(v5 + 4) = v17;
          *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v17;
          *(void *)(v5 + 4_Block_object_dispose(va, 8) = v16;
          uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v14[16], a2);
          *(void *)(v5 + 56) = result;
        }

        break;
    }
  }

  return result;
}

char *GTMTLSMResourceGroup_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  if (v5 == -15769)
  {
    *((void *)result + 3) = *(void *)a3;
  }

  else if (v5 == -15900)
  {
    uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v8 = *(void *)a3;
    uint64_t v9 = *(void *)v7;
    *((void *)v4 + 1) = *((void *)v7 + 1);
    *((void *)v4 + 2) = v8;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
    *((void *)v4 + 5) = v9;
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[24], a2);
    *((void *)v4 + 6) = result;
    *((_DWORD *)v4 + 14) = *((void *)v7 + 2);
  }

  return result;
}

char *GTMTLSMDrawable_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  if (v5 > -7162)
  {
    if (v5 == -7161)
    {
      *((void *)result + 3) = *(void *)a3;
    }

    else if (v5 == -6655)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v8 = *(void *)a3;
      *((void *)v4 + 1) = *((void *)result + 1);
      *((void *)v4 + 2) = v8;
      *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
    }
  }

  else if (v5 == -7167)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    *((void *)v4 + 6) = *((void *)result + 1);
  }

  else if (v5 == -7166)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v6 = *(void *)a3;
    uint64_t v7 = *(void *)result;
    *((void *)v4 + 1) = *((void *)result + 1);
    *((void *)v4 + 2) = v6;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
    *((void *)v4 + 5) = v7;
  }

  return result;
}

uint64_t GTMTLSMLayer_processTraceFuncWithPool(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  switch(v6)
  {
    case -7165:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *(_WORD *)(v5 + 272) = *(void *)(result + 8);
      break;
    case -7164:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *(void *)(v5 + 176) = *(void *)(result + 8);
      *(void *)(v5 + 184) = *(void *)(result + 16);
      break;
    case -7163:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v7 = *(void *)a3;
      uint64_t v8 = *(void *)(result + 8);
      *(void *)(v5 + _Block_object_dispose(va, 8) = *(void *)result;
      *(void *)(v5 + 16) = v7;
      *(void *)(v5 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v8;
      break;
    case -7162:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      for (uint64_t i = 0LL; i != 32; i += 8LL)
        *(void *)(v5 + 216 + i) = *(void *)(result + 8 + i);
      goto LABEL_14;
    case -7161:
    case -7158:
    case -7157:
    case -7156:
    case -7155:
      return result;
    case -7160:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *(_BYTE *)(v5 + 274) = *(_DWORD *)(result + 8);
      break;
    case -7159:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      for (uint64_t j = 0LL; j != 32; j += 8LL)
        *(void *)(v5 + 216 + j) = *(void *)(result + 8 + j);
LABEL_14:
      *(void *)(v5 + 20_Block_object_dispose(va, 8) = *(void *)(result + 40);
      break;
    case -7154:
      uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *(_BYTE *)(v5 + 275) = *(_DWORD *)(result + 8);
      break;
    case -7153:
      unsigned int v11 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2)[8];
      if (g_loadURLAsMemHeader)
      {
        if (v11 < 0x40) {
          uint64_t result = 0LL;
        }
        else {
          uint64_t result = GTTraceMemPool_findHeader(a2, *(void *)a3, v11);
        }
      }

      else
      {
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v11, a2);
      }

      *(void *)(v5 + 264) = result;
      break;
    default:
      if (v6 == -8183)
      {
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        for (uint64_t k = 0LL; k != 128; k += 8LL)
          *(void *)(v5 + 48 + k) = *(void *)(result + 8 + k);
        *(_OWORD *)(v5 + 24_Block_object_dispose(va, 8) = *(_OWORD *)(result + 136);
      }

      else if (v6 == -8181)
      {
        uint64_t result = (uint64_t)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *(void *)(v5 + 192) = *(void *)(result + 8);
        *(void *)(v5 + 20mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 16);
      }

      break;
  }

  return result;
}

char *GTMTLSMAccelerationStructure_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 <= -10198)
  {
    if (v6 > -15507)
    {
      switch(v6)
      {
        case -15359:
          uint64_t v8 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v9 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v8 + 1);
          *((void *)v5 + 2) = v9;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v10 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            uint64_t v11 = *((void *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            *((void *)v5 + 23) = v11;
            uint64_t v12 = *((void *)result + 9);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v12;
            __int128 v13 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v13;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v12 - v13;
            *((_DWORD *)v5 + 21) = v10;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 5) = *(void *)v8;
          uint64_t v14 = *((void *)v8 + 2);
          *((void *)v5 + 25) = *((void *)v8 + 3);
          uint64_t v15 = *((void *)v8 + 4);
          *((void *)v5 + 1_Block_object_dispose(va, 8) = v14;
          *((void *)v5 + 19) = v15;
          return result;
        case -15358:
          goto LABEL_31;
        case -15357:
          return result;
        case -15356:
          unsigned int v42 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v43 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v42 + 1);
          *((void *)v5 + 2) = v43;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v44 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            uint64_t v45 = *((void *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            *((void *)v5 + 23) = v45;
            uint64_t v46 = *((void *)result + 5);
            *((void *)v5 + 25) = *((void *)result + 6);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            uint64_t v47 = *((void *)result + 9);
            *((void *)v5 + 19) = v46;
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v47;
            __int128 v48 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v48;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v47 - v48;
            *((_DWORD *)v5 + 21) = v44;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          goto LABEL_62;
        case -15355:
          unsigned int v42 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v49 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v42 + 1);
          *((void *)v5 + 2) = v49;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v50 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v51 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v50;
            *((_DWORD *)v5 + 22) = v51;
            uint64_t v52 = *((void *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            uint64_t v53 = *((void *)result + 6);
            *((void *)v5 + 19) = *((void *)result + 5);
            *((void *)v5 + 23) = v52;
            *((void *)v5 + 25) = v53;
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            *((_OWORD *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_OWORD *)(result + 72);
            uint64_t v54 = *((void *)result + 12);
            *((void *)v5 + 22) = *((void *)result + 11);
            *((void *)v5 + 24) = v54;
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v42 + 2);
LABEL_62:
          *((void *)v5 + 6) = *(void *)v42;
          return result;
        case -15354:
          uint64_t v33 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v55 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v33 + 1);
          *((void *)v5 + 2) = v55;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v56 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            uint64_t v57 = *((void *)result + 5);
            *((void *)v5 + 25) = *((void *)result + 6);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            uint64_t v58 = *((void *)result + 9);
            *((void *)v5 + 19) = v57;
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v58;
            __int128 v59 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v59;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v58 - v59;
            *((_DWORD *)v5 + 21) = v56;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 6) = *(void *)v33;
          goto LABEL_66;
        case -15353:
          int v60 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v61 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v60 + 1);
          *((void *)v5 + 2) = v61;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v62 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v63 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v62;
            *((_DWORD *)v5 + 22) = v63;
            *((void *)v5 + 16) = *((void *)result + 3);
            uint64_t v64 = *((void *)result + 6);
            *((void *)v5 + 19) = *((void *)result + 5);
            *((void *)v5 + 25) = v64;
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            *((_OWORD *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_OWORD *)(result + 72);
            uint64_t v65 = *((void *)result + 12);
            *((void *)v5 + 22) = *((void *)result + 11);
            *((void *)v5 + 24) = v65;
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 6) = *(void *)v60;
          uint64_t v66 = *((void *)v60 + 2);
          *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v60 + 3);
          *((void *)v5 + 23) = v66;
          return result;
        case -15352:
          uint64_t v67 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v68 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v67 + 1);
          *((void *)v5 + 2) = v68;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v69 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            int v70 = *((_DWORD *)result + 4);
            *((_DWORD *)v5 + 21) = v69;
            *((_DWORD *)v5 + 22) = v70;
            *((void *)v5 + 16) = *((void *)result + 3);
            *((void *)v5 + 25) = *((void *)result + 6);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            *((_OWORD *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_OWORD *)(result + 72);
            uint64_t v71 = *((void *)result + 12);
            *((void *)v5 + 22) = *((void *)result + 11);
            *((void *)v5 + 24) = v71;
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 6) = *(void *)v67;
          uint64_t v72 = *((void *)v67 + 2);
          *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)v67 + 3);
          *((void *)v5 + 23) = v72;
          uint64_t v39 = *((void *)v67 + 4);
          goto LABEL_73;
        case -15351:
          int v73 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v74 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v73 + 1);
          *((void *)v5 + 2) = v74;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v75 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            *((void *)v5 + 25) = *((void *)result + 6);
            uint64_t v76 = *((void *)result + 9);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v76;
            __int128 v77 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v77;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v76 - v77;
            *((_DWORD *)v5 + 21) = v75;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 6) = *(void *)v73;
          goto LABEL_80;
        default:
          if (v6 == -15506)
          {
            int v73 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v78 = *(void *)a3;
            *((void *)v5 + 1) = *((void *)v73 + 1);
            *((void *)v5 + 2) = v78;
            *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *((void *)v5 + 15) = result;
            if (result)
            {
              uint64_t v79 = *((void *)result + 1);
              *((void *)v5 + 7) = *(void *)result;
              *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
              *((void *)v5 + 16) = *((void *)result + 3);
              *((void *)v5 + 25) = *((void *)result + 6);
              uint64_t v80 = *((void *)result + 9);
              *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
              *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v80;
              __int128 v81 = *((_OWORD *)result + 5);
              *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v81;
              *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v80 - v81;
              *((_DWORD *)v5 + 21) = v79;
              *((void *)v5 + 24) = *((void *)result + 12);
              *((void *)v5 + 17) = *((void *)result + 7);
            }

            *((void *)v5 + 5) = *(void *)v73;
LABEL_80:
            uint64_t v82 = *((void *)v73 + 3);
            *((void *)v5 + 23) = *((void *)v73 + 2);
            *((void *)v5 + 19) = v82;
          }

          else if (v6 == -15464)
          {
            uint64_t v24 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            uint64_t v25 = *(void *)a3;
            *((void *)v5 + 1) = *((void *)v24 + 1);
            *((void *)v5 + 2) = v25;
            *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
            *((void *)v5 + 15) = result;
            if (result)
            {
              uint64_t v26 = *((void *)result + 1);
              *((void *)v5 + 7) = *(void *)result;
              *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
              uint64_t v27 = *((void *)result + 4);
              *((void *)v5 + 16) = *((void *)result + 3);
              uint64_t v28 = *((void *)result + 5);
              *((void *)v5 + 23) = v27;
              *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
              uint64_t v29 = *((void *)result + 9);
              *((void *)v5 + 19) = v28;
              *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v29;
              __int128 v30 = *((_OWORD *)result + 5);
              *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v30;
              *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v29 - v30;
              *((_DWORD *)v5 + 21) = v26;
              *((void *)v5 + 24) = *((void *)result + 12);
              *((void *)v5 + 17) = *((void *)result + 7);
            }

            *((void *)v5 + 5) = *(void *)v24;
            uint64_t v31 = *((void *)v24 + 3);
            *((void *)v5 + 1_Block_object_dispose(va, 8) = *((void *)v24 + 2);
            *((void *)v5 + 25) = v31;
          }

          break;
      }
    }

    else if (v6 > -15616)
    {
      switch(v6)
      {
        case -15615:
LABEL_31:
          uint64_t v17 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v18 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v17 + 1);
          *((void *)v5 + 2) = v18;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v19 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            uint64_t v20 = *((void *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            *((void *)v5 + 23) = v20;
            uint64_t v21 = *((void *)result + 5);
            *((void *)v5 + 25) = *((void *)result + 6);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            uint64_t v22 = *((void *)result + 9);
            *((void *)v5 + 19) = v21;
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v22;
            __int128 v23 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v23;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v22 - v23;
            *((_DWORD *)v5 + 21) = v19;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 5) = *(void *)v17;
          break;
        case -15614:
          uint64_t v33 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v34 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v33 + 1);
          *((void *)v5 + 2) = v34;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 15) = result;
          if (result)
          {
            uint64_t v35 = *((void *)result + 1);
            *((void *)v5 + 7) = *(void *)result;
            *((_DWORD *)v5 + 22) = *((_DWORD *)result + 4);
            *((void *)v5 + 16) = *((void *)result + 3);
            uint64_t v36 = *((void *)result + 5);
            *((void *)v5 + 25) = *((void *)result + 6);
            *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = *((_WORD *)result + 32);
            uint64_t v37 = *((void *)result + 9);
            *((void *)v5 + 19) = v36;
            *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v37;
            __int128 v38 = *((_OWORD *)result + 5);
            *(_OWORD *)(v5 + 16_Block_object_dispose(va, 8) = v38;
            *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v37 - v38;
            *((_DWORD *)v5 + 21) = v35;
            *((void *)v5 + 24) = *((void *)result + 12);
            *((void *)v5 + 17) = *((void *)result + 7);
          }

          *((void *)v5 + 5) = *(void *)v33;
LABEL_66:
          *((void *)v5 + 23) = *((void *)v33 + 2);
          break;
        case -15552:
          uint64_t v16 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v16[8], a2);
          *((void *)v5 + 14) = result;
          if (result)
          {
            v5[104] = (*result & 0xFE) == 2;
            v5[105] = 1;
            v5[107] = (result[1] & 4) != 0;
          }

          break;
      }
    }

    else
    {
      switch(v6)
      {
        case -15661:
          uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[8], a2);
          *((void *)v5 + 9) = result;
          break;
        case -15660:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((_DWORD *)v5 + 22) = *((_DWORD *)result + 2);
          break;
        case -15659:
          *((void *)result + 3) = *(void *)a3;
          break;
        case -15651:
          result[100] = 1;
          break;
        case -15650:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v32 = *((void *)result + 2);
          if (v32 != 1) {
            *((_WORD *)v5 + 49) = v32;
          }
          break;
        default:
          return result;
      }
    }

    return result;
  }

  if (v6 > -10174)
  {
    if (v6 <= -10160)
    {
      switch(v6)
      {
        case -10173:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
          break;
        case -10170:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v39 = *((void *)result + 1);
LABEL_73:
          *((void *)v5 + 19) = v39;
          break;
        case -10169:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((_DWORD *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)result + 1);
          break;
        case -10167:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 17) = *((void *)result + 1);
          break;
        default:
          return result;
      }

      return result;
    }

    if (v6 == -10159)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      int16x8_t v41 = *(int16x8_t *)(result + 8);
    }

    else
    {
      if (v6 != -10158)
      {
        if (v6 == -10154)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          if (*((void *)v5 + 1) == *((void *)result + 1))
          {
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, result[16], a2);
            *((void *)v5 + 14) = result;
          }
        }

        return result;
      }

      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      if (*((void *)v5 + 1) != *((void *)result + 1)) {
        return result;
      }
      int16x8_t v41 = *((int16x8_t *)result + 1);
    }

    *(int16x4_t *)v41.i8 = vmovn_s32((int32x4_t)v41);
    *((_DWORD *)v5 + 26) = vmovn_s16(v41).u32[0];
    return result;
  }

  if (v6 <= -10196)
  {
    if (v6 == -10197)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + 7) = *((void *)result + 1);
    }

    else
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((_DWORD *)v5 + 21) = *((void *)result + 1);
    }
  }

  else
  {
    switch(v6)
    {
      case -10195:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_DWORD *)v5 + 23) = *((_DWORD *)result + 2);
        break;
      case -10182:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_OWORD *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_OWORD *)(result + 8);
        uint64_t v40 = *((void *)result + 4);
        *((void *)v5 + 22) = *((void *)result + 3);
        *((_WORD *)v5 + 4_Block_object_dispose(va, 8) = v40;
        *((_OWORD *)v5 + 12) = *(_OWORD *)(result + 40);
        break;
      case -10181:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((void *)v5 + 16) = *((void *)result + 1);
        break;
    }
  }

  return result;
}

char *GTMTLSMFunctionHandle_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(a3 + 8);
  if (v5 > -15445)
  {
    switch(v5)
    {
      case -15444:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v14 = *(void *)a3;
        uint64_t v15 = *(void *)result;
        *((void *)v4 + 1) = *((void *)result + 1);
        *((void *)v4 + 2) = v14;
        *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v4 + 7) = v15;
        *((void *)v4 + 5) = *((void *)result + 2);
        char v11 = 2;
        break;
      case -15437:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v16 = *(void *)a3;
        uint64_t v17 = *(void *)result;
        *((void *)v4 + 1) = *((void *)result + 1);
        *((void *)v4 + 2) = v16;
        *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v4 + 7) = v17;
        *((void *)v4 + 5) = *((void *)result + 2);
        char v11 = 4;
        break;
      case -15436:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v9 = *(void *)a3;
        uint64_t v10 = *(void *)result;
        *((void *)v4 + 1) = *((void *)result + 1);
        *((void *)v4 + 2) = v9;
        *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v4 + 7) = v10;
        *((void *)v4 + 5) = *((void *)result + 2);
        char v11 = 1;
        break;
      default:
        return result;
    }

    v4[64] = v11;
  }

  else
  {
    switch(v5)
    {
      case -15620:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v12 = *(void *)a3;
        uint64_t v13 = *(void *)result;
        *((void *)v4 + 1) = *((void *)result + 1);
        *((void *)v4 + 2) = v12;
        *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v4 + 5) = *((void *)result + 2);
        *((void *)v4 + 6) = v13;
        break;
      case -15610:
        *((void *)result + 3) = *(void *)a3;
        break;
      case -15463:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v6 = *(void *)a3;
        uint64_t v7 = *(void *)result;
        *((void *)v4 + 1) = *((void *)result + 1);
        *((void *)v4 + 2) = v6;
        *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v4 + 7) = v7;
        uint64_t v8 = *((void *)result + 3);
        *((void *)v4 + 5) = *((void *)result + 2);
        v4[64] = v8;
        break;
    }
  }

  return result;
}

char *GTMTLSMIntersectionFunctionTable_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -15444)
  {
    if (v6 <= -10181)
    {
      switch(v6)
      {
        case -15443:
          __int128 v30 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v31 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v30 + 1);
          *((void *)v5 + 2) = v31;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t v32 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 14) = v32;
          if (v32)
          {
            uint64_t v33 = *((void *)v32 + 1);
            *((void *)v5 + 7) = *(void *)v32;
            int v34 = *((_DWORD *)v32 + 4);
            *((_DWORD *)v5 + 21) = v33;
            *((_DWORD *)v5 + 22) = v34;
            *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v32 + 24), *(int8x16_t *)(v32 + 24), 8uLL);
            *((void *)v5 + 19) = *((void *)v32 + 5);
          }

          *((void *)v5 + 16) = *(void *)v30;
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v30[16], a2);
          *((void *)v5 + 13) = result;
          char v18 = 2;
          break;
        case -15442:
          uint64_t v25 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v26 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v25 + 1);
          *((void *)v5 + 2) = v26;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t v27 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 14) = v27;
          if (v27)
          {
            uint64_t v28 = *((void *)v27 + 1);
            *((void *)v5 + 7) = *(void *)v27;
            int v29 = *((_DWORD *)v27 + 4);
            *((_DWORD *)v5 + 21) = v28;
            *((_DWORD *)v5 + 22) = v29;
            *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v27 + 24), *(int8x16_t *)(v27 + 24), 8uLL);
            *((void *)v5 + 19) = *((void *)v27 + 5);
          }

          *((void *)v5 + 16) = *(void *)v25;
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v25[16], a2);
          *((void *)v5 + 13) = result;
          char v18 = 4;
          break;
        case -15441:
          uint64_t v13 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          uint64_t v14 = *(void *)a3;
          *((void *)v5 + 1) = *((void *)v13 + 1);
          *((void *)v5 + 2) = v14;
          *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
          uint64_t v15 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
          *((void *)v5 + 14) = v15;
          if (v15)
          {
            uint64_t v16 = *((void *)v15 + 1);
            *((void *)v5 + 7) = *(void *)v15;
            int v17 = *((_DWORD *)v15 + 4);
            *((_DWORD *)v5 + 21) = v16;
            *((_DWORD *)v5 + 22) = v17;
            *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v15 + 24), *(int8x16_t *)(v15 + 24), 8uLL);
            *((void *)v5 + 19) = *((void *)v15 + 5);
          }

          *((void *)v5 + 16) = *(void *)v13;
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v13[16], a2);
          *((void *)v5 + 13) = result;
          char v18 = 1;
          break;
        default:
          return result;
      }

      v5[160] = v18;
    }

    else
    {
      switch(v6)
      {
        case -10180:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
          break;
        case -10179:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((_DWORD *)v5 + 21) = *((void *)result + 1);
          break;
        case -10178:
        case -10177:
          return result;
        case -10176:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 7) = *((void *)result + 1);
          break;
        case -10175:
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 1_Block_object_dispose(va, 8) = *((void *)result + 1);
          break;
        default:
          if (v6 == -10161)
          {
            uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
            *((void *)v5 + 19) = *((void *)result + 1);
          }

          break;
      }
    }
  }

  else if (v6 > -15561)
  {
    if (v6 > -15541)
    {
      if (v6 == -15540)
      {
        uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v35 = *(void *)a3;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v35;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        uint64_t v36 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 14) = v36;
        if (v36)
        {
          uint64_t v37 = *((void *)v36 + 1);
          *((void *)v5 + 7) = *(void *)v36;
          int v38 = *((_DWORD *)v36 + 4);
          *((_DWORD *)v5 + 21) = v37;
          *((_DWORD *)v5 + 22) = v38;
          *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v36 + 24), *(int8x16_t *)(v36 + 24), 8uLL);
          *((void *)v5 + 19) = *((void *)v36 + 5);
        }

        *((void *)v5 + 15) = *(void *)v7;
LABEL_45:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[16], a2);
        *((void *)v5 + 13) = result;
      }

      else if (v6 == -15462)
      {
        uint64_t v19 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v20 = *(void *)a3;
        *((void *)v5 + 1) = *((void *)v19 + 1);
        *((void *)v5 + 2) = v20;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        uint64_t v21 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 14) = v21;
        if (v21)
        {
          uint64_t v22 = *((void *)v21 + 1);
          *((void *)v5 + 7) = *(void *)v21;
          int v23 = *((_DWORD *)v21 + 4);
          *((_DWORD *)v5 + 21) = v22;
          *((_DWORD *)v5 + 22) = v23;
          *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v21 + 24), *(int8x16_t *)(v21 + 24), 8uLL);
          *((void *)v5 + 19) = *((void *)v21 + 5);
        }

        *((void *)v5 + 16) = *(void *)v19;
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v19[24], a2);
        *((void *)v5 + 13) = result;
        v5[160] = *((void *)v19 + 2);
      }
    }

    else if (v6 == -15560)
    {
      result[100] = 1;
    }

    else if (v6 == -15557)
    {
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v12 = *((void *)result + 2);
      if (v12 != 1) {
        *((_WORD *)v5 + 49) = v12;
      }
    }
  }

  else
  {
    switch(v6)
    {
      case -15577:
        uint64_t v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v8 = *(void *)a3;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v8;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        uint64_t v9 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 14) = v9;
        if (v9)
        {
          uint64_t v10 = *((void *)v9 + 1);
          *((void *)v5 + 7) = *(void *)v9;
          int v11 = *((_DWORD *)v9 + 4);
          *((_DWORD *)v5 + 21) = v10;
          *((_DWORD *)v5 + 22) = v11;
          *(int8x16_t *)(v5 + 136) = vextq_s8(*(int8x16_t *)(v9 + 24), *(int8x16_t *)(v9 + 24), 8uLL);
          *((void *)v5 + 19) = *((void *)v9 + 5);
        }

        *((void *)v5 + 5) = *(void *)v7;
        goto LABEL_45;
      case -15570:
        uint64_t v24 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v24[8], a2);
        *((void *)v5 + 9) = result;
        break;
      case -15569:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_DWORD *)v5 + 22) = *((_DWORD *)result + 2);
        break;
      case -15568:
        *((void *)result + 3) = *(void *)a3;
        break;
      default:
        return result;
    }
  }

  return result;
}

char *GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithPool( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = *(_DWORD *)(a3 + 8);
  if (v7 <= -15531)
  {
    if (v7 > -15546)
    {
      if (v7 == -15545)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v43 = *((void *)result + 1);
        uint64_t v44 = a1 + 184 + 24LL * *((void *)result + 3);
        *(_DWORD *)uint64_t v44 = v43 != 0;
        *(void *)(v44 + _Block_object_dispose(va, 8) = v43;
        *(void *)(a1 + 184 + 24LL * *((void *)result + 3) + 16) = *((void *)result + 2);
        return result;
      }

      if (v7 == -15544)
      {
        uint64_t v24 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v25 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v24[24], a2);
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v24[25], a2);
        if (*((void *)v24 + 2))
        {
          unint64_t v26 = 0LL;
          do
          {
            uint64_t v27 = *(void *)&v25[8 * v26];
            uint64_t v28 = a1 + 184 + 24 * (v26 + *((void *)v24 + 1));
            *(_DWORD *)uint64_t v28 = v27 != 0;
            *(void *)(v28 + _Block_object_dispose(va, 8) = v27;
            *(void *)(a1 + 184 + 24 * (v26 + *((void *)v24 + 1)) + 16) = *(void *)&result[8 * v26];
            ++v26;
          }

          while (*((void *)v24 + 2) > v26);
        }

        return result;
      }
    }

    else
    {
      if (v7 == -15559)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v38 = *(void *)(a1 + 168);
        if (!v38) {
          return result;
        }
        uint64_t v10 = *((void *)result + 1);
        uint64_t v11 = v38 + 16LL * *((void *)result + 2);
        int v12 = 1;
        goto LABEL_48;
      }

      if (v7 == -15558)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        if (*(void *)(a1 + 168))
        {
          uint64_t v13 = result;
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, result[24], a2);
          if (*((void *)v13 + 2))
          {
            unint64_t v14 = 0LL;
            do
            {
              uint64_t v15 = *(void *)(a1 + 168) + 16 * (v14 + *((void *)v13 + 1));
              *(_DWORD *)uint64_t v15 = 1;
              *(void *)(v15 + _Block_object_dispose(va, 8) = *(void *)&result[8 * v14++];
            }

            while (*((void *)v13 + 2) > v14);
          }
        }

        return result;
      }
    }

    return GTMTLSMIntersectionFunctionTable_processTraceFuncWithPool((char *)a1, a2, a3);
  }

  if (v7 <= -15259)
  {
    switch(v7)
    {
      case -15530:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v9 = *(void *)(a1 + 168);
        if (!v9) {
          return result;
        }
        uint64_t v10 = *((void *)result + 1);
        uint64_t v11 = v9 + 16LL * *((void *)result + 2);
        int v12 = 2;
        break;
      case -15529:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        if (*(void *)(a1 + 168) && *((void *)result + 3))
        {
          unint64_t v29 = 0LL;
          do
          {
            uint64_t v30 = *((void *)result + 1);
            uint64_t v31 = *(void *)(a1 + 168) + 16 * (v29 + *((void *)result + 2));
            *(_DWORD *)uint64_t v31 = 2;
            *(void *)(v31 + _Block_object_dispose(va, 8) = v30;
            ++v29;
          }

          while (*((void *)result + 3) > v29);
        }

        return result;
      case -15526:
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v32 = *((void *)result + 1);
        uint64_t v33 = a1 + 24LL * *((void *)result + 2);
        *(_DWORD *)(v33 + 184) = 2 * (v32 != 0);
        *(void *)(v33 + 192) = v32;
        return result;
      case -15525:
        int v34 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v34[24], a2);
        if (*((void *)v34 + 2))
        {
          unint64_t v35 = 0LL;
          do
          {
            uint64_t v36 = *(void *)&result[8 * v35];
            uint64_t v37 = a1 + 24 * (v35 + *((void *)v34 + 1));
            *(_DWORD *)(v37 + 184) = 2 * (v36 != 0);
            *(void *)(v37 + 192) = v36;
            ++v35;
          }

          while (*((void *)v34 + 2) > v35);
        }

        return result;
      default:
        return GTMTLSMIntersectionFunctionTable_processTraceFuncWithPool((char *)a1, a2, a3);
    }

    goto LABEL_48;
  }

  if (v7 == -15258)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v39 = *(void *)(a1 + 168);
    if (!v39) {
      return result;
    }
    uint64_t v10 = *((void *)result + 1);
    uint64_t v11 = v39 + 16LL * *((void *)result + 2);
    int v12 = 3;
LABEL_48:
    *(_DWORD *)uint64_t v11 = v12;
    *(void *)(v11 + _Block_object_dispose(va, 8) = v10;
    return result;
  }

  if (v7 == -15257)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    if (*(void *)(a1 + 168) && *((void *)result + 3))
    {
      unint64_t v40 = 0LL;
      do
      {
        uint64_t v41 = *((void *)result + 1);
        uint64_t v42 = *(void *)(a1 + 168) + 16 * (v40 + *((void *)result + 2));
        *(_DWORD *)uint64_t v42 = 3;
        *(void *)(v42 + _Block_object_dispose(va, 8) = v41;
        ++v40;
      }

      while (*((void *)result + 3) > v40);
    }

    return result;
  }

  if (v7 != -10152) {
    return GTMTLSMIntersectionFunctionTable_processTraceFuncWithPool((char *)a1, a2, a3);
  }
  uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
  if (a4)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, result[8], a2);
    unint64_t v17 = *(void *)result;
    if (*(void *)result)
    {
      char v18 = result;
      unint64_t v19 = 0LL;
      uint64_t v20 = (_DWORD *)(a1 + 184);
      do
      {
        uint64_t v21 = &v18[8 * v19];
        uint64_t v22 = *((void *)v21 + 1);
        if (v22)
        {
          uint64_t result = (char *)GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a4 + 24LL),  *(int *)(*(void *)a4 + 12LL),  *((void *)v21 + 1));
          if (result)
          {
            uint64_t v23 = *((void *)result + 2);
            if (v23)
            {
              unint64_t v46 = *(void *)result;
              uint64_t v47 = a1 + 24 * v19;
              *(_DWORD *)(v47 + 184) = 1;
              *(void *)(v47 + 192) = v23;
              *(void *)(v47 + 20mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v22 - v46;
              return result;
            }
          }

          uint64_t result = (char *)GTMTLIndirectResources_visibleFunctionTableIdForGPUAddress(a4, v22);
          if (result)
          {
            uint64_t v45 = a1 + 24 * v19;
            *(_DWORD *)(v45 + 184) = 2;
            *(void *)(v45 + 192) = result;
            return result;
          }

          unint64_t v17 = *(void *)v18;
        }

        else
        {
          *uint64_t v20 = 0;
        }

        ++v19;
        v20 += 6;
      }

      while (v17 > v19);
    }
  }

  return result;
}

char *GTMTLSMVisibleFunctionTable_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 > -15439)
  {
    if (v6 > -10178)
    {
      if (v6 > -10161)
      {
        if (v6 == -10160)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 19) = *((void *)result + 1);
        }

        else if (v6 == -10153)
        {
          uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
          *((void *)v5 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)result + 1);
        }
      }

      else if (v6 == -10177)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((void *)v5 + 7) = *((void *)result + 1);
      }

      else if (v6 == -10174)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((_DWORD *)v5 + 21) = *((void *)result + 1);
      }

      return result;
    }

    if (v6 != -15438)
    {
      if (v6 == -10193)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((void *)v5 + 17) = *((void *)result + 1);
      }

      else if (v6 == -10178)
      {
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
      }

      return result;
    }

    int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v18 = *(void *)a3;
    *((void *)v5 + 1) = *((void *)v7 + 1);
    *((void *)v5 + 2) = v18;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
    unint64_t v19 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
    *((void *)v5 + 14) = v19;
    if (v19)
    {
      uint64_t v20 = *((void *)v19 + 1);
      *((void *)v5 + 7) = *(void *)v19;
      int v21 = *((_DWORD *)v19 + 4);
      *((_DWORD *)v5 + 21) = v20;
      *((_DWORD *)v5 + 22) = v21;
      *(_OWORD *)(v5 + 136) = *(_OWORD *)(v19 + 24);
      *(_OWORD *)(v5 + 152) = *(_OWORD *)(v19 + 40);
    }

    *((void *)v5 + 16) = *(void *)v7;
    char v16 = 1;
LABEL_40:
    v5[168] = v16;
LABEL_41:
    unsigned int v27 = v7[16];
LABEL_42:
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v27, a2);
    *((void *)v5 + 13) = result;
    return result;
  }

  if (v6 > -15461)
  {
    switch(v6)
    {
      case -15460:
        uint64_t v22 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v23 = *(void *)a3;
        *((void *)v5 + 1) = *((void *)v22 + 1);
        *((void *)v5 + 2) = v23;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        uint64_t v24 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 14) = v24;
        if (v24)
        {
          uint64_t v25 = *((void *)v24 + 1);
          *((void *)v5 + 7) = *(void *)v24;
          int v26 = *((_DWORD *)v24 + 4);
          *((_DWORD *)v5 + 21) = v25;
          *((_DWORD *)v5 + 22) = v26;
          *(_OWORD *)(v5 + 136) = *(_OWORD *)(v24 + 24);
          *(_OWORD *)(v5 + 152) = *(_OWORD *)(v24 + 40);
        }

        *((void *)v5 + 16) = *(void *)v22;
        v5[168] = *((void *)v22 + 2);
        unsigned int v27 = v22[24];
        goto LABEL_42;
      case -15440:
        int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v28 = *(void *)a3;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v28;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        unint64_t v29 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 14) = v29;
        if (v29)
        {
          uint64_t v30 = *((void *)v29 + 1);
          *((void *)v5 + 7) = *(void *)v29;
          int v31 = *((_DWORD *)v29 + 4);
          *((_DWORD *)v5 + 21) = v30;
          *((_DWORD *)v5 + 22) = v31;
          *(_OWORD *)(v5 + 136) = *(_OWORD *)(v29 + 24);
          *(_OWORD *)(v5 + 152) = *(_OWORD *)(v29 + 40);
        }

        *((void *)v5 + 16) = *(void *)v7;
        char v16 = 2;
        break;
      case -15439:
        int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v12 = *(void *)a3;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v12;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        uint64_t v13 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
        *((void *)v5 + 14) = v13;
        if (v13)
        {
          uint64_t v14 = *((void *)v13 + 1);
          *((void *)v5 + 7) = *(void *)v13;
          int v15 = *((_DWORD *)v13 + 4);
          *((_DWORD *)v5 + 21) = v14;
          *((_DWORD *)v5 + 22) = v15;
          *(_OWORD *)(v5 + 136) = *(_OWORD *)(v13 + 24);
          *(_OWORD *)(v5 + 152) = *(_OWORD *)(v13 + 40);
        }

        *((void *)v5 + 16) = *(void *)v7;
        char v16 = 4;
        break;
      default:
        return result;
    }

    goto LABEL_40;
  }

  switch(v6)
  {
    case -15607:
      unint64_t v17 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v17[8], a2);
      *((void *)v5 + 9) = result;
      return result;
    case -15605:
      *((void *)result + 3) = *(void *)a3;
      return result;
    case -15578:
      int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      uint64_t v8 = *(void *)a3;
      *((void *)v5 + 1) = *((void *)v7 + 1);
      *((void *)v5 + 2) = v8;
      *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
      uint64_t v9 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 14), a2);
      *((void *)v5 + 14) = v9;
      if (v9)
      {
        uint64_t v10 = *((void *)v9 + 1);
        *((void *)v5 + 7) = *(void *)v9;
        int v11 = *((_DWORD *)v9 + 4);
        *((_DWORD *)v5 + 21) = v10;
        *((_DWORD *)v5 + 22) = v11;
        *(_OWORD *)(v5 + 136) = *(_OWORD *)(v9 + 24);
        *(_OWORD *)(v5 + 152) = *(_OWORD *)(v9 + 40);
      }

      *((void *)v5 + 15) = *(void *)v7;
      goto LABEL_41;
  }

  return result;
}

char *GTMTLSMVisibleFunctionTableStateful_processTraceFuncWithPool(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a3 + 8);
  if (v6 == -15597)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    if (*(void *)(a1 + 176))
    {
      uint64_t v9 = result;
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, result[24], a2);
      if (*((void *)v9 + 2))
      {
        unint64_t v10 = 0LL;
        uint64_t v11 = *(void *)(a1 + 176);
        do
        {
          *(void *)(v11 + 8 * (v10 + *((void *)v9 + 1))) = *(void *)&result[8 * v10];
          ++v10;
        }

        while (*((void *)v9 + 2) > v10);
      }
    }
  }

  else if (v6 == -15598)
  {
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v8 = *(void *)(a1 + 176);
    if (v8) {
      *(void *)(v8 + 8LL * *((void *)result + 2)) = *((void *)result + 1);
    }
  }

  else
  {
    return GTMTLSMVisibleFunctionTable_processTraceFuncWithPool((char *)a1, a2, a3);
  }

  return result;
}

char *GTMTLFXSMSpatialScaler_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  int v6 = *(_DWORD *)(a3 + 8);
  switch(v6)
  {
    case -20480:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)result + 1);
      break;
    case -20479:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + 7) = *((void *)result + 1);
      break;
    case -20478:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + 11) = *((void *)result + 1);
      break;
    case -20477:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)result + 1);
      break;
    case -20476:
      uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
      *((void *)v5 + 9) = *((void *)result + 1);
      break;
    case -20475:
      *((void *)result + 3) = *(void *)a3;
      break;
    default:
      if (v6 == -18432)
      {
        int v7 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v8 = *(void *)a3;
        uint64_t v9 = *(void *)v7;
        *((void *)v5 + 1) = *((void *)v7 + 1);
        *((void *)v5 + 2) = v8;
        *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
        *((void *)v5 + 5) = v9;
        uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v7[16], a2);
        *((void *)v5 + 6) = result;
        *((_OWORD *)v5 + 5) = *(_OWORD *)result;
      }

      break;
  }

  return result;
}

float32_t GTMTLFXSMTemporalScaler_processTraceFuncWithPool(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a3 + 8);
  switch(v6)
  {
    case -20473:
      *(void *)(a1 + 64) = *((void *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                             + 1);
      break;
    case -20472:
      *(_BYTE *)(a1 + 14_Block_object_dispose(va, 8) = *((_DWORD *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                             + 2);
      break;
    case -20471:
      *(void *)(a1 + 72) = *((void *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                             + 1);
      break;
    case -20470:
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = *((void *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                             + 1);
      break;
    case -20469:
      *(void *)(a1 + 56) = *((void *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                             + 1);
      break;
    case -20468:
      *(void *)(a1 + 12mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                              + 1);
      break;
    case -20467:
      *(void *)(a1 + 112) = *((void *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                              + 1);
      break;
    case -20466:
      v7.i32[0] = *((_DWORD *)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2) + 2);
      *(_DWORD *)(a1 + 12_Block_object_dispose(va, 8) = v7.i32[0];
      break;
    case -20465:
      v7.i32[0] = *((_DWORD *)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2) + 2);
      *(_DWORD *)(a1 + 132) = v7.i32[0];
      break;
    case -20464:
      *(void *)(a1 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                             + 1);
      break;
    case -20463:
      v7.i32[0] = *((_DWORD *)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2) + 2);
      *(_DWORD *)(a1 + 136) = v7.i32[0];
      break;
    case -20462:
      v7.i32[0] = *((_DWORD *)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2) + 2);
      *(_DWORD *)(a1 + 14mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v7.i32[0];
      break;
    case -20461:
      *(void *)(a1 + 96) = *((void *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                             + 1);
      break;
    case -20460:
      v7.i32[0] = *((_DWORD *)GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2) + 2);
      *(_DWORD *)(a1 + memset(v68, 0, 144) = v7.i32[0];
      break;
    case -20459:
      *(_BYTE *)(a1 + 149) = *((_DWORD *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                             + 2);
      break;
    case -20458:
      *(void *)(a1 + 24) = *(void *)a3;
      break;
    case -20457:
      *(_BYTE *)(a1 + 149) = 0;
      break;
    case -20456:
      *(void *)(a1 + 104) = *((void *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                              + 1);
      break;
    default:
      if (v6 == -18430)
      {
        *(_BYTE *)(a1 + 15mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *((void *)GTTraceFunc_argumentBytesWithPool( (uint64_t *)a3,  *(unsigned __int8 *)(a3 + 13),  a2)
                               + 1);
      }

      else if (v6 == -18431)
      {
        uint64_t v8 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
        uint64_t v9 = *(void *)a3;
        uint64_t v10 = *(void *)v8;
        *(void *)(a1 + _Block_object_dispose(va, 8) = *((void *)v8 + 1);
        *(void *)(a1 + 16) = v9;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a3 + 8);
        *(void *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v10;
        uint64_t v11 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v8[16], a2);
        *(void *)(a1 + 4_Block_object_dispose(va, 8) = v11;
        *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
        uint64x2_t v12 = *((uint64x2_t *)v11 + 1);
        *(uint64x2_t *)(a1 + 112) = v12;
        float32x2_t v7 = vneg_f32(vcvt_f32_f64(vcvtq_f64_u64(v12)));
        *(float32x2_t *)(a1 + 136) = v7;
        *(_DWORD *)(a1 + memset(v68, 0, 144) = 1065353216;
        *(_WORD *)(a1 + 14_Block_object_dispose(va, 8) = 257;
      }

      break;
  }

  return v7.f32[0];
}

char *GTMTLSMResidencySet_processTraceFuncWithPool(char *result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 8) == -15245)
  {
    int v5 = result;
    int v6 = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, *(unsigned __int8 *)(a3 + 13), a2);
    uint64_t v7 = *(void *)a3;
    *((void *)v5 + 1) = *((void *)v6 + 1);
    *((void *)v5 + 2) = v7;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a3 + 8);
    uint64_t result = GTTraceFunc_argumentBytesWithPool((uint64_t *)a3, v6[24], a2);
    *((void *)v5 + 5) = *(void *)v6;
    *((void *)v5 + 6) = result;
  }

  return result;
}

uint64_t GTMTLRenderPipelineState_descriptorType(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (v4[6]) {
    return 1LL;
  }
  if (v4[8]) {
    return 2LL;
  }
  if (v4[9]) {
    return 3LL;
  }
  return 0LL;
}

char *GTMTLRenderPipelineState_rootPipeline(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 40mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 36_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 32mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 28_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 24mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 16mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + memset(v68, 0, 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)a1 = 71;
  *(void *)(a1 + 24) = -1LL;
  *(void *)(a1 + 96) = -1LL;
  if (a2 && (uint64_t v7 = *(void *)(a2 + 32)) != 0 && (*(_BYTE *)(v7 + 79) & 8) != 0) {
    uint64_t v8 = v7 + 64;
  }
  else {
    uint64_t v8 = 0LL;
  }
  for (int i = *(_DWORD *)(v8 + 8); i == -15461; int i = *(_DWORD *)(v8 + 8))
  {
    uint64_t v14 = GTTraceFunc_targetContext(v8, a4);
    entry = find_entry(a3, &v14, 8uLL, 0LL);
    if (*entry
      && (uint64_t v11 = *(void *)(*entry + 32LL)) != 0
      && (uint64_t v12 = *(void *)(v11 + 32)) != 0
      && (*(_BYTE *)(v12 + 79) & 8) != 0)
    {
      uint64_t v8 = v12 + 64;
    }

    else
    {
      uint64_t v8 = 0LL;
    }
  }

  return GTMTLSMRenderPipelineState_processTraceFuncWithMap((char *)a1, a4, (uint64_t *)v8);
}

uint64_t GTMTLRenderPipelineState_partialDescriptor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return v4[6];
}

uint64_t GTMTLRenderPipelineState_partialTileDescriptor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return v4[8];
}

uint64_t GTMTLRenderPipelineState_partialMeshDescriptor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return v4[9];
}

uint64_t GTMTLComputePipelineState_computeFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v14 = 0u;
  uint64_t v15 = 0LL;
  memset(&v18[4], 0, 80);
  __int128 v17 = 0u;
  memset(v18, 0, 48);
  LODWORD(v14) = 29;
  uint64_t v16 = -1LL;
  uint64_t v19 = 0LL;
  int8x16_t v18[3] = 0xFFFFFFFFFFFFFFFFLL;
  if (a1 && (uint64_t v5 = *(void *)(a1 + 32)) != 0 && (*(_BYTE *)(v5 + 79) & 8) != 0) {
    uint64_t v6 = v5 + 64;
  }
  else {
    uint64_t v6 = 0LL;
  }
  for (int i = *(_DWORD *)(v6 + 8); i == -15541; int i = *(_DWORD *)(v6 + 8))
  {
    uint64_t v13 = GTTraceFunc_targetContext(v6, a3);
    entry = find_entry(a2, &v13, 8uLL, 0LL);
    if (*entry
      && (uint64_t v9 = *(void *)(*entry + 32LL)) != 0
      && (uint64_t v10 = *(void *)(v9 + 32)) != 0
      && (*(_BYTE *)(v10 + 79) & 8) != 0)
    {
      uint64_t v6 = v10 + 64;
    }

    else
    {
      uint64_t v6 = 0LL;
    }
  }

  GTMTLSMComputePipelineState_processTraceFuncWithMap((char *)&v14, a3, (uint64_t *)v6);
  if (*((void *)&v18[0] + 1)) {
    uint64_t v11 = (_OWORD *)(*((void *)&v18[0] + 1) + 848LL);
  }
  else {
    uint64_t v11 = v18;
  }
  return *(void *)v11;
}

void *GTMTLSMRenderPipelineState_resourceAccess@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v7 = 0u;
  uint64_t v8 = 0LL;
  LODWORD(v7) = 71;
  uint64_t v9 = -1LL;
  __int128 v14 = 0xFFFFFFFFFFFFFFFFLL;
  if (a1 && (uint64_t v4 = *(void *)(a1 + 32)) != 0 && (*(_BYTE *)(v4 + 79) & 8) != 0) {
    uint64_t v5 = (uint64_t *)(v4 + 64);
  }
  else {
    uint64_t v5 = 0LL;
  }
  GTMTLSMRenderPipelineState_processTraceFuncWithMap((char *)&v7, a2, v5);
  return memcpy(a3, (char *)v15 + 8, 0x118uLL);
}

double GTMTLSMComputePipelineState_resourceAccess@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v8 = 0u;
  uint64_t v9 = 0LL;
  uint64_t v17 = 0LL;
  memset(v16, 0, sizeof(v16));
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  LODWORD(v_Block_object_dispose(va, 8) = 29;
  uint64_t v10 = -1LL;
  __int128 v15 = 0xFFFFFFFFFFFFFFFFLL;
  if (a1 && (uint64_t v4 = *(void *)(a1 + 32)) != 0 && (*(_BYTE *)(v4 + 79) & 8) != 0) {
    uint64_t v5 = (uint64_t *)(v4 + 64);
  }
  else {
    uint64_t v5 = 0LL;
  }
  GTMTLSMComputePipelineState_processTraceFuncWithMap((char *)&v8, a2, v5);
  __int128 v6 = *(_OWORD *)((char *)&v16[1] + 8);
  *(_OWORD *)a3 = *(_OWORD *)((char *)v16 + 8);
  *(_OWORD *)(a3 + 16) = v6;
  double result = *((double *)&v16[2] + 1);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)((char *)&v16[2] + 8);
  *(void *)(a3 + 4_Block_object_dispose(va, 8) = *((void *)&v16[3] + 1);
  return result;
}

uint64_t RetainDebugObject(void *a1)
{
  id v1 = a1;
  id v2 = DEVICEOBJECT(v1);
  unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_unfair_lock_lock((os_unfair_lock_t)&s_debugObjectsLock);
  uint64_t v4 = (void *)s_debugObjects;
  if (!s_debugObjects)
  {
    uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    __int128 v6 = (void *)s_debugObjects;
    s_debugObjects = (uint64_t)v5;

    uint64_t v4 = (void *)s_debugObjects;
  }

  __int128 v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v3));
  [v4 setObject:v1 forKey:v7];

  os_unfair_lock_unlock((os_unfair_lock_t)&s_debugObjectsLock);
  return 0LL;
}

void ReleaseDebugObject(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  unsigned int v6 = atomic_load((unsigned int *)(a1 + 104));
  if (v6 != 1)
  {
    BOOL v7 = v6 != 2 || a2 == 0;
    if (v7 || (char v8 = atomic_load((unint64_t *)(a2 + 56)), (v8 & 0x10) == 0))
    {
      id v13 = v5;
      id v9 = DEVICEOBJECT(v5);
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
      os_unfair_lock_lock((os_unfair_lock_t)&s_debugObjectsLock);
      __int128 v11 = (void *)s_debugObjects;
      __int128 v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v10));
      [v11 removeObjectForKey:v12];

      os_unfair_lock_unlock((os_unfair_lock_t)&s_debugObjectsLock);
      id v5 = v13;
    }
  }
}

void ReleaseDebugObjects(uint64_t *a1, int a2)
{
  BOOL v7 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", a2);
  if (a2 >= 1)
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v5 = *a1++;
      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v5));
      -[NSMutableArray addObject:](v7, "addObject:", v6);

      --v4;
    }

    while (v4);
  }

  os_unfair_lock_lock((os_unfair_lock_t)&s_debugObjectsLock);
  [(id)s_debugObjects removeObjectsForKeys:v7];
  os_unfair_lock_unlock((os_unfair_lock_t)&s_debugObjectsLock);
}

id GetDebugLibrary(uint64_t a1)
{
  id v2 = (void *)s_debugObjects;
  unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1));
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:v3]);

  os_unfair_lock_unlock((os_unfair_lock_t)&s_debugObjectsLock);
  uint64_t v6 = objc_opt_class(&OBJC_CLASS___MTLDebugLibrary, v5);
  if ((objc_opt_isKindOfClass(v4, v6) & 1) != 0) {
    BOOL v7 = v4;
  }
  else {
    BOOL v7 = 0LL;
  }
  id v8 = v7;

  return v8;
}

BOOL EncodeDebugLibraryWithSource(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a2 + 96)) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(a3 + 8);
  id DebugLibrary = GetDebugLibrary(v8);
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(DebugLibrary);
  __int128 v11 = v10;
  BOOL v4 = v10 != 0LL;
  if (v10)
  {
    id v12 = objc_claimAutoreleasedReturnValue([v10 code]);
    id v13 = (char *)[v12 UTF8String];
    __int128 v14 = (const void *)(strlen(v13) + 1);
    v17[0] = *(void *)a1;
    v17[1] = v8;
    uint64_t v15 = *(void *)(a1 + 32);
    HashBytes((uint64_t *)v13, (unint64_t)v14, __s);
    GTMTLCaptureState_storePointer(v15, __s, (uint64_t *)v13, v14);
    v18[2] = v22;
    int8x16_t v18[3] = v23;
    char v19 = v24;
    v18[0] = *(_OWORD *)__s;
    v18[1] = v21;
    void v17[2] = v18;
    v17[3] = StoreMTLCompileOptionsUsingEncode(*(void *)(a1 + 32), *(void *)(a2 + 104), (uint64_t)__s, a4);
    v17[4] = 0LL;
    DYTraceEncode_MTLDevice_newLibraryWithSource_options_error( (uint64_t)v17,  *(unsigned int **)(a1 + 8),  *(unsigned int *)(a1 + 16),  0LL,  0LL);
  }

  return v4;
}

uint64_t StoreMTLCompileOptionsUsingEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v8 = (const void *)EncodeDYMTLCompileOptions(a2, 0LL, 0LL, a4);
  __chkstk_darwin();
  uint64_t v10 = (uint64_t *)((char *)&v12 - v9);
  EncodeDYMTLCompileOptions(a2, (uint64_t *)((char *)&v12 - v9), (unint64_t)v8, a4);
  SavePointer(a1, v10, v8, a3);
  return a3;
}

BOOL EncodeDebugLibraryWithData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 96)) {
    return 0LL;
  }
  id DebugLibrary = GetDebugLibrary(*(void *)(a3 + 8));
  BOOL v7 = (void *)objc_claimAutoreleasedReturnValue(DebugLibrary);
  uint64_t v8 = v7;
  BOOL v3 = v7 != 0LL;
  if (v7)
  {
    uint64_t v9 = (dispatch_data_s *)objc_claimAutoreleasedReturnValue([v7 code]);
    size_t size_ptr = 0LL;
    buffer_ptr = 0LL;
    dispatch_data_t v10 = dispatch_data_create_map(v9, (const void **)&buffer_ptr, &size_ptr);
    uint64_t v11 = *(void *)(a3 + 8);
    v16[0] = *(void *)a1;
    v16[1] = v11;
    uint64_t v12 = *(void *)(a1 + 32);
    __int128 v14 = (const void *)size_ptr;
    id v13 = (uint64_t *)buffer_ptr;
    HashBytes((uint64_t *)buffer_ptr, size_ptr, __s);
    GTMTLCaptureState_storePointer(v12, __s, v13, v14);
    v19[2] = v23;
    v19[3] = v24;
    char v20 = v25;
    v19[0] = *(_OWORD *)__s;
    v19[1] = v22;
    void v16[2] = v19;
    v16[3] = 0LL;
    DYTraceEncode_MTLDevice_newLibraryWithData_error( (uint64_t)v16,  *(unsigned int **)(a1 + 8),  *(unsigned int *)(a1 + 16),  0LL,  0LL);
  }

  return v3;
}

uint64_t SaveDirPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = a1;
  context = objc_autoreleasePoolPush();
  BOOL v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  id v31 = 0LL;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 contentsOfDirectoryAtPath:v5 error:&v31]);
  id v21 = v31;
  BOOL v7 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [v6 count]);
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  id v8 = v6;
  id v9 = [v8 countByEnumeratingWithState:&v27 objects:v32 count:16];
  if (v9)
  {
    id v10 = v9;
    uint64_t v11 = *(void *)v28;
    do
    {
      for (int i = 0LL; i != v10; int i = (char *)i + 1)
      {
        if (*(void *)v28 != v11) {
          objc_enumerationMutation(v8);
        }
        uint64_t v13 = *(void *)(*((void *)&v27 + 1) + 8LL * (void)i);
        __int128 v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "stringByAppendingPathComponent:", v13, v21, v22));
        else {
          BOOL v15 = 0;
        }
        if (v15)
        {
          uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v4 contentsAtPath:v14]);
          -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v16, v13);
        }
      }

      id v10 = [v8 countByEnumeratingWithState:&v27 objects:v32 count:16];
    }

    while (v10);
  }

  id v25 = v21;
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v7,  1LL,  &v25));
  id v18 = v25;

  id v19 = v17;
  SavePointer(v22, (uint64_t *)[v19 bytes], objc_msgSend(v19, "length"), a3);

  objc_autoreleasePoolPop(context);
  return a3;
}

void SnapshotResidencySets(uint64_t a1, uint64_t a2)
{
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(a2 + 24) + 8 * v4);
      if (v5) {
        uint64_t v5 = *(void *)(v5 + 8);
      }
      uint64_t v7 = v5;
      entry = find_entry(a1, &v7, 8uLL, 0LL);
      ResidencySetTakeSnapshotInternal(*(void **)(*(void *)(*entry + 32LL) + 16LL), 1);
      ++v4;
    }

    while (v4 < *(int *)(a2 + 12));
  }

void *GTMTLDescriptorAllocator_copyData(uint64_t a1, const void *a2, size_t __n, int a4)
{
  if (__n) {
    uint64_t v4 = *(void **)(a1 + 416);
  }
  else {
    uint64_t v4 = 0LL;
  }
  *(void *)(a1 + 416) += __n;
  if (a4) {
    memcpy(v4, a2, __n);
  }
  return v4;
}

uint64_t GTMTLDescriptorAllocator_size(uint64_t a1)
{
  uint64_t v1 = 0LL;
  uint64_t v2 = 0LL;
  do
  {
    v2 += (*(void *)(a1 + v1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    v1 += 8LL;
  }

  while (v1 != 424);
  return v2;
}

uint64_t GTMTLDescriptorAllocator_rebase(uint64_t result, uint64_t a2)
{
  for (uint64_t i = 0LL; i != 424; i += 8LL)
  {
    if (((*(void *)(result + i) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) != 0) {
      uint64_t v3 = a2;
    }
    else {
      uint64_t v3 = 0LL;
    }
    a2 += (*(void *)(result + i) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    *(void *)(result + i) = v3;
  }

  return result;
}

void *GTMPSDescriptorAllocator_copyData(uint64_t a1, const void *a2, size_t __n, int a4)
{
  if (__n) {
    uint64_t v4 = *(void **)(a1 + 72);
  }
  else {
    uint64_t v4 = 0LL;
  }
  *(void *)(a1 + 72) += __n;
  if (a4) {
    memcpy(v4, a2, __n);
  }
  return v4;
}

void *GTMPSDescriptorAllocator_copyFloats(uint64_t a1, const void *a2, uint64_t a3, int a4)
{
  if (a3) {
    uint64_t v4 = *(void **)(a1 + 64);
  }
  else {
    uint64_t v4 = 0LL;
  }
  *(void *)(a1 + 64) += 4 * a3;
  if (a4) {
    memcpy(v4, a2, 4 * a3);
  }
  return v4;
}

void *GTMPSDescriptorAllocator_copyFloats2(uint64_t a1, const void *a2, uint64_t a3, int a4)
{
  if (a3) {
    uint64_t v4 = *(void **)(a1 + 56);
  }
  else {
    uint64_t v4 = 0LL;
  }
  *(void *)(a1 + 56) += 8 * a3;
  if (a4) {
    memcpy(v4, a2, 8 * a3);
  }
  return v4;
}

uint64_t GTMPSDescriptorAllocator_size(uint64_t a1)
{
  uint64_t v1 = 0LL;
  int64x2_t v2 = 0uLL;
  int64x2_t v3 = vdupq_n_s64(0xFuLL);
  int8x16_t v4 = (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFF0LL);
  do
  {
    int64x2_t v2 = vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vaddq_s64(*(int64x2_t *)(a1 + v1), v3), v4), v2);
    v1 += 16LL;
  }

  while (v1 != 80);
  return vaddvq_s64(v2);
}

uint64_t GTMPSDescriptorAllocator_rebase(uint64_t result, uint64_t a2)
{
  for (uint64_t i = 0LL; i != 80; i += 8LL)
  {
    if (((*(void *)(result + i) + 15LL) & 0xFFFFFFFFFFFFFFF0LL) != 0) {
      uint64_t v3 = a2;
    }
    else {
      uint64_t v3 = 0LL;
    }
    a2 += (*(void *)(result + i) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
    *(void *)(result + i) = v3;
  }

  return result;
}

void *CopyGTMPSPluginCNNConvolutionData(void *a1, __int128 *a2, int a3)
{
  size_t v6 = *((unsigned int *)a2 + 14);
  uint64_t v7 = *((unsigned int *)a2 + 15);
  __int128 v33 = *a2;
  uint64_t v9 = *((void *)a2 + 6);
  uint64_t v8 = *((void *)a2 + 7);
  id v10 = (const void *)*((void *)a2 + 2);
  uint64_t v11 = a1[9];
  if ((_DWORD)v6) {
    double result = (void *)a1[9];
  }
  else {
    double result = 0LL;
  }
  a1[9] = v11 + v6;
  id v31 = result;
  uint64_t v32 = v8;
  if ((a3 & 1) != 0)
  {
    memcpy(result, v10, v6);
    uint64_t v13 = (const void *)*((void *)a2 + 3);
    BOOL v14 = v7 == 0;
    BOOL v15 = a1 + 8;
    if ((_DWORD)v7) {
      uint64_t v16 = (void *)a1[8];
    }
    else {
      uint64_t v16 = 0LL;
    }
    *BOOL v15 = a1[8] + 4 * v7;
    double result = memcpy(v16, v13, 4 * v7);
  }

  else
  {
    BOOL v14 = v7 == 0;
    BOOL v15 = a1 + 8;
    if ((_DWORD)v7) {
      uint64_t v16 = (void *)a1[8];
    }
    else {
      uint64_t v16 = 0LL;
    }
    *BOOL v15 = a1[8] + 4 * v7;
  }

  int v17 = *((_DWORD *)a2 + 2);
  if (v17 == 2)
  {
    id v21 = (const void *)*((void *)a2 + 4);
    char v20 = (void *)*v15;
    *v15 += 1024LL;
    if (a3) {
      double result = memcpy(v20, v21, 0x400uLL);
    }
    goto LABEL_24;
  }

  if (v17 != 1)
  {
    char v20 = 0LL;
LABEL_24:
    id v19 = 0LL;
    goto LABEL_25;
  }

  id v18 = (const void *)*((void *)a2 + 5);
  if (v14) {
    id v19 = 0LL;
  }
  else {
    id v19 = (void *)a1[7];
  }
  a1[7] += 8 * v7;
  if (a3) {
    double result = memcpy(v19, v18, 8 * v7);
  }
  char v20 = 0LL;
LABEL_25:
  uint64_t v22 = (const void **)*((void *)a2 + 6);
  if (v22)
  {
    __int128 v23 = *v22;
    __int128 v24 = (void *)*v15;
    uint64_t v25 = *v15 + 4 * v7;
    *BOOL v15 = v25;
    if ((a3 & 1) != 0)
    {
      if (v14) {
        char v26 = 0LL;
      }
      else {
        char v26 = v24;
      }
      memcpy(v26, v23, 4 * v7);
      __int128 v27 = *(const void **)(*((void *)a2 + 6) + 8LL);
      if (v14) {
        __int128 v28 = 0LL;
      }
      else {
        __int128 v28 = (void *)a1[8];
      }
      a1[8] += 4 * v7;
      double result = memcpy(v28, v27, 4 * v7);
      __int128 v29 = (void *)a1[6];
      *__int128 v29 = v26;
      v29[1] = v28;
    }

    else
    {
      *BOOL v15 = v25 + 4 * v7;
    }

    uint64_t v9 = a1[6];
    a1[6] = v9 + 16;
  }

  if (a3)
  {
    uint64_t v30 = a1[3];
    *(_OWORD *)uint64_t v30 = v33;
    *(void *)(v30 + 16) = v31;
    *(void *)(v30 + 24) = v16;
    *(void *)(v30 + 32) = v20;
    *(void *)(v30 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v19;
    *(void *)(v30 + 4_Block_object_dispose(va, 8) = v9;
    *(void *)(v30 + 56) = v32;
  }

  a1[3] += 64LL;
  return result;
}

uint64_t GTMTLCounterSet_structType(const char *a1)
{
  if (!a1) {
    return -1LL;
  }
  if (!strcmp(a1, "timestamp")) {
    return 0LL;
  }
  if (!strcmp(a1, "stageutilization")) {
    return 1LL;
  }
  if (!strcmp(a1, "statistic")) {
    return 2LL;
  }
  return -1LL;
}

void *GTMTLDescriptorAllocator_copyString(uint64_t a1, char *__s, int a3)
{
  if (__s)
  {
    size_t v6 = strlen(__s);
    uint64_t v7 = (void *)(a1 + 416);
    uint64_t v8 = *(void *)(a1 + 416);
    size_t v9 = v6 + 1;
    if (v6 != -1LL)
    {
      id v10 = *(void **)(a1 + 416);
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v7 = (void *)(a1 + 416);
    uint64_t v8 = *(void *)(a1 + 416);
  }

  size_t v9 = 0LL;
  id v10 = 0LL;
LABEL_6:
  *uint64_t v7 = v8 + v9;
  if (a3) {
    memcpy(v10, __s, v9);
  }
  return v10;
}

uint64_t GTLowerBound(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  uint64_t v3 = *(void *)(a1 + 24);
  int v4 = *(_DWORD *)(a1 + 12);
  if (v4 >= 1)
  {
    do
    {
      int v8 = v4 >> 1;
      uint64_t v9 = v3 + *(int *)(a1 + 8) * (uint64_t)(v4 >> 1);
      if ((a3(v9, a2) & 0x80000000) != 0)
      {
        uint64_t v3 = v9 + *(int *)(a1 + 8);
        int v8 = v4 + ~v8;
      }

      int v4 = v8;
    }

    while (v8 > 0);
  }

  return v3;
}

uint64_t GTBinarySearch(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  int v3 = *(_DWORD *)(a1 + 12);
  if (v3 < 1) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 24);
  while (1)
  {
    int v8 = v3 >> 1;
    uint64_t v9 = v7 + *(int *)(a1 + 8) * (uint64_t)(v3 >> 1);
    int v10 = a3(v9, a2);
    if (!v10) {
      break;
    }
    if (v10 < 0)
    {
      uint64_t v7 = v9 + *(int *)(a1 + 8);
      int v8 = v3 + ~v8;
    }

    int v3 = v8;
    if (v8 <= 0) {
      return 0LL;
    }
  }

  return v9;
}

uint64_t GTInsert(apr_array_header_t *a1, int a2)
{
  return (uint64_t)&a1->elts[a1->elt_size * (uint64_t)a2];
}

void GTTraceDump_writeNewArchive(uint64_t a1, const void *a2, const char *a3)
{
  __int128 v77 = 0u;
  __int128 v76 = 0u;
  __int128 v75 = 0u;
  __int128 v74 = 0u;
  __int128 v73 = 0u;
  __int128 v72 = 0u;
  uint64_t v70 = 0LL;
  size_t v6 = newpool;
  uint64_t v7 = apr_hash_make(newpool);
  uint64_t v68 = v7;
  int v8 = apr_hash_make(v6);
  uint64_t v69 = v8;
  uint64_t v71 = apr_hash_make(v6);
  uint64_t v9 = gt_filepath_merge(a3, "gttrace-dna", v6);
  int v10 = open(v9, 513, 438LL);
  write(v10, &DNA1_BYTES, 0x42EEuLL);
  close(v10);
  uint64_t v11 = gt_filepath_merge(a3, "gttrace-range", v6);
  int v12 = open(v11, 513, 438LL);
  write(v12, a2, 0x28uLL);
  close(v12);
  uint64_t v13 = apr_array_make(v6, *(_DWORD *)(a1 + 48), 64);
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 16) = a1;
  *(_DWORD *)(a1 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0;
  BOOL v14 = apr_hash_next((apr_hash_index_t *)(a1 + 16));
  if (v14)
  {
    BOOL v15 = v14;
    do
    {
      uint64_t v16 = apr_array_push(v13);
      int v17 = *(__int128 **)(*((void *)v15 + 1) + 32LL);
      __int128 v18 = *v17;
      __int128 v19 = v17[1];
      __int128 v20 = v17[3];
      void v16[2] = v17[2];
      v16[3] = v20;
      _OWORD *v16 = v18;
      v16[1] = v19;
      BOOL v15 = apr_hash_next(v15);
    }

    while (v15);
  }

  qsort(v13->elts, v13->nelts, v13->elt_size, (int (__cdecl *)(const void *, const void *))CompareStream);
  id v21 = gt_filepath_merge(a3, "gttrace-streams", v6);
  int v22 = open(v21, 513, 438LL);
  write(v22, v13->elts, v13->elt_size * (uint64_t)v13->nelts);
  close(v22);
  __int128 v23 = (int *)**((void **)v13->elts + 3);
  uint64_t v67 = (pthread_mutex_t *)(v23 + 66);
  pthread_mutex_lock((pthread_mutex_t *)(v23 + 66));
  if (*v23 < 1)
  {
    uint64_t v26 = 0LL;
    uint64_t v27 = 0LL;
  }

  else
  {
    uint64_t v24 = 0LL;
    uint64_t v25 = 0LL;
    do
    {
      GTTraceStore_buildDebugContext( (uint64_t)&v68,  *(unsigned int **)(*((void *)v23 + 1) + v24),  *(void *)(*((void *)v23 + 1) + v24 + 8));
      ++v25;
      v24 += 16LL;
    }

    while (v25 < *v23);
    uint64_t v26 = *((void *)&v77 + 1);
    uint64_t v27 = v76 + *((void *)&v74 + 1);
    uint64_t v7 = v68;
    int v8 = v69;
  }

  int v28 = getpagesize();
  size_t v29 = (v27 + v28 - 1 + v26) & -v28;
  uint64_t v30 = gt_filepath_merge(a3, "gttrace-store", v6);
  int v31 = open(v30, 514, 438LL);
  ftruncate(v31, v29);
  size_t v66 = v29;
  uint64_t v32 = mmap(0LL, v29, 2, 1, v31, 0LL);
  close(v31);
  __int128 v33 = apr_array_make(*(apr_pool_t **)v7, *((_DWORD *)v7 + 12), 8);
  *((void *)v7 + 3) = 0LL;
  *((void *)v7 + 4) = 0LL;
  *((void *)v7 + 2) = v7;
  *((_DWORD *)v7 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0;
  int v34 = apr_hash_next((apr_hash_t *)((char *)v7 + 16));
  if (v34)
  {
    unint64_t v35 = v34;
    do
    {
      uint64_t v36 = *(void *)(*(void *)(*((void *)v35 + 1) + 32LL) + 16LL);
      *(void *)apr_array_push(v33) = v36;
      unint64_t v35 = apr_hash_next(v35);
    }

    while (v35);
  }

  qsort(v33->elts, v33->nelts, v33->elt_size, (int (__cdecl *)(const void *, const void *))CompareUInt64);
  if (v33->nelts < 1)
  {
    uint64_t v38 = 0LL;
  }

  else
  {
    uint64_t v37 = 0LL;
    uint64_t v38 = 0LL;
    do
    {
      v79[0] = *(void *)&v33->elts[8 * v37];
      uint64_t v39 = &v38[(void)v32];
      uint64_t v40 = *(void *)(*find_entry((uint64_t)v7, v79, 8uLL, 0LL) + 32LL);
      *((_OWORD *)v39 + 2) = 0u;
      *((_OWORD *)v39 + 3) = 0u;
      *(_OWORD *)uint64_t v39 = 0u;
      *((_OWORD *)v39 + 1) = 0u;
      char v39[8] = *(_BYTE *)(v40 + 8);
      *((void *)v39 + 2) = *(void *)(v40 + 16);
      signed int v41 = 64;
      do
      {
        unsigned int v42 = atomic_load((unsigned int *)(v40 + 4));
        unsigned int v43 = v42 - 64;
        memcpy(&v39[v41], (const void *)(v40 + 64), (int)(v42 - 64));
        v41 += v43;
        uint64_t v40 = *(void *)(v40 + 40);
      }

      while (v40);
      atomic_store(v41, (unsigned int *)v39 + 1);
      uint64_t v44 = (v41 + 63) & 0xFFFFFFC0;
      *(_DWORD *)&v38[(void)v32] = v44;
      uint64_t v45 = &v38[v44];
      unint64_t v46 = &v38[v44 + (void)v32];
      uint64_t v47 = *find_entry((uint64_t)v8, v79, 8uLL, 0LL);
      if (v47 && (uint64_t v48 = *(void *)(v47 + 32)) != 0)
      {
        uint64_t v49 = v46;
        do
        {
          size_t v50 = atomic_load((unsigned int *)(v48 + 4));
          memcpy(v49, (const void *)v48, v50);
          unsigned int v51 = atomic_load((unsigned int *)(v48 + 4));
          uint64_t v52 = (v51 + 63) & 0xFFFFFFC0;
          *(_DWORD *)uint64_t v49 = v52;
          v49[3] = 0LL;
          v49[5] = 0LL;
          uint64_t v49 = (void *)((char *)v49 + v52);
          uint64_t v48 = *(void *)(v48 + 40);
        }

        while (v48);
      }

      else
      {
        uint64_t v49 = v46;
      }

      uint64_t v38 = (char *)v49 + v45 - v46;
      ++v37;
    }

    while (v37 < v33->nelts);
  }

  v33->int nelts = 0;
  uint64_t v53 = (uint64_t)v71;
  uint64_t v54 = (apr_hash_t *)((char *)v71 + 16);
  *((void *)v71 + 3) = 0LL;
  *(void *)(v53 + 32) = 0LL;
  *(void *)(v53 + 16) = v53;
  *(_DWORD *)(v53 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0;
  uint64_t v55 = apr_hash_next(v54);
  if (v55)
  {
    uint64_t v56 = v55;
    do
    {
      uint64_t v57 = **(void **)(*((void *)v56 + 1) + 16LL);
      *(void *)apr_array_push(v33) = v57;
      uint64_t v56 = apr_hash_next(v56);
    }

    while (v56);
  }

  qsort(v33->elts, v33->nelts, v33->elt_size, (int (__cdecl *)(const void *, const void *))CompareUInt64);
  uint64_t v58 = &v38[(void)v32];
  *((_OWORD *)v58 + 2) = 0u;
  *((_OWORD *)v58 + 3) = 0u;
  *(_OWORD *)uint64_t v58 = 0u;
  *((_OWORD *)v58 + 1) = 0u;
  void v58[8] = 3;
  *((void *)v58 + 4) = v58;
  if (v33->nelts < 1)
  {
    signed int v60 = 64;
  }

  else
  {
    uint64_t v59 = 0LL;
    signed int v60 = 64;
    do
    {
      v79[0] = *(void *)&v33->elts[8 * v59];
      uint64_t v61 = *(void **)(*find_entry(v53, v79, 8uLL, 0LL) + 32LL);
      int v62 = (8 * *v61 + 23) & 0xFFFFFFF8;
      memcpy(&v58[v60], v61 - 1, (8LL * *v61 + 23) & 0xFFFFFFFF8LL);
      v60 += v62;
      ++v59;
    }

    while (v59 < v33->nelts);
  }

  atomic_store(v60, (unsigned int *)v58 + 1);
  uint64_t v63 = (v60 + 63) & 0xFFFFFFC0;
  *(_DWORD *)&v38[(void)v32] = v63;
  uint64_t v64 = &v38[v63];
  uint64_t v65 = &v64[(void)v32];
  *(_OWORD *)(v65 + 36) = 0u;
  *(_OWORD *)(v65 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0u;
  *((_OWORD *)v65 + 3) = 0u;
  *(_OWORD *)(v65 + 4) = 0u;
  *(_DWORD *)uint64_t v65 = v66 - (_DWORD)v64;
  *((void *)v65 + 4) = v65;
  munmap(v32, v66);
  pthread_mutex_unlock(v67);
  apr_pool_destroy(newpool);
}

uint64_t CompareStream(unint64_t *a1, unint64_t *a2)
{
  if (a1)
  {
    unint64_t v2 = *a1;
    if (a2)
    {
LABEL_3:
      unint64_t v3 = *a2;
      goto LABEL_6;
    }
  }

  else
  {
    unint64_t v2 = 0LL;
    if (a2) {
      goto LABEL_3;
    }
  }

  unint64_t v3 = 0LL;
LABEL_6:
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t CompareUInt64(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 != *a2;
  }
}

char *CopyFilePath(uint64_t a1, uint64_t a2, char *a3)
{
  BOOL v5 = *(const char ***)(a2 + 584);
  size_t v6 = *(apr_pool_t ***)(a2 + 592);
  uint64_t v7 = *v6;
  DatCATransform3D a = (uint64_t *)GTCaptureArchive_readData(v5, v6, a3, *v6, 0LL);
  GTMTLCaptureState_storePointer(a1, a3, Data, v9);
  apr_pool_clear(v7);
  return a3;
}

#error "CE2F8: too big function (funcsize=0)"
void WriteTextureInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    int v8 = 0u;
    uint64_t v9 = 0LL;
    __int128 v20 = 0u;
    id v21 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    uint64_t v16 = 0u;
    int v17 = 0u;
    BOOL v14 = 0u;
    BOOL v15 = 0u;
    int v12 = 0u;
    uint64_t v11 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 80;
    int v10 = -1LL;
    WORD1(v15) = 2;
    uint64_t v13 = 0xFFFFFFFFFFFFFFFFLL;
    int v22 = 0xFFFFFFFFLL;
    GTMTLSMTexture_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    WriteTextureInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void *name_array(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v6 = a3;
    int v8 = a1;
    do
    {
      uint64_t v9 = *a2++;
      uint64_t v11 = v9;
      *v8++ = *(void *)(*(void *)(*find_entry(a4, &v11, 8uLL, 0LL) + 32LL) + 8LL);
      --v6;
    }

    while (v6);
  }

  return a1;
}

void FlushChainedComputePipelineStateInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    uint64_t v21 = 0LL;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 29;
    uint64_t v10 = -1LL;
    __int128 v15 = 0xFFFFFFFFFFFFFFFFLL;
    GTMTLSMComputePipelineState_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    FlushChainedComputePipelineStateInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void WriteIntersectionFunctionTableInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    uint64_t v19 = 0LL;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 60;
    uint64_t v10 = -1LL;
    WORD1(v15) = 2;
    __int128 v13 = 0xFFFFFFFFFFFFFFFFLL;
    GTMTLSMIntersectionFunctionTable_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    WriteIntersectionFunctionTableInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void WriteVisibleFunctionTableInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v11 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 83;
    uint64_t v10 = -1LL;
    GTMTLSMVisibleFunctionTable_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    WriteVisibleFunctionTableInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void WriteAccelerationStructureInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v11 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 16;
    uint64_t v10 = -1LL;
    WORD1(v15) = 2;
    __int128 v13 = 0xFFFFFFFFFFFFFFFFLL;
    GTMTLSMAccelerationStructure_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    WriteAccelerationStructureInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void WriteBufferInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    __int128 v15 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 22;
    uint64_t v10 = -1LL;
    WORD1(v15) = 2;
    __int128 v13 = 0xFFFFFFFFFFFFFFFFLL;
    __int128 v16 = 0xFFFFFFFFFFFFFFFFLL;
    GTMTLSMBuffer_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    WriteBufferInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void FlushChainedDynamicLibraryInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v11 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 37;
    uint64_t v10 = -1LL;
    GTMTLSMDynamicLibrary_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    FlushChainedDynamicLibraryInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void FlushChainedFunctionInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    uint64_t v17 = 0LL;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 43;
    uint64_t v10 = -1LL;
    GTMTLSMFunction_processTraceFuncWithMap((uint64_t)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    FlushChainedFunctionInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void WriteIndirectCommandBufferInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v11 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 57;
    uint64_t v10 = -1LL;
    WORD1(v15) = 2;
    __int128 v13 = 0xFFFFFFFFFFFFFFFFLL;
    GTMTLSMIndirectCommandBuffer_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    WriteIndirectCommandBufferInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void FlushChainedLibraryInfo_(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    uint64_t v19 = 0LL;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 62;
    uint64_t v10 = -1LL;
    GTMTLSMLibrary_processTraceFuncWithMap((uint64_t)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    FlushChainedLibraryInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void FlushChainedRenderPipelineStateInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    LODWORD(v_Block_object_dispose(va, 8) = 71;
    uint64_t v10 = -1LL;
    __int128 v15 = 0xFFFFFFFFFFFFFFFFLL;
    GTMTLSMRenderPipelineState_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    FlushChainedRenderPipelineStateInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void WriteSamplerStateInfo_(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    __int128 v12 = 0u;
    __int128 v11 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 75;
    uint64_t v10 = -1LL;
    uint64_t v14 = 0LL;
    __int128 v13 = 0xFFFFFFFFFFFFFFFFLL;
    GTMTLSMSamplerState_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    WriteSamplerStateInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void FlushChainedPipelineLibraryInfo_(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (GTTraceFunc_argumentBytesWithMap((void *)a3, *(unsigned __int8 *)(a3 + 14), *(void *)(a2 + 24)))
  {
    __int128 v8 = 0u;
    uint64_t v9 = 0LL;
    uint64_t v14 = 0LL;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v11 = 0u;
    LODWORD(v_Block_object_dispose(va, 8) = 67;
    uint64_t v10 = -1LL;
    GTMTLSMPipelineLibrary_processTraceFuncWithMap((char *)&v8, *(void *)(a2 + 24), (uint64_t *)a3);
    FlushChainedPipelineLibraryInfo(a1, (uint64_t)&v8, *(void *)(a2 + 16), a4);
  }

void *DecodeDYMTLRenderPassDescriptor(uint64_t a1, uint64_t a2, uint64_t a3, int a4, void *a5)
{
  int v8 = a4;
  double result = a5;
  unsigned int v10 = *(_DWORD *)a1;
  __int128 v11 = (uint64_t *)(a1 + 16);
  __dst[99] = *(void *)(a1 + 8);
  uint64_t v108 = (uint64_t)result;
  unsigned int v88 = v10;
  int v89 = a4;
  while (1)
  {
    __int128 v12 = v11;
    uint64_t v13 = *v11;
    uint64_t v14 = v11[1];
    char v15 = *((_BYTE *)v11 + 16);
    __int16 v16 = *((unsigned __int8 *)v11 + 24);
    __int16 v17 = *((unsigned __int8 *)v11 + 32);
    uint64_t v18 = v11[5];
    char v19 = *((_BYTE *)v11 + 48);
    __int16 v20 = *((_WORD *)v11 + 28);
    if (*v11 == -1) {
      break;
    }
    if (v10 <= 0x12)
    {
      char v21 = 0;
      char v24 = 0;
      __int128 v22 = *(_OWORD *)(v11 + 11);
      __int128 v23 = *(_OWORD *)(v11 + 13);
      v11 += 15;
      if (v8)
      {
LABEL_10:
        __int16 v25 = *((_WORD *)v12 + 32);
        char v26 = *((_BYTE *)v12 + 72);
        char v27 = *((_BYTE *)v12 + 80);
        if (result)
        {
          char v90 = *((_BYTE *)v12 + 72);
          char v91 = *((_BYTE *)v12 + 80);
          char v92 = v24;
          char v96 = v21;
          __int128 v100 = v23;
          __int128 v104 = v22;
          Stream_10858 = (uint64_t *)GetStream_10858((uint64_t)result, v14);
          if (Stream_10858) {
            uint64_t v14 = *Stream_10858;
          }
          else {
            uint64_t v14 = 0LL;
          }
          __int128 v29 = (uint64_t *)GetStream_10858(v108, v18);
          if (v29) {
            uint64_t v18 = *v29;
          }
          else {
            uint64_t v18 = 0LL;
          }
          double result = (void *)v108;
          unsigned int v10 = v88;
          int v8 = v89;
          __int128 v23 = v100;
          __int128 v22 = v104;
          char v24 = v92;
          char v21 = v96;
          char v26 = v90;
          char v27 = v91;
        }

        __int128 v30 = &__dst[8 * v13];
        *__int128 v30 = v18;
        v30[1] = v14;
        *((_WORD *)v30 + _Block_object_dispose(va, 8) = v17;
        *((_WORD *)v30 + 9) = v25;
        *((_WORD *)v30 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v20;
        *((_WORD *)v30 + 11) = v16;
        *((_BYTE *)v30 + 24) = v15;
        *((_BYTE *)v30 + 25) = v26;
        *((_BYTE *)v30 + 26) = v19;
        *((_BYTE *)v30 + 27) = v27;
        *((_BYTE *)v30 + 2_Block_object_dispose(va, 8) = v21;
        *((_BYTE *)v30 + 29) = v24;
        *((_WORD *)v30 + 15) = 0;
        *((_OWORD *)v30 + 2) = v22;
        *((_OWORD *)v30 + 3) = v23;
      }
    }

    else
    {
      char v21 = *((_BYTE *)v11 + 88);
      __int128 v22 = *((_OWORD *)v11 + 6);
      __int128 v23 = *((_OWORD *)v11 + 7);
      if (v10 < 0x27)
      {
        char v24 = 0;
        v11 += 16;
        if (v8) {
          goto LABEL_10;
        }
      }

      else
      {
        v11 += 17;
        char v24 = *((_BYTE *)v12 + 128);
        if (v8) {
          goto LABEL_10;
        }
      }
    }
  }

  if (v10 >= 0x13)
  {
    char v31 = *((_BYTE *)v11 + 88);
    uint64_t v32 = v11[12];
    if (v10 < 0x27)
    {
      char v34 = 0;
      __int128 v33 = v11 + 16;
    }

    else
    {
      __int128 v33 = v11 + 17;
      char v34 = *((_BYTE *)v11 + 128);
    }

    goto LABEL_26;
  }

  char v34 = 0;
  char v31 = 0;
  char v35 = 0;
  uint64_t v32 = v12[11];
  __int128 v33 = v12 + 15;
  if (v10 >= 5)
  {
LABEL_26:
    uint64_t v36 = *v33++;
    char v37 = v36;
    else {
      char v35 = v37;
    }
    if (v8) {
      goto LABEL_30;
    }
  }

  else
  {
    if (!v8) {
      goto LABEL_39;
    }
LABEL_30:
    __int16 v38 = *((_WORD *)v12 + 32);
    char v39 = *((_BYTE *)v12 + 72);
    char v40 = *((_BYTE *)v12 + 80);
    if (result)
    {
      char v93 = *((_BYTE *)v12 + 80);
      char v97 = v34;
      char v101 = v31;
      int v105 = v33;
      signed int v41 = (uint64_t *)GetStream_10858((uint64_t)result, v14);
      if (v41) {
        uint64_t v14 = *v41;
      }
      else {
        uint64_t v14 = 0LL;
      }
      unsigned int v42 = (uint64_t *)GetStream_10858(v108, v18);
      if (v42) {
        uint64_t v18 = *v42;
      }
      else {
        uint64_t v18 = 0LL;
      }
      double result = (void *)v108;
      unsigned int v10 = v88;
      int v8 = v89;
      __int128 v33 = v105;
      char v34 = v97;
      char v31 = v101;
      char v40 = v93;
    }

    __dst[84] = v18;
    __dst[85] = v14;
    LOWORD(__dst[86]) = v17;
    WORD1(__dst[86]) = v38;
    WORD2(__dst[86]) = v20;
    HIWORD(__dst[86]) = v16;
    LOBYTE(__dst[87]) = v15;
    BYTE1(__dst[87]) = v39;
    BYTE2(__dst[87]) = v19;
    BYTE3(__dst[87]) = v40;
    BYTE4(__dst[87]) = v31;
    BYTE5(__dst[87]) = v34;
    HIWORD(__dst[87]) = 0;
    __dst[88] = v32;
    LOBYTE(__dst[89]) = v35;
    *(_DWORD *)((char *)&__dst[89] + 1) = 0;
    HIDWORD(__dst[89]) = 0;
  }

LABEL_46:
    uint64_t v47 = *v33;
    uint64_t v48 = v33[4];
    char v49 = *((_BYTE *)v33 + 8);
    __int16 v50 = *((unsigned __int8 *)v33 + 16);
    __int16 v51 = *((unsigned __int8 *)v33 + 24);
    char v52 = *((_BYTE *)v33 + 40);
    __int16 v53 = *((unsigned __int8 *)v33 + 48);
    __int16 v54 = *((unsigned __int8 *)v33 + 56);
    char v55 = *((_BYTE *)v33 + 64);
    char v56 = *((_BYTE *)v33 + 72);
    unsigned int v57 = v44;
    if (result)
    {
      unsigned int v94 = v44;
      char v98 = v49;
      char v102 = v46;
      char v106 = v43;
      uint64_t v58 = (uint64_t *)GetStream_10858((uint64_t)result, v47);
      if (v58) {
        uint64_t v47 = *v58;
      }
      else {
        uint64_t v47 = 0LL;
      }
      uint64_t v59 = (uint64_t *)GetStream_10858(v108, v48);
      if (v59) {
        uint64_t v48 = *v59;
      }
      else {
        uint64_t v48 = 0LL;
      }
      double result = (void *)v108;
      unsigned int v10 = v88;
      int v8 = v89;
      char v43 = v106;
      char v49 = v98;
      char v46 = v102;
      unsigned int v57 = v94;
    }

    __dst[90] = v48;
    __dst[91] = v47;
    LOWORD(__dst[92]) = v51;
    WORD1(__dst[92]) = v54;
    WORD2(__dst[92]) = v53;
    HIWORD(__dst[92]) = v50;
    LOBYTE(__dst[93]) = v49;
    BYTE1(__dst[93]) = v55;
    BYTE2(__dst[93]) = v52;
    BYTE3(__dst[93]) = v56;
    BYTE4(__dst[93]) = v43;
    BYTE5(__dst[93]) = v46;
    HIWORD(__dst[93]) = 0;
    __dst[94] = v57;
  }

LABEL_55:
  if (v10 >= 7)
  {
    int v60 = *v45;
    HIWORD(__dst[100]) = *v45;
    if (v10 < 0xD)
    {
      int v67 = 0;
      int v66 = 0;
      int v65 = 0;
      int v64 = 0;
      int v63 = 0;
      int v62 = 0;
      int v61 = 0;
    }

    else
    {
      int v61 = v45[4];
      WORD2(__dst[100]) = v45[4];
      int v62 = *((_DWORD *)v45 + 4);
      LODWORD(__dst[100]) = v62;
      int v63 = v45[12];
      HIWORD(__dst[101]) = v45[12];
      int v64 = v45[16];
      WORD2(__dst[101]) = v45[16];
      int v65 = v45[20];
      WORD1(__dst[101]) = v45[20];
      int v66 = v45[24];
      LOWORD(__dst[101]) = v45[24];
      int v67 = *((unsigned __int8 *)v45 + 56);
      LOBYTE(__dst[102]) = *((_BYTE *)v45 + 56);
      if (v10 != 13)
      {
        uint64_t v68 = *((void *)v45 + 8);
        uint64_t v69 = v45 + 36;
        uint64_t v70 = *(_DWORD **)(a3 + 408);
        __dst[95] = v70;
        __dst[96] = (int)v68;
        if (v68 << 32)
        {
          unint64_t v71 = 2LL * (int)v68;
          if (v71 <= 1) {
            unint64_t v71 = 1LL;
          }
          __int128 v72 = v70;
          do
          {
            if (v8) {
              *__int128 v72 = *(_DWORD *)v69;
            }
            v69 += 4;
            ++v72;
            --v71;
          }

          while (v71);
        }

        *(void *)(a3 + 40_Block_object_dispose(va, 8) = &v70[2 * (_DWORD)v68];
        if (v10 >= 0x14)
        {
          BYTE4(__dst[94]) = *(void *)v69;
          if (v10 >= 0x18)
          {
            BYTE2(__dst[102]) = *((void *)v69 + 1);
            if (v10 >= 0x21)
            {
              __dst[98] = *((void *)v69 + 2);
              if (v10 >= 0x27)
              {
                BYTE1(__dst[102]) = *((void *)v69 + 3);
                if (v10 >= 0x2A)
                {
                  __dst[97] = *((void *)v69 + 4);
                  BYTE3(__dst[102]) = *((void *)v69 + 5);
                  if (v10 >= 0x32)
                  {
                    int v95 = v66;
                    int v99 = v67;
                    for (uint64_t i = (uint64_t *)(v69 + 44); ; i += 6)
                    {
                      uint64_t v74 = *(i - 5);
                      if (v74 == -1) {
                        break;
                      }
                      if (v8)
                      {
                        uint64_t v75 = *(i - 4);
                        uint64_t v76 = *(i - 3);
                        uint64_t v78 = *(i - 2);
                        uint64_t v77 = *(i - 1);
                        uint64_t v79 = *i;
                        if (result)
                        {
                          uint64_t v103 = *(i - 1);
                          uint64_t v107 = *(i - 3);
                          uint64_t v80 = (uint64_t *)GetStream_10858((uint64_t)result, v75);
                          if (v80) {
                            uint64_t v75 = *v80;
                          }
                          else {
                            uint64_t v75 = 0LL;
                          }
                          double result = (void *)v108;
                          unsigned int v10 = v88;
                          int v8 = v89;
                          uint64_t v76 = v107;
                          uint64_t v77 = v103;
                        }

                        __int128 v81 = &__dst[5 * v74 + 64];
                        *__int128 v81 = v79;
                        v81[1] = v78;
                        v81[2] = v75;
                        v81[3] = v77;
                        v81[4] = v76;
                      }
                    }

                    int v66 = v95;
                    int v67 = v99;
                    if (v10 >= 0x43) {
                      BYTE4(__dst[102]) = *(i - 4);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    if (v60 == 0xFFFF) {
      HIWORD(__dst[100]) = 0;
    }
    if (v61 == 0xFFFF) {
      WORD2(__dst[100]) = 0;
    }
    if (v62 == -1) {
      LODWORD(__dst[100]) = 0;
    }
    if (v63 == 0xFFFF) {
      HIWORD(__dst[101]) = 0;
    }
    if (v64 == 0xFFFF) {
      WORD2(__dst[101]) = 0;
    }
    if (v65 == 0xFFFF) {
      WORD1(__dst[101]) = 0;
    }
    if (v66 == 0xFFFF) {
      LOWORD(__dst[101]) = 0;
    }
    if (v67 == 255) {
      LOBYTE(__dst[102]) = 0;
    }
  }

  uint64_t v82 = *(char **)(a3 + 240);
  *(void *)(a3 + 24mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = v82 + 824;
  if (v8)
  {
    if (!result)
    {
      id v85 = &__dst[98];
      goto LABEL_105;
    }

    uint64_t v83 = (uint64_t *)GetStream_10858((uint64_t)result, __dst[99]);
    if (v83) {
      uint64_t v84 = *v83;
    }
    else {
      uint64_t v84 = 0LL;
    }
    __dst[99] = v84;
    id v85 = (uint64_t *)GetStream_10858(v108, __dst[98]);
    if (v85) {
LABEL_105:
    }
      uint64_t v86 = *v85;
    else {
      uint64_t v86 = 0LL;
    }
    __dst[98] = v86;
    return memcpy(v82, __dst, 0x338uLL);
  }

  return result;
}

uint64_t GetStream_10858(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = a2;
  entry = find_entry(*(void *)(a1 + 24), &v7, 8uLL, 0LL);
  if (*entry
    && (uint64_t v4 = *(void *)(*entry + 32LL)) != 0
    && (unint64_t v5 = atomic_load((unint64_t *)(*(void *)(a1 + 16) + 72LL)), v5 < *(void *)(v4 + 24)))
  {
    return *(void *)(v4 + 8);
  }

  else
  {
    return 0LL;
  }

uint64_t EncodeDYMTLRenderPassDescriptor(uint64_t a1, void *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v112 = a2;
  unint64_t v114 = a3;
  if (a3 >= 8) {
    *a2 = 81LL;
  }
  uint64_t v113 = 8LL;
  uint64_t v111 = *(void *)(a1 + 792);
  entry = find_entry(a4, &v111, 8uLL, 0LL);
  if (*entry) {
    uint64_t v7 = *(void *)(*entry + 32LL);
  }
  else {
    uint64_t v7 = 0LL;
  }
  uint64_t v8 = v113 + 8;
  if (v113 + 8 <= v114)
  {
    *(void *)((char *)v112 + v113) = *(void *)(v7 + 8);
    uint64_t v8 = v113 + 8;
  }

  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v113 = v8;
  do
  {
    __int128 v11 = (uint64_t *)(a1 + v9);
    uint64_t v12 = *(void *)(a1 + v9 + 8);
    if (v12)
    {
      uint64_t v13 = v8 + 8;
      if (v8 + 8 <= v114)
      {
        *(void *)((char *)v112 + v_Block_object_dispose(va, 8) = v10;
        uint64_t v13 = v113 + 8;
        uint64_t v12 = v11[1];
      }

      uint64_t v113 = v13;
      uint64_t v116 = v12;
      uint64_t v14 = find_entry(a4, &v116, 8uLL, 0LL);
      if (*v14) {
        uint64_t v15 = *(void *)(*v14 + 32LL);
      }
      else {
        uint64_t v15 = 0LL;
      }
      unint64_t v16 = v114;
      uint64_t v17 = v113 + 8;
      if (v113 + 8 <= v114)
      {
        *(void *)((char *)v112 + v113) = *(void *)(v15 + 8);
        unint64_t v16 = v114;
        uint64_t v17 = v113 + 8;
      }

      uint64_t v113 = v17;
      uint64_t v18 = v17 + 8;
      if (v17 + 8 <= v16)
      {
        *(void *)((char *)v112 + v17) = *(unsigned __int8 *)(a1 + v9 + 24);
        unint64_t v16 = v114;
        uint64_t v18 = v113 + 8;
      }

      uint64_t v113 = v18;
      uint64_t v19 = v18 + 8;
      if (v18 + 8 <= v16)
      {
        *(void *)((char *)v112 + v1_Block_object_dispose(va, 8) = *(unsigned __int16 *)(a1 + v9 + 22);
        unint64_t v16 = v114;
        uint64_t v19 = v113 + 8;
      }

      uint64_t v113 = v19;
      uint64_t v20 = v19 + 8;
      if (v19 + 8 <= v16)
      {
        *(void *)((char *)v112 + v19) = *(unsigned __int16 *)(a1 + v9 + 16);
        uint64_t v20 = v113 + 8;
      }

      uint64_t v113 = v20;
      uint64_t v115 = *v11;
      char v21 = find_entry(a4, &v115, 8uLL, 0LL);
      if (*v21) {
        uint64_t v22 = *(void *)(*v21 + 32LL);
      }
      else {
        uint64_t v22 = 0LL;
      }
      unint64_t v23 = v114;
      uint64_t v24 = v113 + 8;
      if (v113 + 8 <= v114)
      {
        *(void *)((char *)v112 + v113) = *(void *)(v22 + 8);
        unint64_t v23 = v114;
        uint64_t v24 = v113 + 8;
      }

      uint64_t v113 = v24;
      uint64_t v25 = v24 + 8;
      if (v24 + 8 <= v23)
      {
        *(void *)((char *)v112 + v24) = *(unsigned __int8 *)(a1 + v9 + 26);
        unint64_t v23 = v114;
        uint64_t v25 = v113 + 8;
      }

      uint64_t v113 = v25;
      uint64_t v26 = v25 + 8;
      if (v25 + 8 <= v23)
      {
        *(void *)((char *)v112 + v25) = *(unsigned __int16 *)(a1 + v9 + 20);
        unint64_t v23 = v114;
        uint64_t v26 = v113 + 8;
      }

      uint64_t v113 = v26;
      uint64_t v27 = v26 + 8;
      if (v26 + 8 <= v23)
      {
        *(void *)((char *)v112 + v26) = *(unsigned __int16 *)(a1 + v9 + 18);
        unint64_t v23 = v114;
        uint64_t v27 = v113 + 8;
      }

      uint64_t v113 = v27;
      uint64_t v28 = v27 + 8;
      if (v27 + 8 <= v23)
      {
        *(void *)((char *)v112 + v27) = *(unsigned __int8 *)(a1 + v9 + 25);
        unint64_t v23 = v114;
        uint64_t v28 = v113 + 8;
      }

      uint64_t v113 = v28;
      uint64_t v29 = v28 + 8;
      if (v28 + 8 <= v23)
      {
        *(void *)((char *)v112 + v2_Block_object_dispose(va, 8) = *(unsigned __int8 *)(a1 + v9 + 27);
        unint64_t v23 = v114;
        uint64_t v29 = v113 + 8;
      }

      uint64_t v113 = v29;
      uint64_t v30 = v29 + 8;
      if (v29 + 8 <= v23)
      {
        *(void *)((char *)v112 + v29) = *(unsigned __int8 *)(a1 + v9 + 28);
        uint64_t v30 = v113 + 8;
      }

      uint64_t v113 = v30;
      SaveGTMTLClearColor( &v112,  *(double *)(a1 + v9 + 32),  *(double *)(a1 + v9 + 40),  *(double *)(a1 + v9 + 48),  *(double *)(a1 + v9 + 56));
      uint64_t v8 = v113 + 8;
      if (v113 + 8 <= v114)
      {
        *(void *)((char *)v112 + v113) = *(unsigned __int8 *)(a1 + v9 + 29);
        uint64_t v8 = v113 + 8;
      }

      uint64_t v113 = v8;
    }

    ++v10;
    v9 += 64LL;
  }

  while (v9 != 512);
  uint64_t v31 = v8 + 8;
  if (v8 + 8 <= v114)
  {
    *(void *)((char *)v112 + v_Block_object_dispose(va, 8) = -1LL;
    uint64_t v31 = v113 + 8;
  }

  uint64_t v113 = v31;
  uint64_t v116 = *(void *)(a1 + 680);
  uint64_t v32 = find_entry(a4, &v116, 8uLL, 0LL);
  if (*v32) {
    uint64_t v33 = *(void *)(*v32 + 32LL);
  }
  else {
    uint64_t v33 = 0LL;
  }
  unint64_t v34 = v114;
  uint64_t v35 = v113 + 8;
  if (v113 + 8 <= v114)
  {
    *(void *)((char *)v112 + v113) = *(void *)(v33 + 8);
    unint64_t v34 = v114;
    uint64_t v35 = v113 + 8;
  }

  uint64_t v113 = v35;
  uint64_t v36 = v35 + 8;
  if (v35 + 8 <= v34)
  {
    *(void *)((char *)v112 + v35) = *(unsigned __int8 *)(a1 + 696);
    unint64_t v34 = v114;
    uint64_t v36 = v113 + 8;
  }

  uint64_t v113 = v36;
  uint64_t v37 = v36 + 8;
  if (v36 + 8 <= v34)
  {
    *(void *)((char *)v112 + v36) = *(unsigned __int16 *)(a1 + 694);
    unint64_t v34 = v114;
    uint64_t v37 = v113 + 8;
  }

  uint64_t v113 = v37;
  uint64_t v38 = v37 + 8;
  if (v37 + 8 <= v34)
  {
    *(void *)((char *)v112 + v37) = *(unsigned __int16 *)(a1 + 688);
    uint64_t v38 = v113 + 8;
  }

  uint64_t v113 = v38;
  uint64_t v115 = *(void *)(a1 + 672);
  char v39 = find_entry(a4, &v115, 8uLL, 0LL);
  if (*v39) {
    uint64_t v40 = *(void *)(*v39 + 32LL);
  }
  else {
    uint64_t v40 = 0LL;
  }
  unint64_t v41 = v114;
  uint64_t v42 = v113 + 8;
  if (v113 + 8 <= v114)
  {
    *(void *)((char *)v112 + v113) = *(void *)(v40 + 8);
    unint64_t v41 = v114;
    uint64_t v42 = v113 + 8;
  }

  uint64_t v113 = v42;
  uint64_t v43 = v42 + 8;
  if (v42 + 8 <= v41)
  {
    *(void *)((char *)v112 + v42) = *(unsigned __int8 *)(a1 + 698);
    unint64_t v41 = v114;
    uint64_t v43 = v113 + 8;
  }

  uint64_t v113 = v43;
  uint64_t v44 = v43 + 8;
  if (v43 + 8 <= v41)
  {
    *(void *)((char *)v112 + v43) = *(unsigned __int16 *)(a1 + 692);
    unint64_t v41 = v114;
    uint64_t v44 = v113 + 8;
  }

  uint64_t v113 = v44;
  uint64_t v45 = v44 + 8;
  if (v44 + 8 <= v41)
  {
    *(void *)((char *)v112 + v44) = *(unsigned __int16 *)(a1 + 690);
    unint64_t v41 = v114;
    uint64_t v45 = v113 + 8;
  }

  uint64_t v113 = v45;
  uint64_t v46 = v45 + 8;
  if (v45 + 8 <= v41)
  {
    *(void *)((char *)v112 + v45) = *(unsigned __int8 *)(a1 + 697);
    unint64_t v41 = v114;
    uint64_t v46 = v113 + 8;
  }

  uint64_t v113 = v46;
  uint64_t v47 = v46 + 8;
  if (v46 + 8 <= v41)
  {
    *(void *)((char *)v112 + v46) = *(unsigned __int8 *)(a1 + 699);
    unint64_t v41 = v114;
    uint64_t v47 = v113 + 8;
  }

  uint64_t v113 = v47;
  uint64_t v48 = v47 + 8;
  if (v47 + 8 <= v41)
  {
    *(void *)((char *)v112 + v47) = *(unsigned __int8 *)(a1 + 700);
    uint64_t v48 = v113 + 8;
  }

  uint64_t v113 = v48;
  SaveGTMTLClearColor(&v112, *(double *)(a1 + 704), 0.0, 0.0, 0.0);
  unint64_t v49 = v114;
  uint64_t v50 = v113 + 8;
  if (v113 + 8 <= v114)
  {
    *(void *)((char *)v112 + v113) = *(unsigned __int8 *)(a1 + 701);
    unint64_t v49 = v114;
    uint64_t v50 = v113 + 8;
  }

  uint64_t v113 = v50;
  uint64_t v51 = v50 + 8;
  if (v50 + 8 <= v49)
  {
    *(void *)((char *)v112 + v5mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(unsigned __int8 *)(a1 + 712);
    uint64_t v51 = v113 + 8;
  }

  uint64_t v113 = v51;
  uint64_t v116 = *(void *)(a1 + 728);
  char v52 = find_entry(a4, &v116, 8uLL, 0LL);
  if (*v52) {
    uint64_t v53 = *(void *)(*v52 + 32LL);
  }
  else {
    uint64_t v53 = 0LL;
  }
  unint64_t v54 = v114;
  uint64_t v55 = v113 + 8;
  if (v113 + 8 <= v114)
  {
    *(void *)((char *)v112 + v113) = *(void *)(v53 + 8);
    unint64_t v54 = v114;
    uint64_t v55 = v113 + 8;
  }

  uint64_t v113 = v55;
  uint64_t v56 = v55 + 8;
  if (v55 + 8 <= v54)
  {
    *(void *)((char *)v112 + v55) = *(unsigned __int8 *)(a1 + 744);
    unint64_t v54 = v114;
    uint64_t v56 = v113 + 8;
  }

  uint64_t v113 = v56;
  uint64_t v57 = v56 + 8;
  if (v56 + 8 <= v54)
  {
    *(void *)((char *)v112 + v56) = *(unsigned __int16 *)(a1 + 742);
    unint64_t v54 = v114;
    uint64_t v57 = v113 + 8;
  }

  uint64_t v113 = v57;
  uint64_t v58 = v57 + 8;
  if (v57 + 8 <= v54)
  {
    *(void *)((char *)v112 + v57) = *(unsigned __int16 *)(a1 + 736);
    uint64_t v58 = v113 + 8;
  }

  uint64_t v113 = v58;
  uint64_t v115 = *(void *)(a1 + 720);
  uint64_t v59 = find_entry(a4, &v115, 8uLL, 0LL);
  if (*v59) {
    uint64_t v61 = *(void *)(*v59 + 32LL);
  }
  else {
    uint64_t v61 = 0LL;
  }
  unint64_t v62 = v114;
  uint64_t v63 = v113 + 8;
  if (v113 + 8 <= v114)
  {
    *(void *)((char *)v112 + v113) = *(void *)(v61 + 8);
    unint64_t v62 = v114;
    uint64_t v63 = v113 + 8;
  }

  uint64_t v113 = v63;
  uint64_t v64 = v63 + 8;
  if (v63 + 8 <= v62)
  {
    *(void *)((char *)v112 + v63) = *(unsigned __int8 *)(a1 + 746);
    unint64_t v62 = v114;
    uint64_t v64 = v113 + 8;
  }

  uint64_t v113 = v64;
  uint64_t v65 = v64 + 8;
  if (v64 + 8 <= v62)
  {
    *(void *)((char *)v112 + v64) = *(unsigned __int16 *)(a1 + 740);
    unint64_t v62 = v114;
    uint64_t v65 = v113 + 8;
  }

  uint64_t v113 = v65;
  uint64_t v66 = v65 + 8;
  if (v65 + 8 <= v62)
  {
    *(void *)((char *)v112 + v65) = *(unsigned __int16 *)(a1 + 738);
    unint64_t v62 = v114;
    uint64_t v66 = v113 + 8;
  }

  uint64_t v113 = v66;
  uint64_t v67 = v66 + 8;
  if (v66 + 8 <= v62)
  {
    *(void *)((char *)v112 + v66) = *(unsigned __int8 *)(a1 + 745);
    unint64_t v62 = v114;
    uint64_t v67 = v113 + 8;
  }

  uint64_t v113 = v67;
  uint64_t v68 = v67 + 8;
  if (v67 + 8 <= v62)
  {
    *(void *)((char *)v112 + v67) = *(unsigned __int8 *)(a1 + 747);
    unint64_t v62 = v114;
    uint64_t v68 = v113 + 8;
  }

  uint64_t v113 = v68;
  uint64_t v69 = v68 + 8;
  if (v68 + 8 <= v62)
  {
    *(void *)((char *)v112 + v6_Block_object_dispose(va, 8) = *(unsigned __int8 *)(a1 + 748);
    uint64_t v69 = v113 + 8;
  }

  uint64_t v113 = v69;
  LODWORD(v6mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(_DWORD *)(a1 + 752);
  SaveGTMTLClearColor(&v112, (double)v60, 0.0, 0.0, 0.0);
  unint64_t v70 = v114;
  uint64_t v71 = v113 + 8;
  if (v113 + 8 <= v114)
  {
    *(void *)((char *)v112 + v113) = *(unsigned __int8 *)(a1 + 749);
    unint64_t v70 = v114;
    uint64_t v71 = v113 + 8;
  }

  uint64_t v113 = v71;
  uint64_t v72 = v71 + 8;
  if (v71 + 8 <= v70)
  {
    *(void *)((char *)v112 + v71) = *(unsigned __int16 *)(a1 + 806);
    unint64_t v70 = v114;
    uint64_t v72 = v113 + 8;
  }

  uint64_t v113 = v72;
  uint64_t v73 = v72 + 8;
  if (v72 + 8 <= v70)
  {
    *(void *)((char *)v112 + v72) = *(unsigned __int16 *)(a1 + 804);
    unint64_t v70 = v114;
    uint64_t v73 = v113 + 8;
  }

  uint64_t v113 = v73;
  uint64_t v74 = v73 + 8;
  if (v73 + 8 <= v70)
  {
    *(void *)((char *)v112 + v73) = *(unsigned int *)(a1 + 800);
    unint64_t v70 = v114;
    uint64_t v74 = v113 + 8;
  }

  uint64_t v113 = v74;
  uint64_t v75 = v74 + 8;
  if (v74 + 8 <= v70)
  {
    *(void *)((char *)v112 + v74) = *(unsigned __int16 *)(a1 + 814);
    unint64_t v70 = v114;
    uint64_t v75 = v113 + 8;
  }

  uint64_t v113 = v75;
  uint64_t v76 = v75 + 8;
  if (v75 + 8 <= v70)
  {
    *(void *)((char *)v112 + v75) = *(unsigned __int16 *)(a1 + 812);
    unint64_t v70 = v114;
    uint64_t v76 = v113 + 8;
  }

  uint64_t v113 = v76;
  uint64_t v77 = v76 + 8;
  if (v76 + 8 <= v70)
  {
    *(void *)((char *)v112 + v76) = *(unsigned __int16 *)(a1 + 810);
    unint64_t v70 = v114;
    uint64_t v77 = v113 + 8;
  }

  uint64_t v113 = v77;
  uint64_t v78 = v77 + 8;
  if (v77 + 8 <= v70)
  {
    *(void *)((char *)v112 + v77) = *(unsigned __int16 *)(a1 + 808);
    unint64_t v70 = v114;
    uint64_t v78 = v113 + 8;
  }

  uint64_t v113 = v78;
  uint64_t v79 = v78 + 8;
  if (v78 + 8 <= v70)
  {
    *(void *)((char *)v112 + v7_Block_object_dispose(va, 8) = *(unsigned __int8 *)(a1 + 816);
    unint64_t v70 = v114;
    uint64_t v79 = v113 + 8;
  }

  uint64_t v113 = v79;
  uint64_t v80 = *(void *)(a1 + 768);
  uint64_t v81 = v79 + 8;
  if (v79 + 8 <= v70)
  {
    *(void *)((char *)v112 + v79) = v80;
    uint64_t v81 = v113 + 8;
    uint64_t v80 = *(void *)(a1 + 768);
  }

  uint64_t v113 = v81;
  if ((v80 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    unint64_t v82 = 0LL;
    do
    {
      unint64_t v83 = v81 + 4;
      unint64_t v84 = v114;
      if (v81 + 4 <= v114)
      {
        *(_DWORD *)((char *)v112 + v81) = *(_DWORD *)(*(void *)(a1 + 760) + 4 * v82);
        unint64_t v84 = v114;
        unint64_t v83 = v113 + 4;
      }

      uint64_t v113 = v83;
      if (v84 > v83)
      {
        if (v84 - v83 >= 4) {
          size_t v85 = 4LL;
        }
        else {
          size_t v85 = v84 - v83;
        }
        bzero((char *)v112 + v83, v85);
        unint64_t v83 = v113;
      }

      uint64_t v81 = v83 + 4;
      uint64_t v113 = v83 + 4;
      ++v82;
    }

    while (v82 < 2LL * *(void *)(a1 + 768));
  }

  uint64_t v86 = v81 + 8;
  unint64_t v87 = v114;
  if (v81 + 8 <= v114)
  {
    *(void *)((char *)v112 + v81) = *(unsigned __int8 *)(a1 + 756);
    unint64_t v87 = v114;
    uint64_t v86 = v113 + 8;
  }

  uint64_t v113 = v86;
  uint64_t v88 = v86 + 8;
  if (v86 + 8 <= v87)
  {
    *(void *)((char *)v112 + v86) = *(unsigned __int8 *)(a1 + 818);
    uint64_t v88 = v113 + 8;
  }

  uint64_t v113 = v88;
  uint64_t v110 = *(void *)(a1 + 784);
  int v89 = find_entry(a4, &v110, 8uLL, 0LL);
  if (*v89) {
    uint64_t v90 = *(void *)(*v89 + 32LL);
  }
  else {
    uint64_t v90 = 0LL;
  }
  unint64_t v91 = v114;
  uint64_t v92 = v113 + 8;
  if (v113 + 8 <= v114)
  {
    *(void *)((char *)v112 + v113) = *(void *)(v90 + 8);
    unint64_t v91 = v114;
    uint64_t v92 = v113 + 8;
  }

  uint64_t v113 = v92;
  uint64_t v93 = v92 + 8;
  if (v92 + 8 <= v91)
  {
    *(void *)((char *)v112 + v92) = *(unsigned __int8 *)(a1 + 817);
    unint64_t v91 = v114;
    uint64_t v93 = v113 + 8;
  }

  uint64_t v113 = v93;
  uint64_t v94 = v93 + 8;
  if (v93 + 8 <= v91)
  {
    *(void *)((char *)v112 + v93) = *(void *)(a1 + 776);
    unint64_t v91 = v114;
    uint64_t v94 = v113 + 8;
  }

  uint64_t v113 = v94;
  uint64_t v95 = v94 + 8;
  if (v94 + 8 <= v91)
  {
    *(void *)((char *)v112 + v94) = *(unsigned __int8 *)(a1 + 819);
    uint64_t v95 = v113 + 8;
  }

  uint64_t v96 = 0LL;
  uint64_t v113 = v95;
  char v97 = (void *)(a1 + 544);
  do
  {
    uint64_t v98 = *(v97 - 2);
    if (v98)
    {
      uint64_t v99 = v95 + 8;
      if (v95 + 8 <= v114)
      {
        *(void *)((char *)v112 + v95) = v96;
        uint64_t v99 = v113 + 8;
        uint64_t v98 = *(v97 - 2);
      }

      uint64_t v113 = v99;
      uint64_t v116 = v98;
      __int128 v100 = find_entry(a4, &v116, 8uLL, 0LL);
      if (*v100) {
        uint64_t v101 = *(void *)(*v100 + 32LL);
      }
      else {
        uint64_t v101 = 0LL;
      }
      unint64_t v102 = v114;
      uint64_t v103 = v113 + 8;
      if (v113 + 8 <= v114)
      {
        *(void *)((char *)v112 + v113) = *(void *)(v101 + 8);
        unint64_t v102 = v114;
        uint64_t v103 = v113 + 8;
      }

      uint64_t v113 = v103;
      uint64_t v104 = v103 + 8;
      if (v103 + 8 <= v102)
      {
        *(void *)((char *)v112 + v103) = *v97;
        unint64_t v102 = v114;
        uint64_t v104 = v113 + 8;
      }

      uint64_t v113 = v104;
      uint64_t v105 = v104 + 8;
      if (v104 + 8 <= v102)
      {
        *(void *)((char *)v112 + v104) = *(v97 - 3);
        unint64_t v102 = v114;
        uint64_t v105 = v113 + 8;
      }

      uint64_t v113 = v105;
      uint64_t v106 = v105 + 8;
      if (v105 + 8 <= v102)
      {
        *(void *)((char *)v112 + v105) = *(v97 - 1);
        unint64_t v102 = v114;
        uint64_t v106 = v113 + 8;
      }

      uint64_t v113 = v106;
      uint64_t v95 = v106 + 8;
      if (v106 + 8 <= v102)
      {
        *(void *)((char *)v112 + v106) = *(v97 - 4);
        uint64_t v95 = v113 + 8;
      }

      uint64_t v113 = v95;
    }

    ++v96;
    v97 += 5;
  }

  while (v96 != 4);
  uint64_t v107 = v95 + 8;
  unint64_t v108 = v114;
  if (v95 + 8 <= v114)
  {
    *(void *)((char *)v112 + v95) = -1LL;
    unint64_t v108 = v114;
    uint64_t v107 = v113 + 8;
  }

  uint64_t v113 = v107;
  uint64_t result = v107 + 8;
  if (v107 + 8 <= v108)
  {
    *(void *)((char *)v112 + v107) = *(unsigned __int8 *)(a1 + 820);
    return v113 + 8;
  }

  return result;
}

void *SaveGTMTLClearColor(void *result, double a2, double a3, double a4, double a5)
{
  uint64_t v6 = result[1];
  unint64_t v5 = result[2];
  uint64_t v7 = v6 + 8;
  if (v6 + 8 <= v5)
  {
    *(double *)(*result + v6) = a2;
    unint64_t v5 = result[2];
    uint64_t v7 = result[1] + 8LL;
  }

  result[1] = v7;
  uint64_t v8 = v7 + 8;
  if (v7 + 8 <= v5)
  {
    *(double *)(*result + v7) = a3;
    unint64_t v5 = result[2];
    uint64_t v8 = result[1] + 8LL;
  }

  result[1] = v8;
  uint64_t v9 = v8 + 8;
  if (v8 + 8 <= v5)
  {
    *(double *)(*result + v_Block_object_dispose(va, 8) = a4;
    unint64_t v5 = result[2];
    uint64_t v9 = result[1] + 8LL;
  }

  result[1] = v9;
  uint64_t v10 = v9 + 8;
  if (v9 + 8 <= v5)
  {
    *(double *)(*result + v9) = a5;
    uint64_t v10 = result[1] + 8LL;
  }

  result[1] = v10;
  return result;
}

uint64_t DecodeDYMTLTextureDescriptor(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a3 + 232);
  *(void *)(a3 + 232) = v4 + 56;
  if (a4)
  {
    *(_OWORD *)uint64_t v4 = GTMTLTextureDescriptorDefaults;
    *(_OWORD *)(v4 + 16) = unk_1C73E0;
    *(_OWORD *)(v4 + 32) = xmmword_1C73F0;
    *(void *)(v4 + 4_Block_object_dispose(va, 8) = 512LL;
    unsigned int v5 = *(_DWORD *)result;
    *(_BYTE *)(v4 + 49) = *(void *)(result + 8);
    *(_WORD *)(v4 + 34) = *(void *)(result + 16);
    *(_DWORD *)(v4 + 24) = *(void *)(result + 24);
    *(_WORD *)(v4 + 32) = *(void *)(result + 32);
    *(_WORD *)(v4 + 3mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(result + 40);
    *(_BYTE *)(v4 + 45) = *(void *)(result + 48);
    *(_BYTE *)(v4 + 47) = *(void *)(result + 56);
    *(_WORD *)(v4 + 2_Block_object_dispose(va, 8) = *(void *)(result + 64);
    uint64_t v6 = 72LL;
    if (v5 < 3) {
      uint64_t v6 = 80LL;
    }
    uint64_t v7 = result + v6;
    *(_BYTE *)(v4 + 43) = *(void *)v7;
    *(_BYTE *)(v4 + 44) = *(void *)(v7 + 8);
    if (v5)
    {
      *(_DWORD *)(v4 + 2mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(v7 + 16);
      if (v5 <= 3)
      {
        if (v5 == 3) {
          *(_WORD *)(v4 + 36) = *(_WORD *)(v7 + 32) | (16 * *(_WORD *)(v7 + 24));
        }
      }

      else
      {
        int v8 = *(unsigned __int8 *)(v7 + 24);
        *(_BYTE *)(v4 + 46) = v8;
        int v9 = *(_DWORD *)(v7 + 40);
        int v10 = v9 | (16 * *(_DWORD *)(v7 + 32));
        *(_WORD *)(v4 + 36) = v9 | (16 * *(_WORD *)(v7 + 32));
        if (v5 >= 0x15)
        {
          *(_BYTE *)(v4 + 3_Block_object_dispose(va, 8) = *(void *)(v7 + 48);
          *(_BYTE *)(v4 + 4mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(v7 + 56);
          if (v5 != 21)
          {
            *(void *)(v4 + _Block_object_dispose(va, 8) = *(void *)(v7 + 64);
            *(_BYTE *)(v4 + 42) = *(void *)(v7 + 72);
            if (v5 >= 0x23)
            {
              *(_DWORD *)(v4 + 16) = *(unsigned __int8 *)(v7 + 80) | (unsigned __int16)(*(_DWORD *)(v7 + 88) << 8) | (*(_DWORD *)(v7 + 96) << 16) | (*(_DWORD *)(v7 + 104) << 24);
              if (v5 >= 0x27)
              {
                *(_DWORD *)(v4 + 16) = *(void *)(v7 + 112);
                if (v5 >= 0x2A)
                {
                  *(_WORD *)(v4 + 36) = v10 | (*(_WORD *)(v7 + 120) << 8);
                  *(void *)uint64_t v4 = *(void *)(v7 + 128);
                  *(_BYTE *)(v4 + 4_Block_object_dispose(va, 8) = *(void *)(v7 + 136);
                  *(_BYTE *)(v4 + 5mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = *(void *)(v7 + 144);
                  if (v5 >= 0x31)
                  {
                    *(_BYTE *)(v4 + 41) = *(void *)(v7 + 152);
                    *(_BYTE *)(v4 + 39) = *(void *)(v7 + 160);
                  }
                }
              }
            }
          }
        }

        if (v8 == 255) {
          *(_BYTE *)(v4 + 46) = 0;
        }
      }
    }
  }

  return result;
}

uint64_t EncodeDYMTLTextureDescriptor(uint64_t a1, void *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    *a2 = 81LL;
    if (a3 >= 0x10)
    {
      a2[1] = *(unsigned __int8 *)(a1 + 49);
      if (a3 >= 0x18)
      {
        a2[2] = *(unsigned __int16 *)(a1 + 34);
        if (a3 >= 0x20)
        {
          a2[3] = *(unsigned int *)(a1 + 24);
          if (a3 >= 0x28)
          {
            a2[4] = *(unsigned __int16 *)(a1 + 32);
            if (a3 >= 0x30)
            {
              a2[5] = *(unsigned __int16 *)(a1 + 30);
              if (a3 >= 0x38)
              {
                a2[6] = *(unsigned __int8 *)(a1 + 45);
                if (a3 >= 0x40)
                {
                  a2[7] = *(unsigned __int8 *)(a1 + 47);
                  if (a3 >= 0x48)
                  {
                    a2[8] = *(unsigned __int16 *)(a1 + 28);
                    if (a3 >= 0x50)
                    {
                      a2[9] = *(unsigned __int8 *)(a1 + 43);
                      if (a3 >= 0x58)
                      {
                        a2[10] = *(unsigned __int8 *)(a1 + 44);
                        if (a3 >= 0x60)
                        {
                          a2[11] = *(unsigned int *)(a1 + 20);
                          if (a3 >= 0x68)
                          {
                            a2[12] = *(unsigned __int8 *)(a1 + 46);
                            if (a3 >= 0x70)
                            {
                              a2[13] = *(_WORD *)(a1 + 36) >> 4;
                              if (a3 >= 0x78)
                              {
                                a2[14] = *(_WORD *)(a1 + 36) & 0xF;
                                if (a3 >= 0x80)
                                {
                                  a2[15] = *(unsigned __int8 *)(a1 + 38);
                                  if (a3 >= 0x88)
                                  {
                                    a2[16] = *(unsigned __int8 *)(a1 + 40);
                                    if (a3 >= 0x90)
                                    {
                                      a2[17] = *(void *)(a1 + 8);
                                      if (a3 >= 0x98)
                                      {
                                        a2[18] = *(unsigned __int8 *)(a1 + 42);
                                        if (a3 >= 0xA0)
                                        {
                                          a2[19] = *(unsigned __int8 *)(a1 + 16);
                                          if (a3 >= 0xA8)
                                          {
                                            a2[20] = BYTE1(*(_DWORD *)(a1 + 16));
                                            if (a3 >= 0xB0)
                                            {
                                              a2[21] = BYTE2(*(_DWORD *)(a1 + 16));
                                              if (a3 >= 0xB8)
                                              {
                                                a2[22] = (unint64_t)*(unsigned int *)(a1 + 16) >> 24;
                                                if (a3 >= 0xC0)
                                                {
                                                  a2[23] = *(unsigned int *)(a1 + 16);
                                                  if (a3 >= 0xC8)
                                                  {
                                                    a2[24] = *(_BYTE *)(a1 + 37) & 3;
                                                    if (a3 >= 0xD0)
                                                    {
                                                      a2[25] = *(void *)a1;
                                                      if (a3 >= 0xD8)
                                                      {
                                                        a2[26] = *(unsigned __int8 *)(a1 + 48);
                                                        if (a3 >= 0xE0)
                                                        {
                                                          a2[27] = *(unsigned __int8 *)(a1 + 50);
                                                          if (a3 >= 0xE8)
                                                          {
                                                            a2[28] = *(unsigned __int8 *)(a1 + 41);
                                                            if (a3 >= 0xF0) {
                                                              a2[29] = *(unsigned __int8 *)(a1 + 39);
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return 240LL;
}

double DecodeDYMTLBufferDescriptor(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a3 + 224);
  *(void *)(a3 + 224) = v4 + 40;
  if (a4)
  {
    *(void *)(v4 + 32) = 0LL;
    double result = 0.0;
    *(_OWORD *)uint64_t v4 = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    *(void *)uint64_t v4 = a1[1];
    *(_WORD *)(v4 + 32) = a1[2];
    *(_BYTE *)(v4 + 34) = a1[6];
    *(void *)(v4 + 24) = a1[8];
    *(void *)(v4 + _Block_object_dispose(va, 8) = a1[9];
    *(void *)(v4 + 16) = a1[10];
  }

  return result;
}

uint64_t EncodeDYMTLBufferDescriptor(uint64_t a1, void *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    *a2 = 81LL;
    if (a3 >= 0x10)
    {
      a2[1] = *(void *)a1;
      if (a3 >= 0x18)
      {
        a2[2] = *(unsigned __int16 *)(a1 + 32);
        if (a3 >= 0x20)
        {
          a2[3] = *(_WORD *)(a1 + 32) & 0xF;
          if (a3 >= 0x28)
          {
            a2[4] = *(_WORD *)(a1 + 32) >> 4;
            if (a3 >= 0x30)
            {
              a2[5] = *(_WORD *)(a1 + 32) & 0xF;
              if (a3 >= 0x38)
              {
                a2[6] = *(unsigned __int8 *)(a1 + 34);
                if (a3 >= 0x40)
                {
                  a2[7] = 0LL;
                  if (a3 >= 0x48)
                  {
                    a2[8] = *(void *)(a1 + 24);
                    if (a3 >= 0x50)
                    {
                      a2[9] = *(void *)(a1 + 8);
                      if (a3 >= 0x58) {
                        a2[10] = *(void *)(a1 + 16);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return 88LL;
}

size_t DecodeDYMTLRenderPipelineDescriptor(uint64_t a1, void *a2, void *a3, int a4, uint64_t a5)
{
  v102[1] = a2;
  memcpy(v101, &GTMTLRenderPipelineDescriptorDefaults, sizeof(v101));
  unsigned int v9 = *(_DWORD *)a1;
  v101[162] = *(void *)(a1 + 8);
  v101[147] = *(void *)(a1 + 16);
  bzero(__src, 0x2E8uLL);
  if (v9 < 0x1A)
  {
    __int128 v11 = (uint64_t *)(a1 + 24);
    uint64_t v10 = 31LL;
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 24);
    __int128 v11 = (uint64_t *)(a1 + 32);
    uint64_t v10 = v10;
  }

  uint64_t v12 = &__src[11];
  do
  {
    if (a4)
    {
      uint64_t v13 = *v11;
      uint64_t v14 = v11[1];
      uint64_t v15 = v11[2];
      if (*v11 == 0xFFFFFFFFLL) {
        uint64_t v13 = -1LL;
      }
      *(void *)(v12 - 11) = v13;
      *(_WORD *)(v12 - 3) = v14;
      *(v12 - 1) = v15;
      *(_DWORD *)uint64_t v12 = 0;
      v12[4] = 0;
    }

    v11 += 3;
    v12 += 16;
    --v10;
  }

  while (v10);
  v102[0] = v11;
  if (v9 <= 0x19)
  {
    uint64_t v16 = 31LL;
    goto LABEL_15;
  }

void **MakeDYMTLRenderPipelineColorAttachmentDescriptor(void **result, uint64_t a2, int a3)
{
  unint64_t v3 = *result;
  uint64_t v4 = *(*result)++;
  uint64_t v5 = v3[1];
  void *result = v3 + 2;
  uint64_t v6 = v3[2];
  void *result = v3 + 3;
  uint64_t v7 = v3[3];
  void *result = v3 + 4;
  uint64_t v8 = v3[4];
  void *result = v3 + 5;
  uint64_t v9 = v3[5];
  void *result = v3 + 6;
  uint64_t v10 = v3[6];
  void *result = v3 + 7;
  uint64_t v11 = v3[7];
  void *result = v3 + 8;
  uint64_t v12 = v3[8];
  void *result = v3 + 9;
  if (a3)
  {
    *(_WORD *)a2 = v12;
    *(_BYTE *)(a2 + 2) = v10;
    *(_BYTE *)(a2 + 3) = v4;
    *(_BYTE *)(a2 + 4) = v9;
    *(_BYTE *)(a2 + 5) = v6;
    *(_BYTE *)(a2 + 6) = v7;
    *(_BYTE *)(a2 + 7) = v8;
    *(_BYTE *)(a2 + _Block_object_dispose(va, 8) = v5;
    *(_BYTE *)(a2 + 9) = v11;
    *(_DWORD *)(a2 + 1mach_msg_server( (BOOLean_t (__cdecl *)(mach_msg_header_t *, mach_msg_header_t *))mach_exc_server,  0x40000u,  exceptionPort, 0) = 0;
    *(_WORD *)(a2 + 14) = 0;
  }

  return result;
}

size_t MakeDYMTLLinkedFunctions(size_t result, void *a2, void *a3, int a4, uint64_t a5)
{
  uint64_t v9 = (const char **)result;
  uint64_t v10 = (const char *)(*(void *)result + 8LL);
  uint64_t v11 = **(void **)result;
  *(void *)size_t result = v10;
  if (v11)
  {
    uint64_t v46 = a3[50];
    uint64_t v12 = v11;
    do
    {
      uint64_t v13 = *(uint64_t **)*v9;
      *v9 += 8;
      if ((a4 & 1) != 0)
      {
        if (a5)
        {
          size_t result = GetStream_10858(a5, (uint64_t)v13);
          if (result) {
            uint64_t v13 = *(uint64_t **)result;
          }
          else {
            uint64_t v13 = 0LL;
          }
        }

        uint64_t v14 = (uint64_t **)a3[50];
        void *v14 = v13;
      }

      else
      {
        uint64_t v14 = (uint64_t **)a3[50];
      }

      a3[50] = v14 + 1;
      --v12;
    }

    while (v12);
    uint64_t v10 = *v9;
  }

  else
  {
    uint64_t v46 = 0LL;
  }

  uint64_t v17 = *(void *)v10;
  uint64_t v15 = v10 + 8;
  uint64_t v16 = v17;
  *uint64_t v9 = v15;
  uint64_t v49 = v17;
  if (v17)
  {
    uint64_t v45 = a3[50];
    uint64_t v18 = v16;
    do
    {
      uint64_t v19 = *(uint64_t **)*v9;
      *v9 += 8;
      if ((a4 & 1) != 0)
      {
        if (a5)
        {
          size_t result = GetStream_10858(a5, (uint64_t)v19);
          if (result) {
            uint64_t v19 = *(uint64_t **)result;
          }
          else {
            uint64_t v19 = 0LL;
          }
        }

        uint64_t v20 = (uint64_t **)a3[50];
        *uint64_t v20 = v19;
      }

      else
      {
        uint64_t v20 = (uint64_t **)a3[50];
      }

      a3[50] = v20 + 1;
      --v18;
    }

    while (v18);
    uint64_t v15 = *v9;
  }

  else
  {
    uint64_t v45 = 0LL;
  }

  uint64_t v22 = v15 + 8;
  uint64_t v21 = *(void *)v15;
  *uint64_t v9 = v15 + 8;
  uint64_t v47 = v11;
  uint64_t v48 = a2;
  if (v21)
  {
    uint64_t v23 = *((void *)v15 + 1);
    uint64_t v22 = v15 + 16;
    *uint64_t v9 = v15 + 16;
    if (v23)
    {
      uint64_t v24 = 0LL;
      uint64_t v50 = a3[42];
      size_t v51 = v15 + 16;
      *uint64_t v9 = &v22[8 * v23];
      a3[42] += 24 * v23;
      while (1)
      {
        uint64_t v25 = *v9;
        size_t result = strlen(*v9);
        *v9 += (result & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if (*v25) {
          int v26 = v25;
        }
        else {
          int v26 = 0LL;
        }
        if (*v25)
        {
          size_t result = strlen(v26);
          uint64_t v27 = a3[52];
          size_t v28 = result + 1;
          if (result != -1LL)
          {
            size_t v29 = (void *)a3[52];
            goto LABEL_36;
          }
        }

        else
        {
          uint64_t v27 = a3[52];
        }

        size_t v28 = 0LL;
        size_t v29 = 0LL;
LABEL_36:
        a3[52] = v27 + v28;
        if (a4) {
          size_t result = (size_t)memcpy(v29, v26, v28);
        }
        uint64_t v30 = *(void *)&v22[8 * v24];
        if ((_DWORD)v30)
        {
          uint64_t v31 = v23;
          uint64_t v32 = a3[50];
          int v33 = v30;
          do
          {
            unint64_t v34 = *(uint64_t **)*v9;
            *v9 += 8;
            if ((a4 & 1) != 0)
            {
              if (a5)
              {
                size_t result = GetStream_10858(a5, (uint64_t)v34);
                if (result) {
                  unint64_t v34 = *(uint64_t **)result;
                }
                else {
                  unint64_t v34 = 0LL;
                }
              }

              uint64_t v35 = (uint64_t **)a3[50];
              *uint64_t v35 = v34;
            }

            else
            {
              uint64_t v35 = (uint64_t **)a3[50];
            }

            a3[50] = v35 + 1;
            --v33;
          }

          while (v33);
          uint64_t v23 = v31;
          uint64_t v22 = v51;
          if ((a4 & 1) == 0) {
            goto LABEL_50;
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          if ((a4 & 1) == 0) {
            goto LABEL_50;
          }
        }

        uint64_t v36 = v50 + 24 * v24;
        *(void *)uint64_t v36 = v29;
        *(void *)(v36 + _Block_object_dispose(va, 8) = v32;
        *(_DWORD *)(v36 + 16) = v30;
LABEL_50:
        if (++v24 == v23)
        {
          uint64_t v22 = *v9;
          uint64_t v37 = v50;
          goto LABEL_56;
        }
      }
    }

    uint64_t v37 = 0LL;
LABEL_56:
    if (a4) {
      uint64_t v38 = v37;
    }
    else {
      uint64_t v38 = 0LL;
    }
    if (a4) {
      uint64_t v39 = v23;
    }
    else {
      uint64_t v39 = 0LL;
    }
  }

  else
  {
    uint64_t v38 = 0LL;
    uint64_t v39 = 0LL;
  }

  uint64_t v40 = *(void *)v22;
  *uint64_t v9 = v22 + 8;
  if (v40)
  {
    uint64_t v41 = a3[50];
    uint64_t v42 = v40;
    do
    {
      size_t v43 = *(uint64_t **)*v9;
      *v9 += 8;
      if ((a4 & 1) != 0)
      {
        if (a5)
        {
          size_t result = GetStream_10858(a5, (uint64_t)v43);
          if (result) {
            size_t v43 = *(uint64_t **)result;
          }
          else {
            size_t v43 = 0LL;
          }
        }

        uint64_t v44 = (uint64_t **)a3[50];
        *uint64_t v44 = v43;
      }

      else
      {
        uint64_t v44 = (uint64_t **)a3[50];
      }

      a3[50] = v44 + 1;
      --v42;
    }

    while (v42);
  }

  else
  {
    uint64_t v41 = 0LL;
  }

  if (a4)
  {
    void *v48 = v45;
    v48[1] = v49;
    v48[2] = v46;
    v48[3] = v47;
    v48[4] = v38;
    v48[5] = v39;
    v48[6] = v41;
    v48[7] = v40;
  }

  return result;
}