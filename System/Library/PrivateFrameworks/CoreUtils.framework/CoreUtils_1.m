uint64_t HTTPReadLine(void *a1, uint64_t (*a2)(void), uint64_t a3, void *a4, void *a5)
{
  char *v9;
  int64_t i;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t result;
  char *v17;
  _BYTE *v18;
  int64_t v19;
  v9 = (char *)(a1 + 1024);
  for (i = a1[1026]; ; a1[1026] = i)
  {
    v11 = (char *)a1[1025];
    if (i >= 1) {
      break;
    }
LABEL_6:
    v14 = a1[1024];
    v15 = (char *)a1 + v14;
    if ((char *)a1 + v14 != v11)
    {
      memmove((char *)a1 + v14, v11, i);
      a1[1025] = v15;
      i = a1[1026];
    }

    v19 = v9 - &v15[i];
    if (v9 == &v15[i]) {
      return 4294960533LL;
    }
    result = a2();
    if ((_DWORD)result) {
      return result;
    }
    i = a1[1026] + v19;
  }

  v12 = &v11[i];
  v13 = (char *)a1[1025];
  while (*v13 != 10)
  {
    if (++v13 >= v12) {
      goto LABEL_6;
    }
  }

  if (v13 <= v11 || (v17 = v13 - 1, *(v13 - 1) != 13)) {
    v17 = v13;
  }
  result = 0LL;
  *a4 = v11;
  *a5 = v17 - v11;
  v18 = v13 + 1;
  a1[1025] = v18;
  a1[1026] = v12 - v18;
  return result;
}

uint64_t NetSocket_HTTPReadHeader(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  uint64_t v14 = 0x2000LL;
  uint64_t v7 = 0x2000LL;
  v8 = (_BYTE *)a2;
LABEL_2:
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, void, uint64_t))(a1 + 24))( a1,  1LL,  v7,  a2 + v6,  &v14,  0LL,  a3);
  if ((_DWORD)result) {
    return result;
  }
  v6 += v14;
  unint64_t v10 = a2 + v6;
  if (*(_BYTE *)a2 != 36 || v6 <= 3)
  {
    while (1)
    {
      if ((unint64_t)v8 >= v10)
      {
LABEL_18:
        uint64_t v7 = 0x2000 - v6;
        uint64_t v14 = 0x2000 - v6;
        if (v6 != 0x2000) {
          goto LABEL_2;
        }
        return 4294960533LL;
      }

      if (*v8 == 10)
      {
        if (v10 - (unint64_t)v8 < 3)
        {
          if (v10 - (void)v8 != 2) {
            goto LABEL_18;
          }
          int v12 = v8[1];
        }

        else
        {
          int v12 = v8[1];
          if (v12 == 13)
          {
            if (v8[2] == 10)
            {
              v13 = v8 + 3;
              goto LABEL_21;
            }

            goto LABEL_17;
          }
        }

        if (v12 == 10)
        {
          v13 = v8 + 2;
          goto LABEL_21;
        }
      }

uint64_t LogHTTP( uint64_t result, int *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result) {
    int v12 = (int *)result;
  }
  else {
    int v12 = (int *)&gLogCategory_HTTPRequests;
  }
  if (a2) {
    v13 = a2;
  }
  else {
    v13 = (int *)&gLogCategory_HTTPResponses;
  }
  if (*v12 > 40 || *v12 == -1 && (uint64_t result = _LogCategory_Initialize((uint64_t)v12, 0x28u), !(_DWORD)result))
  {
    if (*v13 > 40) {
      return result;
    }
    if (*v13 == -1)
    {
      uint64_t result = _LogCategory_Initialize((uint64_t)v13, 0x28u);
      if (!(_DWORD)result) {
        return result;
      }
    }
  }

  if (a4 < 1)
  {
    int v19 = 0;
    LOBYTE(v15) = (_BYTE)a3;
  }

  else
  {
    unint64_t v14 = (unint64_t)&a3[a4];
    v15 = a3;
    do
    {
      int v16 = *v15;
      if (v16 == 10 || v16 == 13) {
        break;
      }
      ++v15;
    }

    while ((unint64_t)v15 < v14);
    v18 = a3;
    do
    {
      int v19 = *v18;
      if (v19 == 32) {
        break;
      }
      ++v18;
    }

    while (v19 != 47 && (unint64_t)v18 < v14);
  }

  if (v19 == 32) {
    v21 = v12;
  }
  else {
    v21 = v13;
  }
  int v22 = *v21;
  if (*v21 > 20) {
    goto LABEL_50;
  }
  if (v22 == -1)
  {
    uint64_t result = _LogCategory_Initialize((uint64_t)v21, 0x14u);
    if (!(_DWORD)result)
    {
      int v22 = *v21;
LABEL_50:
      if (v22 <= 40)
      {
        if (v22 != -1 || (uint64_t result = _LogCategory_Initialize((uint64_t)v21, 0x28u), (_DWORD)result))
        {
          if (a3)
          {
            if (v19 == 32)
            {
              if (*v12 <= 50)
              {
                if (*v12 != -1) {
                  return LogPrintF( (uint64_t)v12,  (uint64_t)"void LogHTTP(LogCategory *, LogCategory *, const void *, size_t, const void *, size_t)",  0x32u,  (uint64_t)"HTTP Request:  %.*s\n",  a5,  a6,  a7,  a8,  v15 - a3);
                }
                uint64_t result = _LogCategory_Initialize((uint64_t)v12, 0x32u);
                if ((_DWORD)result) {
                  return LogPrintF( (uint64_t)v12,  (uint64_t)"void LogHTTP(LogCategory *, LogCategory *, const void *, size_t, const void *, size_t)",  0x32u,  (uint64_t)"HTTP Request:  %.*s\n",  a5,  a6,  a7,  a8,  v15 - a3);
                }
              }
            }

            else if (*v13 <= 50)
            {
              if (*v13 != -1) {
                return LogPrintF( (uint64_t)v13,  (uint64_t)"void LogHTTP(LogCategory *, LogCategory *, const void *, size_t, const void *, size_t)",  0x32u,  (uint64_t)"HTTP Response: %.*s\n\n",  a5,  a6,  a7,  a8,  v15 - a3);
              }
              uint64_t result = _LogCategory_Initialize((uint64_t)v13, 0x32u);
              if ((_DWORD)result) {
                return LogPrintF( (uint64_t)v13,  (uint64_t)"void LogHTTP(LogCategory *, LogCategory *, const void *, size_t, const void *, size_t)",  0x32u,  (uint64_t)"HTTP Response: %.*s\n\n",  a5,  a6,  a7,  a8,  v15 - a3);
              }
            }
          }
        }
      }

      return result;
    }
  }

  v23 = "-------------------- HTTP RESPONSE --------------------\n";
  if (v19 == 32) {
    v23 = "==================== HTTP REQUEST  ====================\n";
  }
  if (a3) {
    LOBYTE(v24) = (_BYTE)v23;
  }
  else {
    v24 = "";
  }
  if (a6 <= 0)
  {
LABEL_43:
    if (*v21 > 50) {
      return result;
    }
    if (*v21 == -1)
    {
      uint64_t result = _LogCategory_Initialize((uint64_t)v21, 0x32u);
      if (!(_DWORD)result) {
        return result;
      }
    }

    char v28 = (char)v24;
    v27 = "%s%{text}%{text}%s";
    return LogPrintF( (uint64_t)v21,  (uint64_t)"void LogHTTP(LogCategory *, LogCategory *, const void *, size_t, const void *, size_t)",  0x32u,  (uint64_t)v27,  a5,  a6,  a7,  a8,  v28);
  }

  v25 = (unsigned __int8 *)a5;
  while (1)
  {
    int v26 = *v25;
  }

  if (*v21 <= 50)
  {
    if (*v21 != -1 || (uint64_t result = _LogCategory_Initialize((uint64_t)v21, 0x32u), (_DWORD)result))
    {
      char v28 = (char)v24;
      v27 = "%s%{text}<< BINARY DATA >>\n%.1H\n";
      return LogPrintF( (uint64_t)v21,  (uint64_t)"void LogHTTP(LogCategory *, LogCategory *, const void *, size_t, const void *, size_t)",  0x32u,  (uint64_t)v27,  a5,  a6,  a7,  a8,  v28);
    }
  }

  return result;
}

uint64_t IEGetNext(_BYTE *a1, _BYTE *a2, _BYTE *a3, void *a4, void *a5, void *a6)
{
  if (a1 == a2) {
    return 4294960569LL;
  }
  if (a1 >= a2) {
    return 4294960591LL;
  }
  uint64_t v6 = a1[1];
  uint64_t v7 = &a1[v6 + 2];
  if (v7 > a2) {
    return 4294960546LL;
  }
  *a3 = *a1;
  *a4 = a1 + 2;
  *a5 = v6;
  uint64_t result = 0LL;
  if (a6) {
    *a6 = v7;
  }
  return result;
}

uint64_t IEGetVendorSpecific( unsigned __int8 *a1, unint64_t a2, int a3, void *a4, void *a5, void *a6)
{
  uint64_t v6 = a1;
  while (1)
  {
    uint64_t v7 = v6;
    int v8 = *v6;
    uint64_t v9 = v6[1];
    v6 += v9 + 2;
    if (v8 == 221)
    {
    }
  }

  *a4 = v7 + 6;
  *a5 = v9 - 4;
  uint64_t result = 0LL;
  if (a6) {
    *a6 = v6;
  }
  return result;
}

uint64_t IEGetAppleGeneral(unsigned __int8 *a1, unint64_t a2, _BYTE *a3, _WORD *a4)
{
  uint64_t result = IEGetVendorSpecific(a1, a2, 234241, &v9, &v8, 0LL);
  if (!(_DWORD)result)
  {
    if (v8 >= 3)
    {
      uint64_t result = 0LL;
      uint64_t v7 = v9;
      *a3 = *v9;
      *a4 = bswap32(*(unsigned __int16 *)(v7 + 1)) >> 16;
    }

    else
    {
      return 4294960553LL;
    }
  }

  return result;
}

uint64_t IEBufferAppendIE(uint64_t a1, char a2, char *__s, size_t a4)
{
  uint64_t result = *(unsigned int *)(a1 + 264);
  if (!(_DWORD)result)
  {
    uint64_t v6 = __s;
    if (a4 == -1LL) {
      a4 = strlen(__s);
    }
    if (a4 > 0xFF || (uint64_t v8 = *(void *)(a1 + 256), a4 + v8 + 2 > 0xFF))
    {
      uint64_t result = 4294960553LL;
    }

    else
    {
      *(void *)(a1 + 256) = v8 + 1;
      *(_BYTE *)(a1 + v8) = a2;
      uint64_t v9 = *(void *)(a1 + 256);
      *(void *)(a1 + 256) = v9 + 1;
      *(_BYTE *)(a1 + v9) = a4;
      if (a4)
      {
        unint64_t v10 = &v6[a4];
        do
        {
          char v11 = *v6++;
          uint64_t v12 = *(void *)(a1 + 256);
          *(void *)(a1 + 256) = v12 + 1;
          *(_BYTE *)(a1 + v12) = v11;
        }

        while (v6 < v10);
      }

      uint64_t result = 0LL;
    }

    if (!*(_DWORD *)(a1 + 264)) {
      *(_DWORD *)(a1 + 264) = result;
    }
  }

  return result;
}

uint64_t IEBufferStartVendorIE(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 264);
  if (!(_DWORD)v2)
  {
    uint64_t v3 = *(void *)(a1 + 256);
    if ((unint64_t)(v3 - 250) < 0xFFFFFFFFFFFFFF00LL)
    {
      uint64_t v4 = 4294960553LL;
      goto LABEL_4;
    }

    uint64_t v4 = 0LL;
    uint64_t v2 = 0LL;
    *(void *)(a1 + 256) = v3 + 1;
    *(_BYTE *)(a1 + v3) = -35;
    uint64_t v5 = *(void *)(a1 + 256);
    *(void *)(a1 + 272) = v5;
    *(void *)(a1 + 256) = v5 + 1;
    *(_BYTE *)(a1 + v5) = 0;
    uint64_t v6 = *(void *)(a1 + 256);
    *(void *)(a1 + 256) = v6 + 1;
    *(_BYTE *)(a1 + v6) = HIBYTE(a2);
    uint64_t v7 = *(void *)(a1 + 256);
    *(void *)(a1 + 256) = v7 + 1;
    *(_BYTE *)(a1 + v7) = BYTE2(a2);
    uint64_t v8 = *(void *)(a1 + 256);
    *(void *)(a1 + 256) = v8 + 1;
    *(_BYTE *)(a1 + v8) = BYTE1(a2);
    uint64_t v9 = *(void *)(a1 + 256);
    *(void *)(a1 + 256) = v9 + 1;
    *(_BYTE *)(a1 + v9) = a2;
    if (!*(_DWORD *)(a1 + 264))
    {
LABEL_4:
      *(_DWORD *)(a1 + 264) = v4;
      return v4;
    }
  }

  return v2;
}

uint64_t IEBufferEndVendorIE(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 264);
  if (!(_DWORD)v1)
  {
    uint64_t v2 = *(void *)(a1 + 272);
    if (!v2)
    {
      uint64_t v3 = 4294960551LL;
      goto LABEL_4;
    }

    uint64_t v3 = 0LL;
    uint64_t v1 = 0LL;
    *(_BYTE *)(a1 + v2) = *(_BYTE *)(a1 + 256) + ~(_BYTE)v2;
    *(void *)(a1 + 272) = 0LL;
    if (!*(_DWORD *)(a1 + 264))
    {
LABEL_4:
      *(_DWORD *)(a1 + 264) = v3;
      return v3;
    }
  }

  return v1;
}

uint64_t DataBuffer_AppendIE(uint64_t a1, char a2, char *__s, size_t a4)
{
  size_t v4 = a4;
  uint64_t v5 = __s;
  if (a4 == -1LL) {
    size_t v4 = strlen(__s);
  }
  if (v4 > 0xFF)
  {
    uint64_t result = 4294960553LL;
  }

  else
  {
    uint64_t result = DataBuffer_Resize(a1, v4 + *(void *)(a1 + 32) + 2, (size_t *)&v14);
    if (!(_DWORD)result)
    {
      uint64_t v9 = v14++;
      *uint64_t v9 = a2;
      unint64_t v10 = v14++;
      *unint64_t v10 = v4;
      if (v4)
      {
        char v11 = &v5[v4];
        do
        {
          char v12 = *v5++;
          v13 = v14++;
          _BYTE *v13 = v12;
        }

        while (v5 < v11);
      }

      uint64_t result = 0LL;
    }
  }

  if (!*(_DWORD *)(a1 + 52)) {
    *(_DWORD *)(a1 + 52) = result;
  }
  return result;
}

const void *CFCreateWithJSONBytes(char *__s, size_t a2, char a3, uint64_t a4, int *a5)
{
  size_t v8 = a2;
  if (a2 != -1LL)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_12:
    if (CFDictionaryGetTypeID() == a4)
    {
      if ((a3 & 3) != 0) {
        CFDictionaryRef Mutable = CFDictionaryCreate(0LL, 0LL, 0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      }
      else {
        CFDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      }
    }

    else
    {
      if (CFArrayGetTypeID() != a4)
      {
        unint64_t v10 = 0LL;
        v13 = 0LL;
        int v14 = -6732;
        goto LABEL_23;
      }

      if ((a3 & 3) != 0) {
        CFDictionaryRef Mutable = CFArrayCreate(0LL, 0LL, 0LL, MEMORY[0x189605228]);
      }
      else {
        CFDictionaryRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
      }
    }

    v13 = Mutable;
    unint64_t v10 = 0LL;
    if (Mutable) {
      goto LABEL_22;
    }
    int v14 = -6728;
    v13 = 0LL;
    goto LABEL_23;
  }

  size_t v8 = strlen(__s);
  if (!v8) {
    goto LABEL_12;
  }
LABEL_3:
  unint64_t v10 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytes:__s length:v8];
  if (v10)
  {
    char v11 = (void *)MEMORY[0x186E432B4]();
    if ((a3 & 2) != 0) {
      uint64_t v12 = 7LL;
    }
    else {
      uint64_t v12 = a3 & 1 | 4LL;
    }
    [MEMORY[0x1896078D8] JSONObjectWithData:v10 options:v12 error:0];
    v13 = (const void *)objc_claimAutoreleasedReturnValue();
    objc_autoreleasePoolPop(v11);
    if (v13)
    {
      if (a4 && CFGetTypeID(v13) != a4)
      {
        CFRelease(v13);
        v13 = 0LL;
        int v14 = -6756;
        goto LABEL_23;
      }

uint64_t CFCreateJSONData(uint64_t a1, char a2, int *a3)
{
  uint64_t v6 = (void *)MEMORY[0x186E432B4]();
  if ((a2 & 1) != 0) {
    uint64_t v7 = 4LL;
  }
  else {
    uint64_t v7 = 5LL;
  }
  uint64_t v8 = [MEMORY[0x1896078D8] dataWithJSONObject:a1 options:v7 error:0];
  objc_autoreleasePoolPop(v6);
  if (a3)
  {
    if (v8) {
      int v9 = 0;
    }
    else {
      int v9 = -6732;
    }
    *a3 = v9;
  }

  return v8;
}

uint64_t KeychainAddFormatted( CFTypeRef *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = CFPropertyListBuildFormatted(0LL, 0LL, (CFTypeRef *)&attributes, a2, (uint64_t)&a9, a6, a7, a8);
  if (!(_DWORD)v10)
  {
    uint64_t v10 = SecItemAdd(attributes, a1);
    CFRelease(attributes);
  }

  return v10;
}

CFTypeRef KeychainCopyMatchingFormatted( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFTypeRef result = 0LL;
  int v10 = CFPropertyListBuildFormatted(0LL, 0LL, (CFTypeRef *)&query, a2, (uint64_t)&a9, a6, a7, a8);
  if (!v10)
  {
    int v10 = SecItemCopyMatching(query, &result);
    CFRelease(query);
    if (!a1) {
      return result;
    }
    goto LABEL_3;
  }

  if (a1) {
LABEL_3:
  }
    *a1 = v10;
  return result;
}

uint64_t KeychainDeleteFormatted( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = CFPropertyListBuildFormatted(0LL, 0LL, (CFTypeRef *)&query, a1, (uint64_t)&a9, a6, a7, a8);
  if (!(_DWORD)v9)
  {
    uint64_t v9 = SecItemDelete(query);
    CFRelease(query);
  }

  return v9;
}

uint64_t KeychainDeleteItemByPersistentRef( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return KeychainDeleteFormatted((uint64_t)"{%kO=%O}", a2, a3, a4, a5, a6, a7, a8, *MEMORY[0x18960BE80]);
}

uint64_t KeychainUpdateFormatted( const __CFDictionary *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = CFPropertyListBuildFormatted(0LL, 0LL, (CFTypeRef *)&attributesToUpdate, a2, (uint64_t)&a9, a6, a7, a8);
  if (!(_DWORD)v10)
  {
    uint64_t v10 = SecItemUpdate(a1, attributesToUpdate);
    CFRelease(attributesToUpdate);
  }

  return v10;
}

uint64_t LogUtils_EnsureInitialized()
{
  if ((gLogCFInitialized & 1) == 0 && (gLogUtilsInitializing & 1) == 0)
  {
    pthread_mutex_lock(&gLogUtilsLock);
    gLogUtilsInitializing = 1;
    if ((gLogCFInitialized & 1) == 0)
    {
      gLogCFInitialized = 1;
      notify_register_dispatch( "com.apple.managedconfiguration.defaultsdidchange",  (int *)&gLogUtilsMCDefaultsChangedToken,  MEMORY[0x1895F8AE0],  &__block_literal_global_11138);
      _LogUtils_ReadCFPreferences(0);
    }

    gLogUtilsInitializing = 0;
    return pthread_mutex_unlock(&gLogUtilsLock);
  }

  return result;
}

void _LogUtils_ReadCFPreferences(int a1)
{
  if (gLogCFPrefsAppID) {
    uint64_t v2 = (const __CFString *)gLogCFPrefsAppID;
  }
  else {
    uint64_t v2 = (const __CFString *)*MEMORY[0x189605188];
  }
  CFPreferencesAppSynchronize(v2);
  uint64_t v3 = (const __CFString *)CFPreferencesCopyAppValue(@"logconfig", v2);
  if (v3)
  {
    size_t v4 = v3;
    CFTypeID v5 = CFGetTypeID(v3);
    if (v5 == CFStringGetTypeID()
      && ((a1 & 4) != 0
       || v4 != (const __CFString *)gLogCFLastControlPref
       && (!gLogCFLastControlPref || !CFEqual(v4, (CFTypeRef)gLogCFLastControlPref))))
    {
      _LogControlLockedCF(v4, a1 | 2);
      uint64_t v6 = (const void *)gLogCFLastControlPref;
      CFRetain(v4);
      gLogCFLastControlPref = (uint64_t)v4;
      if (v6) {
        CFRelease(v6);
      }
    }

    CFRelease(v4);
  }

uint64_t _LogControlLockedCF(const __CFString *a1, int a2)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFIndex usedBufLen = MaximumSizeForEncoding;
  uint64_t v6 = (UInt8 *)malloc(MaximumSizeForEncoding + 1);
  if (!v6) {
    return 4294960568LL;
  }
  uint64_t v7 = v6;
  v11.location = 0LL;
  v11.length = Length;
  if (CFStringGetBytes(a1, v11, 0x8000100u, 0, 0, v6, MaximumSizeForEncoding, &usedBufLen) == Length)
  {
    if (usedBufLen < 1)
    {
      uint64_t v8 = 0LL;
    }

    else
    {
      v7[usedBufLen] = 0;
      uint64_t v8 = _LogControlLocked(v7, a2);
    }
  }

  else
  {
    uint64_t v8 = 4294960596LL;
  }

  free(v7);
  return v8;
}

uint64_t _LogControlLocked(unsigned __int8 *a1, int a2)
{
  if (a1)
  {
    uint64_t v2 = a1 + 1;
    int v3 = *a1;
    BOOL v4 = (a2 & 2) == 0;
    if (v3 != 63) {
      uint64_t v2 = a1;
    }
    int v5 = *v2;
    BOOL v6 = v3 == 63 && (a2 & 2) == 0;
    if (v5 == 43) {
      ++v2;
    }
    int v7 = *v2;
    BOOL v8 = v5 == 43 && (a2 & 2) == 0;
    if (v7 != 126) {
      BOOL v4 = 0;
    }
    if (v6 && v5 == 43)
    {
      if (gLogCFPrefsAppID) {
        uint64_t v9 = (const __CFString *)gLogCFPrefsAppID;
      }
      else {
        uint64_t v9 = (const __CFString *)*MEMORY[0x189605188];
      }
      CFPreferencesSetAppValue(@"logconfig", 0LL, v9);
      return 0LL;
    }

    if (v7 == 126) {
      uint64_t v10 = v2 + 1;
    }
    else {
      uint64_t v10 = v2;
    }
    int v11 = *v10;
    if (*v10)
    {
      uint64_t v12 = &gTUExitCode;
      v13 = &gLogActionList;
      BOOL v47 = v4;
      while (1)
      {
        int v14 = v10;
        if (!v4) {
          break;
        }
        if (v11)
        {
          do
          {
            if (v11 == 58) {
              break;
            }
            int v15 = *++v14;
            int v11 = v15;
          }

          while (v15);
        }

        uint64_t v16 = v14 - v10;
        if (v11) {
          v17 = v14 + 1;
        }
        else {
          v17 = v14;
        }
        for (i = v17; ; ++i)
        {
          unsigned int v19 = *i;
          if (v19 <= 0x3D && ((1LL << v19) & 0x2000100000000001LL) != 0) {
            break;
          }
        }

        if (*i) {
          int v22 = i + 1;
        }
        else {
          int v22 = i;
        }
        do
        {
          int v23 = *v22;
          if (!*v22) {
            break;
          }
          ++v22;
        }

        while (v23 != 44);
        v24 = (uint64_t *)*((void *)v12 + 108);
        if (v24)
        {
          BOOL v25 = v8;
          do
          {
            int v26 = v13;
            v13 = v24;
            while (!strnicmpx(v10, v16, (_BYTE *)v13[1])
                 && (i == v17 || !strnicmpx(v17, i - v17, (_BYTE *)v13[2])))
            {
              *int v26 = *v13;
              _LogUtils_FreeAction(v13);
              v13 = (uint64_t *)*v26;
              if (!*v26) {
                goto LABEL_57;
              }
            }

            v24 = (uint64_t *)*v13;
          }

          while (*v13);
LABEL_57:
          BOOL v8 = v25;
          BOOL v4 = v47;
          uint64_t v12 = &gTUExitCode;
LABEL_58:
          v13 = &gLogActionList;
        }

void _LogUtils_FreeAction(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    free(v2);
    a1[1] = 0LL;
  }

  int v3 = (void *)a1[2];
  if (v3)
  {
    free(v3);
    a1[2] = 0LL;
  }

  BOOL v4 = (void *)a1[3];
  if (v4) {
    free(v4);
  }
  free(a1);
}

void _LogCategory_ApplyActions(uint64_t a1)
{
  uint64_t v1 = gLogActionList;
  if (gLogActionList)
  {
    do
    {
      if (!strnicmpx(*(unsigned __int8 **)(v1 + 16), -1LL, "level"))
      {
        int v3 = LUStringToLevel(*(char **)(v1 + 24));
        if (v3 != -1)
        {
          uint64_t v4 = gLogCategoryList;
          if (gLogCategoryList)
          {
            int v5 = v3;
            do
            {
              uint64_t v4 = *(void *)(v4 + 48);
            }

            while (v4);
          }
        }
      }

      uint64_t v1 = *(void *)v1;
    }

    while (v1);
    uint64_t v6 = gLogActionList;
    if (gLogActionList)
    {
      do
      {
        if (!strnicmpx(*(unsigned __int8 **)(v6 + 16), -1LL, "flags"))
        {
          int v7 = *(const char **)(v6 + 24);
          int v8 = 0;
          uint64_t v9 = &v7[strlen(v7)];
LABEL_17:
          uint64_t v10 = (unsigned __int8 *)v7;
          while (v10 < (unsigned __int8 *)v9)
          {
            if (*v10 == 59)
            {
              BOOL v11 = 1;
              uint64_t v12 = v10;
            }

            else
            {
              size_t v13 = v9 - 1 - (const char *)v10;
              uint64_t v12 = v10;
              while (v13)
              {
                int v14 = *++v12;
                --v13;
                if (v14 == 59) {
                  goto LABEL_26;
                }
              }

              uint64_t v12 = (unsigned __int8 *)v9;
LABEL_26:
              BOOL v11 = v12 < (unsigned __int8 *)v9;
            }

            uint64_t v15 = v12 - v10;
            int v7 = (const char *)&v12[v11];
            if (!strnicmpx(v10, v12 - v10, "none"))
            {
              int v8 = 0;
              goto LABEL_17;
            }

            if (!strnicmpx(v10, v15, "time"))
            {
              v8 |= 1u;
              goto LABEL_17;
            }

            if (!strnicmpx(v10, v15, "pid"))
            {
              v8 |= 2u;
              goto LABEL_17;
            }

            if (!strnicmpx(v10, v15, "program"))
            {
              v8 |= 4u;
              goto LABEL_17;
            }

            if (!strnicmpx(v10, v15, "category"))
            {
              v8 |= 8u;
              goto LABEL_17;
            }

            if (!strnicmpx(v10, v15, "level"))
            {
              v8 |= 0x10u;
              goto LABEL_17;
            }

            if (!strnicmpx(v10, v15, "prefix"))
            {
              v8 |= 0x20u;
              goto LABEL_17;
            }

            if (!strnicmpx(v10, v15, "function"))
            {
              v8 |= 0x40u;
              goto LABEL_17;
            }

            if (!strnicmpx(v10, v15, "thread"))
            {
              v8 |= 0x80u;
              goto LABEL_17;
            }

            int v16 = strnicmpx(v10, v15, "public");
            uint64_t v10 = (unsigned __int8 *)v7;
            if (!v16)
            {
              v8 |= 0x200u;
              goto LABEL_17;
            }
          }

          for (uint64_t i = gLogCategoryList; i; uint64_t i = *(void *)(i + 48))
          {
            if ((!a1 || i == a1) && _LogCategoryMatch(*(_DWORD *)(i + 16), *(char **)(i + 24), *(char **)(v6 + 8)))
            {
              if ((v8 & 0x20) != 0)
              {
                v18 = *(const char **)(i + 24);
                unsigned int v19 = strchr(v18, 95);
                if (!v19) {
                  LODWORD(v19) = (_DWORD)v18 + strlen(v18);
                }
                *(void *)(i + 32) = v18;
                *(_DWORD *)(i + 40) = (_DWORD)v19 - (_DWORD)v18;
              }

              *(_DWORD *)(i + 16) = *(_DWORD *)(i + 16) & 0x70000 | v8;
            }
          }
        }

        uint64_t v6 = *(void *)v6;
      }

      while (v6);
      uint64_t v20 = gLogActionList;
      if (gLogActionList)
      {
        do
        {
          if (!strnicmpx(*(unsigned __int8 **)(v20 + 16), -1LL, "rate"))
          {
            int v21 = *(const char **)(v20 + 24);
            int64_t v22 = strlen(v21);
            int v23 = &v21[v22];
            if (v22 < 1)
            {
              unsigned int v24 = 0;
LABEL_66:
              uint64_t v26 = 0LL;
            }

            else
            {
              unsigned int v24 = 0;
              while (1)
              {
                unsigned int v25 = *(unsigned __int8 *)v21 - 48;
                if (v25 > 9) {
                  break;
                }
                unsigned int v24 = v25 + 10 * v24;
                if (++v21 >= v23) {
                  goto LABEL_66;
                }
              }

              uint64_t v26 = 1LL;
            }

            size_t v27 = &v21[v26];
            if (v27 >= v23)
            {
              uint64_t v28 = 0LL;
            }

            else
            {
              uint64_t v28 = 0LL;
              do
              {
                uint64_t v29 = *(unsigned __int8 *)v27;
                uint64_t v28 = v29 + 10 * v28 - 48;
                ++v27;
              }

              while (v27 < v23);
            }

            if (UpTicksPerSecond_sOnce != -1) {
              dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
            }
            uint64_t v30 = gLogCategoryList;
            if (gLogCategoryList)
            {
              unint64_t v31 = UpTicksPerSecond_sTicksPerSecond * v28 / 0x3E8uLL;
              do
              {
                if ((!a1 || v30 == a1)
                  && _LogCategoryMatch(*(_DWORD *)(v30 + 16), *(char **)(v30 + 24), *(char **)(v20 + 8)))
                {
                  *(void *)(v30 + 72) = v31;
                  *(_DWORD *)(v30 + 88) = v24;
                }

                uint64_t v30 = *(void *)(v30 + 48);
              }

              while (v30);
            }
          }

          uint64_t v20 = *(void *)v20;
        }

        while (v20);
        uint64_t v32 = gLogActionList;
        if (gLogActionList)
        {
          do
          {
            int v33 = strnicmpx(*(unsigned __int8 **)(v32 + 16), -1LL, "output");
            if (!v33 || !strnicmpx(*(unsigned __int8 **)(v32 + 16), -1LL, "output2"))
            {
              for (uint64_t j = gLogCategoryList; j; uint64_t j = *(void *)(j + 48))
              {
                if ((!a1 || j == a1) && _LogCategoryMatch(*(_DWORD *)(j + 16), *(char **)(j + 24), *(char **)(v32 + 8)))
                {
                  v35 = *(char **)(v32 + 24);
                  if (!*v35)
                  {
                    v36 = 0LL;
LABEL_95:
                    if (v33) {
                      uint64_t v37 = 64LL;
                    }
                    else {
                      uint64_t v37 = 56LL;
                    }
                    uint64_t v38 = *(void *)(j + v37);
                    if ((uint64_t *)v38 != v36)
                    {
                      if (v38) {
                        --*(_DWORD *)(v38 + 8);
                      }
                      if (v36) {
                        ++*((_DWORD *)v36 + 2);
                      }
                      *(void *)(j + v37) = v36;
                    }

                    continue;
                  }

                  if (!_LogOutputCreate(v35, &v46))
                  {
                    v36 = v46;
                    goto LABEL_95;
                  }
                }
              }
            }

            uint64_t v32 = *(void *)v32;
          }

          while (v32);
          uint64_t v39 = gLogActionList;
          if (gLogActionList)
          {
            while (strnicmpx(*(unsigned __int8 **)(v39 + 16), -1LL, "o1l"))
            {
              if (!strnicmpx(*(unsigned __int8 **)(v39 + 16), -1LL, "output2Level"))
              {
LABEL_111:
                int v40 = 0;
                goto LABEL_113;
              }

LABEL_124:
              uint64_t v39 = *(void *)v39;
              if (!v39) {
                goto LABEL_125;
              }
            }

            int v40 = 1;
LABEL_113:
            int v41 = LUStringToLevel(*(char **)(v39 + 24));
            uint64_t v42 = gLogCategoryList;
            if (gLogCategoryList)
            {
              int v43 = v41;
              do
              {
                if ((!a1 || v42 == a1)
                  && _LogCategoryMatch(*(_DWORD *)(v42 + 16), *(char **)(v42 + 24), *(char **)(v39 + 8)))
                {
                  if (v40) {
                    uint64_t v44 = 56LL;
                  }
                  else {
                    uint64_t v44 = 64LL;
                  }
                  uint64_t v45 = *(void *)(v42 + v44);
                  if (v45) {
                    *(_DWORD *)(v45 + 24) = v43;
                  }
                }

                uint64_t v42 = *(void *)(v42 + 48);
              }

              while (v42);
            }

            goto LABEL_124;
          }
        }
      }
    }
  }

void _LogUtils_WriteCFPreferences()
{
  cStr = 0LL;
  uint64_t v0 = gLogActionList;
  if (gLogActionList)
  {
    do
    {
      uint64_t v1 = *(const char **)(v0 + 16);
      if (strcasecmp(v1, "output") && strcasecmp(v1, "output2")
        || stricmp_prefix(*(unsigned __int8 **)(v0 + 24), "callback"))
      {
        if (v0 == gLogActionList) {
          int v8 = "";
        }
        else {
          int v8 = ",";
        }
        AppendPrintF((void **)&cStr, (uint64_t)"%s%s:%s=%s", v2, v3, v4, v5, v6, v7, (uint64_t)v8);
      }

      uint64_t v0 = *(void *)v0;
    }

    while (v0);
    uint64_t v9 = cStr;
    if (cStr)
    {
      CFStringRef v10 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
      if (v10)
      {
        CFStringRef v11 = v10;
        if (gLogCFPrefsAppID) {
          uint64_t v12 = (const __CFString *)gLogCFPrefsAppID;
        }
        else {
          uint64_t v12 = (const __CFString *)*MEMORY[0x189605188];
        }
        CFPreferencesSetAppValue(@"logconfig", v10, v12);
        CFPreferencesAppSynchronize(v12);
        size_t v13 = (const void *)gLogCFLastControlPref;
        CFRetain(v11);
        gLogCFLastControlPref = (uint64_t)v11;
        if (v13) {
          CFRelease(v13);
        }
        CFRelease(v11);
      }

      free(v9);
    }
  }

uint64_t LUStringToLevel(char *__s1)
{
  uint64_t v2 = MEMORY[0x1895F8770];
  uint64_t v3 = __s1;
  do
  {
    uint64_t v4 = v3;
    int v5 = *v3;
    if (*v3 < 0) {
      int v6 = __maskrune(*v3, 0x100uLL);
    }
    else {
      int v6 = *(_DWORD *)(v2 + 4LL * *v3 + 60) & 0x100;
    }
    ++v3;
  }

  while (v6);
  size_t v7 = v4 - __s1;
  if (v4 == __s1)
  {
    int v10 = *__s1;
    if ((v10 - 48) > 9)
    {
      unsigned int v11 = 0;
    }

    else
    {
      unsigned int v11 = 0;
      uint64_t v12 = __s1 + 1;
      do
      {
        unsigned int v11 = 10 * v11 + (char)v10 - 48;
        int v13 = *v12++;
        int v10 = v13;
      }

      while ((v13 - 48) < 0xA);
    }

    if (v10) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v11;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    for (uint64_t i = (const char **)&off_189F33770; strncmp(__s1, *i, v7); i += 2)
    {
      if (++v8 == 18) {
        return 0xFFFFFFFFLL;
      }
    }

    uint64_t result = kLogLevelToStringTable[4 * v8];
    if (v5 && (_DWORD)result != -1)
    {
      int v15 = *v3;
      if ((v15 - 48) > 9)
      {
        int v16 = 0;
      }

      else
      {
        int v16 = 0;
        uint64_t v17 = 1LL;
        do
        {
          int v16 = 10 * v16 + (char)v15 - 48;
          int v15 = v3[v17++];
        }

        while ((v15 - 48) < 0xA);
      }

      if (v15) {
        return 0xFFFFFFFFLL;
      }
      if (v5 != 45)
      {
        if (v5 == 43) {
          return (v16 + result);
        }
        return 0xFFFFFFFFLL;
      }

      return (result - v16);
    }
  }

  return result;
}

BOOL _LogCategoryMatch(__int16 a1, char *a2, char *a3)
{
  if ((a1 & 0x100) != 0) {
    return strcasecmp(a2, a3) == 0;
  }
  else {
    return RegexMatch((unsigned __int8 *)a3, a2) != 0;
  }
}

uint64_t _LogOutputCreate(char *a1, uint64_t **a2)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  uint64_t v4 = &gLogOutputList;
  while (1)
  {
    uint64_t v4 = (uint64_t *)*v4;
    if (!v4) {
      break;
    }
    if (!strnicmpx((unsigned __int8 *)v4[2], -1LL, a1))
    {
      uint64_t v5 = 0LL;
LABEL_149:
      *a2 = v4;
      return v5;
    }
  }

  int v6 = (uint64_t *)calloc(1uLL, 0x68uLL);
  if (!v6) {
    return 4294960568LL;
  }
  uint64_t v4 = v6;
  *((_DWORD *)v6 + 2) = 0;
  size_t v7 = strdup(a1);
  v4[2] = (uint64_t)v7;
  if (!v7)
  {
LABEL_152:
    uint64_t v5 = 4294960568LL;
    goto LABEL_142;
  }

  *((_DWORD *)v4 + 6) = -1;
  uint64_t v9 = i - (unsigned __int8 *)a1;
  if (i == (unsigned __int8 *)a1)
  {
    uint64_t v5 = 4294960540LL;
    goto LABEL_142;
  }

  if (*i) {
    int v10 = i + 1;
  }
  else {
    int v10 = i;
  }
  if (strnicmpx((unsigned __int8 *)a1, i - (unsigned __int8 *)a1, "callback"))
  {
    if (!strnicmpx((unsigned __int8 *)a1, v9, "console"))
    {
      goto LABEL_44;
    }

    if (strnicmpx((unsigned __int8 *)a1, v9, "file"))
    {
      if (!strnicmpx((unsigned __int8 *)a1, v9, "oslog"))
      {
        uint64_t v18 = _LogOutputOSLog_Setup((uint64_t)v4, v10);
        if ((_DWORD)v18)
        {
LABEL_144:
          uint64_t v5 = v18;
          goto LABEL_142;
        }

LABEL_148:
        uint64_t v5 = 0LL;
        *uint64_t v4 = gLogOutputList;
        gLogOutputList = (uint64_t)v4;
        goto LABEL_149;
      }

      if (strnicmpx((unsigned __int8 *)a1, v9, "syslog"))
      {
LABEL_20:
        uint64_t v5 = 4294960591LL;
        goto LABEL_142;
      }

LABEL_123:
          size_t v30 = j;
LABEL_124:
          if (v30 == 1)
          {
            v50 = 0LL;
          }

          else
          {
            v51 = malloc(v30);
            if (!v51) {
              goto LABEL_152;
            }
            v50 = v51;
            memcpy(v51, v22 + 1, v28);
            v50[v28] = 0;
          }

          v52 = (void *)v4[11];
          if (v52) {
            free(v52);
          }
          v4[11] = (uint64_t)v50;
          v53 = &v31[v25];
          if (v53 >= v27)
          {
            int v54 = 0;
          }

          else
          {
            int v54 = 0;
            do
            {
              int v55 = *v53;
              int v54 = (char)v55 + 10 * v54 - 48;
              ++v53;
            }

            while (v53 < v27);
          }

          if (v53 != v27) {
            goto LABEL_20;
          }
          *((_DWORD *)v4 + 24) = v54;
          goto LABEL_138;
        }

LABEL_139:
        v56 = (FILE *)v4[7];
        if (!v56) {
          goto LABEL_20;
        }
LABEL_147:
        setvbuf(v56, 0LL, 2, 0LL);
        goto LABEL_148;
      }

      v57 = (FILE **)MEMORY[0x1895F89E0];
    }

    else
    {
      v57 = (FILE **)MEMORY[0x1895F89D0];
    }

    v56 = *v57;
    v4[7] = (uint64_t)*v57;
    goto LABEL_147;
  }

  v4[6] = 0LL;
  v4[7] = 0LL;
  int v11 = *v10;
  if (!*v10)
  {
LABEL_42:
    v4[4] = (uint64_t)_LogOutputCallBack_Writer;
    *((_DWORD *)v4 + 10) = 11;
    goto LABEL_148;
  }

  while (1)
  {
    uint64_t v12 = v10;
    if (!v11)
    {
LABEL_141:
      uint64_t v5 = 4294960554LL;
      goto LABEL_142;
    }

    while (v11 != 61)
    {
      int v13 = *++v12;
      int v11 = v13;
      if (!v13) {
        goto LABEL_141;
      }
    }

    uint64_t v14 = v12 - v10;
    for (k = v12 + 1; *k && *k != 59; ++k)
      ;
    unint64_t v16 = k - (v12 + 1);
    uint64_t v17 = *k ? k + 1 : k;
    if (!strnicmpx(v10, v14, "arg"))
    {
      if (v16 > 0x3F) {
        goto LABEL_155;
      }
      __memcpy_chk();
      v61[v16] = 0;
      if (sscanf(v61, "%p", v4 + 7) != 1) {
        goto LABEL_141;
      }
    }

      v64 = a2;
      while (1)
      {
        if (v64 == (unsigned __int8 *)v16)
        {
LABEL_196:
          v80 = -6727;
          goto LABEL_267;
        }

        if ((unint64_t)v64 >= v16)
        {
          v80 = -6705;
          goto LABEL_267;
        }

        v65 = v64 + 2;
        v66 = v64[1];
        v67 = *v64;
        v64 += v66 + 2;
        if (v67 == 7)
        {
          appended = 0;
          if ((_DWORD)v66 == 1)
          {
            v68 = *v65;
            v69 = -6737;
            switch(*v65)
            {
              case 0:
                goto LABEL_160;
              case 1:
                v69 = -6700;
                goto LABEL_160;
              case 2:
                v70 = *(int **)(a1 + 16);
                if (*v70 > 30) {
                  goto LABEL_212;
                }
                if (*v70 != -1) {
                  goto LABEL_151;
                }
                if (_LogCategory_Initialize((uint64_t)v70, 0x1Eu))
                {
                  v70 = *(int **)(a1 + 16);
LABEL_151:
                  LogPrintF( (uint64_t)v70,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)"### Pair-setup client wrong setup code\n",  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  v167);
                }

LABEL_155:
  uint64_t v5 = 4294960553LL;
LABEL_142:
  _LogOutputDelete(v4);
  return v5;
}

void _LogOutputDeleteUnused()
{
  uint64_t v0 = gLogOutputList;
  if (gLogOutputList)
  {
    uint64_t v1 = &gLogOutputList;
    do
    {
      uint64_t v2 = v1;
      uint64_t v1 = (uint64_t *)v0;
      while (1)
      {
        uint64_t v0 = *v1;
        if (*((_DWORD *)v1 + 2)) {
          break;
        }
        *uint64_t v2 = v0;
        _LogOutputDelete(v1);
        uint64_t v1 = (uint64_t *)*v2;
        if (!*v2) {
          return;
        }
      }
    }

    while (v0);
  }

void _LogOutputDelete(_DWORD *a1)
{
  int v2 = a1[10];
  if (v2 == 2)
  {
    uint64_t v3 = (void *)*((void *)a1 + 6);
    if (v3)
    {
      free(v3);
      *((void *)a1 + 6) = 0LL;
    }

    uint64_t v4 = (FILE *)*((void *)a1 + 7);
    if (v4)
    {
      if (v4 != (FILE *)*MEMORY[0x1895F89D0] && v4 != (FILE *)*MEMORY[0x1895F89E0]) {
        fclose(v4);
      }
      *((void *)a1 + 7) = 0LL;
    }

    int v6 = (void *)*((void *)a1 + 11);
    if (v6)
    {
      free(v6);
      *((void *)a1 + 11) = 0LL;
    }

    int v2 = a1[10];
  }

  if (v2 == 14)
  {
    size_t v7 = (void *)*((void *)a1 + 9);
    if (v7)
    {
      free(v7);
      *((void *)a1 + 9) = 0LL;
    }

    uint64_t v8 = (void *)*((void *)a1 + 6);
    if (v8)
    {
      free(v8);
      *((void *)a1 + 6) = 0LL;
    }

    uint64_t v9 = (void *)*((void *)a1 + 7);
    if (v9)
    {

      *((void *)a1 + 7) = 0LL;
    }
  }

  int v10 = (void *)*((void *)a1 + 2);
  if (v10) {
    free(v10);
  }
  free(a1);
}

uint64_t _LogOutputCallBack_Writer(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a2 + 48);
  if (v4) {
    return v4(result, a3, a4, *(void *)(a2 + 56));
  }
  return result;
}

uint64_t _LogOutputOSLog_Setup(uint64_t a1, unsigned __int8 *a2)
{
  *(void *)(a1 + 32) = _LogOutputOSLog_Writer;
  *(_DWORD *)(a1 + 40) = 14;
  uint64_t v4 = *(void **)(a1 + 48);
  if (v4)
  {
    free(v4);
    *(void *)(a1 + 48) = 0LL;
  }

  uint64_t v5 = *(void **)(a1 + 56);
  if (v5)
  {

    *(void *)(a1 + 56) = 0LL;
  }

  *(_DWORD *)(a1 + 64) = 0;
  int v6 = *(void **)(a1 + 72);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 72) = 0LL;
  }

  int v7 = *a2;
  if (!*a2) {
    return 0LL;
  }
  do
  {
    uint64_t v8 = a2;
    if (!v7) {
      return 4294960554LL;
    }
    while (v7 != 61)
    {
      int v9 = *++v8;
      int v7 = v9;
      if (!v9) {
        return 4294960554LL;
      }
    }

    uint64_t v10 = v8 - a2;
    int v11 = v8 + 1;
    for (uint64_t i = v8 + 1; *i && *i != 59; ++i)
      ;
    size_t v13 = i - v11;
    if (*i) {
      uint64_t v14 = i + 1;
    }
    else {
      uint64_t v14 = i;
    }
    if (strnicmpx(a2, v10, "category"))
    {
      if (strnicmpx(a2, v10, "public"))
      {
        if (strnicmpx(a2, v10, "sensitive"))
        {
          if (strnicmpx(a2, v10, "subsystem"))
          {
            if (strnicmpx(v11, v13, "debug"))
            {
              if (strnicmpx(v11, v13, "default"))
              {
                if (strnicmpx(v11, v13, "error"))
                {
                  if (strnicmpx(v11, v13, "fault"))
                  {
                    char v15 = 1;
                  }

                  else
                  {
                    char v15 = 17;
                  }
                }

                else
                {
                  char v15 = 16;
                }
              }

              else
              {
                char v15 = 0;
              }
            }

            else
            {
              char v15 = 2;
            }

            *(_BYTE *)(a1 + 64) = 1;
            *(_BYTE *)(a1 + 65) = v15;
          }

          else
          {
            int v21 = malloc(v13 + 1);
            if (!v21) {
              return 4294960568LL;
            }
            int64_t v22 = v21;
            memcpy(v21, v11, v13);
            v22[v13] = 0;
            int v23 = *(void **)(a1 + 72);
            if (v23) {
              free(v23);
            }
            *(void *)(a1 + 72) = v22;
          }
        }

        else
        {
          BOOL v20 = !strnicmpx(v11, v13, "true")
             || !strnicmpx(v11, v13, "yes")
             || !strnicmpx(v11, v13, "y")
          *(_BYTE *)(a1 + 67) = v20;
        }
      }

      else
      {
        BOOL v19 = !strnicmpx(v11, v13, "true")
           || !strnicmpx(v11, v13, "yes")
           || !strnicmpx(v11, v13, "y")
        *(_BYTE *)(a1 + 66) = v19;
      }
    }

    else
    {
      unint64_t v16 = malloc(v13 + 1);
      if (!v16) {
        return 4294960568LL;
      }
      uint64_t v17 = v16;
      memcpy(v16, v11, v13);
      v17[v13] = 0;
      uint64_t v18 = *(void **)(a1 + 48);
      if (v18) {
        free(v18);
      }
      *(void *)(a1 + 48) = v17;
    }

uint64_t _LogOutputSysLog_Setup(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  *(_DWORD *)(a1 + 48) = 5;
  int v3 = *a2;
  if (*a2)
  {
    while (1)
    {
      uint64_t v4 = a2;
      if (!v3) {
        return 4294960554LL;
      }
      while (v3 != 61)
      {
        int v5 = *++v4;
        int v3 = v5;
        if (!v5) {
          return 4294960554LL;
        }
      }

      int v6 = v4 + 1;
      for (uint64_t i = v4 + 1; *i && *i != 59; ++i)
        ;
      if (*i) {
        uint64_t v8 = i + 1;
      }
      else {
        uint64_t v8 = i;
      }
      if (!strnicmpx(a2, v4 - a2, "level"))
      {
        uint64_t v9 = (unint64_t)(i - v6) >= 0x1F ? 31LL : i - v6;
        __memcpy_chk();
        __s1[v9] = 0;
        int v10 = LUStringToLevel(__s1);
        if (v10 != -1)
        {
          if (v10 <= 119)
          {
            if (v10 <= 109)
            {
              if (v10 <= 99)
              {
                if (v10 <= 89)
                {
                  if (v10 <= 59)
                  {
                    if (v10 <= 49)
                    {
                      if (v10 > 39) {
                        int v11 = 6;
                      }
                      else {
                        int v11 = 7;
                      }
                    }

                    else
                    {
                      int v11 = 5;
                    }
                  }

                  else
                  {
                    int v11 = 4;
                  }
                }

                else
                {
                  int v11 = 3;
                }
              }

              else
              {
                int v11 = 2;
              }
            }

            else
            {
              int v11 = 1;
            }
          }

          else
          {
            int v11 = 0;
          }

          *(_DWORD *)(a1 + 48) = v11;
        }
      }

      int v3 = *v8;
      a2 = v8;
      if (!*v8) {
        goto LABEL_35;
      }
    }
  }

  else
  {
LABEL_35:
    uint64_t result = 0LL;
    *(void *)(a1 + 32) = _LogOutputSysLog_Writer;
    *(_DWORD *)(a1 + 40) = 6;
  }

  return result;
}

void _LogOutputFile_Writer( int a1, uint64_t a2, void *__ptr, size_t __nitems, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  int v11 = (FILE **)(a2 + 56);
  int v10 = *(FILE **)(a2 + 56);
  if (v10 != (FILE *)*MEMORY[0x1895F89D0] && v10 != (FILE *)*MEMORY[0x1895F89E0])
  {
    uint64_t v14 = *(void *)(a2 + 72);
    uint64_t v15 = *(void *)(a2 + 64) + __nitems;
    *(void *)(a2 + 64) = v15;
    if (v14 >= 1 && v15 > v14)
    {
      if (*(void *)(a2 + 88))
      {
        int v17 = *(_DWORD *)(a2 + 96);
        BOOL v18 = __OFSUB__(v17, 1);
        uint64_t v19 = (v17 - 1);
        if ((int)v19 < 0 == v18)
        {
          SNPrintF((uint64_t)__old, 1025LL, "%s.%d", (uint64_t)v10, a5, a6, a7, a8, *(void *)(a2 + 88), v19);
          remove(__old);
          int v25 = *(_DWORD *)(a2 + 96);
          if (v25 >= 3)
          {
            uint64_t v26 = (v25 - 2);
            do
            {
              SNPrintF((uint64_t)__old, 1025LL, "%s.%d", v20, v21, v22, v23, v24, *(void *)(a2 + 88), v26);
              SNPrintF( (uint64_t)__new,  1025LL,  "%s.%d",  v27,  v28,  v29,  v30,  v31,  *(void *)(a2 + 88),  (v26 + 1));
              rename(__old, __new);
              BOOL v32 = (_DWORD)v26 != 0;
              uint64_t v26 = (v26 - 1);
            }

            while ((_DWORD)v26 != 0 && v32);
          }

          SNPrintF((uint64_t)__new, 1025LL, "%s.1", v20, v21, v22, v23, v24, *(void *)(a2 + 88));
          rename(*(const char **)(a2 + 88), __new);
          SNPrintF((uint64_t)__new, 1025LL, "%s", v33, v34, v35, v36, v37, *(void *)(a2 + 88));
          uint64_t v38 = *(const char **)(a2 + 48);
          int v39 = malloc(0x1000uLL);
          if (v39)
          {
            int v40 = v39;
            uint64_t v41 = fopen(v38, "r");
            if (v41 || *__error() && !*__error())
            {
              uint64_t v42 = fopen(__new, "w");
              if (v42 || *__error() && !*__error())
              {
                do
                  size_t v43 = fread(v40, 1uLL, 0x1000uLL, v41);
                while (v43 && (fwrite(v40, 1uLL, v43, v42) == v43 || *__error() && !*__error()));
              }

              if (v41) {
                fclose(v41);
              }
              if (v42) {
                fclose(v42);
              }
            }

            free(v40);
          }
        }
      }

      RollLogFiles(v11, "\nLOG ENDED, CONTINUES IN NEXT LOG FILE\n", *(const char **)(a2 + 48), *(_DWORD *)(a2 + 80));
      *(void *)(a2 + 64) = __nitems;
      int v10 = *(FILE **)(a2 + 56);
    }
  }

  if (v10)
  {
    fwrite(__ptr, 1uLL, __nitems, v10);
    fflush(*v11);
  }

void _LogOutputSysLog_Writer(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4)
{
  if (a4)
  {
    int v4 = a4 - 1;
    if (a3[a4 - 1] != 10) {
      int v4 = a4;
    }
  }

  else
  {
    int v4 = 0;
  }

  syslog(*(_DWORD *)(a2 + 48), "%.*s", v4, a3);
}

void _LogOutputOSLog_Writer(uint64_t a1, uint64_t a2, char *__s1, size_t __n)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v31 = 0LL;
  uint64_t v8 = *(os_log_s **)(a2 + 56);
  if (!v8)
  {
    os_log_t OSLogHandle = _LogCategoryGetOSLogHandle(*(void *)a1, &v31);
    if (OSLogHandle) {
      uint64_t v8 = OSLogHandle;
    }
    else {
      uint64_t v8 = (os_log_s *)MEMORY[0x1895F8DA0];
    }
  }

  if (*(_BYTE *)(a2 + 64))
  {
    os_log_type_t v10 = *(_BYTE *)(a2 + 65);
    if (!__n) {
      goto LABEL_9;
    }
    goto LABEL_7;
  }

  unsigned int v26 = *(unsigned __int8 *)(a1 + 8);
  if (v26 > 0xA) {
    char v27 = 1;
  }
  else {
    char v27 = 2;
  }
  if (v26 > 0x14) {
    char v27 = 0;
  }
  if (v26 <= 0x59) {
    char v28 = v27;
  }
  else {
    char v28 = 16;
  }
  if (v26 <= 0x72) {
    os_log_type_t v10 = v28;
  }
  else {
    os_log_type_t v10 = OS_LOG_TYPE_FAULT;
  }
  if (__n)
  {
LABEL_7:
    if (__s1[__n - 1] == 10) {
      --__n;
    }
  }

os_log_t _LogCategoryGetOSLogHandle(uint64_t a1, void *a2)
{
  if ((*(_BYTE *)(a1 + 18) & 2) == 0) {
    return 0LL;
  }
  int v4 = *(os_log_t **)(a1 + 104);
  if (!v4) {
    return 0LL;
  }
  os_log_t v2 = *v4;
  if (*v4) {
    goto LABEL_14;
  }
  int v6 = *(const char **)(a1 + 96);
  if (!v6) {
    int v6 = getprogname();
  }
  int v7 = *(const char **)(a1 + 24);
  if (!v7) {
    return 0LL;
  }
  uint64_t v8 = strchr(v7, 45);
  if (!v8)
  {
    os_log_t v2 = os_log_create(v6, v7);
    *int v4 = v2;
    if (!a2) {
      return v2;
    }
    goto LABEL_15;
  }

  uint64_t v9 = v8;
  os_log_t v10 = v4[1];
  if (v10)
  {
    free(v10);
    v4[1] = 0LL;
  }

  int v11 = strdup(v9 + 1);
  v4[1] = (os_log_t)v11;
  if (!v11) {
    return 0LL;
  }
  uint64_t v12 = strndup(v7, v9 - v7);
  if (!v12) {
    return 0LL;
  }
  size_t v13 = v12;
  os_log_t v2 = os_log_create(v6, v12);
  *int v4 = v2;
  free(v13);
LABEL_14:
  if (a2) {
LABEL_15:
  }
    *a2 = v4[1];
  return v2;
}

uint64_t LogControl(char *a1)
{
  if (a1)
  {
    if (!strcmp(a1, "?:output=syslog")) {
      return 0LL;
    }
    LogUtils_EnsureInitialized();
    pthread_mutex_lock(&gLogUtilsLock);
    uint64_t v2 = _LogControlLocked((unsigned __int8 *)a1, 0);
  }

  else
  {
    LogUtils_EnsureInitialized();
    pthread_mutex_lock(&gLogUtilsLock);
    while (1)
    {
      int v3 = (void *)gLogActionList;
      if (!gLogActionList) {
        break;
      }
      gLogActionList = *(void *)gLogActionList;
      _LogUtils_FreeAction(v3);
    }

    uint64_t v2 = 0LL;
  }

  pthread_mutex_unlock(&gLogUtilsLock);
  return v2;
}

uint64_t LogControlCF(const __CFString *a1)
{
  uint64_t locked = _LogControlLockedCF(a1, 0);
  pthread_mutex_unlock(&gLogUtilsLock);
  return locked;
}

uint64_t LogSetAppID(CFTypeRef cf1)
{
  if (cf1)
  {
    uint64_t result = CFEqual(cf1, @"com.apple.CoreRC");
    if ((_DWORD)result) {
      return result;
    }
    pthread_mutex_lock(&gLogUtilsLock);
    int v3 = (const void *)gLogCFPrefsAppID;
    CFRetain(cf1);
  }

  else
  {
    pthread_mutex_lock(&gLogUtilsLock);
    int v3 = (const void *)gLogCFPrefsAppID;
  }

  gLogCFPrefsAppID = (uint64_t)cf1;
  if (v3) {
    CFRelease(v3);
  }
  return pthread_mutex_unlock(&gLogUtilsLock);
}

uint64_t LogSetOutputCallback()
{
  int v3 = 0LL;
  ASPrintF((void **)&v3);
  uint64_t v0 = v3;
  if (!v3) {
    return 4294960568LL;
  }
  LogUtils_EnsureInitialized();
  pthread_mutex_lock(&gLogUtilsLock);
  uint64_t v1 = _LogControlLocked(v0, 1);
  pthread_mutex_unlock(&gLogUtilsLock);
  free(v0);
  return v1;
}

uint64_t LogShow(void **a1)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  pthread_mutex_lock(&gLogUtilsLock);
  size_t v43 = 0LL;
  getprogname();
  getpid();
  if ((int)ASPrintF(&v43) < 1)
  {
    uint64_t v26 = 4294960568LL;
  }

  else
  {
    uint64_t v2 = gLogCategoryList;
    if (!gLogCategoryList) {
      goto LABEL_32;
    }
    size_t v3 = 0LL;
    unint64_t v4 = 0LL;
    do
    {
      size_t v5 = strlen(*(const char **)(v2 + 24));
      if (v5 > v4) {
        unint64_t v4 = v5;
      }
      _LULevelToString(*(_DWORD *)v2, (uint64_t)__s);
      size_t v6 = strlen(__s);
      if (v6 > v3) {
        size_t v3 = v6;
      }
      uint64_t v2 = *(void *)(v2 + 48);
    }

    while (v2);
    uint64_t v7 = gLogCategoryList;
    if (gLogCategoryList)
    {
      uint64_t v42 = a1;
      do
      {
        v45[0] = 0;
        uint64_t v8 = *(void *)(v7 + 56);
        if (v8)
        {
          uint64_t v9 = *(unsigned __int8 **)(v8 + 16);
          int v10 = *(_DWORD *)(v8 + 24);
          if (v10 != -1) {
            _LULevelToString(v10, (uint64_t)v45);
          }
        }

        else
        {
          uint64_t v9 = 0LL;
        }

        if (!v9) {
          uint64_t v9 = "";
        }
        stricmp_prefix(v9, "callback");
        v44[0] = 0;
        uint64_t v11 = *(void *)(v7 + 64);
        if (v11)
        {
          uint64_t v12 = *(unsigned __int8 **)(v11 + 16);
          int v13 = *(_DWORD *)(v11 + 24);
          if (v13 != -1) {
            _LULevelToString(v13, (uint64_t)v44);
          }
        }

        else
        {
          uint64_t v12 = 0LL;
        }

        if (!v12) {
          uint64_t v12 = "";
        }
        stricmp_prefix(v12, "callback");
        _LULevelToString(*(_DWORD *)v7, (uint64_t)__s);
        UpTicksToMilliseconds(*(void *)(v7 + 72));
        if ((int)AppendPrintF( &v43,  (uint64_t)"  %-*s  L=%-*s  R=%u/%-5llu  O1=%s  O1L=%s  O2=%s  O2L=%s\n",  v14,  v15,  v16,  v17,  v18,  v19,  v4) <= 0)
        {
          uint64_t v26 = 4294960568LL;
          a1 = v42;
          goto LABEL_43;
        }

        uint64_t v7 = *(void *)(v7 + 48);
      }

      while (v7);
      uint64_t v26 = 0LL;
      uint64_t v27 = gLogActionList;
      if (gLogCategoryList)
      {
        a1 = v42;
        if (!gLogActionList) {
          goto LABEL_33;
        }
        else {
          uint64_t v26 = 0LL;
        }
        uint64_t v27 = gLogActionList;
        if (gLogActionList) {
          goto LABEL_34;
        }
      }

      else
      {
        a1 = v42;
        if (gLogActionList) {
          goto LABEL_34;
        }
      }
    }

    else
    {
LABEL_32:
      uint64_t v26 = 0LL;
      uint64_t v27 = gLogActionList;
LABEL_33:
      if (v27)
      {
LABEL_34:
        while (1)
        {
          if ((char v28 = *(const char **)(v27 + 16), strcasecmp(v28, "output")) && strcasecmp(v28, "output2")
            || stricmp_prefix(*(unsigned __int8 **)(v27 + 24), "callback"))
          {
            if ((int)AppendPrintF( &v43,  (uint64_t)"  Action: %s:%s=%s\n",  v29,  v30,  v31,  v32,  v33,  v34,  *(void *)(v27 + 8)) < 1) {
              break;
            }
          }

          uint64_t v27 = *(void *)v27;
          if (!v27) {
            goto LABEL_43;
          }
        }

        uint64_t v26 = 4294960568LL;
      }
    }
  }

uint64_t _LULevelToString(unsigned __int8 a1, uint64_t a2)
{
  uint64_t v3 = 0LL;
  int v4 = 0;
  int v5 = 0x7FFFFFFF;
  size_t v6 = kLogLevelToStringTable;
  do
  {
    int v7 = *v6;
    v6 += 4;
    int v8 = a1 - v7;
    if (v8 < 0) {
      int v8 = -v8;
    }
    if (v8 < v5)
    {
      int v5 = v8;
      int v4 = v3;
    }

    ++v3;
  }

  while (v3 != 18);
  int v9 = a1 - kLogLevelToStringTable[4 * v4];
  if (v9 < 1)
  {
    if (v9 < 0) {
      int v10 = "%s-%u";
    }
    else {
      int v10 = "%s";
    }
  }

  else
  {
    int v10 = "%s+%u";
  }

  SNPrintF(a2, 64LL, v10);
  return a2;
}

BOOL _LogCategory_Initialize(uint64_t a1, unsigned __int8 a2)
{
  if ((gLogUtilsInitializing & 1) != 0) {
    return 0LL;
  }
  LogUtils_EnsureInitialized();
  pthread_mutex_lock(&gLogUtilsLock);
  if (*(_DWORD *)a1 == -1)
  {
    *(_DWORD *)a1 = *(_DWORD *)(a1 + 4);
    int v5 = &gLogCategoryList;
    uint64_t v6 = gLogCategoryList;
    if (gLogCategoryList)
    {
      while ((int)strnicmpx(*(unsigned __int8 **)(v6 + 24), -1LL, *(_BYTE **)(a1 + 24)) < 1)
      {
        uint64_t v7 = *(void *)(v6 + 48);
        int v5 = (uint64_t *)(v6 + 48);
        uint64_t v6 = v7;
        if (!v7) {
          goto LABEL_10;
        }
      }

      uint64_t v7 = *v5;
    }

    else
    {
      uint64_t v7 = 0LL;
    }

uint64_t LogPrintF( uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return LogPrintV(a1, a2, a3, a4, &a9);
}

uint64_t LogPrintV(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, char *a5)
{
  uint64_t v6 = a1;
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t v38 = a5;
  __s[0] = 0LL;
  int v7 = a3 & 0x4200000;
  if ((a3 & 0x4200000) != 0)
  {
    __s[1] = v38;
    a1 = VASPrintF((void **)__s);
  }

  LogUtils_EnsureInitialized(a1);
  pthread_mutex_lock(&gLogUtilsLock);
  int v8 = 0;
  uint64_t v40 = v6;
  unsigned int v41 = a3;
  char v42 = 0;
  uint64_t v43 = 0LL;
  char v44 = 0;
  if ((a3 & 0x80000) == 0)
  {
    int v9 = *(_DWORD *)(v6 + 16);
    if ((a3 & 0x400000) == 0 && *(_DWORD *)(v6 + 88))
    {
      if (!*(void *)(v6 + 80)) {
        *(void *)(v6 + 80) = *(void *)(v6 + 72) + mach_absolute_time();
      }
      if (mach_absolute_time() >= *(void *)(v6 + 80))
      {
        unsigned int v10 = 0;
        *(void *)(v6 + 80) = 0LL;
        *(_DWORD *)(v6 + 92) = 0;
      }

      else
      {
        unsigned int v10 = *(_DWORD *)(v6 + 92);
      }

      if (v10 >= *(_DWORD *)(v6 + 88))
      {
        pthread_mutex_unlock(&gLogUtilsLock);
        uint64_t v23 = 0LL;
        uint64_t v24 = __s[0];
        goto LABEL_66;
      }

      *(_DWORD *)(v6 + 92) = v10 + 1;
    }

    if ((v9 & 1) != 0)
    {
      int v11 = SNPrintF(v39, 64LL, "%N ");
      if (v11 >= 1) {
        _LogPrintFWrite((uint64_t)&v40, v39, v11, 1);
      }
    }

    if ((a3 >> 14) & 0x40 | (a3 >> 17) & 0x80 | v9 & 0xFE)
    {
      int v12 = CPrintF((uint64_t)_LogPrintFCallBack, (uint64_t)&v40);
      int v13 = v12 & ~(v12 >> 31);
      int v14 = v13;
      if ((v9 & 4) != 0)
      {
        getprogname();
        int v15 = CPrintF((uint64_t)_LogPrintFCallBack, (uint64_t)&v40);
        int v14 = (v15 & ~(v15 >> 31)) + v13;
      }

      if ((v9 & 2) != 0)
      {
        getpid();
        int v16 = CPrintF((uint64_t)_LogPrintFCallBack, (uint64_t)&v40);
        v14 += v16 & ~(v16 >> 31);
      }

      if ((v9 & 8) != 0 || (v9 & 0x20) != 0)
      {
        int v25 = CPrintF((uint64_t)_LogPrintFCallBack, (uint64_t)&v40);
        v14 += v25 & ~(v25 >> 31);
        if (!((a3 >> 14) & 0x40 | v9 & 0x40))
        {
LABEL_24:
          if (!((a3 >> 17) & 0x80 | v9 & 0x80)) {
            goto LABEL_25;
          }
          goto LABEL_41;
        }
      }

      else if (!((a3 >> 14) & 0x40 | v9 & 0x40))
      {
        goto LABEL_24;
      }

      int v26 = CPrintF((uint64_t)_LogPrintFCallBack, (uint64_t)&v40);
      v14 += v26 & ~(v26 >> 31);
      if (!((a3 >> 17) & 0x80 | v9 & 0x80))
      {
LABEL_25:
        if ((v9 & 0x10) == 0)
        {
LABEL_27:
          int v18 = CPrintF((uint64_t)_LogPrintFCallBack, (uint64_t)&v40);
          int v8 = (v18 & ~(v18 >> 31)) + v14;
          goto LABEL_29;
        }

uint64_t _LogPrintFWrite(uint64_t result, const void *a2, size_t a3, int a4)
{
  uint64_t v6 = result;
  uint64_t v7 = *(void *)result;
  if (!a4)
  {
    uint64_t v12 = *(void *)(v7 + 56);
    if (v12)
    {
      int v13 = *(_DWORD *)(v12 + 24);
      BOOL v14 = v13 != -1 && *(_DWORD *)(result + 8) < v13;
      if (!v14 && ((*(_DWORD *)(result + 8) & 0x800000) == 0 || *(_DWORD *)(v12 + 40) == 14))
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(v12 + 32))(result);
        uint64_t v7 = *(void *)v6;
      }
    }
  }

  uint64_t v8 = *(void *)(v7 + 64);
  if (v8)
  {
    int v9 = *(_DWORD *)(v8 + 24);
    BOOL v10 = v9 != -1 && *(_DWORD *)(v6 + 8) < v9;
    if (!v10 && ((*(_DWORD *)(v6 + 8) & 0x800000) == 0 || *(_DWORD *)(v8 + 40) == 14)) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(v8 + 32))(v6);
    }
  }

  if ((*(_DWORD *)(v6 + 8) & 0x840000) == 0x40000)
  {
    uint64_t result = open("/dev/console", 1, 0LL);
    if ((result & 0x80000000) == 0)
    {
      int v11 = result;
      write(result, a2, a3);
      close(v11);
      return usleep(0xC8u);
    }
  }

  return result;
}

size_t _LogPrintFCallBack(void *__src, size_t __n, uint64_t a3)
{
  if (!__n && *(_BYTE *)(a3 + 2072))
  {
    size_t v6 = *(void *)(a3 + 2064);
    if (!v6) {
      goto LABEL_5;
    }
LABEL_4:
    _LogPrintFWrite(a3, (const void *)(a3 + 12), v6, 0);
    size_t v6 = 0LL;
    *(void *)(a3 + 2064) = 0LL;
    goto LABEL_5;
  }

  size_t v6 = *(void *)(a3 + 2064);
  if (v6 + __n >= 0x801 && v6) {
    goto LABEL_4;
  }
LABEL_5:
  if (__n < 0x801)
  {
    if (__n)
    {
      memcpy((void *)(a3 + v6 + 12), __src, __n);
      *(void *)(a3 + 2064) += __n;
    }
  }

  else
  {
    _LogPrintFWrite(a3, __src, __n, 0);
  }

  return __n;
}

_DWORD *LogCategoryCreate(const char *a1, int a2, int a3, const char *a4, int *a5)
{
  return LogCategoryCreateEx(0LL, a1, a2, a3, a4, a5);
}

_DWORD *LogCategoryCreateEx(const char *a1, const char *a2, int a3, int a4, const char *a5, int *a6)
{
  uint64_t v12 = calloc(1uLL, 0x88uLL);
  if (!v12)
  {
LABEL_14:
    int v20 = -6728;
    goto LABEL_17;
  }

  if (a1 && (int v13 = strdup(a1), (*((void *)v12 + 14) = v13) == 0LL)
    || (BOOL v14 = strdup(a2), (*((void *)v12 + 15) = v14) == 0LL))
  {
LABEL_7:
    int v17 = (void *)*((void *)v12 + 14);
    if (v17) {
      free(v17);
    }
    int v18 = (void *)*((void *)v12 + 15);
    if (v18) {
      free(v18);
    }
    int v19 = (void *)*((void *)v12 + 16);
    if (v19) {
      free(v19);
    }
    free(v12);
    uint64_t v12 = 0LL;
    goto LABEL_14;
  }

  int v15 = v14;
  if (a5)
  {
    int v16 = strdup(a5);
    *((void *)v12 + 16) = v16;
    if (!v16) {
      goto LABEL_7;
    }
  }

  else
  {
    int v16 = (char *)*((void *)v12 + 16);
  }

  *uint64_t v12 = -1;
  v12[1] = a3;
  *((void *)v12 + 1) = v16;
  v12[4] = a4 | 0x70000;
  *((void *)v12 + 3) = v15;
  *((void *)v12 + 4) = v15;
  int v21 = strlen(v15);
  int v20 = 0;
  v12[10] = v21;
  *((void *)v12 + 12) = *((void *)v12 + 14);
LABEL_17:
  if (a6) {
    *a6 = v20;
  }
  return v12;
}

uint64_t LogCategoryReplaceF(uint64_t *a1)
{
  return LogCategoryReplaceV(a1);
}

uint64_t LogCategoryReplaceV(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = 0LL;
  if (!v1) {
    return -6705;
  }
  VASPrintF((void **)&v7);
  uint64_t v3 = (char *)v7;
  if (!v7) {
    return -6700;
  }
  int v4 = LogCategoryCreateEx( *(const char **)(v1 + 96),  v7,  *(_DWORD *)(v1 + 4),  *(_DWORD *)(v1 + 16),  *(const char **)(v1 + 8),  (int *)&v8);
  free(v3);
  if (v4)
  {
    if ((*(_BYTE *)(v1 + 18) & 4) != 0) {
      LogCategory_Remove((void *)v1);
    }
    *a1 = (uint64_t)v4;
  }

  return v8;
}

uint64_t LogCategory_Remove(void *a1)
{
  uint64_t v2 = gLogCategoryList;
  if (gLogCategoryList)
  {
    if ((void *)gLogCategoryList == a1)
    {
      int v4 = &gLogCategoryList;
LABEL_7:
      uint64_t v5 = *((void *)a1 + 7);
      if (v5) {
        --*(_DWORD *)(v5 + 8);
      }
      uint64_t v6 = *((void *)a1 + 8);
      if (v6) {
        --*(_DWORD *)(v6 + 8);
      }
      *int v4 = *((void *)a1 + 6);
      *(_DWORD *)a1 = -1;
      *((void *)a1 + 7) = 0LL;
      *((void *)a1 + 8) = 0LL;
      _LogOutputDeleteUnused();
    }

    else
    {
      while (1)
      {
        uint64_t v3 = v2;
        uint64_t v2 = *(void *)(v2 + 48);
        if (!v2) {
          break;
        }
        if ((void *)v2 == a1)
        {
          int v4 = (uint64_t *)(v3 + 48);
          goto LABEL_7;
        }
      }
    }
  }

  int v7 = *((_DWORD *)a1 + 4);
  if ((v7 & 0x20000) != 0)
  {
    unsigned int v8 = (id *)*((void *)a1 + 13);
    if (v8)
    {
      if (*v8)
      {

        unsigned int v8 = (id *)*((void *)a1 + 13);
        id *v8 = 0LL;
      }

      if (v8[1])
      {
        free(v8[1]);
        unsigned int v8 = (id *)*((void *)a1 + 13);
        v8[1] = 0LL;
      }

      free(v8);
      *((void *)a1 + 13) = 0LL;
      int v7 = *((_DWORD *)a1 + 4);
    }
  }

  if ((v7 & 0x10000) != 0)
  {
    int v9 = (void *)*((void *)a1 + 14);
    if (v9) {
      free(v9);
    }
    BOOL v10 = (void *)*((void *)a1 + 15);
    if (v10) {
      free(v10);
    }
    int v11 = (void *)*((void *)a1 + 16);
    if (v11) {
      free(v11);
    }
    free(a1);
  }

  return pthread_mutex_unlock(&gLogUtilsLock);
}

os_log_t LogCategoryCopyOSLogHandle(uint64_t a1)
{
  os_log_t OSLogHandle = _LogCategoryGetOSLogHandle(a1, 0LL);
  os_log_t v3 = OSLogHandle;
  if (OSLogHandle) {
    int v4 = OSLogHandle;
  }
  pthread_mutex_unlock(&gLogUtilsLock);
  return v3;
}

uint64_t LogPrintF_safe( uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return LogPrintV(a1, a2, a3, a4, &a9);
}

BOOL CUFloatsNearlyEqualWithinTolerance(float a1, float a2, float a3)
{
  return vabds_f32(a1, a2) < (float)((float)(fmaxf(fmaxf(fabsf(a1), fabsf(a2)), 1.1755e-38) * a3) + 0.00000011921);
}

BOOL CUDoublesNearlyEqualWithinTolerance(double a1, double a2, double a3)
{
  return vabdd_f64(a1, a2) < fmax(fmax(fabs(a1), fabs(a2)), 2.22507386e-308) * a3 + 2.22044605e-16;
}

BOOL CUFloatsNearlyEqualWithinULPs(int a1, float a2, float a3)
{
  unsigned int v3 = LODWORD(a2);
  if (a2 < 0.0) {
    unsigned int v3 = 0x80000000 - LODWORD(a2);
  }
  unsigned int v4 = 0x80000000 - LODWORD(a3);
  if (a3 >= 0.0) {
    unsigned int v4 = LODWORD(a3);
  }
  int v5 = v3 - v4;
  if (v5 < 0) {
    int v5 = -v5;
  }
  return v5 <= a1;
}

uint64_t iceil2(int a1)
{
  unsigned int v1 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  unsigned int v2 = v1 | (v1 >> 4) | ((v1 | (v1 >> 4)) >> 8);
  return (v2 | HIWORD(v2)) + 1;
}

unint64_t ifloor2_64(unint64_t a1)
{
  unint64_t v1 = a1 | (a1 >> 1) | ((a1 | (a1 >> 1)) >> 2);
  unint64_t v2 = v1 | (v1 >> 4) | ((v1 | (v1 >> 4)) >> 8);
  unint64_t v3 = v2 | (v2 >> 16) | ((v2 | (v2 >> 16)) >> 32);
  return v3 - (v3 >> 1);
}

uint64_t ilog2_64(unint64_t a1)
{
  if (HIDWORD(a1))
  {
    LOBYTE(v1) = 0;
    do
    {
      LOBYTE(v1) = v1 + 1;
      BOOL v2 = a1 > 3;
      a1 >>= 1;
    }

    while (v2);
  }

  else
  {
    return (__clz(a1 | 1) ^ 0x1F);
  }

  return v1;
}

uint64_t CUFibonacci32(uint64_t result)
{
  if ((_DWORD)result)
  {
    if (result <= 0x2E)
    {
      if (result >= 2)
      {
        int v1 = 0;
        int v2 = result - 1;
        LODWORD(result) = 1;
        do
        {
          int v3 = result;
          uint64_t result = (result + v1);
          int v1 = v3;
          --v2;
        }

        while (v2);
      }

      else
      {
        return 1LL;
      }
    }

    else
    {
      return 2971215073LL;
    }
  }

  return result;
}

double TranslateValue(double a1, double a2, double a3, double a4, double a5)
{
  return a4 + (a1 - a2) / (a3 - a2) * (a5 - a4);
}

uint64_t ValueSmootherInit(uint64_t a1, int a2, unsigned int a3)
{
  *(void *)a1 = calloc(a3 * a2, 8uLL);
  uint64_t v6 = calloc(a3, 8uLL);
  *(void *)(a1 + 8) = v6;
  if (*(void *)a1) {
    BOOL v7 = v6 == 0LL;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    ValueSmootherFree(a1);
    return 4294960568LL;
  }

  else
  {
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 20) = a3;
    *(_DWORD *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 28) = 0;
  }

  return result;
}

void ValueSmootherFree(uint64_t a1)
{
  int v2 = *(void **)a1;
  if (v2)
  {
    free(v2);
    *(void *)a1 = 0LL;
  }

  int v3 = *(void **)(a1 + 8);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 8) = 0LL;
  }

double ValueSmootherGet(uint64_t a1)
{
  return *(double *)(*(void *)(a1 + 8) + 8LL * (*(_DWORD *)(a1 + 20) - 1));
}

double ValueSmootherUpdate(uint64_t a1, double a2)
{
  if (*(_BYTE *)(a1 + 28))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 20);
    int v2 = *(_DWORD *)(a1 + 24);
    unsigned int v4 = *(_DWORD *)(a1 + 16);
    if (v2 + 1 < v4) {
      int v5 = v2 + 1;
    }
    else {
      int v5 = 0;
    }
    *(_DWORD *)(a1 + 24) = v5;
    if ((_DWORD)v3)
    {
      uint64_t v6 = 0LL;
      BOOL v7 = *(double **)a1;
      uint64_t v8 = *(void *)(a1 + 8);
      do
      {
        *(double *)(v8 + 8 * v6) = a2 / (double)v4 + *(double *)(v8 + 8 * v6) - v7[v2] / (double)v4;
        v7[v2] = a2;
        v2 += v4;
        a2 = *(double *)(v8 + 8 * v6++);
      }

      while (v3 != v6);
      LODWORD(v9) = v3;
    }

    else
    {
      LODWORD(v9) = 0;
    }
  }

  else
  {
    uint64_t v9 = *(unsigned int *)(a1 + 20);
    uint64_t v10 = (v9 * *(_DWORD *)(a1 + 16));
    if ((_DWORD)v10)
    {
      int v11 = *(double **)a1;
      do
      {
        *v11++ = a2;
        --v10;
      }

      while (v10);
    }

    if ((_DWORD)v9)
    {
      uint64_t v12 = *(double **)(a1 + 8);
      uint64_t v13 = v9;
      do
      {
        *v12++ = a2;
        --v13;
      }

      while (v13);
    }

    *(_BYTE *)(a1 + 28) = 1;
  }

  return *(double *)(*(void *)(a1 + 8) + 8LL * (v9 - 1));
}

uint64_t MFiPlatform_VerifySignature( const UInt8 *a1, CFIndex a2, const UInt8 *a3, CFIndex a4, const UInt8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return MFiPlatform_VerifySignatureEx(a1, a2, a3, a4, a5, a6, 0LL, a8);
}

uint64_t MFiPlatform_VerifySignatureEx( const UInt8 *a1, CFIndex a2, const UInt8 *a3, CFIndex a4, const UInt8 *a5, uint64_t a6, CFDictionaryRef theDict, uint64_t a8)
{
  error[4] = *(CFErrorRef *)MEMORY[0x1895F89C0];
  SecTrustRef v142 = 0LL;
  if (gLogCategory_MFiClientCore <= 30)
  {
    if (gLogCategory_MFiClientCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x1Eu)) {
      LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const void *, size_t , CFDictionaryRef)",  0x1Eu,  (uint64_t)"MFi verify signature: %zu data bytes, %zu sig bytes, %zu cert bytes, extraInfo %s\n",  (uint64_t)a5,  a6,  (uint64_t)theDict,  a8,  a2);
    }
    if (gLogCategory_MFiClientCore <= 9)
    {
      if (gLogCategory_MFiClientCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 9u)) {
        LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const void *, size _t, CFDictionaryRef)",  9u,  (uint64_t)"MFi challenge:\n%1.2H\n",  (uint64_t)a5,  a6,  (uint64_t)theDict,  a8,  (char)a1);
      }
      if (gLogCategory_MFiClientCore <= 9)
      {
        if (gLogCategory_MFiClientCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 9u)) {
          LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const void *, si ze_t, CFDictionaryRef)",  9u,  (uint64_t)"MFi certificate:\n%1.2H\n",  (uint64_t)a5,  a6,  (uint64_t)theDict,  a8,  (char)a5);
        }
        if (gLogCategory_MFiClientCore <= 9)
        {
          if (gLogCategory_MFiClientCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 9u)) {
            LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const void *, size_t, CFDictionaryRef)",  9u,  (uint64_t)"MFi signature:\n%1.2H\n",  (uint64_t)a5,  a6,  (uint64_t)theDict,  a8,  (char)a3);
          }
          if (gLogCategory_MFiClientCore <= 9
            && (gLogCategory_MFiClientCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 9u)))
          {
            LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const void *, size_t, CFDictionaryRef)",  9u,  (uint64_t)"MFi extra info: %##@",  (uint64_t)a5,  a6,  (uint64_t)theDict,  a8,  (char)theDict);
          }
        }
      }
    }
  }

  if (theDict && CFDictionaryGetValue(theDict, @"baIC"))
  {
    SecTrustRef trust = 0LL;
    error[0] = 0LL;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
    if (!Mutable)
    {
      CFDataRef v16 = 0LL;
      CFDataRef v22 = 0LL;
      unsigned int v144 = -6728;
LABEL_43:
      if (error[0]) {
        CFRelease(error[0]);
      }
      if (v22) {
        CFRelease(v22);
      }
      if (v16) {
        CFRelease(v16);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      return v144;
    }

    CFDataRef v16 = CFDataCreate(0LL, a5, a6);
    if (!v16) {
      goto LABEL_170;
    }
    SecCertificateRef v17 = SecCertificateCreateWithData(0LL, v16);
    CFRelease(v16);
    if (!v17)
    {
      unsigned int v144 = -6742;
      if (gLogCategory_MFiClientCore <= 90
        && (gLogCategory_MFiClientCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x5Au)))
      {
        LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus _MFiPlatform_VerifySignatureBAA(const void *, size_t, const void *, size_t, const void *, si ze_t, CFDictionaryRef)",  0x5Au,  (uint64_t)"### Decode BAA intermediate cert failed",  v18,  v19,  v20,  v21,  v138);
      }

      CFDataRef v22 = 0LL;
      CFDataRef v16 = 0LL;
      goto LABEL_41;
    }

    CFArrayAppendValue(Mutable, v17);
    CFRelease(v17);
    CFDataRef v16 = CFDataCreate(0LL, a1, a2);
    if (!v16)
    {
LABEL_170:
      CFDataRef v22 = 0LL;
      goto LABEL_171;
    }

    CFDataRef v22 = CFDataCreate(0LL, a3, a4);
    if (v22)
    {
      uint64_t v23 = SecCertificateCopyKey(v17);
      if (v23)
      {
        int v28 = v23;
        int v29 = SecKeyVerifySignature(v23, (SecKeyAlgorithm)*MEMORY[0x18960BC80], v16, v22, error);
        CFRelease(v28);
        char v34 = (char)error[0];
        if (!v29 || error[0])
        {
          unsigned int v144 = -6716;
          if (gLogCategory_MFiClientCore > 90) {
            goto LABEL_41;
          }
          if (gLogCategory_MFiClientCore == -1)
          {
            char v34 = (char)error[0];
          }

          LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus _MFiPlatform_VerifySignatureBAA(const void *, size_t, const void *, size_t, const void *, size_t, CFDictionaryRef)",  0x5Au,  (uint64_t)"### Verify BAA signature failed: %@",  v30,  v31,  v32,  v33,  v34);
          goto LABEL_41;
        }

        CFTypeID TypeID = CFDataGetTypeID();
        TypedValue = CFDictionaryGetTypedValue(theDict, @"baIC", TypeID, (int *)&v144);
        if (TypedValue)
        {
          SecCertificateRef v37 = SecCertificateCreateWithData(0LL, TypedValue);
          if (v37)
          {
            SecCertificateRef v38 = v37;
            CFArrayAppendValue(Mutable, v37);
            CFRelease(v38);
            AppleBasicAttestationUser = (const void *)SecPolicyCreateAppleBasicAttestationUser();
            if (AppleBasicAttestationUser)
            {
              uint64_t v40 = AppleBasicAttestationUser;
              unsigned int v144 = SecTrustCreateWithCertificates(Mutable, AppleBasicAttestationUser, &trust);
              CFRelease(v40);
              char v45 = v144;
              if (v144)
              {
                if (gLogCategory_MFiClientCore > 90) {
                  goto LABEL_41;
                }
                if (gLogCategory_MFiClientCore == -1)
                {
                  char v45 = v144;
                }

                LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus _MFiPlatform_VerifySignatureBAA(const void *, size_t, const void *, size_t, const vo id *, size_t, CFDictionaryRef)",  0x5Au,  (uint64_t)"### Create BAA trust failed: %#m",  v41,  v42,  v43,  v44,  v45);
                goto LABEL_41;
              }

              uint64_t v46 = CFDataCreateWithBytesNoCopy(0LL, BAARootCert, 542LL, (CFAllocatorRef)*MEMORY[0x189604DC8]);
              if (!v46) {
                goto LABEL_171;
              }
              uint64_t v47 = v46;
              values = SecCertificateCreateWithData(0LL, v46);
              CFRelease(v47);
              if (values)
              {
                uint64_t v48 = CFArrayCreate(0LL, (const void **)&values, 1LL, MEMORY[0x189605228]);
                CFRelease(values);
                if (v48)
                {
                  unsigned int v144 = SecTrustSetAnchorCertificates(trust, v48);
                  CFRelease(v48);
                  char v53 = v144;
                  if (v144)
                  {
                    if (gLogCategory_MFiClientCore > 90) {
                      goto LABEL_41;
                    }
                    if (gLogCategory_MFiClientCore == -1)
                    {
                      char v53 = v144;
                    }

                    LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus _MFiPlatform_VerifySignatureBAA(const void *, size_t, const void *, size_t, cons t void *, size_t, CFDictionaryRef)",  0x5Au,  (uint64_t)"### Set BAA anchors failed: %#m",  v49,  v50,  v51,  v52,  v53);
                    goto LABEL_41;
                  }

                  BOOL v54 = SecTrustEvaluateWithError(trust, error);
                  char v55 = (char)error[0];
                  if (!v54 || error[0])
                  {
                    unsigned int v144 = -71164;
                    if (gLogCategory_MFiClientCore <= 90)
                    {
                      if (gLogCategory_MFiClientCore != -1)
                      {
LABEL_212:
                        char v138 = v55;
                        v137 = "### Verify BAA trust failed: %@";
                        goto LABEL_213;
                      }

                      if (_LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x5Au))
                      {
                        char v55 = (char)error[0];
                        goto LABEL_212;
                      }
                    }
                  }

LABEL_213:
      LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus _MFiPlatform_VerifySignatureBAA(const void *, size_t, const void *, size_t, const void *, size _t, CFDictionaryRef)",  0x5Au,  (uint64_t)v137,  v24,  v25,  v26,  v27,  v138);
      goto LABEL_41;
    }

LABEL_171:
    unsigned int v144 = -6728;
    goto LABEL_41;
  }

  v57 = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  if (!v57)
  {
    v80 = 0LL;
    uint64_t v60 = 0LL;
    v79 = 0LL;
    v58 = 0LL;
LABEL_174:
    uint64_t v56 = 4294960568LL;
    goto LABEL_130;
  }

  v58 = CFDataCreate(0LL, a5, a6);
  if (!v58)
  {
    v80 = 0LL;
    uint64_t v60 = 0LL;
    v79 = 0LL;
    goto LABEL_174;
  }

  v59 = (const __CFArray *)SecCMSCertificatesOnlyMessageCopyCertificates();
  uint64_t v60 = v59;
  if (v59)
  {
    if (CFArrayGetCount(v59) < 1)
    {
      v80 = 0LL;
      v79 = 0LL;
      uint64_t v56 = 4294960532LL;
      goto LABEL_130;
    }

    ValueAtIndex = (void *)CFArrayGetValueAtIndex(v60, 0LL);
    CFTypeID v62 = CFGetTypeID(ValueAtIndex);
    if (v62 != SecCertificateGetTypeID())
    {
      v80 = 0LL;
      v79 = 0LL;
      uint64_t v56 = 4294960540LL;
      goto LABEL_130;
    }

    CFArrayAppendValue(v57, ValueAtIndex);
    v63 = (const void *)SecPolicyCreateiAP();
    v139 = 0LL;
    if (v63) {
      goto LABEL_58;
    }
    goto LABEL_68;
  }

  SecCertificateRef v78 = SecCertificateCreateWithData(0LL, v58);
  if (v78)
  {
    ValueAtIndex = v78;
    CFArrayAppendValue(v57, v78);
    v63 = (const void *)SecPolicyCreateiAPSWAuth();
    v139 = ValueAtIndex;
    if (v63)
    {
LABEL_58:
      uint64_t v56 = SecTrustCreateWithCertificates(v57, v63, &v142);
      CFRelease(v63);
      if (!(_DWORD)v56)
      {
        if (a4 == 128) {
          uint64_t v68 = 1LL;
        }
        else {
          uint64_t v68 = 6LL;
        }
        theArray = (const __CFArray *)((uint64_t (*)(uint64_t))softLinkmfaa_certificateManager_copyAnchorCertificates[0])(v68);
        if (theArray)
        {
          if (gLogCategory_MFiClientCore <= 30
            && (gLogCategory_MFiClientCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x1Eu)))
          {
            char Count = CFArrayGetCount(theArray);
            LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const void *, size_t, CFDictionaryRef)",  0x1Eu,  (uint64_t)"MFi verify signature: %d anchor certs\n",  v74,  v75,  v76,  v77,  Count);
          }

          uint64_t v81 = SecTrustSetAnchorCertificates(v142, theArray);
          if ((_DWORD)v81)
          {
            uint64_t v56 = v81;
            if (gLogCategory_MFiClientCore <= 90
              && (gLogCategory_MFiClientCore != -1
               || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x5Au)))
            {
              LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const void * , size_t, CFDictionaryRef)",  0x5Au,  (uint64_t)"### MFi set anchor certs failed: %#m\n",  v82,  v83,  v84,  v85,  v56);
            }

            goto LABEL_129;
          }

          uint64_t v86 = SecTrustSetAnchorCertificatesOnly(v142, 1u);
          if ((_DWORD)v86)
          {
            uint64_t v56 = v86;
            if (gLogCategory_MFiClientCore <= 90
              && (gLogCategory_MFiClientCore != -1
               || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x5Au)))
            {
              LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const void * , size_t, CFDictionaryRef)",  0x5Au,  (uint64_t)"### MFi set anchor certs only failed: %#m\n",  v87,  v88,  v89,  v90,  v56);
            }

            goto LABEL_129;
          }
        }

        else if (gLogCategory_MFiClientCore <= 90 {
               && (gLogCategory_MFiClientCore != -1
        }
                || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x5Au)))
        {
          LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const void *, si ze_t, CFDictionaryRef)",  0x5Au,  (uint64_t)"### MFi no certificates from MFA\n",  v69,  v70,  v71,  v72,  v138);
        }

        CFErrorRef err = 0LL;
        BOOL v95 = SecTrustEvaluateWithError(v142, &err);
        if (v95) {
          uint64_t v56 = 0LL;
        }
        else {
          uint64_t v56 = 4294960563LL;
        }
        CFErrorRef v96 = err;
        if (!v95 && err)
        {
          unsigned int Code = CFErrorGetCode(err);
          if (Code) {
            uint64_t v56 = Code;
          }
          else {
            uint64_t v56 = 4294960563LL;
          }
          CFErrorRef v96 = err;
        }

        if (v96) {
          CFRelease(v96);
        }
        if ((_DWORD)v56)
        {
          v80 = v139;
          v79 = theArray;
          if (gLogCategory_MFiClientCore <= 90
            && (gLogCategory_MFiClientCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x5Au)))
          {
            LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const void *, size_t, CFDictionaryRef)",  0x5Au,  (uint64_t)"### MFi SecTrustEvaluate failed: %#m\n",  v91,  v92,  v93,  v94,  v56);
          }

          goto LABEL_130;
        }

        uint64_t v98 = MEMORY[0x186E42624](v142);
        if (!v98)
        {
          uint64_t v56 = 4294960596LL;
          goto LABEL_129;
        }

        v99 = (void *)v98;
        SecTrustRef trust = 0LL;
        if (a4 == 128)
        {
          CC_SHA1(a1, a2, (unsigned __int8 *)error);
          CFDataRef v100 = CFDataCreate(0LL, (const UInt8 *)error, 20LL);
          if (v100)
          {
            SecTrustRef v101 = v100;
            v102 = (const __CFString **)MEMORY[0x18960BCD8];
            goto LABEL_94;
          }
        }

        else
        {
          CC_SHA256(a1, a2, (unsigned __int8 *)error);
          CFDataRef v103 = CFDataCreate(0LL, (const UInt8 *)error, 32LL);
          if (v103)
          {
            SecTrustRef v101 = v103;
            v102 = (const __CFString **)MEMORY[0x18960BC20];
LABEL_94:
            v104 = *v102;
            v105 = CFDataCreate(0LL, a3, a4);
            if (!v105)
            {
              uint64_t v56 = 4294960568LL;
LABEL_109:
              CFRelease(v101);
LABEL_110:
              CFRelease(v99);
              if (!(_DWORD)v56)
              {
                if (MFAAuthenticationLibrary_sOnce != -1) {
                  dispatch_once(&MFAAuthenticationLibrary_sOnce, &__block_literal_global_11288);
                }
                if (MFAAuthenticationLibrary_sLib
                  && dlsym((void *)MFAAuthenticationLibrary_sLib, "mfaa_certificateManager_validateCertificate"))
                {
                  int v115 = ((uint64_t (*)(uint64_t, uint64_t))softLinkmfaa_certificateManager_validateCertificate[0])( (uint64_t)v58,  0LL);
                  if (v115 != 1)
                  {
                    uint64_t v56 = 4294896132LL;
                    v80 = v139;
                    v79 = theArray;
                    if (gLogCategory_MFiClientCore <= 60)
                    {
                      char v120 = v115;
                      if (gLogCategory_MFiClientCore != -1
                        || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x3Cu))
                      {
                        LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, co nst void *, size_t, CFDictionaryRef)",  0x3Cu,  (uint64_t)"### MFi cert rejected (%d)\n",  v116,  v117,  v118,  v119,  v120);
                      }
                    }

                    goto LABEL_130;
                  }

                  goto LABEL_128;
                }

                if (gLogCategory_MFiClientCore <= 60
                  && (gLogCategory_MFiClientCore != -1
                   || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x3Cu)))
                {
                  LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus MFiPlatform_VerifySignatureEx(const void *, size_t, const void *, size_t, const vo id *, size_t, CFDictionaryRef)",  0x3Cu,  (uint64_t)"### MFi cert manager not available\n",  v111,  v112,  v113,  v114,  v138);
                }

                if (a4 != 128
                  || (v121 = SecCertificateCopySerialNumberData((SecCertificateRef)ValueAtIndex, 0LL)) == 0LL)
                {
LABEL_128:
                  uint64_t v56 = 0LL;
                  goto LABEL_129;
                }

                v122 = v121;
                BytePtr = CFDataGetBytePtr(v121);
                CFIndex Length = CFDataGetLength(v122);
                if (gLogCategory_MFiClientCore <= 40
                  && (gLogCategory_MFiClientCore != -1
                   || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x28u)))
                {
                  LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus _VerifySerialNumber(const uint8_t *, size_t)",  0x28u,  (uint64_t)"MFi certificate serial number: %.3H\n",  v124,  v125,  v126,  v127,  (char)BytePtr);
                }

                if (Length == 15
                  && (*(void *)BytePtr == 0x7AA191212AA3333LL
                    ? (BOOL v130 = *(void *)(BytePtr + 7) == 0x10000AA0600AA07LL)
                    : (BOOL v130 = 0),
                      v130))
                {
                  if (gLogCategory_MFiClientCore > 40)
                  {
                    uint64_t v56 = 0LL;
LABEL_156:
                    v80 = v139;
                    v79 = theArray;
LABEL_169:
                    CFRelease(v122);
                    goto LABEL_130;
                  }

                  v80 = v139;
                  v79 = theArray;
                  if (gLogCategory_MFiClientCore != -1
                    || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x28u))
                  {
                    v135 = "Allowing MFi test certificate serial number\n";
                    unsigned int v136 = 40;
                    goto LABEL_163;
                  }
                }

                else
                {
                  if (IAPAuthenticationLibrary_sOnce != -1) {
                    dispatch_once(&IAPAuthenticationLibrary_sOnce, &__block_literal_global_41_11295);
                  }
                  if (IAPAuthenticationLibrary_sLib
                    && dlsym((void *)IAPAuthenticationLibrary_sLib, "MFiVerifyCertificateSerialNumber"))
                  {
                    uint64_t v56 = softLinkMFiVerifyCertificateSerialNumber((uint64_t)BytePtr, Length);
                    if ((_DWORD)v56
                      && gLogCategory_MFiClientCore <= 60
                      && (gLogCategory_MFiClientCore != -1
                       || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x3Cu)))
                    {
                      LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus _VerifySerialNumber(const uint8_t *, size_t)",  0x3Cu,  (uint64_t)"### Bad MFi certificate SN <%.3H>: %#m\n",  v131,  v132,  v133,  v134,  (char)BytePtr);
                    }

                    goto LABEL_156;
                  }

                  v80 = v139;
                  v79 = theArray;
                  if (gLogCategory_MFiClientCore <= 90
                    && (gLogCategory_MFiClientCore != -1
                     || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x5Au)))
                  {
                    v135 = "Skipping MFi certificate serial number check (no func)\n";
                    unsigned int v136 = 90;
LABEL_163:
                    LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus _VerifySerialNumber(const uint8_t *, size_t)",  v136,  (uint64_t)v135,  v124,  v125,  v126,  v127,  v138);
                  }
                }

                uint64_t v56 = 0LL;
                goto LABEL_169;
              }

LABEL_129:
              v80 = v139;
              v79 = theArray;
              goto LABEL_130;
            }

            v106 = v105;
            if (SecKeyVerifySignature((SecKeyRef)v99, v104, v101, v105, &trust))
            {
              uint64_t v56 = 0LL;
              goto LABEL_108;
            }

            if (trust)
            {
              uint64_t v56 = CFErrorGetCode(trust);
              if (!(_DWORD)v56) {
                goto LABEL_108;
              }
            }

            else
            {
              uint64_t v56 = 4294960596LL;
            }

            if (gLogCategory_MFiClientCore <= 90
              && (gLogCategory_MFiClientCore != -1
               || _LogCategory_Initialize((uint64_t)&gLogCategory_MFiClientCore, 0x5Au)))
            {
              LogPrintF( (uint64_t)&gLogCategory_MFiClientCore,  (uint64_t)"OSStatus _SecKeyVerifySignature(SecKeyRef, const uint8_t *, size_t, const uint8_t *, size_t)",  0x5Au,  (uint64_t)"### MFi SecKeyVerifySignature failed: %#m, %@\n",  v107,  v108,  v109,  v110,  v56);
            }

        if (v122 - v13 < 2 || v24 < 1 || *v13 != 48)
        {
          SecCertificateRef v37 = 10LL;
LABEL_155:
          int v5 = v13;
          goto LABEL_156;
        }

        if ((v13[1] & 0xF8) == 0x30) {
          SecCertificateRef v37 = 8LL;
        }
        else {
          SecCertificateRef v37 = 10LL;
        }
        if ((v13[1] & 0xF8) == 0x30)
        {
          --v24;
          int v5 = v13 + 1;
        }

        else
        {
          int v5 = v13;
        }

uint64_t initMFiVerifyCertificateSerialNumber(uint64_t a1, uint64_t a2)
{
  if (IAPAuthenticationLibrary_sOnce != -1) {
    dispatch_once(&IAPAuthenticationLibrary_sOnce, &__block_literal_global_41_11295);
  }
  softLinkMFiVerifyCertificateSerialNumber = (uint64_t (*)())dlsym( (void *)IAPAuthenticationLibrary_sLib,  "MFiVerifyCertificateSerialNumber");
  return ((uint64_t (*)(uint64_t, uint64_t))softLinkMFiVerifyCertificateSerialNumber)(a1, a2);
}

void *__IAPAuthenticationLibrary_block_invoke()
{
  uint64_t result = dlopen("/System/Library/PrivateFrameworks/IAPAuthentication.framework/IAPAuthentication", 2);
  IAPAuthenticationLibrary_sLib = (uint64_t)result;
  return result;
}

uint64_t initmfaa_certificateManager_validateCertificate(uint64_t a1, uint64_t a2)
{
  if (MFAAuthenticationLibrary_sOnce != -1) {
    dispatch_once(&MFAAuthenticationLibrary_sOnce, &__block_literal_global_11288);
  }
  softLinkmfaa_certificateManager_validateCertificate[0] = (uint64_t (*)())dlsym( (void *)MFAAuthenticationLibrary_sLib,  "mfaa_certificateManager_validateCertificate");
  return ((uint64_t (*)(uint64_t, uint64_t))softLinkmfaa_certificateManager_validateCertificate[0])(a1, a2);
}

void *__MFAAuthenticationLibrary_block_invoke()
{
  uint64_t result = dlopen("/System/Library/PrivateFrameworks/MFAAuthentication.framework/MFAAuthentication", 2);
  MFAAuthenticationLibrary_sLib = (uint64_t)result;
  return result;
}

uint64_t initmfaa_certificateManager_copyAnchorCertificates(uint64_t a1)
{
  if (MFAAuthenticationLibrary_sOnce != -1) {
    dispatch_once(&MFAAuthenticationLibrary_sOnce, &__block_literal_global_11288);
  }
  softLinkmfaa_certificateManager_copyAnchorCertificates[0] = (uint64_t (*)())dlsym( (void *)MFAAuthenticationLibrary_sLib,  "mfaa_certificateManager_copyAn chorCertificates");
  return ((uint64_t (*)(uint64_t))softLinkmfaa_certificateManager_copyAnchorCertificates[0])(a1);
}

uint64_t MFiSAP_Create(void *a1, int a2)
{
  if (a2 != 1) {
    return 4294960581LL;
  }
  uint64_t v3 = calloc(1uLL, 0xB8uLL);
  if (!v3) {
    return 4294960568LL;
  }
  unsigned int v4 = v3;
  uint64_t result = 0LL;
  *unsigned int v4 = 257;
  *a1 = v4;
  return result;
}

void MFiSAP_Delete(_CCCryptor **__s)
{
  if (*((_BYTE *)__s + 168))
  {
    AES_CTR_Final(__s + 15);
    *((_BYTE *)__s + 168) = 0;
  }

  int v2 = __s[13];
  if (v2)
  {
    free(v2);
    __s[13] = 0LL;
  }

  __s[14] = 0LL;
  uint64_t v3 = __s[22];
  if (v3)
  {
    CFRelease(v3);
    __s[22] = 0LL;
  }

  memset_s(__s, 0xB8uLL, 0, 0xB8uLL);
  free(__s);
}

uint64_t MFiSAP_CopyCertificate(uint64_t a1, void *a2, size_t *a3)
{
  if (*(_BYTE *)a1 != 4) {
    return 4294960587LL;
  }
  uint64_t v3 = *(const void **)(a1 + 104);
  if (!v3) {
    return 4294960569LL;
  }
  size_t v4 = *(void *)(a1 + 112);
  if (!v4) {
    return 4294960553LL;
  }
  BOOL v7 = malloc(*(void *)(a1 + 112));
  if (!v7) {
    return 4294960568LL;
  }
  uint64_t v8 = v7;
  memcpy(v7, v3, v4);
  uint64_t result = 0LL;
  *a2 = v8;
  *a3 = v4;
  return result;
}

uint64_t MFiSAP_CopyCertificateSerialNumber(uint64_t a1, void *a2, void *a3)
{
  if (*(_BYTE *)a1 != 4) {
    return 4294960587LL;
  }
  size_t v4 = *(const UInt8 **)(a1 + 104);
  if (!v4) {
    return 4294960569LL;
  }
  CFIndex v6 = *(void *)(a1 + 112);
  if (!v6) {
    return 4294960553LL;
  }
  CFDataRef v7 = CFDataCreate(0LL, v4, v6);
  if (!v7) {
    return 4294960568LL;
  }
  CFDataRef v8 = v7;
  uint64_t v9 = (const __CFArray *)SecCMSCertificatesOnlyMessageCopyCertificates();
  CFRelease(v8);
  if (v9)
  {
    if (CFArrayGetCount(v9) <= 0)
    {
      int v16 = -6764;
    }

    else
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(v9, 0LL);
      CFTypeID v11 = CFGetTypeID(ValueAtIndex);
      if (v11 == SecCertificateGetTypeID())
      {
        uint64_t v12 = SecCertificateCopySerialNumberData((SecCertificateRef)ValueAtIndex, 0LL);
        if (v12)
        {
          uint64_t v13 = v12;
          BOOL v14 = CFCopyData(v12, &v17, &v18);
          CFRelease(v13);
          if (!v18)
          {
            if (v17 >= 8 && v17 != 16)
            {
              if (IsAppleInternalBuild_sOnce != -1) {
                dispatch_once(&IsAppleInternalBuild_sOnce, &__block_literal_global_85);
              }
              if (IsAppleInternalBuild_sIsInternal) {
                v14[7] &= ~0x80u;
              }
            }

            *a2 = v14;
            *a3 = v17;
            unsigned int v18 = 0;
          }

          goto LABEL_12;
        }

        int v16 = -6727;
      }

      else
      {
        int v16 = -6756;
      }
    }

    unsigned int v18 = v16;
LABEL_12:
    CFRelease(v9);
    return v18;
  }

  return 4294960554LL;
}

uint64_t MFiSAP_Exchange(unsigned __int8 *a1, uint64_t a2, uint64_t a3, void *a4, void *a5, char *a6)
{
  CFIndex v6 = a6;
  CFDataRef v7 = a5;
  uint64_t v50 = *MEMORY[0x1895F89C0];
  int v11 = *a1;
  if (v11 == 1)
  {
    if (a2) {
      int v11 = 5;
    }
    else {
      int v11 = 2;
    }
    *a1 = v11;
  }

  if (v11 == 3)
  {
    if (a3 >= 36)
    {
      unint64_t v15 = bswap32(*(_DWORD *)(a2 + 32));
      uint64_t result = 4294960553LL;
      if (!(_DWORD)v15) {
        goto LABEL_36;
      }
      if (a3 - 36 < v15) {
        goto LABEL_36;
      }
      size_t v17 = (unsigned int *)(a2 + a3);
      __srCC_SHA1_CTX c = (const UInt8 *)(a2 + 36);
      size_t v44 = v15;
      unsigned int v18 = (unsigned int *)(a2 + 36 + v15);
      unsigned int v20 = *v18;
      uint64_t v19 = (char *)(v18 + 1);
      size_t v21 = bswap32(v20);
      uint64_t v23 = (unsigned int *)&v19[v21];
      if ((char *)v17 - &v19[v21] >= 4)
      {
        unsigned int v25 = *v23;
        uint64_t v24 = (UInt8 *)(v23 + 1);
        unint64_t v26 = bswap32(v25);
        int v28 = _OPACKDecodeBytes(0LL, v24, v26, 0, &v46);
        if (!v28)
        {
          if (v46) {
            uint64_t result = v46;
          }
          else {
            uint64_t result = 4294960554LL;
          }
          goto LABEL_36;
        }

        int v29 = v28;
        CFTypeID v30 = CFGetTypeID(v28);
        if (v30 != CFDictionaryGetTypeID())
        {
          unsigned int v46 = -6756;
          CFRelease(v29);
          CFIndex v6 = a6;
LABEL_32:
          uint64_t result = v46;
          if (!v46)
          {
            char v13 = 1;
            goto LABEL_34;
          }

          goto LABEL_36;
        }

        uint64_t v23 = (unsigned int *)&v24[v26];
        uint64_t v31 = (const void *)*((void *)a1 + 22);
        CFIndex v6 = a6;
        if (v31) {
          CFRelease(v31);
        }
        *((void *)a1 + 22) = v29;
        CFDataRef v7 = a5;
      }

      if (v23 == v17)
      {
        cccurve25519();
        int8x16_t v32 = vorrq_s8(*(int8x16_t *)(a1 + 82), *(int8x16_t *)(a1 + 66));
        if (!*(void *)&vorr_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL)))
        {
          uint64_t result = 4294960554LL;
          goto LABEL_36;
        }

        CC_SHA1_Init(&c);
        CC_SHA1_Update(&c, "AES-KEY", 7u);
        CC_SHA1_Update(&c, a1 + 66, 0x20u);
        CC_SHA1_Final(md, &c);
        CC_SHA1_Init(&c);
        CC_SHA1_Update(&c, "AES-IV", 6u);
        CC_SHA1_Update(&c, a1 + 66, 0x20u);
        CC_SHA1_Final((unsigned __int8 *)&v48, &c);
        uint64_t v33 = (UInt8 *)malloc(v21);
        if (!v33) {
          goto LABEL_46;
        }
        char v34 = v33;
        memcpy(v33, v19, v21);
        *((void *)a1 + 15) = 0LL;
        CCCryptorStatus v35 = CCCryptorCreate(0, 0, 2u, md, 0x10uLL, 0LL, (CCCryptorRef *)a1 + 15);
        if (v35)
        {
          unsigned int v46 = v35;
        }

        else
        {
          *((_OWORD *)a1 + 8) = v48;
          *((void *)a1 + 20) = 0LL;
          unsigned int v46 = 0;
          unsigned int v46 = AES_CTR_Update((uint64_t)(a1 + 120), v19, v21, v34);
          if (!v46 || (AES_CTR_Final((_CCCryptor **)a1 + 15), !v46))
          {
            a1[168] = 1;
            __int128 v37 = *(_OWORD *)(a2 + 16);
            v47[0] = *(_OWORD *)a2;
            v47[1] = v37;
            __int128 v38 = *(_OWORD *)(a1 + 50);
            v47[2] = *(_OWORD *)(a1 + 34);
            v47[3] = v38;
            unsigned int v46 = MFiPlatform_VerifySignatureEx( (const UInt8 *)v47,  64LL,  v34,  v21,  __src,  v44,  *((CFDictionaryRef *)a1 + 22),  v36);
            if (!v46)
            {
              int v39 = (void *)*((void *)a1 + 13);
              if (v39) {
                free(v39);
              }
              *((void *)a1 + 14) = 0LL;
              uint64_t v40 = malloc(v44);
              *((void *)a1 + 13) = v40;
              if (v40)
              {
                memcpy(v40, __src, v44);
                *((void *)a1 + 14) = v44;
              }

              *a4 = 0LL;
              *CFDataRef v7 = 0LL;
            }
          }
        }

        free(v34);
        goto LABEL_32;
      }
    }

    uint64_t result = 4294960553LL;
    goto LABEL_36;
  }

  if (v11 == 2)
  {
    RandomBytes(a1 + 2, 0x20uLL);
    CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  (uint64_t)(a1 + 2),  32LL,  "MFiSAP-ECDH-Salt",  0x10uLL,  (uint64_t)"MFiSAP-ECDH-Info",  16LL,  0x20uLL,  (uint64_t)(a1 + 2));
    cccurve25519_make_pub();
    uint64_t v12 = (char *)malloc(0x21uLL);
    if (v12)
    {
      char v13 = 0;
      *uint64_t v12 = a1[1];
      __int128 v14 = *(_OWORD *)(a1 + 50);
      *(_OWORD *)(v12 + 1) = *(_OWORD *)(a1 + 34);
      *(_OWORD *)(v12 + 17) = v14;
      *a4 = v12;
      *CFDataRef v7 = 33LL;
LABEL_34:
      uint64_t result = 0LL;
      ++*a1;
      *CFIndex v6 = v13;
      return result;
    }

uint64_t MFiSAP_Encrypt(_BYTE *a1, char *a2, unint64_t a3, _BYTE *a4)
{
  if ((*a1 & 0xFD) == 4) {
    return AES_CTR_Update((uint64_t)(a1 + 120), a2, a3, a4);
  }
  else {
    return 4294960587LL;
  }
}

uint64_t MFiSAP_Decrypt(_BYTE *a1, char *a2, unint64_t a3, _BYTE *a4)
{
  if ((*a1 & 0xFD) == 4) {
    return AES_CTR_Update((uint64_t)(a1 + 120), a2, a3, a4);
  }
  else {
    return 4294960587LL;
  }
}

uint64_t MFiPlatform_Initialize()
{
  return 0LL;
}

uint64_t MFiPlatform_CreateSignature(unsigned __int8 *a1, size_t a2, void *a3, size_t *a4)
{
  return MFiPlatform_CreateSignatureEx(1, a1, a2, a3, a4);
}

uint64_t MFiPlatform_CreateSignatureEx(char a1, unsigned __int8 *data, size_t len, void *a4, size_t *a5)
{
  __src[32] = *MEMORY[0x1895F89C0];
  if (IsAppleInternalBuild_sOnce != -1) {
    dispatch_once(&IsAppleInternalBuild_sOnce, &__block_literal_global_85);
  }
  if (!IsAppleInternalBuild_sIsInternal) {
    return 4294960561LL;
  }
  if ((a1 & 1) == 0)
  {
    CC_SHA1(data, len, md);
    len = 20LL;
    data = md;
  }

  uint64_t v10 = _CopyKey(&v31, &v32);
  if (v10)
  {
    int v11 = (void *)v10;
    int v12 = CCRSACryptorImport();
    if (!v12)
    {
      size_t __size = 256LL;
      int v12 = CCRSACryptorSign();
      MEMORY[0x186E41B50](cf);
      if (!v12)
      {
        size_t v13 = __size;
        if (__size)
        {
          __int128 v14 = malloc(__size);
          if (v14)
          {
            unint64_t v15 = v14;
            memcpy(v14, __src, v13);
            int v12 = 0;
            *a4 = v15;
            *a5 = v13;
          }

          else
          {
            int v12 = -6728;
          }
        }

        else
        {
          int v12 = -6762;
        }
      }
    }

    unsigned int v32 = v12;
    free(v11);
    return v32;
  }

  else
  {
    __src[0] = 0LL;
    CFTypeRef cf = 0LL;
    uint64_t v17 = HTTPClientCreate(__src);
    unsigned int v18 = (dispatch_queue_t *)__src[0];
    if ((_DWORD)v17 || (uint64_t v17 = HTTPClientSetDestination(__src[0], "spc.corp.apple.com", 14000), (_DWORD)v17))
    {
      uint64_t v16 = v17;
      dispatch_queue_t v19 = 0LL;
    }

    else
    {
      HTTPClientSetTimeout((uint64_t)v18, 30);
      dispatch_queue_t v19 = dispatch_queue_create("MFiProxy", 0LL);
      if (v19)
      {
        HTTPClientSetDispatchQueue((uint64_t)v18, v19);
        uint64_t v21 = HTTPMessageCreate((uint64_t *)&cf);
        if ((_DWORD)v21
          || (CFTypeRef v26 = cf,
              HTTPHeader_InitRequestF( (uint64_t)cf + 24,  "HTTP/1.1",  (uint64_t)"POST",  (uint64_t)"%s",  v22,  v23,  v24,  v25,  (uint64_t)"/mfi-create-signature"),  uint64_t v21 = HTTPMessageSetBody((uint64_t)v26, (uint64_t)"application/octet-stream", data, len),  (_DWORD)v21))
        {
          uint64_t v16 = v21;
        }

        else
        {
          uint64_t v27 = HTTPClientSendMessageSync(v18, (uint64_t)v26);
          if (!(_DWORD)v27 || (uint64_t v16 = v27, (v27 - 200100) <= 0x1F3))
          {
            size_t v28 = *((void *)v26 + 1066);
            if (v28)
            {
              int v29 = malloc(*((void *)v26 + 1066));
              if (v29)
              {
                CFTypeID v30 = v29;
                memcpy(v29, *((const void **)v26 + 1065), v28);
                uint64_t v16 = 0LL;
                *a4 = v30;
                *a5 = v28;
              }

              else
              {
                uint64_t v16 = 4294960568LL;
              }
            }

            else
            {
              uint64_t v16 = 4294960553LL;
            }
          }
        }
      }

      else
      {
        uint64_t v16 = 4294960596LL;
      }
    }

    if (v18)
    {
      CFRetain(v18);
      dispatch_async_f(v18[2], v18, (dispatch_function_t)_HTTPClientInvalidate);
      CFRelease(v18);
      __src[0] = 0LL;
    }

    if (cf) {
      CFRelease(cf);
    }
  }

  return v16;
}

uint64_t _CopyKey(int64_t *a1, _DWORD *a2)
{
  size_t v4 = getenv("MFI_KEY_PATH");
  if (!v4) {
    size_t v4 = "mfi-key.txt";
  }
  int v5 = CopyFileDataByPath(v4, &v11, (unint64_t *)&v9);
  if (v5)
  {
    int v7 = v5;
  }

  else
  {
    CFIndex v6 = v11;
    int v7 = HexToDataCopy(v11, v9, 22, &v10, (unint64_t *)&v9, 0LL);
    free(v6);
    if (!v7)
    {
      uint64_t result = v10;
      *a1 = v9;
      if (!a2) {
        return result;
      }
      goto LABEL_6;
    }
  }

  uint64_t result = 0LL;
  if (!a2) {
    return result;
  }
LABEL_6:
  *a2 = v7;
  return result;
}

uint64_t MFiPlatform_CopyCertificate(void *a1, size_t *a2)
{
  if (IsAppleInternalBuild_sOnce != -1) {
    dispatch_once(&IsAppleInternalBuild_sOnce, &__block_literal_global_85);
  }
  if (!IsAppleInternalBuild_sIsInternal) {
    return 4294960561LL;
  }
  uint64_t v4 = _CopyKey(&v24, &v25);
  if (v4)
  {
    int v5 = (void *)v4;
    if (a1)
    {
      CFIndex v6 = malloc(0x3B1uLL);
      if (!v6)
      {
        int v8 = -6728;
LABEL_10:
        unsigned int v25 = v8;
        free(v5);
        return v25;
      }

      int v7 = v6;
      memcpy(v6, &kPublicCertificate, 0x3B1uLL);
      *a1 = v7;
    }

    int v8 = 0;
    if (a2) {
      *a2 = 945LL;
    }
    goto LABEL_10;
  }

  CFTypeRef v26 = 0LL;
  CFTypeRef cf = 0LL;
  uint64_t v10 = HTTPClientCreate((uint64_t *)&cf);
  int v11 = (dispatch_queue_t *)cf;
  if ((_DWORD)v10 || (uint64_t v10 = HTTPClientSetDestination((uint64_t)cf, "spc.corp.apple.com", 14000), (_DWORD)v10))
  {
    uint64_t v9 = v10;
    dispatch_queue_t v12 = 0LL;
  }

  else
  {
    HTTPClientSetTimeout((uint64_t)v11, 30);
    dispatch_queue_t v12 = dispatch_queue_create("MFiProxy", 0LL);
    if (v12)
    {
      HTTPClientSetDispatchQueue((uint64_t)v11, v12);
      uint64_t v14 = HTTPMessageCreate((uint64_t *)&v26);
      if ((_DWORD)v14)
      {
        uint64_t v9 = v14;
      }

      else
      {
        CFTypeRef v19 = v26;
        HTTPHeader_InitRequestF( (uint64_t)v26 + 24,  "HTTP/1.1",  (uint64_t)"GET",  (uint64_t)"%s",  v15,  v16,  v17,  v18,  (uint64_t)"/mfi-certificate");
        uint64_t v20 = HTTPClientSendMessageSync(v11, (uint64_t)v19);
        if (!(_DWORD)v20 || (uint64_t v9 = v20, (v20 - 200100) <= 0x1F3))
        {
          size_t v21 = *((void *)v19 + 1066);
          if (v21)
          {
            uint64_t v22 = malloc(*((void *)v19 + 1066));
            if (v22)
            {
              uint64_t v23 = v22;
              memcpy(v22, *((const void **)v19 + 1065), v21);
              uint64_t v9 = 0LL;
              *a1 = v23;
              *a2 = v21;
            }

            else
            {
              uint64_t v9 = 4294960568LL;
            }
          }

          else
          {
            uint64_t v9 = 4294960553LL;
          }
        }
      }
    }

    else
    {
      uint64_t v9 = 4294960596LL;
    }
  }

  if (v11)
  {
    CFRetain(v11);
    dispatch_async_f(v11[2], v11, (dispatch_function_t)_HTTPClientInvalidate);
    CFRelease(v11);
    CFTypeRef cf = 0LL;
  }

  if (v26) {
    CFRelease(v26);
  }

  return v9;
}

uint64_t CUNextID32()
{
  if (CUNextID32_sOnce != -1) {
    dispatch_once(&CUNextID32_sOnce, &__block_literal_global_11346);
  }
  do
  {
    do
    {
      unsigned int v0 = __ldaxr((unsigned int *)&CUNextID32_sNextID);
      unsigned int v1 = __stlxr(v0 + 1, (unsigned int *)&CUNextID32_sNextID);
      uint64_t result = v0 + 1;
      BOOL v3 = v0 == -1;
    }

    while (v1);
  }

  while (v3);
  return result;
}

uint64_t __CUNextID32_block_invoke()
{
  uint64_t result = arc4random();
  CUNextID32_sNextID = result & 0xFFFF0000;
  return result;
}

unint64_t CUNextID64()
{
  if (CUNextID64_sOnce != -1) {
    dispatch_once(&CUNextID64_sOnce, &__block_literal_global_4_11351);
  }
  do
  {
    do
    {
      unint64_t v0 = __ldaxr((unint64_t *)&CUNextID64_sNextID);
      unsigned int v1 = __stlxr(v0 + 1, (unint64_t *)&CUNextID64_sNextID);
      unint64_t result = v0 + 1;
      BOOL v3 = v0 == -1LL;
    }

    while (v1);
  }

  while (v3);
  return result;
}

uint64_t __CUNextID64_block_invoke()
{
  uint64_t result = arc4random();
  CUNextID64_sNextID = result << 32;
  return result;
}

unsigned __int16 *Swap16Mem(unsigned __int16 *result, unint64_t a2, _WORD *a3)
{
  if (a2 >= 2)
  {
    BOOL v3 = (unsigned __int16 *)((char *)result + (a2 & 0xFFFFFFFFFFFFFFFELL));
    do
    {
      unsigned int v4 = *result++;
      *a3++ = bswap32(v4) >> 16;
    }

    while (result != v3);
  }

  return result;
}

unint64_t VarIntEncode64(unint64_t result, _BYTE *a2, void *a3)
{
  if (result < 0x80)
  {
    LOBYTE(v4) = result;
    BOOL v3 = a2;
  }

  else
  {
    BOOL v3 = a2;
    do
    {
      *v3++ = result | 0x80;
      unint64_t v4 = result >> 7;
      unint64_t v5 = result >> 14;
      result >>= 7;
    }

    while (v5);
  }

  *BOOL v3 = v4;
  *a3 = v3 - a2 + 1;
  return result;
}

uint64_t VarIntDecode64(_BYTE *a1, uint64_t a2, void *a3, int *a4)
{
  LOBYTE(v5) = 0;
  uint64_t result = 0LL;
  int v7 = a1 + 10;
  while (1)
  {
    if (a2-- < 1)
    {
      uint64_t result = 0LL;
      int v12 = -6750;
      goto LABEL_9;
    }

    char v9 = *a1;
    unint64_t v10 = (unint64_t)(*a1 & 0x7F) << v5;
    if (v10 >> v5 != (*a1 & 0x7F)) {
      break;
    }
    ++a1;
    BOOL v11 = __CFADD__(v10, result);
    result += v10;
    if (v11)
    {
      uint64_t result = 0LL;
      int v12 = -6710;
      goto LABEL_9;
    }

    if ((v9 & 0x80000000) == 0)
    {
      int v12 = 0;
LABEL_9:
      int v7 = a1;
      if (!a3) {
        goto LABEL_11;
      }
LABEL_10:
      *a3 = v7;
      goto LABEL_11;
    }

    unint64_t v5 = (v5 + 7);
    if (v5 > 0x3F)
    {
      uint64_t result = 0LL;
      goto LABEL_16;
    }
  }

  uint64_t result = 0LL;
  int v7 = a1 + 1;
LABEL_16:
  int v12 = -6710;
  if (a3) {
    goto LABEL_10;
  }
LABEL_11:
  if (a4) {
    *a4 = v12;
  }
  return result;
}

uint64_t CopyFileDataByFile(FILE *__stream, void *a2, unint64_t *a3)
{
  unint64_t v5 = 0LL;
  unint64_t v6 = 0LL;
  unint64_t v7 = 0LL;
  do
  {
    unint64_t v8 = v7;
    if (v7 >= v6)
    {
      uint64_t v10 = 160000LL;
      if (v6 >= 0x27100)
      {
        if (v6 >= 0x3D0900)
        {
          if (v6 > 0xFFFFFFFFFFC2F6FELL)
          {
            uint64_t v13 = 4294960553LL;
            goto LABEL_16;
          }

          uint64_t v10 = v6 + 4000000;
        }

        else
        {
          uint64_t v10 = 2 * v6;
        }
      }

      char v9 = (char *)realloc(v5, v10 + 1);
      unint64_t v6 = v10;
      if (!v9)
      {
        uint64_t v13 = 4294960568LL;
        goto LABEL_16;
      }
    }

    else
    {
      char v9 = v5;
    }

    size_t v11 = fread(&v9[v8], 1uLL, v6 - v8, __stream);
    unint64_t v7 = v11 + v8;
    unint64_t v5 = v9;
  }

  while (v11);
  int v12 = realloc(v9, v8 + 1);
  if (v12)
  {
    v12[v8] = 0;
    *a2 = v12;
    uint64_t v13 = 0LL;
    if (a3) {
      *a3 = v8;
    }
    return v13;
  }

  uint64_t v13 = 4294960568LL;
  unint64_t v5 = v9;
LABEL_16:
  if (v5) {
    free(v5);
  }
  return v13;
}

uint64_t CopyFileDataByPath(const char *a1, void *a2, unint64_t *a3)
{
  unint64_t v5 = fopen(a1, "rb");
  unint64_t v6 = v5;
  if (v5) {
    goto LABEL_5;
  }
  if (!*__error()) {
    return 4294960596LL;
  }
  uint64_t v7 = *__error();
  if (!(_DWORD)v7)
  {
    unint64_t v5 = 0LL;
LABEL_5:
    uint64_t v7 = CopyFileDataByFile(v5, a2, a3);
    fclose(v6);
  }

  return v7;
}

void CUDispatchTimerSet(dispatch_source_s *a1, double a2, double a3, double a4)
{
}

void CUDispatchTimerSetEx(dispatch_source_s *a1, int a2, double a3, double a4, double a5)
{
  unint64_t v8 = (unint64_t)(a3 * 1000000000.0);
  dispatch_time_t v9 = dispatch_time((unint64_t)(a2 != 0) << 63, v8);
  if (a5 <= -10.0)
  {
    uint64_t v10 = v8 / 0xA;
  }

  else if (a5 <= -4.0)
  {
    uint64_t v10 = v8 >> 2;
  }

  else
  {
    uint64_t v10 = (unint64_t)(a5 * 1000000000.0);
  }

  if (a4 < 0.0) {
    uint64_t v11 = -1LL;
  }
  else {
    uint64_t v11 = (unint64_t)(a4 * 1000000000.0);
  }
  dispatch_source_set_timer(a1, v9, v11, v10);
}

uint64_t CUSystem(char *a1)
{
  __argv[4] = *(char **)MEMORY[0x1895F89C0];
  __argv[0] = "/bin/sh";
  __argv[1] = "-c";
  __argv[2] = a1;
  __argv[3] = 0LL;
  unsigned int v1 = _NSGetEnviron();
  uint64_t result = posix_spawn(&v10, "/bin/sh", 0LL, 0LL, __argv, *v1);
  if (!(_DWORD)result)
  {
    while (1)
    {
      pid_t v3 = waitpid(v10, (int *)&v9, 0);
      if (v3 != -1) {
        break;
      }
      if (*__error() != 4) {
        return *__error();
      }
    }

    if (v3)
    {
      int v4 = v9 & 0x7F;
      int v5 = (int)v9 >> 8;
      if (v9 >> 8 == 19) {
        int v6 = 312719;
      }
      else {
        int v6 = -6700;
      }
      if (v5 == 19) {
        unsigned int v7 = v6;
      }
      else {
        unsigned int v7 = v5 + 312700;
      }
      unsigned int v8 = BYTE1(v9);
      if ((v9 & 0x7F) != 0) {
        unsigned int v8 = v4 + 312700;
      }
      if (v4 == 127) {
        return v7;
      }
      else {
        return v8;
      }
    }

    else
    {
      return 4294960560LL;
    }
  }

  return result;
}

uint64_t ReadANSIFile(FILE *__stream, char *__ptr, size_t __nitems, void *a4)
{
  int v6 = __ptr;
  if (__nitems)
  {
    size_t v7 = __nitems;
    int v6 = __ptr;
    do
    {
      size_t v9 = fread(v6, 1uLL, v7, __stream);
      if (!v9) {
        break;
      }
      v6 += v9;
      v7 -= v9;
    }

    while (v7);
  }

  if (a4) {
    *a4 = v6 - __ptr;
  }
  return 0LL;
}

uint64_t WriteANSIFile(FILE *__stream, char *__ptr, size_t __nitems)
{
  if (__nitems)
  {
    size_t v3 = __nitems;
    do
    {
      size_t v6 = fwrite(__ptr, 1uLL, v3, __stream);
      if (!v6) {
        break;
      }
      __ptr += v6;
      v3 -= v6;
    }

    while (v3);
  }

  return 0LL;
}

__CFDictionary *CFDictionaryCreateWithTXTRecordBytes(const char *a1, uint64_t a2, int *a3)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    size_t v7 = (unsigned __int8 *)&a1[a2];
    while (1)
    {
      if (v7 - (unsigned __int8 *)a1 < 1
        || (unsigned int v8 = (const UInt8 *)(a1 + 1), v9 = *(unsigned __int8 *)a1, v7 - (unsigned __int8 *)(a1 + 1) < v9))
      {
        int v14 = 0;
        goto LABEL_16;
      }

      a1 += v9 + 1;
      pid_t v10 = (const char *)v8;
      if ((_DWORD)v9)
      {
        while (*v10 != 61)
        {
          ++v10;
          if (!--v9)
          {
            pid_t v10 = a1;
            break;
          }
        }
      }

      CFStringRef v11 = CFStringCreateWithBytes(0LL, v8, v10 - (const char *)v8, 0x8000100u, 0);
      if (!v11) {
        break;
      }
      CFStringRef v12 = v11;
      if (v10 >= a1) {
        uint64_t v13 = v10;
      }
      else {
        uint64_t v13 = v10 + 1;
      }
      int v14 = CFDictionarySetCString(Mutable, v11, v13, a1 - v13);
      CFRelease(v12);
      if (v14) {
        goto LABEL_20;
      }
    }

    int v14 = -6728;
LABEL_20:
    CFRelease(Mutable);
    CFMutableArrayRef Mutable = 0LL;
  }

  else
  {
    int v14 = -6728;
  }

uint64_t TXTRecordGetNextItem( _BYTE *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, unint64_t *a7)
{
  size_t v7 = a1 + 1;
  unint64_t v8 = *a1;
  unint64_t v10 = (unint64_t)&a1[v8 + 1];
  CFStringRef v11 = a1 + 1;
  if (*a1)
  {
    while (*v11 != 61)
    {
      ++v11;
      if (!--v8)
      {
        CFStringRef v11 = (_BYTE *)v10;
        break;
      }
    }
  }

  *a3 = v7;
  else {
    CFStringRef v12 = v11 + 1;
  }
  *a4 = v11 - v7;
  *a6 = v10 - (void)v12;
  *a5 = v12;
  *a7 = v10;
  return 1LL;
}

uint64_t CreateTXTRecordWithCString(const char *a1, void *a2, size_t *a3)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  v43[0] = 0LL;
  v43[1] = 0LL;
  int v48 = 0;
  v43[2] = -1LL;
  size_t v44 = 0LL;
  unint64_t v45 = 0LL;
  uint64_t v46 = 0LL;
  char v47 = 0;
  size_t v6 = &a1[strlen(a1)];
  uint64_t v7 = MEMORY[0x1895F8770];
  unint64_t v8 = a1;
LABEL_2:
  unint64_t v9 = (unsigned __int8 *)v6;
  if (!a1) {
    unint64_t v9 = (unsigned __int8 *)&v8[strlen(v8)];
  }
  int64_t v10 = v9 - (unsigned __int8 *)v8;
  if (v9 > (unsigned __int8 *)v8)
  {
    do
    {
      uint64_t v11 = *(unsigned __int8 *)v8;
      if (*v8 < 0)
      {
        if (!__maskrune(v11, 0x4000uLL))
        {
LABEL_11:
          int64_t v12 = 0LL;
          uint64_t v13 = 0LL;
          int v14 = 0;
          uint64_t v15 = v8;
          while (2)
          {
            while (2)
            {
              unint64_t v8 = v15;
              uint64_t v16 = v13;
              while (1)
              {
                uint64_t v13 = v16;
                uint64_t v15 = v8 + 1;
                unsigned int v17 = *(unsigned __int8 *)v8;
                if (!(_DWORD)v16) {
                  break;
                }
                uint64_t v16 = 0LL;
                ++v8;
                if (v17 != 39) {
                  goto LABEL_64;
                }
              }

              if (!v14)
              {
                if ((v17 & 0xFFFFFFDF) == 0)
                {
                  ++v8;
LABEL_95:
                  uint64_t v34 = DataBuffer_Resize((uint64_t)v43, v45 + v12 + 1, (size_t *)&__dst);
                  if (!(_DWORD)v34)
                  {
                    CCCryptorStatus v35 = __dst;
                    __dst = (char *)__dst + 1;
                    _BYTE *v35 = v12;
                    memcpy(__dst, __src, v12);
                    goto LABEL_2;
                  }

                  uint64_t v40 = v34;
                  if (v47 && v44) {
                    free(v44);
                  }
                  return v40;
                }

                if (v17 == 34)
                {
                  uint64_t v13 = 0LL;
LABEL_29:
                  int v14 = 1;
                  continue;
                }

                int v14 = 0;
                uint64_t v13 = 1LL;
                if (v17 == 39) {
                  continue;
                }
                if (v17 != 92)
                {
                  uint64_t v13 = 0LL;
                  goto LABEL_64;
                }

                if (v15 < (const char *)v9)
                {
                  unsigned int v17 = *(unsigned __int8 *)v15;
                  if (v17 == 10)
                  {
                    uint64_t v13 = 0LL;
                    int v14 = 0;
                    uint64_t v15 = v8 + 2;
                    continue;
                  }

                  if ((v17 & 0xFFFFFFDF) == 0x58)
                  {
                    uint64_t v15 = v8 + 2;
                    if (v9 - (unsigned __int8 *)(v8 + 2) < 2
                      || (uint64_t v18 = *(unsigned __int8 *)v15, (*(_DWORD *)(v7 + 4 * v18 + 60) & 0x10000) == 0)
                      || (uint64_t v19 = *((unsigned __int8 *)v8 + 3), (*(_DWORD *)(v7 + 4 * v19 + 60) & 0x10000) == 0))
                    {
                      uint64_t v13 = 0LL;
                      int v14 = 0;
                      goto LABEL_64;
                    }

                    char v26 = v18 - 48;
                    if ((v18 - 48) >= 0xA)
                    {
                      if ((v18 - 65) > 5)
                      {
                        else {
                          char v26 = v18 - 87;
                        }
                      }

                      else
                      {
                        char v26 = v18 - 55;
                      }
                    }

                    char v28 = v19 - 48;
                    if ((v19 - 48) >= 0xA)
                    {
                      if ((v19 - 65) > 5)
                      {
                        unsigned int v29 = v19 - 97;
                        char v30 = v19 - 87;
                        if (v29 >= 6) {
                          char v28 = 0;
                        }
                        else {
                          char v28 = v30;
                        }
                      }

                      else
                      {
                        char v28 = v19 - 55;
                      }
                    }

                    uint64_t v13 = 0LL;
                    int v14 = 0;
                    LOBYTE(v17) = v28 | (16 * v26);
LABEL_82:
                    uint64_t v15 = v8 + 4;
                  }

                  else
                  {
                    if ((v17 & 0xF8) == 0x30 && v9 - (unsigned __int8 *)v15 >= 3 && v17 <= 0x33)
                    {
                      unsigned __int8 v20 = v8[2];
                      if ((v20 & 0xF8) == 0x30)
                      {
                        unsigned __int8 v21 = v8[3];
                        if ((v21 & 0xF8) == 0x30)
                        {
                          uint64_t v13 = 0LL;
                          int v14 = 0;
                          LOBYTE(v17) = (8 * v20) ^ 0x80 | ((_BYTE)v17 << 6) | (v21 - 48);
                          goto LABEL_82;
                        }
                      }
                    }

                    uint64_t v13 = 0LL;
                    int v14 = 0;
                    uint64_t v15 = v8 + 2;
                  }

void *TXTRecordCreateWithDictionary(const __CFDictionary *a1, size_t *a2, int *a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  TXTRecordCreate(&txtRecord, 0x100u, &v12);
  int v14 = 0;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)_TXTRecordCreateWithDictionaryApplier, &txtRecord);
  LODWORD(v6) = TXTRecordGetLength(&txtRecord);
  size_t v7 = v6;
  if ((_DWORD)v6) {
    size_t v6 = v6;
  }
  else {
    size_t v6 = 1LL;
  }
  unint64_t v8 = malloc(v6);
  if (v8)
  {
    if ((_DWORD)v7)
    {
      BytesPtr = TXTRecordGetBytesPtr(&txtRecord);
      memcpy(v8, BytesPtr, v7);
    }
  }

  else
  {
    int v14 = -6728;
  }

  TXTRecordDeallocate(&txtRecord);
  if (a2)
  {
    if (v14) {
      size_t v10 = 0LL;
    }
    else {
      size_t v10 = v7;
    }
    *a2 = v10;
  }

  if (a3) {
    *a3 = v14;
  }
  return v8;
}

void _TXTRecordCreateWithDictionaryApplier(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  uint64_t v18 = 0LL;
  uint64_t v16 = 0LL;
  if (*(_DWORD *)(a3 + 16)) {
    return;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID()) {
    goto LABEL_20;
  }
  int v7 = CFStringGetOrCopyCStringUTF8(a1, &v19, (UInt8 **)&v18, 0LL);
  unint64_t v8 = v19;
  if (!v19) {
    goto LABEL_12;
  }
  CFTypeID v9 = CFGetTypeID(a2);
  if (v9 != CFStringGetTypeID())
  {
    if ((const __CFString *)*MEMORY[0x189604DE8] == a2 || v9 == CFNullGetTypeID())
    {
      uint64_t v12 = (TXTRecordRef *)a3;
      uint64_t v13 = v8;
      uint8_t v11 = 0;
      size_t v10 = 0LL;
LABEL_11:
      int v7 = TXTRecordSetValue(v12, v13, v11, v10);
      goto LABEL_12;
    }

uint64_t fcopyline(FILE *a1, unint64_t *a2, void *a3)
{
  if (feof(a1)) {
    return 4294960544LL;
  }
  CFTypeID v6 = malloc(0x80uLL);
  if (!v6) {
    return 4294960568LL;
  }
  unint64_t v7 = (unint64_t)v6;
  unint64_t v8 = 0LL;
  for (uint64_t i = 128LL; ; i *= 2LL)
  {
    memset(&v8[v7], 10, i - (void)v8);
    if (!fgets(&v8[v7], (int)i - (int)v8, a1))
    {
      if (!feof(a1))
      {
        if (*__error()) {
          uint64_t v12 = *__error();
        }
        else {
          uint64_t v12 = 4294960596LL;
        }
        goto LABEL_20;
      }

      if (!v8)
      {
        uint64_t v12 = 4294960544LL;
LABEL_20:
        free((void *)v7);
        return v12;
      }

      goto LABEL_15;
    }

    size_t v10 = memchr(&v8[v7], 10, i - (void)v8);
    if (v10) {
      break;
    }
    if (i < 0)
    {
      uint64_t v12 = 4294960553LL;
      goto LABEL_20;
    }

    uint8_t v11 = realloc((void *)v7, 2 * i);
    if (!v11)
    {
      uint64_t v12 = 4294960568LL;
      goto LABEL_20;
    }

    unint64_t v8 = (_BYTE *)(i - 1);
    unint64_t v7 = (unint64_t)v11;
  }

  if ((unint64_t)(v10 + 1) >= v7 + i || v10[1])
  {
    unint64_t v8 = &v10[~v7];
LABEL_15:
    if (!a2) {
      goto LABEL_17;
    }
LABEL_16:
    *a2 = v7;
    unint64_t v7 = 0LL;
    goto LABEL_17;
  }

  unint64_t v8 = &v10[-v7];
  *size_t v10 = 0;
  if (a2) {
    goto LABEL_16;
  }
LABEL_17:
  if (a3) {
    *a3 = v8;
  }
  uint64_t v12 = 0LL;
  if (v7) {
    goto LABEL_20;
  }
  return v12;
}

uint64_t FDWriteAll(int __fd, char *__buf, size_t __nbyte)
{
  if (!__nbyte) {
    return 0LL;
  }
  size_t v3 = __nbyte;
  while (1)
  {
    ssize_t v6 = write(__fd, __buf, v3);
    if (v6 <= 0) {
      break;
    }
LABEL_6:
    __buf += v6;
    v3 -= v6;
    if (!v3) {
      return 0LL;
    }
  }

  if (*__error())
  {
    uint64_t result = *__error();
    if ((_DWORD)result) {
      return result;
    }
    goto LABEL_6;
  }

  return 4294960596LL;
}

uint64_t IOKitCopyParentOfClass(io_registry_entry_t entry, const char *a2, kern_return_t *a3)
{
  kern_return_t ParentEntry;
  io_registry_entry_t parent;
  LODWORD(v6) = entry;
  while (1)
  {
    ParentEntry = IORegistryEntryGetParentEntry(v6, "IOService", &parent);
    if ((_DWORD)v6 != entry) {
      IOObjectRelease(v6);
    }
    if (ParentEntry) {
      break;
    }
    uint64_t v6 = parent;
    if (IOObjectConformsTo(parent, a2))
    {
      ParentEntry = 0;
      if (!a3) {
        return v6;
      }
      goto LABEL_9;
    }
  }

  uint64_t v6 = 0LL;
  if (!a3) {
    return v6;
  }
LABEL_9:
  *a3 = ParentEntry;
  return v6;
}

uint64_t CUMainQueue()
{
  if (CUMainQueue_sOnce != -1) {
    dispatch_once(&CUMainQueue_sOnce, &__block_literal_global_16);
  }
  return CUMainQueue_sQueue;
}

dispatch_queue_t __CUMainQueue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create_with_target_V2("CUMainQueue", 0LL, MEMORY[0x1895F8AE0]);
  CUMainQueue_sQueue = (uint64_t)result;
  if (!result) {
    FatalErrorF("Create wrapper main queue failed");
  }
  return result;
}

uint64_t mkparent(const char *a1, unsigned int a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  int v4 = &a1[strlen(a1)];
  do
  {
    if (v4 <= a1)
    {
      int64_t v6 = 0LL;
      goto LABEL_8;
    }

    int v5 = *(unsigned __int8 *)--v4;
  }

  while (v5 != 47);
  int64_t v6 = v4 - a1;
  if (v6) {
    memcpy(__dst, a1, v4 - a1);
  }
LABEL_8:
  uint64_t result = 0LL;
  __dst[v6] = 0;
  if (__dst[0]) {
    return mkpath(__dst, a2, a2);
  }
  return result;
}

uint64_t mkpath(const char *a1, unsigned int a2, __int16 a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  size_t v5 = strlen(a1);
  if (v5 >= 0x3FF) {
    uint64_t v6 = 1023LL;
  }
  else {
    uint64_t v6 = v5;
  }
  unint64_t v7 = v16;
  __memcpy_chk();
  v16[v6] = 0;
  while (1)
  {
    unint64_t v8 = &v7[strspn(v7, "/")];
    unint64_t v7 = (char *)&v8[strcspn(v8, "/")];
    int v9 = *v7;
    *unint64_t v7 = 0;
    mode_t v10 = v9 ? a3 : a2;
    if ((mkdir(v16, v10) & 0x80000000) == 0 || *__error() == 17) {
      break;
    }
    unsigned int v11 = *__error();
    if (stat(v16, &v15) < 0)
    {
      if (v11) {
        return v11;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    }

    int v12 = v15.st_mode & 0xF000;
    if (!v9 || v12 != 0x4000)
    {
      if (v12 == 0x4000) {
        return 0LL;
      }
      else {
        return 20LL;
      }
    }

const char *NormalizePath(char *__s, int64_t a2, char *a3, size_t a4, char a5)
{
  unint64_t v8 = __s;
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (a2 == -1) {
    a2 = strlen(__s);
  }
  int v9 = 0LL;
  mode_t v10 = &v8[a2];
  char v31 = 0LL;
  if ((a5 & 1) != 0 || a2 < 1)
  {
    unint64_t v15 = 0LL;
    goto LABEL_35;
  }

  if (*v8 != 126) {
    goto LABEL_15;
  }
  uint64_t v11 = 1LL;
  while (a2 != v11)
  {
    int64_t v12 = v11;
    int v13 = v8[v11++];
    if (v13 == 47)
    {
      unsigned int v14 = &v8[v12];
      a2 = v12;
      goto LABEL_12;
    }
  }

  unsigned int v14 = &v8[a2];
LABEL_12:
  if (a2 != 1)
  {
    else {
      uint64_t v19 = a2 - 1;
    }
    __memcpy_chk();
    v33[v19] = 0;
    uint64_t v20 = sysconf(71);
    if (v20 >= 1) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = 4096LL;
    }
    int v9 = (char *)calloc(1uLL, v21);
    if (v9)
    {
      int v22 = getpwnam_r(v33, &v32, v9, v21, &v31);
      unint64_t v15 = 0LL;
      if (v22 || !v31) {
        goto LABEL_35;
      }
      pw_dir = v31->pw_dir;
      if (pw_dir)
      {
        size_t v18 = strlen(v31->pw_dir);
        goto LABEL_28;
      }
    }

const char *GetProcessNameByPID(int a1, char *a2, size_t a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a3) {
    return "";
  }
  if (proc_pidinfo(a1, 3, 0LL, buffer, 136) == 136)
  {
    if (v11) {
      uint64_t v6 = &v11;
    }
    else {
      uint64_t v6 = (const char *)&v10;
    }
    goto LABEL_12;
  }

  *(void *)unsigned int v14 = 0xE00000001LL;
  int v15 = 1;
  int v16 = a1;
  bzero(v12, 0x288uLL);
  size_t v8 = 648LL;
  if (!sysctl(v14, 4u, v12, &v8, 0LL, 0LL) || *__error() && !*__error())
  {
    uint64_t v6 = v13;
LABEL_12:
    strlcpy(a2, v6, a3);
    return a2;
  }

  *a2 = 0;
  return a2;
}

uint64_t RemovePath(const char *a1)
{
  uint64_t result = nftw(a1, (int (__cdecl *)(const char *, const stat *, int, FTW *))_RemovePathCallBack, 64, 15);
  if ((_DWORD)result)
  {
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result == 20)
    {
      uint64_t result = remove(a1);
      if ((_DWORD)result)
      {
        if (*__error()) {
          return *__error();
        }
        return 4294960596LL;
      }
    }
  }

  return result;
}

uint64_t _RemovePathCallBack(const char *a1)
{
  uint64_t result = remove(a1);
  if ((_DWORD)result)
  {
    if (*__error()) {
      return *__error();
    }
    else {
      return 4294960596LL;
    }
  }

  return result;
}

uint64_t RollLogFiles(FILE **a1, char *a2, const char *a3, int a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    unint64_t v7 = *a1;
    if (*a1)
    {
      if (a2)
      {
        fputs(a2, *a1);
        unint64_t v7 = *a1;
      }

      fclose(v7);
      *a1 = 0LL;
    }
  }

  snprintf(__str, 0x401uLL, "%s.%d", a3, a4 - 1);
  remove(__str);
  int v8 = a4 - 2;
  if (a4 > 2)
  {
    do
    {
      snprintf(__str, 0x401uLL, "%s.%d", a3, v8);
      snprintf(__new, 0x401uLL, "%s.%d", a3, v8 + 1);
      rename(__str, __new);
      BOOL v9 = v8-- != 0;
    }

    while (v8 != 0 && v9);
  }

  if (a4 >= 2)
  {
    snprintf(__new, 0x401uLL, "%s.%d", a3, 1);
    rename(a3, __new);
  }

  if (!a1) {
    return 0LL;
  }
  uint64_t v10 = fopen(a3, "w");
  *a1 = v10;
  if (v10) {
    return 0LL;
  }
  if (!*__error()) {
    return 4294960596LL;
  }
  uint64_t result = *__error();
  if (!(_DWORD)result) {
    return 0LL;
  }
  return result;
}

uint64_t RunProcessAndCaptureOutput(char *a1, void **a2)
{
  return RunProcessAndCaptureOutputEx(a1, a2, 0LL);
}

uint64_t RunProcessAndCaptureOutputEx(char *a1, void **a2, void *a3)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  int v13 = 0;
  v8[2] = -1LL;
  BOOL v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  char v12 = 0;
  uint64_t appended = DataBuffer_RunProcessAndAppendOutput((uint64_t)v8, a1);
  if ((_DWORD)appended || (uint64_t appended = DataBuffer_Resize((uint64_t)v8, v10 + 1, (size_t *)&v14), (_DWORD)appended))
  {
    uint64_t v6 = appended;
  }

  else
  {
    *uint64_t v14 = 0;
    *a2 = v9;
    if (a3) {
      *a3 = v10;
    }
    uint64_t v6 = 0LL;
    BOOL v9 = 0LL;
  }

  if (v12 && v9) {
    free(v9);
  }
  return v6;
}

uint64_t SwitchToMobileUser()
{
  unint64_t v0 = getpwnam("mobile");
  if (!v0)
  {
    uint64_t v5 = *MEMORY[0x1895F89D0];
    __error();
    uint64_t v4 = v5;
    return FPrintF(v4);
  }

  unsigned int v1 = v0;
  uid_t v2 = getuid();
  uint64_t result = v1->pw_uid;
  if (v2 != (_DWORD)result)
  {
    uint64_t result = setuid(result);
    if ((_DWORD)result)
    {
      if (!*__error() || (uint64_t result = (uint64_t)__error(), *(_DWORD *)result))
      {
        uint64_t v4 = *MEMORY[0x1895F89D0];
        return FPrintF(v4);
      }
    }
  }

  return result;
}

void *sysctl_copy(int *a1, size_t *a2, int *a3)
{
  int v6 = 10;
  while (1)
  {
    size_t v12 = 0LL;
    if (sysctl(a1, 6u, 0LL, &v12, 0LL, 0LL))
    {
      if (!*__error()) {
        goto LABEL_14;
      }
      int v7 = *__error();
      if (v7)
      {
        uint64_t v10 = 0LL;
        goto LABEL_17;
      }
    }

    size_t v8 = v12;
    if (v12 <= 1) {
      size_t v9 = 1LL;
    }
    else {
      size_t v9 = v12;
    }
    uint64_t v10 = malloc(v9);
    if (!v10)
    {
      int v7 = -6728;
      goto LABEL_17;
    }

    if (!v8 || !sysctl(a1, 6u, v10, &v12, 0LL, 0LL) || *__error() && !*__error()) {
      break;
    }
    free(v10);
    if (!--v6)
    {
LABEL_14:
      uint64_t v10 = 0LL;
      int v7 = -6700;
      goto LABEL_17;
    }
  }

  int v7 = 0;
  if (a2) {
    *a2 = v12;
  }
LABEL_17:
  if (a3) {
    *a3 = v7;
  }
  return v10;
}

uint64_t systemf( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  *(_OWORD *)__argv = xmmword_189F339D8;
  __int128 v24 = unk_189F339E8;
  v22[0] = 0LL;
  v22[1] = &a9;
  VASPrintF(v22);
  uint64_t v10 = v22[0];
  if (!v22[0]) {
    return 4294960596LL;
  }
  if (a1) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "%s%s\n", a1, (const char *)v22[0]);
  }
  *(void *)&__int128 v24 = v10;
  uint64_t v11 = _NSGetEnviron();
  uint64_t v12 = posix_spawn(&v21, "/bin/sh", 0LL, 0LL, __argv, *v11);
  free(v10);
  if (!(_DWORD)v12)
  {
    do
    {
      pid_t v13 = waitpid(v21, &v20, 0);
      if (v13 != -1)
      {
        if (!v13) {
          return 4294960560LL;
        }
        int v14 = v20 & 0x7F;
        int v15 = v20 >> 8;
        else {
          int v16 = -6700;
        }
        if (v15 == 19) {
          unsigned int v17 = v16;
        }
        else {
          unsigned int v17 = v15 + 312700;
        }
        unsigned int v18 = BYTE1(v20);
        if ((v20 & 0x7F) != 0) {
          unsigned int v18 = v14 + 312700;
        }
        if (v14 == 127) {
          return v17;
        }
        else {
          return v18;
        }
      }
    }

    while (*__error() == 4);
    if (!*__error()) {
      return 4294960596LL;
    }
    return *__error();
  }

  return v12;
}

__CFDictionary *CopyEDIDbyUUID(const void *a1, kern_return_t *a2)
{
  kern_return_t MatchingServices;
  io_object_t v8;
  io_object_t v9;
  CFTypeID v10;
  io_iterator_t existing;
  CFProperty = IOServiceMatching("IOAVService");
  if (CFProperty)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    if (Mutable)
    {
      int v6 = Mutable;
      CFDictionarySetValue(Mutable, @"EDID UUID", a1);
      CFDictionarySetValue(CFProperty, @"IOPropertyMatch", v6);
      CFRelease(v6);
      MatchingServices = IOServiceGetMatchingServices(*MEMORY[0x1896086A8], CFProperty, &existing);
      if (MatchingServices)
      {
        CFProperty = 0LL;
      }

      else
      {
        while (1)
        {
          size_t v8 = IOIteratorNext(existing);
          if (!v8) {
            break;
          }
          size_t v9 = v8;
          CFProperty = (__CFDictionary *)IORegistryEntryCreateCFProperty(v8, @"EDID", 0LL, 0);
          IOObjectRelease(v9);
          if (!CFProperty) {
            goto LABEL_10;
          }
          uint64_t v10 = CFGetTypeID(CFProperty);
          if (v10 == CFDataGetTypeID()) {
            goto LABEL_10;
          }
          CFRelease(CFProperty);
        }

        CFProperty = 0LL;
LABEL_10:
        IOObjectRelease(existing);
        if (CFProperty) {
          MatchingServices = 0;
        }
        else {
          MatchingServices = -6727;
        }
      }
    }

    else
    {
      CFRelease(CFProperty);
      CFProperty = 0LL;
      MatchingServices = -6728;
    }
  }

  else
  {
    MatchingServices = -6700;
  }

  if (a2) {
    *a2 = MatchingServices;
  }
  return CFProperty;
}

uint64_t H264ConvertAVCCtoAnnexBHeader( _BYTE *a1, uint64_t a2, char *a3, uint64_t a4, void *a5, void *a6, char **a7)
{
  if (a2 < 6) {
    return 4294960553LL;
  }
  uint64_t v10 = &a1[a2];
  uint64_t v11 = &a3[a4];
  char v26 = a1[4];
  uint64_t v12 = a1 + 6;
  pid_t v13 = a3;
  int v14 = a1[5] & 0x1F;
  if ((a1[5] & 0x1F) != 0)
  {
    while (v10 - v12 >= 2)
    {
      unsigned int v16 = *(unsigned __int16 *)v12;
      int v15 = v12 + 2;
      int64_t v17 = __rev16(v16);
      if (v10 - v15 < v17) {
        break;
      }
      if (a3)
      {
        int64_t v18 = v17 + 4;
        if (v11 - v13 < v17 + 4) {
          return 4294960545LL;
        }
        *(_DWORD *)pid_t v13 = 0x1000000;
        memcpy(v13 + 4, v15, v17);
      }

      else
      {
        int64_t v18 = v17 + 4;
      }

      uint64_t v12 = &v15[v17];
      v13 += v18;
      if (!--v14) {
        goto LABEL_10;
      }
    }

    return 4294960546LL;
  }

BOOL H264EscapeEmulationPrevention( _BYTE *a1, _BYTE *a2, void *a3, void *a4, const char **a5, uint64_t *a6, void *a7)
{
  if (a2 - a1 < 3)
  {
LABEL_9:
    *a3 = a1;
    *a4 = a2 - a1;
    if (a1 == a2 || *(a2 - 1))
    {
      uint64_t v10 = 0LL;
      uint64_t v11 = 0LL;
    }

    else
    {
      uint64_t v10 = "\x03";
      uint64_t v11 = 1LL;
    }

    *a5 = v10;
    BOOL result = a1 != a2;
    *a6 = v11;
    *a7 = a2;
    return result;
  }

  unint64_t v7 = a2 - a1;
  size_t v8 = a1;
  while (1)
  {
    if (*v8 || v8[1]) {
      goto LABEL_8;
    }
    unsigned int v9 = v8[2];
    if (v9 <= 2) {
      break;
    }
    if (v7 >= 4 && v9 == 3)
    {
      *a3 = a1;
      int v15 = v8 + 3;
      *a4 = v15 - a1;
      *a5 = "\x03";
      BOOL result = 1LL;
      *a6 = 1LL;
      *a7 = v15;
      return result;
    }

uint64_t H264GetNextNALUnit( unsigned int *a1, unsigned int *a2, unint64_t a3, unsigned int **a4, unint64_t *a5, void *a6)
{
  if (a1 == a2) {
    return 4294960544LL;
  }
  switch(a3)
  {
    case 4uLL:
      unsigned int v9 = *a1;
      int v6 = a1 + 1;
      unint64_t v7 = bswap32(v9);
      break;
    case 2uLL:
      unsigned int v10 = *(unsigned __int16 *)a1;
      int v6 = (unsigned int *)((char *)a1 + 2);
      unint64_t v7 = __rev16(v10);
      break;
    case 1uLL:
      unsigned int v8 = *(unsigned __int8 *)a1;
      int v6 = (unsigned int *)((char *)a1 + 1);
      unint64_t v7 = v8;
      break;
    default:
      return 4294960591LL;
  }

  uint64_t v11 = 0LL;
  *a4 = v6;
  *a5 = v7;
  *a6 = (char *)v6 + v7;
  return v11;
}

uint64_t MirroredRingBufferInit(uint64_t a1, uint64_t a2, int a3)
{
  vm_map_t v4 = *MEMORY[0x1895FBBE0];
  mach_vm_address_t address = 0LL;
  uint64_t v5 = ~*MEMORY[0x1895FD578];
  mach_vm_size_t v6 = v5 & (*MEMORY[0x1895FD578] + a2);
  if (a3)
  {
    unsigned int v7 = (v6 - 1) | ((v6 - 1) >> 1) | ((((_DWORD)v6 - 1) | ((v6 - 1) >> 1)) >> 2);
    unsigned int v8 = v7 | (v7 >> 4) | ((v7 | (v7 >> 4)) >> 8);
    mach_vm_size_t v6 = (v8 | HIWORD(v8)) + 1;
  }

  if (v6 != (v5 & (*MEMORY[0x1895FD578] + v6))) {
    return 4294960534LL;
  }
  uint64_t v9 = mach_vm_allocate(v4, &address, 2 * v6, 1);
  mach_vm_address_t v10 = address;
  if ((_DWORD)v9)
  {
    uint64_t v11 = v9;
  }

  else
  {
    mach_vm_address_t target_address = address + v6;
    uint64_t v11 = mach_vm_remap(v4, &target_address, v6, 0LL, 0x4000, v4, address, 0, &cur_protection, &v13, 1u);
    mach_vm_address_t v10 = address;
    if (!(_DWORD)v11)
    {
      *(void *)a1 = address;
      *(void *)(a1 + 8) = v10 + v6;
      *(_DWORD *)(a1 + 16) = v6;
      *(_DWORD *)(a1 + 20) = v6 - 1;
      *(void *)(a1 + 24) = 0LL;
      return v11;
    }
  }

  if (v10) {
    mach_vm_deallocate(v4, v10, 2 * v6);
  }
  return v11;
}

double MirroredRingBufferFree(uint64_t a1)
{
  if (*(void *)a1) {
    mach_vm_deallocate(*MEMORY[0x1895FBBE0], *(void *)a1, (2 * *(_DWORD *)(a1 + 16)));
  }
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t MorseCode(uint64_t result, int a2, int a3, void (*a4)(void, void), uint64_t a5)
{
  char v7 = a3;
  unsigned int v8 = (unsigned __int8 *)result;
  int v21 = a3;
  unsigned int v22 = a4;
  uint64_t v23 = a5;
  if (a2) {
    int v9 = a2;
  }
  else {
    int v9 = 10;
  }
  unsigned int v10 = 0x5B8D80u / -v9;
  BOOL v11 = v9 < 1;
  unsigned int v12 = 0x124F80u / v9;
  if (v11) {
    unsigned int v13 = v10;
  }
  else {
    unsigned int v13 = v12;
  }
  unsigned int v24 = v13;
  if ((a3 & 1) == 0)
  {
    a4(0LL, a5);
    double result = usleep(7 * v13);
  }

  unsigned __int8 v14 = *v8;
  if (*v8)
  {
    int v15 = v8 + 1;
    uint64_t v16 = MEMORY[0x1895F8770];
    do
    {
      __darwin_ct_rune_t v17 = (char)v14;
      unsigned int v18 = v14;
      if ((v14 & 0x80) != 0)
      {
        if (__maskrune(v14, 0x100uLL))
        {
LABEL_13:
          int v19 = (unsigned __int8 *)&kMorseCodeAlpha + 8 * __toupper(v17) - 520;
LABEL_17:
          double result = _MorseCodeDoChar((uint64_t)&v21, v19);
          goto LABEL_18;
        }
      }

      else if ((*(_DWORD *)(v16 + 4LL * v14 + 60) & 0x100) != 0)
      {
        goto LABEL_13;
      }

      if (v18 - 48 <= 9)
      {
        int v19 = (unsigned __int8 *)&kMorseCodeDigit + 8 * (char)v18 - 384;
        goto LABEL_17;
      }

      switch((char)v17)
      {
        case '!':
          int v19 = (unsigned __int8 *)&unk_186B4BA8B;
          goto LABEL_17;
        case '""':
          int v19 = (unsigned __int8 *)&kMorseCodePunct;
          goto LABEL_17;
        case '#':
        case '%':
        case '*':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '<':
        case '>':
          goto LABEL_32;
        case '$':
          int v19 = (unsigned __int8 *)&unk_186B4BABB;
          goto LABEL_17;
        case '&':
          int v19 = (unsigned __int8 *)&unk_186B4BA93;
          goto LABEL_17;
        case '\'':
          int v19 = (unsigned __int8 *)&unk_186B4BA3B;
          goto LABEL_17;
        case '(':
          int v19 = (unsigned __int8 *)&unk_186B4BA43;
          goto LABEL_17;
        case ')':
          int v19 = (unsigned __int8 *)&unk_186B4BA4B;
          goto LABEL_17;
        case '+':
          int v19 = (unsigned __int8 *)&unk_186B4BAAB;
          goto LABEL_17;
        case ',':
          int v19 = (unsigned __int8 *)&unk_186B4BA53;
          goto LABEL_17;
        case '-':
          int v19 = (unsigned __int8 *)&unk_186B4BA5B;
          goto LABEL_17;
        case '.':
          int v19 = (unsigned __int8 *)&unk_186B4BA63;
          goto LABEL_17;
        case '/':
          int v19 = (unsigned __int8 *)&unk_186B4BA6B;
          goto LABEL_17;
        case ':':
          int v19 = (unsigned __int8 *)&unk_186B4BA73;
          goto LABEL_17;
        case ';':
          int v19 = (unsigned __int8 *)&unk_186B4BA9B;
          goto LABEL_17;
        case '=':
          int v19 = (unsigned __int8 *)&unk_186B4BAA3;
          goto LABEL_17;
        case '?':
          int v19 = (unsigned __int8 *)&unk_186B4BA7B;
          goto LABEL_17;
        case '@':
          int v19 = (unsigned __int8 *)&unk_186B4BA83;
          goto LABEL_17;
        default:
          if (v17 == 95)
          {
            int v19 = (unsigned __int8 *)&unk_186B4BAB3;
            goto LABEL_17;
          }

uint64_t _MorseCodeDoChar(uint64_t result, unsigned __int8 *a2)
{
  unsigned __int8 v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = result;
    vm_map_t v4 = a2 + 1;
    do
    {
      if ((*(_BYTE *)v3 & 1) != 0)
      {
        double result = (*(uint64_t (**)(void, void))(v3 + 8))(v2, *(void *)(v3 + 16));
      }

      else
      {
        switch(v2)
        {
          case 1u:
            double result = (*(uint64_t (**)(uint64_t, void))(v3 + 8))(1LL, *(void *)(v3 + 16));
            break;
          case 2u:
            (*(void (**)(uint64_t, void))(v3 + 8))(1LL, *(void *)(v3 + 16));
            useconds_t v5 = *(_DWORD *)(v3 + 24);
            goto LABEL_9;
          case 3u:
            (*(void (**)(uint64_t, void))(v3 + 8))(1LL, *(void *)(v3 + 16));
            useconds_t v5 = 3 * *(_DWORD *)(v3 + 24);
LABEL_9:
            usleep(v5);
            double result = (*(uint64_t (**)(void, void))(v3 + 8))(0LL, *(void *)(v3 + 16));
            break;
          case 4u:
            useconds_t v6 = *(_DWORD *)(v3 + 24);
            goto LABEL_14;
          case 5u:
            useconds_t v6 = 3 * *(_DWORD *)(v3 + 24);
            goto LABEL_14;
          case 6u:
            useconds_t v6 = 7 * *(_DWORD *)(v3 + 24);
LABEL_14:
            double result = usleep(v6);
            break;
          default:
            break;
        }
      }

      if (!*v4) {
        break;
      }
      double result = (*(_BYTE *)v3 & 1) != 0
      int v7 = *v4++;
      unsigned __int8 v2 = v7;
    }

    while (v7);
  }

  return result;
}

uint64_t PIDInit(uint64_t result, double a2, double a3, double a4, double a5, double a6, double a7)
{
  *(void *)(result + 8) = 0LL;
  *(double *)(result + 16) = a6;
  *(double *)(result + 24) = a7;
  *(double *)(result + 32) = a3;
  *(void *)(result + 40) = 0LL;
  *(double *)(result + 48) = 1.0 - a5;
  *(double *)(result + 56) = (1.0 - a5) * a4;
  *(double *)double result = a2;
  return result;
}

double PIDUpdate(double *a1, double a2)
{
  double v2 = *a1 * a2;
  double v3 = a1[3];
  double v4 = a1[1] + a1[4] * a2;
  a1[1] = v4;
  double v5 = v2 + v4;
  if (v5 > v3 || (double v3 = a1[2], v5 < v3))
  {
    a1[1] = v3 - v2;
    double v5 = v3;
  }

  double v6 = a1[5];
  double v7 = a2 - v6;
  a1[5] = v6 + a1[6] * v7;
  return v5 + v7 * a1[7];
}

uint64_t cced25519_make_key_pair_compat()
{
  return cced25519_make_key_pair();
}

uint64_t cced25519_sign_compat()
{
  return cced25519_sign();
}

uint64_t cced25519_verify_compat()
{
  return cced25519_verify();
}

uint64_t Curve25519MakeKeyPair(uint64_t a1, void *a2)
{
  return cccurve25519_make_pub();
}

uint64_t TDSBloomFilterAddHash(uint64_t result, uint64_t a2, unint64_t a3)
{
  unsigned int v3 = 0;
  unint64_t v4 = 8 * a2;
  do
  {
    *(_BYTE *)(result + ((a3 % v4) >> 3)) |= 1 << (~(_BYTE)a3 & 7);
    a3 /= v4;
  }

  while (v3++ < 3);
  return result;
}

unint64_t TDSBloomFilterAddString(uint64_t a1, uint64_t a2, char *__s, size_t a4)
{
  if (a4 == -1LL) {
    a4 = strlen(__s);
  }
  unint64_t result = SipHash(qword_186B4BB0E, (unsigned __int8 *)__s, a4);
  unsigned int v8 = 0;
  unint64_t v9 = 8 * a2;
  do
  {
    *(_BYTE *)(a1 + ((result % v9) >> 3)) |= 1 << (~(_BYTE)result & 7);
    result /= v9;
  }

  while (v8++ < 3);
  return result;
}

BOOL TDSBloomFilterContainsHash(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unsigned int v3 = 0;
  unint64_t v4 = 8 * a2;
  do
  {
    int v5 = (1 << (~(_BYTE)a3 & 7)) & *(unsigned __int8 *)(a1 + ((a3 % v4) >> 3));
    if (v5) {
      BOOL v6 = v3 >= 3;
    }
    else {
      BOOL v6 = 1;
    }
    ++v3;
    a3 /= v4;
  }

  while (!v6);
  return v5 != 0;
}

BOOL TDSBloomFilterContainsString(uint64_t a1, uint64_t a2, char *__s, size_t a4)
{
  if (a4 == -1LL) {
    a4 = strlen(__s);
  }
  unint64_t v7 = SipHash(qword_186B4BB0E, (unsigned __int8 *)__s, a4);
  unsigned int v8 = 0;
  unint64_t v9 = 8 * a2;
  do
  {
    int v10 = (1 << (~(_BYTE)v7 & 7)) & *(unsigned __int8 *)(a1 + ((v7 % v9) >> 3));
    if (v10) {
      BOOL v11 = v8 >= 3;
    }
    else {
      BOOL v11 = 1;
    }
    ++v8;
    v7 /= v9;
  }

  while (!v11);
  return v10 != 0;
}

uint64_t _NetPerfGetTypeID()
{
  uint64_t result = _CFRuntimeRegisterClass();
  gNetPerfCFTypeID TypeID = result;
  return result;
}

void _NetPerfFinalize(void *a1)
{
  double v2 = (dispatch_object_s *)a1[2];
  if (v2)
  {
    dispatch_release(v2);
    a1[2] = 0LL;
  }

  unsigned int v3 = (dispatch_object_s *)a1[5];
  if (v3)
  {
    dispatch_release(v3);
    a1[5] = 0LL;
  }

  unint64_t v4 = (const void *)a1[6];
  if (v4)
  {
    CFRelease(v4);
    a1[6] = 0LL;
  }

uint64_t NetPerfCreate(void *a1)
{
  if (gNetPerfInitOnce != -1) {
    dispatch_once_f(&gNetPerfInitOnce, 0LL, (dispatch_function_t)_NetPerfGetTypeID);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294960568LL;
  }
  unsigned int v3 = (void *)Instance;
  *(_OWORD *)(Instance + 144) = 0u;
  *(_OWORD *)(Instance + 160) = 0u;
  *(_OWORD *)(Instance + 224) = 0u;
  *(_OWORD *)(Instance + 240) = 0u;
  *(_OWORD *)(Instance + 192) = 0u;
  *(_OWORD *)(Instance + 208) = 0u;
  *(_OWORD *)(Instance + 176) = 0u;
  *(_OWORD *)(Instance + 112) = 0u;
  *(_OWORD *)(Instance + 128) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(void *)(Instance + 84) = -1LL;
  *(void *)(Instance + 152) = -1LL;
  *(_DWORD *)(Instance + 160) = -1;
  dispatch_queue_t v4 = dispatch_queue_create("NetPerfControl", 0LL);
  v3[2] = v4;
  if (!v4)
  {
    CFRelease(v3);
    return 4294960568LL;
  }

  uint64_t v5 = MEMORY[0x1895F8AE0];
  dispatch_retain(MEMORY[0x1895F8AE0]);
  BOOL v6 = (dispatch_object_s *)v3[5];
  if (v6) {
    dispatch_release(v6);
  }
  uint64_t result = 0LL;
  v3[5] = v5;
  *a1 = v3;
  return result;
}

void NetPerfSetEventHandler(void *a1, uint64_t a2, uint64_t a3, dispatch_object_s *a4)
{
  a1[3] = a2;
  a1[4] = a3;
  if (a4) {
    uint64_t v5 = a4;
  }
  else {
    uint64_t v5 = (dispatch_object_s *)MEMORY[0x1895F8AE0];
  }
  dispatch_retain(v5);
  BOOL v6 = (dispatch_object_s *)a1[5];
  if (v6) {
    dispatch_release(v6);
  }
  a1[5] = v5;
}

uint64_t _NetPerfControl( unint64_t a1, int a2, CFStringRef theString1, uint64_t a4, const __CFDictionary *a5, __CFDictionary **a6)
{
  if (CFStringCompare(theString1, @"startClientSession", 0LL) == kCFCompareEqualTo)
  {
    if (*(_DWORD *)(a1 + 80)) {
      return 4294960575LL;
    }
    if (a5)
    {
      *(_OWORD *)(a1 + 232) = xmmword_186B49C70;
      *(void *)(a1 + 248) = 0xBFF0000000000000LL;
      *(void *)(a1 + 216) = 0LL;
      *(void *)(a1 + 192) = 0LL;
      if (SecondsToUpTicks_sOnce != -1) {
        dispatch_once_f( &SecondsToUpTicks_sOnce,  &SecondsToUpTicks_sMultiplier,  (dispatch_function_t)_SecondsToUpTicksInit);
      }
      *(void *)(a1 + 224) = SecondsToUpTicks_sMultiplier;
      *(void *)(a1 + 176) = 1500LL;
      BOOL v11 = calloc(1uLL, 0x5DCuLL);
      *(void *)(a1 + 168) = v11;
      if (v11)
      {
        unsigned int v22 = HTTPClientCreate((uint64_t *)(a1 + 56));
        if (!v22)
        {
          HTTPClientSetDispatchQueue(*(void *)(a1 + 56), *(dispatch_object_s **)(a1 + 16));
          *(_DWORD *)(*(void *)(a1 + 56) + 84LL) |= 0x81u;
          unsigned int v12 = CFDictionaryCopyCString(a5, @"destination", &v22);
          if (!v22)
          {
            unsigned int v13 = v12;
            unsigned int v22 = HTTPClientSetDestination(*(void *)(a1 + 56), v12, 5000);
            free(v13);
            if (!v22)
            {
              unsigned int v22 = HTTPMessageCreate((uint64_t *)(a1 + 64));
              if (!v22)
              {
                uint64_t v20 = *(void *)(a1 + 64);
                *(void *)(v20 + 9672) = a1;
                *(void *)(v20 + 9712) = _NetPerfClientHandleControlCompletion;
                CFRetain((CFTypeRef)a1);
                *(_DWORD *)(a1 + 80) = 1;
                _NetPerfClientRunStateMachine(a1);
                return 0LL;
              }
            }
          }
        }

        goto LABEL_16;
      }

      int v21 = -6728;
    }

    else
    {
      int v21 = -6705;
    }

    unsigned int v22 = v21;
LABEL_16:
    _NetPerfClientStop((CFTypeRef)a1);
    uint64_t v10 = v22;
    if (v22) {
      return v10;
    }
    return 0LL;
  }

  if (CFStringCompare(theString1, @"stopClientSession", 0LL) == kCFCompareEqualTo)
  {
    _NetPerfClientStop((CFTypeRef)a1);
    return 0LL;
  }

  if (CFStringCompare(theString1, @"setUpServerSession", 0LL) == kCFCompareEqualTo)
  {
    if (*(_BYTE *)(a1 + 128))
    {
      uint64_t v10 = 4294960577LL;
    }

    else
    {
      *(_DWORD *)(a1 + 184) = 0;
      *(void *)(a1 + 192) = 0LL;
      *(void *)(a1 + 200) = 0LL;
      *(_DWORD *)(a1 + 208) = 0;
      *(void *)(a1 + 176) = 1500LL;
      unsigned __int8 v14 = calloc(1uLL, 0x5DCuLL);
      *(void *)(a1 + 168) = v14;
      if (v14)
      {
        int v15 = (int *)(a1 + 156);
        uint64_t v16 = (int *)(a1 + 160);
        uint64_t v10 = ServerSocketPairOpen(2, 17, 0, &v23, -1, (int *)(a1 + 156), (int *)(a1 + 160));
        if ((_DWORD)v10) {
          goto LABEL_28;
        }
        if ((*v15 & 0x80000000) == 0)
        {
          SocketSetP2P(*v15, 1);
          SocketSetPacketTimestamps(*v15, 1);
        }

        if ((*v16 & 0x80000000) == 0)
        {
          SocketSetP2P(*v16, 1);
          SocketSetPacketTimestamps(*v16, 1);
        }

        uint64_t v10 = OpenSelfConnectedLoopbackSocket((int *)(a1 + 152));
        if ((_DWORD)v10) {
          goto LABEL_28;
        }
        uint64_t v10 = pthread_create( (pthread_t *)(a1 + 136),  0LL,  (void *(__cdecl *)(void *))_NetPerfServerDataThread,  (void *)a1);
        if ((_DWORD)v10) {
          goto LABEL_28;
        }
        *(void *)(a1 + 144) = a1 + 136;
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
        if (Mutable)
        {
          int v19 = Mutable;
          CFDictionarySetInt64(Mutable, @"port", v23);
          *(_BYTE *)(a1 + 128) = 1;
          CFRetain((CFTypeRef)a1);
          *a6 = v19;
          return 0LL;
        }
      }

      uint64_t v10 = 4294960568LL;
    }

CFTypeID _NetPerfClientHandleControlCompletion(CFTypeID result)
{
  if (!*(_DWORD *)(result + 9648))
  {
    CFTypeID v1 = result;
    unint64_t v2 = *(void *)(result + 9672);
    unsigned int v3 = *(const void **)(v2 + 72);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(v2 + 72) = 0LL;
    }

    CFIndex v4 = *(void *)(v1 + 8528);
    if (!v4) {
      return _NetPerfClientRunStateMachine(v2);
    }
    uint64_t result = (CFTypeID)CFDataCreate(0LL, *(const UInt8 **)(v1 + 8520), v4);
    if (result)
    {
      uint64_t v5 = (const void *)result;
      *(void *)(v2 + 72) = CFPropertyListCreateWithData(0LL, (CFDataRef)result, 0LL, 0LL, 0LL);
      CFRelease(v5);
      uint64_t result = *(void *)(v2 + 72);
      if (result)
      {
        CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
        uint64_t result = CFDictionaryGetTypeID();
        if (v6 == result) {
          return _NetPerfClientRunStateMachine(v2);
        }
      }
    }
  }

  return result;
}

unint64_t _NetPerfClientRunStateMachine(unint64_t result)
{
  uint64_t v1 = result;
  unint64_t v2 = (int *)(result + 84);
  unsigned int v3 = (pthread_t *)(result + 112);
  CFIndex v4 = (pthread_t *)(result + 96);
  for (int i = *(_DWORD *)(result + 80); i == 3; int i = 4)
  {
    uint64_t result = OpenSelfConnectedLoopbackSocket(v2);
    if ((_DWORD)result) {
      return result;
    }
    uint64_t result = pthread_create(v3, 0LL, (void *(__cdecl *)(void *))_NetPerfClientReceiveThread, (void *)v1);
    if ((_DWORD)result) {
      return result;
    }
    *(void *)(v1 + 120) = v3;
    uint64_t result = pthread_create(v4, 0LL, (void *(__cdecl *)(void *))_NetPerfClientSendThread, (void *)v1);
    if ((_DWORD)result) {
      return result;
    }
    *(void *)(v1 + 104) = v4;
    *(_DWORD *)(v1 + 80) = 4;
  }

  if (i == 2)
  {
    unint64_t v7 = *(const __CFDictionary **)(v1 + 72);
    uint64_t result = HTTPClientGetPeerAddress(*(void *)(v1 + 56), &v10, 0x1Cu, &v9);
    if (!(_DWORD)result)
    {
      unsigned int v8 = (int *)(v1 + 88);
      uint64_t result = ServerSocketOpenEx2(v10.sa_family, 2, 17, 0LL, 0, -6100, 0LL, -1, 0, (int *)(v1 + 88));
      int v11 = result;
      if (!(_DWORD)result)
      {
        SocketSetP2P(*v8, 1);
        uint64_t result = SocketSetPacketTimestamps(*v8, 1);
        if (v7)
        {
          uint64_t result = CFDictionaryGetInt64(v7, @"port", &v11);
          if (!v11)
          {
            if (v10.sa_family == 30 || v10.sa_family == 2) {
              *(_WORD *)v10.sa_data = bswap32(result) >> 16;
            }
            int v11 = connect(*v8, &v10, v9);
            if (!v11
              || (uint64_t result = (unint64_t)__error(), *(_DWORD *)result)
              && (uint64_t result = (unint64_t)__error(), !*(_DWORD *)result))
            {
              uint64_t result = _NetPerfClientSendControlMessage(v1, @"startServerSession");
              if (!(_DWORD)result)
              {
                int v6 = 3;
                goto LABEL_11;
              }
            }
          }
        }
      }
    }
  }

  else if (i == 1)
  {
    uint64_t result = _NetPerfClientSendControlMessage(v1, @"setUpServerSession");
    if (!(_DWORD)result)
    {
      int v6 = 2;
LABEL_11:
      *(_DWORD *)(v1 + 80) = v6;
    }
  }

  return result;
}

void _NetPerfClientStop(CFTypeRef cf)
{
  if (*((void *)cf + 13))
  {
    SendSelfConnectedLoopbackMessage(*((_DWORD *)cf + 21), "q", 1uLL);
    pthread_join(*((pthread_t *)cf + 12), 0LL);
    *((void *)cf + 13) = 0LL;
  }

  if (*((void *)cf + 15))
  {
    SendSelfConnectedLoopbackMessage(*((_DWORD *)cf + 21), "q", 1uLL);
    pthread_join(*((pthread_t *)cf + 14), 0LL);
    *((void *)cf + 15) = 0LL;
  }

  unint64_t v2 = (dispatch_queue_t *)*((void *)cf + 7);
  if (v2)
  {
    CFRetain(*((CFTypeRef *)cf + 7));
    dispatch_async_f(v2[2], v2, (dispatch_function_t)_HTTPClientInvalidate);
    CFRelease(*((CFTypeRef *)cf + 7));
    *((void *)cf + 7) = 0LL;
  }

  unsigned int v3 = (const void *)*((void *)cf + 8);
  if (v3)
  {
    CFRelease(v3);
    *((void *)cf + 8) = 0LL;
  }

  CFIndex v4 = (const void *)*((void *)cf + 9);
  if (v4)
  {
    CFRelease(v4);
    *((void *)cf + 9) = 0LL;
  }

  int v5 = *((_DWORD *)cf + 21);
  if ((v5 & 0x80000000) == 0)
  {
    if (close(v5) && *__error()) {
      __error();
    }
    *((_DWORD *)cf + 21) = -1;
  }

  int v6 = *((_DWORD *)cf + 22);
  if ((v6 & 0x80000000) == 0)
  {
    if (close(v6) && *__error()) {
      __error();
    }
    *((_DWORD *)cf + 22) = -1;
  }

  unint64_t v7 = (void *)*((void *)cf + 21);
  if (v7)
  {
    free(v7);
    *((void *)cf + 21) = 0LL;
  }

  if (*((_DWORD *)cf + 20))
  {
    uint64_t v8 = *((void *)cf + 3);
    if (v8)
    {
      uint64_t v9 = malloc(0x20uLL);
      if (v9)
      {
        sockaddr v10 = v9;
        *(_DWORD *)uint64_t v9 = 4;
        v9[1] = 0LL;
        v9[2] = v8;
        int v11 = (dispatch_queue_s *)*((void *)cf + 5);
        v10[3] = *((void *)cf + 4);
        dispatch_async_f(v11, v10, (dispatch_function_t)_PostEventOnEventQueue);
      }
    }

    *((_DWORD *)cf + 20) = 0;
    CFRelease(cf);
  }

uint64_t _NetPerfServerDataThread(_DWORD *a1)
{
  unint64_t v2 = a1[39];
  unint64_t v1 = a1[40];
  int v3 = a1[38];
  SetCurrentThreadPriority(62);
  memset(&v16, 0, sizeof(v16));
  else {
    int v4 = v2;
  }
  int v15 = 1 << v2;
  if (v4 <= v3) {
    int v4 = v3;
  }
  unint64_t v5 = v2 >> 5;
  int v6 = 1 << v1;
  unint64_t v7 = v1 >> 5;
  if (v4 < 0) {
    int v4 = -1;
  }
  int v8 = v4 + 1;
  int v9 = 1 << v3;
  unint64_t v10 = (unint64_t)v3 >> 5;
  do
  {
    while (1)
    {
      if ((v2 & 0x80000000) == 0 && __darwin_check_fd_set_overflow(v2, &v16, 0)) {
        v16.fds_bits[v5] |= v15;
      }
      if ((v1 & 0x80000000) == 0 && __darwin_check_fd_set_overflow(v1, &v16, 0)) {
        v16.fds_bits[v7] |= v6;
      }
      if (__darwin_check_fd_set_overflow(v3, &v16, 0)) {
        v16.fds_bits[v10] |= v9;
      }
      int v11 = select(v8, &v16, 0LL, 0LL, 0LL);
      if (v11 > 0) {
        break;
      }
      if (v11 && *__error())
      {
        int v12 = *__error();
        if (!v12) {
          break;
        }
        if (v12 == 4) {
          continue;
        }
      }

      sleep(1u);
    }

    if ((v2 & 0x80000000) == 0 && __darwin_check_fd_set_overflow(v2, &v16, 0) && (v16.fds_bits[v5] & v15) != 0) {
      _NetPerfServerDataHandler((uint64_t)a1, v2);
    }
    if ((v1 & 0x80000000) == 0 && __darwin_check_fd_set_overflow(v1, &v16, 0) && (v16.fds_bits[v7] & v6) != 0) {
      _NetPerfServerDataHandler((uint64_t)a1, v1);
    }
  }

  while (!__darwin_check_fd_set_overflow(v3, &v16, 0) || (v16.fds_bits[v10] & v9) == 0);
  return 0LL;
}

void _NetPerfServerSessionTearDown(CFTypeRef cf)
{
  if (*((void *)cf + 18))
  {
    SendSelfConnectedLoopbackMessage(*((_DWORD *)cf + 38), "q", 1uLL);
    pthread_join(*((pthread_t *)cf + 17), 0LL);
    *((void *)cf + 18) = 0LL;
  }

  int v2 = *((_DWORD *)cf + 38);
  if ((v2 & 0x80000000) == 0)
  {
    if (close(v2) && *__error()) {
      __error();
    }
    *((_DWORD *)cf + 38) = -1;
  }

  int v3 = *((_DWORD *)cf + 39);
  if ((v3 & 0x80000000) == 0)
  {
    if (close(v3) && *__error()) {
      __error();
    }
    *((_DWORD *)cf + 39) = -1;
  }

  int v4 = *((_DWORD *)cf + 40);
  if ((v4 & 0x80000000) == 0)
  {
    if (close(v4) && *__error()) {
      __error();
    }
    *((_DWORD *)cf + 40) = -1;
  }

  unint64_t v5 = (void *)*((void *)cf + 21);
  if (v5)
  {
    free(v5);
    *((void *)cf + 21) = 0LL;
  }

  if (*((_BYTE *)cf + 128))
  {
    *((_BYTE *)cf + 128) = 0;
    CFRelease(cf);
  }

int *_NetPerfServerDataHandler(uint64_t a1, int a2)
{
  int v4 = *(int32x2_t **)(a1 + 168);
  uint64_t result = (int *)SocketRecvFrom(a2, (uint64_t)v4, *(void *)(a1 + 176), &v14, &v13, 0x1Cu, &v12, &v11, 0LL, 0LL);
  if ((_DWORD)result) {
    return result;
  }
  unint64_t v6 = UpTicksToNTP(v11);
  unsigned int v7 = bswap32(v4->i32[0]);
  int v8 = *(_DWORD *)(a1 + 184);
  int v9 = v7 - (v8 + 1);
  if (v7 == v8 + 1) {
    goto LABEL_5;
  }
  if (v9 >= 1)
  {
    *(_DWORD *)(a1 + 204) += v9;
LABEL_5:
    *(_DWORD *)(a1 + 184) = v7;
    goto LABEL_6;
  }

  if (v7 == v8) {
    ++*(_DWORD *)(a1 + 208);
  }
  else {
    ++*(_DWORD *)(a1 + 200);
  }
LABEL_6:
  ++*(void *)(a1 + 192);
  v4[1] = v4[3];
  v4[2] = (int32x2_t)bswap64(v6);
  uint64_t v10 = mach_absolute_time();
  v4[3] = (int32x2_t)bswap64(UpTicksToNTP(v10));
  v4[4] = vrev64_s32((int32x2_t)vrev32_s8(*(int8x8_t *)(a1 + 200)));
  v4[5].i32[0] = bswap32(*(_DWORD *)(a1 + 208));
  uint64_t result = (int *)sendto(a2, v4, 0x30uLL, 0, &v13, v12);
  if (result != (int *)48)
  {
    uint64_t result = __error();
    if (*result) {
      return __error();
    }
  }

  return result;
}

void _PostEventOnEventQueue(unsigned int *a1)
{
  int v2 = (const void *)*((void *)a1 + 1);
  if (v2) {
    CFRelease(v2);
  }
  free(a1);
}

uint64_t _NetPerfClientSendControlMessage(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (!Mutable) {
    return 4294960568LL;
  }
  unint64_t v6 = Mutable;
  CFDictionarySetValue(Mutable, @"controlCommand", a2);
  Data = CFPropertyListCreateData(0LL, v6, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL);
  CFRelease(v6);
  if (!Data) {
    return 4294960596LL;
  }
  HTTPHeader_InitRequestF(v4 + 24, "HTTP/1.1", (uint64_t)"POST", (uint64_t)"%s", v8, v9, v10, v11, (uint64_t)"/perf");
  BytePtr = CFDataGetBytePtr(Data);
  size_t Length = CFDataGetLength(Data);
  uint64_t v14 = HTTPMessageSetBody(v4, (uint64_t)"application/x-apple-binary-plist", BytePtr, Length);
  CFRelease(Data);
  if ((_DWORD)v14) {
    return v14;
  }
  return HTTPClientSendMessage(*(dispatch_queue_t **)(a1 + 56), v4, v15, v16, v17, v18, v19, v20);
}

uint64_t _NetPerfClientReceiveThread(uint64_t a1)
{
  int v3 = *(_DWORD *)(a1 + 84);
  int v2 = *(_DWORD *)(a1 + 88);
  SetCurrentThreadPriority(62);
  memset(&v24, 0, 32);
  if (v2 <= v3) {
    int v4 = v3;
  }
  else {
    int v4 = v2;
  }
  if (v4 < 0) {
    int v4 = -1;
  }
  memset(&v24.fds_bits[8], 0, 96);
  int v5 = v4 + 1;
  int v6 = 1 << v2;
  unint64_t v7 = (unint64_t)v2 >> 5;
  int v8 = 1 << v3;
  unint64_t v9 = (unint64_t)v3 >> 5;
  int v23 = v4 + 1;
  do
  {
    while (1)
    {
      if (__darwin_check_fd_set_overflow(v2, &v24, 0)) {
        v24.fds_bits[v7] |= v6;
      }
      if (__darwin_check_fd_set_overflow(v3, &v24, 0)) {
        v24.fds_bits[v9] |= v8;
      }
      int v10 = select(v5, &v24, 0LL, 0LL, 0LL);
      if (v10 > 0) {
        break;
      }
      if (v10 && *__error())
      {
        int v21 = *__error();
        if (!v21) {
          break;
        }
        if (v21 == 4) {
          continue;
        }
      }

      sleep(1u);
    }

    if (__darwin_check_fd_set_overflow(v2, &v24, 0))
    {
      if ((v24.fds_bits[v7] & v6) != 0)
      {
        uint64_t v11 = *(void *)(a1 + 168);
        if (!SocketRecvFrom(v2, v11, *(void *)(a1 + 176), v26, 0LL, 0, 0LL, &v25, 0LL, 0LL))
        {
          ++*(void *)(a1 + 192);
          unint64_t v12 = bswap64(*(void *)(v11 + 8));
          unint64_t v13 = bswap64(*(void *)(v11 + 16));
          unint64_t v14 = bswap64(*(void *)(v11 + 24));
          unint64_t v15 = UpTicksToNTP(v25);
          double v16 = (double)(uint64_t)(v15 - v12) * 2.32830644e-10 - (double)(uint64_t)(v14 - v13) * 2.32830644e-10;
          double v17 = *(double *)(a1 + 232);
          if (v16 < v17)
          {
            *(double *)(a1 + 232) = v16;
            double v17 = (double)(uint64_t)(v15 - v12) * 2.32830644e-10 - (double)(uint64_t)(v14 - v13) * 2.32830644e-10;
          }

          double v18 = *(double *)(a1 + 240);
          if (v16 > v18)
          {
            *(double *)(a1 + 240) = v16;
            double v18 = (double)(uint64_t)(v15 - v12) * 2.32830644e-10 - (double)(uint64_t)(v14 - v13) * 2.32830644e-10;
          }

          double v19 = *(double *)(a1 + 248);
          if (v19 >= 0.0) {
            double v20 = v16 * 0.1 + v19 * 0.9;
          }
          else {
            double v20 = (double)(uint64_t)(v15 - v12) * 2.32830644e-10 - (double)(uint64_t)(v14 - v13) * 2.32830644e-10;
          }
          *(double *)(a1 + 248) = v20;
          int v6 = 1 << v2;
          int v5 = v23;
          int v8 = 1 << v3;
          if (v16 <= v20 * 3.0)
          {
            if (v25 >= *(void *)(a1 + 216))
            {
              fprintf( (FILE *)*MEMORY[0x1895F89E0],  "%4llu: Min RTT %10f ms, Max RTT %10f, Avg RTT %10f, Recent RTT %10f Lost %u%s\n",  *(void *)(a1 + 192),  v17 * 1000.0,  v18 * 1000.0,  v20 * 1000.0,  v16 * 1000.0,  bswap32(*(_DWORD *)(v11 + 32)),  "");
              *(void *)(a1 + 216) = *(void *)(a1 + 224) + v25;
            }
          }

          else
          {
            fprintf( (FILE *)*MEMORY[0x1895F89E0],  "%4llu: Min RTT %10f ms, Max RTT %10f, Avg RTT %10f, Recent RTT %10f Lost %u%s\n",  *(void *)(a1 + 192),  v17 * 1000.0,  v18 * 1000.0,  v20 * 1000.0,  v16 * 1000.0,  bswap32(*(_DWORD *)(v11 + 32)),  " (bad)");
          }
        }
      }
    }
  }

  while (!__darwin_check_fd_set_overflow(v3, &v24, 0) || (v24.fds_bits[v9] & v8) == 0);
  return 0LL;
}

uint64_t _NetPerfClientSendThread(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 88);
  SetCurrentThreadPriority(62);
  uint64_t v2 = mach_absolute_time();
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  unint64_t v3 = UpTicksPerSecond_sTicksPerSecond / 0x3CuLL;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  unint64_t v12 = 0LL;
  uint64_t v4 = v2 + UpTicksPerSecond_sTicksPerSecond / 0x3CuLL;
  for (unsigned int i = 1; ; ++i)
  {
    unsigned int v8 = bswap32(i);
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    int v11 = 0;
    uint64_t v6 = mach_absolute_time();
    unint64_t v12 = bswap64(UpTicksToNTP(v6));
    if (send(v1, &v8, 0x30uLL, 0) != 48 && (!*__error() || *__error())) {
      break;
    }
    SleepUntilUpTicks(v4);
    v4 += v3;
  }

  return 0LL;
}

uint64_t NetSocketChaCha20Poly1305Configure(void *a1, _OWORD *a2, void *a3, _OWORD *a4, void *a5)
{
  uint64_t v10 = (_OWORD *)a1[12];
  if (!v10)
  {
    uint64_t v10 = calloc(1uLL, 0x8278uLL);
    if (!v10) {
      return 4294960568LL;
    }
    a1[12] = v10;
  }

  __int128 v11 = a2[1];
  v10[16] = *a2;
  v10[17] = v11;
  if (a3) {
    *((void *)v10 + 36) = *a3;
  }
  __int128 v12 = a4[1];
  *(_OWORD *)((char *)v10 + 16936) = *a4;
  *(_OWORD *)((char *)v10 + 16952) = v12;
  if (a5) {
    *((void *)v10 + 2121) = *a5;
  }
  uint64_t result = 0LL;
  a1[3] = _NetSocketTransportRead;
  a1[4] = _NetSocketTransportWrite;
  a1[5] = _NetSocketTransportWriteV;
  a1[6] = NetSocket_WriteFileSlow;
  a1[7] = _NetSocketTransportFree;
  return result;
}

uint64_t _NetSocketTransportRead( uint64_t a1, size_t a2, size_t a3, char *__dst, size_t *a5, uint64_t a6, unsigned int a7)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)a1 != 1853058915)
  {
    size_t v15 = 0LL;
    uint64_t v32 = 4294960556LL;
    goto LABEL_42;
  }

  if (*(_BYTE *)(a1 + 8))
  {
    size_t v15 = 0LL;
    uint64_t v32 = 4294960573LL;
    goto LABEL_42;
  }

  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
  {
    size_t v15 = 0LL;
    uint64_t v32 = 4294960551LL;
    goto LABEL_42;
  }

  uint64_t v9 = __dst;
  size_t v10 = a3;
  uint64_t v11 = *(void *)(a1 + 96);
  __int128 v12 = *(const void **)(a1 + 64);
  size_t v13 = *(void *)(a1 + 72) - (void)v12;
  if (v13)
  {
    if (v13 >= a3) {
      size_t v14 = a3;
    }
    else {
      size_t v14 = *(void *)(a1 + 72) - (void)v12;
    }
    memcpy(__dst, v12, v14);
    size_t v15 = v14;
    *(void *)(a1 + 64) += v14;
    v10 -= v14;
    if (v14 >= a2 || v10 == 0) {
      goto LABEL_40;
    }
    v9 += v14;
  }

  else
  {
    size_t v15 = 0LL;
  }

  double v17 = *(const void **)(v11 + 33384);
  size_t v18 = *(void *)(v11 + 33392) - (void)v17;
  if (v18)
  {
    if (v18 >= v10) {
      size_t v19 = v10;
    }
    else {
      size_t v19 = *(void *)(v11 + 33392) - (void)v17;
    }
    size_t v20 = v15;
    memcpy(v9, v17, v19);
    *(void *)(v11 + 33384) += v19;
    size_t v15 = v19 + v20;
    v10 -= v19;
    if (v10) {
      BOOL v21 = v15 >= a2;
    }
    else {
      BOOL v21 = 1;
    }
    if (!v21)
    {
      size_t v38 = (void *)(v11 + 33384);
      unsigned int v22 = a7;
      v9 += v19;
      goto LABEL_25;
    }

uint64_t _NetSocketTransportWrite(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4)
{
  v5[2] = *MEMORY[0x1895F89C0];
  v5[0] = a2;
  v5[1] = a3;
  return _NetSocketTransportWriteV(a1, v5, 1, a4);
}

uint64_t _NetSocketTransportWriteV(uint64_t a1, unint64_t *a2, int a3, unsigned int a4)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  if (*(_BYTE *)(a1 + 8)) {
    return 4294960573LL;
  }
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0) {
    return 4294960551LL;
  }
  uint64_t v4 = a2;
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = (unsigned int *)(v5 + 16976);
  unint64_t v7 = (int8x16_t *)(v5 + 16978);
  unint64_t v8 = v5 + 33362;
  unint64_t v9 = (unint64_t)&a2[2 * a3];
  size_t v10 = (int32x4_t *)(v5 + 16680);
  uint64_t v33 = (_DWORD *)(v5 + 16936);
  unint64_t v34 = (int8x16_t *)(v5 + 16978);
  uint64_t v11 = (_DWORD *)(v5 + 16968);
  uint64_t v35 = v5;
  uint64_t v32 = (unsigned int *)(v5 + 16816);
  uint64_t v29 = (char *)(v5 + 16976);
  while (1)
  {
    uint64_t v12 = 0LL;
    size_t v13 = v7;
    unint64_t v14 = (unint64_t)v4;
    while (1)
    {
      unint64_t v15 = *(void *)(v14 + 8);
      v12 += v15;
      size_t v13 = (int8x16_t *)((char *)v13 + v15);
      v14 += 16LL;
      if (v14 >= v9)
      {
        if (!v12) {
          return 0LL;
        }
        goto LABEL_12;
      }
    }

    v12 += v8 - (void)v13;
    if (!v12) {
      return 0LL;
    }
LABEL_12:
    chacha20_poly1305_init_64x64(v10, v33, v11);
    *(_WORD *)uint64_t v6 = v12;
    poly1305_update(v32, v6, 2uLL);
    *(void *)(v35 + 16912) += 2LL;
    double v16 = v4 + 1;
    double v17 = v7;
    while (1)
    {
      uint64_t v4 = v16 - 1;
      size_t v18 = (int8x16_t *)*(v16 - 1);
      unint64_t v19 = v8 - (void)v17;
      unint64_t v20 = chacha20_poly1305_encrypt((uint64_t)v10, v18, *v16, v7);
      BOOL v21 = v16 + 2;
      double v17 = (int8x16_t *)((char *)v17 + *v16);
      unint64_t v7 = (int8x16_t *)((char *)v7 + v20);
      BOOL v22 = (unint64_t)(v16 + 1) >= v9;
      v16 += 2;
      if (v22)
      {
        uint64_t v4 = v21 - 1;
        goto LABEL_18;
      }
    }

    unint64_t v23 = chacha20_poly1305_encrypt((uint64_t)v10, v18, v8 - (void)v17, v7);
    *(v16 - 1) += v19;
    *v16 -= v19;
    unint64_t v7 = (int8x16_t *)((char *)v7 + v23);
LABEL_18:
    fd_set v24 = &v7->i8[chacha20_poly1305_final((unsigned int *)v10, v7, (uint64_t)&v36)];
    unint64_t v7 = v34;
    unint64_t v26 = 0LL;
    *(_OWORD *)fd_set v24 = v36;
    do
    {
      __int16 v27 = (*((_BYTE *)v11 + v26))++ + 1;
      if ((v27 & 0x100) == 0) {
        break;
      }
      BOOL v22 = v26++ >= 7;
    }

    while (!v22);
    uint64_t v6 = (unsigned int *)v29;
    uint64_t result = NetSocket_WriteInternal(a1, v29, v24 - v29 + 16, a4);
    if ((_DWORD)result) {
      return result;
    }
  }

void _NetSocketTransportFree(uint64_t a1)
{
  int v1 = *(void **)(a1 + 96);
  if (v1)
  {
    memset_s(*(void **)(a1 + 96), 0x8278uLL, 0, 0x8278uLL);
    free(v1);
    *(void *)(a1 + 96) = 0LL;
  }

void NetSocketGCM_Configure(void *a1, void *a2, __n128 *a3, void *a4, __n128 *a5)
{
  size_t v10 = (_CCCryptor **)a1[12];
  if (!v10)
  {
    uint64_t v11 = (_CCCryptor **)calloc(1uLL, 0x40040uLL);
    if (!v11) {
      return;
    }
    size_t v10 = v11;
    a1[12] = v11;
  }

  AES_GCM_Final(v10);
  AES_GCM_InitEx(v10, 1u, a2, a3);
  if (!v12)
  {
    AES_GCM_Final(v10 + 3);
    AES_GCM_InitEx(v10 + 3, 0, a4, a5);
    if (!v13)
    {
      a1[3] = _NetSocketGCM_Read;
      a1[4] = _NetSocketGCM_Write;
      a1[5] = _NetSocketGCM_WriteV;
      a1[6] = NetSocket_WriteFileSlow;
      a1[7] = _NetSocketGCM_Free;
    }
  }

uint64_t _NetSocketGCM_Read( uint64_t a1, size_t a2, size_t a3, char *__dst, size_t *a5, uint64_t a6, unsigned int a7)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)a1 != 1853058915)
  {
    size_t v14 = 0LL;
    uint64_t result = 4294960556LL;
    goto LABEL_42;
  }

  if (*(_BYTE *)(a1 + 8))
  {
    size_t v14 = 0LL;
    uint64_t result = 4294960573LL;
    goto LABEL_42;
  }

  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
  {
    size_t v14 = 0LL;
    uint64_t result = 4294960551LL;
    goto LABEL_42;
  }

  unint64_t v9 = __dst;
  size_t v10 = a3;
  uint64_t v11 = *(void *)(a1 + 96);
  int v12 = *(const void **)(a1 + 64);
  size_t v13 = *(void *)(a1 + 72) - (void)v12;
  if (v13)
  {
    if (v13 >= a3) {
      size_t v14 = a3;
    }
    else {
      size_t v14 = *(void *)(a1 + 72) - (void)v12;
    }
    memcpy(__dst, v12, v14);
    *(void *)(a1 + 64) += v14;
    v10 -= v14;
    if (v14 >= a2 || v10 == 0) {
      goto LABEL_41;
    }
    v9 += v14;
  }

  else
  {
    size_t v14 = 0LL;
  }

  double v16 = (void *)(v11 + 262192);
  double v17 = *(const void **)(v11 + 262192);
  size_t v18 = *(void *)(v11 + 262200) - (void)v17;
  if (v18)
  {
    if (v18 >= v10) {
      size_t v19 = v10;
    }
    else {
      size_t v19 = *(void *)(v11 + 262200) - (void)v17;
    }
    memcpy(v9, v17, v19);
    *v16 += v19;
    v14 += v19;
    v10 -= v19;
    if (v10) {
      BOOL v20 = v14 >= a2;
    }
    else {
      BOOL v20 = 1;
    }
    if (!v20)
    {
      v9 += v19;
      goto LABEL_24;
    }

uint64_t _NetSocketGCM_Write(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  v5[2] = *MEMORY[0x1895F89C0];
  v5[0] = a2;
  v5[1] = a3;
  return _NetSocketGCM_WriteV(a1, v5, 1, a4);
}

uint64_t _NetSocketGCM_WriteV(uint64_t a1, void *a2, int a3, unsigned int a4)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  if (*(_BYTE *)(a1 + 8)) {
    return 4294960573LL;
  }
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0) {
    return 4294960551LL;
  }
  uint64_t v6 = a2;
  unint64_t v7 = (unint64_t)&a2[2 * a3];
  uint64_t v8 = *(void *)(a1 + 96);
  uint64_t v9 = v8 + 48;
  uint64_t v10 = v8 + 262192;
  uint64_t v11 = (uint64_t *)(v8 + 24);
  while ((unint64_t)v6 < v7)
  {
    unsigned int v12 = 0;
    unint64_t v13 = (unint64_t)v6;
    uint64_t v14 = v9;
    while (1)
    {
      unint64_t v15 = *(void *)(v13 + 8);
      if (v10 - v14 < v15) {
        break;
      }
      v12 += v15;
      v14 += v15;
      v13 += 16LL;
      if (v13 >= v7) {
        goto LABEL_11;
      }
    }

    v12 += v10 - v14;
LABEL_11:
    uint64_t result = AES_GCM_InitMessage((uint64_t)v11, 0LL);
    if (!(_DWORD)result)
    {
      unsigned int v24 = bswap32(v12);
      uint64_t result = CCCryptorGCMAddAAD();
      if (!(_DWORD)result)
      {
        double v17 = v6 + 1;
        uint64_t v18 = v9;
        while (1)
        {
          uint64_t v6 = v17 - 1;
          uint64_t v19 = *(v17 - 1);
          uint64_t v20 = v10 - v18;
          uint64_t v21 = *v11;
          uint64_t result = MEMORY[0x186E41AF0](v21, v19);
          if ((_DWORD)result) {
            return result;
          }
          BOOL v22 = v17 + 2;
          v18 += *v17;
          BOOL v23 = (unint64_t)(v17 + 1) >= v7;
          v17 += 2;
          if (v23)
          {
            uint64_t v6 = v22 - 1;
            goto LABEL_21;
          }
        }

        uint64_t result = MEMORY[0x186E41AF0](v21, v19, v10 - v18, v18);
        if ((_DWORD)result) {
          return result;
        }
        *(v17 - 1) += v20;
        *v17 -= v20;
        uint64_t v18 = v10;
LABEL_21:
        uint64_t result = CCCryptorGCMFinalize();
        if (!(_DWORD)result)
        {
          v26.iov_base = &v24;
          v26.iov_len = 4LL;
          uint64_t v27 = v9;
          uint64_t v28 = v18 - v9;
          uint64_t v29 = &v25;
          uint64_t v30 = 16LL;
          uint64_t result = NetSocket_WriteVInternal(a1, &v26, 3, a4);
          if (!(_DWORD)result) {
            continue;
          }
        }
      }
    }

    return result;
  }

  return 0LL;
}

void _NetSocketGCM_Free(uint64_t a1)
{
  int v1 = *(_CCCryptor ***)(a1 + 96);
  if (v1)
  {
    AES_GCM_Final(*(_CCCryptor ***)(a1 + 96));
    AES_GCM_Final(v1 + 3);
    free(v1);
    *(void *)(a1 + 96) = 0LL;
  }

uint64_t NetSocketTLS_Configure(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (CFTypeRef *)a1[12];
  if (!v6)
  {
    unint64_t v7 = (CFTypeRef *)calloc(1uLL, 0x10uLL);
    if (!v7)
    {
      uint64_t v13 = 4294960568LL;
      goto LABEL_11;
    }

    uint64_t v6 = v7;
    a1[12] = v7;
  }

  if (*v6) {
    CFRelease(*v6);
  }
  unsigned int v12 = SSLCreateContext(0LL, (SSLProtocolSide)(a4 == 0), kSSLStreamType);
  *uint64_t v6 = v12;
  if (v12)
  {
    uint64_t v13 = SSLSetConnection(v12, a1);
    if (!(_DWORD)v13)
    {
      uint64_t v13 = SSLSetIOFuncs((SSLContextRef)*v6, (SSLReadFunc)_TLSRead, (SSLWriteFunc)_TLSWrite);
      if (!(_DWORD)v13)
      {
        uint64_t v13 = SSLSetProtocolVersionMin((SSLContextRef)*v6, kTLSProtocol12);
        if (!(_DWORD)v13)
        {
          uint64_t v13 = SSLSetPSKSharedSecret();
          if (!(_DWORD)v13)
          {
            if (!a4 || (uint64_t v13 = SSLSetPSKIdentity(), !(_DWORD)v13))
            {
              unint64_t v15 = (SSLContext *)*v6;
              *(_DWORD *)ciphers = 11403432;
              uint64_t v13 = SSLSetEnabledCiphers(v15, ciphers, 2uLL);
              if (!(_DWORD)v13)
              {
                a1[3] = _NetSocketTLSRead;
                a1[4] = _NetSocketTLSWrite;
                a1[5] = NetSocket_WriteVSlow;
                a1[6] = NetSocket_WriteFileSlow;
                a1[7] = _NetSocketTLSFree;
                return v13;
              }
            }
          }
        }
      }
    }
  }

  else
  {
    uint64_t v13 = 4294960596LL;
  }

uint64_t _TLSRead(uint64_t a1, char *__dst, uint64_t *a3)
{
  LODWORD(result) = NetSocket_ReadInternal(a1, 1uLL, *a3, __dst, (size_t *)a3, 0, *(_DWORD *)(a1 + 104));
  if ((_DWORD)result == 35) {
    return 4294957493LL;
  }
  else {
    return result;
  }
}

uint64_t _TLSWrite(uint64_t a1, char *a2, size_t *a3)
{
  LODWORD(result) = NetSocket_WriteInternal(a1, a2, *a3, *(_DWORD *)(a1 + 104));
  if ((_DWORD)result == 35) {
    return 4294957493LL;
  }
  else {
    return result;
  }
}

uint64_t _NetSocketTLSRead( uint64_t a1, int a2, size_t dataLength, void *data, size_t *processed, uint64_t a6, int a7)
{
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  uint64_t v7 = *(void *)(a1 + 96);
  if (!v7) {
    return 4294960551LL;
  }
  if (*(_BYTE *)(a1 + 8)) {
    return 4294960573LL;
  }
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0) {
    return 4294960551LL;
  }
  *(_DWORD *)(a1 + 104) = a7;
  if (!*(_BYTE *)(v7 + 8))
  {
    uint64_t result = SSLHandshake(*(SSLContextRef *)v7);
    if ((_DWORD)result) {
      return result;
    }
    *(_BYTE *)(v7 + 8) = 1;
    if (gLogCategory_NetSocketTLS <= 20
      && (gLogCategory_NetSocketTLS != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_NetSocketTLS, 0x14u)))
    {
      LogPrintF( (uint64_t)&gLogCategory_NetSocketTLS,  (uint64_t)"OSStatus _NetSocketTLSRead(NetSocketRef, size_t, size_t, void *, size_t *, int, int32_t)",  0x14u,  (uint64_t)"TLS handshake completed for read\n",  v12,  v13,  v14,  v15,  v20);
    }
  }

  uint64_t result = SSLRead(*(SSLContextRef *)v7, data, dataLength, processed);
  if (!(_DWORD)result)
  {
    if (gLogCategory_NetSocketTLS > 9) {
      return 0LL;
    }
    if (gLogCategory_NetSocketTLS != -1
      || (uint64_t result = _LogCategory_Initialize((uint64_t)&gLogCategory_NetSocketTLS, 9u), (_DWORD)result))
    {
      LogPrintF( (uint64_t)&gLogCategory_NetSocketTLS,  (uint64_t)"OSStatus _NetSocketTLSRead(NetSocketRef, size_t, size_t, void *, size_t *, int, int32_t)",  9u,  (uint64_t)"TLS read %zu bytes\n",  v16,  v17,  v18,  v19,  *processed);
      return 0LL;
    }
  }

  return result;
}

uint64_t _NetSocketTLSWrite(uint64_t a1, void *data, size_t dataLength, int a4)
{
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  uint64_t v4 = *(void *)(a1 + 96);
  if (!v4) {
    return 4294960551LL;
  }
  if (*(_BYTE *)(a1 + 8)) {
    return 4294960573LL;
  }
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0) {
    return 4294960551LL;
  }
  *(_DWORD *)(a1 + 104) = a4;
  if (!*(_BYTE *)(v4 + 8))
  {
    uint64_t result = SSLHandshake(*(SSLContextRef *)v4);
    if ((_DWORD)result) {
      return result;
    }
    *(_BYTE *)(v4 + 8) = 1;
    if (gLogCategory_NetSocketTLS <= 20
      && (gLogCategory_NetSocketTLS != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_NetSocketTLS, 0x14u)))
    {
      LogPrintF( (uint64_t)&gLogCategory_NetSocketTLS,  (uint64_t)"OSStatus _NetSocketTLSWrite(NetSocketRef, const void *, size_t, int32_t)",  0x14u,  (uint64_t)"TLS handshake completed for write\n",  v8,  v9,  v10,  v11,  v16);
    }
  }

  uint64_t result = SSLWrite(*(SSLContextRef *)v4, data, dataLength, &processed);
  if (!(_DWORD)result)
  {
    if (gLogCategory_NetSocketTLS > 9) {
      return 0LL;
    }
    if (gLogCategory_NetSocketTLS != -1
      || (uint64_t result = _LogCategory_Initialize((uint64_t)&gLogCategory_NetSocketTLS, 9u), (_DWORD)result))
    {
      LogPrintF( (uint64_t)&gLogCategory_NetSocketTLS,  (uint64_t)"OSStatus _NetSocketTLSWrite(NetSocketRef, const void *, size_t, int32_t)",  9u,  (uint64_t)"TLS wrote %zu bytes\n",  v12,  v13,  v14,  v15,  processed);
      return 0LL;
    }
  }

  return result;
}

void _NetSocketTLSFree(uint64_t a1)
{
  int v1 = *(CFTypeRef **)(a1 + 96);
  if (v1)
  {
    if (*v1) {
      CFRelease(*v1);
    }
    free(v1);
    *(void *)(a1 + 96) = 0LL;
  }

uint64_t NetTransportChaCha20Poly1305Configure( void *a1, int *a2, __int128 *a3, void *a4, __int128 *a5, void *a6)
{
  uint64_t v12 = calloc(1uLL, 0x46C8uLL);
  if (!v12) {
    return 4294960568LL;
  }
  *(_DWORD *)uint64_t v12 = -1;
  uint64_t v13 = &gLogCategory_NetTransportChaCha20Poly1305;
  if (a2) {
    uint64_t v13 = a2;
  }
  v12[1] = v13;
  *((_DWORD *)v12 + 4) = 1;
  __int128 v14 = *a3;
  *((_OWORD *)v12 + 1046) = a3[1];
  *((_OWORD *)v12 + 1045) = v14;
  if (a4) {
    v12[2094] = *a4;
  }
  __int128 v15 = *a5;
  *((_OWORD *)v12 + 1131) = a5[1];
  *((_OWORD *)v12 + 1130) = v15;
  if (a6) {
    v12[2264] = *a6;
  }
  uint64_t v16 = 0LL;
  *a1 = v12;
  a1[1] = _NetTransportInitialize;
  a1[2] = _NetTransportFinalize;
  a1[3] = _NetTransportRead;
  a1[4] = _NetTransportWriteV;
  return v16;
}

uint64_t _NetTransportInitialize(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0LL;
}

void _NetTransportFinalize(void *a1)
{
  if (a1)
  {
    memset_s(a1, 0x46C8uLL, 0, 0x46C8uLL);
    free(a1);
  }

uint64_t _NetTransportRead(char *__dst, size_t a2, void *a3, uint64_t a4)
{
  uint64_t v6 = __dst;
  uint64_t v7 = (uint64_t *)(a4 + 32);
  uint64_t v8 = (int8x16_t *)(a4 + 42);
  uint64_t v9 = (int8x16_t *)(a4 + 16426);
  uint64_t v10 = (int32x4_t *)(a4 + 16464);
  int v39 = (_DWORD *)(a4 + 16720);
  uint64_t v40 = (unsigned int *)(a4 + 40);
  uint64_t v11 = (_DWORD *)(a4 + 16752);
  uint64_t v12 = *(int8x16_t **)(a4 + 16448);
  size_t v38 = (unsigned int *)(a4 + 16600);
  while (1)
  {
    while (1)
    {
      size_t v13 = *(void *)(a4 + 16456) - (void)v12;
      if (v13)
      {
        if (v13 >= a2) {
          size_t v14 = a2;
        }
        else {
          size_t v14 = *(void *)(a4 + 16456) - (void)v12;
        }
        memcpy(v6, v12, v14);
        uint64_t v12 = (int8x16_t *)(*(void *)(a4 + 16448) + v14);
        *(void *)(a4 + 16448) = v12;
        v6 += v14;
        a2 -= v14;
      }

      if (!a2)
      {
        unsigned int v28 = 0;
        goto LABEL_26;
      }

      int v15 = *(_DWORD *)(a4 + 16);
      if (v15 == 1)
      {
        int Data = SocketReadData(*(_DWORD *)a4, (uint64_t)v40, 2uLL, v7);
        if (Data) {
          goto LABEL_37;
        }
        unint64_t v16 = *(unsigned __int16 *)(a4 + 40);
        *(void *)(a4 + 24) = v16;
        if (v16 <= 0x4000)
        {
          *(void *)(a4 + 32) = 0LL;
          *(_DWORD *)(a4 + 16) = 2;
          goto LABEL_15;
        }

        if (gLogCategory_NetTransportChaCha20Poly1305 <= 60)
        {
          if (gLogCategory_NetTransportChaCha20Poly1305 == -1)
          {
            unint64_t v16 = *(void *)(a4 + 24);
          }

          LogPrintF( (uint64_t)&gLogCategory_NetTransportChaCha20Poly1305,  (uint64_t)"OSStatus _NetTransportRead(void *, size_t, size_t *, void *)",  0x3Cu,  (uint64_t)"### NTCP bad size: %zu / %H\n",  v18,  v19,  v20,  v21,  v16);
        }

uint64_t _NetTransportWriteV(const iovec **a1, int *a2, int32x4_t *a3)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t v4 = &a3[1047].u32[2];
  uint64_t v5 = (int8x16_t *)((char *)&a3[1047].u64[1] + 2);
  unint64_t v6 = (unint64_t)&a3[1111].u64[1] + 2;
  uint64_t v7 = *a1;
  unint64_t v8 = (unint64_t)&(*a1)[*a2];
  __s = a3 + 1114;
  uint64_t v9 = a3 + 1130;
  uint64_t v10 = a3 + 1132;
  uint64_t v11 = (unsigned int *)a3[1113].i64[0];
  uint64_t v37 = &a3[1047].u32[2];
  size_t v38 = &a3[1122].u32[2];
  uint64_t v35 = a3 + 1130;
  __int128 v36 = (int8x16_t *)((char *)&a3[1047].u64[1] + 2);
  while (1)
  {
    while (1)
    {
      uint64_t v12 = (unsigned int *)a3[1113].i64[1];
      int64_t v13 = (char *)v12 - (char *)v11;
      if (v12 == v11) {
        break;
      }
      unsigned int v43 = v11;
      int64_t v44 = (char *)v12 - (char *)v11;
      uint64_t v40 = (const iovec *)&v43;
      int v41 = 1;
      uint64_t result = SocketWriteData(a3->i32[0], &v40, &v41);
      uint64_t v11 = (unsigned int *)(a3[1113].i64[0] + v13 - v44);
      a3[1113].i64[0] = (uint64_t)v11;
      if ((_DWORD)result) {
        goto LABEL_33;
      }
    }

    if ((unint64_t)v7 >= v8)
    {
      uint64_t v15 = 0LL;
      uint64_t v17 = v7;
LABEL_11:
      uint64_t v40 = v17;
      if (!v15)
      {
LABEL_32:
        uint64_t result = 0LL;
        goto LABEL_33;
      }
    }

    else
    {
      uint64_t v15 = 0LL;
      unint64_t v16 = v5;
      uint64_t v17 = v7;
      while (1)
      {
        size_t iov_len = v17->iov_len;
        v15 += iov_len;
        unint64_t v16 = (int8x16_t *)((char *)v16 + iov_len);
      }

      uint64_t v40 = v17;
      v15 += v6 - (void)v16;
      if (!v15) {
        goto LABEL_32;
      }
    }

    chacha20_poly1305_init_64x64(__s, v9, v10);
    *(_WORD *)uint64_t v4 = v15;
    poly1305_update(v38, v4, 2uLL);
    a3[1128].i64[1] += 2LL;
    if ((unint64_t)v7 >= v8)
    {
      uint64_t v21 = v5;
    }

    else
    {
      unint64_t v19 = v6;
      p_size_t iov_len = &v7->iov_len;
      uint64_t v21 = v5;
      while (1)
      {
        unint64_t v22 = v8;
        uint64_t v7 = (const iovec *)(p_iov_len - 1);
        uint64_t v23 = (int8x16_t *)*(p_iov_len - 1);
        unint64_t v24 = v19 - (void)v5;
        unint64_t v25 = chacha20_poly1305_encrypt((uint64_t)__s, v23, *p_iov_len, v21);
        uint64_t v26 = p_iov_len + 2;
        uint64_t v5 = (int8x16_t *)((char *)v5 + *p_iov_len);
        uint64_t v21 = (int8x16_t *)((char *)v21 + v25);
        unint64_t v8 = v22;
        BOOL v27 = (unint64_t)(p_iov_len + 1) >= v22;
        p_iov_len += 2;
        if (v27)
        {
          uint64_t v7 = (const iovec *)(v26 - 1);
          goto LABEL_22;
        }
      }

      unint64_t v28 = chacha20_poly1305_encrypt((uint64_t)__s, v23, v19 - (void)v5, v21);
      *(p_iov_len - 1) += v24;
      *p_iov_len -= v24;
      uint64_t v21 = (int8x16_t *)((char *)v21 + v28);
      unint64_t v8 = v22;
LABEL_22:
      uint64_t v5 = v36;
      uint64_t v4 = v37;
      unint64_t v6 = v19;
      uint64_t v9 = v35;
    }

    uint64_t v29 = &v21->i8[chacha20_poly1305_final((unsigned int *)__s, v21, (uint64_t)&v42)];
    unint64_t v31 = 0LL;
    *(_OWORD *)uint64_t v29 = v42;
    do
    {
      __int16 v32 = v10->i8[v31]++ + 1;
      if ((v32 & 0x100) == 0) {
        break;
      }
      BOOL v27 = v31++ >= 7;
    }

    while (!v27);
    a3[1113].i64[0] = (uint64_t)v4;
    a3[1113].i64[1] = (uint64_t)(v29 + 16);
    uint64_t v11 = v4;
  }

  uint64_t result = 4294960534LL;
LABEL_33:
  *a1 = v7;
  *a2 = (v8 - (unint64_t)v7) >> 4;
  return result;
}

uint64_t NetTransportGCMConfigure(_CCCryptor ***a1, int *a2, void *a3, __n128 *a4, void *a5, __n128 *a6)
{
  uint64_t v12 = (_CCCryptor **)calloc(1uLL, 0x800A8uLL);
  if (!v12) {
    return 4294960568LL;
  }
  int64_t v13 = v12;
  *(_DWORD *)uint64_t v12 = -1;
  size_t v14 = &gLogCategory_NetTransportGCM;
  if (a2) {
    size_t v14 = a2;
  }
  v12[1] = (_CCCryptor *)v14;
  *((_DWORD *)v12 + 4) = 1;
  uint64_t v15 = v12 + 32778;
  AES_GCM_InitEx(v12 + 32778, 1u, a3, a4);
  uint64_t v17 = v16;
  if ((_DWORD)v16 || (AES_GCM_InitEx(v13 + 65554, 0, a5, a6), uint64_t v17 = v18, (_DWORD)v18))
  {
    AES_GCM_Final(v15);
    AES_GCM_Final(v13 + 65554);
    free(v13);
  }

  else
  {
    *a1 = v13;
    a1[1] = (_CCCryptor **)_NetTransportInitialize_11563;
    a1[2] = (_CCCryptor **)_NetTransportFinalize_11564;
    a1[3] = (_CCCryptor **)_NetTransportRead_11565;
    a1[4] = (_CCCryptor **)_NetTransportWriteV_11566;
  }

  return v17;
}

uint64_t _NetTransportInitialize_11563(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0LL;
}

void _NetTransportFinalize_11564(_CCCryptor **a1)
{
  if (a1)
  {
    AES_GCM_Final(a1 + 32778);
    AES_GCM_Final(a1 + 65554);
    free(a1);
  }

uint64_t _NetTransportRead_11565(char *__dst, size_t a2, void *a3, uint64_t a4)
{
  unint64_t v6 = __dst;
  uint64_t v7 = (uint64_t *)(a4 + 262208);
  uint64_t v8 = a4 + 40;
  uint64_t v9 = (uint64_t *)(a4 + 32);
  uint64_t v10 = a4 + 44;
  uint64_t v11 = a4 + 262188;
  uint64_t v12 = (void *)(a4 + 262224);
  for (unsigned int i = *(const void **)(a4 + 262208); ; unsigned int i = (const void *)v10)
  {
    do
    {
      size_t v14 = v7[1] - (void)i;
      if (v14)
      {
        if (v14 >= a2) {
          size_t v15 = a2;
        }
        else {
          size_t v15 = v7[1] - (void)i;
        }
        memcpy(v6, i, v15);
        unsigned int i = (const void *)(*v7 + v15);
        *uint64_t v7 = (uint64_t)i;
        v6 += v15;
        a2 -= v15;
      }

      if (!a2)
      {
        unsigned int v25 = 0;
        goto LABEL_25;
      }

      int v16 = *(_DWORD *)(a4 + 16);
      if (v16 == 1)
      {
        unsigned int Data = SocketReadData(*(_DWORD *)a4, v8, 4uLL, v9);
        if (Data) {
          goto LABEL_23;
        }
        unint64_t v17 = bswap32(*(_DWORD *)(a4 + 40));
        *(void *)(a4 + 24) = v17;
        if (v17 > 0x40000)
        {
          unsigned int v25 = -6743;
          goto LABEL_25;
        }

        *(void *)(a4 + 32) = 0LL;
        *(_DWORD *)(a4 + 16) = 2;
        goto LABEL_15;
      }

      if (v16 == 3) {
        goto LABEL_17;
      }
    }

    while (v16 != 2);
    unint64_t v17 = *(void *)(a4 + 24);
LABEL_15:
    unsigned int Data = SocketReadData(*(_DWORD *)a4, v10, v17, v9);
    if (Data) {
      goto LABEL_23;
    }
    *(void *)(a4 + 32) = 0LL;
    *(_DWORD *)(a4 + 16) = 3;
LABEL_17:
    unsigned int Data = SocketReadData(*(_DWORD *)a4, v11, 0x10uLL, v9);
    if (Data
      || (unsigned int Data = AES_GCM_InitMessage((uint64_t)v12, 0LL)) != 0
      || (unsigned int Data = CCCryptorGCMAddAAD()) != 0
      || (unsigned int Data = MEMORY[0x186E41AE4](*v12, v10, *(void *)(a4 + 24), v10)) != 0)
    {
LABEL_23:
      unsigned int v25 = Data;
LABEL_25:
      BOOL v27 = a3;
      uint64_t v26 = __dst;
      goto LABEL_26;
    }

    unsigned int v19 = CCCryptorGCMFinalize();
    if (v19) {
      break;
    }
    uint64_t v24 = v10 + *(void *)(a4 + 24);
    *uint64_t v7 = v10;
    v7[1] = v24;
    *(void *)(a4 + 32) = 0LL;
    *(_DWORD *)(a4 + 16) = 1;
  }

  unsigned int v25 = v19;
  BOOL v27 = a3;
  uint64_t v26 = __dst;
  if (gLogCategory_NetTransportGCM <= 60
    && (gLogCategory_NetTransportGCM != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_NetTransportGCM, 0x3Cu)))
  {
    LogPrintF( (uint64_t)&gLogCategory_NetTransportGCM,  (uint64_t)"OSStatus _NetTransportRead(void *, size_t, size_t *, void *)",  0x3Cu,  (uint64_t)"### GCM verify failed: %#m\n",  v20,  v21,  v22,  v23,  v25);
  }

uint64_t _NetTransportWriteV_11566(const iovec **a1, int *a2, uint64_t a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (char **)(a3 + 524416);
  uint64_t v5 = a3 + 262252;
  uint64_t v6 = a3 + 524396;
  uint64_t v7 = *a1;
  unint64_t v8 = (unint64_t)&(*a1)[*a2];
  BOOL v27 = (char *)(a3 + 262248);
  unint64_t v28 = (uint64_t *)(a3 + 524432);
  uint64_t v9 = *(char **)(a3 + 524416);
  uint64_t v26 = a3 + 262252;
  while (1)
  {
    while (1)
    {
      uint64_t v10 = v4[1];
      int64_t v11 = v10 - v9;
      if (v10 == v9) {
        break;
      }
      unint64_t v31 = v9;
      int64_t v32 = v10 - v9;
      uint64_t v29 = (const iovec *)&v31;
      int v30 = 1;
      uint64_t result = SocketWriteData(*(_DWORD *)a3, &v29, &v30);
      uint64_t v9 = &(*v4)[v11 - v32];
      *uint64_t v4 = v9;
      if ((_DWORD)result) {
        goto LABEL_30;
      }
    }

    if ((unint64_t)v7 >= v8)
    {
      uint64_t v13 = 0LL;
      size_t v15 = v7;
LABEL_11:
      uint64_t v29 = v15;
      if (!v13)
      {
LABEL_31:
        uint64_t result = 0LL;
        goto LABEL_30;
      }
    }

    else
    {
      uint64_t v13 = 0LL;
      uint64_t v14 = v5;
      size_t v15 = v7;
      while (1)
      {
        size_t iov_len = v15->iov_len;
        if (v6 - v14 < iov_len) {
          break;
        }
        v13 += iov_len;
        v14 += iov_len;
      }

      uint64_t v29 = v15;
      v13 += v6 - v14;
      if (!v13) {
        goto LABEL_31;
      }
    }

    uint64_t result = AES_GCM_InitMessage((uint64_t)v28, 0LL);
    if ((_DWORD)result) {
      goto LABEL_30;
    }
    *(_DWORD *)BOOL v27 = bswap32(v13);
    uint64_t result = CCCryptorGCMAddAAD();
    if ((_DWORD)result) {
      goto LABEL_30;
    }
    uint64_t v18 = v5;
LABEL_27:
    uint64_t result = CCCryptorGCMFinalize();
    if ((_DWORD)result) {
      goto LABEL_30;
    }
    *uint64_t v4 = v27;
    v4[1] = (char *)(v18 + 16);
    uint64_t v9 = v27;
  }

  p_size_t iov_len = &v7->iov_len;
  uint64_t v18 = v5;
  while (1)
  {
    uint64_t v7 = (const iovec *)(p_iov_len - 1);
    uint64_t v19 = *(p_iov_len - 1);
    uint64_t v20 = v6 - v18;
    uint64_t v21 = *v28;
    if (v6 - v18 < *p_iov_len)
    {
      uint64_t result = MEMORY[0x186E41AF0](v21, v19, v6 - v18, v18);
      if ((_DWORD)result) {
        goto LABEL_30;
      }
      *(p_iov_len - 1) += v20;
      *p_iov_len -= v20;
      uint64_t v18 = v6;
      goto LABEL_26;
    }

    uint64_t result = MEMORY[0x186E41AF0](v21, v19);
    if ((_DWORD)result) {
      break;
    }
    uint64_t v22 = p_iov_len + 2;
    v18 += *p_iov_len;
    BOOL v23 = (unint64_t)(p_iov_len + 1) >= v8;
    p_iov_len += 2;
    if (v23)
    {
      uint64_t v7 = (const iovec *)(v22 - 1);
LABEL_26:
      uint64_t v5 = v26;
      goto LABEL_27;
    }
  }

  uint64_t v7 = (const iovec *)(p_iov_len - 1);
LABEL_30:
  *a1 = v7;
  *a2 = (v8 - (unint64_t)v7) >> 4;
  return result;
}

uint64_t NetTransportTLSConfigure(SSLContext ***a1, int a2)
{
  uint64_t v4 = (SSLContext **)calloc(1uLL, 0x60uLL);
  if (!v4) {
    return 4294960568LL;
  }
  uint64_t v5 = v4;
  uint64_t v6 = SSLCreateContext(0LL, (SSLProtocolSide)(a2 != 0), kSSLStreamType);
  *uint64_t v5 = v6;
  if (v6)
  {
    uint64_t v7 = SSLSetConnection(v6, v5);
    if (!(_DWORD)v7)
    {
      uint64_t v7 = SSLSetIOFuncs(*v5, (SSLReadFunc)_SecureTransportRead, (SSLWriteFunc)_SecureTransportWrite);
      if (!(_DWORD)v7)
      {
        uint64_t v7 = SSLSetProtocolVersionMin(*v5, kTLSProtocol12);
        if (!(_DWORD)v7)
        {
          *a1 = v5;
          a1[1] = (SSLContext **)_NetTransportInitialize_11571;
          a1[2] = (SSLContext **)_NetTransportFinalize_11572;
          a1[3] = (SSLContext **)_NetTransportRead_11573;
          a1[4] = (SSLContext **)_NetTransportWriteV_11574;
          return v7;
        }
      }
    }
  }

  else
  {
    uint64_t v7 = 4294960596LL;
  }

  _NetTransportFinalize_11572((CFTypeRef *)v5);
  return v7;
}

uint64_t _SecureTransportRead(uint64_t a1, void *a2, size_t *a3)
{
  do
  {
    unint64_t v6 = read(*(_DWORD *)(a1 + 8), a2, *a3);
    if ((v6 & 0x8000000000000000LL) == 0)
    {
      if (v6)
      {
        if (v6 < *a3) {
          goto LABEL_8;
        }
        uint64_t v7 = 0LL;
      }

      else
      {
        uint64_t v7 = 4294957491LL;
      }

      goto LABEL_13;
    }

    if (!*__error())
    {
      unint64_t v6 = 0LL;
      uint64_t v7 = 4294960596LL;
      goto LABEL_13;
    }

    uint64_t v7 = *__error();
  }

  while ((_DWORD)v7 == 4);
  if ((_DWORD)v7 == 35)
  {
    unint64_t v6 = 0LL;
LABEL_8:
    *(_BYTE *)(a1 + 13) = 1;
    uint64_t v7 = 4294957493LL;
    goto LABEL_13;
  }

  unint64_t v6 = 0LL;
LABEL_13:
  *a3 = v6;
  return v7;
}

size_t _SecureTransportWrite(uint64_t a1, void *__buf, size_t *a3)
{
  size_t v4 = *a3;
  if (*a3)
  {
    while (1)
    {
      unint64_t v7 = write(*(_DWORD *)(a1 + 8), __buf, *a3);
      if ((v7 & 0x8000000000000000LL) == 0) {
        break;
      }
      if (!*__error())
      {
        unint64_t v7 = 0LL;
        size_t v4 = 4294960596LL;
        goto LABEL_14;
      }

      size_t v4 = *__error();
      if ((_DWORD)v4 != 4)
      {
        if ((_DWORD)v4 != 35) {
          goto LABEL_11;
        }
        unint64_t v7 = 0LL;
        goto LABEL_9;
      }
    }

    if (v7)
    {
      if (v7 < *a3)
      {
LABEL_9:
        *(_BYTE *)(a1 + 14) = 1;
        size_t v4 = 4294957493LL;
        goto LABEL_14;
      }

      size_t v4 = 0LL;
    }

    else
    {
      size_t v4 = 4294957491LL;
    }
  }

  else
  {
LABEL_11:
    unint64_t v7 = 0LL;
  }

uint64_t _NetTransportInitialize_11571(int a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 8) = a1;
  return 0LL;
}

void _NetTransportFinalize_11572(CFTypeRef *a1)
{
  if (a1)
  {
    uint64_t v2 = (void (*)(CFTypeRef))a1[5];
    if (v2) {
      v2(a1[3]);
    }
    CFTypeRef v3 = a1[4];
    if (v3)
    {
      CFRelease(v3);
      a1[4] = 0LL;
    }

    if (*a1) {
      CFRelease(*a1);
    }
    free(a1);
  }

uint64_t _NetTransportRead_11573(void *data, size_t dataLength, size_t *a3, uint64_t a4)
{
  size_t processed = 0LL;
  if (!*(_BYTE *)(a4 + 12))
  {
    while (1)
    {
      uint64_t result = SSLHandshake(*(SSLContextRef *)a4);
      if (!(_DWORD)result)
      {
        *(_BYTE *)(a4 + 12) = 1;
        goto LABEL_11;
      }

      if ((_DWORD)result == -9803) {
        break;
      }
      if ((_DWORD)result != -9841)
      {
        size_t v9 = 0LL;
        goto LABEL_33;
      }

      uint64_t result = _HandlePeerAuth(a4);
      size_t v9 = 0LL;
      if ((_DWORD)result) {
        goto LABEL_33;
      }
    }

    int v10 = *(unsigned __int8 *)(a4 + 14);
    if (*(_BYTE *)(a4 + 13))
    {
      *(_BYTE *)(a4 + 13) = 0;
      if (v10)
      {
        uint64_t result = 4294960530LL;
LABEL_27:
        size_t v9 = 0LL;
        goto LABEL_28;
      }

      size_t v9 = 0LL;
      goto LABEL_30;
    }

    if (*(_BYTE *)(a4 + 14))
    {
      uint64_t result = 4294960521LL;
      goto LABEL_27;
    }

    size_t v9 = 0LL;
LABEL_32:
    uint64_t result = 35LL;
    goto LABEL_33;
  }

uint64_t _NetTransportWriteV_11574(const void ***a1, int *a2, uint64_t a3)
{
  if (*(_BYTE *)(a3 + 12))
  {
    while (1)
    {
LABEL_8:
      if (*a2 < 1) {
        return 0LL;
      }
      size_t processed = 0LL;
      LODWORD(result) = SSLWrite(*(SSLContextRef *)a3, **a1, (size_t)(*a1)[1], &processed);
      if (processed) {
        uint64_t result = 0LL;
      }
      else {
        uint64_t result = result;
      }
      if ((_DWORD)result) {
        break;
      }
      uint64_t result = UpdateIOVec((uint64_t **)a1, a2, processed);
      if (!(_DWORD)result) {
        return result;
      }
    }

    if ((_DWORD)result != -9803) {
      return result;
    }
  }

  else
  {
    while (1)
    {
      uint64_t result = SSLHandshake(*(SSLContextRef *)a3);
      if (!(_DWORD)result)
      {
        *(_BYTE *)(a3 + 12) = 1;
        goto LABEL_8;
      }

      if ((_DWORD)result == -9803) {
        break;
      }
      if ((_DWORD)result == -9841)
      {
        uint64_t result = _HandlePeerAuth(a3);
        if (!(_DWORD)result) {
          continue;
        }
      }

      return result;
    }
  }

  int v7 = *(unsigned __int8 *)(a3 + 14);
  if (*(_BYTE *)(a3 + 13))
  {
    *(_BYTE *)(a3 + 13) = 0;
    if (v7)
    {
      uint64_t result = 4294960530LL;
LABEL_23:
      *(_BYTE *)(a3 + 14) = 0;
      return result;
    }

    return 4294960522LL;
  }

  else
  {
    if (*(_BYTE *)(a3 + 14))
    {
      uint64_t result = 4294960521LL;
      goto LABEL_23;
    }

    return 35LL;
  }

uint64_t _HandlePeerAuth(uint64_t a1)
{
  uint64_t v2 = *(uint64_t (**)(SecTrustRef, void))(a1 + 80);
  if (!v2)
  {
    if (!*(_BYTE *)(a1 + 56)) {
      return 0LL;
    }
    uint64_t v2 = *(uint64_t (**)(SecTrustRef, void))(a1 + 48);
    if (!v2) {
      return 0LL;
    }
  }

  uint64_t v3 = SSLCopyPeerTrust(*(SSLContextRef *)a1, &trust);
  if (!(_DWORD)v3)
  {
    uint64_t v3 = v2(trust, *(void *)(a1 + 24));
    CFRelease(trust);
    if (!(_DWORD)v3) {
      return 0LL;
    }
  }

  return v3;
}

uint64_t NetTransportTLSConfigureEx(void *a1, void *a2)
{
  if (*a2 > 0x50uLL) {
    return 4294960553LL;
  }
  uint64_t v3 = calloc(1uLL, 0x60uLL);
  if (!v3) {
    return 4294960568LL;
  }
  size_t v4 = v3;
  __memcpy_chk();
  uint64_t v5 = SSLCreateContext(0LL, (SSLProtocolSide)(*((_BYTE *)v4 + 56) != 0), kSSLStreamType);
  *(void *)size_t v4 = v5;
  if (!v5)
  {
    uint64_t v6 = 4294960596LL;
    goto LABEL_5;
  }

  uint64_t v6 = SSLSetConnection(v5, v4);
  if ((_DWORD)v6) {
    goto LABEL_5;
  }
  unint64_t v8 = (const __CFArray *)*((void *)v4 + 11);
  if (v8)
  {
    uint64_t v6 = SSLSetCertificate(*(SSLContextRef *)v4, v8);
    if ((_DWORD)v6) {
      goto LABEL_5;
    }
  }

  uint64_t v6 = SSLSetIOFuncs(*(SSLContextRef *)v4, (SSLReadFunc)_SecureTransportRead, (SSLWriteFunc)_SecureTransportWrite);
  if ((_DWORD)v6) {
    goto LABEL_5;
  }
  SSLProtocol v9 = *((_DWORD *)v4 + 15);
  if (v9)
  {
    uint64_t v6 = SSLSetProtocolVersionMin(*(SSLContextRef *)v4, v9);
    if ((_DWORD)v6) {
      goto LABEL_5;
    }
  }

  int v10 = (const char *)*((void *)v4 + 8);
  if (v10)
  {
    size_t v11 = *((void *)v4 + 9);
    if (v11 == -1LL) {
      size_t v11 = strlen(*((const char **)v4 + 8));
    }
    uint64_t v6 = SSLSetPeerDomainName(*(SSLContextRef *)v4, v10, v11);
    if ((_DWORD)v6) {
      goto LABEL_5;
    }
  }

  if (!*((_BYTE *)v4 + 56)) {
    goto LABEL_31;
  }
  if (!*((void *)v4 + 6) && !*((void *)v4 + 10)) {
    goto LABEL_23;
  }
  uint64_t v6 = SSLSetSessionOption(*(SSLContextRef *)v4, kSSLSessionOptionBreakOnServerAuth, 1u);
  if ((_DWORD)v6) {
    goto LABEL_5;
  }
  if (!*((_BYTE *)v4 + 56))
  {
LABEL_31:
    if (!*((void *)v4 + 10)) {
      goto LABEL_23;
    }
    uint64_t v6 = SSLSetSessionOption(*(SSLContextRef *)v4, kSSLSessionOptionBreakOnClientAuth, 1u);
    if (!(_DWORD)v6) {
      goto LABEL_23;
    }
LABEL_5:
    _NetTransportFinalize_11572((CFTypeRef *)v4);
    return v6;
  }

uint64_t NetTransportTLSPSKConfigure( SSLContext ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  SSLProtocol v9 = (SSLContext **)calloc(1uLL, 0x60uLL);
  if (!v9) {
    return 4294960568LL;
  }
  int v10 = v9;
  size_t v11 = SSLCreateContext(0LL, (SSLProtocolSide)(a6 != 0), kSSLStreamType);
  *int v10 = v11;
  if (v11)
  {
    uint64_t v12 = SSLSetConnection(v11, v10);
    if (!(_DWORD)v12)
    {
      uint64_t v12 = SSLSetIOFuncs(*v10, (SSLReadFunc)_SecureTransportRead, (SSLWriteFunc)_SecureTransportWrite);
      if (!(_DWORD)v12)
      {
        uint64_t v12 = SSLSetProtocolVersionMin(*v10, kTLSProtocol12);
        if (!(_DWORD)v12)
        {
          uint64_t v12 = SSLSetPSKSharedSecret();
          if (!(_DWORD)v12)
          {
            if (!a4 || (uint64_t v12 = SSLSetPSKIdentity(), !(_DWORD)v12))
            {
              uint64_t v14 = *v10;
              *(_DWORD *)ciphers = 11403432;
              uint64_t v12 = SSLSetEnabledCiphers(v14, ciphers, 2uLL);
              if (!(_DWORD)v12)
              {
                *a1 = v10;
                a1[1] = (SSLContext **)_NetTransportInitialize_11571;
                a1[2] = (SSLContext **)_NetTransportFinalize_11572;
                a1[3] = (SSLContext **)_NetTransportRead_11573;
                a1[4] = (SSLContext **)_NetTransportWriteV_11574;
                return v12;
              }
            }
          }
        }
      }
    }
  }

  else
  {
    uint64_t v12 = 4294960596LL;
  }

  _NetTransportFinalize_11572((CFTypeRef *)v10);
  return v12;
}

uint64_t CreateUsableInterfaceList(const char *a1, int a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  unsigned int v25 = 0LL;
  uint64_t v26 = 0LL;
  int v6 = socket(30, 2, 0);
  if (v6 < 0 && *__error()) {
    __error();
  }
  if (getifaddrs(&v26))
  {
    if (!*__error())
    {
      uint64_t v7 = 4294960596LL;
      goto LABEL_56;
    }

    uint64_t v7 = *__error();
    if ((_DWORD)v7) {
      goto LABEL_56;
    }
  }

  unint64_t v8 = v26;
  if (v26)
  {
    SSLProtocol v9 = &v25;
    while (1)
    {
      if ((v8->ifa_flags & 1) != 0)
      {
        ifa_addr = v8->ifa_addr;
        if (ifa_addr)
        {
          ifa_name = v8->ifa_name;
          if (ifa_name)
          {
            int sa_family = ifa_addr->sa_family;
            BOOL v13 = sa_family == 30 || sa_family == 2;
            if (v13
              && (!a2 || sa_family == a2)
              && (sa_family != 2 || *(_DWORD *)&ifa_addr->sa_data[2])
              && (!a1 || !strcmp(ifa_name, a1)))
            {
              if (v6 < 0 || sa_family != 30)
              {
LABEL_33:
                if (a3)
                {
                  unint64_t v17 = calloc(1uLL, 0x38uLL);
                  if (!v17) {
                    goto LABEL_53;
                  }
                  uint64_t v18 = v17;
                  *SSLProtocol v9 = v17;
                  uint64_t v19 = strdup(v8->ifa_name);
                  v18[1] = v19;
                  if (!v19) {
                    goto LABEL_53;
                  }
                  *((_DWORD *)v18 + 4) = v8->ifa_flags;
                  size_t v20 = sa_family == 2 ? 16LL : 28LL;
                  uint64_t v21 = malloc(v20);
                  v18[3] = v21;
                  if (!v21)
                  {
LABEL_53:
                    uint64_t v7 = 4294960568LL;
                    BOOL v23 = v25;
                    goto LABEL_54;
                  }

                  memcpy(v21, v8->ifa_addr, v20);
                  if (sa_family == 30)
                  {
                    uint64_t v22 = v18[3];
                    if (*(unsigned __int8 *)(v22 + 8) == 254 && (*(_BYTE *)(v22 + 9) & 0xC0) == 0x80)
                    {
                      if (!*(_DWORD *)(v22 + 24)) {
                        *(_DWORD *)(v22 + 24) = __rev16(*(unsigned __int16 *)(v22 + 10));
                      }
                      *(_WORD *)(v22 + 10) = 0;
                    }
                  }

                  SSLProtocol v9 = (void **)v18;
                }
              }

              else
              {
                for (int i = 49; ; --i)
                {
                  memset(v27, 0, sizeof(v27));
                  __strlcpy_chk();
                  size_t v15 = v8->ifa_addr;
                  __int128 v16 = *(_OWORD *)&v15->sa_data[10];
                  v27[1] = *v15;
                  *(_OWORD *)((char *)&v27[1] + 12) = v16;
                  if (ioctl(v6, 0xC1206949uLL, v27) == -1 && (!*__error() || *__error())) {
                    break;
                  }
                  if ((v27[1] & 0x9C) != 0) {
                    break;
                  }
                  if ((v27[1] & 2) == 0) {
                    goto LABEL_33;
                  }
                  if (!i) {
                    break;
                  }
                  usleep(0x186A0u);
                }
              }
            }
          }
        }
      }

      unint64_t v8 = v8->ifa_next;
      if (!v8)
      {
        BOOL v23 = v25;
        goto LABEL_51;
      }
    }
  }

  BOOL v23 = 0LL;
LABEL_51:
  uint64_t v7 = 0LL;
  if (a3)
  {
    *a3 = v23;
  }

  else
  {
LABEL_54:
    if (v23) {
      ReleaseUsableInterfaceList(v23);
    }
  }

void ReleaseUsableInterfaceList(void *a1)
{
  if (a1)
  {
    int v1 = a1;
    do
    {
      uint64_t v3 = (void *)*v1;
      uint64_t v2 = (void *)v1[1];
      if (v2)
      {
        free(v2);
        v1[1] = 0LL;
      }

      size_t v4 = (void *)v1[3];
      if (v4)
      {
        free(v4);
        v1[3] = 0LL;
      }

      uint64_t v5 = (void *)v1[4];
      if (v5)
      {
        free(v5);
        v1[4] = 0LL;
      }

      int v6 = (void *)v1[5];
      if (v6)
      {
        free(v6);
        v1[5] = 0LL;
      }

      uint64_t v7 = (void *)v1[6];
      if (v7) {
        free(v7);
      }
      free(v1);
      int v1 = v3;
    }

    while (v3);
  }

_DWORD *CUDispatchSocketAllocate(int *a1)
{
  uint64_t result = calloc(1uLL, 0x38uLL);
  if (result)
  {
    int v3 = 0;
    *uint64_t result = -1;
    if (!a1) {
      return result;
    }
  }

  else
  {
    int v3 = -6728;
    if (!a1) {
      return result;
    }
  }

  *a1 = v3;
  return result;
}

void CUDispatchSocketCancelAll(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (dispatch_source_s *)a1[1];
    if (v2)
    {
      dispatch_source_cancel(v2);
      if (*((_BYTE *)a1 + 16))
      {
        *((_BYTE *)a1 + 16) = 0;
        dispatch_resume((dispatch_object_t)a1[1]);
      }
    }

    int v3 = (dispatch_source_s *)a1[3];
    if (v3)
    {
      dispatch_source_cancel(v3);
      if (*((_BYTE *)a1 + 32))
      {
        *((_BYTE *)a1 + 32) = 0;
        dispatch_resume((dispatch_object_t)a1[3]);
      }
    }

    _CUDispatchSocketCleanupIfDone(a1);
  }

void _CUDispatchSocketCleanupIfDone(void *a1)
{
  if (!a1[1] && !a1[3])
  {
    int v2 = *(_DWORD *)a1;
    if ((v2 & 0x80000000) == 0)
    {
      if (close(v2) && *__error()) {
        __error();
      }
      *(_DWORD *)a1 = -1;
    }

    int v3 = (void (*)(void *))a1[6];
    if (v3) {
      v3(a1);
    }
    a1[6] = 0LL;
    size_t v4 = (const void *)a1[5];
    if (v4) {
      CFRelease(v4);
    }
    free(a1);
  }

void CUDispatchSocketReadCanceled(void *a1)
{
  if (a1)
  {
    int v2 = (dispatch_object_s *)a1[1];
    if (v2)
    {
      dispatch_release(v2);
      a1[1] = 0LL;
    }

    _CUDispatchSocketCleanupIfDone(a1);
  }

void CUDispatchSocketWriteCanceled(void *a1)
{
  if (a1)
  {
    int v2 = (dispatch_object_s *)a1[3];
    if (v2)
    {
      dispatch_release(v2);
      a1[3] = 0LL;
    }

    _CUDispatchSocketCleanupIfDone(a1);
  }

__CFArray *CUCopyMACAddresses(uint64_t a1, int *a2)
{
  SSLProtocol v9 = 0LL;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  if (!Mutable)
  {
    int v4 = -6728;
    if (!a2) {
      return Mutable;
    }
    goto LABEL_20;
  }

  if (!getifaddrs(&v9)) {
    goto LABEL_5;
  }
  if (!*__error())
  {
    int v4 = -6700;
    goto LABEL_14;
  }

  int v4 = *__error();
  if (!v4)
  {
LABEL_5:
    uint64_t v5 = v9;
    if (!v9)
    {
      int v4 = 0;
      goto LABEL_19;
    }

    while (1)
    {
      if ((v5->ifa_flags & 1) != 0)
      {
        ifa_addr = v5->ifa_addr;
        if (ifa_addr)
        {
          if (ifa_addr->sa_family == 18 && ifa_addr->sa_data[4] == 6)
          {
            int appended = CFArrayAppendBytes( Mutable,  (const UInt8 *)&ifa_addr->sa_data[ifa_addr->sa_data[3] + 6],  6LL);
            if (appended) {
              break;
            }
          }
        }
      }

      uint64_t v5 = v5->ifa_next;
      if (!v5)
      {
        int v4 = 0;
        goto LABEL_15;
      }
    }

    int v4 = appended;
  }

uint64_t CUGetInterfaceAddresses(char a1, const char *a2, sockaddr *a3, uint64_t a4, uint64_t a5)
{
  BOOL v10 = a3 != 0LL;
  BOOL v11 = a4 != 0;
  BOOL v12 = a5 != 0;
  BOOL v23 = 0LL;
  if (getifaddrs(&v23))
  {
    if (!*__error())
    {
      uint64_t v13 = 4294960596LL;
      goto LABEL_43;
    }

    uint64_t v13 = *__error();
    if ((_DWORD)v13) {
      goto LABEL_43;
    }
  }

  for (int i = v23; i; int i = i->ifa_next)
  {
    if ((i->ifa_flags & 1) == 0) {
      continue;
    }
    ifa_addr = i->ifa_addr;
    if (!ifa_addr) {
      continue;
    }
    ifa_name = i->ifa_name;
    if (!ifa_name || strcmp(ifa_name, a2)) {
      continue;
    }
    int sa_family = ifa_addr->sa_family;
    switch(sa_family)
    {
      case 30:
        if (!v11)
        {
          BOOL v11 = 0;
          continue;
        }

        if ((a1 & 1) != 0 && (ifa_addr->sa_data[6] != 254 || (ifa_addr->sa_data[7] & 0xC0) != 0x80))
        {
          BOOL v11 = 1;
          continue;
        }

        BOOL v11 = 0;
        sockaddr v18 = *ifa_addr;
        uint64_t v19 = *(void *)&ifa_addr[1].sa_len;
        *(_DWORD *)(a4 + 24) = *(_DWORD *)&ifa_addr[1].sa_data[6];
        *(void *)(a4 + 16) = v19;
        *(sockaddr *)a4 = v18;
        break;
      case 18:
        if (!v12)
        {
          BOOL v12 = 0;
          continue;
        }

        if (ifa_addr->sa_data[4] != 6)
        {
          BOOL v12 = 1;
          continue;
        }

        BOOL v12 = 0;
        size_t v20 = &ifa_addr->sa_len + ifa_addr->sa_data[3];
        int v21 = *((_DWORD *)v20 + 2);
        *(_WORD *)(a5 + 4) = *((_WORD *)v20 + 6);
        *(_DWORD *)a5 = v21;
        break;
      case 2:
        if (!v10)
        {
          BOOL v10 = 0;
          continue;
        }

        if ((a1 & 2) != 0
          && ifa_addr->sa_data[2] == 169
          && ifa_addr->sa_data[3] == 254)
        {
          BOOL v10 = 1;
          continue;
        }

        BOOL v10 = 0;
        *a3 = *ifa_addr;
        break;
    }

    if (!v10 && !v11 && !v12)
    {
      BOOL v12 = 0;
      BOOL v11 = 0;
LABEL_40:
      if (v11 || v12) {
        uint64_t v13 = 4294960569LL;
      }
      else {
        uint64_t v13 = 0LL;
      }
      goto LABEL_43;
    }
  }

  if (!v10) {
    goto LABEL_40;
  }
  uint64_t v13 = 4294960569LL;
LABEL_43:
  if (v23) {
    MEMORY[0x186E42F24]();
  }
  return v13;
}

__int128 *SockAddrCopy(__int128 *result, uint64_t a2)
{
  int v2 = *((unsigned __int8 *)result + 1);
  if (*((_BYTE *)result + 1))
  {
    if (v2 == 30)
    {
      __int128 v3 = *result;
      uint64_t v4 = *((void *)result + 2);
      *(_DWORD *)(a2 + 24) = *((_DWORD *)result + 6);
      *(void *)(a2 + 16) = v4;
      goto LABEL_8;
    }

    if (v2 == 2)
    {
      __int128 v3 = *result;
LABEL_8:
      *(_OWORD *)a2 = v3;
    }
  }

  else
  {
    *(_BYTE *)(a2 + 1) = 0;
  }

  return result;
}

uint64_t DrainUDPSocket(int a1, int a2, _DWORD *a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v5 = mach_absolute_time();
  int v6 = 0;
  uint64_t v7 = MillisecondsToUpTicks(a2) + v5;
  memset(&v13, 0, sizeof(v13));
  while (1)
  {
    if (__darwin_check_fd_set_overflow(a1, &v13, 0)) {
      v13.fds_bits[(unint64_t)a1 >> 5] |= 1 << a1;
    }
    v12.tv_seCC_SHA1_CTX c = a2 / 1000;
    v12.tv_useCC_SHA1_CTX c = 1000 * (a2 % 1000);
    uint64_t result = select(a1 + 1, &v13, 0LL, 0LL, &v12);
    if ((_DWORD)result == 1) {
      goto LABEL_8;
    }
    if (!(_DWORD)result) {
      goto LABEL_14;
    }
    if (!*__error()) {
      break;
    }
    uint64_t result = *__error();
    if ((_DWORD)result) {
      goto LABEL_14;
    }
LABEL_8:
    socklen_t v10 = 28;
    if (recvfrom(a1, v14, 0x20uLL, 0, &v11, &v10) < 0)
    {
      if (!*__error()) {
        break;
      }
      uint64_t result = *__error();
      if ((_DWORD)result) {
        goto LABEL_14;
      }
    }

    ++v6;
    if (mach_absolute_time() >= v7)
    {
      uint64_t result = 0LL;
      goto LABEL_14;
    }
  }

  uint64_t result = 4294960596LL;
LABEL_14:
  if (a3) {
    *a3 = v6;
  }
  return result;
}

uint64_t GetPrimaryMACAddress(char *a1, int *a2)
{
  if (a1) {
    __int128 v3 = a1;
  }
  else {
    __int128 v3 = &v12;
  }
  *((_WORD *)v3 + 2) = 0;
  *(_DWORD *)__int128 v3 = 0;
  GestaltGetData(@"EthernetMacAddress", 0LL, v3, 6uLL, 0LL, &v13);
  int v4 = v13;
  if (v13)
  {
    GestaltGetData(@"WifiAddressData", 0LL, v3, 6uLL, 0LL, &v13);
    int v4 = v13;
    if (v13)
    {
      GestaltGetData(@"WifiAddress", 0LL, v3, 6uLL, 0LL, &v13);
      int v4 = v13;
    }
  }

  uint64_t v5 = *v3;
  uint64_t v6 = v3[1];
  uint64_t v7 = v3[2];
  uint64_t v8 = v3[3];
  uint64_t v9 = v3[4];
  uint64_t v10 = v3[5];
  if (a2) {
    *a2 = v4;
  }
  return (v5 << 40) | (v6 << 32) | (v7 << 24) | (v8 << 16) | (v9 << 8) | v10;
}

uint64_t OpenSelfConnectedLoopbackSocket(int *a1)
{
  int v2 = socket(2, 2, 17);
  if ((v2 & 0x80000000) == 0) {
    goto LABEL_2;
  }
  if (!*__error()) {
    return 4294960596LL;
  }
  uint64_t v3 = *__error();
  if (!(_DWORD)v3)
  {
LABEL_2:
    *(_DWORD *)&v6.sa_len = 512;
    *(void *)&v6.sa_data[6] = 0LL;
    *(_DWORD *)&v6.sa_data[2] = 16777343;
    if (bind(v2, &v6, 0x10u))
    {
      if (!*__error()) {
        goto LABEL_15;
      }
      uint64_t v3 = *__error();
      if ((_DWORD)v3) {
        goto LABEL_16;
      }
    }

    socklen_t v5 = 28;
    if (!getsockname(v2, &v6, &v5)) {
      goto LABEL_8;
    }
    if (*__error())
    {
      uint64_t v3 = *__error();
      if (!(_DWORD)v3)
      {
LABEL_8:
        if (!connect(v2, &v6, v5))
        {
LABEL_11:
          uint64_t v3 = 0LL;
          *a1 = v2;
          return v3;
        }

        if (*__error())
        {
          uint64_t v3 = *__error();
          if (!(_DWORD)v3) {
            goto LABEL_11;
          }
          goto LABEL_16;
        }

        goto LABEL_15;
      }

uint64_t SendSelfConnectedLoopbackMessage(int a1, const void *a2, size_t a3)
{
  socklen_t v9 = 28;
  if (getsockname(a1, &v10, &v9))
  {
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result) {
      return result;
    }
  }

  ssize_t v7 = sendto(a1, a2, a3, 0, &v10, 0x10u);
  uint64_t result = 0LL;
  if (v7 == a3) {
    return result;
  }
  if (!*__error()) {
    return 4294960596LL;
  }
  uint64_t result = *__error();
  if ((_DWORD)result == 56)
  {
    ssize_t v8 = send(a1, a2, a3, 0);
    uint64_t result = 0LL;
    if (v8 != a3)
    {
      if (*__error()) {
        return *__error();
      }
      return 4294960596LL;
    }
  }

  return result;
}

uint64_t ServerSocketPairOpen(int a1, int a2, int a3, int *a4, int a5, int *a6, int *a7)
{
  int v17 = -1;
  int v18 = a3;
  int v16 = -1;
  uint64_t v13 = ServerSocketOpenEx2(2, a1, a2, 0LL, 0, a3, (unsigned int *)&v18, a5, 0, &v17);
  int v14 = ServerSocketOpenEx2(30, a1, a2, 0LL, 0, v18, (unsigned int *)&v18, a5, 0, &v16);
  if ((_DWORD)v13 && v14)
  {
    if ((v17 & 0x80000000) == 0 && close(v17) && *__error()) {
      __error();
    }
    if ((v16 & 0x80000000) == 0 && close(v16) && *__error()) {
      __error();
    }
  }

  else
  {
    if (a4) {
      *a4 = v18;
    }
    uint64_t v13 = 0LL;
    *a6 = v17;
    *a7 = v16;
  }

  return v13;
}

uint64_t ServerSocketOpenEx2( int a1, int a2, int a3, __int128 *a4, int a5, int a6, unsigned int *a7, int a8, char a9, int *a10)
{
  if (a6 >= 0) {
    unsigned int v17 = a6;
  }
  else {
    unsigned int v17 = -a6;
  }
  int v18 = socket(a1, a2, a3);
  if ((v18 & 0x80000000) == 0) {
    goto LABEL_7;
  }
  if (!*__error()) {
    return 4294960596LL;
  }
  uint64_t v19 = *__error();
  if (!(_DWORD)v19)
  {
LABEL_7:
    int v28 = 1;
    setsockopt(v18, 0xFFFF, 4130, &v28, 4u);
    uint64_t v19 = SocketSetNonBlocking(v18, 1);
    if ((_DWORD)v19)
    {
LABEL_8:
      if ((v18 & 0x80000000) == 0 && close(v18) && *__error()) {
        __error();
      }
      return v19;
    }

    SocketSetBufferSize(v18, 4098, a8);
    int v33 = 1;
    if (a2 == 2) {
      int v20 = 512;
    }
    else {
      int v20 = 4;
    }
    if (setsockopt(v18, 0xFFFF, v20, &v33, 4u))
    {
      if (!*__error()) {
        goto LABEL_66;
      }
      uint64_t v19 = *__error();
      if ((_DWORD)v19) {
        goto LABEL_8;
      }
    }

    if (a1 == 30)
    {
      if ((a9 & 2) == 0)
      {
        int v33 = 1;
        if (setsockopt(v18, 41, 27, &v33, 4u))
        {
          if (!*__error()) {
            goto LABEL_66;
          }
          uint64_t v19 = *__error();
          if ((_DWORD)v19) {
            goto LABEL_8;
          }
        }
      }

      *(void *)&v31[10] = 0LL;
      *(_WORD *)&v31[8] = 0;
      *(_DWORD *)&v31[18] = 0;
      __int16 v30 = 7708;
      *(void *)unint64_t v31 = bswap32(v17) >> 16;
      if (a4) {
        __int128 v22 = *a4;
      }
      else {
        __int128 v22 = *MEMORY[0x1895FB7E8];
      }
      *(_OWORD *)&v31[6] = v22;
      int v32 = a5;
      if (!bind(v18, (const sockaddr *)&v30, 0x1Cu)) {
        goto LABEL_50;
      }
      if (*__error()) {
        uint64_t v19 = *__error();
      }
      else {
        uint64_t v19 = 4294960596LL;
      }
      if ((a6 & 0x80000000) == 0 || !(_DWORD)v19) {
        goto LABEL_49;
      }
      *(_WORD *)unint64_t v31 = 0;
      int v23 = v18;
      socklen_t v24 = 28;
    }

    else
    {
      if (a1 != 2)
      {
        uint64_t v19 = 4294960561LL;
        goto LABEL_8;
      }

      *(void *)&v31[6] = 0LL;
      __int16 v30 = 528;
      *(_WORD *)unint64_t v31 = bswap32(v17) >> 16;
      if (a4) {
        int v21 = *(_DWORD *)a4;
      }
      else {
        int v21 = 0;
      }
      *(_DWORD *)&v31[2] = v21;
      if (!bind(v18, (const sockaddr *)&v30, 0x10u)) {
        goto LABEL_50;
      }
      if (*__error()) {
        uint64_t v19 = *__error();
      }
      else {
        uint64_t v19 = 4294960596LL;
      }
      if ((a6 & 0x80000000) == 0 || !(_DWORD)v19) {
        goto LABEL_49;
      }
      *(_WORD *)unint64_t v31 = 0;
      int v23 = v18;
      socklen_t v24 = 16;
    }

    if (!bind(v23, (const sockaddr *)&v30, v24))
    {
LABEL_50:
      if (a2 == 1 && listen(v18, 128) && (!*__error() || *__error()) && listen(v18, 5))
      {
        if (!*__error()) {
          goto LABEL_66;
        }
        uint64_t v19 = *__error();
        if ((_DWORD)v19) {
          goto LABEL_8;
        }
      }

      if ((a9 & 1) != 0) {
        SocketSetP2P(v18, 1);
      }
      if (!a7) {
        goto LABEL_70;
      }
      socklen_t v29 = 28;
      if (!getsockname(v18, (sockaddr *)&v30, &v29))
      {
LABEL_63:
        if (HIBYTE(v30) == 30)
        {
          unsigned int v25 = a7;
        }

        else
        {
          unsigned int v25 = a7;
          if (HIBYTE(v30) != 2)
          {
            unsigned int v26 = -1;
LABEL_69:
            unsigned int *v25 = v26;
LABEL_70:
            uint64_t v19 = 0LL;
            *a10 = v18;
            return v19;
          }
        }

        unsigned int v26 = bswap32(*(unsigned __int16 *)v31) >> 16;
        goto LABEL_69;
      }

      if (*__error())
      {
        uint64_t v19 = *__error();
        if ((_DWORD)v19) {
          goto LABEL_8;
        }
        goto LABEL_63;
      }

uint64_t SocketSetNonBlocking(int a1, int a2)
{
  BOOL v3 = a2 != 0;
  int v4 = fcntl(a1, 3, 0LL);
  if (fcntl(a1, 4, v4 & 0xFFFFFFFB | (4 * v3)) != -1) {
    return 0LL;
  }
  if (*__error()) {
    return *__error();
  }
  return 4294960596LL;
}

uint64_t SocketSetBufferSize(int a1, int a2, int a3)
{
  int v13 = a3;
  uint64_t result = 4294960591LL;
  if ((a1 & 0x80000000) == 0 && (a2 - 4099) >= 0xFFFFFFFE)
  {
    if (a3 < 1)
    {
      if (a3 == -1)
      {
        return 0LL;
      }

      else
      {
        int v7 = -a3;
        size_t v11 = 4LL;
        if (sysctlbyname("kern.ipc.maxsockbuf", &v12, &v11, 0LL, 0LL) && (!*__error() || *__error())) {
          int v12 = 0x40000;
        }
        signed int v8 = (85 * v12 / 100 + 4095) & 0xFFFFF000;
        if (v8 > v7 && a3 < 0) {
          signed int v8 = v7;
        }
        int v12 = v8;
        do
        {
          uint64_t result = setsockopt(a1, 0xFFFF, a2, &v12, 4u);
          if (!(_DWORD)result) {
            break;
          }
          if (*__error())
          {
            uint64_t result = *__error();
            if (!(_DWORD)result) {
              return result;
            }
          }

          else
          {
            uint64_t result = 4294960596LL;
          }

          int v10 = v12;
          v12 -= 1024;
        }

        while (v10 > 33791);
      }
    }

    else
    {
      uint64_t result = setsockopt(a1, 0xFFFF, a2, &v13, 4u);
      if ((_DWORD)result)
      {
        if (*__error()) {
          return *__error();
        }
        else {
          return 4294960596LL;
        }
      }
    }
  }

  return result;
}

uint64_t SocketSetP2P(int a1, int a2)
{
  int v3 = a2;
  uint64_t result = setsockopt(a1, 0xFFFF, 4356, &v3, 4u);
  if ((_DWORD)result)
  {
    if (*__error()) {
      return *__error();
    }
    else {
      return 4294960596LL;
    }
  }

  return result;
}

uint64_t ServerSocketOpen(int a1, int a2, int a3, int a4, unsigned int *a5, int a6, int *a7)
{
  return ServerSocketOpenEx2(a1, a2, a3, 0LL, 0, a4, a5, a6, 0, a7);
}

uint64_t ServerSocketOpenEx(int a1, int a2, int a3, __int128 *a4, int a5, unsigned int *a6, int a7, int *a8)
{
  return ServerSocketOpenEx2(a1, a2, a3, a4, 0, a5, a6, a7, 0, a8);
}

uint64_t SockAddrGetPort(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 1);
  if (v1 == 30 || v1 == 2) {
    return bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t UDPClientSocketOpen(int a1, __int128 *a2, signed int a3, int a4, unsigned int *a5, int *a6)
{
  int v10 = a1;
  if (a2)
  {
    uint64_t v11 = SockAddrSimplify(a2, (uint64_t)&v24[4]);
    if ((_DWORD)v11) {
      return v11;
    }
    if (!v10) {
      int v10 = v24[5];
    }
    int v12 = &v24[4];
  }

  else
  {
    if (!a1) {
      return 4294960591LL;
    }
    int v12 = 0LL;
  }

  int v13 = socket(v10, 2, 17);
  if ((v13 & 0x80000000) == 0) {
    goto LABEL_9;
  }
  if (!*__error()) {
    return 4294960596LL;
  }
  uint64_t v11 = *__error();
  if (!(_DWORD)v11)
  {
LABEL_9:
    int v21 = 1;
    setsockopt(v13, 0xFFFF, 4130, &v21, 4u);
    SocketSetNonBlocking(v13, 1);
    if (a4 == -1)
    {
      if (!v12) {
        goto LABEL_56;
      }
      goto LABEL_21;
    }

    if (a4 >= 0) {
      unsigned int v14 = a4;
    }
    else {
      unsigned int v14 = -a4;
    }
    if (v10 == 30)
    {
      *(_WORD *)int v23 = 7708;
      *(_WORD *)&v23[2] = bswap32(v14) >> 16;
      *(_DWORD *)&v23[4] = 0;
      *(_OWORD *)&v23[8] = *MEMORY[0x1895FB7E8];
      uint64_t v15 = v24;
      socklen_t v16 = 28;
    }

    else
    {
      if (v10 != 2)
      {
        uint64_t v11 = 4294960561LL;
        goto LABEL_64;
      }

      *(void *)&v23[8] = 0LL;
      *(_WORD *)int v23 = 528;
      *(_WORD *)&v23[2] = bswap32(v14) >> 16;
      uint64_t v15 = &v23[4];
      socklen_t v16 = 16;
    }

    *(_DWORD *)uint64_t v15 = 0;
    socklen_t v22 = v16;
    if (bind(v13, (const sockaddr *)v23, v16))
    {
      if (*__error())
      {
        uint64_t v11 = *__error();
        if ((a4 & 0x80000000) == 0)
        {
LABEL_43:
          if ((_DWORD)v11) {
            goto LABEL_64;
          }
          goto LABEL_44;
        }
      }

      else
      {
        uint64_t v11 = 4294960596LL;
        if ((a4 & 0x80000000) == 0) {
          goto LABEL_43;
        }
      }

      if (!(_DWORD)v11) {
        goto LABEL_43;
      }
      if (v23[1] == 30 || v23[1] == 2) {
        *(_WORD *)&v23[2] = 0;
      }
      if (bind(v13, (const sockaddr *)v23, v16))
      {
        if (!*__error()) {
          goto LABEL_63;
        }
        uint64_t v11 = *__error();
        goto LABEL_43;
      }
    }

uint64_t SockAddrSimplify(__int128 *a1, uint64_t a2)
{
  int v2 = *((unsigned __int8 *)a1 + 1);
  if (v2 == 30)
  {
    unsigned int v5 = *((_DWORD *)a1 + 2);
    if (v5)
    {
      if ((*((_DWORD *)a1 + 2) & 0xC0FF) == 0x80FE)
      {
        uint64_t v3 = 0LL;
        uint64_t v6 = *(void *)((char *)a1 + 12);
        int v7 = (v5 >> 8) & 0xFF00 | HIBYTE(v5);
        int v8 = *((_DWORD *)a1 + 5);
        if (*((_DWORD *)a1 + 6)) {
          int v7 = *((_DWORD *)a1 + 6);
        }
        unsigned __int16 v9 = *((_WORD *)a1 + 4);
        *(void *)a2 = *(void *)a1;
        *(_DWORD *)(a2 + 8) = v9;
        *(void *)(a2 + 12) = v6;
        *(_DWORD *)(a2 + 20) = v8;
        *(_DWORD *)(a2 + 24) = v7;
        return v3;
      }

uint64_t SockAddrSetPort(uint64_t result, unsigned int a2)
{
  int v2 = *(unsigned __int8 *)(result + 1);
  if (v2 == 30 || v2 == 2) {
    *(_WORD *)(result + 2) = bswap32(a2) >> 16;
  }
  return result;
}

uint64_t SockAddrGetSize(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 1);
  if (v1 == 30) {
    unsigned int v2 = 28;
  }
  else {
    unsigned int v2 = 0;
  }
  if (v1 == 2) {
    return 16LL;
  }
  else {
    return v2;
  }
}

uint64_t UpdateIOVec(uint64_t **a1, int *a2, unint64_t a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = (unint64_t)&(*a1)[2 * v3];
  for (int i = *a1 + 1; ; i += 2)
  {
    uint64_t v6 = i - 1;
    uint64_t v7 = *(i - 1);
    uint64_t v8 = *i;
    unint64_t v9 = a3 - *i;
    if (a3 < *i) {
      break;
    }
    *(i - 1) = v7 + v8;
    uint64_t *i = 0LL;
    uint64_t v10 = i + 1;
    a3 = v9;
  }

  *(i - 1) = v7 + a3;
  uint64_t *i = (v8 - a3);
  *a1 = v6;
  *a2 = (v4 - (unint64_t)v6) >> 4;
  return 35LL;
}

uint64_t NetSocket_Create(void *a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  unsigned int v2 = calloc(1uLL, 0x78uLL);
  if (!v2) {
    return 4294960568LL;
  }
  uint64_t v3 = v2;
  *unsigned int v2 = -2441908381LL;
  *(void *)((char *)v2 + 12) = -1LL;
  if (!pipe(&v8)) {
    goto LABEL_5;
  }
  if (!*__error())
  {
    uint64_t v4 = 4294960596LL;
    goto LABEL_7;
  }

  uint64_t v4 = *__error();
  if ((_DWORD)v4)
  {
LABEL_7:
    NetSocket_Delete(v3);
    return v4;
  }

uint64_t NetSocket_ReadInternal( uint64_t a1, size_t a2, uint64_t a3, char *__dst, size_t *a5, int a6, unsigned int a7)
{
  if (a1 && *(_DWORD *)a1 == 1853058915)
  {
    if (*(_BYTE *)(a1 + 8))
    {
      size_t v16 = 0LL;
      uint64_t result = 4294960573LL;
    }

    else if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
    {
      size_t v16 = 0LL;
      uint64_t result = 4294960551LL;
    }

    else
    {
      uint64_t v11 = __dst;
      int64_t v12 = a3;
      __int16 v14 = *(const void **)(a1 + 64);
      uint64_t v15 = *(void *)(a1 + 72) - (void)v14;
      if (v15 < 1)
      {
        size_t v16 = 0LL;
      }

      else
      {
        if (v15 >= a3) {
          size_t v16 = a3;
        }
        else {
          size_t v16 = *(void *)(a1 + 72) - (void)v14;
        }
        memcpy(__dst, v14, v16);
        *(void *)(a1 + 64) += v16;
        v11 += v16;
        v12 -= v16;
      }

      if (v12 >= 1)
      {
        while (1)
        {
          ssize_t v17 = recv(*(_DWORD *)(a1 + 4), v11, v12, a6);
          if (v17 >= 1) {
            break;
          }
          if (!v17)
          {
            if (v16 >= a2) {
              uint64_t result = 0LL;
            }
            else {
              uint64_t result = 4294960543LL;
            }
            goto LABEL_28;
          }

          if (!*__error())
          {
            uint64_t result = 4294960596LL;
            goto LABEL_28;
          }

          uint64_t result = *__error();
          if ((_DWORD)result != 4)
          {
            if ((_DWORD)result != 35) {
              goto LABEL_28;
            }
            if (v16 >= a2) {
              goto LABEL_23;
            }
            uint64_t result = NetSocket_Wait(a1, *(_DWORD *)(a1 + 4), 0, a7);
            if ((_DWORD)result) {
              goto LABEL_28;
            }
LABEL_21:
            uint64_t result = 0LL;
            if (v12 <= 0) {
              goto LABEL_28;
            }
          }
        }

        v11 += v17;
        v12 -= v17;
        v16 += v17;
        goto LABEL_21;
      }

uint64_t NetSocket_WriteInternal(uint64_t a1, char *__buf, size_t __nbyte, unsigned int a4)
{
  if (!a1) {
    return 4294960556LL;
  }
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  if (*(_BYTE *)(a1 + 8)) {
    return 4294960573LL;
  }
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0) {
    return 4294960551LL;
  }
  size_t v5 = __nbyte;
  while (v5)
  {
    ssize_t v8 = write(*(_DWORD *)(a1 + 4), __buf, v5);
    if (v8 < 1)
    {
      if (!*__error()) {
        return 4294960596LL;
      }
      uint64_t result = *__error();
      if ((_DWORD)result != 4)
      {
        if ((_DWORD)result != 35) {
          return result;
        }
        uint64_t result = NetSocket_Wait(a1, *(_DWORD *)(a1 + 4), 1, a4);
        if ((_DWORD)result) {
          return result;
        }
      }
    }

    else
    {
      __buf += v8;
      v5 -= v8;
    }
  }

  return 0LL;
}

uint64_t NetSocket_WriteVInternal(uint64_t a1, iovec *a2, int a3, unsigned int a4)
{
  if (!a1) {
    return 4294960556LL;
  }
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  if (*(_BYTE *)(a1 + 8)) {
    return 4294960573LL;
  }
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0) {
    return 4294960551LL;
  }
  int v5 = a3;
  if (!a3) {
    return 0LL;
  }
  while (1)
  {
    while (1)
    {
      ssize_t v8 = writev(*(_DWORD *)(a1 + 4), a2, v5);
      if (v8 < 1) {
        break;
      }
      if (v5 < 1)
      {
        if (!v5) {
          return 0LL;
        }
        int64_t iov_len = a2->iov_len;
      }

      else
      {
        while (1)
        {
          int64_t iov_len = a2->iov_len;
          if (v8 < iov_len) {
            break;
          }
          ++a2;
          v8 -= iov_len;
          BOOL v11 = __OFSUB__(v5--, 1);
          if ((v5 < 0) ^ v11 | (v5 == 0)) {
            return 0LL;
          }
        }
      }

      a2->iov_base = (char *)a2->iov_base + v8;
      a2->int64_t iov_len = iov_len - v8;
    }

    if (!v8) {
      return 4294960591LL;
    }
    if (!*__error()) {
      break;
    }
    uint64_t result = *__error();
    if ((_DWORD)result != 4)
    {
      if ((_DWORD)result != 35) {
        return result;
      }
      uint64_t result = NetSocket_Wait(a1, *(_DWORD *)(a1 + 4), 1, a4);
      if ((_DWORD)result) {
        return result;
      }
    }
  }

  return 4294960596LL;
}

uint64_t NetSocket_WriteFileSlow( uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, off_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  if (*(void *)(a1 + 112)) {
    size_t v16 = *(int **)(a1 + 112);
  }
  else {
    size_t v16 = (int *)&gLogCategory_NetSocket;
  }
  mach_absolute_time();
  if (SecondsToUpTicks_sOnce != -1) {
    dispatch_once_f(&SecondsToUpTicks_sOnce, &SecondsToUpTicks_sMultiplier, (dispatch_function_t)_SecondsToUpTicksInit);
  }
  uint64_t v46 = SecondsToUpTicks_sMultiplier;
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  if (*(_DWORD *)a1 != 1853058915)
  {
    char v20 = 0;
    uint64_t v35 = 4294960556LL;
    goto LABEL_52;
  }

  if (*(_BYTE *)(a1 + 8))
  {
    char v20 = 0;
    uint64_t v35 = 4294960573LL;
    goto LABEL_52;
  }

  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
  {
    char v20 = 0;
    uint64_t v35 = 4294960551LL;
    goto LABEL_52;
  }

  if (lseek(a6, a7, 0) == -1)
  {
    if (!*__error())
    {
      char v20 = 0;
      uint64_t v35 = 4294960596LL;
      goto LABEL_52;
    }

    uint64_t v35 = *__error();
    if ((_DWORD)v35) {
      goto LABEL_40;
    }
  }

  if (a8 >= 1)
  {
    uint64_t v43 = a4;
    ssize_t v17 = malloc(0x100000uLL);
    if (!v17)
    {
      char v20 = 0;
      uint64_t v35 = 4294960568LL;
      goto LABEL_52;
    }

    int v18 = v17;
    unsigned int v42 = a5;
    uint64_t v45 = v16;
    uint64_t v19 = 0LL;
    char v20 = 0;
    char v21 = 1;
    while (1)
    {
      size_t v22 = a8 >= 0x100000 ? 0x100000LL : a8;
      ssize_t v23 = read(a6, v18, v22);
      ssize_t v24 = v23;
      if (v23 < 1) {
        break;
      }
      if ((v21 & 1) != 0)
      {
        if ((int)a3 < 1)
        {
          int v25 = 0;
        }

        else
        {
          memcpy(__dst, a2, 16LL * a3);
          int v25 = a3;
        }

        BOOL v27 = &__dst[v25];
        void *v27 = v18;
        v27[1] = v24;
        uint64_t v26 = (*(uint64_t (**)(uint64_t, _OWORD *, void, void))(a1 + 40))( a1,  __dst,  (v25 + 1),  a9);
        if ((_DWORD)v26)
        {
LABEL_44:
          uint64_t v35 = v26;
LABEL_50:
          size_t v16 = v45;
          goto LABEL_51;
        }
      }

      else
      {
        uint64_t v26 = (*(uint64_t (**)(uint64_t, void *, ssize_t, void))(a1 + 32))(a1, v18, v23, a9);
        if ((_DWORD)v26) {
          goto LABEL_44;
        }
      }

      v20 += v24;
      uint64_t v28 = mach_absolute_time();
      if (v28 >= v19)
      {
        uint64_t v33 = v28;
        if (*v45 <= 40 && (*v45 != -1 || _LogCategory_Initialize((uint64_t)v45, 0x28u))) {
          LogPrintF( (uint64_t)v45,  (uint64_t)"OSStatus NetSocket_WriteFileSlow(NetSocketRef, iovec_t *, int, iovec_t *, int, FDRef, int64_t, int64_t, int32_t)",  0x28u,  (uint64_t)"Wrote %10lld of %10lld, %6.2f%%, %6.2f Mbit/sec\n",  v29,  v30,  v31,  v32,  v20);
        }
        uint64_t v19 = v33 + v46;
      }

      char v21 = 0;
      BOOL v34 = a8 <= v24;
      a8 -= v24;
      if (v34)
      {
        size_t v16 = v45;
        goto LABEL_47;
      }
    }

    if (!v23)
    {
      uint64_t v35 = 4294960546LL;
      goto LABEL_50;
    }

    size_t v16 = v45;
    if (*__error()) {
      uint64_t v35 = *__error();
    }
    else {
      uint64_t v35 = 4294960596LL;
    }
    goto LABEL_51;
  }

  uint64_t v36 = (*(uint64_t (**)(uint64_t, const void *, uint64_t, void))(a1 + 40))(a1, a2, a3, a9);
  if ((_DWORD)v36)
  {
    uint64_t v35 = v36;
LABEL_40:
    char v20 = 0;
    goto LABEL_52;
  }

  uint64_t v43 = a4;
  unsigned int v42 = a5;
  char v20 = 0;
  int v18 = 0LL;
LABEL_47:
  uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(a1 + 40))(a1, v43, v42, a9);
  if (v18) {
LABEL_51:
  }
    free(v18);
LABEL_52:
  mach_absolute_time();
  if (*v16 <= 40 && (*v16 != -1 || _LogCategory_Initialize((uint64_t)v16, 0x28u))) {
    LogPrintF( (uint64_t)v16,  (uint64_t)"OSStatus NetSocket_WriteFileSlow(NetSocketRef, iovec_t *, int, iovec_t *, int, FDRef, int64_t, int64_t, int32_t)",  0x28u,  (uint64_t)"Wrote %lld of %lld, %6.2f Mbit/sec: %#m\n",  v37,  v38,  v39,  v40,  v20);
  }
  return v35;
}

uint64_t NetSocket_Delete(void *a1)
{
  if (!a1) {
    return 4294960556LL;
  }
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  unsigned int v2 = (void (*)(void *))a1[7];
  if (v2) {
    v2(a1);
  }
  int v3 = *((_DWORD *)a1 + 1);
  if ((v3 & 0x80000000) == 0)
  {
    if (close(v3) && *__error()) {
      __error();
    }
    *((_DWORD *)a1 + 1) = -1;
  }

  int v4 = *((_DWORD *)a1 + 3);
  if ((v4 & 0x80000000) == 0)
  {
    if (close(v4) && *__error()) {
      __error();
    }
    *((_DWORD *)a1 + 3) = -1;
  }

  int v5 = *((_DWORD *)a1 + 4);
  if ((v5 & 0x80000000) == 0)
  {
    if (close(v5) && *__error()) {
      __error();
    }
    *((_DWORD *)a1 + 4) = -1;
  }

  int v6 = (void *)a1[10];
  if (v6) {
    free(v6);
  }
  free(a1);
  return 0LL;
}

uint64_t NetSocket_Wait(uint64_t a1, unsigned int a2, int a3, unsigned int a4)
{
  if (!a1) {
    return 4294960556LL;
  }
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  if (*(_BYTE *)(a1 + 8)) {
    return 4294960573LL;
  }
  if ((a2 & 0x80000000) != 0) {
    return 4294960551LL;
  }
  memset(&v20, 0, sizeof(v20));
  int v8 = *(_DWORD *)(a1 + 16);
  if (__darwin_check_fd_set_overflow(v8, &v20, 0)) {
    *(__int32_t *)((char *)v20.fds_bits + (((unint64_t)v8 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v8;
  }
  if (a3 == 2)
  {
    if (__darwin_check_fd_set_overflow(a2, &v20, 0)) {
      v20.fds_bits[a2 >> 5] |= 1 << a2;
    }
  }

  else if (a3 != 1)
  {
    if (a3) {
      return 4294960591LL;
    }
    int v9 = &v20;
    uint64_t v10 = 0LL;
    if (!__darwin_check_fd_set_overflow(a2, &v20, 0)) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  memset(v19, 0, sizeof(v19));
  int v9 = (fd_set *)v19;
  uint64_t v10 = (fd_set *)v19;
  if (__darwin_check_fd_set_overflow(a2, v19, 0)) {
LABEL_15:
  }
    v9->fds_bits[a2 >> 5] |= 1 << a2;
LABEL_16:
  if ((a4 & 0x80000000) != 0)
  {
    BOOL v11 = 0LL;
  }

  else
  {
    uint64_t v17 = a4;
    int v18 = 0;
    BOOL v11 = (timeval *)&v17;
  }

  signed int v12 = *(_DWORD *)(a1 + 16);
  int v13 = v12 + 1;
  while (1)
  {
    int v14 = select(v13, &v20, v10, 0LL, v11);
    if ((v14 & 0x80000000) == 0) {
      break;
    }
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result != 4) {
      return result;
    }
  }

  if (!v14) {
    return 4294960574LL;
  }
  int v16 = *(_DWORD *)(a1 + 16);
  if (__darwin_check_fd_set_overflow(v16, &v20, 0)
    && ((*(unsigned int *)((char *)v20.fds_bits + (((unint64_t)v16 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v16) & 1) != 0)
  {
    return 4294960573LL;
  }

  return 0LL;
}

uint64_t NetSocket_CreateWithNative(void *a1, int a2)
{
  if (a2 < 0) {
    return 4294960591LL;
  }
  uint64_t result = NetSocket_Create(&v6);
  if (!(_DWORD)result)
  {
    uint64_t v5 = v6;
    *(_DWORD *)(v6 + 4) = a2;
    *a1 = v5;
  }

  return result;
}

uint64_t NetSocket_GetNative(_DWORD *a1)
{
  if (a1 && *a1 == 1853058915) {
    return a1[1];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t NetSocket_Cancel(uint64_t a1)
{
  if (!a1) {
    return 4294960556LL;
  }
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  if (*(_BYTE *)(a1 + 8)) {
    return 0LL;
  }
  *(_BYTE *)(a1 + 8) = 1;
  if (write(*(_DWORD *)(a1 + 12), "Q", 1uLL) == 1) {
    return 0LL;
  }
  if (*__error()) {
    return *__error();
  }
  return 4294960596LL;
}

uint64_t NetSocket_Reset(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (!a1 || *(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  uint64_t v2 = 99LL;
  while (read(*(_DWORD *)(a1 + 16), v5, 0x10uLL) >= 1 && v2-- != 0)
    ;
  uint64_t result = 0LL;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

uint64_t NetSocket_TCPConnect(uint64_t a1, _BYTE *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!a1 || *(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  if (*(_BYTE *)(a1 + 8)) {
    return 4294960573LL;
  }
  uint64_t v5 = a2;
  int v6 = *a2;
  if (!*a2) {
    return 4294960543LL;
  }
  unsigned int v20 = bswap32(a3) >> 16;
  int v9 = -1;
  while (1)
  {
    uint64_t v10 = v5;
    if (v6)
    {
      do
      {
        if (v6 == 44) {
          break;
        }
        int v11 = *++v10;
        int v6 = v11;
      }

      while (v11);
    }

    __memcpy_chk();
    v26[v10 - v5] = 0;
    if (*v10) {
      uint64_t v5 = v10 + 1;
    }
    else {
      uint64_t v5 = v10;
    }
    if (!StringToSockAddr((unsigned __int8 *)v26, (uint64_t)&v24, 0x1CuLL, &v23))
    {
      int v9 = socket(v24.sa_family, 1, 6);
      if ((v9 & 0x80000000) == 0)
      {
        if ((v24.sa_family == 30 || v24.sa_family == 2)
          && !*(_WORD *)v24.sa_data
          && (v24.sa_family == 30 || v24.sa_family == 2))
        {
          *(_WORD *)v24.sa_data = v20;
        }

        int v13 = _NetSocket_Connect(a1, v9, &v24, a4);
        if (!v13) {
          return 0LL;
        }
        int v14 = v13;
        close(v9);
        uint64_t result = 4294960573LL;
        if (v14 == -6723) {
          return result;
        }
        int v9 = -1;
      }

      goto LABEL_39;
    }

    for (int i = v26; *i; ++i)
    {
      if (*i == 58)
      {
        char *i = 0;
        int v16 = strtoul(i + 1, 0LL, 10);
        if (v16) {
          goto LABEL_30;
        }
        break;
      }
    }

    int v16 = a3;
LABEL_30:
    if (v16 >= 1)
    {
      snprintf(__str, 0x20uLL, "%u", v16);
      memset(&v22, 0, sizeof(v22));
      v22.ai_socktype = 1;
      if (!getaddrinfo(v26, __str, &v22, &v21))
      {
        uint64_t v17 = v21;
        if (v21) {
          break;
        }
      }
    }

uint64_t StringToSockAddr(unsigned __int8 *a1, uint64_t a2, unint64_t a3, void *a4)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  int v55 = 0;
  if (!StringToIPv4Address(a1, &v56, &v55))
  {
    if (a3 >= 0x10)
    {
      *(void *)(a2 + 8) = 0LL;
      *(_WORD *)a2 = 528;
      *(_WORD *)(a2 + 2) = bswap32((unsigned __int16)v55) >> 16;
      *(_DWORD *)(a2 + 4) = bswap32(v56);
      uint64_t result = 0LL;
      if (a4) {
        *a4 = 16LL;
      }
      return result;
    }

    return 4294960553LL;
  }

  if (a3 < 0x1C) {
    return 4294960553LL;
  }
  if (!a1) {
    return 4294960591LL;
  }
  if (*a1 == 91) {
    int v8 = a1 + 1;
  }
  else {
    int v8 = a1;
  }
  *(void *)v58 = v8;
  __int128 v57 = 0uLL;
  if (*v8 == 58)
  {
    int v9 = *++v8;
    *(void *)v58 = v8;
    if (v9 != 58) {
      return 4294960554LL;
    }
  }

  unint64_t v10 = 0LL;
  int v11 = 0LL;
LABEL_10:
  unsigned int v12 = 0;
  int v13 = v8;
  int v14 = v11;
  while (2)
  {
    int v11 = v14;
    int v8 = v13 + 1;
    char v15 = 1;
    while (1)
    {
      int v16 = *(v8 - 1);
      if ((v16 - 37) <= 0x38 && ((1LL << (v16 - 37)) & 0x100000000000401LL) != 0
        || v16 == 0)
      {
        *(void *)v58 = v8;
        goto LABEL_35;
      }

      int v16 = (char)v16;
      uint64_t v19 = v16 - 48LL;
      char v15 = 0;
      ++v8;
      int v21 = ParseIPv6Address_kASCIItoHexTable[v19];
      int v22 = (unsigned __int16)(v12 >> 12);
      unsigned int v12 = v21 | (16 * v12);
      if (v22) {
        return 4294960586LL;
      }
    }

    if (v16 == 58)
    {
      if ((v15 & 1) != 0)
      {
        int v13 = v8;
        int v14 = &v58[v10 - 16];
        if (!v11) {
          continue;
        }
        return 4294960554LL;
      }

      *(void *)v58 = v8;
      if (*v8)
      {
        if (v10 <= 0xE)
        {
          uint64_t v23 = v10 | 1;
          v58[v10 - 16] = BYTE1(v12);
          v10 += 2LL;
          v58[v23 - 16] = v12;
          goto LABEL_10;
        }

        return 4294960545LL;
      }

      return 4294960546LL;
    }

    break;
  }

  *(void *)v58 = v8;
  if (v16 == 46 && v10 <= 0xC)
  {
    uint64_t result = ParseIPv4Address(v13, &v58[v10 - 16], (unsigned __int8 **)v58);
    if ((_DWORD)result) {
      return result;
    }
    v10 += 4LL;
    int v8 = (unsigned __int8 *)++*(void *)v58;
    if (!v11) {
      goto LABEL_53;
    }
LABEL_39:
    if ((uint64_t)v10 <= 15)
    {
      int v25 = (char *)(&v58[v10 - 16] - v11);
      if ((int)(&v58[v10 - 16] - (_DWORD)v11) >= 1)
      {
        uint64_t v26 = ((_DWORD)v25 + 1) - 1LL;
        uint64_t v27 = (char *)&v57 + 15;
        uint64_t v28 = &v11[(int)v25 - 1];
        do
        {
          *v27-- = *v28;
          *v28-- = 0;
          --v26;
        }

        while (v26);
        int v8 = *(unsigned __int8 **)v58;
      }

      goto LABEL_54;
    }

    return 4294960545LL;
  }

uint64_t _NetSocket_Connect(uint64_t a1, unsigned int a2, const sockaddr *a3, unsigned int a4)
{
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  if (*(_BYTE *)(a1 + 8)) {
    return 4294960573LL;
  }
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) == 0) {
    return 4294960575LL;
  }
  uint64_t result = SocketSetNonBlocking(a2, 1);
  if (!(_DWORD)result)
  {
    int sa_family = a3->sa_family;
    int v10 = sa_family == 30 ? 28 : 0;
    socklen_t v11 = sa_family == 2 ? 16 : v10;
    if (!connect(a2, a3, v11)
      || (uint64_t result = NetSocket_Wait(a1, a2, 2, a4), !(_DWORD)result)
      && ((v13 = 4, unsigned int v14 = 0, LODWORD(result) = getsockopt(a2, 0xFFFF, 4103, &v14, &v13), (_DWORD)result)
        ? (uint64_t result = result)
        : (uint64_t result = v14),
          !(_DWORD)result))
    {
      int v12 = 1;
      setsockopt(a2, 0xFFFF, 4130, &v12, 4u);
      unsigned int v14 = 1;
      setsockopt(a2, 6, 1, &v14, 4u);
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 4) = a2;
    }
  }

  return result;
}

uint64_t NetSocket_Disconnect(uint64_t a1, unsigned int a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!a1 || *(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  if ((a2 & 0x80000000) != 0)
  {
    uint64_t v5 = 4294960591LL;
    goto LABEL_21;
  }

  if (*(_BYTE *)(a1 + 8))
  {
    uint64_t v5 = 4294960573LL;
    goto LABEL_21;
  }

  int v4 = *(_DWORD *)(a1 + 4);
  if (v4 < 0)
  {
    uint64_t v5 = 4294960551LL;
    goto LABEL_21;
  }

  if (!shutdown(v4, 1)) {
    goto LABEL_9;
  }
  if (*__error())
  {
    uint64_t v5 = *__error();
    if (!(_DWORD)v5)
    {
LABEL_9:
      uint64_t v6 = mach_absolute_time();
      unint64_t v7 = UpTicksToMicroseconds(v6) + 1000000LL * a2;
      while (1)
      {
        ssize_t v8 = recv(*(_DWORD *)(a1 + 4), v13, 0x20uLL, 0);
        if (v8 > 0) {
          goto LABEL_16;
        }
        if (!v8)
        {
          uint64_t v5 = 0LL;
          break;
        }

        if (!*__error()) {
          goto LABEL_18;
        }
        uint64_t v5 = *__error();
        if ((_DWORD)v5 != 4)
        {
          if ((_DWORD)v5 != 35) {
            break;
          }
          uint64_t v9 = NetSocket_Wait(a1, *(_DWORD *)(a1 + 4), 0, a2);
          if ((_DWORD)v9)
          {
            uint64_t v5 = v9;
            break;
          }

uint64_t NetSocket_WriteVSlow(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  if (!a1) {
    return 4294960556LL;
  }
  if (*(_DWORD *)a1 != 1853058915) {
    return 4294960556LL;
  }
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t v6 = a2;
  unint64_t v7 = (unint64_t)&a2[2 * a3];
  while (1)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, void, uint64_t))(a1 + 32))(a1, *v6, v6[1], a4);
    if ((_DWORD)result) {
      break;
    }
    v6 += 2;
  }

  return result;
}

uint64_t NetSocket_ReadFile(uint64_t a1, uint64_t a2, int a3, off_t a4, uint64_t a5)
{
  uint64_t v8 = a2;
  if (a2 >= 0x400000) {
    size_t v10 = 0x400000LL;
  }
  else {
    size_t v10 = a2;
  }
  size_t __nbyte = v10;
  if (v10 > *(void *)(a1 + 88))
  {
    int v11 = *(void **)(a1 + 80);
    if (v11) {
      free(v11);
    }
    int v12 = malloc(v10);
    *(void *)(a1 + 80) = v12;
    if (!v12)
    {
      uint64_t v20 = 4294960568LL;
      goto LABEL_27;
    }

    *(void *)(a1 + 88) = v10;
  }

  if (lseek(a3, a4, 0) != -1) {
    goto LABEL_10;
  }
  if (*__error())
  {
    uint64_t v20 = *__error();
    if (!(_DWORD)v20)
    {
      while (1)
      {
LABEL_10:
        if (v8 < 1)
        {
          uint64_t v20 = 0LL;
          goto LABEL_27;
        }

        uint64_t v13 = *(void *)(a1 + 80);
        if (v8 >= *(void *)(a1 + 88)) {
          size_t v14 = *(void *)(a1 + 88);
        }
        else {
          size_t v14 = v8;
        }
        size_t __nbyte = v14;
        uint64_t v15 = (*(uint64_t (**)(uint64_t, size_t, size_t, uint64_t, size_t *, void, uint64_t))(a1 + 24))( a1,  v14,  v14,  v13,  &__nbyte,  0LL,  a5);
        if ((_DWORD)v15)
        {
          uint64_t v20 = v15;
          goto LABEL_27;
        }

        size_t v16 = __nbyte;
        if (__nbyte) {
          break;
        }
LABEL_21:
        v8 -= v16;
      }

      uint64_t v17 = *(char **)(a1 + 80);
      size_t v18 = __nbyte;
      while (1)
      {
        ssize_t v19 = write(a3, v17, v18);
        if (v19 <= 0)
        {
          if (!*__error()) {
            goto LABEL_25;
          }
          uint64_t v20 = *__error();
          if ((_DWORD)v20) {
            break;
          }
        }

        v17 += v19;
        size_t v18 = __nbyte - v19;
        __nbyte -= v19;
        if (!__nbyte) {
          goto LABEL_21;
        }
      }
    }
  }

  else
  {
LABEL_25:
    uint64_t v20 = 4294960596LL;
  }

uint64_t TCPConnect(_BYTE *a1, char *__str, int a3, int *a4)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (__str) {
    unsigned int v7 = strtoul(__str, 0LL, 10);
  }
  else {
    unsigned int v7 = 0;
  }
  int v8 = *a1;
  if (!*a1) {
    return 4294960543LL;
  }
  unsigned int v9 = bswap32(v7) >> 16;
  while (1)
  {
    size_t v10 = a1;
    if (v8)
    {
      do
      {
        if (v8 == 44) {
          break;
        }
        int v11 = *++v10;
        int v8 = v11;
      }

      while (v11);
    }

    __memcpy_chk();
    v24[v10 - a1] = 0;
    if (*v10) {
      a1 = v10 + 1;
    }
    else {
      a1 = v10;
    }
    if (StringToSockAddr((unsigned __int8 *)v24, (uint64_t)&v22, 0x1CuLL, &v21))
    {
      for (uint64_t i = v24; *i; ++i)
      {
        if (*i == 58)
        {
          char *i = 0;
          int v15 = strtoul(i + 1, 0LL, 10);
          if (v15) {
            goto LABEL_29;
          }
          break;
        }
      }

      int v15 = v7;
LABEL_29:
      if (v15 >= 1)
      {
        snprintf(__stra, 0x20uLL, "%u", v15);
        memset(&v20, 0, sizeof(v20));
        v20.ai_socktype = 1;
        if (!getaddrinfo(v24, __stra, &v20, &v19))
        {
          size_t v16 = v19;
          if (v19)
          {
            while (1)
            {
              int v17 = socket(v16->ai_family, v16->ai_socktype, v16->ai_protocol);
              if ((v17 & 0x80000000) == 0)
              {
                int v14 = v17;
                if (!SocketConnect(v17, v16->ai_addr, a3))
                {
                  freeaddrinfo(v19);
                  goto LABEL_40;
                }

                close(v14);
              }

              size_t v16 = v16->ai_next;
              if (!v16)
              {
                freeaddrinfo(v19);
                break;
              }
            }
          }
        }
      }
    }

    else
    {
      int v13 = socket(v22.sa_family, 1, 6);
      if ((v13 & 0x80000000) == 0)
      {
        int v14 = v13;
        if ((v22.sa_family == 30 || v22.sa_family == 2)
          && !*(_WORD *)v22.sa_data
          && (v22.sa_family == 30 || v22.sa_family == 2))
        {
          *(_WORD *)v22.sa_data = v9;
        }

        if (!SocketConnect(v13, &v22, a3))
        {
LABEL_40:
          uint64_t result = 0LL;
          *a4 = v14;
          return result;
        }

        close(v14);
      }
    }

    int v8 = *a1;
    if (!*a1) {
      return 4294960543LL;
    }
  }

uint64_t SocketConnect(int a1, const sockaddr *a2, int a3)
{
  uint64_t result = SocketSetNonBlocking(a1, 1);
  if ((_DWORD)result) {
    return result;
  }
  int v11 = 1;
  setsockopt(a1, 0xFFFF, 4130, &v11, 4u);
  unsigned int v13 = 1;
  setsockopt(a1, 6, 1, &v13, 4u);
  int sa_family = a2->sa_family;
  int v8 = sa_family == 30 ? 28 : 0;
  socklen_t v9 = sa_family == 2 ? 16 : v8;
  uint64_t result = connect(a1, a2, v9);
  if (!(_DWORD)result) {
    return result;
  }
  memset(&v16, 0, sizeof(v16));
  memset(&v15, 0, sizeof(v15));
  if (__darwin_check_fd_set_overflow(a1, &v16, 0)) {
    *(__int32_t *)((char *)v16.fds_bits + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  }
  if (__darwin_check_fd_set_overflow(a1, &v15, 0)) {
    *(__int32_t *)((char *)v15.fds_bits + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  }
  v14.tv_seCC_SHA1_CTX c = a3;
  v14.tv_useCC_SHA1_CTX c = 0;
  int v10 = select(a1 + 1, &v16, &v15, 0LL, &v14);
  if (v10 <= 0)
  {
    if (!v10) {
      return 4294960574LL;
    }
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result) {
      return result;
    }
  }

  if ((!__darwin_check_fd_set_overflow(a1, &v16, 0)
     || ((*(unsigned int *)((char *)v16.fds_bits + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> a1) & 1) == 0)
    && (!__darwin_check_fd_set_overflow(a1, &v15, 0)
     || ((*(unsigned int *)((char *)v15.fds_bits + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> a1) & 1) == 0))
  {
    return 4294960596LL;
  }

  socklen_t v12 = 4;
  unsigned int v13 = 0;
  if (!getsockopt(a1, 0xFFFF, 4103, &v13, &v12)) {
    return v13;
  }
  if (!*__error()) {
    return 4294960596LL;
  }
  uint64_t result = *__error();
  if (!(_DWORD)result) {
    return v13;
  }
  return result;
}

uint64_t SocketAccept(int a1, unsigned int a2, int *a3, sockaddr *a4)
{
  uint64_t v7 = a2;
  SocketSetNonBlocking(a1, 1);
  if ((a2 & 0x80000000) != 0)
  {
    unint64_t v9 = -1LL;
  }

  else
  {
    uint64_t v8 = mach_absolute_time();
    if (SecondsToUpTicks_sOnce != -1) {
      dispatch_once_f( &SecondsToUpTicks_sOnce,  &SecondsToUpTicks_sMultiplier,  (dispatch_function_t)_SecondsToUpTicksInit);
    }
    unint64_t v9 = v8 + SecondsToUpTicks_sMultiplier * v7;
  }

  int v20 = 0;
  memset(&v23, 0, sizeof(v23));
  while (1)
  {
    if (__darwin_check_fd_set_overflow(a1, &v23, 0)) {
      v23.fds_bits[(unint64_t)a1 >> 5] |= 1 << a1;
    }
    if ((v7 & 0x80000000) != 0)
    {
      int v10 = 0LL;
    }

    else
    {
      uint64_t v21 = v7;
      int v22 = 0;
      int v10 = (timeval *)&v21;
    }

    int v11 = select(a1 + 1, &v23, 0LL, 0LL, v10);
    if (v11 > 0) {
      goto LABEL_16;
    }
    if (!v11) {
      return 4294960574LL;
    }
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result) {
      return result;
    }
LABEL_16:
    if (a4)
    {
      int v20 = 28;
      unsigned int v13 = (socklen_t *)&v20;
    }

    else
    {
      unsigned int v13 = 0LL;
    }

    int v14 = accept(a1, a4, v13);
    if ((v14 & 0x80000000) == 0 || *__error() && !*__error())
    {
      int v18 = 1;
      setsockopt(v14, 0xFFFF, 4130, &v18, 4u);
      SocketSetNonBlocking(v14, 1);
      int v19 = 1;
      setsockopt(v14, 6, 1, &v19, 4u);
      uint64_t result = 0LL;
      *a3 = v14;
      return result;
    }

    if ((v7 & 0x80000000) == 0)
    {
      uint64_t v15 = mach_absolute_time();
      uint64_t v7 = 0LL;
      unint64_t v16 = v9 - v15;
      if (v9 > v15)
      {
        if (UpTicksPerSecond_sOnce != -1) {
          dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
        }
        uint64_t v7 = (v16 / UpTicksPerSecond_sTicksPerSecond);
      }
    }
  }

uint64_t SocketCloseGracefully(int a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v4 = mach_absolute_time();
  memset(&v13, 0, sizeof(v13));
  unint64_t v5 = UpTicksToMicroseconds(v4) + 1000000LL * a2;
  shutdown(a1, 1);
  do
  {
    uint64_t v6 = mach_absolute_time();
    unint64_t v7 = UpTicksToMicroseconds(v6);
    unint64_t v8 = v5 - v7;
    if (v5 <= v7)
    {
      __darwin_time_t v9 = 0LL;
      __darwin_suseconds_t v10 = 0;
    }

    else
    {
      __darwin_time_t v9 = (int)(v8 / 0xF4240);
      __darwin_suseconds_t v10 = v8 % 0xF4240;
    }

    v14.tv_seCC_SHA1_CTX c = v9;
    v14.tv_useCC_SHA1_CTX c = v10;
    if (__darwin_check_fd_set_overflow(a1, &v13, 0)) {
      v13.fds_bits[(unint64_t)a1 >> 5] |= 1 << a1;
    }
    int v11 = select(a1 + 1, &v13, 0LL, 0LL, &v14);
    if (!v11) {
      break;
    }
    if (v11 < 0)
    {
      if (*__error()) {
        __error();
      }
      break;
    }
  }

  while (recv(a1, v15, 0x20uLL, 0) > 0);
  uint64_t result = close(a1);
  if ((_DWORD)result)
  {
    if (*__error()) {
      return *__error();
    }
    else {
      return 4294960596LL;
    }
  }

  return result;
}

uint64_t SocketRecvFrom( int a1, uint64_t a2, uint64_t a3, ssize_t *a4, void *a5, socklen_t a6, void *a7, unint64_t *a8, _DWORD *a9, void *a10)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  v18[0] = a2;
  v18[1] = a3;
  v17.msg_name = a5;
  v17.msg_namelen = a6;
  v17.msg_iov = (iovec *)v18;
  v17.msg_iovlen = 1;
  v17.msg_control = &v19;
  *(void *)&v17.msg_controllen = 256LL;
  while (1)
  {
    ssize_t v14 = recvmsg(a1, &v17, 0);
    if ((v14 & 0x8000000000000000LL) == 0) {
      break;
    }
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result != 4)
    {
      if ((_DWORD)result) {
        return result;
      }
      break;
    }
  }

  if (a4) {
    *a4 = v14;
  }
  if (a7) {
    *a7 = v17.msg_namelen;
  }
  if (a8) {
    *a8 = SocketGetPacketUpTicks((unsigned int *)v17.msg_control, v17.msg_controllen);
  }
  if (a9)
  {
    int PacketReceiveInterface = SocketGetPacketReceiveInterface((unsigned int *)v17.msg_control, v17.msg_controllen, a10);
    uint64_t result = 0LL;
    *a9 = PacketReceiveInterface;
  }

  else
  {
    if (a10) {
      SocketGetPacketReceiveInterface((unsigned int *)v17.msg_control, v17.msg_controllen, a10);
    }
    return 0LL;
  }

  return result;
}

unint64_t SocketGetPacketUpTicks(unsigned int *a1, unsigned int a2)
{
  if (a2 < 0xC) {
    return mach_absolute_time();
  }
  uint64_t v2 = a1;
  if (!a1) {
    return mach_absolute_time();
  }
  while (1)
  {
    if (v2[1] != 0xFFFF) {
      goto LABEL_6;
    }
    unsigned int v3 = v2[2];
    if (v3 == 2) {
      break;
    }
    if (v3 == 4) {
      return *(void *)(v2 + 3);
    }
LABEL_6:
    uint64_t v2 = (unsigned int *)((char *)v2 + ((*v2 + 3LL) & 0x1FFFFFFFCLL));
  }

  gettimeofday(&v11, 0LL);
  uint64_t v5 = mach_absolute_time();
  tv_seCC_SHA1_CTX c = v11.tv_sec;
  if (SecondsToUpTicks_sOnce != -1) {
    dispatch_once_f(&SecondsToUpTicks_sOnce, &SecondsToUpTicks_sMultiplier, (dispatch_function_t)_SecondsToUpTicksInit);
  }
  uint64_t v7 = SecondsToUpTicks_sMultiplier * tv_sec;
  unint64_t v8 = MicrosecondsToUpTicks(v11.tv_usec);
  timeval v11 = *(timeval *)(v2 + 3);
  __darwin_time_t v9 = v11.tv_sec;
  if (SecondsToUpTicks_sOnce != -1) {
    dispatch_once_f(&SecondsToUpTicks_sOnce, &SecondsToUpTicks_sMultiplier, (dispatch_function_t)_SecondsToUpTicksInit);
  }
  uint64_t v10 = SecondsToUpTicks_sMultiplier;
  return v5 - v8 - v7 + v10 * v9 + MicrosecondsToUpTicks(v11.tv_usec);
}

uint64_t SocketGetPacketReceiveInterface(unsigned int *a1, unsigned int a2, void *__dst)
{
  uint64_t result = 0LL;
  if (a2 >= 0xC && a1)
  {
    unint64_t v6 = (unint64_t)a1 + a2;
    while (a1[1] || a1[2] != 20)
    {
      a1 = (unsigned int *)((char *)a1 + ((*a1 + 3LL) & 0x1FFFFFFFCLL));
    }

    if (__dst)
    {
      size_t v7 = *((unsigned __int8 *)a1 + 17);
      if (v7 <= 0xF)
      {
        memcpy(__dst, a1 + 5, v7);
        *((_BYTE *)__dst + *((unsigned __int8 *)a1 + 17)) = 0;
      }
    }

    return *((unsigned __int16 *)a1 + 7);
  }

  return result;
}

uint64_t SocketReadAll(int a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t v16 = v3;
  uint64_t v17 = v4;
  size_t v5 = a3;
  unint64_t v6 = a2;
  unint64_t v8 = &a2[a3];
  int v9 = 1 << a1;
  unint64_t v10 = (unint64_t)a1 >> 5;
  int v11 = a1 + 1;
  while (1)
  {
    do
    {
      ssize_t v12 = recv(a1, v6, v5, 0);
      if (v12 >= 1)
      {
        v6 += v12;
        goto LABEL_16;
      }

      if (!v12) {
        return 4294960543LL;
      }
      if (!*__error()) {
        return 4294960596LL;
      }
      uint64_t result = *__error();
    }

    while ((_DWORD)result == 4);
    if ((_DWORD)result != 35) {
      return result;
    }
    memset(&v15, 0, sizeof(v15));
    if (__darwin_check_fd_set_overflow(a1, &v15, 0)) {
      v15.fds_bits[v10] |= v9;
    }
    int v14 = select(v11, &v15, 0LL, 0LL, 0LL);
    if (!v14) {
      return 4294960574LL;
    }
    if (v14 <= 0)
    {
      if (!*__error()) {
        return 4294960596LL;
      }
      uint64_t result = *__error();
      if ((_DWORD)result) {
        return result;
      }
    }

uint64_t SocketWriteAll(int a1, char *a2, uint64_t a3, int a4)
{
  if (a3 < 1) {
    return 0LL;
  }
  size_t v4 = a3;
  size_t v5 = a2;
  unint64_t v7 = (unint64_t)&a2[a3];
  int v8 = 1 << a1;
  unint64_t v9 = (unint64_t)a1 >> 5;
  __darwin_time_t v10 = a4;
  int v11 = a1 + 1;
  while (1)
  {
    if (__darwin_check_fd_set_overflow(a1, &v16, 0)) {
      v16.fds_bits[v9] |= v8;
    }
    v15.tv_seCC_SHA1_CTX c = v10;
    v15.tv_useCC_SHA1_CTX c = 0;
    int v12 = select(v11, 0LL, &v16, 0LL, &v15);
    if (!v12) {
      return 4294960574LL;
    }
    if (v12 <= 0)
    {
      if (!*__error()) {
        return 4294960596LL;
      }
      uint64_t result = *__error();
      if ((_DWORD)result) {
        return result;
      }
    }

    ssize_t v14 = write(a1, v5, v4);
    if (v14 < 0)
    {
      if (!*__error()) {
        return 4294960596LL;
      }
      uint64_t result = *__error();
      if ((_DWORD)result != 4)
      {
        if ((_DWORD)result) {
          return result;
        }
        goto LABEL_13;
      }
    }

    else
    {
LABEL_13:
      uint64_t result = 0LL;
      v5 += v14;
      size_t v4 = v7 - (void)v5;
    }
  }

uint64_t SocketReadData(int a1, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v4 = *a4;
  size_t v5 = a3 - *a4;
  if (a3 == *a4) {
    return 0LL;
  }
  if (a3 <= *a4) {
    return 4294960533LL;
  }
  unint64_t v9 = (void *)(a2 + v4);
  while (1)
  {
    ssize_t v10 = read(a1, v9, v5);
    if ((v10 & 0x8000000000000000LL) == 0) {
      break;
    }
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result != 4) {
      return result;
    }
  }

  if (!v10) {
    return 4294960543LL;
  }
  *a4 = v10 + v4;
  if (v10 + v4 == a3) {
    return 0LL;
  }
  else {
    return 35LL;
  }
}

uint64_t SocketReadDataEx(int a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t *a5)
{
  uint64_t v5 = *a5;
  size_t v6 = a4 - *a5;
  if (a4 == *a5) {
    return 0LL;
  }
  if (a4 <= *a5) {
    return 4294960533LL;
  }
  ssize_t v10 = (void *)(a2 + v5);
  do
  {
    ssize_t v11 = read(a1, v10, v6);
    if ((v11 & 0x8000000000000000LL) == 0)
    {
      if (!v11) {
        return 4294960543LL;
      }
      *a5 = v11 + v5;
      if (v11 + v5 >= a3) {
        return 0LL;
      }
      else {
        return 35LL;
      }
    }

    if (!*__error())
    {
      uint64_t v17 = 4294960596LL;
      goto LABEL_15;
    }

    uint64_t v17 = *__error();
  }

  while ((_DWORD)v17 == 4);
  if ((_DWORD)v17 == 35) {
    return v17;
  }
LABEL_15:
  if (gLogCategory_NetUtils <= 60
    && (gLogCategory_NetUtils != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_NetUtils, 0x3Cu)))
  {
    LogPrintF( (uint64_t)&gLogCategory_NetUtils,  (uint64_t)"OSStatus SocketReadDataEx(SocketRef, void *, size_t, size_t, size_t *)",  0x3Cu,  (uint64_t)"SocketReadDataEx, fd %d, min %zu, failed: %#m\n",  v12,  v13,  v14,  v15,  a1);
  }

  return v17;
}

uint64_t SocketWriteData(int a1, const iovec **a2, int *a3)
{
  if (!*a3) {
    return 0LL;
  }
  while (1)
  {
    ssize_t v6 = writev(a1, *a2, *a3);
    if ((v6 & 0x8000000000000000LL) == 0) {
      break;
    }
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result != 4) {
      return result;
    }
  }

  if (!v6) {
    return 0LL;
  }
  return UpdateIOVec((uint64_t **)a2, a3, v6);
}

uint64_t SocketTransportRead(void *a1, size_t a2, ssize_t *a3, int a4)
{
  while (1)
  {
    ssize_t v8 = read(a4, a1, a2);
    if ((v8 & 0x8000000000000000LL) == 0) {
      break;
    }
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result != 4) {
      return result;
    }
  }

  ssize_t v10 = v8;
  if (!v8) {
    return 4294960543LL;
  }
  uint64_t result = 0LL;
  *a3 = v10;
  return result;
}

uint64_t SocketTransportWriteV(const iovec **a1, int *a2, int a3)
{
  return SocketWriteData(a3, a1, a2);
}

uint64_t SocketSetBoundInterface(int a1, int a2, int a3)
{
  int v6 = a3;
  if (a2 == 2)
  {
    int v3 = 0;
    int v4 = 25;
  }

  else
  {
    if (a2 != 30) {
      return 4294960561LL;
    }
    int v3 = 41;
    int v4 = 125;
  }

  uint64_t result = setsockopt(a1, v3, v4, &v6, 4u);
  if ((_DWORD)result)
  {
    if (*__error()) {
      return *__error();
    }
    else {
      return 4294960596LL;
    }
  }

  return result;
}

uint64_t SocketGetFamily(int a1)
{
  socklen_t v2 = 28;
  if (getsockname(a1, &v3, &v2) && (!*__error() || *__error())) {
    return 0LL;
  }
  else {
    return v3.sa_family;
  }
}

uint64_t SocketGetInterfaceInfo( int a1, char *ifa_name, char *a3, unsigned int *a4, uint64_t a5, _DWORD *a6, int *a7, void *a8, BOOL *a9, uint64_t a10)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  int v37 = 0LL;
  if (a1 < 0)
  {
    int v20 = socket(2, 2, 0);
    if (v20 < 0)
    {
      int v17 = v20;
      if (!*__error())
      {
        uint64_t v25 = 4294960596LL;
        int v19 = v17;
        goto LABEL_64;
      }

      int v18 = a8;
      uint64_t v25 = *__error();
      int v19 = v17;
      if ((_DWORD)v25) {
        goto LABEL_64;
      }
    }

    else
    {
      int v18 = a8;
      int v17 = v20;
      int v19 = v20;
    }
  }

  else
  {
    int v17 = a1;
    int v18 = a8;
    int v19 = -1;
  }

  if (ifa_name)
  {
    int v36 = v19;
    if (a5)
    {
      *(_WORD *)(a5 + 4) = 0;
      *(_DWORD *)a5 = 0;
      GetInterfaceMACAddress(ifa_name, a5);
    }

    uint64_t v21 = 0LL;
    unint64_t v22 = (unint64_t)v18;
  }

  else
  {
    socklen_t v38 = 28;
    if (getsockname(v17, &v39, &v38))
    {
      if (!*__error())
      {
        uint64_t v25 = 4294960596LL;
        goto LABEL_64;
      }

      uint64_t v25 = *__error();
      if ((_DWORD)v25) {
        goto LABEL_64;
      }
    }

    uint64_t v26 = SockAddrSimplify((__int128 *)&v39, (uint64_t)&v39);
    if ((_DWORD)v26 || (uint64_t v26 = getifaddrs(&v37), (_DWORD)v26))
    {
      uint64_t v25 = v26;
      goto LABEL_64;
    }

    int v36 = v19;
    uint64_t v21 = v37;
    if (!v37)
    {
      uint64_t v25 = 4294960569LL;
      int v19 = v36;
      if (v36 < 0) {
        return v25;
      }
      goto LABEL_67;
    }

    uint64_t v25 = 4294960569LL;
    while (1)
    {
      ifa_addr = v21->ifa_addr;
      if (ifa_addr)
      {
      }

      uint64_t v21 = v21->ifa_next;
      if (!v21) {
        goto LABEL_59;
      }
    }

    ifa_name = v21->ifa_name;
    if (a3) {
      strlcpy(a3, v21->ifa_name, 0x11uLL);
    }
    if (!ifa_name)
    {
      uint64_t v25 = 4294960569LL;
      goto LABEL_59;
    }

    unint64_t v22 = (unint64_t)v18;
    if (a5)
    {
      *(_WORD *)(a5 + 4) = 0;
      *(_DWORD *)a5 = 0;
      uint64_t v21 = v37;
      if (v37)
      {
        while (1)
        {
          int v32 = v21->ifa_addr;
          if (v32)
          {
            if (v32->sa_family == 18)
            {
              int v33 = v21->ifa_name;
              if (v33)
              {
                if (!strcmp(v33, ifa_name) && v32->sa_data[4] == 6) {
                  break;
                }
              }
            }
          }

          uint64_t v21 = v21->ifa_next;
          if (!v21) {
            goto LABEL_9;
          }
        }

        int v34 = &v32->sa_len + v32->sa_data[3];
        int v35 = *((_DWORD *)v34 + 2);
        *(_WORD *)(a5 + 4) = *((_WORD *)v34 + 6);
        *(_DWORD *)a5 = v35;
      }
    }
  }

uint64_t SockAddrCompareAddrEx(_BYTE *a1, uint64_t a2, int a3)
{
  uint64_t v3 = a1[1];
  if (a1[1])
  {
    uint64_t v5 = (_BYTE *)a2;
    if ((_DWORD)v3 == 30)
    {
      if (a1[8] == 254
        && (a1[9] & 0xC0) == 0x80
        && *(unsigned __int8 *)(a2 + 8) == 254
        && (*(_BYTE *)(a2 + 9) & 0xC0) == 0x80)
      {
        SockAddrSimplify((__int128 *)a1, (uint64_t)v17);
        SockAddrSimplify((__int128 *)v5, (uint64_t)v15);
        if (a3)
        {
          LODWORD(v3) = v18 - v16;
          uint64_t v5 = v15;
          a1 = v17;
        }

        else
        {
          LODWORD(v3) = 0;
          a1 = v17;
          uint64_t v5 = v15;
        }
      }

      else
      {
        LODWORD(v3) = 0;
      }

      unint64_t v12 = bswap64(*((void *)a1 + 1));
      unint64_t v13 = bswap64(*((void *)v5 + 1));
      if (v12 == v13 && (unint64_t v12 = bswap64(*((void *)a1 + 2)), v13 = bswap64(*((void *)v5 + 2)), v12 == v13))
      {
        unsigned int v14 = 0;
      }

      else if (v12 < v13)
      {
        unsigned int v14 = -1;
      }

      else
      {
        unsigned int v14 = 1;
      }

      if (v14) {
        return v14;
      }
      else {
        return v3;
      }
    }

    else if ((_DWORD)v3 == 2)
    {
      unsigned int v6 = bswap32(*((_DWORD *)a1 + 1));
      unsigned int v7 = bswap32(*(_DWORD *)(a2 + 4));
      BOOL v8 = v6 >= v7;
      BOOL v9 = v6 > v7;
      int v10 = !v8;
      return (v9 - v10);
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return v3;
}

uint64_t GetInterfaceMACAddress(const char *a1, uint64_t a2)
{
  ssize_t v11 = 0LL;
  if (getifaddrs(&v11))
  {
    if (*__error())
    {
      uint64_t v4 = *__error();
      uint64_t v5 = v11;
      if (!(_DWORD)v4)
      {
        if (v11) {
          goto LABEL_5;
        }
        return 4294960569LL;
      }
    }

    else
    {
      uint64_t v4 = 4294960596LL;
      uint64_t v5 = v11;
    }

    if (v5) {
LABEL_16:
    }
      MEMORY[0x186E42F24](v5);
    return v4;
  }

  uint64_t v5 = v11;
  if (!v11) {
    return 4294960569LL;
  }
LABEL_5:
  unsigned int v6 = v5;
  while (1)
  {
    ifa_addr = v6->ifa_addr;
    if (ifa_addr->sa_family == 18 && !strcmp(v6->ifa_name, a1) && ifa_addr->sa_data[4] == 6) {
      break;
    }
    unsigned int v6 = v6->ifa_next;
    if (!v6)
    {
      uint64_t v4 = 4294960569LL;
      if (v5) {
        goto LABEL_16;
      }
      return v4;
    }
  }

  uint64_t v4 = 0LL;
  BOOL v9 = &ifa_addr->sa_len + ifa_addr->sa_data[3];
  int v10 = *((_DWORD *)v9 + 2);
  *(_WORD *)(a2 + 4) = *((_WORD *)v9 + 6);
  *(_DWORD *)a2 = v10;
  if (v5) {
    goto LABEL_16;
  }
  return v4;
}

uint64_t SocketSetKeepAlive(int a1, int a2, int a3)
{
  return SocketSetKeepAliveEx(a1, a2, a2, a3);
}

uint64_t SocketSetKeepAliveEx(int a1, int a2, int a3, int a4)
{
  BOOL v9 = a2 > 0 && a4 > 0;
  int v14 = v9;
  if (setsockopt(a1, 0xFFFF, 8, &v14, 4u))
  {
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result) {
      return result;
    }
  }

  if (!v14) {
    return 0LL;
  }
  if (a2 <= 1) {
    int v11 = 1;
  }
  else {
    int v11 = a2;
  }
  int v14 = v11;
  if (setsockopt(a1, 6, 16, &v14, 4u) && *__error()) {
    __error();
  }
  if (a3 <= 1) {
    int v12 = 1;
  }
  else {
    int v12 = a3;
  }
  int v14 = v12;
  if (setsockopt(a1, 6, 257, &v14, 4u) && *__error()) {
    __error();
  }
  if (a4 <= 1) {
    int v13 = 1;
  }
  else {
    int v13 = a4;
  }
  int v14 = v13;
  uint64_t result = setsockopt(a1, 6, 258, &v14, 4u);
  if ((_DWORD)result)
  {
    if (*__error()) {
      __error();
    }
    return 0LL;
  }

  return result;
}

uint64_t SocketSetNotSentLowWatermark(int a1, unint64_t a2)
{
  if (a2 >> 31) {
    return 4294960586LL;
  }
  int v3 = a2;
  uint64_t result = setsockopt(a1, 6, 513, &v3, 4u);
  if ((_DWORD)result)
  {
    if (*__error()) {
      return *__error();
    }
    else {
      return 4294960596LL;
    }
  }

  return result;
}

uint64_t SocketSetPacketTimestamps(int a1, int a2)
{
  int v3 = a2;
  uint64_t result = setsockopt(a1, 0xFFFF, 2048, &v3, 4u);
  if ((_DWORD)result)
  {
    if (*__error()) {
      return *__error();
    }
    else {
      return 4294960596LL;
    }
  }

  return result;
}

uint64_t SocketSetQoS(int a1, int a2)
{
  if (a2)
  {
    uint64_t result = 4294960591LL;
    switch(a2)
    {
      case 1:
        int v5 = 32;
        goto LABEL_8;
      case 2:
      case 10:
      case 12:
        int v5 = 128;
        goto LABEL_8;
      case 3:
      case 11:
        goto LABEL_6;
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
        return result;
      default:
        if (a2 != 20) {
          return result;
        }
LABEL_6:
        int v5 = 192;
LABEL_8:
        int v12 = v5;
        break;
    }
  }

  else
  {
    int v12 = 0;
  }

  int Family = SocketGetFamily(a1);
  if (Family == 30)
  {
    int v7 = a1;
    int v8 = 41;
    int v9 = 36;
    goto LABEL_13;
  }

  if (Family == 2)
  {
    int v7 = a1;
    int v8 = 0;
    int v9 = 3;
LABEL_13:
    if (setsockopt(v7, v8, v9, &v12, 4u) && *__error()) {
      __error();
    }
  }

  if (a2)
  {
    switch(a2)
    {
      case 1:
        int v10 = 200;
        goto LABEL_26;
      case 2:
      case 12:
        int v10 = 700;
        goto LABEL_26;
      case 3:
      case 11:
        int v10 = 800;
        goto LABEL_26;
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
        return 4294960591LL;
      case 10:
        int v10 = 500;
        goto LABEL_26;
      default:
        if (a2 != 20) {
          return 4294960591LL;
        }
        int v10 = 900;
LABEL_26:
        int v11 = v10;
        break;
    }
  }

  else
  {
    int v11 = 0;
  }

  if (setsockopt(a1, 0xFFFF, 4230, &v11, 4u))
  {
    if (*__error()) {
      __error();
    }
  }

  return 0LL;
}

uint64_t SocketSetTCPTimeout(int a1, int a2)
{
  int v4 = a2;
  if (setsockopt(a1, 6, 533, &v4, 4u) && *__error()) {
    __error();
  }
  uint64_t result = setsockopt(a1, 6, 128, &v4, 4u);
  if ((_DWORD)result)
  {
    if (*__error()) {
      return *__error();
    }
    else {
      return 4294960596LL;
    }
  }

  return result;
}

uint64_t SocketJoinMulticast(int a1, uint64_t a2, char *a3, unsigned int a4)
{
  return _SocketJoinOrLeaveMulticast(a1, a2, a3, a4, 1);
}

uint64_t _SocketJoinOrLeaveMulticast(int a1, uint64_t a2, char *a3, unsigned int a4, int a5)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  int v7 = *(unsigned __int8 *)(a2 + 1);
  if (v7 != 30)
  {
    if (v7 != 2) {
      return 4294960561LL;
    }
    LODWORD(v13) = *(_DWORD *)(a2 + 4);
    if (a3)
    {
      *(_OWORD *)int v14 = 0u;
      __int128 v15 = 0u;
      __strlcpy_chk();
      goto LABEL_15;
    }

    if (!a4)
    {
      HIDWORD(v13) = 0;
      goto LABEL_20;
    }

    *(_OWORD *)int v14 = 0u;
    __int128 v15 = 0u;
    if (if_indextoname(a4, v14))
    {
LABEL_15:
      if (ioctl(a1, 0xC0206921uLL, v14, v13))
      {
        if (!*__error()) {
          return 4294960596LL;
        }
        uint64_t result = *__error();
        if ((_DWORD)result) {
          return result;
        }
      }

      HIDWORD(v13) = DWORD1(v15);
LABEL_20:
      uint64_t result = setsockopt(a1, 0, 13, &v13, 8u);
      if (a5)
      {
        int v9 = (char *)&v13;
        int v10 = a1;
        int v11 = 0;
        socklen_t v12 = 8;
        goto LABEL_22;
      }

      goto LABEL_23;
    }

    return 4294960552LL;
  }

  *(_OWORD *)int v14 = *(_OWORD *)(a2 + 8);
  if (!a3 || a4)
  {
    LODWORD(v15) = a4;
  }

  else
  {
    LODWORD(v15) = if_nametoindex(a3);
    if (!(_DWORD)v15) {
      return 4294960552LL;
    }
  }

  uint64_t result = setsockopt(a1, 41, 13, v14, 0x14u);
  if (a5)
  {
    int v9 = v14;
    int v10 = a1;
    int v11 = 41;
    socklen_t v12 = 20;
LABEL_22:
    uint64_t result = setsockopt(v10, v11, 12, v9, v12);
  }

uint64_t SocketLeaveMulticast(int a1, uint64_t a2, char *a3, unsigned int a4)
{
  return _SocketJoinOrLeaveMulticast(a1, a2, a3, a4, 0);
}

uint64_t SocketSetMulticastInterface(int a1, const char *a2, unsigned int a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  unsigned int v11 = a3;
  int Family = SocketGetFamily(a1);
  if (Family != 30)
  {
    if (Family != 2) {
      return 4294960561LL;
    }
    if (!a2 || a3 || (unsigned int v11 = if_nametoindex(a2)) != 0)
    {
      uint64_t result = setsockopt(a1, 0, 66, &v11, 4u);
      if (!(_DWORD)result) {
        return result;
      }
      if (*__error() && !*__error()) {
        return 0LL;
      }
      if (a2)
      {
        *(_OWORD *)socklen_t v12 = 0u;
        __int128 v13 = 0u;
        __strlcpy_chk();
        if (ioctl(a1, 0xC0206921uLL, v12))
        {
          if (!*__error()) {
            return 4294960596LL;
          }
          uint64_t result = *__error();
          if ((_DWORD)result) {
            return result;
          }
        }

        int v8 = (char *)&v13 + 4;
        goto LABEL_27;
      }

      if (!v11)
      {
        *(_DWORD *)socklen_t v12 = 0;
        int v8 = v12;
LABEL_27:
        int v9 = a1;
        int v10 = 0;
        goto LABEL_28;
      }

      *(_OWORD *)socklen_t v12 = 0u;
      __int128 v13 = 0u;
      if (if_indextoname(v11, v12))
      {
        if (ioctl(a1, 0xC0206921uLL, v12))
        {
          if (!*__error()) {
            return 4294960596LL;
          }
          uint64_t result = *__error();
          if ((_DWORD)result) {
            return result;
          }
        }

        int v8 = (char *)&v13 + 4;
        goto LABEL_27;
      }
    }

    return 4294960552LL;
  }

  if (a2)
  {
    if (!a3)
    {
      unsigned int v11 = if_nametoindex(a2);
      if (!v11) {
        return 4294960552LL;
      }
    }
  }

  int v8 = (char *)&v11;
  int v9 = a1;
  int v10 = 41;
LABEL_28:
  uint64_t result = setsockopt(v9, v10, 9, v8, 4u);
  if (!(_DWORD)result) {
    return result;
  }
  if (*__error()) {
    return *__error();
  }
  return 4294960596LL;
}

uint64_t SocketSetMulticastLoop(int a1)
{
  int Family = SocketGetFamily(a1);
  if (Family == 30)
  {
    int v8 = 1;
    int v3 = (char *)&v8;
    int v4 = a1;
    int v5 = 41;
    socklen_t v6 = 4;
  }

  else
  {
    if (Family != 2) {
      return 4294960561LL;
    }
    char v9 = 1;
    int v3 = &v9;
    int v4 = a1;
    int v5 = 0;
    socklen_t v6 = 1;
  }

  uint64_t result = setsockopt(v4, v5, 11, v3, v6);
  if ((_DWORD)result)
  {
    if (*__error()) {
      return *__error();
    }
    else {
      return 4294960596LL;
    }
  }

  return result;
}

uint64_t SockAddrToString(uint64_t a1, char a2, char *a3)
{
  int v4 = *(unsigned __int8 *)(a1 + 1);
  if (v4 == 30)
  {
    if ((a2 & 1) != 0) {
      signed int v6 = -1;
    }
    else {
      signed int v6 = bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16;
    }
    if (v6 > 0 || (a2 & 4) == 0) {
      int v9 = v6;
    }
    else {
      int v9 = -2;
    }
    if ((a2 & 2) != 0) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = *(_DWORD *)(a1 + 24);
    }
    IPv6AddressToCString((_BYTE *)(a1 + 8), v10, v9, 0xFFFFFFFF, a3, (a2 & 8) != 0);
  }

  else
  {
    if (v4 != 2) {
      return 4294960561LL;
    }
    if ((a2 & 1) != 0) {
      unsigned int v5 = 0;
    }
    else {
      unsigned int v5 = bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16;
    }
    IPv4AddressToCString(bswap32(*(_DWORD *)(a1 + 4)), v5, a3);
  }

  return 0LL;
}

uint64_t SockAddrCompareAddr(_BYTE *a1, uint64_t a2)
{
  return SockAddrCompareAddrEx(a1, a2, 0);
}

uint64_t SockAddrConvertToIPv6(__int128 *a1, uint64_t a2)
{
  int v3 = *((unsigned __int8 *)a1 + 1);
  if (v3 == 30)
  {
    if (a1 == (__int128 *)a2)
    {
      return 0LL;
    }

    else
    {
      uint64_t result = 0LL;
      __int128 v7 = *a1;
      uint64_t v8 = *((void *)a1 + 2);
      *(_DWORD *)(a2 + 24) = *((_DWORD *)a1 + 6);
      *(void *)(a2 + 16) = v8;
      *(_OWORD *)a2 = v7;
    }
  }

  else if (v3 == 2)
  {
    uint64_t result = 0LL;
    unsigned int v5 = *((_DWORD *)a1 + 1);
    __int16 v6 = *((_WORD *)a1 + 1);
    *(void *)(a2 + 8) = 0LL;
    *(_WORD *)a2 = 7708;
    *(_WORD *)(a2 + 2) = v6;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 16) = -65536;
    *(void *)(a2 + 20) = v5;
  }

  else
  {
    return 4294960561LL;
  }

  return result;
}

unint64_t SockAddrToDeviceID(__int128 *a1)
{
  if (v3 == 30) {
    return ((unint64_t)v6 << 40) | ((unint64_t)v5 << 48) | ((unint64_t)v7 << 32) | ((unint64_t)v8 << 24) | ((unint64_t)v9 << 16) | ((unint64_t)v10 << 8) | v11 | 0x600000000000000LL;
  }
  if (v3 == 2) {
    return bswap32(v4) | 0x400000000000000LL;
  }
  return 0LL;
}

uint64_t IsIPv4MartianAddress(int a1)
{
  int v3 = a1;
  int v1 = (unsigned __int8 *)&IsIPv4MartianAddress_kMartianRules;
  while (!_EqualBits((unsigned __int8 *)&v3, v1, v1[4]))
  {
    v1 += 5;
  }

  return 1LL;
}

BOOL _EqualBits(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  if (a3 >= 8)
  {
    uint64_t v3 = ((a3 - 8) >> 3) + 1;
    unsigned int v4 = &a2[v3];
    unsigned __int8 v5 = &a1[v3];
    while (*a1 == *a2)
    {
      ++a2;
      ++a1;
      LOBYTE(a3) = a3 - 8;
      if (a3 <= 7u)
      {
        a1 = v5;
        a2 = v4;
        return !(_BYTE)a3 || ((-256 >> a3) & (*a2 ^ *a1)) == 0;
      }
    }

    return 0LL;
  }

  return !(_BYTE)a3 || ((-256 >> a3) & (*a2 ^ *a1)) == 0;
}

BOOL IsIPv6MartianAddress(unsigned __int8 *a1)
{
  return IsIPv6MartianAddressEx(a1, 0);
}

BOOL IsIPv6MartianAddressEx(unsigned __int8 *a1, char a2)
{
  uint64_t v4 = 0LL;
  for (uint64_t i = &byte_189F33A60; !_EqualBits(a1, *((unsigned __int8 **)i - 1), *i); i += 16)
  {
    if (++v4 == 23) {
      return 0LL;
    }
  }

  if ((a2 & 1) != 0 && !v4 || (a2 & 2) != 0 && v4 == 20) {
    return 0LL;
  }
  return (a2 & 4) == 0 || v4 != 19;
}

BOOL IsGlobalIPv4Address(unsigned int a1)
{
  unsigned int v1 = bswap32(a1);
  unsigned int v2 = v1 & 0xFF000000;
  if ((v1 & 0xFFFF0000) == 0xC0A80000 || v2 == 167772160 || (v1 & 0xFFF00000) == -1408237568) {
    return 0LL;
  }
  BOOL v6 = v2 != 2130706432 && v2 >> 29 != 7;
  if ((v1 & 0xFFFF0000) == 0xA9FE0000) {
    BOOL v6 = 0;
  }
  return v1 >= 0x10000 && v6;
}

BOOL IsPrivateIPv4Address(unsigned int a1)
{
  unsigned int v1 = bswap32(a1);
  BOOL v2 = HIBYTE(v1) == 10 || v1 >> 20 == 2753;
  unsigned int v3 = HIWORD(v1);
  return v2 || v3 == 49320;
}

BOOL IsRoutableIPv4Address(unsigned int a1)
{
  unsigned int v1 = bswap32(a1) >> 16;
  if (v1) {
    BOOL v2 = v1 == 43518;
  }
  else {
    BOOL v2 = 1;
  }
  return !v2;
}

uint64_t CompareMACAddresses(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = bswap32(*(_DWORD *)a1);
  unsigned int v3 = bswap32(*(_DWORD *)a2);
  if (v2 == v3)
  {
    unsigned int v2 = bswap32(*(unsigned __int16 *)(a1 + 4)) >> 16;
    unsigned int v4 = bswap32(*(unsigned __int16 *)(a2 + 4));
    if (v2 == HIWORD(v4)) {
      return 0LL;
    }
    unsigned int v3 = HIWORD(v4);
  }

  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1LL;
  }
}

BOOL IsWiFiNetworkInterface(char *a1)
{
  int v3 = 0;
  SocketGetInterfaceInfo(-1, a1, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, (uint64_t)&v3);
  BOOL result = 1LL;
  return result;
}

uint64_t GetPrimaryIPAddress(uint64_t a1, uint64_t a2)
{
  return GetPrimaryIPAddressEx(0LL, a1, a2);
}

uint64_t GetPrimaryIPAddressEx(const __SCDynamicStore *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    unsigned __int8 v5 = a1;
LABEL_3:
    BOOL v6 = 0LL;
    goto LABEL_5;
  }

  unsigned __int8 v5 = SCDynamicStoreCreate(0LL, @"NetUtils:GetPrimaryIPAddress", 0LL, 0LL);
  BOOL v6 = v5;
  if (!v5)
  {
    if (!SCError()) {
      return 4294960596LL;
    }
    uint64_t result = SCError();
    if ((_DWORD)result) {
      return result;
    }
    unsigned __int8 v5 = 0LL;
    goto LABEL_3;
  }

uint64_t GetLocalHostName(char *a1, size_t a2)
{
  unsigned int v4 = SCDynamicStoreCopyLocalHostName(0LL);
  if (!v4) {
    return 4294960596LL;
  }
  unsigned __int8 v5 = v4;
  int CString = CFStringGetCString(v4, a1, a2, 0x8000100u);
  CFRelease(v5);
  if (!CString) {
    return 4294960596LL;
  }
  if (strlcat(a1, ".local", a2) >= a2) {
    return 4294960553LL;
  }
  return 0LL;
}

uint64_t GetPeerMACAddress(uint64_t a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  size_t __size = 0LL;
  int v4 = 100;
  while (1)
  {
    *(void *)int v18 = 0x1100000004LL;
    int v5 = *(unsigned __int8 *)(a1 + 1);
    int v19 = 0;
    int v20 = v5;
    uint64_t v21 = 0x40000000002LL;
    if (sysctl(v18, 6u, 0LL, &__size, 0LL, 0LL))
    {
      if (!*__error()) {
        return 4294960596LL;
      }
      uint64_t v6 = *__error();
      if ((_DWORD)v6) {
        return v6;
      }
    }

    if (!__size) {
      return 4294960569LL;
    }
    unsigned __int8 v7 = (unsigned __int16 *)malloc(__size);
    if (!v7) {
      return 4294960568LL;
    }
    unsigned __int8 v8 = v7;
    if (!sysctl(v18, 6u, v7, &__size, 0LL, 0LL)) {
      break;
    }
    if (*__error())
    {
      uint64_t v6 = *__error();
      if (!(_DWORD)v6) {
        break;
      }
    }

    else
    {
      uint64_t v6 = 4294960596LL;
    }

    free(v8);
    if (!--v4) {
      return v6;
    }
  }

  if ((uint64_t)__size < 1)
  {
LABEL_27:
    uint64_t v6 = 4294960569LL;
  }

  else
  {
    unint64_t v9 = (unint64_t)v8 + __size;
    unsigned __int8 v10 = v8;
    while (1)
    {
      unsigned __int8 v11 = v10 + 46;
      uint64_t v12 = *((unsigned __int8 *)v10 + 92);
      uint64_t v13 = (v12 & 3) != 0 ? (v12 | 3) + 1 : *((unsigned __int8 *)v10 + 92);
      uint64_t v14 = *((_BYTE *)v10 + 92) ? v13 : 4LL;
      __int128 v15 = &v11[v14];
      unsigned __int8 v10 = (unsigned __int16 *)((char *)v10 + *v10);
    }

    memcpy(a2, &v15[v15[5] + 8], v15[6]);
    uint64_t v6 = 0LL;
  }

  free(v8);
  return v6;
}

uint64_t _NTPClockGetTypeID()
{
  uint64_t result = _CFRuntimeRegisterClass();
  gNTPClockCFTypeID TypeID = result;
  return result;
}

void _NTPClockFinalize(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 80);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 80) = 0LL;
  }

uint64_t NTPClockCreate(uint64_t *a1)
{
  if (gNTPClockInitOnce != -1) {
    dispatch_once_f(&gNTPClockInitOnce, 0LL, (dispatch_function_t)_NTPClockGetTypeID);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294960568LL;
  }
  uint64_t v3 = Instance;
  bzero((void *)(Instance + 16), 0xED0uLL);
  *(void *)(v3 + 56) = &gLogCategory_NTPClockCore;
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  unint64_t v4 = UpTicksPerSecond_sTicksPerSecond;
  *(void *)(v3 + 96) = UpTicksPerSecond_sTicksPerSecond;
  if (HIDWORD(v4))
  {
    char v6 = -1;
    do
    {
      ++v6;
      BOOL v7 = v4 > 3;
      v4 >>= 1;
    }

    while (v7);
    LOBYTE(v5) = ~v6;
  }

  else
  {
    unsigned int v5 = __clz(v4 | 1) - 31;
  }

  uint64_t result = 0LL;
  *(_BYTE *)(v3 + 76) = v5;
  *(void *)(v3 + 224) = -1LL;
  *(void *)(v3 + 232) = -1LL;
  *a1 = v3;
  return result;
}

uint64_t NTPClockStop( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 216);
  int v10 = *(_DWORD *)(a1 + 228);
  if (v9)
  {
    SendSelfConnectedLoopbackMessage(*(_DWORD *)(a1 + 224), "q", 1uLL);
    pthread_join(*(pthread_t *)(a1 + 208), 0LL);
    *(void *)(a1 + 216) = 0LL;
  }

  int v11 = *(_DWORD *)(a1 + 224);
  if ((v11 & 0x80000000) == 0)
  {
    if (close(v11) && *__error()) {
      __error();
    }
    *(_DWORD *)(a1 + 224) = -1;
  }

  int v12 = *(_DWORD *)(a1 + 228);
  if ((v12 & 0x80000000) == 0)
  {
    if (close(v12) && *__error()) {
      __error();
    }
    *(_DWORD *)(a1 + 228) = -1;
  }

  int v13 = *(_DWORD *)(a1 + 232);
  if ((v13 & 0x80000000) == 0)
  {
    if (close(v13) && *__error()) {
      __error();
    }
    *(_DWORD *)(a1 + 232) = -1;
  }

  int v14 = *(_DWORD *)(a1 + 236);
  if ((v14 & 0x80000000) == 0)
  {
    if (close(v14) && *__error()) {
      __error();
    }
    *(_DWORD *)(a1 + 236) = -1;
  }

  uint64_t result = *(void *)(a1 + 200);
  if (result)
  {
    uint64_t result = pthread_mutex_destroy((pthread_mutex_t *)result);
    *(void *)(a1 + 200) = 0LL;
  }

  *(_DWORD *)(a1 + 52) = 0;
  if (v9)
  {
    uint64_t result = *(void *)(a1 + 56);
    if (*(int *)result <= 30)
    {
      if (*(_DWORD *)result == -1)
      {
        uint64_t result = _LogCategory_Initialize(result, 0x1Eu);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t result = *(void *)(a1 + 56);
      }

      uint64_t v16 = "server";
      if (v10 >= 0) {
        uint64_t v16 = "client";
      }
      return LogPrintF( result,  (uint64_t)"void NTPClockStop(NTPClockRef)",  0x1Eu,  (uint64_t)"NTP %s stopped\n",  a5,  a6,  a7,  a8,  (char)v16);
    }
  }

  return result;
}

uint64_t NTPClockSetEpoch(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t NTPClockSetLogging(uint64_t result, uint64_t a2)
{
  *(void *)(result + 56) = a2;
  return result;
}

uint64_t NTPClockSetP2P(uint64_t result, char a2)
{
  *(_BYTE *)(result + 64) = a2;
  return result;
}

uint64_t NTPClockSetPeer(uint64_t result, __int128 *a2, signed int a3)
{
  int v3 = *((unsigned __int8 *)a2 + 1);
  if (*((_BYTE *)a2 + 1))
  {
    if (v3 == 30)
    {
      __int128 v4 = *a2;
      uint64_t v5 = *((void *)a2 + 2);
      *(_DWORD *)(result + 44) = *((_DWORD *)a2 + 6);
      *(void *)(result + 36) = v5;
      goto LABEL_7;
    }

    if (v3 == 2)
    {
      __int128 v4 = *a2;
LABEL_7:
      *(_OWORD *)(result + 20) = v4;
    }
  }

  else
  {
    *(_BYTE *)(result + 21) = 0;
  }

  if (a3 >= 1)
  {
    int v6 = *((unsigned __int8 *)a2 + 1);
    if ((v6 == 30 || v6 == 2) && !*((_WORD *)a2 + 1))
    {
      int v7 = *(unsigned __int8 *)(result + 21);
      if (v7 == 30 || v7 == 2) {
        *(_WORD *)(result + 22) = bswap32(a3) >> 16;
      }
    }
  }

  return result;
}

uint64_t NTPClockGetListenPort(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t NTPClockSetListenPort(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) = a2;
  return result;
}

uint64_t NTPClockSetQoSDisabled(uint64_t result, char a2)
{
  *(_BYTE *)(result + 77) = a2;
  return result;
}

uint64_t NTPClockSetRTCP(uint64_t result, char a2)
{
  *(_BYTE *)(result + 78) = a2;
  return result;
}

uint64_t NTPClockSetThreadName(uint64_t a1, char *__s1)
{
  if (__s1)
  {
    int v3 = strdup(__s1);
    if (!v3) {
      return 4294960568LL;
    }
  }

  else
  {
    int v3 = 0LL;
  }

  uint64_t v5 = *(void **)(a1 + 80);
  if (v5) {
    free(v5);
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 80) = v3;
  return result;
}

uint64_t NTPClockSetThreadPriority(uint64_t result, int a2)
{
  *(_DWORD *)(result + 88) = a2;
  *(_BYTE *)(result + 92) = 1;
  return result;
}

uint64_t NTPClockSetUpTicksConvertHandler(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 104) = a2;
  *(void *)(result + 112) = a3;
  return result;
}

uint64_t NTPClockSetUpTicksPerSecondHandler(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 120) = a2;
  *(void *)(result + 128) = a3;
  return result;
}

uint64_t NTPClockStartClient(uint64_t a1)
{
  uint64_t v2 = a1 + 136;
  uint64_t v10 = pthread_mutex_init((pthread_mutex_t *)(a1 + 136), 0LL);
  if ((_DWORD)v10) {
    goto LABEL_56;
  }
  *(void *)(a1 + 200) = v2;
  if (*(_BYTE *)(a1 + 78))
  {
    *(_BYTE *)(a1 + 241) = -46;
    *(_WORD *)(a1 + 242) = 1792;
    uint64_t v11 = a1 + 264;
    uint64_t v12 = a1 + 268;
    char v13 = 0x80;
    uint64_t v14 = 32LL;
  }

  else
  {
    uint64_t v11 = a1 + 280;
    uint64_t v12 = a1 + 284;
    char v13 = 35;
    uint64_t v14 = 48LL;
  }

  *(_BYTE *)(a1 + 240) = v13;
  *(void *)(a1 + 288) = v11;
  *(void *)(a1 + 296) = v12;
  *(void *)(a1 + 304) = v14;
  *(_DWORD *)(a1 + 376) = 0;
  *(void *)(a1 + 1024) = 0LL;
  *(void *)(a1 + 3592) = 0LL;
  *(void *)(a1 + 68) = 0x44C000003E8LL;
  *(void *)(a1 + 3624) = 0LL;
  *(_OWORD *)(a1 + 3600) = 0u;
  *(_BYTE *)(a1 + 3616) = 0;
  *(_OWORD *)(a1 + 3632) = xmmword_186B49C70;
  *(_OWORD *)(a1 + 3648) = 0u;
  *(_OWORD *)(a1 + 3664) = xmmword_186B49C70;
  *(void *)(a1 + 3680) = 0LL;
  *(_DWORD *)(a1 + 3688) = 0;
  *(_OWORD *)(a1 + 3696) = xmmword_186B49C80;
  *(void *)(a1 + 3712) = 0x10000000000000LL;
  *(void *)(a1 + 3736) = 0LL;
  *(_OWORD *)(a1 + 3720) = 0u;
  *(void *)(a1 + 3744) = mach_absolute_time();
  unint64_t v15 = *(void *)(a1 + 96);
  *(void *)(a1 + 3752) = 0xFFFFFFFFFFFFFFFFLL / v15;
  *(void *)(a1 + 3760) = v15;
  *(_OWORD *)(a1 + 3768) = 0u;
  *(void *)(a1 + 3784) = 0xFFFFFFFFFFFFFFFFLL / v15;
  *(_OWORD *)(a1 + 3792) = 0u;
  int v16 = *(unsigned __int8 *)(a1 + 21);
  if ((v16 == 30 || v16 == 2) && !*(_WORD *)(a1 + 22)) {
    *(_WORD *)(a1 + 22) = 25115;
  }
  uint64_t v10 = UDPClientSocketOpen(0, (__int128 *)(a1 + 20), 0, *(_DWORD *)(a1 + 48), (unsigned int *)(a1 + 52), &v45);
  if ((_DWORD)v10) {
    goto LABEL_56;
  }
  int v17 = v45;
  *(_DWORD *)(a1 + 228) = v45;
  if (*(_BYTE *)(a1 + 64)) {
    SocketSetP2P(v17, 1);
  }
  if (!*(_BYTE *)(a1 + 77)) {
    SocketSetQoS(v17, 20);
  }
  SocketSetPacketTimestamps(v17, 1);
  uint64_t v22 = *(int **)(a1 + 56);
  if (*v22 > 30) {
    goto LABEL_18;
  }
  if (*v22 == -1)
  {
    uint64_t v22 = *(int **)(a1 + 56);
  }

  LogPrintF( (uint64_t)v22,  (uint64_t)"OSStatus _NTPClockClientNegotiate(NTPClockRef)",  0x1Eu,  (uint64_t)"NTP client negotiating with %##a\n",  v18,  v19,  v20,  v21,  a1 + 20);
LABEL_18:
  uint64_t v23 = mach_absolute_time();
  memset(&v47, 0, sizeof(v47));
  if (SecondsToUpTicks_sOnce != -1) {
    dispatch_once_f(&SecondsToUpTicks_sOnce, &SecondsToUpTicks_sMultiplier, (dispatch_function_t)_SecondsToUpTicksInit);
  }
  LODWORD(v10) = 0;
  unsigned int v24 = 0;
  uint64_t v25 = v23 + 10 * SecondsToUpTicks_sMultiplier;
  do
  {
    while (1)
    {
LABEL_21:
      if (mach_absolute_time() >= v25)
      {
        uint64_t v10 = 4294960574LL;
        goto LABEL_44;
      }

      if ((_DWORD)v10 == -6757) {
        break;
      }
      int v26 = _NTPClockClientSendRequest(a1);
      if (!v26) {
        break;
      }
      LODWORD(v10) = v26;
      usleep(0x186A0u);
    }

    do
    {
      int v27 = *(_DWORD *)(a1 + 228);
      if (__darwin_check_fd_set_overflow(v27, &v47, 0)) {
        *(__int32_t *)((char *)v47.fds_bits + (((unint64_t)v27 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v27;
      }
      v46.tv_seCC_SHA1_CTX c = 0LL;
      v46.tv_useCC_SHA1_CTX c = 200000;
      int v28 = select(*(_DWORD *)(a1 + 228) + 1, &v47, 0LL, 0LL, &v46);
      if (v28 > 0) {
        goto LABEL_32;
      }
      if (!v28)
      {
        LODWORD(v10) = -6722;
        goto LABEL_38;
      }

      if (!*__error())
      {
        LODWORD(v10) = -6700;
LABEL_38:
        ++*(_DWORD *)(a1 + 3800);
        int v33 = *(int **)(a1 + 56);
        if (*v33 > 50) {
          goto LABEL_21;
        }
        if (*v33 != -1) {
          goto LABEL_40;
        }
        if (_LogCategory_Initialize((uint64_t)v33, 0x32u))
        {
          int v33 = *(int **)(a1 + 56);
LABEL_40:
          LogPrintF( (uint64_t)v33,  (uint64_t)"OSStatus _NTPClockClientNegotiate(NTPClockRef)",  0x32u,  (uint64_t)"### NTP client negotiate wait for %##a failed (%u total): %#m\n",  v29,  v30,  v31,  v32,  a1 + 20);
          goto LABEL_21;
        }

        goto LABEL_21;
      }

      LODWORD(v10) = *__error();
    }

    while ((_DWORD)v10 == 4);
    if ((_DWORD)v10) {
      goto LABEL_38;
    }
LABEL_32:
    uint64_t v10 = _NTPClockClientProcessResponse(a1);
    if (!(_DWORD)v10) {
      ++v24;
    }
  }

  while (v24 < 4);
LABEL_44:
  if ((_DWORD)v10) {
    signed int v34 = 60;
  }
  else {
    signed int v34 = 30;
  }
  int v35 = *(signed int **)(a1 + 56);
  if (v34 >= *v35)
  {
    if (*v35 != -1) {
      goto LABEL_49;
    }
    if (_LogCategory_Initialize(*(void *)(a1 + 56), v34))
    {
      int v35 = *(signed int **)(a1 + 56);
LABEL_49:
      uint64_t v36 = mach_absolute_time();
      UpTicksToMilliseconds(v36 - v23);
      uint64_t v41 = "### ";
      if (!(_DWORD)v10) {
        uint64_t v41 = "";
      }
      LogPrintF( (uint64_t)v35,  (uint64_t)"OSStatus _NTPClockClientNegotiate(NTPClockRef)",  v34,  (uint64_t)"%sNTP client negotiation with %##a %s: Good=%d, Serr=%u, Tout=%u, Rerr=%u Dur=%llu ms%s%?#m\n",  v37,  v38,  v39,  v40,  (char)v41);
    }
  }

  if (!(_DWORD)v10)
  {
    uint64_t v10 = OpenSelfConnectedLoopbackSocket((int *)(a1 + 224));
    if (!(_DWORD)v10)
    {
      uint64_t v10 = pthread_create((pthread_t *)(a1 + 208), 0LL, (void *(__cdecl *)(void *))_NTPClockClientThread, (void *)a1);
      if (!(_DWORD)v10)
      {
        *(void *)(a1 + 216) = a1 + 208;
        int64_t v44 = *(int **)(a1 + 56);
        if (*v44 <= 30)
        {
          if (*v44 == -1)
          {
            int64_t v44 = *(int **)(a1 + 56);
          }

          LogPrintF( (uint64_t)v44,  (uint64_t)"OSStatus NTPClockStartClient(NTPClockRef)",  0x1Eu,  (uint64_t)"NTP client started with %##a on port %d\n",  v6,  v7,  v8,  v9,  a1 + 20);
        }

        return 0LL;
      }
    }
  }

uint64_t _NTPClockClientSendRequest(uint64_t a1)
{
  uint64_t v2 = mach_absolute_time();
  unint64_t v3 = *(void *)(a1 + 96);
  unsigned int v4 = *(_DWORD *)(a1 + 16) + v2 / v3;
  unint64_t v5 = ((unint64_t)(v2 % v3) << 32) / v3;
  uint64_t v6 = *(_DWORD **)(a1 + 296);
  **(_DWORD **)(a1 + 288) = bswap32(v4);
  *uint64_t v6 = bswap32(v5);
  if (send(*(_DWORD *)(a1 + 228), (const void *)(a1 + 240), *(void *)(a1 + 304), 0) == *(void *)(a1 + 304))
  {
LABEL_4:
    int v12 = *(_DWORD *)(a1 + 376);
    *(_DWORD *)(a1 + 376) = v12 + 1;
    uint64_t v13 = a1 + 4LL * (v12 & 7);
    *(_DWORD *)(v13 + 312) = v4;
    *(_DWORD *)(v13 + 344) = v5;
    uint64_t v14 = *(int **)(a1 + 56);
    if (*v14 <= 10)
    {
      if (*v14 == -1)
      {
        uint64_t v14 = *(int **)(a1 + 56);
      }

      LogPrintF( (uint64_t)v14,  (uint64_t)"OSStatus _NTPClockClientSendRequest(NTPClockRef)",  0xAu,  (uint64_t)"NTP client request: 0x%08X%08X\n",  v7,  v8,  v9,  v10,  v4);
    }

    return 0LL;
  }

  if (*__error())
  {
    uint64_t v11 = *__error();
    if (!(_DWORD)v11) {
      goto LABEL_4;
    }
  }

  else
  {
    uint64_t v11 = 4294960596LL;
  }

  ++*(_DWORD *)(a1 + 3792);
  unint64_t v15 = *(int **)(a1 + 56);
  if (*v15 <= 50)
  {
    if (*v15 == -1)
    {
      unint64_t v15 = *(int **)(a1 + 56);
    }

    LogPrintF( (uint64_t)v15,  (uint64_t)"OSStatus _NTPClockClientSendRequest(NTPClockRef)",  0x32u,  (uint64_t)"### NTP client send to %##a failed (%u total): %#m\n",  v7,  v8,  v9,  v10,  a1 + 20);
  }

  return v11;
}

uint64_t _NTPClockClientProcessResponse(uint64_t a1)
{
  uint64_t v2 = SocketRecvFrom(*(_DWORD *)(a1 + 228), (uint64_t)v117, 48LL, &v116, 0LL, 0, 0LL, &v115, 0LL, 0LL);
  if ((_DWORD)v2)
  {
    uint64_t v7 = v2;
  }

  else
  {
    if (v116 == 32)
    {
      uint64_t v8 = bswap32(v118);
      unsigned int v9 = bswap32(v119);
      uint64_t v10 = bswap32(v120) + *(_DWORD *)(a1 + 16);
      unsigned int v11 = bswap32(v121);
      uint64_t v12 = bswap32(v122);
      uint64_t v13 = v123;
      goto LABEL_19;
    }

    if (v116 == 48)
    {
      if (!v117[1] && v119 == 1313294680) {
        return 4294960539LL;
      }
      uint64_t v8 = bswap32(v122);
      unsigned int v9 = bswap32(v123[0]);
      uint64_t v10 = bswap32(v123[1]) + *(_DWORD *)(a1 + 16);
      unsigned int v11 = bswap32(v123[2]);
      uint64_t v12 = bswap32(v123[3]);
      uint64_t v13 = (unsigned int *)&v124;
LABEL_19:
      unsigned int v18 = *v13;
      unint64_t v19 = v9 | (unint64_t)(v8 << 32);
      unint64_t v20 = UpTicksToNTP(v115);
      if (v8 | v9)
      {
        LODWORD(v25) = *(_DWORD *)(a1 + 376);
        uint64_t v25 = v25 >= 8 ? 8LL : v25;
        if ((_DWORD)v25)
        {
          uint64_t v26 = bswap32(v18);
          unint64_t v27 = v11 | (unint64_t)(v10 << 32);
          uint64_t v28 = v26 | (v12 << 32);
          uint64_t v29 = (_DWORD *)(a1 + 344);
          while (*(v29 - 8) != (_DWORD)v8 || *v29 != v9)
          {
            ++v29;
            if (!--v25) {
              goto LABEL_28;
            }
          }

          *(v29 - 8) = 0;
          *uint64_t v29 = 0;
          unint64_t v32 = *(void *)(a1 + 1024);
          unint64_t v33 = v32 + 1;
          *(void *)(a1 + 1024) = v32 + 1;
          unint64_t v34 = v32 & 0xF;
          uint64_t v35 = a1 + 40 * v34;
          *(void *)(v35 + 384) = v19;
          *(void *)(v35 + 392) = v27;
          *(void *)(v35 + 400) = v28;
          *(void *)(v35 + 408) = v20;
          double v36 = (double)(uint64_t)(v28 - v27) * -2.32830644e-10;
          double v37 = v36 + (double)(uint64_t)(v20 - v19) * 2.32830644e-10;
          *(double *)(v35 + 416) = v37;
          uint64_t v38 = v32 - 12;
          if (v32 <= 0xF) {
            uint64_t v38 = 4LL;
          }
          if (v32 <= 0x1B) {
            unint64_t v39 = v38;
          }
          else {
            unint64_t v39 = 16LL;
          }
          unint64_t v40 = v33 - v39;
          if (v32 < v39) {
            unint64_t v40 = 0LL;
          }
          char v41 = 1;
          if (v40 < v32)
          {
            double v42 = v36 + (double)(uint64_t)(v20 - v19) * 2.32830644e-10;
            do
            {
              if (*(double *)(a1 + 40 * (v40 & 0xF) + 416) < v42)
              {
                double v42 = *(double *)(a1 + 40 * (v40 & 0xF) + 416);
                unint64_t v34 = v40 & 0xF;
                char v41 = 0;
              }

              ++v40;
            }

            while (v32 != v40);
          }

          if (v32)
          {
            double v43 = *(double *)(a1 + 3656);
            *(double *)(a1 + 3680) = vabdd_f64(v37, v43) * 0.125 + *(double *)(a1 + 3680) * 0.875;
            *(double *)(a1 + 3656) = v37 * 0.125 + v43 * 0.875;
          }

          else
          {
            *(double *)(a1 + 3656) = v37;
          }

          int64_t v44 = &unk_18C69D000;
          if (v33 < 4)
          {
            if (!v32)
            {
              if (gLogCategory_NTPClockRaw > 40) {
                goto LABEL_112;
              }
              if (gLogCategory_NTPClockRaw != -1
                || (BOOL v111 = _LogCategory_Initialize((uint64_t)&gLogCategory_NTPClockRaw, 0x28u),
                    int64_t v44 = (_DWORD *)&unk_18C69D000,
                    v111))
              {
                LogPrintF( (uint64_t)&gLogCategory_NTPClockRaw,  (uint64_t)"OSStatus _NTPClockClientProcessResponse(NTPClockRef)",  0x28u,  (uint64_t)"NTP Raw: #\tT1\tT2\tT3\tT4\tOffset ms\tOffsetAvg\tOffsetMin\tOffsetMax\tOffsetJitter\tRTT ms\t RTTavg\tRTTmin\tRTTmax\tRTTjitter\n",  v21,  v22,  v23,  v24,  v114);
                int64_t v44 = (_DWORD *)&unk_18C69D000;
              }
            }
          }

          else if (v41 || !*(_DWORD *)(a1 + 3600))
          {
            uint64_t v45 = a1 + 40 * v34;
            unint64_t v46 = *(void *)(v45 + 384);
            uint64_t v47 = *(void *)(a1 + 3608);
            uint64_t v48 = *(void *)(v45 + 408);
            if (*(_BYTE *)(a1 + 3616)) {
              uint64_t v47 = -v47;
            }
            unint64_t v49 = v46 + v47;
            uint64_t v50 = v48 + v47;
            uint64_t v51 = *(void *)(a1 + 3728);
            uint64_t v52 = *(void *)(a1 + 3768);
            if (v51 > v52)
            {
              unint64_t v53 = *(void *)(a1 + 3736);
              unint64_t v54 = *(void *)(a1 + 3776);
LABEL_68:
              BOOL v55 = v53 >= v54;
              unint64_t v56 = v53 - v54;
              int v57 = !v55;
              *((void *)&v59 + 1) = (v51 - v52 - v57);
              *(void *)&__int128 v59 = v56;
              uint64_t v58 = v59 >> 32;
              unint64_t v60 = v49 - v58;
              uint64_t v61 = v50 - v58;
              goto LABEL_78;
            }

            if (v51 == v52)
            {
              unint64_t v53 = *(void *)(a1 + 3736);
              unint64_t v54 = *(void *)(a1 + 3776);
              if (v53 > v54) {
                goto LABEL_68;
              }
            }

            else
            {
              unint64_t v54 = *(void *)(a1 + 3776);
              unint64_t v53 = *(void *)(a1 + 3736);
            }

            BOOL v55 = v54 >= v53;
            unint64_t v62 = v54 - v53;
            int v63 = !v55;
            *((void *)&v65 + 1) = (v52 - v51 - v63);
            *(void *)&__int128 v65 = v62;
            uint64_t v64 = v65 >> 32;
            unint64_t v60 = v64 + v49;
            uint64_t v61 = v64 + v50;
LABEL_78:
            unint64_t v66 = *(void *)(a1 + 40 * v34 + 392);
            uint64_t v67 = v66 - v60;
            BOOL v55 = v60 >= v66;
            unint64_t v68 = v60 - v66;
            if (!v55) {
              unint64_t v68 = v67;
            }
            if (v68 <= 0x100000000LL)
            {
              uint64_t v79 = *(void *)(a1 + 40 * v34 + 400);
LABEL_101:
              double v81 = ((double)(v79 - v61) * 2.32830644e-10 + (double)v67 * 2.32830644e-10) * 0.5;
              int v82 = *(_DWORD *)(a1 + 3600);
              *(_DWORD *)(a1 + 3600) = v82 + 1;
              if (v82)
              {
                double v83 = *(double *)(a1 + 3624);
                *(double *)(a1 + 3648) = vabdd_f64(v81, v83) * 0.125 + *(double *)(a1 + 3648) * 0.875;
                *(double *)(a1 + 3624) = v81 * 0.125 + v83 * 0.875;
              }

              else
              {
                *(void *)(a1 + 3624) = 0LL;
              }

              goto LABEL_108;
            }

            unint64_t v69 = v66 - v46;
            BOOL v70 = v46 > v66;
            unint64_t v71 = v46 - v66;
            char v72 = v70;
            *(_BYTE *)(a1 + 3616) = v72;
            if (v70) {
              unint64_t v69 = v71;
            }
            *(void *)(a1 + 3608) = v69;
            int v73 = *(_DWORD *)(a1 + 3604);
            if (v73) {
              int v74 = 50;
            }
            else {
              int v74 = 40;
            }
            uint64_t v75 = *(int **)(a1 + 56);
            if (v74 < *v75)
            {
LABEL_100:
              uint64_t v67 = 0LL;
              *(_DWORD *)(a1 + 3604) = v73 + 1;
              uint64_t v79 = *(void *)(a1 + 40 * v34 + 400);
              uint64_t v61 = v79;
              goto LABEL_101;
            }

            if (*v75 == -1)
            {
              BOOL v80 = _LogCategory_Initialize((uint64_t)v75, v74);
              int v73 = *(_DWORD *)(a1 + 3604);
              if (!v80)
              {
LABEL_99:
                int64_t v44 = &unk_18C69D000;
                goto LABEL_100;
              }

              uint64_t v75 = *(int **)(a1 + 56);
            }

            BOOL v76 = v73 == 0;
            if (v73) {
              unsigned int v77 = 50;
            }
            else {
              unsigned int v77 = 40;
            }
            SecCertificateRef v78 = "### ";
            if (v76) {
              SecCertificateRef v78 = "";
            }
            LogPrintF( (uint64_t)v75,  (uint64_t)"OSStatus _NTPClockClientProcessResponse(NTPClockRef)",  v77,  (uint64_t)"%sNTP client clock reset: %s%{dur}\n",  v21,  v22,  v23,  v24,  (char)v78);
            int v73 = *(_DWORD *)(a1 + 3604);
            goto LABEL_99;
          }

LABEL_140:
          ++*(_DWORD *)(a1 + 3688);
          goto LABEL_141;
        }
      }

                if ((_DWORD)appended == -6776) {
                  uint64_t v88 = 9LL;
                }
                else {
                  uint64_t v88 = 1LL;
                }
                goto LABEL_143;
              }

              uint64_t v88 = 8LL;
            }

uint64_t _NTPClockClientThread(uint64_t a1)
{
  unint64_t v2 = *(int *)(a1 + 224);
  unint64_t v3 = *(int *)(a1 + 228);
  unint64_t v4 = *(void *)(a1 + 96) / 0xAuLL;
  if (*(void *)(a1 + 80)) {
    uint64_t v5 = *(const char **)(a1 + 80);
  }
  else {
    uint64_t v5 = "NTPClockClient";
  }
  pthread_setname_np(v5);
  if (*(_BYTE *)(a1 + 92)) {
    SetCurrentThreadPriority(*(_DWORD *)(a1 + 88));
  }
  else {
    int v6 = v2;
  }
  memset(&v46.fds_bits[24], 0, 32);
  if (v6 < 0) {
    int v6 = -1;
  }
  int v7 = v6 + 1;
  memset(&v46, 0, 96);
  uint64_t v8 = mach_absolute_time();
  int v9 = *(_DWORD *)(a1 + 68);
  uint32_t v10 = arc4random();
  unint64_t v11 = MillisecondsToUpTicks(v10 % (*(_DWORD *)(a1 + 72) - *(_DWORD *)(a1 + 68) + 1) + v9) + v8;
  unint64_t v39 = v4;
  uint64_t v12 = v8 + v4;
  int v13 = 1 << v2;
  unint64_t v14 = v2 >> 5;
  int v15 = 1 << v3;
  unint64_t v16 = v3 >> 5;
LABEL_12:
  uint64_t v40 = v11;
LABEL_13:
  uint64_t v42 = v12;
  if (v12 >= v11) {
    uint64_t v17 = v11;
  }
  else {
    uint64_t v17 = v12;
  }
  do
  {
    while (1)
    {
      if (__darwin_check_fd_set_overflow(v2, &v46, 0)) {
        v46.fds_bits[v14] |= v13;
      }
      if (__darwin_check_fd_set_overflow(v3, &v46, 0)) {
        v46.fds_bits[v16] |= v15;
      }
      if (v17 == -1LL)
      {
        uint64_t v22 = 0LL;
      }

      else
      {
        uint64_t v18 = mach_absolute_time();
        BOOL v19 = v17 >= v18;
        unint64_t v20 = v17 - v18;
        if (v20 != 0 && v19)
        {
          unint64_t v21 = UpTicksToMicroseconds(v20);
          __darwin_time_t v23 = (int)(v21 / 0xF4240);
          __darwin_suseconds_t v24 = v21 % 0xF4240;
        }

        else
        {
          __darwin_time_t v23 = 0LL;
          __darwin_suseconds_t v24 = 0;
        }

        v45.tv_seCC_SHA1_CTX c = v23;
        v45.tv_useCC_SHA1_CTX c = v24;
        uint64_t v22 = &v45;
      }

      int v25 = select(v7, &v46, 0LL, 0LL, v22);
      if (v25 > 0) {
        break;
      }
      if (!v25) {
        goto LABEL_39;
      }
      if (*__error())
      {
        int v26 = *__error();
        if (!v26) {
          break;
        }
        if (v26 != 4)
        {
          if (v26 == -6722)
          {
LABEL_39:
            uint64_t v27 = mach_absolute_time();
            uint64_t v12 = v42;
            if (v27 >= v42)
            {
              uint64_t v43 = mach_absolute_time();
              pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 200));
              uint64_t v28 = (v43 - *(_DWORD *)(a1 + 3744));
              uint64_t v29 = v28 * *(void *)(a1 + 3752);
              uint64_t v30 = *(void *)(a1 + 3736);
              BOOL v19 = __CFADD__(v29, v30);
              *(void *)(a1 + 3736) = v29 + v30;
              uint64_t v31 = *(void *)(a1 + 3728);
              if (v19) {
                ++v31;
              }
              *(void *)(a1 + 3728) = v31;
              uint64_t v32 = *(void *)(a1 + 3784) * v28;
              uint64_t v33 = *(void *)(a1 + 3776);
              BOOL v19 = __CFADD__(v33, v32);
              *(void *)(a1 + 3776) = v33 + v32;
              uint64_t v34 = *(void *)(a1 + 3768);
              if (v19) {
                ++v34;
              }
              *(void *)(a1 + 3768) = v34;
              *(void *)(a1 + 3744) = v43;
              pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 200));
              uint64_t v12 = v27 + v39;
            }

            unint64_t v11 = v40;
            if (v27 >= v40)
            {
              uint64_t v44 = v12;
              _NTPClockClientSendRequest(a1);
              uint64_t v41 = v27;
              int v35 = *(_DWORD *)(a1 + 68);
              uint32_t v36 = arc4random();
              unint64_t v37 = MillisecondsToUpTicks(v36 % (*(_DWORD *)(a1 + 72) - *(_DWORD *)(a1 + 68) + 1) + v35);
              uint64_t v12 = v44;
              unint64_t v11 = v37 + v41;
              goto LABEL_12;
            }

            goto LABEL_13;
          }

          goto LABEL_38;
        }
      }

      else
      {
LABEL_38:
        usleep(0x186A0u);
      }
    }

    if (__darwin_check_fd_set_overflow(v3, &v46, 0) && (v46.fds_bits[v16] & v15) != 0) {
      _NTPClockClientProcessResponse(a1);
    }
  }

  while (!__darwin_check_fd_set_overflow(v2, &v46, 0) || (v46.fds_bits[v14] & v13) == 0);
  return 0LL;
}

uint64_t NTPClockGetSynchronizedNTPTime(uint64_t a1)
{
  uint64_t v2 = (mach_absolute_time() - *(void *)(a1 + 3744)) * *(void *)(a1 + 3752);
  uint64_t v3 = *(void *)(a1 + 3736);
  BOOL v4 = __CFADD__(v3, v2);
  uint64_t v5 = v3 + v2;
  unsigned int v6 = *(_DWORD *)(a1 + 3728);
  if (v4) {
    uint64_t v7 = v6 + 1;
  }
  else {
    uint64_t v7 = v6;
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 200));
  *((void *)&v9 + 1) = v7;
  *(void *)&__int128 v9 = v5;
  return v9 >> 32;
}

uint64_t NTPClockGetSynchronizedNTPTimeNearUpTicks(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = mach_absolute_time();
  uint64_t v5 = v4;
  if (v4 >= a2) {
    uint64_t v6 = v4 - a2;
  }
  else {
    uint64_t v6 = a2 - v4;
  }
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 200));
  uint64_t v7 = *(void *)(a1 + 3752);
  unint64_t v8 = *(void *)(a1 + 3760);
  uint64_t v9 = (v5 - *(void *)(a1 + 3744)) * v7;
  uint64_t v10 = *(void *)(a1 + 3736);
  uint64_t v11 = v9 + v10;
  if (__CFADD__(v9, v10)) {
    uint64_t v12 = *(void *)(a1 + 3728) + 1LL;
  }
  else {
    uint64_t v12 = *(void *)(a1 + 3728);
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 200));
  uint64_t v13 = v6 / v8;
  uint64_t v14 = v6 % v8 * v7;
  if (v5 >= a2)
  {
    BOOL v15 = v11 >= v14;
    uint64_t v16 = v11 - v14;
    uint64_t v18 = !v15;
    uint64_t v17 = v12 - v13 - v18;
  }

  else
  {
    BOOL v15 = __CFADD__(v14, v11);
    uint64_t v16 = v14 + v11;
    uint64_t v17 = v13 + v15 + v12;
  }

  *((void *)&v20 + 1) = v17;
  *(void *)&__int128 v20 = v16;
  return v20 >> 32;
}

unint64_t NTPClockGetUpTicksNearSynchronizedNTPTime(uint64_t a1, unint64_t a2)
{
  unint64_t SynchronizedNTPTime = NTPClockGetSynchronizedNTPTime(a1);
  uint64_t v4 = mach_absolute_time();
  if (SynchronizedNTPTime >= a2) {
    return v4 - NTPtoUpTicks(SynchronizedNTPTime - a2);
  }
  else {
    return NTPtoUpTicks(a2 - SynchronizedNTPTime) + v4;
  }
}

uint64_t NTPClockStartServer(uint64_t a1)
{
  uint64_t v2 = *(uint64_t (**)(void))(a1 + 120);
  if (v2)
  {
    uint64_t v3 = v2(*(void *)(a1 + 128));
  }

  else
  {
    if (UpTicksPerSecond_sOnce != -1) {
      dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
    }
    uint64_t v3 = UpTicksPerSecond_sTicksPerSecond;
  }

  *(void *)(a1 + 96) = v3;
  uint64_t v11 = ServerSocketPairOpen(2, 17, *(_DWORD *)(a1 + 48), (int *)(a1 + 52), -1, &v18, &v17);
  if (!(_DWORD)v11)
  {
    int v12 = v17;
    int v13 = v18;
    *(_DWORD *)(a1 + 232) = v18;
    *(_DWORD *)(a1 + 236) = v12;
    if ((v13 & 0x80000000) == 0)
    {
      if (*(_BYTE *)(a1 + 64)) {
        SocketSetP2P(v13, 1);
      }
      if (!*(_BYTE *)(a1 + 77)) {
        SocketSetQoS(v13, 20);
      }
      SocketSetPacketReceiveInfo(v13);
      SocketSetPacketTimestamps(v13, 1);
    }

    if ((v12 & 0x80000000) == 0)
    {
      if (*(_BYTE *)(a1 + 64)) {
        SocketSetP2P(v12, 1);
      }
      if (!*(_BYTE *)(a1 + 77)) {
        SocketSetQoS(v12, 20);
      }
      SocketSetPacketReceiveInfo(v12);
      SocketSetPacketTimestamps(v12, 1);
    }

    uint64_t v11 = OpenSelfConnectedLoopbackSocket((int *)(a1 + 224));
    if (!(_DWORD)v11)
    {
      uint64_t v11 = pthread_create((pthread_t *)(a1 + 208), 0LL, (void *(__cdecl *)(void *))_NTPClockServerThread, (void *)a1);
      if (!(_DWORD)v11)
      {
        *(void *)(a1 + 216) = a1 + 208;
        uint64_t v16 = *(int **)(a1 + 56);
        if (*v16 <= 30)
        {
          if (*v16 == -1)
          {
            uint64_t v16 = *(int **)(a1 + 56);
          }

          LogPrintF( (uint64_t)v16,  (uint64_t)"OSStatus NTPClockStartServer(NTPClockRef)",  0x1Eu,  (uint64_t)"NTP server started on port %d\n",  v7,  v8,  v9,  v10,  *(_DWORD *)(a1 + 52));
        }

        return 0LL;
      }
    }
  }

  uint64_t v14 = *(int **)(a1 + 56);
  if (*v14 <= 60)
  {
    if (*v14 == -1)
    {
      uint64_t v14 = *(int **)(a1 + 56);
    }

    LogPrintF( (uint64_t)v14,  (uint64_t)"OSStatus NTPClockStartServer(NTPClockRef)",  0x3Cu,  (uint64_t)"### NTP server start failed: %#m\n",  v7,  v8,  v9,  v10,  v11);
  }

uint64_t SocketSetPacketReceiveInfo(int a1)
{
  int v16 = 1;
  uint64_t result = SocketGetFamily(a1);
  if ((_DWORD)result == 30)
  {
    uint64_t result = setsockopt(a1, 41, 61, &v16, 4u);
    if ((_DWORD)result)
    {
      uint64_t result = (uint64_t)__error();
      if (*(_DWORD *)result) {
        uint64_t result = (uint64_t)__error();
      }
    }

    if (gLogCategory_NTPClockCore <= 30)
    {
      if (gLogCategory_NTPClockCore != -1) {
        return LogPrintF( (uint64_t)&gLogCategory_NTPClockCore,  (uint64_t)"OSStatus SocketSetPacketReceiveInfo(SocketRef, int)",  0x1Eu,  (uint64_t)"Set IPV6_RECVPKTINFO: enable %d, %#m",  v12,  v13,  v14,  v15,  v16);
      }
      uint64_t result = _LogCategory_Initialize((uint64_t)&gLogCategory_NTPClockCore, 0x1Eu);
      if ((_DWORD)result) {
        return LogPrintF( (uint64_t)&gLogCategory_NTPClockCore,  (uint64_t)"OSStatus SocketSetPacketReceiveInfo(SocketRef, int)",  0x1Eu,  (uint64_t)"Set IPV6_RECVPKTINFO: enable %d, %#m",  v12,  v13,  v14,  v15,  v16);
      }
    }
  }

  else
  {
    char v7 = result;
    if ((_DWORD)result == 2)
    {
      uint64_t result = setsockopt(a1, 0, 26, &v16, 4u);
      if ((_DWORD)result)
      {
        uint64_t result = (uint64_t)__error();
        if (*(_DWORD *)result) {
          uint64_t result = (uint64_t)__error();
        }
      }

      if (gLogCategory_NTPClockCore <= 30)
      {
        if (gLogCategory_NTPClockCore != -1) {
          return LogPrintF( (uint64_t)&gLogCategory_NTPClockCore,  (uint64_t)"OSStatus SocketSetPacketReceiveInfo(SocketRef, int)",  0x1Eu,  (uint64_t)"Set IP_PKTINFO: enable %d, %#m",  v8,  v9,  v10,  v11,  v16);
        }
        uint64_t result = _LogCategory_Initialize((uint64_t)&gLogCategory_NTPClockCore, 0x1Eu);
        if ((_DWORD)result) {
          return LogPrintF( (uint64_t)&gLogCategory_NTPClockCore,  (uint64_t)"OSStatus SocketSetPacketReceiveInfo(SocketRef, int)",  0x1Eu,  (uint64_t)"Set IP_PKTINFO: enable %d, %#m",  v8,  v9,  v10,  v11,  v16);
        }
      }
    }

    else if (gLogCategory_NTPClockCore <= 90)
    {
      if (gLogCategory_NTPClockCore != -1) {
        return LogPrintF( (uint64_t)&gLogCategory_NTPClockCore,  (uint64_t)"OSStatus SocketSetPacketReceiveInfo(SocketRef, int)",  0x5Au,  (uint64_t)"### IP_PKTINFO/IPV6_RECVPKTINFO not supported for this socket family: %d",  v3,  v4,  v5,  v6,  v7);
      }
      uint64_t result = _LogCategory_Initialize((uint64_t)&gLogCategory_NTPClockCore, 0x5Au);
      if ((_DWORD)result) {
        return LogPrintF( (uint64_t)&gLogCategory_NTPClockCore,  (uint64_t)"OSStatus SocketSetPacketReceiveInfo(SocketRef, int)",  0x5Au,  (uint64_t)"### IP_PKTINFO/IPV6_RECVPKTINFO not supported for this socket family: %d",  v3,  v4,  v5,  v6,  v7);
      }
    }
  }

  return result;
}

uint64_t _NTPClockServerThread(uint64_t a1)
{
  unint64_t v2 = *(int *)(a1 + 224);
  unint64_t v3 = *(unsigned int *)(a1 + 232);
  unint64_t v4 = *(unsigned int *)(a1 + 236);
  if (*(void *)(a1 + 80)) {
    uint64_t v5 = *(const char **)(a1 + 80);
  }
  else {
    uint64_t v5 = "NTPClockServer";
  }
  pthread_setname_np(v5);
  if (*(_BYTE *)(a1 + 92)) {
    SetCurrentThreadPriority(*(_DWORD *)(a1 + 88));
  }
  uint64_t v16 = a1;
  memset(&v18, 0, sizeof(v18));
  else {
    int v6 = v2;
  }
  int v7 = 1 << v2;
  unint64_t v8 = v2 >> 5;
  int v17 = 1 << v3;
  unint64_t v9 = v3 >> 5;
  if (v6 < 0) {
    int v6 = -1;
  }
  int v10 = v6 + 1;
  int v11 = 1 << v4;
  unint64_t v12 = v4 >> 5;
  do
  {
    while (1)
    {
      if (__darwin_check_fd_set_overflow(v2, &v18, 0)) {
        v18.fds_bits[v8] |= v7;
      }
      if ((v3 & 0x80000000) == 0 && __darwin_check_fd_set_overflow(v3, &v18, 0)) {
        v18.fds_bits[v9] |= v17;
      }
      if ((v4 & 0x80000000) == 0 && __darwin_check_fd_set_overflow(v4, &v18, 0)) {
        v18.fds_bits[v12] |= v11;
      }
      int v13 = select(v10, &v18, 0LL, 0LL, 0LL);
      if (v13 > 0) {
        break;
      }
      if (v13 && *__error())
      {
        int v14 = *__error();
        if (!v14) {
          break;
        }
        if (v14 == 4) {
          continue;
        }
      }

      usleep(0x186A0u);
    }

    if ((v3 & 0x80000000) == 0 && __darwin_check_fd_set_overflow(v3, &v18, 0) && (v18.fds_bits[v9] & v17) != 0) {
      _NTPClockServerProcessPacket(v16, v3);
    }
    if ((v4 & 0x80000000) == 0 && __darwin_check_fd_set_overflow(v4, &v18, 0) && (v18.fds_bits[v12] & v11) != 0) {
      _NTPClockServerProcessPacket(v16, v4);
    }
  }

  while (!__darwin_check_fd_set_overflow(v2, &v18, 0) || (v18.fds_bits[v8] & v7) == 0);
  return 0LL;
}

uint64_t _NTPClockServerProcessPacket(uint64_t a1, int a2)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  unint64_t v4 = *(void *)(a1 + 96);
  v39.int sa_family = 0;
  fd_set v46 = v40;
  uint64_t v47 = 48LL;
  v45.msg_name = &v39;
  v45.socklen_t msg_namelen = 28;
  v45.msg_iov = (iovec *)&v46;
  v45.msg_iovlen = 1;
  v45.msg_control = &v48;
  *(void *)&v45.msg_controllen = 256LL;
  do
  {
    ssize_t v5 = recvmsg(a2, &v45, 0);
    if ((v5 & 0x8000000000000000LL) == 0) {
      goto LABEL_6;
    }
    if (!*__error()) {
      goto LABEL_17;
    }
    int v10 = *__error();
  }

  while (v10 == 4);
  if (v10)
  {
LABEL_17:
    int v15 = 0;
LABEL_49:
    uint64_t result = *(void *)(a1 + 56);
    if (*(_DWORD *)result == -1)
    {
      uint64_t result = _LogCategory_Initialize(result, 0x32u);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t result = *(void *)(a1 + 56);
    }

    uint64_t v29 = " RTCP";
    if (!v15) {
      uint64_t v29 = "";
    }
    return LogPrintF( result,  (uint64_t)"void _NTPClockServerProcessPacket(NTPClockRef, SocketRef)",  0x32u,  (uint64_t)"### NTP server send%s to %##a failed: %#m\n",  v6,  v7,  v8,  v9,  (char)v29);
  }

CFStringRef OPACKDecodeData(const __CFData *a1, int a2, _DWORD *a3)
{
  BytePtr = (UInt8 *)CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  return _OPACKDecodeBytes((uint64_t)a1, BytePtr, Length, a2, a3);
}

CFStringRef _OPACKDecodeBytes(uint64_t a1, UInt8 *a2, uint64_t a3, int a4, _DWORD *a5)
{
  if (gOPACKInitalizeOnce != -1) {
    dispatch_once_f(&gOPACKInitalizeOnce, 0LL, (dispatch_function_t)_OPACKInitializeOnce);
  }
  uint64_t v16 = a1;
  int v17 = a4;
  CFTypeRef cf = 0LL;
  uint64_t v20 = 0LL;
  fd_set v18 = a2;
  int v21 = 0;
  if ((a4 & 2) == 0)
  {
    __int128 v10 = *(_OWORD *)(MEMORY[0x189605250] + 16LL);
    *(_OWORD *)&valueCallBacks.version = *MEMORY[0x189605250];
    *(_OWORD *)&valueCallBacks.release = v10;
    valueCallBacks.equal = (CFDictionaryEqualCallBack)_OPACKObjectsExactlyEqual;
    CFTypeRef cf = CFDictionaryCreateMutable(0LL, 0LL, 0LL, &valueCallBacks);
    if (!cf)
    {
      unint64_t v12 = 0LL;
      int v22 = -6728;
      if (!a5) {
        return v12;
      }
      goto LABEL_11;
    }
  }

  int v11 = _OPACKDecodeObject((uint64_t)&v16, a2, (unint64_t)&a2[a3], &v14, &v22);
  unint64_t v12 = v11;
  if (!v22 && !v11) {
    int v22 = -6742;
  }
  if (cf) {
    CFRelease(cf);
  }
  if (a5) {
LABEL_11:
  }
    *a5 = v22;
  return v12;
}

CFNumberRef _OPACKInitializeOnce()
{
  gCFArrayType_11814 = CFArrayGetTypeID();
  gCFBooleanType_11815 = CFBooleanGetTypeID();
  gCFDataType_11816 = CFDataGetTypeID();
  gCFDateType_11817 = CFDateGetTypeID();
  gCFDictionaryType_11818 = CFDictionaryGetTypeID();
  gCFNumberType_11813 = CFNumberGetTypeID();
  gCFStringType_11819 = CFStringGetTypeID();
  uint64_t v0 = 0LL;
  gCFUUIDType = CFUUIDGetTypeID();
  do
  {
    char valuePtr = v0 - 1;
    CFNumberRef result = CFNumberCreate(0LL, kCFNumberSInt8Type, &valuePtr);
    gCFNumbers[v0] = result;
    if (!result) {
      FatalErrorF("Create small number %d failed");
    }
    ++v0;
  }

  while (v0 != 41);
  return result;
}

BOOL _OPACKObjectsExactlyEqual(const void *a1, const __CFNumber *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  BOOL result = 0;
  if (v4 == CFGetTypeID(a2))
  {
    if (CFEqual(a1, a2))
    {
      if (v4 != gCFNumberType_11813) {
        return 1;
      }
      int IsFloatType = CFNumberIsFloatType((CFNumberRef)a1);
      if (IsFloatType == CFNumberIsFloatType(a2)) {
        return 1;
      }
    }
  }

  return result;
}

CFStringRef _OPACKDecodeObject(uint64_t a1, UInt8 *bytes, unint64_t a3, void *a4, int *a5)
{
  __int128 v10 = bytes + 1;
  int v9 = *bytes;
  int v37 = bytes + 1;
  if ((v9 - 64) <= 0x20)
  {
    unint64_t v11 = (v9 - 64);
    if (v9 == 64)
    {
      unint64_t v12 = &stru_189F34A78;
LABEL_17:
      int v37 = v10;
      goto LABEL_18;
    }

    if (a3 - (unint64_t)v10 >= v11)
    {
      unint64_t v12 = CFStringCreateWithBytes(0LL, bytes + 1, (v9 - 64), 0x8000100u, 0);
      if (v12)
      {
        v10 += v11;
LABEL_7:
        int v13 = *(__CFDictionary **)(a1 + 24);
        if (v13)
        {
          uint64_t v14 = *(char **)(a1 + 32);
          *(void *)(a1 + 32) = v14 + 1;
          CFDictionaryAddValue(v13, v14, v12);
        }

        goto LABEL_17;
      }

      goto LABEL_106;
    }

LABEL_106:
      int v18 = -6728;
      goto LABEL_19;
    }

    unint64_t v12 = 0LL;
    switch(v9)
    {
      case 1:
        unsigned int v23 = (const __CFString **)MEMORY[0x189604DE8];
        goto LABEL_47;
      case 2:
        unsigned int v23 = (const __CFString **)MEMORY[0x189604DE0];
        goto LABEL_47;
      case 3:
        goto LABEL_18;
      case 4:
        unsigned int v23 = (const __CFString **)MEMORY[0x189605018];
LABEL_47:
        unint64_t v12 = *v23;
        goto LABEL_18;
      default:
        if ((v9 + 96) <= 0x24u)
        {
          ssize_t v26 = (const __CFString *)_OPACKDecodeUID(a1, bytes + 1, a3, v9, &v37, (int *)v38);
          goto LABEL_90;
        }

        if ((v9 & 0xF0) == 0xD0)
        {
          ssize_t v26 = (const __CFString *)_OPACKDecodeArray(a1, bytes + 1, a3, v9, &v37, (int *)v38);
        }

        else
        {
          if ((v9 & 0xF0) == 0xE0)
          {
            ssize_t v26 = (const __CFString *)_OPACKDecodeDictionary(a1, bytes + 1, a3, v9, &v37, (int *)v38);
            goto LABEL_90;
          }

          unsigned __int8 v32 = v9 - 112;
          if ((v9 - 112) <= 0x20)
          {
            unint64_t v12 = (const __CFString *)CFDataCreate(0LL, bytes + 1, (v9 - 112));
            if (!v12) {
              goto LABEL_106;
            }
            int v37 = &v10[v32];
            if (v32 < 2u) {
              goto LABEL_18;
            }
            goto LABEL_104;
          }

          if ((v9 + 111) > 3u)
          {
            switch(v9)
            {
              case 5:
                if ((*(_BYTE *)(a1 + 8) & 8) != 0)
                {
                  CFUUIDRef v33 = (CFUUIDRef)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:v10];
                }

                else
                {
                  *(void *)&v40.byte0 = *(void *)(bytes + 1);
                  *(void *)&v40.byte8 = *(void *)(bytes + 9);
                  CFUUIDRef v33 = CFUUIDCreateFromUUIDBytes(0LL, v40);
                }

                unint64_t v12 = (const __CFString *)v33;
                if (!v33) {
                  goto LABEL_106;
                }
                unsigned int v34 = bytes + 17;
                break;
              case 6:
                unint64_t v12 = (const __CFString *)CFDateCreate(0LL, *(CFAbsoluteTime *)v10);
                if (!v12) {
                  goto LABEL_106;
                }
                unsigned int v34 = bytes + 9;
                break;
              case 159:
                ssize_t v26 = (const __CFString *)_OPACKDecodeDataChunks(a1, (char *)bytes + 1, a3, (char **)&v37, (int *)v38);
                goto LABEL_90;
              default:
                unint64_t v12 = 0LL;
                int v18 = -6735;
                goto LABEL_19;
            }

            int v37 = v34;
LABEL_104:
            unsigned int v35 = *(__CFDictionary **)(a1 + 24);
            if (v35)
            {
              unsigned int v36 = *(char **)(a1 + 32);
              *(void *)(a1 + 32) = v36 + 1;
              CFDictionaryAddValue(v35, v36, v12);
            }

            goto LABEL_18;
          }

          ssize_t v26 = (const __CFString *)_OPACKDecodeData(a1, bytes + 1, a3, v9, (const UInt8 **)&v37, (int *)v38);
        }

    ssize_t v26 = 0;
    uint64_t v27 = -6728;
    goto LABEL_27;
  }

const void *_OPACKDecodeUID( uint64_t a1, unsigned __int8 *a2, uint64_t a3, int a4, unsigned __int8 **a5, int *a6)
{
  uint64_t v8 = a2;
  if ((a4 + 96) > 0x20u)
  {
    switch(a4)
    {
      case 193:
        uint64_t v8 = a2 + 1;
        unint64_t v9 = *a2;
        goto LABEL_3;
      case 194:
        uint64_t v8 = a2 + 2;
        unint64_t v9 = *(unsigned __int16 *)a2;
        goto LABEL_3;
      case 195:
        unint64_t v9 = *(unsigned __int16 *)a2 | ((unint64_t)a2[2] << 16);
        v8 += 3;
        goto LABEL_3;
      case 196:
        if (a3 - (uint64_t)a2 >= 4)
        {
          uint64_t v8 = a2 + 4;
          unint64_t v9 = *(unsigned int *)a2;
          goto LABEL_3;
        }

__CFDictionary *_OPACKDecodeDictionary(uint64_t a1, UInt8 *a2, uint64_t a3, int a4, UInt8 **a5, int *a6)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    if ((a4 + 32) >= 0xFu)
    {
      while (1)
      {
        int v20 = *(_DWORD *)(a1 + 40);
        if (v20 > 31) {
          goto LABEL_18;
        }
        *(_DWORD *)(a1 + 40) = v20 + 1;
        uint64_t v21 = _OPACKDecodeObject(a1, a2);
        uint64_t v14 = (const void *)v21;
        int v22 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(a1 + 40) = v22 - 1;
        if (v26) {
          break;
        }
        if (!v21) {
          goto LABEL_9;
        }
        *(_DWORD *)(a1 + 40) = v22;
        unsigned int v23 = (const void *)_OPACKDecodeObject(a1, a2);
        unint64_t v24 = v23;
        --*(_DWORD *)(a1 + 40);
        if (!v23)
        {
LABEL_19:
          int v26 = -6742;
LABEL_20:
          CFRelease(v14);
          goto LABEL_23;
        }

        CFDictionaryAddValue(Mutable, v14, v23);
        CFRelease(v14);
        CFRelease(v24);
      }

__CFArray *_OPACKDecodeArray(uint64_t a1, UInt8 *a2, uint64_t a3, int a4, UInt8 **a5, int *a6)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  if (!Mutable)
  {
    int v15 = -6728;
    goto LABEL_9;
  }

  if ((a4 + 48) >= 0xFu)
  {
    while (1)
    {
      int v17 = *(_DWORD *)(a1 + 40);
      if (v17 > 31) {
        break;
      }
      *(_DWORD *)(a1 + 40) = v17 + 1;
      int v18 = (const void *)_OPACKDecodeObject(a1, a2);
      uint64_t v14 = v18;
      --*(_DWORD *)(a1 + 40);
      if (v20)
      {
LABEL_14:
        if (v14) {
          CFRelease(v14);
        }
        goto LABEL_19;
      }

      if (!v18) {
        goto LABEL_8;
      }
      CFArrayAppendValue(Mutable, v18);
      CFRelease(v14);
    }
  }

  else
  {
    uint64_t v11 = (a4 - 208);
    if (a4 == 208)
    {
LABEL_8:
      int v15 = 0;
      goto LABEL_9;
    }

    while (1)
    {
      int v12 = *(_DWORD *)(a1 + 40);
      if (v12 >= 32) {
        break;
      }
      *(_DWORD *)(a1 + 40) = v12 + 1;
      uint64_t v13 = (const void *)_OPACKDecodeObject(a1, a2);
      uint64_t v14 = v13;
      --*(_DWORD *)(a1 + 40);
      if (v20) {
        goto LABEL_14;
      }
      if (!v13)
      {
        int v19 = -6742;
        goto LABEL_18;
      }

      CFArrayAppendValue(Mutable, v13);
      CFRelease(v14);
      if (!--v11) {
        goto LABEL_8;
      }
    }
  }

  int v19 = -6751;
LABEL_18:
  int v20 = v19;
LABEL_19:
  CFRelease(Mutable);
  CFMutableArrayRef Mutable = 0LL;
  int v15 = v20;
LABEL_9:
  *a5 = a2;
  *a6 = v15;
  return Mutable;
}

CFDataRef _OPACKDecodeData(uint64_t a1, UInt8 *bytes, uint64_t a3, int a4, const UInt8 **a5, int *a6)
{
  uint64_t v8 = bytes;
  switch(a4)
  {
    case 145:
      uint64_t v8 = bytes + 1;
      unint64_t v10 = *bytes;
      goto LABEL_12;
    case 146:
      uint64_t v8 = bytes + 2;
      unint64_t v10 = *(unsigned __int16 *)bytes;
      goto LABEL_12;
    case 147:
      uint64_t v8 = bytes + 4;
      unint64_t v10 = *(unsigned int *)bytes;
      goto LABEL_12;
    case 148:
      uint64_t v8 = bytes + 8;
      unint64_t v10 = *(void *)bytes;
      if ((*(void *)bytes & 0x8000000000000000LL) != 0)
      {
        CFDataRef v11 = 0LL;
        int v12 = -6743;
      }

      else
      {
LABEL_12:
        if (a3 - (uint64_t)v8 < v10)
        {
LABEL_24:
          CFDataRef v11 = 0LL;
          int v12 = -6750;
          goto LABEL_20;
        }

        uint64_t v13 = *(void *)a1;
        if (*(void *)a1 && (*(_BYTE *)(a1 + 8) & 4) != 0)
        {
          int v17 = CFDataCreateSubdataWithRangeNoCopy(v13, (uint64_t)&v8[-*(void *)(a1 + 16)], v10, &v18);
          CFDataRef v11 = (CFDataRef)v17;
          int v12 = v18;
          if (v18) {
            goto LABEL_20;
          }
          if (!v17)
          {
LABEL_5:
            int v12 = -6762;
            goto LABEL_20;
          }
        }

        else
        {
          CFDataRef v11 = CFDataCreate(0LL, v8, v10);
          if (!v11)
          {
            int v12 = -6728;
            goto LABEL_20;
          }
        }

        v8 += v10;
        if (v10 >= 2)
        {
          uint64_t v14 = *(__CFDictionary **)(a1 + 24);
          if (v14)
          {
            int v15 = *(char **)(a1 + 32);
            *(void *)(a1 + 32) = v15 + 1;
            CFDictionaryAddValue(v14, v15, v11);
          }
        }

        int v12 = 0;
      }

CFDataRef _OPACKDecodeDataChunks(uint64_t a1, char *a2, uint64_t a3, char **a4, int *a5)
{
  if (a3 - (uint64_t)a2 < 1)
  {
    CFDataRef v16 = 0LL;
    int v20 = -6750;
  }

  else
  {
    uint64_t v21 = a4;
    uint64_t v8 = 0LL;
    unint64_t v9 = 0LL;
    while (1)
    {
      CFDataRef v11 = a2 + 1;
      int v10 = *a2;
      size_t v12 = (v10 - 112);
LABEL_5:
      if (v12)
      {
        if (a3 - (uint64_t)v11 < v12)
        {
LABEL_39:
          int v20 = -6750;
          goto LABEL_28;
        }

        if (__CFADD__(v12, v9))
        {
          int v20 = -6710;
          goto LABEL_28;
        }

        uint64_t v13 = (char *)realloc(v8, v12 + v9);
        if (!v13)
        {
LABEL_40:
          int v20 = -6728;
          goto LABEL_28;
        }

        uint64_t v14 = v13;
        memcpy(&v13[v9], v11, v12);
        a2 = &v11[v12];
        uint64_t v8 = v14;
        v9 += v12;
      }

      else
      {
        a2 = v11;
      }

      if (a3 - (uint64_t)a2 < 1)
      {
        int v20 = -6750;
        CFDataRef v11 = a2;
LABEL_28:
        if (v8) {
          free(v8);
        }
        CFDataRef v16 = 0LL;
        goto LABEL_37;
      }
    }

    switch(*a2)
    {
      case -111:
        CFDataRef v11 = a2 + 2;
        size_t v12 = a2[1];
        goto LABEL_5;
      case -110:
        size_t v12 = *(unsigned __int16 *)(a2 + 1);
        CFDataRef v11 = a2 + 3;
        goto LABEL_5;
      case -109:
        size_t v12 = *(unsigned int *)(a2 + 1);
        CFDataRef v11 = a2 + 5;
        goto LABEL_5;
      case -108:
        size_t v12 = *(void *)(a2 + 1);
        CFDataRef v11 = a2 + 9;
        if ((v12 & 0x8000000000000000LL) == 0) {
          goto LABEL_5;
        }
        goto LABEL_22;
      default:
        if (v10 != 3)
        {
          int v20 = -6742;
          goto LABEL_28;
        }

        if ((v9 & 0x8000000000000000LL) != 0)
        {
LABEL_22:
          int v20 = -6743;
          goto LABEL_28;
        }

        if (v8) {
          CFDataRef v15 = CFDataCreateWithBytesNoCopy(0LL, (const UInt8 *)v8, v9, (CFAllocatorRef)*MEMORY[0x189604DB8]);
        }
        else {
          CFDataRef v15 = CFDataCreate(0LL, (const UInt8 *)"", 0LL);
        }
        CFDataRef v16 = v15;
        if (!v15) {
          goto LABEL_40;
        }
        if (v9 >= 2)
        {
          int v17 = *(__CFDictionary **)(a1 + 24);
          if (v17)
          {
            int v18 = *(char **)(a1 + 32);
            *(void *)(a1 + 32) = v18 + 1;
            CFDictionaryAddValue(v17, v18, v16);
          }
        }

        int v20 = 0;
        break;
    }

CFMutableDataRef OPACKEncoderCreateDataMutable(const __CFString *a1, int a2, int *a3)
{
  CFMutableDataRef Mutable = CFDataCreateMutable(0LL, 0LL);
  if (Mutable)
  {
    int v7 = OPACKEncodeObject(a1, a2, (uint64_t)_OPACKEncoderAppendCallback, (uint64_t)Mutable);
    if (v7)
    {
      CFRelease(Mutable);
      CFMutableDataRef Mutable = 0LL;
    }
  }

  else
  {
    int v7 = -6728;
  }

  if (a3) {
    *a3 = v7;
  }
  return Mutable;
}

uint64_t _OPACKEncoderAppendCallback(UInt8 *bytes, CFIndex length, int a3, CFMutableDataRef theData)
{
  return 0LL;
}

uint64_t OPACKEncodeObject(const __CFString *a1, int a2, uint64_t a3, uint64_t a4)
{
  char v4 = a2;
  v10[0] = a3;
  v10[1] = a4;
  CFTypeRef cf = 0LL;
  uint64_t v12 = 0LL;
  int v13 = a2;
  if (gOPACKInitalizeOnce == -1)
  {
    if ((a2 & 2) != 0) {
      goto LABEL_4;
    }
  }

  else
  {
    dispatch_once_f(&gOPACKInitalizeOnce, 0LL, (dispatch_function_t)_OPACKInitializeOnce);
    if ((v4 & 2) != 0) {
      goto LABEL_4;
    }
  }

  __int128 v6 = *(_OWORD *)(MEMORY[0x189605240] + 32LL);
  *(_OWORD *)&v9.release = *(_OWORD *)(MEMORY[0x189605240] + 16LL);
  *(_OWORD *)&v9.equal = v6;
  *(_OWORD *)&v9.version = *MEMORY[0x189605240];
  v9.equal = (CFDictionaryEqualCallBack)_OPACKObjectsExactlyEqual;
  CFTypeRef cf = CFDictionaryCreateMutable(0LL, 0LL, &v9, 0LL);
  if (!cf) {
    return 4294960568LL;
  }
LABEL_4:
  uint64_t v7 = _OPACKEncodeObject((uint64_t)v10, a1);
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

uint64_t _OPACKEncodeObject(uint64_t a1, const __CFString *a2)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  CFTypeID v4 = CFGetTypeID(a2);
  if (v4 == gCFStringType_11819)
  {
    int v37 = 0LL;
    if (!*(void *)(a1 + 16) || CFStringGetLength(a2) < 1) {
      goto LABEL_6;
    }
    context[0] = 0;
    uint64_t v5 = _OPACKEncodeUID(a1, a2, context);
    if (!(_DWORD)v5)
    {
      if (!context[0])
      {
LABEL_6:
        uint64_t v6 = CFStringGetOrCopyCStringUTF8(a2, &valuePtr, (UInt8 **)&v37, &v36);
        if (!(_DWORD)v6)
        {
          if (v36 > 0x20)
          {
            if (v36 > 0xFF)
            {
              if (v36 >> 16)
              {
                if (HIDWORD(v36))
                {
                  context[0] = 100;
                  *(void *)&context[1] = v36;
                  uint64_t v7 = 9LL;
                }

                else
                {
                  context[0] = 99;
                  *(_DWORD *)&context[1] = v36;
                  uint64_t v7 = 5LL;
                }
              }

              else
              {
                context[0] = 98;
                *(_WORD *)&context[1] = v36;
                uint64_t v7 = 3LL;
              }
            }

            else
            {
              context[0] = 97;
              context[1] = v36;
              uint64_t v7 = 2LL;
            }
          }

          else
          {
            context[0] = v36 + 64;
            uint64_t v7 = 1LL;
          }

          uint64_t v6 = (*(uint64_t (**)(_BYTE *, uint64_t, void, void))a1)(context, v7, 0LL, *(void *)(a1 + 8));
          if (!(_DWORD)v6)
          {
            if (v36) {
              uint64_t v6 = (*(uint64_t (**)(const char *, size_t, void, void))a1)( valuePtr,  v36,  0LL,  *(void *)(a1 + 8));
            }
            else {
              uint64_t v6 = 0LL;
            }
          }
        }

        if (v37) {
          free(v37);
        }
        return v6;
      }

      return 0LL;
    }

    return v5;
  }

  CFTypeID v8 = v4;
  if (v4 == gCFNumberType_11813)
  {
    if (CFNumberIsFloatType((CFNumberRef)a2))
    {
      if (!*(void *)(a1 + 16)) {
        goto LABEL_14;
      }
      context[0] = 0;
      uint64_t v5 = _OPACKEncodeUID(a1, a2, context);
      if ((_DWORD)v5) {
        return v5;
      }
      if (!context[0])
      {
LABEL_14:
        if (CFNumberGetByteSize((CFNumberRef)a2) > 4)
        {
          CFNumberGetValue((CFNumberRef)a2, kCFNumberFloat64Type, &valuePtr);
          context[0] = 54;
          *(void *)&context[1] = valuePtr;
          uint64_t v9 = 9LL;
        }

        else
        {
          uint64_t v9 = 5LL;
          CFNumberGetValue((CFNumberRef)a2, kCFNumberFloat32Type, &valuePtr);
          context[0] = 53;
          *(_DWORD *)&context[1] = (_DWORD)valuePtr;
        }

        return (*(uint64_t (**)(_BYTE *, uint64_t, void, void))a1)(context, v9, 0LL, *(void *)(a1 + 8));
      }

      return 0LL;
    }

    if ((*(_BYTE *)(a1 + 32) & 0x10) == 0)
    {
      CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt64Type, &valuePtr);
      int v17 = valuePtr;
      if (*(void *)(a1 + 16) && (unint64_t)(valuePtr - 40) <= 0xFFFFFFFFFFFFFFD6LL)
      {
        context[0] = 0;
        uint64_t v6 = _OPACKEncodeUID(a1, a2, context);
        if ((_DWORD)v6 || context[0]) {
          return v6;
        }
        int v17 = valuePtr;
      }

      if (v17 == (const char *)(char)v17)
      {
        if (((_BYTE)v17 + 1) > 0x28u)
        {
          context[0] = 48;
          context[1] = (_BYTE)v17;
          uint64_t v9 = 2LL;
        }

        else
        {
          context[0] = (_BYTE)v17 + 8;
          uint64_t v9 = 1LL;
        }
      }

      else if (v17 == (const char *)(int)v17)
      {
        context[0] = 50;
        *(_WORD *)&context[1] = (_WORD)v17;
        context[3] = BYTE2(v17);
        uint64_t v9 = 5LL;
        context[4] = BYTE3(v17);
      }

      else
      {
        context[0] = 51;
        *(void *)&context[1] = v17;
        uint64_t v9 = 9LL;
      }

      return (*(uint64_t (**)(_BYTE *, uint64_t, void, void))a1)(context, v9, 0LL, *(void *)(a1 + 8));
    }

    uint64_t valuePtr = 0LL;
    unint64_t v39 = 0LL;
    CFNumberGetValue((CFNumberRef)a2, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
    unint64_t v27 = (unint64_t)valuePtr;
    unint64_t v26 = v39;
    if (*(void *)(a1 + 16)
      && __PAIR128__(-1LL, -42LL) >= __PAIR128__((unint64_t)&valuePtr[(v39 >= 0x28) - 1], v39 - 40))
    {
      context[0] = 0;
      uint64_t v5 = _OPACKEncodeUID(a1, a2, context);
      if ((_DWORD)v5) {
        return v5;
      }
      if (context[0]) {
        return 0LL;
      }
    }

    else if (v39 + 1 <= 0x28)
    {
      context[0] = v39 + 8;
      uint64_t v14 = 1LL;
LABEL_105:
      uint64_t v12 = *(uint64_t (**)(const char **, uint64_t, void, uint64_t))a1;
      uint64_t v11 = *(void *)(a1 + 8);
      p_uint64_t valuePtr = (const char **)context;
      return v12(p_valuePtr, v14, 0LL, v11);
    }

    if (v26 + 128 > 0xFF)
    {
      if (v26 < 0xFFFFFFFFFFFF8000LL) {
        unint64_t v29 = v27;
      }
      else {
        unint64_t v29 = v27 + 1;
      }
      if (v29 | ((v26 + 0x8000) >> 16))
      {
        if (v26 < 0xFFFFFFFF80000000LL) {
          unint64_t v30 = v27;
        }
        else {
          unint64_t v30 = v27 + 1;
        }
        if (v30 | ((v26 + 0x80000000) >> 32))
        {
          if (v26 < 0x8000000000000000LL) {
            CFNumberRef v31 = (const char *)v27;
          }
          else {
            CFNumberRef v31 = (const char *)(v27 + 1);
          }
          if (v31)
          {
            context[0] = 52;
            *(void *)&context[1] = v26;
            char v41 = v27;
            unint64_t v32 = HIDWORD(v27);
            unint64_t v33 = v27 >> 24;
            unint64_t v34 = v27 >> 16;
            unint64_t v35 = v27 >> 8;
            unsigned __int32 v42 = vmovn_s16((int16x8_t)vqtbl4q_s8(*(int8x16x4_t *)(&v22 - 1), (int8x16_t)xmmword_186B49CA0)).u32[0];
            char v43 = BYTE5(v27);
            char v44 = BYTE6(v27);
            LOBYTE(v45) = HIBYTE(v27);
            uint64_t v14 = 17LL;
          }

          else
          {
            context[0] = 51;
            *(void *)&context[1] = v26;
            uint64_t v14 = 9LL;
          }
        }

        else
        {
          context[0] = 50;
          *(_WORD *)&context[1] = v26;
          context[3] = BYTE2(v26);
          uint64_t v14 = 5LL;
          context[4] = BYTE3(v26);
        }
      }

      else
      {
        context[0] = 49;
        *(_WORD *)&context[1] = v26;
        uint64_t v14 = 3LL;
      }
    }

    else
    {
      context[0] = 48;
      context[1] = v26;
      uint64_t v14 = 2LL;
    }

    goto LABEL_105;
  }

  if (v4 == gCFBooleanType_11815)
  {
    if ((const __CFString *)*MEMORY[0x189604DE8] == a2) {
      char v10 = 1;
    }
    else {
      char v10 = 2;
    }
    goto LABEL_20;
  }

  if (v4 == gCFDictionaryType_11818)
  {
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a2);
    char v16 = Count - 32;
    if (Count >= 15) {
      char v16 = -17;
    }
    LOBYTE(valuePtr) = v16;
    uint64_t v5 = (*(uint64_t (**)(const char **, uint64_t, void, void))a1)( &valuePtr,  1LL,  0LL,  *(void *)(a1 + 8));
    if ((_DWORD)v5) {
      return v5;
    }
    if (Count >= 1)
    {
      *(void *)context = a1;
      unsigned int v45 = 0;
      CFDictionaryApplyFunction( (CFDictionaryRef)a2,  (CFDictionaryApplierFunction)_OPACKEncodeDictionaryApplier,  context);
      uint64_t v6 = v45;
      if (v45) {
        return v6;
      }
    }

    LOBYTE(valuePtr) = 3;
    uint64_t v12 = *(uint64_t (**)(const char **, uint64_t, void, uint64_t))a1;
    uint64_t v11 = *(void *)(a1 + 8);
    p_uint64_t valuePtr = &valuePtr;
    goto LABEL_21;
  }

  if (v4 == gCFArrayType_11814)
  {
    CFIndex v18 = CFArrayGetCount((CFArrayRef)a2);
    char v19 = v18 - 48;
    if (v18 >= 15) {
      char v19 = -33;
    }
    context[0] = v19;
    uint64_t v5 = (*(uint64_t (**)(_BYTE *, uint64_t, void, void))a1)(context, 1LL, 0LL, *(void *)(a1 + 8));
    if ((_DWORD)v5) {
      return v5;
    }
    if (v18 >= 1)
    {
      CFIndex v20 = 0LL;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v20);
        uint64_t v5 = _OPACKEncodeObject(a1, ValueAtIndex);
        if ((_DWORD)v5) {
          return v5;
        }
      }

      while (v18 != ++v20);
    }

    if (context[0] != 223) {
      return 0LL;
    }
    char v10 = 3;
    goto LABEL_20;
  }

  if (v4 == gCFDataType_11816) {
    return _OPACKEncodeData(a1, (CFDataRef)a2);
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0) {
    return _OPACKEncodeUUID(a1, (CFUUIDRef)a2, 1);
  }
  if (v8 == gCFUUIDType) {
    return _OPACKEncodeUUID(a1, (CFUUIDRef)a2, 0);
  }
  if ((const __CFString *)*MEMORY[0x189605018] == a2)
  {
    char v10 = 4;
LABEL_20:
    context[0] = v10;
    uint64_t v12 = *(uint64_t (**)(const char **, uint64_t, void, uint64_t))a1;
    uint64_t v11 = *(void *)(a1 + 8);
    p_uint64_t valuePtr = (const char **)context;
LABEL_21:
    uint64_t v14 = 1LL;
    return v12(p_valuePtr, v14, 0LL, v11);
  }

  if (v8 == gCFDateType_11817) {
    return _OPACKEncodeDate(a1, a2);
  }
  return 4294960561LL;
}

uint64_t _OPACKEncodeUID(uint64_t a1, const void *a2, _BYTE *a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  if (!Value)
  {
    CFTypeID v8 = *(__CFDictionary **)(a1 + 16);
    uint64_t v9 = (const void *)(*(void *)(a1 + 24) + 1LL);
    *(void *)(a1 + 24) = v9;
    CFDictionaryAddValue(v8, a2, v9);
    uint64_t result = 0LL;
    *a3 = 0;
    return result;
  }

  if ((unint64_t)Value > 0x21)
  {
    if ((unint64_t)Value > 0x100)
    {
      if ((unint64_t)Value > 0x10000)
      {
        if ((unint64_t)Value >= 0x1000001)
        {
          char v11 = -60;
          int v12 = (_DWORD)Value - 1;
          uint64_t v7 = 5LL;
        }

        else
        {
          char v11 = -61;
          LOWORD(v12) = (_WORD)Value - 1;
          BYTE2(v12) = ((_DWORD)Value - 1) >> 16;
          uint64_t v7 = 4LL;
        }
      }

      else
      {
        char v11 = -62;
        LOWORD(v12) = (_WORD)Value - 1;
        uint64_t v7 = 3LL;
      }
    }

    else
    {
      char v11 = -63;
      LOBYTE(v12) = (_BYTE)Value - 1;
      uint64_t v7 = 2LL;
    }
  }

  else
  {
    char v11 = (_BYTE)Value - 97;
    uint64_t v7 = 1LL;
  }

  uint64_t result = (*(uint64_t (**)(char *, uint64_t, void, void))a1)(&v11, v7, 0LL, *(void *)(a1 + 8));
  if (!(_DWORD)result) {
    *a3 = 1;
  }
  return result;
}

uint64_t _OPACKEncodeDictionaryApplier(uint64_t result, uint64_t a2, void *a3)
{
  if (!*((_DWORD *)a3 + 4))
  {
    uint64_t result = _OPACKEncodeObject(*a3, result);
    if ((_DWORD)result || (uint64_t result = _OPACKEncodeObject(*a3, a2), (_DWORD)result)) {
      *((_DWORD *)a3 + 4) = result;
    }
  }

  return result;
}

uint64_t _OPACKEncodeData(uint64_t a1, CFDataRef theData)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  unint64_t Length = CFDataGetLength(theData);
  if (Length <= 1) {
    goto LABEL_6;
  }
  if (*(void *)(a1 + 16))
  {
    char v9 = 0;
    uint64_t result = _OPACKEncodeUID(a1, theData, &v9);
    if ((_DWORD)result || v9) {
      return result;
    }
  }

  if (Length > 0x20)
  {
    if (Length > 0xFF)
    {
      if (Length >> 16)
      {
        if (HIDWORD(Length))
        {
          char v9 = -108;
          unint64_t v10 = Length;
          uint64_t v6 = 9LL;
        }

        else
        {
          char v9 = -109;
          LOWORD(v10) = Length;
          BYTE2(v10) = BYTE2(Length);
          uint64_t v6 = 5LL;
          BYTE3(v10) = BYTE3(Length);
        }
      }

      else
      {
        char v9 = -110;
        LOWORD(v10) = Length;
        uint64_t v6 = 3LL;
      }
    }

    else
    {
      char v9 = -111;
      LOBYTE(v10) = Length;
      uint64_t v6 = 2LL;
    }
  }

  else
  {
LABEL_6:
    char v9 = Length + 112;
    uint64_t v6 = 1LL;
  }

  uint64_t result = (*(uint64_t (**)(char *, uint64_t, void, void))a1)(&v9, v6, 0LL, *(void *)(a1 + 8));
  if (Length)
  {
    if (!(_DWORD)result)
    {
      uint64_t v7 = *(uint64_t (**)(const UInt8 *, unint64_t, void, void))a1;
      BytePtr = CFDataGetBytePtr(theData);
      return v7(BytePtr, Length, 0LL, *(void *)(a1 + 8));
    }
  }

  return result;
}

uint64_t _OPACKEncodeUUID(uint64_t a1, CFUUIDRef uuid, int a3)
{
  if (!*(void *)(a1 + 16)) {
    goto LABEL_5;
  }
  char v7 = 0;
  uint64_t result = _OPACKEncodeUID(a1, uuid, &v7);
  if ((_DWORD)result) {
    return result;
  }
  if (v7) {
    return 0LL;
  }
LABEL_5:
  char v7 = 5;
  if (a3) {
    -[__CFUUID getUUIDBytes:](uuid, "getUUIDBytes:", &v8);
  }
  else {
    CFUUIDBytes v8 = CFUUIDGetUUIDBytes(uuid);
  }
  return (*(uint64_t (**)(char *, uint64_t, void, void))a1)(&v7, 17LL, 0LL, *(void *)(a1 + 8));
}

uint64_t _OPACKEncodeDate(uint64_t a1, const void *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (!*(void *)(a1 + 16) || (v5 = 0, uint64_t result = _OPACKEncodeUID(a1, a2, &v5), !(_DWORD)result) && !v5)
  {
    char v5 = 6;
    double v6 = MEMORY[0x186E41D84](a2);
    return (*(uint64_t (**)(char *, uint64_t, void, void))a1)(&v5, 9LL, 0LL, *(void *)(a1 + 8));
  }

  return result;
}

uint64_t OPACKEstimateEncodedSize(const __CFString *a1, int a2, _DWORD *a3)
{
  uint64_t v6 = 0LL;
  int v4 = OPACKEncodeObject(a1, a2, (uint64_t)_OPACKEncoderEstimateCallback, (uint64_t)&v6);
  if (a3) {
    *a3 = v4;
  }
  return v6;
}

uint64_t _OPACKEncoderEstimateCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *a4 += a2;
  return 0LL;
}

CFStringRef OPACKDecodeBytes(UInt8 *a1, uint64_t a2, int a3, _DWORD *a4)
{
  return _OPACKDecodeBytes(0LL, a1, a2, a3, a4);
}

uint64_t _PairingSessionGetTypeID()
{
  uint64_t result = _CFRuntimeRegisterClass();
  gPairingSessionCFTypeID TypeID = result;
  return result;
}

uint64_t _PairingSessionFinalize(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 413))
  {
    unint64_t v2 = *(void (**)(void))(a1 + 40);
    if (v2) {
      v2(*(void *)(a1 + 24));
    }
    *(_BYTE *)(a1 + 413) = 0;
  }

  _PairingSessionReset(a1);
  unint64_t v3 = *(const void **)(a1 + 176);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 176) = 0LL;
  }

  int v4 = *(const void **)(a1 + 264);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 264) = 0LL;
  }

  char v5 = *(const void **)(a1 + 272);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 272) = 0LL;
  }

  uint64_t v6 = *(const void **)(a1 + 280);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 280) = 0LL;
  }

  uint64_t v7 = *(void **)(a1 + 216);
  if (v7)
  {
    free(v7);
    *(void *)(a1 + 216) = 0LL;
  }

  *(void *)(a1 + 224) = 0LL;
  CFUUIDBytes v8 = *(void **)(a1 + 232);
  if (v8)
  {
    free(v8);
    *(void *)(a1 + 232) = 0LL;
  }

  *(void *)(a1 + 240) = 0LL;
  char v9 = *(void **)(a1 + 248);
  if (v9)
  {
    free(v9);
    *(void *)(a1 + 248) = 0LL;
  }

  *(void *)(a1 + 256) = 0LL;
  unint64_t v10 = *(void **)(a1 + 296);
  if (v10)
  {
    free(v10);
    *(void *)(a1 + 296) = 0LL;
  }

  *(void *)(a1 + 304) = 0LL;
  uint64_t v11 = *(const void **)(a1 + 312);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 312) = 0LL;
  }

  int v12 = *(const void **)(a1 + 320);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 320) = 0LL;
  }

  uint64_t v13 = *(const void **)(a1 + 328);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(a1 + 328) = 0LL;
  }

  uint64_t v14 = *(const void **)(a1 + 336);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 336) = 0LL;
  }

  CFDataRef v15 = *(void **)(a1 + 384);
  if (v15)
  {
    free(v15);
    *(void *)(a1 + 384) = 0LL;
  }

  *(void *)(a1 + 392) = 0LL;
  char v16 = *(void **)(a1 + 352);
  if (v16)
  {
    free(v16);
    *(void *)(a1 + 352) = 0LL;
  }

  *(void *)(a1 + 360) = 0LL;
  int v17 = *(const void **)(a1 + 672);
  if (v17)
  {
    CFRelease(v17);
    *(void *)(a1 + 672) = 0LL;
  }

  CFIndex v18 = *(const void **)(a1 + 344);
  if (v18)
  {
    CFRelease(v18);
    *(void *)(a1 + 344) = 0LL;
  }

  char v19 = *(const void **)(a1 + 752);
  if (v19)
  {
    CFRelease(v19);
    *(void *)(a1 + 752) = 0LL;
  }

  CFIndex v20 = *(const void **)(a1 + 760);
  if (v20)
  {
    CFRelease(v20);
    *(void *)(a1 + 760) = 0LL;
  }

  uint64_t v21 = *(const void **)(a1 + 776);
  if (v21)
  {
    CFRelease(v21);
    *(void *)(a1 + 776) = 0LL;
  }

  uint64_t v22 = *(const void **)(a1 + 784);
  if (v22)
  {
    CFRelease(v22);
    *(void *)(a1 + 784) = 0LL;
  }

  unsigned int v23 = *(const void **)(a1 + 800);
  if (v23)
  {
    CFRelease(v23);
    *(void *)(a1 + 800) = 0LL;
  }

  unint64_t v24 = *(const void **)(a1 + 816);
  if (v24)
  {
    CFRelease(v24);
    *(void *)(a1 + 816) = 0LL;
  }

  int v25 = *(const void **)(a1 + 824);
  if (v25)
  {
    CFRelease(v25);
    *(void *)(a1 + 824) = 0LL;
  }

  unint64_t v26 = *(const void **)(a1 + 832);
  if (v26)
  {
    CFRelease(v26);
    *(void *)(a1 + 832) = 0LL;
  }

  unint64_t v27 = *(const void **)(a1 + 840);
  if (v27)
  {
    CFRelease(v27);
    *(void *)(a1 + 840) = 0LL;
  }

  unint64_t v28 = *(const void **)(a1 + 848);
  if (v28)
  {
    CFRelease(v28);
    *(void *)(a1 + 848) = 0LL;
  }

  unint64_t v29 = *(const void **)(a1 + 856);
  if (v29)
  {
    CFRelease(v29);
    *(void *)(a1 + 856) = 0LL;
  }

  unint64_t v30 = *(const void **)(a1 + 944);
  if (v30)
  {
    CFRelease(v30);
    *(void *)(a1 + 944) = 0LL;
  }

  CFNumberRef v31 = *(const void **)(a1 + 952);
  if (v31)
  {
    CFRelease(v31);
    *(void *)(a1 + 952) = 0LL;
  }

  unint64_t v32 = *(const void **)(a1 + 960);
  if (v32)
  {
    CFRelease(v32);
    *(void *)(a1 + 960) = 0LL;
  }

  unint64_t v33 = *(const void **)(a1 + 968);
  if (v33)
  {
    CFRelease(v33);
    *(void *)(a1 + 968) = 0LL;
  }

  unint64_t v34 = *(const void **)(a1 + 976);
  if (v34)
  {
    CFRelease(v34);
    *(void *)(a1 + 976) = 0LL;
  }

  return memset_s((void *)(a1 + 16), 0x3C8uLL, 0, 0x3C8uLL);
}

void _PairingSessionReset(uint64_t a1)
{
  *(_BYTE *)(a1 + 120) = 0;
  unint64_t v2 = *(void **)(a1 + 128);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 128) = 0LL;
  }

  *(void *)(a1 + 136) = 0LL;
  unint64_t v3 = *(void **)(a1 + 144);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 144) = 0LL;
  }

  *(void *)(a1 + 152) = 0LL;
  *(void *)(a1 + 160) = 0LL;
  *(_BYTE *)(a1 + 168) = 0;
  int v4 = *(void **)(a1 + 184);
  if (v4)
  {
    free(v4);
    *(void *)(a1 + 184) = 0LL;
  }

  *(void *)(a1 + 192) = 0LL;
  memset_s((void *)(a1 + 414), 0x20uLL, 0, 0x20uLL);
  char v5 = *(void **)(a1 + 696);
  if (v5)
  {
    SRPDelete_libsrp(v5);
    *(void *)(a1 + 696) = 0LL;
  }

  uint64_t v6 = *(void **)(a1 + 704);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 704) = 0LL;
  }

  *(void *)(a1 + 712) = 0LL;
  uint64_t v7 = *(void **)(a1 + 720);
  if (v7)
  {
    free(v7);
    *(void *)(a1 + 720) = 0LL;
  }

  *(void *)(a1 + 728) = 0LL;
  CFUUIDBytes v8 = *(void **)(a1 + 736);
  if (v8)
  {
    memset_s(v8, *(void *)(a1 + 744), 0, *(void *)(a1 + 744));
    char v9 = *(void **)(a1 + 736);
    if (v9)
    {
      free(v9);
      *(void *)(a1 + 736) = 0LL;
    }
  }

  *(void *)(a1 + 744) = 0LL;
  memset_s((void *)(a1 + 478), 0x20uLL, 0, 0x20uLL);
  memset_s((void *)(a1 + 542), 0x20uLL, 0, 0x20uLL);
  memset_s((void *)(a1 + 638), 0x20uLL, 0, 0x20uLL);
  unint64_t v10 = *(const void **)(a1 + 672);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 672) = 0LL;
  }

  uint64_t v11 = *(const void **)(a1 + 848);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 848) = 0LL;
  }

uint64_t PairingSessionCreate(uint64_t *a1, uint64_t a2, int a3)
{
  if (gPairingSessionInitOnce != -1) {
    dispatch_once_f(&gPairingSessionInitOnce, 0LL, (dispatch_function_t)_PairingSessionGetTypeID);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294960568LL;
  }
  uint64_t v7 = Instance;
  bzero((void *)(Instance + 24), 0x3C0uLL);
  *(void *)(v7 + 16) = &gLogCategory_Pairing;
  *(_DWORD *)(v7 + 96) = a3;
  *(_OWORD *)(v7 + 104) = xmmword_186B49CB0;
  if (SecondsToUpTicks_sOnce != -1) {
    dispatch_once_f(&SecondsToUpTicks_sOnce, &SecondsToUpTicks_sMultiplier, (dispatch_function_t)_SecondsToUpTicksInit);
  }
  *(void *)(v7 + 368) = 172800 * SecondsToUpTicks_sMultiplier;
  CFUUIDBytes v8 = (_OWORD *)(v7 + 24);
  if (a2)
  {
    _OWORD *v8 = *(_OWORD *)a2;
    __int128 v9 = *(_OWORD *)(a2 + 16);
    __int128 v10 = *(_OWORD *)(a2 + 32);
    __int128 v11 = *(_OWORD *)(a2 + 48);
    *(void *)(v7 + 88) = *(void *)(a2 + 64);
    *(_OWORD *)(v7 + 56) = v10;
    *(_OWORD *)(v7 + 72) = v11;
    *(_OWORD *)(v7 + 40) = v9;
  }

  else
  {
    *(void *)(v7 + 88) = 0LL;
    *(_OWORD *)(v7 + 56) = 0u;
    *(_OWORD *)(v7 + 72) = 0u;
    _OWORD *v8 = 0u;
    *(_OWORD *)(v7 + 40) = 0u;
  }

  PairingSessionSetKeychainInfo( v7,  @"com.apple.pairing",  1886538084,  @"Pairing Identity",  @"Pairing Identity",  1886539877,  @"Paired Peer",  @"Paired Peer",  0);
  uint64_t result = 0LL;
  *a1 = v7;
  return result;
}

void PairingSessionSetKeychainInfo( uint64_t a1, CFTypeRef cf1, int a3, CFTypeRef cf, CFTypeRef a5, int a6, CFTypeRef a7, CFTypeRef a8, int a9)
{
  if (cf1)
  {
    int v17 = CFEqual(cf1, &stru_189F34A78);
    CFIndex v18 = *(const void **)(a1 + 752);
    if (v17)
    {
      if (v18)
      {
        CFRelease(*(CFTypeRef *)(a1 + 752));
        *(void *)(a1 + 752) = 0LL;
      }
    }

    else
    {
      CFRetain(cf1);
      *(void *)(a1 + 752) = cf1;
      if (v18) {
        CFRelease(v18);
      }
    }
  }

  if (a3) {
    *(_DWORD *)(a1 + 768) = a3;
  }
  if (cf)
  {
    char v19 = *(const void **)(a1 + 760);
    CFRetain(cf);
    *(void *)(a1 + 760) = cf;
    if (v19) {
      CFRelease(v19);
    }
  }

  if (a5)
  {
    CFIndex v20 = *(const void **)(a1 + 776);
    CFRetain(a5);
    *(void *)(a1 + 776) = a5;
    if (v20) {
      CFRelease(v20);
    }
  }

  if (a6) {
    *(_DWORD *)(a1 + 792) = a6;
  }
  if (a7)
  {
    uint64_t v21 = *(const void **)(a1 + 784);
    CFRetain(a7);
    *(void *)(a1 + 784) = a7;
    if (v21) {
      CFRelease(v21);
    }
  }

  if (a8)
  {
    uint64_t v22 = *(const void **)(a1 + 800);
    CFRetain(a8);
    *(void *)(a1 + 800) = a8;
    if (v22) {
      CFRelease(v22);
    }
  }

  *(_DWORD *)(a1 + 808) = a9;
}

void PairingSessionInvalidate(void *a1)
{
  unsigned int v1 = (void *)a1[107];
  if (v1)
  {
    queue = v1;
    CFRetain(a1);
    dispatch_async_f(queue, a1, (dispatch_function_t)_PairingSessionInvalidate);
  }

void _PairingSessionInvalidate(void *cf)
{
  unint64_t v2 = (const void *)cf[118];
  if (v2)
  {
    CFRelease(v2);
    cf[118] = 0LL;
  }

  unint64_t v3 = (const void *)cf[119];
  if (v3)
  {
    CFRelease(v3);
    cf[119] = 0LL;
  }

  int v4 = (const void *)cf[120];
  if (v4)
  {
    CFRelease(v4);
    cf[120] = 0LL;
  }

  char v5 = (const void *)cf[121];
  if (v5)
  {
    CFRelease(v5);
    cf[121] = 0LL;
  }

  uint64_t v6 = (const void *)cf[122];
  if (v6)
  {
    CFRelease(v6);
    cf[122] = 0LL;
  }

  uint64_t v7 = (void (*)(uint64_t, void, void))cf[108];
  if (v7)
  {
    v7(1LL, 0LL, cf[109]);
    cf[108] = 0LL;
  }

  CFRelease(cf);
}

uint64_t PairingSessionCopyPeerACL(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 272);
  if (v1) {
    CFRetain(*(CFTypeRef *)(a1 + 272));
  }
  return v1;
}

uint64_t PairingSessionSetACL(uint64_t a1, CFTypeRef cf)
{
  int v4 = *(const void **)(a1 + 176);
  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 176) = cf;
  if (v4) {
    CFRelease(v4);
  }
  return 0LL;
}

uint64_t PairingSessionGetPeerAppFlags(uint64_t a1)
{
  return *(void *)(a1 + 200);
}

uint64_t PairingSessionSetSelfAppFlags(uint64_t result, uint64_t a2)
{
  *(void *)(result + 208) = a2;
  return result;
}

void *PairingSessionCopyExtraData(uint64_t a1, size_t *a2, int *a3)
{
  char v5 = *(const void **)(a1 + 232);
  if (v5)
  {
    size_t v6 = *(void *)(a1 + 240);
    if (v6 <= 1) {
      size_t v7 = 1LL;
    }
    else {
      size_t v7 = *(void *)(a1 + 240);
    }
    CFUUIDBytes v8 = malloc(v7);
    __int128 v9 = v8;
    if (v8)
    {
      memcpy(v8, v5, v6);
      int v10 = 0;
    }

    else
    {
      size_t v6 = 0LL;
      int v10 = -6728;
    }
  }

  else
  {
    __int128 v9 = 0LL;
    size_t v6 = 0LL;
    int v10 = -6727;
  }

  if (a2) {
    *a2 = v6;
  }
  if (a3) {
    *a3 = v10;
  }
  return v9;
}

uint64_t PairingSessionSetExtraData(uint64_t a1, const void *a2, size_t a3)
{
  if (a2)
  {
    if (a3 <= 1) {
      size_t v6 = 1LL;
    }
    else {
      size_t v6 = a3;
    }
    size_t v7 = malloc(v6);
    if (!v7) {
      return 4294960568LL;
    }
    CFUUIDBytes v8 = v7;
    if (a3) {
      memcpy(v7, a2, a3);
    }
  }

  else
  {
    CFUUIDBytes v8 = 0LL;
  }

  __int128 v9 = *(void **)(a1 + 216);
  if (v9) {
    free(v9);
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 216) = v8;
  *(void *)(a1 + 224) = a3;
  return result;
}

uint64_t PairingSessionGetPeerFlags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 288);
}

uint64_t PairingSessionSetFlags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 100) = a2;
  return result;
}

uint64_t PairingSessionSetIdentifier(uint64_t a1, char *__s, size_t a3)
{
  return ReplaceString((void **)(a1 + 248), (size_t *)(a1 + 256), __s, a3);
}

CFMutableDictionaryRef PairingSessionCopyPeerInfo(void *a1, int *a2)
{
  int v4 = (const __CFDictionary *)a1[39];
  if (!v4)
  {
    size_t v7 = (const __CFDictionary *)a1[40];
    if (!v7)
    {
      CFMutableDictionaryRef MutableCopy = 0LL;
      goto LABEL_9;
    }

    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v7);
    if (MutableCopy) {
      goto LABEL_9;
    }
LABEL_18:
    int v12 = -6728;
    goto LABEL_15;
  }

  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v4);
  if (!MutableCopy) {
    goto LABEL_18;
  }
  size_t v6 = (const __CFDictionary *)a1[40];
  if (v6) {
    CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)_CFDictionaryMergeDictionaryApplier, MutableCopy);
  }
LABEL_9:
  CFUUIDBytes v8 = (const __CFDictionary *)a1[43];
  CFTypeID TypeID = CFDictionaryGetTypeID();
  TypedValue = CFDictionaryGetTypedValue(v8, @"groupInfoPeer", TypeID, 0LL);
  if (TypedValue)
  {
    __int128 v11 = TypedValue;
    if (MutableCopy || (CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, TypedValue)) != 0LL)
    {
      CFDictionarySetValue(MutableCopy, @"groupInfo", v11);
LABEL_14:
      CFDictionaryRemoveValue(MutableCopy, @"altIRK");
      int v12 = 0;
      goto LABEL_15;
    }

    goto LABEL_18;
  }

  if (MutableCopy) {
    goto LABEL_14;
  }
  int v12 = -6727;
LABEL_15:
  if (a2) {
    *a2 = v12;
  }
  return MutableCopy;
}

uint64_t PairingSessionSetAdditionalPeerInfo(uint64_t a1, CFTypeRef cf)
{
  int v4 = *(const void **)(a1 + 320);
  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 320) = cf;
  if (v4) {
    CFRelease(v4);
  }
  return 0LL;
}

uint64_t PairingSessionSetAdditionalSelfInfo(uint64_t a1, CFTypeRef cf)
{
  int v4 = *(const void **)(a1 + 336);
  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 336) = cf;
  if (v4) {
    CFRelease(v4);
  }
  return 0LL;
}

uint64_t PairingSessionSetLogging(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  return result;
}

void PairingSessionSetMaxTries(uint64_t a1, int a2)
{
  gPairingMaxTries = a2;
}

uint64_t PairingSessionSetMTU(uint64_t a1, unint64_t a2)
{
  if (a2 < 2) {
    return 4294960553LL;
  }
  unint64_t v3 = a2 - 2 * (a2 / 0x101);
  uint64_t v4 = a2 % 0x101 ? -1LL : 0LL;
  uint64_t v5 = -2LL;
  if (a2 % 0x101 <= 1) {
    uint64_t v5 = v4;
  }
  unint64_t v6 = v3 + v5;
  if (!(v3 + v5)) {
    return 4294960553LL;
  }
  uint64_t v2 = 0LL;
  *(void *)(a1 + 104) = v6;
  *(void *)(a1 + 112) = a2;
  return v2;
}

id PairingSessionCopyPairedPeer(uint64_t a1, int *a2)
{
  unint64_t v3 = *(void **)(a1 + 264);
  if (!v3)
  {
    int v5 = -6727;
    if (!a2) {
      return v3;
    }
    goto LABEL_3;
  }

  id v4 = v3;
  int v5 = 0;
  if (a2) {
LABEL_3:
  }
    *a2 = v5;
  return v3;
}

id PairingSessionGetPairedPeer(uint64_t a1, int *a2)
{
  unint64_t v3 = *(void **)(a1 + 264);
  if (!v3)
  {
    int v5 = -6727;
    if (!a2) {
      return v3;
    }
    goto LABEL_3;
  }

  id v4 = v3;
  int v5 = 0;
  if (a2) {
LABEL_3:
  }
    *a2 = v5;
  return v3;
}

char *PairingSessionCopyPeerIdentifier(uint64_t a1, size_t *a2, int *a3)
{
  uint64_t result = *(char **)(a1 + 296);
  if (result)
  {
    size_t v7 = *(void *)(a1 + 304);
    uint64_t result = strndup(result, v7);
    BOOL v8 = result == 0LL;
    if (result)
    {
      size_t v9 = v7;
    }

    else
    {
      uint64_t result = 0LL;
      size_t v9 = 0LL;
    }

    if (v8) {
      int v10 = -6728;
    }
    else {
      int v10 = 0;
    }
    if (a2) {
      goto LABEL_9;
    }
  }

  else
  {
    size_t v9 = 0LL;
    int v10 = -6727;
    if (a2) {
LABEL_9:
    }
      *a2 = v9;
  }

  if (a3) {
    *a3 = v10;
  }
  return result;
}

const void *PairingSessionCopyProperty(uint64_t a1, const void *a2, int *a3)
{
  id v4 = *(const __CFDictionary **)(a1 + 344);
  if (!v4)
  {
    unint64_t v6 = 0LL;
LABEL_7:
    int v7 = -6727;
    if (!a3) {
      return v6;
    }
    goto LABEL_4;
  }

  Value = CFDictionaryGetValue(v4, a2);
  unint64_t v6 = Value;
  if (!Value) {
    goto LABEL_7;
  }
  CFRetain(Value);
  int v7 = 0;
  if (a3) {
LABEL_4:
  }
    *a3 = v7;
  return v6;
}

uint64_t PairingSessionSetProperty(uint64_t a1, void *key, void *value)
{
  CFMutableDataRef Mutable = *(__CFDictionary **)(a1 + 344);
  if (!Mutable)
  {
    CFMutableDataRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    *(void *)(a1 + 344) = Mutable;
    if (!Mutable) {
      return 4294960568LL;
    }
  }

  if (value) {
    CFDictionarySetValue(Mutable, key, value);
  }
  else {
    CFDictionaryRemoveValue(Mutable, key);
  }
  return 0LL;
}

uint64_t PairingSessionGetResumeInfo(uint64_t a1, void *a2)
{
  int v3 = *(_DWORD *)(a1 + 96);
  if ((v3 - 3) > 1)
  {
LABEL_6:
    uint64_t result = 0LL;
    *a2 = *(void *)(a1 + 376);
    return result;
  }

  if (*(_BYTE *)(a1 + 120) == 5) {
    goto LABEL_6;
  }
  return 4294960587LL;
}

uint64_t PairingSessionSetResumeInfo(void *a1, uint64_t a2, const void *a3, size_t a4)
{
  if (a4 <= 1) {
    size_t v8 = 1LL;
  }
  else {
    size_t v8 = a4;
  }
  size_t v9 = malloc(v8);
  if (!v9) {
    return 4294960568LL;
  }
  int v10 = v9;
  if (a4) {
    memcpy(v9, a3, a4);
  }
  __int128 v11 = (void *)a1[44];
  if (v11) {
    free(v11);
  }
  uint64_t result = 0LL;
  a1[44] = v10;
  a1[45] = a4;
  a1[47] = a2;
  return result;
}

uint64_t PairingSessionSetMaxResumeSessions(uint64_t a1, int a2)
{
  gPairingMaxResumeSessions = a2;
  return 0LL;
}

uint64_t PairingSessionSetResumeTTL(uint64_t a1, unsigned int a2)
{
  if (SecondsToUpTicks_sOnce != -1) {
    dispatch_once_f(&SecondsToUpTicks_sOnce, &SecondsToUpTicks_sMultiplier, (dispatch_function_t)_SecondsToUpTicksInit);
  }
  *(void *)(a1 + 368) = SecondsToUpTicks_sMultiplier * a2;
  return 0LL;
}

uint64_t PairingSessionSetSetupCode(uint64_t a1, char *__s, size_t a3)
{
  return ReplaceString((void **)(a1 + 384), (size_t *)(a1 + 392), __s, a3);
}

uint64_t PairingSessionGenerateTranscriptResultMFi4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v20[52] = *MEMORY[0x1895F89C0];
  size_t v9 = *(const __CFData **)(a1 + 672);
  if (v9)
  {
    BytePtr = CFDataGetBytePtr(v9);
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 672));
    if (Length)
    {
      CFIndex v13 = Length;
      uint64_t v14 = PairingSessionDeriveKey(a1, "MFi4-KT1-Salt", 0xDuLL, (uint64_t)"MFi4-KT1-Info", 13LL, 0x20uLL, (uint64_t)v19);
      if ((_DWORD)v14)
      {
        uint64_t v15 = v14;
      }

      else
      {
        CryptoHMACInit(v20, (uint64_t)_kCryptoHashDescriptor_SHA256, v19, 0x20uLL);
        (*(void (**)(uint64_t *, const UInt8 *, CFIndex))(v20[0] + 8))(v20, BytePtr, v13);
        CryptoHMACFinal(v20, a2);
        uint64_t v15 = PairingSessionDeriveKey( a1,  "MFi4-KT2-Salt",  0xDuLL,  (uint64_t)"MFi4-KT2-Info",  13LL,  0x20uLL,  (uint64_t)v18);
        if (!(_DWORD)v15)
        {
          CryptoHMACInit(v20, (uint64_t)_kCryptoHashDescriptor_SHA256, v18, 0x20uLL);
          (*(void (**)(uint64_t *, const UInt8 *, CFIndex))(v20[0] + 8))(v20, BytePtr, v13);
          CryptoHMACFinal(v20, a2 + 32);
          return v15;
        }
      }
    }

    else
    {
      uint64_t v15 = 4294960553LL;
    }
  }

  else
  {
    uint64_t v15 = 4294960551LL;
  }

  int v17 = *(int **)(a1 + 16);
  if (*v17 <= 90)
  {
    if (*v17 == -1)
    {
      int v17 = *(int **)(a1 + 16);
    }

    LogPrintF( (uint64_t)v17,  (uint64_t)"OSStatus PairingSessionGenerateTranscriptResultMFi4(PairingSessionRef, CUPairingTranscriptResultMFi4 *)",  0x5Au,  (uint64_t)"### Generate MFi4 transcript result failed: %#m",  a5,  a6,  a7,  a8,  v15);
  }

  return v15;
}

uint64_t PairingSessionDeriveKey( uint64_t a1, char *a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  unsigned int v8 = *(_DWORD *)(a1 + 96);
  uint64_t result = 4294960561LL;
  if (v8 <= 6)
  {
    if (((1 << v8) & 6) != 0)
    {
      if (*(_BYTE *)(a1 + 120) != 7) {
        return 4294960587LL;
      }
      uint64_t v15 = *(void *)(a1 + 736);
      if (!v15) {
        return 4294960587LL;
      }
      uint64_t v16 = *(void *)(a1 + 744);
      if (!v16) {
        return 4294960587LL;
      }
      CryptoHKDF((uint64_t)_kCryptoHashDescriptor_SHA512, v15, v16, a2, a3, a4, a5, a6, a7);
    }

    else
    {
      if (((1 << v8) & 0x18) != 0)
      {
        if (*(_BYTE *)(a1 + 120) != 5) {
          return 4294960587LL;
        }
      }

      else
      {
        if (((1 << v8) & 0x60) == 0) {
          return result;
        }
        if (*(_BYTE *)(a1 + 120) != 3) {
          return 4294960587LL;
        }
      }

      CryptoHKDF((uint64_t)_kCryptoHashDescriptor_SHA512, a1 + 638, 32LL, a2, a3, a4, a5, a6, a7);
    }

    return 0LL;
  }

  return result;
}

uint64_t PairingSessionSetTranscriptType(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 680) = a2;
  return 0LL;
}

uint64_t PairingSessionSetEventHandler(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 864) = a2;
  *(void *)(result + 872) = a3;
  return result;
}

uint64_t PairingSessionSetAddPairingHandler(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 880) = a2;
  *(void *)(result + 888) = a3;
  return result;
}

uint64_t PairingSessionSetRemovePairingHandler(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 896) = a2;
  *(void *)(result + 904) = a3;
  return result;
}

uint64_t PairingSessionSetListPairingsHandler(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 912) = a2;
  *(void *)(result + 920) = a3;
  return result;
}

uint64_t PairingSessionSetSignBytesHandler(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 928) = a2;
  *(void *)(result + 936) = a3;
  return result;
}

void PairingSessionSetSignBytesHandler_b(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    id v8 = v3;
    uint64_t v5 = [v3 copy];
    unint64_t v6 = *(const void **)(a1 + 944);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(a1 + 944) = v5;
    id v4 = v8;
  }

  else
  {
    int v7 = *(const void **)(a1 + 944);
    if (v7)
    {
      CFRelease(v7);
      id v4 = 0LL;
      *(void *)(a1 + 944) = 0LL;
    }
  }
}

void PairingSessionSetVerifySignatureHandler_b(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    id v8 = v3;
    uint64_t v5 = [v3 copy];
    unint64_t v6 = *(const void **)(a1 + 952);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(a1 + 952) = v5;
    id v4 = v8;
  }

  else
  {
    int v7 = *(const void **)(a1 + 952);
    if (v7)
    {
      CFRelease(v7);
      id v4 = 0LL;
      *(void *)(a1 + 952) = 0LL;
    }
  }
}

uint64_t PairingSessionExchange( uint64_t a1, unsigned __int8 *a2, CFIndex a3, char **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v200 = *MEMORY[0x1895F89C0];
  unint64_t v186 = 0LL;
  v187 = 0LL;
  if (!a1) {
    return 4294960556LL;
  }
  uint64_t v14 = (char *)(a1 + 120);
  if (!*(_BYTE *)(a1 + 120))
  {
    uint64_t v15 = *(int **)(a1 + 16);
    if (*v15 <= 30)
    {
      if (*v15 == -1)
      {
        uint64_t v15 = *(int **)(a1 + 16);
      }

      uint64_t v16 = *(unsigned int *)(a1 + 96);
      else {
        int v17 = off_189F33D10[v16];
      }
      LogPrintF( (uint64_t)v15,  (uint64_t)"OSStatus PairingSessionExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)"PairStart, %s, %#{flags}\n",  a5,  a6,  a7,  a8,  (char)v17);
    }
  }

LABEL_274:
        uint64_t v132 = a2;
        while (v45 > (unint64_t)v132)
        {
          uint64_t v133 = v132 + 2;
          uint64_t v134 = v132[1];
          int v135 = *v132;
          v132 += v134 + 2;
          if (v135 == 7)
          {
            if ((_DWORD)v134 == 1)
            {
              uint64_t v136 = *v133;
              if (v136 >= 9)
              {
                if ((_DWORD)v136 == 9) {
                  uint64_t v18 = 4294960520LL;
                }
                else {
                  uint64_t v18 = 4294960596LL;
                }
              }

              else
              {
                uint64_t v18 = dword_186B4BE50[v136];
              }

              v137 = *(int **)(a1 + 16);
              if (*v137 <= 50)
              {
                if (*v137 != -1) {
                  goto LABEL_287;
                }
                if (_LogCategory_Initialize((uint64_t)v137, 0x32u))
                {
                  v137 = *(int **)(a1 + 16);
                  LOBYTE(v136) = *v133;
LABEL_287:
                  LogPrintF( (uint64_t)v137,  (uint64_t)"OSStatus _AdminPairingClientM2(PairingSessionRef, const uint8_t *const, const uint8_t *cons t, const uint8_t *const)",  0x32u,  (uint64_t)"### AdminPairing client M2 bad status: 0x%X, %#m\n",  v20,  v21,  (uint64_t)v22,  v23,  v136);
                }
              }

              goto LABEL_289;
            }

LABEL_406:
            uint64_t v18 = 4294960553LL;
            goto LABEL_289;
          }
        }

        if (*(_DWORD *)(a1 + 96) == 13)
        {
          theArraya = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
          if (!theArraya)
          {
            uint64_t v18 = 4294960568LL;
            goto LABEL_289;
          }

          while (2)
          {
            CFMutableDictionaryRef Mutable = 0LL;
LABEL_301:
            if (v45 > (unint64_t)v49 && v45 - (unint64_t)v49 >= 2)
            {
              SecTrustRef v142 = v49;
              v143 = (char *)(v49 + 2);
              CFIndex v144 = v49[1];
              v49 += v144 + 2;
              if ((unint64_t)v49 <= v45)
              {
                unsigned __int8 v145 = *v142;
                if (Mutable
                  || (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250])) != 0LL)
                {
                  switch(((v145 + 1) >> 1) | ((v145 + 1) << 7))
                  {
                    case 0:
                      if (CFDictionaryGetCount(Mutable) >= 1) {
                        CFArrayAppendValue(theArraya, Mutable);
                      }
                      CFRelease(Mutable);
                      continue;
                    case 1:
                      uint64_t v146 = CFDictionarySetCString(Mutable, @"identifier", v143, v144);
                      if (!(_DWORD)v146) {
                        goto LABEL_301;
                      }
                      break;
                    case 2:
                      uint64_t v146 = CFDictionarySetData(Mutable, @"pk", (UInt8 *)v143, v144);
                      if (!(_DWORD)v146) {
                        goto LABEL_301;
                      }
                      break;
                    case 6:
                      uint64_t v18 = 4294960553LL;
                      int v147 = v144 - 1;
                      char v41 = v185;
                      switch(v147)
                      {
                        case 0:
                          uint64_t v148 = *v143;
                          break;
                        case 1:
                          uint64_t v148 = *((unsigned __int16 *)v142 + 1);
                          break;
                        case 2:
                        case 4:
                        case 5:
                        case 6:
                          goto LABEL_404;
                        case 3:
                          uint64_t v148 = *(unsigned int *)v143;
                          break;
                        case 7:
                          uint64_t v148 = *(void *)v143;
                          break;
                        default:
                          goto LABEL_403;
                      }

                      uint64_t v146 = CFDictionarySetInt64(Mutable, @"permissions", v148);
                      if (!(_DWORD)v146) {
                        goto LABEL_301;
                      }
                      break;
                    default:
                      goto LABEL_301;
                  }

                  uint64_t v18 = v146;
LABEL_403:
                  char v41 = v185;
LABEL_404:
                  CFRelease(Mutable);
                  CFRelease(theArraya);
                }

                else
                {
                  CFRelease(theArraya);
                  uint64_t v18 = 4294960568LL;
                  char v41 = v185;
                }

                goto LABEL_289;
              }
            }

            break;
          }

          char v41 = v185;
          if (Mutable)
          {
            if (CFDictionaryGetCount(Mutable) >= 1) {
              CFArrayAppendValue(theArraya, Mutable);
            }
            CFRelease(Mutable);
          }

          uint64_t v18 = PairingSessionSetProperty(a1, @"pairings", theArraya);
          CFRelease(theArraya);
          if ((_DWORD)v18)
          {
LABEL_289:
            char *v41 = 0;
            goto LABEL_290;
          }
        }

        *(_BYTE *)(a1 + 120) = 3;
        v161 = *(int **)(a1 + 16);
        if (*v161 <= 30)
        {
          if (*v161 == -1)
          {
            v161 = *(int **)(a1 + 16);
          }

          LogPrintF( (uint64_t)v161,  (uint64_t)"OSStatus _AdminPairingClientM2(PairingSessionRef, const uint8_t *const, const uint8_t *const, const uint8_t *const)",  0x1Eu,  (uint64_t)"AdminPairing client done\n",  v20,  v21,  (uint64_t)v22,  v23,  v175);
        }

LABEL_396:
        unint64_t v186 = 0LL;
        v187 = 0LL;
        char *v41 = 1;
        goto LABEL_127;
      }

      if (v44 != 1)
      {
        uint64_t v75 = *(int **)(a1 + 16);
        if (*v75 <= 60)
        {
          if (*v75 == -1)
          {
            uint64_t v75 = *(int **)(a1 + 16);
            LOBYTE(v44) = *(_BYTE *)(a1 + 120);
          }

          LogPrintF( (uint64_t)v75,  (uint64_t)"OSStatus _AdminPairingClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x3Cu,  (uint64_t)"### AdminPairing client bad state: %d\n",  v20,  v21,  (uint64_t)v22,  v23,  v44);
        }

LABEL_207:
        uint64_t v18 = 4294960587LL;
        goto LABEL_289;
      }

      __srCC_SHA1_CTX c = 0LL;
      v195 = v198;
      __int128 v196 = xmmword_186B49CC0;
      v197 = 0LL;
      if (v182) {
        goto LABEL_373;
      }
      LODWORD(bytes) = TLV8BufferAppend((uint64_t)&v195, 6, __s, 1uLL);
      if ((_DWORD)bytes) {
        goto LABEL_103;
      }
      int v80 = *(_DWORD *)(a1 + 96);
      if (v80 != 13)
      {
        if (v80 == 11)
        {
          v199[0] = 4;
          LODWORD(bytes) = TLV8BufferAppend((uint64_t)&v195, 0, v199, 1uLL);
          if ((_DWORD)bytes) {
            goto LABEL_103;
          }
          double v105 = (char *)CFDictionaryGetOrCopyBytes( *(const __CFDictionary **)(a1 + 344),  @"controllerIdentifier",  (CFIndex *)v199,  (UInt8 **)&__src,  (int *)&bytes);
          if (!v105) {
            goto LABEL_103;
          }
          LODWORD(bytes) = TLV8BufferAppend((uint64_t)&v195, 1, v105, *(size_t *)v199);
          if ((_DWORD)bytes) {
            goto LABEL_103;
          }
          if (__src)
          {
            free(__src);
            __srCC_SHA1_CTX c = 0LL;
          }

          goto LABEL_223;
        }

        if (v80 == 9)
        {
          v199[0] = 3;
          LODWORD(bytes) = TLV8BufferAppend((uint64_t)&v195, 0, v199, 1uLL);
          if ((_DWORD)bytes) {
            goto LABEL_103;
          }
          double v81 = (char *)CFDictionaryGetOrCopyBytes( *(const __CFDictionary **)(a1 + 344),  @"controllerIdentifier",  (CFIndex *)v199,  (UInt8 **)&__src,  (int *)&bytes);
          if (!v81) {
            goto LABEL_103;
          }
          LODWORD(bytes) = TLV8BufferAppend((uint64_t)&v195, 1, v81, *(size_t *)v199);
          if ((_DWORD)bytes) {
            goto LABEL_103;
          }
          if (__src)
          {
            free(__src);
            __srCC_SHA1_CTX c = 0LL;
          }

          int v82 = *(const __CFDictionary **)(a1 + 344);
          CFTypeID TypeID = CFDataGetTypeID();
          TypedValue = CFDictionaryGetTypedValue(v82, @"controllerPK", TypeID, (int *)&bytes);
          if (!TypedValue) {
            goto LABEL_103;
          }
          uint64_t v85 = TypedValue;
          BytePtr = CFDataGetBytePtr(TypedValue);
          size_t Length = CFDataGetLength(v85);
          uint64_t v88 = (char *)BytePtr;
          char v41 = (char *)a6;
          LODWORD(bytes) = TLV8BufferAppend((uint64_t)&v195, 3, v88, Length);
          if ((_DWORD)bytes) {
            goto LABEL_103;
          }
          unsigned int Int64Ranged = CFDictionaryGetInt64Ranged( *(const __CFDictionary **)(a1 + 344),  @"permissions",  0LL,  0xFFFFFFFFLL,  (int *)&bytes);
          if ((_DWORD)bytes) {
            goto LABEL_103;
          }
          int appended = TLV8BufferAppendUInt64((uint64_t)&v195, 11, Int64Ranged);
          goto LABEL_222;
        }

        double v106 = *(int **)(a1 + 16);
        if (*v106 <= 60)
        {
          if (*v106 == -1)
          {
            double v106 = *(int **)(a1 + 16);
            int v80 = *(_DWORD *)(a1 + 96);
          }

          LogPrintF( (uint64_t)v106,  (uint64_t)"OSStatus _AdminPairingClientM1(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8 _t **, size_t *)",  0x3Cu,  (uint64_t)"### AdminPairing client bad session type %d\n",  v20,  v21,  (uint64_t)v22,  v23,  v80);
        }

LABEL_373:
        LODWORD(bytes) = -6705;
        goto LABEL_103;
      }

      v199[0] = 5;
      int appended = TLV8BufferAppend((uint64_t)&v195, 0, v199, 1uLL);
LABEL_222:
      LODWORD(bytes) = appended;
      if (appended) {
        goto LABEL_103;
      }
LABEL_223:
      size_t v98 = v196;
      unint64_t v99 = (char *)v197;
      if (!v197)
      {
        else {
          size_t v100 = v196;
        }
        uint64_t v101 = (char *)malloc(v100);
        if (!v101)
        {
          LODWORD(bytes) = -6728;
          char v41 = (char *)a6;
          goto LABEL_103;
        }

        unint64_t v99 = v101;
        if (v98) {
          memcpy(v101, v195, v98);
        }
      }

      v195 = v198;
      *(void *)&__int128 v196 = 0LL;
      v197 = 0LL;
      unint64_t v186 = v98;
      v187 = v99;
      LODWORD(bytes) = 0;
      *(_BYTE *)(a1 + 120) = 2;
      unint64_t v102 = *(int **)(a1 + 16);
      int v103 = *v102;
      char v41 = (char *)a6;
      if (*v102 > 30) {
        goto LABEL_103;
      }
      if (v103 == -1)
      {
        if (!_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu)) {
          goto LABEL_103;
        }
        unint64_t v102 = *(int **)(a1 + 16);
        int v103 = *v102;
      }

      char v104 = v103 > 10 || v103 == -1 && !_LogCategory_Initialize((uint64_t)v102, 0xAu);
      LogPrintF( (uint64_t)v102,  (uint64_t)"OSStatus _AdminPairingClientM1(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *)",  0x1Eu,  (uint64_t)"AdminPairing client M1 -- request\n%?{end}%1{tlv8}\n",  v20,  v21,  (uint64_t)v22,  v23,  v104);
LABEL_103:
      if (__src) {
        free(__src);
      }
      if (v197) {
        free(v197);
      }
      uint64_t v18 = bytes;
      char *v41 = 0;
      if (!(_DWORD)v18) {
        goto LABEL_127;
      }
LABEL_290:
      char v138 = *(int **)(a1 + 16);
      int v139 = *v138;
      if (*v138 > 50) {
        goto LABEL_126;
      }
      if (v139 == -1)
      {
        if (!_LogCategory_Initialize(*(void *)(a1 + 16), 0x32u)) {
          goto LABEL_126;
        }
        char v138 = *(int **)(a1 + 16);
        int v139 = *v138;
      }

      char v140 = *__s;
      if (v139 == -1) {
        _LogCategory_Initialize((uint64_t)v138, 0x28u);
      }
      LogPrintF( (uint64_t)v138,  (uint64_t)"OSStatus _AdminPairingClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"### AdminPairing client state %d failed: %#m\n%?{end}%1{tlv8}\n",  v20,  v21,  (uint64_t)v22,  v23,  v140);
LABEL_126:
      if ((_DWORD)v18) {
        goto LABEL_53;
      }
LABEL_127:
      unint64_t v63 = v186;
      v195 = v198;
      __int128 v196 = xmmword_186B49CC0;
      v197 = 0LL;
      if (*(void *)(a1 + 112) >= v186)
      {
        uint64_t v18 = 0LL;
        *v183 = v187;
        void *v184 = v63;
        goto LABEL_52;
      }

      if (*(void *)(a1 + 144) || *(void *)(a1 + 152))
      {
        uint64_t v18 = 4294960593LL;
      }

      else
      {
        uint64_t v64 = v187;
        *(void *)(a1 + 144) = v187;
        *(void *)(a1 + 152) = v63;
        size_t v65 = *(void *)(a1 + 104);
        *(void *)(a1 + 160) = v65;
        *(_BYTE *)(a1 + 168) = *v41;
        uint64_t v66 = TLV8BufferAppend((uint64_t)&v195, 12, v64, v65);
        v187 = 0LL;
        uint64_t v67 = (char *)v197;
        if ((_DWORD)v66)
        {
          uint64_t v18 = v66;
          if (v197) {
            free(v197);
          }
          goto LABEL_53;
        }

        size_t v68 = v196;
        if (!v197)
        {
          else {
            size_t v69 = v196;
          }
          BOOL v70 = (char *)malloc(v69);
          if (!v70)
          {
            uint64_t v18 = 4294960568LL;
            goto LABEL_53;
          }

          uint64_t v67 = v70;
          if (v68) {
            memcpy(v70, v195, v68);
          }
        }

        uint64_t v18 = 0LL;
        v195 = v198;
        *(void *)&__int128 v196 = 0LL;
        v197 = 0LL;
        *v183 = v67;
        void *v184 = v68;
        char *v185 = 0;
      }

LABEL_209:
          uint64_t v18 = 4294960587LL;
LABEL_210:
          char *v41 = 0;
          goto LABEL_211;
        }
      }

      else
      {
        char *__s = 1;
        if (*v56 != 1) {
          goto LABEL_209;
        }
      }

      v188 = 0LL;
      v195 = v198;
      __int128 v196 = xmmword_186B49CC0;
      v197 = 0LL;
      char *__s = 2;
      uint64_t v61 = 0LL;
      unsigned int v191 = TLV8BufferAppend((uint64_t)&v195, 6, __s, 1uLL);
      if (v191) {
        goto LABEL_111;
      }
      int v76 = *(_DWORD *)(a1 + 96);
      switch(v76)
      {
        case 14:
          unsigned int v191 = TLV8GetBytes(a2, v53, 0, 1uLL, 1uLL, &__dst, 0LL, 0LL);
          if (v191) {
            goto LABEL_412;
          }
          if (__dst == 5)
          {
            uint64_t v61 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
            if (v61)
            {
              unint64_t v91 = *(uint64_t (**)(unsigned int *, void))(a1 + 912);
              if (v91)
              {
                theArray = (__CFArray *)v91(&v191, *(void *)(a1 + 920));
                unsigned int v92 = v191;
              }

              else
              {
                theArray = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
                if (theArray)
                {
                  double v107 = _PairingSessionCopyPeers(a1, 0LL, 0LL, v199);
                  if (v107)
                  {
                    double v108 = v107;
                    v176 = v61;
                    CFIndex Count = CFArrayGetCount(v107);
                    if (Count < 1)
                    {
LABEL_252:
                      CFRelease(v108);
                    }

                    else
                    {
                      CFIndex v109 = 0LL;
                      while (1)
                      {
                        CFTypeID v110 = CFDictionaryGetTypeID();
                        TypedValueAtIndex = CFArrayGetTypedValueAtIndex(v108, v109, v110, (int *)v199);
                        if (*(_DWORD *)v199) {
                          break;
                        }
                        uint64_t v112 = TypedValueAtIndex;
                        uint64_t v113 = v108;
                        CFMutableDictionaryRef v114 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
                        if (!v114)
                        {
                          *(_DWORD *)v199 = -6728;
                          goto LABEL_415;
                        }

                        CFMutableDictionaryRef v115 = v114;
                        CFTypeID v116 = CFStringGetTypeID();
                        uint64_t v117 = CFDictionaryGetTypedValue(v112, @"identifier", v116, (int *)v199);
                        if (!v117
                          || (CFDictionarySetValue(v115, @"identifier", v117),
                              CFTypeID v118 = CFDataGetTypeID(),
                              (unsigned int v119 = CFDictionaryGetTypedValue(v112, @"pk", v118, (int *)v199)) == 0LL))
                        {
                          CFRelease(v115);
LABEL_415:
                          double v108 = v113;
                          break;
                        }

                        CFDictionarySetValue(v115, @"pk", v119);
                        unsigned int v120 = CFDictionaryGetInt64Ranged(v112, @"permissions", 0LL, 0xFFFFFFFFLL, 0LL);
                        CFDictionarySetInt64(v115, @"permissions", v120);
                        CFArrayAppendValue(theArray, v115);
                        CFRelease(v115);
                        ++v109;
                        double v108 = v113;
                        if (Count == v109) {
                          goto LABEL_252;
                        }
                      }

                      CFRelease(v108);
                      CFRelease(theArray);
                      theArray = 0LL;
                    }

                    BOOL v55 = __s;
                    uint64_t v61 = v176;
                  }
                }

                else
                {
                  theArray = 0LL;
                  *(_DWORD *)v199 = -6728;
                }

                unsigned int v92 = *(_DWORD *)v199;
                unsigned int v191 = *(_DWORD *)v199;
              }

              if (!theArray || v92) {
                goto LABEL_438;
              }
              CFIndex v178 = CFArrayGetCount(theArray);
              if (v178 < 1)
              {
LABEL_435:
                unsigned int v191 = 0;
              }

              else
              {
                CFIndex v162 = 0LL;
                while (1)
                {
                  if (v162)
                  {
                    unsigned int v163 = TLV8BufferAppend((uint64_t)&v195, 255, 0LL, 0LL);
                    LODWORD(numBytes) = v163;
                    if (v163) {
                      goto LABEL_437;
                    }
                  }

                  CFTypeID v164 = CFDictionaryGetTypeID();
                  v165 = CFArrayGetTypedValueAtIndex(theArray, v162, v164, (int *)&numBytes);
                  if (!v165) {
                    break;
                  }
                  v166 = v165;
                  CFTypeID v167 = CFStringGetTypeID();
                  v168 = (const __CFString *)CFDictionaryGetTypedValue( v166,  @"identifier",  v167,  (int *)&numBytes);
                  if (!v168) {
                    break;
                  }
                  unsigned int v163 = CFStringGetOrCopyCStringUTF8(v168, (const char **)v199, (UInt8 **)&__src, (size_t *)&bytes);
                  LODWORD(numBytes) = v163;
                  if (v163) {
                    goto LABEL_436;
                  }
                  unsigned int v163 = TLV8BufferAppend((uint64_t)&v195, 1, *(char **)v199, (size_t)bytes);
                  LODWORD(numBytes) = v163;
                  if (__src)
                  {
                    free(__src);
                    unsigned int v163 = numBytes;
                  }

                  char v41 = v185;
                  if (v163) {
                    goto LABEL_437;
                  }
                  CFTypeID v169 = CFDataGetTypeID();
                  v170 = CFDictionaryGetTypedValue(v166, @"pk", v169, (int *)&numBytes);
                  if (!v170) {
                    break;
                  }
                  v171 = v170;
                  v172 = (char *)CFDataGetBytePtr(v170);
                  size_t v173 = CFDataGetLength(v171);
                  unsigned int v163 = TLV8BufferAppend((uint64_t)&v195, 3, v172, v173);
                  LODWORD(numBytes) = v163;
                  if (v163)
                  {
LABEL_436:
                    char v41 = v185;
LABEL_437:
                    unsigned int v191 = v163;
                    goto LABEL_438;
                  }

                  unsigned int v174 = CFDictionaryGetInt64Ranged(v166, @"permissions", 0LL, 0xFFFFFFFFLL, 0LL);
                  unsigned int v163 = TLV8BufferAppendUInt64((uint64_t)&v195, 11, v174);
                  LODWORD(numBytes) = v163;
                  char v41 = v185;
                  BOOL v55 = __s;
                  if (v163) {
                    goto LABEL_437;
                  }
                  if (v178 == ++v162) {
                    goto LABEL_435;
                  }
                }

                unsigned int v191 = numBytes;
                char v41 = v185;
                if ((_DWORD)numBytes) {
                  goto LABEL_438;
                }
              }

LABEL_355:
              size_t v152 = v196;
              v153 = (char *)v197;
              if (!v197)
              {
                else {
                  size_t v154 = v196;
                }
                v155 = (char *)malloc(v154);
                if (!v155)
                {
                  unsigned int v191 = -6728;
                  goto LABEL_368;
                }

                v153 = v155;
                if (v152) {
                  memcpy(v155, v195, v152);
                }
              }

              v195 = v198;
              *(void *)&__int128 v196 = 0LL;
              v197 = 0LL;
              unint64_t v186 = v152;
              v187 = v153;
              unsigned int v191 = 0;
              v156 = *(int **)(a1 + 16);
              int v157 = *v156;
              if (*v156 < 31)
              {
                char v41 = v185;
                if (v157 == -1)
                {
                  BOOL v159 = _LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu);
                  v156 = *(int **)(a1 + 16);
                  if (!v159) {
                    goto LABEL_376;
                  }
                  int v157 = *v156;
                }

                char v158 = v157 > 10 || v157 == -1 && !_LogCategory_Initialize((uint64_t)v156, 0xAu);
                LogPrintF( (uint64_t)v156,  (uint64_t)"OSStatus _AdminPairingServerM1(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *)",  0x1Eu,  (uint64_t)"AdminPairing server M4 -- response\n%?{end}%1{tlv8}\n",  v20,  v21,  (uint64_t)v22,  v23,  v158);
                v156 = *(int **)(a1 + 16);
LABEL_376:
                int v160 = *v156;
                *BOOL v55 = 3;
                if (v160 > 30) {
                  goto LABEL_438;
                }
                if (v160 == -1)
                {
                  if (!_LogCategory_Initialize((uint64_t)v156, 0x1Eu))
                  {
LABEL_438:
                    if (theArray) {
                      CFRelease(theArray);
                    }
                    goto LABEL_111;
                  }

                  v156 = *(int **)(a1 + 16);
                }

                LogPrintF( (uint64_t)v156,  (uint64_t)"OSStatus _AdminPairingServerM1(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *)",  0x1Eu,  (uint64_t)"AdminPairing server done\n",  v20,  v21,  (uint64_t)v22,  v23,  v175);
                goto LABEL_438;
              }

              *BOOL v55 = 3;
LABEL_368:
              char v41 = v185;
              goto LABEL_438;
            }

            goto LABEL_413;
          }

          break;
        case 12:
          unsigned int v191 = TLV8GetBytes(a2, v53, 0, 1uLL, 1uLL, &__dst, 0LL, 0LL);
          if (!v191)
          {
            if (__dst == 4)
            {
              uint64_t v61 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
              if (v61)
              {
                unsigned int v191 = TLV8GetOrCopyCoalesced(a2, v53, 1, &bytes, (size_t *)&numBytes, (unsigned __int8 **)&v188, 0LL);
                if (v191) {
                  goto LABEL_111;
                }
                unsigned int v191 = CFDictionarySetCString(v61, @"identifier", (const char *)bytes, numBytes);
                if (v191) {
                  goto LABEL_111;
                }
                if (v188)
                {
                  free(v188);
                  v188 = 0LL;
                }

                SecCertificateRef v78 = *(uint64_t (**)(__CFDictionary *, uint64_t))(a1 + 896);
                if (!v78)
                {
                  __srCC_SHA1_CTX c = 0LL;
                  unsigned int v121 = (char *)CFDictionaryGetOrCopyBytes( v61,  @"identifier",  (CFIndex *)v199,  (UInt8 **)&__src,  (int *)&v192);
                  if (v121)
                  {
                    _PairingSessionDeletePeer(a1, v121, *(uint64_t *)v199, v122, v20, v21, (uint64_t)v22, v23);
                    unsigned int v192 = 0;
                  }

                  if (__src) {
                    free(__src);
                  }
                  int v93 = v192;
LABEL_258:
                  unsigned int v191 = v93;
                  if (!v93)
                  {
LABEL_354:
                    theArray = 0LL;
                    goto LABEL_355;
                  }

LABEL_259:
                  v123 = *(int **)(a1 + 16);
                  if (*v123 > 50) {
                    goto LABEL_324;
                  }
                  if (*v123 == -1)
                  {
                    BOOL v149 = _LogCategory_Initialize(*(void *)(a1 + 16), 0x32u);
                    int v93 = v191;
                    if (!v149)
                    {
LABEL_324:
                      if (v93 > -6761)
                      {
                        if (v93 > -6728)
                        {
                          if (v93 == -6727)
                          {
                            unint64_t v150 = 4LL;
                            goto LABEL_353;
                          }

                          if (v93 == -6700)
                          {
                            unint64_t v150 = 1LL;
                            goto LABEL_353;
                          }
                        }

                        else
                        {
                          if (v93 == -6760)
                          {
                            unint64_t v150 = 3LL;
                            goto LABEL_353;
                          }

                          if (v93 == -6754)
                          {
                            unint64_t v150 = 2LL;
                            goto LABEL_353;
                          }
                        }
                      }

                      else if (v93 > -6765)
                      {
                        if (v93 == -6764)
                        {
                          unint64_t v150 = 6LL;
                          goto LABEL_353;
                        }

                        if (v93 == -6763)
                        {
                          unint64_t v150 = 5LL;
                          goto LABEL_353;
                        }
                      }

                      else
                      {
                        if (v93 == -71144)
                        {
                          unint64_t v150 = 8LL;
                          goto LABEL_353;
                        }

                        if (v93 == -6773)
                        {
                          unint64_t v150 = 7LL;
                          goto LABEL_353;
                        }
                      }

                      if (v93 == -6776) {
                        unint64_t v150 = 9LL;
                      }
                      else {
                        unint64_t v150 = 1LL;
                      }
LABEL_353:
                      unsigned int v191 = TLV8BufferAppendUInt64((uint64_t)&v195, 7, v150);
                      if (!v191) {
                        goto LABEL_354;
                      }
LABEL_111:
                      if (v188) {
                        free(v188);
                      }
                      if (v61) {
                        CFRelease(v61);
                      }
                      if (v197) {
                        free(v197);
                      }
                      uint64_t v18 = v191;
                      char *v41 = v191 == 0;
                      if (!(_DWORD)v18) {
                        goto LABEL_127;
                      }
LABEL_211:
                      uint64_t v95 = *(int **)(a1 + 16);
                      int v96 = *v95;
                      if (*v95 > 50) {
                        goto LABEL_53;
                      }
                      if (v96 == -1)
                      {
                        if (!_LogCategory_Initialize(*(void *)(a1 + 16), 0x32u)) {
                          goto LABEL_53;
                        }
                        uint64_t v95 = *(int **)(a1 + 16);
                        int v96 = *v95;
                      }

                      char v97 = *__s;
                      if (v96 == -1) {
                        _LogCategory_Initialize((uint64_t)v95, 0x28u);
                      }
                      LogPrintF( (uint64_t)v95,  (uint64_t)"OSStatus _AdminPairingServerExchange(PairingSessionRef, const void *, size_t, uint8_t * *, size_t *, Boolean *)",  0x32u,  (uint64_t)"### AdminPairing server state %d failed: %#m\n%?{end}%1{tlv8}\n",  v20,  v21,  (uint64_t)v22,  v23,  v97);
                      goto LABEL_53;
                    }

                    v123 = *(int **)(a1 + 16);
                  }

                  LogPrintF( (uint64_t)v123,  (uint64_t)"OSStatus _AdminPairingServerM1(PairingSessionRef, const uint8_t *const, const uint8_t *cons t, uint8_t **, size_t *)",  0x32u,  (uint64_t)"### AdminPairing server failed for %##@: %#m\n",  v20,  v21,  (uint64_t)v22,  v23,  (char)v61);
                  int v93 = v191;
                  goto LABEL_324;
                }

                uint64_t v79 = *(void *)(a1 + 904);
LABEL_200:
                int v93 = v78(v61, v79);
                goto LABEL_258;
              }

              goto LABEL_413;
            }

            break;
          }

          goto LABEL_412;
        case 10:
          unsigned int v191 = TLV8GetBytes(a2, v53, 0, 1uLL, 1uLL, &__dst, 0LL, 0LL);
          if (!v191)
          {
            if (__dst == 3)
            {
              uint64_t v61 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
              if (v61)
              {
                unsigned int v191 = TLV8GetOrCopyCoalesced(a2, v53, 1, &bytes, (size_t *)&numBytes, (unsigned __int8 **)&v188, 0LL);
                if (v191) {
                  goto LABEL_111;
                }
                unsigned int v191 = CFDictionarySetCString(v61, @"identifier", (const char *)bytes, numBytes);
                if (v191) {
                  goto LABEL_111;
                }
                if (v188)
                {
                  free(v188);
                  v188 = 0LL;
                }

                unsigned int v191 = TLV8GetOrCopyCoalesced(a2, v53, 3, &bytes, (size_t *)&numBytes, (unsigned __int8 **)&v188, 0LL);
                if (v191) {
                  goto LABEL_111;
                }
                unsigned int v191 = CFDictionarySetData(v61, @"pk", bytes, numBytes);
                if (v191) {
                  goto LABEL_111;
                }
                if (v188)
                {
                  free(v188);
                  v188 = 0LL;
                }

                unint64_t UInt64 = TLV8GetUInt64(a2, v53, 11, (int *)&v191, 0LL);
                if (v191) {
                  goto LABEL_111;
                }
                if (!HIDWORD(UInt64))
                {
                  unsigned int v191 = CFDictionarySetInt64(v61, @"permissions", UInt64);
                  if (v191) {
                    goto LABEL_111;
                  }
                  SecCertificateRef v78 = *(uint64_t (**)(__CFDictionary *, uint64_t))(a1 + 880);
                  if (!v78)
                  {
                    __srCC_SHA1_CTX c = 0LL;
                    int v124 = CFDictionaryGetOrCopyBytes( v61,  @"identifier",  (CFIndex *)v199,  (UInt8 **)&__src,  (int *)&v192);
                    if (v124)
                    {
                      uint64_t v125 = (char *)v124;
                      CFTypeID v126 = CFDataGetTypeID();
                      uint64_t v127 = CFDictionaryGetTypedValue(v61, @"pk", v126, (int *)&v192);
                      if (v127)
                      {
                        v128 = v127;
                        if (CFDataGetLength(v127) == 32)
                        {
                          unsigned int v129 = CFDictionaryGetInt64Ranged(v61, @"permissions", 0LL, 0xFFFFFFFFLL, 0LL);
                          BOOL v130 = *(void **)v199;
                          uint64_t v131 = (unsigned __int8 *)CFDataGetBytePtr(v128);
                          unsigned int v192 = _PairingSessionSavePeerKeychain(a1, v125, (uint64_t)v130, v131, v129);
                        }

                        else
                        {
                          unsigned int v192 = -6743;
                        }

                        BOOL v55 = __s;
                      }
                    }

                    if (__src) {
                      free(__src);
                    }
                    int v93 = v192;
                    unsigned int v191 = v192;
                    char v41 = v185;
                    if (!v192) {
                      goto LABEL_354;
                    }
                    goto LABEL_259;
                  }

                  uint64_t v79 = *(void *)(a1 + 888);
                  goto LABEL_200;
                }

                unsigned int v151 = -6710;
LABEL_343:
                unsigned int v191 = v151;
                goto LABEL_111;
              }

LABEL_413:
              unsigned int v151 = -6728;
              goto LABEL_343;
            }

            break;
          }

LABEL_412:
          uint64_t v61 = 0LL;
          goto LABEL_111;
        default:
          unint64_t v94 = *(int **)(a1 + 16);
          if (*v94 <= 60)
          {
            if (*v94 == -1)
            {
              unint64_t v94 = *(int **)(a1 + 16);
              int v76 = *(_DWORD *)(a1 + 96);
            }

            LogPrintF( (uint64_t)v94,  (uint64_t)"OSStatus _AdminPairingServerM1(PairingSessionRef, const uint8_t *const, const uint8_t *const, uin t8_t **, size_t *)",  0x3Cu,  (uint64_t)"### AdminPairing server bad session type %d\n",  v20,  v21,  (uint64_t)v22,  v23,  v76);
          }

          break;
      }

      uint64_t v61 = 0LL;
      unsigned int v151 = -6705;
      goto LABEL_343;
    default:
      unint64_t v71 = *(int **)(a1 + 16);
      if (*v71 > 60) {
        goto LABEL_185;
      }
      if (*v71 != -1) {
        goto LABEL_144;
      }
      if (_LogCategory_Initialize((uint64_t)v71, 0x3Cu))
      {
        unint64_t v71 = *(int **)(a1 + 16);
        int v43 = *(_DWORD *)(a1 + 96);
LABEL_144:
        LogPrintF( (uint64_t)v71,  (uint64_t)"OSStatus PairingSessionExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x3Cu,  (uint64_t)"### Bad pair type: %d\n",  v20,  v21,  (uint64_t)v22,  v23,  v43);
      }

LABEL_185:
      uint64_t v18 = 4294960587LL;
      goto LABEL_53;
  }

          GroupInfoTLV = _PairingSessionVerifyACL(a1, (uint64_t)cf);
          if (!GroupInfoTLV)
          {
            int v124 = *(const void **)(a1 + 272);
            if (v124) {
              CFRelease(v124);
            }
            *(void *)(a1 + 272) = cf;
            CFTypeRef cf = 0LL;
            uint64_t v125 = TLV8CopyCoalesced(v65, v70, 29, (size_t *)v171, 0LL);
            if (v125)
            {
              CFTypeID v126 = v125;
              uint64_t v127 = (__CFString *)_OPACKDecodeBytes(0LL, v125, *(uint64_t *)&v171[0], 0, &GroupInfoTLV);
              free(v126);
              if (!v127) {
                goto LABEL_83;
              }
              v128 = CFGetTypeID(v127);
              if (v128 != CFDictionaryGetTypeID())
              {
                GroupInfoTLV = -6756;
                CFRelease(v127);
                goto LABEL_83;
              }

              PairingSessionSetProperty(a1, @"appInfoPeer", v127);
              CFRelease(v127);
            }

            GroupInfoTLV = _ExtractGroupInfoTLV(a1, v65, v70);
            if (!GroupInfoTLV)
            {
              *(_BYTE *)(a1 + 120) = 4;
              GroupInfoTLV = _VerifyServerM4(a1, a4, a5);
              unint64_t v26 = GroupInfoTLV == 0;
              goto LABEL_84;
            }

uint64_t _SetupClientExchange( uint64_t a1, unsigned __int8 *a2, CFIndex a3, UInt8 **a4, const char *a5, uint64_t a6, const void *a7, uint64_t a8)
{
  id v8 = (_BYTE *)a6;
  size_t v9 = (CFIndex *)a5;
  v192[38] = *MEMORY[0x1895F89C0];
  v180 = 0LL;
  size_t v177 = 0LL;
  CFIndex v178 = 0LL;
  size_t v175 = 0LL;
  v176 = 0LL;
  __srCC_SHA1_CTX c = v192;
  __int128 v190 = xmmword_186B49CC0;
  unsigned int v191 = 0LL;
  v185 = (int8x16_t *)&v188;
  __int128 v186 = xmmword_186B49CC0;
  v187 = 0LL;
  uint64_t v15 = (char *)(a1 + 120);
  int v14 = *(unsigned __int8 *)(a1 + 120);
  if (!*(_BYTE *)(a1 + 120))
  {
    int v14 = 1;
    char *v15 = 1;
  }

  unint64_t v16 = (unint64_t)&a2[a3];
  if (!a3) {
    goto LABEL_12;
  }
  int v17 = a2;
  do
  {
    if (v17 == (unsigned __int8 *)v16)
    {
LABEL_85:
      unsigned int v45 = -6727;
LABEL_88:
      Int64 = 0LL;
      LOBYTE(v23) = 0;
      goto LABEL_75;
    }

    if ((unint64_t)v17 >= v16)
    {
      unsigned int v45 = -6705;
      goto LABEL_88;
    }

    uint64_t v18 = v17 + 2;
    uint64_t v19 = v17[1];
    if ((unint64_t)&v17[v19 + 2] > v16)
    {
      unsigned int v45 = -6750;
      goto LABEL_88;
    }

    int v20 = *v17;
    v17 += v19 + 2;
  }

  while (v20 != 6);
  uint64_t v181 = v19;
  CFIndex v182 = v18;
  unsigned int appended = 0;
  if ((_DWORD)v19 != 1) {
    goto LABEL_303;
  }
  if (*v18 != v14)
  {
LABEL_74:
    Int64 = 0LL;
    LOBYTE(v23) = 0;
    unsigned int v45 = -6709;
    goto LABEL_75;
  }

LABEL_299:
                LOBYTE(v23) = 0;
                goto LABEL_300;
              }

              else {
                size_t v82 = v190;
              }
              double v83 = (UInt8 *)malloc(v82);
              uint64_t v23 = v83;
              if (v83)
              {
                if (v81) {
                  memcpy(v83, __src, v81);
                }
                goto LABEL_206;
              }

        unint64_t v26 = 0;
        int v160 = -6728;
        goto LABEL_295;
      }

      size_t v65 = 0LL;
      unint64_t v26 = 0;
    }

    else
    {
      size_t v65 = 0LL;
      unint64_t v26 = 0;
      GroupInfoTLV = -6743;
    }

    int v27 = 1;
    goto LABEL_84;
  }

  CFTypeID v164 = v8;
  if (v17 != 1)
  {
    int v25 = *(int **)(a1 + 16);
    if (*v25 <= 60)
    {
      if (*v25 == -1)
      {
        int v25 = *(int **)(a1 + 16);
        LOBYTE(v17) = *(_BYTE *)(a1 + 120);
      }

      LogPrintF( (uint64_t)v25,  (uint64_t)"OSStatus _VerifyServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x3Cu,  (uint64_t)"### Pair-verify server bad state: %d\n",  (uint64_t)a5,  a6,  a7,  a8,  v17);
    }

LABEL_371:
              Int64 = 0LL;
              unsigned int v140 = -6728;
            }

            else
            {
              Int64 = 0LL;
              LOBYTE(v23) = 0;
              unsigned int v140 = -6703;
            }

LABEL_362:
            unsigned int appended = v140;
            goto LABEL_165;
          }

          Int64 = 0LL;
LABEL_369:
          LOBYTE(v23) = 0;
LABEL_370:
          unsigned int v45 = -6728;
          goto LABEL_75;
        }

        int v49 = *v46;
        v46 += v48 + 2;
      }

      while (v49 != 7);
      unsigned int appended = 0;
      if ((_DWORD)v48 != 1) {
        goto LABEL_303;
      }
      int v50 = *v47;
      unsigned int v51 = -6737;
      switch(*v47)
      {
        case 0:
          goto LABEL_113;
        case 1:
          unsigned int v51 = -6700;
          goto LABEL_113;
        case 2:
          unsigned int v51 = -6754;
          goto LABEL_113;
        case 3:
          unint64_t v52 = TLV8GetUInt64(a2, &a2[a3], 8, (int *)&appended, 0LL);
          if (appended) {
            goto LABEL_163;
          }
          unint64_t v53 = v52;
          if (v52 >> 31)
          {
            Int64 = 0LL;
            LOBYTE(v23) = 0;
            unsigned int v45 = -6710;
            goto LABEL_75;
          }

          _PairingSessionReset(a1);
          uint64_t v54 = *(uint64_t (**)(void, unint64_t, void))(a1 + 48);
          if (!v54) {
            goto LABEL_367;
          }
          unsigned int v55 = v54(*(_DWORD *)(a1 + 100) | 0x20000u, v53, *(void *)(a1 + 24));
          break;
        case 4:
          unsigned int v51 = -6727;
          goto LABEL_113;
        case 5:
          unsigned int v51 = -6763;
          goto LABEL_113;
        case 6:
          unsigned int v51 = -6764;
          goto LABEL_113;
        case 7:
          unsigned int v51 = -6773;
          goto LABEL_113;
        case 8:
          unsigned int v51 = -71144;
          goto LABEL_113;
        default:
          if (v50 == 9) {
            unsigned int v51 = -6776;
          }
          else {
            unsigned int v51 = -6700;
          }
LABEL_113:
          unsigned int appended = v51;
          unint64_t v56 = *(int **)(a1 + 16);
          if (*v56 > 50) {
            goto LABEL_163;
          }
          if (*v56 != -1) {
            goto LABEL_115;
          }
          if (_LogCategory_Initialize((uint64_t)v56, 0x32u))
          {
            unint64_t v56 = *(int **)(a1 + 16);
            LOBYTE(v50) = *v47;
LABEL_115:
            LogPrintF( (uint64_t)v56,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"### Pair-setup client M2 bad status: 0x%X, %#m\n",  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  v50);
          }

          goto LABEL_163;
      }

LABEL_222:
      Int64 = 0LL;
      LOBYTE(v23) = 0;
      if (v55) {
        unsigned int v45 = v55;
      }
      else {
        unsigned int v45 = -6771;
      }
LABEL_75:
      unsigned int appended = v45;
LABEL_165:
      if (v9 && a4 && !appended) {
        _PairingSessionUpdateTranscript(a1, a2, a3, *a4, *v9);
      }
      _BYTE *v8 = (_BYTE)v23;
      if (v191)
      {
        free(v191);
        unsigned int v191 = 0LL;
      }

      if (v187)
      {
        free(v187);
        v187 = 0LL;
      }

      if (v180) {
        free(v180);
      }
      if (Int64) {
        free(Int64);
      }
      if (v178) {
        free(v178);
      }
      if (v176) {
        free(v176);
      }
      uint64_t v72 = appended;
      if (appended != -6771)
      {
        if (appended)
        {
          int v73 = *(int **)(a1 + 16);
          int v74 = *v73;
          if (*v73 <= 50)
          {
            if (v74 != -1) {
              goto LABEL_185;
            }
            BOOL v76 = _LogCategory_Initialize(*(void *)(a1 + 16), 0x32u);
            uint64_t v72 = appended;
            if (v76)
            {
              int v73 = *(int **)(a1 + 16);
              int v74 = *v73;
LABEL_185:
              char v75 = *v15;
              if (v74 == -1) {
                _LogCategory_Initialize((uint64_t)v73, 0x28u);
              }
              LogPrintF( (uint64_t)v73,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"### Pair-setup client state %d failed: %#m\n%?{end}%1{tlv8}\n",  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  v75);
              return appended;
            }
          }
        }
      }

      return v72;
    case 3:
      if (a3)
      {
LABEL_363:
        Int64 = 0LL;
        LOBYTE(v23) = 0;
        unsigned int v45 = -6705;
        goto LABEL_75;
      }

      a5 = *(const char **)(a1 + 384);
      if (!a5 || (a6 = *(void *)(a1 + 392)) == 0)
      {
        Int64 = 0LL;
        LOBYTE(v23) = 0;
        unsigned int v140 = -6745;
        goto LABEL_362;
      }

      goto LABEL_37;
    case 4:
      if (!*(void *)(a1 + 696) || !*(void *)(a1 + 736) || !*(void *)(a1 + 744)) {
        goto LABEL_327;
      }
      size_t v39 = *(int **)(a1 + 16);
      int v40 = *v39;
      if (*v39 > 30) {
        goto LABEL_139;
      }
      if (v40 != -1) {
        goto LABEL_63;
      }
      if (_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu))
      {
        size_t v39 = *(int **)(a1 + 16);
        int v40 = *v39;
LABEL_63:
        BOOL v41 = v40 <= 10 && (v40 != -1 || _LogCategory_Initialize((uint64_t)v39, 0xAu));
        LogPrintF( (uint64_t)v39,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)"Pair-setup client M4 -- verify response\n%?{end}%1{tlv8}\n",  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  !v41);
      }

LABEL_212:
                _PairingSessionReset(a1);
                uint64_t v87 = *(void **)(a1 + 384);
                if (v87)
                {
                  free(v87);
                  *(void *)(a1 + 384) = 0LL;
                }

                *(void *)(a1 + 392) = 0LL;
                *(_BYTE *)(a1 + 400) = 1;
                if (!*(void *)(a1 + 48)) {
                  goto LABEL_367;
                }
                unsigned int v88 = *(_DWORD *)(a1 + 100);
                uint64_t v89 = TLV8GetUInt64(a2, &a2[a3], 8, 0LL, 0LL);
                if (v89) {
                  int v90 = 196608;
                }
                else {
                  int v90 = 0x10000;
                }
                uint64_t v91 = v90 | v88;
                if (v89) {
                  uint64_t v92 = v89;
                }
                else {
                  uint64_t v92 = 0xFFFFFFFFLL;
                }
                unsigned int v55 = (*(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 48))(v91, v92, *(void *)(a1 + 24));
                goto LABEL_222;
              case 3:
                unsigned int v69 = -6760;
                goto LABEL_160;
              case 4:
                unsigned int v69 = -6727;
                goto LABEL_160;
              case 5:
                unsigned int v69 = -6763;
                goto LABEL_160;
              case 6:
                unsigned int v69 = -6764;
                goto LABEL_160;
              case 7:
                unsigned int v69 = -6773;
                goto LABEL_160;
              case 8:
                unsigned int v69 = -71144;
                goto LABEL_160;
              default:
                if (v68 == 9) {
                  unsigned int v69 = -6776;
                }
                else {
                  unsigned int v69 = -6700;
                }
LABEL_160:
                unsigned int appended = v69;
                unint64_t v71 = *(int **)(a1 + 16);
                if (*v71 > 50) {
                  goto LABEL_163;
                }
                if (*v71 != -1) {
                  goto LABEL_162;
                }
                if (_LogCategory_Initialize((uint64_t)v71, 0x32u))
                {
                  unint64_t v71 = *(int **)(a1 + 16);
                  LOBYTE(v68) = *v65;
LABEL_162:
                  LogPrintF( (uint64_t)v71,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"### Pair-setup client M4 bad status: 0x%X, %#m\n",  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  v68);
                }

                goto LABEL_163;
            }
          }

LABEL_303:
          Int64 = 0LL;
LABEL_304:
          LOBYTE(v23) = 0;
          unsigned int v45 = -6743;
          goto LABEL_75;
        }
      }

      unsigned int v80 = -6750;
LABEL_267:
      unsigned int appended = v80;
      unsigned int appended = TLV8GetOrCopyCoalesced(a2, &a2[a3], 4, &v182, (size_t *)&v181, (unsigned __int8 **)&v180, 0LL);
      if (appended) {
        goto LABEL_163;
      }
      unsigned int v113 = SRPClientVerify_libsrp(*(void ***)(a1 + 696));
      unsigned int appended = v113;
      if (v180)
      {
        free(v180);
        v180 = 0LL;
        unsigned int v113 = appended;
      }

      if (v113)
      {
        Int64 = 0LL;
LABEL_374:
        LOBYTE(v23) = 0;
        unsigned int v45 = -6754;
        goto LABEL_75;
      }

      CFMutableDictionaryRef v114 = *(void **)(a1 + 696);
      if (v114)
      {
        SRPDelete_libsrp(v114);
        *(void *)(a1 + 696) = 0LL;
      }

      CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  *(void *)(a1 + 736),  *(void *)(a1 + 744),  "Pair-Setup-Encrypt-Salt",  0x17uLL,  (uint64_t)"Pair-Setup-Encrypt-Info",  23LL,  0x20uLL,  a1 + 414);
      if ((*(_BYTE *)(a1 + 100) & 1) != 0)
      {
        unsigned int v115 = _MFiClientVerify( a1,  a2,  a3,  "PS-Msg04",  *(void *)(a1 + 736),  *(void *)(a1 + 744),  "MFi-Pair-Setup-Salt",  0x13uLL,  (uint64_t)"MFi-Pair-Setup-Info",  19LL,  0);
        if (v115 == -71164 || v115 == 0) {
          unsigned int v117 = v115;
        }
        else {
          unsigned int v117 = -71145;
        }
        unsigned int appended = v117;
        if (v117) {
          goto LABEL_163;
        }
      }

      else
      {
        _ClientDecryptExtra(a1, a2, a3);
      }

      int v118 = *(_DWORD *)(a1 + 100);
      if ((v118 & 0x10) == 0 && ((*(_DWORD *)(a1 + 288) ^ v118) & 0x200) == 0)
      {
        unsigned int v119 = *(void (**)(uint64_t, void, void))(a1 + 864);
        if (v119) {
          v119(3LL, 0LL, *(void *)(a1 + 872));
        }
        unsigned int v120 = *(void **)(a1 + 184);
        *(_BYTE *)(a1 + 120) = 5;
        if (v120)
        {
          free(v120);
          *(void *)(a1 + 184) = 0LL;
        }

        *(void *)(a1 + 192) = 0LL;
        __n = (char *)(a1 + 510);
        unsigned int appended = PairingSessionCopyIdentity(a1, 1LL, (char **)(a1 + 184), (_OWORD *)(a1 + 510), a1 + 542);
        if (appended) {
          goto LABEL_163;
        }
        size_t v121 = strlen(*(const char **)(a1 + 184));
        *(void *)(a1 + 192) = v121;
        if (!v121)
        {
          Int64 = 0LL;
          LOBYTE(v23) = 0;
          unsigned int v45 = -6708;
          goto LABEL_75;
        }

        uint64_t v181 = v121 + 64;
        size_t v170 = v121 + 64;
        uint64_t v122 = (char *)malloc(v121 + 64);
        Int64 = v122;
        v180 = v122;
        if (!v122) {
          goto LABEL_369;
        }
        CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  *(void *)(a1 + 736),  *(void *)(a1 + 744),  "Pair-Setup-Controller-Sign-Salt",  0x1FuLL,  (uint64_t)"Pair-Setup-Controller-Sign-Info",  31LL,  0x20uLL,  (uint64_t)v122);
        CFTypeID v169 = Int64;
        v123 = Int64 + 32;
        size_t v124 = *(void *)(a1 + 192);
        memcpy(v123, *(const void **)(a1 + 184), v124);
        uint64_t v125 = &v123[v124];
        __int128 v126 = *(_OWORD *)(a1 + 526);
        *(_OWORD *)uint64_t v125 = *(_OWORD *)__n;
        *((_OWORD *)v125 + 1) = v126;
        uint64_t v127 = *(void (**)(void, char *, size_t, char *, void))(a1 + 928);
        if (v127)
        {
          v128 = v169;
          v127(*(unsigned int *)(a1 + 100), v169, v170, __dst, *(void *)(a1 + 936));
        }

        else
        {
          ccsha512_di();
          v128 = v169;
          cced25519_sign();
        }

        free(v128);
        v180 = 0LL;
        unsigned int appended = TLV8BufferAppend((uint64_t)&v185, 1, *(char **)(a1 + 184), *(void *)(a1 + 192));
        if (appended) {
          goto LABEL_163;
        }
        unsigned int appended = TLV8BufferAppend((uint64_t)&v185, 3, __n, 0x20uLL);
        if (appended) {
          goto LABEL_163;
        }
        unsigned int appended = TLV8BufferAppend((uint64_t)&v185, 10, __dst, 0x40uLL);
        if (appended) {
          goto LABEL_163;
        }
        v141 = *(const __CFString **)(a1 + 176);
        if (v141)
        {
          DataCFMutableDictionaryRef Mutable = OPACKEncoderCreateDataMutable(v141, 0, (int *)&appended);
          Int64 = (char *)DataMutable;
          if (!DataMutable) {
            goto LABEL_164;
          }
          BytePtr = (char *)CFDataGetBytePtr(DataMutable);
          size_t Length = CFDataGetLength((CFDataRef)Int64);
          unsigned int appended = TLV8BufferAppend((uint64_t)&v185, 18, BytePtr, Length);
          CFRelease(Int64);
          if (appended) {
            goto LABEL_163;
          }
        }

        unsigned __int8 v145 = *(char **)(a1 + 216);
        if (v145)
        {
          unsigned int appended = TLV8BufferAppend((uint64_t)&v185, 16, v145, *(void *)(a1 + 224));
          if (appended) {
            goto LABEL_163;
          }
        }

        int v146 = *(_DWORD *)(a1 + 100);
        if ((v146 & 0x5770FF34) != 0 && (v146 & 0x1000E001) == 0)
        {
          SelfInfo = _PairingSessionGetSelfInfo(a1);
          if (SelfInfo)
          {
            uint64_t v148 = OPACKEncoderCreateDataMutable((const __CFString *)SelfInfo, 0, (int *)&appended);
            Int64 = (char *)v148;
            if (!v148) {
              goto LABEL_164;
            }
            BOOL v149 = (char *)CFDataGetBytePtr(v148);
            size_t v150 = CFDataGetLength((CFDataRef)Int64);
            unsigned int appended = TLV8BufferAppend((uint64_t)&v185, 17, v149, v150);
            CFRelease(Int64);
            if (appended) {
              goto LABEL_163;
            }
          }
        }

        unsigned int v151 = *(const __CFDictionary **)(a1 + 344);
        CFTypeID TypeID = CFDataGetTypeID();
        TypedValue = CFDictionaryGetTypedValue(v151, @"ownershipProof", TypeID, 0LL);
        if (TypedValue)
        {
          size_t v154 = TypedValue;
          v155 = (char *)CFDataGetBytePtr(TypedValue);
          size_t v156 = CFDataGetLength(v154);
          unsigned int appended = TLV8BufferAppend((uint64_t)&v185, 26, v155, v156);
          if (appended) {
            goto LABEL_163;
          }
        }

        unint64_t v157 = v186;
        char v158 = (int8x16_t *)malloc(v186 + 16);
        Int64 = (char *)v158;
        v180 = v158;
        if (!v158) {
          goto LABEL_369;
        }
        _chacha20_poly1305_encrypt_all( (_DWORD *)(a1 + 414),  "PS-Msg05",  8LL,  0LL,  0LL,  v185,  v157,  v158,  (uint64_t)v158->i64 + v157);
        unsigned int appended = TLV8BufferAppend((uint64_t)&__src, 5, Int64, v186 + 16);
        if (appended) {
          goto LABEL_163;
        }
        free(Int64);
        v180 = 0LL;
        unsigned int appended = TLV8BufferAppend((uint64_t)&__src, 6, v15, 1uLL);
        if (appended) {
          goto LABEL_163;
        }
        size_t __nb = v190;
        Int64 = (char *)v191;
        if (!v191)
        {
          else {
            size_t v159 = v190;
          }
          int v160 = (char *)malloc(v159);
          Int64 = v160;
          if (!v160) {
            goto LABEL_369;
          }
          if (__nb) {
            memcpy(v160, __src, __nb);
          }
        }

        LOBYTE(v23) = 0;
        __srCC_SHA1_CTX c = v192;
        *(void *)&__int128 v190 = 0LL;
        unsigned int v191 = 0LL;
        *a4 = (UInt8 *)Int64;
        *size_t v9 = __nb;
        unsigned int appended = 0;
        *(_BYTE *)(a1 + 120) = 6;
        v161 = *(int **)(a1 + 16);
        int v162 = *v161;
        if (*v161 <= 30)
        {
          if (v162 == -1)
          {
            if (!_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu))
            {
LABEL_385:
              LOBYTE(v23) = 0;
              goto LABEL_300;
            }

            v161 = *(int **)(a1 + 16);
            int v162 = *v161;
          }

          char v163 = v162 > 10 || v162 == -1 && !_LogCategory_Initialize((uint64_t)v161, 0xAu);
          LogPrintF( (uint64_t)v161,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)"Pair-setup client M5 -- exchange request\n%?{end}%1{tlv8}\n",  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  v163);
          goto LABEL_385;
        }

LABEL_300:
        Int64 = 0LL;
        unsigned int appended = 0;
        goto LABEL_165;
      }

      *(_BYTE *)(a1 + 120) = 7;
      *a4 = 0LL;
      *size_t v9 = 0LL;
      unsigned int v129 = *(int **)(a1 + 16);
      if (*v129 > 30) {
        goto LABEL_324;
      }
      if (*v129 != -1) {
        goto LABEL_295;
      }
      if (_LogCategory_Initialize((uint64_t)v129, 0x1Eu))
      {
        unsigned int v129 = *(int **)(a1 + 16);
LABEL_295:
        BOOL v130 = "Pair-setup transient client done -- server authenticated\n";
LABEL_296:
        LogPrintF( (uint64_t)v129,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)v130,  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  v168);
      }

LABEL_324:
      LOBYTE(v23) = 1;
      goto LABEL_300;
    case 6:
      if (!*(void *)(a1 + 736) || !*(void *)(a1 + 744))
      {
LABEL_327:
        Int64 = 0LL;
        LOBYTE(v23) = 0;
        unsigned int v45 = -6703;
        goto LABEL_75;
      }

      unsigned __int32 v42 = *(int **)(a1 + 16);
      int v43 = *v42;
      if (*v42 > 30) {
        goto LABEL_120;
      }
      if (v43 != -1) {
        goto LABEL_70;
      }
      if (_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu))
      {
        unsigned __int32 v42 = *(int **)(a1 + 16);
        int v43 = *v42;
LABEL_70:
        BOOL v44 = v43 <= 10 && (v43 != -1 || _LogCategory_Initialize((uint64_t)v42, 0xAu));
        LogPrintF( (uint64_t)v42,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)"Pair-setup client M6 -- exchange response\n%?{end}%1{tlv8}\n",  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  !v44);
      }

LABEL_120:
      uint64_t v57 = a2;
      while (1)
      {
        if (v57 == (unsigned __int8 *)v16)
        {
LABEL_195:
          unsigned int v79 = -6727;
          goto LABEL_255;
        }

        int v58 = v57 + 2;
        uint64_t v59 = v57[1];
        if ((unint64_t)&v57[v59 + 2] > v16)
        {
          unsigned int v79 = -6750;
          goto LABEL_255;
        }

        int v60 = *v57;
        v57 += v59 + 2;
        if (v60 == 7)
        {
          if ((_DWORD)v59 != 1) {
            goto LABEL_303;
          }
          uint64_t v61 = *v58;
          if (v61 >= 9)
          {
            if ((_DWORD)v61 == 9) {
              unsigned int v62 = -6776;
            }
            else {
              unsigned int v62 = -6700;
            }
          }

          else
          {
            unsigned int v62 = dword_186B4BE50[v61];
          }

          unsigned int appended = v62;
          unint64_t v63 = *(int **)(a1 + 16);
          if (*v63 <= 50)
          {
            if (*v63 != -1)
            {
LABEL_134:
              LogPrintF( (uint64_t)v63,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"### Pair-setup client M6 bad status: 0x%X, %#m\n",  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  v61);
              goto LABEL_163;
            }

            if (_LogCategory_Initialize((uint64_t)v63, 0x32u))
            {
              unint64_t v63 = *(int **)(a1 + 16);
              LOBYTE(v61) = *v58;
              goto LABEL_134;
            }
          }

        if (!v34)
        {
          if (v35 && v122 - v13 >= 2 && v24 >= 2 && *v13 == 48 && __tolower(v13[1]) == 120)
          {
            uint64_t v5 = v13 + 2;
            int v37 = 16LL;
            v24 -= 2;
          }

          else
          {
            if (v36)
            {
              int v58 = (unint64_t)v122;
              if (v122 - v13 < 2 || (uint64_t v59 = v24 - 2, v24 < 2) || *v13 != 48 || __tolower(v13[1]) != 98)
              {
                int v37 = 2LL;
                goto LABEL_155;
              }

              uint64_t v5 = v13 + 2;
              goto LABEL_150;
            }

            uint64_t v5 = v13;
          }

          int v58 = (unint64_t)v122;
          goto LABEL_156;
        }

        int v58 = (unint64_t)v122;
        if (v122 - v13 > 2)
        {
          uint64_t v59 = v24 - 2;
          if (v24 >= 2 && *v13 == 48)
          {
            if (__tolower(v13[1]) == 120)
            {
              uint64_t v5 = v13 + 2;
              if ((*(_DWORD *)(v6 + 4LL * v13[2] + 60) & 0x10000) != 0)
              {
                int v37 = 16LL;
                goto LABEL_257;
              }
            }

            if (*v13 != 48) {
              goto LABEL_129;
            }
            uint64_t v5 = v13 + 2;
            if ((v13[2] & 0xFE) != 0x30) {
              goto LABEL_129;
            }
LABEL_150:
            int v37 = 2LL;
LABEL_257:
            size_t v24 = v59;
            goto LABEL_156;
          }
        }

LABEL_163:
          Int64 = 0LL;
          goto LABEL_164;
        }
      }

      unsigned int v79 = -6705;
LABEL_255:
      unsigned int appended = v79;
      uint64_t v101 = (int8x16_t *)TLV8CopyCoalesced(a2, &a2[a3], 5, &v179, (int *)&appended);
      Int64 = (char *)v101;
      if (appended) {
        goto LABEL_164;
      }
      size_t v102 = v179;
      if (v179 <= 0xF) {
        goto LABEL_304;
      }
      v179 -= 16LL;
      int v103 = &v101[-1].u8[v102];
      unsigned int appended = _chacha20_poly1305_decrypt_all( (_DWORD *)(a1 + 414),  "PS-Msg06",  8LL,  0LL,  0LL,  v101,  v179,  v101,  (uint64_t)v103,  16LL);
      if (appended) {
        goto LABEL_164;
      }
      char v104 = *(void **)(a1 + 232);
      if (v104) {
        free(v104);
      }
      *(void *)(a1 + 240) = 0LL;
      *(void *)(a1 + 232) = TLV8CopyCoalesced((unsigned __int8 *)Int64, v103, 16, (size_t *)(a1 + 240), 0LL);
      double v105 = *(const void **)(a1 + 312);
      if (v105)
      {
        CFRelease(v105);
        *(void *)(a1 + 312) = 0LL;
      }

      double v106 = TLV8CopyCoalesced((unsigned __int8 *)Int64, v103, 17, (size_t *)&v181, 0LL);
      if (v106)
      {
        double v107 = v106;
        *(void *)(a1 + 312) = _OPACKDecodeBytes(0LL, v106, v181, 0, &appended);
        free(v107);
        double v108 = *(const void **)(a1 + 312);
        if (!v108) {
          goto LABEL_164;
        }
        CFTypeID v109 = CFGetTypeID(v108);
        if (v109 != CFDictionaryGetTypeID())
        {
          unsigned int appended = -6756;
          CFTypeID v164 = *(const void **)(a1 + 312);
          if (v164)
          {
            CFRelease(v164);
            LOBYTE(v23) = 0;
            *(void *)(a1 + 312) = 0LL;
            goto LABEL_165;
          }

          goto LABEL_164;
        }

        CFTypeID v110 = *(const __CFDictionary **)(a1 + 312);
        CFTypeID v111 = CFDictionaryGetTypeID();
        uint64_t v112 = CFDictionaryGetTypedValue(v110, @"groupInfo", v111, 0LL);
      }

      else
      {
        uint64_t v112 = 0LL;
      }

      PairingSessionSetProperty(a1, @"groupInfoPeer", v112);
      uint64_t v131 = *(void **)(a1 + 296);
      if (v131)
      {
        free(v131);
        *(void *)(a1 + 296) = 0LL;
      }

      uint64_t v132 = (void *)(a1 + 304);
      *(void *)(a1 + 304) = 0LL;
      *(void *)(a1 + 296) = TLV8CopyCoalesced( (unsigned __int8 *)Int64,  v103,  1,  (size_t *)(a1 + 304),  (int *)&appended);
      if (appended) {
        goto LABEL_164;
      }
      if (!*v132) {
        goto LABEL_304;
      }
      __na = (unsigned __int8 *)(a1 + 606);
      unsigned int appended = TLV8GetBytes((unsigned __int8 *)Int64, v103, 3, 0x20uLL, 0x20uLL, (char *)(a1 + 606), 0LL, 0LL);
      if (appended
        || (unsigned int appended = TLV8GetBytes((unsigned __int8 *)Int64, v103, 10, 0x40uLL, 0x40uLL, __dst, 0LL, 0LL)) != 0)
      {
LABEL_164:
        LOBYTE(v23) = 0;
        goto LABEL_165;
      }

      uint64_t v133 = (UInt8 *)malloc(*v132 + 64LL);
      uint64_t v23 = v133;
      v180 = v133;
      if (!v133) {
        goto LABEL_370;
      }
      CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  *(void *)(a1 + 736),  *(void *)(a1 + 744),  "Pair-Setup-Accessory-Sign-Salt",  0x1EuLL,  (uint64_t)"Pair-Setup-Accessory-Sign-Info",  30LL,  0x20uLL,  (uint64_t)v133);
      v171 = v23;
      uint64_t v134 = (char *)(v23 + 32);
      size_t v135 = *(void *)(a1 + 304);
      memcpy(v134, *(const void **)(a1 + 296), v135);
      uint64_t v136 = &v134[v135];
      __int128 v137 = *(_OWORD *)(a1 + 622);
      *(_OWORD *)uint64_t v136 = *(_OWORD *)__na;
      *((_OWORD *)v136 + 1) = v137;
      ccsha512_di();
      unsigned int appended = cced25519_verify();
      if (appended) {
        goto LABEL_374;
      }
      free(v171);
      v180 = 0LL;
      if (Int64) {
        free(Int64);
      }
      unsigned int v138 = _PairingSessionVerifyAllowed(a1);
      unsigned int appended = v138;
      if (v138)
      {
        char v165 = v138;
        v166 = *(int **)(a1 + 16);
        if (*v166 > 50) {
          goto LABEL_163;
        }
        if (*v166 == -1)
        {
          v166 = *(int **)(a1 + 16);
          char v165 = appended;
        }

        LogPrintF( (uint64_t)v166,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"### Pair-setup client: server not allowed: %#m\n",  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  v165);
        goto LABEL_163;
      }

      unsigned int appended = PairingSessionSavePeer( a1,  *(char **)(a1 + 296),  *(void *)(a1 + 304),  __na,  (uint64_t)a5,  a6,  (uint64_t)a7,  a8);
      if (appended) {
        goto LABEL_163;
      }
      int v139 = *(void **)(a1 + 384);
      if (v139)
      {
        free(v139);
        *(void *)(a1 + 384) = 0LL;
      }

      *(void *)(a1 + 392) = 0LL;
      *(_BYTE *)(a1 + 400) = 0;
      *(_BYTE *)(a1 + 120) = 7;
      *a4 = 0LL;
      *size_t v9 = 0LL;
      unsigned int v129 = *(int **)(a1 + 16);
      if (*v129 > 30) {
        goto LABEL_324;
      }
      if (*v129 != -1) {
        goto LABEL_322;
      }
      unsigned int v129 = *(int **)(a1 + 16);
LABEL_322:
      BOOL v130 = "Pair-setup client done -- server authenticated\n";
      goto LABEL_296;
    default:
      unint64_t v29 = *(int **)(a1 + 16);
      if (*v29 > 60) {
        goto LABEL_74;
      }
      if (*v29 != -1) {
        goto LABEL_33;
      }
      if (_LogCategory_Initialize((uint64_t)v29, 0x3Cu))
      {
        unint64_t v29 = *(int **)(a1 + 16);
        LOBYTE(v14) = *(_BYTE *)(a1 + 120);
LABEL_33:
        LogPrintF( (uint64_t)v29,  (uint64_t)"OSStatus _SetupClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x3Cu,  (uint64_t)"### Pair-setup client bad state: %d\n",  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  v14);
      }

      goto LABEL_74;
  }

uint64_t _SetupServerExchange( uint64_t a1, unsigned __int8 *a2, CFIndex a3, UInt8 **a4, CFIndex *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id v8 = (_BYTE *)a6;
  int v10 = a4;
  v208[38] = *MEMORY[0x1895F89C0];
  size_t v194 = 0LL;
  v195 = 0LL;
  int v14 = &a2[a3];
  v193 = 0LL;
  v189 = 0LL;
  __int128 v190 = 0LL;
  size_t v188 = 0LL;
  __srCC_SHA1_CTX c = v208;
  __int128 v206 = xmmword_186B49CC0;
  v207 = 0LL;
  v201 = (int8x16_t *)&v204;
  __int128 v202 = xmmword_186B49CC0;
  uint64_t v15 = a2;
  v203 = 0LL;
  do
  {
    if (v15 == v14)
    {
LABEL_48:
      unsigned int v34 = -6727;
      goto LABEL_51;
    }

    if (v15 >= v14)
    {
      unsigned int v34 = -6705;
      goto LABEL_51;
    }

    unint64_t v16 = v15 + 2;
    CFIndex v17 = v15[1];
    if (&v15[v17 + 2] > v14)
    {
      unsigned int v34 = -6750;
      goto LABEL_51;
    }

    int v18 = *v15;
    v15 += v17 + 2;
  }

  while (v18 != 6);
  CFIndex length = v17;
  unsigned int appended = 0;
  if ((_DWORD)v17 != 1)
  {
    uint64_t v31 = 0LL;
    uint64_t v32 = 0LL;
    LOBYTE(v33) = 0;
    unsigned int v34 = -6743;
    goto LABEL_114;
  }

  if (*v16 == 1) {
    _PairingSessionReset(a1);
  }
  int v20 = (_BYTE *)(a1 + 120);
  int v19 = *(unsigned __int8 *)(a1 + 120);
  if (!*(_BYTE *)(a1 + 120))
  {
    int v19 = 1;
    *int v20 = 1;
  }

  if (*v16 != v19)
  {
    uint64_t v31 = 0LL;
    uint64_t v32 = 0LL;
    LOBYTE(v33) = 0;
    unsigned int v115 = -6709;
    goto LABEL_284;
  }

  if (v19 == 5)
  {
    if (!*(void *)(a1 + 736) || !*(void *)(a1 + 744))
    {
LABEL_283:
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
      LOBYTE(v33) = 0;
      unsigned int v115 = -6703;
      goto LABEL_284;
    }

    int v27 = *(int **)(a1 + 16);
    int v28 = *v27;
    if (*v27 <= 30)
    {
      if (v28 == -1)
      {
        if (!_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu)) {
          goto LABEL_78;
        }
        int v27 = *(int **)(a1 + 16);
        int v28 = *v27;
      }

      BOOL v29 = v28 <= 10 && (v28 != -1 || _LogCategory_Initialize((uint64_t)v27, 0xAu));
      LogPrintF( (uint64_t)v27,  (uint64_t)"OSStatus _SetupServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)"Pair-setup server M5 -- exchange request\n%?{end}%1{tlv8}\n",  (uint64_t)a5,  a6,  a7,  a8,  !v29);
    }

LABEL_428:
                    LOBYTE(v33) = 1;
                    id v8 = v186;
                    goto LABEL_313;
                  }

                  else {
                    size_t v169 = v206;
                  }
                  size_t v170 = (char *)malloc(v169);
                  uint64_t v32 = v170;
                  if (v170)
                  {
                    if (v168) {
                      memcpy(v170, __src, v168);
                    }
                    goto LABEL_356;
                  }
                }

LABEL_420:
                LOBYTE(v33) = 0;
                goto LABEL_396;
              }
            }
          }
        }
      }
    }

LABEL_305:
      int v148 = *(_DWORD *)(a1 + 100);
      if ((v148 & 0x10) == 0 && ((*(_DWORD *)(a1 + 684) ^ v148) & 0x200) == 0)
      {
        uint64_t v31 = 0LL;
        LOBYTE(v33) = 0;
        *int v20 = 5;
LABEL_313:
        int v10 = a4;
LABEL_316:
        uint64_t v32 = 0LL;
        unsigned int appended = 0;
        goto LABEL_115;
      }

      *(_BYTE *)(a1 + 120) = 7;
      BOOL v149 = *(int **)(a1 + 16);
      if (*v149 > 30)
      {
        uint64_t v31 = 0LL;
        LOBYTE(v33) = 1;
        goto LABEL_313;
      }

      if (*v149 == -1)
      {
        int v10 = a4;
        BOOL v149 = *(int **)(a1 + 16);
      }

      else
      {
        int v10 = a4;
      }

      LogPrintF( (uint64_t)v149,  (uint64_t)"OSStatus _SetupServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)"Pair-setup transient server done -- client authenticated\n",  (uint64_t)a5,  a6,  a7,  a8,  v181);
LABEL_315:
      uint64_t v31 = 0LL;
      LOBYTE(v33) = 1;
      goto LABEL_316;
    }

    goto LABEL_283;
  }

  if (v19 != 1)
  {
    unint64_t v30 = *(int **)(a1 + 16);
    int v10 = a4;
    if (*v30 <= 60)
    {
      if (*v30 == -1)
      {
        unint64_t v30 = *(int **)(a1 + 16);
        LOBYTE(v19) = *(_BYTE *)(a1 + 120);
      }

      LogPrintF( (uint64_t)v30,  (uint64_t)"OSStatus _SetupServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x3Cu,  (uint64_t)"### Pair-setup server bad state: %d\n",  (uint64_t)a5,  a6,  a7,  a8,  v19);
    }

LABEL_266:
            uint64_t v31 = 0LL;
LABEL_267:
            uint64_t v32 = 0LL;
LABEL_268:
            LOBYTE(v33) = 0;
            goto LABEL_115;
          }

          size_t v39 = *(int **)(a1 + 16);
        }

        LogPrintF( (uint64_t)v39,  (uint64_t)"OSStatus _SetupServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"Pair-setup server throttling for %d second(s)\n",  (uint64_t)a5,  a6,  a7,  a8,  v38);
        goto LABEL_237;
      }

      if (v37 == -6764)
      {
        uint64_t v89 = *(int **)(a1 + 16);
        int v10 = a4;
        if (*v89 <= 50)
        {
          if (*v89 == -1)
          {
            uint64_t v89 = *(int **)(a1 + 16);
          }

          LogPrintF( (uint64_t)v89,  (uint64_t)"OSStatus _SetupServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"### Pair-setup server disabled after too many attempts\n",  (uint64_t)a5,  a6,  a7,  a8,  v179);
        }

LABEL_263:
        __s[0] = 6;
        unsigned int v110 = TLV8BufferAppend((uint64_t)&__src, 7, __s, 1uLL);
LABEL_264:
        unsigned int appended = v110;
        if (v110) {
          goto LABEL_266;
        }
        __s[0] = 2;
        unsigned int appended = TLV8BufferAppend((uint64_t)&__src, 6, __s, 1uLL);
        if (appended) {
          goto LABEL_266;
        }
        size_t v127 = v206;
        v128 = (UInt8 *)v207;
        if (!v207)
        {
          else {
            size_t v129 = v206;
          }
          BOOL v130 = (UInt8 *)malloc(v129);
          if (!v130)
          {
            unsigned int v34 = -6728;
            int v10 = a4;
            goto LABEL_51;
          }

          v128 = v130;
          if (v127) {
            memcpy(v130, __src, v127);
          }
        }

        unsigned int v34 = 0;
        __srCC_SHA1_CTX c = v208;
        *(void *)&__int128 v206 = 0LL;
        v207 = 0LL;
        *a4 = v128;
        int v10 = a4;
        *a5 = v127;
LABEL_51:
        uint64_t v31 = 0LL;
        uint64_t v32 = 0LL;
        LOBYTE(v33) = 0;
        goto LABEL_114;
      }
    }

    *(_BYTE *)(a1 + 120) = 2;
    if (*(void *)(a1 + 384) && *(void *)(a1 + 392))
    {
LABEL_178:
      uint64_t v91 = *(void **)(a1 + 696);
      if (v91)
      {
        SRPDelete_libsrp(v91);
        *(void *)(a1 + 696) = 0LL;
      }

      uint64_t v92 = (uint64_t *)calloc(1uLL, 0x38uLL);
      if (v92)
      {
        *(void *)(a1 + 696) = v92;
        unsigned int appended = 0;
        unsigned int appended = SRPServerStart_libsrp( v92,  &_kSRPParameters_3072_SHA512,  "Pair-Setup",  10LL,  *(const char **)(a1 + 384),  *(void *)(a1 + 392),  0x10uLL,  v199,  &v195,  &v194);
        if (!appended)
        {
          unsigned int appended = TLV8BufferAppend((uint64_t)&__src, 6, (char *)(a1 + 120), 1uLL);
          if (!appended)
          {
            unsigned int appended = TLV8BufferAppend((uint64_t)&__src, 2, v199, 0x10uLL);
            int v10 = a4;
            if (appended) {
              goto LABEL_266;
            }
            unsigned int appended = TLV8BufferAppend((uint64_t)&__src, 3, (char *)v195, v194);
            if (appended) {
              goto LABEL_266;
            }
            unint64_t v93 = *(_DWORD *)(a1 + 100) & 0x40000200;
            if ((_DWORD)v93)
            {
              unsigned int appended = TLV8BufferAppendUInt64((uint64_t)&__src, 19, v93);
              if (appended) {
                goto LABEL_266;
              }
            }

            unint64_t Int64Ranged = CFDictionaryGetInt64Ranged( *(const __CFDictionary **)(a1 + 344),  @"setupCodeType",  0LL,  0xFFFFFFFFLL,  0LL);
            if (!Int64Ranged || (unsigned int appended = TLV8BufferAppendUInt64((uint64_t)&__src, 27, Int64Ranged)) == 0)
            {
              size_t v95 = v206;
              int v96 = (UInt8 *)v207;
              if (v207)
              {
LABEL_196:
                __srCC_SHA1_CTX c = v208;
                *(void *)&__int128 v206 = 0LL;
                v207 = 0LL;
                *a4 = v96;
                int v10 = a4;
                *a5 = v95;
                unsigned int appended = 0;
                *(_BYTE *)(a1 + 120) = 3;
                unsigned int v99 = *(int **)(a1 + 16);
                int v100 = *v99;
                if (*v99 > 30)
                {
LABEL_402:
                  uint64_t v31 = 0LL;
                  LOBYTE(v33) = 0;
                  goto LABEL_316;
                }

                if (v100 != -1)
                {
LABEL_198:
                  char v101 = v100 > 10 || v100 == -1 && !_LogCategory_Initialize((uint64_t)v99, 0xAu);
                  int v10 = a4;
                  LogPrintF( (uint64_t)v99,  (uint64_t)"OSStatus _SetupServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)"Pair-setup server M2 -- start response\n%?{end}%1{tlv8}\n",  (uint64_t)a5,  a6,  a7,  a8,  v101);
                  goto LABEL_402;
                }

                if (_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu))
                {
                  unsigned int v99 = *(int **)(a1 + 16);
                  int v100 = *v99;
                  goto LABEL_198;
                }

                uint64_t v31 = 0LL;
                LOBYTE(v33) = 0;
                goto LABEL_313;
              }

              else {
                size_t v97 = v206;
              }
              size_t v98 = (UInt8 *)malloc(v97);
              if (v98)
              {
                int v96 = v98;
                if (v95) {
                  memcpy(v98, __src, v95);
                }
                goto LABEL_196;
              }

              goto LABEL_391;
            }
          }
        }

        goto LABEL_68;
      }

    uint64_t v46 = 0LL;
    uint64_t v42 = 0LL;
    goto LABEL_64;
  }

  if (v14 != 1)
  {
    unsigned int v37 = *(int **)(a1 + 16);
    if (*v37 <= 60)
    {
      if (*v37 == -1)
      {
        unsigned int v37 = *(int **)(a1 + 16);
        LOBYTE(v14) = *(_BYTE *)(a1 + 120);
      }

      LogPrintF( (uint64_t)v37,  (uint64_t)"OSStatus _VerifyClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x3Cu,  (uint64_t)"### Pair-verify client bad state: %d\n",  a5,  a6,  a7,  a8,  v14);
    }

LABEL_391:
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
LABEL_392:
      LOBYTE(v33) = 0;
      unsigned int v115 = -6728;
      goto LABEL_284;
    }

    int v90 = *(uint64_t (**)(void, char *, uint64_t, void))(a1 + 32);
    if (!v90)
    {
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
      LOBYTE(v33) = 0;
      unsigned int v115 = -6745;
      goto LABEL_284;
    }

    unsigned int appended = v90(*(unsigned int *)(a1 + 684), __s, 64LL, *(void *)(a1 + 24));
    if (appended)
    {
LABEL_68:
      uint64_t v31 = 0LL;
      goto LABEL_81;
    }

    *(_BYTE *)(a1 + 413) = 1;
    if (strlen(__s) > 3)
    {
      unsigned int appended = ReplaceString((void **)(a1 + 384), (size_t *)(a1 + 392), __s, 0xFFFFFFFFFFFFFFFFLL);
      if (!appended) {
        goto LABEL_178;
      }
      goto LABEL_68;
    }

    uint64_t v31 = 0LL;
LABEL_399:
    uint64_t v32 = 0LL;
    LOBYTE(v33) = 0;
    unsigned int v115 = -6743;
    goto LABEL_284;
  }

  size_t v36 = *(int **)(a1 + 16);
  int v10 = a4;
  if (*v36 <= 50)
  {
    if (*v36 != -1) {
      goto LABEL_58;
    }
    if (_LogCategory_Initialize((uint64_t)v36, 0x32u))
    {
      size_t v36 = *(int **)(a1 + 16);
      char v35 = __dst;
LABEL_58:
      LogPrintF( (uint64_t)v36,  (uint64_t)"OSStatus _SetupServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"### Pair-setup server unsupported method: %u\n",  (uint64_t)a5,  a6,  a7,  a8,  v35);
    }
  }

  uint64_t v31 = 0LL;
  uint64_t v32 = 0LL;
  LOBYTE(v33) = 0;
  unsigned int v34 = -6735;
LABEL_114:
  unsigned int appended = v34;
LABEL_115:
  if (a5 && v10 && !appended) {
    _PairingSessionUpdateTranscript(a1, a2, a3, *v10, *a5);
  }
  _BYTE *v8 = (_BYTE)v33;
  if (v207)
  {
    free(v207);
    v207 = 0LL;
  }

  if (v203)
  {
    free(v203);
    v203 = 0LL;
  }

  if (v31) {
    free(v31);
  }
  if (v32) {
    free(v32);
  }
  if (v195) {
    free(v195);
  }
  if (v193) {
    free(v193);
  }
  if (v190) {
    free(v190);
  }
  if (v189) {
    free(v189);
  }
  uint64_t v70 = appended;
  if (appended != -6771)
  {
    if (appended)
    {
      unint64_t v71 = *(int **)(a1 + 16);
      int v72 = *v71;
      if (*v71 <= 50)
      {
        if (v72 != -1) {
          goto LABEL_139;
        }
        BOOL v74 = _LogCategory_Initialize(*(void *)(a1 + 16), 0x32u);
        uint64_t v70 = appended;
        if (v74)
        {
          unint64_t v71 = *(int **)(a1 + 16);
          int v72 = *v71;
LABEL_139:
          char v73 = *(_BYTE *)(a1 + 120);
          if (v72 == -1) {
            _LogCategory_Initialize((uint64_t)v71, 0x28u);
          }
          LogPrintF( (uint64_t)v71,  (uint64_t)"OSStatus _SetupServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"### Pair-setup server state %d failed: %#m\n%?{end}%1{tlv8}\n",  (uint64_t)a5,  a6,  a7,  a8,  v73);
          return appended;
        }
      }
    }
  }

  return v70;
}

uint64_t _VerifyClientExchange( uint64_t a1, unsigned __int8 *a2, uint64_t a3, UInt8 **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id v8 = (_BYTE *)a6;
  size_t v9 = (CFIndex *)a5;
  uint64_t v188 = *MEMORY[0x1895F89C0];
  uint64_t v15 = a1 + 120;
  int v14 = *(unsigned __int8 *)(a1 + 120);
  if (!*(_BYTE *)(a1 + 120))
  {
    int v14 = 1;
    *(_BYTE *)uint64_t v15 = 1;
  }

  unint64_t v16 = (unint64_t)&a2[a3];
  if (a3)
  {
    CFIndex v17 = a2;
    do
    {
      if (v16 - (unint64_t)v17 < 2)
      {
LABEL_55:
        uint64_t appended = 4294960569LL;
        goto LABEL_104;
      }

      int v18 = v17 + 2;
      uint64_t v19 = v17[1];
      if ((unint64_t)&v17[v19 + 2] > v16)
      {
        uint64_t appended = 4294960546LL;
        goto LABEL_104;
      }

      int v20 = *v17;
      v17 += v19 + 2;
    }

    while (v20 != 6);
    if ((_DWORD)v19 != 1)
    {
      uint64_t appended = 4294960553LL;
      goto LABEL_104;
    }

    if (*v18 != v14) {
      goto LABEL_52;
    }
  }

  if (v14 == 4)
  {
    *(_OWORD *)&__src[8] = xmmword_186B49CC0;
    *(void *)__srCC_SHA1_CTX c = v187;
    *(void *)&__src[24] = 0LL;
    unsigned int v34 = *(int **)(a1 + 16);
    int v35 = *v34;
    if (*v34 <= 30)
    {
      if (v35 != -1)
      {
LABEL_41:
        BOOL v36 = v35 <= 10 && (v35 != -1 || _LogCategory_Initialize((uint64_t)v34, 0xAu));
        LogPrintF( (uint64_t)v34,  (uint64_t)"OSStatus _VerifyClientM4(PairingSessionRef, const uint8_t *const, const uint8_t *const)",  0x1Eu,  (uint64_t)"Pair-verify client M4 -- finish response\n%?{end}%1{tlv8}\n",  a5,  a6,  a7,  a8,  !v36);
        goto LABEL_87;
      }

      if (_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu))
      {
        unsigned int v34 = *(int **)(a1 + 16);
        int v35 = *v34;
        goto LABEL_41;
      }
    }

LABEL_223:
      uint64_t appended = 0LL;
      if (!v65)
      {
LABEL_225:
        if (*(void *)&__src[24]) {
          free(*(void **)&__src[24]);
        }
        if ((_DWORD)appended) {
          goto LABEL_104;
        }
        int *v27 = 0LL;
        *size_t v9 = 0LL;
        char v47 = 1;
        if (v27) {
          goto LABEL_75;
        }
        goto LABEL_77;
      }

        if (v36 == 2 && v18 >= 2)
        {
          *(void *)__format = &__str;
          if ((v20 & 8) == 0)
          {
            if (v30 == 1)
            {
              int v28 = 16LL;
            }

            else if (v30 == 2)
            {
              int v28 = 8LL;
            }

            else if (((v31 - 1) & 0xFE) != 0)
            {
              int v28 = 32LL;
            }

            else
            {
              int v28 = 64LL;
            }

LABEL_224:
      free(v65);
      goto LABEL_225;
    }

    char v163 = v8;
    *(void *)__s = 0LL;
    size_t v64 = (int8x16_t *)TLV8CopyCoalesced(a2, &a2[a3], 5, (size_t *)__s, 0LL);
    size_t v65 = v64;
    uint64_t v66 = 0LL;
    if (v64 && *(void *)__s)
    {
      a7 = *(void *)__s - 16LL;
      if (*(void *)__s < 0x10uLL)
      {
        uint64_t appended = 4294960553LL;
        goto LABEL_294;
      }

      uint64_t v66 = &v64->u8[a7];
      uint64_t v67 = _chacha20_poly1305_decrypt_all( (_DWORD *)(a1 + 414),  v63,  8LL,  0LL,  0LL,  v64,  a7,  v64,  (uint64_t)v64->i64 + a7,  16LL);
      if ((_DWORD)v67)
      {
        uint64_t appended = v67;
        id v8 = v163;
        int v27 = v61;
        goto LABEL_224;
      }
    }

    if ((*(_BYTE *)(a1 + 103) & 0x20) == 0
      || (uint64_t GroupInfoTLV = _PairingSessionAppleIDVerifyPeer(a1, (unsigned __int8 *)v65, v66), !(_DWORD)GroupInfoTLV))
    {
      uint64_t GroupInfoTLV = _ExtractGroupInfoTLV(a1, (unsigned __int8 *)v65, v66);
      if (!(_DWORD)GroupInfoTLV)
      {
        int v27 = v61;
        id v8 = v163;
        goto LABEL_139;
      }
    }

    uint64_t appended = GroupInfoTLV;
LABEL_294:
    id v8 = v163;
    int v27 = v61;
    if (!v65) {
      goto LABEL_225;
    }
    goto LABEL_224;
  }

  if (v14 == 2)
  {
    CFTypeRef cf = 0LL;
    v176 = v179;
    __int128 v177 = xmmword_186B49CC0;
    BOOL v178 = 0LL;
    uint64_t v31 = *(int **)(a1 + 16);
    int v32 = *v31;
    if (*v31 > 30) {
      goto LABEL_58;
    }
    if (v32 == -1)
    {
      if (!_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu)) {
        goto LABEL_58;
      }
      uint64_t v31 = *(int **)(a1 + 16);
      int v32 = *v31;
    }

    BOOL v33 = v32 <= 10 && (v32 != -1 || _LogCategory_Initialize((uint64_t)v31, 0xAu));
    LogPrintF( (uint64_t)v31,  (uint64_t)"OSStatus _VerifyClientM2(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *)",  0x1Eu,  (uint64_t)"Pair-verify client M2 -- start response\n%?{end}%1{tlv8}\n",  a5,  a6,  a7,  a8,  !v33);
LABEL_58:
    unint64_t v166 = v9;
    unsigned int v38 = (_OWORD *)(a1 + 574);
    unsigned int Bytes = TLV8GetBytes(a2, &a2[a3], 3, 0x20uLL, 0x20uLL, (char *)(a1 + 574), 0LL, 0LL);
    unsigned int v173 = Bytes;
    size_t v169 = a4;
    if (!Bytes)
    {
      cccurve25519();
      int8x16_t v40 = vorrq_s8(*(int8x16_t *)(v15 + 534), *(int8x16_t *)(v15 + 518));
      if (vorr_s8(*(int8x8_t *)v40.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL)))
      {
        char v167 = (_DWORD *)(a1 + 414);
        CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  v15 + 518,  32LL,  "Pair-Verify-Encrypt-Salt",  0x18uLL,  (uint64_t)"Pair-Verify-Encrypt-Info",  24LL,  0x20uLL,  a1 + 414);
        BOOL v41 = (int8x16_t *)TLV8CopyCoalesced(a2, &a2[a3], 5, &v172, (int *)&v173);
        uint64_t v42 = (unsigned __int8 *)v41;
        char v43 = v173;
        if (v173)
        {
          v153 = *(int **)(a1 + 16);
          if (*v153 <= 90)
          {
            if (*v153 == -1)
            {
              v153 = *(int **)(a1 + 16);
              char v43 = v173;
            }

            LogPrintF( (uint64_t)v153,  (uint64_t)"OSStatus _VerifyClientM2(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *)",  0x5Au,  (uint64_t)"### Pair-verify client M2 failed: get encrypted data, %#m\n",  a5,  a6,  a7,  a8,  v43);
          }

          goto LABEL_63;
        }

        size_t v44 = v172;
        if (v172 > 0xF)
        {
          v172 -= 16LL;
          uint64_t v45 = &v41[-1].u8[v44];
          unsigned int v173 = _chacha20_poly1305_decrypt_all(v167, "PV-Msg02", 8LL, 0LL, 0LL, v41, v172, v41, (uint64_t)v45, 16LL);
          if (v173) {
            goto LABEL_63;
          }
          *(void *)(a1 + 200) = TLV8GetUInt64(v42, v45, 25, 0LL, 0LL);
          int v48 = *(_DWORD *)(a1 + 100);
          if ((v48 & 0x1000) != 0)
          {
            if ((v48 & 0x20200000) == 0)
            {
              unsigned int v173 = _PairingSessionAppleIDVerifyPeer(a1, v42, v45);
              if (v173) {
                goto LABEL_63;
              }
            }

LABEL_237:
              uint64_t v46 = 0LL;
              goto LABEL_65;
            }

            int v96 = *(const void **)(a1 + 272);
            if (v96) {
              CFRelease(v96);
            }
            *(void *)(a1 + 272) = cf;
            CFTypeRef cf = 0LL;
            size_t v97 = TLV8CopyCoalesced(v42, v45, 29, (size_t *)&v171, 0LL);
            if (v97)
            {
              size_t v98 = v97;
              unsigned int v99 = (__CFString *)_OPACKDecodeBytes(0LL, v97, v171, 0, &v173);
              free(v98);
              if (!v99) {
                goto LABEL_63;
              }
              CFTypeID v100 = CFGetTypeID(v99);
              if (v100 != CFDictionaryGetTypeID())
              {
                unsigned int v173 = -6756;
                CFRelease(v99);
                goto LABEL_63;
              }

              PairingSessionSetProperty(a1, @"appInfoPeer", v99);
              CFRelease(v99);
            }

            size_t v165 = v8;
            *(_BYTE *)(a1 + 120) = 3;
            *(_OWORD *)&__src[8] = xmmword_186B49CC0;
            *(void *)__srCC_SHA1_CTX c = v187;
            *(void *)&__src[24] = 0LL;
            *(void *)__s = &v185;
            __int128 v183 = xmmword_186B49CC0;
            v184 = 0LL;
            int v101 = *(_DWORD *)(a1 + 100);
            if ((v101 & 0x1000) != 0)
            {
              if ((v101 & 0x100000) == 0)
              {
                int v124 = _PairingSessionAppleIDProveSelf(a1, (uint64_t)__s);
LABEL_195:
                int v174 = v124;
                if (v124) {
                  goto LABEL_240;
                }
              }
            }

            else
            {
              uint64_t v102 = *(const void **)(a1 + 944);
              if (!v102)
              {
LABEL_169:
                uint64_t v112 = *(void **)(a1 + 184);
                if (v112)
                {
                  free(v112);
                  *(void *)(a1 + 184) = 0LL;
                }

                *(void *)(a1 + 192) = 0LL;
                int v174 = PairingSessionCopyIdentity(a1, 0LL, (char **)(a1 + 184), (_OWORD *)(a1 + 510), a1 + 542);
                if (v174) {
                  goto LABEL_240;
                }
                size_t v113 = *(const char **)(a1 + 184);
                size_t v114 = strlen(v113);
                *(void *)(a1 + 192) = v114;
                if (!v114)
                {
                  int v160 = -6708;
                  goto LABEL_285;
                }

                size_t v115 = v114;
                int v162 = v42;
                size_t v116 = v114 + 64;
                size_t v117 = malloc(v114 + 64);
                if (!v117)
                {
                  int v174 = -6728;
                  goto LABEL_240;
                }

                int v118 = v117;
                __int128 v119 = *(_OWORD *)(a1 + 462);
                *size_t v117 = *(_OWORD *)(a1 + 446);
                v117[1] = v119;
                unsigned int v120 = v117 + 2;
                memcpy(v117 + 2, v113, v115);
                uint64_t v121 = (_OWORD *)((char *)v120 + v115);
                __int128 v122 = *(_OWORD *)(a1 + 590);
                _OWORD *v121 = *v38;
                v121[1] = v122;
                uint64_t v123 = *(void (**)(void, void *, size_t, char *, void))(a1 + 928);
                if (v123)
                {
                  v123(*(unsigned int *)(a1 + 100), v118, v116, v181, *(void *)(a1 + 936));
                }

                else
                {
                  ccsha512_di();
                  cced25519_sign();
                }

                uint64_t v42 = v162;
                free(v118);
                int v174 = TLV8BufferAppend((uint64_t)__s, 1, *(char **)(a1 + 184), *(void *)(a1 + 192));
                if (v174) {
                  goto LABEL_240;
                }
                int v124 = TLV8BufferAppend((uint64_t)__s, 10, v181, 0x40uLL);
                goto LABEL_195;
              }

              uint64_t v103 = _Block_copy(v102);
              __int128 v104 = *(_OWORD *)(a1 + 462);
              v180[0] = *(_OWORD *)(a1 + 446);
              v180[1] = v104;
              __int128 v105 = *(_OWORD *)(a1 + 590);
              v180[2] = *v38;
              v180[3] = v105;
              int v106 = (*((uint64_t (**)(void *, void, _OWORD *, uint64_t, char *))v103 + 2))( v103,  *(unsigned int *)(a1 + 100),  v180,  64LL,  v181);
              int v174 = v106;
              if (v106)
              {
                char v111 = v106;
                if (v106 == -6714)
                {

                  goto LABEL_169;
                }

                BOOL v149 = *(int **)(a1 + 16);
                if (*v149 <= 90)
                {
                  if (*v149 == -1)
                  {
                    BOOL v149 = *(int **)(a1 + 16);
                  }

                  LogPrintF( (uint64_t)v149,  (uint64_t)"OSStatus _VerifyClientM3(PairingSessionRef, uint8_t **, size_t *)",  0x5Au,  (uint64_t)"### Pair-verify client M3 sign failed: %#m\n",  v107,  v108,  v109,  v110,  v111);
                }

LABEL_239:
                goto LABEL_240;
              }

              int v148 = TLV8BufferAppend((uint64_t)__s, 10, v181, 0x40uLL);
              int v174 = v148;

              if (v148) {
                goto LABEL_240;
              }
            }

            BOOL v130 = *(const __CFDictionary **)(a1 + 344);
            CFTypeID TypeID = CFDictionaryGetTypeID();
            TypedValue = (const __CFString *)CFDictionaryGetTypedValue(v130, @"appInfoSelf", TypeID, 0LL);
            if (TypedValue)
            {
              uint64_t v133 = OPACKEncoderCreateDataMutable(TypedValue, 0, &v174);
              if (!v133) {
                goto LABEL_240;
              }
              uint64_t v134 = v133;
              BytePtr = (char *)CFDataGetBytePtr(v133);
              size_t Length = CFDataGetLength(v134);
              int v174 = TLV8BufferAppend((uint64_t)__s, 29, BytePtr, Length);
              CFRelease(v134);
              if (v174) {
                goto LABEL_240;
              }
            }

            int v174 = _AddGroupInfoTLV(a1, (uint64_t)__s);
            if (v174) {
              goto LABEL_240;
            }
            unint64_t v137 = v183;
            int v138 = (int8x16_t *)malloc(v183 + 16);
            if (v138)
            {
              uint64_t v139 = (char *)v138;
              _chacha20_poly1305_encrypt_all( v167,  "PV-Msg03",  8LL,  0LL,  0LL,  *(int8x16_t **)__s,  v137,  v138,  (uint64_t)v138->i64 + v137);
              int v140 = TLV8BufferAppend((uint64_t)__src, 5, v139, v183 + 16);
              int v174 = v140;
              free(v139);
              if (v140) {
                goto LABEL_240;
              }
              int v174 = TLV8BufferAppend((uint64_t)__src, 6, (char *)v15, 1uLL);
              if (v174) {
                goto LABEL_240;
              }
              size_t v141 = *(void *)&__src[8];
              uint64_t v142 = *(UInt8 **)&__src[24];
              if (*(void *)&__src[24]) {
                goto LABEL_210;
              }
              if (*(void *)&__src[8] <= 1uLL) {
                size_t v143 = 1LL;
              }
              else {
                size_t v143 = *(void *)&__src[8];
              }
              size_t v144 = (UInt8 *)malloc(v143);
              if (v144)
              {
                uint64_t v142 = v144;
                if (v141) {
                  memcpy(v144, *(const void **)__src, v141);
                }
LABEL_210:
                *(void *)__srCC_SHA1_CTX c = v187;
                *(void *)&__src[8] = 0LL;
                *(void *)&__src[24] = 0LL;
                *size_t v169 = v142;
                CFIndex *v166 = v141;
                int v174 = 0;
                *(_BYTE *)(a1 + 120) = 4;
                unsigned __int8 v145 = *(int **)(a1 + 16);
                int v146 = *v145;
                if (*v145 <= 30)
                {
                  if (v146 != -1)
                  {
LABEL_212:
                    char v147 = v146 > 10 || v146 == -1 && !_LogCategory_Initialize((uint64_t)v145, 0xAu);
                    LogPrintF( (uint64_t)v145,  (uint64_t)"OSStatus _VerifyClientM3(PairingSessionRef, uint8_t **, size_t *)",  0x1Eu,  (uint64_t)"Pair-verify client M3 -- finish request\n%?{end}%1{tlv8}\n",  a5,  a6,  a7,  a8,  v147);
                    goto LABEL_240;
                  }

                  if (_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu))
                  {
                    unsigned __int8 v145 = *(int **)(a1 + 16);
                    int v146 = *v145;
                    goto LABEL_212;
                  }
                }

LABEL_240:
                if (v184)
                {
                  free(v184);
                  v184 = 0LL;
                }

                id v8 = v165;
                if (*(void *)&__src[24]) {
                  free(*(void **)&__src[24]);
                }
                uint64_t v46 = 0LL;
                int v150 = v174;
                goto LABEL_245;
              }
            }

            int v160 = -6728;
LABEL_285:
            int v174 = v160;
            goto LABEL_240;
          }

          int v49 = *(const void **)(a1 + 952);
          if (v49)
          {
            int v50 = _Block_copy(v49);
            unsigned int v173 = TLV8GetBytes(v42, v45, 10, 0x40uLL, 0x40uLL, __dst, 0LL, 0LL);
            if (v173)
            {

              goto LABEL_63;
            }

            __int128 v68 = *v38;
            *(_OWORD *)&__src[16] = *(_OWORD *)(a1 + 590);
            *(_OWORD *)__srCC_SHA1_CTX c = v68;
            __int128 v69 = *(_OWORD *)(a1 + 462);
            v187[0] = *(_OWORD *)(a1 + 446);
            v187[1] = v69;
            unsigned int v70 = (*((uint64_t (**)(void *, void, _BYTE *, uint64_t, char *))v50 + 2))( v50,  *(unsigned int *)(a1 + 100),  __src,  64LL,  __dst);
            unsigned int v173 = v70;
            if (v70 != -6714)
            {
              if (!v70)
              {

                goto LABEL_154;
              }

              size_t v129 = *(int **)(a1 + 16);
              size_t v9 = v166;
              if (*v129 <= 90)
              {
                if (*v129 == -1)
                {
                  if (!_LogCategory_Initialize(*(void *)(a1 + 16), 0x5Au)) {
                    goto LABEL_236;
                  }
                  size_t v129 = *(int **)(a1 + 16);
                  LOBYTE(v70) = v173;
                }

                LogPrintF( (uint64_t)v129,  (uint64_t)"OSStatus _VerifyClientM2(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8 _t **, size_t *)",  0x5Au,  (uint64_t)"### Pair-verify client M2 verify signature failed: %#m\n",  v71,  v72,  v73,  v74,  v70);
              }

        if (v5 < v48)
        {
          unsigned int v79 = *v5;
          if (v79 == 45 || v79 == 43) {
            ++v5;
          }
        }

        if (v5 < v48)
        {
          unsigned int v80 = v48 - v5;
          while (*v5 - 48 <= 9)
          {
            ++v5;
            if (!--v80)
            {
              uint64_t v5 = v48;
              break;
            }
          }
        }

        __memcpy_chk();
        v125[v5 - v13] = 0;
        if (sscanf(v125, "%lf", &v123) != 1) {
          return v120;
        }
        if ((_DWORD)v21) {
          continue;
        }
        CFTypeID v81 = (double **)v124;
        v124 += 2;
        size_t v82 = *v81;
        if (!v82) {
          return v120;
        }
        if (v121)
        {
          if (v121 != 108) {
            return v120;
          }
          *size_t v82 = v123;
        }

        else
        {
          size_t v115 = v123;
          *(float *)size_t v82 = v115;
        }

        goto LABEL_211;
      case 'i':
        int v35 = 0;
        BOOL v36 = 0;
        unsigned int v37 = 0LL;
        unsigned int v34 = 1;
        goto LABEL_106;
      case 'n':
        if (v28 || v24 != 0x7FFFFFFF || (_DWORD)v21) {
          return v120;
        }
        unsigned int v51 = (char ***)v124;
        v124 += 2;
        unint64_t v52 = *v51;
        if (v16)
        {
          if (v52)
          {
            _BYTE *v52 = v13;
            uint64_t v5 = v13;
            continue;
          }
        }

        else if (v52)
        {
          *(_DWORD *)unint64_t v52 = (_DWORD)v13 - v119;
          uint64_t v5 = v13;
          continue;
        }

        return v120;
      case 'o':
        unsigned int v34 = 0;
        int v35 = 0;
        BOOL v36 = 0;
        unsigned int v37 = 8LL;
        goto LABEL_106;
      case 'p':
        uint64_t v53 = v28;
        if (!v28) {
          uint64_t v53 = 112;
        }
        uint64_t v121 = v53;
        goto LABEL_105;
      case 's':
        if (v28) {
          return v120;
        }
        if (v13 >= v122) {
          goto LABEL_184;
        }
        __int128 v68 = v18;
        __int128 v69 = v122 - v13;
        uint64_t v5 = v13;
        do
        {
          unsigned int v70 = *v5;
          if (*v5 < 0)
          {
            if (!__maskrune(v70, 0x4000uLL))
            {
LABEL_258:
              if (!v16)
              {
                int v18 = v68;
                if (*v5) {
                  goto LABEL_185;
                }
                return v120;
              }

              int v18 = v68;
              if ((_DWORD)v21) {
                goto LABEL_186;
              }
              goto LABEL_260;
            }
          }

          else if ((*(_DWORD *)(v6 + 4 * v70 + 60) & 0x4000) == 0)
          {
            goto LABEL_258;
          }

          ++v5;
          --v69;
        }

        while (v69);
        CFIndex v13 = v122;
        int v18 = v68;
LABEL_184:
        uint64_t v5 = v13;
        if (!v16) {
          return v120;
        }
LABEL_185:
        if ((_DWORD)v21)
        {
LABEL_186:
          if (v5 < v122)
          {
            uint64_t v71 = v122 - v5;
            while (1)
            {
              uint64_t v72 = *v5;
              if (!*v5) {
                break;
              }
              uint64_t v73 = (v72 & 0x80) != 0 ? __maskrune(v72, 0x4000uLL) : *(_DWORD *)(v6 + 4 * v72 + 60) & 0x4000;
              if (v73 || v24 < 1) {
                break;
              }
              --v24;
              ++v5;
              if (!--v71)
              {
                uint64_t v5 = v122;
                goto LABEL_4;
              }
            }
          }

          continue;
        }

LABEL_236:
              goto LABEL_237;
            }
          }

          unsigned int v80 = *(void **)(a1 + 296);
          if (v80)
          {
            free(v80);
            *(void *)(a1 + 296) = 0LL;
          }

          CFTypeID v81 = (size_t *)(a1 + 304);
          *(void *)(a1 + 304) = 0LL;
          size_t v82 = TLV8CopyCoalesced(v42, v45, 1, (size_t *)(a1 + 304), (int *)&v173);
          *(void *)(a1 + 296) = v82;
          char v83 = v173;
          if (v173)
          {
            size_t v154 = *(int **)(a1 + 16);
            if (*v154 <= 90)
            {
              if (*v154 == -1)
              {
                size_t v154 = *(int **)(a1 + 16);
                char v83 = v173;
              }

              LogPrintF( (uint64_t)v154,  (uint64_t)"OSStatus _VerifyClientM2(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *)",  0x5Au,  (uint64_t)"### Pair-verify client M2 failed: get identifier failed, %#m\n",  a5,  a6,  a7,  a8,  v83);
            }

            goto LABEL_63;
          }

          if (*v81)
          {
            unsigned int Peer = PairingSessionFindPeerEx(a1, (char *)v82, *v81, (_OWORD *)(a1 + 606), &cf, a6, a7, a8);
            unsigned int v173 = Peer;
            if (!Peer)
            {
              CFTypeID v164 = v8;
              unsigned int v85 = TLV8GetBytes(v42, v45, 10, 0x40uLL, 0x40uLL, __dst, 0LL, 0LL);
              unsigned int v173 = v85;
              if (!v85)
              {
                size_t v86 = *v81;
                uint64_t v171 = *v81 + 64;
                uint64_t v87 = (char *)malloc(v171);
                uint64_t v46 = v87;
                if (v87)
                {
                  __int128 v88 = *(_OWORD *)(a1 + 590);
                  *(_OWORD *)uint64_t v87 = *v38;
                  *((_OWORD *)v87 + 1) = v88;
                  memcpy(v87 + 32, *(const void **)(a1 + 296), v86);
                  uint64_t v89 = &v46[v86 + 32];
                  __int128 v90 = *(_OWORD *)(a1 + 462);
                  *(_OWORD *)uint64_t v89 = *(_OWORD *)(a1 + 446);
                  *((_OWORD *)v89 + 1) = v90;
                  ccsha512_di();
                  unsigned int v173 = cced25519_verify();
                  if (!v173)
                  {
                    free(v46);
                    id v8 = v164;
                    goto LABEL_154;
                  }

                  unsigned int v159 = -6754;
                }

                else
                {
                  unsigned int v159 = -6728;
                }

                unsigned int v173 = v159;
                id v8 = v164;
                goto LABEL_64;
              }

              char v157 = v85;
              size_t v158 = *(int **)(a1 + 16);
              if (*v158 <= 90)
              {
                if (*v158 == -1)
                {
                  size_t v158 = *(int **)(a1 + 16);
                  char v157 = v173;
                }

                LogPrintF( (uint64_t)v158,  (uint64_t)"OSStatus _VerifyClientM2(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8 _t **, size_t *)",  0x5Au,  (uint64_t)"### Pair-verify client M2 failed: get signature failed, %#m\n",  a5,  a6,  a7,  a8,  v157);
              }

LABEL_292:
              uint64_t v46 = 0LL;
              goto LABEL_64;
            }

            char v155 = Peer;
            __int128 v156 = *(int **)(a1 + 16);
            if (*v156 <= 90)
            {
              if (*v156 == -1)
              {
                __int128 v156 = *(int **)(a1 + 16);
                char v155 = v173;
              }

              LogPrintF( (uint64_t)v156,  (uint64_t)"OSStatus _VerifyClientM2(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *)",  0x5Au,  (uint64_t)"### Pair-verify client M2 failed: find peer failed, %#m\n",  a5,  a6,  a7,  a8,  v155);
            }

LABEL_245:
      unsigned int v173 = v150;
      goto LABEL_64;
    }

    char v151 = Bytes;
    size_t v152 = *(int **)(a1 + 16);
    if (*v152 <= 90)
    {
      if (*v152 == -1)
      {
        size_t v152 = *(int **)(a1 + 16);
        char v151 = v173;
      }

      LogPrintF( (uint64_t)v152,  (uint64_t)"OSStatus _VerifyClientM2(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *)",  0x5Au,  (uint64_t)"### Pair-verify client M2 failed: get PK, %#m\n",  a5,  a6,  a7,  a8,  v151);
    }

LABEL_104:
  _BYTE *v8 = 0;
  uint64_t v57 = *(int **)(a1 + 16);
  int v58 = *v57;
  if (*v57 <= 50)
  {
    if (v58 == -1)
    {
      if (!_LogCategory_Initialize(*(void *)(a1 + 16), 0x32u)) {
        return appended;
      }
      uint64_t v57 = *(int **)(a1 + 16);
      int v58 = *v57;
    }

    char v59 = *(_BYTE *)v15;
    if (v58 == -1) {
      _LogCategory_Initialize((uint64_t)v57, 0x28u);
    }
    LogPrintF( (uint64_t)v57,  (uint64_t)"OSStatus _VerifyClientExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x32u,  (uint64_t)"### Pair-verify client state %d failed: %#m\n%?{end}%1{tlv8}\n",  a5,  a6,  a7,  a8,  v59);
  }

  return appended;
}

uint64_t _VerifyServerExchange( uint64_t a1, unsigned __int8 *a2, CFIndex a3, UInt8 **a4, size_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id v8 = (_BYTE *)a6;
  v180[38] = *MEMORY[0x1895F89C0];
  __int128 v11 = (int8x16_t *)(a1 + 638);
  int v12 = &a2[a3];
  CFIndex v13 = a2;
  do
  {
    if (v13 == v12)
    {
LABEL_36:
      CFTypeID v164 = (_BYTE *)a6;
      BOOL v26 = 0;
      int v27 = 0;
      uint64_t appended = 4294960569LL;
      goto LABEL_112;
    }

    if (v13 >= v12)
    {
      CFTypeID v164 = (_BYTE *)a6;
      BOOL v26 = 0;
      int v27 = 0;
      uint64_t appended = 4294960591LL;
      goto LABEL_112;
    }

    int v14 = v13 + 2;
    uint64_t v15 = v13[1];
    if (&v13[v15 + 2] > v12)
    {
      CFTypeID v164 = (_BYTE *)a6;
      BOOL v26 = 0;
      int v27 = 0;
      uint64_t appended = 4294960546LL;
      goto LABEL_112;
    }

    int v16 = *v13;
    v13 += v15 + 2;
  }

  while (v16 != 6);
  if ((_DWORD)v15 != 1)
  {
    CFTypeID v164 = (_BYTE *)a6;
    BOOL v26 = 0;
    int v27 = 0;
    uint64_t appended = 4294960553LL;
    goto LABEL_112;
  }

  if (*v14 == 1) {
    _PairingSessionReset(a1);
  }
  int v18 = (_BYTE *)(a1 + 120);
  int v17 = *(unsigned __int8 *)(a1 + 120);
  if (!*(_BYTE *)(a1 + 120))
  {
    int v17 = 1;
    _BYTE *v18 = 1;
  }

  if (*v14 != v17)
  {
    CFTypeID v164 = v8;
    goto LABEL_33;
  }

  if (v17 == 3)
  {
    CFTypeRef cf = 0LL;
    __int128 v178 = xmmword_186B49CC0;
    __srCC_SHA1_CTX c = v180;
    char v179 = 0LL;
    unint64_t v22 = *(int **)(a1 + 16);
    int v23 = *v22;
    if (*v22 <= 30)
    {
      if (v23 != -1)
      {
LABEL_22:
        BOOL v24 = v23 <= 10 && (v23 != -1 || _LogCategory_Initialize((uint64_t)v22, 0xAu));
        LogPrintF( (uint64_t)v22,  (uint64_t)"OSStatus _VerifyServerM3(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, s ize_t *, Boolean *, Boolean *)",  0x1Eu,  (uint64_t)"Pair-verify server M3 -- finish request\n%?{end}%1{tlv8}\n",  (uint64_t)a5,  a6,  a7,  a8,  !v24);
        goto LABEL_63;
      }

      if (_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu))
      {
        unint64_t v22 = *(int **)(a1 + 16);
        int v23 = *v22;
        goto LABEL_22;
      }
    }

LABEL_190:
          LOBYTE(__dst) = 2;
          unsigned int GroupInfoTLV = TLV8BufferAppend((uint64_t)&__src, 7, (char *)&__dst, 1uLL);
          if (GroupInfoTLV) {
            goto LABEL_83;
          }
          LOBYTE(__dst) = 4;
          p_dst = (char *)&__dst;
          goto LABEL_192;
        }

        int v76 = *(_DWORD *)(a1 + 100);
        if ((v76 & 0x1000) != 0)
        {
          if ((v76 & 0x200000) != 0) {
            goto LABEL_185;
          }
          unsigned int v83 = _PairingSessionAppleIDVerifyPeer(a1, v65, v70);
          unsigned int GroupInfoTLV = v83;
LABEL_105:
          if (v83)
          {
            int v84 = *(int **)(a1 + 16);
            if (*v84 <= 50)
            {
              if (*v84 == -1)
              {
                int v84 = *(int **)(a1 + 16);
                LOBYTE(v83) = GroupInfoTLV;
              }

              LogPrintF( (uint64_t)v84,  (uint64_t)"OSStatus _VerifyServerM3(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *, Boolean *, Boolean *)",  0x32u,  (uint64_t)"### Pair-verify server bad signature: %#m\n",  v79,  v80,  v81,  v82,  v83);
            }

LABEL_244:
            char v137 = 2;
            goto LABEL_245;
          }

LABEL_143:
            uint64_t appended = TLV8BufferAppendUInt64((uint64_t)&__src, 7, v88);
            if ((_DWORD)appended) {
              goto LABEL_153;
            }
            uint64_t appended = TLV8BufferAppendUInt64((uint64_t)&__src, 6, *(unsigned __int8 *)(a1 + 120));
            if ((_DWORD)appended) {
              goto LABEL_153;
            }
            size_t v89 = v178;
            __int128 v90 = (UInt8 *)v179;
            if (!v179)
            {
              else {
                size_t v91 = v178;
              }
              uint64_t v92 = (UInt8 *)malloc(v91);
              if (!v92)
              {
                uint64_t appended = 4294960568LL;
                goto LABEL_153;
              }

              __int128 v90 = v92;
              if (v89) {
                memcpy(v92, __src, v89);
              }
            }

            __srCC_SHA1_CTX c = v180;
            *(void *)&__int128 v178 = 0LL;
            char v179 = 0LL;
            *a4 = v90;
            *a5 = v89;
            _PairingSessionReset(a1);
            uint64_t appended = 0LL;
LABEL_153:
            id v8 = v164;
            goto LABEL_226;
          }

          int v118 = *(int **)(a1 + 16);
          if (*v118 > 50) {
            goto LABEL_228;
          }
          if (*v118 == -1)
          {
            int v118 = *(int **)(a1 + 16);
          }

          LogPrintF( (uint64_t)v118,  (uint64_t)"OSStatus _VerifyServerM3(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *, Boolean *, Boolean *)",  0x32u,  (uint64_t)"### Pair-verify server -- client lacks ACL: %@\n",  v114,  v115,  v116,  v117,  *(void *)(a1 + 176));
LABEL_228:
          char v137 = 7;
LABEL_245:
          LOBYTE(__s[0]) = v137;
          unsigned int GroupInfoTLV = TLV8BufferAppend((uint64_t)&__src, 7, (char *)__s, 1uLL);
          if (GroupInfoTLV) {
            goto LABEL_83;
          }
          LOBYTE(__s[0]) = 4;
          p_dst = (char *)__s;
LABEL_192:
          unsigned int GroupInfoTLV = TLV8BufferAppend((uint64_t)&__src, 6, p_dst, 1uLL);
          if (GroupInfoTLV) {
            goto LABEL_83;
          }
          size_t v120 = v178;
          uint64_t v121 = (UInt8 *)v179;
          if (v179)
          {
LABEL_200:
            __srCC_SHA1_CTX c = v180;
            *(void *)&__int128 v178 = 0LL;
            char v179 = 0LL;
            *a4 = v121;
            *a5 = v120;
            unsigned int GroupInfoTLV = 0;
            _PairingSessionReset(a1);
            goto LABEL_83;
          }

          else {
            size_t v122 = v178;
          }
          uint64_t v123 = (UInt8 *)malloc(v122);
          if (v123)
          {
            uint64_t v121 = v123;
            if (v120) {
              memcpy(v123, __src, v120);
            }
            goto LABEL_200;
          }

          BOOL v26 = 0;
          unsigned int v156 = -6728;
LABEL_276:
          unsigned int GroupInfoTLV = v156;
          goto LABEL_84;
        }

        unsigned int v77 = *(const void **)(a1 + 952);
        if (v77)
        {
          unsigned int v78 = _Block_copy(v77);
          unsigned int GroupInfoTLV = TLV8GetBytes(v65, v70, 10, 0x40uLL, 0x40uLL, (char *)&__dst, 0LL, 0LL);
          if (GroupInfoTLV) {
            goto LABEL_100;
          }
          __int128 v129 = *(_OWORD *)(a1 + 590);
          __s[0] = *(_OWORD *)(a1 + 574);
          __s[1] = v129;
          __int128 v130 = *(_OWORD *)(a1 + 462);
          __s[2] = *(_OWORD *)(a1 + 446);
          __s[3] = v130;
          unsigned int v131 = (*((uint64_t (**)(void *, void, _OWORD *, uint64_t, int8x16_t **))v78 + 2))( v78,  *(unsigned int *)(a1 + 100),  __s,  64LL,  &__dst);
          unsigned int GroupInfoTLV = v131;
          if (v131 != -6714)
          {
            if (v131)
            {
              char v147 = *(int **)(a1 + 16);
              if (*v147 <= 90)
              {
                if (*v147 == -1)
                {
                  if (!_LogCategory_Initialize(*(void *)(a1 + 16), 0x5Au)) {
                    goto LABEL_100;
                  }
                  char v147 = *(int **)(a1 + 16);
                  LOBYTE(v131) = GroupInfoTLV;
                }

                LogPrintF( (uint64_t)v147,  (uint64_t)"OSStatus _VerifyServerM3(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8 _t **, size_t *, Boolean *, Boolean *)",  0x5Au,  (uint64_t)"### Pair-verify server M3 verify signature failed: %#m\n",  v132,  v133,  v134,  v135,  v131);
              }

LABEL_100:
              goto LABEL_83;
            }

            unsigned int v83 = GroupInfoTLV;
            goto LABEL_105;
          }
        }

        int v138 = v8;
        uint64_t v139 = *(void **)(a1 + 296);
        if (v139)
        {
          free(v139);
          *(void *)(a1 + 296) = 0LL;
        }

        int v140 = (size_t *)(a1 + 304);
        *(void *)(a1 + 304) = 0LL;
        size_t v141 = TLV8CopyCoalesced(v65, v70, 1, (size_t *)(a1 + 304), (int *)&GroupInfoTLV);
        *(void *)(a1 + 296) = v141;
        if (GroupInfoTLV) {
          goto LABEL_233;
        }
        if (!*v140)
        {
          BOOL v26 = 0;
          unsigned int v160 = -6743;
LABEL_295:
          unsigned int GroupInfoTLV = v160;
          goto LABEL_234;
        }

        unsigned int GroupInfoTLV = PairingSessionFindPeerEx(a1, (char *)v141, *v140, (_OWORD *)(a1 + 606), &cf, a6, a7, a8);
        if (!GroupInfoTLV)
        {
          unsigned int GroupInfoTLV = TLV8GetBytes(v65, v70, 10, 0x40uLL, 0x40uLL, (char *)&__dst, 0LL, 0LL);
          if (GroupInfoTLV)
          {
LABEL_233:
            BOOL v26 = 0;
LABEL_234:
            id v8 = v138;
            goto LABEL_84;
          }

          size_t v148 = *v140;
          *(void *)&v171[0] = *v140 + 64;
          BOOL v149 = malloc(*(size_t *)&v171[0]);
          if (v149)
          {
            int v150 = v149;
            __int128 v151 = *(_OWORD *)(a1 + 590);
            *BOOL v149 = *(_OWORD *)(a1 + 574);
            v149[1] = v151;
            char v163 = v149 + 2;
            memcpy(v149 + 2, *(const void **)(a1 + 296), v148);
            size_t v152 = (_OWORD *)((char *)v163 + v148);
            __int128 v153 = *(_OWORD *)(a1 + 462);
            *size_t v152 = *(_OWORD *)(a1 + 446);
            v152[1] = v153;
            ccsha512_di();
            unsigned int v83 = cced25519_verify();
            unsigned int GroupInfoTLV = v83;
            free(v150);
            id v8 = v138;
            goto LABEL_105;
          }

          goto LABEL_299;
        }

        int v146 = *(int **)(a1 + 16);
        id v8 = v138;
        if (*v146 <= 50)
        {
          if (*v146 == -1)
          {
            int v146 = *(int **)(a1 + 16);
          }

          LogPrintF( (uint64_t)v146,  (uint64_t)"OSStatus _VerifyServerM3(PairingSessionRef, const uint8_t *const, const uint8_t *const, uint8_t **, size_t *, Boolean *, Boolean *)",  0x32u,  (uint64_t)"### Pair-verify server unknown peer: %.*s\n",  v142,  v143,  v144,  v145,  *(void *)(a1 + 304));
        }

LABEL_256:
        LOBYTE(__s[0]) = 2;
        unsigned int GroupInfoTLV = TLV8BufferAppend((uint64_t)&__src, 7, (char *)__s, 1uLL);
        if (GroupInfoTLV) {
          goto LABEL_83;
        }
        LOBYTE(__s[0]) = 4;
        unsigned int GroupInfoTLV = TLV8BufferAppend((uint64_t)&__src, 6, (char *)__s, 1uLL);
        if (GroupInfoTLV) {
          goto LABEL_83;
        }
        size_t v120 = v178;
        uint64_t v121 = (UInt8 *)v179;
        if (v179) {
          goto LABEL_200;
        }
        else {
          size_t v154 = v178;
        }
        char v155 = (UInt8 *)malloc(v154);
        if (v155)
        {
          uint64_t v121 = v155;
          if (v120) {
            memcpy(v155, __src, v120);
          }
          id v8 = v138;
          goto LABEL_200;
        }

LABEL_158:
  unint64_t v93 = *(void *)(a1 + 208);
  if (!v93 || (LODWORD(v169) = TLV8BufferAppendUInt64((uint64_t)&__dst, 25, v93), !(_DWORD)v169))
  {
    uint64_t v94 = *(const __CFDictionary **)(a1 + 344);
    CFTypeID TypeID = CFDictionaryGetTypeID();
    TypedValue = (const __CFString *)CFDictionaryGetTypedValue(v94, @"appInfoSelf", TypeID, 0LL);
    if (!TypedValue
      || (DataCFMutableDictionaryRef Mutable = OPACKEncoderCreateDataMutable(TypedValue, 0, (int *)&v169)) != 0LL
      && (size_t v98 = DataMutable,
          BytePtr = (char *)CFDataGetBytePtr(DataMutable),
          size_t v100 = CFDataGetLength(v98),
          LODWORD(v169) = TLV8BufferAppend((uint64_t)&__dst, 29, BytePtr, v100),
          CFRelease(v98),
          !(_DWORD)v169))
    {
      int v101 = (int8x16_t *)malloc(v173 + 16);
      if (!v101) {
        goto LABEL_279;
      }
      uint64_t v102 = v101;
      CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  (uint64_t)v11,  32LL,  "Pair-Verify-Encrypt-Salt",  0x18uLL,  (uint64_t)"Pair-Verify-Encrypt-Info",  24LL,  0x20uLL,  a1 + 414);
      _chacha20_poly1305_encrypt_all( (_DWORD *)(a1 + 414),  "PV-Msg02",  8LL,  0LL,  0LL,  __dst,  v173,  v102,  (uint64_t)v102->i64 + v173);
      int v103 = TLV8BufferAppend((uint64_t)&__src, 5, v102->i8, v173 + 16);
      LODWORD(v169) = v103;
      free(v102);
      if (v103) {
        goto LABEL_217;
      }
      _BYTE *v18 = 2;
      LODWORD(v169) = TLV8BufferAppend((uint64_t)&__src, 6, (char *)(a1 + 120), 1uLL);
      if ((_DWORD)v169) {
        goto LABEL_217;
      }
      LODWORD(v169) = TLV8BufferAppend((uint64_t)&__src, 3, (char *)(a1 + 446), 0x20uLL);
      if ((_DWORD)v169) {
        goto LABEL_217;
      }
      size_t v104 = v178;
      __int128 v105 = (UInt8 *)v179;
      if (!v179)
      {
        else {
          size_t v106 = v178;
        }
        uint64_t v107 = (UInt8 *)malloc(v106);
        if (v107)
        {
          __int128 v105 = v107;
          if (v104) {
            memcpy(v107, __src, v104);
          }
          goto LABEL_174;
        }

LABEL_279:
        LODWORD(v169) = -6728;
        goto LABEL_217;
      }

LABEL_174:
      __srCC_SHA1_CTX c = v180;
      *(void *)&__int128 v178 = 0LL;
      char v179 = 0LL;
      *a4 = v105;
      *a5 = v104;
      LODWORD(v169) = 0;
      uint64_t v108 = *(int **)(a1 + 16);
      int v109 = *v108;
      if (*v108 <= 30)
      {
        if (v109 != -1) {
          goto LABEL_176;
        }
        if (_LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu))
        {
          uint64_t v108 = *(int **)(a1 + 16);
          int v109 = *v108;
LABEL_176:
          char v110 = v109 > 10 || v109 == -1 && !_LogCategory_Initialize((uint64_t)v108, 0xAu);
          LogPrintF( (uint64_t)v108,  (uint64_t)"OSStatus _VerifyServerM2(PairingSessionRef, uint8_t **, size_t *)",  0x1Eu,  (uint64_t)"Pair-verify server M2 -- start response\n%?{end}%1{tlv8}\n",  (uint64_t)a5,  a6,  a7,  a8,  v110);
        }
      }

      _BYTE *v18 = 3;
    }
  }

    FPrintF(*MEMORY[0x1895F89E0]);
    return appended;
  }

LABEL_217:
  if (v174)
  {
    free(v174);
    int v174 = 0LL;
  }

  uint64_t v67 = a4;
  if (v179) {
    free(v179);
  }
  uint64_t appended = v169;
  __int128 v68 = (CFIndex *)a5;
  if ((_DWORD)v169) {
    goto LABEL_111;
  }
  BOOL v26 = 0;
LABEL_223:
  uint64_t appended = 0LL;
  if (v67 && v68)
  {
    _PairingSessionUpdateTranscript(a1, a2, a3, *v67, *v68);
    uint64_t appended = 0LL;
  }

uint64_t _ResumePairingClientExchange( uint64_t a1, unsigned __int8 *a2, uint64_t a3, UInt8 **a4, size_t *a5, char *a6, uint64_t a7, uint64_t a8)
{
  v68[1] = *MEMORY[0x1895F89C0];
  __srCC_SHA1_CTX c = v67;
  __int128 v65 = xmmword_186B49CC0;
  uint64_t v66 = 0LL;
  uint64_t v15 = (char *)(a1 + 120);
  int v14 = *(unsigned __int8 *)(a1 + 120);
  if (!*(_BYTE *)(a1 + 120))
  {
    int v14 = 1;
    char *v15 = 1;
  }

  unint64_t v16 = (unint64_t)&a2[a3];
  if (a3)
  {
    int v17 = a2;
    do
    {
      if (v16 - (unint64_t)v17 < 2)
      {
LABEL_41:
        unsigned int v30 = -6727;
        goto LABEL_70;
      }

      int v18 = v17 + 2;
      uint64_t v19 = v17[1];
      if ((unint64_t)&v17[v19 + 2] > v16)
      {
        unsigned int v30 = -6750;
        goto LABEL_70;
      }

      int v20 = *v17;
      v17 += v19 + 2;
    }

    while (v20 != 6);
    if ((_DWORD)v19 == 1)
    {
      if (*v18 == v14) {
        goto LABEL_12;
      }
      unsigned int v30 = -6709;
    }

    else
    {
      unsigned int v30 = -6743;
    }

    goto LABEL_70;
  }

uint64_t _ResumePairingServerExchange( uint64_t a1, unsigned __int8 *a2, uint64_t a3, UInt8 **a4, uint64_t a5, char *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v71 = *MEMORY[0x1895F89C0];
  size_t v59 = 0LL;
  __srCC_SHA1_CTX c = 0LL;
  uint64_t v66 = v69;
  int v14 = &a2[a3];
  __int128 v67 = xmmword_186B49CC0;
  __int128 v68 = 0LL;
  uint64_t v15 = a2;
  do
  {
    if (v15 == v14)
    {
LABEL_84:
      unsigned int v27 = -6727;
      goto LABEL_87;
    }

    if (v15 >= v14)
    {
      unsigned int v27 = -6705;
      goto LABEL_87;
    }

    unint64_t v16 = v15 + 2;
    uint64_t v17 = v15[1];
    if (&v15[v17 + 2] > v14)
    {
      unsigned int v27 = -6750;
LABEL_87:
      __int128 v25 = 0LL;
      char v26 = 0;
      goto LABEL_27;
    }

    int v18 = *v15;
    v15 += v17 + 2;
  }

  while (v18 != 6);
  unsigned int Bytes = 0;
  if ((_DWORD)v17 != 1)
  {
    __int128 v25 = 0LL;
    goto LABEL_91;
  }

  if (*v16 == 1) {
    _PairingSessionReset(a1);
  }
  int v20 = (_BYTE *)(a1 + 120);
  int v19 = *(unsigned __int8 *)(a1 + 120);
  if (*(_BYTE *)(a1 + 120))
  {
    if (v19 != 1)
    {
      char v21 = *(int **)(a1 + 16);
      if (*v21 <= 60)
      {
        if (*v21 != -1) {
          goto LABEL_15;
        }
        if (_LogCategory_Initialize((uint64_t)v21, 0x3Cu))
        {
          char v21 = *(int **)(a1 + 16);
          LOBYTE(v19) = *(_BYTE *)(a1 + 120);
LABEL_15:
          LogPrintF( (uint64_t)v21,  (uint64_t)"OSStatus _ResumePairingServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x3Cu,  (uint64_t)"### Pair-resume server bad state: %d\n",  a5,  (uint64_t)a6,  a7,  a8,  v19);
        }
      }

LABEL_79:
  uint64_t v66 = v69;
  *(void *)&__int128 v67 = 0LL;
  __int128 v68 = 0LL;
  *a4 = v47;
  void *v58 = v46;
  unsigned int Bytes = 0;
  size_t v50 = *(int **)(a1 + 16);
  int v51 = *v50;
  if (*v50 >= 31)
  {
    *int v20 = 3;
    goto LABEL_105;
  }

  if (v51 == -1)
  {
    BOOL v54 = _LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu);
    size_t v50 = *(int **)(a1 + 16);
    if (!v54) {
      goto LABEL_101;
    }
    int v51 = *v50;
  }

  char v52 = v51 > 10 || v51 == -1 && !_LogCategory_Initialize((uint64_t)v50, 0xAu);
  LogPrintF( (uint64_t)v50,  (uint64_t)"OSStatus _ResumePairingServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)"Pair-resume server M2 -- resume response\n%?{end}%1{tlv8}\n",  a5,  (uint64_t)a6,  a7,  a8,  v52);
  size_t v50 = *(int **)(a1 + 16);
LABEL_101:
  int v55 = *v50;
  *int v20 = 3;
  if (v55 <= 30)
  {
    if (v55 == -1)
    {
      size_t v50 = *(int **)(a1 + 16);
    }

    LogPrintF( (uint64_t)v50,  (uint64_t)"OSStatus _ResumePairingServerExchange(PairingSessionRef, const void *, size_t, uint8_t **, size_t *, Boolean *)",  0x1Eu,  (uint64_t)"Pair-resume server done\n",  a5,  (uint64_t)a6,  a7,  a8,  v56);
  }

      unint64_t v6 = 0LL;
      id v8 = 0LL;
LABEL_80:
      size_t v9 = 0LL;
      int v7 = -6756;
LABEL_74:
      if (a3) {
        *a3 = v7;
      }
      int v18 = v9;

      return v18;
  }

uint64_t _PairingSessionSavePeerKeychain( uint64_t a1, char *a2, uint64_t a3, unsigned __int8 *a4, unsigned int a5)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  pthread_mutex_lock(&gPairingGlobalLock);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (!Mutable)
  {
    CFDataRef Data = 0LL;
    goto LABEL_22;
  }

  uint64_t v15 = Mutable;
  unint64_t v16 = (const void **)MEMORY[0x189604DE8];
  if ((*(_BYTE *)(a1 + 808) & 4) != 0) {
    CFDictionarySetValue(Mutable, @"homeKitRegistered", (const void *)*MEMORY[0x189604DE8]);
  }
  if (a5)
  {
    CFDictionarySetInt64(v15, @"permissions", a5);
    if ((a5 & 1) != 0)
    {
      uint64_t v17 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      CFDataRef Data = v17;
      if (v17)
      {
        CFDictionarySetValue(v17, @"com.apple.admin", *v16);
        CFDictionarySetValue(v15, @"acl", Data);
        CFRelease(Data);
        goto LABEL_8;
      }

void _PairingSessionDeletePeer( uint64_t a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v31 = a3;
  if (a3 == -1) {
    size_t v31 = strlen(__s);
  }
  int v10 = (const void *)*MEMORY[0x18960BAE0];
  uint64_t v11 = (const __CFArray *)KeychainCopyMatchingFormatted( 0LL,  (uint64_t)"{%kO=%O%kO=%O%kO=%i%kO=%O%kO=%O%kO=%O%kO=%O}",  a3,  a4,  a5,  a6,  a7,  a8,  *MEMORY[0x18960BB38]);
  if (v11)
  {
    uint64_t v12 = v11;
    CFIndex Count = CFArrayGetCount(v11);
    if (Count >= 1)
    {
      CFIndex v14 = Count;
      CFIndex v15 = 0LL;
      char v32 = (const void *)*MEMORY[0x18960B870];
      unint64_t v16 = (const void *)*MEMORY[0x18960BE80];
      do
      {
        CFTypeID TypeID = CFDictionaryGetTypeID();
        TypedValueAtIndex = CFArrayGetTypedValueAtIndex(v12, v15, TypeID, 0LL);
        if (TypedValueAtIndex)
        {
          uint64_t v19 = TypedValueAtIndex;
          if (*(_DWORD *)(a1 + 792) == CFDictionaryGetInt64(TypedValueAtIndex, v10, &v33))
          {
            if (!__s
              || (uint64_t v20 = CFDictionaryCopyCString(v19, v32, &v33), !v33)
              && (v21 = v20, int v22 = strnicmpx((unsigned __int8 *)__s, v31, v20), free(v21), !v22))
            {
              CFTypeID v23 = CFDataGetTypeID();
              CFDictionaryGetTypedValue(v19, v16, v23, &v33);
              if (!v33) {
                int v33 = KeychainDeleteFormatted((uint64_t)"{%kO=%O}", v24, v25, v26, v27, v28, v29, v30, (uint64_t)v16);
              }
            }
          }
        }

        ++v15;
      }

      while (v14 != v15);
    }

    CFRelease(v12);
  }

__CFArray *_PairingSessionCopyPeers(int a1, char *__s, uint64_t a3, _DWORD *a4)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (a3 == -1) {
    strlen(__s);
  }
  pthread_mutex_lock(&gPairingGlobalLock);
  uint64_t v5 = (const void *)*MEMORY[0x18960B870];
  uint64_t v45 = *MEMORY[0x18960BB38];
  uint64_t v11 = (const __CFArray *)KeychainCopyMatchingFormatted( &v48,  (uint64_t)"{%kO=%O%kO=%O%kO=%i%kO=%?.*s%kO=%O%kO=%O%kO=%O}",  *MEMORY[0x189604DE8],  v6,  v7,  v8,  v9,  v10,  *MEMORY[0x18960BB38]);
  if (v48 == -25300)
  {
    int v48 = 0;
  }

  else if (v48)
  {
    CFMutableDictionaryRef Mutable = 0LL;
    goto LABEL_29;
  }

  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  if (!Mutable)
  {
    CFMutableDictionaryRef Mutable = 0LL;
    int v48 = -6728;
    goto LABEL_29;
  }

  size_t v44 = a4;
  if (!v11 || (CFIndex Count = CFArrayGetCount(v11), Count < 1))
  {
LABEL_27:
    int v48 = 0;
    goto LABEL_28;
  }

  CFIndex v13 = Count;
  CFIndex v14 = 0LL;
  CFIndex v15 = (const CFDictionaryKeyCallBacks *)MEMORY[0x189605240];
  unint64_t v16 = (const CFDictionaryValueCallBacks *)MEMORY[0x189605250];
  char v43 = (const void *)*MEMORY[0x18960B928];
  while (1)
  {
    CFTypeID TypeID = CFDictionaryGetTypeID();
    TypedValueAtIndex = CFArrayGetTypedValueAtIndex(v11, v14, TypeID, &v48);
    if (v48) {
      goto LABEL_26;
    }
    uint64_t v19 = TypedValueAtIndex;
    CFMutableDictionaryRef v20 = CFDictionaryCreateMutable(0LL, 0LL, v15, v16);
    if (!v20) {
      break;
    }
    char v21 = v20;
    CFTypeID v22 = CFStringGetTypeID();
    TypedValue = CFDictionaryGetTypedValue(v19, v5, v22, &v48);
    if (v48)
    {
      uint64_t v24 = v21;
    }

    else
    {
      CFDictionarySetValue(v21, @"identifier", TypedValue);
      size_t v31 = (const __CFData *)KeychainCopyMatchingFormatted( &v48,  (uint64_t)"{%kO=%O%kO=%O%kO=%i%kO=%O%kO=%O%kO=%O}",  v25,  v26,  v27,  v28,  v29,  v30,  v45);
      uint64_t v24 = v31;
      if (!v48)
      {
        unint64_t v47 = 0LL;
        char v32 = v15;
        BytePtr = CFDataGetBytePtr(v31);
        CFIndex Length = CFDataGetLength(v24);
        uint64_t v35 = (char *)BytePtr;
        CFIndex v15 = v32;
        int v48 = HexToData(v35, Length, 22, (uint64_t)bytes, 0x20uLL, &v47, 0LL, 0LL);
        if (!v48 && v47 == 32)
        {
          CFDictionarySetData(v21, @"pk", bytes, 32LL);
          CFTypeID v36 = CFDataGetTypeID();
          uint64_t v37 = CFDictionaryGetTypedValue(v19, v43, v36, 0LL);
          if (v37)
          {
            CFPropertyListRef v38 = CFPropertyListCreateWithData(0LL, v37, 0LL, 0LL, 0LL);
            if (v38)
            {
              uint64_t v39 = v38;
              CFTypeID v40 = CFGetTypeID(v38);
              if (v40 == CFDictionaryGetTypeID())
              {
                CFDictionarySetValue(v21, @"info", v39);
                Value = CFDictionaryGetValue((CFDictionaryRef)v39, @"permissions");
                if (Value) {
                  CFDictionarySetValue(v21, @"permissions", Value);
                }
              }

              CFRelease(v39);
              CFIndex v15 = v32;
            }
          }

          CFArrayAppendValue(Mutable, v21);
        }
      }

      CFRelease(v21);
      if (!v24) {
        goto LABEL_26;
      }
    }

    CFRelease(v24);
LABEL_26:
    if (v13 == ++v14) {
      goto LABEL_27;
    }
  }

  int v48 = -6728;
  CFRelease(Mutable);
  CFMutableDictionaryRef Mutable = 0LL;
LABEL_28:
  a4 = v44;
LABEL_29:
  if (v11) {
    CFRelease(v11);
  }
  if (a4) {
    *a4 = v48;
  }
  pthread_mutex_unlock(&gPairingGlobalLock);
  return Mutable;
}

uint64_t _PairingFindResumeState(uint64_t a1, void *a2, size_t *a3, _OWORD *a4)
{
  uint64_t v8 = mach_absolute_time();
  pthread_mutex_lock(&gPairingGlobalLock);
  uint64_t v9 = &gPairingResumeStateList;
  do
  {
    uint64_t v9 = (uint64_t *)*v9;
    if (!v9)
    {
      uint64_t v13 = 4294960569LL;
      goto LABEL_12;
    }
  }

  while (v9[10] != a1);
  if (v8 >= v9[5])
  {
    uint64_t v13 = 4294960574LL;
  }

  else
  {
    if (!a2 || !a3) {
      goto LABEL_10;
    }
    size_t v10 = v9[2];
    if (v10)
    {
      uint64_t v11 = malloc(v9[2]);
      if (v11)
      {
        uint64_t v12 = v11;
        memcpy(v11, (const void *)v9[1], v10);
        *a2 = v12;
        *a3 = v10;
LABEL_10:
        uint64_t v13 = 0LL;
        __int128 v14 = *((_OWORD *)v9 + 4);
        *a4 = *((_OWORD *)v9 + 3);
        a4[1] = v14;
        goto LABEL_12;
      }

      uint64_t v13 = 4294960568LL;
    }

    else
    {
      uint64_t v13 = 4294960553LL;
    }
  }

uint64_t _PairingRemoveResumeSessionID(uint64_t a1)
{
  uint64_t v2 = gPairingResumeStateList;
  if (gPairingResumeStateList)
  {
    id v3 = &gPairingResumeStateList;
    do
    {
      id v4 = v3;
      id v3 = (uint64_t *)v2;
      while (1)
      {
        uint64_t v2 = *v3;
        if (v3[10] != a1) {
          break;
        }
        *id v4 = v2;
        _PairingFreeResumeState(v3);
        id v3 = (uint64_t *)*v4;
        if (!*v4) {
          return pthread_mutex_unlock(&gPairingGlobalLock);
        }
      }
    }

    while (v2);
  }

  return pthread_mutex_unlock(&gPairingGlobalLock);
}

void _PairingSaveResumeState( uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5, uint64_t a6, _OWORD *a7)
{
  uint64_t v14 = gPairingResumeStateList;
  if (gPairingResumeStateList)
  {
    CFIndex v15 = &gPairingResumeStateList;
    do
    {
      unint64_t v16 = v15;
      CFIndex v15 = (uint64_t *)v14;
      while (v15[2] == a3
           && !memcmp(a2, (const void *)v15[1], a3)
           && ((*(_BYTE *)(a1 + 102) & 0x80) == 0 || v15[4] == a5 && !memcmp(a4, (const void *)v15[3], a5)))
      {
        *unint64_t v16 = *v15;
        _PairingFreeResumeState(v15);
        CFIndex v15 = (uint64_t *)*v16;
        if (!*v16) {
          goto LABEL_12;
        }
      }

      uint64_t v14 = *v15;
    }

    while (*v15);
LABEL_12:
    uint64_t v17 = gPairingResumeStateList;
    if (gPairingResumeStateList)
    {
      unsigned int v18 = 0;
      uint64_t v19 = &gPairingResumeStateList;
      do
      {
        CFMutableDictionaryRef v20 = v19;
        ++v18;
        uint64_t v19 = (uint64_t *)v17;
        while (1)
        {
          uint64_t v17 = *v19;
          if (v18 <= gPairingMaxResumeSessions) {
            break;
          }
          *CFMutableDictionaryRef v20 = v17;
          _PairingFreeResumeState(v19);
          uint64_t v19 = (uint64_t *)*v20;
          ++v18;
          if (!*v20) {
            goto LABEL_19;
          }
        }
      }

      while (v17);
    }
  }

void _PairingFreeResumeState(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)a1[1];
    if (v2)
    {
      free(v2);
      a1[1] = 0LL;
    }

    a1[2] = 0LL;
    id v3 = (void *)a1[3];
    if (v3) {
      free(v3);
    }
    free(a1);
  }

uint64_t _PairingSessionAppleIDProveSelf(uint64_t a1, uint64_t a2)
{
  id v4 = (CUAppleIDClient *)*(id *)(a1 + 840);
  if (!v4)
  {
    uint64_t v5 = objc_alloc_init(&OBJC_CLASS___CUAppleIDClient);
    id v4 = v5;
    *(void *)(a1 + 840) = v5;
    if (*(void *)(a1 + 816)) {
      -[CUAppleIDClient setMyAppleID:](v5, "setMyAppleID:");
    }
  }

  id v6 = objc_alloc_init(MEMORY[0x189603FB8]);
  [v6 appendBytes:a1 + 446 length:32];
  [v6 appendBytes:a1 + 574 length:32];
  id v54 = 0LL;
  -[CUAppleIDClient signData:error:](v4, "signData:error:", v6, &v54);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  id v8 = v54;
  id v9 = v8;
  if (!v7)
  {
    unsigned int v20 = NSErrorToOSStatusEx(v8, 0LL);
    if (v20) {
      uint64_t v12 = v20;
    }
    else {
      uint64_t v12 = 4294960580LL;
    }
    __int128 v25 = *(int **)(a1 + 16);
    if (*v25 > 60) {
      goto LABEL_7;
    }
    if (*v25 == -1)
    {
      __int128 v25 = *(int **)(a1 + 16);
    }

    LogPrintF( (uint64_t)v25,  (uint64_t)"OSStatus _PairingSessionAppleIDProveSelf(PairingSessionRef, TLV8Buffer *)",  0x3Cu,  (uint64_t)"### AppleID sign data failed: %{error}\n",  v21,  v22,  v23,  v24,  (char)v9);
    goto LABEL_7;
  }

  id v10 = v7;
  uint64_t v11 = TLV8BufferAppend(a2, 10, (char *)[v10 bytes], objc_msgSend(v10, "length"));
  if ((_DWORD)v11)
  {
    uint64_t v12 = v11;
    goto LABEL_7;
  }

  id v53 = v9;
  id v14 = -[CUAppleIDClient copyMyCertificateDataAndReturnError:](v4, "copyMyCertificateDataAndReturnError:", &v53);
  id v15 = v53;

  if (!v14)
  {
    unsigned int v26 = NSErrorToOSStatusEx(v15, 0LL);
    if (v26) {
      uint64_t v12 = v26;
    }
    else {
      uint64_t v12 = 4294960596LL;
    }
    size_t v31 = *(int **)(a1 + 16);
    if (*v31 > 60) {
      goto LABEL_50;
    }
    if (*v31 == -1)
    {
      size_t v31 = *(int **)(a1 + 16);
    }

    LogPrintF( (uint64_t)v31,  (uint64_t)"OSStatus _PairingSessionAppleIDProveSelf(PairingSessionRef, TLV8Buffer *)",  0x3Cu,  (uint64_t)"### AppleID get my certificate failed: %{error}\n",  v27,  v28,  v29,  v30,  (char)v15);
LABEL_50:
    id v13 = 0LL;
    id v9 = v15;
    goto LABEL_15;
  }

  id v52 = v15;
  NSDataCompress(v14, 3, &v52);
  id v13 = (id)objc_claimAutoreleasedReturnValue();
  id v9 = v52;

  if (!v13)
  {
    unsigned int v32 = NSErrorToOSStatusEx(v9, 0LL);
    if (v32) {
      uint64_t v12 = v32;
    }
    else {
      uint64_t v12 = 4294960596LL;
    }
    uint64_t v37 = *(int **)(a1 + 16);
    if (*v37 > 60) {
      goto LABEL_15;
    }
    if (*v37 == -1)
    {
      uint64_t v37 = *(int **)(a1 + 16);
    }

    LogPrintF( (uint64_t)v37,  (uint64_t)"OSStatus _PairingSessionAppleIDProveSelf(PairingSessionRef, TLV8Buffer *)",  0x3Cu,  (uint64_t)"### Compress AppleID my certificate failed: %{error}\n",  v33,  v34,  v35,  v36,  (char)v9);
LABEL_7:
    id v13 = 0LL;
    goto LABEL_15;
  }

  id v13 = v13;
  uint64_t v16 = TLV8BufferAppend(a2, 9, (char *)[v13 bytes], objc_msgSend(v13, "length"));
  if ((_DWORD)v16)
  {
LABEL_14:
    uint64_t v12 = v16;
    goto LABEL_15;
  }

  id v51 = v9;
  id v17 = -[CUAppleIDClient copyMyValidationDataAndReturnError:](v4, "copyMyValidationDataAndReturnError:", &v51);
  id v18 = v51;

  if (!v17)
  {
    id v9 = v18;
    unsigned int v38 = NSErrorToOSStatusEx(v18, 0LL);
    if (v38) {
      uint64_t v12 = v38;
    }
    else {
      uint64_t v12 = 4294960596LL;
    }
    char v43 = *(int **)(a1 + 16);
    if (*v43 > 60) {
      goto LABEL_7;
    }
    if (*v43 == -1)
    {
      char v43 = *(int **)(a1 + 16);
    }

    LogPrintF( (uint64_t)v43,  (uint64_t)"OSStatus _PairingSessionAppleIDProveSelf(PairingSessionRef, TLV8Buffer *)",  0x3Cu,  (uint64_t)"### AppleID get my validatidation data failed: %{error}\n",  v39,  v40,  v41,  v42,  (char)v18);
    goto LABEL_7;
  }

  id v50 = v18;
  NSDataCompress(v17, 3, &v50);
  id v13 = (id)objc_claimAutoreleasedReturnValue();
  id v9 = v50;

  if (v13)
  {
    id v13 = v13;
    uint64_t v16 = TLV8BufferAppend(a2, 20, (char *)[v13 bytes], objc_msgSend(v13, "length"));
    goto LABEL_14;
  }

  unsigned int v44 = NSErrorToOSStatusEx(v9, 0LL);
  if (v44) {
    uint64_t v12 = v44;
  }
  else {
    uint64_t v12 = 4294960596LL;
  }
  int v49 = *(int **)(a1 + 16);
  if (*v49 <= 60)
  {
    if (*v49 == -1)
    {
      int v49 = *(int **)(a1 + 16);
    }

    LogPrintF( (uint64_t)v49,  (uint64_t)"OSStatus _PairingSessionAppleIDProveSelf(PairingSessionRef, TLV8Buffer *)",  0x3Cu,  (uint64_t)"### Compress AppleID my validatidation data failed: %{error}\n",  v45,  v46,  v47,  v48,  (char)v9);
    goto LABEL_7;
  }

uint64_t PairingSessionCopyIdentity(uint64_t a1, uint64_t a2, char **a3, _OWORD *a4, uint64_t a5)
{
  uint64_t v6 = (uint64_t)a4;
  uint64_t v7 = a3;
  int v8 = a2;
  uint64_t v102 = *MEMORY[0x1895F89C0];
  id v10 = *(uint64_t (**)(uint64_t, char **, _OWORD *, uint64_t, void))(a1 + 56);
  if (v10) {
    return v10(a2, a3, a4, a5, *(void *)(a1 + 24));
  }
  unint64_t v12 = *(unsigned int *)(a1 + 100);
  if ((v12 & 4) != 0)
  {
    uint64_t v61 = (_DWORD)a2 != 0;
    if (a5) {
      v61 |= 2uLL;
    }
    uint64_t v62 = v61 | (v12 >> 19) & 8;
    unint64_t v63 = v12 >> 21;
    uint64_t v64 = v62 | (v12 >> 21) & 0x10;
    if ((v12 & 0x80000000) == 0LL) {
      uint64_t v65 = v64;
    }
    else {
      uint64_t v65 = v64 | 0x100;
    }
    return _PairingSessionCopyIdentityPairingManager(a1, v65 | v63 & 0x20, a3, 0LL, a4, (_OWORD *)a5);
  }

  pthread_mutex_lock(&gPairingGlobalLock);
  uint64_t v85 = *MEMORY[0x18960BB38];
  uint64_t v84 = *MEMORY[0x18960BAA8];
  uint64_t v80 = *MEMORY[0x18960BAB0];
  uint64_t v79 = *MEMORY[0x18960BE18];
  uint64_t v19 = *MEMORY[0x189604DE8];
  BOOL v73 = (v6 | a5) != 0;
  uint64_t v83 = *MEMORY[0x189604DE8];
  if (!(v6 | a5)) {
    uint64_t v19 = 0LL;
  }
  uint64_t v77 = v19;
  uint64_t v78 = *MEMORY[0x18960BE20];
  uint64_t v82 = (const void *)*MEMORY[0x18960B870];
  int v20 = 1;
  uint64_t v81 = (const void *)*MEMORY[0x18960BE78];
  unsigned int v75 = (_OWORD *)v6;
  int v76 = v7;
  int v74 = v8;
  do
  {
    if (v20 != 1) {
      usleep(0x4E20u);
    }
    uint64_t v71 = v78;
    uint64_t v72 = v77;
    uint64_t v69 = v79;
    uint64_t v70 = v83;
    uint64_t v67 = v84;
    uint64_t v68 = v80;
    uint64_t v27 = (const __CFDictionary *)KeychainCopyMatchingFormatted( v88,  (uint64_t)"{%kO=%O%kO=%O%kO=%i%kO=%O%kO=%O%kO=%O}",  v13,  v14,  v15,  v16,  v17,  v18,  v85);
    if (!v27)
    {
      if (*(_DWORD *)(a1 + 768) == 1751216195)
      {
        uint64_t v71 = v78;
        uint64_t v72 = v77;
        uint64_t v69 = v79;
        uint64_t v70 = v83;
        uint64_t v67 = v84;
        uint64_t v68 = v80;
        uint64_t v27 = (const __CFDictionary *)KeychainCopyMatchingFormatted( v88,  (uint64_t)"{%kO=%O%kO=%O%kO=%i%kO=%O%kO=%O%kO=%O}",  v21,  v22,  v23,  v24,  v25,  v26,  v85);
      }

      else
      {
        uint64_t v27 = 0LL;
      }
    }

    if (!LODWORD(v88[0]))
    {
      if (v7)
      {
        uint64_t v28 = CFDictionaryCopyCString(v27, v82, v88);
        if (LODWORD(v88[0])) {
          goto LABEL_19;
        }
        *uint64_t v7 = v28;
      }

      if (v73)
      {
        *(void *)__str = 0LL;
        CFDictionaryGetData(v27, v81, __s, 0x84uLL, __str, (int *)v88);
        *(void *)&v89[0] = __s;
        int64_t v29 = *(void *)__str;
        LODWORD(v88[0]) = HexToData( __s,  *(int64_t *)__str,  22,  v6,  0x20uLL,  (unint64_t *)__str,  0LL,  (char **)v89);
        if (!LODWORD(v88[0]))
        {
          if (*(void *)__str != 32LL) {
            goto LABEL_54;
          }
          if (!a5) {
            goto LABEL_19;
          }
          uint64_t v59 = *(void *)&v89[0];
          if (*(void *)&v89[0] >= (unint64_t)&__s[v29] || **(_BYTE **)&v89[0] != 43)
          {
            int v60 = -6742;
            goto LABEL_61;
          }

          ++*(void *)&v89[0];
          LODWORD(v88[0]) = HexToData( *(char **)&v89[0],  (int64_t)&__s[v29 - 1 - v59],  22,  a5,  0x20uLL,  (unint64_t *)__str,  0LL,  0LL);
          if (!LODWORD(v88[0]) && *(void *)__str != 32LL)
          {
LABEL_54:
            int v60 = -6743;
LABEL_61:
            LODWORD(v88[0]) = v60;
          }
        }
      }
    }

uint64_t _PairingSessionAppleIDVerifyPeer(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v6 = TLV8CopyCoalesced(a2, a3, 9, &v44, (int *)&v45);
  if (!v6 || !v44)
  {
    uint64_t v14 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v39 = 0LL;
    id v9 = 0LL;
    id v11 = 0LL;
LABEL_33:
    unsigned int v45 = -6711;
    goto LABEL_39;
  }

  uint64_t v7 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithBytesNoCopy:v6 length:v44];
  id v9 = v7;
  if (!v7)
  {
    id v11 = 0LL;
    uint64_t v39 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v14 = 0LL;
LABEL_35:
    unsigned int v45 = -6728;
LABEL_52:
    free(v6);
    uint64_t v6 = 0LL;
LABEL_53:
    uint64_t v19 = 0LL;
    goto LABEL_27;
  }

  id v43 = 0LL;
  uint64_t v10 = NSDataDecompress(v7, v8, &v43);
  id v11 = v43;

  uint64_t v39 = (void *)v10;
  if (!v10)
  {
    if (v11) {
      unsigned int v30 = NSErrorToOSStatusEx(v11, 0LL);
    }
    else {
      unsigned int v30 = -6700;
    }
    id v9 = 0LL;
    uint64_t v39 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v14 = 0LL;
    unsigned int v45 = v30;
    goto LABEL_52;
  }

  uint64_t v6 = TLV8CopyCoalesced(a2, a3, 20, &v44, (int *)&v45);
  if (!v6 || !v44)
  {
    uint64_t v14 = 0LL;
    uint64_t v17 = 0LL;
    id v9 = 0LL;
    goto LABEL_33;
  }

  unint64_t v12 = (CUAppleIDClient *)[objc_alloc(MEMORY[0x189603F48]) initWithBytesNoCopy:v6 length:v44];
  uint64_t v14 = v12;
  if (!v12)
  {
    id v9 = 0LL;
    uint64_t v17 = 0LL;
    goto LABEL_35;
  }

  id v42 = v11;
  NSDataDecompress(v12, v13, &v42);
  id v9 = (void *)objc_claimAutoreleasedReturnValue();
  id v15 = v42;

  if (!v9)
  {
    if (v15) {
      unsigned int v31 = NSErrorToOSStatusEx(v15, 0LL);
    }
    else {
      unsigned int v31 = -6700;
    }
    id v9 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v14 = 0LL;
    unsigned int v45 = v31;
    goto LABEL_51;
  }

  uint64_t v14 = (CUAppleIDClient *)*(id *)(a1 + 840);
  if (!v14)
  {
    uint64_t v16 = objc_alloc_init(&OBJC_CLASS___CUAppleIDClient);
    uint64_t v14 = v16;
    *(void *)(a1 + 840) = v16;
    if (*(void *)(a1 + 816)) {
      -[CUAppleIDClient setMyAppleID:](v16, "setMyAppleID:");
    }
  }

  uint64_t v17 = (CUAppleIDClient *)*(id *)(a1 + 848);
  if (!v17)
  {
    uint64_t v17 = objc_alloc_init(&OBJC_CLASS___CUAppleIDClient);
    *(void *)(a1 + 848) = v17;
  }

  -[CUAppleIDClient setMyInfoClient:](v17, "setMyInfoClient:", v14);
  if (*(void *)(a1 + 824)) {
    -[CUAppleIDClient setPeerAppleID:](v17, "setPeerAppleID:");
  }
  if (*(void *)(a1 + 832)) {
    -[CUAppleIDClient setPeerAppleIDs:](v17, "setPeerAppleIDs:");
  }
  -[CUAppleIDClient setPeerCertificateData:](v17, "setPeerCertificateData:", v10);
  -[CUAppleIDClient setPeerValidationData:](v17, "setPeerValidationData:", v9);
  uint64_t v6 = TLV8CopyCoalesced(a2, a3, 10, &v44, (int *)&v45);
  if (!v6 || !v44)
  {
    unsigned int v45 = -6711;
    id v11 = v15;
LABEL_39:
    if (!v6) {
      goto LABEL_53;
    }
    goto LABEL_52;
  }

  uint64_t v18 = [objc_alloc(MEMORY[0x189603F48]) initWithBytesNoCopy:v6 length:v44];
  if (!v18)
  {
    unsigned int v45 = -6743;
LABEL_51:
    id v11 = v15;
    goto LABEL_52;
  }

  uint64_t v19 = (void *)v18;
  uint64_t v6 = (unsigned __int8 *)objc_alloc_init(MEMORY[0x189603FB8]);
  [v6 appendBytes:a1 + 574 length:32];
  [v6 appendBytes:a1 + 446 length:32];
  id v41 = v15;
  BOOL v20 = -[CUAppleIDClient verifyData:signature:error:](v17, "verifyData:signature:error:", v6, v19, &v41);
  id v11 = v41;

  if (v20)
  {
    if (*(void *)(a1 + 824)) {
      BOOL v25 = 0LL;
    }
    else {
      BOOL v25 = *(void *)(a1 + 832) == 0LL;
    }
    id v40 = v11;
    BOOL v26 = -[CUAppleIDClient validatePeerWithFlags:error:](v17, "validatePeerWithFlags:error:", v25, &v40);
    id v27 = v40;

    if (v26) {
      goto LABEL_26;
    }
    unsigned int v37 = [v27 code] ? objc_msgSend(v27, "code") : -6754;
    unsigned int v45 = v37;
    uint64_t v38 = *(int **)(a1 + 16);
    if (*v38 > 60) {
      goto LABEL_26;
    }
    if (*v38 == -1)
    {
      uint64_t v38 = *(int **)(a1 + 16);
    }

    LogPrintF( (uint64_t)v38,  (uint64_t)"OSStatus _PairingSessionAppleIDVerifyPeer(PairingSessionRef, const uint8_t *, const uint8_t *)",  0x3Cu,  (uint64_t)"### AppleID validate peer failed: %{error}\n",  v33,  v34,  v35,  v36,  (char)v27);
LABEL_26:
    id v11 = v27;
    goto LABEL_27;
  }

  unsigned int v45 = -6754;
  uint64_t v32 = *(int **)(a1 + 16);
  if (*v32 <= 60)
  {
    if (*v32 == -1)
    {
      uint64_t v32 = *(int **)(a1 + 16);
    }

    LogPrintF( (uint64_t)v32,  (uint64_t)"OSStatus _PairingSessionAppleIDVerifyPeer(PairingSessionRef, const uint8_t *, const uint8_t *)",  0x3Cu,  (uint64_t)"### AppleID verify peer signature failed: %{error}\n",  v21,  v22,  v23,  v24,  (char)v11);
  }

uint64_t PairingSessionFindPeerEx( uint64_t a1, char *__s, size_t a3, _OWORD *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9 = a3;
  uint64_t v91 = *MEMORY[0x1895F89C0];
  unint64_t v12 = *(unsigned int (**)(char *, size_t, _OWORD *, void))(a1 + 64);
  if (v12)
  {
    if (v12(__s, a3, a4, *(void *)(a1 + 24))) {
      return 4294960569LL;
    }
    else {
      return 0LL;
    }
  }

  if ((*(_BYTE *)(a1 + 100) & 4) != 0)
  {
    uint64_t v86 = 0LL;
    char v87 = &v86;
    uint64_t v88 = 0x2020000000LL;
    int v89 = 1;
    uint64_t v80 = 0LL;
    uint64_t v81 = &v80;
    uint64_t v82 = 0x3032000000LL;
    uint64_t v83 = __Block_byref_object_copy__12007;
    uint64_t v84 = __Block_byref_object_dispose__12008;
    id v85 = 0LL;
    int v34 = StringToUUIDEx(__s, a3, 0, 0LL, &v90, a6, a7, a8);
    *((_DWORD *)v87 + 6) = v34;
    if (v34)
    {
      __int128 v90 = 0uLL;
      int v35 = TextToHardwareAddress(__s, v9, 6LL, (_BYTE *)&v90 + 10);
      *((_DWORD *)v87 + 6) = v35;
      if (v35)
      {
        unsigned int v37 = 0LL;
        uint64_t v39 = 0LL;
        id v54 = 0LL;
        int v58 = 0LL;
        uint64_t v59 = 0LL;
        uint64_t v38 = 0LL;
        goto LABEL_73;
      }

      id v36 = objc_alloc(NSString);
      if (v9 == -1LL) {
        size_t v9 = strlen(__s);
      }
      unsigned int v37 = (void *)[v36 initWithBytes:__s length:v9 encoding:4];
    }

    else
    {
      unsigned int v37 = 0LL;
    }

    uint64_t v38 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:&v90];
    if (v38)
    {
      uint64_t v39 = objc_alloc_init(&OBJC_CLASS___CUPairedPeer);
      -[CUPairedPeer setIdentifier:](v39, "setIdentifier:", v38);
      if (v37) {
        -[CUPairedPeer setIdentifierStr:](v39, "setIdentifierStr:", v37);
      }
      unsigned int v40 = *(_DWORD *)(a1 + 100);
      if ((v40 & 0x80000000) == 0) {
        uint64_t v41 = (v40 >> 21) & 0x10 | (v40 >> 19) & 8;
      }
      else {
        uint64_t v41 = (v40 >> 21) & 0x10 | (v40 >> 19) & 8 | 0x100LL;
      }
      id v42 = _Block_copy(*(const void **)(a1 + 968));
      id v43 = v42;
      uint64_t v44 = v41 | (v40 >> 1) & 4 | (v40 >> 21) & 0x20;
      if (v42)
      {
        v76[0] = 0LL;
        uint64_t v45 = (*((void (**)(void *, CUPairedPeer *, uint64_t, id *))v42 + 2))(v42, v39, v44, v76);
        id v46 = v76[0];
        uint64_t v47 = (void *)v81[5];
        v81[5] = v45;

        if (!v46)
        {
          if (v81[5]) {
            int v60 = 0;
          }
          else {
            int v60 = -6700;
          }
          goto LABEL_62;
        }

        uint64_t v48 = *(int **)(a1 + 16);
        if (*v48 <= 90)
        {
          if (*v48 != -1)
          {
LABEL_32:
            NSPrintF();
            unsigned int v75 = (void *)objc_claimAutoreleasedReturnValue();
            LogPrintF( (uint64_t)v48,  (uint64_t)"OSStatus _PairingSessionFindPeerPairingManager(PairingSessionRef, const void *, size_t, uint8_t * , CFDictionaryRef *)",  0x5Au,  (uint64_t)"### FindPeerHandler failed: %@, %@",  v49,  v50,  v51,  v52,  (char)v39);

            goto LABEL_59;
          }

          if (_LogCategory_Initialize(*(void *)(a1 + 16), 0x5Au))
          {
            uint64_t v48 = *(int **)(a1 + 16);
            goto LABEL_32;
          }
        }

void sub_186B1B4F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

CFDictionaryRef _PairingSessionVerifyACL(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  unsigned int v6 = 0;
  uint64_t result = *(const __CFDictionary **)(a1 + 176);
  if (result)
  {
    if (CFDictionaryGetCount(result) < 1)
    {
      return 0LL;
    }

    else if (a2)
    {
      CFDictionaryApplyFunction( *(CFDictionaryRef *)(a1 + 176),  (CFDictionaryApplierFunction)_PairingSessionVerifyACLApplier,  &v5);
      return (const __CFDictionary *)v6;
    }

    else
    {
      return (const __CFDictionary *)4294960523LL;
    }
  }

  return result;
}

uint64_t _ExtractGroupInfoTLV(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  id v4 = TLV8CopyCoalesced(a2, a3, 30, &v9, 0LL);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  unsigned int v6 = (__CFString *)_OPACKDecodeBytes(0LL, v4, v9, 0, &v10);
  free(v5);
  if (v6)
  {
    CFTypeID v7 = CFGetTypeID(v6);
    if (v7 != CFDictionaryGetTypeID())
    {
      unsigned int v10 = -6756;
      CFRelease(v6);
      return v10;
    }

    PairingSessionSetProperty(a1, @"groupInfoPeer", v6);
    CFRelease(v6);
    return 0;
  }

  return v10;
}

uint64_t _VerifyServerM4(uint64_t a1, void *a2, size_t *a3)
{
  v36[38] = *MEMORY[0x1895F89C0];
  __srCC_SHA1_CTX c = v36;
  __int128 v34 = xmmword_186B49CC0;
  int v35 = 0LL;
  int64_t v29 = (int8x16_t *)&v32;
  __int128 v30 = xmmword_186B49CC0;
  uint64_t v31 = 0LL;
  unsigned int v6 = (_BYTE *)(a1 + 120);
  uint64_t v7 = TLV8BufferAppend((uint64_t)&__src, 6, (char *)(a1 + 120), 1uLL);
  if (!(_DWORD)v7)
  {
    if ((*(_DWORD *)(a1 + 100) & 0x20000000) != 0) {
      uint64_t v8 = "PV-Msg4s";
    }
    else {
      uint64_t v8 = "PV-Msg04";
    }
    uint64_t v9 = _AddGroupInfoTLV(a1, (uint64_t)&v29);
    if ((_DWORD)v9
      || (*(_BYTE *)(a1 + 103) & 0x20) != 0 && (uint64_t v9 = _PairingSessionAppleIDProveSelf(a1, (uint64_t)&v29), (_DWORD)v9))
    {
      uint64_t v7 = v9;
      goto LABEL_36;
    }

    if ((void)v30)
    {
      uint64_t v14 = (int8x16_t *)malloc(v30 + 16);
      if (!v14)
      {
LABEL_42:
        uint64_t v7 = 4294960568LL;
        goto LABEL_36;
      }

      uint64_t v15 = v14;
      CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  a1 + 638,  32LL,  "Pair-Verify-Encrypt-Salt",  0x18uLL,  (uint64_t)"Pair-Verify-Encrypt-Info",  24LL,  0x20uLL,  a1 + 414);
      _chacha20_poly1305_encrypt_all((_DWORD *)(a1 + 414), v8, 8LL, 0LL, 0LL, v29, v30, v15, (uint64_t)v15->i64 + v30);
      uint64_t v7 = TLV8BufferAppend((uint64_t)&__src, 5, v15->i8, v30 + 16);
      free(v15);
      if ((_DWORD)v7) {
        goto LABEL_36;
      }
    }

    size_t v16 = v34;
    uint64_t v17 = v35;
    if (v35) {
      goto LABEL_18;
    }
    else {
      size_t v18 = v34;
    }
    uint64_t v19 = malloc(v18);
    if (v19)
    {
      uint64_t v17 = v19;
      if (v16) {
        memcpy(v19, __src, v16);
      }
LABEL_18:
      __srCC_SHA1_CTX c = v36;
      *(void *)&__int128 v34 = 0LL;
      int v35 = 0LL;
      *a2 = v17;
      *a3 = v16;
      if ((*(_BYTE *)(a1 + 100) & 2) != 0)
      {
        CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  a1 + 638,  32LL,  "Pair-Verify-ResumeSessionID-Salt",  0x20uLL,  (uint64_t)"Pair-Verify-ResumeSessionID-Info",  32LL,  8uLL,  (uint64_t)&v28);
        uint64_t v20 = v28;
        *(void *)(a1 + 376) = v28;
        _PairingSaveResumeState( a1,  *(const void **)(a1 + 296),  *(void *)(a1 + 304),  *(const void **)(a1 + 248),  *(void *)(a1 + 256),  v20,  (_OWORD *)(a1 + 638));
      }

      uint64_t v21 = *(int **)(a1 + 16);
      int v22 = *v21;
      if (*v21 >= 31)
      {
        uint64_t v7 = 0LL;
        *unsigned int v6 = 5;
        goto LABEL_36;
      }

      if (v22 == -1)
      {
        BOOL v24 = _LogCategory_Initialize(*(void *)(a1 + 16), 0x1Eu);
        uint64_t v21 = *(int **)(a1 + 16);
        if (!v24) {
          goto LABEL_31;
        }
        int v22 = *v21;
      }

      char v23 = v22 > 10 || v22 == -1 && !_LogCategory_Initialize((uint64_t)v21, 0xAu);
      LogPrintF( (uint64_t)v21,  (uint64_t)"OSStatus _VerifyServerM4(PairingSessionRef, uint8_t **, size_t *)",  0x1Eu,  (uint64_t)"Pair-verify server M4 -- finish response\n%?{end}%1{tlv8}\n",  v10,  v11,  v12,  v13,  v23);
      uint64_t v21 = *(int **)(a1 + 16);
LABEL_31:
      int v25 = *v21;
      *unsigned int v6 = 5;
      if (v25 <= 30)
      {
        if (v25 == -1)
        {
          uint64_t v21 = *(int **)(a1 + 16);
        }

        LogPrintF( (uint64_t)v21,  (uint64_t)"OSStatus _VerifyServerM4(PairingSessionRef, uint8_t **, size_t *)",  0x1Eu,  (uint64_t)"Pair-verify server done\n",  v10,  v11,  v12,  v13,  v27);
      }

void _PairingSessionUpdateTranscript(uint64_t a1, UInt8 *bytes, CFIndex length, UInt8 *a4, CFIndex a5)
{
  if (*(_DWORD *)(a1 + 680))
  {
    CFMutableDictionaryRef Mutable = *(__CFData **)(a1 + 672);
    if (Mutable || (CFMutableDictionaryRef Mutable = CFDataCreateMutable(0LL, 0LL), (*(void *)(a1 + 672) = Mutable) != 0LL))
    {
      if (bytes && length) {
        CFDataAppendBytes(Mutable, bytes, length);
      }
      if (a4)
      {
        if (a5) {
          CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 672), a4, a5);
        }
      }
    }
  }

uint64_t _AddGroupInfoTLV(uint64_t a1, uint64_t a2)
{
  id v4 = *(const __CFDictionary **)(a1 + 344);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  TypedValue = (const __CFString *)CFDictionaryGetTypedValue(v4, @"groupInfoSelf", TypeID, 0LL);
  if (!TypedValue)
  {
    uint64_t v7 = *(void **)(a1 + 264);
    if (v7) {
      id v8 = v7;
    }
    [v7 info];
    uint64_t v9 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
    CFTypeID v10 = CFDictionaryGetTypeID();
    TypedValue = (const __CFString *)CFDictionaryGetTypedValue(v9, @"groupInfo", v10, 0LL);

    if (!TypedValue) {
      return 0LL;
    }
  }

  DataCFMutableDictionaryRef Mutable = OPACKEncoderCreateDataMutable(TypedValue, 0, (int *)&v16);
  if (!DataMutable) {
    return v16;
  }
  uint64_t v12 = DataMutable;
  BytePtr = (char *)CFDataGetBytePtr(DataMutable);
  size_t Length = CFDataGetLength(v12);
  unsigned int v16 = TLV8BufferAppend(a2, 30, BytePtr, Length);
  CFRelease(v12);
  uint64_t result = v16;
  if (!v16) {
    return 0LL;
  }
  return result;
}

unint64_t _PairingSessionVerifyACLApplier(unint64_t result, uint64_t a2, uint64_t a3)
{
  if (!*(_DWORD *)(a3 + 8))
  {
    id v4 = (const void *)result;
    uint64_t v5 = *(const __CFDictionary **)a3;
    uint64_t result = CFDictionaryGetInt64(*(const __CFDictionary **)a3, (const void *)result, 0LL);
    if (!result)
    {
      uint64_t result = CFDictionaryGetInt64(v5, @"com.apple.admin", 0LL);
      if (!result)
      {
        uint64_t result = CFEqual(v4, @"com.apple.ScreenCapture");
        if (!(_DWORD)result || (uint64_t result = CFDictionaryGetInt64(v5, @"com.apple.developer", 0LL)) == 0) {
          *(_DWORD *)(a3 + _Block_object_dispose((const void *)(v31 - 144), 8) = -6773;
        }
      }
    }
  }

  return result;
}

uint64_t __Block_byref_object_copy__12007(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__12008(uint64_t a1)
{
}

uint64_t _PairingSessionCopyIdentityPairingManager( uint64_t a1, uint64_t a2, char **a3, void *a4, _OWORD *a5, _OWORD *a6)
{
  uint64_t v61 = 0LL;
  dispatch_semaphore_t v62 = &v61;
  uint64_t v63 = 0x2020000000LL;
  int v64 = 1;
  uint64_t v55 = 0LL;
  __int128 v56 = &v55;
  uint64_t v57 = 0x3032000000LL;
  int v58 = __Block_byref_object_copy__12007;
  uint64_t v59 = __Block_byref_object_dispose__12008;
  id v60 = 0LL;
  unint64_t v11 = ((unint64_t)*(unsigned int *)(a1 + 100) >> 1) & 4 | a2;
  uint64_t v12 = (dispatch_semaphore_s *)_Block_copy(*(const void **)(a1 + 960));
  if (v12)
  {
    uint64_t v13 = v12;
    id v54 = 0LL;
    uint64_t v14 = (*((void (**)(dispatch_semaphore_s *, unint64_t, id *))v12 + 2))(v12, v11, &v54);
    id v15 = v54;
    unsigned int v16 = (void *)v56[5];
    v56[5] = v14;

    if (!v15)
    {
      if (v56[5]) {
        int v30 = 0;
      }
      else {
        int v30 = -6700;
      }
      goto LABEL_24;
    }

    uint64_t v17 = *(int **)(a1 + 16);
    if (*v17 <= 90)
    {
      if (*v17 != -1)
      {
LABEL_5:
        NSPrintF();
        size_t v18 = (void *)objc_claimAutoreleasedReturnValue();
        LogPrintF( (uint64_t)v17,  (uint64_t)"OSStatus _PairingSessionCopyIdentityPairingManager(PairingSessionRef, CUPairingOptions, char **, CFDa taRef *, uint8_t *, uint8_t *)",  0x5Au,  (uint64_t)"### CopyIdentityHandler failed: %@",  v19,  v20,  v21,  v22,  (char)v18);

        goto LABEL_21;
      }

      if (_LogCategory_Initialize(*(void *)(a1 + 16), 0x5Au))
      {
        uint64_t v17 = *(int **)(a1 + 16);
        goto LABEL_5;
      }
    }

void sub_186B1C184( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void _PairingSessionDeleteIdentity( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (const void *)*MEMORY[0x18960BAE0];
  CFTypeID v10 = (const __CFArray *)KeychainCopyMatchingFormatted( 0LL,  (uint64_t)"{%kO=%O%kO=%O%kO=%i%kO=%O%kO=%O%kO=%O%kO=%O}",  a3,  a4,  a5,  a6,  a7,  a8,  *MEMORY[0x18960BB38]);
  if (v10)
  {
    uint64_t v11 = v10;
    CFIndex Count = CFArrayGetCount(v10);
    if (Count >= 1)
    {
      CFIndex v13 = Count;
      CFIndex v14 = 0LL;
      id v15 = (const void *)*MEMORY[0x18960BE80];
      do
      {
        CFTypeID TypeID = CFDictionaryGetTypeID();
        TypedValueAtIndex = CFArrayGetTypedValueAtIndex(v11, v14, TypeID, 0LL);
        if (TypedValueAtIndex)
        {
          size_t v18 = TypedValueAtIndex;
          if (*(_DWORD *)(a1 + 768) == CFDictionaryGetInt64(TypedValueAtIndex, v9, &v27))
          {
            CFTypeID v19 = CFDataGetTypeID();
            CFDictionaryGetTypedValue(v18, v15, v19, &v27);
            if (!v27) {
              int v27 = KeychainDeleteFormatted((uint64_t)"{%kO=%O}", v20, v21, v22, v23, v24, v25, v26, (uint64_t)v15);
            }
          }
        }

        ++v14;
      }

      while (v13 != v14);
    }

    CFRelease(v11);
  }

uint64_t _MFiClientVerify( uint64_t a1, unsigned __int8 *a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, char *a7, unint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  id v40 = 0LL;
  unsigned int v37 = 0LL;
  uint64_t v17 = (int8x16_t *)TLV8CopyCoalesced(a2, &a2[a3], 5, &v43, (int *)&GroupInfoTLV);
  uint64_t v22 = (unsigned __int8 *)v17;
  if (GroupInfoTLV) {
    goto LABEL_18;
  }
  if (v43 <= 0xF)
  {
    unsigned int v33 = -6743;
LABEL_29:
    unsigned int GroupInfoTLV = v33;
    goto LABEL_16;
  }

  uint64_t v23 = &v17[-1].u8[v43];
  unsigned int GroupInfoTLV = _chacha20_poly1305_decrypt_all( (_DWORD *)(a1 + 414),  a4,  8LL,  0LL,  0LL,  v17,  v43 - 16,  v17,  (uint64_t)v23,  16LL);
  if (!GroupInfoTLV)
  {
    unsigned int GroupInfoTLV = TLV8GetOrCopyCoalesced(v22, v23, 10, &v42, (size_t *)&v41, (unsigned __int8 **)&v40, 0LL);
    if (!GroupInfoTLV)
    {
      unsigned int GroupInfoTLV = TLV8GetOrCopyCoalesced(v22, v23, 9, &v39, (size_t *)&v38, (unsigned __int8 **)&v37, 0LL);
      if (!GroupInfoTLV)
      {
        CryptoHKDF((uint64_t)_kCryptoHashDescriptor_SHA512, a5, a6, a7, a8, a9, a10, 0x20uLL, (uint64_t)v45);
        CFIndex v25 = v38;
        uint64_t v24 = v39;
        unsigned int GroupInfoTLV = MFiPlatform_VerifySignatureEx(v45, 32LL, v42, v41, v39, v38, 0LL, v26);
        if (!GroupInfoTLV)
        {
          CFIndex length = 0LL;
          bytes = 0LL;
          uint64_t v34 = 0LL;
          TLV8GetOrCopyCoalesced(v22, v23, 28, &bytes, (size_t *)&length, (unsigned __int8 **)&v34, 0LL);
          if (bytes)
          {
            CFDataRef v27 = CFDataCreate(0LL, bytes, length);
            if (v34) {
              free(v34);
            }
            if (!v27)
            {
LABEL_31:
              unsigned int v33 = -6728;
              goto LABEL_29;
            }

            unsigned int GroupInfoTLV = PairingSessionSetProperty(a1, @"productData", v27);
            CFRelease(v27);
            if (GroupInfoTLV) {
              goto LABEL_16;
            }
          }

          if (!a11 || (unsigned int GroupInfoTLV = _ExtractGroupInfoTLV(a1, v22, v23)) == 0)
          {
            CFDataRef v28 = CFDataCreate(0LL, v24, v25);
            if (v28)
            {
              CFDataRef v29 = v28;
              unsigned int GroupInfoTLV = PairingSessionSetProperty(a1, @"certificate", v28);
              CFRelease(v29);
              goto LABEL_16;
            }

            goto LABEL_31;
          }
        }
      }
    }
  }

uint64_t _PairingThrottle()
{
  if (gPairingMaxTries)
  {
    if (gPairingTries >= gPairingMaxTries)
    {
      uint64_t v4 = 4294960532LL;
      goto LABEL_20;
    }

    ++gPairingTries;
    goto LABEL_19;
  }

  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  uint64_t v0 = UpTicksPerSecond_sTicksPerSecond;
  uint64_t v1 = mach_absolute_time();
  if (!gPairingThrottleNextTicks || (uint64_t v2 = gPairingThrottleNextTicks - v1, gPairingThrottleNextTicks <= v1))
  {
    unsigned int v5 = 2 * gPairingThrottleCounter;
    if (gPairingThrottleCounter) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 1LL;
    }
    gPairingThrottleCounter = v6;
    gPairingThrottleNextTicks = v1 + v0 * v6;
LABEL_19:
    uint64_t v4 = 4294960539LL;
    goto LABEL_20;
  }

  if (UpTicksPerSecond_sOnce != -1)
  {
    uint64_t v8 = gPairingThrottleNextTicks - v1;
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
    uint64_t v2 = v8;
  }

  unint64_t v3 = v2 / UpTicksPerSecond_sTicksPerSecond;
  if (v2 == v2 / UpTicksPerSecond_sTicksPerSecond * UpTicksPerSecond_sTicksPerSecond) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = (v3 + 1);
  }
LABEL_20:
  pthread_mutex_unlock(&gPairingGlobalLock);
  return v4;
}

uint64_t PairingResetThrottle()
{
  gPairingThrottleNextTicks = 0LL;
  gPairingThrottleCounter = 0;
  gPairingTries = 0;
  return pthread_mutex_unlock(&gPairingGlobalLock);
}

void _ServerEncryptExtra(uint64_t a1, uint64_t a2)
{
  v21[38] = *MEMORY[0x1895F89C0];
  uint64_t v18 = (int8x16_t *)v21;
  __int128 v19 = xmmword_186B49CC0;
  uint64_t v20 = 0LL;
  uint64_t v4 = *(const __CFDictionary **)(a1 + 344);
  CFTypeID TypeID = CFDataGetTypeID();
  TypedValue = CFDictionaryGetTypedValue(v4, @"productData", TypeID, 0LL);
  if (!TypedValue
    || (CFIndex v14 = TypedValue,
        BytePtr = (char *)CFDataGetBytePtr(TypedValue),
        size_t Length = CFDataGetLength(v14),
        int v9 = TLV8BufferAppend((uint64_t)&v18, 28, BytePtr, Length),
        LOBYTE(v14) = v9,
        !v9))
  {
    CFIndex v14 = (const __CFData *)v19;
    if (!(void)v19)
    {
      if (v20) {
        free(v20);
      }
      return;
    }

    id v15 = (int8x16_t *)malloc(v19 + 16);
    if (v15)
    {
      unsigned int v16 = v15;
      _chacha20_poly1305_encrypt_all( (_DWORD *)(a1 + 414),  "PS-Msg04",  8LL,  0LL,  0LL,  v18,  (unint64_t)v14,  v16,  (uint64_t)v14 + (void)v16);
      LODWORD(v14) = TLV8BufferAppend(a2, 5, v16->i8, v19 + 16);
      free(v16);
      if (v20)
      {
        free(v20);
        uint64_t v20 = 0LL;
      }

      if (!(_DWORD)v14) {
        return;
      }
      goto LABEL_10;
    }

    LOBYTE(v14) = -72;
  }

  if (v20)
  {
    free(v20);
    uint64_t v20 = 0LL;
  }

CFTypeRef _PairingSessionIntersectACL(uint64_t a1, CFDictionaryRef theDict, int *a3)
{
  uint64_t v6 = *(const void **)(a1 + 176);
  context[0] = 0LL;
  context[1] = v6;
  int v10 = 0;
  if (CFDictionaryGetCount(theDict) >= 1)
  {
    uint64_t v7 = *(const __CFDictionary **)(a1 + 176);
    if (!v7 || CFDictionaryGetCount(v7) <= 0)
    {
      CFTypeRef result = 0LL;
      int v10 = -6773;
      goto LABEL_5;
    }

    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)_PairingSessionIntersectACLApplier, context);
    CFTypeRef result = context[0];
    if (!v10 || !context[0]) {
      goto LABEL_5;
    }
    CFRelease(context[0]);
  }

  CFTypeRef result = 0LL;
LABEL_5:
  if (a3) {
    *a3 = v10;
  }
  return result;
}

uint64_t _PairingSessionVerifyAllowed(uint64_t a1)
{
  uint64_t v2 = *(const __CFDictionary **)(a1 + 344);
  CFTypeID TypeID = CFArrayGetTypeID();
  uint64_t result = (uint64_t)CFDictionaryGetTypedValue(v2, @"allowedMACAddresses", TypeID, 0LL);
  if (result)
  {
    unsigned int v5 = (const __CFArray *)result;
    uint64_t v6 = *(const __CFDictionary **)(a1 + 312);
    CFTypeID v7 = CFDataGetTypeID();
    TypedValue = CFDictionaryGetTypedValue(v6, @"mac", v7, 0LL);
    int v9 = *(const __CFDictionary **)(a1 + 312);
    CFTypeID v10 = CFDataGetTypeID();
    uint64_t v11 = CFDictionaryGetTypedValue(v9, @"wifiMAC", v10, 0LL);
    if ((unint64_t)TypedValue | (unint64_t)v11)
    {
      uint64_t v12 = v11;
      CFIndex Count = CFArrayGetCount(v5);
      if (Count < 1)
      {
        return 4294960520LL;
      }

      else
      {
        CFIndex v14 = Count;
        CFIndex v15 = 0LL;
        while (1)
        {
          CFTypeID v16 = CFDataGetTypeID();
          TypedValueAtIndex = CFArrayGetTypedValueAtIndex(v5, v15, v16, 0LL);
          if (TypedValueAtIndex)
          {
            uint64_t v18 = TypedValueAtIndex;
            if (TypedValue)
            {
              if (CFEqual(TypedValueAtIndex, TypedValue)) {
                break;
              }
            }

            if (v12 && CFEqual(v18, v12)) {
              break;
            }
          }

          if (v14 == ++v15) {
            return 4294960520LL;
          }
        }

        return 0LL;
      }
    }

    else
    {
      return 4294960535LL;
    }
  }

  return result;
}

uint64_t PairingSessionSavePeer( uint64_t a1, char *__s, size_t a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9 = a3;
  uint64_t v54 = *MEMORY[0x1895F89C0];
  if (a3 == -1LL) {
    size_t v9 = strlen(__s);
  }
  uint64_t v12 = *(uint64_t (**)(char *, size_t, unsigned __int8 *, void))(a1 + 72);
  if (v12) {
    return v12(__s, v9, a4, *(void *)(a1 + 24));
  }
  if ((*(_BYTE *)(a1 + 100) & 4) == 0) {
    return _PairingSessionSavePeerKeychain(a1, __s, v9, a4, 0);
  }
  uint64_t v49 = 0LL;
  uint64_t v50 = &v49;
  uint64_t v51 = 0x2020000000LL;
  int v52 = 1;
  int v14 = StringToUUIDEx(__s, v9, 0, 0LL, &v53, a6, a7, a8);
  *((_DWORD *)v50 + 6) = v14;
  if (v14)
  {
    __int128 v53 = 0uLL;
    uint64_t v15 = TextToHardwareAddress(__s, v9, 6LL, (_BYTE *)&v53 + 10);
    *((_DWORD *)v50 + 6) = v15;
    if ((_DWORD)v15)
    {
      uint64_t v37 = v15;
      uint64_t v17 = 0LL;
      id v36 = 0LL;
      uint64_t v38 = 0LL;
      id v39 = 0LL;
      CFTypeID v16 = 0LL;
      goto LABEL_33;
    }
  }

  CFTypeID v16 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:&v53];
  if (!v16)
  {
    uint64_t v17 = 0LL;
    id v36 = 0LL;
    uint64_t v38 = 0LL;
    id v39 = 0LL;
    size_t v43 = v50;
    uint64_t v37 = 4294960588LL;
    goto LABEL_35;
  }

  uint64_t v17 = objc_alloc_init(&OBJC_CLASS___CUPairedPeer);
  -[CUPairedPeer setIdentifier:](v17, "setIdentifier:", v16);
  unsigned int v18 = *(_DWORD *)(a1 + 96);
  if (v18 <= 0xD && ((1 << v18) & 0x2A2A) != 0) {
    __int128 v19 = (void *)(a1 + 176);
  }
  else {
    __int128 v19 = (void *)(a1 + 280);
  }
  -[CUPairedPeer setAcl:](v17, "setAcl:", *v19);
  uint64_t v20 = *(const __CFDictionary **)(a1 + 312);
  CFTypeID TypeID = CFDataGetTypeID();
  -[CUPairedPeer setAltIRK:](v17, "setAltIRK:", CFDictionaryGetTypedValue(v20, @"altIRK", TypeID, 0LL));
  CFMutableDictionaryRef v22 = PairingSessionCopyPeerInfo((void *)a1, 0LL);
  -[CUPairedPeer setInfo:](v17, "setInfo:", v22);

  [MEMORY[0x189603F48] dataWithBytes:a4 length:32];
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  -[CUPairedPeer setPublicKey:](v17, "setPublicKey:", v23);

  unint64_t v24 = *(unsigned int *)(a1 + 100);
  CFIndex v25 = _Block_copy(*(const void **)(a1 + 976));
  uint64_t v26 = v25;
  uint64_t v27 = (v24 >> 1) & 4;
  if (v25)
  {
    v46[0] = 0LL;
    (*((void (**)(void *, CUPairedPeer *, unint64_t, id *))v25 + 2))(v25, v17, (v24 >> 1) & 4, v46);
    id v28 = v46[0];
    CFDataRef v29 = v28;
    if (!v28)
    {
LABEL_29:
      *((_DWORD *)v50 + 6) = (_DWORD)v28;

      id v36 = 0LL;
      uint64_t v38 = 0LL;
      id v39 = 0LL;
      goto LABEL_30;
    }

    int v30 = *(int **)(a1 + 16);
    if (*v30 <= 90)
    {
      if (*v30 == -1)
      {
        if (!_LogCategory_Initialize(*(void *)(a1 + 16), 0x5Au)) {
          goto LABEL_28;
        }
        int v30 = *(int **)(a1 + 16);
      }

      NSPrintF();
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
      LogPrintF( (uint64_t)v30,  (uint64_t)"OSStatus _PairingSessionSavePeerPairingManager(PairingSessionRef, const void *, size_t, const uint8_t *)",  0x5Au,  (uint64_t)"### SavePeerHandler failed: %@, %@",  v31,  v32,  v33,  v34,  (char)v17);
    }

void sub_186B1D0FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

__CFDictionary *_PairingSessionGetSelfInfo(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = *(__CFDictionary **)(a1 + 328);
  if (!Mutable)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    if (Mutable)
    {
      if ((*(_BYTE *)(a1 + 100) & 4) != 0)
      {
        value = 0LL;
        uint64_t v17 = 0LL;
        _PairingSessionCopyIdentityPairingManager(a1, 3LL, &v17, &value, 0LL, 0LL);
        if (v17)
        {
          CFDictionarySetCString(Mutable, @"accountID", v17, -1LL);
          free(v17);
        }

        if (value)
        {
          CFDictionarySetValue(Mutable, @"altIRK", value);
          CFRelease(value);
        }
      }

      unint64_t v3 = (const void *)GestaltCopyAnswer(@"UserAssignedDeviceName", 0LL, 0LL);
      if (v3)
      {
        uint64_t v4 = v3;
        CFDictionarySetValue(Mutable, @"name", v3);
        CFRelease(v4);
      }

      unsigned int v5 = (const void *)GestaltCopyAnswer(@"BluetoothAddress", 0LL, 0LL);
      if (v5)
      {
        uint64_t v6 = v5;
        CFDictionarySetValue(Mutable, @"btAddr", v5);
        CFRelease(v6);
      }

      GetPrimaryMACAddress((char *)bytes, (int *)&v17);
      if (!(_DWORD)v17) {
        CFDictionarySetData(Mutable, @"mac", bytes, 6LL);
      }
      CFTypeID v7 = (const void *)GestaltCopyAnswer(@"ProductType", 0LL, 0LL);
      if (v7)
      {
        uint64_t v8 = v7;
        CFDictionarySetValue(Mutable, @"model", v7);
        CFRelease(v8);
      }

      size_t v9 = (const void *)GestaltCopyAnswer(@"WifiAddressData", 0LL, 0LL);
      if (v9)
      {
        CFTypeID v10 = v9;
        CFDictionarySetValue(Mutable, @"wifiMAC", v9);
        CFRelease(v10);
      }

      uint64_t v11 = *(const __CFDictionary **)(a1 + 336);
      if (v11) {
        CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)_CFDictionaryMergeDictionaryApplier, Mutable);
      }
      uint64_t v12 = *(const __CFDictionary **)(a1 + 344);
      CFTypeID TypeID = CFDictionaryGetTypeID();
      TypedValue = CFDictionaryGetTypedValue(v12, @"groupInfoSelf", TypeID, 0LL);
      if (TypedValue) {
        CFDictionarySetValue(Mutable, @"groupInfo", TypedValue);
      }
      *(void *)(a1 + 32_Block_object_dispose(va, 8) = Mutable;
    }
  }

  return Mutable;
}

void _PairingSessionIntersectACLApplier(void *key, const void *a2, uint64_t a3)
{
  if (!*(_DWORD *)(a3 + 16))
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), key);
    if (Value && (CFTypeID v7 = Value, CFEqual(Value, a2)))
    {
      CFMutableDictionaryRef Mutable = *(__CFDictionary **)a3;
      if (*(void *)a3
        || (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]),
            (*(void *)a3 = Mutable) != 0LL))
      {
        CFDictionarySetValue(Mutable, key, v7);
        return;
      }

      int v9 = -6728;
    }

    else
    {
      int v9 = -6773;
    }

    *(_DWORD *)(a3 + 16) = v9;
  }

void _ClientDecryptExtra(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = (int8x16_t *)TLV8CopyCoalesced(a2, &a2[a3], 5, &v19, &v18);
  if (!v4) {
    return;
  }
  unsigned int v5 = (unsigned __int8 *)v4;
  if (v19 <= 0xF)
  {
    int v14 = -6743;
    goto LABEL_17;
  }

  uint64_t v6 = &v4[-1].u8[v19];
  int v18 = _chacha20_poly1305_decrypt_all( (_DWORD *)(a1 + 414),  "PS-Msg04",  8LL,  0LL,  0LL,  v4,  v19 - 16,  v4,  (uint64_t)v6,  16LL);
  if (!v18)
  {
    CFIndex length = 0LL;
    bytes = 0LL;
    uint64_t v15 = 0LL;
    TLV8GetOrCopyCoalesced(v5, v6, 28, &bytes, (size_t *)&length, (unsigned __int8 **)&v15, 0LL);
    if (bytes)
    {
      CFDataRef v7 = CFDataCreate(0LL, bytes, length);
      if (v15) {
        free(v15);
      }
      if (v7)
      {
        int v18 = PairingSessionSetProperty(a1, @"productData", v7);
        CFRelease(v7);
        goto LABEL_9;
      }

      int v14 = -6728;
LABEL_17:
      int v18 = v14;
    }
  }

uint64_t PairingSessionDeleteIdentity(uint64_t a1)
{
  return 0LL;
}

CFArrayRef PairingSessionCopyPeer(int a1, char *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v5 = _PairingSessionCopyPeers(a1, a2, a3, &v12);
  uint64_t v6 = v5;
  if (v12)
  {
    uint64_t v9 = 0LL;
  }

  else if (CFArrayGetCount(v5) <= 0)
  {
    uint64_t v9 = 0LL;
    int v12 = -6727;
  }

  else
  {
    CFTypeID TypeID = CFDictionaryGetTypeID();
    TypedValueAtIndex = CFArrayGetTypedValueAtIndex(v6, 0LL, TypeID, &v12);
    uint64_t v9 = 0LL;
    if (!v12)
    {
      uint64_t v10 = TypedValueAtIndex;
      CFRetain(TypedValueAtIndex);
      uint64_t v9 = v10;
    }
  }

  if (v6) {
    CFRelease(v6);
  }
  if (a4) {
    *a4 = v12;
  }
  return v9;
}

__CFArray *PairingSessionCopyPeers(int a1, _DWORD *a2)
{
  return _PairingSessionCopyPeers(a1, 0LL, 0LL, a2);
}

uint64_t PairingSessionDeletePeer( uint64_t a1, char *__s, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a1 + 100) & 4) != 0)
  {
    uint64_t v35 = 0LL;
    id v36 = &v35;
    uint64_t v37 = 0x2020000000LL;
    int v38 = 1;
    int v17 = StringToUUIDEx(__s, a3, 0, 0LL, &v39, a6, a7, a8);
    *((_DWORD *)v36 + 6) = v17;
    if (v17
      && (__int128 v39 = 0uLL, v18 = TextToHardwareAddress(__s, a3, 6LL, (_BYTE *)&v39 + 10), (*((_DWORD *)v36 + 6) = v18) != 0))
    {
      uint64_t v16 = v18;
    }

    else
    {
      size_t v19 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:&v39];
      if (v19)
      {
        uint64_t v20 = objc_alloc_init(&OBJC_CLASS___CUPairedPeer);
        -[CUPairedPeer setIdentifier:](v20, "setIdentifier:", v19);
        unint64_t v21 = *(unsigned int *)(a1 + 100);
        +[CUPairingDaemon sharedPairingDaemon](&OBJC_CLASS___CUPairingDaemon, "sharedPairingDaemon");
        CFMutableDictionaryRef v22 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v23 = v22;
        uint64_t v24 = (v21 >> 1) & 4;
        if (v22)
        {
          uint64_t v16 = [v22 removePairedPeer:v20 options:v24];
          *((_DWORD *)v36 + 6) = v16;
        }

        else
        {
          CFIndex v25 = objc_alloc_init(&OBJC_CLASS___CUPairingManager);
          dispatch_queue_t v26 = dispatch_queue_create( "OSStatus _PairingSessionDeletePeerPairingManager(PairingSessionRef, const void *, size_t)",  0LL);
          -[CUPairingManager setDispatchQueue:](v25, "setDispatchQueue:", v26);

          if ((*(_BYTE *)(a1 + 100) & 0x40) != 0) {
            -[CUPairingManager setTargetUserSession:](v25, "setTargetUserSession:", 1LL);
          }
          dispatch_semaphore_t v27 = dispatch_semaphore_create(0LL);
          v32[0] = MEMORY[0x1895F87A8];
          v32[1] = 3221225472LL;
          v32[2] = ___PairingSessionDeletePeerPairingManager_block_invoke;
          v32[3] = &unk_189F33CF0;
          uint64_t v34 = &v35;
          id v28 = v27;
          uint64_t v33 = v28;
          -[CUPairingManager removePairedPeer:options:completion:]( v25,  "removePairedPeer:options:completion:",  v20,  v24,  v32);

          dispatch_time_t v29 = dispatch_time(0LL, 120000000000LL);
          uint64_t v30 = dispatch_semaphore_wait(v28, v29);
          -[CUPairingManager invalidate](v25, "invalidate");
          if (v30)
          {
            *((_DWORD *)v36 + 6) = -6722;

            uint64_t v16 = 4294960574LL;
          }

          else
          {
            uint64_t v16 = *((unsigned int *)v36 + 6);
          }
        }
      }

      else
      {
        uint64_t v16 = 4294960588LL;
        *((_DWORD *)v36 + 6) = -6708;
      }
    }

    _Block_object_dispose(&v35, 8);
  }

  else
  {
    pthread_mutex_lock(&gPairingGlobalLock);
    _PairingSessionDeletePeer(a1, __s, a3, v11, v12, v13, v14, v15);
    pthread_mutex_unlock(&gPairingGlobalLock);
    return 0LL;
  }

  return v16;
}

void sub_186B1D96C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

uint64_t PairingSessionFindPeer( uint64_t a1, char *a2, size_t a3, _OWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return PairingSessionFindPeerEx(a1, a2, a3, a4, 0LL, a6, a7, a8);
}

uint64_t PairingSessionUpdatePeerInfo(uint64_t a1, char *__s, uint64_t a3, const void *a4)
{
  CFMutableDictionaryRef v22 = 0LL;
  if (a3 == -1) {
    strlen(__s);
  }
  pthread_mutex_lock(&gPairingGlobalLock);
  uint64_t Formatted = CFPropertyListCreateFormatted( 0LL,  (CFTypeRef *)&v22,  (uint64_t)"{%kO=%O%kO=%O%kO=%i%kO=%.*s%kO=%O}",  v6,  v7,  v8,  v9,  v10,  *MEMORY[0x18960BB38]);
  if (!(_DWORD)Formatted)
  {
    CFDataRef Data = CFPropertyListCreateData(0LL, a4, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL);
    if (Data)
    {
      CFDataRef v19 = Data;
      uint64_t Formatted = KeychainUpdateFormatted(v22, (uint64_t)"{%kO=%O}", v17, v18, v11, v12, v13, v14, *MEMORY[0x18960B928]);
      CFRelease(v19);
      if (!(_DWORD)Formatted) {
        goto LABEL_10;
      }
    }

    else
    {
      uint64_t Formatted = 4294960596LL;
    }
  }

  uint64_t v20 = *(int **)(a1 + 16);
  if (*v20 <= 60)
  {
    if (*v20 != -1)
    {
LABEL_8:
      LogPrintF( (uint64_t)v20,  (uint64_t)"OSStatus PairingSessionUpdatePeerInfo(PairingSessionRef, const void *, size_t, CFDictionaryRef)",  0x3Cu,  (uint64_t)"### Update %@ %.*s info failed: %#m\n",  v11,  v12,  v13,  v14,  *(void *)(a1 + 784));
      goto LABEL_10;
    }

    if (_LogCategory_Initialize((uint64_t)v20, 0x3Cu))
    {
      uint64_t v20 = *(int **)(a1 + 16);
      goto LABEL_8;
    }
  }

void PairingSessionSetCopyIdentityHandler_b(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3)
  {
    id v8 = v3;
    uint64_t v5 = [v3 copy];
    uint64_t v6 = *(const void **)(a1 + 960);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(a1 + 960) = v5;
    uint64_t v4 = v8;
  }

  else
  {
    uint64_t v7 = *(const void **)(a1 + 960);
    if (v7)
    {
      CFRelease(v7);
      uint64_t v4 = 0LL;
      *(void *)(a1 + 960) = 0LL;
    }
  }
}

void PairingSessionSetFindPeerHandler_b(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3)
  {
    id v8 = v3;
    uint64_t v5 = [v3 copy];
    uint64_t v6 = *(const void **)(a1 + 968);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(a1 + 96_Block_object_dispose(va, 8) = v5;
    uint64_t v4 = v8;
  }

  else
  {
    uint64_t v7 = *(const void **)(a1 + 968);
    if (v7)
    {
      CFRelease(v7);
      uint64_t v4 = 0LL;
      *(void *)(a1 + 96_Block_object_dispose(va, 8) = 0LL;
    }
  }
}

void PairingSessionSetSavePeerHandler_b(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3)
  {
    id v8 = v3;
    uint64_t v5 = [v3 copy];
    uint64_t v6 = *(const void **)(a1 + 976);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(a1 + 976) = v5;
    uint64_t v4 = v8;
  }

  else
  {
    uint64_t v7 = *(const void **)(a1 + 976);
    if (v7)
    {
      CFRelease(v7);
      uint64_t v4 = 0LL;
      *(void *)(a1 + 976) = 0LL;
    }
  }
}

uint64_t PairingSessionSetMyAppleID(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 816);
  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 816) = cf;
  if (v4) {
    CFRelease(v4);
  }
  return 0LL;
}

uint64_t PairingSessionSetMyAppleIDInfoClient(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(const void **)(a1 + 840);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 840) = v3;

  return 0LL;
}

uint64_t PairingSessionSetPeerAppleID(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 824);
  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 824) = cf;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 832);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 832) = 0LL;
  }

  return 0LL;
}

uint64_t PairingSessionSetPeerAppleIDs(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 832);
  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 832) = cf;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 824);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 824) = 0LL;
  }

  return 0LL;
}

uint64_t PrintFRegisterExtension(const char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = &gExtensionList;
  while (1)
  {
    uint64_t v6 = (uint64_t *)*v6;
    if (!v6) {
      break;
    }
    if (!strcasecmp((const char *)v6 + 24, a1))
    {
      uint64_t v7 = 4294960566LL;
      goto LABEL_7;
    }
  }

  size_t v8 = strlen(a1);
  uint64_t v9 = malloc(v8 + 25);
  if (v9)
  {
    uint64_t v10 = v9;
    v9[1] = a2;
    v9[2] = a3;
    memcpy(v9 + 3, a1, v8 + 1);
    uint64_t v7 = 0LL;
    *uint64_t v10 = gExtensionList;
    gExtensionList = (uint64_t)v10;
  }

  else
  {
    uint64_t v7 = 4294960568LL;
  }

uint64_t PrintFDeregisterExtension(const char *a1)
{
  uint64_t v2 = (char *)&gExtensionList;
  while (1)
  {
    id v3 = v2;
    uint64_t v2 = *(char **)v2;
    if (!v2) {
      break;
    }
    if (!strcasecmp(v2 + 24, a1))
    {
      *(void *)id v3 = *(void *)v2;
      free(v2);
      uint64_t v4 = 0LL;
      goto LABEL_6;
    }
  }

  uint64_t v4 = 4294960569LL;
LABEL_6:
  pthread_mutex_unlock(&gPrintFUtilsLock);
  return v4;
}

uint64_t CFAppendPrintF(CFMutableStringRef *a1)
{
  return CFAppendPrintV(a1);
}

uint64_t CFAppendPrintV(CFMutableStringRef *a1)
{
  if (!*a1)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
    *a1 = Mutable;
    if (!Mutable) {
      return 4294960568LL;
    }
  }

  cStr = 0LL;
  VASPrintF((void **)&cStr);
  id v3 = cStr;
  if (!cStr) {
    return 4294960568LL;
  }
  CFStringAppendCString(*a1, cStr, 0x8000100u);
  free(v3);
  return 0LL;
}

uint64_t VASPrintF(void **a1)
{
  uint64_t v5 = PrintFCallBackAllocatedString;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v2 = PrintFCoreVAList(&v5);
  if ((v2 & 0x80000000) == 0)
  {
    uint64_t v3 = v5("", 1LL, (uint64_t)&v5);
    if ((v3 & 0x80000000) == 0)
    {
      *a1 = v6;
      return v2;
    }

    uint64_t v2 = v3;
  }

  if (v6) {
    free(v6);
  }
  return v2;
}

uint64_t PrintFCallBackAllocatedString(const void *a1, size_t a2, uint64_t a3)
{
  size_t v4 = a2;
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v7 = v6 + a2;
  if (v6 + a2 <= *(void *)(a3 + 24))
  {
    uint64_t v9 = *(char **)(a3 + 8);
  }

  else
  {
    if (v7 >= 0x100) {
      size_t v8 = ((_DWORD)v7 + 1023) & 0xFFFFFC00;
    }
    else {
      size_t v8 = 256LL;
    }
    uint64_t v9 = (char *)realloc(*(void **)(a3 + 8), v8);
    if (!v9) {
      return 4294960568LL;
    }
    *(void *)(a3 + _Block_object_dispose(va, 8) = v9;
    *(void *)(a3 + 24) = v8;
    uint64_t v6 = *(void *)(a3 + 16);
  }

  memcpy(&v9[v6], a1, v4);
  *(void *)(a3 + 16) += v4;
  return v4;
}

uint64_t PrintFCoreVAList( uint64_t (**a1)(unsigned __int8 *, int64_t, void), unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = a2;
  uint64_t v9 = 0LL;
  uint64_t v362 = *MEMORY[0x1895F89C0];
  v348[0] = a3;
  v348[1] = a3;
  int v10 = (char)*a2;
  v342 = (__CFString *)*MEMORY[0x189604DE8];
LABEL_2:
  while (2)
  {
    uint64_t v11 = v8 + 1;
    uint64_t v12 = v8;
    if (v10)
    {
      do
      {
        if (v10 == 37) {
          break;
        }
        int v13 = (char)*++v12;
        int v10 = v13;
        ++v11;
      }

      while (v13);
    }

    int v14 = (_DWORD)v12 - (_DWORD)v8;
    if (v12 == v8)
    {
      if (!v10) {
        return v9;
      }
    }

    else
    {
      uint64_t v15 = ((uint64_t (*)(unsigned __int8 *, void))*a1)(v8, v14);
      if ((v15 & 0x80000000) != 0) {
        return v15;
      }
      uint64_t v9 = (v9 + v14);
      if (!v10) {
        return v9;
      }
    }

    int v16 = 0;
    int v17 = 0;
    char v18 = 0;
    char v19 = 0;
    unsigned int v20 = 0;
    __int128 v346 = 0u;
    __int128 v347 = 0u;
    while (2)
    {
      int v21 = *v11;
      switch(*v11)
      {
        case ' ':
          int v16 = 32;
          BYTE4(v346) = 32;
          goto LABEL_23;
        case '!':
        case '""':
        case '$':
        case '%':
        case '&':
        case '(':
        case ')':
        case ',':
        case '.':
        case '/':
          goto LABEL_24;
        case '#':
          BYTE3(v346) = ++v18;
          goto LABEL_23;
        case '\'':
          BYTE8(v347) = ++v19;
          goto LABEL_23;
        case '*':
          CFIndex v25 = (unsigned int *)v348[0];
          v348[0] += 8LL;
          uint64_t v23 = *v25;
          if ((v23 & 0x80000000) != 0)
          {
            uint64_t v23 = -(int)v23;
            LOBYTE(v20) = v20 | 1;
            LOBYTE(v346) = v20;
          }

          DWORD2(v346) = v23;
          int v21 = *++v11;
          goto LABEL_32;
        case '+':
          v20 |= 2u;
          goto LABEL_22;
        case '-':
          v20 |= 1u;
          goto LABEL_22;
        case '0':
          v20 |= 4u;
          goto LABEL_22;
        default:
          if (v21 == 63)
          {
            CFMutableDictionaryRef v22 = (_DWORD *)v348[0];
            v348[0] += 8LL;
            unsigned int v20 = v20 & 0xFFFFFFEF | (16 * (*v22 == 0));
LABEL_22:
            LOBYTE(v346) = v20;
LABEL_23:
            ++v11;
            continue;
          }

          if (v21 == 126)
          {
            int v17 = 1;
            BYTE11(v347) = 1;
            goto LABEL_23;
          }

LABEL_384:
        if (v18 == 1)
        {
          CFDataRef Data = CFPropertyListCreateData(0LL, v52, kCFPropertyListXMLFormat_v1_0, 0LL, 0LL);
          if (Data)
          {
            size_t v170 = Data;
            BytePtr = (unsigned __int8 *)CFDataGetBytePtr(Data);
            CFIndex Length = CFDataGetLength(v170);
            uint64_t v39 = PrintFWriteMultiLineText(a1, (uint64_t)&v346, BytePtr, Length);
            CFRelease(v170);
            goto LABEL_660;
          }

          uint64_t v178 = (uint64_t)a1;
LABEL_658:
          uint64_t v146 = PrintFCore(v178);
LABEL_659:
          uint64_t v39 = v146;
          goto LABEL_660;
        }

        while (2)
        {
          int v173 = BYTE3(v346);
          CFTypeID v174 = CFGetTypeID(v52);
          if (v174 == CFBooleanGetTypeID())
          {
            if (v342 == v52) {
              uint64_t v191 = 4LL;
            }
            else {
              uint64_t v191 = 5LL;
            }
            if (v342 == v52) {
              p_str = "true";
            }
            else {
              p_str = "false";
            }
            goto LABEL_641;
          }

          if (v174 == CFNumberGetTypeID())
          {
            if (CFNumberIsFloatType((CFNumberRef)v52))
            {
              *(void *)__format = 0LL;
              CFNumberGetValue((CFNumberRef)v52, kCFNumberDoubleType, __format);
              int v195 = SNPrintF(&__str, 300LL, "%f");
            }

            else
            {
              *(void *)__format = 0LL;
              CFNumberGetValue((CFNumberRef)v52, kCFNumberSInt64Type, __format);
              int v195 = SNPrintF(&__str, 300LL, "%lld");
            }

            uint64_t v191 = v195;
            goto LABEL_640;
          }

          if (v174 != CFStringGetTypeID())
          {
            if (v174 == CFNullGetTypeID())
            {
              v203 = (uint64_t (**)(const char *, uint64_t, void))a1;
              p_str = "Null";
              uint64_t v191 = 4LL;
              goto LABEL_642;
            }

            if (v174 == CFURLGetTypeID())
            {
              int v52 = (__CFString *)CFURLGetString((CFURLRef)v52);
              uint64_t v39 = 4294960596LL;
              if (!v52) {
                return v39;
              }
              continue;
            }

            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              -[__CFString getUUIDBytes:](v52, "getUUIDBytes:", __format);
              goto LABEL_605;
            }

            if (v174 == CFUUIDGetTypeID())
            {
              *(CFUUIDBytes *)__format = CFUUIDGetUUIDBytes((CFUUIDRef)v52);
LABEL_605:
              if (BYTE11(v347)) {
                int v256 = SNPrintF(&__str, 300LL, "%~#U", __format);
              }
              else {
                int v256 = SNPrintF(&__str, 300LL, "%#U", __format);
              }
              int v257 = v347;
              if ((v346 & 8) != 0) {
                int v258 = v257;
              }
              else {
                int v258 = v256;
              }
              uint64_t v191 = v258;
LABEL_640:
              p_str = &__str;
LABEL_641:
              v203 = (uint64_t (**)(const char *, uint64_t, void))a1;
LABEL_642:
              uint64_t v146 = PrintFWriteText(v203, (uint64_t)&v346, p_str, v191);
              goto LABEL_659;
            }

            if (v174 != CFDataGetTypeID())
            {
              *(void *)__format = a1;
              *(void *)&__format[8] = &v346;
              uint64_t v361 = 0LL;
              int v360 = DWORD2(v346);
              uint64_t v39 = PrintFWriteCFObjectLevel( (uint64_t (***)(CFUUIDBytes *))__format,  (const __CFArray *)v52,  0LL);
              if ((v39 & 0x80000000) != 0
                || v173 == 2
                || v174 != CFArrayGetTypeID() && v174 != CFDictionaryGetTypeID() && v174 != CFSetGetTypeID())
              {
                goto LABEL_660;
              }

              int v288 = ((uint64_t (*)(const char *, uint64_t))*a1)("\n", 1LL);
              if (v288 <= 0) {
                int v289 = 0;
              }
              else {
                int v289 = v39;
              }
              goto LABEL_861;
            }

            v281 = (unsigned __int8 *)CFDataGetBytePtr((CFDataRef)v52);
            unint64_t v282 = CFDataGetLength((CFDataRef)v52);
            unint64_t v283 = v282;
            unint64_t v284 = v347;
            if ((v346 & 8) == 0) {
              unint64_t v284 = v282;
            }
            uint64_t v285 = 32LL;
            if (v284 < 0x20) {
              uint64_t v285 = v284;
            }
            if (v173 == 2) {
              unint64_t v284 = v285;
            }
            if (BYTE8(v347)) {
              BOOL v286 = (v346 & 8) == 0;
            }
            else {
              BOOL v286 = 1;
            }
            if (v286) {
              unint64_t v287 = v284;
            }
            else {
              unint64_t v287 = v284 + 2;
            }
            if (v282 >= 0x21 && v287 > 0x20)
            {
              uint64_t v39 = (*a1)("\n", 1LL, a1);
              if ((v39 & 0x80000000) != 0) {
                return v39;
              }
              int v288 = PrintFWriteHex( (uint64_t (**)(const char *, uint64_t))a1,  (uint64_t)&v346,  0LL,  (uint64_t)v281,  v283,  v287,  0);
              if (v288 >= 0) {
                int v289 = v39;
              }
              else {
                int v289 = 0;
              }
LABEL_861:
              uint64_t v39 = (v289 + v288);
              goto LABEL_660;
            }

            if (BYTE9(v347))
            {
              uint64_t v39 = ((uint64_t (*)(char *, uint64_t))*a1)((char *)&v347 + 9, 1LL);
              if ((v39 & 0x80000000) != 0) {
                return v39;
              }
            }

            else
            {
              LODWORD(v39) = 0;
            }

            if (v283 >= v287) {
              uint64_t v316 = v287;
            }
            else {
              uint64_t v316 = v283;
            }
            uint64_t v15 = PrintFWriteHexByteStream(a1, 0, v281, v316);
            if ((v15 & 0x80000000) != 0) {
              return v15;
            }
            int v317 = v15 + v39;
            if (BYTE10(v347))
            {
              int v288 = ((uint64_t (*)(char *, uint64_t))*a1)((char *)&v347 + 10, 1LL);
              if (v288 >= 0) {
                int v289 = v317;
              }
              else {
                int v289 = 0;
              }
              goto LABEL_861;
            }

            uint64_t v9 = (v317 + v9);
LABEL_762:
            int v10 = (char)v11[1];
            size_t v8 = v11 + 1;
            goto LABEL_2;
          }

          break;
        }

        CFIndex v196 = CFStringGetLength(v52);
        CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v196, 0x8000100u);
        v358.tv_seCC_SHA1_CTX c = MaximumSizeForEncoding;
        if (!MaximumSizeForEncoding)
        {
          v203 = (uint64_t (**)(const char *, uint64_t, void))a1;
          p_str = "";
          uint64_t v191 = 0LL;
          goto LABEL_642;
        }

        CFIndex v198 = MaximumSizeForEncoding;
        v199 = (UInt8 *)malloc(MaximumSizeForEncoding);
        if (v199)
        {
          uint64_t v200 = (char *)v199;
          time_t v349 = 0LL;
          v363.location = 0LL;
          v363.CFIndex length = v196;
          CFStringGetBytes(v52, v363, 0x8000100u, 0x5Eu, 0, v199, v198, &v349);
          tv_seCC_SHA1_CTX c = v349;
          if (BYTE11(v347))
          {
            __int128 v202 = __format;
            _PrintFObfuscateString((unint64_t)v200, v349, __format, &v358.tv_sec);
            tv_seCC_SHA1_CTX c = v358.tv_sec;
            time_t v349 = v358.tv_sec;
          }

          else
          {
            __int128 v202 = v200;
          }

          if ((v346 & 8) != 0 && tv_sec > (uint64_t)v347)
          {
            tv_seCC_SHA1_CTX c = (int)v347;
            if ((uint64_t)((void)v347 << 32) >= 1)
            {
              else {
                uint64_t v290 = (int)v347;
              }
              uint64_t v291 = v290 - 1;
              while ((v202[tv_sec] & 0xC0) == 0x80)
              {
                BOOL v165 = tv_sec-- <= 1;
                if (v165)
                {
                  tv_seCC_SHA1_CTX c = v291;
                  break;
                }
              }
            }

            time_t v349 = tv_sec;
          }

          uint64_t v39 = PrintFWriteText( (uint64_t (**)(const char *, uint64_t, void))a1,  (uint64_t)&v346,  v202,  tv_sec);
          free(v200);
        }

        else
        {
          uint64_t v39 = 4294960568LL;
        }

LABEL_660:
        if ((v39 & 0x80000000) == 0)
        {
          uint64_t v9 = (v39 + v9);
          goto LABEL_762;
        }

        return v39;
      case 'A':
      case 'B':
      case 'D':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'T':
      case 'W':
      case 'Y':
      case 'Z':
      case '[':
      case '\\':
      case ']':
      case '^':
      case '_':
      case 'h':
      case 'j':
      case 'k':
      case 'l':
      case 'q':
      case 'r':
      case 't':
      case 'w':
      case 'y':
      case 'z':
        goto LABEL_81;
      case 'C':
        uint64_t v54 = (unsigned int *)v348[0];
        v348[0] += 8LL;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        unsigned int v55 = *v54;
        if (v19)
        {
          char __str = 39;
          unsigned int v56 = 1;
        }

        else
        {
          unsigned int v56 = 0;
        }

        unsigned int v156 = HIBYTE(v55);
        int v48 = &__str;
        char v157 = &v355[v56 - 1];
        if (HIBYTE(v55)) {
          char v158 = 94;
        }
        else {
          char v158 = 46;
        }
        if (HIBYTE(v55) - 127 < 0xFFFFFFA1) {
          LOBYTE(v156) = v158;
        }
        *char v157 = v156;
        char v159 = BYTE2(v55);
        if (BYTE2(v55)) {
          char v160 = 94;
        }
        else {
          char v160 = 46;
        }
        v157[1] = v159;
        int v161 = BYTE1(v55);
        if (v161) {
          char v162 = 94;
        }
        else {
          char v162 = 46;
        }
        v157[2] = v161;
        int v163 = v55 << 24;
        if ((_BYTE)v55) {
          char v164 = 94;
        }
        else {
          char v164 = 46;
        }
        BOOL v165 = v163 == 2130706432 || v163 < 520093697;
        if (v165) {
          LOBYTE(v55) = v164;
        }
        v157[3] = v55;
        if (v19)
        {
          LODWORD(v39) = v56 + 5;
          v355[(v56 | 4LL) - 1] = 39;
          int v35 = 67;
        }

        else
        {
          int v35 = 67;
          LODWORD(v39) = v56 | 4;
        }

        goto LABEL_758;
      case 'E':
      case 'F':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        __format[0] = 37;
        if ((v20 & 2) != 0)
        {
          __format[1] = 43;
          uint64_t v38 = 2LL;
        }

        else
        {
          uint64_t v38 = 1LL;
        }

        if (v18) {
          __format[v38++] = 35;
        }
        if ((v20 & 4) != 0) {
          __format[v38++] = 48;
        }
        uint64_t v40 = v38 + 1;
        __format[v38] = 42;
        if ((v20 & 8) != 0)
        {
          __format[v40] = 46;
          uint64_t v40 = v38 + 3;
          __format[v38 + 2] = 42;
        }

        dispatch_semaphore_t v41 = &__format[v40];
        char *v41 = v21;
        v41[1] = 0;
        if ((v20 & 1) != 0) {
          uint64_t v42 = -(int)v23;
        }
        else {
          uint64_t v42 = v23;
        }
        size_t v43 = (void *)v348[0];
        v348[0] += 8LL;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        double v44 = *(double *)v43;
        if ((v20 & 8) != 0) {
          uint64_t v45 = snprintf(&__str, 0x12CuLL, __format, v44, v42, v28, *v43, v333);
        }
        else {
          uint64_t v45 = snprintf(&__str, 0x12CuLL, __format, v44, v42, *v43, v332, v333);
        }
        uint64_t v39 = v45;
        if ((v45 & 0x80000000) == 0) {
          goto LABEL_77;
        }
        return v39;
      case 'H':
        uint64_t v57 = v348[0];
        v348[0] += 8LL;
        int v58 = *(char **)v57;
        v348[0] = v57 + 16;
        size_t v59 = *(int *)(v57 + 8);
        v348[0] = v57 + 24;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        size_t v60 = *(int *)(v57 + 16);
        if (!v58 && (_DWORD)v59)
        {
          uint64_t usedBufLen = v59;
          uint64_t v61 = PrintFCore((uint64_t)a1);
LABEL_372:
          uint64_t v39 = v61;
          if ((v61 & 0x80000000) == 0)
          {
            uint64_t v9 = (v61 + v9);
            goto LABEL_762;
          }

          return v39;
        }

        if ((_DWORD)v59 == -1) {
          size_t v59 = strlen(v58);
        }
        switch(v28)
        {
          case 0uLL:
            if (v59 >= v60) {
              unint64_t v145 = v60;
            }
            else {
              unint64_t v145 = v59;
            }
            uint64_t v146 = PrintFWriteHexOneLine( (uint64_t (**)(const char *, uint64_t, void))a1,  (uint64_t)&v346,  (unsigned __int8 *)v58,  v145);
            goto LABEL_659;
          case 1uLL:
            uint64_t v204 = (uint64_t (**)(const char *, uint64_t))a1;
            uint64_t v205 = v23;
            goto LABEL_469;
          case 2uLL:
            if (!v59)
            {
              uint64_t v178 = (uint64_t)a1;
              goto LABEL_658;
            }

            if (v59 > 0x10)
            {
              uint64_t v15 = PrintFCore((uint64_t)a1);
              if ((v15 & 0x80000000) != 0) {
                return v15;
              }
              uint64_t v205 = DWORD2(v346);
              uint64_t v204 = (uint64_t (**)(const char *, uint64_t))a1;
              uint64_t v206 = (uint64_t)v58;
              unint64_t v207 = v59;
              unint64_t v208 = v60;
            }

            else
            {
              uint64_t v204 = (uint64_t (**)(const char *, uint64_t))a1;
              uint64_t v205 = 0LL;
LABEL_469:
              uint64_t v206 = (uint64_t)v58;
              unint64_t v207 = v59;
              unint64_t v208 = v60;
            }

            uint64_t v146 = PrintFWriteHex(v204, (uint64_t)&v346, v205, v206, v207, v208, 1);
            goto LABEL_659;
          case 3uLL:
            if (v59 >= v60) {
              uint64_t v209 = v60;
            }
            else {
              uint64_t v209 = v59;
            }
            v210 = a1;
            int v211 = 0;
            goto LABEL_479;
          case 4uLL:
            if (v59 >= v60) {
              uint64_t v209 = v60;
            }
            else {
              uint64_t v209 = v59;
            }
            v210 = a1;
            int v211 = 1;
LABEL_479:
            uint64_t v146 = PrintFWriteHexByteStream(v210, v211, (unsigned __int8 *)v58, v209);
            goto LABEL_659;
          default:
            uint64_t v178 = (uint64_t)a1;
            goto LABEL_658;
        }

      case 'N':
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        gettimeofday(&v358, 0LL);
        time_t v349 = v358.tv_sec;
        if (BYTE3(v346) == 2)
        {
          dispatch_semaphore_t v62 = gmtime(&v349);
          strftime(__format, 0x18uLL, "%Y-%m-%d-%H:%M:%S", v62);
          int v63 = SNPrintF(&__str, 300LL, "%s.%06u");
        }

        else
        {
          char v147 = localtime(&v349);
          if (BYTE3(v346)) {
            size_t v148 = "%Y-%m-%d_%I-%M-%S";
          }
          else {
            size_t v148 = "%Y-%m-%d %I:%M:%S";
          }
          strftime(__format, 0x18uLL, v148, v147);
          strftime(v357, 8uLL, "%p", v147);
          uint64_t v149 = 32LL;
          if (BYTE3(v346)) {
            uint64_t v149 = 45LL;
          }
          uint64_t v332 = v149;
          unint64_t v333 = (unint64_t)v357;
          int v63 = SNPrintF(&__str, 300LL, "%s.%06u%c%s");
        }

        LODWORD(v39) = v63;
        int v35 = 78;
        goto LABEL_77;
      case 'S':
        int v64 = (unsigned __int8 **)v348[0];
        v348[0] += 8LL;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        uint64_t v65 = *v64;
        if (v65)
        {
          char v66 = v20 & 8;
          BOOL v67 = (v20 & 8) == 0;
          if (v19 && v66)
          {
            BOOL v68 = v28 >= 2;
            v28 -= 2LL;
            if (!v68)
            {
LABEL_363:
              BOOL v67 = 0;
              char v19 = 0;
              size_t v28 = 0LL;
              *(void *)&__int128 v347 = 0LL;
              BYTE8(v347) = 0;
              goto LABEL_488;
            }

            BOOL v67 = 0;
            *(void *)&__int128 v347 = v28;
          }

LABEL_488:
          if (v67 || v28)
          {
            int v216 = *v65;
            if (v216 == 255)
            {
              if (v65[1] == 254)
              {
                char v18 = 2;
                goto LABEL_496;
              }
            }

            else if (v216 == 254 && v65[1] == 255)
            {
              char v18 = 1;
LABEL_496:
              BYTE3(v346) = v18;
              --v28;
              v65 += 2;
              *(void *)&__int128 v347 = v28;
              goto LABEL_498;
            }
          }

          if ((v18 - 1) >= 2)
          {
            if (v18)
            {
              LODWORD(v39) = SNPrintF(&__str, 300LL, "<< ERROR: %%S with too many #'s (%d) >>", v18);
              char v19 = BYTE8(v347);
              goto LABEL_536;
            }

            int v224 = (int)v28 > 0 || v67;
            if (v224 == 1)
            {
              uint64_t v39 = 0LL;
              uint64_t v225 = 300LL;
              do
              {
                int v226 = *(unsigned __int16 *)&v65[2 * v39];
                if (*(_WORD *)&v65[2 * v39]) {
                  BOOL v227 = v225 < 1;
                }
                else {
                  BOOL v227 = 1;
                }
                if (v227) {
                  break;
                }
                v355[v39++ - 1] = v226;
                BOOL v228 = v39 < (int)v28 || v67;
                --v225;
              }

              while (v228);
LABEL_536:
              if (v19 == 2)
              {
                __int16 v229 = 8738;
              }

              else
              {
                if (v19 != 1)
                {
LABEL_541:
                  int v35 = 83;
                  goto LABEL_77;
                }

                __int16 v229 = 10023;
              }

              *(_WORD *)((char *)&v347 + 9) = v229;
              goto LABEL_541;
            }

LABEL_534:
            LODWORD(v39) = 0;
            goto LABEL_536;
          }

LABEL_498:
          int v217 = (int)v28 > 0 || v67;
          if (v217 == 1)
          {
            uint64_t v39 = 0LL;
            uint64_t v218 = 300LL;
            uint64_t v219 = 2LL - v18;
            do
            {
              if (*(_WORD *)&v65[2 * v39]) {
                BOOL v220 = v218 < 1;
              }
              else {
                BOOL v220 = 1;
              }
              if (v220) {
                break;
              }
              int v221 = v65[v219];
              if (v65[v219]) {
                char v222 = 94;
              }
              else {
                char v222 = 46;
              }
              v355[v39++ - 1] = v221;
              BOOL v223 = v39 < (int)v28 || v67;
              v219 += 2LL;
              --v218;
            }

            while (v223);
            goto LABEL_536;
          }

          goto LABEL_534;
        }

        int v35 = 83;
        LODWORD(v39) = 4;
        if ((v20 & 8) != 0 && !v28)
        {
          if (!v19)
          {
            BOOL v67 = 0;
            char v19 = 0;
            size_t v28 = 0LL;
            goto LABEL_488;
          }

          goto LABEL_363;
        }

        goto LABEL_367;
      case 'U':
        __int128 v69 = (int8x16_t **)v348[0];
        v348[0] += 8LL;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        p_s = *v69;
        if (!*v69)
        {
          int v35 = 85;
          goto LABEL_366;
        }

        if (v17)
        {
          if (gObfuscateOnce != -1) {
            dispatch_once_f(&gObfuscateOnce, 0LL, (dispatch_function_t)_PrintFObfuscateInit);
          }
          if (!v18)
          {
            *(int8x16_t *)__format = vqtbl1q_s8(*p_s, (int8x16_t)xmmword_186B49CD0);
            p_s = (int8x16_t *)__format;
          }

          int v71 = SipHash(gObfuscateKey, (unsigned __int8 *)p_s, 16LL);
          __s.i16[0] = 187;
          __s.i8[2] = HIBYTE(v71);
          __s.i8[3] = BYTE2(v71);
          __s.i8[4] = BYTE1(v71);
          __s.i8[5] = v71;
          *(uint64_t *)((char *)__s.i64 + 6) = 0xFBF31F0000800010LL;
          __s.i16[7] = -8320;
          if (!v18) {
            int8x16_t __s = vqtbl1q_s8(__s, (int8x16_t)xmmword_186B49CD0);
          }
          p_s = &__s;
          char v18 = BYTE3(v346);
        }

        if (v18)
        {
          int v72 = p_s->u8[0];
          int v73 = p_s->u8[1];
          int v74 = p_s->u8[2];
          int v75 = p_s->u8[3];
          int v76 = p_s->u8[4];
          int v77 = p_s->u8[5];
          int v78 = p_s->u8[6];
          int v79 = p_s->u8[7];
        }

        else
        {
          int v72 = p_s->u8[3];
          int v73 = p_s->u8[2];
          int v74 = p_s->u8[1];
          int v75 = p_s->u8[0];
          int v76 = p_s->u8[5];
          int v77 = p_s->u8[4];
          int v78 = p_s->u8[7];
          int v79 = p_s->u8[6];
        }

        int v340 = p_s->u8[14];
        int v341 = p_s->u8[15];
        int v338 = p_s->u8[12];
        int v339 = p_s->u8[13];
        int v336 = p_s->u8[10];
        int v337 = p_s->u8[11];
        int v334 = p_s->u8[8];
        int v335 = p_s->u8[9];
        int v48 = &__str;
        LODWORD(v39) = SNPrintF( &__str,  300LL,  "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",  v72,  v73,  v74,  v75,  v76,  v77,  v78,  v79,  v334,  v335,  v336,  v337,  v338,  v339,  v340,  v341);
        int v35 = 85;
        goto LABEL_758;
      case 'V':
        uint64_t v80 = (uint64_t *)v348[0];
        v348[0] += 8LL;
        uint64_t v81 = *v80;
        v348[0] = v80 + 2;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        int v35 = 86;
        LODWORD(v39) = 4;
        if (!v81 || !v80[1]) {
          goto LABEL_367;
        }
        uint64_t v61 = PrintFCoreVAList(a1);
        goto LABEL_372;
      case 'X':
        goto LABEL_173;
      case 'a':
        uint64_t v82 = (char **)v348[0];
        v348[0] += 8LL;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        uint64_t v83 = *v82;
        if (!*v82)
        {
          int v35 = 97;
          goto LABEL_366;
        }

        uint64_t v84 = (unsigned __int8 *)(v83 + 4);
        if (v18 != 2)
        {
          if (v18 != 1)
          {
            *((void *)&v176 + 1) = v28;
            *(void *)&__int128 v176 = v28 - 2;
            switch((unint64_t)(v176 >> 1))
            {
              case 0uLL:
                unsigned int v177 = v83[1];
                uint64_t v332 = v177 >> 4;
                unint64_t v333 = v177 & 0xF;
                goto LABEL_771;
              case 1uLL:
                if (v17)
                {
                  _PrintFObfuscateIPv4((unsigned __int8 *)v83, __format);
                  uint64_t v83 = __format;
                }

                uint64_t v234 = v83[2];
                unint64_t v235 = v83[3];
                goto LABEL_770;
              case 2uLL:
                if (v17)
                {
                  _PrintFObfuscateHardwareAddress((unsigned __int8 *)v83, 6uLL, __format);
                  uint64_t v83 = __format;
                }

                uint64_t v267 = *v83;
                uint64_t v268 = v83[2];
                unint64_t v269 = v83[3];
                goto LABEL_776;
              case 3uLL:
                if (v17)
                {
                  _PrintFObfuscateHardwareAddress((unsigned __int8 *)v83, 8uLL, __format);
                  uint64_t v83 = __format;
                }

                uint64_t v332 = v83[2];
                unint64_t v333 = v83[3];
                int v265 = SNPrintF(&__str, 300LL, "%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X", *v83);
                goto LABEL_777;
              case 7uLL:
                if (v17)
                {
                  _PrintFObfuscateIPv6((unsigned __int8 *)v83, (uint64_t)__format);
                  uint64_t v83 = __format;
                }

                uint64_t v84 = (unsigned __int8 *)v83;
                goto LABEL_728;
              default:
                int v265 = SNPrintF(&__str, 300LL, "%s");
                goto LABEL_777;
            }
          }

          if (v28 == 6)
          {
            v230 = __format;
            if (v17)
            {
              if (v83 == __format)
              {
                v299 = &__format[4];
                do
                {
                  char v300 = *v230;
                  *v230++ = v299[1];
                  v299[1] = v300;
                  BOOL v68 = v230 >= v299--;
                }

                while (!v68);
              }

              else
              {
                v231 = v83 + 6;
                v232 = __format;
                do
                {
                  char v233 = *--v231;
                  *v232++ = v233;
                }

                while (v231 > v83);
              }

              _PrintFObfuscateHardwareAddress((unsigned __int8 *)__format, 6uLL, __format);
              uint64_t v267 = __format[0];
              uint64_t v268 = __format[2];
              unint64_t v269 = __format[3];
            }

            else
            {
              uint64_t v267 = v83[5];
              uint64_t v268 = v83[3];
              unint64_t v269 = v83[2];
            }

LABEL_776:
            uint64_t v332 = v268;
            unint64_t v333 = v269;
            int v265 = SNPrintF(&__str, 300LL, "%02X:%02X:%02X:%02X:%02X:%02X", v267);
            goto LABEL_777;
          }

          if (v28 == 4)
          {
            id v85 = __format;
            if (v17)
            {
              if (v83 == __format)
              {
                v297 = &__format[2];
                do
                {
                  char v298 = *v85;
                  *v85++ = v297[1];
                  v297[1] = v298;
                  BOOL v68 = v85 >= v297--;
                }

                while (!v68);
              }

              else
              {
                do
                {
                  char v86 = *--v84;
                  *v85++ = v86;
                }

                while (v84 > (unsigned __int8 *)v83);
              }

              _PrintFObfuscateIPv4((unsigned __int8 *)__format, __format);
              uint64_t v234 = __format[2];
              unint64_t v235 = __format[3];
            }

            else
            {
              uint64_t v234 = v83[1];
              unint64_t v235 = *v83;
            }

            goto LABEL_770;
          }

          if (*(_DWORD *)v83 != 6)
          {
            if (*(_DWORD *)v83 == 4)
            {
              if (v17)
              {
                _PrintFObfuscateIPv4(v84, __format);
                uint64_t v84 = (unsigned __int8 *)__format;
              }

              uint64_t v234 = v84[2];
              unint64_t v235 = v84[3];
LABEL_770:
              uint64_t v332 = v234;
              unint64_t v333 = v235;
LABEL_771:
              int v265 = SNPrintF(&__str, 300LL, "%u.%u.%u.%u");
              goto LABEL_777;
            }

            int v265 = SNPrintF(&__str, 300LL, "<< ERROR: %%#a used with unsupported type: %d >>");
LABEL_777:
            LODWORD(v39) = v265;
LABEL_778:
            int v35 = 97;
LABEL_77:
            int v48 = &__str;
            goto LABEL_758;
          }

          if (v17)
          {
            _PrintFObfuscateIPv6(v84, (uint64_t)__format);
            uint64_t v84 = (unsigned __int8 *)__format;
          }

LABEL_728:
          unsigned int v193 = 0;
          unsigned int v194 = 0;
          goto LABEL_729;
        }

        unsigned int v175 = v83[1];
        if (v175 > 0x11)
        {
          if (v175 == 18)
          {
            v266 = (unsigned __int8 *)&v83[v83[5] + 8];
            if (v83[6] == 6)
            {
              if (v17)
              {
                _PrintFObfuscateHardwareAddress((unsigned __int8 *)&v83[v83[5] + 8], 6uLL, __format);
                v266 = (unsigned __int8 *)__format;
              }

              uint64_t v332 = v266[2];
              unint64_t v333 = v266[3];
              int v265 = SNPrintF(&__str, 300LL, "%02X:%02X:%02X:%02X:%02X:%02X", *v266);
            }

            else
            {
              uint64_t v332 = v83[6];
              int v265 = SNPrintF(&__str, 300LL, "<< AF_LINK %H >>", v266);
            }

            goto LABEL_777;
          }

          if (v175 == 30)
          {
            uint64_t v84 = (unsigned __int8 *)(v83 + 8);
            if (v17)
            {
              _PrintFObfuscateIPv6(v84, (uint64_t)__format);
              uint64_t v84 = (unsigned __int8 *)__format;
            }

            unsigned int v193 = *((_DWORD *)v83 + 6);
            unsigned int v194 = bswap32(*((unsigned __int16 *)v83 + 1)) >> 16;
LABEL_729:
            IPv6AddressToCString(v84, v193, v194, 0xFFFFFFFF, &__str, 0);
LABEL_730:
            LODWORD(v39) = strlen(&__str);
            goto LABEL_778;
          }
        }

        else
        {
          if (!v83[1])
          {
            int v265 = SNPrintF(&__str, 300LL, "<< AF_UNSPEC >>", usedBufLen);
            goto LABEL_777;
          }

          if (v175 == 2)
          {
            if (v17)
            {
              _PrintFObfuscateIPv4(v84, __format);
              uint64_t v84 = (unsigned __int8 *)__format;
            }

            IPv4AddressToCString(bswap32(*(_DWORD *)v84), bswap32(*((unsigned __int16 *)v83 + 1)) >> 16, &__str);
            goto LABEL_730;
          }
        }

        int v265 = SNPrintF(&__str, 300LL, "<< ERROR: %%##a used with unknown family: %d >>");
        goto LABEL_777;
      case 'b':
        unsigned int v36 = 2;
        goto LABEL_174;
      case 'c':
        char v87 = (int *)v348[0];
        v348[0] += 8LL;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        int v88 = *v87;
        if (!v19)
        {
          char __str = *v87;
          int v35 = 99;
          goto LABEL_369;
        }

        char __str = 39;
        if (v88) {
          char v89 = 94;
        }
        else {
          char v89 = 46;
        }
        else {
          char v90 = v88;
        }
        v355[0] = v90;
        v355[1] = 39;
        int v35 = 99;
        LODWORD(v39) = 3;
        goto LABEL_77;
      case 'd':
      case 'i':
        uint64_t v343 = v9;
        if (v31 == 1 || v31 == 2)
        {
          uint64_t v46 = (unint64_t *)v348[0];
          v348[0] += 8LL;
          unint64_t v47 = *v46;
        }

        else
        {
          uint64_t v123 = (int *)v348[0];
          v348[0] += 8LL;
          unint64_t v47 = *v123;
        }

        if (v30 == 1) {
          unint64_t v47 = (__int16)v47;
        }
        if (v30 == 2) {
          unint64_t v100 = (char)v47;
        }
        else {
          unint64_t v100 = v47;
        }
        if ((v100 & 0x8000000000000000LL) != 0)
        {
          unint64_t v100 = -(uint64_t)v100;
          unsigned int v36 = 10;
          char v98 = 45;
          int v16 = 45;
        }

        else
        {
          unsigned int v36 = 10;
          if ((v20 & 2) == 0)
          {
            uint64_t v37 = "0123456789ABCDEF";
            if ((v20 & 0x10) != 0) {
              goto LABEL_218;
            }
            goto LABEL_223;
          }

          int v16 = 45;
          char v98 = 43;
        }

LABEL_221:
        uint64_t v37 = "0123456789ABCDEF";
LABEL_222:
        BYTE4(v346) = v98;
        if ((v20 & 0x10) != 0)
        {
LABEL_218:
          uint64_t v9 = v343;
          goto LABEL_762;
        }

LABEL_283:
            *(void *)&__int128 v347 = v28;
            goto LABEL_284;
          }

          if (v28 < 0x41)
          {
            if (!v28)
            {
              size_t v28 = 1LL;
              goto LABEL_283;
            }

LABEL_284:
            if (v18 == 2)
            {
              uint64_t v137 = (v28 - 1);
              do
              {
                if (((v100 >> v137) & 1) != 0)
                {
                  int v138 = "";
                  SNPrintF_Add((uint64_t *)__format, (uint64_t)v357, (uint64_t)"%s%d", a4, a5, a6, a7, a8, (uint64_t)v138);
                }

                BOOL v165 = v137-- <= 0;
              }

              while (!v165);
            }

            else
            {
              int v139 = 0;
              do
              {
                if (((v100 >> (v28 - 1)) & 1) != 0)
                {
                  int v140 = "";
                  SNPrintF_Add((uint64_t *)__format, (uint64_t)v357, (uint64_t)"%s%d", a4, a5, a6, a7, a8, (uint64_t)v140);
                }

                ++v139;
                --v28;
              }

              while (v28);
            }
          }

          else
          {
            SNPrintF_Add( (uint64_t *)__format,  (uint64_t)v357,  (uint64_t)"ERROR: << precision must be 0-%d >>",  a4,  a5,  a6,  a7,  a8,  64LL);
          }

          int v48 = &__str;
          LODWORD(v39) = *(_DWORD *)__format - &__str;
          LODWORD(v9) = v343;
          goto LABEL_758;
        }

        if ((v20 & 8) != 0) {
          goto LABEL_242;
        }
        if ((v20 & 4) != 0)
        {
          unsigned int v124 = 2 * (v36 != 10);
          if (v36 == 8) {
            unsigned int v124 = 1;
          }
          if (!v18) {
            unsigned int v124 = 0;
          }
          if (v16) {
            ++v124;
          }
          BOOL v68 = v23 >= v124;
          unsigned int v125 = v23 - v124;
          if (v68) {
            size_t v28 = v125;
          }
          else {
            size_t v28 = 0LL;
          }
          *(void *)&__int128 v347 = v28;
        }

        if (v28)
        {
LABEL_242:
          if (v28 < 0x12C) {
            goto LABEL_256;
          }
          size_t v28 = 299LL;
        }

        else
        {
          size_t v28 = 1LL;
        }

        *(void *)&__int128 v347 = v28;
LABEL_256:
        if (v19)
        {
          int v129 = 0;
          int v130 = -1;
          unsigned int v131 = 1;
          for (uint64_t i = v357; ; uint64_t i = v48)
          {
            if (HIDWORD(v100))
            {
              unint64_t v133 = v100 / v36;
              *(i - 1) = v37[v100 % v36];
              int v48 = i - 1;
              LODWORD(v39) = v129 + 1;
            }

            else
            {
              unint64_t v133 = v100 / v36;
              *(i - 1) = v37[v100 % v36];
              int v48 = i - 1;
              LODWORD(v39) = v129 + 1;
              if (v36 > v100)
              {
                LODWORD(v2_Block_object_dispose(va, 8) = v347;
                goto LABEL_306;
              }
            }

            unint64_t v100 = v133;
            if (!(v130 + 3 * (v131 / 3)))
            {
              *(i - 2) = 44;
              LODWORD(v39) = v129 + 2;
              int v48 = i - 2;
            }

            --v130;
            ++v131;
            int v129 = v39;
          }
        }

        if (v100)
        {
          uint64_t v134 = 0LL;
          do
          {
            if (HIDWORD(v100)) {
              int v135 = v100 % v36;
            }
            else {
              int v135 = v100 % v36;
            }
            if (HIDWORD(v100)) {
              v100 /= v36;
            }
            else {
              unint64_t v100 = v100 / v36;
            }
            v356[v134-- + 45] = v37[v135];
          }

          while (v100);
          int v48 = &v357[v134];
          LODWORD(v39) = -(int)v134;
        }

        else
        {
          LODWORD(v39) = 0;
          int v48 = v357;
        }

LABEL_306:
        LODWORD(v9) = v343;
        if ((int)v39 < (int)v28)
        {
          do
          {
            *--int v48 = 48;
            LODWORD(v39) = v39 + 1;
          }

          while ((int)v39 < (int)v347);
        }

        if (!BYTE3(v346)) {
          goto LABEL_314;
        }
        if (v36 == 8)
        {
          int v143 = 1;
          uint64_t v144 = -1LL;
        }

        else
        {
          if (v36 == 10) {
            goto LABEL_314;
          }
          *(v48 - 1) = v35;
          int v143 = 2;
          uint64_t v144 = -2LL;
        }

        v48 += v144;
        *int v48 = 48;
        LODWORD(v39) = v143 + v39;
LABEL_314:
        if (BYTE4(v346))
        {
          *--int v48 = BYTE4(v346);
          LODWORD(v39) = v39 + 1;
        }

        goto LABEL_758;
      case 'm':
        uint64_t v91 = (_DWORD *)v348[0];
        v348[0] += 8LL;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        uint64_t v92 = *v91;
        if (v18)
        {
          if ((v92 - 0x20000000) >> 24 > 0x5E
            || BYTE2(v92) - 32 > 0x5E
            || BYTE1(v92) - 32 > 0x5E
            || *v91 - 32 > 0x5E)
          {
            BOOL v93 = v18 == 2;
            char v94 = "%d/0x%X ";
            unsigned __int8 v95 = "%-11d    0x%08X    '^^^^'    ";
          }

          else
          {
            BOOL v93 = v18 == 2;
            char v94 = "%d/0x%X/'%C' ";
            unsigned __int8 v95 = "%-11d    0x%08X    '%C'    ";
          }

          if (v93) {
            size_t v141 = v95;
          }
          else {
            size_t v141 = v94;
          }
          uint64_t v332 = v92;
          int v142 = SNPrintF(&__str, 300LL, v141, v92);
        }

        else
        {
          int v142 = 0;
        }

        DebugGetErrorStringEx(0LL, v92, &v355[v142 - 1], 300LL - v142);
        size_t v166 = strlen(&__str);
        uint64_t v61 = PrintFWriteText((uint64_t (**)(const char *, uint64_t, void))a1, (uint64_t)&v346, &__str, v166);
        goto LABEL_372;
      case 'n':
        unsigned __int8 v96 = (_BYTE **)v348[0];
        v348[0] += 8LL;
        unsigned __int8 v97 = *v96;
        if (v30 == 2)
        {
          *unsigned __int8 v97 = v9;
          goto LABEL_762;
        }

        if (v30 == 1)
        {
          *(_WORD *)unsigned __int8 v97 = v9;
          goto LABEL_762;
        }

        if (v31 == 2)
        {
          uint64_t v136 = (int)v9;
        }

        else
        {
          if (v31 != 1)
          {
            *(_DWORD *)unsigned __int8 v97 = v9;
            goto LABEL_762;
          }

          uint64_t v136 = (int)v9;
        }

        *(void *)unsigned __int8 v97 = v136;
        goto LABEL_762;
      case 'o':
        unsigned int v36 = 8;
        goto LABEL_174;
      case 'p':
        uint64_t v343 = v9;
        char v98 = 0;
        int v16 = 0;
        unsigned __int8 v99 = (unint64_t *)v348[0];
        v348[0] += 8LL;
        unint64_t v100 = *v99;
        size_t v28 = 16LL;
        *(void *)&__int128 v347 = 16LL;
        LOBYTE(v20) = v20 | 8;
        LOBYTE(v346) = v20;
        char v18 = 1;
        BYTE3(v346) = 1;
        int v35 = 120;
        unsigned int v36 = 16;
        goto LABEL_221;
      case 's':
        unsigned __int8 v101 = (const char **)v348[0];
        v348[0] += 8LL;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        int v48 = (char *)*v101;
        if (!*v101)
        {
          int v35 = 115;
          LODWORD(v39) = 4;
          if ((v20 & 8) == 0 || v28) {
            goto LABEL_367;
          }
        }

        if (v17)
        {
          if ((v20 & 8) == 0) {
            size_t v28 = strlen(*v101);
          }
          _PrintFObfuscateString((unint64_t)v48, v28, &__s, 0LL);
          char v19 = BYTE8(v347);
          int v48 = (char *)&__s;
        }

        if (v19 && (v346 & 8) != 0)
        {
          if ((unint64_t)v347 < 2)
          {
            *(void *)&__int128 v347 = 0LL;
            BYTE8(v347) = 0;
          }

          else
          {
            *(void *)&__int128 v347 = v347 - 2;
          }
        }

        switch(BYTE3(v346))
        {
          case 0:
            if ((v346 & 8) != 0)
            {
              int v212 = v347;
              uint64_t v213 = 0LL;
              while (v48[v213])
              {
              }

              int v212 = v213;
LABEL_682:
              if (v212)
              {
                int v274 = 0;
                int v275 = v212;
                uint64_t v276 = (v212 - 1);
                do
                {
                  int v277 = v48[v276];
                  if ((v277 & 0x80) == 0) {
                    break;
                  }
                  ++v274;
                  int v278 = v275--;
                  if (v278 < 2) {
                    break;
                  }
                  --v276;
                }

                while ((v277 & 0xC0) == 0x80);
                unsigned int v279 = v274 - 2;
                int v280 = v274 + v275;
                if (v279 <= 4) {
                  LODWORD(v39) = v280;
                }
                else {
                  LODWORD(v39) = v275;
                }
              }

              else
              {
LABEL_692:
                LODWORD(v39) = 0;
              }
            }

            else
            {
              uint64_t v181 = 0LL;
              do
                LODWORD(v39) = v181;
              while (v48[v181++]);
            }

            goto LABEL_744;
          case 1:
            int v183 = *v48++;
            LODWORD(v39) = v183;
            goto LABEL_744;
          case 2:
            *(void *)__format = &__str;
            uint64_t v184 = *v48;
            if (*v48 || (*(void *)__format = v355, __str = 46, uint64_t v184 = *v48, *v48))
            {
              while (1)
              {
                if (v184 >= 0x40)
                {
                  SNPrintF_Add( (uint64_t *)__format,  (uint64_t)v357,  (uint64_t)"<<INVALID DNS LABEL LENGTH %u>>",  a4,  a5,  a6,  a7,  a8,  v184);
                  goto LABEL_615;
                }

                SNPrintF_Add((uint64_t *)__format, (uint64_t)v357, (uint64_t)"%#s.", a4, a5, a6, a7, a8, (uint64_t)v48);
                uint64_t v185 = &v48[*v48];
                unsigned int v186 = v185[1];
                int v48 = v185 + 1;
                uint64_t v184 = v186;
                if (!v186) {
                  goto LABEL_615;
                }
              }

              SNPrintF_Add( (uint64_t *)__format,  (uint64_t)v357,  (uint64_t)"<<DNS NAME TOO LONG>>",  a4,  a5,  a6,  a7,  a8,  usedBufLen);
            }

LABEL_615:
            int v48 = &__str;
            LODWORD(v39) = *(_DWORD *)__format - &__str;
            goto LABEL_744;
          case 3:
            int v187 = *v48;
            if (v187 == 43 || v187 == 45)
            {
              LODWORD(v18_Block_object_dispose(va, 8) = (_DWORD)v48 + strlen(v48);
              goto LABEL_743;
            }

            v251 = v48 + 1;
            v252 = v48 + 1;
            char v253 = *v48;
            v254 = v48;
            break;
          default:
            int v48 = &__str;
            LODWORD(v39) = SNPrintF(&__str, 300LL, "<< ERROR: %%s with too many #'s (%d) >>", SBYTE3(v346));
            goto LABEL_744;
        }

        while (2)
        {
          if (v253 == 32)
          {
            v254 = v252;
LABEL_601:
            char v255 = *v252++;
            char v253 = v255;
            continue;
          }

          break;
        }

        if (!v253) {
          goto LABEL_669;
        }
        if (v253 != 58) {
          goto LABEL_601;
        }
        v271 = v252 - 1;
        if (v271[1] != 58)
        {
          while (1)
          {
LABEL_669:
            if (v187 == 32)
            {
              int v48 = v251;
            }

            else if (!(_BYTE)v187 || v187 == 40)
            {
              uint64_t v188 = v251 - 1;
              goto LABEL_673;
            }

            char v272 = *v251++;
            LOBYTE(v187) = v272;
          }
        }

        uint64_t v188 = v271 + 2;
        int v48 = v254;
LABEL_673:
        while (1)
        {
          int v273 = *v188;
          if (!*v188 || v273 == 32) {
            break;
          }
          if (v273 == 40)
          {
            if (v188[1] == 41)
            {
              v292 = (unsigned __int8 *)(v188 + 2);
              int v293 = v188[2];
              uint64_t v294 = 3LL;
              if (v293 != 39) {
                uint64_t v294 = 0LL;
              }
              v188 += v294;
              if (v293 == 40) {
                uint64_t v188 = (char *)v292;
              }
            }

            break;
          }

          ++v188;
        }

        if (v48 < v188 && *v48 == 42) {
          ++v48;
        }
LABEL_743:
        LODWORD(v39) = (_DWORD)v188 - (_DWORD)v48;
LABEL_744:
        if ((v346 & 8) != 0 && (int)v39 > (int)v347)
        {
          LODWORD(v39) = v347;
          if ((int)v347 >= 1)
          {
            uint64_t v39 = v347;
            while ((v48[v39] & 0xC0) == 0x80)
            {
              BOOL v165 = v39-- <= 1;
              if (v165)
              {
                LODWORD(v39) = 0;
                break;
              }
            }
          }
        }

        if (BYTE8(v347) == 2)
        {
          __int16 v295 = 8738;
        }

        else
        {
          if (BYTE8(v347) != 1) {
            goto LABEL_757;
          }
          __int16 v295 = 10023;
        }

        *(_WORD *)((char *)&v347 + 9) = v295;
LABEL_757:
        int v35 = 115;
        goto LABEL_758;
      case 'u':
        goto LABEL_174;
      case 'v':
        uint64_t v102 = (unsigned int *)v348[0];
        v348[0] += 8LL;
        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        unsigned int v103 = *v102;
        int v104 = HIWORD(*v102) & 0xF;
        *(void *)__format = &__str;
        SNPrintF_Add((uint64_t *)__format, (uint64_t)v357, (uint64_t)"%u", a4, a5, a6, a7, a8, HIBYTE(v103));
        SNPrintF_Add( (uint64_t *)__format,  (uint64_t)v357,  (uint64_t)".%u",  v105,  v106,  v107,  v108,  v109,  (v103 >> 20) & 0xF);
        if (v104) {
          SNPrintF_Add( (uint64_t *)__format,  (uint64_t)v357,  (uint64_t)".%u",  v110,  v111,  v112,  v113,  v114,  HIWORD(v103) & 0xF);
        }
        HIDWORD(v115) = v103 >> 8;
        LODWORD(v115) = ((v103 >> 8) & 0xE0) - 32;
        switch((v115 >> 5))
        {
          case 0u:
            SNPrintF_Add( (uint64_t *)__format,  (uint64_t)v357,  (uint64_t)"d%u",  v110,  v111,  v112,  v113,  v114,  v103);
            break;
          case 1u:
            SNPrintF_Add( (uint64_t *)__format,  (uint64_t)v357,  (uint64_t)"a%u",  v110,  v111,  v112,  v113,  v114,  v103);
            break;
          case 2u:
            SNPrintF_Add( (uint64_t *)__format,  (uint64_t)v357,  (uint64_t)"b%u",  v110,  v111,  v112,  v113,  v114,  v103);
            break;
          case 3u:
            if ((_BYTE)v103) {
              SNPrintF_Add( (uint64_t *)__format,  (uint64_t)v357,  (uint64_t)"f%u",  v110,  v111,  v112,  v113,  v114,  v103);
            }
            break;
          default:
            SNPrintF_Add( (uint64_t *)__format,  (uint64_t)v357,  (uint64_t)"<< ERROR: invalid NumVersion stage: 0x%02X >>",  v110,  v111,  v112,  v113,  v114,  v103);
            break;
        }

        int v48 = &__str;
        LODWORD(v39) = *(_DWORD *)__format - &__str;
        int v35 = 118;
        goto LABEL_758;
      case 'x':
        uint64_t v37 = "0123456789abcdef";
LABEL_173:
        unsigned int v36 = 16;
LABEL_174:
        uint64_t v343 = v9;
        if (v31 == 2 || v31 == 1)
        {
          uint64_t v116 = (unint64_t *)v348[0];
          v348[0] += 8LL;
          unint64_t v117 = *v116;
        }

        else
        {
          int v118 = (unsigned int *)v348[0];
          v348[0] += 8LL;
          unint64_t v117 = *v118;
        }

        unint64_t v119 = v117;
        unint64_t v120 = (unsigned __int16)v117;
        if (v30 != 1) {
          unint64_t v120 = v117;
        }
        char v98 = 0;
        int v16 = 0;
        if (v30 == 2) {
          unint64_t v100 = v119;
        }
        else {
          unint64_t v100 = v120;
        }
        goto LABEL_222;
      case '{':
        uint64_t v121 = ++v11;
        while (1)
        {
          int v35 = *v11;
          if (!*v11 || v35 == 125) {
            break;
          }
          ++v11;
        }

        if (!strnicmpx(v121, v11 - v121, "asbd"))
        {
          __int128 v126 = (uint64_t *)v348[0];
          v348[0] += 8LL;
          if ((v346 & 0x10) != 0) {
            goto LABEL_761;
          }
          uint64_t v127 = *v126;
          uint64_t v128 = *(unsigned int *)(*v126 + 8);
          if ((int)v128 <= 1634492770)
          {
            if ((_DWORD)v128 == 1633772320 || (_DWORD)v128 == 1633772389)
            {
LABEL_552:
              uint64_t v39 = PrintFCore((uint64_t)a1);
              if ((v39 & 0x80000000) != 0) {
                return v39;
              }
              if (*(_DWORD *)(v127 + 32))
              {
                uint64_t v236 = (uint64_t)a1;
              }

              else
              {
                if (*(_DWORD *)(v127 + 8) != 1634492771) {
                  goto LABEL_559;
                }
                uint64_t v236 = (uint64_t)a1;
              }

              uint64_t v15 = PrintFCore(v236);
              if ((v15 & 0x80000000) != 0) {
                return v15;
              }
              LODWORD(v39) = v15 + v39;
LABEL_559:
              int v237 = *(_DWORD *)(v127 + 28);
              if (v237 == 1)
              {
                v238 = "Mono";
              }

              else if (v237 == 2)
              {
                v238 = "Stereo";
              }

              else
              {
                v238 = __format;
                SNPrintF(__format, 32LL, "%u ch", *(_DWORD *)(v127 + 28));
              }

              uint64_t usedBufLen = (uint64_t)v238;
              uint64_t v15 = PrintFCore((uint64_t)a1);
              if ((v15 & 0x80000000) != 0) {
                return v15;
              }
              int v239 = v15 + v39;
              if ((*(_BYTE *)(v127 + 12) & 0x20) != 0)
              {
                uint64_t v240 = PrintFCore((uint64_t)a1);
                uint64_t v39 = v240;
                if ((v240 & 0x80000000) != 0) {
                  return v39;
                }
                v239 += v240;
              }

              if (*(_DWORD *)(v127 + 8) != 1819304813) {
                goto LABEL_580;
              }
              int v241 = *(_DWORD *)(v127 + 12);
              if ((v241 & 2) != 0)
              {
                uint64_t v242 = PrintFCore((uint64_t)a1);
                uint64_t v39 = v242;
                if ((v242 & 0x80000000) != 0) {
                  return v39;
                }
                v239 += v242;
                int v241 = *(_DWORD *)(v127 + 12);
              }

              if ((v241 & 1) != 0)
              {
                uint64_t v245 = (uint64_t)a1;
              }

              else
              {
                if ((v241 & 4) == 0 || (int v243 = *(_DWORD *)(v127 + 32)) == 0 || (v244 = v241 & 0x1F80) == 0)
                {
LABEL_580:
                  if (*(_DWORD *)(v127 + 20) > 1u)
                  {
                    uint64_t usedBufLen = *(unsigned int *)(v127 + 20);
                    int v247 = PrintFCore((uint64_t)a1);
                    if (v247 >= 0) {
                      int v248 = v239;
                    }
                    else {
                      int v248 = 0;
                    }
                    uint64_t v39 = (v248 + v247);
                    if (v248 + v247 < 0) {
                      return v39;
                    }
                    goto LABEL_760;
                  }

                  uint64_t v9 = (v239 + v9);
                  goto LABEL_761;
                }

                uint64_t usedBufLen = v243 - (v244 >> 7);
                uint64_t v245 = (uint64_t)a1;
              }

              uint64_t v246 = PrintFCore(v245);
              uint64_t v39 = v246;
              if ((v246 & 0x80000000) != 0) {
                return v39;
              }
              v239 += v246;
              goto LABEL_580;
            }
          }

          else if ((_DWORD)v128 == 1634492771 || (_DWORD)v128 == 1819304813 || (_DWORD)v128 == 1869641075)
          {
            goto LABEL_552;
          }

          SNPrintF(__format, 32LL, "%C,", v128);
          goto LABEL_552;
        }

        if (!strnicmpx(v121, v11 - v121, "cec"))
        {
          int v150 = (unsigned __int8 **)v348[0];
          v348[0] += 8LL;
          __int128 v151 = *v150;
          v348[0] = v150 + 2;
          if ((v346 & 0x10) != 0) {
            goto LABEL_761;
          }
          int v344 = v9;
          unsigned int v152 = *((_DWORD *)v150 + 2);
          if ((int)v152 < 1)
          {
LABEL_884:
            uint64_t v332 = 64LL;
            uint64_t usedBufLen = (uint64_t)v151;
            uint64_t v39 = PrintFCore((uint64_t)a1);
            if ((v39 & 0x80000000) != 0) {
              return v39;
            }
            LODWORD(v9) = v344;
LABEL_760:
            uint64_t v9 = (v39 + v9);
            goto LABEL_761;
          }

          unsigned int v153 = *v151;
          if (v152 == 1)
          {
            size_t v154 = "<Poll>";
            char v155 = "";
            goto LABEL_841;
          }

          v189 = v151 + 2;
          unsigned int v190 = v151[1];
          if (v190 > 0x7F)
          {
            switch(v151[1])
            {
              case 0x80u:
                if (v152 < 6) {
                  goto LABEL_884;
                }
                char v155 = (const char *)&v358;
                SNPrintF(&v358, 32LL, "%.2a -> %.2a", COERCE_DOUBLE(v151 + 2), COERCE_DOUBLE(v151 + 4));
                size_t v154 = "<Routing Change>";
                break;
              case 0x82u:
                if (v152 < 4) {
                  goto LABEL_884;
                }
                char v155 = (const char *)&v358;
                SNPrintF(&v358, 32LL, "%.2a", COERCE_DOUBLE(v151 + 2));
                size_t v154 = "<Active Source>";
                break;
              case 0x83u:
                size_t v154 = "<Give Physical Address>";
                goto LABEL_840;
              case 0x84u:
                size_t v154 = "<Report Physical Address>";
                goto LABEL_840;
              case 0x85u:
                size_t v154 = "<Request Active Source>";
                goto LABEL_840;
              case 0x86u:
                if (v152 < 4) {
                  goto LABEL_884;
                }
                char v155 = (const char *)&v358;
                SNPrintF(&v358, 32LL, "%.2a", COERCE_DOUBLE(v151 + 2));
                size_t v154 = "<Set Stream Path>";
                break;
              case 0x87u:
                if (v152 < 5) {
                  goto LABEL_884;
                }
                char v155 = (const char *)&v358;
                SNPrintF(&v358, 32LL, "%02X-%02X-%02X", v151[2], v151[3], v151[4]);
                size_t v154 = "<Device Vendor ID>";
                break;
              case 0x8Cu:
                size_t v154 = "<Give Device Vendor ID>";
                goto LABEL_840;
              case 0x8Du:
                size_t v154 = "<Menu Request>";
                goto LABEL_840;
              case 0x8Eu:
                size_t v154 = "<Menu Status>";
                goto LABEL_840;
              case 0x8Fu:
                size_t v154 = "<Give Power Status>";
                goto LABEL_840;
              case 0x90u:
                size_t v154 = "<Report Power Status>";
                goto LABEL_840;
              case 0x9Du:
                size_t v154 = "<Inactive Source>";
                goto LABEL_840;
              case 0x9Eu:
                if (v152 < 3) {
                  goto LABEL_884;
                }
                if (*v189 - 4 >= 3)
                {
                  char v155 = (const char *)&v358;
                  SNPrintF(&v358, 32LL, "Other %H", v151 + 2, v152 - 2, v152 - 2);
                }

                else
                {
                  char v155 = off_189F33DA8[(*v189 - 4)];
                }

                size_t v154 = "<CEC Version>";
                break;
              case 0x9Fu:
                size_t v154 = "<Get CEC Version>";
                goto LABEL_840;
              case 0xA0u:
                size_t v154 = "<Vendor Command with ID>";
                goto LABEL_840;
              default:
                goto LABEL_837;
            }

LABEL_841:
            v311 = "TV";
            if (v153 >= 0x10)
            {
              v311 = "Broadcast";
              if ((v153 >> 4) - 1 <= 0xD) {
                v311 = off_189F33DC0[((v153 >> 4) - 1)];
              }
            }

            uint64_t v332 = (uint64_t)v154;
            unint64_t v333 = (unint64_t)v155;
            uint64_t usedBufLen = (uint64_t)v311;
            int v312 = PrintFCore((uint64_t)a1);
            if ((v312 & 0x80000000) == 0)
            {
              uint64_t v9 = (v312 + v344);
              goto LABEL_761;
            }

            goto LABEL_884;
          }

          if (v151[1] > 0x31u)
          {
            switch(v151[1])
            {
              case 'D':
                size_t v154 = "<User Control Pressed>";
                goto LABEL_840;
              case 'E':
                size_t v154 = "<User Control Released>";
                goto LABEL_840;
              case 'F':
                size_t v154 = "<Get OSD Name>";
                goto LABEL_840;
              case 'G':
                char v155 = (const char *)&v358;
                SNPrintF(&v358, 32LL, "'%.*s'", v152 - 2, (const char *)v151 + 2);
                size_t v154 = "<Set OSD Name>";
                goto LABEL_841;
              default:
                if (v190 == 50)
                {
                  char v155 = (const char *)&v358;
                  SNPrintF(&v358, 32LL, "'%.*s'", v152 - 2, (const char *)v151 + 2);
                  size_t v154 = "<Set Menu Language>";
                  goto LABEL_841;
                }

                if (v190 != 54) {
                  goto LABEL_837;
                }
                size_t v154 = "<Standby>";
                break;
            }

            goto LABEL_840;
          }

          if (v151[1] > 0xCu)
          {
            if (v190 == 13)
            {
              size_t v154 = "<Text View On>";
            }

            else
            {
              if (v190 != 26)
              {
LABEL_837:
                size_t v154 = __format;
                SNPrintF(__format, 32LL, "<<? 0x%02X>>", v151[1]);
                v189 = v151 + 2;
                goto LABEL_840;
              }

              size_t v154 = "<Give Deck Status>";
            }
          }

          else if (v151[1])
          {
            size_t v154 = "<Image View On>";
            if (v190 != 4) {
              goto LABEL_837;
            }
          }

          else
          {
            size_t v154 = "<Feature Abort>";
          }

LABEL_840:
          char v155 = (const char *)&v358;
          SNPrintF(&v358, 32LL, "%H", v189, v152 - 2, v152 - 2);
          goto LABEL_841;
        }

        if (!strnicmpx(v121, v11 - v121, "DateCF"))
        {
          char v167 = (double *)v348[0];
          v348[0] += 8LL;
          if ((v346 & 0x10) != 0) {
            goto LABEL_761;
          }
          double v168 = *v167;
          SecondsToYMD_HMS((uint64_t)*v167 + 0xEB1E31100LL, (int *)&v358, &v349, v357, (int *)&v352, &v351, &v350);
          modf(v168, (double *)__format);
          unint64_t v333 = v352;
          uint64_t v332 = *(unsigned int *)v357;
          int v48 = &__str;
          int v49 = SNPrintF(&__str, 300LL, "%04d-%02d-%02d-%02d:%02d:%02d.%03d", LODWORD(v358.tv_sec));
LABEL_82:
          LODWORD(v39) = v49;
          goto LABEL_758;
        }

        if (!strnicmpx(v121, v11 - v121, "dur"))
        {
          if (BYTE2(v346) == 2 || BYTE2(v346) == 1)
          {
            char v179 = (unint64_t *)v348[0];
            v348[0] += 8LL;
            unint64_t v180 = *v179;
          }

          else
          {
            v249 = (unsigned int *)v348[0];
            v348[0] += 8LL;
            unint64_t v180 = *v249;
          }

          if (BYTE1(v346) == 1) {
            unint64_t v180 = (unsigned __int16)v180;
          }
          if (BYTE1(v346) == 2) {
            unint64_t v250 = v180;
          }
          else {
            unint64_t v250 = v180;
          }
          if ((v346 & 0x10) != 0) {
            goto LABEL_761;
          }
          int v48 = &__str;
          int v49 = PrintFWriteTimeDuration(v250, SBYTE3(v346), &__str);
          goto LABEL_82;
        }

        if (!strnicmpx(v121, v11 - v121, "end"))
        {
          uint64_t v39 = v9;
          if ((v346 & 0x10) == 0) {
            return v39;
          }
          goto LABEL_761;
        }

        if (strnicmpx(v121, v11 - v121, "error"))
        {
          if (strnicmpx(v121, v11 - v121, "fill"))
          {
            if (!strnicmpx(v121, v11 - v121, "flags"))
            {
              if (BYTE2(v346) == 2 || BYTE2(v346) == 1)
              {
                v270 = (uint64_t *)v348[0];
                v348[0] += 8LL;
                a4 = *v270;
              }

              else
              {
                v303 = (unsigned int *)v348[0];
                v348[0] += 8LL;
                a4 = *v303;
              }

              if (BYTE1(v346) == 2)
              {
                a4 = a4;
              }

              else if (BYTE1(v346) == 1)
              {
                a4 = (unsigned __int16)a4;
              }

              v304 = (const char **)v348[0];
              v348[0] += 8LL;
              if ((v346 & 0x10) != 0) {
                goto LABEL_761;
              }
              v305 = *v304;
              if (v305) {
                v306 = v305;
              }
              else {
                v306 = (const char *)&unk_186B4BE74;
              }
              uint64_t v215 = PrintFWriteFlags((uint64_t)a1, SBYTE3(v346), v306, a4);
              goto LABEL_759;
            }

            if (!strnicmpx(v121, v11 - v121, "mask"))
            {
              v296 = (const __CFURL **)v348[0];
              v348[0] += 8LL;
              if ((v346 & 0x10) != 0) {
                goto LABEL_761;
              }
              if (*v296)
              {
                uint64_t v215 = PrintFWriteMaskObject(a1, *v296);
LABEL_759:
                uint64_t v39 = v215;
                if ((v215 & 0x80000000) != 0) {
                  return v39;
                }
                goto LABEL_760;
              }

LABEL_366:
              LODWORD(v39) = 4;
LABEL_367:
              int v48 = "NULL";
LABEL_758:
              uint64_t v215 = PrintFWriteText( (uint64_t (**)(const char *, uint64_t, void))a1,  (uint64_t)&v346,  v48,  (int)v39);
              goto LABEL_759;
            }

            if (strnicmpx(v121, v11 - v121, "pid"))
            {
              if (!strnicmpx(v121, v11 - v121, "ptr"))
              {
                v307 = (uint64_t *)v348[0];
                v348[0] += 8LL;
                if ((v346 & 0x10) == 0) {
                  uint64_t v9 = PrintFWriteObfuscatedPtr((uint64_t)a1, *v307) + v9;
                }
                goto LABEL_761;
              }

              if (!strnicmpx(v121, v11 - v121, "sline"))
              {
                uint64_t v308 = v348[0];
                v348[0] += 8LL;
                v309 = *(char **)v308;
                v348[0] = v308 + 16;
                if ((v346 & 0x10) != 0) {
                  goto LABEL_761;
                }
                size_t v310 = *(void *)(v308 + 8);
                if (v310 == -1LL) {
                  size_t v310 = strlen(v309);
                }
                uint64_t v215 = PrintFWriteSingleLineText(a1, (unsigned __int8 *)v309, v310, SBYTE3(v346));
                goto LABEL_759;
              }

              if (!strnicmpx(v121, v11 - v121, "text"))
              {
                uint64_t v313 = v348[0];
                v348[0] += 8LL;
                v314 = *(char **)v313;
                v348[0] = v313 + 16;
                if ((v346 & 0x10) != 0) {
                  goto LABEL_761;
                }
                size_t v315 = *(void *)(v313 + 8);
                if (v315 == -1LL) {
                  size_t v315 = strlen(v314);
                }
                uint64_t v215 = PrintFWriteMultiLineText(a1, (uint64_t)&v346, (unsigned __int8 *)v314, v315);
                goto LABEL_759;
              }

              if (!strnicmpx(v121, v11 - v121, "tlv8"))
              {
                uint64_t v318 = v348[0];
                v348[0] += 8LL;
                v319 = *(const char **)v318;
                v348[0] = v318 + 16;
                a4 = *(void *)(v318 + 8);
                v348[0] = v318 + 24;
                if ((v346 & 0x10) != 0) {
                  goto LABEL_761;
                }
                if (v319) {
                  v320 = v319;
                }
                else {
                  v320 = (const char *)&unk_186B4BE74;
                }
                uint64_t v215 = PrintFWriteTLV8((uint64_t)a1, (uint64_t)&v346, v320, (unsigned __int8 *)a4, *(int *)(v318 + 16));
                goto LABEL_759;
              }

              if (!strnicmpx(v121, v11 - v121, "txt"))
              {
                v321 = (uint64_t *)v348[0];
                v348[0] += 8LL;
                a4 = *v321;
                v348[0] = v321 + 2;
                if ((v346 & 0x10) != 0) {
                  goto LABEL_761;
                }
                uint64_t v215 = PrintFWriteTXTRecord((uint64_t)a1, SBYTE3(v346), DWORD2(v346), (unsigned __int8 *)a4, v321[1]);
                goto LABEL_759;
              }

              if (!strnicmpx(v121, v11 - v121, "xml"))
              {
                uint64_t v322 = v348[0];
                v348[0] += 8LL;
                v323 = *(char **)v322;
                v348[0] = v322 + 16;
                if ((v346 & 0x10) != 0) {
                  goto LABEL_761;
                }
                uint64_t v215 = PrintFWriteXMLEscaped( (uint64_t (**)(char *, int64_t, void))a1,  v323,  *(void *)(v322 + 8));
                goto LABEL_759;
              }

              if (strnicmpx(v121, v11 - v121, "xpc"))
              {
                pthread_mutex_lock(&gPrintFUtilsLock);
                size_t v122 = &gExtensionList;
                do
                {
                  size_t v122 = (uint64_t *)*v122;
                  if (!v122)
                  {
                    pthread_mutex_unlock(&gPrintFUtilsLock);
                    int v48 = &__str;
                    int v49 = SNPrintF(&__str, 300LL, "<<UNKNOWN PRINTF EXTENSION '%.*s'>>");
                    goto LABEL_82;
                  }
                }

                while (strnicmpx(v121, v11 - v121, (_BYTE *)v122 + 24));
                uint64_t v39 = ((uint64_t (*)(uint64_t (**)(unsigned __int8 *, int64_t, void), __int128 *, void *, uint64_t))v122[1])( a1,  &v346,  v348,  v122[2]);
                pthread_mutex_unlock(&gPrintFUtilsLock);
                if ((v39 & 0x80000000) != 0) {
                  return v39;
                }
                goto LABEL_760;
              }

              v324 = (id *)v348[0];
              v348[0] += 8LL;
              id v325 = *v324;
              v326 = v325;
              if ((v346 & 0x10) != 0) {
                goto LABEL_882;
              }
              if (v325)
              {
                v327 = (const char *)MEMORY[0x186E43B84](v325);
                if (v327)
                {
                  v328 = (unsigned __int8 *)v327;
                  size_t v329 = strlen(v327);
                  uint64_t v39 = PrintFWriteMultiLineText(a1, (uint64_t)&v346, v328, v329);
                  free(v328);
                  if ((v39 & 0x80000000) != 0)
                  {

                    return v39;
                  }

                  uint64_t v9 = (v39 + v9);
LABEL_882:

                  goto LABEL_761;
                }

                LODWORD(v39) = 17;
                int v48 = "<<NULL XPC DESC>>";
              }

              else
              {
                LODWORD(v39) = 4;
                int v48 = "NULL";
              }

              goto LABEL_758;
            }

            v301 = (int *)v348[0];
            v348[0] += 8LL;
            if ((v346 & 0x10) != 0) {
              goto LABEL_761;
            }
            int v302 = *v301;
            char __str = 0;
            GetProcessNameByPID(v302, &__str, 0x12CuLL);
            if (__str) {
              uint64_t usedBufLen = (uint64_t)&__str;
            }
            else {
              uint64_t usedBufLen = v302;
            }
            uint64_t v39 = PrintFCore((uint64_t)a1);
            if ((v39 & 0x80000000) != 0) {
              return v39;
            }
          }

          else
          {
            v259 = (int *)v348[0];
            v348[0] += 8LL;
            int v260 = *v259;
            v348[0] = v259 + 4;
            if ((v346 & 0x10) != 0) {
              goto LABEL_761;
            }
            int v261 = v259[2];
            if (!v261) {
              goto LABEL_761;
            }
            int v262 = v9;
            LODWORD(v39) = 0;
            unint64_t v263 = v261;
            do
            {
              if (v263 >= 0x12C) {
                size_t v264 = 300LL;
              }
              else {
                size_t v264 = v263;
              }
              memset(&__str, v260, v264);
              uint64_t v15 = ((uint64_t (*)(char *, size_t))*a1)(&__str, v264);
              if ((v15 & 0x80000000) != 0) {
                return v15;
              }
              uint64_t v39 = (v15 + v39);
              v263 -= v264;
            }

            while (v263);
            if ((v39 & 0x80000000) != 0) {
              return v39;
            }
            LODWORD(v9) = v262;
          }

          uint64_t v9 = (v39 + v9);
        }

        else
        {
          v214 = (void **)v348[0];
          v348[0] += 8LL;
          if ((v346 & 0x10) == 0)
          {
            uint64_t v215 = PrintFWriteErrorObject((uint64_t)a1, *v214);
            goto LABEL_759;
          }
        }

LABEL_761:
        int v10 = 0;
        size_t v8 = v11;
        if (v35) {
          goto LABEL_762;
        }
        continue;
      default:
        if ((char)v21 != 37)
        {
LABEL_81:
          int v48 = &__str;
          int v49 = SNPrintF(&__str, 300LL, "<<UNKNOWN FORMAT CONVERSION CODE '%%%c'>>");
          goto LABEL_82;
        }

        if ((v20 & 0x10) != 0) {
          goto LABEL_762;
        }
        int v35 = 37;
        char __str = 37;
LABEL_369:
        LODWORD(v39) = 1;
        goto LABEL_77;
    }
  }

uint64_t SNPrintF_Add( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = *a1;
  uint64_t v10 = a2 - *a1;
  if (a2 == *a1) {
    return 4294960533LL;
  }
  uint64_t result = VSNPrintF(v9, v10, a3, &a9);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v14 = v9 + result;
    if ((int)result < (int)v10)
    {
      uint64_t result = 0LL;
    }

    else
    {
      uint64_t v14 = a2;
      uint64_t result = 4294960545LL;
    }

    *a1 = v14;
  }

  return result;
}

unint64_t _PrintFObfuscateString(unint64_t __s, uint64_t a2, _BYTE *a3, uint64_t *a4)
{
  uint64_t v6 = (unsigned __int8 *)__s;
  if (a2 == -1)
  {
    int8x16_t __s = strlen((const char *)__s);
    uint64_t v7 = __s;
    if (__s) {
      goto LABEL_8;
    }
LABEL_15:
    *a3 = 0;
    if (!a4) {
      return __s;
    }
    uint64_t v9 = 0LL;
    goto LABEL_17;
  }

  if (!a2) {
    goto LABEL_15;
  }
  uint64_t v7 = 0LL;
  while (*(_BYTE *)(__s + v7))
  {
    if (a2 == ++v7)
    {
      uint64_t v7 = a2;
      break;
    }
  }

  if (!v7) {
    goto LABEL_15;
  }
LABEL_8:
  if (gObfuscateOnce != -1) {
    dispatch_once_f(&gObfuscateOnce, 0LL, (dispatch_function_t)_PrintFObfuscateInit);
  }
  int8x16_t __s = SipHash(gObfuscateKey, v6, v7);
  *(_WORD *)a3 = 16962;
  for (uint64_t i = 2LL; i != 8; ++i)
  {
    a3[i] = aAbcdefghijklmn[__s % 0x34];
    __s >>= 8;
  }

  a3[8] = 0;
  if (a4)
  {
    uint64_t v9 = 8LL;
LABEL_17:
    *a4 = v9;
  }

  return __s;
}

uint64_t SNPrintF(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  return VSNPrintF(a1, a2, (unsigned __int8 *)a3, (uint64_t)va, a5, a6, a7, a8);
}

uint64_t PrintFCore(uint64_t a1)
{
  return PrintFCoreVAList(a1);
}

uint64_t PrintFWriteMultiLineText( uint64_t (**a1)(unsigned __int8 *, int64_t, void), uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  if (a4 < 1) {
    return 0LL;
  }
  size_t v4 = a3;
  uint64_t v6 = 0LL;
  unint64_t v7 = (unint64_t)&a3[a4];
  while (1)
  {
    size_t v8 = v4;
    uint64_t v9 = v4;
    while (1)
    {
      int v10 = *v9;
      if (v10 == 10) {
        break;
      }
      if (v10 == 13)
      {
        if ((unint64_t)(v9 + 1) < v7 && v9[1] == 10)
        {
          size_t v4 = v9 + 2;
          goto LABEL_12;
        }

        break;
      }

      if ((unint64_t)++v9 >= v7)
      {
        int v11 = 0;
        size_t v4 = v9;
        goto LABEL_13;
      }
    }

    size_t v4 = v9 + 1;
LABEL_12:
    int v11 = 1;
LABEL_13:
    if (v8 >= v9) {
      goto LABEL_24;
    }
    int v12 = *v8;
    if (v12 != 10 && v12 != 13)
    {
      int v14 = *(_DWORD *)(a2 + 8);
      if (v14) {
        break;
      }
    }

uint64_t PrintFWriteText( uint64_t (**a1)(const char *, uint64_t, void), uint64_t a2, const char *a3, uint64_t a4)
{
  size_t v8 = (const char *)(a2 + 25);
  if (*(_BYTE *)(a2 + 25)) {
    int v9 = a4 + 1;
  }
  else {
    int v9 = a4;
  }
  int v10 = (const char *)(a2 + 26);
  if (*(_BYTE *)(a2 + 26)) {
    int v11 = v9 + 1;
  }
  else {
    int v11 = v9;
  }
  if ((*(_BYTE *)a2 & 1) == 0 && v11 < *(_DWORD *)(a2 + 8))
  {
    int v12 = 0;
    while (1)
    {
      uint64_t v13 = (*a1)(" ", 1LL, a1);
      if ((v13 & 0x80000000) != 0) {
        return v13;
      }
      ++v12;
      int v14 = *(_DWORD *)(a2 + 8) - 1;
      *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v14;
      if (v11 >= v14)
      {
        if (*v8) {
          goto LABEL_15;
        }
        goto LABEL_17;
      }
    }
  }

  int v12 = 0;
  if (*(_BYTE *)(a2 + 25))
  {
LABEL_15:
    uint64_t v13 = (*a1)(v8, 1LL, a1);
    if ((v13 & 0x80000000) != 0) {
      return v13;
    }
    ++v12;
  }

uint64_t PrintFWriteHexByteStream( uint64_t (**a1)(_BYTE *, uint64_t, void), int a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a2) {
    size_t v4 = "0123456789ABCDEF";
  }
  else {
    size_t v4 = "0123456789abcdef";
  }
  if (a4 < 1) {
    return 0LL;
  }
  uint64_t v5 = a3;
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  unint64_t v9 = (unint64_t)&a3[a4];
  do
  {
    if (v8 == 64)
    {
      uint64_t v10 = (*a1)(v15, 64LL, a1);
      if ((v10 & 0x80000000) != 0) {
        return v10;
      }
      uint64_t v8 = 0LL;
      uint64_t v7 = (v7 + 64);
    }

    int v11 = &v15[v8];
    unsigned int v12 = *v5++;
    *int v11 = v4[(unint64_t)v12 >> 4];
    v8 += 2LL;
    v11[1] = v4[v12 & 0xF];
  }

  while ((unint64_t)v5 < v9);
  if (v8)
  {
    int v13 = (*a1)(v15, v8, a1);
    if (v13 >= 0) {
      return (v7 + v8);
    }
    else {
      return v13;
    }
  }

  return v7;
}

uint64_t PrintFWriteHex( uint64_t (**a1)(const char *, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, int a7)
{
  uint64_t v7 = a4;
  uint64_t v32 = 0LL;
  uint64_t v8 = 0LL;
  int v34 = 0;
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (a5 >= a6) {
    unint64_t v9 = a6;
  }
  else {
    unint64_t v9 = a5;
  }
  uint64_t v10 = &v40;
  int v11 = &v41;
  while (1)
  {
    unint64_t v12 = 0LL;
    unint64_t v13 = v9 >= 0x10 ? 16LL : v9;
    uint64_t v38 = v11;
    do
    {
      if (v12 && (v12 & 3) == 0) {
        *v11++ = 32;
      }
      if (v12 >= v13)
      {
        char v14 = 32;
        *int v11 = 32;
      }

      else
      {
        *int v11 = a0123456789abcd[(unint64_t)*(unsigned __int8 *)(v7 + v12) >> 4];
        char v14 = a0123456789abcd[*(_BYTE *)(v7 + v12) & 0xF];
      }

      v11[1] = v14;
      v11 += 2;
      ++v12;
    }

    while (v12 != 16);
    unint64_t v15 = 0LL;
    *int v11 = 0;
    do
    {
      if (v15 >= v13)
      {
        LOBYTE(v16) = 32;
      }

      else
      {
        int v16 = *(unsigned __int8 *)(v7 + v15);
      }

      v39[v15++] = v16;
    }

    while (v15 != 16);
    v39[16] = 0;
    if (a5 > 0x10)
    {
      if (v7 == a4)
      {
        int v35 = v10;
        uint64_t v19 = PrintFCore((uint64_t)a1);
        if ((v19 & 0x80000000) != 0) {
          return v19;
        }
        uint64_t v20 = PrintFCore((uint64_t)a1);
        if ((v20 & 0x80000000) != 0) {
          return v20;
        }
        int v25 = v19 + v8;
LABEL_49:
        uint64_t v8 = (v25 + v20);
        uint64_t v10 = v35;
        goto LABEL_50;
      }

      if (*(char *)(a2 + 24) < 1
        || (*(void *)v38 == *(void *)v10 ? (BOOL v21 = *((void *)v38 + 1) == *((void *)v10 + 1)) : (BOOL v21 = 0),
            v21 ? (BOOL v22 = *((void *)v38 + 2) == *((void *)v10 + 2)) : (BOOL v22 = 0),
            v22 ? (BOOL v23 = *((void *)v38 + 3) == *((void *)v10 + 3)) : (BOOL v23 = 0),
            !v23))
      {
        uint64_t v20 = (*a1)("\n", 1LL);
        if ((v20 & 0x80000000) != 0) {
          return v20;
        }
        int v35 = v10;
        int v24 = v8 + 1;
        if (v34 >= 1)
        {
          uint64_t v8 = PrintFCore((uint64_t)a1);
          if ((v8 & 0x80000000) != 0) {
            return v8;
          }
          uint64_t v20 = PrintFCore((uint64_t)a1);
          if ((v20 & 0x80000000) != 0) {
            return v20;
          }
          int v34 = 0;
          uint64_t v32 = 0LL;
          v24 += v8 + v20;
        }

        uint64_t v8 = PrintFCore((uint64_t)a1);
        if ((v8 & 0x80000000) != 0) {
          return v8;
        }
        uint64_t v20 = PrintFCore((uint64_t)a1);
        if ((v20 & 0x80000000) != 0) {
          return v20;
        }
        int v25 = v8 + v24;
        goto LABEL_49;
      }

      ++v34;
      v32 += v13;
    }

    else
    {
      unint64_t v17 = v9;
      char v18 = v10;
      uint64_t v19 = PrintFCore((uint64_t)a1);
      if ((v19 & 0x80000000) != 0) {
        return v19;
      }
      uint64_t v20 = PrintFCore((uint64_t)a1);
      if ((v20 & 0x80000000) != 0) {
        return v20;
      }
      uint64_t v8 = (v19 + v8 + v20);
      uint64_t v10 = v18;
      unint64_t v9 = v17;
    }

uint64_t PrintFWriteCFObjectLevel(uint64_t (***a1)(CFUUIDBytes *), const __CFArray *a2, uint64_t a3)
{
  while (1)
  {
    uint64_t v3 = a3;
    size_t v4 = a2;
    uint64_t v5 = a1;
    uint64_t v68 = *MEMORY[0x1895F89C0];
    uint64_t v6 = (uint64_t)a1[1];
    int v7 = *(unsigned __int8 *)(v6 + 3);
    CFTypeID v8 = CFGetTypeID(a2);
    if (v8 == CFArrayGetTypeID())
    {
      if (v7 == 2)
      {
        CFIndex Count = CFArrayGetCount(v4);
        if (Count > 0)
        {
          CFIndex v10 = Count;
          uint64_t v11 = ((uint64_t (*)(const char *, uint64_t))**v5)("[ ", 2LL);
          LODWORD(v12) = 0;
LABEL_11:
          if ((v11 & 0x80000000) != 0) {
            return v11;
          }
          CFIndex v14 = 0LL;
          int v15 = v11 + v12;
          while (1)
          {
            ++*((_DWORD *)v5 + 4);
            ValueAtIndex = CFArrayGetValueAtIndex(v4, v14);
            uint64_t v12 = PrintFWriteCFObjectLevel(v5, ValueAtIndex, 1LL);
            --*((_DWORD *)v5 + 4);
            if ((v12 & 0x80000000) != 0) {
              return v12;
            }
            if (++v14 >= v10) {
              break;
            }
            context.byte0 = 44;
            if (v7 != 2)
            {
              uint64_t v18 = 1LL;
LABEL_20:
              uint64_t v17 = v18 + 1;
              *(&context.byte0 + v1_Block_object_dispose(va, 8) = 10;
              goto LABEL_21;
            }

            context.byte1 = 32;
            uint64_t v17 = 2LL;
LABEL_21:
            uint64_t v11 = ((uint64_t (*)(CFUUIDBytes *, uint64_t))**v5)(&context, v17);
            if ((v11 & 0x80000000) != 0) {
              return v11;
            }
            v15 += v12 + v11;
            if (v10 == v14)
            {
              uint64_t v19 = (uint64_t (**)(const char *, uint64_t))*v5;
              if (v7 == 2)
              {
                int v20 = (*v19)(" ]", 2LL);
              }

              else
              {
                uint64_t v27 = PrintFCore((uint64_t)v19);
                uint64_t v12 = v27;
                if ((v27 & 0x80000000) != 0) {
                  return v12;
                }
                v15 += v27;
                int v20 = ((uint64_t (*)(const char *, uint64_t))**v5)("]", 1LL);
              }

              if (v20 >= 0) {
                int v28 = v15;
              }
              else {
                int v28 = 0;
              }
              return (v28 + v20);
            }
          }

          uint64_t v18 = 0LL;
          uint64_t v17 = 0LL;
          if (v7 == 2) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }

        LODWORD(v12) = 0;
      }

      else
      {
        uint64_t v12 = PrintFCore((uint64_t)*v5);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
        CFIndex v13 = CFArrayGetCount(v4);
        if (v13 > 0)
        {
          CFIndex v10 = v13;
          uint64_t v11 = ((uint64_t (*)(const char *, uint64_t))**v5)("[\n", 2LL);
          goto LABEL_11;
        }
      }

      char v31 = **v5;
      uint64_t v32 = "[]";
      goto LABEL_58;
    }

    if (v8 == CFBooleanGetTypeID())
    {
      if (v7 == 2)
      {
        LODWORD(v12) = 0;
      }

      else
      {
        uint64_t v12 = PrintFCore((uint64_t)*v5);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
      }

      if ((const __CFArray *)*MEMORY[0x189604DE8] == v4) {
        uint64_t v29 = 4LL;
      }
      else {
        uint64_t v29 = 5LL;
      }
      if ((const __CFArray *)*MEMORY[0x189604DE8] == v4) {
        unsigned __int8 v30 = "true";
      }
      else {
        unsigned __int8 v30 = "false";
      }
      uint64_t v11 = ((uint64_t (*)(const char *, uint64_t))**v5)(v30, v29);
LABEL_51:
      if ((v11 & 0x80000000) != 0) {
        return v11;
      }
      return (v11 + v12);
    }

    if (v8 == CFDataGetTypeID())
    {
      BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v4);
      unint64_t Length = CFDataGetLength(v4);
      unint64_t v23 = Length;
      unint64_t v24 = Length;
      if ((*(_BYTE *)v6 & 8) != 0) {
        unint64_t v24 = *(void *)(v6 + 16);
      }
      if (v7 == 2)
      {
        if (v24 >= Length) {
          unint64_t v25 = Length;
        }
        else {
          unint64_t v25 = v24;
        }
        if (v25 >= 0x40) {
          unint64_t v26 = 64LL;
        }
        else {
          unint64_t v26 = v25;
        }
        uint64_t v12 = PrintFWriteHexByteStream((uint64_t (**)(_BYTE *, uint64_t, void))*v5, 0, BytePtr, v26);
        if ((v12 & 0x80000000) != 0 || v26 >= v23) {
          return v12;
        }
        int v20 = ((uint64_t (*)(const char *, uint64_t))**v5)("...", 3LL);
        goto LABEL_59;
      }

      int v34 = *((_DWORD *)v5 + 4);
      if ((_DWORD)v3 || Length >= 0x11)
      {
        if ((_DWORD)v3)
        {
          LODWORD(v12) = 0;
        }

        else
        {
          uint64_t v12 = ((uint64_t (*)(const char *, uint64_t))**v5)("\n", 1LL);
          if ((v12 & 0x80000000) != 0) {
            return v12;
          }
        }

        uint64_t v35 = (v34 + 1);
      }

      else
      {
        uint64_t v35 = 0LL;
        LODWORD(v12) = 0;
      }

      *((_DWORD *)v5 + 4) = v35;
      uint64_t v11 = PrintFWriteHex((uint64_t (**)(const char *, uint64_t))*v5, v6, v35, (uint64_t)BytePtr, v23, v24, 0);
      if ((v11 & 0x80000000) == 0)
      {
        uint64_t v12 = (v11 + v12);
        *((_DWORD *)v5 + 4) = v34;
        return v12;
      }

      return v11;
    }

    if (v8 == CFDateGetTypeID())
    {
      if (v7 == 2)
      {
        LODWORD(v12) = 0;
      }

      else
      {
        uint64_t v12 = PrintFCore((uint64_t)*v5);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
      }

      CFDateGetComponents((uint64_t)v4, &context, &v63, &v58, &v62, &v61, &v60, &v59);
      int v37 = PrintFCore((uint64_t)*v5);
      goto LABEL_73;
    }

    if (v8 == CFDictionaryGetTypeID())
    {
      if (v7 == 2)
      {
        if (CFDictionaryGetCount(v4) > 0)
        {
          uint64_t v36 = ((uint64_t (*)(const char *, uint64_t))**v5)("{ ", 2LL);
          LODWORD(v12) = 0;
          goto LABEL_84;
        }

        LODWORD(v12) = 0;
LABEL_108:
        char v31 = **v5;
        uint64_t v32 = "{}";
LABEL_58:
        int v20 = ((uint64_t (*)(const char *, uint64_t))v31)(v32, 2LL);
LABEL_59:
        if (v20 >= 0) {
          int v28 = v12;
        }
        else {
          int v28 = 0;
        }
        return (v28 + v20);
      }

      uint64_t v12 = PrintFCore((uint64_t)*v5);
      if ((v12 & 0x80000000) != 0) {
        return v12;
      }
      if (CFDictionaryGetCount(v4) <= 0) {
        goto LABEL_108;
      }
      uint64_t v36 = ((uint64_t (*)(const char *, uint64_t))**v5)("{\n", 2LL);
LABEL_84:
      if ((v36 & 0x80000000) == 0)
      {
        *(void *)&context.byte0 = *v5;
        *(void *)&context.byte8 = v6;
        int v38 = *((_DWORD *)v5 + 4) + 1;
        int v66 = 0;
        unsigned int v67 = 0;
        int v65 = v38;
        CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)PrintFWriteCFObjectApplier, &context);
        if ((v67 & 0x80000000) != 0)
        {
          return v67;
        }

        else
        {
          int v39 = v36 + v12 + v66;
          if (v7 == 2)
          {
LABEL_89:
            int v41 = ((uint64_t (*)(const char *, uint64_t))**v5)("}", 1LL);
            if (v41 >= 0) {
              return (v41 + v39);
            }
            else {
              return v41;
            }
          }

          else
          {
            uint64_t v40 = PrintFCore((uint64_t)*v5);
            uint64_t v36 = v40;
            if ((v40 & 0x80000000) == 0)
            {
              v39 += v40;
              goto LABEL_89;
            }
          }
        }
      }

      return v36;
    }

    if (v8 == CFNumberGetTypeID())
    {
      if (v7 == 2)
      {
        LODWORD(v12) = 0;
      }

      else
      {
        uint64_t v12 = PrintFCore((uint64_t)*v5);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
      }

      *(void *)&context.byte0 = 0LL;
      if (CFNumberIsFloatType(v4)) {
        CFNumberGetValue(v4, kCFNumberDoubleType, &context);
      }
      else {
        CFNumberGetValue(v4, kCFNumberSInt64Type, &context);
      }
      uint64_t v42 = (uint64_t)*v5;
      goto LABEL_110;
    }

    if (v8 == CFStringGetTypeID()) {
      break;
    }
    if (v8 == CFNullGetTypeID())
    {
      if (v7 == 2)
      {
        LODWORD(v12) = 0;
      }

      else
      {
        uint64_t v12 = PrintFCore((uint64_t)*v5);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
      }

      int v37 = ((uint64_t (*)(const char *, uint64_t))**v5)("Null", 4LL);
LABEL_73:
      if (v37 >= 0) {
        return (v37 + v12);
      }
      else {
        return v37;
      }
    }

    if (v8 != CFURLGetTypeID())
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        if (v7 == 2)
        {
          LODWORD(v12) = 0;
          goto LABEL_132;
        }

        uint64_t usedBufLen = (CFIndex *)(4 * *((_DWORD *)v5 + 4));
        uint64_t v57 = "";
        uint64_t v12 = PrintFCore((uint64_t)*v5);
        if ((v12 & 0x80000000) == 0)
        {
LABEL_132:
          -[__CFArray getUUIDBytes:](v4, "getUUIDBytes:", &context, usedBufLen, v57);
          uint64_t v51 = (uint64_t)*v5;
          goto LABEL_139;
        }

        return v12;
      }

      if (v8 == CFUUIDGetTypeID())
      {
        if (v7 == 2)
        {
          LODWORD(v12) = 0;
        }

        else
        {
          uint64_t v12 = PrintFCore((uint64_t)*v5);
          if ((v12 & 0x80000000) != 0) {
            return v12;
          }
        }

        CFUUIDBytes context = CFUUIDGetUUIDBytes(v4);
        uint64_t v51 = (uint64_t)*v5;
LABEL_139:
        uint64_t v11 = PrintFCore(v51);
        if ((v11 & 0x80000000) != 0) {
          return v11;
        }
        return (v11 + v12);
      }

      if (v8 == CFSetGetTypeID())
      {
        -[__CFArray allObjects](v4, "allObjects");
        int v52 = (void *)objc_claimAutoreleasedReturnValue();
        if (v52) {
          uint64_t v12 = PrintFWriteCFObjectLevel(v5, v52, v3);
        }
        else {
          uint64_t v12 = 4294960568LL;
        }

        return v12;
      }

      if (v7 == 2)
      {
        LODWORD(v12) = 0;
      }

      else
      {
        uint64_t v12 = PrintFCore((uint64_t)*v5);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
      }

      CFStringRef v53 = CFCopyDescription(v4);
      uint64_t v42 = (uint64_t)*v5;
      if (v53)
      {
        int v54 = PrintFCore(v42);
        CFRelease(v53);
        if (v54 >= 0) {
          int v55 = v12;
        }
        else {
          int v55 = 0;
        }
        return (v55 + v54);
      }

uint64_t PrintFWriteHexOneLine( uint64_t (**a1)(const char *, uint64_t, void), uint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  if (!a4) {
    return 0LL;
  }
  if (*(_BYTE *)(a2 + 3) == 2)
  {
    int v8 = 1;
    uint64_t v9 = (*a1)("|", 1LL, a1);
    if ((v9 & 0x80000000) == 0)
    {
LABEL_14:
      if (a4 <= 1) {
        uint64_t v16 = 1LL;
      }
      else {
        uint64_t v16 = a4;
      }
      int v17 = v8 + v16;
      while (1)
      {
        int v19 = *a3++;
        char v18 = v19;
        char v22 = v18;
        uint64_t v9 = (*a1)(&v22, 1LL, a1);
        if ((v9 & 0x80000000) != 0) {
          break;
        }
        if (!--v16)
        {
          int v20 = (*a1)("|", 1LL, a1);
          if (v20 >= 0) {
            return (v17 + 1);
          }
          else {
            return v20;
          }
        }
      }
    }
  }

  else
  {
    LODWORD(v10) = 0;
    uint64_t v11 = 0LL;
    while (1)
    {
      if (v11)
      {
        v23[0] = 32;
        uint64_t v12 = 1LL;
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      unint64_t v13 = a3[v11];
      CFIndex v14 = &v23[v12];
      *CFIndex v14 = a0123456789abcd[v13 >> 4];
      int v15 = v12 | 2;
      v14[1] = a0123456789abcd[v13 & 0xF];
      uint64_t v9 = (*a1)(v23, v12 | 2, a1);
      if ((v9 & 0x80000000) != 0) {
        break;
      }
      uint64_t v10 = (v10 + v15);
      if (a4 == ++v11)
      {
        uint64_t v9 = (*a1)(" |", 2LL, a1);
        if ((v9 & 0x80000000) == 0)
        {
          int v8 = v10 + 2;
          goto LABEL_14;
        }

        return v9;
      }
    }
  }

  return v9;
}

uint64_t _PrintFObfuscateIPv4(unsigned __int8 *a1, _BYTE *a2)
{
  if (gObfuscateOnce != -1) {
    dispatch_once_f(&gObfuscateOnce, 0LL, (dispatch_function_t)_PrintFObfuscateInit);
  }
  uint64_t result = SipHash(gObfuscateKey, a1, 4LL);
  *a2 = -69;
  a2[1] = BYTE2(result);
  a2[2] = BYTE1(result);
  a2[3] = result;
  return result;
}

void _PrintFObfuscateHardwareAddress(unsigned __int8 *a1, unint64_t a2, _WORD *a3)
{
  if (gObfuscateOnce != -1) {
    dispatch_once_f(&gObfuscateOnce, 0LL, (dispatch_function_t)_PrintFObfuscateInit);
  }
  unint64_t v6 = SipHash(gObfuscateKey, a1, a2);
  *a3 = 187;
  int v7 = a3 + 1;
  uint64_t v8 = 8LL;
  if (a2 < 8) {
    uint64_t v8 = a2;
  }
  uint64_t v9 = v8 - 2;
  do
  {
    *v7++ = v6;
    v6 >>= 8;
    --v9;
  }

  while (v9);
  if (a2 >= 9) {
    bzero((char *)a3 + v8, a2 - v8);
  }
}

uint64_t _PrintFObfuscateIPv6(unsigned __int8 *a1, uint64_t a2)
{
  if (gObfuscateOnce != -1) {
    dispatch_once_f(&gObfuscateOnce, 0LL, (dispatch_function_t)_PrintFObfuscateInit);
  }
  uint64_t result = SipHash(gObfuscateKey, a1, 16LL);
  *(_BYTE *)a2 = -69;
  *(void *)(a2 + 1) = 0LL;
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = 0;
  *(_DWORD *)(a2 + 12) = bswap32(result);
  return result;
}

uint64_t _PrintFObfuscateInit()
{
  return RandomBytes(&gObfuscateKey, 0x10uLL);
}

uint64_t PrintFWriteTimeDuration(unint64_t a1, int a2, char *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  unint64_t v3 = a1 / 0x1E13380;
  unsigned int v4 = a1 % 0x1E13380;
  unsigned int v5 = v4 / 0x15180;
  unsigned int v6 = v4 % 0x15180;
  unsigned int v7 = v4 % 0x15180 / 0xE10;
  unsigned int v8 = v4 % 0x15180 % 0xE10;
  unsigned int v9 = (unsigned __int16)v8 / 0x3Cu;
  uint64_t v10 = a3;
  if ((a1 / 0x1E13380))
  {
    uint64_t v11 = v31;
    do
    {
      *v11++ = (v3 % 0xA) | 0x30;
      BOOL v12 = v3 > 9;
      LODWORD(v3) = v3 / 0xA;
    }

    while (v12);
    unint64_t v13 = a3;
    if (v11 > v31)
    {
      unint64_t v13 = a3;
      do
      {
        char v14 = *--v11;
        *v13++ = v14;
      }

      while (v11 > v31);
    }

    char *v13 = 121;
    uint64_t v10 = v13 + 1;
  }

  if (v4 >= 0x15180)
  {
    int v15 = a3;
    if (v10 != a3)
    {
      *uint64_t v10 = 32;
      int v15 = v10 + 1;
    }

    uint64_t v16 = v31;
    do
    {
      *v16++ = (v5 % 0xA) | 0x30;
      BOOL v12 = v5 > 9;
      v5 /= 0xAu;
    }

    while (v12);
    while (v16 > v31)
    {
      char v17 = *--v16;
      *v15++ = v17;
    }

    char *v15 = 100;
    uint64_t v10 = v15 + 1;
  }

  unsigned int v18 = (unsigned __int16)v8 % 0x3Cu;
  if (v6 >= 0xE10)
  {
    int v19 = a3;
    if (v10 != a3)
    {
      *uint64_t v10 = 32;
      int v19 = v10 + 1;
    }

    if (a2 && v6 >> 5 <= 0x464) {
      *v19++ = 48;
    }
    int v20 = v31;
    do
    {
      *v20++ = (v7 % 0xA) | 0x30;
      BOOL v12 = v7 > 9;
      v7 /= 0xAu;
    }

    while (v12);
    while (v20 > v31)
    {
      char v21 = *--v20;
      *v19++ = v21;
    }

    if (a2) {
      char v22 = 58;
    }
    else {
      char v22 = 104;
    }
    *int v19 = v22;
    uint64_t v10 = v19 + 1;
  }

  if (a2 || v8 >= 0x3C)
  {
    if (a2 || v10 == a3)
    {
      if (v6 < 0xE10 || !a2 || v8 > 0x257) {
        goto LABEL_40;
      }
      char v23 = 48;
    }

    else
    {
      char v23 = 32;
    }

    *v10++ = v23;
LABEL_40:
    unint64_t v24 = v31;
    do
    {
      *v24++ = (v9 % 0xA) | 0x30;
      BOOL v12 = v9 > 9;
      v9 /= 0xAu;
    }

    while (v12);
    while (v24 > v31)
    {
      char v25 = *--v24;
      *v10++ = v25;
    }

    if (a2) {
      char v26 = 58;
    }
    else {
      char v26 = 109;
    }
    *v10++ = v26;
  }

  if (!a2 && v10 != a3)
  {
    char v27 = 32;
LABEL_57:
    *v10++ = v27;
    goto LABEL_58;
  }

  if (a2 && v18 <= 9)
  {
    char v27 = 48;
    goto LABEL_57;
  }

uint64_t PrintFWriteErrorObject(uint64_t a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    unsigned int v4 = 0LL;
    unsigned int v5 = 0LL;
    int v6 = 0;
    LODWORD(v7) = 0;
    char v26 = 0;
    uint64_t v8 = *MEMORY[0x189607798];
    while (1)
    {
      if (v6)
      {
        uint64_t v9 = PrintFCore(a1);
        if ((v9 & 0x80000000) != 0)
        {
          uint64_t v7 = v9;
          uint64_t v10 = v5;
          goto LABEL_32;
        }

        LODWORD(v7) = v9 + v7;
      }

      [v3 userInfo];
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();

      uint64_t v11 = [v10 objectForKeyedSubscript:@"cuErrorDesc"];

      if (v11)
      {
        char v23 = (void *)v11;
        uint64_t v12 = PrintFCore(a1);
        if ((v12 & 0x80000000) != 0)
        {
          uint64_t v7 = v12;
          unsigned int v4 = (void *)v11;
          goto LABEL_32;
        }

        uint64_t v7 = (v12 + v7);
        unsigned int v4 = (void *)v11;
      }

      else
      {
        unint64_t v13 = CUErrorCFErrorToString((__CFError *)v3);
        if (v13)
        {
          unint64_t v24 = (char *)v13;
          uint64_t v14 = PrintFCore(a1);
          if ((v14 & 0x80000000) != 0) {
            goto LABEL_35;
          }
        }

        else
        {
          v27[0] = 0;
          int v15 = NSErrorToOSStatusEx(v3, &v26);
          if (v26) {
            DebugGetErrorStringEx(0LL, v15, v27, 128LL);
          }
          if (v27[0])
          {
            unint64_t v24 = v27;
            uint64_t v14 = PrintFCore(a1);
            if ((v14 & 0x80000000) != 0) {
              goto LABEL_35;
            }
          }

          else
          {
            [v3 domain];
            unint64_t v24 = (char *)objc_claimAutoreleasedReturnValue();
            uint64_t v25 = [v3 code];
            uint64_t v14 = PrintFCore(a1);

            if ((v14 & 0x80000000) != 0)
            {
LABEL_35:
              unsigned int v4 = 0LL;
              uint64_t v7 = v14;
              goto LABEL_32;
            }
          }
        }

        uint64_t v7 = (v14 + v7);
        CFTypeID TypeID = CFStringGetTypeID();
        CFDictionaryGetTypedValue((const __CFDictionary *)v10, @"cuErrorMsg", TypeID, 0LL);
        unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue();
        if (objc_msgSend(v4, "length", v24))
        {
          char v23 = v4;
          int v17 = PrintFCore(a1);
          uint64_t v7 = (v7 & ~(v17 >> 31)) + v17;
          if (v17 < 0) {
            goto LABEL_32;
          }
        }
      }

      uint64_t v18 = objc_msgSend(v10, "objectForKeyedSubscript:", v8, v23, v25);

      if (!v18)
      {
        id v3 = 0LL;
        goto LABEL_32;
      }

      id v3 = (id)v18;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        break;
      }
      ++v6;
      unsigned int v5 = v10;
      if (v6 == 4) {
        goto LABEL_32;
      }
    }

    int v21 = PrintFCore(a1);
    if (v21 >= 0) {
      int v22 = v7;
    }
    else {
      int v22 = 0;
    }
    uint64_t v7 = (v22 + v21);
LABEL_32:

    return v7;
  }

  else if (v3)
  {
    uint64_t v19 = PrintFCore(a1);

    return v19;
  }

  else
  {
    return PrintFCore(a1);
  }

uint64_t PrintFWriteFlags(uint64_t a1, char a2, const char *a3, uint64_t a4)
{
  if (a2)
  {
    uint64_t v7 = PrintFCore(a1);
    if ((v7 & 0x80000000) != 0) {
      return v7;
    }
  }

  else
  {
    LODWORD(v7) = 0;
  }

  uint64_t v8 = PrintFCore(a1);
  if ((v8 & 0x80000000) != 0) {
    return v8;
  }
  int v9 = v8 + v7;
  if (a4)
  {
    unint64_t v10 = 0LL;
    do
    {
      if ((a4 & (1LL << v10)) != 0)
      {
        a4 &= ~(1LL << v10);
        for (uint64_t i = a3; ; i += v12 + 2)
        {
          size_t v12 = strlen(i + 1);
          if (!v12) {
            break;
          }
          if (v10 == *(unsigned __int8 *)i)
          {
            uint64_t v13 = PrintFCore(a1);
            uint64_t v7 = v13;
            if ((v13 & 0x80000000) != 0) {
              return v7;
            }
            v9 += v13;
            break;
          }
        }
      }

      if (v10 > 0x3E) {
        break;
      }
      ++v10;
    }

    while (a4);
  }

  int v14 = PrintFCore(a1);
  if (v14 >= 0) {
    int v15 = v9;
  }
  else {
    int v15 = 0;
  }
  return (v15 + v14);
}

uint64_t PrintFWriteMaskObject( uint64_t (**a1)(unsigned __int8 *, uint64_t, void), const __CFURL *cf)
{
  uint64_t v2 = cf;
  int v41 = 0LL;
  CFTypeID TypeID = CFGetTypeID(cf);
  if (TypeID == CFURLGetTypeID())
  {
    uint64_t v2 = (const __CFURL *)CFURLGetString(v2);
    CFTypeID TypeID = CFStringGetTypeID();
  }

  if (TypeID == CFStringGetTypeID())
  {
    uint64_t v5 = CFStringGetOrCopyCStringUTF8((const __CFString *)v2, (const char **)&v40, (UInt8 **)&v41, &v39);
    if (!(_DWORD)v5)
    {
      size_t v10 = v39;
      int v9 = (unsigned __int8 *)v40;
      if (v39 < 0x24 || StringToUUIDEx(v40, v39, 1, 0LL, 0LL, v6, v7, v8))
      {
        if (stricmp_prefix(v9, "http://"))
        {
          if (stricmp_prefix(v9, "mailto:"))
          {
            if (stricmp_prefix(v9, "file:///"))
            {
              if (stricmp_prefix(v9, "tel:"))
              {
                unsigned int v11 = *v9;
                uint64_t v12 = 1LL;
                if ((v11 > 0x2F || ((1LL << v11) & 0x881000000000LL) == 0) && v11 != 126)
                {
                  uint64_t v13 = 0LL;
                  int v14 = (char *)v9;
                  goto LABEL_27;
                }
              }

              else
              {
                uint64_t v12 = 4LL;
              }

LABEL_97:
              uint64_t v34 = -v31;
              goto LABEL_98;
            }

        unint64_t v24 = v6 + 2;
        uint64_t v16 = v47 + 1;
      }

      uint64_t v6 = v22;
    }
  }

  else
  {
    unint64_t v24 = 0LL;
    int v25 = 0LL;
    char v26 = 0LL;
    char v27 = 0LL;
    uint64_t v16 = 0LL;
    uint64_t v22 = 0LL;
  }

  if (v6 >= a2)
  {
    uint64_t v31 = 0;
    if (v16)
    {
      int v32 = 0LL;
      int v33 = 0LL;
      uint64_t v34 = 0LL;
      uint64_t v35 = 0LL;
      int v36 = 0LL;
      int v37 = 0LL;
      int v38 = 0LL;
      size_t v39 = v6;
      size_t v30 = v6;
      goto LABEL_81;
    }

    uint64_t v34 = 0LL;
    int v33 = 0LL;
    int v32 = 0LL;
    uint64_t v42 = 0LL;
    size_t v30 = v6;
    size_t v39 = v6;
  }

  else
  {
    int v28 = 0LL;
    while (1)
    {
      unint64_t v29 = v6[v28];
      if (v29 == 35 || v29 == 63) {
        break;
      }
      if (a2 - v6 == ++v28)
      {
        size_t v30 = a2;
        goto LABEL_52;
      }
    }

    size_t v30 = &v6[v28];
LABEL_52:
    if (v29 == 63)
    {
      uint64_t v34 = v30 + 1;
      if (v30 + 1 >= a2)
      {
        unint64_t v29 = 63;
        int v33 = v30 + 1;
        int v41 = v30 + 1;
      }

      else
      {
        uint64_t v40 = &a2[~(unint64_t)v30];
        int v33 = v30 + 1;
        while (1)
        {
          unint64_t v29 = *v33;
          if (v29 == 35) {
            break;
          }
          ++v33;
          if (!--v40)
          {
            int v33 = a2;
            int v41 = a2;
            goto LABEL_62;
          }
        }

        int v41 = v33;
      }
    }

    else
    {
      uint64_t v34 = 0LL;
      int v33 = 0LL;
      int v41 = v30;
    }

uint64_t PrintFWriteObfuscatedPtr(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a2;
  if (gObfuscateOnce != -1)
  {
    dispatch_once_f(&gObfuscateOnce, 0LL, (dispatch_function_t)_PrintFObfuscateInit);
    if (!a2) {
      goto LABEL_5;
    }
    goto LABEL_3;
  }

  if (a2) {
LABEL_3:
  }
    SipHash(gObfuscateKey, (unsigned __int8 *)&v6, 8LL);
LABEL_5:
  int v4 = PrintFCore(a1);
  return v4 & ~(v4 >> 31);
}

uint64_t PrintFWriteSingleLineText( uint64_t (**a1)(unsigned __int8 *, int64_t, void), unsigned __int8 *a2, uint64_t a3, int a4)
{
  if (a3 >= 1)
  {
    uint64_t v5 = a2;
    uint64_t v7 = 0LL;
    uint64_t v8 = &a2[a3];
    while (1)
    {
      int v9 = v5;
      do
      {
        int v10 = *v9;
        if (v10 == 10 || v10 == 13) {
          break;
        }
        ++v9;
      }

      while (v9 < v8);
      if (v5 < v9)
      {
        uint64_t v12 = (*a1)(v5, v9 - v5, a1);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
        uint64_t v7 = (v12 + v7);
      }

      if (v9 >= v8)
      {
        uint64_t v5 = v9;
      }

      else
      {
        uint64_t v13 = v8 - v9;
        uint64_t v5 = v9;
        while (1)
        {
          int v14 = *v5;
          if (v14 != 13 && v14 != 10) {
            break;
          }
          ++v5;
          if (!--v13)
          {
            uint64_t v5 = v8;
            goto LABEL_22;
          }
        }

        if (v9 < v5)
        {
          if (a4)
          {
            uint64_t v16 = " ";
            uint64_t v17 = 1LL;
          }

          else
          {
            uint64_t v16 = " ⏎ ";
            uint64_t v17 = 5LL;
          }

          uint64_t v12 = (*a1)((unsigned __int8 *)v16, v17, a1);
          if ((v12 & 0x80000000) != 0) {
            return v12;
          }
          uint64_t v7 = (v12 + v7);
        }
      }

uint64_t PrintFWriteTLV8(uint64_t a1, uint64_t a2, const char *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  if (a5 >= 2)
  {
    uint64_t v34 = a5;
    unsigned int v7 = 0;
    unsigned int v8 = 0;
    int v9 = a4;
    do
    {
      uint64_t v10 = v9[1];
      unint64_t v11 = (unint64_t)&v9[v10 + 2];
      if (v11 > v6) {
        break;
      }
      int v12 = *v9;
      v9 += v10 + 2;
      for (uint64_t i = a3; ; i += v14 + 2)
      {
        unsigned int v14 = strlen(i + 1);
        if (!v14) {
          break;
        }
      }
    }

    while ((uint64_t)(v6 - v11) >= 2);
    a5 = v34;
  }

  if (a5 >= 2)
  {
    uint64_t v16 = 0LL;
    while (1)
    {
      uint64_t v17 = v5[1];
      uint64_t v18 = v5 + 2;
      uint64_t v19 = &v5[v17 + 2];
      int v20 = *v5;
      v5 += v17 + 2;
      for (size_t j = a3; ; size_t j = &v22[v23 + 1])
      {
        uint64_t v22 = j + 1;
        int v23 = strlen(j + 1);
        if (!v23) {
          break;
        }
      }

      uint64_t v22 = 0LL;
LABEL_24:
      if ((_DWORD)v17)
      {
        uint64_t v24 = v17 - 1;
        int v25 = v18;
        do
          int v26 = *v25++;
        while ((v26 - 32) <= 0x5E && v24-- != 0);
      }

      uint64_t v28 = PrintFCore(a1);
      if ((v28 & 0x80000000) != 0) {
        return v28;
      }
      int v29 = v28 + v16;
      if (v22)
      {
        uint64_t v30 = PrintFCore(a1);
        uint64_t v16 = v30;
        if ((v30 & 0x80000000) != 0) {
          return v16;
        }
        v29 += v30;
        strlen(v22);
        if ((_DWORD)v17)
        {
LABEL_35:
          uint64_t v31 = a1;
          goto LABEL_38;
        }
      }

      else if ((_DWORD)v17)
      {
        goto LABEL_35;
      }

      uint64_t v31 = a1;
LABEL_38:
      uint64_t v32 = PrintFCore(v31);
      uint64_t v16 = v32;
      if ((v32 & 0x80000000) == 0)
      {
        uint64_t v16 = (v32 + v29);
      }

      return v16;
    }
  }

  return 0LL;
}

uint64_t PrintFWriteTXTRecord(uint64_t a1, char a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  unint64_t v6 = a4;
  uint64_t v26 = *MEMORY[0x1895F89C0];
  unsigned int v8 = &a4[a5];
  if (a2)
  {
    if (a5 < 1) {
      return 0LL;
    }
    uint64_t v9 = 0LL;
    do
    {
      unsigned int v12 = *v6;
      uint64_t v10 = v6 + 1;
      uint64_t v11 = v12;
      uint64_t v13 = PrintFCore(a1);
      if ((v13 & 0x80000000) != 0) {
        return v13;
      }
      uint64_t v9 = (v13 + v9);
      unint64_t v6 = &v10[v11];
    }

    while (v6 < v8);
    return v9;
  }

  if ((unint64_t)a5 >= 6 && *(_DWORD *)(a4 + 1) == 1095590263 && a4[5] == 61)
  {
    if (&a4[*a4 + 1] != v8) {
      return PrintFCore(a1);
    }
    if (a5 < 2) {
      goto LABEL_36;
    }
    LODWORD(v9) = 0;
    uint64_t v17 = a4 + 1;
    while (1)
    {
      uint64_t v18 = &v25;
      uint64_t v19 = v17;
      do
      {
        int v21 = *v17++;
        int v20 = v21;
        if (v21 == 92)
        {
          if (v17 >= v8) {
            goto LABEL_39;
          }
          uint64_t v17 = v19 + 2;
          LOBYTE(v20) = v19[1];
        }

        else if (v20 == 44)
        {
          break;
        }

        *v18++ = v20;
        uint64_t v19 = v17;
      }

      while (v17 < v8);
      uint64_t v13 = PrintFCore(a1);
      if ((v13 & 0x80000000) != 0) {
        return v13;
      }
      uint64_t v9 = (v13 + v9);
      if (v17 >= v8) {
        goto LABEL_37;
      }
    }
  }

  if (a5 >= 1)
  {
    LODWORD(v9) = 0;
    int v15 = a4;
    while (1)
    {
      unint64_t v16 = (unint64_t)&v15[*v15 + 1];
      uint64_t v13 = PrintFCore(a1);
      if ((v13 & 0x80000000) != 0) {
        return v13;
      }
      uint64_t v9 = (v13 + v9);
      int v15 = (unsigned __int8 *)v16;
    }

uint64_t PrintFWriteXMLEscaped( uint64_t (**a1)(char *, int64_t, void), char *__s, int64_t a3)
{
  id v3 = __s;
  if (a3 == -1) {
    a3 = strlen(__s);
  }
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  unint64_t v6 = &v3[a3];
  unsigned int v7 = v3;
  do
  {
    int v8 = *v7;
    if (v8 <= 38)
    {
      if (v8 != 34 && v8 != 38)
      {
LABEL_12:
        ++v7;
        continue;
      }
    }

    else if (v8 != 39 && v8 != 60 && v8 != 62)
    {
      goto LABEL_12;
    }

    if (v7 != v3)
    {
      uint64_t v9 = (*a1)(v3, v7 - v3, a1);
      if ((v9 & 0x80000000) != 0) {
        return v9;
      }
      LODWORD(v5) = v9 + v5;
    }

    uint64_t v9 = PrintFCore((uint64_t)a1);
    if ((v9 & 0x80000000) != 0) {
      return v9;
    }
    ++v7;
    uint64_t v5 = (v9 + v5);
    id v3 = v7;
  }

  while (v7 < v6);
  if (v7 != v3)
  {
    int v10 = (*a1)(v3, v7 - v3, a1);
    if (v10 >= 0) {
      int v11 = v5;
    }
    else {
      int v11 = 0;
    }
    return (v11 + v10);
  }

  return v5;
}

void PrintFWriteCFObjectApplier(uint64_t a1, void *a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 24))
  {
    id v3 = 0LL;
    goto LABEL_47;
  }

  int v6 = *(unsigned __int8 *)(*(void *)(a3 + 8) + 3LL);
  int v7 = PrintFWriteCFObjectLevel(a3, a1, 0LL);
  if (v7 < 0)
  {
    id v3 = 0LL;
LABEL_46:
    *(_DWORD *)(a3 + 24) = v7;
    goto LABEL_47;
  }

  int v8 = (**(uint64_t (***)(const char *, uint64_t))a3)(" : ", 3LL);
  if (v8 < 0)
  {
    id v3 = 0LL;
    int v7 = v8;
    goto LABEL_46;
  }

  CFTypeID v9 = CFGetTypeID(a2);
  if (v9 == CFSetGetTypeID())
  {
    [a2 allObjects];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v3) {
      goto LABEL_47;
    }
    id v30 = v3;
    CFTypeID v9 = CFGetTypeID(v3);
    a2 = v30;
  }

  else
  {
    id v30 = 0LL;
  }

  int v10 = v8 + v7;
  if (v9 == CFArrayGetTypeID())
  {
    if (CFArrayGetCount((CFArrayRef)a2) >= 1)
    {
      if (v6 == 2)
      {
        uint64_t v11 = a3;
        unsigned int v12 = a2;
        uint64_t v13 = 1LL;
        goto LABEL_17;
      }

      int v7 = (**(uint64_t (***)(const char *, uint64_t))a3)("\n", 1LL);
      if ((v7 & 0x80000000) == 0)
      {
        uint64_t v20 = a3;
        int v21 = a2;
        uint64_t v22 = 1LL;
LABEL_37:
        int v26 = PrintFWriteCFObjectLevel(v20, v21, v22);
        if ((v26 & 0x80000000) == 0)
        {
          v10 += v7 + v26;
          int v15 = **(uint64_t (***)(const char *, uint64_t))a3;
          unint64_t v16 = ",\n";
          goto LABEL_39;
        }

        int v7 = v26;
        goto LABEL_51;
      }

      goto LABEL_51;
    }

    int v15 = **(uint64_t (***)(const char *, uint64_t))a3;
    uint64_t v18 = "[],\n";
    uint64_t v19 = "[], ";
  }

  else
  {
    if (v9 != CFDictionaryGetTypeID())
    {
      if (v9 == CFDataGetTypeID())
      {
        int v17 = PrintFWriteCFObjectLevel(a3, a2, 0LL);
        int v7 = v17;
        if (v17 < 0) {
          goto LABEL_51;
        }
        v10 += v17;
      }

      else
      {
        int v23 = *(_DWORD *)(a3 + 16);
        *(_DWORD *)(a3 + 16) = 0;
        int v24 = PrintFWriteCFObjectLevel(a3, a2, 0LL);
        int v7 = v24;
        if (v24 < 0) {
          goto LABEL_51;
        }
        v10 += v24;
        *(_DWORD *)(a3 + 16) = v23;
      }

      int v15 = **(uint64_t (***)(const char *, uint64_t))a3;
      if (v6 == 2) {
        unint64_t v16 = ", ";
      }
      else {
        unint64_t v16 = ",\n";
      }
      goto LABEL_39;
    }

    if (CFDictionaryGetCount((CFDictionaryRef)a2) >= 1)
    {
      if (v6 == 2)
      {
        uint64_t v11 = a3;
        unsigned int v12 = a2;
        uint64_t v13 = 0LL;
LABEL_17:
        int v14 = PrintFWriteCFObjectLevel(v11, v12, v13);
        int v7 = v14;
        if ((v14 & 0x80000000) == 0)
        {
          v10 += v14;
          int v15 = **(uint64_t (***)(const char *, uint64_t))a3;
          unint64_t v16 = ", ";
LABEL_39:
          uint64_t v25 = 2LL;
          goto LABEL_40;
        }

        goto LABEL_51;
      }

      int v7 = (**(uint64_t (***)(const char *, uint64_t))a3)("\n", 1LL);
      if ((v7 & 0x80000000) == 0)
      {
        uint64_t v20 = a3;
        int v21 = a2;
        uint64_t v22 = 0LL;
        goto LABEL_37;
      }

uint64_t VSNPrintF( uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (uint64_t (*)(unsigned __int8 *, int64_t, void))PrintFCallBackFixedString;
  uint64_t v12 = a1;
  uint64_t v9 = a2 - 1;
  if (!a2) {
    uint64_t v9 = 0LL;
  }
  uint64_t v13 = 0LL;
  uint64_t v14 = v9;
  uint64_t result = PrintFCoreVAList(&v11, a3, a4, a4, a5, a6, a7, a8);
  if (a2) {
    *(_BYTE *)(v12 + v13) = 0;
  }
  return result;
}

size_t PrintFCallBackFixedString(_BYTE *__src, size_t __n, void *a3)
{
  size_t v4 = __n;
  uint64_t v5 = a3[2];
  size_t v6 = a3[3] - v5;
  if (v6 >= __n)
  {
    if (!__n) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  if (v6)
  {
    while ((__src[v6] & 0xC0) == 0x80)
    {
      if (!--v6) {
        goto LABEL_5;
      }
    }

    size_t v4 = v6;
LABEL_9:
    memcpy((void *)(a3[1] + v5), __src, v4);
    uint64_t v5 = a3[2];
    goto LABEL_10;
  }

void CUAppendF(id *a1, int *a2)
{
}

void CUAppendV(id *a1, int *a2)
{
  uint64_t v9 = 0LL;
  VASPrintF(&v9);
  size_t v4 = (char *)v9;
  if (v9)
  {
    if (!*(_BYTE *)v9)
    {
      free(v9);
      return;
    }

    id v5 = *a1;
    if (!v5)
    {
      id v5 = objc_alloc_init(MEMORY[0x189607940]);
      *a1 = v5;
    }

    int v6 = *a2;
    id v8 = v5;
    if ((*a2 & 1) == 0)
    {
      v6 |= 1u;
LABEL_18:
      CFStringAppendCString((CFMutableStringRef)*a1, v4, 0x8000100u);
      free(v4);
      *a2 = v6;

      return;
    }

    if ((v6 & 2) != 0)
    {
      if ((v6 & 8) != 0) {
        objc_msgSend(v5, "appendString:", @", ");
      }
      goto LABEL_18;
    }

    if ((v6 & 4) != 0)
    {
      int v7 = @": ";
    }

    else
    {
      if ((v6 & 8) == 0)
      {
LABEL_17:
        v6 |= 2u;
        goto LABEL_18;
      }

      int v7 = @", ";
    }

    objc_msgSend(v5, "appendString:", v7, v5);
    goto LABEL_17;
  }

id NSPrintF()
{
  return (id)objc_claimAutoreleasedReturnValue();
}

__CFString *NSPrintV()
{
  id v3 = 0LL;
  VASPrintF(&v3);
  uint64_t v0 = v3;
  if (!v3) {
    return &stru_189F34A78;
  }
  [NSString stringWithUTF8String:v3];
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue();
  free(v0);
  return (__CFString *)v1;
}

id NSPrintF_safe()
{
  return (id)objc_claimAutoreleasedReturnValue();
}

void NSAppendPrintF(CFMutableStringRef *a1)
{
}

void NSAppendPrintV(CFMutableStringRef *a1)
{
  if (!*a1)
  {
    [MEMORY[0x189607940] string];
    *a1 = (CFMutableStringRef)(id)objc_claimAutoreleasedReturnValue();
  }

  cStr = 0LL;
  VASPrintF((void **)&cStr);
  uint64_t v2 = cStr;
  if (cStr)
  {
    CFStringAppendCString(*a1, cStr, 0x8000100u);
    free(v2);
  }

void NSAppendPrintF_safe(CFMutableStringRef *a1)
{
}

id NSPrintTypedObject(const char *a1, void *a2, int *a3)
{
  id v5 = a2;
  int v6 = 0LL;
  int v7 = -6735;
  id v8 = 0LL;
  id v9 = 0LL;
  switch(*a1)
  {
    case 'a':
      if (!strcasecmp(a1, "addr"))
      {
        id v8 = v5;
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          goto LABEL_81;
        }
        id v8 = v8;
        -[__CFString bytes](v8, "bytes");
        uint64_t v13 = -[__CFString length](v8, "length");
        *((void *)&v15 + 1) = v13;
        *(void *)&__int128 v15 = v13 - 2;
        unint64_t v14 = v15 >> 1;
        if (v14 < 4 || v14 == 7)
        {
          uint64_t v20 = v13;
          goto LABEL_54;
        }

        goto LABEL_78;
      }

      if (strcasecmp(a1, "asbd")) {
        goto LABEL_48;
      }
      id v8 = v5;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_81;
      }
      if (-[__CFString length](v8, "length") != 40) {
        goto LABEL_78;
      }
      goto LABEL_44;
    case 'b':
      if (strcasecmp(a1, "base2")) {
        goto LABEL_48;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0) {
        goto LABEL_58;
      }
      goto LABEL_79;
    case 'c':
      if (strcasecmp(a1, "cec")) {
        goto LABEL_48;
      }
      id v8 = v5;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_81;
      }
      id v8 = v8;
      uint64_t v20 = -[__CFString bytes](v8, "bytes");
      -[__CFString length](v8, "length");
      goto LABEL_54;
    case 'd':
      if (strcasecmp(a1, "dur")) {
        goto LABEL_48;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0) {
        goto LABEL_58;
      }
      goto LABEL_79;
    case 'e':
      if (!strcasecmp(a1, "err"))
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          goto LABEL_79;
        }
        uint64_t v20 = -[__CFString longValue](v5, "longValue");
      }

      else
      {
        if (strcasecmp(a1, "error")) {
          goto LABEL_48;
        }
        uint64_t v20 = (uint64_t)v5;
      }

      goto LABEL_68;
    case 'f':
    case 'g':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'n':
    case 'q':
    case 'r':
    case 'v':
    case 'w':
      goto LABEL_74;
    case 'h':
      if (strcasecmp(a1, "hex")) {
        goto LABEL_48;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_79;
      }
LABEL_50:
      uint64_t v20 = (uint64_t)v5;
      goto LABEL_68;
    case 'o':
      if (!strcasecmp(a1, "obj")) {
        goto LABEL_50;
      }
      if (!strcasecmp(a1, "obj1"))
      {
        uint64_t v20 = (uint64_t)v5;
        goto LABEL_68;
      }

      if (strcasecmp(a1, "oneline"))
      {
        if (strcasecmp(a1, "onoff")) {
          goto LABEL_48;
        }
        unint64_t v10 = CFGetInt64(v5, 0LL);
        uint64_t v11 = "on";
        uint64_t v12 = "off";
LABEL_60:
        if (!v10) {
          uint64_t v11 = v12;
        }
        uint64_t v20 = (uint64_t)v11;
        goto LABEL_68;
      }

      NSPrintF();
      unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
      if (v16)
      {
        id v17 = v16;
        uint64_t v20 = objc_msgSend(v17, "UTF8String", v5);
        NSPrintF();
        int v6 = (void *)objc_claimAutoreleasedReturnValue();

        goto LABEL_69;
      }

      int v6 = 0LL;
      id v8 = 0LL;
      id v9 = 0LL;
      int v7 = -6700;
      goto LABEL_74;
    case 'p':
      if (!strcasecmp(a1, "pid"))
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          goto LABEL_79;
        }
      }

      else
      {
        if (strcasecmp(a1, "ptr"))
        {
LABEL_48:
          int v6 = 0LL;
          id v8 = 0LL;
          goto LABEL_49;
        }

        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          goto LABEL_79;
        }
      }

uint64_t AppendPrintF( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v12[1] = &a9;
  uint64_t v10 = ASPrintF(v12);
  if ((v10 & 0x80000000) == 0)
  {
    if (*a1) {
      free(*a1);
    }
    *a1 = v12[0];
  }

  return v10;
}

uint64_t ASPrintF(void **a1)
{
  return VASPrintF(a1);
}

uint64_t CPrintF(uint64_t a1, uint64_t a2)
{
  return VCPrintF(a1, a2);
}

uint64_t VCPrintF(uint64_t a1, uint64_t a2)
{
  v5[0] = PrintFCallBackUserCallBack;
  memset(&v5[1], 0, 24);
  v5[4] = a1;
  v5[5] = a2;
  uint64_t v2 = PrintFCoreVAList(v5);
  if ((v2 & 0x80000000) == 0)
  {
    int v3 = ((uint64_t (*)(const char *, void, void *))v5[0])("", 0LL, v5);
    if (v3 >= 0) {
      return v2;
    }
    else {
      return v3;
    }
  }

  return v2;
}

uint64_t PrintFCallBackUserCallBack(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a3 + 32))(a1, a2, *(void *)(a3 + 40));
}

uint64_t FPrintF(uint64_t a1)
{
  return VCPrintF((uint64_t)FPrintFCallBack, a1);
}

size_t FPrintFCallBack(const void *a1, size_t __nitems, FILE *__stream)
{
  if (__stream) {
    fwrite(a1, 1uLL, __nitems, __stream);
  }
  return __nitems;
}

uint64_t VFPrintF(uint64_t a1)
{
  return VCPrintF((uint64_t)FPrintFCallBack, a1);
}

uint64_t FPrintF_safe(uint64_t a1)
{
  return VCPrintF((uint64_t)FPrintFCallBack, a1);
}

uint64_t VFPrintF_safe(uint64_t a1)
{
  return VCPrintF((uint64_t)FPrintFCallBack, a1);
}

uint64_t MemPrintF( uint64_t (*a1)(unsigned __int8 *, int64_t, void), uint64_t (*a2)(unsigned __int8 *, int64_t, void), unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v10[0] = (uint64_t (*)(unsigned __int8 *, int64_t, void))PrintFCallBackFixedString;
  v10[1] = a1;
  void v10[2] = 0LL;
  v10[3] = a2;
  return PrintFCoreVAList(v10, a3, (uint64_t)&a9, a4, a5, a6, a7, a8);
}

uint64_t CUObfuscatedPtr(uint64_t a1)
{
  uint64_t v3 = a1;
  if (gObfuscateOnce != -1)
  {
    dispatch_once_f(&gObfuscateOnce, 0LL, (dispatch_function_t)_PrintFObfuscateInit);
    if (a1) {
      goto LABEL_3;
    }
LABEL_5:
    LOWORD(result) = 0;
    return (unsigned __int16)result;
  }

  if (!a1) {
    goto LABEL_5;
  }
LABEL_3:
  LOWORD(result) = SipHash(gObfuscateKey, (unsigned __int8 *)&v3, 8LL);
  return (unsigned __int16)result;
}

__CFString *CUPrintAddress(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = @"NULL";
  switch(__ROR8__(a2, 1))
  {
    case 0LL:
      return v3;
    case 1LL:
    case 2LL:
    case 3LL:
    case 4LL:
    case 8LL:
      goto LABEL_3;
    default:
      if (!a1) {
        return @"NULL";
      }
LABEL_3:
      NSPrintF();
      uint64_t v3 = (__CFString *)objc_claimAutoreleasedReturnValue();
      return v3;
  }

id CUPrintASBD()
{
  return NSPrintF();
}

id CUPrintDateCF()
{
  return NSPrintF();
}

id CUPrintDuration32()
{
  return NSPrintF();
}

id CUPrintDuration64()
{
  return NSPrintF();
}

id CUPrintDurationDouble()
{
  return NSPrintF();
}

id CUPrintErrorCode()
{
  return NSPrintF();
}

id CUPrintFlags32()
{
  return NSPrintF();
}

__CFString *CUPrintFlags(unint64_t a1, _BYTE *a2, char a3)
{
  int v6 = (__CFString *)objc_alloc_init(MEMORY[0x189607940]);
  int v7 = v6;
  if ((a3 & 1) != 0) {
    -[__CFString appendString:](v6, "appendString:", @"[");
  }
  int v8 = 0;
  char v9 = *a2;
  do
  {
    uint64_t v10 = a2 + 1;
    if (((a1 >> v9) & 1) != 0)
    {
      if (v8 <= 0) {
        uint64_t v11 = "";
      }
      else {
        uint64_t v11 = ", ";
      }
      -[__CFString appendFormat:](v7, "appendFormat:", @"%s%s", v11, v10);
      ++v8;
    }

    uint64_t v12 = &v10[strlen(v10)];
    int v13 = *((unsigned __int8 *)v12 + 1);
    a2 = v12 + 1;
    char v9 = v13;
  }

  while (v13);
  if ((a3 & 1) != 0) {
    -[__CFString appendString:](v7, "appendString:", @"]");
  }
  if (v7) {
    unint64_t v14 = v7;
  }
  else {
    unint64_t v14 = &stru_189F34A78;
  }
  __int128 v15 = v14;

  return v15;
}

id CUPrintFlags64()
{
  return NSPrintF();
}

id CUPrintHex()
{
  return (id)objc_claimAutoreleasedReturnValue();
}

__CFString *CUPrintNSDataAddress(void *a1)
{
  id v1 = a1;
  uint64_t v2 = @"NULL";
  switch(__ROR8__([v1 length], 1))
  {
    case 0LL:
      break;
    case 1LL:
    case 2LL:
    case 3LL:
    case 4LL:
    case 8LL:
      [v1 bytes];
      goto LABEL_5;
    default:
      if (v1)
      {
LABEL_5:
        NSPrintF();
        uint64_t v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
      }

      else
      {
        uint64_t v2 = @"NULL";
      }

      break;
  }

  return v2;
}

id CUPrintNSDataHex(void *a1)
{
  id v1 = a1;
  [v1 bytes];
  [v1 length];

  NSPrintF();
  return (id)objc_claimAutoreleasedReturnValue();
}

id CUPrintNSError()
{
  return NSPrintF();
}

id CUPrintNSObject()
{
  return NSPrintF();
}

id CUPrintNSObjectMasked()
{
  return NSPrintF();
}

id CUPrintNSObjectOneLine()
{
  return NSPrintF();
}

id CUPrintNSObjectOneLineEx()
{
  return NSPrintF();
}

id CUPrintPID()
{
  return NSPrintF();
}

id CUPrintSockAddr()
{
  return NSPrintF();
}

id CUPrintText()
{
  return NSPrintF();
}

id CUPrintTimeNow(void *a1)
{
  if (a1 <= 2)
  {
    NSPrintF();
    a1 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return a1;
}

id CUPrintXPC()
{
  return NSPrintF();
}

uint64_t CryptoRandomKey(void *a1, size_t a2, char *a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  return CryptoHKDF((uint64_t)_kCryptoHashDescriptor_SHA512, (uint64_t)a1, a2, a3, a4, a5, a6, a2, (uint64_t)a1);
}

uint64_t RandomBytes(void *bytes, size_t count)
{
  while (1)
  {
    uint64_t result = CCRandomGenerateBytes(bytes, count);
    if (!(_DWORD)result) {
      break;
    }
    if (gLogCategory_RandomNumberUtils <= 60)
    {
      char v9 = result;
      if (gLogCategory_RandomNumberUtils != -1
        || _LogCategory_Initialize((uint64_t)&gLogCategory_RandomNumberUtils, 0x3Cu))
      {
        LogPrintF( (uint64_t)&gLogCategory_RandomNumberUtils,  (uint64_t)"OSStatus RandomBytes(void *, size_t)",  0x3Cu,  (uint64_t)"### CCRandomGenerateBytes failed: %#m\n",  v5,  v6,  v7,  v8,  v9);
      }
    }

    sleep(1u);
  }

  return result;
}

_BYTE *RandomString(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t v10 = bytes % (unint64_t)(a4 - a3 + 1) + a3;
  uint64_t v11 = a5;
  if (v10 >= 1)
  {
    unint64_t v12 = (unint64_t)&a5[v10];
    uint64_t v11 = a5;
    do
    {
      RandomBytes(&bytes, 4uLL);
      *v11++ = *(_BYTE *)(a1 + bytes % a2);
    }

    while ((unint64_t)v11 < v12);
  }

  *uint64_t v11 = 0;
  return a5;
}

uint64_t ScreenGetTypeID()
{
  if (gScreenInitOnce != -1) {
    dispatch_once_f(&gScreenInitOnce, 0LL, (dispatch_function_t)_ScreenGetTypeID);
  }
  return gScreenTypeID;
}

uint64_t _ScreenGetTypeID()
{
  uint64_t result = _CFRuntimeRegisterClass();
  gScreenCFTypeID TypeID = result;
  return result;
}

void _ScreenFinalize(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0LL;
  }

  uint64_t v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0LL;
  }

  size_t v4 = (const void *)a1[8];
  if (v4)
  {
    CFRelease(v4);
    a1[8] = 0LL;
  }

uint64_t ScreenCreate(uint64_t *a1, const __CFDictionary *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (gScreenInitOnce != -1) {
    dispatch_once_f(&gScreenInitOnce, 0LL, (dispatch_function_t)_ScreenGetTypeID);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294960568LL;
  }
  uint64_t v5 = Instance;
  *(_OWORD *)(Instance + 16) = 0u;
  uint64_t v6 = (const __CFDictionary **)(Instance + 16);
  *(void *)(Instance + 64) = 0LL;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
  CFObjectSetPropertyInt64( (const void *)Instance,  0LL,  (uint64_t (*)(const void *, uint64_t, const void *, const void *, const void *))_ScreenSetProperty,  1LL,  @"features",  0LL,  14LL);
  CFObjectSetPropertyInt64( (const void *)v5,  0LL,  (uint64_t (*)(const void *, uint64_t, const void *, const void *, const void *))_ScreenSetProperty,  1LL,  @"maxFPS",  0LL,  60LL);
  CFObjectSetPropertyInt64( (const void *)v5,  0LL,  (uint64_t (*)(const void *, uint64_t, const void *, const void *, const void *))_ScreenSetProperty,  1LL,  @"widthPixels",  0LL,  960LL);
  CFObjectSetPropertyInt64( (const void *)v5,  0LL,  (uint64_t (*)(const void *, uint64_t, const void *, const void *, const void *))_ScreenSetProperty,  1LL,  @"heightPixels",  0LL,  540LL);
  _ScreenSetProperty(v5, v7, @"uuid", v8, @"e5f7a68d-7b0f-4305-984b-974f677a150b");
  if (!a2) {
    goto LABEL_24;
  }
  CFTypeID TypeID = CFDataGetTypeID();
  TypedValue = CFDictionaryGetTypedValue(a2, @"edid", TypeID, 0LL);
  *uint64_t v6 = TypedValue;
  if (TypedValue) {
    CFRetain(TypedValue);
  }
  int Int64 = CFDictionaryGetInt64(a2, @"features", (int *)&v21);
  if (!v21) {
    *(_DWORD *)(v5 + 24) = Int64;
  }
  int v12 = CFDictionaryGetInt64(a2, @"maxFPS", (int *)&v21);
  if (!v21) {
    *(_DWORD *)(v5 + 2_Block_object_dispose(va, 8) = v12;
  }
  int v13 = CFDictionaryGetInt64(a2, @"primaryInputDevice", (int *)&v21);
  if (!v21) {
    *(_DWORD *)(v5 + 56) = v13;
  }
  int v14 = CFDictionaryGetInt64(a2, @"widthPixels", (int *)&v21);
  if (!v21) {
    *(_DWORD *)(v5 + 40) = v14;
  }
  int v15 = CFDictionaryGetInt64(a2, @"heightPixels", (int *)&v21);
  if (!v21) {
    *(_DWORD *)(v5 + 44) = v15;
  }
  int v16 = CFDictionaryGetInt64(a2, @"widthPhysical", (int *)&v21);
  if (!v21) {
    *(_DWORD *)(v5 + 4_Block_object_dispose(va, 8) = v16;
  }
  int v17 = CFDictionaryGetInt64(a2, @"heightPhysical", (int *)&v21);
  if (!v21) {
    *(_DWORD *)(v5 + 52) = v17;
  }
  Value = (__CFString *)CFDictionaryGetValue(a2, @"uuid");
  if (Value
    && (unsigned int v21 = CFGetUUIDEx(Value, 0LL, (uint64_t)v22)) == 0
    && (snprintf( __str,  0x25uLL,  "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",  v22[0],  v22[1],  v22[2],  v22[3],  v22[4],  v22[5],  v22[6],  v22[7],  v22[8],  v22[9],  v22[10],  v22[11],  v22[12],  v22[13],  v22[14],  v22[15]),  CFStringRef v19 = CFStringCreateWithCString(0LL, __str, 0x8000100u),  (*(void *)(v5 + 64) = v19) == 0LL))
  {
    unsigned int v21 = -6700;
    CFRelease((CFTypeRef)v5);
    return v21;
  }

  else
  {
LABEL_24:
    uint64_t result = 0LL;
    *a1 = v5;
  }

  return result;
}

uint64_t _ScreenSetProperty(uint64_t a1, int a2, CFTypeRef cf1, uint64_t a4, const __CFString *a5)
{
  if (CFEqual(cf1, @"edid"))
  {
    if (a5)
    {
      CFTypeID v8 = CFGetTypeID(a5);
      if (v8 == CFDataGetTypeID())
      {
        uint64_t v11 = *(const void **)(a1 + 16);
        char v9 = (const __CFString **)(a1 + 16);
        uint64_t v10 = v11;
LABEL_5:
        CFRetain(a5);
        goto LABEL_9;
      }

      return 4294960540LL;
    }

    int v14 = *(const void **)(a1 + 16);
    char v9 = (const __CFString **)(a1 + 16);
    uint64_t v10 = v14;
    goto LABEL_9;
  }

  if (CFEqual(cf1, @"features"))
  {
    int v12 = CFGetInt64(a5, 0LL);
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 24) = v12;
    return result;
  }

  if (CFEqual(cf1, @"maxFPS"))
  {
    int v15 = CFGetInt64(a5, 0LL);
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = v15;
    return result;
  }

  if (CFEqual(cf1, @"platformLayer"))
  {
    uint64_t v10 = *(const void **)(a1 + 32);
    if (a5) {
      CFRetain(a5);
    }
    *(void *)(a1 + 32) = a5;
    if (!v10) {
      return 0LL;
    }
    goto LABEL_10;
  }

  if (CFEqual(cf1, @"widthPhysical"))
  {
    int v16 = CFGetInt64(a5, 0LL);
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = v16;
    return result;
  }

  if (CFEqual(cf1, @"heightPhysical"))
  {
    int v17 = CFGetInt64(a5, 0LL);
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 52) = v17;
    return result;
  }

  if (CFEqual(cf1, @"widthPixels"))
  {
    int v18 = CFGetInt64(a5, 0LL);
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 40) = v18;
    return result;
  }

  if (CFEqual(cf1, @"heightPixels"))
  {
    int v19 = CFGetInt64(a5, 0LL);
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 44) = v19;
    return result;
  }

  if (CFEqual(cf1, @"primaryInputDevice"))
  {
    int v20 = CFGetInt64(a5, 0LL);
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 56) = v20;
    return result;
  }

  if (CFEqual(cf1, @"uuid"))
  {
    if (a5)
    {
      CFTypeID v21 = CFGetTypeID(a5);
      if (v21 == CFStringGetTypeID())
      {
        uint64_t v22 = *(const void **)(a1 + 64);
        char v9 = (const __CFString **)(a1 + 64);
        uint64_t v10 = v22;
        goto LABEL_5;
      }

      return 4294960540LL;
    }

    int v23 = *(const void **)(a1 + 64);
    char v9 = (const __CFString **)(a1 + 64);
    uint64_t v10 = v23;
LABEL_9:
    *char v9 = a5;
    if (!v10) {
      return 0LL;
    }
LABEL_10:
    CFRelease(v10);
    return 0LL;
  }

  return 4294960582LL;
}

CFNumberRef _ScreenCopyProperty(void *a1, int a2, CFTypeRef cf1, uint64_t a4, int *a5)
{
  if (CFEqual(cf1, @"edid"))
  {
    CFNumberRef v8 = (CFNumberRef)a1[2];
    if (v8)
    {
LABEL_3:
      CFRetain(v8);
LABEL_9:
      int v10 = 0;
      goto LABEL_10;
    }

    goto LABEL_31;
  }

  if (CFEqual(cf1, @"features"))
  {
    char v9 = a1 + 3;
LABEL_8:
    CFNumberRef v8 = CFNumberCreate(0LL, kCFNumberSInt32Type, v9);
    if (v8) {
      goto LABEL_9;
    }
    int v10 = -6728;
    goto LABEL_10;
  }

  if (CFEqual(cf1, @"maxFPS"))
  {
    char v9 = (char *)a1 + 28;
    goto LABEL_8;
  }

  if (a1[4] && CFEqual(cf1, @"platformLayer"))
  {
    CFNumberRef v8 = (CFNumberRef)a1[4];
    goto LABEL_3;
  }

  if (CFEqual(cf1, @"widthPhysical"))
  {
    char v9 = a1 + 6;
    goto LABEL_8;
  }

  if (CFEqual(cf1, @"heightPhysical"))
  {
    char v9 = (char *)a1 + 52;
    goto LABEL_8;
  }

  if (CFEqual(cf1, @"widthPixels"))
  {
    char v9 = a1 + 5;
    goto LABEL_8;
  }

  if (CFEqual(cf1, @"heightPixels"))
  {
    char v9 = (char *)a1 + 44;
    goto LABEL_8;
  }

  if (CFEqual(cf1, @"primaryInputDevice"))
  {
    char v9 = a1 + 7;
    goto LABEL_8;
  }

  if (!CFEqual(cf1, @"uuid"))
  {
    CFNumberRef v8 = 0LL;
LABEL_31:
    int v10 = -6714;
    goto LABEL_10;
  }

  CFNumberRef v8 = (CFNumberRef)a1[8];
  if (v8) {
    goto LABEL_3;
  }
  int v10 = -6745;
LABEL_10:
  if (a5) {
    *a5 = v10;
  }
  return v8;
}

__CFArray *ScreenCopyAllScreens(int *a1)
{
  CFMutableStringRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  if (!Mutable)
  {
    int v7 = -6728;
    if (!a1) {
      return Mutable;
    }
    goto LABEL_7;
  }

  pthread_mutex_lock(&gScreenLock);
  if (gScreenArray)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)gScreenArray);
    if (Count >= 1)
    {
      CFIndex v4 = Count;
      for (CFIndex i = 0LL; i != v4; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)gScreenArray, i);
        CFArrayAppendValue(Mutable, ValueAtIndex);
      }
    }
  }

  pthread_mutex_unlock(&gScreenLock);
  int v7 = 0;
  if (a1) {
LABEL_7:
  }
    *a1 = v7;
  return Mutable;
}

void *ScreenCopyMain(int *a1)
{
  value = 0LL;
  pthread_mutex_lock(&gScreenLock);
  if (gScreenArray)
  {
    if (CFArrayGetCount((CFArrayRef)gScreenArray) >= 1)
    {
      value = (void *)CFArrayGetValueAtIndex((CFArrayRef)gScreenArray, 0LL);
      CFRetain(value);
      if (value)
      {
        int v2 = 0;
        goto LABEL_9;
      }
    }

    if (gScreenArray) {
      goto LABEL_7;
    }
  }

  gScreenArray = (uint64_t)CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  if (gScreenArray)
  {
LABEL_7:
    int v2 = ScreenCreate((uint64_t *)&value, 0LL);
    if (!v2) {
      CFArrayAppendValue((CFMutableArrayRef)gScreenArray, value);
    }
  }

  else
  {
    int v2 = -6728;
  }

uint64_t ScreenRegister(void *a1)
{
  CFMutableStringRef Mutable = (__CFArray *)gScreenArray;
  if (gScreenArray
    || (CFMutableStringRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]), (gScreenArray = (uint64_t)Mutable) != 0))
  {
    CFArrayAppendValue(Mutable, a1);
    if (gLogCategory_Screen <= 50
      && (gLogCategory_Screen != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_Screen, 0x32u)))
    {
      LogPrintF( (uint64_t)&gLogCategory_Screen,  (uint64_t)"OSStatus ScreenRegister(ScreenRef)",  0x32u,  (uint64_t)"Registered screen %@ %u x %u, %u FPS\n",  v3,  v4,  v5,  v6,  a1[8]);
    }

    uint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v7 = 4294960568LL;
  }

  pthread_mutex_unlock(&gScreenLock);
  return v7;
}

uint64_t ScreenDeregister(void *a1)
{
  if (!gScreenArray) {
    goto LABEL_12;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)gScreenArray);
  CFIndex v3 = Count;
  if (Count >= 1)
  {
    unint64_t v4 = Count + 1;
    do
    {
      if (CFArrayGetValueAtIndex((CFArrayRef)gScreenArray, v4 - 2) == a1)
      {
        if (gLogCategory_Screen <= 50
          && (gLogCategory_Screen != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_Screen, 0x32u)))
        {
          LogPrintF( (uint64_t)&gLogCategory_Screen,  (uint64_t)"OSStatus ScreenDeregister(ScreenRef)",  0x32u,  (uint64_t)"Deregistered screen %@ %u x %u\n",  v5,  v6,  v7,  v8,  a1[8]);
        }

        CFArrayRemoveValueAtIndex((CFMutableArrayRef)gScreenArray, v4 - 2);
        --v3;
      }

      --v4;
    }

    while (v4 > 1);
  }

  if (!v3)
  {
LABEL_12:
    if (gScreenArray)
    {
      CFRelease((CFTypeRef)gScreenArray);
      gScreenArray = 0LL;
    }
  }

  pthread_mutex_unlock(&gScreenLock);
  return 0LL;
}

uint64_t _ScreenStreamGetTypeID()
{
  uint64_t result = _CFRuntimeRegisterClass();
  gScreenStreamCFTypeID TypeID = result;
  return result;
}

void _ScreenStreamFinalize(void *a1)
{
  uint64_t v2 = a1[7];
  if (v2)
  {
    ((void (*)(uint64_t))softLinkVTDecompressionSessionInvalidate[0])(v2);
    CFRelease((CFTypeRef)a1[7]);
    a1[7] = 0LL;
  }

  CFIndex v3 = (const void *)a1[6];
  if (v3)
  {
    CFRelease(v3);
    a1[6] = 0LL;
  }

  unint64_t v4 = (const void *)a1[2];
  if (v4)
  {
    CFRelease(v4);
    a1[2] = 0LL;
  }

  uint64_t v5 = a1[9];
  if (v5)
  {
    softLinkCAImageQueueInvalidate(v5);
    CFRelease((CFTypeRef)a1[9]);
    a1[9] = 0LL;
  }

  uint64_t v6 = (const void *)a1[8];
  if (v6)
  {
    CFRelease(v6);
    a1[8] = 0LL;
  }

uint64_t initCAImageQueueInvalidate(uint64_t a1)
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  softLinkCAImageQueueInvalidate = (uint64_t (*)())dlsym( (void *)QuartzCoreLibrary_sLib_12558,  "CAImageQueueInvalidate");
  return ((uint64_t (*)(uint64_t))softLinkCAImageQueueInvalidate)(a1);
}

void *__QuartzCoreLibrary_block_invoke_12560()
{
  uint64_t result = dlopen("/System/Library/Frameworks/QuartzCore.framework/QuartzCore", 2);
  QuartzCoreLibrary_sLib_12558 = (uint64_t)result;
  return result;
}

uint64_t initVTDecompressionSessionInvalidate(uint64_t a1)
{
  if (VideoToolboxLibrary_sOnce_12562 != -1) {
    dispatch_once(&VideoToolboxLibrary_sOnce_12562, &__block_literal_global_27_12563);
  }
  softLinkVTDecompressionSessionInvalidate[0] = (uint64_t (*)())dlsym( (void *)VideoToolboxLibrary_sLib_12564,  "VTDecompressionSessionInvalidate");
  return ((uint64_t (*)(uint64_t))softLinkVTDecompressionSessionInvalidate[0])(a1);
}

void *__VideoToolboxLibrary_block_invoke_12566()
{
  uint64_t result = dlopen("/System/Library/Frameworks/VideoToolbox.framework/VideoToolbox", 2);
  VideoToolboxLibrary_sLib_12564 = (uint64_t)result;
  return result;
}

uint64_t ScreenStreamCreate(void *a1)
{
  if (gScreenStreamInitOnce != -1) {
    dispatch_once_f(&gScreenStreamInitOnce, 0LL, (dispatch_function_t)_ScreenStreamGetTypeID);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294960568LL;
  }
  CFIndex v3 = (_OWORD *)Instance;
  uint64_t result = 0LL;
  v3[5] = 0u;
  v3[6] = 0u;
  v3[3] = 0u;
  v3[4] = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  *a1 = v3;
  return result;
}

uint64_t ScreenStreamSetFrameHook(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 80) = a2;
  *(void *)(result + 8_Block_object_dispose(va, 8) = a3;
  return result;
}

uint64_t _ScreenStreamSetProperty(uint64_t a1, int a2, CFTypeRef cf1, uint64_t a4, __CFString *a5)
{
  if (CFEqual(cf1, @"avcc"))
  {
    if (a5)
    {
      CFTypeID v8 = CFGetTypeID(a5);
      if (v8 == CFDataGetTypeID())
      {
        char v9 = *(__CFString **)(a1 + 16);
        if (v9 == a5) {
          return 0LL;
        }
        if (v9)
        {
          if (!CFEqual(a5, v9))
          {
            int v10 = *(const void **)(a1 + 16);
            CFRetain(a5);
            *(void *)(a1 + 16) = a5;
            if (v10) {
              CFRelease(v10);
            }
            goto LABEL_21;
          }

          return 0LL;
        }

        CFRetain(a5);
        *(void *)(a1 + 16) = a5;
LABEL_21:
        *(_BYTE *)(a1 + 41) = 1;
        return 0LL;
      }
    }

    return 4294960540LL;
  }

  if (CFEqual(cf1, @"platformLayer"))
  {
    uint64_t v11 = a5;
    getCALayerClass_12570[0]();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      CFRetain(v11);
      int v12 = *(const void **)(a1 + 64);
      if (v12) {
        CFRelease(v12);
      }
      *(void *)(a1 + 64) = v11;

      return 0LL;
    }

    return 4294960540LL;
  }

  if (CFEqual(cf1, @"widthPhysical"))
  {
    int v13 = CFGetInt64(a5, 0LL);
    if (*(_DWORD *)(a1 + 32) == v13) {
      return 0LL;
    }
    *(_DWORD *)(a1 + 32) = v13;
    goto LABEL_21;
  }

  if (CFEqual(cf1, @"heightPhysical"))
  {
    int v14 = CFGetInt64(a5, 0LL);
    if (*(_DWORD *)(a1 + 36) == v14) {
      return 0LL;
    }
    *(_DWORD *)(a1 + 36) = v14;
    goto LABEL_21;
  }

  if (CFEqual(cf1, @"widthPixels"))
  {
    *(_DWORD *)(a1 + 24) = CFGetInt64(a5, (int *)&v16);
  }

  else
  {
    if (!CFEqual(cf1, @"heightPixels"))
    {
      if (!CFEqual(cf1, @"requireHardwareDecoder")) {
        return 4294960582LL;
      }
      *(_BYTE *)(a1 + 40) = CFGetInt64(a5, 0LL) != 0;
      return 0LL;
    }

    *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = CFGetInt64(a5, (int *)&v16);
  }

  uint64_t result = v16;
  if (!v16) {
    return 0LL;
  }
  return result;
}

id CALayerFunction_12571()
{
  return (id)classCALayer_12584;
}

Class initCALayer_12572()
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  Class result = objc_getClass("CALayer");
  classCALayer_12584 = (uint64_t)result;
  getCALayerClass_12570[0] = (uint64_t (*)())CALayerFunction_12571;
  return result;
}

uint64_t ScreenStreamStart( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 64))
  {
    uint64_t v9 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))softLinkCAImageQueueCreate[0])(1LL, 1LL, 17LL);
    *(void *)(a1 + 72) = v9;
    if (v9)
    {
      uint64_t v10 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))softLinkCAImageQueueSetFlags[0])(v9, 1LL, 1LL);
      uint64_t v11 = (void *)MEMORY[0x186E432B4](v10);
      int v12 = getCATransactionClass_12587;
      id v13 = *(id *)(a1 + 64);
      -[objc_class begin](v12(), "begin");
      -[objc_class setDisableActions:](getCATransactionClass_12587(), "setDisableActions:", 1LL);
      [v13 setContents:*(void *)(a1 + 72)];
      [v13 setEdgeAntialiasingMask:0];

      -[objc_class commit](getCATransactionClass_12587(), "commit");
      objc_autoreleasePoolPop(v11);
      uint64_t v18 = 0LL;
      if (gLogCategory_ScreenStream <= 50)
      {
        if (gLogCategory_ScreenStream != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_ScreenStream, 0x32u)) {
          LogPrintF( (uint64_t)&gLogCategory_ScreenStream,  (uint64_t)"OSStatus ScreenStreamStart(ScreenStreamRef)",  0x32u,  (uint64_t)"Screen stream started\n",  v14,  v15,  v16,  v17,  v20);
        }
        return 0LL;
      }

      return v18;
    }

    uint64_t v18 = 4294960596LL;
  }

  else
  {
    uint64_t v18 = 4294960551LL;
  }

  if (gLogCategory_ScreenStream <= 90
    && (gLogCategory_ScreenStream != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_ScreenStream, 0x5Au)))
  {
    LogPrintF( (uint64_t)&gLogCategory_ScreenStream,  (uint64_t)"OSStatus ScreenStreamStart(ScreenStreamRef)",  0x5Au,  (uint64_t)"### Start screen stream failed: %#m\n",  a5,  a6,  a7,  a8,  v18);
  }

  ScreenStreamStop((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8, v20);
  return v18;
}

id CATransactionFunction_12588()
{
  return (id)classCATransaction_12597;
}

Class initCATransaction_12589()
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  Class result = objc_getClass("CATransaction");
  classCATransaction_12597 = (uint64_t)result;
  getCATransactionClass_12587 = (uint64_t (*)())CATransactionFunction_12588;
  return result;
}

void ScreenStreamStop( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (gLogCategory_ScreenStream <= 50
    && (gLogCategory_ScreenStream != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_ScreenStream, 0x32u)))
  {
    LogPrintF( (uint64_t)&gLogCategory_ScreenStream,  (uint64_t)"void ScreenStreamStop(ScreenStreamRef)",  0x32u,  (uint64_t)"Screen stream stopping...\n",  a5,  a6,  a7,  a8,  v12);
  }

  uint64_t v10 = a1[7];
  if (v10)
  {
    ((void (*)(uint64_t))softLinkVTDecompressionSessionWaitForAsynchronousFrames[0])(v10);
    ((void (*)(uint64_t))softLinkVTDecompressionSessionInvalidate[0])(a1[7]);
    CFRelease((CFTypeRef)a1[7]);
    a1[7] = 0LL;
  }

  if (a1[9])
  {
    -[objc_class begin](getCATransactionClass_12587(), "begin");
    -[objc_class setDisableActions:](getCATransactionClass_12587(), "setDisableActions:", 1LL);
    uint64_t v11 = (void *)a1[8];
    if (v11) {
      [v11 setContents:0];
    }
    -[objc_class commit](getCATransactionClass_12587(), "commit");
    softLinkCAImageQueueInvalidate(a1[9]);
    CFRelease((CFTypeRef)a1[9]);
    a1[9] = 0LL;
  }

  if (gLogCategory_ScreenStream <= 50
    && (gLogCategory_ScreenStream != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_ScreenStream, 0x32u)))
  {
    LogPrintF( (uint64_t)&gLogCategory_ScreenStream,  (uint64_t)"void ScreenStreamStop(ScreenStreamRef)",  0x32u,  (uint64_t)"Screen stream stopped\n",  a5,  a6,  a7,  a8,  a9);
  }

uint64_t initVTDecompressionSessionWaitForAsynchronousFrames(uint64_t a1)
{
  if (VideoToolboxLibrary_sOnce_12562 != -1) {
    dispatch_once(&VideoToolboxLibrary_sOnce_12562, &__block_literal_global_27_12563);
  }
  softLinkVTDecompressionSessionWaitForAsynchronousFrames[0] = (uint64_t (*)())dlsym( (void *)VideoToolboxLibrary_sLib_12564,  "VTDecompressionSessionWaitFor AsynchronousFrames");
  return ((uint64_t (*)(uint64_t))softLinkVTDecompressionSessionWaitForAsynchronousFrames[0])(a1);
}

uint64_t initCAImageQueueSetFlags(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  softLinkCAImageQueueSetFlags[0] = (uint64_t (*)())dlsym( (void *)QuartzCoreLibrary_sLib_12558,  "CAImageQueueSetFlags");
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))softLinkCAImageQueueSetFlags[0])(a1, a2, a3);
}

uint64_t initCAImageQueueCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  softLinkCAImageQueueCreate[0] = (uint64_t (*)())dlsym( (void *)QuartzCoreLibrary_sLib_12558,  "CAImageQueueCreate");
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))softLinkCAImageQueueCreate[0])(a1, a2, a3);
}

uint64_t ScreenStreamProcessData( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, void (*a6)(uint64_t), uint64_t a7, uint64_t a8)
{
  int v11 = a3;
  uint64_t v52 = a3;
  if (!*(void *)(a1 + 48) || *(_BYTE *)(a1 + 41))
  {
    uint64_t v14 = *(const __CFData **)(a1 + 16);
    if (!v14 || !*(_DWORD *)(a1 + 24) || !*(_DWORD *)(a1 + 28))
    {
      uint64_t v22 = 4294960551LL;
      goto LABEL_39;
    }

    int BytePtr = CFDataGetBytePtr(v14);
    int Length = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    if (gLogCategory_ScreenStream <= 40
      && (gLogCategory_ScreenStream != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_ScreenStream, 0x28u)))
    {
      LogPrintF( (uint64_t)&gLogCategory_ScreenStream,  (uint64_t)"OSStatus _ScreenStreamEnsureDecoderSetUp(ScreenStreamRef)",  0x28u,  (uint64_t)"Screen stream format change to %u x %x, avcc 0x%.3H\n",  v16,  v17,  v18,  v19,  *(_DWORD *)(a1 + 24));
    }

    uint64_t v21 = softLinkFigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom( 0,  1635148593,  *(_DWORD *)(a1 + 24),  *(_DWORD *)(a1 + 28),  1635148611,  BytePtr,  Length,  0,  (uint64_t)v45);
    if ((_DWORD)v21) {
      goto LABEL_11;
    }
    int v23 = *(const void **)(a1 + 48);
    if (v23) {
      CFRelease(v23);
    }
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = v45[0];
    ((void (*)(uint64_t, uint64_t, uint64_t))softLinkCAImageQueueSetSize[0])( *(void *)(a1 + 72),  *(unsigned int *)(a1 + 24),  *(unsigned int *)(a1 + 28));
    uint64_t v24 = *(void *)(a1 + 56);
    if (v24
      && !((unsigned int (*)(uint64_t, uint64_t))softLinkVTDecompressionSessionCanAcceptFormatDescription[0])( v24,  *(void *)(a1 + 48)))
    {
      if (gLogCategory_ScreenStream <= 40
        && (gLogCategory_ScreenStream != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_ScreenStream, 0x28u)))
      {
        LogPrintF( (uint64_t)&gLogCategory_ScreenStream,  (uint64_t)"OSStatus _ScreenStreamEnsureDecoderSetUp(ScreenStreamRef)",  0x28u,  (uint64_t)"Screen stream rebuilding for format change\n",  v25,  v26,  v27,  v28,  v42);
      }

      ((void (*)(uint64_t))softLinkVTDecompressionSessionWaitForAsynchronousFrames[0])(*(void *)(a1 + 56));
      ((void (*)(uint64_t))softLinkVTDecompressionSessionInvalidate[0])(*(void *)(a1 + 56));
      CFRelease(*(CFTypeRef *)(a1 + 56));
      *(void *)(a1 + 56) = 0LL;
    }

    *(_BYTE *)(a1 + 41) = 0;
  }

  if (!*(void *)(a1 + 56))
  {
    v45[0] = _ScreenStreamDecodeCompleted;
    v45[1] = a1;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    if (!Mutable)
    {
      uint64_t v22 = 4294960568LL;
      goto LABEL_39;
    }

    id v30 = Mutable;
    uint64_t v31 = (const void *)getkVTDecompressionPropertyKey_Usage[0]();
    CFDictionarySetInt64(v30, v31, 20LL);
    uint64_t v32 = (const void *)getkVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoder[0]();
    int v33 = (const void *)*MEMORY[0x189604DE8];
    CFDictionarySetValue(v30, v32, (const void *)*MEMORY[0x189604DE8]);
    if (*(_BYTE *)(a1 + 40))
    {
      uint64_t v34 = (const void *)getkVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder[0]();
      CFDictionarySetValue(v30, v34, v33);
    }

    uint64_t v35 = (const void *)getkVTVideoDecoderSpecification_EnableSandboxedVideoDecoder();
    CFDictionarySetValue(v30, v35, (const void *)*MEMORY[0x189604DE0]);
    int v36 = softLinkVTDecompressionSessionCreate(0LL, *(void *)(a1 + 48), (uint64_t)v30, 0LL, (uint64_t)v45, a1 + 56);
    CFRelease(v30);
    if (v36)
    {
      if (gLogCategory_ScreenStream <= 50
        && (gLogCategory_ScreenStream != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_ScreenStream, 0x32u)))
      {
        LogPrintF( (uint64_t)&gLogCategory_ScreenStream,  (uint64_t)"OSStatus _ScreenStreamEnsureDecoderSetUp(ScreenStreamRef)",  0x32u,  (uint64_t)"### Screen stream setup decoder failed...retrying with defaults: %#m\n",  v37,  v38,  v39,  v40,  v36);
      }

      uint64_t v21 = softLinkVTDecompressionSessionCreate(0LL, *(void *)(a1 + 48), 0LL, 0LL, (uint64_t)v45, a1 + 56);
      if ((_DWORD)v21)
      {
LABEL_11:
        uint64_t v22 = v21;
        goto LABEL_39;
      }
    }
  }

  uint64_t v22 = softLinkCMBlockBufferCreateWithMemoryBlock(0, a2, v11, *MEMORY[0x189604DC8], 0, 0, v11, 0, (uint64_t)&v51);
  if (!(_DWORD)v22)
  {
    ((void (*)(uint64_t@<X8>))getkCMTimeInvalid[0])((uint64_t)v45);
    ((void (*)(uint64_t@<X8>))getkCMTimeInvalid[0])((uint64_t)cf);
    __int128 v48 = *(_OWORD *)cf;
    uint64_t v49 = v44;
    softLinkCMClockMakeHostTimeFromSystemUnits(a4);
    __int128 v46 = *(_OWORD *)cf;
    uint64_t v47 = v44;
    uint64_t v22 = softLinkCMSampleBufferCreate( 0,  (int)v51,  1,  0,  0,  *(void *)(a1 + 48),  1,  1,  (uint64_t)v45,  1LL,  (uint64_t)&v52,  (uint64_t)cf);
    CFRelease(v51);
    if (!(_DWORD)v22)
    {
      uint64_t v22 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))softLinkVTDecompressionSessionDecodeFrame[0])( *(void *)(a1 + 56),  (uint64_t)cf[0],  0LL,  0LL,  (uint64_t)v50);
      CFRelease(cf[0]);
      if (!(_DWORD)v22)
      {
        uint64_t v22 = 0LL;
        if ((v50[0] & 2) != 0) {
          ++*(_DWORD *)(a1 + 96);
        }
      }
    }
  }

uint64_t _ScreenStreamDecodeCompleted( uint64_t result, uint64_t a2, int a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a3;
  uint64_t v10 = result;
  if (a3)
  {
    if ((a4 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_13:
    ++*(_DWORD *)(v10 + 96);
    if (!v9) {
      return result;
    }
    goto LABEL_14;
  }

  id v13 = *(void (**)(uint64_t, uint64_t, void))(result + 80);
  if (v13)
  {
    __int128 v19 = *(_OWORD *)a6;
    uint64_t v20 = *(void *)(a6 + 16);
    uint64_t v14 = ((uint64_t (*)(__int128 *))softLinkCMClockConvertHostTimeToSystemUnits[0])(&v19);
    v13(a5, v14, *(void *)(v10 + 88));
  }

  Class result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))softLinkCAImageQueueRegisterCVImageBuffer[0])( *(void *)(v10 + 72),  a5,  0LL);
  if (!result) {
    goto LABEL_12;
  }
  uint64_t v15 = result;
  ((void (*)(uint64_t))softLinkCAImageQueueCollect[0])(*(void *)(v10 + 72));
  uint64_t v16 = *(void *)(v10 + 72);
  __int128 v19 = *(_OWORD *)a6;
  uint64_t v20 = *(void *)(a6 + 16);
  ((void (*)(__int128 *))softLinkCMTimeGetSeconds[0])(&v19);
  Class result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, double))softLinkCAImageQueueInsertImage[0])( v16,  3LL,  v15,  1LL,  (uint64_t)_ScreenStreamImageReleased,  v10,  v17);
  if ((result & 1) == 0)
  {
    Class result = ((uint64_t (*)(uint64_t, uint64_t))softLinkCAImageQueueDeleteBuffer[0])(*(void *)(v10 + 72), v15);
LABEL_12:
    int v9 = -6700;
    if ((a4 & 2) != 0) {
      goto LABEL_13;
    }
    goto LABEL_3;
  }

  int v9 = 0;
  if ((a4 & 2) != 0) {
    goto LABEL_13;
  }
LABEL_3:
  if (!v9) {
    return result;
  }
LABEL_14:
  int v18 = *(_DWORD *)(v10 + 100) + 1;
  *(_DWORD *)(v10 + 100) = v18;
  if (gLogCategory_ScreenStream <= 50)
  {
    if (gLogCategory_ScreenStream != -1) {
      return LogPrintF( (uint64_t)&gLogCategory_ScreenStream,  (uint64_t)"void _ScreenStreamDecodeCompleted(void *, void *, OSStatus, VTDecodeInfoFlags, CVImageBufferRef, CMTime, CMTime)",  0x32u,  (uint64_t)"### Screen stream decode error (%u total): %#m\n",  a5,  a6,  a7,  a8,  v18);
    }
    Class result = _LogCategory_Initialize((uint64_t)&gLogCategory_ScreenStream, 0x32u);
    if ((_DWORD)result)
    {
      int v18 = *(_DWORD *)(v10 + 100);
      return LogPrintF( (uint64_t)&gLogCategory_ScreenStream,  (uint64_t)"void _ScreenStreamDecodeCompleted(void *, void *, OSStatus, VTDecodeInfoFlags, CVImageBufferRef, CMTime, CMTime)",  0x32u,  (uint64_t)"### Screen stream decode error (%u total): %#m\n",  a5,  a6,  a7,  a8,  v18);
    }
  }

  return result;
}

uint64_t initValkVTDecompressionPropertyKey_Usage()
{
  if (VideoToolboxLibrary_sOnce_12562 != -1) {
    dispatch_once(&VideoToolboxLibrary_sOnce_12562, &__block_literal_global_27_12563);
  }
  uint64_t v0 = (uint64_t *)dlsym((void *)VideoToolboxLibrary_sLib_12564, "kVTDecompressionPropertyKey_Usage");
  if (v0)
  {
    uint64_t result = *v0;
    constantValkVTDecompressionPropertyKey_Usage = result;
  }

  else
  {
    uint64_t result = constantValkVTDecompressionPropertyKey_Usage;
  }

  getkVTDecompressionPropertyKey_Usage[0] = kVTDecompressionPropertyKey_UsageFunction;
  return result;
}

uint64_t kVTDecompressionPropertyKey_UsageFunction()
{
  return constantValkVTDecompressionPropertyKey_Usage;
}

uint64_t initValkVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoder()
{
  if (VideoToolboxLibrary_sOnce_12562 != -1) {
    dispatch_once(&VideoToolboxLibrary_sOnce_12562, &__block_literal_global_27_12563);
  }
  uint64_t v0 = (uint64_t *)dlsym( (void *)VideoToolboxLibrary_sLib_12564,  "kVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoder");
  if (v0)
  {
    uint64_t result = *v0;
    constantValkVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoder = result;
  }

  else
  {
    uint64_t result = constantValkVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoder;
  }

  getkVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoder[0] = kVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoderFunction;
  return result;
}

uint64_t kVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoderFunction()
{
  return constantValkVTVideoDecoderSpecification_EnableHardwareAcceleratedVideoDecoder;
}

uint64_t initValkVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder()
{
  if (VideoToolboxLibrary_sOnce_12562 != -1) {
    dispatch_once(&VideoToolboxLibrary_sOnce_12562, &__block_literal_global_27_12563);
  }
  uint64_t v0 = (uint64_t *)dlsym( (void *)VideoToolboxLibrary_sLib_12564,  "kVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder");
  if (v0)
  {
    uint64_t result = *v0;
    constantValkVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder = result;
  }

  else
  {
    uint64_t result = constantValkVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder;
  }

  getkVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder[0] = kVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoderFunction;
  return result;
}

uint64_t kVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoderFunction()
{
  return constantValkVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder;
}

uint64_t initValkVTVideoDecoderSpecification_EnableSandboxedVideoDecoder()
{
  if (VideoToolboxLibrary_sOnce_12562 != -1) {
    dispatch_once(&VideoToolboxLibrary_sOnce_12562, &__block_literal_global_27_12563);
  }
  uint64_t v0 = (uint64_t *)dlsym( (void *)VideoToolboxLibrary_sLib_12564,  "kVTVideoDecoderSpecification_EnableSandboxedVideoDecoder");
  if (v0)
  {
    uint64_t result = *v0;
    constantValkVTVideoDecoderSpecification_EnableSandboxedVideoDecoder = result;
  }

  else
  {
    uint64_t result = constantValkVTVideoDecoderSpecification_EnableSandboxedVideoDecoder;
  }

  getkVTVideoDecoderSpecification_EnableSandboxedVideoDecoder = kVTVideoDecoderSpecification_EnableSandboxedVideoDecoderFunction;
  return result;
}

uint64_t kVTVideoDecoderSpecification_EnableSandboxedVideoDecoderFunction()
{
  return constantValkVTVideoDecoderSpecification_EnableSandboxedVideoDecoder;
}

double initValkCMTimeInvalid@<D0>(uint64_t a1@<X8>)
{
  if (CoreMediaLibrary_sOnce != -1) {
    dispatch_once(&CoreMediaLibrary_sOnce, &__block_literal_global_32_12605);
  }
  uint64_t v2 = (__int128 *)dlsym((void *)CoreMediaLibrary_sLib, "kCMTimeInvalid");
  if (v2)
  {
    __int128 v3 = *v2;
    qword_18C69EF08 = *((void *)v2 + 2);
    constantValkCMTimeInvalid = v3;
  }

  getkCMTimeInvalid[0] = (uint64_t (*)())kCMTimeInvalidFunction;
  double result = *(double *)&constantValkCMTimeInvalid;
  *(_OWORD *)a1 = constantValkCMTimeInvalid;
  *(void *)(a1 + 16) = qword_18C69EF08;
  return result;
}

double kCMTimeInvalidFunction@<D0>(uint64_t a1@<X8>)
{
  double result = *(double *)&constantValkCMTimeInvalid;
  *(_OWORD *)a1 = constantValkCMTimeInvalid;
  *(void *)(a1 + 16) = qword_18C69EF08;
  return result;
}

uint64_t initVTDecompressionSessionDecodeFrame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (VideoToolboxLibrary_sOnce_12562 != -1) {
    dispatch_once(&VideoToolboxLibrary_sOnce_12562, &__block_literal_global_27_12563);
  }
  softLinkVTDecompressionSessionDecodeFrame[0] = (uint64_t (*)())dlsym( (void *)VideoToolboxLibrary_sLib_12564,  "VTDecompressionSessionDecodeFrame");
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))softLinkVTDecompressionSessionDecodeFrame[0])( a1,  a2,  a3,  a4,  a5);
}

uint64_t initCMSampleBufferCreate( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (CoreMediaLibrary_sOnce != -1) {
    dispatch_once(&CoreMediaLibrary_sOnce, &__block_literal_global_32_12605);
  }
  softLinkCMSampleBufferCreate = (uint64_t (*)(int, int, int, int, int, int, int, int, uint64_t, uint64_t, uint64_t, uint64_t))dlsym((void *)CoreMediaLibrary_sLib, "CMSampleBufferCreate");
  return softLinkCMSampleBufferCreate(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

void *__CoreMediaLibrary_block_invoke()
{
  double result = dlopen("/System/Library/Frameworks/CoreMedia.framework/CoreMedia", 2);
  CoreMediaLibrary_sLib = (uint64_t)result;
  return result;
}

uint64_t initCMClockMakeHostTimeFromSystemUnits(uint64_t a1)
{
  if (CoreMediaLibrary_sOnce != -1) {
    dispatch_once(&CoreMediaLibrary_sOnce, &__block_literal_global_32_12605);
  }
  softLinkCMClockMakeHostTimeFromSystemUnits = (uint64_t (*)())dlsym( (void *)CoreMediaLibrary_sLib,  "CMClockMakeHostTimeFromSystemUnits");
  return ((uint64_t (*)(uint64_t))softLinkCMClockMakeHostTimeFromSystemUnits)(a1);
}

uint64_t initCMBlockBufferCreateWithMemoryBlock( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (CoreMediaLibrary_sOnce != -1) {
    dispatch_once(&CoreMediaLibrary_sOnce, &__block_literal_global_32_12605);
  }
  softLinkCMBlockBufferCreateWithMemoryBlock = (uint64_t (*)(int, int, int, int, int, int, int, int, uint64_t))dlsym((void *)CoreMediaLibrary_sLib, "CMBlockBufferCreateWithMemoryBlock");
  return softLinkCMBlockBufferCreateWithMemoryBlock(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t initVTDecompressionSessionCreate( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (VideoToolboxLibrary_sOnce_12562 != -1) {
    dispatch_once(&VideoToolboxLibrary_sOnce_12562, &__block_literal_global_27_12563);
  }
  softLinkVTDecompressionSessionCreate = (uint64_t (*)())dlsym( (void *)VideoToolboxLibrary_sLib_12564,  "VTDecompressionSessionCreate");
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))softLinkVTDecompressionSessionCreate)( a1,  a2,  a3,  a4,  a5,  a6);
}

uint64_t _ScreenStreamImageReleased(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (_DWORD *)softLinkCAImageQueueGetReleasedImageInfo[0]();
  if (v5 && !*v5) {
    ++*(_DWORD *)(a3 + 104);
  }
  return ((uint64_t (*)(uint64_t, uint64_t))softLinkCAImageQueueDeleteBuffer[0])(*(void *)(a3 + 72), a2);
}

uint64_t initCAImageQueueDeleteBuffer(uint64_t a1, uint64_t a2)
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  softLinkCAImageQueueDeleteBuffer[0] = (uint64_t (*)())dlsym( (void *)QuartzCoreLibrary_sLib_12558,  "CAImageQueueDeleteBuffer");
  return ((uint64_t (*)(uint64_t, uint64_t))softLinkCAImageQueueDeleteBuffer[0])(a1, a2);
}

uint64_t initCAImageQueueInsertImage( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7)
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  softLinkCAImageQueueInsertImage[0] = (uint64_t (*)())dlsym( (void *)QuartzCoreLibrary_sLib_12558,  "CAImageQueueInsertImage");
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, double))softLinkCAImageQueueInsertImage[0])( a1,  a2,  a3,  a4,  a5,  a6,  a7);
}

uint64_t initCAImageQueueGetReleasedImageInfo()
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  softLinkCAImageQueueGetReleasedImageInfo[0] = (uint64_t (*)())dlsym( (void *)QuartzCoreLibrary_sLib_12558,  "CAImageQueueGetReleasedImageInfo");
  return softLinkCAImageQueueGetReleasedImageInfo[0]();
}

uint64_t initCMTimeGetSeconds(__int128 *a1)
{
  if (CoreMediaLibrary_sOnce != -1) {
    dispatch_once(&CoreMediaLibrary_sOnce, &__block_literal_global_32_12605);
  }
  softLinkCMTimeGetSeconds[0] = (uint64_t (*)())dlsym((void *)CoreMediaLibrary_sLib, "CMTimeGetSeconds");
  __int128 v3 = *a1;
  uint64_t v4 = *((void *)a1 + 2);
  return ((uint64_t (*)(__int128 *))softLinkCMTimeGetSeconds[0])(&v3);
}

uint64_t initCAImageQueueCollect(uint64_t a1)
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  softLinkCAImageQueueCollect[0] = (uint64_t (*)())dlsym( (void *)QuartzCoreLibrary_sLib_12558,  "CAImageQueueCollect");
  return ((uint64_t (*)(uint64_t))softLinkCAImageQueueCollect[0])(a1);
}

uint64_t initCAImageQueueRegisterCVImageBuffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  softLinkCAImageQueueRegisterCVImageBuffer[0] = (uint64_t (*)())dlsym( (void *)QuartzCoreLibrary_sLib_12558,  "CAImageQueueRegisterCVImageBuffer");
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))softLinkCAImageQueueRegisterCVImageBuffer[0])(a1, a2, a3);
}

uint64_t initCMClockConvertHostTimeToSystemUnits(__int128 *a1)
{
  if (CoreMediaLibrary_sOnce != -1) {
    dispatch_once(&CoreMediaLibrary_sOnce, &__block_literal_global_32_12605);
  }
  softLinkCMClockConvertHostTimeToSystemUnits[0] = (uint64_t (*)())dlsym( (void *)CoreMediaLibrary_sLib,  "CMClockConvertHostTimeToSystemUnits");
  __int128 v3 = *a1;
  uint64_t v4 = *((void *)a1 + 2);
  return ((uint64_t (*)(__int128 *))softLinkCMClockConvertHostTimeToSystemUnits[0])(&v3);
}

uint64_t initVTDecompressionSessionCanAcceptFormatDescription(uint64_t a1, uint64_t a2)
{
  if (VideoToolboxLibrary_sOnce_12562 != -1) {
    dispatch_once(&VideoToolboxLibrary_sOnce_12562, &__block_literal_global_27_12563);
  }
  softLinkVTDecompressionSessionCanAcceptFormatDescription[0] = (uint64_t (*)())dlsym( (void *)VideoToolboxLibrary_sLib_12564,  "VTDecompressionSessionCanAcc eptFormatDescription");
  return ((uint64_t (*)(uint64_t, uint64_t))softLinkVTDecompressionSessionCanAcceptFormatDescription[0])(a1, a2);
}

uint64_t initCAImageQueueSetSize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (QuartzCoreLibrary_sOnce_12556 != -1) {
    dispatch_once(&QuartzCoreLibrary_sOnce_12556, &__block_literal_global_12557);
  }
  softLinkCAImageQueueSetSize[0] = (uint64_t (*)())dlsym( (void *)QuartzCoreLibrary_sLib_12558,  "CAImageQueueSetSize");
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))softLinkCAImageQueueSetSize[0])(a1, a2, a3);
}

uint64_t initFigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (CoreMediaLibrary_sOnce != -1) {
    dispatch_once(&CoreMediaLibrary_sOnce, &__block_literal_global_32_12605);
  }
  softLinkFigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom = (uint64_t (*)(int, int, int, int, int, int, int, int, uint64_t))dlsym((void *)CoreMediaLibrary_sLib, "FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom");
  return softLinkFigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t SDPFindAttribute( char *a1, unint64_t a2, unsigned __int8 *a3, void *a4, void *a5, char **a6)
{
  for (CFIndex i = a1; ; a1 = i)
  {
    uint64_t result = SDPGetNext(a1, a2, &v20, &v19, (unsigned __int8 **)&v18, &i);
    if ((_DWORD)result) {
      break;
    }
    if (v20 == 97 && v18 >= 1)
    {
      uint64_t v12 = 0LL;
      id v13 = v19;
      uint64_t v14 = &v19[v18];
      uint64_t v15 = v19;
      while (*v15 != 58)
      {
        ++v15;
        --v12;
        if (v15 >= v14) {
          goto LABEL_15;
        }
      }

      uint64_t v16 = a3;
      while (v12)
      {
        int v17 = *v16;
        if (*v13 != v17) {
          goto LABEL_15;
        }
        ++v16;
        ++v13;
        ++v12;
        if (!v17) {
          goto LABEL_16;
        }
      }

      if (a3[v15 - v19]) {
        continue;
      }
LABEL_16:
      uint64_t result = 0LL;
      *a4 = v15 + 1;
      *a5 = v14 - (v15 + 1);
      break;
    }

uint64_t SDPGetNext(char *a1, unint64_t a2, _BYTE *a3, void *a4, unsigned __int8 **a5, void *a6)
{
  uint64_t v6 = a2 - (void)a1 - 2;
  if (a1[1] != 61) {
    return 4294960554LL;
  }
  uint64_t v7 = a1 + 2;
  CFTypeID v8 = (unsigned __int8 *)(a1 + 2);
  if ((unint64_t)(a1 + 2) < a2)
  {
    CFTypeID v8 = (unsigned __int8 *)(a1 + 2);
    while (1)
    {
      int v9 = *v8;
      if (v9 == 10 || v9 == 13) {
        break;
      }
      ++v8;
      if (!--v6)
      {
        CFTypeID v8 = (unsigned __int8 *)a2;
        break;
      }
    }
  }

  char v11 = *a1;
  uint64_t v12 = (unsigned __int8 *)(v8 - v7);
  if ((unint64_t)v8 < a2)
  {
    unint64_t v13 = a2 - (void)v8;
    while (1)
    {
      int v14 = *v8;
      if (v14 != 13 && v14 != 10) {
        break;
      }
      ++v8;
      if (!--v13)
      {
        CFTypeID v8 = (unsigned __int8 *)a2;
        break;
      }
    }
  }

  uint64_t result = 0LL;
  *a3 = v11;
  *a4 = v7;
  *a5 = v12;
  *a6 = v8;
  return result;
}

uint64_t SDPFindMediaSection( char *a1, unint64_t a2, void *a3, void *a4, void *a5, unsigned __int8 **a6, void *a7)
{
  char v20 = a1;
  do
  {
  }

  while (v19 != 109);
  unint64_t v13 = v17;
  uint64_t v14 = v18;
  uint64_t v15 = v18 - 2;
  while (!SDPGetNext(v20, a2, &v19, &v18, &v17, &v20))
  {
    if (v19 == 109)
    {
      char v20 = (char *)(v18 - 2);
      break;
    }
  }

  if (a3) {
    *a3 = v15;
  }
  if (a4) {
    *a4 = v20;
  }
  if (a5) {
    *a5 = v14;
  }
  if (a6) {
    *a6 = v13;
  }
  uint64_t result = 0LL;
  if (a7) {
    *a7 = v20;
  }
  return result;
}

uint64_t SDPFindParameter(_BYTE *a1, _BYTE *a2, unsigned __int8 *a3, void *a4, void *a5, void *a6)
{
  uint64_t v12 = a2 - 1;
  uint64_t v13 = MEMORY[0x1895F8770];
LABEL_2:
  while (2)
  {
    uint64_t v14 = a1;
    if (a1 < a2)
    {
      uint64_t v15 = a2 - a1;
      uint64_t v14 = a1;
      do
      {
        uint64_t v16 = *v14;
        if ((char)*v14 < 0)
        {
          if (!__maskrune(v16, 0x4000uLL)) {
            goto LABEL_10;
          }
        }

        else if ((*(_DWORD *)(v13 + 4 * v16 + 60) & 0x4000) == 0)
        {
          goto LABEL_10;
        }

        ++v14;
        --v15;
      }

      while (v15);
      uint64_t v14 = a2;
    }

uint64_t SDPFindSessionSection(char *a1, unint64_t a2, char **a3, void *a4, void *a5)
{
  uint64_t v14 = a1;
  while (!SDPGetNext(v14, a2, &v13, &v12, &v11, &v14))
  {
    if (v13 == 109)
    {
      uint64_t v14 = (char *)(v12 - 2);
      break;
    }
  }

  if (a3) {
    *a3 = a1;
  }
  if (a4) {
    *a4 = v14;
  }
  if (a5) {
    *a5 = v14;
  }
  return 0LL;
}

uint64_t SDPFindType(char *a1, unint64_t a2, unsigned __int8 a3, void *a4, void *a5, void *a6)
{
  int v10 = a3;
  uint64_t v15 = a1;
  while (1)
  {
    uint64_t result = SDPGetNext(v15, a2, &v14, &v13, &v12, &v15);
    if ((_DWORD)result) {
      break;
    }
    if (v14 == v10)
    {
      if (a4) {
        *a4 = v13;
      }
      uint64_t result = 0LL;
      if (a5) {
        *a5 = v12;
      }
      break;
    }
  }

  if (a6) {
    *a6 = v15;
  }
  return result;
}

uint64_t SDPGetNextAttribute( char *a1, unint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  uint64_t v22 = a1;
  do
    uint64_t result = SDPGetNext(v22, a2, &v21, &v20, (unsigned __int8 **)&v19, &v22);
  while (!(_DWORD)result && v21 != 97);
  if ((_DWORD)result) {
    goto LABEL_18;
  }
  unsigned __int8 v14 = v20;
  uint64_t v15 = &v20[v19];
  if (v19 < 1)
  {
    uint64_t v16 = 0LL;
    BOOL v17 = v20;
    if (!a3) {
      goto LABEL_12;
    }
  }

  else
  {
    uint64_t v16 = 1LL;
    BOOL v17 = v20;
    while (*v17 != 58)
    {
      if (++v17 >= v15)
      {
        uint64_t v16 = 0LL;
        break;
      }
    }

    if (!a3) {
      goto LABEL_12;
    }
  }

  *a3 = v20;
LABEL_12:
  if (a4) {
    *a4 = v17 - v14;
  }
  uint64_t v18 = &v17[v16];
  if (a5) {
    *a5 = v18;
  }
  if (a6) {
    *a6 = v15 - v18;
  }
LABEL_18:
  if (a7) {
    *a7 = v22;
  }
  return result;
}

uint64_t SerialStreamGetTypeID()
{
  if (gSerialStreamInitOnce != -1) {
    dispatch_once_f(&gSerialStreamInitOnce, 0LL, (dispatch_function_t)_SerialStreamGetTypeID);
  }
  return gSerialStreamTypeID;
}

uint64_t _SerialStreamGetTypeID()
{
  uint64_t result = _CFRuntimeRegisterClass();
  gSerialStreamCFTypeID TypeID = result;
  return result;
}

void _SerialStreamFinalize(uint64_t a1)
{
  uint64_t v2 = *(dispatch_object_s **)(a1 + 16);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(a1 + 16) = 0LL;
  }

uint64_t SerialStreamCreate(uint64_t *a1)
{
  if (gSerialStreamInitOnce != -1) {
    dispatch_once_f(&gSerialStreamInitOnce, 0LL, (dispatch_function_t)_SerialStreamGetTypeID);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294960568LL;
  }
  uint64_t v3 = Instance;
  bzero((void *)(Instance + 24), 0x478uLL);
  uint64_t v4 = (dispatch_object_s *)MEMORY[0x1895F8AE0];
  *(void *)(v3 + 16) = MEMORY[0x1895F8AE0];
  dispatch_retain(v4);
  uint64_t result = 0LL;
  *(_DWORD *)(v3 + 24) = -1;
  *(void *)(v3 + 104) = v3 + 96;
  *(void *)(v3 + 120) = v3 + 112;
  *a1 = v3;
  return result;
}

uint64_t SerialStreamSetConfig(uint64_t a1, void *a2)
{
  if (!*a2) {
    return 4294960592LL;
  }
  __strlcpy_chk();
  uint64_t result = 0LL;
  *(void *)(a1 + 1156) = a2[1];
  return result;
}

void SerialStreamSetDispatchQueue(uint64_t a1, dispatch_object_s *a2)
{
  if (a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = (dispatch_object_s *)MEMORY[0x1895F8AE0];
  }
  dispatch_retain(v3);
  uint64_t v4 = *(dispatch_object_s **)(a1 + 16);
  if (v4) {
    dispatch_release(v4);
  }
  *(void *)(a1 + 16) = v3;
}

void SerialStreamInvalidate(dispatch_queue_t *a1)
{
}

void _SerialStreamInvalidate(const void *a1)
{
}

void _SerialStreamErrorHandler(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(dispatch_source_s **)(a1 + 32);
  if (v4)
  {
    dispatch_source_cancel(v4);
    if (*(_BYTE *)(a1 + 40))
    {
      dispatch_resume(*(dispatch_object_t *)(a1 + 32));
      *(_BYTE *)(a1 + 40) = 0;
    }

    dispatch_release(*(dispatch_object_t *)(a1 + 32));
    *(void *)(a1 + 32) = 0LL;
  }

  uint64_t v5 = *(dispatch_source_s **)(a1 + 80);
  if (v5)
  {
    dispatch_source_cancel(v5);
    if (*(_BYTE *)(a1 + 88))
    {
      dispatch_resume(*(dispatch_object_t *)(a1 + 80));
      *(_BYTE *)(a1 + 8_Block_object_dispose(va, 8) = 0;
    }

    dispatch_release(*(dispatch_object_t *)(a1 + 80));
    *(void *)(a1 + 80) = 0LL;
  }

  while (1)
  {
    uint64_t v6 = *(void **)(a1 + 96);
    if (!v6) {
      break;
    }
    v6[5] = 0LL;
    _SerialStreamReadCompleted(a1, v6, a2);
  }

  while (1)
  {
    uint64_t v7 = *(uint64_t **)(a1 + 112);
    if (!v7) {
      break;
    }
    _SerialStreamWriteCompleted(a1, v7, a2);
  }

  CFTypeID v8 = *(void **)(a1 + 48);
  if (v8)
  {
    free(v8);
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  }

void _SerialStreamReadCompleted(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = *(void (**)(uint64_t, void, void, void))a2;
  *(void *)(a1 + 96) = *(void *)a2;
  if (!v4) {
    *(void *)(a1 + 104) = a1 + 96;
  }
  (*((void (**)(uint64_t, void, void, void))a2 + 7))( a3,  *((void *)a2 + 6),  *((void *)a2 + 5),  *((void *)a2 + 8));
  CFRelease(*((CFTypeRef *)a2 + 1));
  free(a2);
}

void _SerialStreamWriteCompleted(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *(void *)(a1 + 112) = *a2;
  if (!v4) {
    *(void *)(a1 + 120) = a1 + 112;
  }
  uint64_t v5 = (void (*)(uint64_t, uint64_t))a2[6];
  if (v5) {
    v5(a3, a2[7]);
  }
  CFRelease((CFTypeRef)a2[1]);
  free(a2);
}

uint64_t SerialStreamRead(dispatch_queue_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6)
{
  if (a4) {
    size_t v12 = 72LL;
  }
  else {
    size_t v12 = a3 + 72;
  }
  uint64_t v13 = malloc(v12);
  if (!v13) {
    return 4294960568LL;
  }
  unsigned __int8 v14 = v13;
  CFRetain(a1);
  v14[1] = a1;
  *((_DWORD *)v14 + 4) = 0;
  v14[3] = a2;
  v14[4] = a3;
  uint64_t v15 = (char *)(v14 + 9);
  if (a4) {
    uint64_t v15 = a4;
  }
  v14[5] = 0LL;
  v14[6] = v15;
  v14[7] = a5;
  v14[8] = a6;
  dispatch_async_f(a1[2], v14, (dispatch_function_t)_SerialStreamRead);
  return 0LL;
}

void _SerialStreamRead( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[1];
  *a1 = 0LL;
  **(void **)(v8 + 104) = a1;
  *(void *)(v8 + 104) = a1;
  uint64_t v9 = _SerialStreamEnsureSetUp(v8, a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)v9) {
    _SerialStreamErrorHandler(v8, v9);
  }
  else {
    _SerialStreamReadHandler(v8);
  }
}

uint64_t _SerialStreamEnsureSetUp( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if ((*(_DWORD *)(a1 + 24) & 0x80000000) == 0) {
    return 0LL;
  }
  if (gLogCategory_SerialUtils <= 20
    && (gLogCategory_SerialUtils != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_SerialUtils, 0x14u)))
  {
    LogPrintF( (uint64_t)&gLogCategory_SerialUtils,  (uint64_t)"OSStatus _SerialStreamEnsureSetUp(SerialStreamRef)",  0x14u,  (uint64_t)"Opening serial port '%s'\n",  a5,  a6,  a7,  a8,  a1 + 0x80);
  }

  uint64_t v9 = 1LL;
  while (1)
  {
    int v10 = open((const char *)(a1 + 128), 131078);
    *(_DWORD *)(a1 + 24) = v10;
    if ((v10 & 0x80000000) == 0) {
      break;
    }
    if (*__error())
    {
      uint64_t v15 = *__error();
      if (!(_DWORD)v15) {
        break;
      }
    }

    else
    {
      uint64_t v15 = 4294960596LL;
    }

    if (gLogCategory_SerialUtils <= 50
      && (gLogCategory_SerialUtils != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_SerialUtils, 0x32u)))
    {
      uint64_t v25 = v9;
      uint64_t v26 = v15;
      LogPrintF( (uint64_t)&gLogCategory_SerialUtils,  (uint64_t)"OSStatus _SerialStreamEnsureSetUp(SerialStreamRef)",  0x32u,  (uint64_t)"### Open '%s' error %d of 10: %#m\n",  v11,  v12,  v13,  v14,  a1 + 0x80);
    }

    if ((_DWORD)v15 != 16) {
      goto LABEL_48;
    }
    usleep(0x186A0u);
    uint64_t v9 = (v9 + 1);
    if ((_DWORD)v9 == 10)
    {
      uint64_t v9 = 10LL;
      goto LABEL_20;
    }
  }

void _SerialStreamReadHandler(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (!v2)
  {
LABEL_71:
    if (!*(_BYTE *)(a1 + 40))
    {
      *(_BYTE *)(a1 + 40) = 1;
      dispatch_suspend(*(dispatch_object_t *)(a1 + 32));
    }

    return;
  }

  uint64_t v3 = (void *)(a1 + 64);
  while (1)
  {
    uint64_t v4 = *(void *)(a1 + 64);
    int64_t v5 = *(void *)(a1 + 72);
    int v6 = *(_DWORD *)(v2 + 16);
    if ((v6 & 0x10000) != 0) {
      break;
    }
    if (v5 == v4)
    {
      size_t v7 = *(void *)(v2 + 40);
    }

    else
    {
      uint64_t v13 = *(void *)(v2 + 40);
      else {
        size_t v14 = *(void *)(v2 + 32) - v13;
      }
      memcpy((void *)(*(void *)(v2 + 48) + v13), (const void *)(*(void *)(a1 + 48) + v4), v14);
      *(void *)(a1 + 64) += v14;
      size_t v7 = *(void *)(v2 + 40) + v14;
      *(void *)(v2 + 40) = v7;
    }

    if (v7 >= *(void *)(v2 + 24)) {
      goto LABEL_50;
    }
    size_t v15 = *(void *)(v2 + 32) - v7;
    int v16 = (void *)(*(void *)(v2 + 48) + v7);
    while (1)
    {
      ssize_t v17 = read(*(_DWORD *)(a1 + 24), v16, v15);
      if ((v17 & 0x8000000000000000LL) == 0)
      {
        unsigned int v18 = 0;
        goto LABEL_44;
      }

      if (!*__error()) {
        break;
      }
      unsigned int v18 = *__error();
      if (v18 != 4) {
        goto LABEL_44;
      }
    }

    unsigned int v18 = -6700;
LABEL_44:
    if (v17) {
      uint64_t v24 = v18;
    }
    else {
      uint64_t v24 = 35LL;
    }
    if ((_DWORD)v24 == 35) {
      goto LABEL_69;
    }
    if ((_DWORD)v24) {
      goto LABEL_76;
    }
    unint64_t v25 = *(void *)(v2 + 40) + v17;
    *(void *)(v2 + 40) = v25;
    if (v25 >= *(void *)(v2 + 24)) {
      goto LABEL_50;
    }
LABEL_51:
    uint64_t v2 = *(void *)(a1 + 96);
    if (!v2) {
      goto LABEL_71;
    }
  }

  uint64_t v8 = *(_BYTE **)(a1 + 48);
  unint64_t v9 = (unint64_t)&v8[v4];
  if ((v6 & 4) != 0)
  {
    if (v5 > v4)
    {
      int v19 = &v8[v4];
      while (1)
      {
        int v20 = *v19;
        if (v20 == 7 || v20 == 13) {
          break;
        }
        if (++v19 >= &v8[v5]) {
          goto LABEL_32;
        }
      }

      *uint64_t v3 = v19 - v8 + 1;
      *(void *)(v2 + 4_Block_object_dispose(va, 8) = v9;
      if (*v19 == 7) {
        uint64_t v12 = (uint64_t)&v19[-v9 + 1];
      }
      else {
        uint64_t v12 = (uint64_t)&v19[-v9];
      }
      goto LABEL_42;
    }
  }

  else
  {
    if ((v6 & 2) != 0) {
      int v10 = 13;
    }
    else {
      int v10 = 10;
    }
    uint64_t v11 = memchr(&v8[v4], v10, v5 - v4);
    if (v11)
    {
      *uint64_t v3 = v11 - v8 + 1;
      *(void *)(v2 + 4_Block_object_dispose(va, 8) = v9;
      uint64_t v12 = (uint64_t)&v11[-v9];
LABEL_42:
      *(void *)(v2 + 40) = v12;
LABEL_50:
      _SerialStreamReadCompleted(a1, (void *)v2, 0LL);
      goto LABEL_51;
    }
  }

LABEL_76:
      _SerialStreamErrorHandler(a1, v24);
      return;
    }
  }

  else
  {
    uint64_t v23 = *(void *)(a1 + 56);
    size_t v22 = v23 - v5;
    if (v23 == v5)
    {
      if (!v4) {
        goto LABEL_53;
      }
      memmove(v8, &v8[v4], v5 - v4);
      size_t v22 = *(void *)(a1 + 64);
      int64_t v5 = *(void *)(a1 + 72) - v22;
      *(void *)(a1 + 64) = 0LL;
      *(void *)(a1 + 72) = v5;
      uint64_t v8 = *(_BYTE **)(a1 + 48);
    }
  }

void _SerialStreamCancelHandler(_DWORD *cf)
{
  int v2 = cf[7] - 1;
  cf[7] = v2;
  if (!v2)
  {
    int v3 = cf[6];
    if ((v3 & 0x80000000) == 0)
    {
      if (close(v3) && *__error()) {
        __error();
      }
      cf[6] = -1;
    }
  }

  CFRelease(cf);
}

void _SerialStreamWriteHandler(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 112);
  if (!v2)
  {
LABEL_22:
    if (!*(_BYTE *)(a1 + 88))
    {
      *(_BYTE *)(a1 + 8_Block_object_dispose(va, 8) = 1;
      dispatch_suspend(*(dispatch_object_t *)(a1 + 80));
    }

    return;
  }

  while (1)
  {
    do
    {
      ssize_t v3 = writev(*(_DWORD *)(a1 + 24), *(const iovec **)(v2 + 40), *(_DWORD *)(v2 + 32));
      if ((v3 & 0x8000000000000000LL) == 0)
      {
        unsigned int v4 = 0;
        break;
      }

      if (!*__error())
      {
        unsigned int v4 = -6700;
        break;
      }

      unsigned int v4 = *__error();
    }

    while (v4 == 4);
    if (v3) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 35LL;
    }
    if ((_DWORD)v5 == 35) {
      goto LABEL_20;
    }
    if ((_DWORD)v5) {
      break;
    }
    uint64_t updated = UpdateIOVec((uint64_t **)(v2 + 40), (int *)(v2 + 32), v3);
    if ((_DWORD)updated != 35)
    {
      uint64_t v5 = updated;
      if ((_DWORD)updated) {
        break;
      }
      _SerialStreamWriteCompleted(a1, (uint64_t *)v2, 0LL);
    }

    uint64_t v2 = *(void *)(a1 + 112);
    if (!v2) {
      goto LABEL_22;
    }
  }

  if (!(_DWORD)v5) {
    goto LABEL_22;
  }
  if ((_DWORD)v5 != 35)
  {
    _SerialStreamErrorHandler(a1, v5);
    return;
  }

uint64_t SerialStreamReadLine(dispatch_queue_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (char *)malloc(0x48uLL);
  if (!v8) {
    return 4294960568LL;
  }
  unint64_t v9 = v8;
  CFRetain(a1);
  *((void *)v9 + 1) = a1;
  *((_DWORD *)v9 + 4) = a2 | 0x10000;
  *(_OWORD *)(v9 + 24) = 0u;
  *(_OWORD *)(v9 + 40) = 0u;
  *((void *)v9 + 7) = a3;
  *((void *)v9 + _Block_object_dispose(va, 8) = a4;
  dispatch_async_f(a1[2], v9, (dispatch_function_t)_SerialStreamRead);
  return 0LL;
}

uint64_t SerialStreamReadLineSync(dispatch_queue_t *a1, int a2, void *a3, void *a4)
{
  dispatch_semaphore_t dsema = dispatch_semaphore_create(0LL);
  if (dsema)
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    unsigned int Line = SerialStreamReadLine(a1, a2, (uint64_t)_SerialStreamReadLineSyncCompletion, (uint64_t)&dsema);
    if (!Line)
    {
      dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
      *a3 = v11;
      if (a4) {
        *a4 = v12;
      }
    }

    if (dsema) {
      dispatch_release(dsema);
    }
  }

  else
  {
    return -6700;
  }

  return Line;
}

uint64_t _SerialStreamReadLineSyncCompletion(int a1, const void *a2, size_t a3, uint64_t a4)
{
  if (a1)
  {
    int v6 = 0LL;
  }

  else
  {
    uint64_t v8 = malloc(a3 + 1);
    int v6 = v8;
    if (v8)
    {
      if (a3) {
        memcpy(v8, a2, a3);
      }
      a1 = 0;
      v6[a3] = 0;
    }

    else
    {
      a1 = -6728;
    }
  }

  *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = a1;
  *(void *)(a4 + 16) = v6;
  *(void *)(a4 + 24) = a3;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)a4);
}

uint64_t SerialStreamReadSync(dispatch_queue_t *a1, uint64_t a2, uint64_t a3, char *a4, void *a5)
{
  dispatch_semaphore_t dsema = dispatch_semaphore_create(0LL);
  if (!dsema) {
    return 4294960596LL;
  }
  uint64_t result = SerialStreamRead(a1, a2, a3, a4, (uint64_t)_SerialStreamReadSyncCompletion, (uint64_t)&dsema);
  unsigned int v12 = result;
  if (!(_DWORD)result)
  {
    dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
    uint64_t result = v12;
    if (a5)
    {
      if (!v12) {
        *a5 = v13;
      }
    }
  }

  if (dsema)
  {
    dispatch_release(dsema);
    return v12;
  }

  return result;
}

uint64_t _SerialStreamReadSyncCompletion(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = a1;
  *(void *)(a4 + 24) = a3;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)a4);
}

uint64_t SerialStreamWrite(dispatch_queue_t *a1, char a2, char *a3, int a4, uint64_t a5, uint64_t a6)
{
  int v8 = a4;
  unint64_t v9 = a3;
  if ((a2 & 1) == 0)
  {
    uint64_t v11 = malloc(0x40uLL);
    if (!v11) {
      return 4294960568LL;
    }
LABEL_14:
    v11[8] = v8;
    *((void *)v11 + 5) = v9;
    CFRetain(a1);
    *((void *)v11 + 1) = a1;
    *((void *)v11 + 6) = a5;
    *((void *)v11 + 7) = a6;
    dispatch_async_f(a1[2], v11, (dispatch_function_t)_SerialStreamWrite);
    return 0LL;
  }

  if (a4 >= 1)
  {
    uint64_t v12 = a4;
    uint64_t v13 = (uint64_t *)(a3 + 8);
    size_t v14 = 64LL;
    uint64_t v15 = a4;
    do
    {
      uint64_t v16 = *v13;
      v13 += 2;
      v14 += v16;
      --v15;
    }

    while (v15);
    ssize_t v17 = malloc(v14);
    if (!v17) {
      return 4294960568LL;
    }
    uint64_t v11 = v17;
    uint64_t v18 = 0LL;
    int v19 = (size_t *)(v9 + 8);
    do
    {
      size_t v20 = *v19;
      memcpy((char *)v11 + v18 + 64, (const void *)*(v19 - 1), *v19);
      v18 += v20;
      v19 += 2;
      --v12;
    }

    while (v12);
    goto LABEL_13;
  }

  dispatch_source_t v21 = malloc(0x40uLL);
  if (v21)
  {
    uint64_t v11 = v21;
    uint64_t v18 = 0LL;
LABEL_13:
    *((void *)v11 + 2) = v11 + 16;
    *((void *)v11 + 3) = v18;
    unint64_t v9 = (char *)(v11 + 4);
    int v8 = 1;
    goto LABEL_14;
  }

  return 4294960568LL;
}

void _SerialStreamWrite( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[1];
  *a1 = 0LL;
  **(void **)(v8 + 120) = a1;
  *(void *)(v8 + 120) = a1;
  uint64_t v9 = _SerialStreamEnsureSetUp(v8, a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)v9) {
    _SerialStreamErrorHandler(v8, v9);
  }
  else {
    _SerialStreamWriteHandler(v8);
  }
}

uint64_t SerialStreamWriteSync(dispatch_queue_t *a1, char *a2, int a3)
{
  dispatch_semaphore_t dsema = dispatch_semaphore_create(0LL);
  if (dsema)
  {
    unsigned int v8 = SerialStreamWrite(a1, 0, a2, a3, (uint64_t)_SerialStreamWriteSyncCompletion, (uint64_t)&dsema);
    if (!v8) {
      dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
    }
    if (dsema) {
      dispatch_release(dsema);
    }
  }

  else
  {
    return -6700;
  }

  return v8;
}

uint64_t _SerialStreamWriteSyncCompletion(int a1, uint64_t a2)
{
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = a1;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)a2);
}

uint64_t _SHA3_Block(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = *a2 ^ *a1;
  uint64_t v4 = a2[1] ^ a1[1];
  uint64_t v5 = a2[2] ^ a1[2];
  uint64_t v82 = a2[3] ^ a1[3];
  uint64_t v81 = a2[4] ^ a1[4];
  uint64_t v79 = a2[5] ^ a1[5];
  uint64_t v77 = a2[6] ^ a1[6];
  uint64_t v80 = a2[7] ^ a1[7];
  uint64_t v6 = a1[9];
  uint64_t v78 = a2[8] ^ a1[8];
  uint64_t v7 = a1[10];
  uint64_t v8 = a1[11];
  uint64_t v10 = a1[12];
  uint64_t v9 = a1[13];
  uint64_t v11 = a1[14];
  uint64_t v12 = a1[15];
  uint64_t v13 = a1[16];
  uint64_t v14 = a1[17];
  uint64_t v16 = a1[18];
  uint64_t v15 = a1[19];
  uint64_t v18 = a1[20];
  uint64_t v17 = a1[21];
  uint64_t v19 = a1[22];
  uint64_t v20 = a1[23];
  uint64_t v21 = a1[24];
  do
  {
    uint64_t v73 = v7;
    uint64_t v74 = v8;
    uint64_t v75 = v20;
    uint64_t v22 = v18 ^ v12 ^ v7 ^ v79;
    uint64_t v23 = v17 ^ v13 ^ v8 ^ v77 ^ v4;
    uint64_t v76 = v14;
    uint64_t v24 = v11;
    uint64_t v25 = v15 ^ v11 ^ v21 ^ v6 ^ v81;
    uint64_t v26 = v25 ^ __ROR8__(v23, 63);
    uint64_t v27 = v16 ^ v9 ^ v20 ^ v78 ^ v82;
    uint64_t v28 = v23 ^ __ROR8__(v27, 63);
    uint64_t v29 = v22 ^ v3;
    uint64_t v30 = v27 ^ __ROR8__(v29, 63);
    uint64_t v31 = v14 ^ v10 ^ v19 ^ v80 ^ v5;
    uint64_t v32 = v29 ^ __ROR8__(v31, 63);
    uint64_t v33 = v30 ^ v21;
    uint64_t v34 = v15;
    uint64_t v35 = v31 ^ __ROR8__(v25, 63);
    uint64_t v36 = v35 ^ v16;
    uint64_t v37 = __ROR8__(v33, 50) & ~__ROR8__(v35 ^ v16, 43);
    uint64_t v38 = v26 ^ v3;
    uint64_t v39 = v35 ^ v82;
    uint64_t v82 = v38 & ~__ROR8__(v33, 50) ^ __ROR8__(v36, 43);
    uint64_t v40 = v28 ^ v10;
    uint64_t v41 = __ROR8__(v36, 43) & ~__ROR8__(v28 ^ v10, 21);
    uint64_t v42 = v28 ^ v5;
    uint64_t v71 = v37 ^ __ROR8__(v40, 21);
    uint64_t v72 = __ROR8__(v40, 21) & ~__ROR8__(v32 ^ v77, 20);
    uint64_t v43 = v26 ^ v79;
    uint64_t v44 = v32 ^ v4;
    uint64_t v45 = v2;
    uint64_t v46 = v41 ^ __ROR8__(v32 ^ v77, 20);
    uint64_t v47 = v26 ^ v73;
    uint64_t v48 = v26 ^ v12;
    uint64_t v49 = v26 ^ v18;
    uint64_t v50 = v30 ^ v81;
    uint64_t v51 = v30 ^ v6;
    uint64_t v52 = __ROR8__(v30 ^ v6, 44);
    uint64_t v81 = __ROR8__(v32 ^ v77, 20) & ~v38 ^ __ROR8__(v33, 50);
    uint64_t v53 = v32 ^ v74;
    uint64_t v54 = v32 ^ v13;
    uint64_t v55 = v28 ^ v19;
    uint64_t v56 = v32 ^ v17;
    uint64_t v57 = v28 ^ v80;
    uint64_t v58 = v28 ^ v76;
    uint64_t v59 = v35 ^ v78;
    uint64_t v60 = v35 ^ v9;
    uint64_t v61 = v35 ^ v75;
    uint64_t v62 = v30 ^ v24;
    uint64_t v63 = v30 ^ v34;
    uint64_t v64 = __ROR8__(v60, 39);
    uint64_t v77 = __ROR8__(v54, 19) & ~__ROR8__(v47, 61) ^ __ROR8__(v51, 44);
    uint64_t v80 = __ROR8__(v55, 3) & ~__ROR8__(v54, 19) ^ __ROR8__(v47, 61);
    uint64_t v78 = __ROR8__(v39, 36) & ~__ROR8__(v55, 3) ^ __ROR8__(v54, 19);
    uint64_t v79 = __ROR8__(v47, 61) & ~__ROR8__(v51, 44) ^ __ROR8__(v39, 36);
    uint64_t v6 = v52 & ~__ROR8__(v39, 36) ^ __ROR8__(v55, 3);
    uint64_t v65 = __ROR8__(v49, 46) & ~__ROR8__(v63, 56) ^ v64;
    uint64_t v9 = __ROR8__(v44, 63) & ~__ROR8__(v49, 46) ^ __ROR8__(v63, 56);
    uint64_t v66 = v64 & ~__ROR8__(v57, 58);
    uint64_t v8 = __ROR8__(v63, 56) & ~v64 ^ __ROR8__(v57, 58);
    uint64_t v7 = v66 ^ __ROR8__(v44, 63);
    uint64_t v11 = __ROR8__(v57, 58) & ~__ROR8__(v44, 63) ^ __ROR8__(v49, 46);
    uint64_t v14 = __ROR8__(v61, 8) & ~__ROR8__(v58, 49) ^ __ROR8__(v53, 54);
    uint64_t result = __ROR8__(v58, 49) & ~__ROR8__(v53, 54) ^ __ROR8__(v43, 28);
    uint64_t v4 = v46;
    uint64_t v68 = v45;
    uint64_t v16 = __ROR8__(v50, 37) & ~__ROR8__(v61, 8) ^ __ROR8__(v58, 49);
    uint64_t v12 = __ROR8__(v53, 54) & ~__ROR8__(v43, 28) ^ __ROR8__(v50, 37);
    uint64_t v15 = __ROR8__(v43, 28) & ~__ROR8__(v50, 37) ^ __ROR8__(v61, 8);
    uint64_t v20 = __ROR8__(v42, 2) & ~__ROR8__(v56, 62) ^ __ROR8__(v48, 23);
    uint64_t v19 = __ROR8__(v56, 62) & ~__ROR8__(v48, 23) ^ __ROR8__(v62, 25);
    uint64_t v5 = v71;
    uint64_t v17 = __ROR8__(v48, 23) & ~__ROR8__(v62, 25) ^ __ROR8__(v59, 9);
    uint64_t v3 = v72 ^ *(uint64_t *)((char *)&kSHA3RoundConstants + v68) ^ v38;
    uint64_t v18 = __ROR8__(v62, 25) & ~__ROR8__(v59, 9) ^ __ROR8__(v42, 2);
    uint64_t v69 = __ROR8__(v59, 9) & ~__ROR8__(v42, 2);
    uint64_t v10 = v65;
    uint64_t v13 = result;
    uint64_t v21 = v69 ^ __ROR8__(v56, 62);
    uint64_t v2 = v68 + 8;
  }

  while (v2 != 192);
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v71;
  a1[3] = v82;
  a1[4] = v81;
  a1[5] = v79;
  a1[6] = v77;
  a1[7] = v80;
  a1[8] = v78;
  a1[9] = v6;
  a1[10] = v7;
  a1[11] = v8;
  a1[12] = v10;
  a1[13] = v9;
  a1[14] = v11;
  a1[15] = v12;
  a1[16] = result;
  a1[17] = v14;
  a1[18] = v16;
  a1[19] = v15;
  a1[20] = v18;
  a1[21] = v17;
  a1[22] = v19;
  a1[23] = v20;
  a1[24] = v21;
  return result;
}

uint64_t HMAC_SHA1_Init(CC_SHA1_CTX *c, unsigned __int8 *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a3 < 0x41)
  {
    if (!a3)
    {
LABEL_7:
      memset(&data[v3], 54, 64 - v3);
      memset((char *)&c[1] + v3, 92, 64 - v3);
      goto LABEL_8;
    }
  }

  else
  {
    CC_SHA1_Init(c);
    CC_SHA1_Update(c, a2, v3);
    a2 = md;
    CC_SHA1_Final(md, c);
    unint64_t v3 = 20LL;
  }

  uint64_t v6 = 0LL;
  do
  {
    unsigned __int8 v7 = a2[v6];
    data[v6] = v7 ^ 0x36;
    *((_BYTE *)&c[1].h0 + v6++) = v7 ^ 0x5C;
  }

  while (v3 != v6);
  if (v3 <= 0x3F) {
    goto LABEL_7;
  }
LABEL_8:
  CC_SHA1_Init(c);
  return CC_SHA1_Update(c, data, 0x40u);
}

uint64_t HMAC_SHA1_Final(CC_SHA1_CTX *c, unsigned __int8 *md)
{
  return CC_SHA1_Final(md, c);
}

void *PBKDF2_HMAC_SHA1(char *__s, size_t a2, char *a3, uint64_t a4, uint64_t a5)
{
  size_t v7 = a2;
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a2 == -1LL) {
    size_t v7 = strlen(__s);
  }
  if (a4 == -1) {
    LODWORD(a4) = strlen(a3);
  }
  uint64_t v9 = 0LL;
  unint64_t v10 = 32LL;
  int data = 0x1000000;
  do
  {
    HMAC_SHA1_Init(&c, (unsigned __int8 *)__s, v7);
    CC_SHA1_Update(&c, a3, a4);
    CC_SHA1_Update(&c, &data, 4u);
    HMAC_SHA1_Final(&c, __src);
    for (int i = 1; i != 4096; ++i)
    {
      HMAC_SHA1_Init(&c, (unsigned __int8 *)__s, v7);
      if (i == 1) {
        uint64_t v12 = __src;
      }
      else {
        uint64_t v12 = md;
      }
      CC_SHA1_Update(&c, v12, 0x14u);
      HMAC_SHA1_Final(&c, md);
      for (uint64_t j = 0LL; j != 20; ++j)
        __src[j] ^= md[j];
    }

    if (v10 >= 0x14) {
      size_t v14 = 20LL;
    }
    else {
      size_t v14 = v10;
    }
    uint64_t result = memcpy((void *)(a5 + v9), __src, v14);
    v9 += v14;
    v10 -= v14;
    uint64_t v16 = 3LL;
    do
    {
      if (v16 == -1) {
        break;
      }
      __int16 v17 = ++md[v16-- - 4];
    }

    while ((v17 & 0x100) != 0);
  }

  while (v10);
  return result;
}

uint64_t srp6a_client_init(void *a1)
{
  *a1 = 0x30000000CLL;
  a1[13] = malloc(0x1E0uLL);
  (*(void (**)(void))(a1[18] + 16LL))();
  (*(void (**)(uint64_t))(a1[18] + 16LL))(a1[13] + 208LL);
  return 0LL;
}

uint64_t srp6_client_finish(uint64_t a1)
{
  id v1 = *(_OWORD **)(a1 + 104);
  if (v1)
  {
    v1[28] = 0u;
    v1[29] = 0u;
    v1[26] = 0u;
    v1[27] = 0u;
    v1[24] = 0u;
    v1[25] = 0u;
    v1[22] = 0u;
    v1[23] = 0u;
    v1[20] = 0u;
    v1[21] = 0u;
    v1[18] = 0u;
    v1[19] = 0u;
    v1[16] = 0u;
    v1[17] = 0u;
    v1[14] = 0u;
    v1[15] = 0u;
    v1[12] = 0u;
    v1[13] = 0u;
    v1[10] = 0u;
    v1[11] = 0u;
    v1[8] = 0u;
    v1[9] = 0u;
    v1[6] = 0u;
    v1[7] = 0u;
    v1[4] = 0u;
    v1[5] = 0u;
    v1[2] = 0u;
    v1[3] = 0u;
    *id v1 = 0u;
    v1[1] = 0u;
    free(*(void **)(a1 + 104));
  }

  return 0LL;
}

uint64_t srp6_client_params(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  (*(void (**)(_BYTE *))(*(void *)(a1 + 144) + 16LL))(v17);
  (*(void (**)(_BYTE *, uint64_t, void))(*(void *)(a1 + 144) + 24LL))(v17, a2, a3);
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)(a1 + 144) + 32LL))(v19, v17);
  (*(void (**)(_BYTE *))(*(void *)(a1 + 144) + 16LL))(v17);
  (*(void (**)(_BYTE *, uint64_t, void))(*(void *)(a1 + 144) + 24LL))(v17, a4, a5);
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)(a1 + 144) + 32LL))(v18, v17);
  uint64_t v14 = *(void *)(a1 + 144);
  if ((int)*(void *)v14 >= 1)
  {
    uint64_t v15 = 0LL;
    do
    {
      v19[v15] ^= v18[v15];
      ++v15;
    }

    while (v15 < (int)*(void *)v14);
  }

  (*(void (**)(void, _BYTE *))(v14 + 24))(*(void *)(a1 + 104), v19);
  (*(void (**)(_BYTE *))(*(void *)(a1 + 144) + 16LL))(v17);
  (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))( v17,  **(void **)(a1 + 8),  *(int *)(*(void *)(a1 + 8) + 8LL));
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)(a1 + 144) + 32LL))(v19, v17);
  (*(void (**)(void, _BYTE *, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104),  v19,  **(void **)(a1 + 144));
  (*(void (**)(void, uint64_t, void))(*(void *)(a1 + 144) + 24LL))(*(void *)(a1 + 104), a6, a7);
  return 0LL;
}

uint64_t srp6_client_auth(uint64_t a1)
{
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = CCBigNumFromData();
  *(void *)(a1 + 40) = BigIntegerFromInt();
  CCBigNumModExp();
  return 0LL;
}

uint64_t srp6_client_passwd(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  (*(void (**)(_OWORD *))(*(void *)(a1 + 144) + 16LL))(v8);
  (*(void (**)(_OWORD *, void, void))(*(void *)(a1 + 144) + 24LL))( v8,  **(void **)(a1 + 8),  *(int *)(*(void *)(a1 + 8) + 8LL));
  (*(void (**)(_OWORD *, const char *, uint64_t))(*(void *)(a1 + 144) + 24LL))(v8, ":", 1LL);
  (*(void (**)(_OWORD *, uint64_t, void))(*(void *)(a1 + 144) + 24LL))(v8, a2, a3);
  (*(void (**)(_BYTE *, _OWORD *))(*(void *)(a1 + 144) + 32LL))(v9, v8);
  (*(void (**)(_OWORD *))(*(void *)(a1 + 144) + 16LL))(v8);
  (*(void (**)(_OWORD *, void, void))(*(void *)(a1 + 144) + 24LL))( v8,  **(void **)(a1 + 32),  *(int *)(*(void *)(a1 + 32) + 8LL));
  (*(void (**)(_OWORD *, _BYTE *, void))(*(void *)(a1 + 144) + 24LL))(v8, v9, **(void **)(a1 + 144));
  (*(void (**)(_BYTE *, _OWORD *))(*(void *)(a1 + 144) + 32LL))(v9, v8);
  memset(v8, 0, sizeof(v8));
  uint64_t v6 = (*(uint64_t (**)(uint64_t, _BYTE *, void))(*(void *)(a1 + 96) + 32LL))( a1,  v9,  **(unsigned int **)(a1 + 144));
  __memset_chk();
  return v6;
}

uint64_t srp6_client_genpub(uint64_t *a1, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v4 = (void *)*a2;
    if (!*a2)
    {
      uint64_t v5 = (uint64_t (**)())default_alloc;
      if (!default_alloc)
      {
        uint64_t v5 = malloc_allocator;
        default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
      }

      uint64_t v6 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v5)(32LL, v5[2]);
      uint64_t v4 = (void *)v6;
      if (v6)
      {
        *(void *)uint64_t v6 = &cstr_empty_string;
        *(void *)(v6 + _Block_object_dispose(va, 8) = 0LL;
        *(_DWORD *)(v6 + 16) = 1;
        *(void *)(v6 + 24) = v5;
      }

      *a2 = v6;
    }
  }

  else
  {
    size_t v7 = (uint64_t (**)())default_alloc;
    if (!default_alloc)
    {
      size_t v7 = malloc_allocator;
      default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
    }

    uint64_t v8 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v7)(32LL, v7[2]);
    uint64_t v4 = (void *)v8;
    if (v8)
    {
      *(void *)uint64_t v8 = &cstr_empty_string;
      *(void *)(v8 + _Block_object_dispose(va, 8) = 0LL;
      *(_DWORD *)(v8 + 16) = 1;
      *(void *)(v8 + 24) = v7;
    }
  }

  int v9 = CCBigNumBitCount();
  int v10 = v9 + 7;
  if (v9 < -7) {
    int v10 = v9 + 14;
  }
  cstr_set_length((uint64_t)v4, v10 >> 3);
  RandomBytes((void *)*v4, 0x20uLL);
  a1[8] = CCBigNumFromData();
  CCBigNumBitCount();
  CCBigNumAddI();
  a1[7] = BigIntegerFromInt();
  CCBigNumModExp();
  BigIntegerToCstr(a1[7], (uint64_t)v4);
  (*(void (**)(uint64_t, void, void))(a1[18] + 24))(a1[13], *v4, *((int *)v4 + 2));
  (*(void (**)(uint64_t, void, void))(a1[18] + 24))(a1[13] + 208, *v4, *((int *)v4 + 2));
  if (!a2) {
    cstr_clear_free((uint64_t)v4);
  }
  return 0LL;
}

uint64_t srp6a_client_key(uint64_t a1, uint64_t *a2, const void *a3, int a4)
{
  LODWORD(v4) = a4;
  uint64_t v31 = *MEMORY[0x1895F89C0];
  (*(void (**)(_BYTE *))(*(void *)(a1 + 144) + 16LL))(v27);
  uint64_t v8 = (uint64_t (**)())default_alloc;
  if (!default_alloc)
  {
    uint64_t v8 = malloc_allocator;
    default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
  }

  uint64_t v9 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v8)(32LL, v8[2]);
  int v10 = (void *)v9;
  if (v9)
  {
    *(void *)uint64_t v9 = &cstr_empty_string;
    *(void *)(v9 + _Block_object_dispose(va, 8) = 0LL;
    *(_DWORD *)(v9 + 16) = 1;
    *(void *)(v9 + 24) = v8;
  }

  BigIntegerToCstr(*(void *)(a1 + 16), v9);
  (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v27, *v10, *((int *)v10 + 2));
  uint64_t v11 = *(void *)(a1 + 24);
  if ((*(_BYTE *)(a1 + 4) & 2) != 0) {
    BigIntegerToCstrEx(v11, (const void **)v10, *((_DWORD *)v10 + 2));
  }
  else {
    BigIntegerToCstr(v11, (uint64_t)v10);
  }
  (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v27, *v10, *((int *)v10 + 2));
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)(a1 + 144) + 32LL))(v29, v27);
  cstr_free((uint64_t)v10);
  CCBigNumFromData();
  int v12 = CCBigNumBitCount();
  int v13 = v12 + 7;
  if (v12 < -7) {
    int v13 = v12 + 14;
  }
  int v14 = v13 >> 3;
  (*(void (**)(_BYTE *))(*(void *)(a1 + 144) + 16LL))(v28);
  uint64_t v15 = (uint64_t (**)())default_alloc;
  if (!default_alloc)
  {
    uint64_t v15 = malloc_allocator;
    default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
  }

  uint64_t v16 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v15)(32LL, v15[2]);
  __int16 v17 = (void *)v16;
  if (v16)
  {
    *(void *)uint64_t v16 = &cstr_empty_string;
    *(void *)(v16 + _Block_object_dispose(va, 8) = 0LL;
    *(_DWORD *)(v16 + 16) = 1;
    *(void *)(v16 + 24) = v15;
  }

  uint64_t v18 = *(void *)(a1 + 56);
  if ((*(_BYTE *)(a1 + 4) & 2) == 0)
  {
    BigIntegerToCstr(v18, (uint64_t)v17);
    (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v28, *v17, *((int *)v17 + 2));
LABEL_20:
    uint64_t v4 = (int)v4;
    (*(void (**)(_BYTE *, const void *, void))(*(void *)(a1 + 144) + 24LL))(v28, a3, (int)v4);
    goto LABEL_21;
  }

  BigIntegerToCstrEx(v18, (const void **)v17, v14);
  (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v28, *v17, *((int *)v17 + 2));
  int v19 = v14 - v4;
  size_t v20 = v19;
  uint64_t v4 = (int)v4;
  memcpy((void *)(*v17 + v19), a3, (int)v4);
  bzero((void *)*v17, v20);
  (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v28, *v17, v14);
LABEL_21:
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)(a1 + 144) + 32LL))(v30, v28);
  *(void *)(a1 + 72) = CCBigNumFromData();
  (*(void (**)(void, const void *, uint64_t))(*(void *)(a1 + 144) + 24LL))(*(void *)(a1 + 104), a3, v4);
  uint64_t v21 = CCBigNumFromData();
  if ((MEMORY[0x186E41A30](v21, *(void *)(a1 + 16)) & 0x80000000) == 0
    || !MEMORY[0x186E41A3C](v21, 0LL))
  {
    CCBigNumFree();
    cstr_clear_free((uint64_t)v17);
LABEL_23:
    uint64_t v22 = 0xFFFFFFFFLL;
    goto LABEL_24;
  }

  BigIntegerFromInt();
  *(void *)(a1 + 80) = BigIntegerFromInt();
  CCBigNumSub();
  CCBigNumMul();
  CCBigNumAdd();
  CCBigNumMod();
  CCBigNumMul();
  CCBigNumAdd();
  CCBigNumModExp();
  CCBigNumFree();
  CCBigNumFree();
  BigIntegerToCstr(*(void *)(a1 + 80), (uint64_t)v17);
  uint64_t v24 = *(void *)(a1 + 144);
  if (*(void *)(v24 + 8) == 40LL)
  {
    t_mgf1(*(void *)(a1 + 104) + 416LL, (const void *)*v17, *((_DWORD *)v17 + 2));
  }

  else
  {
    (*(void (**)(_BYTE *))(v24 + 16))(v28);
    (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v28, *v17, *((int *)v17 + 2));
    (*(void (**)(uint64_t, _BYTE *))(*(void *)(a1 + 144) + 32LL))(*(void *)(a1 + 104) + 416LL, v28);
  }

  cstr_clear_free((uint64_t)v17);
  (*(void (**)(void, uint64_t, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104),  *(void *)(a1 + 104) + 416LL,  *(void *)(*(void *)(a1 + 144) + 8LL));
  uint64_t v25 = *(void *)(a1 + 88);
  if (a2)
  {
    uint64_t v26 = *a2;
    if (!*a2)
    {
      uint64_t v26 = cstr_new();
      *a2 = v26;
    }

    cstr_setn(v26, (const void *)(*(void *)(a1 + 104) + 416LL), *(_DWORD *)(*(void *)(a1 + 144) + 8LL));
  }

  uint64_t v22 = 0LL;
LABEL_24:
  CCBigNumFree();
  return v22;
}

uint64_t srp6_client_verify(uint64_t a1, const void *a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  (*(void (**)(_BYTE *, uint64_t))(*(void *)(a1 + 144) + 32LL))(__s1, *(void *)(a1 + 104) + 208LL);
  if (**(_DWORD **)(a1 + 144) != a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = memcmp(__s1, a2, a3);
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t srp6_client_respond(uint64_t a1, void **a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *a2;
  if (!*a2)
  {
    uint64_t v5 = (uint64_t (**)())default_alloc;
    if (!default_alloc)
    {
      uint64_t v5 = malloc_allocator;
      default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
    }

    uint64_t v4 = (void *)((uint64_t (*)(uint64_t, uint64_t (*)()))*v5)(32LL, v5[2]);
    if (v4)
    {
      *uint64_t v4 = &cstr_empty_string;
      v4[1] = 0LL;
      *((_DWORD *)v4 + 4) = 1;
      v4[3] = v5;
    }

    *a2 = v4;
  }

  cstr_set_length((uint64_t)v4, **(_DWORD **)(a1 + 144));
  (*(void (**)(void, void))(*(void *)(a1 + 144) + 32LL))(**a2, *(void *)(a1 + 104));
  (*(void (**)(uint64_t, void, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 208LL,  **a2,  *((int *)*a2 + 2));
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 208LL,  *(void *)(a1 + 104) + 416LL,  *(void *)(*(void *)(a1 + 144) + 8LL));
  return 0LL;
}

uint64_t srp6_server_finish(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 104);
  if (v2)
  {
    bzero(v2, 0x3C0uLL);
    free(*(void **)(a1 + 104));
  }

  return 0LL;
}

uint64_t srp6_server_params(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  (*(void (**)(_BYTE *))(*(void *)(a1 + 144) + 16LL))(v17);
  (*(void (**)(_BYTE *, uint64_t, void))(*(void *)(a1 + 144) + 24LL))(v17, a2, a3);
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)(a1 + 144) + 32LL))(v19, v17);
  (*(void (**)(_BYTE *))(*(void *)(a1 + 144) + 16LL))(v17);
  (*(void (**)(_BYTE *, uint64_t, void))(*(void *)(a1 + 144) + 24LL))(v17, a4, a5);
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)(a1 + 144) + 32LL))(v18, v17);
  uint64_t v14 = *(void *)(a1 + 144);
  if ((int)*(void *)v14 >= 1)
  {
    uint64_t v15 = 0LL;
    do
    {
      v19[v15] ^= v18[v15];
      ++v15;
    }

    while (v15 < (int)*(void *)v14);
  }

  (*(void (**)(uint64_t, _BYTE *))(v14 + 24))(*(void *)(a1 + 104) + 208LL, v19);
  (*(void (**)(_BYTE *))(*(void *)(a1 + 144) + 16LL))(v17);
  (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))( v17,  **(void **)(a1 + 8),  *(int *)(*(void *)(a1 + 8) + 8LL));
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)(a1 + 144) + 32LL))(v19, v17);
  (*(void (**)(uint64_t, _BYTE *, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 208LL,  v19,  **(void **)(a1 + 144));
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 208LL,  a6,  a7);
  return 0LL;
}

uint64_t srp6_server_auth(uint64_t a1)
{
  *(void *)(a1 + 40) = CCBigNumFromData();
  return 0LL;
}

uint64_t srp6_server_passwd(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  (*(void (**)(_OWORD *))(*(void *)(a1 + 144) + 16LL))(v7);
  (*(void (**)(_OWORD *, void, void))(*(void *)(a1 + 144) + 24LL))( v7,  **(void **)(a1 + 8),  *(int *)(*(void *)(a1 + 8) + 8LL));
  (*(void (**)(_OWORD *, const char *, uint64_t))(*(void *)(a1 + 144) + 24LL))(v7, ":", 1LL);
  (*(void (**)(_OWORD *, uint64_t, void))(*(void *)(a1 + 144) + 24LL))(v7, a2, a3);
  (*(void (**)(_BYTE *, _OWORD *))(*(void *)(a1 + 144) + 32LL))(v8, v7);
  (*(void (**)(_OWORD *))(*(void *)(a1 + 144) + 16LL))(v7);
  (*(void (**)(_OWORD *, void, void))(*(void *)(a1 + 144) + 24LL))( v7,  **(void **)(a1 + 32),  *(int *)(*(void *)(a1 + 32) + 8LL));
  (*(void (**)(_OWORD *, _BYTE *, void))(*(void *)(a1 + 144) + 24LL))(v7, v8, **(void **)(a1 + 144));
  (*(void (**)(_BYTE *, _OWORD *))(*(void *)(a1 + 144) + 32LL))(v8, v7);
  memset(v7, 0, sizeof(v7));
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = CCBigNumFromData();
  __memset_chk();
  *(void *)(a1 + 40) = BigIntegerFromInt();
  CCBigNumModExp();
  return 0LL;
}

uint64_t srp6_server_key(uint64_t a1, uint64_t *a2, const void *a3, int a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v8 = CCBigNumBitCount();
  int v9 = v8 + 7;
  if (v8 < -7) {
    int v9 = v8 + 14;
  }
  int v10 = v9 >> 3;
  if (v9 >> 3 < a4) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(uint64_t, const void *, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 208LL,  a3,  a4);
  uint64_t v11 = (uint64_t (**)())default_alloc;
  if (!default_alloc)
  {
    uint64_t v11 = malloc_allocator;
    default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
  }

  uint64_t v12 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v11)(32LL, v11[2]);
  int v13 = (void *)v12;
  if (v12)
  {
    *(void *)uint64_t v12 = &cstr_empty_string;
    *(void *)(v12 + _Block_object_dispose(va, 8) = 0LL;
    *(_DWORD *)(v12 + 16) = 1;
    *(void *)(v12 + 24) = v11;
  }

  BigIntegerToCstr(*(void *)(a1 + 56), v12);
  (*(void (**)(uint64_t, void, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 208LL,  *v13,  *((int *)v13 + 2));
  (*(void (**)(void, const void *, void))(*(void *)(a1 + 144) + 24LL))(*(void *)(a1 + 104), a3, a4);
  (*(void (**)(uint64_t, const void *, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 416LL,  a3,  a4);
  (*(void (**)(_BYTE *))(*(void *)(a1 + 144) + 16LL))(v22);
  if ((*(_BYTE *)(a1 + 4) & 2) != 0)
  {
    int v14 = v10 - a4;
    if (v10 <= a4)
    {
      (*(void (**)(_BYTE *, const void *, void))(*(void *)(a1 + 144) + 24LL))(v22, a3, a4);
      if (*((_DWORD *)v13 + 2) >= v10) {
        goto LABEL_14;
      }
    }

    else
    {
      cstr_set_length((uint64_t)v13, v10);
      memcpy((void *)(*v13 + v14), a3, a4);
      bzero((void *)*v13, v14);
      (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v22, *v13, v10);
    }

    BigIntegerToCstrEx(*(void *)(a1 + 56), (const void **)v13, v10);
    goto LABEL_14;
  }

  (*(void (**)(_BYTE *, const void *, void))(*(void *)(a1 + 144) + 24LL))(v22, a3, a4);
LABEL_14:
  (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v22, *v13, *((int *)v13 + 2));
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)(a1 + 144) + 32LL))(v23, v22);
  *(void *)(a1 + 72) = CCBigNumFromData();
  uint64_t v15 = BigIntegerFromInt();
  CCBigNumModExp();
  CCBigNumFromData();
  uint64_t v16 = BigIntegerFromInt();
  CCBigNumMulMod();
  CCBigNumFree();
  if ((int)MEMORY[0x186E41A3C](v16, 1LL) <= 0
    || (CCBigNumAddI(), !MEMORY[0x186E41A30](v15, *(void *)(a1 + 16))))
  {
    CCBigNumFree();
    CCBigNumFree();
    cstr_free((uint64_t)v13);
    return 0xFFFFFFFFLL;
  }

  *(void *)(a1 + 80) = BigIntegerFromInt();
  CCBigNumModExp();
  CCBigNumFree();
  CCBigNumFree();
  BigIntegerToCstr(*(void *)(a1 + 80), (uint64_t)v13);
  uint64_t v17 = *(void *)(a1 + 144);
  if (*(void *)(v17 + 8) == 40LL)
  {
    t_mgf1(*(void *)(a1 + 104) + 832LL, (const void *)*v13, *((_DWORD *)v13 + 2));
  }

  else
  {
    (*(void (**)(_BYTE *))(v17 + 16))(v22);
    (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v22, *v13, *((int *)v13 + 2));
    (*(void (**)(uint64_t, _BYTE *))(*(void *)(a1 + 144) + 32LL))(*(void *)(a1 + 104) + 832LL, v22);
  }

  cstr_clear_free((uint64_t)v13);
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 208LL,  *(void *)(a1 + 104) + 832LL,  *(void *)(*(void *)(a1 + 144) + 8LL));
  uint64_t v19 = *(void *)(a1 + 88);
  if (*(int *)(v19 + 8) >= 1) {
    (*(void (**)(uint64_t, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 208LL,  *(void *)v19);
  }
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 416LL,  *(void *)(a1 + 104) + 832LL,  *(void *)(*(void *)(a1 + 144) + 8LL));
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 624LL,  *(void *)(a1 + 104) + 832LL,  *(void *)(*(void *)(a1 + 144) + 8LL));
  if (a2)
  {
    uint64_t v20 = *a2;
    if (!*a2)
    {
      uint64_t v21 = (uint64_t (**)())default_alloc;
      if (!default_alloc)
      {
        uint64_t v21 = malloc_allocator;
        default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
      }

      uint64_t v20 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v21)(32LL, v21[2]);
      if (v20)
      {
        *(void *)uint64_t v20 = &cstr_empty_string;
        *(void *)(v20 + _Block_object_dispose(va, 8) = 0LL;
        *(_DWORD *)(v20 + 16) = 1;
        *(void *)(v20 + 24) = v21;
      }

      *a2 = v20;
    }

    cstr_setn(v20, (const void *)(*(void *)(a1 + 104) + 832LL), *(_DWORD *)(*(void *)(a1 + 144) + 8LL));
  }

  return 0LL;
}

uint64_t srp6_server_verify(uint64_t a1, const void *a2, int a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  (*(void (**)(_BYTE *, uint64_t))(*(void *)(a1 + 144) + 32LL))(__s1, *(void *)(a1 + 104) + 624LL);
  uint64_t v6 = *(void *)(a1 + 144);
  if (*(_DWORD *)v6 == a3 && !memcmp(__s1, a2, a3))
  {
    (*(void (**)(uint64_t, uint64_t))(v6 + 32))(*(void *)(a1 + 104) + 896LL, *(void *)(a1 + 104) + 416LL);
  }

  else
  {
    (*(void (**)(_BYTE *, uint64_t))(v6 + 32))(__s1, *(void *)(a1 + 104) + 208LL);
    size_t v7 = *(uint64_t **)(a1 + 144);
    uint64_t v8 = *v7;
    ((void (*)(void, _BYTE *, uint64_t))v7[3])(*(void *)(a1 + 104), __s1, v8);
    (*(void (**)(void, uint64_t, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104),  *(void *)(a1 + 104) + 832LL,  *(void *)(*(void *)(a1 + 144) + 8LL));
    (*(void (**)(uint64_t, void))(*(void *)(a1 + 144) + 32LL))( *(void *)(a1 + 104) + 896LL,  *(void *)(a1 + 104));
  }

  return 0LL;
}

uint64_t srp6_server_respond(uint64_t a1, void ***a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *a2;
  if (!*a2)
  {
    uint64_t v5 = (uint64_t (**)())default_alloc;
    if (!default_alloc)
    {
      uint64_t v5 = malloc_allocator;
      default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
    }

    uint64_t v4 = (void **)((uint64_t (*)(uint64_t, uint64_t (*)()))*v5)(32LL, v5[2]);
    if (v4)
    {
      *uint64_t v4 = &cstr_empty_string;
      v4[1] = 0LL;
      *((_DWORD *)v4 + 4) = 1;
      v4[3] = v5;
    }

    *a2 = v4;
  }

  cstr_set_length((uint64_t)v4, **(_DWORD **)(a1 + 144));
  memcpy(**a2, (const void *)(*(void *)(a1 + 104) + 896LL), **(void **)(a1 + 144));
  return 0LL;
}

uint64_t srp6a_server_init(void *a1)
{
  *a1 = 0x30000001CLL;
  a1[13] = malloc(0x3C0uLL);
  (*(void (**)(void))(a1[18] + 16LL))();
  (*(void (**)(uint64_t))(a1[18] + 16LL))(a1[13] + 208LL);
  (*(void (**)(uint64_t))(a1[18] + 16LL))(a1[13] + 416LL);
  (*(void (**)(uint64_t))(a1[18] + 16LL))(a1[13] + 624LL);
  return 0LL;
}

uint64_t srp6a_server_genpub(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  (*(void (**)(_BYTE *))(*(void *)(a1 + 144) + 16LL))(v16);
  uint64_t v4 = (uint64_t (**)())default_alloc;
  if (!default_alloc)
  {
    uint64_t v4 = malloc_allocator;
    default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
  }

  uint64_t v5 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v4)(32LL, v4[2]);
  uint64_t v6 = (void *)v5;
  if (v5)
  {
    *(void *)uint64_t v5 = &cstr_empty_string;
    *(void *)(v5 + _Block_object_dispose(va, 8) = 0LL;
    *(_DWORD *)(v5 + 16) = 1;
    *(void *)(v5 + 24) = v4;
  }

  BigIntegerToCstr(*(void *)(a1 + 16), v5);
  (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v16, *v6, *((int *)v6 + 2));
  uint64_t v7 = *(void *)(a1 + 24);
  if ((*(_BYTE *)(a1 + 4) & 2) != 0) {
    BigIntegerToCstrEx(v7, (const void **)v6, *((_DWORD *)v6 + 2));
  }
  else {
    BigIntegerToCstr(v7, (uint64_t)v6);
  }
  (*(void (**)(_BYTE *, void, void))(*(void *)(a1 + 144) + 24LL))(v16, *v6, *((int *)v6 + 2));
  (*(void (**)(_BYTE *, _BYTE *))(*(void *)(a1 + 144) + 32LL))(v17, v16);
  cstr_free((uint64_t)v6);
  CCBigNumFromData();
  if (MEMORY[0x186E41A3C]())
  {
    CCBigNumBitCount();
    if (a2)
    {
      uint64_t v8 = *(void **)a2;
      if (!*(void *)a2)
      {
        int v9 = (uint64_t (**)())default_alloc;
        if (!default_alloc)
        {
          int v9 = malloc_allocator;
          default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
        }

        uint64_t v10 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v9)(32LL, v9[2]);
        uint64_t v8 = (void *)v10;
        if (v10)
        {
          *(void *)uint64_t v10 = &cstr_empty_string;
          *(void *)(v10 + _Block_object_dispose(va, 8) = 0LL;
          *(_DWORD *)(v10 + 16) = 1;
          *(void *)(v10 + 24) = v9;
        }

        *(void *)a2 = v10;
      }
    }

    else
    {
      uint64_t v11 = (uint64_t (**)())default_alloc;
      if (!default_alloc)
      {
        uint64_t v11 = malloc_allocator;
        default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
      }

      uint64_t v12 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v11)(32LL, v11[2]);
      uint64_t v8 = (void *)v12;
      if (v12)
      {
        *(void *)uint64_t v12 = &cstr_empty_string;
        *(void *)(v12 + _Block_object_dispose(va, 8) = 0LL;
        *(_DWORD *)(v12 + 16) = 1;
        *(void *)(v12 + 24) = v11;
      }
    }

    int v13 = CCBigNumBitCount();
    int v14 = v13 + 7;
    if (v13 < -7) {
      int v14 = v13 + 14;
    }
    cstr_set_length((uint64_t)v8, v14 >> 3);
    RandomBytes((void *)*v8, 0x20uLL);
    *(void *)(a1 + 64) = CCBigNumFromData();
    *(void *)(a1 + 56) = BigIntegerFromInt();
    CCBigNumMul();
    CCBigNumModExp();
    CCBigNumAdd();
    CCBigNumMod();
    BigIntegerToCstr(*(void *)(a1 + 56), (uint64_t)v8);
    (*(void (**)(uint64_t, void, void))(*(void *)(a1 + 144) + 24LL))( *(void *)(a1 + 104) + 624LL,  *v8,  *((int *)v8 + 2));
    if (a2) {
      a2 = 0LL;
    }
    else {
      cstr_clear_free((uint64_t)v8);
    }
  }

  else
  {
    a2 = 0xFFFFFFFFLL;
  }

  CCBigNumFree();
  return a2;
}

void *SRP_new(uint64_t a1)
{
  uint64_t v2 = malloc(0x98uLL);
  unint64_t v3 = v2;
  if (v2)
  {
    v2[1] = 0;
    uint64_t v4 = (uint64_t (**)())default_alloc;
    if (!default_alloc)
    {
      uint64_t v4 = malloc_allocator;
      default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
    }

    uint64_t v5 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v4)(32LL, v4[2]);
    if (v5)
    {
      *(void *)uint64_t v5 = &cstr_empty_string;
      *(void *)(v5 + _Block_object_dispose(va, 8) = 0LL;
      *(_DWORD *)(v5 + 16) = 1;
      *(void *)(v5 + 24) = v4;
    }

    v3[1] = v5;
    *((_OWORD *)v3 + 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    v3[10] = 0LL;
    v3[14] = 0LL;
    v3[15] = 0LL;
    uint64_t v6 = (uint64_t (**)())default_alloc;
    if (!default_alloc)
    {
      uint64_t v6 = malloc_allocator;
      default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
    }

    uint64_t v7 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v6)(32LL, v6[2]);
    if (v7)
    {
      *(void *)uint64_t v7 = &cstr_empty_string;
      *(void *)(v7 + _Block_object_dispose(va, 8) = 0LL;
      *(_DWORD *)(v7 + 16) = 1;
      *(void *)(v7 + 24) = v6;
    }

    v3[11] = v7;
    v3[12] = a1;
    v3[13] = 0LL;
    v3[16] = 0LL;
    v3[17] = 0LL;
    v3[18] = &kSRPHashDescriptor_SHA512;
    uint64_t v8 = *(unsigned int (**)(void *))(a1 + 8);
    if (v8 && v8(v3))
    {
      free(v3);
      return 0LL;
    }
  }

  return v3;
}

void SRP_free(void *a1)
{
  uint64_t v2 = *(void (**)(void *))(a1[12] + 16LL);
  if (v2) {
    v2(a1);
  }
  uint64_t v3 = a1[1];
  if (v3) {
    cstr_clear_free(v3);
  }
  if (a1[2]) {
    CCBigNumFree();
  }
  if (a1[3]) {
    CCBigNumFree();
  }
  uint64_t v4 = a1[4];
  if (v4) {
    cstr_clear_free(v4);
  }
  if (a1[5]) {
    CCBigNumFree();
  }
  if (a1[6]) {
    CCBigNumFree();
  }
  if (a1[7]) {
    CCBigNumFree();
  }
  if (a1[8]) {
    CCBigNumFree();
  }
  if (a1[9]) {
    CCBigNumFree();
  }
  if (a1[10]) {
    CCBigNumFree();
  }
  uint64_t v5 = a1[11];
  if (v5) {
    cstr_clear_free(v5);
  }
  free(a1);
}

uint64_t SRP_set_user_raw(uint64_t a1, const void *a2, int a3)
{
  uint64_t result = *(void *)(a1 + 136);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)result + 24LL))( result,  a1,  *(void *)(a1 + 8));
  }
  return result;
}

uint64_t SRP_set_params(uint64_t a1, const void *a2, uint64_t a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 16) = CCBigNumFromData();
  if ((*(_BYTE *)(a1 + 4) & 1) != 0) {
    *(void *)(a1 + 120) = 0LL;
  }
  *(void *)(a1 + 24) = CCBigNumFromData();
  uint64_t v6 = *(void *)(a1 + 32);
  if (!v6)
  {
    uint64_t v7 = (uint64_t (**)())default_alloc;
    if (!default_alloc)
    {
      uint64_t v7 = malloc_allocator;
      default_alloCC_SHA1_CTX c = (uint64_t)malloc_allocator;
    }

    uint64_t v6 = ((uint64_t (*)(uint64_t, uint64_t (*)()))*v7)(32LL, v7[2]);
    if (v6)
    {
      *(void *)uint64_t v6 = &cstr_empty_string;
      *(void *)(v6 + _Block_object_dispose(va, 8) = 0LL;
      *(_DWORD *)(v6 + 16) = 1;
      *(void *)(v6 + 24) = v7;
    }

    *(void *)(a1 + 32) = v6;
  }

  cstr_setn(v6, a2, a3);
  int v9 = *(uint64_t (**)(uint64_t, void *, uint64_t, void *, uint64_t))(a1 + 128);
  if (!v9) {
    return (*(uint64_t (**)(uint64_t, void *, uint64_t, void *, uint64_t, const void *, uint64_t))(*(void *)(a1 + 96) + 24LL))( a1,  &kSRPModulus3072,  384LL,  &kSRPGenerator5,  1LL,  a2,  a3);
  }
  uint64_t result = v9(a1, &kSRPModulus3072, 384LL, &kSRPGenerator5, 1LL);
  if (!(_DWORD)result) {
    return (*(uint64_t (**)(uint64_t, void *, uint64_t, void *, uint64_t, const void *, uint64_t))(*(void *)(a1 + 96) + 24LL))( a1,  &kSRPModulus3072,  384LL,  &kSRPGenerator5,  1LL,  a2,  a3);
  }
  return result;
}

uint64_t t_mgf1(uint64_t a1, const void *a2, CC_LONG a3)
{
  uint64_t v6 = 0LL;
  unsigned int v7 = 0;
  do
  {
    unsigned int data = bswap32(v7);
    CC_SHA1_Init(&c);
    CC_SHA1_Update(&c, a2, a3);
    CC_SHA1_Update(&c, &data, 4u);
    uint64_t result = CC_SHA1_Final((unsigned __int8 *)(a1 + v6), &c);
    ++v7;
    v6 += 20LL;
  }

  while (v6 != 40);
  return result;
}

uint64_t SRPCreate_corecrypto(void *a1)
{
  uint64_t v2 = calloc(1uLL, 0x38uLL);
  if (!v2) {
    return 4294960568LL;
  }
  uint64_t v3 = v2;
  uint64_t result = 0LL;
  *a1 = v3;
  return result;
}

void SRPDelete_corecrypto(void *a1)
{
  if (a1)
  {
    _SRPCleanup_corecrypto((uint64_t)a1);
    free(a1);
  }

void _SRPCleanup_corecrypto(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    memset_s(v2, *(void *)(a1 + 8), 0, *(void *)(a1 + 8));
    if (*(void *)a1)
    {
      free(*(void **)a1);
      *(void *)a1 = 0LL;
    }
  }

  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 16) = 0LL;
  }

  uint64_t v4 = *(void **)(a1 + 24);
  if (v4)
  {
    memset_s(v4, *(void *)(a1 + 32), 0, *(void *)(a1 + 32));
    uint64_t v5 = *(void **)(a1 + 24);
    if (v5)
    {
      free(v5);
      *(void *)(a1 + 24) = 0LL;
    }
  }

  *(void *)(a1 + 32) = 0LL;
  uint64_t v6 = *(void **)(a1 + 40);
  if (v6)
  {
    memset_s(v6, *(void *)(a1 + 48), 0, *(void *)(a1 + 48));
    unsigned int v7 = *(void **)(a1 + 40);
    if (v7)
    {
      free(v7);
      *(void *)(a1 + 40) = 0LL;
    }
  }

  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
}

uint64_t SRPClientStart_corecrypto( void *a1, void *a2, const char *a3, size_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, size_t a10, void *a11, size_t *a12, void *a13, size_t *a14, void *a15, size_t *a16)
{
  if (a2 != &_kSRPParameters_3072_SHA512)
  {
    uint64_t v17 = 4294960561LL;
LABEL_33:
    _SRPCleanup_corecrypto((uint64_t)a1);
    return v17;
  }

  uint64_t v22 = (void *)ccsha512_di();
  ccsrp_gp_rfc5054_3072();
  size_t v23 = 4 * (*v22 + ccdh_ccn_size()) + 48;
  a1[1] = v23;
  uint64_t v24 = calloc(1uLL, v23);
  *a1 = v24;
  if (!v24) {
    goto LABEL_32;
  }
  int8x16_t __s = a5;
  ccrng();
  ccsrp_ctx_init_option();
  uint64_t v25 = MEMORY[0x186E42B34](*(void *)(*a1 + 8LL));
  size_t v26 = 8 * v25;
  size_t v27 = 8 * v25 - a10;
  if (8 * v25 > a10)
  {
    uint64_t v28 = (char *)malloc(8 * v25);
    if (v28)
    {
      uint64_t v29 = v28;
      memset(v28, 48, v27);
      memcpy(&v29[v27], a9, a10);
      goto LABEL_9;
    }

uint64_t SRPClientVerify_corecrypto(void *a1, uint64_t a2, uint64_t a3)
{
  if (*a1)
  {
    if (ccsrp_get_session_key_length() == a3)
    {
      else {
        uint64_t v4 = 4294960542LL;
      }
    }

    else
    {
      uint64_t v4 = 4294960553LL;
    }
  }

  else
  {
    uint64_t v4 = 4294960551LL;
  }

  _SRPCleanup_corecrypto((uint64_t)a1);
  return v4;
}

uint64_t SRPServerStart_corecrypto( uint64_t a1, void *a2, const char *a3, size_t a4, const char *a5, uint64_t a6, size_t a7, void *a8, void *a9, size_t *a10)
{
  if (a2 == &_kSRPParameters_3072_SHA512)
  {
    uint64_t v18 = (void *)ccsha512_di();
    ccsrp_gp_rfc5054_3072();
    size_t v19 = 4 * (*v18 + ccdh_ccn_size()) + 48;
    *(void *)(a1 + _Block_object_dispose(va, 8) = v19;
    uint64_t v20 = calloc(1uLL, v19);
    *(void *)a1 = v20;
    if (v20)
    {
      ccrng();
      ccsrp_ctx_init_option();
      size_t v21 = 8 * MEMORY[0x186E42B34](*(void *)(*(void *)a1 + 8LL));
      uint64_t v22 = malloc(v21);
      *(void *)(a1 + 40) = v22;
      if (v22)
      {
        if (a4 == -1LL) {
          a4 = strlen(a3);
        }
        size_t v23 = strndup(a3, a4);
        *(void *)(a1 + 16) = v23;
        if (v23)
        {
          uint64_t v24 = malloc(a7);
          *(void *)(a1 + 24) = v24;
          if (v24)
          {
            *(void *)(a1 + 32) = a7;
            if (a6 == -1) {
              strlen(a5);
            }
            if (ccsrp_generate_salt_and_verification())
            {
LABEL_15:
              uint64_t v11 = 4294960596LL;
              goto LABEL_16;
            }

            memcpy(a8, *(const void **)(a1 + 24), a7);
            uint64_t v25 = malloc(v21);
            if (v25)
            {
              size_t v26 = v25;
              if (!ccsrp_server_generate_public_key())
              {
                uint64_t v11 = 0LL;
                *a9 = v26;
                *a10 = v21;
                return v11;
              }

              free(v26);
              goto LABEL_15;
            }
          }
        }
      }
    }

    uint64_t v11 = 4294960568LL;
    goto LABEL_16;
  }

  uint64_t v11 = 4294960561LL;
LABEL_16:
  _SRPCleanup_corecrypto(a1);
  return v11;
}

uint64_t SRPServerVerify_corecrypto( void *a1, const void *a2, size_t a3, uint64_t a4, size_t a5, void *a6, size_t *a7, void *a8, size_t *a9)
{
  if (!*a1 || !a1[2] || !a1[3] || !a1[4])
  {
    uint64_t v17 = 4294960551LL;
    goto LABEL_21;
  }

  session_key_CFIndex length = ccsrp_get_session_key_length();
  uint64_t v17 = 4294960553LL;
  if (session_key_length && session_key_length == a5)
  {
    size_t v18 = 8 * MEMORY[0x186E42B34](*(void *)(*a1 + 8LL));
    size_t v19 = v18 - a3;
    if (v18 < a3)
    {
      uint64_t v17 = 4294960553LL;
      goto LABEL_21;
    }

    if (v18 > a3)
    {
      uint64_t v20 = (char *)malloc(v18);
      if (!v20)
      {
        uint64_t v17 = 4294960568LL;
        goto LABEL_21;
      }

      size_t v21 = v20;
      bzero(v20, v19);
      memcpy(&v21[v19], a2, a3);
    }

    else
    {
      size_t v21 = 0LL;
    }

    if (ccsrp_server_compute_session())
    {
      uint64_t v22 = 0LL;
    }

    else
    {
      uint64_t v22 = malloc(a5);
      if (!v22) {
        goto LABEL_23;
      }
      if (ccsrp_server_verify_session())
      {
        size_t v23 = malloc(a5);
        if (v23)
        {
          uint64_t v24 = v23;
          uint64_t v25 = *a1;
          uint64_t v26 = MEMORY[0x186E42B34](*(void *)(*a1 + 8LL));
          memcpy(v24, (const void *)(v25 + 32 * v26 + 32), a5);
          uint64_t v17 = 0LL;
          *a6 = v24;
          *a7 = a5;
          *a8 = v22;
          *a9 = a5;
          uint64_t v22 = 0LL;
LABEL_17:
          if (v21) {
            free(v21);
          }
          if (v22) {
            free(v22);
          }
          goto LABEL_21;
        }

uint64_t SRPCreate_libsrp(void *a1)
{
  uint64_t v2 = calloc(1uLL, 0x38uLL);
  if (!v2) {
    return 4294960568LL;
  }
  uint64_t v3 = v2;
  uint64_t result = 0LL;
  *a1 = v3;
  return result;
}

void SRPDelete_libsrp(void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (v2) {
    SRP_free(v2);
  }
  free(a1);
}

uint64_t SRPClientStart_libsrp( uint64_t *a1, void *a2, const char *a3, uint64_t a4, const char *a5, uint64_t a6, const void *a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  if (a2 == &_kSRPParameters_3072_SHA512)
  {
    uint64_t v24 = (void *)*a1;
    if (v24)
    {
      SRP_free(v24);
      *a1 = 0LL;
    }

    uint64_t v25 = SRP_new((uint64_t)&srp6a_client_meth);
    *a1 = (uint64_t)v25;
    if (!v25) {
      return 4294960568LL;
    }
    uint64_t v26 = (uint64_t)v25;
    if (a4 == -1) {
      LODWORD(a4) = strlen(a3);
    }
    if (a6 == -1) {
      strlen(a5);
    }
    if ((*(unsigned int (**)(void))(*(void *)(*a1 + 96) + 40LL))()
      || (*(unsigned int (**)(void))(*(void *)(*a1 + 96) + 48LL))())
    {
      return 4294960596LL;
    }

    if (MEMORY[8] < 1)
    {
      uint64_t v16 = 4294960553LL;
      cstr_free(0LL);
      return v16;
    }

    if (MEMORY[8] >= 1)
    {
      if (MEMORY[8] >= 1)
      {
        uint64_t v16 = 0LL;
        *a11 = MEMORY[0];
        *a12 = MEMORY[8];
        MEMORY[8] = 0LL;
        *a13 = MEMORY[0];
        *a14 = MEMORY[8];
        MEMORY[8] = 0LL;
        *a15 = MEMORY[0];
        *a16 = MEMORY[8];
        MEMORY[8] = 0LL;
        return v16;
      }
    }

    return 4294960553LL;
  }

  return 4294960561LL;
}

uint64_t SRPClientVerify_libsrp(void **a1)
{
  uint64_t v2 = (uint64_t)*a1;
  if (!v2) {
    return 4294960551LL;
  }
  else {
    uint64_t v3 = 0LL;
  }
  if (*a1)
  {
    SRP_free(*a1);
    *a1 = 0LL;
  }

  return v3;
}

uint64_t SRPServerStart_libsrp( uint64_t *a1, void *a2, const char *a3, uint64_t a4, const char *a5, uint64_t a6, size_t a7, void *a8, void *a9, void *a10)
{
  if (a2 != &_kSRPParameters_3072_SHA512) {
    return 4294960561LL;
  }
  size_t v18 = (void *)*a1;
  if (v18)
  {
    SRP_free(v18);
    *a1 = 0LL;
  }

  size_t v19 = SRP_new((uint64_t)&srp6a_server_meth);
  *a1 = (uint64_t)v19;
  if (!v19) {
    return 4294960568LL;
  }
  uint64_t v20 = (uint64_t)v19;
  if (a4 == -1) {
    LODWORD(a4) = strlen(a3);
  }
  if (a7 < 0x10) {
    return 4294960591LL;
  }
  RandomBytes(a8, a7);
  CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  (uint64_t)a8,  a7,  "SRP-Salt-Salt",  0xDuLL,  (uint64_t)"SRP-Salt-Info",  13LL,  a7,  (uint64_t)a8);
  if (a6 == -1) {
    strlen(a5);
  }
  uint64_t v10 = 0LL;
  *a9 = MEMORY[0];
  *a10 = MEMORY[8];
  MEMORY[8] = 0LL;
  cstr_free(0LL);
  return v10;
}

uint64_t SRPServerVerify_libsrp( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9)
{
  uint64_t v10 = (uint64_t)*a1;
  if (!v10) {
    return 4294960551LL;
  }
  if (MEMORY[8] < 1)
  {
    uint64_t v14 = 4294960553LL;
    cstr_clear_free(0LL);
  }

  else if ((*(unsigned int (**)(void))((*a1)[12] + 64LL))())
  {
    uint64_t v14 = 4294960542LL;
  }

  else
  {
    if ((*(unsigned int (**)(void))((*a1)[12] + 72LL))())
    {
LABEL_6:
      uint64_t v14 = 4294960596LL;
      goto LABEL_7;
    }

    if (MEMORY[8] < 1)
    {
      uint64_t v14 = 4294960553LL;
    }

    else
    {
      uint64_t v14 = 0LL;
      *a6 = MEMORY[0];
      *a7 = MEMORY[8];
      MEMORY[8] = 0LL;
      *a8 = MEMORY[0];
      *a9 = MEMORY[8];
      MEMORY[8] = 0LL;
    }
  }

uint64_t ParseIPv4Address(unsigned __int8 *a1, _BYTE *a2, unsigned __int8 **a3)
{
  *a2 = 0;
  unsigned __int8 v3 = *a1;
  if (!*a1) {
    return 4294960546LL;
  }
  LOBYTE(v4) = 0;
  int v5 = 0;
  int v6 = 0;
  do
  {
    if (v3 - 48 <= 9)
    {
      int v4 = 10 * v4 + (char)v3 - 48;
      if (v4 > 255) {
        return 4294960586LL;
      }
      *a2 = v4;
      if (!v5)
      {
        if (v6 > 3) {
          return 4294960545LL;
        }
        ++v6;
      }

      int v5 = 1;
      goto LABEL_13;
    }

    if (!v5 || v3 != 46) {
      break;
    }
    if (v6 > 3) {
      return 4294960554LL;
    }
    LOBYTE(v4) = 0;
    int v5 = 0;
    *++a2 = 0;
LABEL_13:
    int v7 = *++a1;
    unsigned __int8 v3 = v7;
  }

  while (v7);
  if (v6 != 4) {
    return 4294960546LL;
  }
  uint64_t v8 = 0LL;
  *a3 = a1;
  return v8;
}

uint64_t StringToIPv4Address(unsigned __int8 *a1, _DWORD *a2, int *a3)
{
  uint64_t v16 = (char *)a1;
  if (!a1) {
    return 4294960591LL;
  }
  uint64_t result = ParseIPv4Address(a1, &v15, (unsigned __int8 **)&v16);
  if (!(_DWORD)result)
  {
    int v6 = (unsigned __int8 *)v16;
    int v7 = *v16;
    if (v7 == 58)
    {
      int v6 = (unsigned __int8 *)(v16 + 1);
      int v8 = v16[1];
      if ((v8 - 48) > 9)
      {
        int v9 = 0;
        ++v16;
      }

      else
      {
        int v9 = 0;
        do
        {
          int v9 = v8 + 10 * v9 - 48;
          int v10 = (char)*++v6;
          int v8 = v10;
        }

        while ((v10 - 48) < 0xA);
        uint64_t v16 = (char *)v6;
        if (v9 >= 0x10000) {
          return 4294960586LL;
        }
      }
    }

    else
    {
      int v9 = 0;
      int v8 = *v16;
    }

    if (v8 == 47)
    {
      int v11 = v6[1];
      if ((v11 - 48) <= 9)
      {
        unsigned int v12 = 0;
        int v13 = v6 + 2;
        do
        {
          unsigned int v12 = v11 + 10 * v12 - 48;
          int v14 = *v13++;
          int v11 = v14;
        }

        while ((v14 - 48) < 0xA);
        if (v12 > 0x20) {
          return 4294960586LL;
        }
      }
    }

    if (a2) {
      *a2 = bswap32(v15);
    }
    uint64_t result = 0LL;
    if (a3)
    {
      if (v7 == 58)
      {
        uint64_t result = 0LL;
        *a3 = v9;
      }
    }
  }

  return result;
}

char *IPv6AddressToCString(_BYTE *a1, unsigned int a2, int a3, unsigned int a4, char *a5, char a6)
{
  unsigned int v8 = a3;
  unsigned int v9 = a2;
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (a3 > 0 || (int v10 = a5, a3 == -2))
  {
    *a5 = 91;
    int v10 = a5 + 1;
  }

  if (*a1 || a1[1] || a1[2] || a1[3]) {
    goto LABEL_28;
  }
  BOOL v11 = !a1[4]
     && !a1[5]
     && !a1[6]
     && !a1[7]
     && !a1[8]
     && !a1[9]
     && a1[10] == 255
     && a1[11] == 255;
  if (a1[4] || a1[5] || a1[6] || a1[7] || a1[8] || a1[9] || a1[10] || a1[11])
  {
    int v12 = 0;
    goto LABEL_25;
  }

  if (a1[12] || a1[13] || a1[14])
  {
    BOOL v48 = 0;
LABEL_101:
    int v12 = !v48;
    goto LABEL_25;
  }

  int v12 = a1[15];
  if (a1[15])
  {
    BOOL v48 = v12 == 1;
    goto LABEL_101;
  }

_BYTE *IPv4AddressToCString(unsigned int a1, unsigned int a2, _BYTE *a3)
{
  unsigned int v3 = 1;
  uint64_t v13 = *MEMORY[0x1895F89C0];
  int v4 = a3;
  do
  {
    unsigned int v5 = (a1 >> (-8 * v3));
    int v6 = v12;
    do
    {
      *v6++ = (v5 % 0xA) | 0x30;
      BOOL v7 = v5 > 9;
      v5 /= 0xAu;
    }

    while (v7);
    while (v6 > v12)
    {
      char v8 = *--v6;
      *v4++ = v8;
    }

    if (v3 <= 3) {
      *v4++ = 46;
    }
    ++v3;
  }

  while (v3 != 5);
  if ((int)a2 >= 1)
  {
    *int v4 = 58;
    unsigned int v9 = v12;
    do
    {
      *v9++ = (a2 % 0xA) | 0x30;
      BOOL v7 = a2 > 9;
      a2 /= 0xAu;
    }

    while (v7);
    ++v4;
    while (v9 > v12)
    {
      char v10 = *--v9;
      *v4++ = v10;
    }
  }

  *int v4 = 0;
  return a3;
}

_BYTE *BitListString_Make(unsigned int a1, _BYTE *a2, void *a3)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  unsigned int v3 = a2;
  if (a1)
  {
    unsigned int v4 = 0;
    unsigned int v3 = a2;
    do
    {
      if ((a1 & 1) != 0)
      {
        unsigned int v5 = a2;
        if (v3 != a2)
        {
          *unsigned int v3 = 44;
          unsigned int v5 = v3 + 1;
        }

        int v6 = v11;
        unsigned int v7 = v4;
        do
        {
          *v6++ = (v7 % 0xA) | 0x30;
          BOOL v8 = v7 > 9;
          v7 /= 0xAu;
        }

        while (v8);
        while (v6 > v11)
        {
          char v9 = *--v6;
          *v5++ = v9;
        }

        unsigned int v3 = v5;
      }

      ++v4;
      BOOL v8 = a1 > 1;
      a1 >>= 1;
    }

    while (v8);
  }

  *unsigned int v3 = 0;
  if (a3) {
    *a3 = v3 - a2;
  }
  return a2;
}

uint64_t BitListString_Parse(char *__s, int64_t a2, _DWORD *a3)
{
  unsigned int v4 = __s;
  if (a2 == -1) {
    a2 = strlen(__s);
  }
  if (a2 < 1)
  {
    int v5 = 0;
LABEL_15:
    uint64_t result = 0LL;
    *a3 = v5;
  }

  else
  {
    int v5 = 0;
    unint64_t v6 = (unint64_t)&v4[a2];
    while (1)
    {
      unsigned int v7 = 0;
      BOOL v8 = v4;
      do
      {
        int v9 = *v8;
        unsigned int v7 = v9 + 10 * v7 - 48;
        ++v8;
      }

      while ((unint64_t)v8 < v6);
      if (v7 > 0x1F) {
        return 4294960586LL;
      }
      v5 |= 1 << v7;
      unsigned int v4 = v8 + 1;
    }
  }

  return result;
}

_BYTE *FourCharCodeToCString(unsigned int a1, _BYTE *a2)
{
  unsigned int v2 = HIBYTE(a1);
  if (!HIBYTE(a1)) {
    LOBYTE(v2) = 32;
  }
  *a2 = v2;
  unsigned int v3 = HIWORD(a1);
  if (!BYTE2(a1)) {
    LOBYTE(v3) = 32;
  }
  a2[1] = v3;
  unsigned int v4 = a1 >> 8;
  if (!BYTE1(a1)) {
    LOBYTE(v4) = 32;
  }
  a2[2] = v4;
  if ((_BYTE)a1) {
    char v5 = a1;
  }
  else {
    char v5 = 32;
  }
  a2[3] = v5;
  a2[4] = 0;
  return a2;
}

uint64_t TextToFourCharCode(char *__s, size_t a2)
{
  if (a2 == -1LL) {
    a2 = strlen(__s);
  }
  int v3 = 0x2000;
  if (a2)
  {
    if (*__s) {
      int v4 = *__s << 8;
    }
    else {
      int v4 = 0x2000;
    }
    int v5 = 32;
    if (a2 == 1)
    {
      int v6 = 32;
    }

    else
    {
      if (__s[1]) {
        int v6 = __s[1];
      }
      else {
        int v6 = 32;
      }
      int v3 = 0x2000;
      if (a2 >= 3)
      {
        if (__s[2]) {
          int v3 = __s[2] << 8;
        }
        else {
          int v3 = 0x2000;
        }
        int v5 = 32;
        if (a2 != 3)
        {
          if (__s[3]) {
            int v5 = __s[3];
          }
          else {
            int v5 = 32;
          }
        }
      }
    }
  }

  else
  {
    int v6 = 32;
    int v4 = 0x2000;
    int v5 = 32;
  }

  return v5 | v3 | ((v4 | v6) << 16);
}

uint64_t TextToHardwareAddress(char *__s, size_t a2, uint64_t a3, _BYTE *a4)
{
  if (__s)
  {
    uint64_t v5 = a3;
    int v6 = __s;
    if (a2 == -1LL)
    {
      a2 = strlen(__s);
      if (!v5) {
        return 0LL;
      }
    }

    else if (!a3)
    {
      return 0LL;
    }

    unsigned int v7 = &v6[a2];
    uint64_t v8 = MEMORY[0x1895F8770];
    while (1)
    {
      if (v6 >= v7) {
        return 4294960554LL;
      }
      int v9 = 0;
      int v10 = 0;
      --v5;
      BOOL v11 = v6;
      while (1)
      {
        unsigned int v13 = *v6++;
        unsigned int v12 = v13;
        int v14 = (char)v13;
        if (v13 - 48 > 9) {
          break;
        }
        int v9 = v14 + 16 * v9 - 48;
LABEL_17:
        ++v10;
LABEL_18:
        if (v10 <= 1)
        {
          BOOL v11 = v6;
          if (v6 < v7) {
            continue;
          }
        }

        if (!v10) {
          return 4294960554LL;
        }
        if (a4) {
          goto LABEL_22;
        }
        goto LABEL_23;
      }

      if (!v10)
      {
        if (v12 > 0x3A || ((1LL << v12) & 0x400200100000000LL) == 0) {
          return 4294960554LL;
        }
        int v10 = 0;
        goto LABEL_18;
      }

      int v6 = v11 + 1;
      if (a4) {
LABEL_22:
      }
        *a4++ = v9;
LABEL_23:
      if (!v5) {
        return 0LL;
      }
    }

    int v9 = __tolower(v12) + 16 * v9 - 87;
    goto LABEL_17;
  }

  return 4294960591LL;
}

unint64_t TextToHardwareAddressScalar(char *a1, size_t a2, unint64_t a3)
{
  v5[1] = *MEMORY[0x1895F89C0];
  if (a3 != 8)
  {
    if (a3 == 6) {
      return ((unint64_t)LOBYTE(v5[0]) << 40) | ((unint64_t)BYTE1(v5[0]) << 32) | ((unint64_t)BYTE2(v5[0]) << 24) | ((unint64_t)BYTE3(v5[0]) << 16) | ((unint64_t)BYTE4(v5[0]) << 8) | BYTE5(v5[0]);
    }
    return 0LL;
  }

  return bswap64(v5[0]);
}

_BYTE *HardwareAddressToCString(unsigned __int8 *a1, uint64_t a2, _BYTE *a3)
{
  int v3 = a3;
  if (a2 >= 1)
  {
    int v4 = &a1[a2];
    int v3 = a3;
    do
    {
      uint64_t v5 = a3;
      if (v3 != a3)
      {
        *int v3 = 58;
        uint64_t v5 = v3 + 1;
      }

      unsigned int v6 = *a1++;
      *uint64_t v5 = a0123456789abcd_0[(unint64_t)v6 >> 4];
      int v3 = v5 + 2;
      v5[1] = a0123456789abcd_0[v6 & 0xF];
    }

    while (a1 < v4);
  }

  *int v3 = 0;
  return a3;
}

uint64_t TextToInt32(char *__s, int64_t a2, int a3)
{
  int64_t v4 = a2;
  if (a2 == -1) {
    int64_t v4 = strlen(__s);
  }
  unsigned int v6 = &__s[v4];
  if (v4 < 1)
  {
    uint64_t v8 = __s;
  }

  else
  {
    uint64_t v7 = MEMORY[0x1895F8770];
    uint64_t v8 = __s;
    do
    {
      uint64_t v9 = *v8;
      if (*v8 < 0)
      {
        if (!__maskrune(v9, 0x4000uLL)) {
          break;
        }
      }

      else if ((*(_DWORD *)(v7 + 4 * v9 + 60) & 0x4000) == 0)
      {
        break;
      }

      ++v8;
    }

    while (v8 < v6);
  }

  if (v6 - v8 <= 1)
  {
    if (a3) {
      goto LABEL_22;
    }
  }

  else
  {
    if (*v8 == 48)
    {
      if (__tolower(v8[1]) == 120)
      {
        v8 += 2;
        a3 = 16;
LABEL_22:
        int v10 = a3 - 2;
        goto LABEL_27;
      }

      if (*v8 == 48 && __tolower(v8[1]) == 98)
      {
        v8 += 2;
        a3 = 2;
        goto LABEL_22;
      }
    }

    if (a3) {
      goto LABEL_22;
    }
    if (*v8 == 48 && (v8[1] & 0xF8) == 0x30)
    {
      a3 = 8;
      ++v8;
      goto LABEL_22;
    }
  }

  int v10 = 8;
LABEL_27:
  uint64_t v11 = 0LL;
  HIDWORD(v12) = v10;
  LODWORD(v12) = v10;
  switch((v12 >> 1))
  {
    case 0u:
      if (v8 >= v6) {
        goto LABEL_54;
      }
      uint64_t v11 = 0LL;
      unsigned int v13 = (char *)(&__s[v4] - v8);
      do
      {
        int v14 = *v8;
        ++v8;
        uint64_t v11 = (v14 + 2 * v11 - 48);
        --v13;
      }

      while (v13);
      break;
    case 3u:
      if (v8 >= v6) {
        goto LABEL_54;
      }
      uint64_t v11 = 0LL;
      uint64_t v15 = (char *)(&__s[v4] - v8);
      do
      {
        int v16 = *v8;
        ++v8;
        uint64_t v11 = (v16 + 8 * v11 - 48);
        --v15;
      }

      while (v15);
      break;
    case 4u:
      int v17 = *v8;
      if (v17 == 45 || v17 == 43) {
        ++v8;
      }
      unsigned int v18 = 0;
      while (v8 < v6)
      {
        int v20 = *v8++;
        int v19 = v20;
        if (v20 != 44)
        {
          unsigned int v21 = v19 - 48;
          if (v21 > 9) {
            break;
          }
          unsigned int v18 = v21 + 10 * v18;
        }
      }

      if (v17 == 45) {
        uint64_t v11 = -v18;
      }
      else {
        uint64_t v11 = v18;
      }
      break;
    case 7u:
      if (v8 >= v6)
      {
LABEL_54:
        uint64_t v11 = 0LL;
      }

      else
      {
        uint64_t v11 = 0LL;
        int v22 = (char *)(&__s[v4] - v8);
        uint64_t v23 = MEMORY[0x1895F8770];
        do
        {
          unsigned int v25 = *v8++;
          unsigned int v24 = v25;
          unsigned int v26 = v25 - 48;
          if (v25 - 48 > 9)
          {
            if ((*(_DWORD *)(v23 + 4LL * v24 + 60) & 0x10000) == 0) {
              return v11;
            }
            uint64_t v11 = (__tolower(v24) + 16 * v11 - 87);
          }

          else
          {
            uint64_t v11 = v26 + 16 * (_DWORD)v11;
          }

          --v22;
        }

        while (v22);
      }

      break;
    default:
      return v11;
  }

  return v11;
}

uint64_t TextToSourceVersion(char *__s, int64_t a2)
{
  int64_t v2 = a2;
  if (a2 == -1) {
    int64_t v2 = strlen(__s);
  }
  int64_t v4 = &__s[v2];
  if (v2 < 1)
  {
    unsigned int v6 = __s;
  }

  else
  {
    uint64_t v5 = MEMORY[0x1895F8770];
    unsigned int v6 = __s;
    do
    {
      uint64_t v7 = *v6;
      if (*v6 < 0)
      {
        if (!__maskrune(v7, 0x4000uLL)) {
          break;
        }
      }

      else if ((*(_DWORD *)(v5 + 4 * v7 + 60) & 0x4000) == 0)
      {
        break;
      }

      ++v6;
    }

    while (v6 < v4);
  }

  if (v6 >= v4)
  {
    int v10 = 0;
    unsigned int v8 = 0;
  }

  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = (char *)(&__s[v2] - v6);
    while (1)
    {
      int v10 = *v6;
      unsigned int v8 = v10 - 48 + 10 * v8;
      ++v6;
      if (!--v9)
      {
        unsigned int v6 = &__s[v2];
        break;
      }
    }

    if (v8 > 0x346DB) {
      return 0LL;
    }
  }

  if (v10 == 46) {
    unint64_t v12 = v6 + 1;
  }
  else {
    unint64_t v12 = v6;
  }
  if (v12 >= v4)
  {
    unsigned int v13 = 0;
  }

  else
  {
    unsigned int v13 = 0;
    while (1)
    {
      int v10 = *v12;
      unsigned int v13 = v10 - 48 + 10 * v13;
      if (++v12 >= v4)
      {
        unint64_t v12 = &__s[v2];
        break;
      }
    }

    if (v13 > 0x63) {
      return 0LL;
    }
  }

  if (v10 == 46) {
    ++v12;
  }
  if (v12 >= v4)
  {
    unsigned int v14 = 0;
  }

  else
  {
    unsigned int v14 = 0;
    do
    {
      unsigned int v15 = *v12 - 48;
      if (v15 > 9) {
        break;
      }
      if (v14 > 0x63) {
        break;
      }
      unsigned int v14 = v15 + 10 * v14;
      ++v12;
    }

    while (v12 < v4);
    if (v14 > 0x63) {
      return 0LL;
    }
  }

  return 10000 * v8 + 100 * v13 + v14;
}

char *SourceVersionToCString(unsigned int a1, char *__str)
{
  if (a1 % 0x64)
  {
    snprintf(__str, 0x10uLL, "%u.%u.%u");
  }

  else if (a1 / 0x64 == 100 * ((42949673 * (unint64_t)(a1 / 0x64)) >> 32))
  {
    snprintf(__str, 0x10uLL, "%u");
  }

  else
  {
    snprintf(__str, 0x10uLL, "%u.%u");
  }

  return __str;
}

uint64_t HexToData( char *__s, int64_t a2, char a3, uint64_t a4, unint64_t a5, unint64_t *a6, void *a7, char **a8)
{
  unint64_t v12 = __s;
  if (a2 == -1) {
    a2 = strlen(__s);
  }
  unsigned int v13 = (unsigned __int8 *)&v12[a2];
  uint64_t v14 = MEMORY[0x1895F8770];
  int64_t v30 = a2;
  unsigned int v15 = v12;
  if (a2 >= 1)
  {
    do
    {
      uint64_t v16 = *v15;
      if (*v15 < 0)
      {
        if (!__maskrune(v16, 0x4000uLL)) {
          break;
        }
      }

      else if ((*(_DWORD *)(v14 + 4 * v16 + 60) & 0x4000) == 0)
      {
        break;
      }

      ++v15;
    }

    while (v15 < (char *)v13);
  }

  if (v15 >= (char *)v13)
  {
    unint64_t v20 = 0LL;
    uint64_t v19 = 0LL;
    if (a4) {
      goto LABEL_56;
    }
    goto LABEL_59;
  }

  int v28 = a8;
  char v29 = a7;
  int v27 = v12;
  char v17 = 0;
  int v18 = 0;
  uint64_t v19 = 0LL;
  unint64_t v20 = 0LL;
  while (1)
  {
    uint64_t v21 = *v15;
    if (v13 - (unsigned __int8 *)v15 >= 2 && (a3 & 0x10) != 0 && !v18 && (_DWORD)v21 == 48)
    {
      if ((v15[1] | 0x20) == 0x78)
      {
        int v18 = 0;
        ++v15;
        goto LABEL_31;
      }

      char v22 = 0;
LABEL_30:
      char v17 = 16 * v22;
      int v18 = 1;
      goto LABEL_31;
    }

    char v22 = v21 - 48;
    if ((v21 - 65) <= 5u)
    {
      char v22 = v21 - 55;
LABEL_24:
      if (v18) {
        goto LABEL_25;
      }
      goto LABEL_30;
    }

    if ((v21 - 97) <= 5u)
    {
      char v22 = v21 - 87;
      if (v18)
      {
LABEL_25:
        v17 |= v22;
        if (a4 && v20 < a5) {
          *(_BYTE *)(a4 + v20++) = v17;
        }
        int v18 = 0;
        ++v19;
        goto LABEL_31;
      }

      goto LABEL_30;
    }

    if ((a3 & 2) == 0) {
      goto LABEL_41;
    }
    if ((v21 & 0x80) != 0) {
      break;
    }
    if ((*(_DWORD *)(v14 + 4 * v21 + 60) & 0x4000) == 0) {
      goto LABEL_41;
    }
LABEL_31:
  }

uint64_t HexToDataCopy(char *a1, int64_t a2, char a3, void *a4, unint64_t *a5, char **a6)
{
  unint64_t v16 = 0LL;
  HexToData(a1, a2, a3, 0LL, 0LL, 0LL, &v16, 0LL);
  unint64_t v12 = v16;
  unsigned int v13 = malloc(v16 + 1);
  if (!v13) {
    return 4294960568LL;
  }
  uint64_t v14 = v13;
  HexToData(a1, a2, a3, (uint64_t)v13, v12, a5, 0LL, a6);
  uint64_t result = 0LL;
  v14[v16] = 0;
  *a4 = v14;
  return result;
}

_BYTE *DataToHexCStringEx(unsigned __int8 *a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  int64_t v4 = a3;
  if (a2 >= 1)
  {
    uint64_t v5 = &a1[a2];
    unsigned int v6 = a3;
    do
    {
      unsigned int v7 = *a1++;
      *unsigned int v6 = *(_BYTE *)(a4 + ((unint64_t)v7 >> 4));
      int64_t v4 = v6 + 2;
      v6[1] = *(_BYTE *)(a4 + (v7 & 0xF));
      v6 += 2;
    }

    while (a1 < v5);
  }

  *int64_t v4 = 0;
  return a3;
}

uint64_t NormalizeUUIDString( char *a1, size_t a2, __int128 *a3, char a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t result = StringToUUIDEx(a1, a2, a4 & 1, a3, &v13, a6, a7, a8);
  unsigned int v12 = result;
  if (!(_DWORD)result)
  {
    UUIDtoCStringFlags(&v13, 16LL, a3, a4, a5, (int *)&v12);
    return v12;
  }

  return result;
}

uint64_t StringToUUIDEx( char *__s, size_t a2, int a3, _OWORD *a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v11 = a2;
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (a2 == -1LL) {
    size_t v11 = strlen(__s);
  }
  int v25 = 0;
  if (a3) {
    int v13 = SNScanF( __s,  v11,  "%2hhx%2hhx%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx%2hhx%2hhx%2hhx%2hhx%n",  (uint64_t)&v26 + 4,  (uint64_t)&v26 + 7,  (uint64_t)&v26 + 6,  (uint64_t)&v25,  a8,  (int)&v26 + 3);
  }
  else {
    int v13 = SNScanF( __s,  v11,  "%2hhx%2hhx%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx%2hhx%2hhx%2hhx%2hhx%n",  (uint64_t)&v26 + 5,  (uint64_t)&v26 + 6,  (uint64_t)&v26 + 7,  (uint64_t)&v25,  a8,  (int)&v26);
  }
  int v19 = v13;
  if (!a4 || v13 == 16)
  {
    uint64_t result = 4294960554LL;
    if (v19 != 16 || v25 != 36) {
      return result;
    }
    if (a5)
    {
      uint64_t result = 0LL;
      *a5 = v26;
      return result;
    }

    return 0LL;
  }

  int v20 = SNScanF(__s, v11, "%llx%n", v14, v15, v16, v17, v18, (int)&v23);
  uint64_t result = 4294960554LL;
  if (v20 != 1) {
    return result;
  }
  unsigned int v22 = v23;
  if (HIDWORD(v23) || v24 != (_DWORD)v11) {
    return result;
  }
  if (!a5) {
    return 0LL;
  }
  *a5 = *a4;
  uint64_t result = 0LL;
  if (!a3) {
    unsigned int v22 = bswap32(v22);
  }
  *(_DWORD *)a5 = v22;
  return result;
}

char *UUIDtoCStringFlags(_BYTE *a1, uint64_t a2, __int128 *a3, char a4, char *__str, int *a6)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (a2 == 1 && a3)
  {
    int v8 = 0;
    __int128 v20 = *a3;
    if ((a4 & 1) != 0) {
      uint64_t v9 = 0LL;
    }
    else {
      uint64_t v9 = 3LL;
    }
    int v10 = (unsigned __int8 *)&v20;
    *(_BYTE *)((unint64_t)&v20 | v9) = *a1;
    goto LABEL_24;
  }

  if (a2 == 2 && a3)
  {
    __int128 v20 = *a3;
    int v8 = 0;
    if ((a4 & 1) != 0)
    {
      LOBYTE(v20) = a1[1];
      BYTE1(v20) = *a1;
      goto LABEL_23;
    }

    __int16 v11 = *(_WORD *)a1;
LABEL_15:
    WORD1(v20) = v11;
LABEL_23:
    int v10 = (unsigned __int8 *)&v20;
    goto LABEL_24;
  }

  if (a2 == 4 && a3)
  {
    __int128 v20 = *a3;
    int v8 = 0;
    if ((a4 & 1) != 0)
    {
      BYTE3(v20) = *a1;
      BYTE2(v20) = a1[1];
      BYTE1(v20) = a1[2];
      LOBYTE(v20) = a1[3];
      goto LABEL_23;
    }

    LOWORD(v20) = *(_WORD *)a1;
    __int16 v11 = *((_WORD *)a1 + 1);
    goto LABEL_15;
  }

  int v10 = (unsigned __int8 *)&unk_186B4C0CA;
  if (a2 == 16)
  {
    int v10 = a1;
    int v8 = 0;
  }

  else
  {
    int v8 = -6743;
  }

  if (!a3) {
    goto LABEL_29;
  }
LABEL_24:
  if ((a4 & 2) == 0
    || (*(void *)(v10 + 4) == *(void *)((char *)a3 + 4)
      ? (BOOL v12 = *((unsigned int *)v10 + 3) == (unint64_t)*((unsigned int *)a3 + 3))
      : (BOOL v12 = 0),
        !v12))
  {
LABEL_29:
    if ((a4 & 1) != 0)
    {
      uint64_t v13 = v10[3];
      uint64_t v14 = v10[2];
      uint64_t v15 = v10[1];
      uint64_t v16 = *v10;
      uint64_t v17 = v10[5];
      uint64_t v18 = v10[4];
    }

    else
    {
      uint64_t v13 = *v10;
      uint64_t v14 = v10[1];
      uint64_t v15 = v10[2];
      uint64_t v16 = v10[3];
      uint64_t v17 = v10[4];
      uint64_t v18 = v10[5];
    }

    snprintf( __str,  0x25uLL,  "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",  v13,  v14,  v15,  v16,  v17,  v18);
    goto LABEL_33;
  }

  snprintf(__str, 0x25uLL, "%x");
LABEL_33:
  if (a6) {
    *a6 = v8;
  }
  return __str;
}

uint64_t SNScanF( char *a1, size_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return VSNScanF(a1, a2, a3, &a9);
}

uint64_t VSNScanF(char *__s, size_t a2, unsigned __int8 *a3, int *a4)
{
  uint64_t v5 = __s;
  uint64_t v126 = *MEMORY[0x1895F89C0];
  unsigned int v124 = a4;
  if (a2 == -1LL) {
    a2 = strlen(__s);
  }
  unsigned int v120 = 0;
  size_t v122 = &v5[a2];
  uint64_t v6 = MEMORY[0x1895F8770];
  int v119 = (int)v5;
LABEL_4:
  while (2)
  {
    while (2)
    {
      uint64_t v7 = *a3;
      else {
        int v8 = *(_DWORD *)(v6 + 4 * v7 + 60) & 0x4000;
      }
      if (v8)
      {
        do
        {
          while (1)
          {
            int v9 = (char)*++a3;
            uint64_t v10 = v9;
            if (v9 < 0) {
              break;
            }
            if ((*(_DWORD *)(v6 + 4 * v10 + 60) & 0x4000) == 0) {
              goto LABEL_12;
            }
          }
        }

        while (__maskrune(v10, 0x4000uLL));
LABEL_12:
        if (v5 < v122)
        {
          int64_t v11 = v122 - v5;
          do
          {
            uint64_t v12 = *v5;
            if (*v5 < 0)
            {
              if (!__maskrune(v12, 0x4000uLL)) {
                goto LABEL_20;
              }
            }

            else if ((*(_DWORD *)(v6 + 4 * v12 + 60) & 0x4000) == 0)
            {
              goto LABEL_20;
            }

            ++v5;
            --v11;
          }

          while (v11);
          uint64_t v5 = v122;
        }
      }

LABEL_285:
        if (v13 == v5 && !v16) {
          return v120;
        }
        a3 = v44 + 1;
        if ((_DWORD)v21) {
          continue;
        }
        uint64_t v92 = v124;
        v124 += 2;
        BOOL v93 = *(_BYTE **)v92;
        if ((v18 & 1) != 0)
        {
          if (!v93) {
            return v120;
          }
          if (v13 < v5)
          {
            int64_t v94 = v5 - v13;
            do
            {
              char v95 = *v13++;
              *v93++ = v95;
              --v94;
            }

            while (v94);
          }

          *BOOL v93 = 0;
          unsigned int v96 = v120;
        }

        else
        {
          if (v93) {
            *(void *)BOOL v93 = v13;
          }
          uint64_t v116 = v124;
          v124 += 2;
          unint64_t v117 = *(void **)v116;
          unsigned int v96 = v120;
          if (v117) {
            *unint64_t v117 = v5 - v13;
          }
        }

        unsigned int v120 = v96 + 1;
        continue;
      case '\\':
      case ']':
      case '^':
      case '_':
      case 'a':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'q':
      case 'r':
      case 't':
      case 'v':
      case 'w':
        return v120;
      case 'b':
        int v34 = 0;
        int v35 = 0;
        int v36 = 1;
        uint64_t v37 = 2LL;
        goto LABEL_106;
      case 'c':
        if (v28) {
          return v120;
        }
        if ((v18 & 1) != 0)
        {
          if (v24 == 0x7FFFFFFF) {
            uint64_t v45 = 1LL;
          }
          else {
            uint64_t v45 = v24;
          }
          if (v122 - v13 < v45) {
            return v120;
          }
          if ((_DWORD)v21)
          {
            uint64_t v5 = &v13[v45];
            continue;
          }

          uint64_t v111 = v124;
          v124 += 2;
          uint64_t v112 = *(_BYTE **)v111;
          if (!v112) {
            return v120;
          }
          if ((_DWORD)v45)
          {
            unsigned int v113 = v45 + 1;
            unsigned int v101 = v120;
            do
            {
              char v114 = *v13++;
              *v112++ = v114;
              --v113;
            }

            while (v113 > 1);
          }

          else
          {
            unsigned int v101 = v120;
          }
        }

        else
        {
          int64_t v76 = v122 - v13;
          if ((_DWORD)v21)
          {
            uint64_t v5 = &v13[v76];
            continue;
          }

          unsigned __int8 v97 = (char ***)v124;
          v124 += 2;
          char v98 = *v97;
          if (v98) {
            *char v98 = v13;
          }
          unsigned __int8 v99 = v124;
          v124 += 2;
          unint64_t v100 = *(int64_t **)v99;
          unsigned int v101 = v120;
          if (v100) {
            *unint64_t v100 = v76;
          }
          v13 += v76;
        }

        unsigned int v120 = v101 + 1;
        uint64_t v5 = v13;
        continue;
      case 'd':
      case 'u':
        goto LABEL_106;
      case 'f':
        if (v13 >= v122) {
          goto LABEL_82;
        }
        int64_t v46 = v122 - v13;
        do
        {
          uint64_t v47 = *v13;
          if (*v13 < 0)
          {
            if (!__maskrune(v47, 0x4000uLL)) {
              goto LABEL_82;
            }
          }

          else if ((*(_DWORD *)(v6 + 4 * v47 + 60) & 0x4000) == 0)
          {
            goto LABEL_82;
          }

          ++v13;
          --v46;
        }

        while (v46);
        uint64_t v13 = v122;
LABEL_82:
        else {
          BOOL v48 = &v13[v24];
        }
        uint64_t v5 = v13;
        if (v13 < v48)
        {
          if (*v13 == 45) {
            uint64_t v5 = v13 + 1;
          }
          else {
            uint64_t v5 = v13;
          }
        }

        if (v5 < v48)
        {
          int64_t v49 = v48 - v5;
          while (1)
          {
            int v50 = *v5;
            ++v5;
            if (!--v49)
            {
              uint64_t v5 = v48;
              goto LABEL_233;
            }
          }

          if (v50 == 46) {
            ++v5;
          }
        }

LABEL_233:
        if (v5 < v48)
        {
          int64_t v77 = v48 - v5;
          while (1)
          {
            __darwin_ct_rune_t v78 = *v5;
            ++v5;
            if (!--v77)
            {
              uint64_t v5 = v48;
              goto LABEL_240;
            }
          }

          if (__tolower(v78) == 101) {
            ++v5;
          }
        }

LABEL_260:
        if ((v18 & 1) != 0)
        {
          uint64_t v83 = (char **)v124;
          v124 += 2;
          uint64_t v84 = *v83;
          if (*v83)
          {
            if (v5 < v122)
            {
              int64_t v85 = v122 - v5;
              while (1)
              {
                uint64_t v86 = *v5;
                if (!*v5) {
                  break;
                }
                char v87 = *v5;
                int v88 = (char)v86 < 0 ? __maskrune(v86, 0x4000uLL) : *(_DWORD *)(v6 + 4 * v86 + 60) & 0x4000;
                if (v88 || v24 < 1) {
                  break;
                }
                --v24;
                ++v5;
                *v84++ = v87;
                if (!--v85)
                {
                  uint64_t v5 = v122;
                  break;
                }
              }
            }

            *uint64_t v84 = 0;
            goto LABEL_211;
          }

          return v120;
        }

        uint64_t v102 = v5;
        if (v5 < v122)
        {
          int64_t v103 = v122 - v5;
          uint64_t v102 = v5;
          while (1)
          {
            uint64_t v104 = *v102;
            if (!*v102) {
              break;
            }
            int v105 = (v104 & 0x80) != 0 ? __maskrune(v104, 0x4000uLL) : *(_DWORD *)(v6 + 4 * v104 + 60) & 0x4000;
            if (v105 || v24 < 1) {
              break;
            }
            --v24;
            ++v102;
            if (!--v103)
            {
              uint64_t v102 = v122;
              break;
            }
          }
        }

        uint64_t v107 = (char ***)v124;
        v124 += 2;
        uint64_t v108 = *v107;
        if (v108) {
          *uint64_t v108 = v5;
        }
        uint64_t v109 = v124;
        v124 += 2;
        uint64_t v110 = *(void **)v109;
        if (v110) {
          *uint64_t v110 = v102 - v5;
        }
        ++v120;
        uint64_t v5 = v102;
        continue;
      case 'x':
        goto LABEL_105;
      default:
        if (v22 == 37)
        {
          if (!v28 && v24 == 0x7FFFFFFF && !(_DWORD)v21 && v13 < v122)
          {
            uint64_t v5 = v13 + 1;
            if (*v13 == 37) {
              continue;
            }
          }

          return v120;
        }

        if (v22 != 88) {
          return v120;
        }
LABEL_105:
        int v34 = 0;
        int v36 = 0;
        int v35 = 1;
        uint64_t v37 = 16LL;
LABEL_106:
        if (v13 < v122)
        {
          int64_t v54 = v122 - v13;
          do
          {
            uint64_t v55 = *v13;
            if (*v13 < 0)
            {
              if (!__maskrune(v55, 0x4000uLL)) {
                goto LABEL_114;
              }
            }

            else if ((*(_DWORD *)(v6 + 4 * v55 + 60) & 0x4000) == 0)
            {
              goto LABEL_114;
            }

            ++v13;
            --v54;
          }

          while (v54);
          uint64_t v13 = v122;
        }

LABEL_114:
        int v56 = 1;
        if (v122 - v13 < 2 || v24 < 1) {
          goto LABEL_120;
        }
        int v57 = *v13;
        if (v57 == 43) {
          goto LABEL_119;
        }
        if (v57 == 45)
        {
          int v56 = 0;
LABEL_119:
          ++v13;
          --v24;
        }

LABEL_211:
              ++v120;
              continue;
            }

            switch(v121)
            {
              case 'h':
                *(_WORD *)unsigned int v67 = v65;
                goto LABEL_211;
              case 'i':
              case 'k':
              case 'm':
              case 'n':
              case 'o':
                return v120;
              case 'j':
              case 'l':
              case 'p':
                goto LABEL_210;
              default:
                if (v121 == 116 || v121 == 122) {
                  goto LABEL_210;
                }
                break;
            }
          }
        }

        return v120;
    }
  }

char *UUIDtoCString(_BYTE *a1, int a2, char *__str)
{
  return UUIDtoCStringFlags(a1, 16LL, 0LL, a2 != 0, __str, 0LL);
}

char *UUIDtoCStringEx(_BYTE *a1, uint64_t a2, int a3, __int128 *a4, char *a5)
{
  return UUIDtoCStringFlags(a1, a2, a4, a3 != 0, a5, 0LL);
}

uint64_t StringToUUID( char *a1, size_t a2, int a3, _OWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return StringToUUIDEx(a1, a2, a3, 0LL, a4, a6, a7, a8);
}

uint64_t memicmp(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  int64_t v4 = a1;
  unint64_t v5 = (unint64_t)&a1[a3];
  while (1)
  {
    __darwin_ct_rune_t v6 = *a2;
    __darwin_ct_rune_t v7 = __tolower(*v4);
    __darwin_ct_rune_t v8 = __tolower(v6);
    if (v7 < v8) {
      break;
    }
    ++a2;
    ++v4;
    if (v7 > v8) {
      return 1LL;
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t snprintf_add( char **a1, char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = *a1;
  size_t v10 = a2 - *a1;
  if (a2 == *a1) {
    return 4294960533LL;
  }
  uint64_t result = vsnprintf(*a1, v10, a3, &a9);
  if ((result & 0x80000000) == 0)
  {
    int v14 = &v9[result];
    if ((int)result < (int)v10)
    {
      uint64_t result = 0LL;
    }

    else
    {
      int v14 = a2;
      uint64_t result = 4294960545LL;
    }

    *a1 = v14;
  }

  return result;
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  size_t v3 = 0LL;
  if (__n)
  {
    while (__s1[v3])
    {
      if (__n == ++v3)
      {
        size_t v3 = __n;
        break;
      }
    }
  }

  int64_t v4 = (char *)malloc(v3 + 1);
  unint64_t v5 = v4;
  if (v4)
  {
    memcpy(v4, __s1, v3);
    v5[v3] = 0;
  }

  return v5;
}

uint64_t strcmp_prefix(unsigned __int8 *a1, _BYTE *a2)
{
  unsigned int v2 = *a2;
  if (!*a2) {
    return 0LL;
  }
  size_t v3 = a2 + 1;
  while (1)
  {
    unsigned int v4 = *a1;
    if (v4 < v2) {
      return 0xFFFFFFFFLL;
    }
    if (v4 > v2) {
      break;
    }
    ++a1;
    unsigned int v5 = *v3++;
    unsigned int v2 = v5;
    if (!v5) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t stricmp_prefix(unsigned __int8 *a1, unsigned __int8 *a2)
{
  while (1)
  {
    __darwin_ct_rune_t v4 = __tolower(*a1);
    uint64_t result = __tolower(*a2);
    if (!(_DWORD)result) {
      break;
    }
    ++a1;
    ++a2;
  }

  return result;
}

uint64_t strncmp_prefix(unsigned __int8 *a1, uint64_t a2, unsigned __int8 *a3)
{
  size_t v3 = a3;
  for (uint64_t i = a2; i; --i)
  {
    unsigned int v6 = *v3++;
    unsigned int v5 = v6;
    if (!v6) {
      return 0LL;
    }
    unsigned int v8 = *a1++;
    unsigned int v7 = v8;
    if (v8 < v5) {
      return 0xFFFFFFFFLL;
    }
    if (v7 > v5) {
      return 1LL;
    }
  }

  if (a3[a2]) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0LL;
  }
}

uint64_t strnicmp_prefix(unsigned __int8 *a1, uint64_t a2, _BYTE *a3)
{
  if (a2)
  {
    uint64_t v4 = a2;
    while (1)
    {
      __darwin_ct_rune_t v6 = __tolower(*a1);
      uint64_t result = __tolower(*a3);
      if (!(_DWORD)result) {
        break;
      }
      --v4;
      ++a1;
      ++a3;
      if (!v4) {
        goto LABEL_8;
      }
    }
  }

  else
  {
LABEL_8:
    if (*a3) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t strncmpx(unsigned __int8 *a1, uint64_t a2, unsigned __int8 *a3)
{
  size_t v3 = a3;
  for (uint64_t i = a2; i; --i)
  {
    unsigned int v6 = *a1++;
    unsigned int v5 = v6;
    unsigned int v8 = *v3++;
    unsigned int v7 = v8;
    BOOL v9 = v5 > v8;
    if (v5 < v8) {
      return 0xFFFFFFFFLL;
    }
    if (v9) {
      return 1LL;
    }
    if (!v7) {
      return 0LL;
    }
  }

  if (a3[a2]) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0LL;
  }
}

uint64_t strnicmp_suffix(uint64_t a1, unint64_t a2, char *__s)
{
  unint64_t v5 = 0LL;
  if (a2)
  {
    while (*(_BYTE *)(a1 + v5))
    {
      if (a2 == ++v5)
      {
        unint64_t v5 = a2;
        break;
      }
    }
  }

  size_t v6 = strlen(__s);
  if (v5 >= v6) {
    return strnicmpx((unsigned __int8 *)(a1 + v5 - v6), v6, __s);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t strnicmpx(unsigned __int8 *a1, uint64_t a2, _BYTE *a3)
{
  if (a2)
  {
    uint64_t v4 = a2;
    while (1)
    {
      --v4;
      __darwin_ct_rune_t v6 = __tolower(*a1);
      uint64_t result = __tolower(*a3);
      if (!(_DWORD)result) {
        return result;
      }
      ++a1;
      ++a3;
      if (!v4) {
        goto LABEL_8;
      }
    }
  }

  else
  {
LABEL_8:
    if (*a3) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

_BYTE *stristr(_BYTE *a1, _BYTE *a2)
{
  if (a2 && *a2)
  {
    __darwin_ct_rune_t v4 = __tolower(*a2);
    while (*a1)
    {
      if (__tolower(*a1) == v4)
      {
        uint64_t v5 = 1LL;
        do
        {
          __darwin_ct_rune_t v6 = __tolower(a1[v5]);
          __darwin_ct_rune_t v7 = __tolower(a2[v5++]);
          if (v6) {
            BOOL v8 = v6 == v7;
          }
          else {
            BOOL v8 = 0;
          }
        }

        while (v8);
        if (!v7) {
          return a1;
        }
      }

      ++a1;
    }

    return 0LL;
  }

  return a1;
}

const char *strncasestr(const char *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5 = (const char *)(a2 + 1);
  __darwin_ct_rune_t v6 = __tolower(*a2) << 24;
  if (v6)
  {
    size_t v7 = strlen(v5);
    for (size_t i = a3 - 1; i != -1LL; --i)
    {
      __darwin_ct_rune_t v9 = __tolower(*(unsigned __int8 *)a1) << 24;
      if (!v9) {
        break;
      }
      if (v9 == v6)
      {
        if (v7 > i) {
          return 0LL;
        }
        if (!strncasecmp(a1 + 1, v5, v7)) {
          return a1;
        }
      }

      ++a1;
    }

    return 0LL;
  }

  return a1;
}

unint64_t memrchr(unint64_t a1, int a2, uint64_t a3)
{
  unint64_t result = a1 + a3;
  while (result > a1)
  {
    int v5 = *(unsigned __int8 *)--result;
    if (v5 == a2) {
      return result;
    }
  }

  return 0LL;
}

uint64_t memrlen(uint64_t a1, uint64_t a2)
{
  while (a2)
  {
    uint64_t v2 = a2 - 1;
  }

  return 0LL;
}

char *CUTrimText(char *a1, char *a2, char **a3)
{
  __darwin_ct_rune_t v4 = a2;
  int v5 = a1;
  uint64_t v6 = MEMORY[0x1895F8770];
  if (a1 < a2)
  {
    uint64_t v7 = a2 - a1;
    while (1)
    {
      uint64_t v8 = *v5;
      if (*v5 < 0)
      {
        if (!__maskrune(v8, 0x4000uLL)) {
          break;
        }
      }

      else if ((*(_DWORD *)(v6 + 4 * v8 + 60) & 0x4000) == 0)
      {
        break;
      }

      ++v5;
      if (!--v7)
      {
        int v5 = v4;
        break;
      }
    }
  }

  while (1)
  {
    __darwin_ct_rune_t v9 = v4;
    if (v5 >= v4) {
      break;
    }
    --v4;
    uint64_t v10 = *(v9 - 1);
    if (*(v9 - 1) < 0)
    {
      if (!__maskrune(v10, 0x4000uLL)) {
        break;
      }
    }

    else if ((*(_DWORD *)(v6 + 4 * v10 + 60) & 0x4000) == 0)
    {
      break;
    }
  }

  *a3 = v9;
  return v5;
}

unint64_t TruncatedUTF8Length(char *__s, size_t a2, unint64_t a3)
{
  if (a2 == -1LL) {
    a2 = strlen(__s);
  }
  if (a2 >= a3) {
    unint64_t result = a3;
  }
  else {
    unint64_t result = a2;
  }
  while (result)
  {
    if ((__s[result - 1] & 0x80000000) == 0) {
      return result;
    }
    unsigned int v6 = __s[result - 1];
    if (v6 > 0xBF || result == 1)
    {
      LOBYTE(v_Block_object_dispose(va, 8) = 0;
      char v9 = 0;
      unsigned int v12 = 1;
      --result;
    }

    else
    {
      char v10 = 0;
      unint64_t v11 = result - 2;
      unsigned int v12 = 1;
      while (1)
      {
        char v9 = v6;
        unsigned int v13 = v12;
        if ((__s[v11] & 0x80000000) == 0) {
          break;
        }
        unsigned int v6 = __s[v11];
        ++v12;
        BOOL v15 = v11-- != 0;
        if (v6 <= 0xBF)
        {
          char v10 = v9;
          if (v15) {
            continue;
          }
        }

        unint64_t result = v11 + 1;
        unsigned int v8 = v13;
        goto LABEL_22;
      }

      unsigned int v8 = v12 - 1;
      unint64_t result = v11 + 1;
      char v9 = v10;
LABEL_22:
      if (v8 >= 6) {
        continue;
      }
    }

    if ((((255 << (v8 ^ 7)) | (1 << (6 - v8))) & v6) == (255 << (v8 ^ 7))
      && (v6 != 237 || (v9 & 0xF0) != 0xA0))
    {
      result += v12;
      return result;
    }
  }

  return result;
}

const char *GetLastFilePathSegment(char *__s, uint64_t a2, size_t *a3)
{
  __darwin_ct_rune_t v4 = __s;
  if (a2 != -1)
  {
    int v5 = &__s[a2];
    if (a2 >= 1)
    {
      unsigned int v6 = __s;
      do
      {
        int v7 = *v6++;
        if (v7 == 47) {
          __darwin_ct_rune_t v4 = v6;
        }
      }

      while (v6 < v5);
    }

    if (a3)
    {
      size_t v8 = v5 - v4;
      goto LABEL_17;
    }

    return v4;
  }

  for (size_t i = __s + 1; *(i - 1) == 47; ++i)
  {
    __darwin_ct_rune_t v4 = i;
LABEL_14:
    ;
  }

  if (*(i - 1)) {
    goto LABEL_14;
  }
  if (a3)
  {
    size_t v8 = strlen(v4);
LABEL_17:
    *a3 = v8;
  }

  return v4;
}

uint64_t LevenshteinDistance( char *__s, uint64_t a2, const char *a3, size_t a4, int a5, int a6, int a7, int a8, int *a9)
{
  int v11 = a2;
  if (a2 == -1) {
    int v11 = strlen(__s);
  }
  unsigned int v13 = a9;
  if (a4 == -1LL) {
    a4 = strlen(a3);
  }
  size_t v14 = (uint64_t)((a4 << 32) + 0x100000000LL) >> 30;
  BOOL v15 = malloc(v14);
  if (!v15)
  {
    int v39 = -6728;
    uint64_t v38 = 0x7FFFFFFFLL;
    if (!a9) {
      return v38;
    }
    goto LABEL_34;
  }

  int v16 = v15;
  uint64_t v17 = malloc(v14);
  if (v17)
  {
    char v18 = v17;
    int v19 = malloc(v14);
    if (v19)
    {
      if ((a4 & 0x80000000) == 0)
      {
        int v20 = 0;
        uint64_t v21 = (a4 + 1);
        int v22 = v18;
        do
        {
          *v22++ = v20;
          v20 += a7;
          --v21;
        }

        while (v21);
      }

      uint64_t v41 = a4 << 32;
      if (v11 < 1)
      {
        uint64_t v37 = v19;
      }

      else
      {
        uint64_t v23 = 0LL;
        uint64_t v42 = v11;
        int v43 = a4;
        uint64_t v48 = a4;
        do
        {
          int64_t v46 = v18;
          uint64_t v47 = v16;
          char v18 = v19;
          uint64_t v44 = v23 + 1;
          *int v19 = (v23 + 1) * a8;
          if ((int)a4 >= 1)
          {
            uint64_t v24 = 0LL;
            int v25 = *v46;
            do
            {
              __darwin_ct_rune_t v26 = __tolower(__s[v23]);
              __darwin_ct_rune_t v27 = __tolower(a3[v24]);
              int v28 = a6;
              if (v26 == v27) {
                int v28 = 0;
              }
              int v29 = v28 + v25;
              int v30 = &v18[v24];
              v30[1] = v29;
              if (v23)
              {
                if (v24)
                {
                  __darwin_ct_rune_t v31 = __tolower(__s[(v23 - 1)]);
                  if (v31 == __tolower(a3[v24]))
                  {
                    __darwin_ct_rune_t v32 = __tolower(__s[v23]);
                    uint64_t v33 = (v24 - 1);
                    if (v32 == __tolower(a3[v33]))
                    {
                      int v34 = v16[v33] + a5;
                      if (v29 > v34) {
                        v30[1] = v34;
                      }
                    }
                  }
                }
              }

              int v35 = v30[1];
              int v25 = v46[v24 + 1];
              if (v35 > v25 + a8)
              {
                v30[1] = v25 + a8;
                int v35 = v25 + a8;
              }

              int v36 = v18[v24] + a7;
              if (v35 > v36) {
                v30[1] = v36;
              }
              ++v24;
            }

            while (v48 != v24);
          }

          LODWORD(a4) = v43;
          ++v23;
          int v16 = v46;
          uint64_t v37 = v47;
          int v19 = v47;
        }

        while (v44 != v42);
      }

      uint64_t v38 = *(unsigned int *)((char *)v18 + (v41 >> 30));
      free(v16);
      int v39 = 0;
      int v16 = v18;
      char v18 = v37;
      unsigned int v13 = a9;
    }

    else
    {
      int v39 = -6728;
      uint64_t v38 = 0x7FFFFFFFLL;
    }

    free(v16);
    int v16 = v18;
  }

  else
  {
    int v39 = -6728;
    uint64_t v38 = 0x7FFFFFFFLL;
  }

  free(v16);
  if (v13) {
LABEL_34:
  }
    int *v13 = v39;
  return v38;
}

uint64_t MapStringToValue( char *__s1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v16 = (const char **)&a9;
  while (1)
  {
    int v11 = v16;
    uint64_t v17 = (unsigned int *)(v16 + 1);
    unsigned int v12 = *v11;
    if (!*v11) {
      break;
    }
    unsigned int v13 = v17;
    int v16 = (const char **)(v17 + 2);
    uint64_t v14 = *v13;
    if (!strcmp(__s1, v12)) {
      return v14;
    }
  }

  return a2;
}

const char *MIMETypeToExtension(uint64_t a1)
{
  uint64_t v3 = a1;
  id v1 = bsearch(&v3, kMIMEMap, 0x10uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_MIMETypeMatch);
  if (v1) {
    return (const char *)v1[1];
  }
  else {
    return "";
  }
}

uint64_t _MIMETypeMatch(const char **a1, const char **a2)
{
  return strcasecmp(*a1, *a2);
}

uint64_t NMEAParse(uint64_t a1, char a2, char *__s, int64_t a4, char **a5)
{
  int64_t v6 = a4;
  if (a4 == -1) {
    int64_t v6 = strlen(__s);
  }
  char v10 = &__s[v6];
  *(_DWORD *)(a1 + 30_Block_object_dispose(va, 8) = 0;
  *(_OWORD *)(a1 + 244) = 0u;
  *(_OWORD *)(a1 + 22_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_OWORD *)(a1 + 196) = 0u;
  *(_OWORD *)(a1 + 180) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  *(_OWORD *)(a1 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 100) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_OWORD *)(a1 + 276) = 0u;
  *(_OWORD *)(a1 + 292) = 0u;
  *(_OWORD *)(a1 + 260) = 0u;
  *(_DWORD *)a1 = a2 & 0x10;
  if ((a2 & 8) != 0)
  {
    int v11 = __s;
    if (v6 >= 1)
    {
      int v11 = __s;
      do
      {
        if (*v11 == 36) {
          break;
        }
        ++v11;
      }

      while (v11 < v10);
    }
  }

  else
  {
    int v11 = __s;
    if (v6 >= 1)
    {
      uint64_t v12 = MEMORY[0x1895F8770];
      int v11 = __s;
      do
      {
        uint64_t v13 = *v11;
        if (*v11 < 0)
        {
          if (!__maskrune(v13, 0x4000uLL)) {
            break;
          }
        }

        else if ((*(_DWORD *)(v12 + 4 * v13 + 60) & 0x4000) == 0)
        {
          break;
        }

        ++v11;
      }

      while (v11 < v10);
    }
  }

  if (v11 >= v10)
  {
    if (a5) {
      *a5 = v11;
    }
    return 4294960569LL;
  }

  if (*v11 == 36)
  {
    ++v11;
    *(_DWORD *)a1 |= 1u;
  }

  uint64_t v14 = v11;
  if (v11 < v10)
  {
    BOOL v15 = (char *)(&__s[v6] - v11);
    uint64_t v14 = v11;
    while (1)
    {
      int v16 = *v14;
      if (v16 == 10 || v16 == 13) {
        break;
      }
      ++v14;
      if (!--v15)
      {
        uint64_t v14 = &__s[v6];
        break;
      }
    }
  }

  if (a5)
  {
    char v18 = v14;
    if (v14 < v10)
    {
      int v19 = (char *)(&__s[v6] - v14);
      char v18 = v14;
      while (1)
      {
        int v20 = *v18;
        if (v20 != 13 && v20 != 10) {
          break;
        }
        ++v18;
        if (!--v19)
        {
          char v18 = &__s[v6];
          break;
        }
      }
    }

    *a5 = v18;
  }

  if (v11 >= v14)
  {
LABEL_42:
    uint64_t v24 = v14;
  }

  else
  {
    unsigned __int8 v22 = 0;
    uint64_t v23 = v11;
    uint64_t v24 = v11;
    while (1)
    {
      int v25 = *v24;
      if (v25 == 42) {
        break;
      }
      v22 ^= v25;
      ++v24;
      if (v14 == ++v23) {
        goto LABEL_42;
      }
    }

    if (v14 - v24 >= 3)
    {
      uint64_t v27 = v24[1];
      if ((*(_DWORD *)(MEMORY[0x1895F8770] + 4 * v27 + 60) & 0x10000) != 0)
      {
        uint64_t v28 = v24[2];
        if ((*(_DWORD *)(MEMORY[0x1895F8770] + 4 * v28 + 60) & 0x10000) != 0)
        {
          unsigned int v29 = v27 - 48;
          unsigned int v30 = v27 - 65;
          else {
            char v31 = v27 - 87;
          }
          char v32 = v27 - 55;
          if (v30 > 5) {
            char v32 = v31;
          }
          if (v29 < 0xA) {
            char v32 = v29;
          }
          char v33 = 16 * v32;
          unsigned int v34 = v28 - 48;
          unsigned int v35 = v28 - 65;
          else {
            char v36 = v28 - 87;
          }
          char v37 = v28 - 55;
          if (v35 > 5) {
            char v37 = v36;
          }
          if (v34 < 0xA) {
            char v37 = v34;
          }
        }
      }
    }

    uint64_t v14 = v24;
  }

  if (v11 >= v24)
  {
    *(_BYTE *)(a1 + 4) = 0;
    uint64_t v38 = (const char *)(a1 + 4);
    int v39 = v11;
    goto LABEL_79;
  }

  if (*v11 == 44)
  {
    *(_BYTE *)(a1 + 4) = 0;
    uint64_t v38 = (const char *)(a1 + 4);
    int v39 = v11;
LABEL_77:
    if (*v39 == 44) {
      ++v39;
    }
    goto LABEL_79;
  }

  uint64_t v40 = 0LL;
  while (&v14[~(unint64_t)v11] != v40)
  {
    int v41 = (v40++)[(void)v11 + 1];
    if (v41 == 44)
    {
      int v39 = &v40[(void)v11];
      goto LABEL_75;
    }
  }

  int v39 = v14;
LABEL_75:
  uint64_t v38 = (const char *)(a1 + 4);
  memcpy((void *)(a1 + 4), v11, v39 - v11);
  *(_BYTE *)(a1 + 4 + v39 - v11) = 0;
  if (v39 < v24) {
    goto LABEL_77;
  }
LABEL_79:
  if (!strcasecmp(v38, "GPGGA"))
  {
    int v102 = 1;
    while (1)
    {
      int64_t v103 = v39;
      if (v39 >= v24)
      {
LABEL_97:
        int v105 = v14;
        int v39 = v24;
        if (v103 == v24)
        {
LABEL_233:
          uint64_t result = 0LL;
          *(_DWORD *)a1 |= 4u;
          return result;
        }
      }

      else
      {
        int64_t v104 = v14 - v39;
        int v105 = v39;
        while (*v105 != 44)
        {
          ++v105;
          if (!--v104) {
            goto LABEL_97;
          }
        }

        int v39 = v105 + 1;
      }

      size_t v106 = v105 - v103;
      switch(v102)
      {
        case 1:
          double v148 = 0.0;
          *(double *)(a1 + 16) = (double)(3600 * v152 + 60 * v151) + 0.0;
          goto LABEL_123;
        case 2:
          LODWORD(v107) = v150;
          *(double *)(a1 + 24) = v148 / 60.0 + (double)v107;
          goto LABEL_123;
        case 3:
          if (v105 == v103) {
            char v108 = 63;
          }
          else {
            char v108 = *v103;
          }
          *(_BYTE *)(a1 + 32) = v108;
          goto LABEL_123;
        case 4:
          LODWORD(v109) = v150;
          *(double *)(a1 + 40) = v148 / 60.0 + (double)v109;
LABEL_123:
          ++v102;
          break;
        case 5:
          if (v105 == v103) {
            char v110 = 63;
          }
          else {
            char v110 = *v103;
          }
          *(_BYTE *)(a1 + 4_Block_object_dispose(va, 8) = v110;
          goto LABEL_123;
        case 6:
          if (v105 == v103) {
            char v111 = 63;
          }
          else {
            char v111 = *v103;
          }
          *(_BYTE *)(a1 + 49) = v111;
          goto LABEL_123;
        case 7:
          SNScanF(v103, v106, "%u", v42, v43, v44, v45, v46, a1 + 52);
          goto LABEL_123;
        case 8:
          SNScanF(v103, v106, "%lf", v42, v43, v44, v45, v46, a1 + 56);
          goto LABEL_123;
        case 9:
          int v112 = a1 + 64;
          goto LABEL_122;
        case 10:
          if (v105 == v103) {
            char v113 = 63;
          }
          else {
            char v113 = *v103;
          }
          *(_BYTE *)(a1 + 72) = v113;
          goto LABEL_123;
        case 11:
          int v112 = a1 + 80;
          goto LABEL_122;
        case 12:
          if (v105 == v103) {
            char v114 = 63;
          }
          else {
            char v114 = *v103;
          }
          *(_BYTE *)(a1 + 8_Block_object_dispose(va, 8) = v114;
          goto LABEL_123;
        case 13:
          int v112 = a1 + 96;
LABEL_122:
          SNScanF(v103, v106, "%lf", v42, v43, v44, v45, v46, v112);
          goto LABEL_123;
        case 14:
          SNScanF(v103, v106, "%.s", v42, v43, v44, v45, v46, 8);
          goto LABEL_123;
        default:
          goto LABEL_123;
      }
    }
  }

  if (!strcasecmp(v38, "GPGLL"))
  {
    for (int i = 1; ; ++i)
    {
      uint64_t v116 = v39;
      if (v39 >= v24)
      {
LABEL_140:
        int v118 = v14;
        int v39 = v24;
        if (v116 == v24) {
          goto LABEL_233;
        }
      }

      else
      {
        int64_t v117 = v14 - v39;
        int v118 = v39;
        while (*v118 != 44)
        {
          ++v118;
          if (!--v117) {
            goto LABEL_140;
          }
        }

        int v39 = v118 + 1;
      }

      size_t v119 = v118 - v116;
      switch(i)
      {
        case 1:
          LODWORD(v120) = v149;
          *(double *)(a1 + 16) = v148 / 60.0 + (double)v120;
          break;
        case 2:
          if (v118 == v116) {
            char v121 = 63;
          }
          else {
            char v121 = *v116;
          }
          *(_BYTE *)(a1 + 24) = v121;
          break;
        case 3:
          LODWORD(v122) = v149;
          *(double *)(a1 + 32) = v148 / 60.0 + (double)v122;
          break;
        case 4:
          if (v118 == v116) {
            char v123 = 63;
          }
          else {
            char v123 = *v116;
          }
          *(_BYTE *)(a1 + 40) = v123;
          break;
        case 5:
          double v148 = 0.0;
          *(double *)(a1 + 4_Block_object_dispose(va, 8) = (double)(3600 * v152 + 60 * v151 + v150) + 0.0;
          break;
        case 6:
          if (v118 == v116) {
            char v124 = 63;
          }
          else {
            char v124 = *v116;
          }
          *(_BYTE *)(a1 + 56) = v124;
          break;
        case 7:
          if (v118 == v116) {
            char v125 = 63;
          }
          else {
            char v125 = *v116;
          }
          *(_BYTE *)(a1 + 57) = v125;
          break;
        default:
          continue;
      }
    }
  }

  if (!strcasecmp(v38, "GPGSA"))
  {
    for (int j = 1; ; ++j)
    {
      uint64_t v127 = v39;
      if (v39 >= v24)
      {
LABEL_172:
        int v129 = v14;
        int v39 = v24;
        if (v127 == v24) {
          goto LABEL_233;
        }
      }

      else
      {
        int64_t v128 = v14 - v39;
        int v129 = v39;
        while (*v129 != 44)
        {
          ++v129;
          if (!--v128) {
            goto LABEL_172;
          }
        }

        int v39 = v129 + 1;
      }

      size_t v130 = v129 - v127;
      if ((j - 3) >= 0xC)
      {
        if (j <= 14)
        {
          if (j == 1)
          {
            if (v129 == v127) {
              char v132 = 63;
            }
            else {
              char v132 = *v127;
            }
            *(_BYTE *)(a1 + 16) = v132;
          }

          else if (j == 2)
          {
            if (v129 == v127) {
              char v131 = 63;
            }
            else {
              char v131 = *v127;
            }
            *(_BYTE *)(a1 + 17) = v131;
          }
        }

        else
        {
          switch(j)
          {
            case 15:
              SNScanF(v127, v130, "%lf", v52, v53, v54, v55, v56, a1 + 72);
              break;
            case 16:
              SNScanF(v127, v130, "%lf", v52, v53, v54, v55, v56, a1 + 80);
              break;
            case 17:
              SNScanF(v127, v130, "%lf", v52, v53, v54, v55, v56, a1 + 88);
              break;
          }
        }
      }

      else
      {
        SNScanF(v127, v130, "%u", v52, v53, v54, v55, v56, a1 + 20 + 4 * (j - 3));
      }
    }
  }

  if (!strcasecmp(v38, "GPGSV"))
  {
    int v133 = a1 + 32;
    int v134 = 1;
    while (1)
    {
      int v135 = v39;
      if (v39 >= v24)
      {
LABEL_200:
        uint64_t v137 = v14;
        int v39 = v24;
        if (v135 == v24) {
          goto LABEL_233;
        }
      }

      else
      {
        int64_t v136 = v14 - v39;
        uint64_t v137 = v39;
        while (*v137 != 44)
        {
          ++v137;
          if (!--v136) {
            goto LABEL_200;
          }
        }

        int v39 = v137 + 1;
      }

      size_t v138 = v137 - v135;
      switch(v134)
      {
        case 1:
          int v141 = a1 + 16;
          goto LABEL_215;
        case 2:
          int v147 = a1 + 20;
          goto LABEL_216;
        case 3:
          int v141 = a1 + 24;
LABEL_215:
          int v147 = v141;
LABEL_216:
          int v140 = "%d";
          goto LABEL_210;
        case 4:
        case 8:
        case 12:
        case 16:
          if (SNScanF( v135,  v138,  "%d",  v57,  v58,  v59,  v60,  v61,  v133 + 32 * ((v134 - 4) >> 2)) != 1) {
            return 4294960554LL;
          }
          ++*(_DWORD *)(a1 + 28);
          goto LABEL_211;
        case 5:
        case 9:
        case 13:
        case 17:
          int v139 = v133 + 32 * ((v134 - 4) >> 2) + 8;
          goto LABEL_209;
        case 6:
        case 10:
        case 14:
        case 18:
          int v139 = v133 + 32 * ((v134 - 4) >> 2) + 16;
          goto LABEL_209;
        case 7:
        case 11:
        case 15:
        case 19:
          int v139 = v133 + 32 * ((v134 - 4) >> 2) + 24;
LABEL_209:
          int v147 = v139;
          int v140 = "%lf";
LABEL_210:
          return 4294960554LL;
        default:
LABEL_211:
          ++v134;
          break;
      }
    }
  }

  if (!strcasecmp(v38, "GPHDT"))
  {
    for (int k = 1; ; ++k)
    {
      if (v39 >= v24)
      {
LABEL_222:
        uint64_t v144 = v14;
        unint64_t v145 = v24;
        if (v39 == v24) {
          goto LABEL_233;
        }
      }

      else
      {
        int64_t v143 = v14 - v39;
        uint64_t v144 = v39;
        while (*v144 != 44)
        {
          ++v144;
          if (!--v143) {
            goto LABEL_222;
          }
        }

        unint64_t v145 = v144 + 1;
      }

      if (k == 2)
      {
        if (v144 == v39) {
          char v146 = 63;
        }
        else {
          char v146 = *v39;
        }
        *(_BYTE *)(a1 + 24) = v146;
      }

      else if (k == 1)
      {
        SNScanF(v39, v144 - v39, "%lf", v62, v63, v64, v65, v66, a1 + 16);
      }

      int v39 = v145;
    }
  }

  if (!strcasecmp(v38, "GPRMC")) {
    return _NMEAParseGPRMC(a1, v39, v24, v67, v68, v69, v70, v71);
  }
  if (!strcasecmp(v38, "GPVTG"))
  {
    _NMEAParseGPVTG(a1, v39, v24, v72, v73, v74, v75, v76);
    return 0LL;
  }

  if (!strcasecmp(v38, "GPZDA")) {
    return _NMEAParseGPZDA(a1, v39, v24, v77, v78, v79, v80, v81);
  }
  if (!strcasecmp(v38, "OHPR"))
  {
    _NMEAParseOHPR(a1, v39, v24, v82, v83, v84, v85, v86);
    return 0LL;
  }

  if (!strcasecmp(v38, "PAACD")) {
    return _NMEAParsePAACD(a1, v39, v24, v87, v88, v89, v90, v91);
  }
  if (strcasecmp(v38, "PAGCD"))
  {
    if (!strcasecmp(v38, "PASCD")) {
      return _NMEAParsePASCD(a1, v39, v24, v97, v98, v99, v100, v101);
    }
    return 0LL;
  }

  return _NMEAParsePAGCD(a1, v39, v24, v92, v93, v94, v95, v96);
}

uint64_t _NMEAParseGPRMC( uint64_t a1, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v29 = a1 + 88;
  int v11 = a1 + 72;
  int v12 = a1 + 64;
  int v13 = 1;
  while (1)
  {
    uint64_t v14 = a2;
    if (a2 < a3)
    {
      uint64_t v15 = 0LL;
      while (1)
      {
        int v16 = &a2[v15];
        if (a2[v15] == 44) {
          break;
        }
        if (a3 - a2 == ++v15) {
          goto LABEL_6;
        }
      }

      unsigned int v35 = a2;
      a2 = v16 + 1;
      goto LABEL_9;
    }

char *_NMEAParseGPVTG( uint64_t a1, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a1 + 64;
  int v12 = a1 + 48;
  int v13 = a1 + 16;
  int v14 = a1 + 32;
  for (int i = 1; ; ++i)
  {
    uint64_t result = a2;
    if (a2 >= a3) {
      break;
    }
    int64_t v17 = a3 - a2;
    double v18 = a2;
    while (*v18 != 44)
    {
      ++v18;
      if (!--v17) {
        goto LABEL_6;
      }
    }

    a2 = v18 + 1;
LABEL_9:
    size_t v19 = v18 - result;
    switch(i)
    {
      case 1:
        SNScanF(result, v19, "%lf", a4, a5, a6, a7, a8, v13);
        break;
      case 2:
        if (v18 == result) {
          char v20 = 63;
        }
        else {
          char v20 = *result;
        }
        *(_BYTE *)(a1 + 24) = v20;
        break;
      case 3:
        SNScanF(result, v19, "%lf", a4, a5, a6, a7, a8, v14);
        break;
      case 4:
        if (v18 == result) {
          char v21 = 63;
        }
        else {
          char v21 = *result;
        }
        *(_BYTE *)(a1 + 40) = v21;
        break;
      case 5:
        SNScanF(result, v19, "%lf", a4, a5, a6, a7, a8, v12);
        break;
      case 6:
        if (v18 == result) {
          char v22 = 63;
        }
        else {
          char v22 = *result;
        }
        *(_BYTE *)(a1 + 56) = v22;
        break;
      case 7:
        SNScanF(result, v19, "%lf", a4, a5, a6, a7, a8, v11);
        break;
      case 8:
        if (v18 == result) {
          char v23 = 63;
        }
        else {
          char v23 = *result;
        }
        *(_BYTE *)(a1 + 72) = v23;
        break;
      case 9:
        if (v18 == result) {
          char v24 = 63;
        }
        else {
          char v24 = *result;
        }
        *(_BYTE *)(a1 + 73) = v24;
        break;
      default:
        continue;
    }
  }

uint64_t _NMEAParseGPZDA( uint64_t a1, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v23 = a1 + 16;
  int v24 = a1 + 48;
  int v21 = a1 + 40;
  int v22 = a1 + 44;
  int v11 = (_DWORD *)(a1 + 36);
  int v12 = (_DWORD *)(a1 + 32);
  int v13 = 1;
  while (1)
  {
    int v14 = a2;
    if (a2 >= a3) {
      break;
    }
    int64_t v15 = a3 - a2;
    int v16 = a2;
    while (*v16 != 44)
    {
      ++v16;
      if (!--v15) {
        goto LABEL_6;
      }
    }

    a2 = v16 + 1;
LABEL_9:
    size_t v17 = v16 - v14;
    switch(v13)
    {
      case 1:
        return 4294960554LL;
      case 2:
        SNScanF(v14, v17, "%u", a4, a5, a6, a7, a8, (int)v12);
        if (*v12 >= 0x20u) {
          return 4294960554LL;
        }
        goto LABEL_20;
      case 3:
        SNScanF(v14, v17, "%u", a4, a5, a6, a7, a8, (int)v11);
        if (*v11 < 0xDu) {
          goto LABEL_20;
        }
        return 4294960554LL;
      case 4:
        SNScanF(v14, v17, "%u", a4, a5, a6, a7, a8, v21);
        goto LABEL_20;
      case 5:
        int v18 = v22;
        goto LABEL_19;
      case 6:
        int v18 = v24;
LABEL_19:
        SNScanF(v14, v17, "%d", a4, a5, a6, a7, a8, v18);
        goto LABEL_20;
      default:
LABEL_20:
        ++v13;
        break;
    }
  }

uint64_t _NMEAParseOHPR( uint64_t result, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = result + 48;
  int v11 = result + 16;
  int v12 = result + 40;
  int v13 = result + 32;
  char v20 = (_DWORD *)result;
  int v14 = result + 24;
  int v15 = 1;
  while (a2 < a3)
  {
    int64_t v16 = a3 - a2;
    size_t v17 = a2;
    while (*v17 != 44)
    {
      ++v17;
      if (!--v16) {
        goto LABEL_6;
      }
    }

    int v18 = v17 + 1;
LABEL_9:
    int v19 = v11;
    switch(v15)
    {
      case 1:
        goto LABEL_14;
      case 2:
        int v19 = v14;
        goto LABEL_14;
      case 3:
        int v19 = v13;
        goto LABEL_14;
      case 4:
        int v19 = v12;
        goto LABEL_14;
      case 5:
        int v19 = v10;
LABEL_14:
        uint64_t result = SNScanF(a2, v17 - a2, "%lf", a4, a5, a6, a7, a8, v19);
        break;
      default:
        break;
    }

    ++v15;
    a2 = v18;
  }

uint64_t _NMEAParsePAACD( uint64_t a1, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a1 + 32;
  int v27 = a1 + 24;
  int v28 = a1 + 16;
  int v25 = a1 + 32;
  __srCC_SHA1_CTX c = (void *)(a1 + 48);
  for (int i = 1; ; ++i)
  {
    int v13 = a2;
    if (a2 >= a3)
    {
LABEL_6:
      int v15 = a3;
      a2 = a3;
      if (v13 == a3)
      {
        uint64_t result = 0LL;
        *(_DWORD *)a1 |= 4u;
        return result;
      }
    }

    else
    {
      int64_t v14 = a3 - a2;
      int v15 = a2;
      while (*v15 != 44)
      {
        ++v15;
        if (!--v14) {
          goto LABEL_6;
        }
      }

      a2 = v15 + 1;
    }

    size_t v16 = v15 - v13;
    if (i == 3)
    {
      SNScanF(v13, v15 - v13, "%u", a4, a5, a6, a7, a8, v11);
      continue;
    }

    if (i == 2)
    {
      int v18 = v27;
      goto LABEL_15;
    }

    int v17 = i - 1;
    if (i == 1)
    {
      int v18 = v28;
LABEL_15:
      SNScanF(v13, v16, "%lf", a4, a5, a6, a7, a8, v18);
      continue;
    }

    if (i >= 4) {
      int v17 = i - 4;
    }
    uint64_t v19 = (uint64_t)v17 >> 2;
    LODWORD(v20) = (_DWORD)__src;
    *(void *)(a1 + 40) = __src;
LABEL_24:
    int v21 = i - 4 - 4 * v19;
    if (v21 == 2)
    {
      SNScanF(v13, v16, "%lf", a4, a5, a6, a7, a8, (_DWORD)v20 + 32 * v19 + 16);
    }

    else
    {
      if (v21 == 1)
      {
        SNScanF(v13, v16, "%lf", a4, a5, a6, a7, a8, (_DWORD)v20 + 32 * v19 + 8);
      }

      else if (!v21)
      {
        SNScanF(v13, v16, "%lf", a4, a5, a6, a7, a8, (_DWORD)v20 + 32 * v19);
        ++*(_DWORD *)(a1 + 36);
      }

      SNScanF(v13, v16, "%lf", a4, a5, a6, a7, a8, (_DWORD)v20 + 32 * v19 + 24);
    }

uint64_t _NMEAParsePAGCD( uint64_t a1, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a1 + 24;
  __srCC_SHA1_CTX c = (void *)(a1 + 40);
  int v30 = a1 + 16;
  int v12 = 1;
  int v28 = a1 + 24;
  while (1)
  {
    int v13 = a2;
    if (a2 >= a3)
    {
LABEL_6:
      int v15 = a3;
      a2 = a3;
      if (v13 == a3)
      {
        uint64_t result = 0LL;
        *(_DWORD *)a1 |= 4u;
        return result;
      }
    }

    else
    {
      int64_t v14 = a3 - a2;
      int v15 = a2;
      while (*v15 != 44)
      {
        ++v15;
        if (!--v14) {
          goto LABEL_6;
        }
      }

      a2 = v15 + 1;
    }

    size_t v16 = v15 - v13;
    if (v12 == 2)
    {
      int v27 = v11;
      int v17 = v13;
      size_t v18 = v15 - v13;
      uint64_t v19 = "%u";
      goto LABEL_14;
    }

    if (v12 == 1)
    {
      int v27 = v30;
      int v17 = v13;
      size_t v18 = v15 - v13;
LABEL_12:
      uint64_t v19 = "%lf";
LABEL_14:
      SNScanF(v17, v18, (unsigned __int8 *)v19, a4, a5, a6, a7, a8, v27);
      goto LABEL_30;
    }

    if (v12 >= 3) {
      int v20 = v12 - 3;
    }
    else {
      int v20 = v12;
    }
    uint64_t v21 = (uint64_t)v20 >> 2;
    if ((v20 >> 2) < 8)
    {
      LODWORD(v22) = (_DWORD)__src;
      *(void *)(a1 + 32) = __src;
      goto LABEL_23;
    }

    if ((*(_BYTE *)a1 & 0x10) == 0) {
      goto LABEL_30;
    }
    int v22 = *(char **)(a1 + 32);
LABEL_23:
    int v23 = v12 - 3 - 4 * v21;
    switch(v23)
    {
      case 2:
        int v27 = (_DWORD)v22 + 32 * v21 + 16;
        int v17 = v13;
        size_t v18 = v16;
        goto LABEL_12;
      case 1:
        SNScanF(v13, v16, "%lf", a4, a5, a6, a7, a8, (_DWORD)v22 + 32 * v21 + 8);
        break;
      case 0:
        SNScanF(v13, v16, "%lf", a4, a5, a6, a7, a8, (_DWORD)v22 + 32 * v21);
        ++*(_DWORD *)(a1 + 28);
        break;
    }

    SNScanF(v13, v16, "%lf", a4, a5, a6, a7, a8, (_DWORD)v22 + 32 * v21 + 24);
LABEL_30:
    ++v12;
  }

  size_t v16 = 32 * v21 + 32;
  int v24 = (char *)realloc(*(void **)(a1 + 296), v16);
  if (v24)
  {
    int v22 = v24;
    if (!*(void *)(a1 + 296)) {
      memcpy(v24, __src, 32 * v21);
    }
    int v25 = &v22[32 * v21];
    *(_OWORD *)int v25 = 0u;
    *((_OWORD *)v25 + 1) = 0u;
    *(void *)(a1 + 296) = v22;
    *(void *)(a1 + 32) = v22;
    int v11 = v28;
    goto LABEL_23;
  }

  return 4294960568LL;
}

uint64_t _NMEAParsePASCD( uint64_t a1, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a1 + 32;
  int v30 = a1 + 28;
  int v31 = a1 + 16;
  __srCC_SHA1_CTX c = (void *)(a1 + 48);
  int v12 = 1;
  while (2)
  {
    int v13 = a2;
    if (a2 >= a3)
    {
LABEL_6:
      int v15 = a3;
      a2 = a3;
      if (v13 == a3)
      {
        uint64_t result = 0LL;
        *(_DWORD *)a1 |= 4u;
        return result;
      }
    }

    else
    {
      int64_t v14 = a3 - a2;
      int v15 = a2;
      while (*v15 != 44)
      {
        ++v15;
        if (!--v14) {
          goto LABEL_6;
        }
      }

      a2 = v15 + 1;
    }

    size_t v16 = v15 - v13;
    switch(v12)
    {
      case 1:
        int v28 = v31;
        int v17 = v13;
        size_t v18 = v15 - v13;
        goto LABEL_32;
      case 2:
        if (v16) {
          char v22 = *v13;
        }
        else {
          char v22 = 63;
        }
        *(_BYTE *)(a1 + 24) = v22;
        goto LABEL_34;
      case 3:
        if (v16) {
          char v23 = *v13;
        }
        else {
          char v23 = 63;
        }
        *(_BYTE *)(a1 + 25) = v23;
        goto LABEL_34;
      case 4:
        int v28 = v30;
        goto LABEL_23;
      case 5:
        int v28 = v11;
LABEL_23:
        int v17 = v13;
        size_t v18 = v15 - v13;
        int v24 = "%u";
        goto LABEL_33;
      default:
        int v19 = v12 - 6;
        if (v12 < 6) {
          int v19 = v12 - 5;
        }
        uint64_t v20 = (uint64_t)v19 >> 1;
        if ((v19 >> 1) < 8)
        {
          LODWORD(v21) = (_DWORD)__src;
          *(void *)(a1 + 40) = __src;
          goto LABEL_25;
        }

        if ((*(_BYTE *)a1 & 0x10) == 0) {
          goto LABEL_34;
        }
        if (v20 < *(_DWORD *)(a1 + 36))
        {
          uint64_t v21 = *(char **)(a1 + 40);
          goto LABEL_25;
        }

        size_t v16 = 16 * v20 + 16;
        int v25 = (char *)realloc(*(void **)(a1 + 176), v16);
        if (v25)
        {
          uint64_t v21 = v25;
          if (!*(void *)(a1 + 176)) {
            memcpy(v25, __src, 16 * v20);
          }
          char v26 = &v21[16 * v20];
          *(void *)char v26 = 0LL;
          *((void *)v26 + 1) = 0LL;
          *(void *)(a1 + 176) = v21;
          *(void *)(a1 + 40) = v21;
LABEL_25:
          if ((v12 & 1) != 0)
          {
            int v28 = (_DWORD)v21 + 16 * v20 + 8;
            int v17 = v13;
            size_t v18 = v16;
LABEL_32:
            int v24 = "%lf";
LABEL_33:
            SNScanF(v17, v18, (unsigned __int8 *)v24, a4, a5, a6, a7, a8, v28);
          }

          else
          {
            SNScanF(v13, v16, "%lf", a4, a5, a6, a7, a8, (_DWORD)v21 + 16 * v20);
            ++*(_DWORD *)(a1 + 36);
          }

void NMEAFree(uint64_t a1)
{
  uint64_t v2 = (const char *)(a1 + 4);
  if (!strcmp((const char *)(a1 + 4), "PAACD"))
  {
    *(_DWORD *)(a1 + 36) = 0;
    *(void *)(a1 + 40) = 0LL;
    uint64_t v3 = *(void **)(a1 + 304);
    if (!v3) {
      return;
    }
    __darwin_ct_rune_t v4 = (void *)(a1 + 304);
    goto LABEL_10;
  }

  if (!strcmp(v2, "PAGCD"))
  {
    *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = 0;
    *(void *)(a1 + 32) = 0LL;
    uint64_t v3 = *(void **)(a1 + 296);
    if (!v3) {
      return;
    }
    __darwin_ct_rune_t v4 = (void *)(a1 + 296);
    goto LABEL_10;
  }

  if (!strcmp(v2, "PASCD"))
  {
    int v5 = *(void **)(a1 + 176);
    __darwin_ct_rune_t v4 = (void *)(a1 + 176);
    uint64_t v3 = v5;
    *((_DWORD *)v4 - 35) = 0;
    *(v4 - 17) = 0LL;
    if (v5)
    {
LABEL_10:
      free(v3);
      *__darwin_ct_rune_t v4 = 0LL;
    }
  }

uint64_t ParseCommandLineIntoArgV(const char *a1, unsigned int *a2, void *a3)
{
  int v5 = a1;
  int64_t v6 = strlen(a1);
  int v7 = malloc(v6 + 1);
  if (!v7) {
    return 4294960568LL;
  }
  size_t v8 = v7;
  char v9 = malloc(0x88uLL);
  if (!v9)
  {
LABEL_57:
    uint64_t v28 = 4294960568LL;
    goto LABEL_53;
  }

  int v10 = v9;
  if (v6 < 1)
  {
    uint64_t v28 = 0LL;
    *char v9 = 0LL;
    *a2 = 0;
    *a3 = v9;
    goto LABEL_53;
  }

  uint64_t v11 = 0LL;
  int v12 = (unsigned __int8 *)&v5[v6];
  int v32 = 16;
  uint64_t v13 = MEMORY[0x1895F8770];
  int64_t v14 = v8;
  do
  {
    while (1)
    {
      uint64_t v15 = *(unsigned __int8 *)v5;
      if (*v5 < 0)
      {
        if (__maskrune(v15, 0x4000uLL)) {
          goto LABEL_7;
        }
        break;
      }

      if ((*(_DWORD *)(v13 + 4 * v15 + 60) & 0x4000) == 0) {
        break;
      }
LABEL_7:
      if (++v5 >= (const char *)v12)
      {
        unsigned int v26 = v11;
        int v27 = v10;
        goto LABEL_50;
      }
    }

    int v30 = a3;
    int v31 = a2;
    uint64_t v16 = 0LL;
    int v17 = 0;
    size_t v18 = v14;
    int v19 = v5;
    while (1)
    {
      do
      {
        while (1)
        {
          int v5 = v19;
          uint64_t v20 = v16;
          while (1)
          {
            uint64_t v16 = v20;
            int v19 = v5 + 1;
            uint64_t v21 = *(unsigned __int8 *)v5;
            if (!(_DWORD)v20) {
              break;
            }
            uint64_t v20 = 0LL;
            ++v5;
            if ((_DWORD)v21 != 39) {
              goto LABEL_15;
            }
          }

          if (!v17) {
            break;
          }
          uint64_t v16 = 0LL;
          int v17 = 0;
          if ((_DWORD)v21 != 34)
          {
            if ((_DWORD)v21 != 92) {
              goto LABEL_34;
            }
            LODWORD(v21) = *(unsigned __int8 *)v19;
            if ((_DWORD)v21 != 10)
            {
              if ((_DWORD)v21 == 92 || (_DWORD)v21 == 34)
              {
                uint64_t v16 = 0LL;
                int v19 = v5 + 2;
              }

              else
              {
LABEL_33:
                uint64_t v16 = 0LL;
                LOBYTE(v21) = 92;
              }

void FreeCommandLineArgV(int a1, void **a2)
{
  if (a2)
  {
    if (*a2) {
      free(*a2);
    }
    free(a2);
  }

uint64_t ParseCommaSeparatedNameValuePair( unsigned __int8 *a1, unint64_t a2, _BYTE *a3, uint64_t a4, void *a5, _BYTE *a6, void *a7, void *a8)
{
  uint64_t v13 = a1;
  if ((unint64_t)a1 >= a2)
  {
    uint64_t result = 4294960569LL;
    if (!a8) {
      return result;
    }
    goto LABEL_5;
  }

  uint64_t result = ParseEscapedString(a1, a2, 0x3Du, a3, a4, a5, &v13);
  if (!(_DWORD)result) {
    uint64_t result = ParseEscapedString(v13, a2, 0x2Cu, a6, 256LL, a7, &v13);
  }
  if (a8) {
LABEL_5:
  }
    *a8 = v13;
  return result;
}

uint64_t ParseEscapedString( unsigned __int8 *a1, unint64_t a2, unsigned __int8 a3, _BYTE *a4, uint64_t a5, void *a6, unsigned __int8 **a7)
{
  if (a5) {
    uint64_t v7 = a5 - 1;
  }
  else {
    uint64_t v7 = 0LL;
  }
  if ((unint64_t)a1 < a2)
  {
    unint64_t v8 = (unint64_t)&a4[v7];
    char v9 = a4;
    while (1)
    {
      int v10 = a1 + 1;
      int v11 = *a1;
      if (v11 == a3)
      {
        ++a1;
        goto LABEL_19;
      }

      if (v11 == 92)
      {
        if ((unint64_t)v10 >= a2)
        {
          uint64_t v12 = 4294960546LL;
          if (!a6) {
            goto LABEL_23;
          }
LABEL_22:
          *a6 = v9 - a4;
          goto LABEL_23;
        }

        LOBYTE(v11) = a1[1];
        a1 += 2;
      }

      else
      {
        ++a1;
      }

      if ((unint64_t)v9 < v8)
      {
        if (a4) {
          *char v9 = v11;
        }
        ++v9;
      }
    }
  }

  char v9 = a4;
LABEL_19:
  uint64_t v12 = 0LL;
  if (a4) {
    *char v9 = 0;
  }
  int v10 = a1;
  if (a6) {
    goto LABEL_22;
  }
LABEL_23:
  if (a7) {
    *a7 = v10;
  }
  return v12;
}

uint64_t ParseLine( unint64_t a1, unint64_t a2, unint64_t *a3, void *a4, unint64_t *a5)
{
  if (a1 == a2) {
    return 0LL;
  }
  unint64_t v5 = a1;
  unint64_t v6 = a1;
  if (a1 >= a2)
  {
LABEL_10:
    *a3 = a1;
    *a4 = v5 - a1;
  }

  else
  {
    uint64_t v7 = 0LL;
    while (1)
    {
      uint64_t v8 = a1 + v7;
      int v9 = *(unsigned __int8 *)(a1 + v7);
      if (v9 == 10 || v9 == 13) {
        break;
      }
      if (a2 - a1 == ++v7)
      {
        unint64_t v5 = a2;
        unint64_t v6 = a2;
        goto LABEL_10;
      }
    }

    *a3 = a1;
    *a4 = v7;
    unint64_t v6 = v8 + 1;
    if (v9 == 13 && v6 < a2)
    {
      int v13 = *(unsigned __int8 *)(v8 + 1);
      unint64_t v14 = v8 + 2;
      if (v13 == 10) {
        unint64_t v6 = v14;
      }
    }
  }

  *a5 = v6;
  return 1LL;
}

uint64_t RegexMatch(unsigned __int8 *a1, _BYTE *a2)
{
  uint64_t v2 = a2;
  if (*a1 == 94) {
    return RegexMatchHere(a1 + 1, a2);
  }
  while (!RegexMatchHere(a1, v2))
  {
    if (!*v2++) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t RegexMatchHere(unsigned __int8 *a1, _BYTE *a2)
{
  __darwin_ct_rune_t v2 = *a1;
  if (*a1)
  {
    __darwin_ct_rune_t v4 = a1;
    while (1)
    {
      __darwin_ct_rune_t v6 = *++v4;
      __darwin_ct_rune_t v5 = v6;
      if (v6 == 42) {
        break;
      }
      __darwin_ct_rune_t v7 = *a2;
      if (v2 == 36 && !v5) {
        return v7 == 0;
      }
      if (!*a2) {
        return 0LL;
      }
      if (v2 != 46)
      {
        __darwin_ct_rune_t v8 = __tolower(v2);
        if (v8 != __tolower(v7)) {
          return 0LL;
        }
        __darwin_ct_rune_t v5 = *v4;
      }

      ++a2;
      __darwin_ct_rune_t v2 = v5;
      a1 = v4;
      if (!v5) {
        return 1LL;
      }
    }

    int v10 = a1 + 2;
    while (!RegexMatchHere(v10, a2))
    {
      uint64_t result = *a2;
      if (!*a2) {
        return result;
      }
      ++a2;
      __darwin_ct_rune_t v11 = __tolower(result);
      __darwin_ct_rune_t v12 = __tolower(v2);
      if (v2 != 46 && v11 != v12) {
        return 0LL;
      }
    }
  }

  return 1LL;
}

uint64_t ReplaceDifferentString(void **a1, char *a2)
{
  __darwin_ct_rune_t v2 = a2;
  __darwin_ct_rune_t v4 = (char *)*a1;
  if (a2) {
    __darwin_ct_rune_t v5 = a2;
  }
  else {
    __darwin_ct_rune_t v5 = "";
  }
  if (v4) {
    __darwin_ct_rune_t v6 = v4;
  }
  else {
    __darwin_ct_rune_t v6 = "";
  }
  uint64_t result = strcmp(v5, v6);
  if ((_DWORD)result)
  {
    if (v2)
    {
      if (!*v2)
      {
        __darwin_ct_rune_t v2 = 0LL;
        if (!v4) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }

      __darwin_ct_rune_t v2 = strdup(v2);
      if (!v2) {
        return 4294960568LL;
      }
    }

    if (!v4)
    {
LABEL_13:
      uint64_t result = 0LL;
      *a1 = v2;
      return result;
    }

uint64_t ReplaceString(void **a1, size_t *a2, char *__s, size_t a4)
{
  size_t v4 = a4;
  if (__s)
  {
    if (a4 == -1LL) {
      size_t v4 = strlen(__s);
    }
    __darwin_ct_rune_t v8 = malloc(v4 + 1);
    if (!v8) {
      return 4294960568LL;
    }
    int v9 = v8;
    memcpy(v8, __s, v4);
    v9[v4] = 0;
  }

  else
  {
    int v9 = 0LL;
  }

  if (*a1) {
    free(*a1);
  }
  *a1 = v9;
  uint64_t result = 0LL;
  if (a2) {
    *a2 = v4;
  }
  return result;
}

const char *GetFileExtensionFromString(const char *a1)
{
  id v1 = strrchr(a1, 46);
  if (!v1) {
    return "";
  }
  int v4 = v1[1];
  uint64_t result = v1 + 1;
  int v3 = v4;
  return result;
}

uint64_t StringArray_Append(const void **a1, uint64_t *a2, char *__s1)
{
  __darwin_ct_rune_t v5 = strdup(__s1);
  if (!v5) {
    return 4294960568LL;
  }
  __darwin_ct_rune_t v6 = v5;
  uint64_t v7 = *a2;
  uint64_t v8 = *a2 + 1;
  int v9 = malloc(8 * v8);
  if (!v9)
  {
    free(v6);
    return 4294960568LL;
  }

  int v10 = v9;
  if (v7)
  {
    __darwin_ct_rune_t v11 = (void *)*a1;
    memcpy(v9, *a1, 8 * v7);
    free(v11);
  }

  uint64_t result = 0LL;
  v10[v7] = v6;
  *a1 = v10;
  *a2 = v8;
  return result;
}

void StringArray_Free(void **a1, uint64_t a2)
{
  if (a2)
  {
    for (uint64_t i = 0LL; i != a2; ++i)
      free(a1[i]);
    free(a1);
  }

uint64_t TextFindColumn(char *__s, size_t a2, _BYTE *a3, int a4, void *a5, void *a6)
{
  int v10 = __s;
  if (a2 == -1LL) {
    a2 = strlen(__s);
  }
  __darwin_ct_rune_t v11 = &v10[a2];
  int v12 = 1;
  do
  {
    int v13 = v10;
    if (v10 >= v11)
    {
LABEL_11:
      unint64_t v14 = v11;
      int v10 = v11;
      if (v13 == v11) {
        return 4294960569LL;
      }
    }

    else
    {
      unint64_t v14 = v10;
      while (!*a3)
      {
LABEL_10:
        if (++v14 == v11) {
          goto LABEL_11;
        }
      }

      uint64_t v15 = a3 + 1;
      int v16 = *a3;
      while (*v14 != v16)
      {
        int v17 = *v15++;
        int v16 = v17;
        if (!v17) {
          goto LABEL_10;
        }
      }

      int v10 = v14 + 1;
    }
  }

  while (v12++ != a4);
  if (a5) {
    *a5 = v13;
  }
  uint64_t result = 0LL;
  if (a6) {
    *a6 = v14 - v13;
  }
  return result;
}

uint64_t TextSep( unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 **a4, void *a5, unsigned __int8 **a6)
{
  if (a1 < a2)
  {
    int v8 = *a3;
    __darwin_ct_rune_t v6 = a3 + 1;
    int v7 = v8;
    int v9 = a1;
    while (!v7)
    {
LABEL_7:
      if (++v9 == a2) {
        goto LABEL_8;
      }
    }

    int v10 = v6;
    int v11 = v7;
    while (*v9 != v11)
    {
      int v12 = *v10++;
      int v11 = v12;
      if (!v12) {
        goto LABEL_7;
      }
    }

    *a4 = a1;
    *a5 = v9 - a1;
    if (!a6) {
      return 1LL;
    }
    a2 = v9 + 1;
    uint64_t v13 = 1LL;
    goto LABEL_14;
  }

size_t TruncateUTF8(char *a1, size_t a2, void *a3, uint64_t a4, int a5)
{
  if (!a4) {
    return 0LL;
  }
  size_t v8 = TruncatedUTF8Length(a1, a2, a4 - (a5 != 0));
  memmove(a3, a1, v8);
  if (a5) {
    *((_BYTE *)a3 + v_Block_object_dispose(va, 8) = 0;
  }
  return v8;
}

int64_t XMLEscape(const char *a1, char *a2, void *a3)
{
  __darwin_ct_rune_t v5 = a1;
  int64_t result = strlen(a1);
  int v7 = a2;
  if (result >= 1)
  {
    size_t v8 = (char *)&v5[result];
    int v7 = a2;
    do
    {
      int v9 = *v5;
      if (v9 <= 38)
      {
        if (v9 == 34)
        {
          int v10 = "&quot;";
        }

        else
        {
          int v10 = "&amp;";
          if (v9 != 38)
          {
LABEL_10:
            if (a2) {
              *int v7 = v9;
            }
            ++v7;
            goto LABEL_21;
          }
        }
      }

      else
      {
        switch(v9)
        {
          case '\'':
            int v10 = "&#39;";
            break;
          case '<':
            int v10 = "&lt;";
            break;
          case '>':
            int v10 = "&gt;";
            break;
          default:
            goto LABEL_10;
        }
      }

      char v11 = *v10;
      if (*v10)
      {
        int v12 = (unsigned __int8 *)(v10 + 1);
        do
        {
          if (a2) {
            *int v7 = v11;
          }
          ++v7;
          int v13 = *v12++;
          char v11 = v13;
        }

        while (v13);
      }

uint64_t XMLEscapeCopy(const char *a1, char **a2)
{
  int v4 = (char *)malloc(v7 + 1);
  if (!v4) {
    return 4294960568LL;
  }
  __darwin_ct_rune_t v5 = v4;
  XMLEscape(a1, v4, &v7);
  uint64_t result = 0LL;
  v5[v7] = 0;
  *a2 = v5;
  return result;
}

uint64_t DNSServiceConstructFullNameEx(_BYTE *a1, uint64_t a2, char *__s, unsigned __int8 *a4)
{
  if (!__s) {
    return 4294960591LL;
  }
  size_t v8 = strlen(__s);
  BOOL v9 = DomainEndsInDot((unsigned __int8 *)__s);
  uint64_t result = 4294960591LL;
  if (a4)
  {
    unint64_t v11 = v8 - v9;
    if (v11 >= 6)
    {
      if (*a4)
      {
        int v12 = &__s[v11 - 4];
        if (strncasecmp(v12, "_tcp", 4uLL) && strncasecmp(v12, "_udp", 4uLL)) {
          return 4294960591LL;
        }
        if (a2)
        {
          unsigned __int8 v13 = *(_BYTE *)a2;
          if (*(_BYTE *)a2)
          {
            uint64_t v14 = 0LL;
            uint64_t v15 = (unsigned __int8 *)(a2 + 1);
            int v16 = a1;
            while (1)
            {
              if (v13 < 0x21u)
              {
LABEL_13:
                if (v14 > 1000) {
                  goto LABEL_47;
                }
                *int v16 = 92;
                int v17 = &a1[v14];
                v17[1] = 48;
                uint64_t v18 = v14 + 3;
                v17[2] = (v13 / 0xAu) | 0x30;
                unsigned __int8 v13 = (v13 % 0xAu) | 0x30;
                goto LABEL_25;
              }

              if (v13 > 0x39u)
              {
                if (v13 != 92)
                {
                  if (v13 == 58) {
                    goto LABEL_13;
                  }
LABEL_21:
                  if (v14 >= 1004) {
                    goto LABEL_47;
                  }
                  uint64_t v18 = v14;
                  goto LABEL_25;
                }
              }

              else
              {
                if (v13 == 37) {
                  goto LABEL_13;
                }
                if (v13 != 46) {
                  goto LABEL_21;
                }
              }

              if (v14 > 1002)
              {
LABEL_47:
                int v25 = &a1[v14];
                goto LABEL_53;
              }

              uint64_t v18 = v14 + 1;
              *int v16 = 92;
LABEL_25:
              uint64_t v14 = v18 + 1;
              a1[v18] = v13;
              unsigned __int8 v19 = *v15++;
              unsigned __int8 v13 = v19;
              int v16 = &a1[v18 + 1];
              if (!v19)
              {
                a2 = v18 + 2;
                *int v16 = 46;
                goto LABEL_28;
              }
            }
          }

          a2 = 0LL;
        }

BOOL DomainEndsInDot(unsigned __int8 *a1)
{
  int v1 = *a1;
  if (*a1)
  {
    while (1)
    {
      int v2 = a1[1];
      if (!a1[1]) {
        break;
      }
      if (v1 == 92)
      {
        else {
          uint64_t v3 = 4LL;
        }
        a1 += v3;
        int v1 = *a1;
        if (!*a1) {
          return v1 == 46;
        }
      }

      else
      {
        int v1 = *++a1;
        if (!v2) {
          return v1 == 46;
        }
      }
    }
  }

  return v1 == 46;
}

_BYTE *MakeDomainNameFromDNSNameString(_BYTE *a1, char *a2)
{
  uint64_t v2 = 0LL;
  *a1 = 0;
  while (1)
  {
    uint64_t v3 = a1[v2];
    if (v3 > 0x3F)
    {
LABEL_5:
      int v4 = a1 + 255;
      goto LABEL_6;
    }

    if (!a1[v2]) {
      break;
    }
    v2 += v3 + 1;
  }

  unint64_t v7 = (unint64_t)&a1[v2];
  if ((unint64_t)v2 > 0xFD || (char v8 = *a2) == 0)
  {
    int v4 = &a1[v2];
    goto LABEL_6;
  }

  BOOL v9 = a1 + 1;
  do
  {
    if (v8 == 46) {
      return 0LL;
    }
    if (v2 <= 253) {
      uint64_t v10 = 253LL;
    }
    else {
      uint64_t v10 = v2;
    }
    for (uint64_t i = v2; ; ++i)
    {
      if (!v8 || v8 == 46)
      {
        uint64_t v10 = i;
LABEL_29:
        uint64_t v2 = i + 1;
        int v4 = &v9[i];
        uint64_t i = v10;
        goto LABEL_30;
      }

      if (v10 == i) {
        goto LABEL_29;
      }
      int v12 = a2 + 1;
      if (v8 == 92) {
        break;
      }
LABEL_27:
      v9[i] = v8;
      char v8 = *v12;
      a2 = v12;
    }

    int v13 = *v12;
    if (*v12)
    {
      char v8 = *v12;
      int v12 = a2 + 2;
      if (v13 - 48 <= 9)
      {
        int v14 = *v12;
        if ((v14 - 48) <= 9)
        {
          int v15 = a2[3];
          if ((v15 - 48) <= 9)
          {
            int v16 = 100 * v13 + 10 * (char)v14 + (char)v15;
            int v17 = a2 + 4;
            if (v16 < 5584)
            {
              char v8 = v16 + 48;
              int v12 = v17;
            }
          }
        }
      }

      goto LABEL_27;
    }

    char v8 = 0;
    uint64_t v2 = i + 1;
    int v4 = &v9[i];
    ++a2;
LABEL_30:
    uint64_t v18 = (uint64_t)&v4[~v7];
    if (v18 > 63) {
      return 0LL;
    }
    if (v8) {
      ++a2;
    }
    *(_BYTE *)unint64_t v7 = v18;
    char v8 = *a2;
    if (!*a2) {
      break;
    }
    unint64_t v7 = (unint64_t)v4;
  }

  while (i < 253);
LABEL_6:
  *int v4 = 0;
  __darwin_ct_rune_t v5 = v4 + 1;
  if (*a2) {
    return 0LL;
  }
  else {
    return v5;
  }
}

unint64_t IncrementNumericSuffix( char *__s, unint64_t a2, uint64_t a3, int a4, unint64_t *a5)
{
  size_t v8 = a2;
  if (a4)
  {
    unint64_t v10 = a2;
    while (v10 - 2 > 2)
    {
      int v11 = __s[v10-- - 3];
      if ((v11 - 48) >= 0xA)
      {
        uint64_t v12 = v10 - 1;
        goto LABEL_19;
      }
    }

    int v11 = __s[1];
    uint64_t v12 = 2LL;
LABEL_19:
    if (v11 != 40 || __s[v12 - 2] != 32) {
      goto LABEL_43;
    }
    if (a2 != 0 && a4 != 0) {
      size_t v8 = a2 - 1;
    }
  }

  else
  {
    unint64_t v13 = a2 - 2;
    if (a2 < 2 || __s[a2 - 1] - 48 > 9)
    {
      BOOL v15 = 0;
      uint64_t v16 = 2LL;
      uint32_t v17 = 2;
      goto LABEL_51;
    }

    while (v13 + 1 > 1)
    {
      int v14 = __s[v13--];
    }

    int v14 = *__s;
LABEL_16:
    if (v14 != 45) {
      goto LABEL_43;
    }
  }

  if (v8)
  {
    unsigned int v18 = 0;
    int v19 = 1;
    while (1)
    {
      size_t v20 = v8 - 1;
      int v21 = __s[v8 - 1];
      v18 += (v21 - 48) * v19;
      v19 *= 10;
      --v8;
      if (!v20) {
        goto LABEL_40;
      }
    }

    if (a4)
    {
      if (v8 < 2)
      {
        size_t v8 = 1LL;
      }

      else if (v21 == 40 && __s[v8 - 2] == 32)
      {
        v8 -= 2LL;
      }
    }

    else if (v21 == 45)
    {
      --v8;
    }

char *GetDeviceInternalModelString(char *a1, size_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  v12[0] = 0;
  size_t v11 = 63LL;
  if (sysctlbyname("hw.target", v12, &v11, 0LL, 0LL))
  {
    size_t v11 = 63LL;
    if (sysctlbyname("hw.model", v12, &v11, 0LL, 0LL)) {
      size_t v11 = 0LL;
    }
  }

  v12[v11] = 0;
  int v4 = (char *)&v11 + 6;
  uint64_t v5 = MEMORY[0x1895F8770];
  do
  {
    uint64_t v6 = v4[2];
    if (v4[2] < 0) {
      int v7 = __maskrune(v6, 0x100uLL);
    }
    else {
      int v7 = *(_DWORD *)(v5 + 4 * v6 + 60) & 0x100;
    }
    ++v4;
  }

  while (v7);
  do
    int v8 = *++v4;
  while ((v8 - 48) < 0xA);
  *int v4 = 0;
  if (v12[0]) {
    BOOL v9 = v12;
  }
  else {
    BOOL v9 = "N88";
  }
  strlcpy(a1, v9, a2);
  return a1;
}

uint64_t GestaltSetDomain(const void *a1)
{
  uint64_t v2 = (const void *)gGestaltDomain;
  if (a1) {
    CFRetain(a1);
  }
  gGestaltDomain = (uint64_t)a1;
  if (v2) {
    CFRelease(v2);
  }
  return pthread_mutex_unlock(&gGestaltLock);
}

void *GestaltSetHook(void *result, uint64_t a2)
{
  gGestaltHook_f = result;
  gGestaltHook_ctx = a2;
  return result;
}

uint64_t GestaltCopyAnswer(CFTypeRef cf1, uint64_t a2, int *a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (!gGestaltHook_f || (uint64_t result = gGestaltHook_f(cf1, a2, a3, gGestaltHook_ctx)) == 0)
  {
    if (CFEqual(cf1, @"NANCapability"))
    {
      int v6 = gGestaltCacheNANCapability;
      if (!gGestaltCacheNANCapability)
      {
        if (if_nametoindex("nan0")) {
          int v6 = 6;
        }
        else {
          int v6 = 5;
        }
        gGestaltCacheNANCapability = v6;
      }

      goto LABEL_21;
    }

    if (!CFEqual(cf1, @"R1Capability"))
    {
      if (CFEqual(cf1, @"systemUUID"))
      {
        uint64_t v37 = 0LL;
        pthread_mutex_lock(&gGestaltLock);
        if (gGestaltDomain) {
          uint32_t v17 = (const __CFString *)gGestaltDomain;
        }
        else {
          uint32_t v17 = (const __CFString *)*MEMORY[0x189605188];
        }
        __s[0] = 0;
        CFPrefs_GetCString(v17, @"systemUUID", __s, 0x80uLL, 0LL);
        unsigned int v18 = strchr(__s, 58);
        if (v18
          && (unint64_t v22 = v18, !StringToUUIDEx(__s, v18 - __s, 0, 0LL, &bytes, v19, v20, v21))
          && sscanf(v22 + 1, "%lf", &v37) == 1)
        {
          if (gLogCategory_Gestalt <= 20
            && (gLogCategory_Gestalt != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_Gestalt, 0x14u)))
          {
            LogPrintF( (uint64_t)&gLogCategory_Gestalt,  (uint64_t)"void GetSystemUUID(int, uint8_t *)",  0x14u,  (uint64_t)"Reused system UUID %s\n",  v23,  v24,  v25,  v26,  (char)__s);
          }
        }

        else
        {
          RandomBytes(&bytes, 0x10uLL);
          BYTE6(bytes) = BYTE6(bytes) & 0xF | 0x40;
          BYTE8(bytes) = BYTE8(bytes) & 0x3F | 0x80;
          CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
          SNPrintF((uint64_t)__s, 128LL, "%#U:%f", v28, v29, v30, v31, v32, &bytes, *(void *)&Current, v37);
          CFPrefs_SetCString(v17, @"systemUUID", __s, -1LL);
          CFPreferencesAppSynchronize(v17);
          if (gLogCategory_Gestalt <= 40
            && (gLogCategory_Gestalt != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_Gestalt, 0x28u)))
          {
            LogPrintF( (uint64_t)&gLogCategory_Gestalt,  (uint64_t)"void GetSystemUUID(int, uint8_t *)",  0x28u,  (uint64_t)"Generated system UUID %s\n",  v33,  v34,  v35,  v36,  (char)__s);
          }
        }

        pthread_mutex_unlock(&gGestaltLock);
        uint64_t result = (uint64_t)CFDataCreate(0LL, (const UInt8 *)&bytes, 16LL);
        if (result) {
          goto LABEL_25;
        }
        int v16 = -6728;
      }

      else
      {
        uint64_t result = MGCopyAnswer();
        if (result)
        {
LABEL_25:
          int v16 = 0;
          goto LABEL_26;
        }

        int v16 = -6727;
      }

BOOL GestaltGetBoolean(const void *a1, uint64_t a2, int *a3)
{
  int v4 = (const __CFString *)GestaltCopyAnswer(a1, a2, a3);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  BOOL v6 = CFGetInt64(v4, a3) != 0;
  CFRelease(v5);
  return v6;
}

char *GestaltGetCString(const void *a1, uint64_t a2, char *a3, size_t a4, int *a5)
{
  int v8 = (const __CFString *)GestaltCopyAnswer(a1, a2, a5);
  if (v8)
  {
    BOOL v9 = v8;
    a3 = (char *)CFGetCString(v8, a3, a4);
    CFRelease(v9);
    if (a5) {
      *a5 = 0;
    }
  }

  return a3;
}

const char *GestaltGetData( const void *a1, uint64_t a2, const char *a3, unint64_t a4, void *a5, int *a6)
{
  io_registry_entry_t v10 = (__CFString *)GestaltCopyAnswer(a1, a2, a6);
  if (v10)
  {
    size_t v11 = v10;
    unint64_t v12 = CFGetData(v10, a3, a4, a5, a6);
    CFRelease(v11);
    return v12;
  }

  else
  {
    if (a5) {
      *a5 = 0LL;
    }
    return 0LL;
  }

uint64_t GestaltGetDeviceClass()
{
  if (GestaltGetDeviceClass_sOnce != -1) {
    dispatch_once(&GestaltGetDeviceClass_sOnce, &__block_literal_global_13042);
  }
  return GestaltGetDeviceClass_deviceClass;
}

uint64_t __GestaltGetDeviceClass_block_invoke()
{
  uint64_t result = MGGetSInt32Answer();
  GestaltGetDeviceClass_deviceClass = result;
  return result;
}

uint64_t GestaltProductTypeStringToDeviceClass(void *a1)
{
  id v1 = a1;
  if ([v1 hasPrefix:@"iPhone"])
  {
    uint64_t v2 = 1LL;
  }

  else if ([v1 hasPrefix:@"iPad"])
  {
    uint64_t v2 = 3LL;
  }

  else if ([v1 containsString:@"Mac"])
  {
    uint64_t v2 = 100LL;
  }

  else if ([v1 hasPrefix:@"AppleTV"])
  {
    uint64_t v2 = 4LL;
  }

  else if (([v1 hasPrefix:@"AudioAccessory1,"] & 1) != 0 {
         || ([v1 hasPrefix:@"AudioAccessory5,"] & 1) != 0
  }
         || ([v1 hasPrefix:@"AudioAccessory6,"] & 1) != 0
         || ([v1 hasPrefix:@"HomePod"] & 1) != 0)
  {
    uint64_t v2 = 7LL;
  }

  else if ([v1 hasPrefix:@"Watch"])
  {
    uint64_t v2 = 6LL;
  }

  else if ([v1 hasPrefix:@"iPod"])
  {
    uint64_t v2 = 2LL;
  }

  else if ([v1 hasPrefix:@"RealityDevice"])
  {
    uint64_t v2 = 11LL;
  }

  else
  {
    uint64_t v2 = 0LL;
  }

  return v2;
}

CFStringRef CUGestaltDeviceClassToString(int a1)
{
  int v1 = a1 - 1;
  uint64_t result = @"AppleTV";
  switch(v1)
  {
    case 0:
      uint64_t result = @"iPhone";
      break;
    case 1:
      uint64_t result = @"iPod";
      break;
    case 2:
      uint64_t result = @"iPad";
      break;
    case 3:
      return result;
    case 4:
    case 7:
    case 8:
    case 9:
      goto LABEL_5;
    case 5:
      uint64_t result = @"Watch";
      break;
    case 6:
      uint64_t result = @"HomePod";
      break;
    case 10:
      uint64_t result = @"RealityDevice";
      break;
    default:
      else {
LABEL_5:
      }
        uint64_t result = @"?";
      break;
  }

  return result;
}

BOOL DeviceOSVersionAtOrLater( int a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8)
{
  return DeviceOSVersionAtOrLaterEx(a1, a2, a3, a4, a5, a6, a7, a8, 0x2710u);
}

BOOL DeviceOSVersionAtOrLaterEx( int a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9)
{
  BOOL result = 0LL;
  unsigned int v11 = 10000 * a2 + 100 * a3 + a4;
  switch(a1)
  {
    case 1:
    case 2:
    case 3:
      return v11 >= a5;
    case 4:
    case 7:
      return v11 >= a7;
    case 5:
    case 8:
    case 9:
    case 10:
      return result;
    case 6:
      return v11 >= a8;
    case 11:
      return v11 >= a9;
    default:
      if (a1 != 100) {
        return result;
      }
      return v11 >= a6;
  }

BOOL wInTP56r94EFs9NAAi(int a1, int a2, int a3, int a4)
{
  return DeviceOSVersionAtOrLaterEx(a1, a2, a3, a4, 0x1D4C0u, 0x18C18u, 0x1D4C0u, 0xC350u, 0x2710u);
}

BOOL se1P4X0Kh(int a1, int a2, int a3, int a4)
{
  return DeviceOSVersionAtOrLaterEx(a1, a2, a3, a4, 0x1D524u, 0x18C19u, 0x1D524u, 0xC3B4u, 0x2710u);
}

BOOL TN6sBSnEP2(int a1, int a2, int a3, int a4)
{
  return DeviceOSVersionAtOrLaterEx(a1, a2, a3, a4, 0x1D588u, 0x18C1Cu, 0x1D588u, 0xC418u, 0x2710u);
}

BOOL NADyFF4UGjtVGBmEW6h(int a1, int a2, int a3, int a4)
{
  return DeviceOSVersionAtOrLaterEx(a1, a2, a3, a4, 0x1FBD0u, 0x18C7Cu, 0x1FBD0u, 0xEA60u, 0x2710u);
}

char *GetDeviceModelString(char *a1, size_t a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  __source[0] = 0;
  size_t __n = 63LL;
  if (sysctlbyname("hw.machine", __source, &__n, 0LL, 0LL)
    || (size_t v6 = __n, !memchr(__source, 44, __n))
    || strnstr(__source, "iProd", v6))
  {
    size_t v4 = 0LL;
    size_t __n = 0LL;
  }

  else
  {
    size_t v4 = __n;
  }

  __source[v4] = 0;
  strlcpy(a1, __source, a2);
  return a1;
}

const char *GetDeviceName(char *a1, CFIndex a2)
{
  size_t v4 = (const __CFString *)MGCopyAnswer();
  if (!v4)
  {
LABEL_4:
    uint64_t v5 = (const __CFString *)MGCopyAnswer();
    if (!v5) {
      goto LABEL_7;
    }
    goto LABEL_5;
  }

  uint64_t v5 = v4;
  CFTypeID v6 = CFGetTypeID(v4);
  if (v6 != CFStringGetTypeID())
  {
    CFRelease(v5);
    goto LABEL_4;
  }

char *GetDeviceUniqueID(char *a1, CFIndex a2)
{
  size_t v4 = (const __CFString *)MGCopyAnswer();
  if (v4)
  {
    uint64_t v5 = v4;
    CFTypeID v6 = CFGetTypeID(v4);
    if (v6 == CFStringGetTypeID()) {
      CFStringGetCString(v5, a1, a2, 0x8000100u);
    }
    CFRelease(v5);
  }

  return a1;
}

char *GetSystemBuildVersionString(char *a1, CFIndex a2)
{
  size_t v4 = (const __CFString *)MGCopyAnswer();
  if (v4)
  {
    uint64_t v5 = v4;
    CFTypeID v6 = CFGetTypeID(v4);
    if (v6 == CFStringGetTypeID()) {
      CFStringGetCString(v5, a1, a2, 0x8000100u);
    }
    CFRelease(v5);
  }

  return a1;
}

uint64_t CUIsGreenTeaDevice()
{
  if (CUIsGreenTeaDevice_sOnce != -1) {
    dispatch_once(&CUIsGreenTeaDevice_sOnce, &__block_literal_global_57);
  }
  return CUIsGreenTeaDevice_sResult;
}

uint64_t __CUIsGreenTeaDevice_block_invoke()
{
  if ((MGGetBoolAnswer() & 1) != 0) {
    uint64_t result = 1LL;
  }
  else {
    uint64_t result = MGGetBoolAnswer();
  }
  CUIsGreenTeaDevice_sResult = result;
  return result;
}

uint64_t CUSetSystemName(const __CFString *a1, const __CFString *a2, char a3)
{
  CFTypeID v6 = SCPreferencesCreateWithAuthorization(0LL, @"com.apple.CoreUtils", 0LL, 0LL);
  if (v6)
  {
    CFTypeID v7 = v6;
    if (SCPreferencesSetComputerName(v6, a1, 0x8000100u))
    {
      uint64_t v12 = 0LL;
      if (a2)
      {
LABEL_4:
        uint64_t v13 = 0LL;
        goto LABEL_5;
      }
    }

    else
    {
      if (gLogCategory_CUMisc <= 60
        && (gLogCategory_CUMisc != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_CUMisc, 0x3Cu)))
      {
        SCError();
        LogPrintF( (uint64_t)&gLogCategory_CUMisc,  (uint64_t)"OSStatus CUSetSystemName(CFStringRef, CFStringRef _Nullable, CUSystemNameFlags)",  0x3Cu,  (uint64_t)"### Set computer name %@' failed: %#m\n",  v19,  v20,  v21,  v22,  (char)a1);
      }

      uint64_t v12 = SCError();
      if (a2) {
        goto LABEL_4;
      }
    }

    if ((a3 & 1) != 0)
    {
      uint64_t v13 = (const __CFString *)softLink_CSCopyLocalHostnameForComputerName(0LL, (uint64_t)a1);
      a2 = v13;
      if (v13)
      {
LABEL_5:
        if ((a3 & 2) != 0)
        {
          CFMutableDictionaryRef MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, a2);
          if (MutableCopy)
          {
            memset(bytes, 0, 6);
            int InterfaceMACAddress = GetInterfaceMACAddress("en0", (uint64_t)bytes);
            if (InterfaceMACAddress
              && gLogCategory_CUMisc <= 60
              && (gLogCategory_CUMisc != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_CUMisc, 0x3Cu)))
            {
              LogPrintF( (uint64_t)&gLogCategory_CUMisc,  (uint64_t)"OSStatus CUSetSystemName(CFStringRef, CFStringRef _Nullable, CUSystemNameFlags)",  0x3Cu,  (uint64_t)"### Set computer name, get en0 failed: %#m",  v23,  v24,  v25,  v26,  InterfaceMACAddress);
            }

            v28.i32[0] = *(_DWORD *)((char *)bytes + 1);
            if (InterfaceMACAddress | vmovn_s16((int16x8_t)vmovl_u8(v28)).u32[0]
              || LOBYTE(bytes[0]) != 2
              || BYTE1(bytes[1]))
            {
              if (InterfaceMACAddress) {
                goto LABEL_48;
              }
            }

            else
            {
              unint64_t Int64 = CFPrefs_GetInt64(0LL, @"CUSystemNameAddress", 0LL);
              if (Int64)
              {
                unint64_t v34 = Int64;
                if (gLogCategory_CUMisc <= 50
                  && (gLogCategory_CUMisc != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_CUMisc, 0x32u)))
                {
                  LogPrintF( (uint64_t)&gLogCategory_CUMisc,  (uint64_t)"OSStatus CUSetSystemName(CFStringRef, CFStringRef _Nullable, CUSystemNameFlags)",  0x32u,  (uint64_t)"Computer name address: existing=0x%012lX",  v30,  v31,  v32,  v33,  v34);
                }

                LOBYTE(bytes[0]) = BYTE5(v34);
                BYTE1(bytes[0]) = BYTE4(v34);
                BYTE2(bytes[0]) = BYTE3(v34);
                HIBYTE(bytes[0]) = BYTE2(v34);
                LOBYTE(bytes[1]) = BYTE1(v34);
                BYTE1(bytes[1]) = v34;
              }

              else
              {
                RandomBytes(bytes, 6uLL);
                char v35 = BYTE1(bytes[1]);
                CFPrefs_SetInt64( 0LL,  @"CUSystemNameAddress",  ((unint64_t)LOBYTE(bytes[0]) << 40) | ((unint64_t)BYTE1(bytes[0]) << 32) | ((unint64_t)BYTE2(bytes[0]) << 24) | ((unint64_t)HIBYTE(bytes[0]) << 16) | ((unint64_t)LOBYTE(bytes[1]) << 8) | BYTE1(bytes[1]));
                if (gLogCategory_CUMisc <= 50
                  && (gLogCategory_CUMisc != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_CUMisc, 0x32u)))
                {
                  LogPrintF( (uint64_t)&gLogCategory_CUMisc,  (uint64_t)"OSStatus CUSetSystemName(CFStringRef, CFStringRef _Nullable, CUSystemNameFlags)",  0x32u,  (uint64_t)"Computer name address: generated=0x%012lX",  v36,  v37,  v38,  v39,  v35);
                }
              }
            }

            CFStringAppendFormat( MutableCopy,  0LL,  @"-%02X%02X%02X%02X%02X%02X",  LOBYTE(bytes[0]),  BYTE1(bytes[0]),  BYTE2(bytes[0]),  HIBYTE(bytes[0]),  LOBYTE(bytes[1]),  BYTE1(bytes[1]));
            a2 = MutableCopy;
          }
        }

        else
        {
          CFMutableDictionaryRef MutableCopy = 0LL;
        }

uint64_t init_CSCopyLocalHostnameForComputerName(uint64_t a1, uint64_t a2)
{
  if (MobileCoreServicesLibrary_sOnce_13102 != -1) {
    dispatch_once(&MobileCoreServicesLibrary_sOnce_13102, &__block_literal_global_96);
  }
  softLink_CSCopyLocalHostnameForComputerName = (uint64_t (*)())dlsym( (void *)MobileCoreServicesLibrary_sLib_13103,  "_CSCopyLocalHostnameForComputerName");
  return ((uint64_t (*)(uint64_t, uint64_t))softLink_CSCopyLocalHostnameForComputerName)(a1, a2);
}

void *__MobileCoreServicesLibrary_block_invoke_13105()
{
  uint64_t result = dlopen("/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices", 2);
  MobileCoreServicesLibrary_sLib_13103 = (uint64_t)result;
  return result;
}

uint64_t IsAppleInternalBuild()
{
  if (IsAppleInternalBuild_sOnce != -1) {
    dispatch_once(&IsAppleInternalBuild_sOnce, &__block_literal_global_85);
  }
  return IsAppleInternalBuild_sIsInternal;
}

uint64_t __IsAppleInternalBuild_block_invoke()
{
  uint64_t result = os_variant_allows_internal_security_policies();
  if ((_DWORD)result) {
    uint64_t result = os_variant_has_internal_content();
  }
  IsAppleInternalBuild_sIsuint64_t Internal = result;
  return result;
}

uint64_t IsAppleTV()
{
  if (IsAppleTV_sOnce != -1) {
    dispatch_once(&IsAppleTV_sOnce, &__block_literal_global_87);
  }
  return IsAppleTV_sIsAppleTV;
}

void __IsAppleTV_block_invoke()
{
  uint64_t v0 = (const void *)MGCopyAnswer();
  if (v0)
  {
    int v1 = v0;
    IsAppleTV_sIsAppleTV = CFEqual(v0, @"AppleTV");
    CFRelease(v1);
  }

uint64_t BigIntegerFromInt()
{
  uint64_t v0 = CCCreateBigNum();
  if (v0) {
    CCBigNumSetI();
  }
  return v0;
}

uint64_t BigIntegerToCstr(uint64_t a1, uint64_t a2)
{
  int v3 = CCBigNumBitCount();
  int v4 = v3 + 7;
  if (v3 < -7) {
    int v4 = v3 + 14;
  }
  uint64_t result = cstr_set_length(a2, v4 >> 3);
  if ((result & 0x80000000) == 0)
  {
    int v6 = CCBigNumToData();
    return cstr_set_length(a2, v6);
  }

  return result;
}

void BigIntegerToCstrEx(uint64_t a1, const void **a2, int a3)
{
  if ((cstr_set_length((uint64_t)a2, a3) & 0x80000000) == 0)
  {
    int v5 = CCBigNumToData();
    int v6 = a3 - v5;
    if (a3 > v5)
    {
      size_t v7 = v6;
      memmove((char *)*a2 + v6, *a2, v5);
      bzero((void *)*a2, v7);
    }
  }

void sub_186B34E90(_Unwind_Exception *a1)
{
}

void sub_186B34F40(_Unwind_Exception *a1)
{
}

uint64_t TUInitialize(int a1, const char **a2)
{
  uint64_t v2 = (uint64_t *)MEMORY[0x1895F89E0];
  if (a1 >= 1)
  {
    int v5 = *a2;
    int v6 = strrchr(*a2, 47);
    uint64_t v7 = v6 ? (uint64_t)(v6 + 1) : (uint64_t)v5;
    gTUProgramName = v7;
    if (a1 != 1)
    {
      int v11 = 1;
      do
      {
        uint64_t v12 = v11 + 1LL;
        uint64_t v13 = a2[v11];
        if (!strcasecmp(v13, "--BATS"))
        {
          v11 += 2;
          uint64_t v15 = (unsigned __int8 *)a2[v12];
          if (strnicmpx(v15, -1LL, "true")
            && strnicmpx(v15, -1LL, "yes")
            && strnicmpx(v15, -1LL, "y")
            && strnicmpx(v15, -1LL, "on")
            && strnicmpx(v15, -1LL, "1"))
          {
            if (strnicmpx(v15, -1LL, "false")
              && strnicmpx(v15, -1LL, "no")
              && strnicmpx(v15, -1LL, "n")
              && strnicmpx(v15, -1LL, "off")
              && strnicmpx(v15, -1LL, "0"))
            {
              goto LABEL_131;
            }

            gTUBATSMode = 0;
          }

          else
          {
            gTUBATSMode = 1;
          }
        }

        else if (!strcasecmp(v13, "--BreakOnFail"))
        {
          v11 += 2;
          uint64_t v16 = (unsigned __int8 *)a2[(int)v12];
          if (strnicmpx(v16, -1LL, "true")
            && strnicmpx(v16, -1LL, "yes")
            && strnicmpx(v16, -1LL, "y")
            && strnicmpx(v16, -1LL, "on")
            && strnicmpx(v16, -1LL, "1"))
          {
            if (strnicmpx(v16, -1LL, "false")
              && strnicmpx(v16, -1LL, "no")
              && strnicmpx(v16, -1LL, "n")
              && strnicmpx(v16, -1LL, "off")
              && strnicmpx(v16, -1LL, "0"))
            {
              goto LABEL_131;
            }

            gTUBreakOnFail = 1;
          }

          else
          {
            gTUBreakOnFail = 0;
          }
        }

        else
        {
          if (!strcasecmp(v13, "--ConvertTURtoJUnit"))
          {
            if ((int)v12 >= a1)
            {
              uint64_t v26 = *v2;
            }

            else
            {
              if (v11 + 2 < a1)
              {
                BOOL v25 = TUConvertToJUnit(a2[(int)v12], (CFMutableArrayRef)a2[v11 + 2]) != 0;
                exit(v25);
              }

              uint64_t v26 = *v2;
            }

            FPrintF(v26);
            exit(1);
          }

          if (!strcasecmp(v13, "--DontRunLeaks"))
          {
            v11 += 2;
            uint64_t v17 = (unsigned __int8 *)a2[(int)v12];
            if (strnicmpx(v17, -1LL, "true")
              && strnicmpx(v17, -1LL, "yes")
              && strnicmpx(v17, -1LL, "y")
              && strnicmpx(v17, -1LL, "on")
              && strnicmpx(v17, -1LL, "1"))
            {
              if (strnicmpx(v17, -1LL, "false")
                && strnicmpx(v17, -1LL, "no")
                && strnicmpx(v17, -1LL, "n")
                && strnicmpx(v17, -1LL, "off")
                && strnicmpx(v17, -1LL, "0"))
              {
                goto LABEL_131;
              }

              gTUDontRunLeaks = 0;
            }

            else
            {
              gTUDontRunLeaks = 1;
            }
          }

          else if (!strcasecmp(v13, "--ExcludeNonTestUtilsTests"))
          {
            v11 += 2;
            uint64_t v18 = (unsigned __int8 *)a2[(int)v12];
            if (!strnicmpx(v18, -1LL, "true")
              || !strnicmpx(v18, -1LL, "yes")
              || !strnicmpx(v18, -1LL, "y")
              || !strnicmpx(v18, -1LL, "on")
              || !strnicmpx(v18, -1LL, "1"))
            {
              goto LABEL_90;
            }

            if (strnicmpx(v18, -1LL, "false")
              && strnicmpx(v18, -1LL, "no")
              && strnicmpx(v18, -1LL, "n")
              && strnicmpx(v18, -1LL, "off")
              && strnicmpx(v18, -1LL, "0"))
            {
              goto LABEL_131;
            }

            gTUExcludeNonTestUtilsTests = 0;
          }

          else
          {
            if (!strcasecmp(v13, "--ExcludedTests"))
            {
              v11 += 2;
              gTUExcludedTests = (uint64_t)a2[(int)v12];
LABEL_90:
              gTUExcludeNonTestUtilsTests = 1;
              continue;
            }

            if (!strcasecmp(v13, "--Filter"))
            {
              v11 += 2;
              gTUFilter = (uint64_t)a2[(int)v12];
              goto LABEL_90;
            }

            if (!strcasecmp(v13, "--JUnitXMLOutputPath"))
            {
              v11 += 2;
              gTUJUnitXMLOutputPath = (uint64_t)a2[(int)v12];
            }

            else if (!strcasecmp(v13, "--Level"))
            {
              v11 += 2;
              int v19 = LUStringToLevel((char *)a2[(int)v12]);
              if (v19 == -1) {
                goto LABEL_131;
              }
              gTULogLevel = v19;
            }

            else if (!strcasecmp(v13, "--LogControl"))
            {
              v11 += 2;
              if (LogControl((char *)a2[(int)v12]))
              {
                uint64_t v20 = *v2;
                goto LABEL_132;
              }
            }

            else
            {
              if (!strcasecmp(v13, "--OutputPath"))
              {
                v11 += 2;
                uint64_t v21 = a2[(int)v12];
                uint64_t v22 = fopen(v21, "w");
                if (v22 || *__error() && !*__error())
                {
                  if (gTUOutputFile && fclose((FILE *)gTUOutputFile) && *__error()) {
                    __error();
                  }
                  gTUOutputFile = (uint64_t)v22;
                  gTUOutputFilePtr = (uint64_t)v22;
                  gTUOutputPath = (uint64_t)v21;
                  continue;
                }

                uint64_t v20 = *v2;
                goto LABEL_132;
              }

              if (!strcasecmp(v13, "--Qualifier"))
              {
                v11 += 2;
                gTUQualifier = (uint64_t)a2[(int)v12];
              }

              else
              {
                if (strcasecmp(v13, "--StopOnFirstFail"))
                {
                  if (strcasecmp(v13, "--UserMode"))
                  {
                    uint64_t v14 = *v2;
LABEL_134:
                    FPrintF(v14);
                    ++v11;
                    continue;
                  }

                  if ((int)v12 >= a1)
                  {
LABEL_133:
                    uint64_t v14 = *v2;
                    goto LABEL_134;
                  }

                  v11 += 2;
                  uint64_t v24 = (unsigned __int8 *)a2[(int)v12];
                  if (!strnicmpx(v24, -1LL, "true")
                    || !strnicmpx(v24, -1LL, "yes")
                    || !strnicmpx(v24, -1LL, "y")
                    || !strnicmpx(v24, -1LL, "on")
                    || !strnicmpx(v24, -1LL, "1"))
                  {
                    gTUUserMode = 1;
                    continue;
                  }

                  if (!strnicmpx(v24, -1LL, "false")
                    || !strnicmpx(v24, -1LL, "no")
                    || !strnicmpx(v24, -1LL, "n")
                    || !strnicmpx(v24, -1LL, "off")
                    || !strnicmpx(v24, -1LL, "0"))
                  {
                    gTUUserMode = 0;
                    continue;
                  }

LABEL_131:
                  uint64_t v20 = *v2;
LABEL_132:
                  FPrintF(v20);
                  continue;
                }

                v11 += 2;
                uint64_t v23 = (unsigned __int8 *)a2[(int)v12];
                if (!strnicmpx(v23, -1LL, "true")
                  || !strnicmpx(v23, -1LL, "yes")
                  || !strnicmpx(v23, -1LL, "y")
                  || !strnicmpx(v23, -1LL, "on")
                  || !strnicmpx(v23, -1LL, "1"))
                {
                  gTUStopOnFirstFail = 0;
                  continue;
                }

                if (strnicmpx(v23, -1LL, "false")
                  && strnicmpx(v23, -1LL, "no")
                  && strnicmpx(v23, -1LL, "n")
                  && strnicmpx(v23, -1LL, "off")
                  && strnicmpx(v23, -1LL, "0"))
                {
                  goto LABEL_131;
                }

                gTUStopOnFirstFail = 1;
              }
            }
          }
        }
      }

      while (v11 < a1);
    }
  }

  if (gTUUserMode) {
    LogControl("?.*:level=error");
  }
  if (gTUOutputPath) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = gTUJUnitXMLOutputPath == 0;
  }
  if (!v8) {
    FPrintF(*v2);
  }
  uint64_t v9 = (FILE *)gTUOutputFilePtr;
  if (!gTUOutputFilePtr)
  {
    uint64_t v9 = (FILE *)*v2;
    gTUOutputFilePtr = *v2;
  }

  setvbuf(v9, 0LL, 1, 0x400uLL);
  setvbuf((FILE *)*MEMORY[0x1895F89D0], 0LL, 1, 0x400uLL);
  setvbuf((FILE *)*v2, 0LL, 1, 0x400uLL);
  if (gTUBATSMode == 1 || !gTUUserMode) {
    _TUPrintF();
  }
  gTUTotalPasses = 0;
  gTUTotalFailures = 0;
  gTUTotalExpectedTests = 0;
  gTUStartTicks = mach_absolute_time();
  return 0LL;
}

uint64_t TUConvertToJUnit(const char *a1, CFMutableArrayRef Mutable)
{
  if (!strcmp(a1, "-"))
  {
    int v4 = 0LL;
    int v5 = (FILE *)*MEMORY[0x1895F89D8];
    goto LABEL_7;
  }

  int v4 = fopen(a1, "r");
  int v5 = v4;
  if (!v4)
  {
    if (*__error())
    {
      uint64_t appended = *__error();
      if (!(_DWORD)appended)
      {
        int v4 = 0LL;
        int v5 = 0LL;
        goto LABEL_7;
      }
    }

    else
    {
      uint64_t appended = 4294960596LL;
    }

LABEL_151:
    uint64_t v30 = v80;
  }

LABEL_152:
  if (v94[0]) {
    free(v94[0]);
  }
  if (v93) {
    free(v93);
  }
  if (v30 && fclose(v30) && *__error()) {
    __error();
  }
  uint64_t appended = v92;
LABEL_161:
  if (v81 && fclose(v81) && *__error()) {
    __error();
  }
  if (theArray) {
    CFRelease(theArray);
  }
  if (v86) {
    CFRelease(v86);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (cf) {
    CFRelease(cf);
  }
  if ((_DWORD)appended) {
    goto LABEL_174;
  }
  return appended;
}

uint64_t _TUPrintF()
{
  return VCPrintF((uint64_t)_TUPrintFCallback, 0LL);
}

uint64_t _TUPrintFCallback(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (gTUOutputFilePtr) {
      FPrintF(gTUOutputFilePtr);
    }
    if (!gTUUserMode && (gTUBATSMode & 1) == 0) {
      FPrintF(*MEMORY[0x1895F89D0]);
    }
  }

  return a2;
}

uint64_t _TUConvertToJUnitParseAssertion( unsigned __int8 *a1, unsigned __int8 **a2, int64_t *a3, const char **a4, size_t *a5, const char **a6, int64_t *a7)
{
  for (uint64_t i = a1; ; ++i)
  {
    int v15 = *i;
    if (!*i || v15 == 58) {
      break;
    }
  }

  if (v15 != 58) {
    return 4294960554LL;
  }
  int64_t v16 = i - a1;
  uint64_t v17 = (const char *)(i + 1);
  if (strnicmpx(a1, i - a1, "leaks") && strnicmpx(a1, i - a1, "total"))
  {
    for (int j = (const char *)(i + 2); *(j - 1); ++j)
    {
      if (*(j - 1) == 44)
      {
        CFIndex v32 = a5;
        do
        {
          uint64_t v22 = j;
          int v24 = *(unsigned __int8 *)j++;
          int v23 = v24;
        }

        while (v24 != 44 && v23 != 0);
        double v31 = a7;
        if (v23 == 44)
        {
          CFMutableArrayRef v19 = a6;
          int64_t v20 = v22 - v17;
          uint64_t v26 = MEMORY[0x1895F8770];
          do
          {
            uint64_t v21 = j;
            uint64_t v27 = *(unsigned __int8 *)j;
            if (!*j) {
              break;
            }
            int v28 = (v27 & 0x80) != 0 ? __maskrune(v27, 0x4000uLL) : *(_DWORD *)(v26 + 4 * v27 + 60) & 0x4000;
            int j = v21 + 1;
          }

          while (v28);
          a7 = v31;
          goto LABEL_27;
        }

        return 4294960554LL;
      }
    }

    return 4294960554LL;
  }

  CFIndex v32 = a5;
  CFMutableArrayRef v19 = a6;
  int64_t v20 = 0LL;
  uint64_t v21 = v17;
  uint64_t v17 = 0LL;
LABEL_27:
  size_t v29 = strlen(v21);
  uint64_t result = 0LL;
  *a2 = a1;
  *a3 = v16;
  *a4 = v21;
  *CFIndex v32 = v29;
  *CFMutableArrayRef v19 = v17;
  *a7 = v20;
  return result;
}

void TUFinalize()
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if ((gTUDontRunLeaks & 1) != 0) {
    goto LABEL_60;
  }
  int v0 = gTUBreakOnFail;
  if (gTUBATSMode == 1) {
    _TUPrintF();
  }
  mach_absolute_time();
  pid_t v1 = getpid();
  snprintf(__str, 0x40uLL, "/usr/bin/leaks %d", v1);
  uint64_t v2 = popen(__str, "r");
  if (!v2)
  {
    if (*__error())
    {
      int v3 = *__error();
      if (!v3) {
        goto LABEL_7;
      }
    }

    else
    {
      int v3 = -6700;
    }

uint64_t TULogF(uint64_t a1, int a2, const char *a3)
{
  if (gTULogLevel <= a2)
  {
    int v3 = "";
    if (a3) {
      int v3 = a3;
    }
    int v5 = v3;
    char v6 = 0;
    return VCPrintF((uint64_t)_TULogPrintFCallback, (uint64_t)&v5);
  }

  return result;
}

uint64_t _TULogPrintFCallback(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= 1)
  {
    unint64_t v4 = a1;
    unint64_t v5 = a1 + a2;
    do
    {
      if (!*(_BYTE *)(a3 + 8))
      {
        FPrintF(gTUOutputFilePtr);
        *(_BYTE *)(a3 + _Block_object_dispose(va, 8) = 1;
      }

      unint64_t v6 = v4;
      if (v4 >= v5)
      {
LABEL_10:
        FPrintF(gTUOutputFilePtr);
        unint64_t v4 = v6;
      }

      else
      {
        uint64_t v7 = 0LL;
        while (1)
        {
          uint64_t v8 = v4 + v7;
          if (*(_BYTE *)(v4 + v7) == 10) {
            break;
          }
          if (v5 - v4 == ++v7)
          {
            unint64_t v6 = v5;
            goto LABEL_10;
          }
        }

        FPrintF(gTUOutputFilePtr);
        unint64_t v4 = v8 + 1;
        FPrintF(gTUOutputFilePtr);
        *(_BYTE *)(a3 + _Block_object_dispose(va, 8) = 0;
      }
    }

    while (v4 < v5);
  }

  if (!a2 && *(_BYTE *)(a3 + 8))
  {
    FPrintF(gTUOutputFilePtr);
    *(_BYTE *)(a3 + _Block_object_dispose(va, 8) = 0;
  }

  return a2;
}

BOOL TULogLevelEnabled(uint64_t a1, int a2)
{
  return gTULogLevel <= a2;
}

void _TUXCTestSetup(void *a1)
{
  id v3 = (id)[a1 copy];
  pid_t v1 = _Block_copy(v3);
  uint64_t v2 = (void *)gTUXCTestFailer;
  gTUXCTestFailer = (uint64_t)v1;
}

uint64_t TUSetExpectedTestCount(uint64_t result)
{
  gTUTotalExpectedTests = result;
  return result;
}

size_t _TUPerformTest(size_t result, void (*a2)(__int128 *))
{
  id v3 = (_BYTE *)result;
  __int128 v19 = xmmword_189F34210;
  __int128 v20 = unk_189F34220;
  unint64_t v4 = (unsigned __int8 *)gTUExcludedTests;
  if (!gTUExcludedTests)
  {
LABEL_12:
    uint64_t v9 = (unsigned __int8 *)gTUFilter;
    if (gTUFilter)
    {
      uint64_t result = strlen((const char *)gTUFilter);
      uint64_t v10 = (unsigned __int8 *)(gTUFilter + result);
      do
      {
        if (v9 >= v10)
        {
LABEL_18:
          uint64_t v12 = v10;
          uint64_t v13 = v10;
          if (v9 == v10) {
            return result;
          }
        }

        else
        {
          int64_t v11 = v10 - v9;
          uint64_t v12 = v9;
          while (*v12 != 44)
          {
            ++v12;
            if (!--v11) {
              goto LABEL_18;
            }
          }

          uint64_t v13 = v12 + 1;
        }

        uint64_t result = strnicmpx(v9, v12 - v9, v3);
        uint64_t v9 = v13;
      }

      while ((_DWORD)result);
    }

    int v14 = (FILE **)MEMORY[0x1895F89E0];
    if (!gTUOutputFilePtr) {
      gTUOutputFilePtr = *MEMORY[0x1895F89E0];
    }
    *(void *)&__int128 v19 = v3;
    if (gTUQualifier)
    {
      if ((gTUBATSMode & 1) == 0 && gTUUserMode) {
        goto LABEL_33;
      }
    }

    else if ((gTUBATSMode & 1) == 0 && gTUUserMode)
    {
      goto LABEL_33;
    }

    uint64_t result = _TUPrintF();
LABEL_33:
    unsigned int v15 = (void *)MEMORY[0x186E432B4](result, a2);
    mach_absolute_time();
    a2(&v19);
    mach_absolute_time();
    objc_autoreleasePoolPop(v15);
    if ((_DWORD)v20) {
      BOOL v16 = DWORD1(v20) == 0;
    }
    else {
      BOOL v16 = 0;
    }
    int v17 = v16;
    if (gTUUserMode)
    {
      if (sUpTicksToSecondsOnce != -1) {
        dispatch_once_f( &sUpTicksToSecondsOnce,  &sUpTicksToSecondsMultiplier,  (dispatch_function_t)_UpTicksToSecondsInit);
      }
      goto LABEL_47;
    }

    if (gTUBATSMode == 1)
    {
      if (sUpTicksToSecondsOnce == -1) {
        goto LABEL_46;
      }
    }

    else
    {
      _TUPrintF();
      if (sUpTicksToSecondsOnce == -1)
      {
LABEL_46:
        _TUPrintF();
LABEL_47:
        _TUPrintF();
        int v18 = (int *)&gTUSuiteFailures;
        if (v17) {
          int v18 = &gTUSuitePasses;
        }
        ++*v18;
        if (gTUOutputFilePtr) {
          fflush((FILE *)gTUOutputFilePtr);
        }
        fflush((FILE *)*MEMORY[0x1895F89D0]);
        return fflush(*v14);
      }
    }

    dispatch_once_f(&sUpTicksToSecondsOnce, &sUpTicksToSecondsMultiplier, (dispatch_function_t)_UpTicksToSecondsInit);
    goto LABEL_46;
  }

  uint64_t result = strlen((const char *)gTUExcludedTests);
  unint64_t v5 = (unsigned __int8 *)(gTUExcludedTests + result);
  do
  {
    if (v4 >= v5)
    {
LABEL_7:
      uint64_t v7 = v5;
      uint64_t v8 = v5;
      if (v4 == v5) {
        goto LABEL_12;
      }
    }

    else
    {
      int64_t v6 = v5 - v4;
      uint64_t v7 = v4;
      while (*v7 != 44)
      {
        ++v7;
        if (!--v6) {
          goto LABEL_7;
        }
      }

      uint64_t v8 = v7 + 1;
    }

    uint64_t result = strnicmpx(v4, v7 - v4, v3);
    unint64_t v4 = v8;
  }

  while ((_DWORD)result);
  return result;
}

uint64_t TUTestRequire(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5 = a3;
  if ((*(_BYTE *)(a1 + 28) & 8) == 0)
  {
    uint64_t v7 = &gTUTotalFailures;
    if ((_DWORD)a3) {
      uint64_t v7 = &gTUTotalPasses;
    }
    do
      unsigned int v8 = __ldaxr((unsigned int *)v7);
    while (__stlxr(v8 + 1, (unsigned int *)v7));
    if ((_DWORD)a3) {
      int v9 = *(_DWORD *)(a1 + 20);
    }
    else {
      int v9 = *(_DWORD *)(a1 + 20) + 1;
    }
    *(_DWORD *)(a1 + 16) += a3 != 0;
    *(_DWORD *)(a1 + 20) = v9;
  }

  if ((_DWORD)a3)
  {
    uint64_t v10 = 0LL;
    if (gTULogLevel > 30) {
      return v10;
    }
  }

  else if ((a2 & 1) == 0 && ((gTUStopOnFirstFail & 1) != 0 || (*(_BYTE *)(a1 + 28) & 4) != 0))
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v10 = 4294960544LL;
  }

  if ((*(_BYTE *)(a1 + 28) & 8) != 0) {
    goto LABEL_28;
  }
  _TUPrintF();
  for (uint64_t i = a4 + 1; *(_BYTE *)(i - 1) == 47 || *(_BYTE *)(i - 1); ++i)
    ;
  _TUPrintF();
  if (v5 || (gTUBreakOnFail & 1) != 0)
  {
LABEL_28:
    if (v5) {
      return v10;
    }
  }

  else if ((*(_BYTE *)(a1 + 28) & 2) == 0 && DebugIsDebuggerPresent())
  {
    __debugbreak();
    JUMPOUT(0x186B37A10LL);
  }

  if (!*(_DWORD *)(a1 + 24)) {
    *(_DWORD *)(a1 + 24) = -6737;
  }
  if ((*(_BYTE *)(a1 + 28) & 8) == 0 && gTUXCTestFailer) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(gTUXCTestFailer + 16))(gTUXCTestFailer, a2, a3, a4);
  }
  return v10;
}

uint64_t TUTestRequireNoErr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5 = a3;
  if ((*(_BYTE *)(a1 + 28) & 8) == 0)
  {
    uint64_t v7 = &gTUTotalFailures;
    if (!(_DWORD)a3) {
      uint64_t v7 = &gTUTotalPasses;
    }
    do
      unsigned int v8 = __ldaxr((unsigned int *)v7);
    while (__stlxr(v8 + 1, (unsigned int *)v7));
    if ((_DWORD)a3) {
      int v9 = *(_DWORD *)(a1 + 20) + 1;
    }
    else {
      int v9 = *(_DWORD *)(a1 + 20);
    }
    *(_DWORD *)(a1 + 16) += a3 == 0;
    *(_DWORD *)(a1 + 20) = v9;
  }

  if ((_DWORD)a3)
  {
    uint64_t v10 = a3;
    if ((a2 & 1) == 0)
    {
      if ((gTUStopOnFirstFail & 1) != 0)
      {
        uint64_t v10 = 0LL;
      }

      else if ((*(_BYTE *)(a1 + 28) & 4) != 0)
      {
        uint64_t v10 = 0LL;
      }

      else
      {
        uint64_t v10 = a3;
      }
    }
  }

  else
  {
    uint64_t v10 = 0LL;
    if (gTULogLevel > 30) {
      return v10;
    }
  }

  if ((*(_BYTE *)(a1 + 28) & 8) != 0) {
    goto LABEL_29;
  }
  _TUPrintF();
  for (uint64_t i = a4 + 1; *(_BYTE *)(i - 1) == 47 || *(_BYTE *)(i - 1); ++i)
    ;
  _TUPrintF();
  if (!v5 || (gTUBreakOnFail & 1) != 0)
  {
LABEL_29:
    if (!v5) {
      return v10;
    }
  }

  else if ((*(_BYTE *)(a1 + 28) & 2) == 0 && DebugIsDebuggerPresent())
  {
    __debugbreak();
    JUMPOUT(0x186B37BD4LL);
  }

  if (!*(_DWORD *)(a1 + 24)) {
    *(_DWORD *)(a1 + 24) = v5;
  }
  if ((*(_BYTE *)(a1 + 28) & 8) == 0 && gTUXCTestFailer) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(gTUXCTestFailer + 16))(gTUXCTestFailer, a2, a3, a4);
  }
  return v10;
}

BOOL TUTestRequireNoNSError(uint64_t a1, char a2, int a3, void *a4, uint64_t a5)
{
  id v12 = a4;
  if ((*(_BYTE *)(a1 + 28) & 8) == 0)
  {
    uint64_t v13 = &gTUTotalFailures;
    if (a3) {
      uint64_t v13 = &gTUTotalPasses;
    }
    do
      unsigned int v14 = __ldaxr((unsigned int *)v13);
    while (__stlxr(v14 + 1, (unsigned int *)v13));
    int v15 = *(_DWORD *)(a1 + 20) + (a3 ^ 1);
    *(_DWORD *)(a1 + 16) += a3;
    *(_DWORD *)(a1 + 20) = v15;
  }

  if ((a3 & 1) != 0)
  {
    BOOL v16 = 0LL;
    if (gTULogLevel > 30) {
      goto LABEL_25;
    }
  }

  else
  {
    BOOL v16 = (a2 & 1) != 0 || (gTUStopOnFirstFail & 1) == 0 && (*(_BYTE *)(a1 + 28) & 4) == 0;
  }

  if ((*(_BYTE *)(a1 + 28) & 8) == 0)
  {
    _TUPrintF();
    for (uint64_t i = a5 + 1; *(_BYTE *)(i - 1) == 47 || *(_BYTE *)(i - 1); ++i)
      ;
    _TUPrintF();
    if ((a3 & 1) == 0
      && (gTUBreakOnFail & 1) == 0
      && (*(_BYTE *)(a1 + 28) & 2) == 0
      && DebugIsDebuggerPresent())
    {
      __debugbreak();
    }
  }

uint64_t TULogV(uint64_t a1, int a2, const char *a3)
{
  id v3 = "";
  if (a3) {
    id v3 = a3;
  }
  int v5 = v3;
  char v6 = 0;
  if (gTULogLevel <= a2) {
    return VCPrintF((uint64_t)_TULogPrintFCallback, (uint64_t)&v5);
  }
  return result;
}

uint64_t TUFaultEnable(char *a1, uint64_t a2)
{
  if (!_TUFaultLookup(a1, &v10))
  {
    uint64_t v7 = 0LL;
    *((void *)*v10 + 2) = a2;
    goto LABEL_6;
  }

  unint64_t v4 = calloc(1uLL, 0x18uLL);
  if (!v4)
  {
LABEL_8:
    uint64_t v7 = 4294960568LL;
    goto LABEL_6;
  }

  int v5 = v4;
  char v6 = strdup(a1);
  v5[1] = v6;
  if (!v6)
  {
    free(v5);
    goto LABEL_8;
  }

  uint64_t v7 = 0LL;
  unint64_t v5[2] = a2;
  unsigned int v8 = v10;
  *int v5 = *v10;
  unsigned __int8 *v8 = (const char *)v5;
LABEL_6:
  pthread_mutex_unlock(&gTUFaultLock);
  return v7;
}

uint64_t _TUFaultLookup(char *a1, const char ***a2)
{
  int v4 = *a1;
  if (*a1)
  {
    int v5 = a1 + 1;
    unsigned int v6 = -2128831035;
    do
    {
      unsigned int v6 = 16777619 * (v6 ^ v4);
      int v7 = *v5++;
      int v4 = v7;
    }

    while (v7);
    uint64_t v8 = v6 % 0x1F;
  }

  else
  {
    uint64_t v8 = 8LL;
  }

  uint64_t v9 = (const char **)((char *)&gTUFaultHashTable + 8 * v8);
  do
  {
    uint64_t v10 = v9;
    uint64_t v9 = (const char **)*v9;
  }

  while (v9 && strcasecmp(v9[1], a1));
  if (a2) {
    *a2 = v10;
  }
  if (v9) {
    return 0LL;
  }
  else {
    return 4294960569LL;
  }
}

uint64_t TUFaultDisable(char *a1)
{
  uint64_t v2 = _TUFaultLookup(a1, (const char ***)&v5);
  if (!(_DWORD)v2)
  {
    id v3 = (void **)*v5;
    *int v5 = (const char **)**v5;
    free(v3[1]);
    free(v3);
  }

  pthread_mutex_unlock(&gTUFaultLock);
  return v2;
}

uint64_t TUFaultInject(char *a1, int a2, _BYTE *a3)
{
  uint64_t v6 = _TUFaultLookup(a1, &v11);
  if ((_DWORD)v6)
  {
    uint64_t v7 = v6;
  }

  else
  {
    uint64_t v7 = 4294960564LL;
    uint64_t v8 = (uint64_t)*v11;
    switch(a2)
    {
      case 1:
      case 2:
      case 3:
        uint64_t v7 = 0LL;
        *a3 = *(void *)(v8 + 16);
        break;
      case 4:
      case 5:
        uint64_t v7 = 0LL;
        *(_WORD *)a3 = *(void *)(v8 + 16);
        break;
      case 6:
      case 7:
      case 10:
        uint64_t v7 = 0LL;
        *(_DWORD *)a3 = *(void *)(v8 + 16);
        break;
      case 8:
      case 9:
      case 11:
        uint64_t v7 = 0LL;
        *(void *)a3 = *(void *)(v8 + 16);
        break;
      case 20:
      case 22:
        uint64_t v7 = 0LL;
        float v9 = *(double *)(v8 + 16);
        *(float *)a3 = v9;
        break;
      case 21:
      case 23:
        uint64_t v7 = 0LL;
        *(void *)a3 = *(void *)(v8 + 16);
        break;
      default:
        break;
    }
  }

  pthread_mutex_unlock(&gTUFaultLock);
  return v7;
}

_OWORD *TUTestStateCreate(int *a1)
{
  if (TUTestStateGetTypeID_sOnce != -1) {
    dispatch_once_f( &TUTestStateGetTypeID_sOnce,  &TUTestStateGetTypeID_sTypeID,  (dispatch_function_t)_TUTestStateGetTypeID);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  id v3 = Instance;
  if (Instance)
  {
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
    Instance[1] = 0u;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    *((void *)v3 + 2) = Mutable;
    if (!Mutable)
    {
      int v5 = -6728;
LABEL_7:
      CFRelease(v3);
      id v3 = 0LL;
      goto LABEL_8;
    }

    int v5 = pthread_mutex_init((pthread_mutex_t *)((char *)v3 + 24), 0LL);
    if (v5) {
      goto LABEL_7;
    }
    *((void *)v3 + 11) = (char *)v3 + 24;
    int v5 = pthread_cond_init((pthread_cond_t *)v3 + 2, 0LL);
    if (v5) {
      goto LABEL_7;
    }
    *((void *)v3 + 1_Block_object_dispose(va, 8) = v3 + 6;
  }

  else
  {
    int v5 = -6728;
  }

uint64_t _TUTestStateGetTypeID(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

pthread_mutex_t *_TUTestStateFinalize(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0LL;
  }

  id v3 = (pthread_cond_t *)a1[18];
  if (v3)
  {
    pthread_cond_destroy(v3);
    a1[18] = 0LL;
  }

  uint64_t result = (pthread_mutex_t *)a1[11];
  if (result)
  {
    uint64_t result = (pthread_mutex_t *)pthread_mutex_destroy(result);
    a1[11] = 0LL;
  }

  return result;
}

CFMutableStringRef _TUTestStateCopyDescription()
{
  CFMutableStringRef v1 = 0LL;
  CFAppendPrintF(&v1);
  return v1;
}

const void *TUTestStateGetObject(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 0LL;
  }
  if (!a2) {
    return 0LL;
  }
  if (!*(void *)(a1 + 16)) {
    return 0LL;
  }
  int v4 = *(pthread_mutex_t **)(a1 + 88);
  if (!v4) {
    return 0LL;
  }
  pthread_mutex_lock(v4);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 88));
  return Value;
}

uint64_t TUTestStateSetObject(uint64_t result, const void *a2, const void *a3)
{
  if (result)
  {
    if (a2)
    {
      uint64_t v4 = result;
      if (*(void *)(result + 16))
      {
        uint64_t result = *(void *)(result + 88);
        if (result)
        {
          pthread_mutex_lock((pthread_mutex_t *)result);
          uint64_t v6 = *(__CFDictionary **)(v4 + 16);
          if (a3) {
            CFDictionarySetValue(v6, a2, a3);
          }
          else {
            CFDictionaryRemoveValue(v6, a2);
          }
          return pthread_mutex_unlock(*(pthread_mutex_t **)(v4 + 88));
        }
      }
    }
  }

  return result;
}

int64_t TUTestStateGetSInt32(uint64_t a1, const void *a2, _DWORD *a3)
{
  if (!a1 || !a2 || !*(void *)(a1 + 16) || (uint64_t v6 = *(pthread_mutex_t **)(a1 + 88)) == 0LL)
  {
    int64_t Int64Ranged = 0LL;
    int v9 = -6745;
    if (!a3) {
      return Int64Ranged;
    }
    goto LABEL_6;
  }

  pthread_mutex_lock(v6);
  int64_t Int64Ranged = CFDictionaryGetInt64Ranged( *(const __CFDictionary **)(a1 + 16),  a2,  0xFFFFFFFF80000000LL,  0x7FFFFFFFLL,  &v9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 88));
  if (a3) {
LABEL_6:
  }
    *a3 = v9;
  return Int64Ranged;
}

uint64_t TUTestStateSetSInt32(uint64_t result, const void *a2, int a3)
{
  if (result)
  {
    if (a2)
    {
      uint64_t v4 = result;
      if (*(void *)(result + 16))
      {
        uint64_t result = *(void *)(result + 88);
        if (result)
        {
          pthread_mutex_lock((pthread_mutex_t *)result);
          CFDictionarySetInt64(*(__CFDictionary **)(v4 + 16), a2, a3);
          return pthread_mutex_unlock(*(pthread_mutex_t **)(v4 + 88));
        }
      }
    }
  }

  return result;
}

uint64_t TUTestStateUpdateSInt32(uint64_t a1, const void *a2, int a3)
{
  uint64_t v3 = 0LL;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 16) && (uint64_t v6 = *(pthread_mutex_t **)(a1 + 88)) != 0LL)
    {
      pthread_mutex_lock(v6);
      uint64_t v3 = CFDictionaryGetInt64Ranged( *(const __CFDictionary **)(a1 + 16),  a2,  0xFFFFFFFF80000000LL,  0x7FFFFFFFLL,  0LL)
         + a3;
      CFDictionarySetInt64(*(__CFDictionary **)(a1 + 16), a2, (int)v3);
      pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 88));
    }

    else
    {
      return 0LL;
    }
  }

  return v3;
}

uint64_t TUTestStateSignal(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = *(void *)(result + 88);
    if (result)
    {
      if (*(void *)(v1 + 144))
      {
        pthread_mutex_lock((pthread_mutex_t *)result);
        ++*(_DWORD *)(v1 + 152);
        pthread_cond_signal(*(pthread_cond_t **)(v1 + 144));
        return pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 88));
      }
    }
  }

  return result;
}

uint64_t TUTestStateSignalCount(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 152);
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 88));
  return v2;
}

uint64_t TUTestStateWait(uint64_t a1, double a2)
{
  if (!a1 || !*(void *)(a1 + 88) || !*(void *)(a1 + 144)) {
    return 4294960551LL;
  }
  v13.tv_seCC_SHA1_CTX c = 0LL;
  v13.tv_nseCC_SHA1_CTX c = 0LL;
  clock_gettime(_CLOCK_REALTIME, &v13);
  __darwin_time_t v4 = v13.tv_sec + (uint64_t)a2;
  v13.tv_seCC_SHA1_CTX c = v4;
  double v5 = (a2 - (double)(uint64_t)a2) * 1000000000.0;
  uint64_t v6 = v13.tv_nsec + (uint64_t)v5;
  if (v6 > 999999999)
  {
    uint64_t v7 = 1999999999LL;
    if (v6 < 1999999999) {
      uint64_t v7 = v13.tv_nsec + (uint64_t)v5;
    }
    unint64_t v8 = (v6 + 999999999 - v7) / 0x3B9ACA00uLL;
    uint64_t v6 = v6 - 1000000000 * v8 - 1000000000;
    v13.tv_seCC_SHA1_CTX c = v4 + v8 + 1;
  }

  v13.tv_nseCC_SHA1_CTX c = v6;
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 88));
  while (1)
  {
    int v9 = *(_DWORD *)(a1 + 152);
    if (v9) {
      break;
    }
    uint64_t v10 = pthread_cond_timedwait(*(pthread_cond_t **)(a1 + 144), *(pthread_mutex_t **)(a1 + 88), &v13);
    if ((_DWORD)v10)
    {
      uint64_t v11 = v10;
      goto LABEL_14;
    }
  }

  uint64_t v11 = 0LL;
  *(_DWORD *)(a1 + 152) = v9 - 1;
LABEL_14:
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 88));
  return v11;
}

uint64_t GetMachThreadPriority(_DWORD *a1, kern_return_t *a2)
{
  kern_return_t v6;
  uint64_t v7;
  int v9;
  integer_t v10[5];
  integer_t v11[5];
  integer_t v12[4];
  integer_t thread_info_out[5];
  int v14;
  mach_msg_type_number_t thread_info_outCnt;
  __darwin_time_t v4 = pthread_self();
  thread_inspect_t v5 = pthread_mach_thread_np(v4);
  thread_info_outCnt = 10;
  uint64_t v6 = thread_info(v5, 3u, thread_info_out, &thread_info_outCnt);
  if (v6) {
    goto LABEL_2;
  }
  int v9 = v14;
  if (a1) {
    *a1 = v14;
  }
  switch(v9)
  {
    case 4:
      thread_info_outCnt = 4;
      uint64_t v6 = thread_info(v5, 0xCu, v12, &thread_info_outCnt);
      if (v6) {
        goto LABEL_2;
      }
      uint64_t v7 = v12[1];
      break;
    case 2:
      thread_info_outCnt = 5;
      uint64_t v6 = thread_info(v5, 0xBu, v11, &thread_info_outCnt);
      if (v6) {
        goto LABEL_2;
      }
      uint64_t v7 = v11[1];
      break;
    case 1:
      thread_info_outCnt = 5;
      uint64_t v6 = thread_info(v5, 0xAu, v10, &thread_info_outCnt);
      if (!v6)
      {
        uint64_t v7 = v10[1];
        break;
      }

uint64_t SetCurrentThreadPriority(int a1)
{
  if (a1 == 0x7FFFFFFF)
  {
    BOOLean_t get_default = 1;
    mach_msg_type_number_t policy_infoCnt = 4;
    thread_inspect_t v1 = MEMORY[0x186E430BC]();
    uint64_t result = thread_policy_get(v1, 2u, (thread_policy_t)policy_info, &policy_infoCnt, &get_default);
    if (!(_DWORD)result)
    {
      thread_act_t v3 = MEMORY[0x186E430BC]();
      return thread_policy_set(v3, 2u, (thread_policy_t)policy_info, 4u);
    }
  }

  else
  {
    thread_inspect_t v5 = pthread_self();
    uint64_t result = pthread_getschedparam(v5, (int *)&policy_infoCnt, policy_info);
    if (!(_DWORD)result)
    {
      policy_info[0].sched_priority = a1;
      uint64_t v6 = pthread_self();
      return pthread_setschedparam(v6, 2, policy_info);
    }
  }

  return result;
}

uint64_t UpTicksPerSecond()
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  return UpTicksPerSecond_sTicksPerSecond;
}

uint64_t _UpTicksPerSecondInit(unint64_t *a1)
{
  unint64_t v2 = 1000000000LL;
  uint64_t result = mach_timebase_info(&info);
  if (!(_DWORD)result)
  {
    if (info.numer) {
      BOOL v4 = info.denom == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (!v4) {
      unint64_t v2 = 1000000000 * (unint64_t)info.denom / info.numer;
    }
  }

  *a1 = v2;
  return result;
}

uint64_t SleepForUpTicks(uint64_t a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  unint64_t v2 = UpTicksPerSecond_sTicksPerSecond;
  uint64_t result = mach_absolute_time();
  for (i = result + a1; result < i; uint64_t result = mach_absolute_time())
  {
    v5.tv_seCC_SHA1_CTX c = (int)((i - result) / v2);
    v5.tv_nseCC_SHA1_CTX c = (int)(1000000000 * ((i - result) % v2) / v2);
    if (nanosleep(&v5, 0LL))
    {
      if (*__error()) {
        __error();
      }
    }
  }

  return result;
}

uint64_t SleepUntilUpTicks(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = mach_absolute_time();
    BOOL v3 = v1 >= v2;
    uint64_t result = v1 - v2;
    if (result != 0 && v3) {
      return SleepForUpTicks(result);
    }
  }

  return result;
}

unint64_t UpTicksToSeconds(unint64_t a1)
{
  if (sUpTicksToSecondsOnce != -1) {
    dispatch_once_f(&sUpTicksToSecondsOnce, &sUpTicksToSecondsMultiplier, (dispatch_function_t)_UpTicksToSecondsInit);
  }
  return (unint64_t)(*(double *)&sUpTicksToSecondsMultiplier * (double)a1);
}

double _UpTicksToSecondsInit(double *a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  double result = 1.0 / (double)(unint64_t)UpTicksPerSecond_sTicksPerSecond;
  *a1 = result;
  return result;
}

double UpTicksToSecondsF(unint64_t a1)
{
  if (sUpTicksToSecondsOnce != -1) {
    dispatch_once_f(&sUpTicksToSecondsOnce, &sUpTicksToSecondsMultiplier, (dispatch_function_t)_UpTicksToSecondsInit);
  }
  return *(double *)&sUpTicksToSecondsMultiplier * (double)a1;
}

unint64_t UpTicksToMilliseconds(unint64_t a1)
{
  if (UpTicksToMilliseconds_sOnce != -1) {
    dispatch_once_f( &UpTicksToMilliseconds_sOnce,  &UpTicksToMilliseconds_sMultiplier,  (dispatch_function_t)_UpTicksToMillisecondsInit);
  }
  return (unint64_t)(*(double *)&UpTicksToMilliseconds_sMultiplier * (double)a1);
}

double _UpTicksToMillisecondsInit(double *a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  double result = 1000.0 / (double)(unint64_t)UpTicksPerSecond_sTicksPerSecond;
  *a1 = result;
  return result;
}

unint64_t UpTicksToMicroseconds(unint64_t a1)
{
  if (UpTicksToMicroseconds_sOnce != -1) {
    dispatch_once_f( &UpTicksToMicroseconds_sOnce,  &UpTicksToMicroseconds_sMultiplier,  (dispatch_function_t)_UpTicksToMicrosecondsInit);
  }
  return (unint64_t)(*(double *)&UpTicksToMicroseconds_sMultiplier * (double)a1);
}

double _UpTicksToMicrosecondsInit(double *a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  double result = 1000000.0 / (double)(unint64_t)UpTicksPerSecond_sTicksPerSecond;
  *a1 = result;
  return result;
}

unint64_t UpTicksToNanoseconds(unint64_t a1)
{
  if (UpTicksToNanoseconds_sOnce != -1) {
    dispatch_once_f( &UpTicksToNanoseconds_sOnce,  &UpTicksToNanoseconds_sMultiplier,  (dispatch_function_t)_UpTicksToNanosecondsInit);
  }
  return (unint64_t)(*(double *)&UpTicksToNanoseconds_sMultiplier * (double)a1);
}

double _UpTicksToNanosecondsInit(double *a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  double result = 1000000000.0 / (double)(unint64_t)UpTicksPerSecond_sTicksPerSecond;
  *a1 = result;
  return result;
}

unint64_t UpTicksToNTP(unint64_t a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
}

uint64_t SecondsToUpTicks(uint64_t a1)
{
  if (SecondsToUpTicks_sOnce != -1) {
    dispatch_once_f(&SecondsToUpTicks_sOnce, &SecondsToUpTicks_sMultiplier, (dispatch_function_t)_SecondsToUpTicksInit);
  }
  return SecondsToUpTicks_sMultiplier * a1;
}

void _SecondsToUpTicksInit(void *a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  *a1 = UpTicksPerSecond_sTicksPerSecond;
}

unint64_t SecondsToUpTicksF(double a1)
{
  if (SecondsToUpTicksF_sOnce != -1) {
    dispatch_once_f( &SecondsToUpTicksF_sOnce,  &SecondsToUpTicksF_sMultiplier,  (dispatch_function_t)_SecondsToUpTicksFInit);
  }
  return (unint64_t)(*(double *)&SecondsToUpTicksF_sMultiplier * a1);
}

double _SecondsToUpTicksFInit(double *a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  double result = (double)(unint64_t)UpTicksPerSecond_sTicksPerSecond;
  *a1 = (double)(unint64_t)UpTicksPerSecond_sTicksPerSecond;
  return result;
}

unint64_t MillisecondsToUpTicks(unint64_t a1)
{
  if (MillisecondsToUpTicks_sOnce != -1) {
    dispatch_once_f( &MillisecondsToUpTicks_sOnce,  &MillisecondsToUpTicks_sMultiplier,  (dispatch_function_t)_MillisecondsToUpTicksInit);
  }
  return (unint64_t)(*(double *)&MillisecondsToUpTicks_sMultiplier * (double)a1);
}

double _MillisecondsToUpTicksInit(double *a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  double result = (double)(unint64_t)UpTicksPerSecond_sTicksPerSecond / 1000.0;
  *a1 = result;
  return result;
}

unint64_t MicrosecondsToUpTicks(unint64_t a1)
{
  if (MicrosecondsToUpTicks_sOnce != -1) {
    dispatch_once_f( &MicrosecondsToUpTicks_sOnce,  &MicrosecondsToUpTicks_sMultiplier,  (dispatch_function_t)_MicrosecondsToUpTicksInit);
  }
  return (unint64_t)(*(double *)&MicrosecondsToUpTicks_sMultiplier * (double)a1);
}

double _MicrosecondsToUpTicksInit(double *a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  double result = (double)(unint64_t)UpTicksPerSecond_sTicksPerSecond / 1000000.0;
  *a1 = result;
  return result;
}

unint64_t NanosecondsToUpTicks(unint64_t a1)
{
  if (NanosecondsToUpTicks_sOnce != -1) {
    dispatch_once_f( &NanosecondsToUpTicks_sOnce,  &NanosecondsToUpTicks_sMultiplier,  (dispatch_function_t)_NanosecondsToUpTicksInit);
  }
  return (unint64_t)(*(double *)&NanosecondsToUpTicks_sMultiplier * (double)a1);
}

double _NanosecondsToUpTicksInit(double *a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  double result = (double)(unint64_t)UpTicksPerSecond_sTicksPerSecond / 1000000000.0;
  *a1 = result;
  return result;
}

unint64_t NTPtoUpTicks(unint64_t a1)
{
  if (UpTicksPerSecond_sOnce != -1) {
    dispatch_once_f( &UpTicksPerSecond_sOnce,  &UpTicksPerSecond_sTicksPerSecond,  (dispatch_function_t)_UpTicksPerSecondInit);
  }
  return UpTicksPerSecond_sTicksPerSecond * HIDWORD(a1)
       + ((UpTicksPerSecond_sTicksPerSecond * (unint64_t)a1) >> 32);
}

__darwin_time_t NanoTimeGetCurrent()
{
  return (1000 * v1.tv_usec) + 1000000000 * v1.tv_sec;
}

uint64_t YMD_HMStoSeconds(int a1, int a2, int a3, int a4, int a5, unsigned int a6, int a7)
{
  int v7 = a1 + 2;
  if (a1 >= 1) {
    int v7 = a1 - 1;
  }
  int v8 = 365 * (a1 - 1) + (v7 >> 2) + (a1 - 1) / -100 + (a1 - 1) / 400 + (3057 * a2 - 3007) / 100;
  HIDWORD(v10) = -1030792151 * a1 + 85899344;
  LODWORD(v10) = HIDWORD(v10);
  unsigned int v9 = v10 >> 2;
  LODWORD(v10) = HIDWORD(v10);
  else {
    int v11 = -1;
  }
  if (v9 <= 0x28F5C28) {
    int v12 = v11;
  }
  else {
    int v12 = -1;
  }
  if ((a1 & 3) != 0) {
    int v12 = -2;
  }
  int v13 = v12 + v8;
  if (a2 >= 3) {
    int v8 = v13;
  }
  return 60 * a5 + (uint64_t)(3600 * a4) + a6 + 86400LL * (a3 - a7 + v8);
}

unint64_t SecondsToYMD_HMS( uint64_t a1, int *a2, _DWORD *a3, _DWORD *a4, int *a5, unsigned int *a6, _DWORD *a7)
{
  uint64_t v7 = a1 / 86400;
  uint64_t v8 = 963315389LL * (int)(400 * (a1 / 86400));
  int v9 = (v8 >> 47) + ((unint64_t)v8 >> 63);
  int v10 = 365 * v9 - 365;
  do
  {
    int v11 = v9;
    if (v9 >= 0) {
      int v12 = v9;
    }
    else {
      int v12 = v9 + 3;
    }
    int v13 = v9 / -100;
    int v14 = v9 / 400;
    ++v9;
    v10 += 365;
  }

  while (v10 + v14 + v13 + (v12 >> 2) < (int)v7);
  int v15 = a1 % 86400;
  int v16 = v11 - 1;
  if (v11 >= 1) {
    int v17 = v11 - 1;
  }
  else {
    int v17 = v11 + 2;
  }
  unint64_t result = (unint64_t)(-1374389535LL * v16) >> 63;
  int v19 = v7 - (v17 >> 2) - 365 * v16 + v16 / 100 + v16 / -400;
  int v20 = v19;
  if (v19 >= 60)
  {
    int v20 = v19 + 2;
    if ((v11 & 3) == 0)
    {
      HIDWORD(v21) = -1030792151 * v11 + 85899344;
      LODWORD(v21) = HIDWORD(v21);
      if ((v21 >> 2) > 0x28F5C28 || -400 * v14 == -v11)
      {
        else {
          int v22 = -1;
        }
        v20 += v22;
      }
    }
  }

  unint64_t v23 = 1438680573LL * (100 * v20 + 3007);
  unint64_t v24 = HIDWORD(v23);
  unint64_t v25 = v23 >> 63;
  int v26 = v15 / 3600;
  int v27 = v15 + 61936 * (v15 / 3600);
  if (a2) {
    *a2 = v11;
  }
  int v28 = v25 + ((int)v24 >> 10);
  if (a3) {
    *a3 = v28;
  }
  if (a4) {
    *a4 = (3057 * v28 - 3007) / -100 + v20;
  }
  if (a5) {
    *a5 = v26;
  }
  if (a6) {
    *a6 = v29;
  }
  if (a7) {
    *a7 = (__int16)(v27 - 60 * v29);
  }
  return result;
}

const char *MakeFractionalDateString(timeval *a1, char *a2, size_t a3)
{
  timespec v5 = a1;
  if (!a1)
  {
    timespec v5 = &v10;
    gettimeofday(&v10, 0LL);
  }

  tv_seCC_SHA1_CTX c = v5->tv_sec;
  uint64_t v6 = gmtime(&tv_sec);
  if (!v6) {
    return "";
  }
  size_t v7 = strftime(a2, a3, "%Y-%m-%dT%H:%M:%S", v6);
  snprintf(&a2[v7], a3 - v7, ".%06uZ", v5->tv_usec);
  return a2;
}

uint64_t ParseFractionalDateString( char *__s, int64_t a2, uint64_t a3, char **a4, double a5, int32x2_t a6)
{
  int64_t v8 = a2;
  if (a2 == -1) {
    int64_t v8 = strlen(__s);
  }
  timeval v10 = &__s[v8];
  if (v8 < 1)
  {
    int v11 = 0;
    int v13 = 0;
    int v12 = __s;
  }

  else
  {
    int v11 = 0;
    int v12 = __s;
    do
    {
      int v13 = *v12;
      int v11 = *v12++ + 10 * v11 - 48;
    }

    while (v12 < v10);
  }

  if (v12 - __s != 4) {
    return 4294960554LL;
  }
  if (v12 == v10)
  {
    unsigned int v18 = 0;
    unsigned int v19 = 0;
    unsigned int v20 = 0;
    LODWORD(v21) = 0;
    int v15 = 1;
LABEL_29:
    unsigned int v23 = 1;
    goto LABEL_30;
  }

  if (v13 != 90 && v13 != 45) {
    return 4294960554LL;
  }
  int v14 = v12 + 1;
  if (v12 + 1 >= v10)
  {
    int v15 = 0;
    int v17 = v12 + 1;
  }

  else
  {
    int v15 = 0;
    int v16 = (char *)(&__s[v8] - v12 - 1);
    int v17 = v12 + 1;
    while (1)
    {
      int v13 = *v17;
      int v15 = *v17++ + 10 * v15 - 48;
      if (!--v16)
      {
        int v17 = &__s[v8];
        break;
      }
    }
  }

  if (v17 - v14 != 2) {
    return 4294960554LL;
  }
  if (v17 == v10)
  {
    unsigned int v18 = 0;
    unsigned int v19 = 0;
    unsigned int v20 = 0;
    LODWORD(v21) = 0;
    goto LABEL_29;
  }

  if (v13 != 90 && v13 != 45) {
    return 4294960554LL;
  }
  int v22 = v17 + 1;
  if (v13 == 90)
  {
    unsigned int v18 = 0;
    unsigned int v19 = 0;
    unsigned int v20 = 0;
    LODWORD(v21) = 0;
    unsigned int v23 = 1;
LABEL_27:
    timeval v10 = v22;
    goto LABEL_30;
  }

  if (v22 >= v10) {
    return 4294960554LL;
  }
  unsigned int v23 = 0;
  unint64_t v25 = &__s[v8];
  int v26 = &__s[v8 + ~(unint64_t)v17];
  int v27 = v17 + 1;
  while (1)
  {
    int v28 = *v27;
    unsigned __int8 v29 = *v27;
    unsigned int v23 = (char)v28 + 10 * v23 - 48;
    ++v27;
    if (!--v26)
    {
      int v27 = &__s[v8];
      break;
    }
  }

  if (v27 - v22 != 2) {
    return 4294960554LL;
  }
  if (v23 > 0x1F) {
    return 4294960586LL;
  }
  if (v27 == v10)
  {
    unsigned int v18 = 0;
    goto LABEL_49;
  }

  int v22 = v27 + 1;
  if ((char)v28 == 90)
  {
    unsigned int v18 = 0;
LABEL_46:
    unsigned int v19 = 0;
LABEL_47:
    unsigned int v20 = 0;
    LODWORD(v21) = 0;
    goto LABEL_27;
  }

  if (v22 >= v10) {
    return 4294960554LL;
  }
  unsigned int v18 = 0;
  uint64_t v30 = &__s[v8 + ~(unint64_t)v27];
  double v31 = v27 + 1;
  while (1)
  {
    int v32 = *v31;
    unsigned __int8 v33 = *v31;
    unsigned int v18 = (char)v32 + 10 * v18 - 48;
    ++v31;
    if (!--v30)
    {
      double v31 = &__s[v8];
      break;
    }
  }

  if (v31 - v22 != 2) {
    return 4294960554LL;
  }
  if (v18 > 0x17) {
    return 4294960586LL;
  }
  if (v31 == v10)
  {
LABEL_49:
    unsigned int v19 = 0;
LABEL_50:
    unsigned int v20 = 0;
    goto LABEL_51;
  }

  int v22 = v31 + 1;
  if (v22 >= v10) {
    return 4294960554LL;
  }
  unsigned int v19 = 0;
  int v34 = &__s[v8 + ~(unint64_t)v31];
  char v35 = v31 + 1;
  while (1)
  {
    int v36 = *v35;
    unsigned __int8 v37 = *v35;
    unsigned int v19 = (char)v36 + 10 * v19 - 48;
    ++v35;
    if (!--v34)
    {
      char v35 = &__s[v8];
      break;
    }
  }

  if (v35 - v22 != 2) {
    return 4294960554LL;
  }
  if (v19 > 0x3B) {
    return 4294960586LL;
  }
  if (v35 == v10) {
    goto LABEL_50;
  }
  int v22 = v35 + 1;
  if (v22 >= v10) {
    return 4294960554LL;
  }
  unsigned int v20 = 0;
  uint64_t v38 = &__s[v8 + ~(unint64_t)v35];
  int v39 = v35 + 1;
  while (1)
  {
    int v40 = *v39;
    unsigned int v20 = *v39++ + 10 * v20 - 48;
    if (!--v38)
    {
      int v39 = &__s[v8];
      break;
    }
  }

  if (v39 - v22 != 2) {
    return 4294960554LL;
  }
  if (v20 > 0x3D) {
    return 4294960586LL;
  }
  if (v39 == v10)
  {
LABEL_51:
    LODWORD(v21) = 0;
    goto LABEL_30;
  }

  if (v40 != 90 && v40 != 46) {
    return 4294960554LL;
  }
  int v41 = v39 + 1;
  if (v40 == 90)
  {
    LODWORD(v21) = 0;
    timeval v10 = v39 + 1;
    goto LABEL_30;
  }

  if (v41 >= v10)
  {
    uint64_t v42 = 0LL;
    CFIndex v44 = v39 + 1;
  }

  else
  {
    uint64_t v42 = 0LL;
    int v43 = &__s[v8 + ~(unint64_t)v39];
    CFIndex v44 = v41;
    while (1)
    {
      int v40 = *v44;
      uint64_t v42 = *v44++ + 10 * v42 - 48;
      if (!--v43)
      {
        CFIndex v44 = v25;
        break;
      }
    }
  }

  int v45 = (_DWORD)v44 - (_DWORD)v41;
  int v46 = v45 - 1;
  if (v45 < 1)
  {
    uint64_t v53 = 1LL;
  }

  else
  {
    unsigned int v47 = (v45 + 3) & 0xFFFFFFFC;
    a6.i32[0] = v46;
    unsigned int v48 = v46 & 0xFFFFFFFC;
    v49.i64[0] = 0x100000001LL;
    v49.i64[1] = 0x100000001LL;
    v50.i64[0] = 0xA0000000ALL;
    v50.i64[1] = 0xA0000000ALL;
    do
    {
      int8x16_t v51 = v49;
      int8x16_t v49 = (int8x16_t)vmulq_s32((int32x4_t)v49, v50);
      v47 -= 4;
    }

    while (v47);
    int8x16_t v52 = vbslq_s8( (int8x16_t)vcgtq_u32( (uint32x4_t)vorrq_s8((int8x16_t)vdupq_n_s32(v48), (int8x16_t)xmmword_186B49CF0),  (uint32x4_t)vdupq_lane_s32(a6, 0)),  v51,  v49);
    *(int32x2_t *)v52.i8 = vmul_s32(*(int32x2_t *)v52.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL));
    uint64_t v53 = (v52.i32[0] * v52.i32[1]);
  }

  uint64_t v21 = 1000000 * v42 / v53;
  if (v44 != v10)
  {
    if (v40 == 90)
    {
      timeval v10 = v44 + 1;
      goto LABEL_30;
    }

    return 4294960554LL;
  }

uint64_t TLV8Get( unsigned __int8 *a1, unsigned __int8 *a2, int a3, unsigned __int8 **a4, void *a5, unsigned __int8 **a6)
{
  do
  {
    if (a1 == a2) {
      return 4294960569LL;
    }
    if (a1 >= a2) {
      return 4294960591LL;
    }
    uint64_t v6 = a1 + 2;
    uint64_t v7 = a1[1];
    int64_t v8 = &a1[v7 + 2];
    if (v8 > a2) {
      return 4294960546LL;
    }
    int v9 = *a1;
    a1 += v7 + 2;
  }

  while (v9 != a3);
  if (a4) {
    *a4 = v6;
  }
  if (a5) {
    *a5 = v7;
  }
  uint64_t result = 0LL;
  if (a6) {
    *a6 = v8;
  }
  return result;
}

uint64_t TLV8GetNext(_BYTE *a1, _BYTE *a2, _BYTE *a3, void *a4, void *a5, void *a6)
{
  if (a1 == a2) {
    return 4294960569LL;
  }
  if (a1 >= a2) {
    return 4294960591LL;
  }
  uint64_t v6 = a1[1];
  uint64_t v7 = &a1[v6 + 2];
  if (v7 > a2) {
    return 4294960546LL;
  }
  *a3 = *a1;
  *a4 = a1 + 2;
  *a5 = v6;
  uint64_t result = 0LL;
  if (a6) {
    *a6 = v7;
  }
  return result;
}

uint64_t TLV8GetBytes( unsigned __int8 *a1, unsigned __int8 *a2, int a3, unint64_t a4, size_t a5, char *__dst, void *a7, unsigned __int8 **a8)
{
  do
  {
    if (a1 == a2) {
      return 4294960569LL;
    }
    if (a1 >= a2) {
      return 4294960591LL;
    }
    int v14 = a1 + 2;
    size_t v15 = a1[1];
    int v16 = &a1[v15 + 2];
    if (v16 > a2) {
      return 4294960546LL;
    }
    int v17 = *a1;
    a1 += v15 + 2;
  }

  while (v17 != a3);
  if (v15 > a5) {
    return 4294960545LL;
  }
  unsigned int v18 = &__dst[a5];
  memcpy(__dst, v14, v15);
  unsigned int v19 = &__dst[v15];
LABEL_8:
  unsigned int v20 = v16;
  while (a2 > v20)
  {
    uint64_t v21 = v20 + 2;
    size_t v22 = v20[1];
    int v16 = &v20[v22 + 2];
    if (v16 > a2 || *v20 != a3) {
      break;
    }
    v20 += v22 + 2;
    if ((_DWORD)v22)
    {
      if (v18 - v19 < v22) {
        return 4294960545LL;
      }
      memcpy(v19, v21, v22);
      v19 += v22;
      goto LABEL_8;
    }
  }

  if (v19 - __dst < a4) {
    return 4294960546LL;
  }
  if (a7) {
    *a7 = v19 - __dst;
  }
  uint64_t result = 0LL;
  if (a8) {
    *a8 = v20;
  }
  return result;
}

unint64_t TLVParseSInt64(unsigned __int8 *a1, uint64_t a2, char a3, int *a4)
{
  unint64_t result = 0LL;
  int v6 = -6743;
  if ((a3 & 1) != 0)
  {
    switch(a2)
    {
      case 1LL:
LABEL_6:
        int v6 = 0;
        unint64_t result = (char)*a1;
        if (a4) {
          goto LABEL_16;
        }
        return result;
      case 2LL:
        int v6 = 0;
        unint64_t result = (__int16)(*a1 << 8) | (unint64_t)a1[1];
        if (a4) {
          goto LABEL_16;
        }
        return result;
      case 4LL:
        int v6 = 0;
        unint64_t result = (*a1 << 24) | ((unint64_t)a1[1] << 16) | ((unint64_t)a1[2] << 8) | a1[3];
        goto LABEL_15;
      case 8LL:
        int v6 = 0;
        unint64_t result = bswap64(*(void *)a1);
        if (!a4) {
          return result;
        }
        goto LABEL_16;
      default:
LABEL_15:
        if (a4) {
LABEL_16:
        }
          *a4 = v6;
        break;
    }
  }

  else
  {
    switch(a2)
    {
      case 1LL:
        goto LABEL_6;
      case 2LL:
        int v6 = 0;
        unint64_t result = (__int16)(a1[1] << 8) | (unint64_t)*a1;
        if (a4) {
          goto LABEL_16;
        }
        break;
      case 4LL:
        int v6 = 0;
        unint64_t result = *(int *)a1;
        if (a4) {
          goto LABEL_16;
        }
        break;
      case 8LL:
        int v6 = 0;
        unint64_t result = *(void *)a1;
        if (a4) {
          goto LABEL_16;
        }
        break;
      default:
        goto LABEL_15;
    }
  }

  return result;
}

uint64_t TLV8GetUInt64(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int *a4, unsigned __int8 **a5)
{
  do
  {
    if (a1 == a2)
    {
LABEL_16:
      uint64_t result = 0LL;
      int v9 = -6727;
      goto LABEL_13;
    }

    timespec v5 = a1;
    if (a1 >= a2)
    {
      uint64_t result = 0LL;
      int v9 = -6705;
      goto LABEL_13;
    }

    int v6 = a1 + 2;
    uint64_t v7 = a1[1];
    a1 += v7 + 2;
    if (a1 > a2)
    {
      uint64_t result = 0LL;
      int v9 = -6750;
      goto LABEL_13;
    }
  }

  while (*v5 != a3);
  if (a5) {
    *a5 = a1;
  }
  uint64_t result = 0LL;
  int v9 = -6743;
  switch((int)v7)
  {
    case 1:
      int v9 = 0;
      uint64_t result = *v6;
      break;
    case 2:
      int v9 = 0;
      uint64_t result = *((unsigned __int16 *)v5 + 1);
      break;
    case 4:
      int v9 = 0;
      uint64_t result = *(unsigned int *)v6;
      break;
    case 8:
      int v9 = 0;
      uint64_t result = *(void *)v6;
      break;
    default:
      break;
  }

unint64_t TLVParseUInt64(unsigned int *a1, uint64_t a2, char a3, int *a4)
{
  unint64_t result = 0LL;
  int v6 = -6743;
  if ((a3 & 1) != 0)
  {
    switch(a2)
    {
      case 1LL:
LABEL_6:
        int v6 = 0;
        unint64_t result = *(unsigned __int8 *)a1;
        if (a4) {
          goto LABEL_16;
        }
        return result;
      case 2LL:
        int v6 = 0;
        unint64_t result = __rev16(*(unsigned __int16 *)a1);
        if (a4) {
          goto LABEL_16;
        }
        return result;
      case 4LL:
        int v6 = 0;
        unint64_t result = bswap32(*a1);
        goto LABEL_15;
      case 8LL:
        int v6 = 0;
        unint64_t result = bswap64(*(void *)a1);
        if (!a4) {
          return result;
        }
        goto LABEL_16;
      default:
LABEL_15:
        if (a4) {
LABEL_16:
        }
          *a4 = v6;
        break;
    }
  }

  else
  {
    switch(a2)
    {
      case 1LL:
        goto LABEL_6;
      case 2LL:
        int v6 = 0;
        unint64_t result = *(unsigned __int16 *)a1;
        if (a4) {
          goto LABEL_16;
        }
        break;
      case 4LL:
        int v6 = 0;
        unint64_t result = *a1;
        if (a4) {
          goto LABEL_16;
        }
        break;
      case 8LL:
        int v6 = 0;
        unint64_t result = *(void *)a1;
        if (a4) {
          goto LABEL_16;
        }
        break;
      default:
        goto LABEL_15;
    }
  }

  return result;
}

unsigned __int8 *TLV8CopyCoalesced(unsigned __int8 *a1, unsigned __int8 *a2, int a3, size_t *a4, int *a5)
{
  int v7 = TLV8GetOrCopyCoalesced(a1, a2, a3, (unsigned __int8 **)&__src, &v15, &v14, &v13);
  if (v7)
  {
    int64_t v8 = 0LL;
  }

  else
  {
    int64_t v8 = v14;
    size_t v9 = v15;
    if (v14)
    {
LABEL_8:
      int v7 = 0;
      *a4 = v9;
      goto LABEL_9;
    }

    if (v15 <= 1) {
      size_t v10 = 1LL;
    }
    else {
      size_t v10 = v15;
    }
    int v11 = (unsigned __int8 *)malloc(v10);
    int64_t v8 = v11;
    if (v11)
    {
      memcpy(v11, __src, v9);
      goto LABEL_8;
    }

    int v7 = -6728;
  }

uint64_t TLV8GetOrCopyCoalesced( unsigned __int8 *a1, unsigned __int8 *a2, int a3, unsigned __int8 **a4, size_t *a5, unsigned __int8 **a6, unsigned __int8 **a7)
{
  do
  {
    if (a1 == a2) {
      return 4294960569LL;
    }
    if (a1 >= a2) {
      return 4294960591LL;
    }
    size_t v9 = a1 + 2;
    size_t v10 = a1[1];
    int v11 = &a1[v10 + 2];
    if (v11 > a2) {
      return 4294960546LL;
    }
    int v12 = *a1;
    a1 += v10 + 2;
  }

  while (v12 != a3);
  int v13 = 0LL;
  while (2)
  {
    int v14 = v13;
    size_t v15 = v9;
    size_t v16 = v10;
    while (2)
    {
      size_t v17 = v16;
      unsigned int v18 = v15;
      unsigned int v19 = v11;
      do
      {
        if (a2 <= v19
          || (unint64_t)(a2 - v19) < 2
          || (v15 = v19 + 2, size_t v16 = v19[1], v11 = &v19[v16 + 2], v11 > a2)
          || *v19 != a3)
        {
          *a4 = v18;
          *a5 = v17;
          *a6 = v14;
          uint64_t result = 0LL;
          if (a7) {
            *a7 = v19;
          }
          return result;
        }

        v19 += v16 + 2;
      }

      while (!(_DWORD)v16);
      if (!v17) {
        continue;
      }
      break;
    }

    size_t v22 = a4;
    unsigned int v23 = a5;
    unint64_t v24 = a6;
    unint64_t v25 = a7;
    size_t v10 = v17 + v16;
    unsigned int v20 = (unsigned __int8 *)malloc(v17 + v16);
    if (v20)
    {
      size_t v9 = v20;
      memcpy(v20, v18, v17);
      memcpy(&v9[v17], v15, v16);
      int v13 = v9;
      a6 = v24;
      a7 = v25;
      a4 = v22;
      a5 = v23;
      if (v14)
      {
        free(v14);
        a4 = v22;
        a5 = v23;
        a6 = v24;
        a7 = v25;
        int v13 = v9;
      }

      continue;
    }

    break;
  }

  if (v14) {
    free(v14);
  }
  return 4294960568LL;
}

void *TLV8BufferInit(void *result, uint64_t a2)
{
  *uint64_t result = result + 4;
  result[1] = 0LL;
  result[2] = a2;
  result[3] = 0LL;
  return result;
}

void TLV8BufferFree(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 24) = 0LL;
  }

uint64_t TLV8BufferAppend(uint64_t a1, char a2, char *__s, size_t a4)
{
  size_t v4 = a4;
  timespec v5 = __s;
  if (a4 == -1LL) {
    size_t v4 = strlen(__s);
  }
  if (v4 >= 0x100)
  {
    unint64_t v9 = v4 / 0xFF;
    if (v4 % 0xFF) {
      ++v9;
    }
    uint64_t v8 = 2 * v9;
  }

  else
  {
    uint64_t v8 = 2LL;
  }

  size_t v10 = *(void *)(a1 + 8);
  size_t v11 = v8 + v4 + v10;
  if (v11 > *(void *)(a1 + 16)) {
    return 4294960553LL;
  }
  if (v11 < v10) {
    return 4294960545LL;
  }
  if (v11 > 0x12C)
  {
    int v13 = (char *)malloc(v11);
    if (!v13) {
      return 4294960568LL;
    }
    int v14 = v13;
    size_t v15 = *(void **)(a1 + 24);
    if (v15)
    {
      memcpy(v13, *(const void **)(a1 + 24), v10);
      free(v15);
      size_t v10 = *(void *)(a1 + 8);
    }

    else if (v10)
    {
      memcpy(v13, (const void *)(a1 + 32), v10);
    }

    *(void *)a1 = v14;
    *(void *)(a1 + 24) = v14;
    int v12 = &v14[v10];
  }

  else
  {
    int v12 = (char *)(a1 + v10 + 32);
  }

  size_t v16 = &v5[v4];
  do
  {
    else {
      size_t v17 = v16 - v5;
    }
    *int v12 = a2;
    v12[1] = v17;
    if (v17) {
      memcpy(v12 + 2, v5, v17);
    }
    v5 += v17;
    v12 += v17 + 2;
  }

  while (v5 != v16);
  uint64_t result = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = &v12[-*(void *)a1];
  return result;
}

uint64_t TLV8BufferAppendSInt64(uint64_t a1, char a2, uint64_t a3)
{
  v5[1] = *MEMORY[0x1895F89C0];
  if (a3 == (char)a3)
  {
    LOBYTE(v5[0]) = a3;
    size_t v3 = 1LL;
  }

  else
  {
    v5[0] = a3;
    size_t v3 = 8LL;
  }

  return TLV8BufferAppend(a1, a2, (char *)v5, v3);
}

uint64_t TLV8BufferAppendUInt64(uint64_t a1, char a2, unint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (a3 > 0xFF)
  {
    if (a3 >> 16)
    {
      int v5 = a3;
      if (HIDWORD(a3))
      {
        char v6 = BYTE4(a3);
        char v7 = BYTE5(a3);
        char v8 = BYTE6(a3);
        char v9 = HIBYTE(a3);
        size_t v3 = 8LL;
      }

      else
      {
        size_t v3 = 4LL;
      }
    }

    else
    {
      LOWORD(v5) = a3;
      size_t v3 = 2LL;
    }
  }

  else
  {
    LOBYTE(v5) = a3;
    size_t v3 = 1LL;
  }

  return TLV8BufferAppend(a1, a2, (char *)&v5, v3);
}

uint64_t TLV8BufferDetach(uint64_t a1, void *a2, size_t *a3)
{
  size_t v6 = *(void *)(a1 + 8);
  char v7 = *(void **)(a1 + 24);
  if (v7) {
    goto LABEL_8;
  }
  if (v6 <= 1) {
    size_t v8 = 1LL;
  }
  else {
    size_t v8 = *(void *)(a1 + 8);
  }
  char v9 = malloc(v8);
  if (v9)
  {
    char v7 = v9;
    if (v6) {
      memcpy(v9, *(const void **)a1, v6);
    }
LABEL_8:
    uint64_t result = 0LL;
    *(void *)a1 = a1 + 32;
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a1 + 24) = 0LL;
    *a2 = v7;
    *a3 = v6;
    return result;
  }

  return 4294960568LL;
}

uint64_t URLDecodeEx(char *__s, int64_t a2, _BYTE *a3, uint64_t a4, void *a5, _DWORD *a6)
{
  uint64_t v10 = __s;
  if (a2 == -1) {
    a2 = strlen(__s);
  }
  if (a2 < 1)
  {
    uint64_t result = 0LL;
    int v11 = 0;
    int v13 = a3;
    goto LABEL_27;
  }

  int v11 = 0;
  int v12 = &v10[a2];
  int v13 = a3;
  while (1)
  {
    int v14 = *v10;
    if (v14 != 43) {
      break;
    }
    ++v11;
    LOBYTE(v14) = 32;
LABEL_12:
    ++v10;
    if (!a3) {
      goto LABEL_24;
    }
LABEL_22:
    if (v13 >= &a3[a4])
    {
      uint64_t result = 4294960545LL;
      goto LABEL_27;
    }

    _BYTE *v13 = v14;
LABEL_24:
    ++v13;
    if (v10 >= v12)
    {
      uint64_t result = 0LL;
      goto LABEL_27;
    }
  }

  if (v14 != 37) {
    goto LABEL_12;
  }
  if (v12 - (v10 + 1) >= 2)
  {
    int v15 = v10[1];
    char v16 = v15 - 48;
    if ((v15 - 48) >= 0xA)
    {
      if ((v15 - 97) > 5)
      {
        char v16 = v15 - 55;
      }

      else
      {
        char v16 = v15 - 87;
      }
    }

    int v17 = v10[2];
    char v18 = v17 - 48;
    if ((v17 - 48) >= 0xA)
    {
      if ((v17 - 97) > 5)
      {
        if ((v17 - 65) > 5)
        {
LABEL_32:
          uint64_t result = 4294960554LL;
          goto LABEL_27;
        }

        char v18 = v17 - 55;
      }

      else
      {
        char v18 = v17 - 87;
      }
    }

    v10 += 3;
    LOBYTE(v14) = v18 | (16 * v16);
    ++v11;
    if (!a3) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }

  uint64_t result = 4294960546LL;
LABEL_27:
  if (a5) {
    *a5 = v13 - a3;
  }
  if (a6) {
    *a6 = v11;
  }
  return result;
}

uint64_t URLDecodeCopy(char *__s, size_t a2, void *a3, uint64_t *a4)
{
  size_t v6 = a2;
  if (a2 == -1LL) {
    size_t v6 = strlen(__s);
  }
  uint64_t v8 = URLDecodeEx(__s, v6, 0LL, 0LL, &v16, 0LL);
  if ((_DWORD)v8) {
    return v8;
  }
  uint64_t v9 = v16;
  uint64_t v10 = malloc(v16 + 1);
  if (!v10) {
    return 4294960568LL;
  }
  int v11 = v10;
  uint64_t v12 = URLDecodeEx(__s, v6, v10, v9, &v16, 0LL);
  if ((_DWORD)v12)
  {
    uint64_t v14 = v12;
    free(v11);
  }

  else
  {
    uint64_t v13 = v16;
    *((_BYTE *)v11 + v16) = 0;
    *a3 = v11;
    uint64_t v14 = 0LL;
    if (a4) {
      *a4 = v13;
    }
  }

  return v14;
}

uint64_t URLParseComponents(char *__s, char *a2, char **a3, char **a4)
{
  size_t v6 = __s;
  if (!a2) {
    a2 = &__s[strlen(__s)];
  }
  if (a2 <= v6)
  {
    uint64_t v10 = 0LL;
    int v11 = 0LL;
    uint64_t v12 = v6;
  }

  else
  {
    uint64_t v7 = 0LL;
    do
    {
      unsigned int v8 = v6[v7];
      if (v8 <= 0x3F && ((1LL << v8) & 0x8400800800000000LL) != 0)
      {
        uint64_t v13 = &v6[v7];
        goto LABEL_13;
      }

      ++v7;
    }

    while (a2 - v6 != v7);
    uint64_t v13 = a2;
LABEL_13:
    BOOL v14 = v8 == 58;
    if (v8 == 58) {
      uint64_t v12 = v13 + 1;
    }
    else {
      uint64_t v12 = v6;
    }
    if (v14) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = 0LL;
    }
    if (v14) {
      int v11 = v13;
    }
    else {
      int v11 = 0LL;
    }
    if (v14) {
      size_t v6 = v13 + 1;
    }
  }

  int v15 = (char *)(a2 - v12);
  if (a2 - v12 >= 2 && *v6 == 47 && v6[1] == 47)
  {
    uint64_t v16 = v6 + 2;
    if (v6 + 2 >= a2)
    {
      unint64_t v24 = 0LL;
      unint64_t v25 = 0LL;
      int v26 = 0LL;
      int v27 = 0LL;
      size_t v22 = v6 + 2;
      v6 += 2;
    }

    else
    {
      uint64_t v17 = 2LL;
      while (1)
      {
        unsigned int v18 = v6[v17];
        BOOL v19 = v18 > 0x3F;
        unint64_t v20 = (1LL << v18) & 0x8000800800000000LL;
        if (!v19 && v20 != 0) {
          break;
        }
        if (v15 == (char *)++v17)
        {
          uint64_t v17 = (uint64_t)v15;
          break;
        }
      }

      size_t v22 = &v6[v17];
      if (v17 < 3)
      {
LABEL_41:
        unint64_t v24 = 0LL;
        unint64_t v25 = 0LL;
        int v26 = 0LL;
        int v27 = 0LL;
      }

      else
      {
        unint64_t v23 = 2LL;
        while (v6[v23] != 64)
        {
          if (v17 == ++v23) {
            goto LABEL_41;
          }
        }

        unsigned int v47 = &v6[v23];
        if (v23 < 3)
        {
          int v27 = 0LL;
          int v26 = 0LL;
          unint64_t v25 = v6 + 2;
        }

        else
        {
          unint64_t v25 = v6 + 2;
          int v26 = v6 + 2;
          while (1)
          {
            int v48 = *v26++;
            if (v48 == 58) {
              break;
            }
            unint64_t v25 = v26;
            if (v26 >= v47)
            {
              int v27 = 0LL;
              unint64_t v25 = v26;
              int v26 = 0LL;
              goto LABEL_97;
            }
          }

          int v27 = v47;
        }

uint64_t URLGetNextPathSegment(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v3 = *(void *)(a1 + 112);
  unint64_t v4 = *(void *)(a1 + 120);
  if (v3 >= v4 || *(_BYTE *)v3 == 47) {
    return 4294960569LL;
  }
  uint64_t v5 = 0LL;
  size_t v6 = *(_BYTE **)(a1 + 120);
  while (~v3 + v4 != v5)
  {
    int v7 = *(unsigned __int8 *)(v3 + v5++ + 1);
    if (v7 == 47)
    {
      size_t v6 = (_BYTE *)(v3 + v5);
      break;
    }
  }

  if (v6 == (_BYTE *)v3) {
    return 4294960569LL;
  }
  uint64_t v8 = 0LL;
  *a2 = v3;
  *a3 = &v6[-v3];
  else {
    uint64_t v9 = v6 + 1;
  }
  *(void *)(a1 + 112) = v9;
  return v8;
}

uint64_t URLGetOrCopyNextVariable( unint64_t a1, _BYTE *a2, char **a3, size_t *a4, void *a5, void *a6, size_t *a7, void *a8, void *a9)
{
  uint64_t v30 = 0LL;
  int v27 = 0LL;
  uint64_t v15 = URLGetNextVariable(a1, a2, (unint64_t *)&v32, &v31, &v29, &v28, a9);
  if ((_DWORD)v15) {
    return v15;
  }
  size_t v17 = v31;
  uint64_t v16 = v32;
  uint64_t v18 = URLDecodeEx(v32, v31, 0LL, 0LL, 0LL, &v26);
  if ((_DWORD)v18) {
    goto LABEL_17;
  }
  if (v26 < 1)
  {
    unint64_t v20 = 0LL;
    if (!a8) {
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v19 = URLDecodeCopy(v16, v17, &v30, (uint64_t *)&v31);
    unint64_t v20 = v30;
    if ((_DWORD)v19) {
      goto LABEL_15;
    }
    int v32 = (char *)v30;
    uint64_t v16 = (char *)v30;
    if (!a8)
    {
LABEL_6:
      uint64_t v21 = 0LL;
      goto LABEL_7;
    }
  }

  unint64_t v25 = a7;
  size_t v22 = v28;
  unint64_t v23 = v29;
  uint64_t v19 = URLDecodeEx(v29, v28, 0LL, 0LL, 0LL, &v26);
  if ((_DWORD)v19)
  {
LABEL_15:
    uint64_t v18 = v19;
    if (v20) {
      free(v20);
    }
    goto LABEL_17;
  }

  if (v26 < 1)
  {
    uint64_t v21 = 0LL;
    a7 = v25;
  }

  else
  {
    uint64_t v19 = URLDecodeCopy(v23, v22, &v27, (uint64_t *)&v28);
    a7 = v25;
    if ((_DWORD)v19) {
      goto LABEL_15;
    }
    uint64_t v21 = v27;
    int v29 = (char *)v27;
  }

uint64_t URLGetNextVariable( unint64_t a1, _BYTE *a2, unint64_t *a3, void *a4, void *a5, void *a6, void *a7)
{
  int v7 = 0LL;
  BOOL v8 = 1;
  while (1)
  {
    int v9 = v7[a1];
    if (v9 == 38 || v9 == 61) {
      break;
    }
    BOOL v8 = &(++v7)[a1] < a2;
    if (&a2[-a1] == v7)
    {
      uint64_t v10 = a2;
      goto LABEL_8;
    }
  }

  uint64_t v10 = &v7[a1];
LABEL_8:
  int v11 = &v10[v8];
  if (v9 == 61)
  {
    if (v11 >= a2)
    {
      uint64_t v12 = 0LL;
      uint64_t v13 = v11;
    }

    else
    {
      uint64_t v12 = 1LL;
      uint64_t v13 = v11;
      while (*v13 != 38)
      {
        if (++v13 >= a2)
        {
          uint64_t v12 = 0LL;
          uint64_t v13 = a2;
          break;
        }
      }
    }

    BOOL v14 = &v13[v12];
  }

  else
  {
    uint64_t v13 = 0LL;
    BOOL v14 = &v10[v8];
    int v11 = 0LL;
  }

  uint64_t v15 = 0LL;
  *a3 = a1;
  *a4 = &v10[-a1];
  *a5 = v11;
  *a6 = v13 - v11;
  *a7 = v14;
  return v15;
}

uint64_t URLGetOrCopyVariable( unint64_t a1, _BYTE *a2, unsigned __int8 *a3, void *a4, size_t *a5, char **a6, void *a7)
{
  int v26 = 0LL;
  unint64_t v27 = a1;
  unint64_t v24 = 0LL;
  size_t v25 = 0LL;
  unint64_t v23 = 0LL;
  while (1)
  {
    uint64_t result = URLGetOrCopyNextVariable(v27, a2, &v26, &v25, &v24, &v23, &v22, 0LL, &v27);
    if ((_DWORD)result) {
      return result;
    }
    BOOL v14 = v26;
    uint64_t v15 = a3;
    size_t v16 = v25;
    while (v16)
    {
      int v17 = *v15;
      if (*v14 != v17)
      {
        int v18 = 1;
        goto LABEL_12;
      }

      ++v15;
      ++v14;
      --v16;
      if (!v17)
      {
        int v18 = 0;
        goto LABEL_12;
      }
    }

    if (a3[v25]) {
      int v18 = -1;
    }
    else {
      int v18 = 0;
    }
LABEL_12:
    if (v24) {
      free(v24);
    }
    if (!v18)
    {
      uint64_t v21 = 0LL;
      if (!a6) {
        goto LABEL_20;
      }
      uint64_t result = URLDecodeEx(v23, v22, 0LL, 0LL, 0LL, &v20);
      if ((_DWORD)result) {
        return result;
      }
      if (v20 >= 1)
      {
        uint64_t result = URLDecodeCopy(v23, v22, &v21, (uint64_t *)&v22);
        if ((_DWORD)result) {
          return result;
        }
        uint64_t v19 = v21;
        unint64_t v23 = v21;
      }

      else
      {
LABEL_20:
        uint64_t v19 = 0LL;
      }

      if (a4) {
        *a4 = v23;
      }
      if (a5) {
        *a5 = v22;
      }
      if (a6) {
        *a6 = v19;
      }
      uint64_t result = 0LL;
      if (a7) {
        *a7 = v27;
      }
      return result;
    }
  }

uint64_t URLGetVariable( unint64_t a1, _BYTE *a2, unsigned __int8 *a3, void *a4, void *a5, void *a6)
{
  int v20 = 0LL;
  unint64_t v21 = a1;
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v17 = 0LL;
LABEL_2:
  while (2)
  {
    uint64_t result = URLGetNextVariable(v21, a2, (unint64_t *)&v20, &v19, &v18, &v17, &v21);
    if (!(_DWORD)result)
    {
      uint64_t v12 = v20;
      uint64_t v13 = a3;
      uint64_t v14 = v19;
      while (v14)
      {
        int v15 = *v13;
        if (*v12 != v15) {
          goto LABEL_2;
        }
        ++v13;
        ++v12;
        --v14;
        if (!v15) {
          goto LABEL_14;
        }
      }

      if (a3[v19]) {
        int v16 = -1;
      }
      else {
        int v16 = 0;
      }
      if (v16) {
        continue;
      }
LABEL_14:
      if (a4) {
        *a4 = v18;
      }
      if (a5) {
        *a5 = v17;
      }
      uint64_t result = 0LL;
      if (a6) {
        *a6 = v21;
      }
    }

    return result;
  }

uint64_t UUIDGet(_BYTE *a1)
{
  uint64_t result = RandomBytes(a1, 0x10uLL);
  a1[6] = a1[6] & 0xF | 0x40;
  a1[8] = a1[8] & 0x3F | 0x80;
  return result;
}

uint64_t UUIDGetPerSystemHost(const char *a1, size_t a2, uuid_t a3)
{
  v13.tv_seCC_SHA1_CTX c = 0LL;
  v13.tv_nseCC_SHA1_CTX c = 0LL;
  int v6 = gethostuuid(a3, &v13);
  if (v6)
  {
    if (gLogCategory_CUMisc <= 90)
    {
      char v11 = v6;
      if (gLogCategory_CUMisc != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_CUMisc, 0x5Au)) {
        LogPrintF( (uint64_t)&gLogCategory_CUMisc,  (uint64_t)"void UUIDGetPerSystemHost(const void *, size_t, void *)",  0x5Au,  (uint64_t)"### gethostuuid failed for per-system host UUID: %#m\n",  v7,  v8,  v9,  v10,  v11);
      }
    }

    RandomBytes(a3, 0x10uLL);
    a3[6] = a3[6] & 0xF | 0x40;
    a3[8] = a3[8] & 0x3F | 0x80;
  }

  if (a2 == -1LL) {
    a2 = strlen(a1);
  }
  uint64_t result = CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  (uint64_t)a3,  16LL,  "PerSystem",  9uLL,  (uint64_t)a1,  a2,  0x10uLL,  (uint64_t)a3);
  a3[6] = a3[6] & 0xF | 0x40;
  a3[8] = a3[8] & 0x3F | 0x80;
  return result;
}

uint64_t UUIDGetPerUserHost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  memset(bytes, 0, sizeof(bytes));
  v14.tv_seCC_SHA1_CTX c = 0LL;
  v14.tv_nseCC_SHA1_CTX c = 0LL;
  int v6 = gethostuuid(bytes, &v14);
  if (v6)
  {
    if (gLogCategory_CUMisc <= 90)
    {
      char v11 = v6;
      if (gLogCategory_CUMisc != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_CUMisc, 0x5Au)) {
        LogPrintF( (uint64_t)&gLogCategory_CUMisc,  (uint64_t)"void UUIDGetPerUserHost(const void *, size_t, void *)",  0x5Au,  (uint64_t)"### gethostuuid failed for per-user host UUID: %#m\n",  v7,  v8,  v9,  v10,  v11);
      }
    }

    RandomBytes(bytes, 0x10uLL);
    UInt8 bytes[6] = bytes[6] & 0xF | 0x40;
    bytes[8] = bytes[8] & 0x3F | 0x80;
  }

  uid_t v12 = getuid();
  int v16 = 0;
  char v17 = HIBYTE(v12);
  char v18 = BYTE2(v12);
  char v19 = BYTE1(v12);
  char v20 = v12;
  uint64_t result = CryptoHKDF( (uint64_t)_kCryptoHashDescriptor_SHA512,  (uint64_t)bytes,  24LL,  "PerUser",  7uLL,  a1,  a2,  0x10uLL,  a3);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a3 + 6) & 0xF | 0x40;
  *(_BYTE *)(a3 + _Block_object_dispose(va, 8) = *(_BYTE *)(a3 + 8) & 0x3F | 0x80;
  return result;
}

uint64_t _WiFiManagerGetTypeID()
{
  uint64_t result = _CFRuntimeRegisterClass();
  gWiFiManagerCFTypeID TypeID = result;
  return result;
}

pthread_mutex_t *_WiFiManagerFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 88);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  }

  int v3 = *(_DWORD *)(a1 + 104);
  if ((v3 & 0x80000000) == 0)
  {
    if (close(v3) && *__error()) {
      __error();
    }
    *(_DWORD *)(a1 + 104) = -1;
  }

  unint64_t v4 = *(const void **)(a1 + 176);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 176) = 0LL;
  }

  uint64_t v5 = *(const void **)(a1 + 184);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 184) = 0LL;
  }

  if (*(void *)(a1 + 152))
  {
    Apple80211Close();
    *(void *)(a1 + 152) = 0LL;
  }

  int v6 = *(const void **)(a1 + 168);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  }

  uint64_t result = *(pthread_mutex_t **)(a1 + 80);
  if (result)
  {
    uint64_t result = (pthread_mutex_t *)pthread_mutex_destroy(result);
    *(void *)(a1 + 80) = 0LL;
  }

  return result;
}

uint64_t WiFiManagerCreate(void *a1)
{
  if (gWiFiManagerInitOnce != -1) {
    dispatch_once_f(&gWiFiManagerInitOnce, 0LL, (dispatch_function_t)_WiFiManagerGetTypeID);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294960568LL;
  }
  int v3 = (void *)Instance;
  *(_OWORD *)(Instance + 16) = 0u;
  uint64_t v4 = Instance + 16;
  *(_OWORD *)(Instance + 160) = 0u;
  *(_OWORD *)(Instance + 176) = 0u;
  *(_OWORD *)(Instance + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(Instance + 144) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 112) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(Instance + 104) = -1;
  uint64_t v5 = pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0LL);
  if ((_DWORD)v5)
  {
    CFRelease(v3);
  }

  else
  {
    v3[10] = v4;
    *a1 = v3;
  }

  return v5;
}

uint64_t WiFiManagerDoApple80211( uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  size_t v25 = 0LL;
  if (gLogCategory_WiFiManagerCore <= 30
    && (gLogCategory_WiFiManagerCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_WiFiManagerCore, 0x1Eu)))
  {
    timespec v13 = "get";
    if (!a2) {
      timespec v13 = "set";
    }
    LogPrintF( (uint64_t)&gLogCategory_WiFiManagerCore,  (uint64_t)"OSStatus WiFiManagerDoApple80211(CUWiFiManagerRef, int, int, void *, size_t)",  0x1Eu,  (uint64_t)"WiFiManagerDoApple80211: %s, ioc 0x%X, len %zu",  a5,  a6,  a7,  a8,  (char)v13);
  }

  if (a1)
  {
    timespec v14 = 0LL;
  }

  else
  {
    uint64_t v22 = WiFiManagerCreate(&v25);
    timespec v14 = v25;
    a1 = (uint64_t)v25;
    if ((_DWORD)v22) {
      goto LABEL_38;
    }
  }

  uint64_t v15 = _WiFiManagerEnsureInitialized(a1);
  if ((_DWORD)v15)
  {
    uint64_t v22 = v15;
    goto LABEL_38;
  }

  if (!*(void *)(a1 + 152) && (uint64_t v20 = Apple80211Open(), (_DWORD)v20))
  {
    uint64_t v22 = v20;
    if (gLogCategory_WiFiManagerCore <= 60
      && (gLogCategory_WiFiManagerCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_WiFiManagerCore, 0x3Cu)))
    {
      LogPrintF( (uint64_t)&gLogCategory_WiFiManagerCore,  (uint64_t)"OSStatus WiFiManagerDoApple80211(CUWiFiManagerRef, int, int, void *, size_t)",  0x3Cu,  (uint64_t)"### Open failed: %#m",  v16,  v17,  v18,  v19,  v22);
    }
  }

  else
  {
    if (*(_BYTE *)(a1 + 160)) {
      goto LABEL_16;
    }
    if (!*(void *)(a1 + 168))
    {
      if (gLogCategory_WiFiManagerCore <= 60
        && (gLogCategory_WiFiManagerCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_WiFiManagerCore, 0x3Cu)))
      {
        uint64_t v22 = 4294960596LL;
        LogPrintF( (uint64_t)&gLogCategory_WiFiManagerCore,  (uint64_t)"OSStatus WiFiManagerDoApple80211(CUWiFiManagerRef, int, int, void *, size_t)",  0x3Cu,  (uint64_t)"### No ifname: %#m",  v16,  v17,  v18,  v19,  212);
        goto LABEL_38;
      }

      goto LABEL_37;
    }

    uint64_t v21 = Apple80211BindToInterface();
    if (!(_DWORD)v21)
    {
      *(_BYTE *)(a1 + 160) = 1;
LABEL_16:
      *(_DWORD *)(a1 + 12_Block_object_dispose(va, 8) = a3;
      *(_DWORD *)(a1 + 136) = v8;
      *(void *)(a1 + 144) = a4;
      if (a2)
      {
      }

      else if (Apple80211RawSet())
      {
LABEL_18:
        if (*__error())
        {
          uint64_t v22 = *__error();
          goto LABEL_38;
        }

uint64_t _WiFiManagerEnsureInitialized(uint64_t a1)
{
  if (*(void *)(a1 + 184))
  {
    uint64_t v2 = 0LL;
    goto LABEL_31;
  }

  uint64_t v3 = WiFiManagerClientCreate();
  if (!v3)
  {
    uint64_t v2 = 4294960596LL;
    goto LABEL_31;
  }

  uint64_t v4 = (const void *)v3;
  uint64_t v5 = (const __CFArray *)WiFiManagerClientCopyInterfaces();
  uint64_t v10 = v5;
  if (v5)
  {
    CFIndex Count = CFArrayGetCount(v5);
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0LL; v12 != i; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v10, i);
        if (*(void *)(a1 + 88))
        {
          InterfaceName = (const void *)WiFiDeviceClientGetInterfaceName();
          if (InterfaceName && CFEqual(InterfaceName, *(CFTypeRef *)(a1 + 88)))
          {
LABEL_14:
            CFRetain(ValueAtIndex);
            *(void *)(a1 + 184) = ValueAtIndex;
            *(_BYTE *)(a1 + 96) = WiFiDeviceClientIsInterfaceAWDL();
            break;
          }
        }

        else if (!WiFiDeviceClientGetInterfaceRoleIndex())
        {
          goto LABEL_14;
        }
      }
    }
  }

  if (!*(void *)(a1 + 184))
  {
    if (gLogCategory_WiFiManagerCore <= 30
      && (gLogCategory_WiFiManagerCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_WiFiManagerCore, 0x1Eu)))
    {
      unint64_t v23 = *(const __CFString **)(a1 + 88);
      if (!v23) {
        unint64_t v23 = @"*";
      }
      LogPrintF( (uint64_t)&gLogCategory_WiFiManagerCore,  (uint64_t)"OSStatus _WiFiManagerEnsureInitialized(CUWiFiManagerRef)",  0x1Eu,  (uint64_t)"### Init interface not found (%@)\n",  v6,  v7,  v8,  v9,  (char)v23);
    }

    uint64_t v2 = 4294960569LL;
    goto LABEL_27;
  }

  *(void *)(a1 + 176) = v4;
  int v16 = socket(2, 2, 0);
  *(_DWORD *)(a1 + 104) = v16;
  if ((v16 & 0x80000000) == 0) {
    goto LABEL_17;
  }
  if (*__error())
  {
    uint64_t v2 = *__error();
    if (!(_DWORD)v2)
    {
LABEL_17:
      uint64_t v17 = (const __CFString *)WiFiDeviceClientGetInterfaceName();
      uint64_t v4 = v17;
      if (v17)
      {
        CFStringGetCString(v17, (char *)(a1 + 112), 16LL, 0x8000100u);
        *(void *)(a1 + 16_Block_object_dispose(va, 8) = CFRetain(v4);
        if (gLogCategory_WiFiManagerCore <= 30
          && (gLogCategory_WiFiManagerCore != -1
           || _LogCategory_Initialize((uint64_t)&gLogCategory_WiFiManagerCore, 0x1Eu)))
        {
          LogPrintF( (uint64_t)&gLogCategory_WiFiManagerCore,  (uint64_t)"OSStatus _WiFiManagerEnsureInitialized(CUWiFiManagerRef)",  0x1Eu,  (uint64_t)"Initialized for %@ (%.6a)\n",  v18,  v19,  v20,  v21,  (char)v4);
        }

        uint64_t v4 = 0LL;
        uint64_t v2 = 0LL;
      }

      else
      {
        uint64_t v2 = 4294960552LL;
      }

      goto LABEL_27;
    }

    uint64_t v4 = 0LL;
  }

  else
  {
    uint64_t v4 = 0LL;
    uint64_t v2 = 4294960596LL;
  }

unint64_t WiFiManagerGetInt64(uint64_t a1, const void *a2, uint64_t a3, int *a4)
{
  uint64_t v6 = a1;
  uint64_t v7 = 0LL;
  int v41 = 0LL;
  if (!a1)
  {
    int v42 = WiFiManagerCreate(&v41);
    uint64_t v7 = v41;
    if (v42) {
      goto LABEL_14;
    }
    uint64_t v6 = (uint64_t)v41;
  }

  int v42 = _WiFiManagerEnsureInitialized(v6);
  if (!v42)
  {
    if (CFEqual(a2, @"channel"))
    {
      if (*(_BYTE *)(v6 + 96)) {
        uint64_t v8 = 132LL;
      }
      else {
        uint64_t v8 = 4LL;
      }
      CFNumberRef Int64 = CFNumberCreateInt64(v8);
      if (Int64)
      {
        CFNumberRef v10 = Int64;
        char v11 = (const __CFDictionary *)WiFiDeviceClientCopyProperty();
        CFRelease(v10);
        if (v11)
        {
          Value = (const __CFString *)CFDictionaryGetValue(v11, @"CHANNEL");
          if (Value)
          {
LABEL_10:
            CFRetain(Value);
            int v42 = 0;
            goto LABEL_11;
          }

          int v29 = -6727;
LABEL_63:
          int v42 = v29;
LABEL_11:
          CFRelease(v11);
          if (!v7) {
            goto LABEL_40;
          }
LABEL_39:
          CFRelease(v7);
          goto LABEL_40;
        }

        goto LABEL_56;
      }

      goto LABEL_60;
    }

    if (CFEqual(a2, @"features"))
    {
      LOBYTE(valuePtr[0]) = 12;
      CFNumberRef v13 = CFNumberCreate(0LL, kCFNumberSInt8Type, valuePtr);
      if (!v13)
      {
LABEL_60:
        Value = 0LL;
        goto LABEL_61;
      }

      CFNumberRef v14 = v13;
      Value = (const __CFString *)WiFiDeviceClientCopyProperty();
      CFRelease(v14);
      if (!Value)
      {
LABEL_57:
        int v25 = -6735;
        goto LABEL_58;
      }

      CFIndex Count = CFArrayGetCount((CFArrayRef)Value);
      if (Count < 1)
      {
        uint64_t v17 = 0LL;
      }

      else
      {
        CFIndex v16 = Count;
        uint64_t v17 = 0LL;
        for (CFIndex i = 0LL; i != v16; ++i)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)Value, i);
          if (CFGetInt64(ValueAtIndex, &v42) == 51 && v42 == 0) {
            uint64_t v17 = 1LL;
          }
        }
      }

      CFRelease(Value);
      Value = (const __CFString *)CFNumberCreateInt64(v17);
      if (!Value)
      {
LABEL_61:
        int v25 = -6728;
LABEL_58:
        int v42 = v25;
        if (v7) {
          goto LABEL_39;
        }
        goto LABEL_40;
      }

uint64_t WiFiManagerSetProperty(uint64_t a1, CFTypeRef cf1, const __CFString *a3, const __CFString *a4)
{
  if (CFEqual(cf1, @"interfaceName"))
  {
    if (a4 && (CFTypeID v8 = CFGetTypeID(a4), v8 == CFStringGetTypeID()))
    {
      uint64_t v9 = (char *)(a1 + 97);
      if (!a3)
      {
        char v11 = 0;
        *(_WORD *)(a1 + 101) = 0;
        *(_DWORD *)uint64_t v9 = 0;
LABEL_11:
        *(_BYTE *)(a1 + 103) = v11;
        CFIndex v12 = *(const void **)(a1 + 88);
        CFRetain(a4);
        *(void *)(a1 + 8_Block_object_dispose(va, 8) = a4;
        if (v12) {
          CFRelease(v12);
        }
        return 0LL;
      }

      CFGetHardwareAddress(a3, v9, 6uLL, (int *)&v13);
      uint64_t result = v13;
      if (!v13)
      {
        char v11 = 1;
        goto LABEL_11;
      }
    }

    else
    {
      return 4294960540LL;
    }
  }

  else if (CFEqual(cf1, @"powered"))
  {
    CFGetInt64(a4, 0LL);
    uint64_t result = WiFiDeviceClientSetPower();
    if (!(_DWORD)result) {
      return 0LL;
    }
  }

  else
  {
    return 4294960561LL;
  }

  return result;
}

uint64_t AWDLTrafficRegister(uint64_t a1, int a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  CFTypeRef cf = 0LL;
  uint64_t v6 = WiFiManagerCreate(&cf);
  CFTypeRef v7 = cf;
  if (!(_DWORD)v6)
  {
    WiFiManagerSetProperty((uint64_t)cf, @"interfaceName", 0LL, @"awdl0");
    memset(&v13[1], 0, 48);
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    int v22 = 0;
    v13[0] = 1;
    if (a1)
    {
      v13[1] = *(_DWORD *)a1;
      LOWORD(v13[2]) = *(_WORD *)(a1 + 4);
    }

    v13[3] = 26;
    qmemcpy(&v13[4], "airplay-connectivity-check", 26);
    DWORD1(v21) = a2;
    if (a2) {
      DWORD2(v21) = 1;
    }
    if (a3) {
      DWORD2(v21) = 2;
    }
    uint64_t v6 = WiFiManagerDoApple80211((uint64_t)v7, 0, 164, (uint64_t)v13, 184LL, v8, v9, v10);
  }

  if (v7) {
    CFRelease(v7);
  }
  return v6;
}

uint64_t WiFiJoinNetworkEx(const __CFDictionary *a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, a1);
  uint64_t v8 = _Block_copy(v5);

  id v9 = v8;
  CFDictionarySetValue(MutableCopy, @"joinExCompletion", v9);
  CFRelease(v9);
  CFDictionarySetValue(MutableCopy, @"queue", v6);
  uint64_t v10 = WiFiJoinNetwork(MutableCopy, v6, 0LL, 0LL);

  CFRelease(MutableCopy);
  return v10;
}

uint64_t WiFiJoinNetwork(const void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7 = a2;
  *(void *)__int128 v21 = a4;
  *(void *)uuid_t bytes = a3;
  logger_13856();
  uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 v20 = 0;
    _os_log_impl(&dword_186A3B000, v8, OS_LOG_TYPE_DEFAULT, "WiFiJoinNetwork start", v20, 2u);
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (!Mutable)
  {
    uint64_t v18 = 4294960568LL;
    goto LABEL_28;
  }

  uint64_t v10 = Mutable;
  CFDictionarySetValue(Mutable, @"options", a1);
  if (!CFDictionaryGetValue((CFDictionaryRef)a1, @"platformNetwork"))
  {
    uint64_t v18 = 4294960591LL;
    goto LABEL_33;
  }

  if (CFDictionaryGetInt64((const __CFDictionary *)a1, @"directed", 0LL)) {
    WiFiNetworkSetDirectedState();
  }
  if (getkWiFiNetworkShareableEAPConfig() && CFDictionaryGetValue((CFDictionaryRef)a1, @"eapConfig"))
  {
    getkWiFiNetworkShareableEAPConfig();
    WiFiNetworkSetProperty();
  }

  if (CFDictionaryGetValue((CFDictionaryRef)a1, @"eapTrustExceptions"))
  {
    getkWiFiNetworkShareableEAPTrustExceptions();
    WiFiNetworkSetProperty();
  }

  CFTypeID TypeID = CFStringGetTypeID();
  if (CFDictionaryGetTypedValue((const __CFDictionary *)a1, @"password", TypeID, 0LL)
    && !WiFiNetworkSetPassword())
  {
    goto LABEL_30;
  }

  Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"persistent");
  if (Value) {
    CFDictionarySetValue(v10, @"persistent", Value);
  }
  uint64_t v13 = WiFiManagerClientCreate();
  if (!v13)
  {
LABEL_30:
    uint64_t v18 = 4294960596LL;
LABEL_33:
    __int128 v16 = v10;
    goto LABEL_27;
  }

  __int128 v14 = (const void *)v13;
  CFRunLoopGetMain();
  WiFiManagerClientScheduleWithRunLoop();
  CFDictionarySetValue(v10, @"platformManager", v14);
  __int128 v15 = (const __CFArray *)WiFiManagerClientCopyDevices();
  __int128 v16 = v15;
  if (!v15 || CFArrayGetCount(v15) < 1)
  {
    uint64_t v18 = 4294960569LL;
    goto LABEL_24;
  }

  ValueAtIndex = CFArrayGetValueAtIndex(v16, 0LL);
  CFDictionarySetValue(v10, @"platformDevice", ValueAtIndex);
  if (v7) {
    CFDictionarySetValue(v10, @"queue", v7);
  }
  if (a3)
  {
    CFDictionarySetData(v10, @"callback", bytes, 8LL);
    CFDictionarySetData(v10, @"context", v21, 8LL);
  }

  uint64_t v18 = WiFiDeviceClientAssociateAsync();
  if ((_DWORD)v18)
  {
LABEL_24:
    CFRelease(v10);
    CFRunLoopGetMain();
    WiFiManagerClientUnscheduleFromRunLoop();
    CFRelease(v14);
    if (!v16) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }

  CFRelease(v14);
LABEL_27:
  CFRelease(v16);
LABEL_28:

  return v18;
}

id logger_13856()
{
  if (sCUOSLogCreateOnce_logger_13913 != -1) {
    dispatch_once(&sCUOSLogCreateOnce_logger_13913, &__block_literal_global_13914);
  }
  return (id)sCUOSLogHandle_logger_13915;
}

uint64_t initValkWiFiNetworkShareableEAPConfig()
{
  if (MobileWiFiLibrary_sOnce != -1) {
    dispatch_once(&MobileWiFiLibrary_sOnce, &__block_literal_global_120);
  }
  int v0 = (uint64_t *)dlsym((void *)MobileWiFiLibrary_sLib, "kWiFiNetworkShareableEAPConfig");
  if (v0)
  {
    uint64_t result = *v0;
    constantValkWiFiNetworkShareableEAPConfig = result;
  }

  else
  {
    uint64_t result = constantValkWiFiNetworkShareableEAPConfig;
  }

  getkWiFiNetworkShareableEAPConfig = kWiFiNetworkShareableEAPConfigFunction;
  return result;
}

uint64_t kWiFiNetworkShareableEAPConfigFunction()
{
  return constantValkWiFiNetworkShareableEAPConfig;
}

uint64_t initValkWiFiNetworkShareableEAPTrustExceptions()
{
  if (MobileWiFiLibrary_sOnce != -1) {
    dispatch_once(&MobileWiFiLibrary_sOnce, &__block_literal_global_120);
  }
  int v0 = (uint64_t *)dlsym((void *)MobileWiFiLibrary_sLib, "kWiFiNetworkShareableEAPTrustExceptions");
  if (v0)
  {
    uint64_t result = *v0;
    constantValkWiFiNetworkShareableEAPTrustExceptions = result;
  }

  else
  {
    uint64_t result = constantValkWiFiNetworkShareableEAPTrustExceptions;
  }

  getkWiFiNetworkShareableEAPTrustExceptions = kWiFiNetworkShareableEAPTrustExceptionsFunction;
  return result;
}

uint64_t kWiFiNetworkShareableEAPTrustExceptionsFunction()
{
  return constantValkWiFiNetworkShareableEAPTrustExceptions;
}

void _WiFiJoinNetworkCB(int a1, uint64_t a2, int a3, int a4, CFDictionaryRef theDict)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  CFDictionaryGetValue(theDict, @"platformManager");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  TypedValue = CFDictionaryGetTypedValue(theDict, @"options", TypeID, 0LL);
  if (a2 && !a4 && CFDictionaryGetInt64(theDict, @"persistent", 0LL))
  {
    if (CFDictionaryGetInt64(TypedValue, @"directed", 0LL)) {
      WiFiNetworkSetDirectedState();
    }
    if (CFDictionaryGetInt64(TypedValue, @"homeNetwork", 0LL))
    {
      WiFiNetworkSetIntProperty();
      WiFiNetworkSetProperty();
    }

    if (CFDictionaryGetInt64(TypedValue, @"forceFix", 0LL)) {
      WiFiNetworkSetProperty();
    }
    WiFiManagerClientAddNetwork();
  }

  uint64_t v10 = CFDictionaryGetValue(theDict, @"queue");
  char v11 = (dispatch_queue_s *)v10;
  if (TypedValue)
  {
    CFDictionaryGetValue(TypedValue, @"joinExCompletion");
    TypedValue = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
    BOOL v12 = v11 != 0LL;
    if (TypedValue && v11)
    {
      if (a2)
      {
        Property = (__CFDictionary *)WiFiNetworkGetProperty();
        if (Property && (__int128 v14 = Property, v15 = CFGetTypeID(Property), v15 == CFDictionaryGetTypeID()))
        {
          CFMutableDictionaryRef Mutable = 0LL;
        }

        else
        {
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
          _WiFiDictionaryAddNetworkAdditionalInfo(Mutable);
          __int128 v14 = Mutable;
        }
      }

      else
      {
        CFMutableDictionaryRef Mutable = 0LL;
        __int128 v14 = 0LL;
      }

      logger_13856();
      __int128 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        NSPrintF();
        __int128 v21 = (void *)objc_claimAutoreleasedReturnValue();
        NSPrintF();
        int v22 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412546;
        *(void *)&uint8_t buf[4] = v21;
        __int16 v32 = 2112;
        uint64_t v33 = v22;
        _os_log_impl( &dword_186A3B000,  v20,  OS_LOG_TYPE_DEFAULT,  "WiFiJoinNetwork completed: info=%@, error=%@",  buf,  0x16u);
      }

      if (v14) {
        CFRetain(v14);
      }
      v25[0] = MEMORY[0x1895F87A8];
      v25[1] = 3221225472LL;
      v25[2] = ___WiFiJoinNetworkCB_block_invoke;
      v25[3] = &unk_189F343E8;
      TypedValue = TypedValue;
      unint64_t v26 = TypedValue;
      unint64_t v27 = v14;
      int v29 = a4;
      size_t v28 = Mutable;
      dispatch_async(v11, v25);

      goto LABEL_33;
    }
  }

  else
  {
    BOOL v12 = v10 != 0;
  }

  logger_13856();
  __int128 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    NSPrintF();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    *(void *)&uint8_t buf[4] = v18;
    _os_log_impl(&dword_186A3B000, v17, OS_LOG_TYPE_DEFAULT, "WiFiJoinNetwork completed: error=%@", buf, 0xCu);
  }

  *(void *)buf = 0LL;
  CFDictionaryGetData(theDict, @"callback", buf, 8uLL, 0LL, 0LL);
  uint64_t v30 = 0LL;
  CFDictionaryGetData(theDict, @"context", (const char *)&v30, 8uLL, 0LL, 0LL);
  if (*(void *)buf) {
    BOOL v19 = v12;
  }
  else {
    BOOL v19 = 0;
  }
  if (v19)
  {
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___WiFiJoinNetworkCB_block_invoke_129;
    block[3] = &__block_descriptor_52_e5_v8__0l;
    int v24 = a4;
    block[4] = *(void *)buf;
    block[5] = v30;
    dispatch_async(v11, block);
  }

void _WiFiDictionaryAddNetworkAdditionalInfo(__CFDictionary *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  Property = (const void *)WiFiNetworkGetProperty();
  if (Property) {
    CFDictionarySetValue(a1, @"cca", Property);
  }
  uint64_t v3 = (const __CFString *)WiFiNetworkGetProperty();
  if (v3)
  {
    __int16 v8 = 0;
    int v7 = 0;
    CFGetHardwareAddress(v3, (char *)&v7, 6uLL, 0LL);
    __int16 v10 = 0;
    *(void *)char __str = 0LL;
    snprintf(__str, 0xAuLL, "%02X:%02X:%02X", v7, BYTE1(v7), BYTE2(v7));
    CFDictionarySetCString(a1, @"oui", __str, -1LL);
  }

  uint64_t v4 = (const void *)WiFiNetworkGetProperty();
  if (v4) {
    CFDictionarySetValue(a1, @"channel", v4);
  }
  if (WiFiNetworkIsEAP() && WiFiNetworkIsSAE())
  {
    id v5 = "SAE-EAP";
  }

  else if (WiFiNetworkIsSAE())
  {
    id v5 = "SAE";
  }

  else if (WiFiNetworkIsEAP() && WiFiNetworkIsWPA())
  {
    id v5 = "WPA-EAP";
  }

  else if (WiFiNetworkIsWPA())
  {
    id v5 = "WPA";
  }

  else if (WiFiNetworkIsEAP())
  {
    id v5 = "EAP";
  }

  else if (WiFiNetworkIsWEP())
  {
    id v5 = "WEP";
  }

  else if (WiFiNetworkIsOpen())
  {
    id v5 = "Open";
  }

  else
  {
    id v5 = "Unknown";
  }

  CFDictionarySetCString(a1, @"securityStr", v5, -1LL);
  id v6 = (const void *)WiFiNetworkGetProperty();
  if (v6) {
    CFDictionarySetValue(a1, @"rssi", v6);
  }
}

void *__MobileWiFiLibrary_block_invoke()
{
  uint64_t result = dlopen("/System/Library/PrivateFrameworks/MobileWiFi.framework/MobileWiFi", 2);
  MobileWiFiLibrary_sLib = (uint64_t)result;
  return result;
}

void __logger_block_invoke_13916()
{
  os_log_t v0 = os_log_create("com.apple.CoreUtils", "WiFiUtils");
  timeval v1 = (void *)sCUOSLogHandle_logger_13915;
  sCUOSLogHandle_logger_13915 = (uint64_t)v0;
}

uint64_t WiFiJoinNetwork_b(const void *a1, void *a2, const void *a3)
{
  id v5 = a2;
  id v6 = _Block_copy(a3);

  uint64_t v7 = WiFiJoinNetwork(a1, v5, (uint64_t)_WiFiJoinNetwork_bCallBack, (uint64_t)v6);
  if ((_DWORD)v7) {

  }
  return v7;
}

void _WiFiJoinNetwork_bCallBack(uint64_t a1, void (**a2)(void, void))
{
}

__CFDictionary *WiFiCopyCurrentNetworkInfo(int *a1)
{
  return WiFiCopyCurrentNetworkInfoEx(0, a1);
}

__CFDictionary *WiFiCopyCurrentNetworkInfoEx(char a1, int *a2)
{
  uint64_t v4 = WiFiManagerClientCreate();
  if (!v4)
  {
    CFMutableDictionaryRef Mutable = 0LL;
    int v11 = -6700;
    if (!a2) {
      return Mutable;
    }
    goto LABEL_10;
  }

  id v5 = (const void *)v4;
  id v6 = (const __CFArray *)WiFiManagerClientCopyDevices();
  if (v6)
  {
    uint64_t v7 = v6;
    if (CFArrayGetCount(v6) < 1)
    {
      CFMutableDictionaryRef Mutable = 0LL;
      int v11 = -6727;
    }

    else
    {
      CFArrayGetValueAtIndex(v7, 0LL);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      if (Mutable)
      {
        id v9 = (const void *)WiFiDeviceClientCopyCurrentNetwork();
        if (v9)
        {
          __int16 v10 = v9;
          _WiFiDictionaryAddNetworkInfo(Mutable, a1, v9);
          CFRelease(v10);
        }

        int v11 = 0;
      }

      else
      {
        int v11 = -6728;
      }
    }

    CFRelease(v5);
  }

  else
  {
    CFMutableDictionaryRef Mutable = 0LL;
    int v11 = -6727;
    uint64_t v7 = (const __CFArray *)v5;
  }

  CFRelease(v7);
  if (a2) {
LABEL_10:
  }
    *a2 = v11;
  return Mutable;
}

void _WiFiDictionaryAddNetworkInfo(__CFDictionary *a1, char a2, const void *a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  Channel = (const void *)WiFiNetworkGetChannel();
  if (Channel) {
    CFDictionarySetValue(a1, @"channel", Channel);
  }
  int DirectedState = WiFiNetworkGetDirectedState();
  __int16 v8 = (const void **)MEMORY[0x189604DE8];
  if (DirectedState) {
    CFDictionarySetValue(a1, @"directed", (const void *)*MEMORY[0x189604DE8]);
  }
  int IsCaptive = WiFiNetworkIsCaptive();
  if (IsCaptive) {
    CFDictionarySetValue(a1, @"captive", *v8);
  }
  int v10 = WiFiNetworkWasCaptive();
  if (v10) {
    CFDictionarySetValue(a1, @"wasCaptive", *v8);
  }
  Property = (const __CFString *)WiFiNetworkGetProperty();
  if (Property && CFGetInt64(Property, 0LL) == 1) {
    CFDictionarySetValue(a1, @"homeNetwork", *v8);
  }
  int IsEAP = WiFiNetworkIsEAP();
  if (IsEAP) {
    CFDictionarySetValue(a1, @"enterprise", *v8);
  }
  int IsOpen = WiFiNetworkIsOpen();
  if (IsOpen) {
    CFDictionarySetValue(a1, @"open", *v8);
  }
  if (IsCaptive || v10 && IsOpen) {
    CFDictionarySetValue(a1, @"likelyCaptive", *v8);
  }
  SSID = (const void *)WiFiNetworkGetSSID();
  if (SSID) {
    CFDictionarySetValue(a1, @"ssid", SSID);
  }
  SSIDCFDataRef Data = (const __CFString *)WiFiNetworkGetSSIDData();
  if (SSIDData) {
    CFDictionarySetValue(a1, @"ssidData", SSIDData);
  }
  unsigned int ShareMode = WiFiNetworkGetShareMode();
  CFDictionarySetInt64(a1, @"shareMode", ShareMode);
  else {
    __int128 v17 = (const void *)*MEMORY[0x189604DE0];
  }
  CFDictionarySetValue(a1, @"standalone6G", v17);
  if (MobileWiFiLibrary_sOnce != -1) {
    dispatch_once(&MobileWiFiLibrary_sOnce, &__block_literal_global_120);
  }
  if (MobileWiFiLibrary_sLib && dlsym((void *)MobileWiFiLibrary_sLib, "WiFiNetworkGetShareableStatus"))
  {
    int ShareableStatus = softLinkWiFiNetworkGetShareableStatus((uint64_t)a3);
    CFDictionarySetInt64(a1, @"shareableStatus", ShareableStatus);
  }

  if ((a2 & 3) != 0)
  {
    BOOL v19 = (const __CFString *)WiFiNetworkCopyPassword();
    if (v19)
    {
      __int128 v20 = v19;
      CFDictionarySetValue(a1, @"password", v19);
      if ((a2 & 2) != 0 && !WPAHashPSK(SSIDData, v20, bytes, v25))
      {
        CFDictionarySetData(a1, @"psk", bytes, 32LL);
        CFDictionarySetCString(a1, @"pskStr", v25, -1LL);
      }

      CFRelease(v20);
    }
  }

  if ((a2 & 4) != 0)
  {
    __int128 v21 = (const void *)WiFiNetworkCopyRecord();
    if (v21)
    {
      int v22 = v21;
      CFDictionarySetValue(a1, @"rawRecord", v21);
      CFRelease(v22);
    }
  }

  CFDictionarySetValue(a1, @"platformNetwork", a3);
  if (IsEAP)
  {
    if (getkWiFiNetworkShareableEAPConfig())
    {
      getkWiFiNetworkShareableEAPConfig();
      uint64_t v23 = (const void *)WiFiNetworkGetProperty();
      if (v23) {
        CFDictionarySetValue(a1, @"eapConfig", v23);
      }
    }

    if (getkWiFiNetworkShareableEAPTrustExceptions())
    {
      getkWiFiNetworkShareableEAPTrustExceptions();
      int v24 = (const void *)WiFiNetworkGetProperty();
      if (v24) {
        CFDictionarySetValue(a1, @"eapTrustExceptions", v24);
      }
    }
  }

  _WiFiDictionaryAddNetworkAdditionalInfo(a1);
}

uint64_t WPAHashPSK(const __CFString *a1, CFStringRef theString, _OWORD *a3, _BYTE *a4)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  buffer[0] = 0;
  if (!CFStringGetCString(theString, buffer, 128LL, 0x8000100u)) {
    return 4294960579LL;
  }
  size_t v7 = strlen(buffer);
  size_t v18 = v7;
  if (v7 - 8 > 0x37)
  {
    uint64_t result = HexToData(buffer, v7, 30, (uint64_t)v20, 0x20uLL, 0LL, &v18, 0LL);
    if ((_DWORD)result) {
      return result;
    }
    if (v18 != 32) {
      return 4294960553LL;
    }
    if (!a3) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 == CFDataGetTypeID())
  {
    int BytePtr = CFDataGetBytePtr((CFDataRef)a1);
    CFIndex Length = CFDataGetLength((CFDataRef)a1);
    size_t v11 = v7;
    BOOL v12 = (char *)BytePtr;
  }

  else
  {
    if (v8 != CFStringGetTypeID()) {
      return 4294960540LL;
    }
    v23.CFIndex length = CFStringGetLength(a1);
    CFIndex usedBufLen = 0LL;
    v23.location = 0LL;
    CFStringGetBytes(a1, v23, 0x8000100u, 0, 0, v19, 64LL, &usedBufLen);
    CFIndex Length = usedBufLen;
    BOOL v12 = (char *)v19;
    size_t v11 = v7;
  }

  PBKDF2_HMAC_SHA1(buffer, v11, v12, Length, (uint64_t)v20);
  if (a3)
  {
LABEL_8:
    __int128 v14 = v20[1];
    *a3 = v20[0];
    a3[1] = v14;
  }

uint64_t initWiFiNetworkGetShareableStatus(uint64_t a1)
{
  if (MobileWiFiLibrary_sOnce != -1) {
    dispatch_once(&MobileWiFiLibrary_sOnce, &__block_literal_global_120);
  }
  softLinkWiFiNetworkGetint ShareableStatus = (uint64_t (*)())dlsym( (void *)MobileWiFiLibrary_sLib,  "WiFiNetworkGetShareableStatus");
  return ((uint64_t (*)(uint64_t))softLinkWiFiNetworkGetShareableStatus)(a1);
}

__CFDictionary *WiFiCopyNetworkInfo(const __CFDictionary *a1, char a2, int *a3)
{
  uint64_t v6 = WiFiManagerClientCreate();
  if (v6)
  {
    size_t v11 = (const void *)v6;
    BOOL v12 = (const __CFArray *)WiFiManagerClientCopyNetworks();
    if (v12)
    {
      uint64_t v13 = v12;
      CFIndex Count = CFArrayGetCount(v12);
      if (Count < 1) {
        goto LABEL_9;
      }
      CFIndex v15 = Count;
      CFIndex v16 = 0LL;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v13, v16);
        CFTypeID TypeID = CFStringGetTypeID();
        TypedValue = CFDictionaryGetTypedValue(a1, @"ssid", TypeID, 0LL);
        if (!TypedValue) {
          break;
        }
        __int128 v20 = TypedValue;
        SSID = (const void *)WiFiNetworkGetSSID();
        if (SSID)
        {
          if (CFEqual(SSID, v20)) {
            break;
          }
        }

        if (v15 == ++v16) {
          goto LABEL_9;
        }
      }

      if (ValueAtIndex)
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
        uint64_t v22 = Mutable;
        if (Mutable)
        {
          _WiFiDictionaryAddNetworkInfo(Mutable, a2, ValueAtIndex);
          int v23 = 0;
        }

        else
        {
          int v23 = -6728;
        }
      }

      else
      {
LABEL_9:
        uint64_t v22 = 0LL;
        int v23 = -6727;
      }

      CFRelease(v13);
    }

    else
    {
      uint64_t v22 = 0LL;
      int v23 = -6727;
    }

    CFRelease(v11);
    if (a3) {
      goto LABEL_16;
    }
  }

  else
  {
    if (gLogCategory_WiFiManagerCore <= 60
      && (gLogCategory_WiFiManagerCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_WiFiManagerCore, 0x3Cu)))
    {
      LogPrintF( (uint64_t)&gLogCategory_WiFiManagerCore,  (uint64_t)"CFDictionaryRef WiFiCopyNetworkInfo(CFDictionaryRef, WiFiNetworkInfoFlags, OSStatus *)",  0x3Cu,  (uint64_t)"### WiFiManagerClientCreate failed\n",  v7,  v8,  v9,  v10,  v26);
    }

    uint64_t v22 = 0LL;
    int v23 = -6700;
    if (a3) {
LABEL_16:
    }
      *a3 = v23;
  }

  return v22;
}

uint64_t WiFiRestoreNetwork(const __CFDictionary *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t Value = (uint64_t)CFDictionaryGetValue(a1, @"platformNetwork");
  if (Value)
  {
    uint64_t v8 = WiFiManagerClientCreate();
    if (!v8)
    {
      id v16 = 0LL;
      uint64_t v13 = 0LL;
      uint64_t Value = 4294960596LL;
      goto LABEL_13;
    }

    uint64_t v9 = (const void *)v8;
    CFRunLoopGetMain();
    WiFiManagerClientScheduleWithRunLoop();
    uint64_t v10 = (const __CFArray *)WiFiManagerClientCopyDevices();
    size_t v11 = v10;
    if (v10 && CFArrayGetCount(v10) >= 1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v11, 0LL);
      uint64_t v13 = (void *)[v6 copy];
      if (v6)
      {
        id v14 = objc_alloc_init(MEMORY[0x189603FC8]);
        CFIndex v15 = _Block_copy(v13);
        [v14 setObject:v15 forKeyedSubscript:@"block"];

        [v14 setObject:ValueAtIndex forKeyedSubscript:@"platformDevice"];
        [v14 setObject:v9 forKeyedSubscript:@"platformManager"];
        [v14 setObject:v5 forKeyedSubscript:@"queue"];
        id v16 = v14;
        uint64_t Value = WiFiDeviceClientAssociateAsync();
        if (!(_DWORD)Value)
        {
          CFRelease(v9);

          id v16 = 0LL;
LABEL_12:
          CFRelease(v11);
          goto LABEL_13;
        }

        CFRelease(v16);
      }

      else
      {
        id v16 = 0LL;
        uint64_t Value = 4294960568LL;
      }
    }

    else
    {
      id v16 = 0LL;
      uint64_t v13 = 0LL;
      uint64_t Value = 4294960569LL;
    }

    CFRunLoopGetMain();
    WiFiManagerClientUnscheduleFromRunLoop();
    CFRelease(v9);
    if (!v11) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __WiFiRestoreNetwork_block_invoke;
  block[3] = &unk_189F34300;
  id v19 = v6;
  dispatch_async(v5, block);

  id v16 = 0LL;
  uint64_t v13 = 0LL;
LABEL_13:

  return Value;
}

uint64_t __WiFiRestoreNetwork_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void _WiFiRestoreNetworkCB(uint64_t a1, uint64_t a2, uint64_t a3, int a4, void *a5)
{
  uint64_t v7 = (const void *)objc_claimAutoreleasedReturnValue();
  [a5 objectForKeyedSubscript:@"block"];
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  [a5 objectForKeyedSubscript:@"queue"];
  uint64_t v9 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  v11[2] = ___WiFiRestoreNetworkCB_block_invoke;
  v11[3] = &unk_189F34430;
  id v12 = v8;
  int v13 = a4;
  id v10 = v8;
  dispatch_async(v9, v11);
  CFRunLoopGetMain();
  WiFiManagerClientUnscheduleFromRunLoop();
  CFRelease(v7);
}

uint64_t WiFiScan(const __CFDictionary *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7 = a2;
  *(void *)uint64_t v80 = a4;
  *(void *)uuid_t bytes = a3;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  p_cache = (void **)(&OBJC_CLASS___CUAppleIDClient + 16);
  if (Mutable)
  {
    id v14 = Mutable;
    uint64_t v15 = mach_absolute_time();
    CFDictionarySetInt64(v14, @"startTime", v15);
    uint64_t v16 = WiFiManagerClientCreate();
    if (!v16)
    {
      unsigned int v79 = -6700;
      goto LABEL_59;
    }

    __int128 v17 = (const void *)v16;
    CFRunLoopGetMain();
    WiFiManagerClientScheduleWithRunLoop();
    CFDictionarySetValue(v14, @"platformManager", v17);
    size_t v18 = (const __CFArray *)WiFiManagerClientCopyDevices();
    id v19 = v18;
    if (v18 && CFArrayGetCount(v18) > 0)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v19, 0LL);
      CFDictionarySetValue(v14, @"platformDevice", ValueAtIndex);
      CFRelease(v19);
      CFDictionarySetData(v14, @"callback", bytes, 8LL);
      CFDictionarySetData(v14, @"context", v80, 8LL);
      CFDictionarySetValue(v14, @"queue", v7);
      __int128 v20 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      id v19 = v20;
      if (!v20)
      {
        theDict = 0LL;
LABEL_82:
        uint64_t v68 = 0LL;
        unsigned int v69 = -6728;
        goto LABEL_83;
      }

      __int128 v21 = (const void *)*MEMORY[0x189604DE8];
      CFDictionarySetValue(v20, @"SCAN_MERGE", (const void *)*MEMORY[0x189604DE8]);
      uint64_t Value = CFDictionaryGetValue(a1, @"scanDwellTime");
      if (Value) {
        CFDictionarySetValue(v19, @"SCAN_DWELL_TIME", Value);
      }
      CFTypeID TypeID = CFStringGetTypeID();
      Typeduint64_t Value = CFDictionaryGetTypedValue(a1, @"ssid", TypeID, 0LL);
      if (TypedValue)
      {
        int v25 = TypedValue;
        CFDictionarySetValue(v19, @"HIDDEN_NETWORK", v21);
        CFDictionarySetValue(v19, @"SCAN_DIRECTED", v21);
        CFDictionarySetValue(v19, @"SSID_STR", v25);
      }

      int Int64Ranged = CFDictionaryGetInt64Ranged(a1, @"channel", 0xFFFFFFFF80000000LL, 0x7FFFFFFFLL, 0LL);
      unint64_t Int64 = CFDictionaryGetInt64(a1, @"channel_2pt4GHz", (int *)&v79);
      if (v79) {
        BOOL v28 = 0;
      }
      else {
        BOOL v28 = Int64 == 0;
      }
      int v29 = a1;
      int v30 = !v28;
      uint64_t v77 = v29;
      unint64_t v31 = CFDictionaryGetInt64(v29, @"channel_5GHz", (int *)&v79);
      if (v79) {
        BOOL v32 = 0;
      }
      else {
        BOOL v32 = v31 == 0;
      }
      uint64_t v33 = !v32;
      if ((v30 & 1) != 0 || (v33 & 1) != 0)
      {
        if (Int64Ranged < 1) {
          int v34 = v30;
        }
        else {
          int v34 = 0;
        }
        CFMutableArrayRef v35 = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
        theDict = v19;
        if (v35)
        {
          theArray = v35;
          char valuePtr = 27;
          CFNumberRef v36 = CFNumberCreate(0LL, kCFNumberSInt8Type, &valuePtr);
          if (v36)
          {
            CFNumberRef v37 = v36;
            id v19 = (const __CFArray *)WiFiDeviceClientCopyProperty();
            CFRelease(v37);
            if (v19)
            {
              CFTypeID v72 = v17;
              uint64_t v73 = v14;
              id v74 = v7;
              CFIndex Count = CFArrayGetCount(v19);
              if (Count >= 1)
              {
                CFIndex v39 = Count;
                CFIndex v40 = 0LL;
                int v41 = @"SUP_CHANNEL";
                int v42 = @"SUP_CHANNEL_FLAGS";
                int v71 = v30;
                while (1)
                {
                  CFTypeID v43 = CFDictionaryGetTypeID();
                  TypedValueAtIndex = CFArrayGetTypedValueAtIndex(v19, v40, v43, (int *)&v79);
                  if (v79) {
                    break;
                  }
                  int v45 = TypedValueAtIndex;
                  int v46 = CFDictionaryGetInt64Ranged(TypedValueAtIndex, v41, 0xFFFFFFFF80000000LL, 0x7FFFFFFFLL, 0LL);
                  int v47 = v46;
                  if (Int64Ranged < 1 || v46 == Int64Ranged)
                  {
                    unsigned int v48 = CFDictionaryGetInt64(v45, v42, 0LL);
                    unsigned int v49 = v48;
                    int v50 = (v48 & 8) != 0 ? v30 : 1;
                    if (v50 == 1)
                    {
                      int v51 = (v48 & 0x10) != 0 ? v33 : 1;
                      if (v51 == 1)
                      {
                        int8x16_t v52 = v41;
                        uint64_t v53 = v33;
                        uint64_t v54 = v42;
                        uint64_t v55 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
                        if (!v55)
                        {
                          unsigned int v79 = -6728;
                          break;
                        }

                        CFIndex v56 = v55;
                        CFDictionarySetInt64(v55, @"CHANNEL", v47);
                        CFDictionarySetInt64(v56, @"CHANNEL_FLAGS", v49);
                        CFArrayAppendValue(theArray, v56);
                        CFRelease(v56);
                        int v42 = v54;
                        uint64_t v33 = v53;
                        int v41 = v52;
                        int v30 = v71;
                      }
                    }
                  }

                  if (v39 == ++v40) {
                    goto LABEL_47;
                  }
                }

                id v14 = v73;
                id v7 = v74;
                p_cache = (void **)(&OBJC_CLASS___CUAppleIDClient + 16);
                __int128 v17 = v72;
                goto LABEL_73;
              }

void _WiFiScanCallback(int a1, const __CFArray *a2, int a3, CFDictionaryRef theDict)
{
  if (sUpTicksToSecondsOnce != -1) {
    dispatch_once_f(&sUpTicksToSecondsOnce, &sUpTicksToSecondsMultiplier, (dispatch_function_t)_UpTicksToSecondsInit);
  }
  if (gLogCategory_WiFiManagerCore <= 30
    && (gLogCategory_WiFiManagerCore != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_WiFiManagerCore, 0x1Eu)))
  {
    if (a2) {
      char Count = CFArrayGetCount(a2);
    }
    else {
      char Count = 0;
    }
    LogPrintF( (uint64_t)&gLogCategory_WiFiManagerCore,  (uint64_t)"void _WiFiScanCallback(WiFiDeviceClientRef, CFArrayRef, WiFiError, void *)",  0x1Eu,  (uint64_t)"WiFi scan completed: %ld results, %.3f seconds, %#m\n",  v7,  v8,  v9,  v10,  Count);
  }

  CFDictionaryGetData(theDict, @"callback", (const char *)&v16, 8uLL, 0LL, 0LL);
  CFDictionaryGetData(theDict, @"context", (const char *)&v15, 8uLL, 0LL, 0LL);
  CFDictionaryGetValue(theDict, @"queue");
  uint64_t v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
  if (a2) {
    CFRetain(a2);
  }
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___WiFiScanCallback_block_invoke;
  block[3] = &__block_descriptor_60_e5_v8__0l;
  int v14 = a3;
  void block[4] = a2;
  block[5] = v16;
  void block[6] = v15;
  dispatch_async(v12, block);
  CFRunLoopGetMain();
  WiFiManagerClientUnscheduleFromRunLoop();
  CFRelease(theDict);
}

uint64_t WiFiScan_b(const __CFDictionary *a1, void *a2, const void *a3)
{
  id v5 = a2;
  id v6 = _Block_copy(a3);

  uint64_t v7 = WiFiScan(a1, v5, (uint64_t)_WiFiScan_bCallBack, (uint64_t)v6);
  if ((_DWORD)v7) {

  }
  return v7;
}

void _WiFiScan_bCallBack(uint64_t a1, uint64_t a2, void (**a3)(void, void, void))
{
}

uint64_t WiFiSWAPStart(__CFDictionary **a1, const __CFDictionary *a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v9 = a3;
  uint64_t v27 = a5;
  *(void *)uuid_t bytes = a4;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (!Mutable)
  {
    uint64_t started = 4294960568LL;
    goto LABEL_21;
  }

  uint64_t v11 = Mutable;
  uint64_t v12 = (const void *)WiFiManagerClientCreate();
  if (!v12)
  {
    uint64_t started = 4294960596LL;
    goto LABEL_20;
  }

  int v13 = v12;
  CFDictionarySetValue(v11, @"platformManager", v12);
  CFRunLoopGetMain();
  WiFiManagerClientScheduleWithRunLoop();
  int v14 = (const __CFArray *)WiFiManagerClientCopyDevices();
  if (!v14)
  {
    CFRelease(v13);
    uint64_t started = 4294960569LL;
    goto LABEL_20;
  }

  uint64_t v15 = v14;
  if (CFArrayGetCount(v14) < 1)
  {
    uint64_t started = 4294960569LL;
  }

  else
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v15, 0LL);
    CFDictionarySetValue(v11, @"platformDevice", ValueAtIndex);
    if (a4) {
      CFDictionarySetData(v11, @"startedCallback", bytes, 8LL);
    }
    if (a5) {
      CFDictionarySetData(v11, @"startedContext", (UInt8 *)&v27, 8LL);
    }
    if (v9) {
      CFDictionarySetValue(v11, @"startedQueue", v9);
    }
    __int128 v17 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    if (v17)
    {
      size_t v18 = v17;
      CFDictionarySetInt64(v17, @"AP_MODE_AUTH_LOWER", 1LL);
      CFDictionarySetInt64(v18, @"AP_MODE_AUTH_UPPER", 0LL);
      CFDictionarySetInt64(v18, @"AP_MODE_CYPHER_TYPE", 0LL);
      int64_t Int64 = CFDictionaryGetInt64(a2, @"channel_2pt4GHz", (int *)&v32);
      if (v32 && (int64_t Int64 = CFDictionaryGetInt64(a2, @"channel_5GHz", (int *)&v32), v32))
      {
        uint64_t v20 = 6LL;
      }

      else
      {
        uint64_t v20 = Int64;
        if (Int64 <= 0)
        {
          unsigned int v32 = -6705;
LABEL_18:
          CFRelease(v18);
          uint64_t started = v32;
          goto LABEL_19;
        }
      }

      CFDictionarySetInt64(v18, @"CHANNEL", v20);
      CFTypeID TypeID = CFStringGetTypeID();
      Typeduint64_t Value = (const __CFString *)CFDictionaryGetTypedValue(a2, @"ssid", TypeID, (int *)&v32);
      if (v32) {
        goto LABEL_18;
      }
      unsigned int v32 = CFStringGetOrCopyCStringUTF8(TypedValue, (const char **)&v31, (UInt8 **)&v30, (size_t *)&length);
      if (v32) {
        goto LABEL_18;
      }
      CFDictionarySetData(v18, @"AP_MODE_SSID_BYTES", v31, length);
      if (v30) {
        free(v30);
      }
      CFTypeID v25 = CFDataGetTypeID();
      char v26 = CFDictionaryGetTypedValue(a2, @"ie", v25, 0LL);
      if (v26) {
        CFDictionarySetValue(v18, @"AP_MODE_IE_LIST", v26);
      }
      CFRetain(v11);
      uint64_t started = WiFiDeviceClientStartNetwork();
      CFRelease(v18);
      if ((_DWORD)started)
      {
        CFRelease(v11);
      }

      else
      {
        *a1 = v11;
        uint64_t v11 = 0LL;
      }
    }

    else
    {
      uint64_t started = 4294960568LL;
    }
  }

void _WiFiSWAPStartCallBack(int a1, int a2, void *value, int a4, CFMutableDictionaryRef theDict)
{
  uint64_t v14 = 0LL;
  uint64_t v13 = 0LL;
  if (value) {
    CFDictionarySetValue(theDict, @"platformNetwork", value);
  }
  CFDictionarySetInt64(theDict, @"startedStatus", a2);
  CFDictionaryGetValue(theDict, @"startedQueue");
  uint64_t v8 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
  CFDictionaryGetData(theDict, @"startedCallback", (const char *)&v14, 8uLL, 0LL, 0LL);
  CFDictionaryGetData(theDict, @"startedContext", (const char *)&v13, 8uLL, 0LL, 0LL);
  if (v8 && v14)
  {
    CFRetain(theDict);
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 3221225472LL;
    v11[2] = ___WiFiSWAPStartCallBack_block_invoke;
    v11[3] = &__block_descriptor_60_e5_v8__0l;
    void v11[4] = v14;
    v11[5] = theDict;
    int v12 = a2;
    v11[6] = v13;
    dispatch_async(v8, v11);
  }

  if (CFDictionaryGetInt64(theDict, @"stopPending", 0LL))
  {
    int v9 = CFRetain(theDict);
    if (value)
    {
    }

    else
    {
      _WiFiSWAPStopCallBack(v9, 0, v10, theDict);
    }
  }

  CFRelease(theDict);
}

void _WiFiSWAPStopCallBack(int a1, int a2, int a3, CFDictionaryRef theDict)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  CFDictionaryGetValue(theDict, @"stoppedQueue");
  id v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
  CFDictionaryGetData(theDict, @"stoppedCallback", (const char *)&v10, 8uLL, 0LL, 0LL);
  CFDictionaryGetData(theDict, @"stoppedContext", (const char *)&v9, 8uLL, 0LL, 0LL);
  if (v6 && v10)
  {
    CFRetain(theDict);
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = ___WiFiSWAPStopCallBack_block_invoke;
    v7[3] = &__block_descriptor_60_e5_v8__0l;
    v7[4] = v10;
    v7[5] = theDict;
    int v8 = a2;
    v7[6] = v9;
    dispatch_async(v6, v7);
  }

  if (CFDictionaryGetValue(theDict, @"platformManager"))
  {
    CFRunLoopGetMain();
    WiFiManagerClientUnscheduleFromRunLoop();
  }

  CFRelease(theDict);
}

uint64_t WiFiSWAPStop(__CFDictionary *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7 = a2;
  uint64_t v12 = a4;
  *(void *)uuid_t bytes = a3;
  if (CFDictionaryGetValue(a1, @"platformDevice"))
  {
    if (a3) {
      CFDictionarySetData(a1, @"stoppedCallback", bytes, 8LL);
    }
    if (a4) {
      CFDictionarySetData(a1, @"stoppedContext", (UInt8 *)&v12, 8LL);
    }
    if (v7) {
      CFDictionarySetValue(a1, @"stoppedQueue", v7);
    }
    if (CFDictionaryGetValue(a1, @"platformNetwork"))
    {
      CFRetain(a1);
      uint64_t v8 = WiFiDeviceClientStopNetwork();
      if ((_DWORD)v8) {
        CFRelease(a1);
      }
    }

    else
    {
      if (CFDictionaryGetInt64(a1, @"startedStatus", 0LL))
      {
        int v9 = CFRetain(a1);
        _WiFiSWAPStopCallBack(v9, 0, v10, a1);
      }

      else
      {
        CFDictionarySetValue(a1, @"stopPending", (const void *)*MEMORY[0x189604DE8]);
      }

      uint64_t v8 = 0LL;
    }
  }

  else
  {
    uint64_t v8 = 4294960576LL;
  }

  CFRelease(a1);

  return v8;
}

BOOL xpc_connection_has_entitlement()
{
  uint64_t v0 = xpc_connection_copy_entitlement_value();
  if (!v0) {
    return 0LL;
  }
  timeval v1 = (void *)v0;
  BOOL v2 = MEMORY[0x186E43C98]() == MEMORY[0x1895F9228] && xpc_BOOL_get_value(v1);
  xpc_release(v1);
  return v2;
}

void xpc_connection_set_event_handler_f(_xpc_connection_s *a1, uint64_t a2, uint64_t a3)
{
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  v3[2] = __xpc_connection_set_event_handler_f_block_invoke;
  v3[3] = &__block_descriptor_tmp_14025;
  v3[4] = a2;
  v3[5] = a3;
  xpc_connection_set_event_handler(a1, v3);
}

uint64_t __xpc_connection_set_event_handler_f_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 32))(a2, *(void *)(a1 + 40));
}

void xpc_connection_send_message_with_reply_f( _xpc_connection_s *a1, void *a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __xpc_connection_send_message_with_reply_f_block_invoke;
  void v5[3] = &__block_descriptor_tmp_1;
  v5[4] = a4;
  v5[5] = a5;
  xpc_connection_send_message_with_reply(a1, a2, a3, v5);
}

uint64_t __xpc_connection_send_message_with_reply_f_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 32))(a2, *(void *)(a1 + 40));
}

uint64_t xpc_dictionary_copy_cf_object(void *a1, const char *a2, int *a3)
{
  uint64_t result = (uint64_t)xpc_dictionary_get_value(a1, a2);
  if (!result)
  {
    int v5 = -6727;
    if (!a3) {
      return result;
    }
    goto LABEL_6;
  }

  uint64_t result = _CFXPCCreateCFObjectFromXPCObject();
  if (result) {
    int v5 = 0;
  }
  else {
    int v5 = -6756;
  }
  if (a3) {
LABEL_6:
  }
    *a3 = v5;
  return result;
}

uint64_t xpc_dictionary_set_cf_object(void *a1, const char *a2)
{
  uint64_t v4 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  if (!v4) {
    return 4294960540LL;
  }
  int v5 = v4;
  xpc_dictionary_set_value(a1, a2, v4);
  xpc_release(v5);
  return 0LL;
}

uint64_t xpc_send_message_sync(const char *a1, uint64_t a2, int a3, void *a4, void *a5)
{
  uint64_t v28 = 0LL;
  int v29 = 0LL;
  uint64_t v25 = 0LL;
  char v26 = &v25;
  uint64_t v27 = 0x2000000000LL;
  asprintf(&v29, "xpc_send_message_sync:%s", a1);
  if (v29 && (int v10 = dispatch_queue_create(v29, 0LL), free(v29), v10))
  {
    mach_service = xpc_connection_create_mach_service(a1, v10, a2);
    if (!mach_service)
    {
      uint64_t v19 = 4294960596LL;
      uint64_t v14 = (dispatch_semaphore_s *)v10;
LABEL_12:
      dispatch_release(v14);
      goto LABEL_13;
    }

    uint64_t v12 = mach_service;
    xpc_connection_set_event_handler(mach_service, &__block_literal_global_14028);
    if (a3) {
      xpc_connection_set_target_uid();
    }
    xpc_connection_resume(v12);
    dispatch_semaphore_t v13 = dispatch_semaphore_create(0LL);
    uint64_t v14 = v13;
    if (v13)
    {
      if (a5)
      {
        handler[0] = MEMORY[0x1895F87A8];
        handler[1] = 0x40000000LL;
        handler[2] = __xpc_send_message_sync_block_invoke_2;
        handler[3] = &unk_189F344F8;
        handler[4] = &v25;
        handler[5] = v13;
        xpc_connection_send_message_with_reply(v12, a4, v10, handler);
        dispatch_semaphore_wait(v14, 0xFFFFFFFFFFFFFFFFLL);
        if (MEMORY[0x186E43C98](v26[3]) == MEMORY[0x1895F9268])
        {
          if (gLogCategory_XPCUtils <= 50
            && (gLogCategory_XPCUtils != -1 || _LogCategory_Initialize((uint64_t)&gLogCategory_XPCUtils, 0x32u)))
          {
            LogPrintF( (uint64_t)&gLogCategory_XPCUtils,  (uint64_t)"OSStatus xpc_send_message_sync(const char *, uint64_t, uid_t, xpc_object_t, xpc_object_t *)",  0x32u,  (uint64_t)"### XPC service '%s' error: %{xpc}\n",  v15,  v16,  v17,  v18,  (char)a1);
          }

          uint64_t v19 = 4294960543LL;
        }

        else
        {
          uint64_t v19 = 0LL;
          uint64_t v20 = v26;
          *a5 = v26[3];
          v20[3] = 0LL;
        }
      }

      else
      {
        xpc_connection_send_message(v12, a4);
        barrier[0] = MEMORY[0x1895F87A8];
        barrier[1] = 0x40000000LL;
        barrier[2] = __xpc_send_message_sync_block_invoke_3;
        barrier[3] = &__block_descriptor_tmp_7_14030;
        barrier[4] = v14;
        xpc_connection_send_barrier(v12, barrier);
        dispatch_semaphore_wait(v14, 0xFFFFFFFFFFFFFFFFLL);
        uint64_t v19 = 0LL;
      }
    }

    else
    {
      uint64_t v19 = 4294960568LL;
    }

    xpc_connection_cancel(v12);
    xpc_release(v12);
    dispatch_release(v10);
    if (v14) {
      goto LABEL_12;
    }
  }

  else
  {
    uint64_t v19 = 4294960568LL;
  }

uint64_t __xpc_send_message_sync_block_invoke_2(uint64_t a1, xpc_object_t object)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = object;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

uint64_t __xpc_send_message_sync_block_invoke_3(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t Apple80211BindToInterface()
{
  return MEMORY[0x18960FF18]();
}

uint64_t Apple80211Close()
{
  return MEMORY[0x18960FF30]();
}

uint64_t Apple80211Open()
{
  return MEMORY[0x18960FF80]();
}

uint64_t Apple80211RawGet()
{
  return MEMORY[0x18960FFA0]();
}

uint64_t Apple80211RawSet()
{
  return MEMORY[0x18960FFA8]();
}

uint64_t CCBigNumAdd()
{
  return MEMORY[0x1895F8010]();
}

uint64_t CCBigNumAddI()
{
  return MEMORY[0x1895F8018]();
}

uint64_t CCBigNumBitCount()
{
  return MEMORY[0x1895F8020]();
}

uint64_t CCBigNumCompare()
{
  return MEMORY[0x1895F8028]();
}

uint64_t CCBigNumCompareI()
{
  return MEMORY[0x1895F8030]();
}

uint64_t CCBigNumFree()
{
  return MEMORY[0x1895F8038]();
}

uint64_t CCBigNumFromData()
{
  return MEMORY[0x1895F8040]();
}

uint64_t CCBigNumMod()
{
  return MEMORY[0x1895F8048]();
}

uint64_t CCBigNumModExp()
{
  return MEMORY[0x1895F8050]();
}

uint64_t CCBigNumMul()
{
  return MEMORY[0x1895F8058]();
}

uint64_t CCBigNumMulMod()
{
  return MEMORY[0x1895F8060]();
}

uint64_t CCBigNumSetI()
{
  return MEMORY[0x1895F8068]();
}

uint64_t CCBigNumSub()
{
  return MEMORY[0x1895F8070]();
}

uint64_t CCBigNumToData()
{
  return MEMORY[0x1895F8078]();
}

uint64_t CCCreateBigNum()
{
  return MEMORY[0x1895F8088]();
}

CCCryptorStatus CCCryptorCreate( CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, CCCryptorRef *cryptorRef)
{
  return MEMORY[0x1895F80B0](*(void *)&op, *(void *)&alg, *(void *)&options, key, keyLength, iv, cryptorRef);
}

CCCryptorStatus CCCryptorCreateWithMode( CCOperation op, CCMode mode, CCAlgorithm alg, CCPadding padding, const void *iv, const void *key, size_t keyLength, const void *tweak, size_t tweakLength, int numRounds, CCModeOptions options, CCCryptorRef *cryptorRef)
{
  return MEMORY[0x1895F80B8]( *(void *)&op,  *(void *)&mode,  *(void *)&alg,  *(void *)&padding,  iv,  key,  keyLength,  tweak);
}

uint64_t CCCryptorGCMAddAAD()
{
  return MEMORY[0x1895F80D0]();
}

uint64_t CCCryptorGCMDecrypt()
{
  return MEMORY[0x1895F80D8]();
}

uint64_t CCCryptorGCMEncrypt()
{
  return MEMORY[0x1895F80E0]();
}

uint64_t CCCryptorGCMFinalize()
{
  return MEMORY[0x1895F80E8]();
}

uint64_t CCCryptorGCMReset()
{
  return MEMORY[0x1895F8100]();
}

uint64_t CCCryptorGCMSetIV()
{
  return MEMORY[0x1895F8108]();
}

CCCryptorStatus CCCryptorRelease(CCCryptorRef cryptorRef)
{
  return MEMORY[0x1895F8120](cryptorRef);
}

CCCryptorStatus CCCryptorReset(CCCryptorRef cryptorRef, const void *iv)
{
  return MEMORY[0x1895F8128](cryptorRef, iv);
}

CCCryptorStatus CCCryptorUpdate( CCCryptorRef cryptorRef, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x1895F8130](cryptorRef, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

uint64_t CCRSACryptorImport()
{
  return MEMORY[0x1895F8200]();
}

uint64_t CCRSACryptorRelease()
{
  return MEMORY[0x1895F8208]();
}

uint64_t CCRSACryptorSign()
{
  return MEMORY[0x1895F8210]();
}

CCRNGStatus CCRandomGenerateBytes(void *bytes, size_t count)
{
  return MEMORY[0x1895F8228](bytes, count);
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x1895F8278](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x1895F8280](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F8288](c, data, *(void *)&len);
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1895F8290](data, *(void *)&len, md);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x1895F8298](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x1895F82A0](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F82A8](c, data, *(void *)&len);
}

unsigned __int8 *__cdecl CC_SHA256(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1895F82D0](data, *(void *)&len, md);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x1895F82D8](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x1895F82E0](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F82E8](c, data, *(void *)&len);
}

int CC_SHA512_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return MEMORY[0x1895F8318](md, c);
}

int CC_SHA512_Init(CC_SHA512_CTX *c)
{
  return MEMORY[0x1895F8320](c);
}

int CC_SHA512_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F8328](c, data, *(void *)&len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

CFArrayRef CFArrayCreate( CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x189602638](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x189602640](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable( CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x189602648](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x189602658](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x189602660](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x189602678](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x189602690]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x189602698](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArraySortValues( CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1896027C8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1896027D0](BOOLean);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return MEMORY[0x189602940](calendar, at, componentDesc);
}

CFCalendarRef CFCalendarCopyCurrent(void)
{
  return (CFCalendarRef)MEMORY[0x189602948]();
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  uint64_t v3 = va_arg(va, void);
  return MEMORY[0x189602958](calendar, v3, at);
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x189602A10](cf);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x189602A58](allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x189602A68](allocator, capacity);
}

CFDataRef CFDataCreateWithBytesNoCopy( CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x189602A80](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x189602A98](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x189602AB0](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x189602AC8]();
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return MEMORY[0x189602AE8](theDate, otherDate, context);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x189602AF0](allocator, at);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x189602B78]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

CFDictionaryRef CFDictionaryCreate( CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x189602BA8](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable( CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x189602BB8](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy( CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x189602BC8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x189602BD0](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x189602BF0]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x189602C00](theDict, key);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x189602C38](cf1, cf2);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x189602C70](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x189602C78](err);
}

CFTypeID CFErrorGetTypeID(void)
{
  return MEMORY[0x189602C80]();
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x189602D30](cf);
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x189602E88]();
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x189602EA0](allocator, theType, valuePtr);
}

CFIndex CFNumberGetByteSize(CFNumberRef number)
{
  return MEMORY[0x189602EF0](number);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x189602EF8](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x189602F08]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x189602F10](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x189602F20](number);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x189602F58](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x189602F68](key, applicationID);
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFArrayRef)MEMORY[0x189602F78](applicationID, userName, hostName);
}

CFPropertyListRef CFPreferencesCopyValue( CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x189602F88](key, applicationID, userName, hostName);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

CFDataRef CFPropertyListCreateData( CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x189602FD0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateDeepCopy( CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  return (CFPropertyListRef)MEMORY[0x189602FD8](allocator, propertyList, mutabilityOption);
}

CFPropertyListRef CFPropertyListCreateWithData( CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x189602FF0](allocator, data, options, format, error);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1896030F0](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x189603138]();
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x189603140]();
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopRun(void)
{
}

CFRunLoopRunResult CFRunLoopRunInMode( CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return MEMORY[0x189603198](mode, returnAfterSourceHandled, seconds);
}

CFRunLoopSourceRef CFRunLoopSourceCreate( CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x1896031A0](allocator, order, context);
}

void CFRunLoopStop(CFRunLoopRef rl)
{
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

CFTypeID CFSetGetTypeID(void)
{
  return MEMORY[0x189603278]();
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare( CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1896033C0](theString1, theString2, compareOptions);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x189603430](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x189603438](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes( CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x189603450](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x189603468](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x189603490](alloc, formatOptions, format);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
}

CFIndex CFStringGetBytes( CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1896034F0]( theString,  range.location,  range.length,  *(void *)&encoding,  lossByte,  isExternalRepresentation,  buffer,  maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1896034F8](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x189603500](theString, *(void *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x189603548](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x189603558](length, *(void *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x189603590]();
}

CFTimeZoneRef CFTimeZoneCreateWithName(CFAllocatorRef allocator, CFStringRef name, Boolean tryAbbrev)
{
  return (CFTimeZoneRef)MEMORY[0x189603680](allocator, name, tryAbbrev);
}

CFURLRef CFURLCreateFromFileSystemRepresentation( CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x189603780](allocator, buffer, bufLen, isDirectory);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x189603828](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x189603830]();
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x189603870](alloc);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x189603880](alloc, *(void *)&bytes.byte0, *(void *)&bytes.byte8);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x189603888](alloc, uuid);
}

CFTypeID CFUUIDGetTypeID(void)
{
  return MEMORY[0x1896038A0]();
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1 = MEMORY[0x1896038B0](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  return MEMORY[0x1896038C8](userNotification);
}

CFUserNotificationRef CFUserNotificationCreate( CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return (CFUserNotificationRef)MEMORY[0x1896038D0](allocator, flags, error, dictionary, timeout);
}

CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource( CFAllocatorRef allocator, CFUserNotificationRef userNotification, CFUserNotificationCallBack callout, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x1896038D8](allocator, userNotification, callout, order);
}

uint64_t CUErrorCodesTableGet()
{
  return MEMORY[0x18960EFF0]();
}

uint64_t CUErrorDomainTableGet()
{
  return MEMORY[0x18960EFF8]();
}

DNSServiceErrorType DNSServiceBrowse( DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *regtype, const char *domain, DNSServiceBrowseReply callBack, void *context)
{
  return MEMORY[0x1895F83A8](sdRef, *(void *)&flags, *(void *)&interfaceIndex, regtype, domain, callBack, context);
}

DNSServiceErrorType DNSServiceConstructFullName( char *const fullName, const char *const service, const char *const regtype, const char *const domain)
{
  return MEMORY[0x1895F83B8](fullName, service, regtype, domain);
}

DNSServiceErrorType DNSServiceCreateConnection(DNSServiceRef *sdRef)
{
  return MEMORY[0x1895F83C0](sdRef);
}

DNSServiceErrorType DNSServiceGetAddrInfo( DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, DNSServiceProtocol protocol, const char *hostname, DNSServiceGetAddrInfoReply callBack, void *context)
{
  return MEMORY[0x1895F83E0]( sdRef,  *(void *)&flags,  *(void *)&interfaceIndex,  *(void *)&protocol,  hostname,  callBack,  context);
}

DNSServiceErrorType DNSServiceProcessResult(DNSServiceRef sdRef)
{
  return MEMORY[0x1895F83F8](sdRef);
}

DNSServiceErrorType DNSServiceQueryRecord( DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *fullname, uint16_t rrtype, uint16_t rrclass, DNSServiceQueryRecordReply callBack, void *context)
{
  return MEMORY[0x1895F8400]( sdRef,  *(void *)&flags,  *(void *)&interfaceIndex,  fullname,  rrtype,  rrclass,  callBack,  context);
}

DNSServiceErrorType DNSServiceReconfirmRecord( DNSServiceFlags flags, uint32_t interfaceIndex, const char *fullname, uint16_t rrtype, uint16_t rrclass, uint16_t rdlen, const void *rdata)
{
  return MEMORY[0x1895F8410](*(void *)&flags, *(void *)&interfaceIndex, fullname, rrtype, rrclass, rdlen, rdata);
}

void DNSServiceRefDeallocate(DNSServiceRef sdRef)
{
}

DNSServiceErrorType DNSServiceRegister( DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *name, const char *regtype, const char *domain, const char *host, uint16_t port, uint16_t txtLen, const void *txtRecord, DNSServiceRegisterReply callBack, void *context)
{
  return MEMORY[0x1895F8428](sdRef, *(void *)&flags, *(void *)&interfaceIndex, name, regtype, domain, host, port);
}

DNSServiceErrorType DNSServiceResolve( DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *name, const char *regtype, const char *domain, DNSServiceResolveReply callBack, void *context)
{
  return MEMORY[0x1895F8438]( sdRef,  *(void *)&flags,  *(void *)&interfaceIndex,  name,  regtype,  domain,  callBack,  context);
}

DNSServiceErrorType DNSServiceSetDispatchQueue(DNSServiceRef service, dispatch_queue_t queue)
{
  return MEMORY[0x1895F8448](service, queue);
}

DNSServiceErrorType DNSServiceUpdateRecord( DNSServiceRef sdRef, DNSRecordRef RecordRef, DNSServiceFlags flags, uint16_t rdlen, const void *rdata, uint32_t ttl)
{
  return MEMORY[0x1895F8460](sdRef, RecordRef, *(void *)&flags, rdlen, rdata, *(void *)&ttl);
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  return MEMORY[0x189607C78](*(void *)&kernelPort, notificationID);
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  return MEMORY[0x189607D90](notifier);
}

IOReturn IOHIDDeviceClose(IOHIDDeviceRef device, IOOptionBits options)
{
  return MEMORY[0x189607DE0](device, *(void *)&options);
}

IOHIDDeviceRef IOHIDDeviceCreate(CFAllocatorRef allocator, io_service_t service)
{
  return (IOHIDDeviceRef)MEMORY[0x189607E00](allocator, *(void *)&service);
}

CFTypeRef IOHIDDeviceGetProperty(IOHIDDeviceRef device, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x189607E08](device, key);
}

IOReturn IOHIDDeviceOpen(IOHIDDeviceRef device, IOOptionBits options)
{
  return MEMORY[0x189607E30](device, *(void *)&options);
}

void IOHIDDeviceRegisterInputReportCallback( IOHIDDeviceRef device, uint8_t *report, CFIndex reportLength, IOHIDReportCallback callback, void *context)
{
}

void IOHIDDeviceRegisterRemovalCallback(IOHIDDeviceRef device, IOHIDCallback callback, void *context)
{
}

void IOHIDDeviceScheduleWithRunLoop(IOHIDDeviceRef device, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
}

void IOHIDDeviceUnscheduleFromRunLoop(IOHIDDeviceRef device, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x1896082F0](*(void *)&iterator);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x189608330](*(void *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return MEMORY[0x189608360](*(void *)&object, className);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x189608398](*(void *)&object);
}

CFDictionaryRef IOPSCopyExternalPowerAdapterDetails(void)
{
  return (CFDictionaryRef)MEMORY[0x1896083E8]();
}

uint64_t IOPSCopyPowerSourcesByType()
{
  return MEMORY[0x1896083F0]();
}

CFArrayRef IOPSCopyPowerSourcesList(CFTypeRef blob)
{
  return (CFArrayRef)MEMORY[0x189608408](blob);
}

uint64_t IOPSCreatePowerSource()
{
  return MEMORY[0x189608410]();
}

uint64_t IOPSDrawingUnlimitedPower()
{
  return MEMORY[0x189608418]();
}

CFDictionaryRef IOPSGetPowerSourceDescription(CFTypeRef blob, CFTypeRef ps)
{
  return (CFDictionaryRef)MEMORY[0x189608428](blob, ps);
}

uint64_t IOPSReleasePowerSource()
{
  return MEMORY[0x189608430]();
}

uint64_t IOPSSetPowerSourceDetails()
{
  return MEMORY[0x189608438]();
}

io_connect_t IORegisterForSystemPower( void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  return MEMORY[0x189608440](refcon, thePortRef, callback, notifier);
}

CFTypeRef IORegistryEntryCreateCFProperty( io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x189608470](*(void *)&entry, key, allocator, *(void *)&options);
}

kern_return_t IORegistryEntryGetParentEntry( io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  return MEMORY[0x1896084D0](*(void *)&entry, plane, parent);
}

kern_return_t IOServiceAddMatchingNotification( IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return MEMORY[0x189608548](notifyPort, notificationType, matching, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x189608550](*(void *)&connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x189608560](*(void *)&mainPort, matching);
}

kern_return_t IOServiceGetMatchingServices( mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return MEMORY[0x189608578](*(void *)&mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x189608580](name);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x189608590](name);
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1896136F0]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x189613710]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x189613728]();
}

uint64_t MKBDeviceUnlockedSinceBoot()
{
  return MEMORY[0x189611508]();
}

uint64_t MKBGetDeviceLockState()
{
  return MEMORY[0x189611510]();
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x189607700](aClass);
}

CFStringRef SCDynamicStoreCopyComputerName(SCDynamicStoreRef store, CFStringEncoding *nameEncoding)
{
  return (CFStringRef)MEMORY[0x18960C198](store, nameEncoding);
}

CFStringRef SCDynamicStoreCopyLocalHostName(SCDynamicStoreRef store)
{
  return (CFStringRef)MEMORY[0x18960C1B0](store);
}

CFPropertyListRef SCDynamicStoreCopyValue(SCDynamicStoreRef store, CFStringRef key)
{
  return (CFPropertyListRef)MEMORY[0x18960C1C0](store, key);
}

SCDynamicStoreRef SCDynamicStoreCreate( CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return (SCDynamicStoreRef)MEMORY[0x18960C1C8](allocator, name, callout, context);
}

CFStringRef SCDynamicStoreKeyCreateComputerName(CFAllocatorRef allocator)
{
  return (CFStringRef)MEMORY[0x18960C1D8](allocator);
}

CFStringRef SCDynamicStoreKeyCreateNetworkGlobalEntity( CFAllocatorRef allocator, CFStringRef domain, CFStringRef entity)
{
  return (CFStringRef)MEMORY[0x18960C1E0](allocator, domain, entity);
}

CFStringRef SCDynamicStoreKeyCreateNetworkInterfaceEntity( CFAllocatorRef allocator, CFStringRef domain, CFStringRef ifname, CFStringRef entity)
{
  return (CFStringRef)MEMORY[0x18960C1F0](allocator, domain, ifname, entity);
}

Boolean SCDynamicStoreSetDispatchQueue(SCDynamicStoreRef store, dispatch_queue_t queue)
{
  return MEMORY[0x18960C208](store, queue);
}

Boolean SCDynamicStoreSetNotificationKeys(SCDynamicStoreRef store, CFArrayRef keys, CFArrayRef patterns)
{
  return MEMORY[0x18960C218](store, keys, patterns);
}

int SCError(void)
{
  return MEMORY[0x18960C220]();
}

uint64_t SCNetworkReachabilityCreateWithOptions()
{
  return MEMORY[0x18960C300]();
}

Boolean SCNetworkReachabilityGetFlags(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags *flags)
{
  return MEMORY[0x18960C308](target, flags);
}

Boolean SCNetworkReachabilitySetCallback( SCNetworkReachabilityRef target, SCNetworkReachabilityCallBack callout, SCNetworkReachabilityContext *context)
{
  return MEMORY[0x18960C320](target, callout, context);
}

Boolean SCNetworkReachabilitySetDispatchQueue(SCNetworkReachabilityRef target, dispatch_queue_t queue)
{
  return MEMORY[0x18960C328](target, queue);
}

uint64_t SCNetworkSignatureCopyActiveIdentifiers()
{
  return MEMORY[0x18960C3D8]();
}

Boolean SCPreferencesApplyChanges(SCPreferencesRef prefs)
{
  return MEMORY[0x18960C3E8](prefs);
}

Boolean SCPreferencesCommitChanges(SCPreferencesRef prefs)
{
  return MEMORY[0x18960C3F0](prefs);
}

SCPreferencesRef SCPreferencesCreateWithAuthorization( CFAllocatorRef allocator, CFStringRef name, CFStringRef prefsID, AuthorizationRef authorization)
{
  return (SCPreferencesRef)MEMORY[0x18960C400](allocator, name, prefsID, authorization);
}

Boolean SCPreferencesSetComputerName(SCPreferencesRef prefs, CFStringRef name, CFStringEncoding nameEncoding)
{
  return MEMORY[0x18960C428](prefs, name, *(void *)&nameEncoding);
}

uint64_t SCPreferencesSetHostName()
{
  return MEMORY[0x18960C430]();
}

Boolean SCPreferencesSetLocalHostName(SCPreferencesRef prefs, CFStringRef name)
{
  return MEMORY[0x18960C438](prefs, name);
}

OSStatus SSLCopyPeerTrust(SSLContextRef context, SecTrustRef *trust)
{
  return MEMORY[0x18960B078](context, trust);
}

SSLContextRef SSLCreateContext( CFAllocatorRef alloc, SSLProtocolSide protocolSide, SSLConnectionType connectionType)
{
  return (SSLContextRef)MEMORY[0x18960B080](alloc, *(void *)&protocolSide, *(void *)&connectionType);
}

OSStatus SSLHandshake(SSLContextRef context)
{
  return MEMORY[0x18960B0E8](context);
}

OSStatus SSLRead(SSLContextRef context, void *data, size_t dataLength, size_t *processed)
{
  return MEMORY[0x18960B0F8](context, data, dataLength, processed);
}

OSStatus SSLSetCertificate(SSLContextRef context, CFArrayRef certRefs)
{
  return MEMORY[0x18960B118](context, certRefs);
}

OSStatus SSLSetConnection(SSLContextRef context, SSLConnectionRef connection)
{
  return MEMORY[0x18960B128](context, connection);
}

OSStatus SSLSetEnabledCiphers(SSLContextRef context, const SSLCipherSuite *ciphers, size_t numCiphers)
{
  return MEMORY[0x18960B138](context, ciphers, numCiphers);
}

OSStatus SSLSetIOFuncs(SSLContextRef context, SSLReadFunc readFunc, SSLWriteFunc writeFunc)
{
  return MEMORY[0x18960B140](context, readFunc, writeFunc);
}

uint64_t SSLSetPSKIdentity()
{
  return MEMORY[0x18960B158]();
}

uint64_t SSLSetPSKSharedSecret()
{
  return MEMORY[0x18960B160]();
}

OSStatus SSLSetPeerDomainName(SSLContextRef context, const char *peerName, size_t peerNameLen)
{
  return MEMORY[0x18960B168](context, peerName, peerNameLen);
}

OSStatus SSLSetProtocolVersionMin(SSLContextRef context, SSLProtocol minVersion)
{
  return MEMORY[0x18960B180](context, *(void *)&minVersion);
}

OSStatus SSLSetSessionOption(SSLContextRef context, SSLSessionOption option, Boolean value)
{
  return MEMORY[0x18960B190](context, *(void *)&option, value);
}

OSStatus SSLWrite(SSLContextRef context, const void *data, size_t dataLength, size_t *processed)
{
  return MEMORY[0x18960B198](context, data, dataLength, processed);
}

uint64_t SecCMSCertificatesOnlyMessageCopyCertificates()
{
  return MEMORY[0x18960B220]();
}

OSStatus SecCertificateCopyCommonName(SecCertificateRef certificate, CFStringRef *commonName)
{
  return MEMORY[0x18960B248](certificate, commonName);
}

CFDataRef SecCertificateCopyData(SecCertificateRef certificate)
{
  return (CFDataRef)MEMORY[0x18960B260](certificate);
}

SecKeyRef SecCertificateCopyKey(SecCertificateRef certificate)
{
  return (SecKeyRef)MEMORY[0x18960B290](certificate);
}

CFDataRef SecCertificateCopySerialNumberData(SecCertificateRef certificate, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x18960B2C0](certificate, error);
}

SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef allocator, CFDataRef data)
{
  return (SecCertificateRef)MEMORY[0x18960B2E8](allocator, data);
}

CFTypeID SecCertificateGetTypeID(void)
{
  return MEMORY[0x18960B320]();
}

OSStatus SecIdentityCopyCertificate(SecIdentityRef identityRef, SecCertificateRef *certificateRef)
{
  return MEMORY[0x18960B3D8](identityRef, certificateRef);
}

OSStatus SecIdentityCopyPrivateKey(SecIdentityRef identityRef, SecKeyRef *privateKeyRef)
{
  return MEMORY[0x18960B3E0](identityRef, privateKeyRef);
}

uint64_t SecIdentityCreate()
{
  return MEMORY[0x18960B3E8]();
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  return MEMORY[0x18960B3F8](attributes, result);
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return MEMORY[0x18960B400](query, result);
}

OSStatus SecItemDelete(CFDictionaryRef query)
{
  return MEMORY[0x18960B408](query);
}

OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate)
{
  return MEMORY[0x18960B418](query, attributesToUpdate);
}

SecKeyRef SecKeyCreateWithData(CFDataRef keyData, CFDictionaryRef attributes, CFErrorRef *error)
{
  return (SecKeyRef)MEMORY[0x18960B4C8](keyData, attributes, error);
}

size_t SecKeyGetBlockSize(SecKeyRef key)
{
  return MEMORY[0x18960B4E8](key);
}

OSStatus SecKeyRawSign( SecKeyRef key, SecPadding padding, const uint8_t *dataToSign, size_t dataToSignLen, uint8_t *sig, size_t *sigLen)
{
  return MEMORY[0x18960B4F8](key, *(void *)&padding, dataToSign, dataToSignLen, sig, sigLen);
}

OSStatus SecKeyRawVerify( SecKeyRef key, SecPadding padding, const uint8_t *signedData, size_t signedDataLen, const uint8_t *sig, size_t sigLen)
{
  return MEMORY[0x18960B500](key, *(void *)&padding, signedData, signedDataLen, sig, sigLen);
}

Boolean SecKeyVerifySignature( SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef signedData, CFDataRef signature, CFErrorRef *error)
{
  return MEMORY[0x18960B510](key, algorithm, signedData, signature, error);
}

uint64_t SecPolicyCreateAppleBasicAttestationUser()
{
  return MEMORY[0x18960B548]();
}

uint64_t SecPolicyCreateiAP()
{
  return MEMORY[0x18960B5A0]();
}

uint64_t SecPolicyCreateiAPSWAuth()
{
  return MEMORY[0x18960B5A8]();
}

SecKeyRef SecTrustCopyPublicKey(SecTrustRef trust)
{
  return (SecKeyRef)MEMORY[0x18960B6A8](trust);
}

OSStatus SecTrustCreateWithCertificates(CFTypeRef certificates, CFTypeRef policies, SecTrustRef *trust)
{
  return MEMORY[0x18960B6B8](certificates, policies, trust);
}

BOOL SecTrustEvaluateWithError(SecTrustRef trust, CFErrorRef *error)
{
  return MEMORY[0x18960B6E0](trust, error);
}

OSStatus SecTrustSetAnchorCertificates(SecTrustRef trust, CFArrayRef anchorCertificates)
{
  return MEMORY[0x18960B710](trust, anchorCertificates);
}

OSStatus SecTrustSetAnchorCertificatesOnly(SecTrustRef trust, Boolean anchorCertificatesOnly)
{
  return MEMORY[0x18960B718](trust, anchorCertificatesOnly);
}

void TXTRecordCreate(TXTRecordRef *txtRecord, uint16_t bufferLen, void *buffer)
{
}

void TXTRecordDeallocate(TXTRecordRef *txtRecord)
{
}

const void *__cdecl TXTRecordGetBytesPtr(const TXTRecordRef *txtRecord)
{
  return (const void *)MEMORY[0x1895F8640](txtRecord);
}

uint16_t TXTRecordGetLength(const TXTRecordRef *txtRecord)
{
  return MEMORY[0x1895F8658](txtRecord);
}

const void *__cdecl TXTRecordGetValuePtr(uint16_t txtLen, const void *txtRecord, const char *key, uint8_t *valueLen)
{
  return (const void *)MEMORY[0x1895F8660](txtLen, txtRecord, key, valueLen);
}

DNSServiceErrorType TXTRecordSetValue( TXTRecordRef *txtRecord, const char *key, uint8_t valueSize, const void *value)
{
  return MEMORY[0x1895F8668](txtRecord, key, valueSize, value);
}

uint64_t WiFiDeviceClientAssociateAsync()
{
  return MEMORY[0x1896117A8]();
}

uint64_t WiFiDeviceClientCopyCurrentNetwork()
{
  return MEMORY[0x1896117B0]();
}

uint64_t WiFiDeviceClientCopyHostedNetworks()
{
  return MEMORY[0x1896117B8]();
}

uint64_t WiFiDeviceClientCopyProperty()
{
  return MEMORY[0x1896117C0]();
}

uint64_t WiFiDeviceClientGetInterfaceName()
{
  return MEMORY[0x1896117C8]();
}

uint64_t WiFiDeviceClientGetInterfaceRoleIndex()
{
  return MEMORY[0x1896117D0]();
}

uint64_t WiFiDeviceClientGetPower()
{
  return MEMORY[0x1896117D8]();
}

uint64_t WiFiDeviceClientIsInterfaceAWDL()
{
  return MEMORY[0x1896117E0]();
}

uint64_t WiFiDeviceClientRegister24GHzNetworkInCriticalStateCallback()
{
  return MEMORY[0x1896117E8]();
}

uint64_t WiFiDeviceClientRegisterAutoJoinNotificationCallback()
{
  return MEMORY[0x1896117F0]();
}

uint64_t WiFiDeviceClientRegisterHostApStateChangedCallback()
{
  return MEMORY[0x1896117F8]();
}

uint64_t WiFiDeviceClientRegisterPowerCallback()
{
  return MEMORY[0x189611800]();
}

uint64_t WiFiDeviceClientRegisterRemovalCallback()
{
  return MEMORY[0x189611808]();
}

uint64_t WiFiDeviceClientScanAsync()
{
  return MEMORY[0x189611810]();
}

uint64_t WiFiDeviceClientSetPower()
{
  return MEMORY[0x189611818]();
}

uint64_t WiFiDeviceClientStartNetwork()
{
  return MEMORY[0x189611820]();
}

uint64_t WiFiDeviceClientStopNetwork()
{
  return MEMORY[0x189611828]();
}

uint64_t WiFiDeviceClientTrafficRegistration()
{
  return MEMORY[0x189611830]();
}

uint64_t WiFiManagerClientAddNetwork()
{
  return MEMORY[0x189611838]();
}

uint64_t WiFiManagerClientCopyDevices()
{
  return MEMORY[0x189611840]();
}

uint64_t WiFiManagerClientCopyInterfaces()
{
  return MEMORY[0x189611848]();
}

uint64_t WiFiManagerClientCopyNetworks()
{
  return MEMORY[0x189611850]();
}

uint64_t WiFiManagerClientCreate()
{
  return MEMORY[0x189611858]();
}

uint64_t WiFiManagerClientDisable()
{
  return MEMORY[0x189611860]();
}

uint64_t WiFiManagerClientEnable()
{
  return MEMORY[0x189611868]();
}

uint64_t WiFiManagerClientEnableNetwork()
{
  return MEMORY[0x189611870]();
}

uint64_t WiFiManagerClientGetPower()
{
  return MEMORY[0x189611878]();
}

uint64_t WiFiManagerClientRegisterDeviceAttachmentCallback()
{
  return MEMORY[0x189611880]();
}

uint64_t WiFiManagerClientRegisterServerRestartCallback()
{
  return MEMORY[0x189611888]();
}

uint64_t WiFiManagerClientScheduleWithRunLoop()
{
  return MEMORY[0x189611890]();
}

uint64_t WiFiManagerClientSetWoWState()
{
  return MEMORY[0x189611898]();
}

uint64_t WiFiManagerClientTemporarilyDisableNetwork()
{
  return MEMORY[0x1896118A0]();
}

uint64_t WiFiManagerClientUnscheduleFromRunLoop()
{
  return MEMORY[0x1896118A8]();
}

uint64_t WiFiNetworkCopyPassword()
{
  return MEMORY[0x1896118B0]();
}

uint64_t WiFiNetworkCopyRecord()
{
  return MEMORY[0x1896118B8]();
}

uint64_t WiFiNetworkGetAuthFlags()
{
  return MEMORY[0x1896118C0]();
}

uint64_t WiFiNetworkGetChannel()
{
  return MEMORY[0x1896118C8]();
}

uint64_t WiFiNetworkGetDirectedState()
{
  return MEMORY[0x1896118D0]();
}

uint64_t WiFiNetworkGetIntProperty()
{
  return MEMORY[0x1896118D8]();
}

uint64_t WiFiNetworkGetOperatingBand()
{
  return MEMORY[0x1896118E0]();
}

uint64_t WiFiNetworkGetProperty()
{
  return MEMORY[0x1896118E8]();
}

uint64_t WiFiNetworkGetSSID()
{
  return MEMORY[0x1896118F0]();
}

uint64_t WiFiNetworkGetSSIDData()
{
  return MEMORY[0x1896118F8]();
}

uint64_t WiFiNetworkGetShareMode()
{
  return MEMORY[0x189611900]();
}

uint64_t WiFiNetworkIsAdHoc()
{
  return MEMORY[0x189611908]();
}

uint64_t WiFiNetworkIsCaptive()
{
  return MEMORY[0x189611910]();
}

uint64_t WiFiNetworkIsEAP()
{
  return MEMORY[0x189611918]();
}

uint64_t WiFiNetworkIsHidden()
{
  return MEMORY[0x189611920]();
}

uint64_t WiFiNetworkIsHotspot()
{
  return MEMORY[0x189611928]();
}

uint64_t WiFiNetworkIsHotspot20()
{
  return MEMORY[0x189611930]();
}

uint64_t WiFiNetworkIsOpen()
{
  return MEMORY[0x189611938]();
}

uint64_t WiFiNetworkIsProfileBased()
{
  return MEMORY[0x189611940]();
}

uint64_t WiFiNetworkIsSAE()
{
  return MEMORY[0x189611948]();
}

uint64_t WiFiNetworkIsWEP()
{
  return MEMORY[0x189611950]();
}

uint64_t WiFiNetworkIsWPA()
{
  return MEMORY[0x189611958]();
}

uint64_t WiFiNetworkSetDirectedState()
{
  return MEMORY[0x189611960]();
}

uint64_t WiFiNetworkSetIntProperty()
{
  return MEMORY[0x189611968]();
}

uint64_t WiFiNetworkSetPassword()
{
  return MEMORY[0x189611970]();
}

uint64_t WiFiNetworkSetProperty()
{
  return MEMORY[0x189611978]();
}

uint64_t WiFiNetworkWasCaptive()
{
  return MEMORY[0x189611980]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1895F8720](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x189604550]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x189604568]();
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return MEMORY[0x189604828]();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return MEMORY[0x189604838]();
}

char ***_NSGetEnviron(void)
{
  return (char ***)MEMORY[0x1895F87C8]();
}

uint64_t _SCNetworkInterfaceCreateWithBSDName()
{
  return MEMORY[0x18960C4A8]();
}

uint64_t _SCNetworkInterfaceIsThunderbolt()
{
  return MEMORY[0x18960C4B0]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return MEMORY[0x1895F8880](*(void *)&a1, a2, *(void *)&a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1895F8898]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1895F8918](*(void *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1895F8930]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x1895F8940]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1895F8A08]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1895F8A28](*(void *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1895F8A30](*(void *)&a1);
}

os_activity_t _os_activity_create( void *dso, const char *description, os_activity_t activity, os_activity_flag_t flags)
{
  return (os_activity_t)MEMORY[0x1895F8D40](dso, description, activity, *(void *)&flags);
}

uint64_t _os_crash()
{
  return MEMORY[0x1895F8D78]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1895F8D88]();
}

void _os_log_debug_impl( void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1895F9320](*(void *)&a1, a2, a3);
}

uint32_t arc4random(void)
{
  return MEMORY[0x1895F94C0]();
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1895F9540](a1, a2);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1895F9608](*(void *)&a1, a2, *(void *)&a3);
}

void *__cdecl bsearch( const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x1895F9650](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x1895F9710](__count, __size);
}

uint64_t ccaes_gcm_decrypt_mode()
{
  return MEMORY[0x1895F9790]();
}

uint64_t ccaes_gcm_encrypt_mode()
{
  return MEMORY[0x1895F9798]();
}

uint64_t cccurve25519()
{
  return MEMORY[0x1895F9868]();
}

uint64_t cccurve25519_make_pub()
{
  return MEMORY[0x1895F9880]();
}

uint64_t ccdh_ccn_size()
{
  return MEMORY[0x1895F9A28]();
}

uint64_t ccdh_gp_n()
{
  return MEMORY[0x1895F9A60]();
}

uint64_t cced25519_make_key_pair()
{
  return MEMORY[0x1895F9CE0]();
}

uint64_t cced25519_sign()
{
  return MEMORY[0x1895F9D00]();
}

uint64_t cced25519_verify()
{
  return MEMORY[0x1895F9D10]();
}

uint64_t ccgcm_aad()
{
  return MEMORY[0x1895F9D38]();
}

uint64_t ccgcm_finalize()
{
  return MEMORY[0x1895F9D48]();
}

uint64_t ccgcm_init()
{
  return MEMORY[0x1895F9D60]();
}

uint64_t ccgcm_one_shot()
{
  return MEMORY[0x1895F9D70]();
}

uint64_t ccgcm_reset()
{
  return MEMORY[0x1895F9D78]();
}

uint64_t ccgcm_set_iv()
{
  return MEMORY[0x1895F9D80]();
}

uint64_t ccgcm_update()
{
  return MEMORY[0x1895F9D88]();
}

uint64_t ccrng()
{
  return MEMORY[0x1895FA118]();
}

uint64_t ccsha512_di()
{
  return MEMORY[0x1895FA298]();
}

uint64_t ccsrp_client_process_challenge()
{
  return MEMORY[0x1895FA328]();
}

uint64_t ccsrp_client_start_authentication()
{
  return MEMORY[0x1895FA330]();
}

uint64_t ccsrp_client_verify_session()
{
  return MEMORY[0x1895FA338]();
}

uint64_t ccsrp_ctx_init_option()
{
  return MEMORY[0x1895FA348]();
}

uint64_t ccsrp_generate_salt_and_verification()
{
  return MEMORY[0x1895FA358]();
}

uint64_t ccsrp_get_session_key_length()
{
  return MEMORY[0x1895FA370]();
}

uint64_t ccsrp_gp_rfc5054_3072()
{
  return MEMORY[0x1895FA388]();
}

uint64_t ccsrp_server_compute_session()
{
  return MEMORY[0x1895FA3A8]();
}

uint64_t ccsrp_server_generate_public_key()
{
  return MEMORY[0x1895FA3B0]();
}

uint64_t ccsrp_server_verify_session()
{
  return MEMORY[0x1895FA3C0]();
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x1895FA538](a1, a2);
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return MEMORY[0x1895FA570](*(void *)&__clock_id, __tp);
}

int close(int a1)
{
  return MEMORY[0x1895FA590](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1895FA5A8](a1);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1895FA5F0](*(void *)&a1, a2, *(void *)&a3);
}

int deflate(z_streamp strm, int flush)
{
  return MEMORY[0x189617580](strm, *(void *)&flush);
}

int deflateEnd(z_streamp strm)
{
  return MEMORY[0x189617590](strm);
}

int deflateInit2_( z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  return MEMORY[0x189617598]( strm,  *(void *)&level,  *(void *)&method,  *(void *)&windowBits,  *(void *)&memLevel,  *(void *)&strategy,  version,  *(void *)&stream_size);
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_queue_t dispatch_get_current_queue(void)
{
  return (dispatch_queue_t)MEMORY[0x1895FAC38]();
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1895FAC60]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency( dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1895FAD68](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class( dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1895FAD78](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1895FAD80](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2( const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1895FAD90](label, attr, target);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  return (const char *)MEMORY[0x1895FAD98](queue);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(uint64_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1895FADF0](value);
}

uint64_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1895FAE00](dsema);
}

uint64_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1895FAE08](dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create( dispatch_source_type_t type, uintptr_t handle, unint64_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1895FAE50](type, handle, mask, queue);
}

unint64_t dispatch_source_get_data(dispatch_source_t source)
{
  return MEMORY[0x1895FAE58](source);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_cancel_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_timer( dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1895FAEE8](when, delta);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1895FAF60](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1895FAF78](__handle, __symbol);
}

void exit(int a1)
{
}

int fclose(FILE *a1)
{
  return MEMORY[0x1895FB208](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1895FB210](*(void *)&a1, *(void *)&a2);
}

int feof(FILE *a1)
{
  return MEMORY[0x1895FB248](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1895FB268](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x1895FB290](a1, *(void *)&a2, a3);
}

int fileno(FILE *a1)
{
  return MEMORY[0x1895FB2A0](a1);
}

double fmod(double a1, double a2)
{
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1895FB348](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1895FB360](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1895FB370](*(void *)&a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1895FB378](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1895FB388](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

void freeaddrinfo(addrinfo *a1)
{
}

void freeifaddrs(ifaddrs *a1)
{
}

int fseeko(FILE *__stream, off_t a2, int __whence)
{
  return MEMORY[0x1895FB428](__stream, a2, *(void *)&__whence);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1895FB448](*(void *)&a1, a2);
}

off_t ftello(FILE *__stream)
{
  return MEMORY[0x1895FB478](__stream);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1895FB4C8](__ptr, __size, __nitems, __stream);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return MEMORY[0x1895FB4E0](a1, a2, a3, a4);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1895FB538](a1);
}

int gethostuuid(uuid_t a1, const timespec *a2)
{
  return MEMORY[0x1895FB598](a1, a2);
}

int getifaddrs(ifaddrs **a1)
{
  return MEMORY[0x1895FB5A0](a1);
}

int getpeername(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1895FB610](*(void *)&a1, a2, a3);
}

pid_t getpid(void)
{
  return MEMORY[0x1895FB628]();
}

const char *getprogname(void)
{
  return (const char *)MEMORY[0x1895FB638]();
}

passwd *__cdecl getpwnam(const char *a1)
{
  return (passwd *)MEMORY[0x1895FB660](a1);
}

int getpwnam_r(const char *a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x1895FB668](a1, a2, a3, a4, a5);
}

int getpwuid_r(uid_t a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x1895FB678](*(void *)&a1, a2, a3, a4, a5);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1895FB6D0](*(void *)&a1, a2, a3);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return MEMORY[0x1895FB6D8](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1895FB6E0](a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x1895FB6E8]();
}

tm *__cdecl gmtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1895FB720](a1);
}

tm *__cdecl gmtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1895FB728](a1, a2);
}

char *__cdecl if_indextoname(unsigned int a1, char *a2)
{
  return (char *)MEMORY[0x1895FB7C8](*(void *)&a1, a2);
}

unsigned int if_nametoindex(const char *a1)
{
  return MEMORY[0x1895FB7D8](a1);
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x189617608](strm, *(void *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x189617610](strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return MEMORY[0x189617618](strm, *(void *)&windowBits, version, *(void *)&stream_size);
}

int ioctl(int a1, unint64_t a2, ...)
{
  return MEMORY[0x1895FB850](*(void *)&a1, a2);
}

int isatty(int a1)
{
  return MEMORY[0x1895FB868](*(void *)&a1);
}

int listen(int a1, int a2)
{
  return MEMORY[0x1895FB9F8](*(void *)&a1, *(void *)&a2);
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1895FBA18](a1);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1895FBA80](*(void *)&a1, a2, *(void *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1895FBA88](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1895FBA98]();
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1895FBB28](*(void *)&task, *(void *)&name);
}

mach_port_t mach_thread_self(void)
{
  return MEMORY[0x1895FBBF0]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1895FBBF8](info);
}

kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags)
{
  return MEMORY[0x1895FBC00](*(void *)&target, address, size, *(void *)&flags);
}

kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  return MEMORY[0x1895FBC10](*(void *)&target, address, size);
}

kern_return_t mach_vm_remap( vm_map_t target_task, mach_vm_address_t *target_address, mach_vm_size_t size, mach_vm_offset_t mask, int flags, vm_map_t src_task, mach_vm_address_t src_address, BOOLean_t copy, vm_prot_t *cur_protection, vm_prot_t *max_protection, vm_inherit_t inheritance)
{
  return MEMORY[0x1895FBC50]( *(void *)&target_task,  target_address,  size,  mask,  *(void *)&flags,  *(void *)&src_task,  src_address,  *(void *)&copy);
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x1895FBC88](__size);
}

void *__cdecl memchr(const void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1895FBE00](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1895FBE08](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1895FBE18](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1895FBE30](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1895FBE48](__b, *(void *)&__c, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return MEMORY[0x1895FBE68](__s, __smax, *(void *)&__c, __n);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1895FBEF0](a1, a2);
}

int mkstemp(char *a1)
{
  return MEMORY[0x1895FBF38](a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1895FBF70](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

double modf(double a1, double *a2)
{
  return result;
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1895FBF98](a1, a2);
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  return MEMORY[0x1895FBFB0](__rqtp, __rmtp);
}

int nftw(const char *a1, int (__cdecl *a2)(const char *, const stat *, int, FTW *), int a3, int a4)
{
  return MEMORY[0x1895FC170](a1, a2, *(void *)&a3, *(void *)&a4);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1895FC188](*(void *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1895FC198](*(void *)&token, state64);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1895FC1B0](name);
}

uint32_t notify_register_dispatch( const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1895FC1C0](name, out_token, queue, handler);
}

const char *__cdecl nw_interface_get_name(nw_interface_t interface)
{
  return (const char *)MEMORY[0x189609810](interface);
}

nw_parameters_t nw_parameters_create(void)
{
  return (nw_parameters_t)MEMORY[0x1896099E0]();
}

void nw_parameters_prohibit_interface_type(nw_parameters_t parameters, nw_interface_type_t interface_type)
{
}

uint64_t nw_parameters_set_avoided_netagent_classes()
{
  return MEMORY[0x189609B00]();
}

uint64_t nw_path_copy_interface()
{
  return MEMORY[0x189609D10]();
}

uint64_t nw_path_create_evaluator_for_endpoint()
{
  return MEMORY[0x189609D48]();
}

uint64_t nw_path_evaluator_cancel()
{
  return MEMORY[0x189609D58]();
}

uint64_t nw_path_evaluator_copy_path()
{
  return MEMORY[0x189609D68]();
}

uint64_t nw_path_evaluator_set_update_handler()
{
  return MEMORY[0x189609D88]();
}

nw_path_status_t nw_path_get_status(nw_path_t path)
{
  return MEMORY[0x189609E68](path);
}

void nw_path_monitor_cancel(nw_path_monitor_t monitor)
{
}

nw_path_monitor_t nw_path_monitor_create(void)
{
  return (nw_path_monitor_t)MEMORY[0x189609EE0]();
}

void nw_path_monitor_set_queue(nw_path_monitor_t monitor, dispatch_queue_t queue)
{
}

void nw_path_monitor_set_update_handler( nw_path_monitor_t monitor, nw_path_monitor_update_handler_t update_handler)
{
}

void nw_path_monitor_start(nw_path_monitor_t monitor)
{
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1896165B0](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1896165C0]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1896165D8](a1);
}

void objc_autoreleasePoolPop(void *context)
{
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1896165E8]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1896165F0](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1896165F8](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x189616600]();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

id objc_getAssociatedObject(id object, const void *key)
{
  return (id)MEMORY[0x1896166A8](object, key);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1896166B8](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1896166C8](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1896166D8](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x189616700](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x189616728](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x189616730]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x189616738]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x189616748]();
}

uint64_t objc_opt_self()
{
  return MEMORY[0x189616750]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x189616818](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x189616820](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x189616828](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x189616830](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x189616838](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x189616978](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x189616980](obj);
}

void objc_terminate(void)
{
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1895FC248](a1, *(void *)&a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1895FC278](a1);
}

void os_activity_scope_enter(os_activity_t activity, os_activity_scope_state_t state)
{
}

void os_activity_scope_leave(os_activity_scope_state_t state)
{
}

uint64_t os_channel_advance_slot()
{
  return MEMORY[0x1895FC2F0]();
}

uint64_t os_channel_attr_create()
{
  return MEMORY[0x1895FC2F8]();
}

uint64_t os_channel_attr_destroy()
{
  return MEMORY[0x1895FC300]();
}

uint64_t os_channel_attr_get()
{
  return MEMORY[0x1895FC308]();
}

uint64_t os_channel_get_fd()
{
  return MEMORY[0x1895FC370]();
}

uint64_t os_channel_get_next_slot()
{
  return MEMORY[0x1895FC388]();
}

uint64_t os_channel_read_attr()
{
  return MEMORY[0x1895FC3C0]();
}

uint64_t os_channel_ring_id()
{
  return MEMORY[0x1895FC3C8]();
}

uint64_t os_channel_rx_ring()
{
  return MEMORY[0x1895FC3D0]();
}

uint64_t os_channel_set_slot_properties()
{
  return MEMORY[0x1895FC3D8]();
}

uint64_t os_channel_sync()
{
  return MEMORY[0x1895FC3F8]();
}

uint64_t os_channel_tx_ring()
{
  return MEMORY[0x1895FC400]();
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1895FC440](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1895FC470](oslog, type);
}

uint64_t os_state_add_handler()
{
  return MEMORY[0x1895FC620]();
}

uint64_t os_state_remove_handler()
{
  return MEMORY[0x1895FC628]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_allows_internal_security_policies()
{
  return MEMORY[0x1895FC6A8]();
}

uint64_t os_variant_has_internal_content()
{
  return MEMORY[0x1895FC6C0]();
}

uint64_t os_variant_is_recovery()
{
  return MEMORY[0x1895FC6E0]();
}

int pclose(FILE *a1)
{
  return MEMORY[0x1895FC778](a1);
}

int pipe(int a1[2])
{
  return MEMORY[0x1895FC7B0](a1);
}

FILE *__cdecl popen(const char *a1, const char *a2)
{
  return (FILE *)MEMORY[0x1895FC7C8](a1, a2);
}

int posix_spawn( pid_t *a1, const char *a2, const posix_spawn_file_actions_t *a3, const posix_spawnattr_t *a4, char *const __argv[], char *const __envp[])
{
  return MEMORY[0x1895FC7E0](a1, a2, a3, a4, __argv, __envp);
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1895FC890](a1);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return MEMORY[0x1895FC8E0](*(void *)&pid, *(void *)&flavor, arg, buffer, *(void *)&buffersize);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x1895FC9A0](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x1895FC9A8](a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return MEMORY[0x1895FC9B0](a1);
}

int pthread_cond_timedwait(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return MEMORY[0x1895FC9B8](a1, a2, a3);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1895FC9D8](a1, a2, a3, a4);
}

int pthread_getname_np(pthread_t a1, char *a2, size_t a3)
{
  return MEMORY[0x1895FCA30](a1, a2, a3);
}

int pthread_getschedparam(pthread_t a1, int *a2, sched_param *a3)
{
  return MEMORY[0x1895FCA38](a1, a2, a3);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x1895FCA58](a1, a2);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x1895FCA70](a1);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1895FCA88](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1895FCA90](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1895FCA98](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1895FCAA8](a1);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1895FCB20]();
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x1895FCB38](a1);
}

int pthread_setschedparam(pthread_t a1, int a2, const sched_param *a3)
{
  return MEMORY[0x1895FCB40](a1, *(void *)&a2, a3);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1895FCC38](*(void *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1895FCC40](a1);
}

void *__cdecl realloc(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1895FCC68](__ptr, __size);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1895FCC80](a1, a2);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return MEMORY[0x1895FCCA8](*(void *)&a1, a2, a3, *(void *)&a4);
}

ssize_t recvfrom(int a1, void *a2, size_t a3, int a4, sockaddr *a5, socklen_t *a6)
{
  return MEMORY[0x1895FCCB0](*(void *)&a1, a2, a3, *(void *)&a4, a5, a6);
}

ssize_t recvmsg(int a1, msghdr *a2, int a3)
{
  return MEMORY[0x1895FCCB8](*(void *)&a1, a2, *(void *)&a3);
}

int remove(const char *a1)
{
  return MEMORY[0x1895FCD08](a1);
}

int rename(const char *__old, const char *__new)
{
  return MEMORY[0x1895FCD50](__old, __new);
}

int select(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  return MEMORY[0x1895FCE10](*(void *)&a1, a2, a3, a4, a5);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return MEMORY[0x1895FCE30](*(void *)&a1, a2, a3, *(void *)&a4);
}

ssize_t sendmsg(int a1, const msghdr *a2, int a3)
{
  return MEMORY[0x1895FCE38](*(void *)&a1, a2, *(void *)&a3);
}

ssize_t sendto(int a1, const void *a2, size_t a3, int a4, const sockaddr *a5, socklen_t a6)
{
  return MEMORY[0x1895FCE48](*(void *)&a1, a2, a3, *(void *)&a4, a5, *(void *)&a6);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x1895FCEC8](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, *(void *)&a5);
}

int setuid(uid_t a1)
{
  return MEMORY[0x1895FCED0](*(void *)&a1);
}

int setvbuf(FILE *a1, char *a2, int a3, size_t a4)
{
  return MEMORY[0x1895FCED8](a1, a2, *(void *)&a3, a4);
}

int shutdown(int a1, int a2)
{
  return MEMORY[0x1895FCEF8](*(void *)&a1, *(void *)&a2);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return (void (__cdecl *)(int))MEMORY[0x1895FCF50](*(void *)&a1, a2);
}

double sin(double a1)
{
  return result;
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1895FCF88](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1895FCF90](__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x1895FCFA0](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1895FCFD0](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1895FD010](a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x1895FD030](a1, a2);
}

char *__cdecl strchr(const char *__s, int __c)
{
  return (char *)MEMORY[0x1895FD048](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1895FD050](__s1, __s2);
}

size_t strcspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1895FD070](__s, __charset);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1895FD078](__s1);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x1895FD090](a1, a2, a3, a4);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1895FD0A0](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1895FD0B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1895FD0B8](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1895FD0D0](a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1895FD0E8](__s1, __s2, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return (char *)MEMORY[0x1895FD108](__big, __little, __len);
}

char *__cdecl strrchr(const char *__s, int __c)
{
  return (char *)MEMORY[0x1895FD120](__s, *(void *)&__c);
}

char *__cdecl strsep(char **__stringp, const char *__delim)
{
  return (char *)MEMORY[0x1895FD128](__stringp, __delim);
}

size_t strspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1895FD140](__s, __charset);
}

char *__cdecl strstr(const char *__big, const char *__little)
{
  return (char *)MEMORY[0x1895FD148](__big, __little);
}

double strtod(const char *a1, char **a2)
{
  return result;
}

char *__cdecl strtok_r(char *__str, const char *__sep, char **__lasts)
{
  return (char *)MEMORY[0x1895FD178](__str, __sep, __lasts);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1895FD180](__str, __endptr, *(void *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1895FD1B8](__str, __endptr, *(void *)&__base);
}

uint64_t sysconf(int a1)
{
  return MEMORY[0x1895FD2A8](*(void *)&a1);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1895FD2B0](a1, *(void *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1895FD2B8](a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
}

int tcgetattr(int a1, termios *a2)
{
  return MEMORY[0x1895FD380](*(void *)&a1, a2);
}

int tcsetattr(int a1, int a2, const termios *a3)
{
  return MEMORY[0x1895FD390](*(void *)&a1, *(void *)&a2, a3);
}

kern_return_t thread_info( thread_inspect_t target_act, thread_flavor_t flavor, thread_info_t thread_info_out, mach_msg_type_number_t *thread_info_outCnt)
{
  return MEMORY[0x1895FD3B0](*(void *)&target_act, *(void *)&flavor, thread_info_out, thread_info_outCnt);
}

kern_return_t thread_policy_get( thread_inspect_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t *policy_infoCnt, BOOLean_t *get_default)
{
  return MEMORY[0x1895FD3B8](*(void *)&thread, *(void *)&flavor, policy_info, policy_infoCnt, get_default);
}

kern_return_t thread_policy_set( thread_act_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return MEMORY[0x1895FD3C0](*(void *)&thread, *(void *)&flavor, policy_info, *(void *)&policy_infoCnt);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1895FD400](a1);
}

int unlink(const char *a1)
{
  return MEMORY[0x1895FD468](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1895FD490](*(void *)&a1);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1895FD610](__str, __size, __format, a4);
}

pid_t waitpid(pid_t a1, int *a2, int a3)
{
  return MEMORY[0x1895FD638](*(void *)&a1, a2, *(void *)&a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1895FD750](*(void *)&__fd, __buf, __nbyte);
}

ssize_t writev(int a1, const iovec *a2, int a3)
{
  return MEMORY[0x1895FD760](*(void *)&a1, a2, *(void *)&a3);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return MEMORY[0x1895FD7C8](xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1895FD7D8](objects, count);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x1895FD808](xarray);
}

void xpc_array_set_double(xpc_object_t xarray, size_t index, double value)
{
}

void xpc_array_set_int64(xpc_object_t xarray, size_t index, int64_t value)
{
}

void xpc_array_set_string(xpc_object_t xarray, size_t index, const char *string)
{
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return MEMORY[0x1895FD8C0](xBOOL);
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

uint64_t xpc_connection_copy_entitlement_value()
{
  return MEMORY[0x1895FD930]();
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1895FD968](name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_barrier(xpc_connection_t connection, dispatch_block_t barrier)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_send_message_with_reply( xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

uint64_t xpc_connection_set_target_uid()
{
  return MEMORY[0x1895FDA58]();
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return (char *)MEMORY[0x1895FDA98](object);
}

uint64_t xpc_copy_entitlement_for_token()
{
  return MEMORY[0x1895FDAB0]();
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return (xpc_object_t)MEMORY[0x1895FDB00](bytes, length);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return (const void *)MEMORY[0x1895FDB20](xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return MEMORY[0x1895FDB30](xdata);
}

int64_t xpc_date_get_value(xpc_object_t xdate)
{
  return MEMORY[0x1895FDB58](xdate);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return MEMORY[0x1895FDB78](xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1895FDB98](keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return (xpc_object_t)MEMORY[0x1895FDBB0](original);
}

uint64_t xpc_dictionary_expects_reply()
{
  return MEMORY[0x1895FDBC0]();
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1895FDBE8](xdict, key);
}

size_t xpc_dictionary_get_count(xpc_object_t xdict)
{
  return MEMORY[0x1895FDBF8](xdict);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x1895FDC00](xdict, key, length);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  return result;
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1895FDC20](xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1895FDC48](xdict, key);
}

const uint8_t *__cdecl xpc_dictionary_get_uuid(xpc_object_t xdict, const char *key)
{
  return (const uint8_t *)MEMORY[0x1895FDC58](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1895FDC68](xdict, key);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uuid(xpc_object_t xdict, const char *key, const unsigned __int8 *uuid)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  return result;
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1895FDE70](object);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return MEMORY[0x1895FDEC8](xint);
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1895FDF88](object);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return (const char *)MEMORY[0x1895FE080](xstring);
}

uint64_t xpc_uint64_get_value(xpc_object_t xuint)
{
  return MEMORY[0x1895FE0E0](xuint);
}

const uint8_t *__cdecl xpc_uuid_get_bytes(xpc_object_t xuuid)
{
  return (const uint8_t *)MEMORY[0x1895FE110](xuuid);
}

uint64_t objc_msgSend__getPairingIdentityForLegacyWithOptions_user_nonLegacyIdentity_label_completion_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718](a1, sel__getPairingIdentityForLegacyWithOptions_user_nonLegacyIdentity_label_completion_);
}

uint64_t objc_msgSend__publisher_dataConfirmedForHandle_localInterfaceIndex_serviceSpecificInfo_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718](a1, sel__publisher_dataConfirmedForHandle_localInterfaceIndex_serviceSpecificInfo_);
}

uint64_t objc_msgSend_decryptInputBytes_inputLength_inputAADBytes_inputAADLength_inputAuthTagPtr_inputAuthTagLength_outputBytes_error_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718]( a1,  sel_decryptInputBytes_inputLength_inputAADBytes_inputAADLength_inputAuthTagPtr_inputAuthTagLength_outputBytes_error_);
}

uint64_t objc_msgSend_encryptInputBytes_inputLength_inputAADBytes_inputAADLength_outputBytes_outputAuthTagBytes_outputAuthTagLength_error_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718]( a1,  sel_encryptInputBytes_inputLength_inputAADBytes_inputAADLength_outputBytes_outputAuthTagBytes_outputAuthTagLength_error_);
}

uint64_t objc_msgSend_fetchLocationsOfInterestVisitedBetweenStartDate_endDate_withHandler_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718](a1, sel_fetchLocationsOfInterestVisitedBetweenStartDate_endDate_withHandler_);
}