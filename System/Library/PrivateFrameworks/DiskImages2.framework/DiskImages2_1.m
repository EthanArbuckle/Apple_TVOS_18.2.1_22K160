void di_log::logger_buf<di_log::log_printer<37ul>>::~logger_buf(uint64_t a1)
{
  void *v1;
  v1 = (void *)di_log::logger_buf<di_log::log_printer<37ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<37ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<37ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880DDC10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<37ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 37LL;
    __int16 v22 = 2082;
    v23 = v8;
    v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 37LL;
      __int16 v22 = 2082;
      v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  result = __error();
  int *result = v5;
  return result;
}

void *di_log::logger<di_log::log_printer<41ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<41ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1DE9B8;
  a1[45] = &unk_18A1DEAB8;
  a1[46] = &unk_18A1DEAE0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1DE9B8;
  a1[45] = &unk_18A1DEA40;
  a1[46] = &unk_18A1DEA68;
  return a1;
}

void sub_1880DDF5C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<41ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<41ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DEB50;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DE028(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<41ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1DEB50;
  di_log::logger_buf<di_log::log_printer<41ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<41ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<41ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<41ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<41ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<41ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<41ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<41ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<41ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<41ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<41ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<41ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<41ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<41ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880DE3DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<41ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 41LL;
    __int16 v22 = 2082;
    v23 = v8;
    v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 41LL;
      __int16 v22 = 2082;
      v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  result = __error();
  int *result = v5;
  return result;
}

uint64_t di_log::logger_buf<di_log::log_printer<46ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DA6F8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DE650(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<59ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DA918;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DE6CC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<80ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DAB38;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DE748(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<101ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DAD58;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DE7C4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<107ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DAF78;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DE840(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<111ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DB198;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DE8BC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<154ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DB3B8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DE938(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<165ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DB5D8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DE9B4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<172ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DB7F8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DEA30(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<190ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DBA18;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DEAAC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<194ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DBC38;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DEB28(_Unwind_Exception *a1)
{
}

void boost::container::vector<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>*,std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>>>( void **a1@<X0>, char *a2@<X1>, const char *a3@<X2>, _OWORD *a4@<X3>, void *a5@<X8>)
{
  v10 = *a1;
  unint64_t v11 = boost::container::vector_alloc_holder<boost::container::small_vector_allocator<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( (uint64_t)a1,  a3);
  if (v11 >> 59) {
    boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v12);
  }
  uint64_t v13 = (char *)v11;
  v14 = operator new(16 * v11);
  boost::container::vector<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>*,std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>>>( a1,  v14,  v13,  a2,  (uint64_t)a3,  a4);
  *a5 = (char *)*a1 + a2 - v10;
}

unint64_t boost::container::vector_alloc_holder<boost::container::small_vector_allocator<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( uint64_t a1, const char *a2)
{
  unint64_t v2 = 0x7FFFFFFFFFFFFFFLL;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = v4 >> 61;
  unint64_t v6 = 8 * v4;
  if (v5 > 4) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = v6 / 5;
  if (v5) {
    unint64_t v8 = v7;
  }
  v9 = &a2[v3];
  if (v8 < 0x7FFFFFFFFFFFFFFLL) {
    unint64_t v2 = v8;
  }
  else {
    return (unint64_t)v9;
  }
}

void boost::container::vector<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>*,std::pair<std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,unsigned long>>>( void **a1, _OWORD *__dst, char *a3, char *__src, uint64_t a5, _OWORD *a6)
{
  os_log_type_t v12 = (char *)*a1;
  uint64_t v13 = (char *)a1[1];
  if (*a1) {
    BOOL v14 = __dst == 0LL;
  }
  else {
    BOOL v14 = 1;
  }
  BOOL v15 = v14 || v12 == __src;
  v16 = __dst;
  if (!v15)
  {
    memmove(__dst, v12, __src - v12);
    v16 = (_OWORD *)((char *)__dst + __src - v12);
  }

  _OWORD *v16 = *a6;
  if (__src)
  {
    int v17 = &v12[16 * (void)v13];
    if (v17 != __src && v16 != 0LL) {
      memmove(&v16[a5], __src, v17 - __src);
    }
  }

  if (v12 && a1 + 3 != *a1) {
    operator delete(*a1);
  }
  uint64_t v19 = (char *)a1[1] + a5;
  *a1 = __dst;
  a1[1] = v19;
  a1[2] = a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<213ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DBE58;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DED84(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<218ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DC078;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DEE00(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<222ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DC298;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DEE7C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<231ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DC4B8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DEEF8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<235ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DC6D8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DEF74(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<237ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DC8F8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DEFF0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<284ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DCB18;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DF06C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<295ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DCD38;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DF0E8(_Unwind_Exception *a1)
{
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<DiskImageSparseBundle::void_stackable_identifier(void)::$_0 &&>>( di_utils *a1)
{
  uint64_t v1 = **(uint64_t ***)a1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 560);
  *(void *)(v3 + 136) = di_utils::random_uuid(a1);
  *(void *)(v3 + 144) = v4;
  SparseBundleBackend::write_info_plists(*(SparseBundleBackend **)(v2 + 560));
}

void sub_1880DF144( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11, int a12, int a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60)
{
  uint64_t v64 = v60;
  if (a2 == 1)
  {
    v61 = __cxa_begin_catch(exception_object);
    *(void *)&a11 = "DiskImageSparseBundle::void_stackable_identifier()::(anonymous class)::operator()() const";
    *((void *)&a11 + 1) = 81LL;
    a12 = 16;
    di_log::logger<di_log::log_printer<307ul>>::logger(&a14, &a11);
    operator<<(&a59, (uint64_t)v61);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<307ul>>::~logger_buf((uint64_t)&a14);
    MEMORY[0x1895BC2CC](&a60);
    int v62 = v61[2];
    if (v62 < 0) {
      int v63 = v61[2];
    }
    else {
      int v63 = -v62;
    }
    **(_DWORD **)(v64 + 8) = v63;
    __cxa_end_catch();
    JUMPOUT(0x1880DF130LL);
  }

  _Unwind_Resume(exception_object);
}

void *di_log::logger<di_log::log_printer<307ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<307ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1DEBD8;
  a1[45] = &unk_18A1DECD8;
  a1[46] = &unk_18A1DED00;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1DEBD8;
  a1[45] = &unk_18A1DEC60;
  a1[46] = &unk_18A1DEC88;
  return a1;
}

void sub_1880DF2A4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<307ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<307ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DED70;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DF370(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<307ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1DED70;
  di_log::logger_buf<di_log::log_printer<307ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<307ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<307ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<307ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<307ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<307ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<307ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<307ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<307ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<307ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<307ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<307ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<307ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<307ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880DF724( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<307ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 307LL;
    __int16 v22 = 2082;
    v23 = v8;
    v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        BOOL v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 307LL;
      __int16 v22 = 2082;
      v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  result = __error();
  int *result = v5;
  return result;
}

uint64_t boost::icl::cardinality<boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( void *a1)
{
  uint64_t v1 = boost::icl::identity_element<unsigned long>::value(void)::_value;
  unsigned __int8 v2 = a1 + 1;
  uint64_t v3 = (void *)*a1;
  if ((void *)*a1 != a1 + 1)
  {
    do
    {
      uint64_t v4 = boost::icl::cardinality<boost::icl::discrete_interval<unsigned long long,std::less>>(v3 + 4);
      int v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          char v6 = v5;
          int v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          char v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }

        while (!v7);
      }

      v1 += v4;
      uint64_t v3 = v6;
    }

    while (v6 != v2);
  }

  return v1;
}

uint64_t boost::icl::cardinality<boost::icl::discrete_interval<unsigned long long,std::less>>( unint64_t *a1)
{
  unsigned int v1 = *((unsigned __int8 *)a1 + 16);
  if (*((_BYTE *)a1 + 16))
  {
    if (v1 == 3)
    {
      unint64_t v3 = *a1;
      unint64_t v2 = a1[1];
      if (v2 >= *a1) {
        return (v1 & 1) + (uint64_t)(int)(((v1 >> 1) & 1) - 1) + v2 - v3;
      }
    }

    else
    {
      unint64_t v3 = *a1;
      unint64_t v2 = a1[1];
      if (*a1 < v2) {
        return (v1 & 1) + (uint64_t)(int)(((v1 >> 1) & 1) - 1) + v2 - v3;
      }
    }
  }

  else
  {
    unint64_t v3 = *a1;
    unint64_t v2 = a1[1];
    if (*a1 < v2 && *a1 + 1 < v2) {
      return (v1 & 1) + (uint64_t)(int)(((v1 >> 1) & 1) - 1) + v2 - v3;
    }
  }

  return boost::icl::identity_element<unsigned long>::value(void)::_value;
}

uint64_t di_log::logger_buf<di_log::log_printer<387ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DD178;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DFA80(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<390ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DD398;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DFAFC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<434ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DD5B8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DFB78(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<443ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DD7D8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DFBF4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<460ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DD9F8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DFC70(_Unwind_Exception *a1)
{
}

uint64_t std::set<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::set[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)a1 = a1 + 8;
  std::set<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::insert[abi:ne180100]<std::__tree_const_iterator<boost::icl::discrete_interval<unsigned long long,std::less>,std::__tree_node<boost::icl::discrete_interval<unsigned long long,std::less>,void *> *,long>>( (_OWORD *)a1,  *(void **)a2,  (void *)(a2 + 8));
  return a1;
}

void sub_1880DFCC0(_Unwind_Exception *a1)
{
}

_OWORD *std::set<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::insert[abi:ne180100]<std::__tree_const_iterator<boost::icl::discrete_interval<unsigned long long,std::less>,std::__tree_node<boost::icl::discrete_interval<unsigned long long,std::less>,void *> *,long>>( _OWORD *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    char v4 = a2;
    __int128 v5 = (uint64_t **)result;
    char v6 = (uint64_t *)result + 1;
    do
    {
      result = std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::__emplace_hint_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::discrete_interval<unsigned long long,std::less> const&>( v5,  v6,  (uint64_t)(v4 + 4),  (uint64_t)(v4 + 4));
      BOOL v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          BOOL v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          char v4 = v8;
        }

        while (!v9);
      }

      char v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

_OWORD *std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::__emplace_hint_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::discrete_interval<unsigned long long,std::less> const&>( uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  char v6 = std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( a1,  a2,  &v11,  &v10,  a3);
  BOOL v7 = (_OWORD *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    BOOL v7 = operator new(0x38uLL);
    v7[2] = *(_OWORD *)a4;
    *((void *)v7 + 6) = *(void *)(a4 + 16);
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  (uint64_t)v11,  v8,  (uint64_t *)v7);
  }

  return v7;
}

uint64_t di_log::logger_buf<di_log::log_printer<469ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DDC18;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880DFE50(_Unwind_Exception *a1)
{
}

uint64_t *std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::erase( uint64_t **a1, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    char v4 = a2;
    do
    {
      char v6 = std::__tree<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>>>::__remove_node_pointer( a1,  v4);
      operator delete(v4);
      char v4 = v6;
    }

    while (v6 != a3);
  }

  return a3;
}

uint64_t **boost::icl::interval_base_set<boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::_add( uint64_t **a1, uint64_t a2)
{
  if (!*(_BYTE *)(a2 + 16))
  {
    unint64_t v11 = *(void *)(a2 + 8);
    if (*(void *)a2 < v11 && *(void *)a2 + 1LL < v11) {
      goto LABEL_4;
    }
    return a1 + 1;
  }

  if (*(_BYTE *)(a2 + 16) == 3)
  {
    if (*(void *)(a2 + 8) >= *(void *)a2) {
      goto LABEL_4;
    }
    return a1 + 1;
  }

  if (*(void *)a2 >= *(void *)(a2 + 8)) {
    return a1 + 1;
  }
LABEL_4:
  char v4 = (uint64_t *)std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::__emplace_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::discrete_interval<unsigned long long,std::less> const&>( a1,  a2,  a2);
  if ((v5 & 1) != 0)
  {
    uint64_t v13 = v4;
    boost::icl::segmental::join_left<boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( a1,  &v13);
    return boost::icl::segmental::join_right<boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( a1,  (uint64_t ***)&v13);
  }

  else
  {
    char v6 = (void *)std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::upper_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  a2);
    BOOL v7 = (void *)*v6;
    if (*v6)
    {
      do
      {
        uint64_t v8 = v7;
        BOOL v7 = (void *)v7[1];
      }

      while (v7);
    }

    else
    {
      do
      {
        uint64_t v8 = (void *)v6[2];
        BOOL v9 = *v8 == (void)v6;
        char v6 = v8;
      }

      while (v9);
    }

    return boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::add_over( a1,  (unint64_t *)a2,  (uint64_t)v8);
  }

uint64_t **boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::add_over( uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  char v5 = (uint64_t *)boost::icl::segmental::join_under<boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( a1,  a2,  a3);
  boost::icl::segmental::join_left<boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( a1,  &v5);
  return boost::icl::segmental::join_right<boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( a1,  (uint64_t ***)&v5);
}

_OWORD *std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::__emplace_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::discrete_interval<unsigned long long,std::less> const&>( uint64_t **a1, uint64_t a2, uint64_t a3)
{
  char v5 = (void **)std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  &v9,  a2);
  char v6 = *v5;
  if (!*v5)
  {
    BOOL v7 = (uint64_t **)v5;
    char v6 = operator new(0x38uLL);
    v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  v9,  v7,  (uint64_t *)v6);
  }

  return v6;
}

uint64_t *boost::icl::segmental::join_left<boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( uint64_t **a1, uint64_t **a2)
{
  unint64_t v2 = *a2;
  if (*a2 == *a1) {
    return *a1;
  }
  uint64_t v4 = *v2;
  if (*v2)
  {
    do
    {
      uint64_t v5 = v4;
      uint64_t v4 = *(void *)(v4 + 8);
    }

    while (v4);
  }

  else
  {
    uint64_t v6 = (uint64_t)*a2;
    do
    {
      uint64_t v5 = *(void *)(v6 + 16);
      BOOL v7 = *(void *)v5 == v6;
      uint64_t v6 = v5;
    }

    while (v7);
  }

  uint64_t v8 = v2[4];
  if ((v2[6] & 2) == 0) {
    ++v8;
  }
  if (v8 == (*(_BYTE *)(v5 + 48) & 1) + *(void *)(v5 + 40))
  {
    __int128 v14 = *((_OWORD *)v2 + 2);
    uint64_t v15 = v2[6];
    std::__tree<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>>>::__remove_node_pointer( a1,  v2);
    operator delete(v2);
    __int128 v10 = *(_OWORD *)(v5 + 32);
    uint64_t v11 = *(void *)(v5 + 48);
    boost::icl::hull<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)&v10,  (unint64_t *)&v14,  (uint64_t)&v12);
    *(_OWORD *)(v5 + 32) = v12;
    *(_BYTE *)(v5 + 48) = v13;
    *a2 = (uint64_t *)v5;
    return (uint64_t *)v5;
  }

  return v2;
}

uint64_t **boost::icl::segmental::join_right<boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( uint64_t **a1, uint64_t ***a2)
{
  unint64_t v3 = a1 + 1;
  result = *a2;
  if (*a2 == v3) {
    return v3;
  }
  uint64_t v6 = result[1];
  if (v6)
  {
    do
    {
      BOOL v7 = (uint64_t **)v6;
      uint64_t v6 = (uint64_t *)*v6;
    }

    while (v6);
  }

  else
  {
    uint64_t v8 = *a2;
    do
    {
      BOOL v7 = (uint64_t **)v8[2];
      BOOL v9 = *v7 == (uint64_t *)v8;
      uint64_t v8 = v7;
    }

    while (!v9);
  }

  if (v7 != v3)
  {
    __int128 v10 = v7[4];
    if (((_BYTE)v7[6] & 2) == 0) {
      __int128 v10 = (uint64_t *)((char *)v10 + 1);
    }
    if (v10 == (uint64_t *)((char *)result[5] + ((_BYTE)result[6] & 1)))
    {
      __int128 v17 = *((_OWORD *)v7 + 2);
      __int16 v18 = v7[6];
      std::__tree<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>>>::__remove_node_pointer( a1,  (uint64_t *)v7);
      operator delete(v7);
      uint64_t v11 = *a2;
      __int128 v13 = *((_OWORD *)*a2 + 2);
      __int128 v14 = v11[6];
      boost::icl::hull<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)&v13,  (unint64_t *)&v17,  (uint64_t)&v15);
      __int128 v12 = *a2;
      *((_OWORD *)v12 + 2) = v15;
      *((_BYTE *)v12 + 48) = v16;
      return *a2;
    }
  }

  return result;
}

unint64_t *boost::icl::hull<boost::icl::discrete_interval<unsigned long long,std::less>>@<X0>( unint64_t *result@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = *((unsigned __int8 *)a2 + 16);
  if (*((_BYTE *)a2 + 16))
  {
    if (v3 == 3)
    {
      uint64_t v5 = (uint64_t *)*a2;
      unint64_t v4 = a2[1];
      if (v4 >= *a2) {
        goto LABEL_4;
      }
LABEL_24:
      *(_OWORD *)a3 = *(_OWORD *)result;
      unint64_t v15 = result[2];
LABEL_33:
      *(void *)(a3 + 16) = v15;
      return result;
    }

    uint64_t v5 = (uint64_t *)*a2;
    unint64_t v4 = a2[1];
    if (*a2 >= v4) {
      goto LABEL_24;
    }
  }

  else
  {
    uint64_t v5 = (uint64_t *)*a2;
    unint64_t v4 = a2[1];
    if (*a2 >= v4 || *a2 + 1 >= v4) {
      goto LABEL_24;
    }
  }

uint64_t std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::upper_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t result = a1 + 8;
  uint64_t v3 = v4;
  if (v4)
  {
    unint64_t v5 = (*(_BYTE *)(a2 + 16) & 1) + *(void *)(a2 + 8) - 1LL;
    do
    {
      unint64_t v6 = *(void *)(v3 + 32);
      if ((*(_BYTE *)(v3 + 48) & 2) == 0) {
        ++v6;
      }
      BOOL v7 = v5 >= v6;
      if (v5 >= v6) {
        uint64_t v8 = (uint64_t *)(v3 + 8);
      }
      else {
        uint64_t v8 = (uint64_t *)v3;
      }
      if (!v7) {
        uint64_t result = v3;
      }
      uint64_t v3 = *v8;
    }

    while (*v8);
  }

  return result;
}

uint64_t boost::icl::segmental::join_under<boost::icl::interval_set<unsigned long long,std::less,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v6 = std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::lower_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  (uint64_t)a2);
  uint64_t v7 = v6;
  uint64_t v8 = *(uint64_t **)(v6 + 8);
  if (v8)
  {
    do
    {
      char v9 = v8;
      uint64_t v8 = (uint64_t *)*v8;
    }

    while (v8);
  }

  else
  {
    uint64_t v10 = v6;
    do
    {
      char v9 = *(uint64_t **)(v10 + 16);
      BOOL v11 = *v9 == v10;
      uint64_t v10 = (uint64_t)v9;
    }

    while (!v11);
  }

  int v12 = *(uint64_t **)(a3 + 8);
  if (v12)
  {
    do
    {
      int v13 = v12;
      int v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  else
  {
    __int128 v14 = (uint64_t *)a3;
    do
    {
      int v13 = (uint64_t *)v14[2];
      BOOL v11 = *v13 == (void)v14;
      __int128 v14 = v13;
    }

    while (!v11);
  }

  __int128 v24 = *(_OWORD *)(v6 + 32);
  uint64_t v25 = *(void *)(v6 + 48);
  boost::icl::right_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)&v24,  (uint64_t)a2,  (uint64_t)&v26);
  __int128 v21 = *(_OWORD *)(a3 + 32);
  uint64_t v22 = *(void *)(a3 + 48);
  boost::icl::left_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)&v21,  (uint64_t)a2,  (uint64_t)v23);
  std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::erase( a1,  v9,  v13);
  __int128 v16 = v26;
  uint64_t v17 = v27;
  boost::icl::hull<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)&v16,  a2,  (uint64_t)v18);
  boost::icl::hull<boost::icl::discrete_interval<unsigned long long,std::less>>(v18, v23, (uint64_t)&v19);
  *(_OWORD *)(v7 + 32) = v19;
  *(_BYTE *)(v7 + 48) = v20;
  return v7;
}

unint64_t *boost::icl::right_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>@<X0>( unint64_t *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = *((unsigned __int8 *)result + 16);
  if (*((_BYTE *)result + 16))
  {
    if (v3 == 3)
    {
      unint64_t v4 = *result;
      unint64_t v5 = result[1];
      if (v5 < *result) {
        goto LABEL_27;
      }
    }

    else
    {
      unint64_t v4 = *result;
      unint64_t v5 = result[1];
      if (*result >= v5) {
        goto LABEL_27;
      }
    }
  }

  else
  {
    unint64_t v4 = *result;
    unint64_t v5 = result[1];
    if (*result >= v5 || *result + 1 >= v5) {
      goto LABEL_27;
    }
  }

  int v7 = *(unsigned __int8 *)(a2 + 16);
  if (!*(_BYTE *)(a2 + 16))
  {
    unint64_t v8 = *(void *)a2;
    unint64_t v9 = *(void *)(a2 + 8);
    if (*(void *)a2 >= v9 || *(void *)a2 + 1LL >= v9) {
      goto LABEL_27;
    }
    goto LABEL_23;
  }

  if (v7 != 3)
  {
    unint64_t v8 = *(void *)a2;
    if (*(void *)a2 < *(void *)(a2 + 8)) {
      goto LABEL_23;
    }
LABEL_27:
    *(_OWORD *)a3 = *(_OWORD *)result;
    *(void *)(a3 + 16) = result[2];
    return result;
  }

  unint64_t v8 = *(void *)a2;
  if (*(void *)(a2 + 8) < *(void *)a2) {
    goto LABEL_27;
  }
LABEL_23:
  unint64_t v11 = (v3 & 1) + v5 - 1;
  if ((v7 & 2) != 0) {
    unint64_t v12 = v8;
  }
  else {
    unint64_t v12 = v8 + 1;
  }
  if (v11 < v12) {
    goto LABEL_27;
  }
  *(void *)a3 = v4;
  *(void *)(a3 + 8) = v8;
  *(_BYTE *)(a3 + 16) = v3 & 2 | ((~v7 & 2) != 0);
  return result;
}

uint64_t boost::icl::left_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = *(unsigned __int8 *)(a2 + 16);
  if (*(_BYTE *)(a2 + 16))
  {
    if (v3 == 3)
    {
      unint64_t v4 = *(void *)(a2 + 8);
      if (v4 < *(void *)a2) {
        goto LABEL_26;
      }
    }

    else
    {
      unint64_t v4 = *(void *)(a2 + 8);
      if (*(void *)a2 >= v4) {
        goto LABEL_26;
      }
    }
  }

  else
  {
    unint64_t v4 = *(void *)(a2 + 8);
    if (*(void *)a2 >= v4 || *(void *)a2 + 1LL >= v4) {
      goto LABEL_26;
    }
  }

  int v6 = *(unsigned __int8 *)(result + 16);
  if (!*(_BYTE *)(result + 16))
  {
    unint64_t v8 = *(void *)result;
    unint64_t v7 = *(void *)(result + 8);
    if (*(void *)result >= v7 || *(void *)result + 1LL >= v7) {
      goto LABEL_26;
    }
    goto LABEL_23;
  }

  if (v6 != 3)
  {
    unint64_t v8 = *(void *)result;
    unint64_t v7 = *(void *)(result + 8);
    if (*(void *)result < v7) {
      goto LABEL_23;
    }
LABEL_26:
    *(_OWORD *)a3 = *(_OWORD *)result;
    *(void *)(a3 + 16) = *(void *)(result + 16);
    return result;
  }

  unint64_t v8 = *(void *)result;
  unint64_t v7 = *(void *)(result + 8);
  if (v7 < *(void *)result) {
    goto LABEL_26;
  }
LABEL_23:
  if ((v6 & 2) == 0) {
    ++v8;
  }
  if ((v3 & 1) + v4 - 1 < v8) {
    goto LABEL_26;
  }
  *(void *)a3 = v4;
  *(void *)(a3 + 8) = v7;
  *(_BYTE *)(a3 + 16) = v6 & 1 | (2 * ((v3 & 1) == 0));
  return result;
}

uint64_t std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::lower_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t result = a1 + 8;
  uint64_t v3 = v4;
  if (v4)
  {
    unint64_t v5 = *(void *)a2;
    if ((*(_BYTE *)(a2 + 16) & 2) == 0) {
      ++v5;
    }
    do
    {
      unint64_t v6 = (*(_BYTE *)(v3 + 48) & 1) + *(void *)(v3 + 40) - 1LL;
      BOOL v7 = v6 >= v5;
      if (v6 >= v5) {
        unint64_t v8 = (uint64_t *)v3;
      }
      else {
        unint64_t v8 = (uint64_t *)(v3 + 8);
      }
      if (v7) {
        uint64_t result = v3;
      }
      uint64_t v3 = *v8;
    }

    while (*v8);
  }

  return result;
}

uint64_t di_log::logger_buf<di_log::log_printer<492ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DDE38;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880E0748(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<498ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DE058;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880E07C4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<505ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DE278;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880E0840(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<511ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DE498;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880E08BC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<523ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DE6B8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880E0938(_Unwind_Exception *a1)
{
}

const void **details::copy_user_entry_to_resource(const __CFString *a1, void *a2, __CFDictionary *a3)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (a1)
  {
    unint64_t v7 = TypeID;
    if (CFGetTypeID(a1) != TypeID)
    {
      exception = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
      CFTypeID v15 = CFGetTypeID(a1);
LABEL_19:
      __int128 v16 = (void *)cf::CFUtilException::CFUtilException(exception, v15, v7);
    }
  }

  int OSType = CFStringGetOSType(a1);
  if (OSType == 1651272568 || OSType == 1970628964 || OSType == 1886155636)
  {
    unint64_t v11 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    unint64_t v12 = "User data contains reserved key(s)";
    goto LABEL_16;
  }

  CFTypeID v9 = CFDataGetTypeID();
  if (!a2)
  {
    unint64_t v11 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    unint64_t v12 = "Invalid user data content";
LABEL_16:
    DiskImagesRuntimeException::DiskImagesRuntimeException(v11, v12, 0x16u);
  }

  unint64_t v7 = v9;
  if (CFGetTypeID(a2) != v9)
  {
    exception = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
    CFTypeID v15 = CFGetTypeID(a2);
    goto LABEL_19;
  }

  std::string::basic_string[abi:ne180100]<0>(v21, "");
  LOBYTE(__p[0]) = 0;
  char v20 = 0;
  udif::details::block_attributes::block_attributes(&v17, 80);
  udif::details::create_data_wrap_dict((uint64_t)v21, (uint64_t)__p, 0, a2, (CFDictionaryRef *)&v23);
  if (v20 && v19 < 0) {
    operator delete(__p[0]);
  }
  if (v22 < 0) {
    operator delete(v21[0]);
  }
  __p[0] = v23;
  v21[0] = CFArrayCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const void **)__p, 1LL, MEMORY[0x189605228]);
  CFDictionarySetValue(a3, a1, v21[0]);
  CFAutoRelease<__CFArray const*>::~CFAutoRelease((const void **)v21);
  return CFAutoRelease<__CFDictionary const*>::~CFAutoRelease((const void **)&v23);
}

void sub_1880E0B38( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
}

BOOL details::udif_verify::verify_checksums(details::udif_verify *this)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  int v1 = *((_DWORD *)this + 71);
  if (v1) {
    unint64_t v2 = (__int128 *)*((void *)this + 9);
  }
  else {
    unint64_t v2 = 0LL;
  }
  uint64_t v3 = *((void *)this + 1);
  int v4 = *((_DWORD *)this + 70);
  if (v4)
  {
    __int128 v16 = *((_OWORD *)this + 6);
    LOBYTE(v4) = 1;
  }

  else
  {
    LOBYTE(v16) = 0;
  }

  __int128 v5 = (__int128 *)*((void *)this + 10);
  BOOL v6 = v1 == 0;
  char v17 = v4;
  uint64_t v7 = *(void *)(v3 + 72);
  uint64_t v22 = *(void *)(v7 + 352);
  __int128 v27 = *(_OWORD *)(v7 + 424);
  __int128 v28 = *(_OWORD *)(v7 + 440);
  __int128 v29 = *(_OWORD *)(v7 + 456);
  __int128 v30 = *(_OWORD *)(v7 + 472);
  __int128 v23 = *(_OWORD *)(v7 + 360);
  __int128 v24 = *(_OWORD *)(v7 + 376);
  __int128 v25 = *(_OWORD *)(v7 + 392);
  __int128 v26 = *(_OWORD *)(v7 + 408);
  *(void *)&__int128 v21 = udif::get_csum_any((unsigned int *)&v22);
  *((void *)&v21 + 1) = v8;
  if (v6)
  {
    if (!v17) {
      return 1LL;
    }
  }

  else
  {
    CFTypeID v9 = *(void **)(v3 + 32);
    if (v9 == (void *)(v3 + 40) || v2 == v5) {
      goto LABEL_23;
    }
    BOOL v10 = 1;
    do
    {
      __int128 v20 = *v2;
      if (v10) {
        BOOL v10 = udif::details::checksum::operator==((_DWORD *)v9 + 15, (uint64_t)&v20);
      }
      std::string::basic_string[abi:ne180100]<0>(__p, "BLX");
      udif::details::UDIF_base::print_checksum_verification_status(v3, (uint64_t)__p, (uint64_t)&v20, (int *)v9 + 15);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
      __int128 v21 = *(_OWORD *)udif::master_checksum_add<checksum::Any<locks::None,checksum::None,checksum::CRC32>>( (uint64_t)&v21,  (uint64_t)&v20);
      unint64_t v11 = (void *)v9[1];
      if (v11)
      {
        do
        {
          unint64_t v12 = v11;
          unint64_t v11 = (void *)*v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          unint64_t v12 = (void *)v9[2];
          BOOL v13 = *v12 == (void)v9;
          CFTypeID v9 = v12;
        }

        while (!v13);
      }

      if (v12 == (void *)(v3 + 40)) {
        break;
      }
      unint64_t v2 = (__int128 *)((char *)v2 + 184);
      CFTypeID v9 = v12;
    }

    while (v2 != v5);
    if (v10) {
LABEL_23:
    }
      BOOL v10 = udif::details::checksum::operator==(&v22, (uint64_t)&v21);
    std::string::basic_string[abi:ne180100]<0>(__p, "Master checksum");
    udif::details::UDIF_base::print_checksum_verification_status(v3, (uint64_t)__p, (uint64_t)&v21, (int *)&v22);
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    if (!v17) {
      return v10;
    }
    if (!v10)
    {
      BOOL v14 = 0LL;
      goto LABEL_31;
    }
  }

  BOOL v14 = udif::details::checksum::operator==((_DWORD *)(*(void *)(v3 + 72) + 80LL), (uint64_t)&v16);
LABEL_31:
  std::string::basic_string[abi:ne180100]<0>(__p, "Data Fork");
  udif::details::UDIF_base::print_checksum_verification_status( v3,  (uint64_t)__p,  (uint64_t)&v16,  (int *)(*(void *)(v3 + 72) + 80LL));
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  return v14;
}

void sub_1880E0E38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t details::udif_verify::is_csum_data_none_type(uint64_t a1)
{
  uint64_t v3 = &v4;
  uint64_t v1 = *(unsigned int *)(a1 + 12);
  if ((_DWORD)v1 == -1) {
    std::__throw_bad_variant_access[abi:ne180100]();
  }
  __int128 v5 = &v3;
  ((void (*)(unsigned __int8 ***, uint64_t))off_18A1DEF88[v1])(&v5, a1 + 4);
  return v4;
}

details::udif_verify *details::udif_verify::udif_verify( details::udif_verify *this, DiskImageUDIF *a2, const udif::details::UDIF_base *a3)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = (*(uint64_t (**)(DiskImageUDIF *))(*(void *)a2 + 24LL))(a2);
  uint64_t runs_iterator = udif::details::UDIF_base::create_runs_iterator(*((udif::details::UDIF_base **)this + 1));
  *((void *)this + 7) = v6;
  *((void *)this + 3) = runs_iterator;
  *((void *)this + 4) = v6;
  *((void *)this + 5) = runs_iterator;
  *((void *)this + 9) = 0LL;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  uint64_t v7 = *((void *)a3 + 9);
  uint64_t v8 = *((void *)this + 2) * *((void *)a3 + 10);
  v11[0] = 0LL;
  v11[1] = v8;
  char v12 = 2;
  details::udif_verify::create_csum_data<boost::iterators::transform_iterator<interval_map2set_it::$_0,std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__tree_node<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,void *> *,long>>,boost::use_default,boost::use_default>>( (__int128 *)((char *)this + 40),  (__int128 *)((char *)this + 56),  (uint64_t)v11,  (unsigned int *)(v7 + 80),  (uint64_t)this + 96);
  else {
    int v9 = 0;
  }
  *((_DWORD *)this + 71) = v9;
  *((_DWORD *)this + 70) = details::udif_verify::is_csum_data_none_type((uint64_t)this + 96) ^ 1;
  return this;
}

void sub_1880E0F88(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void details::udif_verify::create_csum_data<boost::iterators::transform_iterator<interval_map2set_it::$_0,std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__tree_node<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,void *> *,long>>,boost::use_default,boost::use_default>>( __int128 *a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X2>, unsigned int *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uLong csum_any = udif::get_csum_any(a4);
  *(void *)char v12 = 850045863LL;
  v14[0] = 0LL;
  v14[1] = 0LL;
  memset(&v12[8], 0, 60);
  BOOL v13 = v14;
  __int128 v15 = *a1;
  __int128 v16 = v15;
  __int128 v17 = *a2;
  char v19 = 0;
  uint64_t v11 = v15;
  if ((void)v15 != (void)v17)
  {
    uint64_t v11 = *(void *)(v15 + 32);
    if ((*(_BYTE *)(v15 + 48) & 2) == 0) {
      ++v11;
    }
    uint64_t v18 = v11;
  }

  v20[0] = csum_any;
  v20[1] = v10;
  memset(&v21[8], 0, 60);
  v23[0] = 0LL;
  v23[1] = 0LL;
  *(void *)__int128 v21 = 850045863LL;
  uint64_t v22 = v23;
  __int128 v24 = *a1;
  __int128 v25 = v24;
  __int128 v26 = *a2;
  uint64_t v27 = v11;
  char v28 = 0;
  char v29 = 0;
  ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::ChecksumScheduler( a5,  (uint64_t)v20,  a3);
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( (uint64_t)&v22,  v23[0]);
  std::mutex::~mutex((std::mutex *)v21);
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( (uint64_t)&v13,  v14[0]);
  std::mutex::~mutex((std::mutex *)v12);
}

void sub_1880E1128( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41)
{
}

uint64_t ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::~ChecksumScheduler( uint64_t a1)
{
  unint64_t v2 = (std::mutex *)(a1 + 16);
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( a1 + 88,  *(void **)(a1 + 96));
  std::mutex::~mutex(v2);
  return a1;
}

details::udif_verify *details::udif_verify::udif_verify( details::udif_verify *this, DiskImageUDIF *a2, const udif::details::UDIF_base *a3, char a4)
{
  *((_DWORD *)details::udif_verify::udif_verify(this, a2, a3) + 71) = 4 * (a4 & 1);
  if ((a4 & 2) != 0) {
    int v6 = details::udif_verify::is_csum_data_none_type((uint64_t)this + 96) ^ 1;
  }
  else {
    int v6 = 0;
  }
  *((_DWORD *)this + 70) = v6;
  return this;
}

void sub_1880E11E0(_Unwind_Exception *a1)
{
}

void details::udif_verify::~udif_verify(details::udif_verify *this)
{
  unint64_t v2 = (std::mutex *)((char *)this + 112);
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( (uint64_t)this + 184,  *((void **)this + 24));
  std::mutex::~mutex(v2);
  uint64_t v3 = (void **)((char *)this + 72);
  std::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

uint64_t details::udif_verify::populate_csum_data(uint64_t a1, void *a2)
{
  v18[12] = *(void **)MEMORY[0x1895F89C0];
  unint64_t v2 = (unsigned int *)(a2 + 1);
  uint64_t v3 = (unsigned int *)*a2;
  if ((void *)*a2 == a2 + 1) {
    return 0LL;
  }
  LODWORD(v5) = 0;
  int v6 = (__int128 *)(a1 + 40);
  uint64_t v7 = (__int128 *)(a1 + 56);
  __int128 v15 = (uint64_t *)(a1 + 72);
  do
  {
    details::udif_verify::create_csum_data<boost::iterators::transform_iterator<interval_map2set_it::$_0,std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__tree_node<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,void *> *,long>>,boost::use_default,boost::use_default>>( v6,  v7,  (uint64_t)(v3 + 8),  v3 + 15,  (uint64_t)v16);
    unint64_t v8 = *(void *)(a1 + 80);
    if (v8 >= *(void *)(a1 + 88))
    {
      uint64_t v9 = std::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::__emplace_back_slow_path<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>( v15,  (uint64_t)v16);
    }

    else
    {
      std::construct_at[abi:ne180100]<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>( *(void *)(a1 + 80),  (uint64_t)v16);
      uint64_t v9 = v8 + 184;
      *(void *)(a1 + 80) = v8 + 184;
    }

    *(void *)(a1 + 80) = v9;
    std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( (uint64_t)v18,  v18[1]);
    std::mutex::~mutex(&v17);
    unsigned int v10 = v3[15];
    BOOL v11 = v10 == 10 || v10 == 0;
    if (v11) {
      uint64_t v5 = v5;
    }
    else {
      uint64_t v5 = 2LL;
    }
    char v12 = (unsigned int *)*((void *)v3 + 1);
    if (v12)
    {
      do
      {
        BOOL v13 = v12;
        char v12 = *(unsigned int **)v12;
      }

      while (v12);
    }

    else
    {
      do
      {
        BOOL v13 = (unsigned int *)*((void *)v3 + 2);
        BOOL v11 = *(void *)v13 == (void)v3;
        uint64_t v3 = v13;
      }

      while (!v11);
    }

    uint64_t v3 = v13;
  }

  while (v13 != v2);
  return v5;
}

void sub_1880E139C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t details::udif_verify::create_execution_contexts@<X0>( details::udif_verify *this@<X0>, uint64_t a2@<X1>, int a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v8 = a5;
  uint64_t v62 = a2;
  uint64_t result = ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::ContextAllocator( a5,  a4);
  if (a4)
  {
    uint64_t v10 = 0LL;
    uint64_t v11 = a4;
    v52 = this;
    uint64_t v53 = v8;
    do
    {
      uint64_t v12 = (*(uint64_t (**)(void))(**(void **)this + 136LL))(*(void *)this);
      uint64_t v61 = v12;
      v59[1] = 0LL;
      __int128 v60 = 0uLL;
      v59[0] = 0LL;
      if ((DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::is_simple(*(void *)this) & 1) == 0)
      {
        BOOL v13 = *(std::__shared_weak_count **)(v12 + 48);
        v57 = *(const void **)(v12 + 40);
        v58 = v13;
        if (v13)
        {
          p_shared_owners = (unint64_t *)&v13->__shared_owners_;
          do
            unint64_t v15 = __ldxr(p_shared_owners);
          while (__stxr(v15 + 1, p_shared_owners));
        }

        __int128 v16 = *(void **)(v12 + 16);
        if (v16 != (void *)(v12 + 24))
        {
          do
          {
            if (v59[0])
            {
              if (!(void)v60)
              {
                BackendInternalBackend::getContext(v59[0]);
                __int128 v17 = v56;
                __int128 v56 = 0uLL;
                uint64_t v18 = (std::__shared_weak_count *)*((void *)&v60 + 1);
                __int128 v60 = v17;
                if (v18)
                {
                  char v19 = (unint64_t *)&v18->__shared_owners_;
                  do
                    unint64_t v20 = __ldaxr(v19);
                  while (__stlxr(v20 - 1, v19));
                  if (!v20)
                  {
                    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
                    std::__shared_weak_count::__release_weak(v18);
                  }
                }

                __int128 v21 = (std::__shared_weak_count *)*((void *)&v56 + 1);
                if (*((void *)&v56 + 1))
                {
                  uint64_t v22 = (unint64_t *)(*((void *)&v56 + 1) + 8LL);
                  do
                    unint64_t v23 = __ldaxr(v22);
                  while (__stlxr(v23 - 1, v22));
                  if (!v23)
                  {
                    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
                    std::__shared_weak_count::__release_weak(v21);
                  }
                }
              }
            }

            else
            {
              LODWORD(v63) = 1;
              BOOL v55 = a3 != 1;
              std::allocate_shared[abi:ne180100]<BackendSG,std::allocator<BackendSG>,std::shared_ptr<Backend> const&,unsigned long &,int,BOOL,void>( (uint64_t)&v57,  &v62,  (int *)&v63,  (unsigned __int8 *)&v55,  &v56);
              __int128 v24 = v56;
              __int128 v56 = 0uLL;
              __int128 v25 = (std::__shared_weak_count *)v59[1];
              *(_OWORD *)v59 = v24;
              if (v25)
              {
                __int128 v26 = (unint64_t *)&v25->__shared_owners_;
                do
                  unint64_t v27 = __ldaxr(v26);
                while (__stlxr(v27 - 1, v26));
                if (!v27)
                {
                  ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
                  std::__shared_weak_count::__release_weak(v25);
                }
              }

              char v28 = (std::__shared_weak_count *)*((void *)&v56 + 1);
              if (*((void *)&v56 + 1))
              {
                char v29 = (unint64_t *)(*((void *)&v56 + 1) + 8LL);
                do
                  unint64_t v30 = __ldaxr(v29);
                while (__stlxr(v30 - 1, v29));
                if (!v30)
                {
                  ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
                  std::__shared_weak_count::__release_weak(v28);
                }
              }

              std::shared_ptr<DiskImage>::operator=[abi:ne180100](&v60, (uint64_t *)v59);
            }

            if (a3 == 1 || (const void *)v16[5] == v57)
            {
              unsigned int v54 = *((_DWORD *)v16 + 8);
              __int128 v56 = v60;
              if (*((void *)&v60 + 1))
              {
                v36 = (unint64_t *)(*((void *)&v60 + 1) + 8LL);
                do
                  unint64_t v37 = __ldxr(v36);
                while (__stxr(v37 + 1, v36));
              }

              int v63 = &v54;
              v38 = std::__tree<std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,std::shared_ptr<Backend>>>>::__emplace_unique_key_args<udif::run_type,std::piecewise_construct_t const&,std::tuple<udif::run_type const&>,std::tuple<>>( (uint64_t **)(v12 + 16),  &v54,  (uint64_t)&std::piecewise_construct,  &v63);
              std::shared_ptr<DiskImage>::operator=[abi:ne180100](v38 + 5, (uint64_t *)&v56);
              v33 = (std::__shared_weak_count *)*((void *)&v56 + 1);
              if (!*((void *)&v56 + 1)) {
                goto LABEL_48;
              }
              v39 = (unint64_t *)(*((void *)&v56 + 1) + 8LL);
              do
                unint64_t v35 = __ldaxr(v39);
              while (__stlxr(v35 - 1, v39));
            }

            else
            {
              __int128 v56 = v60;
              if (*((void *)&v60 + 1))
              {
                uint64_t v31 = (unint64_t *)(*((void *)&v60 + 1) + 8LL);
                do
                  unint64_t v32 = __ldxr(v31);
                while (__stxr(v32 + 1, v31));
              }

              replace_internal_backend((uint64_t)(v16 + 5), &v57, (uint64_t *)&v56);
              v33 = (std::__shared_weak_count *)*((void *)&v56 + 1);
              if (!*((void *)&v56 + 1)) {
                goto LABEL_48;
              }
              v34 = (unint64_t *)(*((void *)&v56 + 1) + 8LL);
              do
                unint64_t v35 = __ldaxr(v34);
              while (__stlxr(v35 - 1, v34));
            }

            if (!v35)
            {
              ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
              std::__shared_weak_count::__release_weak(v33);
            }

LABEL_48:
            v40 = (void *)v16[1];
            if (v40)
            {
              do
              {
                uint64_t v41 = v40;
                v40 = (void *)*v40;
              }

              while (v40);
            }

            else
            {
              do
              {
                uint64_t v41 = (void *)v16[2];
                BOOL v42 = *v41 == (void)v16;
                __int128 v16 = v41;
              }

              while (!v42);
            }

            __int128 v16 = v41;
          }

          while (v41 != (void *)(v12 + 24));
        }

        *(_BYTE *)(v12 + 56) = 0;
        uint64_t v43 = v58;
        this = v52;
        uint64_t v8 = v53;
        uint64_t v11 = a4;
        if (v58)
        {
          v44 = (unint64_t *)&v58->__shared_owners_;
          do
            unint64_t v45 = __ldaxr(v44);
          while (__stlxr(v45 - 1, v44));
          if (!v45)
          {
            ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
            std::__shared_weak_count::__release_weak(v43);
          }
        }
      }

      ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::emplace_back( v8,  &v61,  &v60);
      v46 = (std::__shared_weak_count *)v59[1];
      if (v59[1])
      {
        v47 = (unint64_t *)((char *)v59[1] + 8);
        do
          unint64_t v48 = __ldaxr(v47);
        while (__stlxr(v48 - 1, v47));
        if (!v48)
        {
          ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
          std::__shared_weak_count::__release_weak(v46);
        }
      }

      v49 = (std::__shared_weak_count *)*((void *)&v60 + 1);
      if (*((void *)&v60 + 1))
      {
        v50 = (unint64_t *)(*((void *)&v60 + 1) + 8LL);
        do
          unint64_t v51 = __ldaxr(v50);
        while (__stlxr(v51 - 1, v50));
        if (!v51)
        {
          ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
          std::__shared_weak_count::__release_weak(v49);
        }
      }

      uint64_t result = v61;
      uint64_t v61 = 0LL;
      if (result) {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40LL))(result);
      }
      ++v10;
    }

    while (v10 != v11);
  }

  return result;
}

    *a3 = v21;
    return v5;
  }

  if (v11)
  {
    *a3 = a4;
  }

  else
  {
    *a3 = a2;
    return a2 + 1;
  }

  return a4;
}

    *a3 = v21;
    return v5;
  }

  if (v11)
  {
    *a3 = a4;
  }

  else
  {
    *a3 = a2;
    return a2 + 1;
  }

  return a4;
}
  }

  if (v46 == 1)
  {
    uint64_t v53 = __s1;
    if (__s1)
    {
      if (!strcmp(__s1, "encryption")) {
        unint64_t v45 = 1;
      }
      if (!strcmp(v53, "location")) {
        v44 = 1;
      }
    }
  }

  ++v46;
LABEL_47:
  if (v46) {
    goto LABEL_48;
  }
  if (*a5 && *a6)
  {
    char v28 = 0LL;
    goto LABEL_16;
  }

  uint64_t v62 = "invalid/missing decryption components";
  int v63 = 631;
LABEL_62:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchiveS3/AAS3Knox.c",  (uint64_t)"contextGetDecryptionComponents",  v63,  125,  0,  v62,  v38,  v39,  v66);
LABEL_15:
  char v28 = 0xFFFFFFFFLL;
LABEL_16:
  AAJSONInputStreamClose(v21);
  AAByteStreamClose(v18);
  free(v27);
  free(v8);
  return v28;
}

void sub_1880E1804(_Unwind_Exception *a1)
{
}

uint64_t DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::is_simple(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 168);
  unint64_t v2 = (void *)(a1 + 176);
  if (v1 == (void *)(a1 + 176)) {
    return 1LL;
  }
  do
  {
    get_sink_backend((uint64_t)(v1 + 5), &v13);
    uint64_t v3 = v1[5];
    uint64_t v5 = v13;
    unsigned __int8 v4 = v14;
    BOOL v6 = v3 == v13;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }

    if (v3 != v5) {
      break;
    }
    uint64_t v9 = (void *)v1[1];
    if (v9)
    {
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (void *)*v9;
      }

      while (v9);
    }

    else
    {
      do
      {
        uint64_t v10 = (void *)v1[2];
        BOOL v11 = *v10 == (void)v1;
        uint64_t v1 = v10;
      }

      while (!v11);
    }

    uint64_t v1 = v10;
  }

  while (v10 != v2);
  return v6;
}

void BackendInternalBackend::getContext(BackendInternalBackend *this)
{
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 3) + 72LL))(&v5);
  (*(void (**)(BackendInternalBackend *, uint64_t *))(*(void *)this + 176LL))(this, &v5);
  unint64_t v2 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

void sub_1880E19DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::emplace_back( uint64_t a1, uint64_t *a2, __int128 *a3)
{
  BOOL v6 = (char *)operator new(0x18uLL);
  uint64_t v7 = *a2;
  *a2 = 0LL;
  __int128 v8 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  unint64_t v9 = *(void *)(a1 + 24);
  *(void *)BOOL v6 = v7;
  *(_OWORD *)(v6 + 8) = v8;
  uint64_t v10 = *(void **)(a1 + 16);
  if ((unint64_t)v10 >= v9)
  {
    uint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = ((uint64_t)v10 - v12) >> 3;
    uint64_t v14 = v9 - v12;
    uint64_t v15 = v14 >> 2;
    else {
      unint64_t v16 = v15;
    }
    if (v16) {
      __int128 v17 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( a1 + 24,  v16);
    }
    else {
      __int128 v17 = 0LL;
    }
    uint64_t v18 = &v17[8 * v13];
    char v19 = &v17[8 * v16];
    *(void *)uint64_t v18 = v6;
    BOOL v11 = v18 + 8;
    __int128 v21 = *(char **)(a1 + 8);
    unint64_t v20 = *(char **)(a1 + 16);
    if (v20 != v21)
    {
      do
      {
        uint64_t v22 = *((void *)v20 - 1);
        v20 -= 8;
        *((void *)v18 - 1) = v22;
        v18 -= 8;
      }

      while (v20 != v21);
      unint64_t v20 = *(char **)(a1 + 8);
    }

    *(void *)(a1 + 8) = v18;
    *(void *)(a1 + 16) = v11;
    *(void *)(a1 + 24) = v19;
    if (v20) {
      operator delete(v20);
    }
  }

  else
  {
    void *v10 = v6;
    BOOL v11 = v10 + 1;
  }

  *(void *)(a1 + 16) = v11;
  uint64_t result = v11 - 1;
  ++*(_DWORD *)a1;
  return result;
}

uint64_t details::udif_verify::calculate_checksums(int32x2_t *this, workqueue::workqueue *a2)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  resources = system_properties::get_resources((system_properties *)this);
  unint64_t v57 = (*(uint64_t (**)(int32x2_t))(**(void **)this + 24LL))(*this);
  uint64_t v5 = (system_properties::$_2 *)(*(void *(**)(std::condition_variable *__return_ptr))(**(void **)this
                                                                                                  + 72LL))(v89);
  else {
    unint64_t sig = v89[0].__cv_.__sig;
  }
  int v7 = *((_DWORD *)resources + 2);
  if (v7 == 1)
  {
    unsigned int v8 = (*resources)(v5);
  }

  else
  {
    if (v7) {
      std::__throw_bad_variant_access[abi:ne180100]();
    }
    unsigned int v8 = *(_DWORD *)resources;
  }

  unint64_t v9 = (unint64_t)resources[3] / sig;
  else {
    uint64_t v10 = v9;
  }
  (*(void (**)(std::condition_variable *__return_ptr))(**(void **)this + 72LL))(v89);
  unint64_t v56 = *(void *)&v89[0].__cv_.__opaque[8] + sig;
  BufferAllocator::BufferAllocator((BufferAllocator *)v89, *(void *)&v89[0].__cv_.__opaque[8] + sig, 0, v10);
  uint64_t v85 = 0LL;
  v86 = 0LL;
  BOOL v11 = (udif::details::UDIF_base *)this[1];
  uint64_t runs_iterator = udif::details::UDIF_base::create_runs_iterator(v11);
  BOOL v55 = v13;
  uint64_t v14 = (void *)runs_iterator;
  if (this[35].i32[1])
  {
    __int32 v15 = details::udif_verify::populate_csum_data((uint64_t)this, (void *)v11 + 4);
    this[35].i32[1] = v15;
  }

  else
  {
    __int32 v15 = 0;
  }

  __int32 v16 = this[35].i32[0];
  int is_simple = DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::is_simple((uint64_t)*this);
  if (is_simple)
  {
    this[35] = (int32x2_t)vbic_s8((int8x8_t)0x200000002LL, (int8x8_t)vceqz_s32(this[35]));
    int v18 = 2;
  }

  else
  {
    int v18 = v16 | v15;
  }

  details::udif_verify::create_execution_contexts((details::udif_verify *)this, v56, v18, v10, (uint64_t)v88);
  workqueue::workqueue::create_transaction(a2, v10, (uint64_t)v87);
  int32x2_t v19 = this[9];
  unsigned int v84 = 0;
  unint64_t v20 = (void *)*((void *)v11 + 4);
  if (v20 != (void *)((char *)v11 + 40) && v14 != v55)
  {
    unint64_t v21 = (v57 + sig - 1) / v57;
    while ((unint64_t)(v14[6] & 1) + v14[5] - 1 > (unint64_t)(v20[6] & 1) + v20[5] - 1)
    {
LABEL_23:
      uint64_t v22 = (void *)v20[1];
      if (v22)
      {
        do
        {
          unint64_t v23 = v22;
          uint64_t v22 = (void *)*v22;
        }

        while (v22);
      }

      else
      {
        do
        {
          unint64_t v23 = (void *)v20[2];
          BOOL v47 = *v23 == (void)v20;
          unint64_t v20 = v23;
        }

        while (!v47);
      }

      if (v23 != (void *)((char *)v11 + 40))
      {
        *(void *)&v19 += 184LL;
        unint64_t v20 = v23;
        if (v14 != v55) {
          continue;
        }
      }

      goto LABEL_83;
    }

    __int128 v24 = v14;
    while (1)
    {
      __int128 v79 = *((_OWORD *)v20 + 2);
      uint64_t v80 = v20[6];
      boost::icl::operator&<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)&v79,  v24 + 4,  (uint64_t)&v81);
      unint64_t v25 = v81;
      if ((v83 & 2) == 0) {
        unint64_t v25 = v81 + 1;
      }
LABEL_69:
      v46 = (void *)v24[1];
      if (v46)
      {
        do
        {
          uint64_t v14 = v46;
          v46 = (void *)*v46;
        }

        while (v46);
      }

      else
      {
        do
        {
          uint64_t v14 = (void *)v24[2];
          BOOL v47 = *v14 == (void)v24;
          __int128 v24 = v14;
        }

        while (!v47);
      }

      BOOL v47 = (unint64_t)(v14[6] & 1) + v14[5] - 1 > (unint64_t)(v20[6] & 1) + v20[5] - 1 || v14 == v55;
      __int128 v24 = v14;
      if (v47) {
        goto LABEL_23;
      }
    }

    while (!atomic_load(&v84))
    {
      unint64_t v27 = v25 + v21;
      v75[0] = v25;
      v75[1] = v25 + v21;
      char v76 = 2;
      boost::icl::operator&<boost::icl::discrete_interval<unsigned long long,std::less>>(v75, &v81, (uint64_t)&v77);
      if (v18 == 1)
      {
        uint64_t v73 = v85;
        v74 = v86;
        if (v86)
        {
          p_shared_owners = (unint64_t *)&v86->__shared_owners_;
          do
            unint64_t v29 = __ldxr(p_shared_owners);
          while (__stxr(v29 + 1, p_shared_owners));
        }
      }

      else
      {
        BufferAllocator::allocate(v89, &v73);
      }

      ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::allocate( (uint64_t)v88,  &v71);
      v58[0] = MEMORY[0x1895F87A8];
      v58[1] = 1174405120LL;
      v58[2] = ___ZN7details11udif_verify19calculate_checksumsERN9workqueue9workqueueE_block_invoke;
      v58[3] = &__block_descriptor_tmp_4;
      __int128 v59 = v77;
      uint64_t v60 = v78;
      v58[4] = this;
      unint64_t v61 = v57;
      uint64_t v62 = v73;
      int v63 = v74;
      if (v74)
      {
        unint64_t v30 = (unint64_t *)&v74->__shared_owners_;
        do
          unint64_t v31 = __ldxr(v30);
        while (__stxr(v31 + 1, v30));
      }

      unint64_t v64 = v56;
      uint64_t v65 = v71;
      v66 = v72;
      if (v72)
      {
        unint64_t v32 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v33 = __ldxr(v32);
        while (__stxr(v33 + 1, v32));
      }

      int v69 = v18;
      v67 = &v84;
      int32x2_t v68 = v19;
      char v70 = is_simple;
      workqueue::transaction::add(v87, v58);
      v34 = v66;
      if (v66)
      {
        unint64_t v35 = (unint64_t *)&v66->__shared_owners_;
        do
          unint64_t v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }

      unint64_t v37 = v63;
      if (v63)
      {
        v38 = (unint64_t *)&v63->__shared_owners_;
        do
          unint64_t v39 = __ldaxr(v38);
        while (__stlxr(v39 - 1, v38));
        if (!v39)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }

      v40 = v72;
      if (v72)
      {
        uint64_t v41 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v42 = __ldaxr(v41);
        while (__stlxr(v42 - 1, v41));
        if (!v42)
        {
          ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
          std::__shared_weak_count::__release_weak(v40);
        }
      }

      uint64_t v43 = v74;
      if (v74)
      {
        v44 = (unint64_t *)&v74->__shared_owners_;
        do
          unint64_t v45 = __ldaxr(v44);
        while (__stlxr(v45 - 1, v44));
        if (!v45)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
      }

      unint64_t v25 = v27;
    }

    int32x2_t v48 = this[9];
    for (int32x2_t i = this[10]; *(void *)&v48 != *(void *)&i; *(void *)&v48 += 184LL)
    {
      *(_BYTE *)(*(void *)&v48 + 176LL) = 1;
      ExecutionSchedulerSortedConsecutiveIt<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,locks::Std,boost::iterators::transform_iterator<interval_map2set_it::$_0,std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__tree_node<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,void *> *,long>>,boost::use_default,boost::use_default>>::abort(*(void *)&v48 + 16LL);
    }

    this[34].i8[0] = 1;
    ExecutionSchedulerSortedConsecutiveIt<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,locks::Std,boost::iterators::transform_iterator<interval_map2set_it::$_0,std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__tree_node<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,void *> *,long>>,boost::use_default,boost::use_default>>::abort((uint64_t)&this[14]);
  }

LABEL_83:
  uint64_t v50 = atomic_load(&v84);
  workqueue::transaction::~transaction((workqueue::transaction *)v87);
  ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::~ContextAllocator((uint64_t)v88);
  unint64_t v51 = v86;
  if (v86)
  {
    v52 = (unint64_t *)&v86->__shared_owners_;
    do
      unint64_t v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }

  BufferAllocator::~BufferAllocator((BufferAllocator *)v89);
  return v50;
}

void sub_1880E2118( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,char a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
}

double boost::icl::operator&<boost::icl::discrete_interval<unsigned long long,std::less>>@<D0>( unint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = *((unsigned __int8 *)a1 + 16);
  if (*((_BYTE *)a1 + 16))
  {
    if (v3 == 3)
    {
      unint64_t v5 = *a1;
      unint64_t v4 = a1[1];
      if (v4 < *a1) {
        goto LABEL_31;
      }
    }

    else
    {
      unint64_t v5 = *a1;
      unint64_t v4 = a1[1];
      if (*a1 >= v4) {
        goto LABEL_31;
      }
    }
  }

  else
  {
    unint64_t v5 = *a1;
    unint64_t v4 = a1[1];
    if (*a1 >= v4 || *a1 + 1 >= v4) {
      goto LABEL_31;
    }
  }

  int v7 = *((unsigned __int8 *)a2 + 16);
  if (!*((_BYTE *)a2 + 16))
  {
    unint64_t v9 = *a2;
    unint64_t v8 = a2[1];
    if (*a2 < v8 && *a2 + 1 < v8) {
      goto LABEL_15;
    }
    goto LABEL_31;
  }

  if (v7 == 3)
  {
    unint64_t v9 = *a2;
    unint64_t v8 = a2[1];
    if (v8 >= *a2) {
      goto LABEL_15;
    }
LABEL_31:
    if ((v17 & 1) == 0)
    {
      uint64_t v20 = a3;
      a3 = v20;
      if (v19)
      {
        *(void *)&boost::icl::identity_element<boost::icl::discrete_interval<unsigned long long,std::less>>::value(void)::_value = boost::icl::identity_element<unsigned long long>::value(void)::_value;
        *((void *)&boost::icl::identity_element<boost::icl::discrete_interval<unsigned long long,std::less>>::value(void)::_value
        + 1) = boost::icl::identity_element<unsigned long long>::value(void)::_value;
        LOBYTE(qword_18C7011A8) = 2;
        a3 = v20;
      }
    }

    double result = *(double *)&boost::icl::identity_element<boost::icl::discrete_interval<unsigned long long,std::less>>::value(void)::_value;
    *(_OWORD *)a3 = boost::icl::identity_element<boost::icl::discrete_interval<unsigned long long,std::less>>::value(void)::_value;
    *(void *)(a3 + 16) = qword_18C7011A8;
    return result;
  }

  unint64_t v9 = *a2;
  unint64_t v8 = a2[1];
  if (*a2 >= v8) {
    goto LABEL_31;
  }
LABEL_15:
  char v10 = v3 & 2;
  if ((v3 & 2) != 0) {
    unint64_t v11 = v5;
  }
  else {
    unint64_t v11 = v5 + 1;
  }
  char v12 = v7 & 2;
  if ((v7 & 2) != 0) {
    unint64_t v13 = v9;
  }
  else {
    unint64_t v13 = v9 + 1;
  }
  int v14 = v3 & 1;
  int v15 = v7 & 1;
  if (v11 < v13)
  {
    unint64_t v5 = v9;
    char v10 = v12;
  }

  if (v4 + v14 - 1 >= v8 + v15 - 1)
  {
    unint64_t v4 = v8;
    LOBYTE(v14) = v15;
  }

  *(void *)a3 = v5;
  *(void *)(a3 + 8) = v4;
  *(_BYTE *)(a3 + 16) = v14 | v10;
  return result;
}

void ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::allocate( uint64_t a1@<X0>, void *a2@<X8>)
{
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 32);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 32));
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (*(_BYTE *)(a1 + 144)) {
    BOOL v6 = v5 == v4;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    uint64_t v13 = 0LL;
    __int128 v12 = 0uLL;
    ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::emplace_back( a1,  &v13,  &v12);
    int v7 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    if (*((void *)&v12 + 1))
    {
      unint64_t v8 = (unint64_t *)(*((void *)&v12 + 1) + 8LL);
      do
        unint64_t v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }

    uint64_t v10 = v13;
    uint64_t v13 = 0LL;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 40LL))(v10);
    }
    uint64_t v4 = *(void *)(a1 + 16);
  }

  else if (v5 == v4)
  {
    do
    {
      std::condition_variable::wait((std::condition_variable *)(a1 + 96), &__lk);
      uint64_t v4 = *(void *)(a1 + 16);
    }

    while (*(void *)(a1 + 8) == v4);
  }

  uint64_t v11 = *(void *)(v4 - 8);
  *(void *)(a1 + 16) = v4 - 8;
  std::shared_ptr<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>>::shared_ptr[abi:ne180100]<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>,ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::allocate(void)::{lambda(std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>)#1},void>( a2,  v11,  a1);
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
}

void sub_1880E2418( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, std::mutex *a13, char a14)
{
  uint64_t v15 = a12;
  a12 = 0LL;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 40LL))(v15);
  }
  std::mutex::unlock(a13);
  _Unwind_Resume(a1);
}

void ___ZN7details11udif_verify19calculate_checksumsERN9workqueue9workqueueE_block_invoke(uint64_t a1)
{
  uint64_t v144 = *MEMORY[0x1895F89C0];
  unsigned int v2 = *(unsigned __int8 *)(a1 + 56);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v6 = (*(void *)(a1 + 48) - v3 + (v2 & 1) + (int)(((v2 >> 1) & 1) - 1)) * v5;
  if ((v2 & 2) != 0) {
    uint64_t v7 = *(void *)(a1 + 40);
  }
  else {
    uint64_t v7 = v3 + 1;
  }
  uint64_t v8 = v7 * v5;
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 80);
  uint64_t v9 = *(void *)(a1 + 88);
  uint64_t v119 = *(void *)(a1 + 72);
  v120 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  unint64_t v121 = v6;
  uint64_t v122 = v8;
  uint64_t v123 = v9;
  char v124 = 0;
  uint64_t v13 = *(DiskImage::Context ***)(a1 + 96);
  sg_vec_ns::make(&v119, (uint64_t *)&v131);
  sg_vec_ref::begin((sg_vec_ref *)v136, (uint64_t)&v128);
  sg_vec_ref::end((sg_vec_ref *)v136, (uint64_t)&v125);
  uint64_t v14 = DiskImage::Context::read( *v13,  (const sg_vec_ns::details::sg_vec_iterator *)&v128,  (const sg_vec_ns::details::sg_vec_iterator *)&v125);
  uint64_t v16 = v15;
  unsigned __int8 v17 = v127;
  if (v127)
  {
    int v18 = (unint64_t *)&v127->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  uint64_t v20 = v126;
  if (v126)
  {
    unint64_t v21 = (unint64_t *)&v126->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  unint64_t v23 = v130;
  if (v130)
  {
    __int128 v24 = (unint64_t *)&v130->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  __int128 v26 = (std::__shared_weak_count *)*((void *)&v128 + 1);
  if (*((void *)&v128 + 1))
  {
    unint64_t v27 = (unint64_t *)(*((void *)&v128 + 1) + 8LL);
    do
      unint64_t v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  unint64_t v29 = v143;
  if (v143)
  {
    unint64_t v30 = (unint64_t *)&v143->__shared_owners_;
    do
      unint64_t v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

  unint64_t v32 = v142;
  if (v142)
  {
    unint64_t v33 = (unint64_t *)&v142->__shared_owners_;
    do
      unint64_t v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }

  unint64_t v35 = v141;
  if (v141)
  {
    unint64_t v36 = (unint64_t *)&v141->__shared_owners_;
    do
      unint64_t v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }

  v38 = v140;
  if (v140)
  {
    unint64_t v39 = (unint64_t *)&v140->__shared_owners_;
    do
      unint64_t v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }

  uint64_t v41 = v139;
  if (v139)
  {
    unint64_t v42 = (unint64_t *)&v139->__shared_owners_;
    do
      unint64_t v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }

  v44 = v137;
  if (v137)
  {
    unint64_t v45 = (unint64_t *)&v137->__shared_owners_;
    do
      unint64_t v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }

  if (v134 && &v135 != __p) {
    operator delete(__p);
  }
  boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)&v131);
  if ((v14 & 0x8000000000000000LL) == 0 || !(_DWORD)v14)
  {
    uint64_t v47 = *(void *)(a1 + 80);
    *(void *)&__int128 v128 = *(void *)(a1 + 72) + v8 - v16;
    *((void *)&v128 + 1) = v47;
    if (v47)
    {
      int32x2_t v48 = (unint64_t *)(v47 + 8);
      do
        unint64_t v49 = __ldxr(v48);
      while (__stxr(v49 + 1, v48));
    }

    uint64_t v50 = 0LL;
    unint64_t v51 = *(void *)(a1 + 64);
    unint64_t v52 = v122;
    if (v121 <= v51) {
      unint64_t v53 = *(void *)(a1 + 64);
    }
    else {
      unint64_t v53 = v121;
    }
    if (v121) {
      unint64_t v54 = v53;
    }
    else {
      unint64_t v54 = 0LL;
    }
    unint64_t v55 = v51 + v122 + v54 - 1;
    uint64_t v125 = 0LL;
    v126 = 0LL;
    if ((*(_BYTE *)(a1 + 128) & 1) != 0 && v8 == v16)
    {
      uint64_t v56 = *(void *)(a1 + 96);
      uint64_t v57 = *(void *)(v56 + 8);
      uint64_t v58 = *(void *)(v57 + 72);
      *(void *)&__int128 v131 = *(void *)(v57 + 64);
      *((void *)&v131 + 1) = v58;
      if (v58)
      {
        __int128 v59 = (unint64_t *)(v58 + 8);
        do
          unint64_t v60 = __ldxr(v59);
        while (__stxr(v60 + 1, v59));
        unint64_t v61 = (std::__shared_weak_count *)*((void *)&v131 + 1);
        *(_OWORD *)v132 = *(_OWORD *)(v57 + 80);
        *(_OWORD *)&v132[9] = *(_OWORD *)(v57 + 89);
        if (*((void *)&v131 + 1))
        {
          uint64_t v62 = (unint64_t *)(*((void *)&v131 + 1) + 8LL);
          do
            unint64_t v63 = __ldaxr(v62);
          while (__stlxr(v63 - 1, v62));
          if (!v63)
          {
            ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
            std::__shared_weak_count::__release_weak(v61);
          }
        }
      }

      std::shared_ptr<DiskImage>::operator=[abi:ne180100](&v125, (uint64_t *)&v131);
      uint64_t v64 = *(void *)(v56 + 8);
      uint64_t v65 = *(std::__shared_weak_count **)(v64 + 72);
      if (v65)
      {
        v66 = (unint64_t *)&v65->__shared_owners_;
        do
          unint64_t v67 = __ldxr(v66);
        while (__stxr(v67 + 1, v66));
        uint64_t v50 = *(void *)(v64 + 80);
        do
          unint64_t v68 = __ldaxr(v66);
        while (__stlxr(v68 - 1, v66));
        if (!v68)
        {
          ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
          std::__shared_weak_count::__release_weak(v65);
        }
      }

      else
      {
        uint64_t v50 = *(void *)(v64 + 80);
      }
    }

    int v69 = *(_DWORD *)(v4 + 284);
    uint64_t v70 = v50;
    if (v69 != 1)
    {
      if (v69 != 2) {
        goto LABEL_120;
      }
      uint64_t v70 = v6;
    }

    if (v70)
    {
      uint64_t v71 = *(void *)(a1 + 120);
      if (v69 == 2)
      {
        uint64_t v73 = (std::__shared_weak_count *)*((void *)&v128 + 1);
        v117 = (std::__shared_weak_count *)*((void *)&v128 + 1);
        uint64_t v72 = v128;
        if (*((void *)&v128 + 1))
        {
          char v76 = (unint64_t *)(*((void *)&v128 + 1) + 8LL);
          do
            unint64_t v77 = __ldxr(v76);
          while (__stxr(v77 + 1, v76));
        }
      }

      else
      {
        uint64_t v72 = v125;
        uint64_t v73 = v126;
        v117 = v126;
        if (v126)
        {
          v74 = (unint64_t *)&v126->__shared_owners_;
          do
            unint64_t v75 = __ldxr(v74);
          while (__stxr(v75 + 1, v74));
        }
      }

      int v78 = *(_DWORD *)(v4 + 284);
      if (v78 == 1) {
        uint64_t v79 = v50;
      }
      else {
        uint64_t v79 = 0LL;
      }
      if (v78 == 2) {
        uint64_t v80 = v6;
      }
      else {
        uint64_t v80 = v79;
      }
      *(void *)&__int128 v131 = v52 / v51;
      *((void *)&v131 + 1) = v55 / v51;
      v132[0] = 2;
      *(void *)&v132[8] = v72;
      *(void *)&v132[16] = v73;
      if (v73)
      {
        unint64_t v81 = (unint64_t *)&v73->__shared_owners_;
        do
          unint64_t v82 = __ldxr(v81);
        while (__stxr(v82 + 1, v81));
      }

      *(void *)&v132[24] = v80;
      ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::add( v71,  &v131);
      char v83 = *(std::__shared_weak_count **)&v132[16];
      if (*(void *)&v132[16])
      {
        unsigned int v84 = (unint64_t *)(*(void *)&v132[16] + 8LL);
        do
          unint64_t v85 = __ldaxr(v84);
        while (__stlxr(v85 - 1, v84));
        if (!v85)
        {
          ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
          std::__shared_weak_count::__release_weak(v83);
        }
      }

      if (v117)
      {
        v86 = (unint64_t *)&v117->__shared_owners_;
        do
          unint64_t v87 = __ldaxr(v86);
        while (__stlxr(v87 - 1, v86));
        if (!v87)
        {
          ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
          std::__shared_weak_count::__release_weak(v117);
        }
      }
    }

LABEL_120:
    int v88 = *(_DWORD *)(v4 + 280);
    uint64_t v89 = v50;
    if (v88 != 1)
    {
      if (v88 != 2)
      {
LABEL_151:
        if (!*(_BYTE *)(a1 + 132)) {
          BackendSG::drop_sg(*(BackendSG **)(*(void *)(a1 + 96) + 8LL));
        }
        v106 = v126;
        if (v126)
        {
          v107 = (unint64_t *)&v126->__shared_owners_;
          do
            unint64_t v108 = __ldaxr(v107);
          while (__stlxr(v108 - 1, v107));
          if (!v108)
          {
            ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
            std::__shared_weak_count::__release_weak(v106);
          }
        }

        v109 = (std::__shared_weak_count *)*((void *)&v128 + 1);
        if (*((void *)&v128 + 1))
        {
          v110 = (unint64_t *)(*((void *)&v128 + 1) + 8LL);
          do
            unint64_t v111 = __ldaxr(v110);
          while (__stlxr(v111 - 1, v110));
          if (!v111)
          {
            ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
            std::__shared_weak_count::__release_weak(v109);
          }
        }

        goto LABEL_163;
      }

      uint64_t v89 = v6;
    }

    if (v89)
    {
      if (v88 == 2)
      {
        v91 = (std::__shared_weak_count *)*((void *)&v128 + 1);
        v118 = (std::__shared_weak_count *)*((void *)&v128 + 1);
        uint64_t v90 = v128;
        if (*((void *)&v128 + 1))
        {
          v94 = (unint64_t *)(*((void *)&v128 + 1) + 8LL);
          do
            unint64_t v95 = __ldxr(v94);
          while (__stxr(v95 + 1, v94));
        }
      }

      else
      {
        uint64_t v90 = v125;
        v91 = v126;
        v118 = v126;
        if (v126)
        {
          v92 = (unint64_t *)&v126->__shared_owners_;
          do
            unint64_t v93 = __ldxr(v92);
          while (__stxr(v93 + 1, v92));
        }
      }

      int v96 = *(_DWORD *)(v4 + 280);
      if (v96 == 1) {
        uint64_t v97 = v50;
      }
      else {
        uint64_t v97 = 0LL;
      }
      if (v96 == 2) {
        uint64_t v98 = v6;
      }
      else {
        uint64_t v98 = v97;
      }
      *(void *)&__int128 v131 = v52 / v51;
      *((void *)&v131 + 1) = v55 / v51;
      v132[0] = 2;
      *(void *)&v132[8] = v90;
      *(void *)&v132[16] = v91;
      if (v91)
      {
        v99 = (unint64_t *)&v91->__shared_owners_;
        do
          unint64_t v100 = __ldxr(v99);
        while (__stxr(v100 + 1, v99));
      }

      *(void *)&v132[24] = v98;
      ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::add( v4 + 96,  &v131);
      v101 = *(std::__shared_weak_count **)&v132[16];
      if (*(void *)&v132[16])
      {
        v102 = (unint64_t *)(*(void *)&v132[16] + 8LL);
        do
          unint64_t v103 = __ldaxr(v102);
        while (__stlxr(v103 - 1, v102));
        if (!v103)
        {
          ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
          std::__shared_weak_count::__release_weak(v101);
        }
      }

      if (v118)
      {
        v104 = (unint64_t *)&v118->__shared_owners_;
        do
          unint64_t v105 = __ldaxr(v104);
        while (__stlxr(v105 - 1, v104));
        if (!v105)
        {
          ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
          std::__shared_weak_count::__release_weak(v118);
        }
      }
    }

    goto LABEL_151;
  }

  v115 = *(unsigned int **)(a1 + 112);
  while (!__ldaxr(v115))
  {
    if (!__stlxr(v14, v115))
    {
      *(void *)&__int128 v128 = "details::udif_verify::calculate_checksums(workqueue::workqueue &)_block_invoke";
      *((void *)&v128 + 1) = 41LL;
      int v129 = 16;
      di_log::logger<di_log::log_printer<337ul>>::logger(&v131, &v128);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v138,  (uint64_t)"Error reading sectors for verify ",  33LL);
      std::ostream::operator<<();
      di_log::logger<di_log::log_printer<337ul>>::~logger((uint64_t)&v131);
      goto LABEL_163;
    }
  }

  __clrex();
LABEL_163:
  v112 = v120;
  if (v120)
  {
    v113 = (unint64_t *)&v120->__shared_owners_;
    do
      unint64_t v114 = __ldaxr(v113);
    while (__stlxr(v114 - 1, v113));
    if (!v114)
    {
      ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
      std::__shared_weak_count::__release_weak(v112);
    }
  }

void sub_1880E2CE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
}

void *di_log::logger<di_log::log_printer<337ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<337ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1DEFB0;
  a1[45] = &unk_18A1DF0B0;
  a1[46] = &unk_18A1DF0D8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1DEFB0;
  a1[45] = &unk_18A1DF038;
  a1[46] = &unk_18A1DF060;
  return a1;
}

void sub_1880E2E08(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<337ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::add( uint64_t a1, __int128 *a2)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  uint64_t v3 = (std::mutex *)(a1 + 16);
  __int128 v51 = *a2;
  uint64_t v4 = *((void *)a2 + 3);
  uint64_t v52 = *((void *)a2 + 2);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)a2 + 4);
  uint64_t v6 = *((void *)a2 + 5);
  *((void *)a2 + 3) = 0LL;
  *((void *)a2 + 4) = 0LL;
  unint64_t v53 = v5;
  uint64_t v7 = v51;
  int v54 = *(_DWORD *)((char *)&v52 + 1);
  HIBYTE(v54) = BYTE4(v52);
  std::mutex::lock((std::mutex *)(a1 + 16));
  if (*(_BYTE *)(a1 + 168))
  {
    std::mutex::unlock(v3);
  }

  else
  {
    *(_OWORD *)uint64_t v56 = v51;
    v56[16] = v52;
    *(_DWORD *)&v56[17] = v54;
    *(_DWORD *)&v56[20] = HIDWORD(v52);
    uint64_t v57 = a1;
    __int128 v58 = v51;
    uint64_t v59 = v52;
    uint64_t v60 = v4;
    unint64_t v53 = 0LL;
    unint64_t v61 = v5;
    uint64_t v62 = v6;
    std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::__emplace_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,std::pair<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>( (uint64_t **)(a1 + 88),  (unint64_t *)v56,  (uint64_t)v56);
    uint64_t v8 = v61;
    if (v61)
    {
      p_shared_owners = (unint64_t *)&v61->__shared_owners_;
      do
        unint64_t v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    if ((v52 & 2) == 0) {
      uint64_t v7 = v51 + 1;
    }
    uint64_t v11 = *(void *)(a1 + 160);
    std::mutex::unlock(v3);
    if (v7 == v11)
    {
      unint64_t v12 = (uint64_t *)(a1 + 96);
      while (1)
      {
        *(void *)uint64_t v56 = &v57;
        *(_OWORD *)&v56[8] = xmmword_188179140;
        std::mutex::lock(v3);
        uint64_t v14 = *(uint64_t **)(a1 + 88);
        unint64_t v15 = *(void *)(a1 + 160);
        if (v14 != v12)
        {
          uint64_t v16 = *(void **)(a1 + 144);
          unsigned __int8 v17 = *(void **)(a1 + 112);
          int v18 = *(uint64_t **)(a1 + 88);
          while (v17 != v16)
          {
            uint64_t v19 = v18[4];
            if ((v18[6] & 2) == 0) {
              ++v19;
            }
            if (v19 != v15) {
              break;
            }
            unint64_t v15 = v18[5] + (v18[6] & 1);
            for (uint64_t i = (v17[6] & 1) + v17[5]; v15 > i - 1; uint64_t i = (v17[6] & 1) + v17[5])
            {
              unint64_t v21 = (void *)v17[1];
              unint64_t v22 = v17;
              if (v21)
              {
                do
                {
                  unsigned __int8 v17 = v21;
                  unint64_t v21 = (void *)*v21;
                }

                while (v21);
              }

              else
              {
                do
                {
                  unsigned __int8 v17 = (void *)v22[2];
                  BOOL v23 = *v17 == (void)v22;
                  unint64_t v22 = v17;
                }

                while (!v23);
              }

              *(void *)(a1 + 112) = v17;
              if (v17 == v16)
              {
                unsigned __int8 v17 = v16;
                break;
              }

              if ((v17[6] & 2) != 0) {
                unint64_t v15 = v17[4];
              }
              else {
                unint64_t v15 = v17[4] + 1LL;
              }
            }

            __int128 v24 = (uint64_t *)v18[1];
            if (v24)
            {
              do
              {
                unint64_t v25 = v24;
                __int128 v24 = (uint64_t *)*v24;
              }

              while (v24);
            }

            else
            {
              do
              {
                unint64_t v25 = (uint64_t *)v18[2];
                BOOL v23 = *v25 == (void)v18;
                int v18 = v25;
              }

              while (!v23);
            }

            int v18 = v25;
            if (v25 == v12)
            {
              int v18 = (uint64_t *)(a1 + 96);
              break;
            }
          }

          if (v14 != v18)
          {
            uint64_t v26 = 0LL;
            unint64_t v27 = v14;
            do
            {
              unint64_t v28 = v26;
              unint64_t v29 = (uint64_t *)v27[1];
              if (v29)
              {
                do
                {
                  unint64_t v30 = v29;
                  unint64_t v29 = (uint64_t *)*v29;
                }

                while (v29);
              }

              else
              {
                do
                {
                  unint64_t v30 = (uint64_t *)v27[2];
                  BOOL v23 = *v30 == (void)v27;
                  unint64_t v27 = v30;
                }

                while (!v23);
              }

              ++v26;
              unint64_t v27 = v30;
            }

            while (v30 != v18);
            if (*(void *)&v56[16] <= v28)
            {
              if (v28 >= 0x249249249249249LL) {
                boost::container::throw_length_error( (boost::container *)"get_next_capacity, allocator's max size reached",  v13);
              }
              unint64_t v31 = operator new(56 * v26);
              boost::container::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_range_proxy<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,boost::move_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*>>( (uint64_t *)v56,  (uint64_t)v31,  v26,  *(void *)v56 + 56LL * *(void *)&v56[8],  0LL,  0LL);
            }

            do
            {
              uint64_t v32 = *(void *)v56;
              uint64_t v33 = *(void *)&v56[8];
              unint64_t v34 = (void *)(*(void *)v56 + 56LL * *(void *)&v56[8]);
              if (*(void *)&v56[8] == *(void *)&v56[16])
              {
                boost::container::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>( (uint64_t *)v56,  (uint64_t)v34,  (const char *)1,  (uint64_t)(v14 + 7),  v55);
              }

              else
              {
                void *v34 = v14[7];
                uint64_t v35 = v32 + 56 * v33;
                __int128 v36 = *((_OWORD *)v14 + 4);
                *(void *)(v35 + 24) = v14[10];
                *(_OWORD *)(v35 + 8) = v36;
                *(_OWORD *)(v35 + 32) = *(_OWORD *)(v14 + 11);
                v14[11] = 0LL;
                v14[12] = 0LL;
                *(void *)(v35 + 48) = v14[13];
                ++*(void *)&v56[8];
              }

              unint64_t v37 = std::__tree<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>>>::__remove_node_pointer( (uint64_t **)(a1 + 88),  v14);
              std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)(v14 + 11));
              operator delete(v14);
              uint64_t v14 = v37;
            }

            while (v18 != v37);
          }
        }

        std::mutex::unlock(v3);
        if (*(void *)&v56[8])
        {
          v38 = *(uint64_t **)v56;
          uint64_t v39 = *(void *)v56 + 56LL * *(void *)&v56[8];
          do
          {
            uint64_t v40 = *v38;
            uint64_t v41 = v38[6];
            v55[0] = v38[4];
            v55[1] = v41;
            checksum::Any<locks::None,checksum::None,checksum::CRC32>::add(v40, (uint64_t)v55);
            v38 += 7;
          }

          while (v38 != (uint64_t *)v39);
          uint64_t v42 = *(void *)&v56[8];
          if (*(void *)&v56[8])
          {
            uint64_t v43 = *(void *)v56 + 32LL;
            do
            {
              --v42;
              uint64_t v43 = std::shared_ptr<char>::~shared_ptr[abi:ne180100](v43) + 56;
            }

            while (v42);
          }
        }

        *(void *)&v56[8] = 0LL;
        std::mutex::lock(v3);
        *(void *)(a1 + 160) = v15;
        uint64_t v44 = *(void *)(a1 + 88);
        char v45 = *(_BYTE *)(v44 + 48);
        uint64_t v46 = *(void *)(v44 + 32);
        if ((v45 & 2) != 0) {
          uint64_t v47 = v46;
        }
        else {
          uint64_t v47 = v46 + 1;
        }
        std::mutex::unlock(v3);
        if (v47 != v15) {
          goto LABEL_68;
        }
        boost::container::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)v56);
      }

      std::mutex::unlock(v3);
LABEL_68:
      boost::container::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)v56);
    }
  }

  if (v53)
  {
    int32x2_t v48 = (unint64_t *)&v53->__shared_owners_;
    do
      unint64_t v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }

  return a1;
}

void sub_1880E3360( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
}

void BackendSG::drop_sg(BackendSG *this)
{
  std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100]((uint64_t)this + 64, v5);
  *((_OWORD *)this + 5) = v5[1];
  *(_OWORD *)((char *)this + 89) = *(__int128 *)((char *)&v5[1] + 9);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)&v5[0] + 1);
  if (*((void *)&v5[0] + 1))
  {
    uint64_t v3 = (unint64_t *)(*((void *)&v5[0] + 1) + 8LL);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

void *__copy_helper_block_e8_72c27_ZTSNSt3__110shared_ptrIcEE96c178_ZTSNSt3__110shared_ptrINS_5tupleIJNS_10unique_ptrIN17DiskImageUDIFReadI10UDIFReaderIN5locks4NoneEE13DiskImageUDIFE11ContextUDIFENS_14default_deleteISA_EEEENS0_I9BackendSGEEEEEEE( void *result, void *a2)
{
  uint64_t v2 = a2[10];
  result[9] = a2[9];
  result[10] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[13];
  result[12] = a2[12];
  result[13] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_72c27_ZTSNSt3__110shared_ptrIcEE96c178_ZTSNSt3__110shared_ptrINS_5tupleIJNS_10unique_ptrIN17DiskImageUDIFReadI10UDIFReaderIN5locks4NoneEE13DiskImageUDIFE11ContextUDIFENS_14default_deleteISA_EEEENS0_I9BackendSGEEEEEEE( uint64_t a1)
{
  uint64_t v1 = a1 + 72;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](a1 + 96);
  return std::shared_ptr<char>::~shared_ptr[abi:ne180100](v1);
}

const void **DiskImageUDIF::get_user_data@<X0>(DiskImageUDIF *this@<X0>, CFMutableDictionaryRef *a2@<X8>)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)copy_user_entry_from_resource, Mutable);
  *a2 = Mutable;
  return CFAutoRelease<__CFDictionary const*>::~CFAutoRelease((const void **)&theDict);
}

void sub_1880E3524(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void copy_user_entry_from_resource(const __CFString *a1, const void *a2, __CFDictionary *a3)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (a1)
  {
    CFTypeID v7 = TypeID;
    if (CFGetTypeID(a1) != TypeID)
    {
      exception = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
      CFTypeID v15 = CFGetTypeID(a1);
LABEL_16:
      uint64_t v16 = exception;
      unint64_t v17 = v7;
      goto LABEL_17;
    }
  }

  int OSType = CFStringGetOSType(a1);
  switch(OSType)
  {
    case 1651272568:
      return;
    case 1886155636:
      return;
    case 1970628964:
      return;
  }

  CFTypeID v9 = CFArrayGetTypeID();
  if (!a2) {
    return;
  }
  CFTypeID v7 = v9;
  if (CFGetTypeID(a2) != v9)
  {
    exception = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
    CFTypeID v15 = CFGetTypeID(a2);
    goto LABEL_16;
  }

  if (CFArrayGetCount((CFArrayRef)a2) >= 1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, 0LL);
    CFTypeID v11 = CFDictionaryGetTypeID();
    if (ValueAtIndex)
    {
      CFTypeID v12 = v11;
      if (CFGetTypeID(ValueAtIndex) != v11)
      {
LABEL_19:
        uint64_t v19 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
        CFTypeID v15 = CFGetTypeID(ValueAtIndex);
        uint64_t v16 = v19;
        unint64_t v17 = v12;
LABEL_17:
        int v18 = (void *)cf::CFUtilException::CFUtilException(v16, v15, v17);
      }

      ValueAtIndex = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"Data");
      CFTypeID v13 = CFDataGetTypeID();
      if (ValueAtIndex)
      {
        CFTypeID v12 = v13;
        if (CFGetTypeID(ValueAtIndex) == v13)
        {
          CFDictionaryAddValue(a3, a1, ValueAtIndex);
          return;
        }

        goto LABEL_19;
      }
    }
  }

void sub_1880E36F0(_Unwind_Exception *a1)
{
}

const void **DiskImageUDIF::write_user_data(DiskImageUDIF *this, const __CFDictionary *a2)
{
  unint64_t v4 = (DiskImageUDIF *)((char *)this + 64);
  udif::details::UDIF_base::get_resources((DiskImageUDIF *)((char *)this + 64), &theDict);
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, theDict);
  uint64_t v14 = MutableCopy;
  if (!MutableCopy)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    unint64_t v10 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v10;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Failed creating CFAutoRelease instance.";
  }

  CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)details::copy_user_entry_to_resource, MutableCopy);
  unint64_t v6 = udif::details::UDIF_base::write_resources(v4, v14);
  unsigned int v7 = (*(uint64_t (**)(void, unint64_t))(**((void **)this + 6) + 56LL))(*((void *)this + 6), v6);
  if (v7)
  {
    CFTypeID v11 = "UDIFDiskImage: failed truncating image";
    goto LABEL_8;
  }

  unsigned int v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 6) + 16LL))(*((void *)this + 6), 2LL);
  if (v7)
  {
    CFTypeID v11 = "UDIFDiskImage: failed flush after user data write";
LABEL_8:
    CFTypeID v12 = __cxa_allocate_exception(0x40uLL);
    *CFTypeID v12 = off_18A1E43B0;
    CFTypeID v13 = std::generic_category();
    v12[1] = v7;
    v12[2] = v13;
    *((_BYTE *)v12 + 24) = 0;
    *((_BYTE *)v12 + 48) = 0;
    v12[7] = v11;
  }

  CFAutoRelease<__CFDictionary *>::~CFAutoRelease((const void **)&v14);
  return CFAutoRelease<__CFDictionary const*>::~CFAutoRelease((const void **)&theDict);
}

void sub_1880E388C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

BOOL DiskImageUDIF::verify_image(DiskImageUDIF *this, workqueue::workqueue *a2, int a3)
{
  v12[13] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v5 = (DiskImageUDIF *)((char *)this + 64);
  if (a3)
  {
    details::udif_verify::udif_verify((details::udif_verify *)v9, this, v5, 3);
  }

  else
  {
    details::udif_verify::udif_verify((details::udif_verify *)v9, this, v5);
    if (!details::udif_verify::calculate_checksums(v9, a2))
    {
LABEL_6:
      BOOL v6 = details::udif_verify::verify_checksums((details::udif_verify *)v9);
      goto LABEL_7;
    }
  }

  BOOL v6 = 0LL;
LABEL_7:
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( (uint64_t)v12,  v12[1]);
  std::mutex::~mutex(&v11);
  uint64_t v8 = (void **)&v10;
  std::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::__destroy_vector::operator()[abi:ne180100](&v8);
  return v6;
}

void sub_1880E39A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *DiskImageUDIF::udif_extents_iterator_interface::make_val@<X0>(void *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = this[5];
  unint64_t v4 = (void *)this[8];
  uint64_t v3 = (void *)this[9];
  if (v4 == v3)
  {
LABEL_9:
    int v8 = 0;
    int v9 = 1;
    unint64_t v4 = v3;
    goto LABEL_21;
  }

  while (1)
  {
    unint64_t v5 = v4[5];
    if (v2 <= (v4[6] & 1) + v5 - 1) {
      break;
    }
    BOOL v6 = (void *)v4[1];
    if (v6)
    {
      do
      {
        unsigned int v7 = v6;
        BOOL v6 = (void *)*v6;
      }

      while (v6);
    }

    else
    {
      do
      {
        unsigned int v7 = (void *)v4[2];
        BOOL v16 = *v7 == (void)v4;
        unint64_t v4 = v7;
      }

      while (!v16);
    }

    this[8] = v7;
    unint64_t v4 = v7;
    if (v7 == v3) {
      goto LABEL_9;
    }
  }

  unint64_t v10 = v4[4];
  if ((v4[6] & 2) != 0)
  {
    if (v2 < v10) {
      goto LABEL_20;
    }
  }

  else if (v10 >= v2)
  {
    goto LABEL_20;
  }

  if ((v4[6] & 1) != 0)
  {
    if (v5 >= v2) {
      goto LABEL_18;
    }
LABEL_20:
    int v8 = 0;
    int v9 = 1;
    goto LABEL_21;
  }

  if (v2 >= v5) {
    goto LABEL_20;
  }
LABEL_18:
  int v11 = *((_DWORD *)v4 + 14);
  if (v11 != 1 && (v11 & 0xFF000000) != 0x80000000) {
    goto LABEL_20;
  }
  int v9 = 0;
  int v8 = 1;
LABEL_21:
  unint64_t v12 = this[3];
  unint64_t v13 = v2;
  if (v2 < v12)
  {
    unint64_t v13 = v2;
    do
    {
      unint64_t v14 = v12;
      if (v4 == v3) {
        goto LABEL_27;
      }
      unint64_t v14 = v4[4];
      if ((v4[6] & 2) == 0) {
        ++v14;
      }
      if (v14 > v13)
      {
LABEL_27:
        if ((v8 & 1) != 0) {
          break;
        }
      }

      else
      {
        if (v8)
        {
          int v15 = *((_DWORD *)v4 + 14);
          BOOL v16 = v15 == 1 || (v15 & 0xFF000000) == 0x80000000;
          if (!v16) {
            break;
          }
        }

        if (v9)
        {
          int v17 = *((_DWORD *)v4 + 14);
          if (v17 == 1 || (v17 & 0xFF000000) == 0x80000000) {
            break;
          }
        }

        int v18 = (void *)v4[1];
        uint64_t v19 = v4;
        if (v18)
        {
          do
          {
            uint64_t v20 = v18;
            int v18 = (void *)*v18;
          }

          while (v18);
        }

        else
        {
          do
          {
            uint64_t v20 = (void *)v19[2];
            BOOL v16 = *v20 == (void)v19;
            uint64_t v19 = v20;
          }

          while (!v16);
        }

        unint64_t v14 = (v4[6] & 1) + v4[5];
        this[8] = v20;
        unint64_t v4 = v20;
      }

      unint64_t v13 = v14;
    }

    while (v14 < v12);
  }

  *(void *)a2 = v2;
  *(void *)(a2 + 8) = v13;
  *(_BYTE *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 24) = v8;
  return this;
}

__n128 DiskImageUDIF::udif_extents_iterator_interface::clone@<Q0>( DiskImageUDIF::udif_extents_iterator_interface *this@<X0>, void *a2@<X8>)
{
  unint64_t v4 = (char *)operator new(0x50uLL);
  *(_OWORD *)(v4 + 8) = *(_OWORD *)((char *)this + 8);
  *(_OWORD *)(v4 + 24) = *(_OWORD *)((char *)this + 24);
  *((void *)v4 + 5) = *((void *)this + 5);
  *(void *)unint64_t v4 = off_18A1DEE20;
  __n128 result = *((__n128 *)this + 3);
  __int128 v6 = *((_OWORD *)this + 4);
  *((__n128 *)v4 + 3) = result;
  *((_OWORD *)v4 + 4) = v6;
  *a2 = v4;
  return result;
}

void DiskImageUDIF::~DiskImageUDIF(DiskImageUDIF *this)
{
  *(void *)this = &off_18A1CACA8;
  uint64_t v1 = (char *)this + 48;
  udif::details::UDIF_base::~UDIF_base((DiskImageUDIF *)((char *)this + 64));
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v1);
}

{
  char *v2;
  *(void *)this = &off_18A1CACA8;
  unint64_t v2 = (char *)this + 48;
  udif::details::UDIF_base::~UDIF_base((DiskImageUDIF *)((char *)this + 64));
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  operator delete(this);
}

uint64_t DiskImageUDIF::is_writable(DiskImageUDIF *this)
{
  return 0LL;
}

info::DiskImageInfoUDIF *DiskImageUDIF::create_image_info@<X0>( DiskImageUDIF *this@<X0>, char a2@<W1>, void *a3@<X8>)
{
  __int128 v6 = (info::DiskImageInfoUDIF *)operator new(0x120uLL);
  __n128 result = info::DiskImageInfoUDIF::DiskImageInfoUDIF(v6, this, a2);
  *a3 = (char *)v6 + *(void *)(*(void *)v6 - 104LL);
  return result;
}

void sub_1880E3CBC(_Unwind_Exception *a1)
{
}

uint64_t DiskImageUDIF::supports_get_extents(DiskImageUDIF *this)
{
  return 1LL;
}

uint64_t DiskImageUDIF::get_extents_iterator_interface@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  unint64_t v12 = operator new(0x50uLL);
  v12[1] = *(_OWORD *)a4;
  *((void *)v12 + 4) = *(void *)(a4 + 16);
  *((void *)v12 + 5) = a5;
  *((void *)v12 + 6) = a1;
  *((void *)v12 + 7) = a3;
  *(void *)unint64_t v12 = off_18A1DEE20;
  *((void *)v12 + 1) = a2;
  *((void *)v12 + 8) = 0LL;
  *((void *)v12 + 9) = 0LL;
  uint64_t result = udif::details::UDIF_base::create_runs_range_iterator(a1 + 64, (uint64_t)(v12 + 1));
  *((void *)v12 + 8) = result;
  *((void *)v12 + 9) = v14;
  *a6 = v12;
  return result;
}

void sub_1880E3D64(_Unwind_Exception *a1)
{
}

uint64_t DiskImageUDIF::write()
{
  return -78LL;
}

_WORD *udif::details::block_attributes::block_attributes(_WORD *this, int a2)
{
  uint64_t v2 = 0LL;
  uint64_t v8 = *MEMORY[0x1895F89C0];
  *this = a2;
  uint64_t v5 = 0x10000800040002LL;
  int v6 = 4194336;
  __int16 v7 = 128;
  do
  {
    a2 &= *(unsigned __int16 *)((char *)&v5 + v2) ^ 0xFFFF;
    v2 += 2LL;
  }

  while (v2 != 14);
  if (a2)
  {
    __int16 v3 = a2;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid flags";
    exception[3] = "flags validator";
    void *exception = off_18A1DEF68;
    exception[1] = "block_attributes";
    *((_WORD *)exception + 16) = v3;
  }

  return this;
}

void smart_enums::validators::validator_exception<unsigned short>::~validator_exception(std::exception *a1)
{
}

void smart_enums::validators::validator_exception<unsigned short>::reason( smart_enums::validators::validator_exception_base *a1@<X0>, void *a2@<X8>)
{
  __int16 v3 = (char *)smart_enums::validators::validator_exception_base::what(a1);
  std::string::basic_string[abi:ne180100]<0>(v15, v3);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v10);
  if ((v16 & 0x80u) == 0) {
    unint64_t v4 = v15;
  }
  else {
    unint64_t v4 = (void **)v15[0];
  }
  if ((v16 & 0x80u) == 0) {
    uint64_t v5 = v16;
  }
  else {
    uint64_t v5 = (uint64_t)v15[1];
  }
  int v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)v4, v5);
  __int16 v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" [", 2LL);
  *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(*v7 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"]", 1LL);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v12, a2);
  v10[0] = *MEMORY[0x189614728];
  uint64_t v9 = *(void *)(MEMORY[0x189614728] + 72LL);
  *(void *)((char *)v10 + *(void *)(v10[0] - 24LL)) = *(void *)(MEMORY[0x189614728] + 64LL);
  uint64_t v11 = v9;
  v12[0] = MEMORY[0x189614750] + 16LL;
  if (v13 < 0) {
    operator delete((void *)v12[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1895BC2CC](&v14);
}

_BYTE ***std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<details::udif_verify::is_csum_data_none_type(ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,checksum::None<locks::None>,checksum::CRC32<locks::None>> const&>( _BYTE ***result)
{
  **info::DiskImageInfoUDIF *result = 1;
  return result;
}

_BYTE ***std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<details::udif_verify::is_csum_data_none_type(ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,checksum::None<locks::None>,checksum::CRC32<locks::None>> const&>( _BYTE ***result)
{
  **info::DiskImageInfoUDIF *result = 0;
  return result;
}

void std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( a1,  *a2);
    std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( a1,  a2[1]);
    std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 11));
    operator delete(a2);
  }

void std::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::__destroy_vector::operator()[abi:ne180100]( void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::__base_destruct_at_end[abi:ne180100]( (uint64_t)v2,  (uint64_t)*v2);
    operator delete(**a1);
  }

void std::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::__base_destruct_at_end[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 != a2)
  {
    do
    {
      uint64_t v5 = v4 - 184;
      int v6 = (std::mutex *)(v4 - 168);
      std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( v4 - 96,  *(void **)(v4 - 88));
      std::mutex::~mutex(v6);
      uint64_t v4 = v5;
    }

    while (v5 != a2);
  }

  *(void *)(a1 + 8) = a2;
}

uint64_t std::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::__emplace_back_slow_path<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>( uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xD37A6F4DE9BD37A7LL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x1642C8590B21642LL) {
    std::vector<iovec>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xD37A6F4DE9BD37A7LL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xB21642C8590B21LL) {
    unint64_t v9 = 0x1642C8590B21642LL;
  }
  else {
    unint64_t v9 = v5;
  }
  int v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::allocate_at_least[abi:ne180100]( v7,  v9);
  }
  else {
    unint64_t v10 = 0LL;
  }
  char v13 = v10;
  uint64_t v14 = &v10[184 * v4];
  unsigned __int8 v16 = &v10[184 * v9];
  std::construct_at[abi:ne180100]<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>( (uint64_t)v14,  a2);
  int v15 = v14 + 184;
  std::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::__swap_out_circular_buffer( a1,  &v13);
  uint64_t v11 = a1[1];
  std::__split_buffer<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_1880E41D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

__n128 std::construct_at[abi:ne180100]<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>( uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = 850045863LL;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0LL;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  uint64_t v2 = (void *)(a2 + 96);
  uint64_t v3 = *(void *)(a2 + 96);
  *(void *)(a1 + 96) = v3;
  uint64_t v4 = a1 + 96;
  uint64_t v5 = *(void *)(a2 + 104);
  *(void *)(a1 + 104) = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    *(void *)(a2 + 88) = v2;
    void *v2 = 0LL;
    *(void *)(a2 + 104) = 0LL;
  }

  else
  {
    *(void *)(a1 + 88) = v4;
  }

  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  __n128 result = *(__n128 *)(a2 + 144);
  *(__n128 *)(a1 + 144) = result;
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  *(_BYTE *)(a1 + 168) = 0;
  *(_BYTE *)(a1 + 176) = *(_BYTE *)(a2 + 176);
  return result;
}

uint64_t std::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::__swap_out_circular_buffer( uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>,std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>,std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>,std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>>( (uint64_t)(a1 + 2),  a1[1],  a1[1],  *a1,  *a1,  a2[1],  a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::allocate_at_least[abi:ne180100]( uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1642C8590B21643LL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(184 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>,std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>,std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>,std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v15 = a6;
  *((void *)&v15 + 1) = a7;
  __int128 v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  char v13 = 0;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }

  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 184LL;
      std::construct_at[abi:ne180100]<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>( v7 - 184,  v9);
      uint64_t v7 = *((void *)&v15 + 1) - 184LL;
      *((void *)&v15 + 1) -= 184LL;
    }

    while (v9 != a5);
    uint64_t v10 = v15;
  }

  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>,std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

void sub_1880E43DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>,std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>>>::~__exception_guard_exceptions[abi:ne180100]( uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>,std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>,std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>>::operator()[abi:ne180100]( uint64_t *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v14 = v3;
  uint64_t v15 = v2;
  uint64_t v16 = v3;
  uint64_t v17 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v9 = v7;
  uint64_t v10 = v6;
  uint64_t v11 = v7;
  uint64_t v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>,std::reverse_iterator<std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>>,std::reverse_iterator<std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>>>( v4,  (uint64_t)v13,  (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>,std::reverse_iterator<std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>>,std::reverse_iterator<std::reverse_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>*>>>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *(void *)(a2 + 32); i != *(void *)(a3 + 32); *(void *)(a2 + 32) = i)
  {
    uint64_t v6 = (std::mutex *)(i + 16);
    std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( i + 88,  *(void **)(i + 96));
    std::mutex::~mutex(v6);
    uint64_t i = *(void *)(a2 + 32) + 184LL;
  }

uint64_t std::__split_buffer<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::~__split_buffer( uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>>::__destruct_at_end[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 184;
    uint64_t v5 = (std::mutex *)(i - 168);
    std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( i - 96,  *(void **)(i - 88));
    std::mutex::~mutex(v5);
  }

void non-virtual thunk to'di_log::logger<di_log::log_printer<337ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<337ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<337ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<337ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<337ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<337ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<337ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<337ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<337ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<337ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1DF148;
  di_log::logger_buf<di_log::log_printer<337ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<337ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<337ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880E491C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<337ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<337ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<337ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 337LL;
    __int16 v22 = 2082;
    BOOL v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 337LL;
      __int16 v22 = 2082;
      BOOL v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

const void **CFAutoRelease<__CFArray const*>::~CFAutoRelease(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t udif::master_checksum_add<checksum::Any<locks::None,checksum::None,checksum::CRC32>>( uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  udif::details::checksum::checksum((uint64_t)&v15, a2);
  int v4 = v15;
  __int128 v9 = v20;
  __int128 v10 = v21;
  __int128 v11 = v22;
  __int128 v12 = v23;
  __int128 v5 = v16;
  __int128 v6 = v17;
  __int128 v7 = v18;
  __int128 v8 = v19;
  udif::details::serialize_field((uint64_t)&v4, (uint64_t)v13);
  int v4 = &v14;
  *(void *)&__int128 v5 = (unint64_t)HIDWORD(v15) >> 3;
  checksum::Any<locks::None,checksum::None,checksum::CRC32>::add(a1, (uint64_t)&v4);
  return a1;
}

uint64_t checksum::Any<locks::None,checksum::None,checksum::CRC32>::add(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v2 = *(unsigned int *)(a1 + 12);
  if ((_DWORD)v2 == -1) {
    std::__throw_bad_variant_access[abi:ne180100]();
  }
  __int128 v6 = &v5;
  ((void (*)(uint64_t **, uint64_t))off_18A1DF1B8[v2])(&v6, a1 + 4);
  return a1;
}

uLong _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IONS1_9__variant15__value_visitorIZN8checksum3AnyIN5locks4NoneEJNS8_4NoneENS8_5CRC32EEE3addERK18checksum_algo_dataEUlRT_E_EEJRNS0_6__baseILNS0_6_TraitE0EJNSC_ISB_EENSD_ISB_EEEEEEEEDcSI_DpT0_( const Bytef ****a1, _DWORD *a2)
{
  uLong result = crc32(*a2, ***a1, *((_DWORD *)**a1 + 2));
  *a2 = result;
  return result;
}

uint64_t ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::ChecksumScheduler( uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)uLong result = *(_OWORD *)a2;
  if ((*(_BYTE *)(a3 + 16) & 2) != 0) {
    unint64_t v3 = *(void *)a3;
  }
  else {
    unint64_t v3 = *(void *)a3 + 1LL;
  }
  uint64_t v5 = (_OWORD *)(a2 + 144);
  int v4 = *(void **)(a2 + 144);
  __int128 v6 = *(void **)(a2 + 128);
  uint64_t v7 = *(void *)(a2 + 136);
  if (v6 != v4)
  {
    while (1)
    {
      unint64_t v8 = v6[4];
      if ((v6[6] & 2) == 0) {
        ++v8;
      }
      if (v8 >= v3) {
        break;
      }
      __int128 v9 = (void *)v6[1];
      if (v9)
      {
        do
        {
          __int128 v10 = v9;
          __int128 v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          __int128 v10 = (void *)v6[2];
          BOOL v11 = *v10 == (void)v6;
          __int128 v6 = v10;
        }

        while (!v11);
      }

      __int128 v6 = v10;
      if (v10 == v4) {
        goto LABEL_29;
      }
    }
  }

  if (v6 == v4)
  {
LABEL_29:
    int v17 = *(_DWORD *)(a2 + 80);
    *(void *)(result + 96) = 0LL;
    *(void *)(result + 16) = 850045863LL;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(void *)(result + 72) = 0LL;
    *(_DWORD *)(result + 80) = v17;
    *(void *)(result + 104) = 0LL;
    *(void *)(result + 88) = result + 96;
    *(_OWORD *)(result + 112) = *v5;
    *(_OWORD *)(result + 128) = *v5;
    *(_OWORD *)(result + 144) = *v5;
    *(_BYTE *)(result + 168) = 0;
    __int128 v6 = *(void **)(result + 112);
    if (v6 == *(void **)(result + 144)) {
      goto LABEL_33;
    }
    goto LABEL_30;
  }

  __int128 v12 = v6;
  while (1)
  {
    unint64_t v13 = v12[4];
    if ((v12[6] & 2) == 0) {
      ++v13;
    }
    uint64_t v14 = (void *)v12[1];
    if (v14)
    {
      do
      {
        uint64_t v15 = v14;
        uint64_t v14 = (void *)*v14;
      }

      while (v14);
    }

    else
    {
      do
      {
        uint64_t v15 = (void *)v12[2];
        BOOL v11 = *v15 == (void)v12;
        __int128 v12 = v15;
      }

      while (!v11);
    }

    __int128 v12 = v15;
    if (v15 == v4)
    {
      __int128 v12 = *(void **)(a2 + 144);
      break;
    }
  }

  int v16 = *(_DWORD *)(a2 + 80);
  *(void *)(result + 96) = 0LL;
  *(void *)(result + 16) = 850045863LL;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(void *)(result + 72) = 0LL;
  *(_DWORD *)(result + 80) = v16;
  *(void *)(result + 88) = result + 96;
  *(void *)(result + 104) = 0LL;
  *(void *)(result + 112) = v6;
  *(void *)(result + 120) = v7;
  *(void *)(result + 128) = v6;
  *(void *)(result + 136) = v7;
  *(void *)(result + 144) = v12;
  *(void *)(result + 152) = v7;
  *(_BYTE *)(result + 168) = 0;
  if (v6 != v12)
  {
LABEL_30:
    char v18 = *((_BYTE *)v6 + 48);
    uint64_t v19 = v6[4];
    if ((v18 & 2) == 0) {
      ++v19;
    }
    *(void *)(result + 160) = v19;
  }

uint64_t ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::ContextAllocator( uint64_t a1, unsigned int a2)
{
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 850045863LL;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 1018212795LL;
  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 129) = 0u;
  if (a2) {
    std::vector<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *,std::allocator<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *>>::reserve( (void **)(a1 + 8),  a2);
  }
  return a1;
}

void sub_1880E4F34(_Unwind_Exception *a1)
{
  __int128 v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v6;
    operator delete(v6);
  }

  _Unwind_Resume(a1);
}

void std::vector<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *,std::allocator<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *>>::reserve( void **a1, unint64_t a2)
{
  int v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<iovec>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    __int128 v6 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( v3,  a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8LL];
    __int128 v9 = &v6[8 * v8];
    BOOL v11 = (char *)*a1;
    __int128 v10 = (char *)a1[1];
    __int128 v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }

      while (v10 != v11);
      __int128 v10 = (char *)*a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::~ContextAllocator( uint64_t a1)
{
  uint64_t v2 = *(uint64_t ***)(a1 + 8);
  uint64_t v3 = *(uint64_t ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      int v4 = *v2;
      if (*v2)
      {
        std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)(v4 + 1));
        uint64_t v5 = *v4;
        *int v4 = 0LL;
        if (v5) {
          (*(void (**)(uint64_t))(*(void *)v5 + 40LL))(v5);
        }
        operator delete(v4);
      }

      ++v2;
    }

    while (v2 != v3);
    uint64_t v2 = *(uint64_t ***)(a1 + 8);
  }

  *(void *)(a1 + 16) = v2;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 96));
  std::mutex::~mutex((std::mutex *)(a1 + 32));
  __int128 v6 = *(void **)(a1 + 8);
  if (v6)
  {
    *(void *)(a1 + 16) = v6;
    operator delete(v6);
  }

  return a1;
}

void std::allocate_shared[abi:ne180100]<BackendSG,std::allocator<BackendSG>,std::shared_ptr<Backend> const&,unsigned long &,int,BOOL,void>( uint64_t a1@<X1>, void *a2@<X2>, int *a3@<X3>, unsigned __int8 *a4@<X4>, void *a5@<X8>)
{
  __int128 v10 = operator new(0x90uLL);
  std::__shared_ptr_emplace<BackendSG>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<Backend> const&,unsigned long &,int,BOOL,std::allocator<BackendSG>,0>( v10,  a1,  a2,  a3,  a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a5,  v10 + 4,  (uint64_t)(v10 + 3));
}

void sub_1880E50F8(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<BackendSG>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<Backend> const&,unsigned long &,int,BOOL,std::allocator<BackendSG>,0>( void *a1, uint64_t a2, void *a3, int *a4, unsigned __int8 *a5)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1DF1D8;
  BackendSG::BackendSG(a1 + 3, a2, *a3, *a4, *a5);
  return a1;
}

void sub_1880E514C(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<BackendSG>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_18A1DF1D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<BackendSG>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_18A1DF1D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<BackendSG>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void ExecutionSchedulerSortedConsecutiveIt<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,locks::Std,boost::iterators::transform_iterator<interval_map2set_it::$_0,std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__tree_node<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,void *> *,long>>,boost::use_default,boost::use_default>>::abort( uint64_t a1)
{
  *(_BYTE *)(a1 + 152) = 1;
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::destroy( a1 + 72,  *(void **)(a1 + 80));
  *(void *)(a1 + 72) = a1 + 80;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  std::mutex::unlock((std::mutex *)a1);
}

void *std::shared_ptr<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>>::shared_ptr[abi:ne180100]<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>,ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::allocate(void)::{lambda(std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>)#1},void>( void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  __int128 v6 = operator new(0x28uLL);
  *__int128 v6 = off_18A1DF228;
  v6[1] = 0LL;
  v6[2] = 0LL;
  v6[3] = a2;
  v6[4] = a3;
  a1[1] = v6;
  return a1;
}

void sub_1880E5248(void *a1, uint64_t a2, ...)
{
}

void sub_1880E5260(_Unwind_Exception *a1)
{
}

void ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::allocate(void)::{lambda(locks::Std)#1}::operator()<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *>( void *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  int v4 = (std::mutex *)(*a1 + 32LL);
  std::mutex::lock(v4);
  uint64_t v5 = *(void **)(v3 + 16);
  unint64_t v6 = *(void *)(v3 + 24);
  if ((unint64_t)v5 >= v6)
  {
    uint64_t v8 = *(void *)(v3 + 8);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    uint64_t v10 = v6 - v8;
    uint64_t v11 = v10 >> 2;
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      uint64_t v13 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( v3 + 24,  v12);
    }
    else {
      uint64_t v13 = 0LL;
    }
    uint64_t v14 = &v13[8 * v9];
    uint64_t v15 = &v13[8 * v12];
    *(void *)uint64_t v14 = a2;
    uint64_t v7 = v14 + 8;
    int v17 = *(char **)(v3 + 8);
    int v16 = *(char **)(v3 + 16);
    if (v16 != v17)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *((void *)v14 - 1) = v18;
        v14 -= 8;
      }

      while (v16 != v17);
      int v16 = *(char **)(v3 + 8);
    }

    *(void *)(v3 + 8) = v14;
    *(void *)(v3 + 16) = v7;
    *(void *)(v3 + 24) = v15;
    if (v16) {
      operator delete(v16);
    }
  }

  else
  {
    *uint64_t v5 = a2;
    uint64_t v7 = v5 + 1;
  }

  *(void *)(v3 + 16) = v7;
  std::mutex::unlock(v4);
  std::condition_variable::notify_one((std::condition_variable *)(v3 + 96));
}

void sub_1880E5374(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *,ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::allocate(void)::{lambda(std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *)#1},std::allocator<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *,ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::allocate(void)::{lambda(std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *)#1},std::allocator<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>>>::__on_zero_shared( uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *,ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::allocate(void)::{lambda(std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *)#1},std::allocator<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>>>::__get_deleter( uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100]( a2,  (uint64_t)&_ZTIZN16ContextAllocatorIN5locks3StdEJNSt3__110unique_ptrIN17DiskImageUDIFReadI10UDIFReaderINS0_4NoneEE13DiskImageUDIFE11ContextUDIFENS2_14default_deleteISA_EEEENS2_10shared_ptrI9BackendSGEEEE8allocateEvEUlT_E_))
  {
    return a1 + 32;
  }

  else
  {
    return 0LL;
  }

uint64_t di_log::logger_buf<di_log::log_printer<337ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DF148;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880E546C(_Unwind_Exception *a1)
{
}

_OWORD *std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::__emplace_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,std::pair<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>( uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  __int128 v5 = (void **)std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  &v12,  a2);
  unint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    unint64_t v6 = operator new(0x70uLL);
    v10[1] = a1 + 1;
    v6[2] = *(_OWORD *)a3;
    uint64_t v8 = *(void *)(a3 + 24);
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *((void *)v6 + 7) = v8;
    v6[4] = *(_OWORD *)(a3 + 32);
    *((void *)v6 + 10) = *(void *)(a3 + 48);
    *(_OWORD *)((char *)v6 + 88) = *(_OWORD *)(a3 + 56);
    *(void *)(a3 + 56) = 0LL;
    *(void *)(a3 + 64) = 0LL;
    *((void *)v6 + 13) = *(void *)(a3 + 72);
    char v11 = 1;
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  v12,  v7,  (uint64_t *)v6);
    v10[0] = 0LL;
    std::unique_ptr<std::__tree_node<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,void *>>>>::reset[abi:ne180100]( (uint64_t)v10,  0LL);
  }

  return v6;
}

void *std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( uint64_t a1, void *a2, unint64_t *a3)
{
  __int128 v5 = (void *)(a1 + 8);
  char v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = v4;
        uint64_t v8 = v4 + 4;
        if (!boost::icl::operator<<boost::icl::discrete_interval<unsigned long long,std::less>>( a3,  v4 + 4)) {
          break;
        }
        char v4 = (void *)*v7;
        __int128 v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      __int128 v5 = v7 + 1;
      char v4 = (void *)v7[1];
    }

    while (v4);
  }

  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }

uint64_t boost::icl::operator<<boost::icl::discrete_interval<unsigned long long,std::less>>( unint64_t *a1, unint64_t *a2)
{
  int v2 = *((unsigned __int8 *)a1 + 16);
  if (*((_BYTE *)a1 + 16))
  {
    if (v2 == 3)
    {
      unint64_t v4 = *a1;
      unint64_t v3 = a1[1];
      if (v3 >= *a1)
      {
LABEL_4:
        if ((v2 & 2) != 0) {
          unint64_t v5 = v4;
        }
        else {
          unint64_t v5 = v4 + 1;
        }
        unint64_t v6 = *a2;
        if ((a2[2] & 2) == 0) {
          ++v6;
        }
        if (v5 < v6) {
          return 1LL;
        }
        if (v6 == v5) {
          return (v2 & 1) + v3 - 1 < (a2[2] & 1) + a2[1] - 1;
        }
        return 0LL;
      }
    }

    else
    {
      unint64_t v4 = *a1;
      unint64_t v3 = a1[1];
      if (*a1 < v3) {
        goto LABEL_4;
      }
    }
  }

  else
  {
    unint64_t v4 = *a1;
    unint64_t v3 = a1[1];
    if (*a1 < v3 && *a1 + 1 < v3) {
      goto LABEL_4;
    }
  }

  if (*((_BYTE *)a2 + 16))
  {
    if (*((_BYTE *)a2 + 16) == 3) {
      BOOL v9 = a2[1] < *a2;
    }
    else {
      BOOL v9 = *a2 >= a2[1];
    }
  }

  else
  {
    unint64_t v10 = a2[1];
    BOOL v9 = *a2 >= v10 || *a2 + 1 >= v10;
  }

  return !v9;
}

void std::unique_ptr<std::__tree_node<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,void *>>>>::reset[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  int v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v2 + 88);
    }
    operator delete(v2);
  }

void boost::container::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_range_proxy<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,boost::move_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*>>( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *a1;
  boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,boost::container::dtl::insert_range_proxy<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,boost::move_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*>>( (uint64_t)a1,  *a1,  a4,  *a1 + 56 * a1[1],  a2,  a5,  a6);
  if (v10)
  {
    uint64_t v11 = a1[1];
    if (v11)
    {
      uint64_t v12 = v10 + 32;
      do
      {
        --v11;
        uint64_t v12 = std::shared_ptr<char>::~shared_ptr[abi:ne180100](v12) + 56;
      }

      while (v11);
    }
  }

  uint64_t v13 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v13;
  a1[2] = a3;
}

void sub_1880E57C4(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

__n128 boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,boost::container::dtl::insert_range_proxy<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,boost::move_iterator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*>>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  while (a2 != a3)
  {
    *(void *)a5 = *(void *)a2;
    __int128 v7 = *(_OWORD *)(a2 + 8);
    *(void *)(a5 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a5 + 8) = v7;
    __n128 result = *(__n128 *)(a2 + 32);
    *(__n128 *)(a5 + 32) = result;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    *(void *)(a5 + 48) = *(void *)(a2 + 48);
    a5 += 56LL;
    a2 += 56LL;
  }

  if (a6)
  {
    uint64_t v9 = a6;
    uint64_t v10 = a5;
    do
    {
      *(void *)uint64_t v10 = *(void *)a7;
      __int128 v11 = *(_OWORD *)(a7 + 8);
      *(void *)(v10 + 24) = *(void *)(a7 + 24);
      *(_OWORD *)(v10 + 8) = v11;
      __n128 result = *(__n128 *)(a7 + 32);
      *(__n128 *)(v10 + 32) = result;
      *(void *)(a7 + 32) = 0LL;
      *(void *)(a7 + 40) = 0LL;
      *(void *)(v10 + 48) = *(void *)(a7 + 48);
      a7 += 56LL;
      v10 += 56LL;
      --v9;
    }

    while (v9);
  }

  if (a3 != a4)
  {
    uint64_t v12 = a5 + 56 * a6;
    do
    {
      *(void *)uint64_t v12 = *(void *)a3;
      __int128 v13 = *(_OWORD *)(a3 + 8);
      *(void *)(v12 + 24) = *(void *)(a3 + 24);
      *(_OWORD *)(v12 + 8) = v13;
      __n128 result = *(__n128 *)(a3 + 32);
      *(__n128 *)(v12 + 32) = result;
      *(void *)(a3 + 32) = 0LL;
      *(void *)(a3 + 40) = 0LL;
      *(void *)(v12 + 48) = *(void *)(a3 + 48);
      a3 += 56LL;
      v12 += 56LL;
    }

    while (a3 != a4);
  }

  return result;
}

void boost::container::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>( uint64_t *a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = boost::container::vector_alloc_holder<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( (uint64_t)a1,  a3);
  if (v11 >= 0x24924924924924ALL) {
    boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v12);
  }
  uint64_t v13 = v11;
  uint64_t v14 = operator new(56 * v11);
  boost::container::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>( a1,  (uint64_t)v14,  v13,  a2,  (uint64_t)a3,  a4);
  *a5 = *a1 + a2 - v10;
}

unint64_t boost::container::vector_alloc_holder<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( uint64_t a1, const char *a2)
{
  unint64_t v2 = 0x249249249249249LL;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = v4 >> 61;
  unint64_t v6 = 8 * v4;
  if (v5 > 4) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = v6 / 5;
  if (v5) {
    unint64_t v8 = v7;
  }
  uint64_t v9 = &a2[v3];
  if (v8 < 0x249249249249249LL) {
    unint64_t v2 = v8;
  }
  else {
    return (unint64_t)v9;
  }
}

void boost::container::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *a1;
  boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>( (uint64_t)a1,  *a1,  a4,  *a1 + 56 * a1[1],  a2,  a5,  a6);
  if (v10)
  {
    uint64_t v11 = a1[1];
    if (v11)
    {
      uint64_t v12 = v10 + 32;
      do
      {
        --v11;
        uint64_t v12 = std::shared_ptr<char>::~shared_ptr[abi:ne180100](v12) + 56;
      }

      while (v11);
    }
  }

  uint64_t v13 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v13;
  a1[2] = a3;
}

void sub_1880E5A94(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

__n128 boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper*,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  while (a2 != a3)
  {
    *(void *)a5 = *(void *)a2;
    __int128 v7 = *(_OWORD *)(a2 + 8);
    *(void *)(a5 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a5 + 8) = v7;
    *(_OWORD *)(a5 + 32) = *(_OWORD *)(a2 + 32);
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    *(void *)(a5 + 48) = *(void *)(a2 + 48);
    a5 += 56LL;
    a2 += 56LL;
  }

  *(void *)a5 = *(void *)a7;
  __int128 v8 = *(_OWORD *)(a7 + 8);
  *(void *)(a5 + 24) = *(void *)(a7 + 24);
  *(_OWORD *)(a5 + 8) = v8;
  __n128 result = *(__n128 *)(a7 + 32);
  *(__n128 *)(a5 + 32) = result;
  *(void *)(a7 + 32) = 0LL;
  *(void *)(a7 + 40) = 0LL;
  *(void *)(a5 + 48) = *(void *)(a7 + 48);
  if (a3 != a4)
  {
    uint64_t v10 = a5 + 56 * a6;
    do
    {
      *(void *)uint64_t v10 = *(void *)a3;
      __int128 v11 = *(_OWORD *)(a3 + 8);
      *(void *)(v10 + 24) = *(void *)(a3 + 24);
      *(_OWORD *)(v10 + 8) = v11;
      __n128 result = *(__n128 *)(a3 + 32);
      *(__n128 *)(v10 + 32) = result;
      *(void *)(a3 + 32) = 0LL;
      *(void *)(a3 + 40) = 0LL;
      *(void *)(v10 + 48) = *(void *)(a3 + 48);
      a3 += 56LL;
      v10 += 56LL;
    }

    while (a3 != a4);
  }

  return result;
}

uint64_t boost::container::vector<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::small_vector_allocator<ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper,boost::container::new_allocator<void>,void>,void>::~vector( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)a1 + 32LL;
    do
    {
      --v2;
      uint64_t v3 = std::shared_ptr<char>::~shared_ptr[abi:ne180100](v3) + 56;
    }

    while (v2);
  }

  if (*(void *)(a1 + 16) && a1 + 24 != *(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t di_asif::details::dir_base::calc_num_real_elements(di_asif::details::dir_base *this)
{
  unint64_t v1 = *((void *)this + 4);
  unint64_t v2 = v1 % (*((void *)this + 6) + 1LL);
  uint64_t result = v1 - v2;
  if (v1 == v2)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Invalid chunk size", 0xFFFFFFEA);
  }

  return result;
}

unint64_t di_asif::details::unmap_iterator_t::make_val(di_asif::details::unmap_iterator_t *this)
{
  unint64_t v1 = (void *)*((void *)this + 2);
  unint64_t v2 = *((void *)this + 7);
  uint64_t v3 = v2 * *v1;
  unint64_t v4 = *((void *)this + 5);
  unint64_t v5 = v3 + v4;
  unint64_t v6 = v1[1] * v2;
  if (v4 < v6) {
    return v5 / v2;
  }
  *((void *)this + 5) = 0LL;
  uint64_t v7 = *(void *)this;
  unint64_t v8 = *((void *)this + 1);
  *((void *)this + 2) = v1 + 2;
  if (v8 != ((uint64_t)v1 - v7 + 16) >> 4)
  {
    unint64_t v9 = v1[2] * v2;
    if (v9 < *((void *)this + 9))
    {
      unint64_t v5 = v1[2] * v2;
      return v5 / v2;
    }
  }

  return 0LL;
}

di_asif::details::unmap_iterator_t *di_asif::details::unmap_iterator_t::unmap_iterator_t( di_asif::details::unmap_iterator_t *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = a4;
  *((void *)this + 7) = a5;
  *((void *)this + 8) = a6;
  unint64_t v9 = (uint64_t *)(a2 + 16 * a8);
  *((void *)this + 9) = a7;
  if (a8 == a3)
  {
LABEL_6:
    *((void *)this + 2) = v9;
  }

  else
  {
    uint64_t v10 = 16 * a3 - 16 * a8;
    while (1)
    {
      uint64_t v11 = *v9;
      if ((v9[1] + *v9) * a5 >= a6) {
        break;
      }
      v9 += 2;
      v10 -= 16LL;
      if (!v10)
      {
        unint64_t v9 = (uint64_t *)(a2 + 16 * a3);
        goto LABEL_6;
      }
    }

    *((void *)this + 2) = v9;
    unint64_t v13 = v11 * a5;
    if (v11 * a5 < a7)
    {
      BOOL v14 = a6 >= v13;
      unint64_t v15 = a6 - v13;
      if (v15 != 0 && v14) {
        *((void *)this + 5) = v15;
      }
      *((void *)this + 3) = di_asif::details::unmap_iterator_t::make_val(this);
      *((void *)this + 4) = v16;
    }
  }

  return this;
}

uint64_t di_asif::details::table::get_map_entry_for_offset( di_asif::details::table *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 1);
  di_asif::details::table_entry_map::table_entry_map( &v4,  this,  *(void *)(v2 + 48)
  + (*(void *)(v2 + 48) + 1LL)
  * ((a2 / *(unsigned __int16 *)(v2 + 18) - *((void *)this + 44) / (unint64_t)*(unsigned __int16 *)(v2 + 18))
   / (*(void *)(v2 + 48)
    * (unint64_t)(*(_DWORD *)(v2 + 20) / *(unsigned __int16 *)(v2 + 18)))));
  return v4;
}

uint64_t di_asif::details::map_entry_iterator_t::operator*(uint64_t a1)
{
  return a1 + 16;
}

uint64_t di_asif::details::map_entry_iterator_t::operator++(uint64_t a1)
{
  uint64_t v2 = *(di_asif::details::table **)a1;
  uint64_t v3 = *((void *)v2 + 1);
  unint64_t v4 = *(void *)(a1 + 8)
     + *(unsigned __int16 *)(v3 + 18)
  *(void *)(a1 + 8) = v4;
  if (v4 >= *((void *)v2 + 44) + *(void *)(v3 + 80))
  {
    uint64_t v7 = 0LL;
    unint64_t v6 = 0LL;
    int v8 = 0;
  }

  else
  {
    uint64_t map_entry_for_offset = di_asif::details::table::get_map_entry_for_offset(v2, v4);
    unint64_t v6 = map_entry_for_offset & 0xFFFFFFFFFFFFFF00LL;
    uint64_t v7 = map_entry_for_offset;
    int v8 = 1;
  }

  if (*(unsigned __int8 *)(a1 + 32) == v8)
  {
    if (*(_BYTE *)(a1 + 32)) {
      *(void *)(a1 + 24) = v4;
    }
  }

  else if (*(_BYTE *)(a1 + 32))
  {
    *(_BYTE *)(a1 + 32) = 0;
  }

  else
  {
    *(void *)(a1 + 16) = v6 | v7;
    *(void *)(a1 + 24) = v4;
    *(_BYTE *)(a1 + 32) = 1;
  }

  return a1;
}

uint64_t di_asif::details::map_entry_iterator_t::operator++@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v2;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  return di_asif::details::map_entry_iterator_t::operator++(a1);
}

uint64_t di_asif::details::table::get_data_entry_for_offset( di_asif::details::table *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *(unsigned __int16 *)(v2 + 18);
  di_asif::details::table_entry_data::table_entry_data( &v5,  this,  ((a2 / v3 - *((void *)this + 44) / v3) / (*(_DWORD *)(v2 + 20) / v3)
  return v5;
}

uint64_t di_asif::details::data_entry_iterator_t::operator++(uint64_t a1)
{
  uint64_t v2 = *(di_asif::details::table **)a1;
  uint64_t v3 = *((void *)v2 + 1);
  unint64_t v4 = *(void *)(a1 + 8) + *(unsigned int *)(v3 + 20);
  *(void *)(a1 + 8) = v4;
  if (v4 >= *((void *)v2 + 44) + *(void *)(v3 + 80))
  {
    uint64_t v7 = 0LL;
    unint64_t v6 = 0LL;
    int v8 = 0;
  }

  else
  {
    uint64_t data_entry_for_offset = di_asif::details::table::get_data_entry_for_offset(v2, v4);
    unint64_t v6 = data_entry_for_offset & 0xFFFFFFFFFFFFFF00LL;
    uint64_t v7 = data_entry_for_offset;
    int v8 = 1;
  }

  if (*(unsigned __int8 *)(a1 + 32) == v8)
  {
    if (*(_BYTE *)(a1 + 32)) {
      *(void *)(a1 + 24) = v4;
    }
  }

  else if (*(_BYTE *)(a1 + 32))
  {
    *(_BYTE *)(a1 + 32) = 0;
  }

  else
  {
    *(void *)(a1 + 16) = v6 | v7;
    *(void *)(a1 + 24) = v4;
    *(_BYTE *)(a1 + 32) = 1;
  }

  return a1;
}

uint64_t di_asif::details::data_entry_iterator_t::operator++@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v2;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  return di_asif::details::data_entry_iterator_t::operator++(a1);
}

uint64_t di_asif::details::table::table( uint64_t a1, uint64_t a2, void *a3, unint64_t a4, uint64_t a5, int a6)
{
  char v6 = a6;
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = a2;
  di_utils::fixed_vector_t<di_asif::details::table_entry>::fixed_vector_t( (uint64_t *)(a1 + 16),  *(void *)(a2 + 56),  a6);
  std::vector<ref::tagged_weak_ptr<di_asif::details::map_element,unsigned long long>>::vector( (void *)(a1 + 72),  *(void *)(a2 + 64));
  *(void *)(a1 + 104) = 850045863LL;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 101) = 1;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 160) = 0LL;
  *(void *)(a1 + 168) = 850045863LL;
  *(void *)(a1 + 280) = 850045863LL;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(void *)(a1 + 272) = 0LL;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)(a1 + 336) = 0LL;
  *(void *)(a1 + 344) = a4;
  *(void *)(a1 + 352) = a5;
  if (a4 && a4 % *(unsigned int *)(a2 + 20))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    __int128 v20 = std::generic_category();
    exception[1] = 4294967274LL;
    exception[2] = v20;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "ASIF: table is not aligned to chunk size";
  }

  if ((v6 & 1) != 0)
  {
    unsigned int v12 = 1;
  }

  else
  {
    unint64_t v13 = (std::__shared_weak_count *)a3[1];
    v21[0] = *a3;
    v21[1] = v13;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }

    di_asif::details::table::load((void *)a1, v21);
    if (v13)
    {
      uint64_t v16 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    unsigned int v12 = 0;
  }

  atomic_store(v12, (unsigned int *)(a1 + 96));
  *(_BYTE *)(a1 + 100) = v12;
  return a1;
}

void sub_1880E6194(_Unwind_Exception *a1, uint64_t a2, uint64_t *a3, ...)
{
  unint64_t v9 = *v4;
  if (*v4)
  {
    *(void *)(v3 + 80) = v9;
    operator delete(v9);
  }

  std::unique_ptr<di_asif::details::table_entry,std::function<void ()(di_asif::details::table_entry*)>>::~unique_ptr[abi:ne180100](a3);
  _Unwind_Resume(a1);
}

void di_asif::details::table::load(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = *(void *)(v4 + 56);
  size_t v6 = ((unint64_t)*(unsigned __int16 *)(v4 + 18) + 8 * v5 - 1)
  uint64_t v7 = operator new[](v6);
  bzero(v7, v6);
  unint64_t v8 = (*(uint64_t (**)(void))(*(void *)*a2 + 40LL))(*a2);
  unint64_t v9 = a1[43];
  size_t v10 = v8 - v9;
  if (v8 < v9) {
    size_t v10 = 0LL;
  }
  if (v10 >= v6) {
    size_t v11 = v6;
  }
  else {
    size_t v11 = v10;
  }
  unsigned int v12 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  uint64_t v24 = v7;
  unint64_t v25 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }

  size_t v26 = v11;
  unint64_t v27 = v9;
  size_t v28 = v11;
  char v29 = 0;
  unsigned int v15 = (*(uint64_t (**)(void, void **))(*(void *)*a2 + 88LL))(*a2, &v24);
  if (v11 != v15)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    __int128 v23 = std::generic_category();
    exception[1] = v15;
    exception[2] = v23;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Read returned an error";
  }

  bzero(v7, v6 - v11);
  if (v5)
  {
    uint64_t v16 = 0LL;
    unint64_t v17 = (unint64_t *)v7;
    do
    {
      unint64_t v18 = *v17++;
      atomic_store(0LL, (unint64_t *)(a1[7] + v16));
      atomic_store(bswap64(v18), (unint64_t *)(a1[7] + v16 + 8));
      v16 += 16LL;
      --v5;
    }

    while (v5);
  }

  uint64_t v19 = v25;
  if (v25)
  {
    __int128 v20 = (unint64_t *)&v25->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  operator delete[](v7);
}

void sub_1880E63B4(_Unwind_Exception *a1)
{
}

void di_asif::details::table::return_chunk(di_asif::details::table *this, uint64_t a2)
{
  uint64_t v4 = a2;
  if (a2)
  {
    uint64_t v3 = (std::mutex *)((char *)this + 280);
    std::mutex::lock((std::mutex *)((char *)this + 280));
    std::deque<unsigned long long>::emplace_back<unsigned long long &>((void *)this + 29, &v4);
    atomic_store(1u, (unsigned int *)this + 24);
    std::mutex::unlock(v3);
  }

void sub_1880E6434(_Unwind_Exception *a1)
{
}

uint64_t std::deque<unsigned long long>::emplace_back<unsigned long long &>(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[4];
  uint64_t v8 = a1[5];
  unint64_t v9 = v8 + v7;
  if (v6 == v8 + v7)
  {
    std::deque<unsigned long long>::__add_back_capacity(a1);
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    uint64_t v5 = a1[1];
    unint64_t v9 = v7 + v8;
  }

  *(void *)(*(void *)(v5 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v9 & 0x1FF)) = *a2;
  uint64_t v10 = v8 + 1;
  a1[5] = v10;
  unint64_t v11 = v7 + v10;
  unsigned int v12 = (void *)(v5 + 8 * (v11 >> 9));
  uint64_t v13 = v11 & 0x1FF;
  if (v13) {
    uint64_t v14 = *v12 + 8 * v13;
  }
  else {
    uint64_t v14 = *(v12 - 1) + 4096LL;
  }
  return v14 - 8;
}

uint64_t di_asif::details::table::update_entry_if_bits_in_same_state( di_asif::details::table *this, di_asif::details::ContextASIF *a2, di_asif::details::table_entry_data *a3)
{
  unint64_t v3 = atomic_load((unint64_t *)(*(void *)(*(void *)a3 + 56LL) + 16LL * *((void *)a3 + 1) + 8));
  if (v3 >> 62 != 3) {
    return 0LL;
  }
  uint64_t v7 = (ref::ref_cnt *)(*(void *)(*(void *)a3 + 56LL) + 16LL * *((void *)a3 + 1));
  while (*(void *)v7)
  {
LABEL_10:
    if ((ref::ref_cnt::wait_fn(v7, (const void *)1) & 1) == 0)
    {
      char v45 = 0;
      uint64_t v43 = off_18A1E3FE0;
      uint64_t v44 = v7;
      uint64_t v46 = 0LL;
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = off_18A1E43B0;
      uint64_t v10 = std::generic_category();
      exception[1] = 4294967291LL;
      exception[2] = v10;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 48) = 0;
      exception[7] = "Can't take exclusive lock on entry";
    }
  }

  while (1)
  {
    unint64_t v8 = __ldaxr((unint64_t *)v7);
    if (!v8) {
      break;
    }
    __clrex();
LABEL_9:
    if (v8) {
      goto LABEL_10;
    }
  }

  int v12 = 1;
  char v45 = 1;
  uint64_t v43 = off_18A1E3FE0;
  uint64_t v44 = v7;
  uint64_t v46 = 0LL;
  unint64_t v13 = atomic_load((unint64_t *)(*(void *)(*(void *)a3 + 56LL) + 16LL * *((void *)a3 + 1) + 8));
  if (v13 >> 62 == 3)
  {
    uint64_t v14 = *(void *)(*(void *)a3 + 8LL);
    di_asif::details::table::get_bitmap( this,  a2,  (*(void *)(*(void *)a3 + 352LL)
     + (*(void *)(v14 + 48) + *(void *)(v14 + 48) * *((void *)a3 + 1))
     / (unint64_t)(*(void *)(v14 + 48) + 1LL)
     * *(unsigned int *)(v14 + 20))
    / *(unsigned __int16 *)(v14 + 18),
      0,
      1LL,
      (unint64_t *)&v42);
    if (!v42 || v42[344])
    {
      uint64_t v15 = 0LL;
      BOOL v16 = 0;
      uint64_t v17 = 0LL;
      goto LABEL_17;
    }

    if (v42[224]) {
      unint64_t v18 = (di_asif::details::map_element *)(v42 + 40);
    }
    else {
      unint64_t v18 = 0LL;
    }
    unsigned int bitmap_range = di_asif::details::table_entry_data::get_bitmap_range(a3);
    uint64_t block_bits = di_asif::details::map_element::get_block_bits(v18, bitmap_range);
    uint64_t v21 = *(void *)(*(void *)a3 + 8LL);
    uint64_t v22 = *(void *)(v21 + 48);
    uint64_t v23 = *(unsigned int *)(v21 + 20);
    if (v42)
    {
      if (v42[224]) {
        unint64_t v25 = v42 + 40;
      }
      else {
        unint64_t v25 = 0LL;
      }
    }

    else
    {
      unint64_t v25 = 0LL;
    }

    unint64_t v24 = *(void *)(*(void *)a3 + 352LL) + (v22 + v22 * *((void *)a3 + 1)) / (unint64_t)(v22 + 1) * v23;
    if (di_asif::details::map_element::search_for_pattern(v25, this, block_bits, v24, v24 + v23, 0) == v24 + v23)
    {
      size_t v26 = (unint64_t *)(*(void *)(*(void *)a3 + 56LL) + 16LL * *((void *)a3 + 1) + 8);
      unint64_t v27 = *v26;
      uint64_t v28 = *(unsigned int *)(*(void *)(*(void *)a3 + 8LL) + 20LL);
      BOOL v16 = block_bits == 2;
      unint64_t v29 = *v26;
      unint64_t v30 = __ldaxr(v26);
      if (v30 == v29)
      {
        if (!__stlxr((block_bits << 62) | v29 & 0x3FFFFFFFFFFFFFFFLL, v26))
        {
          char v31 = 1;
          goto LABEL_41;
        }
      }

      else
      {
        __clrex();
      }

      char v31 = 0;
LABEL_41:
      uint64_t v32 = v27 & 0x7FFFFFFFFFFFFFLL;
      if ((v31 & 1) == 0)
      {
        while (2)
        {
          unint64_t v33 = __ldaxr(v26);
          if (v33 == v30)
          {
            if (!__stlxr(v30 & 0x3FFFFFFFFFFFFFFFLL | (block_bits << 62), v26))
            {
              int v34 = 1;
              goto LABEL_47;
            }
          }

          else
          {
            __clrex();
          }

          int v34 = 0;
LABEL_47:
          unint64_t v30 = v33;
          if (v34) {
            break;
          }
          continue;
        }
      }

      uint64_t v15 = v32 * v28;
      if ((_DWORD)block_bits != 1)
      {
        uint64_t v35 = (unint64_t *)(*(void *)(*(void *)a3 + 56LL) + 16LL * *((void *)a3 + 1) + 8);
        if (*(_DWORD *)(*(void *)(*(void *)a3 + 8LL) + 20LL))
        {
          do
            unint64_t v36 = __ldxr(v35);
          while (__stxr(v36 & 0xFF80000000000000LL, v35));
          goto LABEL_64;
        }

        unint64_t v37 = *v35;
        unint64_t v38 = __ldxr(v35);
        if (v38 == v37)
        {
          if (!__stxr(v37 & 0xFF80000000000000LL, v35))
          {
            char v39 = 1;
LABEL_57:
            if ((v39 & 1) != 0) {
              goto LABEL_64;
            }
            while (2)
            {
              unint64_t v40 = __ldxr(v35);
              if (v40 == v38)
              {
                if (!__stxr(v38 & 0xFF80000000000000LL, v35))
                {
                  char v41 = 1;
                  goto LABEL_63;
                }
              }

              else
              {
                __clrex();
              }

              char v41 = 0;
LABEL_63:
              unint64_t v38 = v40;
              if ((v41 & 1) != 0) {
                goto LABEL_64;
              }
              continue;
            }
          }
        }

        else
        {
          __clrex();
        }

        char v39 = 0;
        goto LABEL_57;
      }

LABEL_64:
      int v12 = 0;
      uint64_t v17 = 1LL;
      atomic_store(1u, (unsigned int *)this + 24);
    }

    else
    {
      uint64_t v15 = 0LL;
      BOOL v16 = 0;
      uint64_t v17 = 0LL;
      int v12 = 0;
    }

LABEL_17:
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)&v42);
  }

  else
  {
    uint64_t v15 = 0LL;
    BOOL v16 = 0;
    uint64_t v17 = 0LL;
  }

  ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)&v43);
  if (v12) {
    uint64_t result = 0LL;
  }
  else {
    uint64_t result = v17;
  }
  if (!v12 && v16)
  {
    di_asif::details::table::return_chunk(this, v15);
    return v17;
  }

  return result;
}

          uint64_t v7 = 1000 * v6.__d_.__rep_;
LABEL_18:
          if (v7 > (v5.__d_.__rep_ ^ 0x7FFFFFFFFFFFFFFFLL))
          {
            v8.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
LABEL_21:
            std::condition_variable::__do_timed_wait((std::condition_variable *)(a1 + 3624), &__lk, v8);
            std::chrono::steady_clock::now();
            goto LABEL_22;
          }
        }

        v8.__d_.__rep_ = v7 + v5.__d_.__rep_;
        goto LABEL_21;
      }

      v13.__d_.__rep_ = v12 + v10.__d_.__rep_;
      goto LABEL_18;
    }
  }

  while (std::chrono::steady_clock::now().__d_.__rep_ < *a3);
  if ((*(_DWORD *)(**(void **)a4 + 368LL) & 1) != 0) {
    return 1LL;
  }
  uint64_t v14 = *(void *)(a4 + 8);
  return *(void *)v14
      && !*(_BYTE *)(*(void *)v14 + 344LL)
      && *(void *)(*(void *)v14 + 32LL) == **(void **)(a4 + 16);
}

      v13.__d_.__rep_ = v12 + v10.__d_.__rep_;
      goto LABEL_18;
    }
  }

  while (std::chrono::steady_clock::now().__d_.__rep_ < *a3);
  if ((*(_DWORD *)(**(void **)a4 + 544LL) & 1) != 0) {
    return 1LL;
  }
  uint64_t v14 = *(void *)(a4 + 8);
  return *(void *)v14
      && !*(_BYTE *)(*(void *)v14 + 520LL)
      && *(void *)(*(void *)v14 + 32LL) == **(void **)(a4 + 16);
}

      v13.__d_.__rep_ = v12 + v10.__d_.__rep_;
      goto LABEL_18;
    }
  }

  while (std::chrono::steady_clock::now().__d_.__rep_ < *a3);
  if ((*(_DWORD *)(**(void **)a4 + 336LL) & 1) != 0) {
    return 1LL;
  }
  uint64_t v14 = *(void *)(a4 + 8);
  return *(void *)v14
      && !*(_BYTE *)(*(void *)v14 + 312LL)
      && *(void *)(*(void *)v14 + 32LL) == **(void **)(a4 + 16);
}

void sub_1880E68F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  unint64_t v3 = va_arg(va1, void);
  ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)va);
  ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)va1);
  _Unwind_Resume(a1);
}

unint64_t di_asif::details::table_entry_data::get_flags(di_asif::details::table_entry_data *this)
{
  unint64_t v1 = atomic_load((unint64_t *)(*(void *)(*(void *)this + 56LL) + 16LL * *((void *)this + 1) + 8));
  return v1 >> 62;
}

void di_asif::details::table::get_bitmap( di_asif::details::table *this@<X0>, di_asif::details::ContextASIF *a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, unint64_t *a6@<X8>)
{
  unint64_t v12 = (a3 - *((void *)this + 44) / (unint64_t)*(unsigned __int16 *)(*((void *)this + 1) + 18LL))
      / (*(void *)(*((void *)this + 1) + 48LL)
  unint64_t v13 = di_asif::details::table::bitmap_idx_to_tag(this, v12);
  ref::tagged_weak_ptr<di_asif::details::map_element,unsigned long long>::lock_if_tag( (unint64_t *)(*((void *)this + 9) + 8 * v12),  v13,  a6);
  if (!*a6 || *(_BYTE *)(*a6 + 344))
  {
    uint64_t v14 = *((void *)this + 1);
    uint64_t v30 = *(void *)(v14 + 48)
        + (*(void *)(v14 + 48) + 1LL)
        * ((a3 - *((void *)this + 44) / (unint64_t)*(unsigned __int16 *)(v14 + 18))
         / (*(void *)(v14 + 48)
          * (unint64_t)(*(_DWORD *)(v14 + 20) / *(unsigned __int16 *)(v14 + 18))));
    di_asif::details::table_entry_map::table_entry_map(&v27, this, v30);
    uint64_t v15 = v27;
    uint64_t v16 = v28;
    if ((a4 & 1) != 0)
    {
      LOBYTE(v27) = 0;
      char v29 = 0;
    }

    else
    {
      uint64_t v17 = (ref::ref_cnt *)(*(void *)(v27 + 56) + 16 * v28);
      BOOL v18 = ref::ref_cnt::get(v17);
      v25[0] = (uint64_t)off_18A1E3FC0;
      v25[1] = (uint64_t)v17;
      BOOL v26 = v18;
      ref::details::ref_cnt_handle::ref_cnt_handle((uint64_t)&v27, (uint64_t)v25);
      char v29 = 1;
      ref::details::ref_cnt_handle::~ref_cnt_handle((ref::details::ref_cnt_handle *)v25);
    }

    (*(void (**)(uint64_t *__return_ptr, void, unint64_t, uint64_t))(**((void **)this + 1) + 32LL))( v25,  *((void *)this + 1),  v13,  a5);
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::operator=(a6, (unint64_t *)v25);
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)v25);
    if (*a6)
    {
      if (!*(_BYTE *)(*a6 + 344))
      {
        if (!*a6 || (unsigned int v19 = atomic_load((unsigned int *)(*a6 + 24)), v19 != 2))
        {
          unint64_t v20 = atomic_load(a6);
          v25[0] = v20;
          uint64_t v21 = *((void *)this + 9);
          do
            unint64_t v22 = __ldaxr((unint64_t *)v25);
          while (__stlxr(0LL, (unint64_t *)v25));
          atomic_store(v22, (unint64_t *)(v21 + 8 * v12));
          v25[0] = (*(void *)(*(void *)(v15 + 56) + 16 * v16 + 8) & 0x7FFFFFFFFFFFFFLL)
                 * *(unsigned int *)(*(void *)(v15 + 8) + 20LL);
          if (v25[0])
          {
            ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::make_value<di_asif::details::ContextASIF &,di_asif::details::table &,unsigned long &,unsigned long long &>( (uint64_t *)a6,  a2,  this,  (unint64_t *)&v30,  v25);
          }

          else
          {
            uint64_t space = di_asif::details::dir_base::allocate_space(*((di_asif::details::dir_base **)this + 1), a2, 1);
            char v23 = 1;
            ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::make_value<di_asif::details::ContextASIF &,di_asif::details::table &,unsigned long &,unsigned long long &,BOOL>( (uint64_t *)a6,  a2,  this,  (unint64_t *)&v30,  &space,  &v23);
          }
        }
      }
    }

    if (v29) {
      ref::details::ref_cnt_handle::~ref_cnt_handle((ref::details::ref_cnt_handle *)&v27);
    }
  }

void sub_1880E6B90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a17) {
    ref::details::ref_cnt_handle::~ref_cnt_handle((ref::details::ref_cnt_handle *)&a14);
  }
  ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(v17);
  _Unwind_Resume(a1);
}

unint64_t di_asif::details::table_entry_data::get_start_block( di_asif::details::table_entry_data *this)
{
  uint64_t v1 = *(void *)(*(void *)this + 8LL);
  return (*(void *)(*(void *)this + 352LL)
        + (*(void *)(v1 + 48) + *(void *)(v1 + 48) * *((void *)this + 1))
        / (unint64_t)(*(void *)(v1 + 48) + 1LL)
}

uint64_t di_asif::details::map_element::get_block_bits( di_asif::details::map_element *this, unint64_t a2)
{
  unint64_t v3 = (di_asif::details::map_element *)((char *)this + 32);
  unsigned int bit = lock_free::bitmap_t::get_bit((di_asif::details::map_element *)((char *)this + 32), a2);
  else {
    int v5 = 0;
  }
  uint64_t result = v5 | bit;
  if ((_DWORD)result == 3)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "bitmap flag value invalid", 0xFFFFFFEA);
  }

  return result;
}

unint64_t di_asif::details::table_entry_data::get_bitmap_range( di_asif::details::table_entry_data *this)
{
  unint64_t v1 = *(void *)(*(void *)this + 352LL);
  uint64_t v2 = *(void *)(*(void *)this + 8LL);
  uint64_t v3 = *(void *)(v2 + 48);
  uint64_t v4 = *(unsigned int *)(v2 + 20);
  unint64_t v5 = (v3 + v3 * *((void *)this + 1)) / (unint64_t)(v3 + 1) * v4;
  unint64_t v6 = *(unsigned __int16 *)(v2 + 18);
  return ((2
         * ((v5
                         - ((v5 + v1) / v6 - v1 / v6)
                         / (v3
                          * (unint64_t)(v4 / v6))
                         * v3
                         * v4)
                        / v6)) | (((v4
                                  - v6
                                  + v5
                                  - ((v4 - v6 + v5 + v1) / v6 - v1 / v6)
                                  / (v3
                                   * (unint64_t)(v4 / v6))
                                  * v3
                                  * v4)
                                 / v6) << 33))
       + 0x200000000LL;
}

unint64_t di_asif::details::table_entry_data::get_logical_offset( di_asif::details::table_entry_data *this)
{
  return *(void *)(*(void *)this + 352LL)
       + (*(void *)(*(void *)(*(void *)this + 8LL) + 48LL)
        + *(void *)(*(void *)(*(void *)this + 8LL) + 48LL) * *((void *)this + 1))
}

unint64_t di_asif::details::map_element::search_for_pattern_match( void *a1, di_asif::details::table *a2, char a3, unint64_t a4, uint64_t a5)
{
  return di_asif::details::map_element::search_for_pattern(a1, a2, a3, a4, a5, 0);
}

void *di_asif::details::table_entry_obj::set_offset(void *this, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(*(void *)(*this + 8LL) + 20LL);
  uint64_t v3 = (unint64_t *)(*(void *)(*this + 56LL) + 16LL * this[1] + 8);
  if (v2 > a2)
  {
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 & 0xFF80000000000000LL, v3));
    return this;
  }

  unint64_t v5 = *v3;
  unint64_t v6 = __ldxr(v3);
  unint64_t v7 = a2 / v2;
  if (v6 != v5)
  {
    __clrex();
LABEL_8:
    while (1)
    {
      unint64_t v8 = __ldxr(v3);
      if (v8 != v6) {
        break;
      }
      if (__stxr(v6 & 0xFF80000000000000LL | v7, v3)) {
        goto LABEL_12;
      }
      int v9 = 1;
LABEL_13:
      unint64_t v6 = v8;
      if (v9) {
        return this;
      }
    }

    __clrex();
LABEL_12:
    int v9 = 0;
    goto LABEL_13;
  }

  if (__stxr(v5 & 0xFF80000000000000LL | v7, v3)) {
    goto LABEL_8;
  }
  return this;
}

unint64_t di_asif::details::table::bitmap_idx_to_tag(di_asif::details::table *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *(void *)(v2 + 64);
  if ((v3 & (v3 - 1)) != 0)
  {
    char v4 = 0;
    unint64_t v5 = 2 * v3;
    do
    {
      v5 >>= 1;
      ++v4;
    }

    while (v5 != 1);
    unint64_t v3 = 1 << v4;
  }

  unint64_t v6 = *(void *)(v2 + 80);
  if (v3 == 1)
  {
    char v7 = 0;
  }

  else
  {
    char v7 = 0;
    do
    {
      v3 >>= 1;
      ++v7;
    }

    while (v3 != 1);
  }

  return ((*((void *)this + 44) / v6) << v7) | a2;
}

unint64_t *ref::tagged_weak_ptr<di_asif::details::map_element,unsigned long long>::lock_if_tag@<X0>( unint64_t *result@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v4 = atomic_load(result);
  if (v4 && *(void *)(v4 + 32) == a2)
  {
    unint64_t v6 = (unint64_t *)atomic_load(result);
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::tagged_ptr(&v9, v6, 1);
    if (v9 && !*(_BYTE *)(v9 + 344))
    {
      uint64_t v7 = *(void *)(v9 + 32);
      *a3 = 0LL;
      if (v7 == a2)
      {
        do
          unint64_t v8 = __ldaxr(&v9);
        while (__stlxr(0LL, &v9));
        atomic_store(v8, a3);
      }
    }

    else
    {
      *a3 = 0LL;
    }

    return ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v9);
  }

  else
  {
    *a3 = 0LL;
  }

  return result;
}

unint64_t *ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::operator=( unint64_t *a1, unint64_t *a2)
{
  if (a2 != a1)
  {
    do
      unint64_t v3 = __ldaxr(a2);
    while (__stlxr(0LL, a2));
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(a1);
    atomic_store(v3, a1);
  }

  return a1;
}

uint64_t ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::make_value<di_asif::details::ContextASIF &,di_asif::details::table &,unsigned long &,unsigned long long &>( uint64_t *a1, di_asif::details::ContextASIF *a2, di_asif::details::table *a3, unint64_t *a4, uint64_t *a5)
{
  return ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::make_value<di_asif::details::ContextASIF &,di_asif::details::table &,unsigned long &,unsigned long long &>( *a1,  a2,  a3,  a4,  a5);
}

void sub_1880E6F70( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*v10)
  {
    uint64_t v11 = *(void *)(*v10 + 288);
    if (v11)
    {
      a10 = *v10;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &a10, v10);
    }
  }

  __cxa_rethrow();
}

void sub_1880E6FA4(_Unwind_Exception *a1)
{
}

uint64_t di_asif::details::dir_base::allocate_space( di_asif::details::dir_base *this, di_asif::details::ContextASIF *a2, int a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  unint64_t v6 = (unint64_t *)((char *)this + 8);
  do
    unint64_t v7 = __ldaxr(v6);
  while (__stlxr(v7 + 1, v6));
  uint64_t v8 = (*(uint64_t (**)(di_asif::details::dir_base *))(*(void *)this + 16LL))(this);
  if (a3)
  {
    uint64_t v9 = *((unsigned int *)this + 5);
    v14[0] = off_18A1DF658;
    v14[1] = a2;
    v14[2] = v9;
    uint64_t v15 = v14;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  uint64_t v10 = space_allocators::FixedSize::allocate(v8, (uint64_t)v14);
  uint64_t v11 = v15;
  if (v15 == v14)
  {
    uint64_t v12 = 4LL;
    uint64_t v11 = v14;
    goto LABEL_10;
  }

  if (v15)
  {
    uint64_t v12 = 5LL;
LABEL_10:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }

  return v10;
}

void sub_1880E70A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::make_value<di_asif::details::ContextASIF &,di_asif::details::table &,unsigned long &,unsigned long long &,BOOL>( uint64_t *a1, di_asif::details::ContextASIF *a2, di_asif::details::table *a3, unint64_t *a4, uint64_t *a5, char *a6)
{
  return ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::make_value<di_asif::details::ContextASIF &,di_asif::details::table &,unsigned long &,unsigned long long &,BOOL>( *a1,  a2,  a3,  a4,  a5,  a6);
}

void sub_1880E7110( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*v10)
  {
    uint64_t v11 = *(void *)(*v10 + 288);
    if (v11)
    {
      a10 = *v10;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &a10, v10);
    }
  }

  __cxa_rethrow();
}

void sub_1880E7144(_Unwind_Exception *a1)
{
}

uint64_t di_asif::details::table::allocate_backend_space_for_entry( uint64_t a1, di_asif::details::ContextASIF *a2, uint64_t a3, uint64_t a4)
{
  if ((*(void *)(*(void *)(a3 + 56) + 16 * a4 + 8) & 0x7FFFFFFFFFFFFFLL)
     * *(unsigned int *)(*(void *)(a3 + 8) + 20LL))
  {
    return 0LL;
  }

  unint64_t space = di_asif::details::dir_base::allocate_space(*(di_asif::details::dir_base **)(a1 + 8), a2, 0);
  if (space)
  {
    uint64_t v9 = *(void *)(a3 + 56) + 16 * a4;
    unint64_t v10 = *(void *)(v9 + 8);
    if ((v10 & 0x7FFFFFFFFFFFFFLL) == 0)
    {
      uint64_t v11 = (unint64_t *)(v9 + 8);
      unint64_t v12 = space / *(unsigned int *)(*(void *)(a3 + 8) + 20LL);
      while (1)
      {
        unint64_t v13 = __ldxr(v11);
        if (v13 != v10) {
          break;
        }
        if (__stxr(v10 & 0xFF80000000000000LL | v12, v11)) {
          goto LABEL_9;
        }
        char v14 = 1;
LABEL_10:
        if ((v14 & 1) != 0) {
          return 0LL;
        }
        unint64_t v10 = v13;
        if ((v13 & 0x7FFFFFFFFFFFFFLL) != 0) {
          goto LABEL_12;
        }
      }

      __clrex();
LABEL_9:
      char v14 = 0;
      goto LABEL_10;
    }

LABEL_12:
    di_asif::details::dir_base::insert_space(*(di_asif::details::dir_base **)(a1 + 8), space, a2);
    return 0LL;
  }

  return 4294967268LL;
}

    if ((v28 & 2) != 0) {
      uint64_t v11 = v8;
    }
    else {
      uint64_t v11 = v8 + 1;
    }
    unint64_t v12 = v11 * *((unsigned __int16 *)this + 9);
    di_asif::details::dir::get_table(this, a2, v12 / *((void *)this + 10), 0, 1, (unint64_t *)&v26);
    if (v26 && v26[520])
    {
      exception = __cxa_allocate_exception(0x40uLL);
      DiskImagesRuntimeException *exception = off_18A1E43B0;
      uint64_t v21 = std::generic_category();
      exception[1] = 4294967291LL;
      exception[2] = v21;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 48) = 0;
      exception[7] = "Can't load table to get extents";
    }

    if (v26 && !v26[520])
    {
      if (v26[400]) {
        uint64_t v15 = (di_asif::details::table *)(v26 + 40);
      }
      else {
        uint64_t v15 = 0LL;
      }
      next_extent = di_asif::details::table::get_next_extent(v15, a2, (uint64_t)&v27, (uint64_t)&v29);
    }

    else
    {
      next_extent = 0LL;
      char v14 = (*((void *)this + 10) + *((void *)this + 10) * (v12 / *((void *)this + 10)) + 1)
          / *((unsigned __int16 *)this + 9);
      if (v14 >= v9) {
        char v14 = v9;
      }
      char v29 = v11;
      uint64_t v30 = v14;
      char v31 = 2;
    }

    if ((_DWORD)next_extent == (_DWORD)v7)
    {
LABEL_36:
      *((void *)&v32 + 1) = v30;
      unint64_t v33 = 2;
      unint64_t v22 = v27;
      char v23 = v28;
      boost::icl::left_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)&v22,  (uint64_t)&v32,  (uint64_t)&v24);
      uint64_t v27 = v24;
      LOBYTE(v28) = v25;
      BOOL v18 = 1;
      unint64_t v7 = next_extent;
      goto LABEL_40;
    }

    if (v33)
    {
      if (v33 == 3)
      {
        uint64_t v16 = *((void *)&v32 + 1);
        uint64_t v17 = v32;
      }

      else
      {
        uint64_t v16 = *((void *)&v32 + 1);
        uint64_t v17 = v32;
      }
    }

    else
    {
      uint64_t v16 = *((void *)&v32 + 1);
      uint64_t v17 = v32;
      if ((unint64_t)v32 < *((void *)&v32 + 1) && (unint64_t)(v32 + 1) < *((void *)&v32 + 1))
      {
LABEL_35:
        goto LABEL_39;
      }
    }

void *di_asif::details::dir_base::insert_space( di_asif::details::dir_base *this, uint64_t a2, di_asif::details::ContextASIF *a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (*(uint64_t (**)(di_asif::details::dir_base *))(*(void *)this + 16LL))(this);
  v11[0] = off_18A1DF6E8;
  v11[1] = a3;
  unint64_t v12 = v11;
  space_allocators::FixedSize::insert(v6, a2, (uint64_t)v11);
  uint64_t result = v12;
  if (v12 == v11)
  {
    uint64_t v8 = 4LL;
    uint64_t result = v11;
    goto LABEL_5;
  }

  if (v12)
  {
    uint64_t v8 = 5LL;
LABEL_5:
    uint64_t result = (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  uint64_t v9 = (unint64_t *)((char *)this + 8);
  do
    unint64_t v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  return result;
}

void sub_1880E7300( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void di_asif::details::table::set_entry_bitmap_range( uint64_t a1, di_asif::details::ContextASIF *a2, di_asif::details::table_entry_data *a3, unsigned int *a4, unsigned int a5, uint64_t a6)
{
  uint64_t v11 = *(void *)(*(void *)a3 + 8LL);
  di_asif::details::table::get_bitmap( (di_asif::details::table *)a1,  a2,  (*(void *)(*(void *)a3 + 352LL)
   + (*(void *)(v11 + 48) + *(void *)(v11 + 48) * *((void *)a3 + 1))
   / (unint64_t)(*(void *)(v11 + 48) + 1LL)
   * *(unsigned int *)(v11 + 20))
  / *(unsigned __int16 *)(v11 + 18),
    0,
    1LL,
    (unint64_t *)&v30);
  if (!(void)v30 || *(_BYTE *)(v30 + 344))
  {
    *(void *)&__int128 v34 = "di_asif::details::table::set_entry_bitmap_range(ContextASIF &, data_entry_t &, const bits_range_t &, data_entry_t::flags, std::optional<data_entry_t::flags>)";
    *((void *)&v34 + 1) = 47LL;
    int v35 = 16;
    di_log::logger<di_log::log_printer<436ul>>::logger(&bitmap_range, &v34);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v38,  (uint64_t)"Can't load bitmap while setting range",  37LL);
    di_log::logger<di_log::log_printer<436ul>>::~logger((uint64_t)&bitmap_range);
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    uint64_t v27 = std::generic_category();
    exception[1] = 5LL;
    exception[2] = v27;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Can't load bitmap while setting range";
  }

  BOOL v12 = (a6 & 0xFF00000000LL) == 0 || (_DWORD)a6 == 3;
  char v13 = v12;
  if (!v12)
  {
    if (*(_BYTE *)(v30 + 224)) {
      uint64_t v14 = v30 + 40;
    }
    else {
      uint64_t v14 = 0LL;
    }
    unint64_t bitmap_range = di_asif::details::table_entry_data::get_bitmap_range(a3);
    di_asif::details::map_element::set_range(v14, (di_asif::details::table *)a1, (unsigned int *)&bitmap_range, a6);
  }

  if ((void)v30)
  {
    if (*(_BYTE *)(v30 + 224)) {
      uint64_t v15 = v30 + 40;
    }
    else {
      uint64_t v15 = 0LL;
    }
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  di_asif::details::map_element::set_range(v15, (di_asif::details::table *)a1, a4, a5);
  ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)&v30);
  if ((v13 & 1) != 0) {
    return;
  }
  uint64_t v16 = *(void *)(*(void *)a3 + 8LL);
  uint64_t v17 = *(void *)(a1 + 8);
  uint64_t v18 = *(void *)(v17 + 48);
  di_asif::details::table_entry_map::table_entry_map( &bitmap_range,  (di_asif::details::table *)a1,  v18 + (v18 + 1)
  * (((*(void *)(*(void *)a3 + 352LL)
     + (*(void *)(v16 + 48) + *(void *)(v16 + 48) * *((void *)a3 + 1))
     / (unint64_t)(*(void *)(v16 + 48) + 1LL)
     * *(unsigned int *)(v16 + 20))
    / *(unsigned __int16 *)(v16 + 18)
    - *(void *)(a1 + 352) / (unint64_t)*(unsigned __int16 *)(v17 + 18))
   / (v18
    * (unint64_t)(*(_DWORD *)(v17 + 20) / *(unsigned __int16 *)(v17 + 18)))));
  unint64_t v32 = bitmap_range;
  uint64_t v33 = v37;
  unsigned int v19 = (ref::ref_cnt *)(*(void *)(bitmap_range + 56) + 16 * v37);
  BOOL v20 = ref::ref_cnt::get(v19);
  *(void *)&__int128 v34 = off_18A1E3FC0;
  *((void *)&v34 + 1) = v19;
  LOBYTE(v35) = v20;
  if (!v20)
  {
    *(void *)&__int128 v30 = "di_asif::details::table::set_entry_bitmap_range(ContextASIF &, data_entry_t &, const bits_range_t &, data_entry_t::flags, std::optional<data_entry_t::flags>)";
    *((void *)&v30 + 1) = 47LL;
    int v31 = 16;
    di_log::logger<di_log::log_printer<450ul>>::logger(&bitmap_range, &v30);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)"Couldn't lock entry ", 20LL);
    std::operator<<[abi:ne180100]<di_log::logger<di_log::log_printer<450ul>>,di_asif::details::table_entry_map,0>((uint64_t)&bitmap_range);
    di_log::logger<di_log::log_printer<450ul>>::~logger((uint64_t)&bitmap_range);
    uint64_t v28 = __cxa_allocate_exception(0x40uLL);
    *uint64_t v28 = off_18A1E43B0;
    char v29 = std::generic_category();
    v28[1] = 4294967282LL;
    v28[2] = v29;
    *((_BYTE *)v28 + 24) = 0;
    *((_BYTE *)v28 + 48) = 0;
    v28[7] = "Couldn't lock entry";
  }

  uint64_t v21 = (unint64_t *)(*(void *)(*(void *)a3 + 56LL) + 16LL * *((void *)a3 + 1) + 8);
  unint64_t v22 = *v21;
  unint64_t v23 = __ldaxr(v21);
  if (v23 != v22)
  {
    __clrex();
LABEL_25:
    while (1)
    {
      unint64_t v24 = __ldaxr(v21);
      if (v24 != v23) {
        break;
      }
      if (__stlxr(v23 | 0xC000000000000000LL, v21)) {
        goto LABEL_29;
      }
      int v25 = 1;
LABEL_30:
      unint64_t v23 = v24;
      if (v25) {
        goto LABEL_31;
      }
    }

    __clrex();
LABEL_29:
    int v25 = 0;
    goto LABEL_30;
  }

  if (__stlxr(v22 | 0xC000000000000000LL, v21)) {
    goto LABEL_25;
  }
LABEL_31:
  atomic_store(1u, (unsigned int *)(a1 + 96));
  ref::details::ref_cnt_handle::~ref_cnt_handle((ref::details::ref_cnt_handle *)&v34);
}

void sub_1880E76B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void *di_log::logger<di_log::log_printer<436ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<436ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1DF770;
  a1[45] = &unk_18A1DF870;
  a1[46] = &unk_18A1DF898;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1DF770;
  a1[45] = &unk_18A1DF7F8;
  a1[46] = &unk_18A1DF820;
  return a1;
}

void sub_1880E7794(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<436ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_asif::details::map_element::set_range( uint64_t a1, di_asif::details::table *a2, unsigned int *a3, unsigned int a4)
{
  unint64_t v6 = *a3;
  unint64_t v7 = a3[1];
  LOWORD(v11[0]) = a4 & 1 | (((a4 >> 1) & 1) << 8);
  uint64_t result = (void *)lock_free::bitmap_t::update_pair_bits(a1 + 32, v6, v7, (unsigned __int8 *)v11);
  if ((_DWORD)result)
  {
    *(_BYTE *)(a1 + 113) = 1;
    uint64_t result = di_asif::details::table_entry_map::table_entry_map(v11, a2, *(void *)a1);
    uint64_t v9 = (unint64_t *)(*(void *)(v11[0] + 56LL) + 16LL * v11[1] + 8);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 | 0x8000000000000000LL, v9));
  }

  return result;
}

uint64_t std::operator<<[abi:ne180100]<di_log::logger<di_log::log_printer<450ul>>,di_asif::details::table_entry_map,0>( uint64_t a1)
{
  uint64_t v2 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)" = offset = ", 12LL);
  std::ostream::operator<<();
  return a1;
}

void *di_log::logger<di_log::log_printer<450ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<450ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1DF990;
  a1[45] = &unk_18A1DFA90;
  a1[46] = &unk_18A1DFAB8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1DF990;
  a1[45] = &unk_18A1DFA18;
  a1[46] = &unk_18A1DFA40;
  return a1;
}

void sub_1880E7994(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<450ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_asif::details::table::update_map_entry( di_asif::details::table *this, uint64_t a2, unint64_t a3)
{
  uint64_t result = di_asif::details::table_entry_map::table_entry_map(v14, this, a2);
  unint64_t v6 = *(unsigned int *)(*(void *)(v14[0] + 8LL) + 20LL);
  unint64_t v7 = (unint64_t *)(*(void *)(v14[0] + 56LL) + 16LL * v14[1] + 8);
  if (v6 > a3)
  {
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 & 0xFF80000000000000LL, v7));
    goto LABEL_14;
  }

  unint64_t v9 = *v7;
  unint64_t v10 = __ldxr(v7);
  unint64_t v11 = a3 / v6;
  if (v10 != v9)
  {
    __clrex();
LABEL_8:
    while (1)
    {
      unint64_t v12 = __ldxr(v7);
      if (v12 != v10) {
        break;
      }
      if (__stxr(v10 & 0xFF80000000000000LL | v11, v7)) {
        goto LABEL_12;
      }
      int v13 = 1;
LABEL_13:
      unint64_t v10 = v12;
      if (v13) {
        goto LABEL_14;
      }
    }

    __clrex();
LABEL_12:
    int v13 = 0;
    goto LABEL_13;
  }

  if (__stxr(v9 & 0xFF80000000000000LL | v11, v7)) {
    goto LABEL_8;
  }
LABEL_14:
  atomic_store(1u, (unsigned int *)this + 24);
  return result;
}

__n128 di_asif::details::table::make_unmap_iterators@<Q0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  __int128 v13 = v15[3];
  *(_OWORD *)(a7 + 32) = v15[2];
  *(_OWORD *)(a7 + 48) = v13;
  *(_OWORD *)(a7 + 64) = v15[4];
  __n128 result = (__n128)v15[1];
  *(_OWORD *)a7 = v15[0];
  *(__n128 *)(a7 + 16) = result;
  return result;
}

void di_asif::details::dir::defrag(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  v18[0] = off_18A1D9CC8;
  v18[1] = v3;
  (*(void (**)(void))(**(void **)(v3 + 16) + 72LL))(*(void *)(v3 + 16));
  if (*(_BYTE *)(a1 + 16)) {
    goto LABEL_41;
  }
  do
  {
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 3680);
    __lk.__owns_ = 1;
    std::mutex::lock((std::mutex *)(a1 + 3680));
    while (!*(_BYTE *)(a1 + 16) && !*(_BYTE *)(a1 + 3672))
      std::condition_variable::wait((std::condition_variable *)(a1 + 3624), &__lk);
    v4.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_ + 2000000000;
    while (!*(_BYTE *)(a1 + 16) && v4.__d_.__rep_ > std::chrono::steady_clock::now().__d_.__rep_)
    {
      v5.__d_.__rep_ = v4.__d_.__rep_ - std::chrono::steady_clock::now().__d_.__rep_;
      if (v5.__d_.__rep_ >= 1)
      {
        std::chrono::steady_clock::now();
        v6.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
        if (!v6.__d_.__rep_)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = 0LL;
          goto LABEL_18;
        }

        if (v6.__d_.__rep_ < 1)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = 0x8000000000000000LL;
        }

        else
        {
          if ((unint64_t)v6.__d_.__rep_ > 0x20C49BA5E353F7LL)
          {
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = 0x7FFFFFFFFFFFFFFFLL;
            goto LABEL_18;
          }

void sub_1880E7EE8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_1880E7F14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 - 120) = off_18A1D9CC8;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](a12);
  _Unwind_Resume(a1);
}

uint64_t di_asif::details::dir_base::create_context@<X0>( di_asif::details::dir_base *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *((void *)this + 3);
  *a2 = off_18A1D9CC8;
  a2[1] = v2;
  return (*(uint64_t (**)(void))(**(void **)(v2 + 16) + 72LL))(*(void *)(v2 + 16));
}

uint64_t di_asif::details::dir::defrag_table( di_asif::details::dir *this, di_asif::details::ContextASIF *a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  unint64_t v3 = atomic_load((unint64_t *)this + 1);
  uint64_t v4 = *((unsigned int *)this + 5);
  uint64_t v5 = *(void *)(*((void *)this + 19) + 8 * a3) * v4;
  uint64_t v26 = v5;
  if (v5 && 3 * v5 > 4 * v3 * v4)
  {
    unint64_t v9 = (unint64_t *)(*((void *)this + 16) + 8 * a3);
    ref::tagged_weak_ptr<di_asif::details::table,unsigned long long>::lock_if_tag(v9, a3, &v25);
    if (v25 && !*(_BYTE *)(v25 + 520))
    {
      uint64_t v11 = *(void *)(v25 + 464);
      if (v11)
      {
        uint64_t v27 = (char *)v25;
        (*(void (**)(uint64_t, char **, unint64_t *))(*(void *)v11 + 48LL))(v11, &v27, &v25);
      }

      ref::tagged_weak_ptr<di_asif::details::table,unsigned long long>::lock_if_tag(v9, a3, (unint64_t *)&v27);
      ref::tagged_ptr<di_asif::details::table,unsigned long long>::operator=(&v25, (unint64_t *)&v27);
      ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v27);
      if (v25)
      {
        if (!*(_BYTE *)(v25 + 520))
        {
LABEL_15:
          (*(void (**)(di_asif::details::dir *))(*(void *)this + 24LL))(this);
LABEL_16:
          uint64_t v10 = 4294967248LL;
LABEL_17:
          ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(&v25);
          return v10;
        }
      }
    }

    ref::Allocator<di_asif::details::table,unsigned long long>::allocate( (uint64_t)this + 280,  (ref::details **)a3,  1,  (unint64_t *)&v27);
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::operator=(&v25, (unint64_t *)&v27);
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v27);
    if (!v25 || *(_BYTE *)(v25 + 520) || (unsigned int v13 = atomic_load((unsigned int *)(v25 + 24)), v13 == 2))
    {
      if (!v25 || *(_BYTE *)(v25 + 520)) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }

    uint64_t v14 = (char *)valloc(*((unsigned int *)this + 5));
    if (!v14)
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      unint64_t v24 = std::bad_alloc::bad_alloc(exception);
      __cxa_throw(v24, MEMORY[0x189614708], MEMORY[0x189614690]);
    }

    v29[0] = off_18A1DFDC8;
    __int128 v30 = v29;
    uint64_t v27 = v14;
    std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)&v28, (uint64_t)v29);
    unint64_t v15 = v30;
    if (v30 == v29)
    {
      uint64_t v16 = 4LL;
      unint64_t v15 = v29;
    }

    else
    {
      if (!v30)
      {
LABEL_26:
        unint64_t v17 = *((unsigned int *)this + 5);
        uint64_t v18 = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 40LL))(*((void *)a2 + 2));
        if (v18 - v26 >= v17) {
          uint64_t v19 = v17;
        }
        else {
          uint64_t v19 = v18 - v26;
        }
        uint64_t v10 = di_asif::details::dir_base::move_realloc_chunk(this, a2, v27, v19, v26);
        uint64_t v21 = v20;
        if (v25)
        {
          uint64_t v22 = *(void *)(v25 + 464);
          if (v22)
          {
            v29[0] = v25;
            (*(void (**)(uint64_t, void *, unint64_t *))(*(void *)v22 + 48LL))(v22, v29, &v25);
          }
        }

        if ((v10 & 0x8000000000000000LL) == 0)
        {
          (*(void (**)(di_asif::details::dir *, uint64_t, uint64_t))(*(void *)this + 40LL))( this,  *((void *)this + 10) * a3,  v21);
          std::mutex::lock((std::mutex *)((char *)this + 3792));
          std::deque<unsigned long long>::emplace_back<unsigned long long &>((void *)this + 468, &v26);
          atomic_store(1u, (unsigned int *)this + 898);
          std::mutex::unlock((std::mutex *)((char *)this + 3792));
          uint64_t v10 = 0LL;
        }

        std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v27);
        goto LABEL_17;
      }

      uint64_t v16 = 5LL;
    }

    (*(void (**)(void))(*v15 + 8 * v16))();
    goto LABEL_26;
  }

  return 4294967274LL;
}

void sub_1880E8248( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

unint64_t *di_asif::details::dir::get_table@<X0>( di_asif::details::dir *this@<X0>, di_asif::details::ContextASIF *a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, char a5@<W4>, unint64_t *a6@<X8>)
{
  __n128 result = ref::tagged_weak_ptr<di_asif::details::table,unsigned long long>::lock_if_tag( (unint64_t *)(*((void *)this + 16) + 8 * a3),  a3,  a6);
  if (!*a6 || *(_BYTE *)(*a6 + 520))
  {
    di_asif::details::dir::load_create_table( (uint64_t)this,  a2,  (ref::details **)a3,  *(void *)(*((void *)this + 19) + 8 * a3) * *((unsigned int *)this + 5),  a4,  a5,  &v16);
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::operator=(a6, &v16);
    __n128 result = ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(&v16);
    if (*a6 && !*(_BYTE *)(*a6 + 520))
    {
      unint64_t v13 = atomic_load(a6);
      unint64_t v16 = v13;
      uint64_t v14 = *((void *)this + 16);
      do
        unint64_t v15 = __ldaxr(&v16);
      while (__stlxr(0LL, &v16));
      atomic_store(v15, (unint64_t *)(v14 + 8 * a3));
    }
  }

  return result;
}

void sub_1880E839C(_Unwind_Exception *a1)
{
}

uint64_t di_asif::details::table::defrag(di_asif::details::table *this, di_asif::details::ContextASIF *a2)
{
  v26[4] = *MEMORY[0x1895F89C0];
  unint64_t v4 = atomic_load((unint64_t *)(*((void *)this + 1) + 8LL));
  size_t v5 = *(unsigned int *)(*((void *)this + 1) + 20LL);
  std::chrono::system_clock::time_point v6 = (char *)valloc(v5);
  if (!v6)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v17 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v17, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  v20[0] = off_18A1DFDC8;
  uint64_t v22 = v20;
  unint64_t v25 = v6;
  std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)v26, (uint64_t)v20);
  std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v8 = v22;
  if (v22 == v20)
  {
    uint64_t v9 = 4LL;
    std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v8 = v20;
    goto LABEL_6;
  }

  if (v22)
  {
    uint64_t v9 = 5LL;
LABEL_6:
    (*(void (**)(void))(*v8 + 8 * v9))();
  }

  di_asif::details::table::make_map_entry_iterators(this, v7, (uint64_t)v20);
  char v10 = 0;
  uint64_t v11 = v4 * v5;
  while ((v20[0] != v23 || v20[1] != v24) && !*(_BYTE *)(*((void *)this + 1) + 16LL))
  {
    int v12 = di_asif::details::table::defrag_map_entry(this, a2, (di_asif::details::table_entry_map *)&v21, v11, v25);
    di_asif::details::table::make_data_entry_iterators_for_map( this,  (const di_asif::details::table_entry_map *)&v21,  (uint64_t)v18);
    for (BOOL i = v12 == 0; ; BOOL i = v14 != 0)
    {
      v10 |= i;
      if (v18[0] == v19[3] && v18[1] == v19[4]) {
        break;
      }
      if (*(_BYTE *)(*((void *)this + 1) + 16LL)) {
        break;
      }
      int v14 = di_asif::details::table::defrag_entry(this, a2, (di_asif::details::table_entry_obj *)v19, v11, v25);
      di_asif::details::data_entry_iterator_t::operator++((uint64_t)v18);
    }

    di_asif::details::map_entry_iterator_t::operator++((uint64_t)v20);
  }

  std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v25);
  return v10 & 1;
}

void sub_1880E85B0(_Unwind_Exception *a1)
{
}

void *di_log::logger<di_log::log_printer<547ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<547ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1DFBB0;
  a1[45] = &unk_18A1DFCB0;
  a1[46] = &unk_18A1DFCD8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1DFBB0;
  a1[45] = &unk_18A1DFC38;
  a1[46] = &unk_18A1DFC60;
  return a1;
}

void sub_1880E865C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<547ul>>::~logger(uint64_t a1)
{
  return a1;
}

void di_asif::details::dir::async_defrag(di_asif::details::dir *this)
{
  uint64_t v2 = (std::mutex *)((char *)this + 3680);
  std::mutex::lock((std::mutex *)((char *)this + 3680));
  *((_BYTE *)this + 3672) = 1;
  std::condition_variable::notify_one((std::condition_variable *)((char *)this + 3624));
  std::mutex::unlock(v2);
}

uint64_t di_asif::details::table::defrag_entry( di_asif::details::table *this, di_asif::details::ContextASIF *a2, di_asif::details::table_entry_obj *a3, uint64_t a4, char *a5)
{
  uint64_t v5 = *((void *)a3 + 1);
  uint64_t v6 = *(void *)(*(void *)a3 + 56LL);
  uint64_t v7 = (*(void *)(v6 + 16 * v5 + 8) & 0x7FFFFFFFFFFFFFLL) * *(unsigned int *)(*(void *)(*(void *)a3 + 8LL) + 20LL);
  uint64_t v9 = (unint64_t *)(v6 + 16 * v5);
  if (*v9)
  {
LABEL_4:
    char v16 = 0;
    int v14 = off_18A1E3FE0;
    unint64_t v15 = v9;
    uint64_t v17 = 0LL;
    (*(void (**)(void, di_asif::details::ContextASIF *))(**((void **)this + 1) + 24LL))( *((void *)this + 1),  a2);
    ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)&v14);
    return 4294967282LL;
  }

  while (1)
  {
    unint64_t v12 = __ldaxr(v9);
    if (!v12) {
      break;
    }
    __clrex();
LABEL_10:
    if (v12) {
      goto LABEL_4;
    }
  }

  if (__stlxr(0xFFFFFFFFFFFFFFFFLL, v9)) {
    goto LABEL_10;
  }
  char v16 = 1;
  int v14 = off_18A1E3FE0;
  unint64_t v15 = v9;
  uint64_t v17 = 0LL;
  uint64_t v13 = (*(void *)(*(void *)(*(void *)a3 + 56LL) + 16LL * *((void *)a3 + 1) + 8) & 0x7FFFFFFFFFFFFFLL)
      * *(unsigned int *)(*(void *)(*(void *)a3 + 8LL) + 20LL);
  uint64_t v10 = di_asif::details::table::defrag_entry_locked(this, a2, a3, v13, a5);
  ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)&v14);
  if ((v10 & 0x80000000) == 0)
  {
    atomic_store(1u, (unsigned int *)this + 24);
    di_asif::details::table::return_chunk(this, v13);
  }

  return v10;
}

void sub_1880E884C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t di_asif::details::table::defrag_entry_locked( di_asif::details::table *this, di_asif::details::ContextASIF *a2, di_asif::details::table_entry_obj *a3, uint64_t a4, char *a5)
{
  if (!a4) {
    return 0LL;
  }
  unint64_t v10 = *(unsigned int *)(*((void *)this + 1) + 20LL);
  uint64_t v11 = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 40LL))(*((void *)a2 + 2));
  if (v11 - a4 >= v10) {
    uint64_t v12 = v10;
  }
  else {
    uint64_t v12 = v11 - a4;
  }
  uint64_t result = di_asif::details::dir_base::move_realloc_chunk(*((di_asif::details::dir_base **)this + 1), a2, a5, v12, a4);
  if ((result & 0x8000000000000000LL) == 0)
  {
    di_asif::details::table_entry_obj::set_offset(a3, v14);
    return 0LL;
  }

  return result;
}

uint64_t di_asif::details::dir_base::move_realloc_chunk( di_asif::details::dir_base *this, di_asif::details::ContextASIF *a2, char *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  unint64_t v32 = a3;
  uint64_t v33 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  uint64_t v34 = a4;
  uint64_t v35 = a5;
  uint64_t v36 = a4;
  char v37 = 0;
  int v13 = (*(uint64_t (**)(void, char **))(**((void **)a2 + 2) + 88LL))(*((void *)a2 + 2), &v32);
  if (v13 != a4)
  {
    *(void *)&__int128 v27 = "di_asif::details::dir_base::move_realloc_chunk(ContextASIF &, char *, size_t, uint64_t)";
    *((void *)&v27 + 1) = 46LL;
    int v28 = 16;
    di_log::logger<di_log::log_printer<2061ul>>::logger(v29, &v27);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v30,  (uint64_t)"Can't read for defrag",  21LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<2061ul>>::~logger_buf((uint64_t)v29);
    MEMORY[0x1895BC2CC](v31);
    if (v13 < 0) {
      int v22 = v13;
    }
    else {
      int v22 = -5;
    }
    goto LABEL_21;
  }

  uint64_t space = di_asif::details::dir_base::allocate_space(this, a2, 0);
  if (!space)
  {
    a4 = -28LL;
    goto LABEL_23;
  }

  unint64_t v15 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  if (v15)
  {
    char v16 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }

  uint64_t v18 = v33;
  unint64_t v32 = a3;
  uint64_t v33 = v15;
  if (v18)
  {
    uint64_t v19 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  uint64_t v34 = a4;
  uint64_t v35 = space;
  uint64_t v36 = a4;
  char v37 = 0;
  int v21 = (*(uint64_t (**)(void, char **))(**((void **)a2 + 2) + 80LL))(*((void *)a2 + 2), &v32);
  if (v21 != a4)
  {
    *(void *)&__int128 v27 = "di_asif::details::dir_base::move_realloc_chunk(ContextASIF &, char *, size_t, uint64_t)";
    *((void *)&v27 + 1) = 46LL;
    int v28 = 16;
    di_log::logger<di_log::log_printer<2071ul>>::logger(v29, &v27);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v30,  (uint64_t)"Can't write table for defrag",  28LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<2071ul>>::~logger_buf((uint64_t)v29);
    MEMORY[0x1895BC2CC](v31);
    di_asif::details::dir_base::insert_space(this, space, a2);
    if (v21 < 0) {
      int v22 = v21;
    }
    else {
      int v22 = -5;
    }
LABEL_21:
    a4 = -(uint64_t)-v22;
  }

void sub_1880E8B7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t di_asif::details::table::defrag_map_entry( di_asif::details::table *this, di_asif::details::ContextASIF *a2, di_asif::details::table_entry_map *a3, uint64_t a4, char *a5)
{
  uint64_t v5 = *((void *)a3 + 1);
  uint64_t v6 = *(void *)(*(void *)a3 + 56LL);
  uint64_t v7 = (*(void *)(v6 + 16 * v5 + 8) & 0x7FFFFFFFFFFFFFLL) * *(unsigned int *)(*(void *)(*(void *)a3 + 8LL) + 20LL);
  uint64_t v9 = (unint64_t *)(v6 + 16 * v5);
  if (*v9)
  {
LABEL_4:
    char v27 = 0;
    unint64_t v25 = off_18A1E3FE0;
    uint64_t v26 = v9;
    uint64_t v28 = 0LL;
    (*(void (**)(void, di_asif::details::ContextASIF *))(**((void **)this + 1) + 24LL))( *((void *)this + 1),  a2);
    ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)&v25);
    return 4294967274LL;
  }

  while (1)
  {
    unint64_t v15 = __ldaxr(v9);
    if (!v15) {
      break;
    }
    __clrex();
LABEL_10:
    if (v15) {
      goto LABEL_4;
    }
  }

  if (__stlxr(0xFFFFFFFFFFFFFFFFLL, v9)) {
    goto LABEL_10;
  }
  char v27 = 1;
  unint64_t v25 = off_18A1E3FE0;
  uint64_t v26 = v9;
  uint64_t v28 = 0LL;
  uint64_t v16 = *((void *)this + 1);
  unint64_t v17 = *(unsigned __int16 *)(v16 + 18);
  unint64_t v18 = ((*(void *)(*(void *)a3 + 352LL)
        + *((void *)a3 + 1)
        / (unint64_t)(*(void *)(*(void *)(*(void *)a3 + 8LL) + 48LL) + 1LL)
        * *(void *)(*(void *)(*(void *)a3 + 8LL) + 48LL)
        * *(unsigned int *)(*(void *)(*(void *)a3 + 8LL) + 20LL))
       / v17
       - *((void *)this + 44) / v17)
      / (*(void *)(v16 + 48)
       * (unint64_t)(*(_DWORD *)(v16 + 20) / v17));
  unint64_t v19 = di_asif::details::table::bitmap_idx_to_tag(this, v18);
  ref::tagged_weak_ptr<di_asif::details::map_element,unsigned long long>::lock_if_tag( (unint64_t *)(*((void *)this + 9) + 8 * v18),  v19,  &v24);
  if (!v24 || *(_BYTE *)(v24 + 344)) {
    goto LABEL_14;
  }
  uint64_t v20 = *(void *)(v24 + 288);
  if (v20)
  {
    unint64_t v29 = v24;
    (*(void (**)(uint64_t, unint64_t *, unint64_t *))(*(void *)v20 + 48LL))(v20, &v29, &v24);
  }

  ref::tagged_weak_ptr<di_asif::details::map_element,unsigned long long>::lock_if_tag( (unint64_t *)(*((void *)this + 9) + 8 * v18),  v19,  &v29);
  ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::operator=(&v24, &v29);
  ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v29);
  if (!v24 || *(_BYTE *)(v24 + 344))
  {
LABEL_14:
    (*(void (**)(unint64_t *__return_ptr, void, unint64_t, uint64_t))(**((void **)this + 1)
                                                                                              + 32LL))( &v29,  *((void *)this + 1),  v19,  1LL);
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::operator=(&v24, &v29);
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v29);
    if (!v24 || *(_BYTE *)(v24 + 344) || (unsigned int v22 = atomic_load((unsigned int *)(v24 + 24)), v22 == 2))
    {
      if (v24 && !*(_BYTE *)(v24 + 344))
      {
        (*(void (**)(void))(**((void **)this + 1) + 24LL))(*((void *)this + 1));
        uint64_t v10 = 4294967248LL;
      }

      else
      {
        uint64_t v10 = 4294967274LL;
      }
    }

    else
    {
      uint64_t v7 = (*(void *)(*(void *)(*(void *)a3 + 56LL) + 16LL * *((void *)a3 + 1) + 8) & 0x7FFFFFFFFFFFFFLL)
         * *(unsigned int *)(*(void *)(*(void *)a3 + 8LL) + 20LL);
      uint64_t v10 = di_asif::details::table::defrag_entry_locked(this, a2, a3, v7, a5);
    }

    if (v24)
    {
      if (!*(_BYTE *)(v24 + 344))
      {
        uint64_t v23 = *(void *)(v24 + 288);
        if (v23)
        {
          unint64_t v29 = v24;
          (*(void (**)(uint64_t, unint64_t *, unint64_t *))(*(void *)v23 + 48LL))( v23,  &v29,  &v24);
        }
      }
    }

    int v21 = 1;
  }

  else
  {
    (*(void (**)(void))(**((void **)this + 1) + 24LL))(*((void *)this + 1));
    int v21 = 0;
    uint64_t v10 = 4294967274LL;
  }

  ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v24);
  ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)&v25);
  if (!v21) {
    return 4294967248LL;
  }
  if (!(_DWORD)v10)
  {
    atomic_store(1u, (unsigned int *)this + 24);
    di_asif::details::table::return_chunk(this, v7);
  }

  return v10;
}

void sub_1880E8F10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, char a10)
{
}

uint64_t di_asif::details::table::make_map_entry_iterators@<X0>( di_asif::details::table *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5 = *((void *)this + 44);
  unint64_t v6 = *(void *)(*((void *)this + 1) + 80LL) + v5;
  if (v5 >= v6)
  {
    char v8 = 0;
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t result = di_asif::details::table::get_map_entry_for_offset(this, *((void *)this + 44));
    unint64_t v6 = *(void *)(*((void *)this + 1) + 80LL) + *((void *)this + 44);
    char v8 = 1;
  }

  *(void *)a3 = this;
  *(void *)(a3 + 8) = v5;
  *(void *)(a3 + 16) = result;
  *(void *)(a3 + 24) = a2;
  *(_BYTE *)(a3 + 32) = v8;
  *(void *)(a3 + 40) = this;
  *(void *)(a3 + 48) = v6;
  *(void *)(a3 + 56) = 0LL;
  *(_BYTE *)(a3 + 72) = 0;
  return result;
}

uint64_t di_asif::details::table::make_data_entry_iterators_for_map@<X0>( di_asif::details::table *this@<X0>, const di_asif::details::table_entry_map *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = *(void *)(*(void *)a2 + 352LL)
     + *((void *)a2 + 1)
     / (unint64_t)(*(void *)(*(void *)(*(void *)a2 + 8LL) + 48LL) + 1LL)
     * *(void *)(*(void *)(*(void *)a2 + 8LL) + 48LL)
     * *(unsigned int *)(*(void *)(*(void *)a2 + 8LL) + 20LL);
  uint64_t v7 = *((void *)this + 1);
  unint64_t v8 = *((void *)this + 44) + *(void *)(v7 + 80);
  if (v6 >= v8)
  {
    uint64_t v12 = 0LL;
    unint64_t v11 = 0LL;
    char v17 = 0;
    unint64_t v16 = *(void *)(*(void *)a2 + 352LL)
        + *((void *)a2 + 1)
        / (unint64_t)(*(void *)(*(void *)(*(void *)a2 + 8LL) + 48LL) + 1LL)
        * *(void *)(*(void *)(*(void *)a2 + 8LL) + 48LL)
        * *(unsigned int *)(*(void *)(*(void *)a2 + 8LL) + 20LL);
  }

  else
  {
    uint64_t data_entry_for_offset = di_asif::details::table::get_data_entry_for_offset(this, v6);
    unint64_t v3 = a2;
    unint64_t v11 = data_entry_for_offset & 0xFFFFFFFFFFFFFF00LL;
    uint64_t v12 = data_entry_for_offset;
    uint64_t v13 = *(void *)(*(void *)a2 + 8LL);
    uint64_t v14 = *(void *)(v13 + 48);
    uint64_t v15 = *(unsigned int *)(v13 + 20);
    uint64_t v7 = *((void *)this + 1);
    unint64_t v16 = *(void *)(*(void *)a2 + 352LL) + *((void *)a2 + 1) / (unint64_t)(v14 + 1) * v14 * v15;
    unint64_t v8 = *((void *)this + 44) + *(void *)(v7 + 80);
    char v17 = 1;
  }

  unsigned int v18 = *(unsigned __int16 *)(v7 + 18);
  unsigned int v19 = *(_DWORD *)(v7 + 20) / v18;
  uint64_t v20 = *(void *)(v7 + 48);
  unint64_t v21 = v16 + v18 * (unint64_t)v19 * v20;
  if (v21 >= v8)
  {
    char v23 = 0;
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t result = di_asif::details::table::get_data_entry_for_offset(this, v16 + v18 * (unint64_t)v19 * v20);
    char v23 = 1;
  }

  *(void *)a3 = this;
  *(void *)(a3 + 8) = v6;
  *(void *)(a3 + 16) = v11 | v12;
  *(void *)(a3 + 24) = v3;
  *(_BYTE *)(a3 + 32) = v17;
  *(void *)(a3 + 40) = this;
  *(void *)(a3 + 48) = v21;
  *(void *)(a3 + 56) = result;
  *(void *)(a3 + 64) = a2;
  *(_BYTE *)(a3 + 72) = v23;
  return result;
}

void di_asif::details::dir::~dir(di_asif::details::dir *this)
{
  *(void *)this = off_18A1DF288;
  uint64_t v2 = (std::mutex *)((char *)this + 3680);
  std::mutex::lock((std::mutex *)((char *)this + 3680));
  *((_BYTE *)this + 16) = 1;
  std::condition_variable::notify_one((std::condition_variable *)((char *)this + 3624));
  std::mutex::unlock(v2);
  std::thread::join((std::thread *)this + 452);
  std::mutex::~mutex((std::mutex *)((char *)this + 3792));
  std::deque<std::atomic<DiskImage::Context *>>::~deque[abi:ne180100]((void *)this + 468);
  std::mutex::~mutex(v2);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 3624));
  std::thread::~thread((std::thread *)this + 452);
  std::mutex::~mutex((std::mutex *)((char *)this + 3528));
  ref::Allocator<di_asif::details::map_element,unsigned long long>::~Allocator((uint64_t)this + 2080);
  ref::Allocator<di_asif::details::table,unsigned long long>::~Allocator((uint64_t)this + 280);
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::destroy( (uint64_t)this + 248,  *((void **)this + 32));
  std::mutex::~mutex((std::mutex *)((char *)this + 184));
  unint64_t v3 = (void *)*((void *)this + 19);
  if (v3)
  {
    *((void *)this + 20) = v3;
    operator delete(v3);
  }

  uint64_t v4 = (void *)*((void *)this + 16);
  if (v4)
  {
    *((void *)this + 17) = v4;
    operator delete(v4);
  }

  unint64_t v5 = (di_asif::details::dir *)*((void *)this + 14);
  if (v5 == (di_asif::details::dir *)((char *)this + 88))
  {
    uint64_t v6 = 4LL;
    unint64_t v5 = (di_asif::details::dir *)((char *)this + 88);
  }

  else
  {
    if (!v5) {
      return;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*(void *)v5 + 8 * v6))();
}

{
  void *v1;
  di_asif::details::dir::~dir(this);
  operator delete(v1);
}

void space_allocators::FixedSize::~FixedSize(space_allocators::FixedSize *this)
{
}

__n128 di_asif::details::dir::make_unmap_iterators@<Q0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v8 = v10[3];
  *(_OWORD *)(a4 + 32) = v10[2];
  *(_OWORD *)(a4 + 48) = v8;
  *(_OWORD *)(a4 + 64) = v10[4];
  __n128 result = (__n128)v10[1];
  *(_OWORD *)a4 = v10[0];
  *(__n128 *)(a4 + 16) = result;
  return result;
}

void di_asif::details::table::check_if_map_element_needed( di_asif::details::table *this, di_asif::details::ContextASIF *a2, uint64_t a3)
{
  __int128 v43 = v39;
  if ((*(void *)(*(void *)(v39 + 56) + 16LL * *((void *)&v39 + 1) + 8) & 0x7FFFFFFFFFFFFFLL)
     * *(unsigned int *)(*(void *)(v39 + 8) + 20LL))
  {
    di_asif::details::table::make_data_entry_iterators_for_map( this,  (const di_asif::details::table_entry_map *)&v43,  (uint64_t)&v39);
    __int128 v36 = v39;
    __int128 v37 = v40;
    uint64_t v38 = v41;
    while (v36 != v42)
    {
      unint64_t v5 = atomic_load((unint64_t *)(*(void *)(v37 + 56) + 16LL * *((void *)&v37 + 1) + 8));
      if (v5 >> 62 == 3) {
        return;
      }
      di_asif::details::data_entry_iterator_t::operator++((uint64_t)&v36);
    }

    if ((*(void *)(*(void *)(v43 + 56) + 16LL * *((void *)&v43 + 1) + 8) & 0x7FFFFFFFFFFFFFLL)
       * *(unsigned int *)(*(void *)(v43 + 8) + 20LL))
    {
      __int128 v36 = v39;
      if (v38 == v41)
      {
        if ((_BYTE)v38) {
          *((void *)&v37 + 1) = *((void *)&v40 + 1);
        }
      }

      else if ((_BYTE)v38)
      {
        LOBYTE(v38) = 0;
      }

      else
      {
        __int128 v37 = v40;
        LOBYTE(v38) = 1;
      }

      uint64_t v33 = 0LL;
      unint64_t v34 = 0LL;
      unint64_t v35 = 0LL;
      while (v36 != v42)
      {
        uint64_t v6 = (unint64_t *)(*(void *)(v37 + 56) + 16LL * *((void *)&v37 + 1));
        do
        {
          if (!*v6)
          {
            do
            {
              unint64_t v7 = __ldaxr(v6);
              if (v7)
              {
                __clrex();
              }

              else if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v6))
              {
                char v8 = 1;
                goto LABEL_25;
              }
            }

            while (!v7);
          }
        }

        while ((ref::ref_cnt::wait_fn((ref::ref_cnt *)v6, (const void *)1) & 1) != 0);
        char v8 = 0;
LABEL_25:
        char v31 = v8;
        unint64_t v29 = (void **)off_18A1E3FE0;
        uint64_t v30 = v6;
        uint64_t v32 = 0LL;
        uint64_t v9 = (void *)v34;
        if (v34 >= v35)
        {
          uint64_t v10 = std::vector<ref::details::ref_cnt_set_handle>::__emplace_back_slow_path<ref::details::ref_cnt_set_handle>( &v33,  (uint64_t)&v29);
        }

        else
        {
          ref::details::ref_cnt_handle::ref_cnt_handle(v34, (uint64_t)&v29);
          void *v9 = off_18A1E3FE0;
          v9[3] = v32;
          uint64_t v10 = (uint64_t)(v9 + 4);
        }

        unint64_t v34 = v10;
        ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)&v29);
        unint64_t v11 = atomic_load((unint64_t *)(*(void *)(v37 + 56) + 16LL * *((void *)&v37 + 1) + 8));
        if (v11 >> 62 == 3) {
          goto LABEL_54;
        }
        di_asif::details::data_entry_iterator_t::operator++((uint64_t)&v36);
      }

      uint64_t v12 = (unint64_t *)(*(void *)(v43 + 56) + 16LL * *((void *)&v43 + 1));
      if ((v12[1] & 0x7FFFFFFFFFFFFFLL) * *(unsigned int *)(*(void *)(v43 + 8) + 20LL))
      {
        do
        {
          if (!*v12)
          {
            do
            {
              unint64_t v13 = __ldaxr(v12);
              if (v13)
              {
                __clrex();
              }

              else if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v12))
              {
                char v14 = 1;
                goto LABEL_40;
              }
            }

            while (!v13);
          }
        }

        while ((ref::ref_cnt::wait_fn((ref::ref_cnt *)v12, (const void *)1) & 1) != 0);
        char v14 = 0;
LABEL_40:
        char v31 = v14;
        unint64_t v29 = (void **)off_18A1E3FE0;
        uint64_t v30 = v12;
        uint64_t v32 = 0LL;
        __int128 v15 = v43;
        uint64_t v16 = *(void *)(v43 + 8);
        uint64_t v17 = *(unsigned int *)(v16 + 20);
        if ((*(void *)(*(void *)(v43 + 56) + 16LL * *((void *)&v43 + 1) + 8) & 0x7FFFFFFFFFFFFFLL) * v17)
        {
          di_asif::details::table::get_bitmap( this,  a2,  (*(void *)(v43 + 352)
           + *(void *)(v16 + 48) * v17 * (*((void *)&v43 + 1) / (unint64_t)(*(void *)(v16 + 48) + 1LL)))
          / *(unsigned __int16 *)(*((void *)this + 1) + 18LL),
            1,
            1LL,
            &v28);
          if (v28 && !*(_BYTE *)(v28 + 344))
          {
            if (*(_BYTE *)(v28 + 224)) {
              uint64_t v18 = v28 + 40;
            }
            else {
              uint64_t v18 = 0LL;
            }
            uint64_t v19 = *(void *)(v18 + 16);
            *(void *)(v18 + 16) = 0LL;
            *(void *)(v18 + 24) = v19;
            *(_BYTE *)(v18 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 112) = 0;
            if (v28)
            {
              uint64_t v20 = *(void *)(v28 + 288);
              if (v20)
              {
                unint64_t v44 = v28;
                (*(void (**)(uint64_t, unint64_t *, unint64_t *))(*(void *)v20 + 48LL))( v20,  &v44,  &v28);
              }
            }

            uint64_t v21 = *((void *)this + 1);
            unint64_t v22 = *(unsigned __int16 *)(v21 + 18);
            unint64_t v23 = (*(void *)(v15 + 352)
                 + *((void *)&v15 + 1)
                 / (unint64_t)(*(void *)(*(void *)(v15 + 8) + 48LL) + 1LL)
                 * *(void *)(*(void *)(v15 + 8) + 48LL)
                 * *(unsigned int *)(*(void *)(v15 + 8) + 20LL))
                / v22
                - *((void *)this + 44) / v22;
            unint64_t v24 = *(void *)(v21 + 48) * (*(_DWORD *)(v21 + 20) / v22);
            unint64_t v44 = 0LL;
            uint64_t v25 = *((void *)this + 9);
            unint64_t v26 = v23 / v24;
            do
              unint64_t v27 = __ldaxr(&v44);
            while (__stlxr(0LL, &v44));
            atomic_store(v27, (unint64_t *)(v25 + 8 * v26));
          }

          ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v28);
        }

        ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)&v29);
      }

LABEL_54:
      unint64_t v29 = (void **)&v33;
      std::vector<ref::details::ref_cnt_set_handle>::__destroy_vector::operator()[abi:ne180100](&v29);
    }
  }

      ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)v82);
LABEL_55:
      uint64_t v17 = 2;
      goto LABEL_56;
    }

    if ((_DWORD)v33 == 3)
    {
      v94[0] = di_asif::details::table::make_range_bits(this, v26, v25);
      di_asif::details::table::set_entry_bitmap_range( (uint64_t)this,  a2,  (di_asif::details::table_entry_data *)&data_entry_for_offset,  (unsigned int *)v94,  1u,  v33 | 0x100000000LL);
      if (!v23) {
        goto LABEL_40;
      }
    }

    else
    {
      ref::details::ref_cnt_handle::upgrade_to_exclusive((ref::details::ref_cnt_handle *)v92, 0LL, (uint64_t)v82);
      if (!v83)
      {
        *(void *)&uint64_t v80 = "di_asif::details::table::write(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
        *((void *)&v80 + 1) = 30LL;
        unint64_t v81 = 16;
        di_log::logger<di_log::log_printer<1188ul>>::logger(v94, &v80);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v96,  (uint64_t)"Couldn't upgrade lock entry ",  28LL);
        di_asif::details::operator<<(&v96, &data_entry_for_offset);
        di_log::logger<di_log::log_printer<1188ul>>::~logger((uint64_t)v94);
        unint64_t v77 = __cxa_allocate_exception(0x40uLL);
        *unint64_t v77 = off_18A1E43B0;
        int v78 = std::generic_category();
        v77[1] = 4294967282LL;
        v77[2] = v78;
        *((_BYTE *)v77 + 24) = 0;
        *((_BYTE *)v77 + 48) = 0;
        v77[7] = "Couldn't upgrade lock entry";
      }

      __int128 v40 = atomic_load((unint64_t *)(data_entry_for_offset[7] + 16 * v105 + 8));
      if (!((*(void *)(data_entry_for_offset[7] + 16 * v105 + 8) & 0x7FFFFFFFFFFFFFLL) {
      uint64_t v41 = v40 >> 62;
      }
      if (v40 >> 62 == 1) {
        goto LABEL_54;
      }
      v94[0] = di_asif::details::table::make_range_bits(this, v27, v18);
      di_asif::details::table::set_entry_bitmap_range( (uint64_t)this,  a2,  (di_asif::details::table_entry_data *)&data_entry_for_offset,  (unsigned int *)v94,  1u,  v41 | 0x100000000LL);
      ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)v82);
      if (!v23)
      {
LABEL_40:
        uint64_t v17 = 0;
        atomic_store(1u, (unsigned int *)this + 24);
        goto LABEL_56;
      }
    }

    uint64_t v17 = 0;
LABEL_56:
    v79 += v18;
    finally<di_asif::details::table::write(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::$_0>::~finally((uint64_t)&v84);
LABEL_72:
    ref::details::ref_cnt_handle::~ref_cnt_handle((ref::details::ref_cnt_handle *)v92);
LABEL_73:
    unint64_t v49 = v103;
    if (v103)
    {
      uint64_t v50 = (unint64_t *)&v103->__shared_owners_;
      do
        __int128 v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }

    uint64_t v52 = v102;
    if (v102)
    {
      unint64_t v53 = (unint64_t *)&v102->__shared_owners_;
      do
        int v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
    }

    unint64_t v55 = v100;
    if (v100)
    {
      uint64_t v56 = (unint64_t *)&v100->__shared_owners_;
      do
        uint64_t v57 = __ldaxr(v56);
      while (__stlxr(v57 - 1, v56));
      if (!v57)
      {
        ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
        std::__shared_weak_count::__release_weak(v55);
      }
    }

    __int128 v58 = v99;
    if (v99)
    {
      uint64_t v59 = (unint64_t *)&v99->__shared_owners_;
      do
        uint64_t v60 = __ldaxr(v59);
      while (__stlxr(v60 - 1, v59));
      if (!v60)
      {
        ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
        std::__shared_weak_count::__release_weak(v58);
      }
    }

    if ((v17 | 2) != 2) {
      goto LABEL_102;
    }
  }

  if (v121)
  {
    updated = di_asif::details::table::update_entry_if_bits_in_same_state( this,  a2,  (di_asif::details::table_entry_data *)&v119[1]);
    uint64_t v18 = v79;
    if (v119[0]) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = updated;
    }
    v119[0] = v62;
    if (v62 == 1)
    {
      uint64_t v63 = *(void *)(*(void *)&v119[1] + 8LL);
      uint64_t v64 = *((void *)this + 1);
      uint64_t v65 = *(void *)(v64 + 48);
      di_asif::details::table::check_if_map_element_needed( this,  a2,  v65 + (v65 + 1)
      * (((*(void *)(*(void *)&v119[1] + 352LL)
         + (*(void *)(v63 + 48) + *(void *)(v63 + 48) * v120)
         / (unint64_t)(*(void *)(v63 + 48) + 1LL)
         * *(unsigned int *)(v63 + 20))
        / *(unsigned __int16 *)(v63 + 18)
        - *((void *)this + 44) / (unint64_t)*(unsigned __int16 *)(v64 + 18))
       / (v65
        * (unint64_t)(*(_DWORD *)(v64 + 20) / *(unsigned __int16 *)(v64 + 18)))));
    }
  }

  else
  {
    uint64_t v18 = v79;
  }

  unint64_t v34 = curl_easy_setopt(v16, CURLOPT_READFUNCTION, s3BufRead);
  uint64_t v32 = curl_easy_setopt(v16, CURLOPT_READDATA, a4) | v34;
LABEL_55:
  if (v32) {
    unint64_t v24 = 0;
  }
LABEL_57:
  if (a5)
  {
    *(void *)&uint64_t v56 = v16;
    __int128 v58 = a5;
    DWORD2(v56) = -1;
    if (a7)
    {
      unint64_t v35 = *a7;
      if (*a7)
      {
        __int128 v36 = 0LL;
        __int128 v37 = MEMORY[0x1895F8770];
        do
        {
          if (!strncmp(v35, "Range:", 6uLL))
          {
            __int128 v40 = *((unsigned __int8 *)v35 + 6);
            __int128 v39 = v35 + 6;
            uint64_t v38 = v40;
            if (v40)
            {
              do
              {
                if (v38 < 0)
                {
                  if (!__maskrune(v38, 0x4000uLL)) {
                    break;
                  }
                }

                else if ((*(_DWORD *)(v37 + 4LL * v38 + 60) & 0x4000) == 0)
                {
                  break;
                }

                uint64_t v41 = *(unsigned __int8 *)++v39;
                uint64_t v38 = v41;
              }

              while (v41);
            }

            if (!strncmp(v39, "bytes=", 6uLL))
            {
              unint64_t v44 = *((unsigned __int8 *)v39 + 6);
              __int128 v43 = v39 + 6;
              __int128 v42 = v44;
              if (v44)
              {
                do
                {
                  if (v42 < 0)
                  {
                    if (!__maskrune(v42, 0x4000uLL)) {
                      break;
                    }
                  }

                  else if ((*(_DWORD *)(v37 + 4LL * v42 + 60) & 0x4000) == 0)
                  {
                    break;
                  }

                  char v45 = *(unsigned __int8 *)++v43;
                  __int128 v42 = v45;
                }

                while (v45);
              }

              HIDWORD(v56) = 1;
              *(void *)&uint64_t v57 = strtoull(v43, 0LL, 0);
            }
          }

          unint64_t v35 = a7[++v36];
        }

        while (v35);
      }
    }

    uint64_t v46 = curl_easy_setopt(v16, CURLOPT_WRITEFUNCTION, curlWriteData);
    if (curl_easy_setopt(v16, CURLOPT_WRITEDATA, &v56) | v46) {
      unint64_t v24 = 0;
    }
  }

  if (a6)
  {
    if (curl_easy_setopt(v16, CURLOPT_HEADERFUNCTION, s3BufWrite)) {
      unint64_t v24 = 0;
    }
    if (curl_easy_setopt(v16, CURLOPT_HEADERDATA, a6)) {
      goto LABEL_86;
    }
  }

  if (!v24)
  {
LABEL_86:
    unint64_t v26 = (FILE *)*MEMORY[0x1895F89D0];
    unint64_t v27 = "curl_easy_setopt failed\n";
    unint64_t v28 = 24LL;
    goto LABEL_42;
  }

  uint64_t v47 = curl_easy_perform(v16);
  if (v47 == CURLE_OK)
  {
    unint64_t v55 = 499LL;
    curl_easy_getinfo(v16, CURLINFO_RESPONSE_CODE, &v55);
    if ((unint64_t)(v55 - 400) <= 0xC7)
    {
      if (a1 != 1 || v55 != 416)
      {
        pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchiveS3/AAS3Common.c",  (uint64_t)"s3Perform",  401,  84,  "HTTP %u\n",  v52,  v53,  v54,  v55);
        goto LABEL_43;
      }

      if (a5)
      {
        unint64_t v29 = 0LL;
        *a5 = v59;
        *((void *)a5 + 2) = v60;
        goto LABEL_44;
      }
    }

    unint64_t v29 = 0LL;
    goto LABEL_44;
  }

  int32x2_t v48 = v47;
  curl_easy_strerror(v47);
  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchiveS3/AAS3Common.c",  (uint64_t)"s3Perform",  379,  84,  "> %d %s\n",  v49,  v50,  v51,  v48);
LABEL_43:
  unint64_t v29 = 0xFFFFFFFFLL;
LABEL_44:
  curl_slist_free_all(v61);
  curl_easy_cleanup(v16);
  return v29;
}

void sub_1880E9738( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  a10 = (void **)&a14;
  std::vector<ref::details::ref_cnt_set_handle>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void *di_asif::details::operator<<(void *a1, void *a2)
{
  unint64_t v3 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" = offset = ", 12LL);
  uint64_t v4 = (void *)std::ostream::operator<<();
  unint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)", flags = ", 10LL);
  unint64_t v6 = atomic_load((unint64_t *)(*(void *)(*a2 + 56LL) + 16LL * a2[1] + 8));
  int v8 = v6 >> 62;
  return di_asif::details::operator<<(v5, &v8);
}

__n128 di_asif::details::table::unmap@<Q0>( uint64_t a1@<X0>, di_asif::details::ContextASIF *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  uint64_t v71 = (std::mutex *)(a1 + 104);
  std::mutex::lock((std::mutex *)(a1 + 104));
  di_asif::details::table::make_unmap_iterators( a3,  a4,  *(unsigned int *)(*(void *)(a1 + 8) + 20LL),  *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL),  *(void *)(a1 + 352),  *(void *)(*(void *)(a1 + 8) + 80LL) + *(void *)(a1 + 352),  (uint64_t)v84);
  int v9 = 0;
  LOBYTE(v82) = 0;
  char v83 = 0;
  int v72 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 8) + 24LL) + 184LL);
LABEL_2:
  while (*(void *)v84 != v87
       || *(_OWORD *)&v84[8] != v88
       || *(void *)&v84[16] != *(void *)v84 + 16LL * *(void *)&v84[8]
       && (*(_OWORD *)&v85[8] != v89 || *(void *)&v85[24] != v90))
  {
    uint64_t v10 = *(void *)&v84[24];
    uint64_t v11 = *(void *)v85;
    *(void *)&v85[8] += *(void *)&v85[24] * *(void *)v85;
    *(void *)&v84[24] = di_asif::details::unmap_iterator_t::make_val((di_asif::details::unmap_iterator_t *)v84);
    *(void *)unint64_t v85 = v12;
    unint64_t v13 = v10 * *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL);
    uint64_t data_entry_for_offset = di_asif::details::table::get_data_entry_for_offset((di_asif::details::table *)a1, v13);
    uint64_t v16 = (void *)data_entry_for_offset;
    uint64_t v17 = v15;
    *(void *)&__int128 v81 = data_entry_for_offset;
    *((void *)&v81 + 1) = v15;
    if (v83)
    {
      uint64_t v18 = v82;
      if (*(void *)(data_entry_for_offset + 352) != *(void *)(v82 + 352) || v15 != *((void *)&v82 + 1))
      {
        v9 |= di_asif::details::table::update_entry_if_bits_in_same_state( (di_asif::details::table *)a1,  a2,  (di_asif::details::table_entry_data *)&v82);
        uint64_t v20 = *(void *)(v18 + 8);
        unint64_t v21 = (*(void *)(v18 + 352)
             + (*(void *)(v20 + 48) + *(void *)(v20 + 48) * *((void *)&v82 + 1))
             / (unint64_t)(*(void *)(v20 + 48) + 1LL)
        uint64_t v22 = *(void *)(a1 + 8);
        uint64_t v23 = *(void *)(v22 + 48);
        unsigned int v24 = *(_DWORD *)(v22 + 20);
        unint64_t v25 = *(unsigned __int16 *)(v22 + 18);
        unint64_t v26 = v23 * (v24 / v25);
        unint64_t v27 = *(void *)(a1 + 352) / v25;
        ++v23;
        uint64_t v28 = v23 + v23 * ((v21 - v27) / v26);
        uint64_t v29 = v16[1];
        if (v28 != v23
                  + v23
                  * (((v16[44]
                     + (*(void *)(v29 + 48) + *(void *)(v29 + 48) * v17)
                     / (unint64_t)(*(void *)(v29 + 48) + 1LL)
                     * *(unsigned int *)(v29 + 20))
                    / *(unsigned __int16 *)(v29 + 18)
                    - v27)
                   / v26)
          && (v9 & 1) != 0)
        {
          di_asif::details::table::check_if_map_element_needed((di_asif::details::table *)a1, a2, v28 - 1);
          int v9 = 0;
        }
      }

      *((void *)&v82 + 1) = v17;
    }

    else
    {
      __int128 v82 = v81;
      char v83 = 1;
    }

    unint64_t v30 = atomic_load((unint64_t *)(v16[7] + 16 * v17 + 8));
    unint64_t v31 = v30 >> 62;
    if (v30 >> 62 != 2)
    {
      uint64_t v32 = *(void *)(v81 + 8);
      uint64_t v33 = *(void *)(v32 + 48);
      uint64_t v34 = *(unsigned int *)(v32 + 20);
      if (*(void *)(v81 + 352) + (v33 + v33 * *((void *)&v81 + 1)) / (unint64_t)(v33 + 1) * v34 == v13
        && v11 * *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL) == v34)
      {
        unint64_t v35 = (ref::ref_cnt *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1));
        while (*(void *)v35)
        {
LABEL_28:
          if ((ref::ref_cnt::wait_fn(v35, (const void *)1) & 1) == 0)
          {
            char v79 = 0;
            int v78 = v35;
            unint64_t v77 = off_18A1E3FE0;
            uint64_t v80 = 0LL;
            *(void *)&__int128 v73 = "di_asif::details::table::unmap(ContextASIF &, const unmap_extent_t *, size_t)";
            *((void *)&v73 + 1) = 30LL;
            int v74 = 16;
            di_log::logger<di_log::log_printer<863ul>>::logger(v75, &v73);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v76,  (uint64_t)"Couldn't lock entry ",  20LL);
            di_asif::details::operator<<(v76, &v81);
            di_log::logger<di_log::log_printer<863ul>>::~logger((uint64_t)v75);
            exception = __cxa_allocate_exception(0x40uLL);
            void *exception = off_18A1E43B0;
            uint64_t v65 = std::generic_category();
            exception[1] = 4294967282LL;
            exception[2] = v65;
            *((_BYTE *)exception + 24) = 0;
            *((_BYTE *)exception + 48) = 0;
            exception[7] = "Couldn't lock entry";
          }
        }

        while (1)
        {
          unint64_t v36 = __ldaxr((unint64_t *)v35);
          if (!v36) {
            break;
          }
          __clrex();
LABEL_27:
          if (v36) {
            goto LABEL_28;
          }
        }

        char v79 = 1;
        int v78 = v35;
        unint64_t v77 = off_18A1E3FE0;
        uint64_t v80 = 0LL;
        unint64_t v42 = atomic_load((unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1) + 8));
        if ((_DWORD)v31 != 1 && (v42 & 0xC000000000000000LL) == 0x4000000000000000LL) {
          goto LABEL_49;
        }
        __int128 v43 = (unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1) + 8);
        unint64_t v44 = *v43;
        unint64_t v45 = __ldaxr(v43);
        if (v45 == v44)
        {
          if (!__stlxr(v44 & 0x3FFFFFFFFFFFFFFFLL | 0x8000000000000000LL, v43)) {
            goto LABEL_56;
          }
        }

        else
        {
          __clrex();
        }

        do
        {
          while (1)
          {
            unint64_t v44 = v45;
            unint64_t v45 = __ldaxr(v43);
            if (v45 == v44) {
              break;
            }
            __clrex();
          }
        }

        while (__stlxr(v44 & 0x3FFFFFFFFFFFFFFFLL | 0x8000000000000000LL, v43));
LABEL_56:
        BOOL v48 = v44 >> 62 == 3;
        unint64_t v49 = (unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1) + 8);
        unint64_t v50 = *v49;
        uint64_t v51 = *(unsigned int *)(*(void *)(v81 + 8) + 20LL);
        if ((_DWORD)v51)
        {
          do
            unint64_t v52 = __ldxr(v49);
          while (__stxr(v52 & 0xFF80000000000000LL, v49));
          goto LABEL_69;
        }

        unint64_t v53 = *v49;
        unint64_t v54 = __ldxr(v49);
        if (v54 != v53)
        {
          __clrex();
LABEL_63:
          while (1)
          {
            unint64_t v55 = __ldxr(v49);
            if (v55 != v54) {
              break;
            }
            if (__stxr(v54 & 0xFF80000000000000LL, v49)) {
              goto LABEL_67;
            }
            int v56 = 1;
LABEL_68:
            unint64_t v54 = v55;
            if (v56) {
              goto LABEL_69;
            }
          }

          __clrex();
LABEL_67:
          int v56 = 0;
          goto LABEL_68;
        }

        if (__stxr(v53 & 0xFF80000000000000LL, v49)) {
          goto LABEL_63;
        }
LABEL_69:
        v9 |= v48;
        uint64_t v57 = (v50 & 0x7FFFFFFFFFFFFFLL) * v51;
        atomic_store(1u, (unsigned int *)(a1 + 96));
        ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)&v77);
        if (v57) {
          di_asif::details::table::return_chunk((di_asif::details::table *)a1, v57);
        }
      }

      else
      {
        if ((v30 & 0x4000000000000000LL) == 0)
        {
          if (v72) {
            continue;
          }
          __int128 v37 = (ref::ref_cnt *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1));
          while (*(void *)v37)
          {
LABEL_40:
            if ((ref::ref_cnt::wait_fn(v37, (const void *)1) & 1) == 0)
            {
              char v79 = 0;
              int v78 = v37;
              unint64_t v77 = off_18A1E3FE0;
              uint64_t v80 = 0LL;
              *(void *)&__int128 v73 = "di_asif::details::table::unmap(ContextASIF &, const unmap_extent_t *, size_t)";
              *((void *)&v73 + 1) = 30LL;
              int v74 = 16;
              di_log::logger<di_log::log_printer<900ul>>::logger(v75, &v73);
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v76,  (uint64_t)"Couldn't exclusively lock entry ",  32LL);
              di_asif::details::operator<<(v76, &v81);
              di_log::logger<di_log::log_printer<900ul>>::~logger((uint64_t)v75);
              v66 = __cxa_allocate_exception(0x40uLL);
              void *v66 = off_18A1E43B0;
              unint64_t v67 = std::generic_category();
              v66[1] = 4294967282LL;
              v66[2] = v67;
              *((_BYTE *)v66 + 24) = 0;
              *((_BYTE *)v66 + 48) = 0;
              v66[7] = "Couldn't lock entry";
            }
          }

          while (1)
          {
            unint64_t v38 = __ldaxr((unint64_t *)v37);
            if (v38)
            {
              __clrex();
            }

            else if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, (unint64_t *)v37))
            {
              char v79 = 1;
              int v78 = v37;
              unint64_t v77 = off_18A1E3FE0;
              uint64_t v80 = 0LL;
              unint64_t v46 = atomic_load((unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1) + 8));
              uint64_t v47 = *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL);
              *(void *)unint64_t v75 = di_asif::details::table::make_range_bits( (di_asif::details::table *)a1,  v10 * v47,  v11 * v47);
              di_asif::details::table::set_entry_bitmap_range( a1,  a2,  (di_asif::details::table_entry_data *)&v81,  v75,  2u,  (v46 >> 62) | 0x100000000LL);
LABEL_49:
              ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)&v77);
              goto LABEL_2;
            }

            if (v38) {
              goto LABEL_40;
            }
          }
        }

        __int128 v39 = (ref::ref_cnt *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1));
        BOOL v40 = ref::ref_cnt::get(v39);
        unint64_t v77 = off_18A1E3FC0;
        int v78 = v39;
        char v79 = v40;
        if (!v40)
        {
          *(void *)&__int128 v73 = "di_asif::details::table::unmap(ContextASIF &, const unmap_extent_t *, size_t)";
          *((void *)&v73 + 1) = 30LL;
          int v74 = 16;
          di_log::logger<di_log::log_printer<888ul>>::logger(v75, &v73);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v76,  (uint64_t)"Couldn't lock entry ",  20LL);
          di_asif::details::operator<<(v76, &v81);
          di_log::logger<di_log::log_printer<888ul>>::~logger((uint64_t)v75);
          unint64_t v68 = __cxa_allocate_exception(0x40uLL);
          *unint64_t v68 = off_18A1E43B0;
          int v69 = std::generic_category();
          v68[1] = 4294967282LL;
          v68[2] = v69;
          *((_BYTE *)v68 + 24) = 0;
          *((_BYTE *)v68 + 48) = 0;
          v68[7] = "Couldn't lock entry";
        }

        uint64_t v41 = *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL);
        *(void *)unint64_t v75 = di_asif::details::table::make_range_bits((di_asif::details::table *)a1, v10 * v41, v11 * v41);
        di_asif::details::table::set_entry_bitmap_range( a1,  a2,  (di_asif::details::table_entry_data *)&v81,  v75,  2u,  v31 | 0x100000000LL);
        ref::details::ref_cnt_handle::~ref_cnt_handle((ref::details::ref_cnt_handle *)&v77);
      }
    }
  }

  if (v83
    && ((di_asif::details::table::update_entry_if_bits_in_same_state( (di_asif::details::table *)a1,  a2,  (di_asif::details::table_entry_data *)&v82) | v9) & 1) != 0)
  {
    uint64_t v58 = *(void *)(v82 + 8);
    uint64_t v59 = *(void *)(a1 + 8);
    uint64_t v60 = *(void *)(v59 + 48);
    di_asif::details::table::check_if_map_element_needed( (di_asif::details::table *)a1,  a2,  v60 + (v60 + 1)
    * (((*(void *)(v82 + 352)
       + (*(void *)(v58 + 48) + *(void *)(v58 + 48) * *((void *)&v82 + 1))
       / (unint64_t)(*(void *)(v58 + 48) + 1LL)
       * *(unsigned int *)(v58 + 20))
      / *(unsigned __int16 *)(v58 + 18)
      - *(void *)(a1 + 352) / (unint64_t)*(unsigned __int16 *)(v59 + 18))
     / (v60
      * (unint64_t)(*(_DWORD *)(v59 + 20) / *(unsigned __int16 *)(v59 + 18)))));
  }

  __int128 v61 = *(_OWORD *)&v85[16];
  a5[2] = *(_OWORD *)v85;
  a5[3] = v61;
  a5[4] = v86;
  __int128 v62 = *(_OWORD *)&v84[16];
  *a5 = *(_OWORD *)v84;
  a5[1] = v62;
  std::mutex::unlock(v71);
  return result;
}

void sub_1880EA164( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::mutex *a11)
{
}

void *di_log::logger<di_log::log_printer<863ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<863ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1DFE50;
  a1[45] = &unk_18A1DFF50;
  a1[46] = &unk_18A1DFF78;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1DFE50;
  a1[45] = &unk_18A1DFED8;
  a1[46] = &unk_18A1DFF00;
  return a1;
}

void sub_1880EA280(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<863ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<888ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<888ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E0070;
  a1[45] = &unk_18A1E0170;
  a1[46] = &unk_18A1E0198;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E0070;
  a1[45] = &unk_18A1E00F8;
  a1[46] = &unk_18A1E0120;
  return a1;
}

void sub_1880EA368(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<888ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<900ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<900ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E0290;
  a1[45] = &unk_18A1E0390;
  a1[46] = &unk_18A1E03B8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E0290;
  a1[45] = &unk_18A1E0318;
  a1[46] = &unk_18A1E0340;
  return a1;
}

void sub_1880EA450(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<900ul>>::~logger(uint64_t a1)
{
  return a1;
}

BOOL di_asif::details::table::flush(di_asif::details::table *this, di_asif::details::ContextASIF *a2)
{
  v79[4] = *MEMORY[0x1895F89C0];
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v68 = 0u;
  uint64_t v2 = (unsigned int *)((char *)this + 96);
  do
    unsigned int v3 = __ldaxr(v2);
  while (__stlxr(0, v2));
  unsigned int v57 = v3;
  std::mutex::lock((std::mutex *)((char *)this + 280));
  __int128 v4 = v68;
  __int128 v5 = v69;
  __int128 v6 = *(_OWORD *)((char *)this + 248);
  __int128 v7 = *(_OWORD *)((char *)this + 264);
  __int128 v68 = *(_OWORD *)((char *)this + 232);
  __int128 v69 = v6;
  *(_OWORD *)((char *)this + 232) = v4;
  *(_OWORD *)((char *)this + 248) = v5;
  __int128 v8 = v70;
  __int128 v70 = v7;
  *(_OWORD *)((char *)this + 264) = v8;
  std::mutex::unlock((std::mutex *)((char *)this + 280));
  size_t v9 = ((unint64_t)*(unsigned __int16 *)(*((void *)this + 1) + 18LL)
      + 8LL * *(void *)(*((void *)this + 1) + 56LL)
      - 1)
  uint64_t v10 = valloc(v9);
  if (!v10)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v55 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v55, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  v73[0] = off_18A1DFDC8;
  unint64_t v75 = (unint64_t)v73;
  uint64_t v78 = (uint64_t)v10;
  std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)v79, (uint64_t)v73);
  uint64_t v11 = (void *)v75;
  if ((void *)v75 == v73)
  {
    uint64_t v12 = 4LL;
    uint64_t v11 = v73;
    goto LABEL_8;
  }

  if (v75)
  {
    uint64_t v12 = 5LL;
LABEL_8:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }

  uint64_t v13 = v78;
  std::mutex::lock((std::mutex *)((char *)this + 168));
  di_asif::details::table::make_map_entry_iterators(this, v14, (uint64_t)v73);
  uint64_t v15 = 0LL;
  size_t v16 = v13 + v9;
  uint64_t v67 = *((void *)this + 43);
  char v66 = 0;
  *(void *)&__int128 v64 = a2;
  *((void *)&v64 + 1) = &v67;
  *(void *)&__int128 v65 = v13;
  *((void *)&v65 + 1) = &v66;
  uint64_t v17 = (void *)v13;
  while (v73[0] != v76 || v73[1] != v77)
  {
    uint64_t v18 = (unint64_t *)(v74[7] + 16 * v75 + 8);
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 & 0x7FFFFFFFFFFFFFFFLL, v18));
    if ((v19 & 0x8000000000000000LL) != 0)
    {
      di_asif::details::table::get_bitmap( this,  a2,  (v74[44] + v75 / (*(void *)(v74[1] + 48LL) + 1LL) * *(void *)(v74[1] + 48LL) * *(unsigned int *)(v74[1] + 20LL))
      / *(unsigned __int16 *)(*((void *)this + 1) + 18LL),
        0,
        0LL,
        v59);
      if (v59[0] && !*(_BYTE *)(v59[0] + 344))
      {
        if (*(_BYTE *)(v59[0] + 224)) {
          uint64_t v20 = (di_asif::details::map_element *)(v59[0] + 40);
        }
        else {
          uint64_t v20 = 0LL;
        }
        int v21 = di_asif::details::map_element::flush(v20, a2, this);
        if (v21)
        {
          DiskImage::Context::terminate_di(a2);
          unint64_t v50 = __cxa_allocate_exception(0x40uLL);
          uint64_t v51 = v50;
          if (v21 < 0) {
            uint64_t v52 = v21;
          }
          else {
            uint64_t v52 = -v21;
          }
          void *v50 = off_18A1E43B0;
          unint64_t v53 = std::generic_category();
          v51[1] = v52;
          v51[2] = v53;
          *((_BYTE *)v51 + 24) = 0;
          *((_BYTE *)v51 + 48) = 0;
          v51[7] = "Can't flush asif, bitmap flush failed";
        }

        char v66 = 1;
      }

      ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(v59);
    }

    uint64_t v22 = (ref::ref_cnt *)(v74[7] + 16 * v75);
    while (*(void *)v22)
    {
LABEL_31:
      if ((ref::ref_cnt::wait_fn(v22, (const void *)1) & 1) == 0)
      {
        char v24 = 0;
        goto LABEL_33;
      }
    }

    while (1)
    {
      unint64_t v23 = __ldaxr((unint64_t *)v22);
      if (!v23) {
        break;
      }
      __clrex();
LABEL_30:
      if (v23) {
        goto LABEL_31;
      }
    }

    char v24 = 1;
LABEL_33:
    char v62 = v24;
    v61[0] = off_18A1E3FE0;
    v61[1] = v22;
    uint64_t v63 = 0LL;
    unint64_t v25 = (unint64_t *)(v74[7] + 16 * v75 + 8);
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 & 0x7FFFFFFFFFFFFFFFLL, v25));
    di_asif::details::table_entry_map::validate((di_asif::details::table_entry_map *)&v74);
    if ((v26 & 0x8000000000000000LL) != 0)
    {
      di_asif::details::table::get_bitmap( this,  a2,  (v74[44] + v75 / (*(void *)(v74[1] + 48LL) + 1LL) * *(void *)(v74[1] + 48LL) * *(unsigned int *)(v74[1] + 20LL))
      / *(unsigned __int16 *)(*((void *)this + 1) + 18LL),
        1,
        0LL,
        v59);
      if (v59[0] && !*(_BYTE *)(v59[0] + 344))
      {
        if (*(_BYTE *)(v59[0] + 224)) {
          unint64_t v27 = (di_asif::details::map_element *)(v59[0] + 40);
        }
        else {
          unint64_t v27 = 0LL;
        }
        int v28 = di_asif::details::map_element::flush(v27, a2, this);
        if (v28)
        {
          DiskImage::Context::terminate_di(a2);
          unint64_t v46 = __cxa_allocate_exception(0x40uLL);
          uint64_t v47 = v46;
          if (v28 < 0) {
            uint64_t v48 = v28;
          }
          else {
            uint64_t v48 = -v28;
          }
          void *v46 = off_18A1E43B0;
          unint64_t v49 = std::generic_category();
          v47[1] = v48;
          v47[2] = v49;
          *((_BYTE *)v47 + 24) = 0;
          *((_BYTE *)v47 + 48) = 0;
          v47[7] = "Can't flush asif, bitmap flush failed";
        }

        char v66 = 1;
      }

      ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(v59);
    }

    ++v15;
    if (!v57)
    {
      if (v17 != (void *)v13) {
        di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0::operator()((uint64_t)&v64, (uint64_t)v17);
      }
      uint64_t v67 = *((void *)this + 43) + 8 * (v15 + v15 * *(void *)(*((void *)this + 1) + 48LL));
      goto LABEL_66;
    }

    di_asif::details::table::make_data_entry_iterators_for_map( this,  (const di_asif::details::table_entry_map *)&v74,  (uint64_t)v59);
    while (2)
    {
      if (v59[0] != v60[3] || v59[1] != v60[4])
      {
        di_asif::details::table_entry_data::validate((di_asif::details::table_entry_data *)v60);
        unint64_t v29 = atomic_load((unint64_t *)(*(void *)(v60[0] + 56LL) + 16LL * v60[1] + 8));
        *v17++ = bswap64(v29);
        unint64_t v30 = operator new(0x28uLL);
        *(void *)unint64_t v30 = off_18A1E29C8;
        __int128 v31 = v65;
        *(_OWORD *)(v30 + 8) = v64;
        *(_OWORD *)(v30 + 24) = v31;
        int v72 = v30;
        di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0::operator()( (uint64_t)(v30 + 8),  (uint64_t)v17);
        unint64_t v30 = v72;
        uint64_t v17 = (void *)v13;
        if (v72 != v71)
        {
          if (v72)
          {
            uint64_t v17 = (void *)v13;
LABEL_52:
            uint64_t v32 = 5LL;
LABEL_54:
            (*(void (**)(void))(*(void *)v30 + 8 * v32))();
          }

          di_asif::details::data_entry_iterator_t::operator++((uint64_t)v59);
          continue;
        }

        unint64_t v30 = v71;
        uint64_t v32 = 4LL;
        goto LABEL_54;
      }

      break;
    }

    unint64_t v33 = atomic_load((unint64_t *)(v74[7] + 16 * v75 + 8));
    *v17++ = bswap64(v33);
    uint64_t v34 = operator new(0x28uLL);
    *(void *)uint64_t v34 = off_18A1E29C8;
    __int128 v35 = v65;
    *(_OWORD *)(v34 + 8) = v64;
    *(_OWORD *)(v34 + 24) = v35;
    int v72 = v34;
    di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0::operator()((uint64_t)(v34 + 8), (uint64_t)v17);
    uint64_t v34 = v72;
    uint64_t v17 = (void *)v13;
    if (v72 == v71)
    {
      uint64_t v34 = v71;
      uint64_t v36 = 4LL;
      goto LABEL_65;
    }

    if (v72)
    {
      uint64_t v17 = (void *)v13;
LABEL_60:
      uint64_t v36 = 5LL;
LABEL_65:
      (*(void (**)(void))(*(void *)v34 + 8 * v36))();
    }

LABEL_66:
    ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)v61);
    di_asif::details::map_entry_iterator_t::operator++((uint64_t)v73);
  }

  if (v17 != (void *)v13)
  {
    unint64_t v37 = *(unsigned __int16 *)(*((void *)this + 1) + 18LL);
    size_t v38 = v37 + ((unint64_t)v17 - v13) / v37 * v37 - ((void)v17 - v13);
    bzero(v17, v38);
    di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0::operator()((uint64_t)&v64, (uint64_t)v17 + v38);
  }

  std::mutex::unlock((std::mutex *)((char *)this + 168));
  std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100](&v78);
  uint64_t v39 = *((void *)&v70 + 1);
  BOOL v40 = (unint64_t **)(*((void *)&v68 + 1) + 8 * ((unint64_t)v70 >> 9));
  if ((void)v69 == *((void *)&v68 + 1))
  {
    uint64_t v41 = 0LL;
    __int128 v43 = 0LL;
    unint64_t v42 = (char *)(*((void *)&v68 + 1) + 8LL * (((void)v70 + *((void *)&v70 + 1)) >> 9));
  }

  else
  {
    uint64_t v41 = &(*v40)[v70 & 0x1FF];
    unint64_t v42 = (char *)(*((void *)&v68 + 1) + 8LL * (((void)v70 + *((void *)&v70 + 1)) >> 9));
    __int128 v43 = (unint64_t *)(*(void *)v42 + 8 * ((v70 + *((void *)&v70 + 1)) & 0x1FF));
  }

  di_asif::details::dir_base::insert_space<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>( *((unint64_t **)this + 1),  v40,  v41,  v42,  v43,  (uint64_t)a2);
  if (v39) {
    (*(void (**)(void))(**((void **)this + 1) + 24LL))(*((void *)this + 1));
  }
  int v44 = *((unsigned __int8 *)this + 100);
  if (*((_BYTE *)this + 100))
  {
    (*(void (**)(void, void, void))(**((void **)this + 1) + 40LL))( *((void *)this + 1),  *((void *)this + 44),  *((void *)this + 43));
    *((_BYTE *)this + 100) = 0;
  }

  std::deque<std::atomic<DiskImage::Context *>>::~deque[abi:ne180100](&v68);
  return v44 != 0;
}

void sub_1880EACE4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, std::mutex *a11, std::mutex *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, unint64_t a41, uint64_t a42)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    std::mutex::lock(a11);
    unint64_t v46 = a16[33] + a16[34];
    uint64_t v47 = a16[30];
    uint64_t v48 = (char *)(v47 + 8 * (v46 >> 9));
    if (a16[31] == v47) {
      uint64_t v49 = 0LL;
    }
    else {
      uint64_t v49 = *(void *)v48 + 8 * (v46 & 0x1FF);
    }
    unint64_t v50 = (char *)(a38 + 8 * (a41 >> 9));
    if (a39 == a38)
    {
      uint64_t v51 = 0LL;
      uint64_t v52 = 0LL;
      unint64_t v53 = (char *)(a38 + 8 * ((a42 + a41) >> 9));
    }

    else
    {
      uint64_t v51 = (char *)(*(void *)v50 + 8 * (a41 & 0x1FF));
      unint64_t v53 = (char *)(a38 + 8 * ((a42 + a41) >> 9));
      uint64_t v52 = (char *)(*(void *)v53 + 8 * ((a42 + a41) & 0x1FF));
    }

    std::deque<unsigned long long>::insert<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>( a10,  v48,  v49,  v50,  v51,  v53,  v52);
    std::mutex::unlock(a11);
    do
      unsigned int v54 = __ldaxr(v42);
    while (__stlxr(v54 | ((_DWORD)a15 != 0), v42));
    __cxa_rethrow();
  }

  std::deque<std::atomic<DiskImage::Context *>>::~deque[abi:ne180100](&a37);
  _Unwind_Resume(a1);
}

void sub_1880EAEC4()
{
}

uint64_t di_asif::details::map_element::flush( di_asif::details::map_element *this, di_asif::details::ContextASIF *a2, di_asif::details::table *a3)
{
  __int128 v6 = (std::mutex *)((char *)this + 120);
  std::mutex::lock((std::mutex *)((char *)this + 120));
  uint64_t v7 = di_asif::details::map_element::flush_locked(this, a2, a3, *(unsigned int *)(*((void *)a3 + 1) + 20LL));
  std::mutex::unlock(v6);
  return v7;
}

void sub_1880EAF60(_Unwind_Exception *a1)
{
}

BOOL di_asif::details::table_entry_map::validate(di_asif::details::table_entry_map *this)
{
  unint64_t v1 = atomic_load((unint64_t *)(*(void *)(*(void *)this + 56LL) + 16LL * *((void *)this + 1) + 8));
  if ((v1 & 0x7F80000000000000LL) != 0)
  {
    *(void *)&__int128 v3 = "di_asif::details::table_entry_map::validate() const";
    *((void *)&v3 + 1) = 43LL;
    int v4 = 16;
    di_log::logger<di_log::log_printer<325ul>>::logger(v5, &v3);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v6,  (uint64_t)"Diskimages2 - ASIF - bad map entry reserved bits ",  49LL);
    *(_DWORD *)((char *)&v6 + *(void *)(v6 - 24) + 8) = *(_DWORD *)((_BYTE *)&v6 + *(void *)(v6 - 24) + 8) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<325ul>>::~logger_buf((uint64_t)v5);
    MEMORY[0x1895BC2CC](&v7);
  }

  return (v1 & 0x7F80000000000000LL) == 0;
}

void sub_1880EB050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0::operator()( uint64_t a1, uint64_t a2)
{
  if (**(_BYTE **)(a1 + 24))
  {
    int v4 = (*(uint64_t (**)(void, void))(**(void **)(*(void *)a1 + 16LL) + 16LL))( *(void *)(*(void *)a1 + 16LL),  0LL);
    if (v4)
    {
      int v21 = *(DiskImage::Context **)a1;
      int v22 = v4;
      DiskImage::Context::terminate_di(v21);
      exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
      if (v22 < 0) {
        unsigned int v24 = v22;
      }
      else {
        unsigned int v24 = -v22;
      }
      DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Can't flush asif, backend flush failed", v24);
    }

    **(_BYTE **)(a1 + 24) = 0;
  }

  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = a2 - v5;
  uint64_t v7 = **(void **)(a1 + 8);
  __int128 v8 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  uint64_t v26 = v5;
  unint64_t v27 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  uint64_t v28 = v6;
  uint64_t v29 = v7;
  uint64_t v30 = v6;
  char v31 = 0;
  int v11 = (*(uint64_t (**)(void, uint64_t *))(**(void **)(*(void *)a1 + 16LL) + 80LL))( *(void *)(*(void *)a1 + 16LL),  &v26);
  **(void **)(a1 + 8) += v6;
  if (v6 != v11)
  {
    uint64_t v15 = *(DiskImage::Context **)a1;
    int v16 = v11;
    DiskImage::Context::terminate_di(v15);
    LODWORD(v17) = v16;
    uint64_t v18 = __cxa_allocate_exception(0x40uLL);
    unint64_t v19 = v18;
    else {
      uint64_t v17 = -(int)v17;
    }
    *uint64_t v18 = off_18A1E43B0;
    uint64_t v20 = std::generic_category();
    v19[1] = v17;
    v19[2] = v20;
    *((_BYTE *)v19 + 24) = 0;
    *((_BYTE *)v19 + 48) = 0;
    v19[7] = "Can't flush asif";
  }

  uint64_t v12 = v27;
  if (v27)
  {
    uint64_t v13 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_1880EB214( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL di_asif::details::table_entry_data::validate(di_asif::details::table_entry_data *this)
{
  unint64_t v1 = atomic_load((unint64_t *)(*(void *)(*(void *)this + 56LL) + 16LL * *((void *)this + 1) + 8));
  if ((v1 & 0x3F80000000000000LL) != 0)
  {
    *(void *)&__int128 v3 = "di_asif::details::table_entry_data::validate() const";
    *((void *)&v3 + 1) = 44LL;
    int v4 = 16;
    di_log::logger<di_log::log_printer<258ul>>::logger(v5, &v3);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v6,  (uint64_t)"Diskimages2 - ASIF - bad reserved bits ",  39LL);
    *(_DWORD *)((char *)&v6 + *(void *)(v6 - 24) + 8) = *(_DWORD *)((_BYTE *)&v6 + *(void *)(v6 - 24) + 8) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<258ul>>::~logger_buf((uint64_t)v5);
    MEMORY[0x1895BC2CC](&v7);
  }

  return (v1 & 0x3F80000000000000LL) == 0;
}

void sub_1880EB318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *std::deque<unsigned long long>::insert<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>( void **a1, char *a2, uint64_t a3, char *a4, char *a5, char *a6, char *a7)
{
  if (a7 == a5) {
    unint64_t v7 = 0LL;
  }
  else {
    unint64_t v7 = ((uint64_t)&a7[-*(void *)a6] >> 3) + ((a6 - a4) << 6) - ((uint64_t)&a5[-*(void *)a4] >> 3);
  }
  return std::deque<unsigned long long>::__insert_bidirectional[abi:ne180100]<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>( a1,  a2,  a3,  a4,  a5,  a6,  a7,  v7);
}

void *di_asif::details::dir_base::insert_space<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>( unint64_t *a1, unint64_t **a2, unint64_t *a3, char *a4, unint64_t *a5, uint64_t a6)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v12 = (*(uint64_t (**)(unint64_t *))(*a1 + 16))(a1);
  v18[0] = off_18A1DF6E8;
  v18[1] = a6;
  unint64_t v19 = v18;
  space_allocators::FixedSize::insert<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>( v12,  a2,  a3,  (uint64_t)a4,  a5,  (uint64_t)v18);
  __n128 result = v19;
  if (v19 == v18)
  {
    uint64_t v14 = 4LL;
    __n128 result = v18;
  }

  else
  {
    if (!v19) {
      goto LABEL_6;
    }
    uint64_t v14 = 5LL;
  }

  __n128 result = (void *)(*(uint64_t (**)(void))(*result + 8 * v14))();
LABEL_6:
  if (a5 == a3) {
    uint64_t v15 = 0LL;
  }
  else {
    uint64_t v15 = (((char *)a2 - a4) << 6) - (((uint64_t)a5 - *(void *)a4) >> 3) + a3 - *a2;
  }
  int v16 = a1 + 1;
  do
    unint64_t v17 = __ldaxr(v16);
  while (__stlxr(v17 + v15, v16));
  return result;
}

void sub_1880EB47C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t di_asif::details::table::write( di_asif::details::table *this, di_asif::details::ContextASIF *a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4)
{
  *(_WORD *)uint64_t v119 = 0;
  char v121 = 0;
  unint64_t v7 = (std::__shared_weak_count *)*((void *)a3 + 1);
  uint64_t v106 = *(void *)a3;
  v107 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  *(_OWORD *)unint64_t v108 = *((_OWORD *)a3 + 1);
  *(_OWORD *)&v108[9] = *(_OWORD *)((char *)a3 + 25);
  uint64_t v109 = *((void *)a3 + 6);
  __int128 v110 = *(_OWORD *)((char *)a3 + 56);
  __int128 v111 = *(_OWORD *)((char *)a3 + 72);
  __int128 v112 = *(_OWORD *)((char *)a3 + 88);
  char v113 = *((_BYTE *)a3 + 104);
  unint64_t v10 = (std::__shared_weak_count *)*((void *)a3 + 15);
  uint64_t v114 = *((void *)a3 + 14);
  v115 = v10;
  if (v10)
  {
    int v11 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  unint64_t v79 = 0LL;
  __int128 v116 = *((_OWORD *)a3 + 8);
  uint64_t v117 = *((void *)a3 + 18);
  char v118 = *((_BYTE *)a3 + 152);
  while (!sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&v106, (uint64_t)a4))
  {
    uint64_t data_entry_for_offset = (void *)di_asif::details::table::get_data_entry_for_offset( this,  *(unint64_t *)&v108[8]);
    uint64_t v105 = v13;
    uint64_t v14 = data_entry_for_offset[1];
    uint64_t v15 = *(void *)(v14 + 48);
    uint64_t v16 = *(unsigned int *)(v14 + 20);
    v94[0] = data_entry_for_offset[44] + (v15 + v15 * v13) / (unint64_t)(v15 + 1) * v16;
    v94[1] = v94[0] + v16;
    char v95 = 2;
    sg_vec_ns::details::sg_vec_iterator::subvec( (sg_vec_ns::details::sg_vec_iterator *)&v106,  (uint64_t)v94,  (uint64_t)a4,  (uint64_t)v98);
    if (sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)v98, (uint64_t)&v101))
    {
      *(void *)&__int128 v84 = "di_asif::details::table::write(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
      *((void *)&v84 + 1) = 30LL;
      LODWORD(v85) = 16;
      di_log::logger<di_log::log_printer<1075ul>>::logger(v94, &v84);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v96,  (uint64_t)"Couldn't trim entry in write ",  29LL);
      operator<<(&v96);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<1075ul>>::~logger_buf((uint64_t)v94);
      MEMORY[0x1895BC2CC](v97);
      int v17 = 1;
      unint64_t v18 = -34LL;
      goto LABEL_73;
    }

    unint64_t v19 = (ref::ref_cnt *)(data_entry_for_offset[7] + 16 * v105);
    BOOL v20 = ref::ref_cnt::get(v19);
    v92[0] = off_18A1E3FC0;
    v92[1] = v19;
    BOOL v93 = v20;
    if (!v20)
    {
      *(void *)&__int128 v84 = "di_asif::details::table::write(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
      *((void *)&v84 + 1) = 30LL;
      LODWORD(v85) = 16;
      di_log::logger<di_log::log_printer<1081ul>>::logger(v94, &v84);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v96,  (uint64_t)"Couldn't lock entry ",  20LL);
      di_asif::details::operator<<(&v96, &data_entry_for_offset);
      di_log::logger<di_log::log_printer<1081ul>>::~logger((uint64_t)v94);
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = off_18A1E43B0;
      int v74 = std::generic_category();
      exception[1] = 4294967282LL;
      exception[2] = v74;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 48) = 0;
      exception[7] = "Couldn't lock entry";
    }

    uint64_t v21 = v105;
    uint64_t v22 = data_entry_for_offset[7];
    uint64_t v23 = (*(void *)(v22 + 16 * v105 + 8) & 0x7FFFFFFFFFFFFFLL) * *(unsigned int *)(data_entry_for_offset[1] + 20LL);
    if (!v23)
    {
      LODWORD(v18) = di_asif::details::table::allocate_backend_space_for_entry( (uint64_t)this,  a2,  (uint64_t)data_entry_for_offset,  v105);
      if ((_DWORD)v18)
      {
        *(void *)&__int128 v84 = "di_asif::details::table::write(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
        *((void *)&v84 + 1) = 30LL;
        LODWORD(v85) = 16;
        di_log::logger<di_log::log_printer<1090ul>>::logger(v94, &v84);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v96,  (uint64_t)"couldn't allocate space for entry ",  34LL);
        di_asif::details::operator<<(&v96, &data_entry_for_offset);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v96, (uint64_t)" ret: ", 6LL);
        std::ostream::operator<<();
        std::ostream::~ostream();
        di_log::logger_buf<di_log::log_printer<1090ul>>::~logger_buf((uint64_t)v94);
        MEMORY[0x1895BC2CC](v97);
        unint64_t v18 = (int)v18;
        goto LABEL_71;
      }

      uint64_t v21 = v105;
      uint64_t v22 = data_entry_for_offset[7];
    }

    unint64_t v24 = atomic_load((unint64_t *)(v22 + 16 * v21 + 8));
    unint64_t v25 = di_asif::details::table_entry_data::write( (di_asif::details::table_entry_data *)&data_entry_for_offset,  a2,  (const sg_vec_ns::details::sg_vec_iterator *)v98,  (const sg_vec_ns::details::sg_vec_iterator *)&v101);
    unint64_t v18 = v25;
    unint64_t v27 = v26;
    if ((v25 & 0x8000000000000000LL) != 0 && (_DWORD)v25)
    {
      if (v23) {
        goto LABEL_71;
      }
      ref::details::ref_cnt_handle::upgrade_to_exclusive((ref::details::ref_cnt_handle *)v92, 0LL, (uint64_t)v94);
      if (!v95) {
        goto LABEL_70;
      }
      unint64_t v28 = atomic_load((unint64_t *)(data_entry_for_offset[7] + 16 * v105 + 8));
      if ((v28 & 0x4000000000000000LL) != 0) {
        goto LABEL_70;
      }
      uint64_t v29 = (unint64_t *)(data_entry_for_offset[7] + 16 * v105 + 8);
      unint64_t v30 = *v29;
      uint64_t v31 = *(unsigned int *)(data_entry_for_offset[1] + 20LL);
      if ((_DWORD)v31)
      {
        do
          unint64_t v32 = __ldxr(v29);
        while (__stxr(v32 & 0xFF80000000000000LL, v29));
LABEL_66:
        uint64_t v48 = (v30 & 0x7FFFFFFFFFFFFFLL) * v31;
        ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)v94);
        if (v48) {
          di_asif::details::dir_base::insert_space(*((di_asif::details::dir_base **)this + 1), v48, a2);
        }
        goto LABEL_71;
      }

      unint64_t v44 = *v29;
      unint64_t v45 = __ldxr(v29);
      if (v45 == v44)
      {
        if (__stxr(v44 & 0xFF80000000000000LL, v29)) {
          goto LABEL_60;
        }
LABEL_70:
        ref::details::ref_cnt_set_handle::~ref_cnt_set_handle((ref::details::ref_cnt_set_handle *)v94);
LABEL_71:
        int v17 = 1;
        goto LABEL_72;
      }

      __clrex();
LABEL_60:
      while (2)
      {
        unint64_t v46 = __ldxr(v29);
        if (v46 == v45)
        {
          if (!__stxr(v45 & 0xFF80000000000000LL, v29))
          {
            char v47 = 1;
            goto LABEL_65;
          }
        }

        else
        {
          __clrex();
        }

        char v47 = 0;
LABEL_65:
        unint64_t v45 = v46;
        if ((v47 & 1) != 0) {
          goto LABEL_66;
        }
        continue;
      }
    }

    unint64_t v33 = v24 >> 62;
    *(void *)&__int128 v84 = &v106;
    *((void *)&v84 + 1) = a4;
    unint64_t v85 = &v119[1];
    p_uint64_t data_entry_for_offset = &data_entry_for_offset;
    uint64_t v87 = v119;
    __int128 v88 = this;
    unint64_t v89 = v25;
    unint64_t v90 = v26;
    v91 = a2;
    if ((_DWORD)v33 == 1) {
      goto LABEL_55;
    }
    uint64_t v34 = data_entry_for_offset[1];
    uint64_t v35 = *(unsigned int *)(v34 + 20);
    if (v25 == v35
      && data_entry_for_offset[44]
       + (*(void *)(v34 + 48) + *(void *)(v34 + 48) * v105) / (unint64_t)(*(void *)(v34 + 48) + 1LL) * v35 == v26)
    {
      ref::details::ref_cnt_handle::upgrade_to_exclusive((ref::details::ref_cnt_handle *)v92, 0LL, (uint64_t)v82);
      if (!v83)
      {
        *(void *)&__int128 v80 = "di_asif::details::table::write(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
        *((void *)&v80 + 1) = 30LL;
        int v81 = 16;
        di_log::logger<di_log::log_printer<1151ul>>::logger(v94, &v80);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v96,  (uint64_t)"Couldn't upgrade lock entry ",  28LL);
        di_asif::details::operator<<(&v96, &data_entry_for_offset);
        di_log::logger<di_log::log_printer<1151ul>>::~logger((uint64_t)v94);
        unint64_t v75 = __cxa_allocate_exception(0x40uLL);
        *unint64_t v75 = off_18A1E43B0;
        uint64_t v76 = std::generic_category();
        v75[1] = 4294967282LL;
        unint64_t v75[2] = v76;
        *((_BYTE *)v75 + 24) = 0;
        *((_BYTE *)v75 + 48) = 0;
        v75[7] = "Couldn't upgrade lock entry";
      }

      unint64_t v36 = atomic_load((unint64_t *)(data_entry_for_offset[7] + 16 * v105 + 8));
      if ((_DWORD)v33 == 2 || (v36 & 0xC000000000000000LL) != 0x8000000000000000LL)
      {
        unint64_t v37 = (unint64_t *)(data_entry_for_offset[7] + 16 * v105 + 8);
        unint64_t v38 = *v37;
        unint64_t v39 = __ldaxr(v37);
        if (v39 == v38)
        {
          if (!__stlxr(v38 & 0x3FFFFFFFFFFFFFFFLL | 0x4000000000000000LL, v37)) {
            goto LABEL_47;
          }
        }

        else
        {
          __clrex();
        }

        do
        {
          while (1)
          {
            unint64_t v38 = v39;
            unint64_t v39 = __ldaxr(v37);
            if (v39 == v38) {
              break;
            }
            __clrex();
          }
        }

        while (__stlxr(v38 & 0x3FFFFFFFFFFFFFFFLL | 0x4000000000000000LL, v37));
LABEL_47:
        if (v119[0]) {
          BOOL v42 = 1;
        }
        else {
          BOOL v42 = v38 >> 62 == 3;
        }
        char v43 = v42;
        v119[0] = v43;
        atomic_store(1u, (unsigned int *)this + 24);
      }

LABEL_102:
  char v66 = v115;
  if (v115)
  {
    uint64_t v67 = (unint64_t *)&v115->__shared_owners_;
    do
      unint64_t v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }

  __int128 v69 = v107;
  if (v107)
  {
    __int128 v70 = (unint64_t *)&v107->__shared_owners_;
    do
      unint64_t v71 = __ldaxr(v70);
    while (__stlxr(v71 - 1, v70));
    if (!v71)
    {
      ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
      std::__shared_weak_count::__release_weak(v69);
    }
  }

  return v18;
}

          unint64_t v46 = v19;
          unint64_t v30 = "invalid char %c %s";
          uint64_t v31 = 610;
          goto LABEL_103;
        }

        if ((v26 & 1) != 0) {
          uint64_t v23 = 0;
        }
        else {
          uint64_t v23 = 6;
        }
LABEL_69:
        *(_DWORD *)(a1 + 16) = v23;
        continue;
      case 6:
        *(void *)(a1 + 80) = 0LL;
        if (((char)v18 & 0x80000000) == 0)
        {
          continue;
        }

void sub_1880EBF88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
}

void *di_log::logger<di_log::log_printer<1075ul>>::logger(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<1075ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E06D0;
  a1[45] = &unk_18A1E07D0;
  a1[46] = &unk_18A1E07F8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E06D0;
  a1[45] = &unk_18A1E0758;
  a1[46] = &unk_18A1E0780;
  return a1;
}

void sub_1880EC0FC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<1075ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<1081ul>>::logger(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<1081ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E08F0;
  a1[45] = &unk_18A1E09F0;
  a1[46] = &unk_18A1E0A18;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E08F0;
  a1[45] = &unk_18A1E0978;
  a1[46] = &unk_18A1E09A0;
  return a1;
}

void sub_1880EC1E4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<1081ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<1090ul>>::logger(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<1090ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E0B10;
  a1[45] = &unk_18A1E0C10;
  a1[46] = &unk_18A1E0C38;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E0B10;
  a1[45] = &unk_18A1E0B98;
  a1[46] = &unk_18A1E0BC0;
  return a1;
}

void sub_1880EC2CC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<1090ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_asif::details::table_entry_data::write( di_asif::details::table_entry_data *this, di_asif::details::ContextASIF *a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4)
{
  v194[80] = *MEMORY[0x1895F89C0];
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *(void *)(*(void *)this + 8LL);
  uint64_t v6 = *(unsigned int *)(v5 + 20);
  if (!((*(void *)(*(void *)(*(void *)this + 56LL) + 16 * v4 + 8) & 0x7FFFFFFFFFFFFFLL) * v6))
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "ASIF: No data offset found (write)", 0xFFFFFFEA);
  }

  __p = (void *)(*(void *)(*(void *)this + 352LL)
               + (*(void *)(v5 + 48) + *(void *)(v5 + 48) * v4)
  *(void *)&__int128 v193 = (char *)__p + v6;
  BYTE8(v193) = 2;
  sg_vec_ns::details::sg_vec_iterator::subvec(a3, (uint64_t)&__p, (uint64_t)a4, (uint64_t)v124);
  if (sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)v124, (uint64_t)&v127))
  {
    uint64_t v11 = -34LL;
  }

  else
  {
    __p = v194;
    __int128 v193 = xmmword_188179140;
    __int128 v12 = *(_OWORD *)((char *)a3 + 72);
    __int128 v182 = *(_OWORD *)((char *)a3 + 56);
    __int128 v183 = v12;
    __int128 v184 = *(_OWORD *)((char *)a3 + 88);
    char v185 = *((_BYTE *)a3 + 104);
    uint64_t v13 = (std::__shared_weak_count *)*((void *)a3 + 15);
    uint64_t v186 = *((void *)a3 + 14);
    v187 = v13;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }

    __int128 v188 = *((_OWORD *)a3 + 8);
    uint64_t v16 = *((void *)a4 + 7);
    uint64_t v17 = *((void *)a4 + 8);
    *(void *)&__int128 v168 = v16;
    *((void *)&v168 + 1) = v17;
    __int128 v18 = *(_OWORD *)((char *)a4 + 88);
    __int128 v169 = *(_OWORD *)((char *)a4 + 72);
    __int128 v170 = v18;
    char v171 = *((_BYTE *)a4 + 104);
    unint64_t v19 = (std::__shared_weak_count *)*((void *)a4 + 15);
    uint64_t v172 = *((void *)a4 + 14);
    v173 = v19;
    if (v19)
    {
      BOOL v20 = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }

    size_t v22 = 0LL;
    unint64_t v23 = 0LL;
    uint64_t v111 = (uint64_t)a3 + 128;
    __int128 v174 = *((_OWORD *)a4 + 8);
    while (1)
    {
      BOOL v24 = (void)v182 == v16 && *((void *)&v182 + 1) == v17;
      if (v24 && (void)v183 == (void)v169) {
        break;
      }
      ++v23;
      v22 += 40LL;
      sg_vec_ns::details::buffer_iterator::operator++((sg_vec_ns::details::buffer_iterator *)&v182);
    }

    if (v19)
    {
      unint64_t v25 = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }

    unint64_t v27 = v187;
    if (v187)
    {
      unint64_t v28 = (unint64_t *)&v187->__shared_owners_;
      do
        unint64_t v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }

    if (*((void *)&v193 + 1) < v23)
    {
      if (v23 >= 0x333333333333334LL) {
        boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v10);
      }
      unint64_t v30 = operator new(v22);
      boost::container::vector<lw_future<int>,boost::container::small_vector_allocator<lw_future<int>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_range_proxy<boost::container::small_vector_allocator<lw_future<int>,boost::container::new_allocator<void>,void>,boost::move_iterator<lw_future<int>*>,lw_future<int>*>>( (uint64_t)&__p,  (unint64_t)v30,  v23,  (_DWORD *)__p + 10 * v193,  0LL,  0LL);
    }

    uint64_t v31 = *(void *)a3;
    unint64_t v32 = (std::__shared_weak_count *)*((void *)a3 + 1);
    if (v32)
    {
      unint64_t v33 = (unint64_t *)&v32->__shared_owners_;
      do
        unint64_t v34 = __ldxr(v33);
      while (__stxr(v34 + 1, v33));
    }

    *(_OWORD *)uint64_t v117 = *((_OWORD *)a3 + 1);
    *(_OWORD *)&v117[9] = *(_OWORD *)((char *)a3 + 25);
    __int128 v118 = *(_OWORD *)((char *)a3 + 72);
    uint64_t v35 = *((void *)a3 + 6);
    uint64_t v36 = *((void *)a3 + 7);
    uint64_t v37 = *((void *)a3 + 8);
    __int128 v119 = *(_OWORD *)((char *)a3 + 88);
    char v120 = *((_BYTE *)a3 + 104);
    uint64_t v38 = *((void *)a3 + 14);
    unint64_t v39 = (std::__shared_weak_count *)*((void *)a3 + 15);
    if (v39)
    {
      unint64_t v40 = (unint64_t *)&v39->__shared_owners_;
      do
        unint64_t v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
    }

    __int128 v121 = *(_OWORD *)v111;
    unint64_t v122 = *((void *)a3 + 18);
    char v123 = *((_BYTE *)a3 + 152);
    uint64_t v42 = *(void *)a4;
    char v43 = (std::__shared_weak_count *)*((void *)a4 + 1);
    if (v43)
    {
      unint64_t v44 = (unint64_t *)&v43->__shared_owners_;
      do
        unint64_t v45 = __ldxr(v44);
      while (__stxr(v45 + 1, v44));
    }

    *(_OWORD *)char v113 = *((_OWORD *)a4 + 1);
    *(_OWORD *)&v113[9] = *(_OWORD *)((char *)a4 + 25);
    __int128 v114 = *(_OWORD *)((char *)a4 + 72);
    uint64_t v47 = *((void *)a4 + 6);
    uint64_t v46 = *((void *)a4 + 7);
    uint64_t v48 = *((void *)a4 + 8);
    __int128 v115 = *(_OWORD *)((char *)a4 + 88);
    char v116 = *((_BYTE *)a4 + 104);
    uint64_t v50 = *((void *)a4 + 14);
    uint64_t v49 = (std::__shared_weak_count *)*((void *)a4 + 15);
    if (v49)
    {
      unint64_t v51 = (unint64_t *)&v49->__shared_owners_;
      do
        unint64_t v52 = __ldxr(v51);
      while (__stxr(v52 + 1, v51));
    }

    unint64_t v53 = 0LL;
    v146[0] = *(_OWORD *)v117;
    *(_OWORD *)((char *)v146 + 9) = *(_OWORD *)&v117[9];
    __int128 v149 = v118;
    __int128 v150 = v119;
    __int128 v154 = v121;
    v132[0] = *(_OWORD *)v113;
    *(_OWORD *)((char *)v132 + 9) = *(_OWORD *)&v113[9];
    __int128 v137 = v115;
    uint64_t v144 = v31;
    v145 = v32;
    uint64_t v147 = v35;
    *(void *)&__int128 v148 = v36;
    *((void *)&v148 + 1) = v37;
    char v151 = v120;
    uint64_t v152 = v38;
    v153 = v39;
    unint64_t v155 = v122;
    char v156 = v123;
    uint64_t v130 = v42;
    __int128 v131 = v43;
    uint64_t v133 = v47;
    uint64_t v134 = v46;
    uint64_t v135 = v48;
    char v138 = v116;
    __int128 v136 = v114;
    uint64_t v139 = v50;
    v140 = v49;
    __int128 v141 = *((_OWORD *)a4 + 8);
    char v143 = *((_BYTE *)a4 + 152);
    unint64_t v142 = *((void *)a4 + 18);
    unint64_t v54 = v142;
    LOBYTE(v182) = 0;
    char v189 = 0;
    while (!sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&v144, (uint64_t)&v130))
    {
      if (DIDebugLogsEnabled())
      {
        *(void *)&__int128 v178 = "details::for_each_sg_in_vec_internal(Fn &&, sg_vec_ref::iterator, sg_vec::iterator, size_t, BOOL) [Fn = (lambda at /Library/Caches/com.apple.xbs/Sources/DiskImages2/app/disk_images/formats/asif.cpp:1765:32)]";
        *((void *)&v178 + 1) = 104LL;
        LODWORD(v179) = 2;
        di_log::logger<di_log::log_printer<545ul>>::logger(&v168, &v178);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v176, (uint64_t)"sg: ", 4LL);
        operator<<(&v176);
        std::ostream::~ostream();
        di_log::logger_buf<di_log::log_printer<545ul>>::~logger_buf((uint64_t)&v168);
        MEMORY[0x1895BC2CC](&v177);
      }

      *(void *)&__int128 v168 = 0LL;
      *((void *)&v168 + 1) = v54;
      LOBYTE(v169) = 2;
      trim_sg_to_interval(&v144, (uint64_t)&v168, (uint64_t)&v178);
      unint64_t v56 = v179;
      uint64_t v57 = *(void *)(*(void *)(*(void *)this + 56LL) + 16LL * *((void *)this + 1) + 8);
      unint64_t v58 = *(unsigned int *)(*(void *)(*(void *)this + 8LL) + 20LL);
      uint64_t v59 = v180;
      uint64_t v60 = v181;
      __int128 v168 = v178;
      if (*((void *)&v178 + 1))
      {
        __int128 v61 = (unint64_t *)(*((void *)&v178 + 1) + 8LL);
        do
          unint64_t v62 = __ldxr(v61);
        while (__stxr(v62 + 1, v61));
      }

      *(void *)&__int128 v169 = v56;
      *((void *)&v169 + 1) = (unint64_t)v59 % v58 + (v57 & 0x7FFFFFFFFFFFFFLL) * v58;
      *(void *)&__int128 v170 = v60;
      BYTE8(v170) = 0;
      (*(void (**)(void *__return_ptr, void, __int128 *))(**((void **)a2 + 2) + 136LL))( v190,  *((void *)a2 + 2),  &v168);
      if ((void)v193 == *((void *)&v193 + 1))
      {
        boost::container::vector<lw_future<int>,boost::container::small_vector_allocator<lw_future<int>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<lw_future<int>,boost::container::new_allocator<void>,void>,lw_future<int>*,lw_future<int>>>( (uint64_t *)&__p,  (_DWORD *)__p + 10 * v193,  (const char *)1,  v190,  &v191);
      }

      else
      {
        lw_future<int>::lw_future((unint64_t)__p + 40 * v193, v190);
        *(void *)&__int128 v193 = v193 + 1;
      }

      uint64_t v63 = v180;
      uint64_t v64 = v179;
      uint64_t v65 = (std::__shared_weak_count *)*((void *)&v168 + 1);
      if (*((void *)&v168 + 1))
      {
        char v66 = (unint64_t *)(*((void *)&v168 + 1) + 8LL);
        do
          unint64_t v67 = __ldaxr(v66);
        while (__stlxr(v67 - 1, v66));
        if (!v67)
        {
          ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
          std::__shared_weak_count::__release_weak(v65);
        }
      }

      BOOL v68 = v64 >= 0 || (_DWORD)v64 == 0;
      char v69 = v68;
      if (v68)
      {
        if (sg_vec_ns::should_create_new_sg_vec_ref( (sg_vec_ns *)&v144,  (const sg_vec_ns::details::sg_vec_iterator *)&v130,  v63,  v64))
        {
          v157[0] = v144;
          v157[1] = v145;
          if (v145)
          {
            int v74 = (unint64_t *)&v145->__shared_owners_;
            do
              unint64_t v75 = __ldxr(v74);
            while (__stxr(v75 + 1, v74));
          }

          v158[0] = v146[0];
          *(_OWORD *)((char *)v158 + 9) = *(_OWORD *)((char *)v146 + 9);
          __int128 v160 = v148;
          __int128 v161 = v149;
          __int128 v162 = v150;
          char v163 = v151;
          uint64_t v159 = v147;
          v164[0] = v152;
          v164[1] = v153;
          if (v153)
          {
            uint64_t v76 = (unint64_t *)&v153->__shared_owners_;
            do
              unint64_t v77 = __ldxr(v76);
            while (__stxr(v77 + 1, v76));
          }

          __int128 v165 = v154;
          unint64_t v166 = v155;
          char v167 = v156;
          sg_vec_ns::generate_vec_ref( (uint64_t)v157,  (uint64_t)&v130,  (uint64_t)v63,  v64,  0xFFFFFFFFFFFFFFFFLL,  (sg_vec_ref *)&v168);
          std::optional<sg_vec_ref>::operator=[abi:ne180100]<sg_vec_ref,void>((sg_vec_ref *)&v182, (uint64_t)&v168);
          sg_vec_ref::~sg_vec_ref((sg_vec_ref *)&v168);
          std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v164);
          std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v157);
          sg_vec_ref::begin((sg_vec_ref *)&v182, (uint64_t)&v168);
          sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v144, (uint64_t)&v168);
          std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v175);
          std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&v168);
          sg_vec_ref::end((sg_vec_ref *)&v182, (uint64_t)&v168);
          sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v130, (uint64_t)&v168);
          std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v175);
          std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&v168);
        }

        sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v144, v64);
        unint64_t v53 = (_OWORD *)((char *)v53 + v64);
      }

      else
      {
        else {
          uint64_t v73 = -(int)v64;
        }
        uint64_t v111 = -v73;
      }

      __int128 v70 = (std::__shared_weak_count *)*((void *)&v178 + 1);
      if (*((void *)&v178 + 1))
      {
        unint64_t v71 = (unint64_t *)(*((void *)&v178 + 1) + 8LL);
        do
          unint64_t v72 = __ldaxr(v71);
        while (__stlxr(v72 - 1, v71));
        if (!v72)
        {
          ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
          std::__shared_weak_count::__release_weak(v70);
        }
      }

      if ((v69 & 1) == 0) {
        goto LABEL_91;
      }
    }

    uint64_t v111 = (uint64_t)v53;
LABEL_91:
    std::__optional_destruct_base<sg_vec_ref,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v182);
    uint64_t v78 = v140;
    if (v140)
    {
      unint64_t v79 = (unint64_t *)&v140->__shared_owners_;
      do
        unint64_t v80 = __ldaxr(v79);
      while (__stlxr(v80 - 1, v79));
      if (!v80)
      {
        ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
        std::__shared_weak_count::__release_weak(v78);
      }
    }

    int v81 = v131;
    if (v131)
    {
      __int128 v82 = (unint64_t *)&v131->__shared_owners_;
      do
        unint64_t v83 = __ldaxr(v82);
      while (__stlxr(v83 - 1, v82));
      if (!v83)
      {
        ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
        std::__shared_weak_count::__release_weak(v81);
      }
    }

    __int128 v84 = v153;
    uint64_t v11 = v111;
    if (v153)
    {
      unint64_t v85 = (unint64_t *)&v153->__shared_owners_;
      do
        unint64_t v86 = __ldaxr(v85);
      while (__stlxr(v86 - 1, v85));
      if (!v86)
      {
        ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
        std::__shared_weak_count::__release_weak(v84);
      }
    }

    uint64_t v87 = v145;
    if (v145)
    {
      __int128 v88 = (unint64_t *)&v145->__shared_owners_;
      do
        unint64_t v89 = __ldaxr(v88);
      while (__stlxr(v89 - 1, v88));
      if (!v89)
      {
        ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
        std::__shared_weak_count::__release_weak(v87);
      }
    }

    if ((v111 & 0x8000000000000000LL) == 0 || !(_DWORD)v111)
    {
      (*(void (**)(void))(**((void **)a2 + 2) + 144LL))(*((void *)a2 + 2));
      if ((void)v193)
      {
        int v90 = 0;
        v91 = (unsigned int *)__p;
        uint64_t v92 = 40 * v193;
        do
        {
          int v93 = lw_future<int>::get(v91);
          if (v93 < 0) {
            break;
          }
          v90 += v93;
          v91 += 10;
          int v93 = v90;
          v92 -= 40LL;
        }

        while (v92);
      }

      else
      {
        int v93 = 0;
      }

      int v94 = v93 < 0 ? v93 : -5;
      uint64_t v95 = -v94;
      if (v111 != v93) {
        uint64_t v11 = -v95;
      }
    }

    if (*((void *)&v193 + 1) && v194 != __p) {
      operator delete(__p);
    }
  }

  uint64_t v96 = v129;
  if (v129)
  {
    uint64_t v97 = (unint64_t *)&v129->__shared_owners_;
    do
      unint64_t v98 = __ldaxr(v97);
    while (__stlxr(v98 - 1, v97));
    if (!v98)
    {
      ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
      std::__shared_weak_count::__release_weak(v96);
    }
  }

  v99 = v128;
  if (v128)
  {
    unint64_t v100 = (unint64_t *)&v128->__shared_owners_;
    do
      unint64_t v101 = __ldaxr(v100);
    while (__stlxr(v101 - 1, v100));
    if (!v101)
    {
      ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
      std::__shared_weak_count::__release_weak(v99);
    }
  }

  v102 = v126;
  if (v126)
  {
    unint64_t v103 = (unint64_t *)&v126->__shared_owners_;
    do
      unint64_t v104 = __ldaxr(v103);
    while (__stlxr(v104 - 1, v103));
    if (!v104)
    {
      ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
      std::__shared_weak_count::__release_weak(v102);
    }
  }

  uint64_t v105 = v125;
  if (v125)
  {
    uint64_t v106 = (unint64_t *)&v125->__shared_owners_;
    do
      unint64_t v107 = __ldaxr(v106);
    while (__stlxr(v107 - 1, v106));
    if (!v107)
    {
      ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
      std::__shared_weak_count::__release_weak(v105);
    }
  }

  return v11;
}

void sub_1880ECFEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (STACK[0x990])
  {
    if (a23 != STACK[0x980]) {
      operator delete((void *)STACK[0x980]);
    }
  }

  std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>::~pair((uint64_t)&a67);
  _Unwind_Resume(a1);
}

void *di_log::logger<di_log::log_printer<1151ul>>::logger(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<1151ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E0D30;
  a1[45] = &unk_18A1E0E30;
  a1[46] = &unk_18A1E0E58;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E0D30;
  a1[45] = &unk_18A1E0DB8;
  a1[46] = &unk_18A1E0DE0;
  return a1;
}

void sub_1880ED184(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<1151ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<1188ul>>::logger(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<1188ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E0F50;
  a1[45] = &unk_18A1E1050;
  a1[46] = &unk_18A1E1078;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E0F50;
  a1[45] = &unk_18A1E0FD8;
  a1[46] = &unk_18A1E1000;
  return a1;
}

void sub_1880ED26C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<1188ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t finally<di_asif::details::table::write(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::$_0>::~finally( uint64_t a1)
{
  __int128 v3 = *(di_asif::details::table **)(a1 + 40);
  unint64_t v2 = *(void *)(a1 + 48);
  if ((v2 & 0x8000000000000000LL) == 0 || !*(void *)(a1 + 48))
  {
    sg_vec_ns::details::sg_vec_iterator::operator+=(*(void *)a1, v2);
    uint64_t v4 = *(void *)(a1 + 16);
    if (*(_BYTE *)(v4 + 16))
    {
      uint64_t v5 = *(void **)(a1 + 24);
      if (*(void *)(*v5 + 352LL) != *(void *)(*(void *)v4 + 352LL) || v5[1] != *(void *)(v4 + 8))
      {
        char updated = di_asif::details::table::update_entry_if_bits_in_same_state( v3,  *(di_asif::details::ContextASIF **)(a1 + 64),  (di_asif::details::table_entry_data *)v4);
        unint64_t v7 = *(_BYTE **)(a1 + 32);
        BOOL v8 = (updated & 1) != 0 || *v7 != 0;
        *unint64_t v7 = v8;
        uint64_t v4 = *(void *)(a1 + 16);
        if (v8)
        {
          uint64_t v9 = *(void *)(*(void *)v4 + 8LL);
          uint64_t v10 = *((void *)v3 + 1);
          uint64_t v11 = *(void *)(v10 + 48);
          unsigned int v12 = *(_DWORD *)(v10 + 20);
          unint64_t v13 = *(unsigned __int16 *)(v10 + 18);
          unint64_t v14 = v11 * (v12 / v13);
          unint64_t v15 = *((void *)v3 + 44) / v13;
          ++v11;
          uint64_t v16 = v11
              + v11
              * (((*(void *)(*(void *)v4 + 352LL)
                 + (*(void *)(v9 + 48) + *(void *)(v9 + 48) * *(void *)(v4 + 8))
                 / (unint64_t)(*(void *)(v9 + 48) + 1LL)
                 * *(unsigned int *)(v9 + 20))
                / *(unsigned __int16 *)(v9 + 18)
                - v15)
               / v14);
          uint64_t v17 = *(void **)(a1 + 24);
          uint64_t v18 = *(void *)(*v17 + 8LL);
          if (v16 != v11
                    + v11
                    * (((*(void *)(*v17 + 352LL)
                       + (*(void *)(v18 + 48) + *(void *)(v18 + 48) * v17[1])
                       / (unint64_t)(*(void *)(v18 + 48) + 1LL)
                       * *(unsigned int *)(v18 + 20))
                      / *(unsigned __int16 *)(v18 + 18)
                      - v15)
                     / v14))
          {
            di_asif::details::table::check_if_map_element_needed( v3,  *(di_asif::details::ContextASIF **)(a1 + 64),  v16 - 1);
            **(_BYTE **)(a1 + 32) = 0;
            uint64_t v4 = *(void *)(a1 + 16);
          }
        }
      }
    }

    uint64_t v19 = *(void *)(a1 + 24);
    if (*(_BYTE *)(v4 + 16))
    {
      *(void *)(v4 + 8) = *(void *)(v19 + 8);
    }

    else
    {
      *(_OWORD *)uint64_t v4 = *(_OWORD *)v19;
      *(_BYTE *)(v4 + 16) = 1;
    }
  }

  return a1;
}

uint64_t std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>::~pair( uint64_t a1)
{
  uint64_t v2 = a1 + 160;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](a1 + 272);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](a1 + 112);
  return std::shared_ptr<char>::~shared_ptr[abi:ne180100](a1);
}

uint64_t di_asif::details::table::read( di_asif::details::table *this, di_asif::details::ContextASIF *a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4)
{
  uint64_t v4 = MEMORY[0x1895F8858](this);
  uint64_t v8 = v7;
  uint64_t v9 = (uint64_t)v5;
  uint64_t v10 = (di_asif::details::table *)v4;
  v311[599] = *MEMORY[0x1895F89C0];
  uint64_t v137 = v6[3];
  uint64_t v11 = *v6;
  unsigned int v12 = (std::__shared_weak_count *)v6[1];
  uint64_t v185 = *v6;
  uint64_t v186 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }

  *(_OWORD *)v187 = *((_OWORD *)v6 + 1);
  *(_OWORD *)&v187[9] = *(_OWORD *)((char *)v6 + 25);
  uint64_t v188 = v6[6];
  __int128 v189 = *(_OWORD *)(v6 + 7);
  __int128 v190 = *(_OWORD *)(v6 + 9);
  __int128 v191 = *(_OWORD *)(v6 + 11);
  char v192 = *((_BYTE *)v6 + 104);
  unint64_t v15 = (std::__shared_weak_count *)v6[15];
  uint64_t v193 = v6[14];
  v194 = v15;
  if (v15)
  {
    uint64_t v16 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    unsigned int v12 = v186;
  }

  __int128 v195 = *((_OWORD *)v6 + 8);
  uint64_t v196 = v6[18];
  char v197 = *((_BYTE *)v6 + 152);
  *(void *)&__int128 v198 = -78LL;
  LOBYTE(v237[0]) = 0;
  char v241 = 0;
  uint64_t v242 = v11;
  v243 = v12;
  if (v12)
  {
    uint64_t v18 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }

  *(_OWORD *)((char *)v244 + 9) = *(_OWORD *)&v187[9];
  v244[0] = *(_OWORD *)v187;
  __int128 v246 = v189;
  __int128 v247 = v190;
  uint64_t v245 = v188;
  char v249 = v192;
  __int128 v248 = v191;
  uint64_t v250 = v193;
  v251 = v194;
  if (v194)
  {
    BOOL v20 = (unint64_t *)&v194->__shared_owners_;
    do
      unint64_t v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }

  size_t v22 = (const sg_vec_ns::details::sg_vec_iterator *)&v270;
  __int128 v252 = v195;
  char v254 = v197;
  uint64_t v253 = v196;
  v255[0] = v11;
  v255[1] = v186;
  if (v186)
  {
    unint64_t v23 = (unint64_t *)&v186->__shared_owners_;
    do
      unint64_t v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }

  *(_OWORD *)((char *)v256 + 9) = *(_OWORD *)&v187[9];
  v256[0] = *(_OWORD *)v187;
  __int128 v258 = v189;
  __int128 v259 = v190;
  uint64_t v257 = v188;
  __int128 v260 = v191;
  char v261 = v192;
  uint64_t v262 = v193;
  v263 = v194;
  if (v194)
  {
    unint64_t v25 = (unint64_t *)&v194->__shared_owners_;
    do
      unint64_t v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }

  uint64_t v141 = 0LL;
  char v266 = v197;
  __int128 v264 = v195;
  uint64_t v265 = v196;
  v267 = v5;
  v268[0] = (uint64_t)&v269;
  v268[1] = 0LL;
  v268[2] = 16LL;
  LOBYTE(v270) = 0;
  char v271 = 0;
  v272 = &v275;
  uint64_t v273 = 0LL;
  uint64_t v274 = 16LL;
  uint64_t v276 = 0LL;
  v184[0] = (uint64_t)v237;
  v184[1] = (uint64_t)&v198;
  v184[2] = (uint64_t)v5;
  char v138 = (di_asif::details::table *)v4;
  uint64_t v139 = v5;
  while (!sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&v185, v8))
  {
    *(void *)&__int128 v183 = di_asif::details::table::get_data_entry_for_offset(v10, *(unint64_t *)&v187[8]);
    *((void *)&v183 + 1) = v27;
    uint64_t v28 = *(void *)(v183 + 8);
    uint64_t v29 = *(void *)(v28 + 48);
    uint64_t v30 = *(unsigned int *)(v28 + 20);
    *(void *)&__int128 v277 = *(void *)(v183 + 352) + (v29 + v29 * v27) / (unint64_t)(v29 + 1) * v30;
    *((void *)&v277 + 1) = v277 + v30;
    v278[0] = 2;
    sg_vec_ns::details::sg_vec_iterator::subvec( (sg_vec_ns::details::sg_vec_iterator *)&v185,  (uint64_t)&v277,  v8,  (uint64_t)&v158);
    if (sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&v158, (uint64_t)&v170))
    {
      *(void *)&__int128 v305 = "di_asif::details::table::read(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
      *((void *)&v305 + 1) = 29LL;
      LODWORD(v306) = 16;
      di_log::logger<di_log::log_printer<1441ul>>::logger(&v277, &v305);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v302,  (uint64_t)"Couldn't trim entry in read ",  28LL);
      operator<<(&v302);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<1441ul>>::~logger_buf((uint64_t)&v277);
      MEMORY[0x1895BC2CC](v303);
      *(void *)&__int128 v198 = -34LL;
      int v31 = 3;
    }

    else
    {
      if (v271
        && !di_asif::details::table_entry_obj::is_physically_contiguous( (di_asif::details::table_entry_obj *)&v183,  (const di_asif::details::table_entry_obj *)&v270)
        && (uint64_t v74 = di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::data_entries_vectorizer_t::finalize_ios((uint64_t)v237),
            v74 < 0)
        && (_DWORD)v74)
      {
        *(void *)&__int128 v153 = v74;
        *((void *)&v153 + 1) = v75;
        __int128 v154 = v237;
        int v155 = 0;
        v156[0] = 0;
        char v157 = 0;
      }

      else
      {
        __int128 v270 = v183;
        char v271 = 1;
        unint64_t v32 = (ref::ref_cnt *)(*(void *)(v183 + 56) + 16LL * *((void *)&v183 + 1));
        BOOL v33 = ref::ref_cnt::get(v32);
        *(void *)&__int128 v305 = off_18A1E3FC0;
        *((void *)&v305 + 1) = v32;
        LOBYTE(v306) = v33;
        if (v33)
        {
          uint64_t v34 = 0LL;
        }

        else
        {
          *(void *)&__int128 v224 = "di_asif::details::table::read(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)::data_entries_vectorizer_t::add_data_entry(const data_entry_t &)";
          *((void *)&v224 + 1) = 139LL;
          LODWORD(v225[0]) = 16;
          di_log::logger<di_log::log_printer<1409ul>>::logger(&v277, &v224);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v302,  (uint64_t)"Couldn't lock entry ",  20LL);
          di_asif::details::operator<<(&v302, &v183);
          std::ostream::~ostream();
          di_log::logger_buf<di_log::log_printer<1409ul>>::~logger_buf((uint64_t)&v277);
          MEMORY[0x1895BC2CC](v303);
          uint64_t v34 = -5LL;
        }

        unint64_t v35 = atomic_load((unint64_t *)(*(void *)(v270 + 56) + 16LL * *((void *)&v270 + 1) + 8));
        *(void *)&__int128 v153 = v34;
        __int128 v154 = v237;
        int v155 = v35 >> 62;
        ref::details::ref_cnt_handle::ref_cnt_handle((uint64_t)v156, (uint64_t)&v305);
        char v157 = 1;
        ref::details::ref_cnt_handle::~ref_cnt_handle((ref::details::ref_cnt_handle *)&v305);
      }

      __int128 v198 = v153;
      if ((v153 & 0x8000000000000000LL) != 0 && (_DWORD)v198)
      {
LABEL_171:
        int v31 = 3;
      }

      else
      {
        switch(v155)
        {
          case 0:
          case 2:
            __int128 v36 = v158;
            if (*((void *)&v158 + 1))
            {
              uint64_t v37 = (unint64_t *)(*((void *)&v158 + 1) + 8LL);
              do
                unint64_t v38 = __ldxr(v37);
              while (__stxr(v38 + 1, v37));
            }

            *(_OWORD *)v146 = v159[0];
            *(_OWORD *)&v146[9] = *(_OWORD *)((char *)v159 + 9);
            uint64_t v39 = v160;
            uint64_t v40 = v161;
            __int128 v147 = v162;
            __int128 v148 = v163;
            char v149 = v164;
            uint64_t v41 = *((void *)&v161 + 1);
            uint64_t v42 = v165;
            char v43 = v166;
            if (v166)
            {
              unint64_t v44 = (unint64_t *)&v166->__shared_owners_;
              do
                unint64_t v45 = __ldxr(v44);
              while (__stxr(v45 + 1, v44));
            }

            __int128 v150 = v167;
            unint64_t v151 = v168;
            char v152 = v169;
            uint64_t v46 = v170;
            uint64_t v47 = v171;
            if (v171)
            {
              uint64_t v48 = (unint64_t *)&v171->__shared_owners_;
              do
                unint64_t v49 = __ldxr(v48);
              while (__stxr(v49 + 1, v48));
            }

            *(_OWORD *)unint64_t v142 = v172[0];
            *(_OWORD *)&v142[9] = *(_OWORD *)((char *)v172 + 9);
            uint64_t v50 = v173;
            __int128 v51 = v174;
            uint64_t v52 = v178;
            __int128 v143 = v175;
            __int128 v144 = v176;
            char v145 = v177;
            unint64_t v53 = v179;
            if (v179)
            {
              unint64_t v54 = (unint64_t *)&v179->__shared_owners_;
              do
                unint64_t v55 = __ldxr(v54);
              while (__stxr(v55 + 1, v54));
            }

            unint64_t v56 = 0LL;
            int v57 = 0;
            uint64_t v58 = 0LL;
            __int128 v212 = v36;
            v213[0] = *(_OWORD *)v146;
            *(_OWORD *)((char *)v213 + 9) = *(_OWORD *)&v146[9];
            uint64_t v214 = v39;
            *(void *)&__int128 v215 = v40;
            __int128 v216 = v147;
            __int128 v217 = v148;
            char v218 = v149;
            *((void *)&v215 + 1) = v41;
            uint64_t v219 = v42;
            v220 = v43;
            __int128 v221 = v150;
            unint64_t v222 = v151;
            char v223 = v152;
            uint64_t v199 = v46;
            v200 = v47;
            v201[0] = *(_OWORD *)v142;
            *(_OWORD *)((char *)v201 + 9) = *(_OWORD *)&v142[9];
            uint64_t v202 = v50;
            __int128 v203 = v51;
            char v206 = v145;
            __int128 v204 = v143;
            __int128 v205 = v144;
            uint64_t v207 = v52;
            v208 = v53;
            __int128 v209 = v180;
            char v211 = v182;
            unint64_t v210 = v181;
            unint64_t v59 = v181;
            LOBYTE(v277) = 0;
            v303[160] = 0;
            while (!sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&v212, (uint64_t)&v199))
            {
              if (v222 >= v59 || v58 == -1) {
                break;
              }
              if (DIDebugLogsEnabled())
              {
                *(void *)&__int128 v235 = "details::for_each_sg_in_vec_internal(Fn &&, sg_vec_ref::iterator, sg_vec::iterator, size_t, BOOL) [Fn = (lambda at /Library/Caches/com.apple.xbs/Sources/DiskImages2/app/disk_images/formats/asif.cpp:1462:30)]";
                *((void *)&v235 + 1) = 104LL;
                int v236 = 2;
                di_log::logger<di_log::log_printer<545ul>>::logger(&v305, &v235);
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v310, (uint64_t)"sg: ", 4LL);
                operator<<(&v310);
                std::ostream::~ostream();
                di_log::logger_buf<di_log::log_printer<545ul>>::~logger_buf((uint64_t)&v305);
                MEMORY[0x1895BC2CC](v311);
              }

              *(void *)&__int128 v305 = 0LL;
              *((void *)&v305 + 1) = v59;
              LOBYTE(v306) = 2;
              trim_sg_to_interval(&v212, (uint64_t)&v305, (uint64_t)&v235);
              int64_t zeros = di_asif::details::table_entry_data::get_zeros(&v183, &v235);
              unint64_t v63 = zeros;
              BOOL v64 = zeros >= 0 || (_DWORD)zeros == 0;
              char v65 = v64;
              if (v64)
              {
                size_t v22 = v62;
                if (!v57) {
                  unint64_t v56 = v62;
                }
                if (sg_vec_ns::should_create_new_sg_vec_ref( (sg_vec_ns *)&v212,  (const sg_vec_ns::details::sg_vec_iterator *)&v199,  v62,  zeros))
                {
                  __int128 v224 = v212;
                  if (*((void *)&v212 + 1))
                  {
                    __int128 v70 = (unint64_t *)(*((void *)&v212 + 1) + 8LL);
                    do
                      unint64_t v71 = __ldxr(v70);
                    while (__stxr(v71 + 1, v70));
                  }

                  v225[0] = v213[0];
                  *(_OWORD *)((char *)v225 + 9) = *(_OWORD *)((char *)v213 + 9);
                  __int128 v227 = v215;
                  __int128 v228 = v216;
                  __int128 v229 = v217;
                  char v230 = v218;
                  uint64_t v226 = v214;
                  v231[0] = v219;
                  v231[1] = v220;
                  if (v220)
                  {
                    unint64_t v72 = (unint64_t *)&v220->__shared_owners_;
                    do
                      unint64_t v73 = __ldxr(v72);
                    while (__stxr(v73 + 1, v72));
                  }

                  __int128 v232 = v221;
                  unint64_t v233 = v222;
                  char v234 = v223;
                  sg_vec_ns::generate_vec_ref( (uint64_t)&v224,  (uint64_t)&v199,  (uint64_t)v22,  v63,  0xFFFFFFFFFFFFFFFFLL,  (sg_vec_ref *)&v305);
                  std::optional<sg_vec_ref>::operator=[abi:ne180100]<sg_vec_ref,void>( (sg_vec_ref *)&v277,  (uint64_t)&v305);
                  sg_vec_ref::~sg_vec_ref((sg_vec_ref *)&v305);
                  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v231);
                  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&v224);
                  sg_vec_ref::begin((sg_vec_ref *)&v277, (uint64_t)&v305);
                  sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v212, (uint64_t)&v305);
                  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v309);
                  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&v305);
                  sg_vec_ref::end((sg_vec_ref *)&v277, (uint64_t)&v305);
                  sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v199, (uint64_t)&v305);
                  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v309);
                  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&v305);
                }

                sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v212, v63);
                v58 += v63;
                int v57 = 1;
              }

              else
              {
                else {
                  uint64_t v69 = -(int)zeros;
                }
                uint64_t v140 = -v69;
              }

              char v66 = (std::__shared_weak_count *)*((void *)&v235 + 1);
              if (*((void *)&v235 + 1))
              {
                unint64_t v67 = (unint64_t *)(*((void *)&v235 + 1) + 8LL);
                do
                  unint64_t v68 = __ldaxr(v67);
                while (__stlxr(v68 - 1, v67));
                if (!v68)
                {
                  ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
                  std::__shared_weak_count::__release_weak(v66);
                }
              }

              if ((v65 & 1) == 0) {
                goto LABEL_90;
              }
            }

            if (v57) {
              size_t v22 = v56;
            }
            else {
              size_t v22 = 0LL;
            }
            uint64_t v140 = v58;
LABEL_90:
            std::__optional_destruct_base<sg_vec_ref,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v277);
            uint64_t v76 = v208;
            uint64_t v10 = v138;
            if (v208)
            {
              unint64_t v77 = (unint64_t *)&v208->__shared_owners_;
              do
                unint64_t v78 = __ldaxr(v77);
              while (__stlxr(v78 - 1, v77));
              if (!v78)
              {
                ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
                std::__shared_weak_count::__release_weak(v76);
              }
            }

            unint64_t v79 = v200;
            uint64_t v9 = (uint64_t)v139;
            if (v200)
            {
              unint64_t v80 = (unint64_t *)&v200->__shared_owners_;
              do
                unint64_t v81 = __ldaxr(v80);
              while (__stlxr(v81 - 1, v80));
              if (!v81)
              {
                ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
                std::__shared_weak_count::__release_weak(v79);
              }
            }

            __int128 v82 = v220;
            if (v220)
            {
              unint64_t v83 = (unint64_t *)&v220->__shared_owners_;
              do
                unint64_t v84 = __ldaxr(v83);
              while (__stlxr(v84 - 1, v83));
              if (!v84)
              {
                ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
                std::__shared_weak_count::__release_weak(v82);
              }
            }

            unint64_t v85 = (std::__shared_weak_count *)*((void *)&v212 + 1);
            if (*((void *)&v212 + 1))
            {
              unint64_t v86 = (unint64_t *)(*((void *)&v212 + 1) + 8LL);
              do
                unint64_t v87 = __ldaxr(v86);
              while (__stlxr(v87 - 1, v86));
              if (!v87)
              {
                ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
                std::__shared_weak_count::__release_weak(v85);
              }
            }

            *(void *)&__int128 v198 = v140;
            *((void *)&v198 + 1) = v22;
            size_t v22 = (const sg_vec_ns::details::sg_vec_iterator *)&v270;
            goto LABEL_169;
          case 1:
            goto LABEL_166;
          case 3:
            uint64_t v88 = *(void *)(v183 + 8);
            unint64_t v89 = (*(void *)(v183 + 352)
                 + (*(void *)(v88 + 48) + *(void *)(v88 + 48) * *((void *)&v183 + 1))
                 / (unint64_t)(*(void *)(v88 + 48) + 1LL)
            if (!v241)
            {
              uint64_t v90 = 0LL;
LABEL_115:
              *(void *)&__int128 v305 = 0LL;
              *((void *)&v305 + 1) = v10;
              v306 = &v308;
              __int128 v307 = xmmword_188179140;
              di_asif::details::table::get_bitmap(v10, v267, v89, 0, 1LL, (unint64_t *)&v224);
              ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::operator=( (unint64_t *)&v305,  (unint64_t *)&v224);
              ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)&v224);
              size_t v22 = (const sg_vec_ns::details::sg_vec_iterator *)&v270;
              if ((void)v305 && !*(_BYTE *)(v305 + 344))
              {
                ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::tagged_ptr( (unint64_t *)&v277,  (unint64_t *)&v305);
                *((void *)&v277 + 1) = *((void *)&v305 + 1);
                *(void *)v278 = &v278[24];
                *(_OWORD *)&v278[8] = xmmword_188179140;
                *(void *)&__int128 v224 = v306;
                *(void *)&__int128 v212 = &v306[40 * v307];
                boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::assign<boost::container::vec_iterator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,true>>( (uint64_t *)v278,  (const char *)&v224,  (uint64_t *)&v212);
                char v92 = 1;
              }

              else
              {
                v91 = std::generic_category();
                char v92 = 0;
                *(void *)&__int128 v277 = 5LL;
                *((void *)&v277 + 1) = v91;
              }

              char v304 = v92;
              di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::bitmap_handle_t::~bitmap_handle_t((uint64_t)&v305);
              if (!v304)
              {
                else {
                  uint64_t v129 = -(int)v277;
                }
                uint64_t v90 = -v129;
                goto LABEL_164;
              }

              if (v241)
              {
                di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::bitmap_handle_t::~bitmap_handle_t((uint64_t)v237);
                char v241 = 0;
              }

              ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::tagged_ptr( v237,  (unint64_t *)&v277);
              v237[1] = *((void *)&v277 + 1);
              v238 = &v240;
              __int128 v239 = xmmword_188179140;
              *(void *)&__int128 v305 = *(void *)v278;
              *(void *)&__int128 v224 = *(void *)v278 + 320LL * *(void *)&v278[8];
              boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::assign<boost::container::vec_iterator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,true>>( (uint64_t *)&v238,  (const char *)&v305,  (uint64_t *)&v224);
              char v241 = 1;
              if (v304) {
                di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::bitmap_handle_t::~bitmap_handle_t((uint64_t)&v277);
              }
              goto LABEL_129;
            }

            if (*(void *)(v237[0] + 40) == (v89
                                             - *((void *)v10 + 44)
                                             / (unint64_t)*(unsigned __int16 *)(*((void *)v10 + 1) + 18LL))
                                            / (*(void *)(*((void *)v10 + 1) + 48LL)
                                             * (unint64_t)(*(_DWORD *)(*((void *)v10 + 1) + 20LL)
                                                                / *(unsigned __int16 *)(*((void *)v10 + 1) + 18LL))))
            {
              uint64_t v90 = 0LL;
              goto LABEL_129;
            }

            uint64_t v93 = di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::data_entries_vectorizer_t::finalize((uint64_t)v237);
            uint64_t v90 = v93;
            if (v93 < 0 && (_DWORD)v93)
            {
              size_t v22 = (const sg_vec_ns::details::sg_vec_iterator *)&v270;
              goto LABEL_164;
            }

            uint64_t v140 = v94;
            if (!v241) {
              goto LABEL_115;
            }
LABEL_129:
            __int128 v277 = v158;
            if (*((void *)&v158 + 1))
            {
              uint64_t v95 = (unint64_t *)(*((void *)&v158 + 1) + 8LL);
              do
                unint64_t v96 = __ldxr(v95);
              while (__stxr(v96 + 1, v95));
            }

            *(_OWORD *)v278 = v159[0];
            *(_OWORD *)&v278[9] = *(_OWORD *)((char *)v159 + 9);
            __int128 v280 = v161;
            __int128 v281 = v162;
            __int128 v282 = v163;
            char v283 = v164;
            uint64_t v279 = v160;
            uint64_t v284 = v165;
            v285 = v166;
            if (v166)
            {
              uint64_t v97 = (unint64_t *)&v166->__shared_owners_;
              do
                unint64_t v98 = __ldxr(v97);
              while (__stxr(v98 + 1, v97));
            }

            __int128 v286 = v167;
            unint64_t v287 = v168;
            char v288 = v169;
            uint64_t v289 = v170;
            v290 = v171;
            if (v171)
            {
              v99 = (unint64_t *)&v171->__shared_owners_;
              do
                unint64_t v100 = __ldxr(v99);
              while (__stxr(v100 + 1, v99));
            }

            v291[0] = v172[0];
            *(_OWORD *)((char *)v291 + 9) = *(_OWORD *)((char *)v172 + 9);
            __int128 v293 = v174;
            __int128 v294 = v175;
            __int128 v295 = v176;
            char v296 = v177;
            uint64_t v292 = v173;
            uint64_t v297 = v178;
            v298 = v179;
            if (v179)
            {
              unint64_t v101 = (unint64_t *)&v179->__shared_owners_;
              do
                unint64_t v102 = __ldxr(v101);
              while (__stxr(v102 + 1, v101));
            }

            __int128 v299 = v180;
            unint64_t v300 = v181;
            char v301 = v182;
            if ((void)v239 == *((void *)&v239 + 1))
            {
              boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>>>( (uint64_t *)&v238,  (uint64_t)&v238[40 * v239],  (const char *)1,  (uint64_t)&v277,  &v305);
            }

            else
            {
              __n128 v103 = std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>::pair[abi:ne180100]( (uint64_t)&v238[40 * v239],  (uint64_t)&v277);
              *(void *)&__int128 v239 = v239 + 1;
            }

            unint64_t v104 = v298;
            if (v298)
            {
              uint64_t v105 = (unint64_t *)&v298->__shared_owners_;
              do
                unint64_t v106 = __ldaxr(v105);
              while (__stlxr(v106 - 1, v105));
              if (!v106)
              {
                ((void (*)(std::__shared_weak_count *, __n128))v104->__on_zero_shared)(v104, v103);
                std::__shared_weak_count::__release_weak(v104);
              }
            }

            unint64_t v107 = v290;
            if (v290)
            {
              unint64_t v108 = (unint64_t *)&v290->__shared_owners_;
              do
                unint64_t v109 = __ldaxr(v108);
              while (__stlxr(v109 - 1, v108));
              if (!v109)
              {
                ((void (*)(std::__shared_weak_count *, __n128))v107->__on_zero_shared)(v107, v103);
                std::__shared_weak_count::__release_weak(v107);
              }
            }

            __int128 v110 = v285;
            if (v285)
            {
              uint64_t v111 = (unint64_t *)&v285->__shared_owners_;
              do
                unint64_t v112 = __ldaxr(v111);
              while (__stlxr(v112 - 1, v111));
              if (!v112)
              {
                ((void (*)(std::__shared_weak_count *, __n128))v110->__on_zero_shared)(v110, v103);
                std::__shared_weak_count::__release_weak(v110);
              }
            }

            char v113 = (std::__shared_weak_count *)*((void *)&v277 + 1);
            if (*((void *)&v277 + 1))
            {
              __int128 v114 = (unint64_t *)(*((void *)&v277 + 1) + 8LL);
              do
                unint64_t v115 = __ldaxr(v114);
              while (__stlxr(v115 - 1, v114));
              if (!v115)
              {
                ((void (*)(std::__shared_weak_count *, __n128))v113->__on_zero_shared)(v113, v103);
                std::__shared_weak_count::__release_weak(v113);
              }
            }

            size_t v22 = (const sg_vec_ns::details::sg_vec_iterator *)&v270;
            uint64_t v94 = v140;
LABEL_164:
            *(void *)&__int128 v198 = v90;
            *((void *)&v198 + 1) = v94;
            if ((v90 & 0x8000000000000000LL) == 0 || !(_DWORD)v90)
            {
LABEL_166:
              di_asif::details::table_entry_data::future_read( (sg_vec_ns::details::sg_vec_iterator *)&v158,  &v183,  v9,  (uint64_t)&v170,  v268,  (unint64_t *)&v277);
              __int128 v198 = v277;
              if ((v277 & 0x8000000000000000LL) == 0 || !(_DWORD)v198) {
                v276 += *(void *)v278;
              }
            }

LABEL_169:
            uint64_t v116 = v198;
            if ((v198 & 0x8000000000000000LL) != 0 && (_DWORD)v198) {
              goto LABEL_171;
            }
            sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v185, v198);
            v141 += v116;
            sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)v255, (uint64_t)&v185);
            int v31 = 0;
            break;
          default:
            goto LABEL_169;
        }
      }

      di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::data_entries_vectorizer_t::io_result_inserter_t::~io_result_inserter_t((uint64_t)&v153);
    }

    uint64_t v117 = v179;
    if (v179)
    {
      __int128 v118 = (unint64_t *)&v179->__shared_owners_;
      do
        unint64_t v119 = __ldaxr(v118);
      while (__stlxr(v119 - 1, v118));
      if (!v119)
      {
        ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
        std::__shared_weak_count::__release_weak(v117);
      }
    }

    char v120 = v171;
    if (v171)
    {
      __int128 v121 = (unint64_t *)&v171->__shared_owners_;
      do
        unint64_t v122 = __ldaxr(v121);
      while (__stlxr(v122 - 1, v121));
      if (!v122)
      {
        ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
        std::__shared_weak_count::__release_weak(v120);
      }
    }

    char v123 = v166;
    if (v166)
    {
      char v124 = (unint64_t *)&v166->__shared_owners_;
      do
        unint64_t v125 = __ldaxr(v124);
      while (__stlxr(v125 - 1, v124));
      if (!v125)
      {
        ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
        std::__shared_weak_count::__release_weak(v123);
      }
    }

    v126 = (std::__shared_weak_count *)*((void *)&v158 + 1);
    if (!*((void *)&v158 + 1)) {
      goto LABEL_193;
    }
    uint64_t v127 = (unint64_t *)(*((void *)&v158 + 1) + 8LL);
    do
      unint64_t v128 = __ldaxr(v127);
    while (__stlxr(v128 - 1, v127));
    if (!v128)
    {
      ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
      std::__shared_weak_count::__release_weak(v126);
      if (v31) {
        break;
      }
    }

    else
    {
LABEL_193:
      if (v31) {
        break;
      }
    }
  }

  if ((v198 & 0x8000000000000000LL) == 0 || !(_DWORD)v198)
  {
    *(void *)&__int128 v198 = v141;
    *((void *)&v198 + 1) = v137;
  }

  finally<di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::$_0>::~finally(v184);
  di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::data_entries_vectorizer_t::~data_entries_vectorizer_t((uint64_t)v237);
  uint64_t v130 = v194;
  if (v194)
  {
    __int128 v131 = (unint64_t *)&v194->__shared_owners_;
    do
      unint64_t v132 = __ldaxr(v131);
    while (__stlxr(v132 - 1, v131));
    if (!v132)
    {
      ((void (*)(std::__shared_weak_count *))v130->__on_zero_shared)(v130);
      std::__shared_weak_count::__release_weak(v130);
    }
  }

  uint64_t v133 = v186;
  if (v186)
  {
    uint64_t v134 = (unint64_t *)&v186->__shared_owners_;
    do
      unint64_t v135 = __ldaxr(v134);
    while (__stlxr(v135 - 1, v134));
    if (!v135)
    {
      ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
      std::__shared_weak_count::__release_weak(v133);
    }
  }

  return v198;
}

void sub_1880EEAFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void *di_log::logger<di_log::log_printer<1441ul>>::logger(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<1441ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E1170;
  a1[45] = &unk_18A1E1270;
  a1[46] = &unk_18A1E1298;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E1170;
  a1[45] = &unk_18A1E11F8;
  a1[46] = &unk_18A1E1220;
  return a1;
}

void sub_1880EED9C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<1441ul>>::~logger(uint64_t a1)
{
  return a1;
}

void di_asif::details::table_entry_data::future_read( sg_vec_ns::details::sg_vec_iterator *a1@<X2>, void *a2@<X0>, uint64_t a3@<X1>, uint64_t a4@<X3>, uint64_t *a5@<X4>, unint64_t *a6@<X8>)
{
  uint64_t v9 = *(void *)(*a2 + 8LL);
  uint64_t v10 = *(void *)(v9 + 48);
  uint64_t v11 = *(unsigned int *)(v9 + 20);
  *(void *)&__int128 v229 = *(void *)(*a2 + 352LL) + (v10 + v10 * a2[1]) / (unint64_t)(v10 + 1) * v11;
  *((void *)&v229 + 1) = v229 + v11;
  LOBYTE(v230[0]) = 2;
  sg_vec_ns::details::sg_vec_iterator::subvec(a1, (uint64_t)&v229, a4, (uint64_t)&v149);
  if (sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&v149, (uint64_t)&v163))
  {
    *a6 = -34LL;
    a6[2] = 0LL;
  }

  else
  {
    uint64_t v12 = v149;
    if ((*(void *)(*(void *)(*a2 + 56LL) + 16LL * a2[1] + 8) & 0x7FFFFFFFFFFFFFLL)
       * *(unsigned int *)(*(void *)(*a2 + 8LL) + 20LL))
    {
      unint64_t v13 = v150;
      if (v150)
      {
        p_shared_owners = (unint64_t *)&v150->__shared_owners_;
        do
          unint64_t v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
      }

      *(_OWORD *)uint64_t v133 = v151[0];
      *(_OWORD *)&v133[9] = *(_OWORD *)((char *)v151 + 9);
      uint64_t v16 = v152;
      uint64_t v17 = v153;
      uint64_t v18 = v154;
      __int128 v134 = v155;
      __int128 v135 = v156;
      char v136 = v157;
      uint64_t v19 = v158;
      BOOL v20 = v159;
      if (v159)
      {
        unint64_t v21 = (unint64_t *)&v159->__shared_owners_;
        do
          unint64_t v22 = __ldxr(v21);
        while (__stxr(v22 + 1, v21));
      }

      v126 = a6;
      __int128 v137 = v160;
      unint64_t v138 = v161;
      char v139 = v162;
      __int128 v23 = v163;
      if (*((void *)&v163 + 1))
      {
        unint64_t v24 = (unint64_t *)(*((void *)&v163 + 1) + 8LL);
        do
          unint64_t v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }

      *(_OWORD *)uint64_t v129 = v164[0];
      *(_OWORD *)&v129[9] = *(_OWORD *)((char *)v164 + 9);
      uint64_t v26 = v165;
      __int128 v27 = v166;
      __int128 v130 = v167;
      __int128 v131 = v168;
      char v132 = v169;
      uint64_t v28 = v170;
      uint64_t v29 = v171;
      if (v171)
      {
        uint64_t v30 = (unint64_t *)&v171->__shared_owners_;
        do
          unint64_t v31 = __ldxr(v30);
        while (__stxr(v31 + 1, v30));
      }

      unint64_t v127 = 0LL;
      unint64_t v32 = 0LL;
      int v33 = 0;
      unint64_t v34 = 0LL;
      v189[0] = *(_OWORD *)v133;
      *(_OWORD *)((char *)v189 + 9) = *(_OWORD *)&v133[9];
      __int128 v192 = v134;
      __int128 v193 = v135;
      __int128 v197 = v137;
      v176[0] = *(_OWORD *)v129;
      *(_OWORD *)((char *)v176 + 9) = *(_OWORD *)&v129[9];
      __int128 v180 = v131;
      __int128 v179 = v130;
      uint64_t v187 = v12;
      uint64_t v188 = v13;
      uint64_t v190 = v16;
      *(void *)&__int128 v191 = v17;
      *((void *)&v191 + 1) = v18;
      char v194 = v136;
      uint64_t v195 = v19;
      uint64_t v196 = v20;
      unint64_t v198 = v138;
      char v199 = v139;
      __int128 v175 = v23;
      uint64_t v177 = v26;
      __int128 v178 = v27;
      char v181 = v132;
      uint64_t v182 = v28;
      __int128 v183 = v29;
      __int128 v184 = v172;
      char v186 = v174;
      unint64_t v185 = v173;
      unint64_t v35 = v173;
      LOBYTE(v229) = 0;
      char v242 = 0;
      while (!sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&v187, (uint64_t)&v175))
      {
        if (v198 >= v35 || v34 == -1LL) {
          break;
        }
        if (DIDebugLogsEnabled())
        {
          *(void *)&__int128 v245 = "details::for_each_sg_in_vec_internal(Fn &&, sg_vec_ref::iterator, sg_vec::iterator, size_t, BOOL) [Fn = (lambda at /Library/Caches/com.apple.xbs/Sources/DiskImages2/app/disk_images/formats/asif.cpp:1729:32)]";
          *((void *)&v245 + 1) = 104LL;
          LODWORD(v246) = 2;
          di_log::logger<di_log::log_printer<545ul>>::logger(&v211, &v245);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v223, (uint64_t)"sg: ", 4LL);
          operator<<(&v223);
          std::ostream::~ostream();
          di_log::logger_buf<di_log::log_printer<545ul>>::~logger_buf((uint64_t)&v211);
          MEMORY[0x1895BC2CC](&v224);
        }

        *(void *)&__int128 v211 = 0LL;
        *((void *)&v211 + 1) = v35;
        v212[0] = 2;
        trim_sg_to_interval(&v187, (uint64_t)&v211, (uint64_t)&v225);
        unint64_t v37 = v226;
        uint64_t v38 = *(void *)(*(void *)(*a2 + 56LL) + 16LL * a2[1] + 8);
        unint64_t v39 = *(unsigned int *)(*(void *)(*a2 + 8LL) + 20LL);
        uint64_t v40 = v227;
        uint64_t v41 = v228;
        __int128 v211 = v225;
        if (*((void *)&v225 + 1))
        {
          uint64_t v42 = (unint64_t *)(*((void *)&v225 + 1) + 8LL);
          do
            unint64_t v43 = __ldxr(v42);
          while (__stxr(v43 + 1, v42));
        }

        *(void *)__int128 v212 = v37;
        *(void *)&v212[8] = (unint64_t)v40 % v39 + (v38 & 0x7FFFFFFFFFFFFFLL) * v39;
        *(void *)&v212[16] = v41;
        v212[24] = 0;
        uint64_t v44 = (*(uint64_t (**)(void))(**(void **)(a3 + 16) + 40LL))(*(void *)(a3 + 16));
        v243[0] = 0LL;
        v243[1] = v44;
        char v244 = 2;
        trim_sg_to_interval(&v211, (uint64_t)v243, (uint64_t)&v245);
        if (v246)
        {
          (*(void (**)(void *__return_ptr, void, __int128 *))(**(void **)(a3 + 16) + 128LL))( v243,  *(void *)(a3 + 16),  &v245);
          uint64_t v45 = a5[1];
          if (v45 == a5[2])
          {
            boost::container::vector<lw_future<int>,boost::container::small_vector_allocator<lw_future<int>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<lw_future<int>,boost::container::new_allocator<void>,void>,lw_future<int>*,lw_future<int>>>( a5,  (_DWORD *)(*a5 + 40 * v45),  (const char *)1,  v243,  &v247);
          }

          else
          {
            lw_future<int>::lw_future(*a5 + 40 * v45, v243);
            ++a5[1];
          }

          v127 += v246;
        }

        uint64_t v46 = v227;
        uint64_t v47 = v226;
        uint64_t v48 = (std::__shared_weak_count *)*((void *)&v245 + 1);
        if (*((void *)&v245 + 1))
        {
          unint64_t v49 = (unint64_t *)(*((void *)&v245 + 1) + 8LL);
          do
            unint64_t v50 = __ldaxr(v49);
          while (__stlxr(v50 - 1, v49));
          if (!v50)
          {
            ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
            std::__shared_weak_count::__release_weak(v48);
          }
        }

        __int128 v51 = (std::__shared_weak_count *)*((void *)&v211 + 1);
        if (*((void *)&v211 + 1))
        {
          uint64_t v52 = (unint64_t *)(*((void *)&v211 + 1) + 8LL);
          do
            unint64_t v53 = __ldaxr(v52);
          while (__stlxr(v53 - 1, v52));
          if (!v53)
          {
            ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
            std::__shared_weak_count::__release_weak(v51);
          }
        }

        BOOL v54 = v47 >= 0 || (_DWORD)v47 == 0;
        char v55 = v54;
        if (v54)
        {
          if (!v33) {
            unint64_t v32 = v46;
          }
          if (sg_vec_ns::should_create_new_sg_vec_ref( (sg_vec_ns *)&v187,  (const sg_vec_ns::details::sg_vec_iterator *)&v175,  v46,  v47))
          {
            v200[0] = v187;
            v200[1] = v188;
            if (v188)
            {
              uint64_t v60 = (unint64_t *)&v188->__shared_owners_;
              do
                unint64_t v61 = __ldxr(v60);
              while (__stxr(v61 + 1, v60));
            }

            v201[0] = v189[0];
            *(_OWORD *)((char *)v201 + 9) = *(_OWORD *)((char *)v189 + 9);
            __int128 v203 = v191;
            __int128 v204 = v192;
            __int128 v205 = v193;
            char v206 = v194;
            uint64_t v202 = v190;
            v207[0] = v195;
            v207[1] = v196;
            if (v196)
            {
              unint64_t v62 = (unint64_t *)&v196->__shared_owners_;
              do
                unint64_t v63 = __ldxr(v62);
              while (__stxr(v63 + 1, v62));
            }

            __int128 v208 = v197;
            unint64_t v209 = v198;
            char v210 = v199;
            sg_vec_ns::generate_vec_ref( (uint64_t)v200,  (uint64_t)&v175,  (uint64_t)v46,  v47,  0xFFFFFFFFFFFFFFFFLL,  (sg_vec_ref *)&v211);
            std::optional<sg_vec_ref>::operator=[abi:ne180100]<sg_vec_ref,void>((sg_vec_ref *)&v229, (uint64_t)&v211);
            sg_vec_ref::~sg_vec_ref((sg_vec_ref *)&v211);
            std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v207);
            std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v200);
            sg_vec_ref::begin((sg_vec_ref *)&v229, (uint64_t)&v211);
            sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v187, (uint64_t)&v211);
            std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&v218);
            std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&v211);
            sg_vec_ref::end((sg_vec_ref *)&v229, (uint64_t)&v211);
            sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v175, (uint64_t)&v211);
            std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&v218);
            std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&v211);
          }

          sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v187, v47);
          v34 += v47;
          int v33 = 1;
        }

        else
        {
          else {
            uint64_t v59 = -(int)v47;
          }
          unint64_t v125 = -v59;
        }

        unint64_t v56 = (std::__shared_weak_count *)*((void *)&v225 + 1);
        if (*((void *)&v225 + 1))
        {
          int v57 = (unint64_t *)(*((void *)&v225 + 1) + 8LL);
          do
            unint64_t v58 = __ldaxr(v57);
          while (__stlxr(v58 - 1, v57));
          if (!v58)
          {
            ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
            std::__shared_weak_count::__release_weak(v56);
          }
        }

        if ((v55 & 1) == 0) {
          goto LABEL_76;
        }
      }

      if (v33) {
        uint64_t v46 = v32;
      }
      else {
        uint64_t v46 = 0LL;
      }
      unint64_t v125 = v34;
LABEL_76:
      std::__optional_destruct_base<sg_vec_ref,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v229);
      BOOL v64 = v183;
      if (v183)
      {
        char v65 = (unint64_t *)&v183->__shared_owners_;
        do
          unint64_t v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }

      unint64_t v67 = (std::__shared_weak_count *)*((void *)&v175 + 1);
      if (*((void *)&v175 + 1))
      {
        unint64_t v68 = (unint64_t *)(*((void *)&v175 + 1) + 8LL);
        do
          unint64_t v69 = __ldaxr(v68);
        while (__stlxr(v69 - 1, v68));
        if (!v69)
        {
          ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
          std::__shared_weak_count::__release_weak(v67);
        }
      }

      __int128 v70 = v196;
      if (v196)
      {
        unint64_t v71 = (unint64_t *)&v196->__shared_owners_;
        do
          unint64_t v72 = __ldaxr(v71);
        while (__stlxr(v72 - 1, v71));
        if (!v72)
        {
          ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
          std::__shared_weak_count::__release_weak(v70);
        }
      }

      unint64_t v73 = v188;
      if (v188)
      {
        uint64_t v74 = (unint64_t *)&v188->__shared_owners_;
        do
          unint64_t v75 = __ldaxr(v74);
        while (__stlxr(v75 - 1, v74));
        if (!v75)
        {
          ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
          std::__shared_weak_count::__release_weak(v73);
        }
      }

      unint64_t *v126 = v125;
      v126[1] = (unint64_t)v46;
      if ((v125 & 0x8000000000000000LL) != 0 && (_DWORD)v125) {
        v126[2] = 0LL;
      }
      else {
        v126[2] = v127;
      }
    }

    else
    {
      uint64_t v76 = v150;
      uint64_t v140 = v150;
      if (v150)
      {
        unint64_t v77 = (unint64_t *)&v150->__shared_owners_;
        do
          unint64_t v78 = __ldxr(v77);
        while (__stxr(v78 + 1, v77));
      }

      *(_OWORD *)uint64_t v141 = v151[0];
      *(_OWORD *)&v141[9] = *(_OWORD *)((char *)v151 + 9);
      uint64_t v79 = v152;
      uint64_t v80 = v153;
      uint64_t v81 = v154;
      __int128 v142 = v155;
      __int128 v143 = v156;
      char v144 = v157;
      uint64_t v82 = v158;
      unint64_t v83 = v159;
      char v145 = v159;
      if (v159)
      {
        unint64_t v84 = (unint64_t *)&v159->__shared_owners_;
        do
          unint64_t v85 = __ldxr(v84);
        while (__stxr(v85 + 1, v84));
      }

      __int128 v146 = v160;
      unint64_t v147 = v161;
      char v148 = v162;
      *(void *)&__int128 v229 = v12;
      *((void *)&v229 + 1) = v76;
      if (v76)
      {
        unint64_t v86 = (unint64_t *)&v76->__shared_owners_;
        do
          unint64_t v87 = __ldxr(v86);
        while (__stxr(v87 + 1, v86));
      }

      v230[0] = *(_OWORD *)v141;
      *(_OWORD *)((char *)v230 + 9) = *(_OWORD *)&v141[9];
      __int128 v234 = v142;
      uint64_t v231 = v79;
      uint64_t v232 = v80;
      uint64_t v233 = v81;
      __int128 v235 = v143;
      char v236 = v144;
      uint64_t v237 = v82;
      v238 = v83;
      if (v83)
      {
        uint64_t v88 = (unint64_t *)&v83->__shared_owners_;
        do
          unint64_t v89 = __ldxr(v88);
        while (__stxr(v89 + 1, v88));
      }

      __int128 v239 = v146;
      unint64_t v240 = v147;
      char v241 = v148;
      __int128 v211 = v163;
      if (*((void *)&v163 + 1))
      {
        uint64_t v90 = (unint64_t *)(*((void *)&v163 + 1) + 8LL);
        do
          unint64_t v91 = __ldxr(v90);
        while (__stxr(v91 + 1, v90));
      }

      *(_OWORD *)__int128 v212 = v164[0];
      *(_OWORD *)&v212[9] = *(_OWORD *)((char *)v164 + 9);
      uint64_t v213 = v165;
      __int128 v214 = v166;
      __int128 v215 = v167;
      __int128 v216 = v168;
      char v217 = v169;
      uint64_t v218 = v170;
      uint64_t v219 = v171;
      if (v171)
      {
        char v92 = (unint64_t *)&v171->__shared_owners_;
        do
          unint64_t v93 = __ldxr(v92);
        while (__stxr(v93 + 1, v92));
      }

      __int128 v220 = v172;
      unint64_t v221 = v173;
      char v222 = v174;
      unint64_t v94 = for_each_sg_in_vec<io_result_t (&)(sg_entry const&)>( (uint64_t (*)(__int128 *))zero_sg_entry,  &v229,  &v211,  0xFFFFFFFFFFFFFFFFLL);
      unint64_t v96 = v95;
      uint64_t v97 = v219;
      if (v219)
      {
        unint64_t v98 = (unint64_t *)&v219->__shared_owners_;
        do
          unint64_t v99 = __ldaxr(v98);
        while (__stlxr(v99 - 1, v98));
        if (!v99)
        {
          ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
          std::__shared_weak_count::__release_weak(v97);
        }
      }

      unint64_t v100 = (std::__shared_weak_count *)*((void *)&v211 + 1);
      if (*((void *)&v211 + 1))
      {
        unint64_t v101 = (unint64_t *)(*((void *)&v211 + 1) + 8LL);
        do
          unint64_t v102 = __ldaxr(v101);
        while (__stlxr(v102 - 1, v101));
        if (!v102)
        {
          ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
          std::__shared_weak_count::__release_weak(v100);
        }
      }

      __n128 v103 = v238;
      if (v238)
      {
        unint64_t v104 = (unint64_t *)&v238->__shared_owners_;
        do
          unint64_t v105 = __ldaxr(v104);
        while (__stlxr(v105 - 1, v104));
        if (!v105)
        {
          ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
          std::__shared_weak_count::__release_weak(v103);
        }
      }

      unint64_t v106 = (std::__shared_weak_count *)*((void *)&v229 + 1);
      if (*((void *)&v229 + 1))
      {
        unint64_t v107 = (unint64_t *)(*((void *)&v229 + 1) + 8LL);
        do
          unint64_t v108 = __ldaxr(v107);
        while (__stlxr(v108 - 1, v107));
        if (!v108)
        {
          ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
          std::__shared_weak_count::__release_weak(v106);
        }
      }

      *a6 = v94;
      a6[1] = v96;
      a6[2] = 0LL;
      if (v145)
      {
        unint64_t v109 = (unint64_t *)&v145->__shared_owners_;
        do
          unint64_t v110 = __ldaxr(v109);
        while (__stlxr(v110 - 1, v109));
        if (!v110)
        {
          ((void (*)(std::__shared_weak_count *))v145->__on_zero_shared)(v145);
          std::__shared_weak_count::__release_weak(v145);
        }
      }

      if (v140)
      {
        uint64_t v111 = (unint64_t *)&v140->__shared_owners_;
        do
          unint64_t v112 = __ldaxr(v111);
        while (__stlxr(v112 - 1, v111));
        if (!v112)
        {
          ((void (*)(std::__shared_weak_count *))v140->__on_zero_shared)(v140);
          std::__shared_weak_count::__release_weak(v140);
        }
      }
    }
  }

  char v113 = v171;
  if (v171)
  {
    __int128 v114 = (unint64_t *)&v171->__shared_owners_;
    do
      unint64_t v115 = __ldaxr(v114);
    while (__stlxr(v115 - 1, v114));
    if (!v115)
    {
      ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
      std::__shared_weak_count::__release_weak(v113);
    }
  }

  uint64_t v116 = (std::__shared_weak_count *)*((void *)&v163 + 1);
  if (*((void *)&v163 + 1))
  {
    uint64_t v117 = (unint64_t *)(*((void *)&v163 + 1) + 8LL);
    do
      unint64_t v118 = __ldaxr(v117);
    while (__stlxr(v118 - 1, v117));
    if (!v118)
    {
      ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
      std::__shared_weak_count::__release_weak(v116);
    }
  }

  unint64_t v119 = v159;
  if (v159)
  {
    char v120 = (unint64_t *)&v159->__shared_owners_;
    do
      unint64_t v121 = __ldaxr(v120);
    while (__stlxr(v121 - 1, v120));
    if (!v121)
    {
      ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
      std::__shared_weak_count::__release_weak(v119);
    }
  }

  unint64_t v122 = v150;
  if (v150)
  {
    char v123 = (unint64_t *)&v150->__shared_owners_;
    do
      unint64_t v124 = __ldaxr(v123);
    while (__stlxr(v124 - 1, v123));
    if (!v124)
    {
      ((void (*)(std::__shared_weak_count *))v122->__on_zero_shared)(v122);
      std::__shared_weak_count::__release_weak(v122);
    }
  }

void sub_1880EFC10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
}

uint64_t di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::data_entries_vectorizer_t::io_result_inserter_t::~io_result_inserter_t( uint64_t a1)
{
  if (*(_BYTE *)(a1 + 56))
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (*(_BYTE *)(v2 + 6184) && (*(_DWORD *)(a1 + 24) | 2) != 2)
    {
      uint64_t v3 = *(void *)(v2 + 6200);
      if (v3 == *(void *)(v2 + 6208))
      {
        boost::container::vector<ref::details::ref_cnt_handle,boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,ref::details::ref_cnt_handle*,ref::details::ref_cnt_handle>>( (uint64_t *)(v2 + 6192),  *(void *)(v2 + 6192) + 24 * v3,  (const char *)1,  a1 + 32,  &v5);
      }

      else
      {
        ref::details::ref_cnt_handle::ref_cnt_handle(*(void *)(v2 + 6192) + 24 * v3, a1 + 32);
        ++*(void *)(v2 + 6200);
      }
    }

    if (*(_BYTE *)(a1 + 56)) {
      ref::details::ref_cnt_handle::~ref_cnt_handle((ref::details::ref_cnt_handle *)(a1 + 32));
    }
  }

  return a1;
}

uint64_t *finally<di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::$_0>::~finally( uint64_t *a1)
{
  uint64_t v2 = di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::data_entries_vectorizer_t::finalize(*a1);
  if (v2 < 0)
  {
    if ((_DWORD)v2)
    {
      uint64_t v4 = (uint64_t *)a1[1];
      if ((*v4 & 0x8000000000000000LL) == 0 || !*v4)
      {
        *uint64_t v4 = v2;
        v4[1] = v3;
      }
    }
  }

  return a1;
}

uint64_t di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::data_entries_vectorizer_t::~data_entries_vectorizer_t( uint64_t a1)
{
  if (*(void *)(a1 + 5520))
  {
    uint64_t v2 = *(void **)(a1 + 5504);
  }

  std::shared_ptr<char>::~shared_ptr[abi:ne180100](a1 + 5440);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](a1 + 5328);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](a1 + 5280);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](a1 + 5168);
  if (*(_BYTE *)(a1 + 5160)) {
    di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::bitmap_handle_t::~bitmap_handle_t(a1);
  }
  return a1;
}

uint64_t di_asif::details::table::close(di_asif::details::table *this)
{
  uint64_t v3 = *(void *)(*((void *)this + 1) + 24LL);
  unint64_t v14 = off_18A1D9CC8;
  uint64_t v15 = v3;
  uint64_t v4 = (uint64_t)&v16;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v3 + 16) + 72LL))(&v16);
  if ((*(_BYTE *)(v15 + 8) & 1) != 0)
  {
    char v6 = 0;
    uint64_t v4 = 4294967290LL;
  }

  else
  {
    LODWORD(v5) = (*(uint64_t (**)(uint64_t, void))(*(void *)v16 + 16LL))(v16, 0LL);
    if ((_DWORD)v5)
    {
      DiskImage::Context::terminate_di((DiskImage::Context *)&v14);
      exception = __cxa_allocate_exception(0x40uLL);
      uint64_t v12 = exception;
      else {
        uint64_t v5 = -(int)v5;
      }
      void *exception = off_18A1E43B0;
      unint64_t v13 = std::generic_category();
      v12[1] = v5;
      v12[2] = v13;
      *((_BYTE *)v12 + 24) = 0;
      *((_BYTE *)v12 + 48) = 0;
      v12[7] = "Can't flush asif on bitmap close, backend flush failed";
    }

    di_asif::details::table::flush(this, (di_asif::details::ContextASIF *)&v14);
    char v6 = 1;
  }

  unint64_t v14 = off_18A1D9CC8;
  uint64_t v7 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
      if ((v6 & 1) == 0) {
        return v4;
      }
      return 0LL;
    }
  }

  if ((v6 & 1) != 0) {
    return 0LL;
  }
  return v4;
}

void *di_log::logger<di_log::log_printer<1513ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<1513ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E15B0;
  a1[45] = &unk_18A1E16B0;
  a1[46] = &unk_18A1E16D8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E15B0;
  a1[45] = &unk_18A1E1638;
  a1[46] = &unk_18A1E1660;
  return a1;
}

void sub_1880F0158(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<1513ul>>::~logger(uint64_t a1)
{
  return a1;
}

unint64_t di_asif::details::map_element::search_for_pattern( void *a1, di_asif::details::table *this, char a3, unint64_t a4, uint64_t a5, int a6)
{
  if (a5 != a4)
  {
    unint64_t range_bits = di_asif::details::table::make_range_bits(this, a4, a5 - a4);
    unsigned int v11 = range_bits;
    unint64_t v12 = HIDWORD(range_bits);
    uint64_t v13 = (uint64_t)(a1 + 4);
    if (a6)
    {
      __int16 v17 = a3 & 1 | (((a3 & 2) != 0) << 8);
      unint64_t mismatch_bits = lock_free::bitmap_t::find_mismatch_bits(v13, v11, v12, (unsigned __int8 *)&v17);
    }

    else
    {
      __int16 v16 = a3 & 1 | (((a3 & 2) != 0) << 8);
      unint64_t mismatch_bits = lock_free::bitmap_t::find_match_bits(v13, v11, v12, (unsigned __int8 *)&v16);
    }

    return *((void *)this + 44)
         + *a1
         / (unint64_t)(*(void *)(*((void *)this + 1) + 48LL) + 1LL)
         * *(void *)(*((void *)this + 1) + 48LL)
  }

  return a4;
}

unint64_t di_asif::details::table::make_range_bits( di_asif::details::table *this, unint64_t a2, unint64_t a3)
{
  uint64_t v3 = *((void *)this + 1);
  unint64_t v4 = *(unsigned __int16 *)(v3 + 18);
  if (v4 <= a3) {
    unint64_t v5 = a3;
  }
  else {
    unint64_t v5 = *(unsigned __int16 *)(v3 + 18);
  }
  if (!a3) {
    unint64_t v5 = 0LL;
  }
  uint64_t v6 = *(unsigned int *)(v3 + 20);
  uint64_t v7 = *(void *)(v3 + 48);
  return ((2
         * ((a2
                         - (*((void *)this + 44)
                          + v7
                          * v6
                          * ((a2 / v4 - *((void *)this + 44) / v4)
                           / (v7
                            * (unint64_t)(v6 / v4)))))
                        / v4)) | (((v5
                                  + a2
                                  - v4
                                  - (*((void *)this + 44)
                                   + ((v5 + a2 - v4) / v4 - *((void *)this + 44) / v4)
                                   / (v7
                                    * (unint64_t)(v6 / v4))
                                   * v7
                                   * v6))
                                 / v4) << 33))
       + 0x200000000LL;
}

uint64_t ref::ref_cnt::take_exclusive@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = (ref::ref_cnt *)this;
  while (*(void *)v4)
  {
LABEL_9:
    this = ref::ref_cnt::wait_fn(v4, (const void *)1);
    if ((this & 1) == 0)
    {
      char v7 = 0;
      goto LABEL_11;
    }
  }

  while (1)
  {
    unint64_t v6 = __ldaxr((unint64_t *)v4);
    if (!v6) {
      break;
    }
    __clrex();
LABEL_8:
    if (v6) {
      goto LABEL_9;
    }
  }

  char v7 = 1;
LABEL_11:
  *(_BYTE *)(a3 + 16) = v7;
  *(void *)a3 = off_18A1E3FE0;
  *(void *)(a3 + 8) = v4;
  *(void *)(a3 + 24) = a2;
  return this;
}

BOOL di_asif::details::table_entry_obj::is_physically_contiguous( di_asif::details::table_entry_obj *this, const di_asif::details::table_entry_obj *a2)
{
  uint64_t v2 = *(unsigned int *)(*(void *)(*(void *)this + 8LL) + 20LL);
  uint64_t v3 = (*(void *)(*(void *)(*(void *)this + 56LL) + 16LL * *((void *)this + 1) + 8) & 0x7FFFFFFFFFFFFFLL) * v2;
  uint64_t v4 = (*(void *)(*(void *)(*(void *)a2 + 56LL) + 16LL * *((void *)a2 + 1) + 8) & 0x7FFFFFFFFFFFFFLL)
     * *(unsigned int *)(*(void *)(*(void *)a2 + 8LL) + 20LL);
  if (v3) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  return v5 || v3 == v4 + v2;
}

uint64_t Backend::get_returned_io_size(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    return 0LL;
  }
  LODWORD(ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::allocate(void)::{lambda(locks::Std)#1}::operator()<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *>( (uint64_t *)va, v2) = 0;
  uint64_t v3 = *(unsigned int **)a1;
  uint64_t v4 = 40 * v1;
  while (1)
  {
    uint64_t v5 = lw_future<int>::get(v3);
    if ((v5 & 0x80000000) != 0) {
      break;
    }
    uint64_t v2 = (v5 + v2);
    v3 += 10;
    v4 -= 40LL;
    if (!v4) {
      return v2;
    }
  }

  return v5;
}

size_t di_asif::details::table_entry_data::get_zeros(void *a1, void *a2)
{
  uint64_t v2 = *(void *)(*a1 + 8LL);
  uint64_t v3 = *(void *)(v2 + 48);
  uint64_t v4 = *(unsigned int *)(v2 + 20);
  v10[0] = *(void *)(*a1 + 352LL) + (v3 + v3 * a1[1]) / (unint64_t)(v3 + 1) * v4;
  v10[1] = v10[0] + v4;
  char v11 = 2;
  trim_sg_to_interval(a2, (uint64_t)v10, (uint64_t)&v12);
  if (v14)
  {
    bzero(v12, v14);
    size_t v5 = v14;
  }

  else
  {
    size_t v5 = -34LL;
  }

  unint64_t v6 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return v5;
}

uint64_t di_asif::details::map_element::flush_locked( di_asif::details::map_element *this, di_asif::details::ContextASIF *a2, di_asif::details::table *a3, uint64_t a4)
{
  if (!*((_BYTE *)this + 113)) {
    goto LABEL_23;
  }
  *((_BYTE *)this + 113) = 0;
  uint64_t v6 = *((void *)this + 2);
  if (!v6) {
    goto LABEL_23;
  }
  uint64_t v9 = *((void *)this + 5);
  uint64_t v10 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    uint64_t v22 = v9;
    __int128 v23 = v10;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    uint64_t v24 = a4;
    uint64_t v25 = v6;
    uint64_t v26 = a4;
    char v27 = 1;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  else
  {
    uint64_t v22 = v9;
    __int128 v23 = 0LL;
    uint64_t v24 = a4;
    uint64_t v25 = v6;
    uint64_t v26 = a4;
    char v27 = 1;
  }

  int v15 = (*(uint64_t (**)(void, uint64_t *))(**((void **)a2 + 2) + 80LL))(*((void *)a2 + 2), &v22);
  uint64_t v16 = v24;
  if (v24 != v15)
  {
    *((_BYTE *)this + 113) = 1;
    DiskImage::Context::terminate_di(a2);
    if (v15 < 0) {
      a4 = v15;
    }
    else {
      a4 = -v15;
    }
  }

  __int16 v17 = v23;
  if (v23)
  {
    uint64_t v18 = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if (v16 == v15)
  {
LABEL_23:
    a4 = 0LL;
    if (a3)
    {
      if (*((_BYTE *)this + 112))
      {
        *((_BYTE *)this + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 112) = 0;
        di_asif::details::table::update_map_entry(a3, *(void *)this, *((void *)this + 2));
        a4 = 0LL;
        if (!*((void *)this + 2))
        {
          uint64_t v20 = *((void *)this + 3);
          if (v20) {
            di_asif::details::table::return_chunk(a3, v20);
          }
          return 0LL;
        }
      }
    }
  }

  return a4;
}

void sub_1880F06E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unint64_t di_asif::details::map_element::zero_range_in_sg( unint64_t result, di_asif::details::table *this, char **a3)
{
  unint64_t v3 = *(unsigned __int16 *)(*((void *)this + 1) + 18LL);
  uint64_t v4 = a3[3];
  unint64_t v5 = (unint64_t)v4 / v3 * v3;
  unint64_t v6 = (unint64_t)&v4[(void)a3[2]];
  unint64_t v7 = (v3 + v6 - 1) / v3 * v3;
  if (v5 < v7)
  {
    uint64_t v9 = (void *)result;
    unint64_t v10 = (unint64_t)v4 % v3;
    char v11 = *a3;
    do
    {
      unint64_t v12 = di_asif::details::map_element::search_for_pattern(v9, this, 1, v5, v7, 1);
      unint64_t v13 = v12;
      if (v6 >= v12) {
        unint64_t v14 = v12;
      }
      else {
        unint64_t v14 = v6;
      }
      unint64_t v15 = v5 + v10;
      if (v14 >= v5 + v10)
      {
        else {
          size_t v16 = (size_t)&(*a3)[a3[2] - v11];
        }
        bzero(v11, v16);
      }

      __n128 result = di_asif::details::map_element::search_for_pattern(v9, this, 1, v13, v7, 0);
      unint64_t v5 = result;
      if (result < v14 + v10)
      {
        unint64_t v17 = 0LL;
      }

      else
      {
        unint64_t v10 = 0LL;
        unint64_t v17 = result - v15;
      }

      v11 += v17;
    }

    while (result < v6);
  }

  return result;
}

void di_asif::details::map_element::load( di_asif::details::map_element *this, di_asif::details::ContextASIF *a2, const di_asif::details::table *a3)
{
  uint64_t v6 = *((void *)this + 5);
  uint64_t v7 = *(unsigned int *)(*((void *)a3 + 1) + 20LL);
  uint64_t v8 = *((void *)this + 2);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  uint64_t v21 = v6;
  uint64_t v22 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  uint64_t v23 = v7;
  uint64_t v24 = v8;
  uint64_t v25 = v7;
  char v26 = 0;
  int v12 = (*(uint64_t (**)(void, uint64_t *))(**((void **)a2 + 2) + 88LL))(*((void *)a2 + 2), &v21);
  if (v23 != v12)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v18 = exception;
    if (v12 < 0) {
      uint64_t v19 = v12;
    }
    else {
      uint64_t v19 = -v12;
    }
    void *exception = off_18A1E43B0;
    uint64_t v20 = std::generic_category();
    v18[1] = v19;
    void v18[2] = v20;
    *((_BYTE *)v18 + 24) = 0;
    *((_BYTE *)v18 + 48) = 0;
    v18[7] = "Can't load bitmap from backend";
  }

  if (*(void *)(*((void *)a3 + 1) + 48LL)
     * (*(_DWORD *)(*((void *)a3 + 1) + 20LL)
      / *(unsigned __int16 *)(*((void *)a3 + 1) + 18LL)))
  {
    unint64_t v13 = 0LL;
    do
    {
      di_asif::details::map_element::get_block_bits(this, v13);
      v13 += 2LL;
    }

    while (*(void *)(*((void *)a3 + 1) + 48LL)
  }

  unint64_t v14 = v22;
  if (v22)
  {
    unint64_t v15 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

void sub_1880F0994( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

di_asif::details::map_element *di_asif::details::map_element::map_element( di_asif::details::map_element *this, di_asif::details::ContextASIF *a2, di_asif::details::table *a3, unint64_t a4, uint64_t a5, char a6)
{
  *(void *)this = a4;
  uint64_t v9 = *((void *)a3 + 1);
  uint64_t v10 = *(void *)(v9 + 48);
  uint64_t v11 = *(unsigned int *)(v9 + 20);
  *((void *)this + 1) = *((void *)a3 + 44) + a4 / (v10 + 1) * v10 * v11;
  *((void *)this + 2) = a5;
  *((void *)this + 3) = 0LL;
  char v12 = a6 ^ 1;
  lock_free::bitmap_dynamically_allocated_t::bitmap_dynamically_allocated_t( (void *)this + 4,  2 * v10 * (v11 / *(unsigned __int16 *)(v9 + 18)),  a6 ^ 1);
  *((void *)this + 15) = 850045863LL;
  *((_WORD *)this + 56) = 0;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = 0LL;
  if ((v12 & 1) != 0)
  {
    di_asif::details::map_element::load(this, a2, a3);
  }

  else
  {
    *((_WORD *)this + 56) = 257;
    di_asif::details::table_entry_map::table_entry_map(v16, a3, *(void *)this);
    unint64_t v13 = (unint64_t *)(*(void *)(v16[0] + 56LL) + 16LL * v16[1] + 8);
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 | 0x8000000000000000LL, v13));
  }

  return this;
}

void sub_1880F0AB0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 32) = off_18A1D9F40;
  std::unique_ptr<unsigned long long,std::function<void ()(unsigned long long *)>>::~unique_ptr[abi:ne180100]((uint64_t *)(v1 + 56));
  _Unwind_Resume(a1);
}

uint64_t di_asif::details::map_element::close( di_asif::details::map_element *this, di_asif::details::ContextASIF *a2, di_asif::details::table *a3, uint64_t a4)
{
  if ((*(_BYTE *)(*((void *)a2 + 1) + 8LL) & 1) == 0)
  {
    uint64_t v8 = (std::mutex *)((char *)this + 120);
    std::mutex::lock((std::mutex *)((char *)this + 120));
    int v9 = (*(uint64_t (**)(void, void))(**((void **)a2 + 2) + 16LL))(*((void *)a2 + 2), 0LL);
    if (v9)
    {
      DiskImage::Context::terminate_di(a2);
      exception = __cxa_allocate_exception(0x40uLL);
      uint64_t v19 = exception;
      if (v9 < 0) {
        uint64_t v20 = v9;
      }
      else {
        uint64_t v20 = -v9;
      }
      void *exception = off_18A1E43B0;
      uint64_t v21 = std::generic_category();
      v19[1] = v20;
      v19[2] = v21;
      *((_BYTE *)v19 + 24) = 0;
      *((_BYTE *)v19 + 48) = 0;
      v19[7] = "Can't flush asif on bitmap close, backend flush failed";
    }

    if (!a3) {
      goto LABEL_28;
    }
    di_asif::details::table_entry_map::table_entry_map(&v22, a3, *(void *)this);
    uint64_t v10 = (unint64_t *)(*(void *)(v22 + 56) + 16 * v23 + 8);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 & 0x7FFFFFFFFFFFFFFFLL, v10));
    if ((v11 & 0x8000000000000000LL) != 0)
    {
      int v12 = 1;
    }

    else
    {
LABEL_28:
      if (*((_BYTE *)this + 113))
      {
        int v12 = 0;
      }

      else
      {
        int v12 = 0;
        if (!*((_BYTE *)this + 112))
        {
          uint64_t v13 = 0LL;
LABEL_20:
          std::mutex::unlock(v8);
          return v13;
        }
      }
    }

    uint64_t v13 = di_asif::details::map_element::flush_locked(this, a2, a3, a4);
    if ((_DWORD)v13) {
      int v14 = v12;
    }
    else {
      int v14 = 0;
    }
    if (a3 && v14)
    {
      di_asif::details::table_entry_map::table_entry_map(&v22, a3, *(void *)this);
      unint64_t v15 = (unint64_t *)(*(void *)(v22 + 56) + 16 * v23 + 8);
      do
        unint64_t v16 = __ldaxr(v15);
      while (__stlxr(v16 | 0x8000000000000000LL, v15));
    }

    goto LABEL_20;
  }

  return 4294967290LL;
}

void sub_1880F0C7C(_Unwind_Exception *a1)
{
}

uint64_t di_asif::details::dir::load_create_table@<X0>( uint64_t this@<X0>, di_asif::details::ContextASIF *a2@<X1>, ref::details **a3@<X2>, unint64_t a4@<X3>, int a5@<W4>, char a6@<W5>, unint64_t *a7@<X8>)
{
  uint64_t v10 = this;
  unint64_t v19 = a4;
  *a7 = 0LL;
  if (a4 || a5)
  {
    ref::Allocator<di_asif::details::table,unsigned long long>::allocate(this + 280, a3, a6, &v18);
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::operator=(a7, &v18);
    this = (uint64_t)ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(&v18);
    unint64_t v12 = *a7;
    if (*a7) {
      LOBYTE(v12) = *(_BYTE *)(v12 + 520) == 0;
    }
    if ((v12 & 1) != 0 || (a6 & 1) != 0)
    {
      if (!*a7 || (unsigned int v13 = atomic_load((unsigned int *)(*a7 + 24)), v13 != 2))
      {
        if (!*a7 || !*(_BYTE *)(*a7 + 520))
        {
          if (v19 | (*(void *)(*(void *)(v10 + 152) + 8LL * (void)a3) * *(unsigned int *)(v10 + 20)))
          {
            if (v19) {
              unint64_t v14 = v19;
            }
            else {
              unint64_t v14 = *(void *)(*(void *)(v10 + 152) + 8LL * (void)a3) * *(unsigned int *)(v10 + 20);
            }
            unint64_t v18 = *(void *)(v10 + 80) * (void)a3;
            unint64_t v19 = v14;
            return ref::tagged_ptr<di_asif::details::table,unsigned long long>::make_value<di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long>( (uint64_t *)a7,  v10,  (void *)a2 + 2,  &v19,  (uint64_t *)&v18);
          }

          else
          {
            uint64_t space = di_asif::details::dir_base::allocate_space((di_asif::details::dir_base *)v10, a2, 1);
            uint64_t v17 = *(void *)(v10 + 80) * (void)a3;
            unint64_t v18 = space;
            unsigned __int8 v16 = 1;
            this = ref::tagged_ptr<di_asif::details::table,unsigned long long>::make_value<di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long,BOOL>( (uint64_t *)a7,  v10,  (void *)a2 + 2,  &v18,  &v17,  &v16);
            *(void *)(*(void *)(v10 + 152) + 8LL * (void)a3) = v18 / *(unsigned int *)(v10 + 20);
          }
        }
      }
    }
  }

  return this;
}

void sub_1880F0DFC(_Unwind_Exception *a1)
{
}

unint64_t *ref::Allocator<di_asif::details::table,unsigned long long>::allocate@<X0>( uint64_t a1@<X0>, ref::details **a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  unsigned __int8 v16 = 0LL;
  uint64_t v17 = a2;
  ref::Allocator<di_asif::details::table,unsigned long long>::add_tag(a1, a2, a3, &v14);
  if (v14 && !*(_BYTE *)(v14 + 520) || v14 && *(_BYTE *)(v14 + 520))
  {
    *a4 = 0LL;
    do
      unint64_t v7 = __ldaxr(&v14);
    while (__stlxr(0LL, &v14));
LABEL_21:
    atomic_store(v7, a4);
    return ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(&v14);
  }

  if (*(_BYTE *)(a1 + 912) && v15 != (void *)(a1 + 936))
  {
    do
    {
      ref::Allocator<di_asif::details::table,unsigned long long>::allocate_from_empty_pool(a1, (uint64_t)a2, &v12);
      unsigned __int8 v16 = v12;
      ref::tagged_ptr<di_asif::details::table,unsigned long long>::operator=(&v14, &v13);
      ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(&v13);
      if (v14)
      {
        if (!*(_BYTE *)(v14 + 520)) {
          break;
        }
      }

      min = (unint64_t *)ref::Allocator<di_asif::details::table,unsigned long long>::extract_min((void *)a1);
      if (min)
      {
        unsigned __int8 v16 = min;
        ref::Allocator<di_asif::details::table,unsigned long long>::insert_elem( a1,  min,  (uint64_t)a2,  (unint64_t *)&v12);
        ref::tagged_ptr<di_asif::details::table,unsigned long long>::operator=(&v14, (unint64_t *)&v12);
        ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v12);
        break;
      }
    }

    while (*(_BYTE *)(a1 + 912));
    std::mutex::lock((std::mutex *)(a1 + 952));
    int v9 = std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *&>( (uint64_t **)(a1 + 928),  v15,  (unint64_t *)&v17,  (uint64_t *)&v17,  (uint64_t *)&v16);
    if (!v10) {
      v9[5] = (uint64_t)v16;
    }
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 1016));
    std::mutex::unlock((std::mutex *)(a1 + 952));
    ref::Allocator<di_asif::details::table,unsigned long long>::run_failed_dtors_list(a1, 0, 0LL, 0);
    *a4 = 0LL;
    do
      unint64_t v7 = __ldaxr(&v14);
    while (__stlxr(0LL, &v14));
    goto LABEL_21;
  }

  *a4 = 0LL;
  return ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(&v14);
}

void sub_1880F0FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

unint64_t *ref::tagged_ptr<di_asif::details::table,unsigned long long>::operator=( unint64_t *a1, unint64_t *a2)
{
  if (a2 != a1)
  {
    do
      unint64_t v3 = __ldaxr(a2);
    while (__stlxr(0LL, a2));
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(a1);
    atomic_store(v3, a1);
  }

  return a1;
}

uint64_t ref::tagged_ptr<di_asif::details::table,unsigned long long>::make_value<di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long,BOOL>( uint64_t *a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5, unsigned __int8 *a6)
{
  return ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::make_value<di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long,BOOL>( *a1,  a2,  a3,  a4,  a5,  a6);
}

void sub_1880F107C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*v10)
  {
    uint64_t v11 = *(void *)(*v10 + 464);
    if (v11)
    {
      a10 = *v10;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &a10, v10);
    }
  }

  __cxa_rethrow();
}

void sub_1880F10B0(_Unwind_Exception *a1)
{
}

uint64_t ref::tagged_ptr<di_asif::details::table,unsigned long long>::make_value<di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long>( uint64_t *a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5)
{
  return ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::make_value<di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long>( *a1,  a2,  a3,  a4,  a5);
}

void sub_1880F10F0( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*v10)
  {
    uint64_t v11 = *(void *)(*v10 + 464);
    if (v11)
    {
      a10 = *v10;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &a10, v10);
    }
  }

  __cxa_rethrow();
}

void sub_1880F1124(_Unwind_Exception *a1)
{
}

unint64_t *ref::tagged_weak_ptr<di_asif::details::table,unsigned long long>::lock_if_tag@<X0>( unint64_t *result@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v4 = atomic_load(result);
  if (v4 && *(void *)(v4 + 32) == a2)
  {
    uint64_t v6 = (unint64_t *)atomic_load(result);
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::tagged_ptr(&v9, v6, 1);
    if (v9 && !*(_BYTE *)(v9 + 520))
    {
      uint64_t v7 = *(void *)(v9 + 32);
      *a3 = 0LL;
      if (v7 == a2)
      {
        do
          unint64_t v8 = __ldaxr(&v9);
        while (__stlxr(0LL, &v9));
        atomic_store(v8, a3);
      }
    }

    else
    {
      *a3 = 0LL;
    }

    return ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(&v9);
  }

  else
  {
    *a3 = 0LL;
  }

  return result;
}

void *di_log::logger<di_log::log_printer<2061ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<2061ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E1860;
  a1[45] = &unk_18A1E1960;
  a1[46] = &unk_18A1E1988;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E1860;
  a1[45] = &unk_18A1E18E8;
  a1[46] = &unk_18A1E1910;
  return a1;
}

void sub_1880F125C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<2061ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<2071ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<2071ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E1A80;
  a1[45] = &unk_18A1E1B80;
  a1[46] = &unk_18A1E1BA8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E1A80;
  a1[45] = &unk_18A1E1B08;
  a1[46] = &unk_18A1E1B30;
  return a1;
}

void sub_1880F1344(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<2071ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_asif::details::dir::handle_all_failures( di_asif::details::dir *this, di_asif::details::ContextASIF *a2)
{
  int v4 = ref::Allocator<di_asif::details::map_element,unsigned long long>::run_failed_dtors_list( (uint64_t)this + 2080,  0,  0LL,  0);
  if (v4 == -1) {
    return 4294967282LL;
  }
  if (v4 == 1)
  {
    LODWORD(result) = (*(uint64_t (**)(void, void))(**((void **)a2 + 2) + 16LL))( *((void *)a2 + 2),  0LL);
    int v6 = result;
    uint64_t result = (int)result < 0 ? result : -(int)result;
    if (v6) {
      return result;
    }
  }

  int v7 = ref::Allocator<di_asif::details::table,unsigned long long>::run_failed_dtors_list((uint64_t)this + 280, 0, 0LL, 0);
  if (v7 == -1) {
    return 4294967282LL;
  }
  if (v7 != 1) {
    return 0LL;
  }
  LODWORD(result) = (*(uint64_t (**)(void, void))(**((void **)a2 + 2) + 16LL))(*((void *)a2 + 2), 0LL);
  int v8 = result;
  uint64_t result = (int)result < 0 ? result : -(int)result;
  if (!v8) {
    return 0LL;
  }
  return result;
}

uint64_t di_asif::details::dir::flush_dir( di_asif::details::dir *this, di_asif::details::ContextASIF *a2, uint64_t (***a3)())
{
  v54[4] = *MEMORY[0x1895F89C0];
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v44 = 0u;
  int v6 = (std::mutex *)((char *)this + 3792);
  std::mutex::lock((std::mutex *)((char *)this + 3792));
  __int128 v7 = *((_OWORD *)this + 234);
  *((_OWORD *)this + 234) = 0u;
  __int128 v8 = *((_OWORD *)this + 235);
  __int128 v44 = v7;
  __int128 v45 = v8;
  *((_OWORD *)this + 235) = 0u;
  __int128 v9 = v46;
  __int128 v46 = *((_OWORD *)this + 236);
  *((_OWORD *)this + 236) = v9;
  std::mutex::unlock(v6);
  size_t v10 = (*((void *)this + 20) - *((void *)this + 19) + (unint64_t)*((unsigned __int16 *)this + 9) + 7)
  uint64_t v11 = valloc(v10);
  if (!v11)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v43 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v43, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  uint64_t v47 = off_18A1DFDC8;
  unint64_t v50 = &v47;
  unint64_t v53 = v11;
  std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)v54, (uint64_t)&v47);
  unint64_t v12 = v50;
  if (v50 == &v47)
  {
    uint64_t v13 = 4LL;
    unint64_t v12 = &v47;
    goto LABEL_6;
  }

  if (v50)
  {
    uint64_t v13 = 5LL;
LABEL_6:
    ((void (*)(uint64_t (***)()))(*v12)[v13])(v12);
  }

  unint64_t v14 = v53;
  unint64_t v15 = *((void *)this + 451);
  *((void *)this + 451) = v15 + 1;
  void *v14 = bswap64(v15);
  unsigned __int8 v16 = v14 + 1;
  uint64_t v17 = (unint64_t *)*((void *)this + 19);
  unint64_t v18 = (unint64_t *)*((void *)this + 20);
  while (v17 != v18)
  {
    unint64_t v19 = *v17++;
    *v16++ = bswap64(v19);
  }

  bzero(v16, (size_t)v53 + v10 - (void)v16);
  ref::Allocator<di_asif::details::map_element,unsigned long long>::wait_for_idle((uint64_t)this + 2080);
  ref::Allocator<di_asif::details::table,unsigned long long>::wait_for_idle((uint64_t)this + 280);
  uint64_t v20 = di_asif::details::dir::handle_all_failures(this, a2);
  if (!(_DWORD)v20)
  {
    uint64_t v22 = (uint64_t)v53;
    uint64_t v23 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
    uint64_t v47 = (uint64_t (**)())v22;
    uint64_t v48 = v23;
    if (v23)
    {
      p_shared_owners = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v25 = __ldxr(p_shared_owners);
      while (__stxr(v25 + 1, p_shared_owners));
    }

    size_t v49 = v10;
    unint64_t v50 = a3;
    size_t v51 = v10;
    char v52 = 0;
    int v26 = (*(uint64_t (**)(void, uint64_t (***)()))(**((void **)a2 + 2) + 80LL))( *((void *)a2 + 2),  &v47);
    if (v10 == v26)
    {
      char v27 = (unint64_t **)(*((void *)&v44 + 1) + 8 * ((unint64_t)v46 >> 9));
      if ((void)v45 == *((void *)&v44 + 1))
      {
        uint64_t v28 = 0LL;
        uint64_t v30 = 0LL;
        uint64_t v29 = (char *)(*((void *)&v44 + 1) + 8LL * ((*((void *)&v46 + 1) + (void)v46) >> 9));
      }

      else
      {
        uint64_t v28 = &(*v27)[v46 & 0x1FF];
        uint64_t v29 = (char *)(*((void *)&v44 + 1) + 8LL * ((*((void *)&v46 + 1) + (void)v46) >> 9));
        uint64_t v30 = (unint64_t *)(*(void *)v29 + 8 * ((*((void *)&v46 + 1) + v46) & 0x1FF));
      }

      di_asif::details::dir_base::insert_space<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>( (unint64_t *)this,  v27,  v28,  v29,  v30,  (uint64_t)a2);
      uint64_t v20 = 1LL;
    }

    else
    {
      *((void *)this + 451) = v15;
      std::mutex::lock(v6);
      unint64_t v31 = *((void *)this + 472) + *((void *)this + 473);
      uint64_t v32 = *((void *)this + 469);
      int v33 = (char *)(v32 + 8 * (v31 >> 9));
      if (*((void *)this + 470) == v32) {
        uint64_t v34 = 0LL;
      }
      else {
        uint64_t v34 = *(void *)v33 + 8 * (v31 & 0x1FF);
      }
      unint64_t v35 = (char *)(*((void *)&v44 + 1) + 8 * ((unint64_t)v46 >> 9));
      if ((void)v45 == *((void *)&v44 + 1))
      {
        __int128 v36 = 0LL;
        uint64_t v38 = 0LL;
        unint64_t v37 = (char *)(*((void *)&v44 + 1) + 8LL * ((*((void *)&v46 + 1) + (void)v46) >> 9));
      }

      else
      {
        __int128 v36 = (char *)(*(void *)v35 + 8 * (v46 & 0x1FF));
        unint64_t v37 = (char *)(*((void *)&v44 + 1) + 8LL * ((*((void *)&v46 + 1) + (void)v46) >> 9));
        uint64_t v38 = (char *)(*(void *)v37 + 8 * ((*((void *)&v46 + 1) + v46) & 0x1FF));
      }

      std::deque<unsigned long long>::insert<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>( (void **)this + 468,  v33,  v34,  v35,  v36,  v37,  v38);
      if (v26 >= 0) {
        uint64_t v20 = 4294967291LL;
      }
      else {
        uint64_t v20 = v26;
      }
      std::mutex::unlock(v6);
    }

    unint64_t v39 = v48;
    if (v48)
    {
      uint64_t v40 = (unint64_t *)&v48->__shared_owners_;
      do
        unint64_t v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
  }

  std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v53);
  std::deque<std::atomic<DiskImage::Context *>>::~deque[abi:ne180100](&v44);
  return v20;
}

void sub_1880F17F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
}

void ref::Allocator<di_asif::details::map_element,unsigned long long>::wait_for_idle(uint64_t a1)
{
  if (atomic_load((unint64_t *)(a1 + 608)))
  {
    unint64_t v3 = (unint64_t *)(a1 + 616);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(v4 + 1, v3));
    v8.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 624);
    v8.__owns_ = 1;
    std::mutex::lock((std::mutex *)(a1 + 624));
    do
      unint64_t v7 = __ldaxr(v3);
    while (__stlxr(v7 - 1, v3));
    if (v8.__owns_) {
      std::mutex::unlock(v8.__m_);
    }
  }

void ref::Allocator<di_asif::details::table,unsigned long long>::wait_for_idle(uint64_t a1)
{
  if (atomic_load((unint64_t *)(a1 + 784)))
  {
    unint64_t v3 = (unint64_t *)(a1 + 792);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(v4 + 1, v3));
    v8.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 800);
    v8.__owns_ = 1;
    std::mutex::lock((std::mutex *)(a1 + 800));
    do
      unint64_t v7 = __ldaxr(v3);
    while (__stlxr(v7 - 1, v3));
    if (v8.__owns_) {
      std::mutex::unlock(v8.__m_);
    }
  }

uint64_t di_asif::details::dir::do_io( di_asif::details::dir *this, di_asif::details::ContextASIF *a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4, int a5)
{
  uint64_t v8 = *((void *)a4 + 18) - *((void *)a3 + 18);
  unint64_t v9 = *((void *)a3 + 3);
  size_t v10 = (std::__shared_weak_count *)*((void *)a3 + 1);
  uint64_t v56 = *(void *)a3;
  int v57 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  v58[0] = *((_OWORD *)a3 + 1);
  uint64_t v13 = v8 & ~(v8 >> 63);
  *(_OWORD *)((char *)v58 + 9) = *(_OWORD *)((char *)a3 + 25);
  uint64_t v59 = *((void *)a3 + 6);
  __int128 v60 = *(_OWORD *)((char *)a3 + 56);
  __int128 v61 = *(_OWORD *)((char *)a3 + 72);
  __int128 v62 = *(_OWORD *)((char *)a3 + 88);
  char v63 = *((_BYTE *)a3 + 104);
  unint64_t v14 = (std::__shared_weak_count *)*((void *)a3 + 15);
  uint64_t v64 = *((void *)a3 + 14);
  char v65 = v14;
  if (v14)
  {
    unint64_t v15 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  uint64_t v17 = 0LL;
  __int128 v66 = *((_OWORD *)a3 + 8);
  uint64_t v67 = *((void *)a3 + 18);
  char v68 = *((_BYTE *)a3 + 152);
  int v18 = a5 ^ 1;
  while (1)
  {
    uint64_t v19 = v9 / *((void *)this + 10);
    di_asif::details::dir::get_table(this, a2, v19, v18, 1, (unint64_t *)&v55);
    if (v55 && v55[520])
    {
      if ((a5 & 1) == 0) {
        DiskImage::Context::terminate_di(a2);
      }
      int v20 = 1;
      uint64_t v5 = -5LL;
      goto LABEL_38;
    }

    sg_vec_ns::details::sg_vec_iterator::subvec( (sg_vec_ns::details::sg_vec_iterator *)&v56,  a4,  *((void *)this + 10) + *((void *)this + 10) * v19,  0LL,  (uint64_t)&v48);
    if (!v55 || v55[520])
    {
      unint64_t v21 = 0LL;
      do
      {
        size_t v22 = v50;
        bzero(v48, v50);
        sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v48, v22);
        v21 += v22;
      }

      while (!sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&v48, (uint64_t)&v52));
      goto LABEL_17;
    }

    if (a5)
    {
      if (v55[400]) {
        unint64_t v35 = (di_asif::details::table *)(v55 + 40);
      }
      else {
        unint64_t v35 = 0LL;
      }
      uint64_t v37 = di_asif::details::table::read( v35,  a2,  (const sg_vec_ns::details::sg_vec_iterator *)&v48,  (const sg_vec_ns::details::sg_vec_iterator *)&v52);
      uint64_t v5 = v37;
      if ((v37 & 0x8000000000000000LL) == 0 || !(_DWORD)v37) {
        goto LABEL_55;
      }
    }

    else
    {
      if (v55[400]) {
        __int128 v36 = (di_asif::details::table *)(v55 + 40);
      }
      else {
        __int128 v36 = 0LL;
      }
      unint64_t v38 = di_asif::details::table::write( v36,  a2,  (const sg_vec_ns::details::sg_vec_iterator *)&v48,  (const sg_vec_ns::details::sg_vec_iterator *)&v52);
      uint64_t v5 = v38;
      if ((v38 & 0x8000000000000000LL) == 0 || !(_DWORD)v38)
      {
LABEL_55:
        unint64_t v21 = v5;
LABEL_17:
        sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v56, v21);
        int v20 = 0;
        v9 += v21;
        v17 += v21;
        goto LABEL_18;
      }

      DiskImage::Context::terminate_di(a2);
    }

    int v20 = 1;
LABEL_18:
    uint64_t v23 = v54;
    if (v54)
    {
      uint64_t v24 = (unint64_t *)&v54->__shared_owners_;
      do
        unint64_t v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }

    int v26 = v53;
    if (v53)
    {
      char v27 = (unint64_t *)&v53->__shared_owners_;
      do
        unint64_t v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }

    uint64_t v29 = v51;
    if (v51)
    {
      uint64_t v30 = (unint64_t *)&v51->__shared_owners_;
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }

    uint64_t v32 = v49;
    if (v49)
    {
      int v33 = (unint64_t *)&v49->__shared_owners_;
      do
        unint64_t v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }

LABEL_38:
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v55);
    if (v20) {
      break;
    }
    if (v17 == v13) {
      goto LABEL_57;
    }
  }

  uint64_t v13 = v5;
LABEL_57:
  unint64_t v39 = v65;
  if (v65)
  {
    uint64_t v40 = (unint64_t *)&v65->__shared_owners_;
    do
      unint64_t v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }

  uint64_t v42 = v57;
  if (v57)
  {
    unint64_t v43 = (unint64_t *)&v57->__shared_owners_;
    do
      unint64_t v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }

  return v13;
}

  unint64_t v34 = v77;
  if (v77)
  {
    unint64_t v35 = (unint64_t *)&v77->__shared_owners_;
    do
      __int128 v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }

  uint64_t v37 = v76;
  if (v76)
  {
    unint64_t v38 = (unint64_t *)&v76->__shared_owners_;
    do
      unint64_t v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }

  uint64_t v40 = v75;
  if (v75)
  {
    unint64_t v41 = (unint64_t *)&v75->__shared_owners_;
    do
      uint64_t v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }

  unint64_t v43 = v74;
  if (v74)
  {
    unint64_t v44 = (unint64_t *)&v74->__shared_owners_;
    do
      __int128 v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }

  __int128 v46 = v73;
  if (v73)
  {
    uint64_t v47 = (unint64_t *)&v73->__shared_owners_;
    do
      uint64_t v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }

  size_t v49 = v72;
  if (v72)
  {
    size_t v50 = (unint64_t *)&v72->__shared_owners_;
    do
      size_t v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }

  if (v69 && &v70 != __p) {
    operator delete(__p);
  }
  boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)v66);
  return std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v78);
}

void sub_1880F1DA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

double di_asif::details::asif_extents_iterator_interface::make_val@<D0>( di_asif::details::asif_extents_iterator_interface *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (*((_BYTE *)this + 32) & 1) + *((void *)this + 3);
  v10[0] = *((void *)this + 5);
  v10[1] = v3;
  char v11 = 2;
  *(void *)&__int128 v8 = boost::icl::identity_element<unsigned long long>::value(void)::_value;
  *((void *)&v8 + 1) = boost::icl::identity_element<unsigned long long>::value(void)::_value;
  LOBYTE(v9) = 2;
  unsigned int next_extent = di_asif::details::dir::get_next_extent( *((di_asif::details::dir **)this + 8),  *((di_asif::details::ContextASIF **)this + 7),  v10,  (uint64_t)&v8);
  if (next_extent >= 3)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Can't convert ASIF flag.", 5u);
  }

  double result = *(double *)&v8;
  *(_OWORD *)a2 = v8;
  *(void *)(a2 + 16) = v9;
  *(_DWORD *)(a2 + 24) = next_extent;
  return result;
}

uint64_t di_asif::details::dir::get_next_extent( di_asif::details::dir *this, di_asif::details::ContextASIF *a2, void *a3, uint64_t a4)
{
  uint64_t v7 = 0LL;
  *(void *)&__int128 v32 = *a3;
  *((void *)&v32 + 1) = v32;
  uint64_t v29 = boost::icl::identity_element<unsigned long long>::value(void)::_value;
  uint64_t v30 = boost::icl::identity_element<unsigned long long>::value(void)::_value;
  unsigned __int8 v33 = 2;
  char v31 = 2;
  __int128 v27 = *(_OWORD *)a3;
  uint64_t v28 = a3[2];
  do
  {
    if ((_BYTE)v28)
    {
      if (v28 == 3)
      {
        unint64_t v9 = *((void *)&v27 + 1);
        uint64_t v8 = v27;
      }

      else
      {
        unint64_t v9 = *((void *)&v27 + 1);
        uint64_t v8 = v27;
      }
    }

    else
    {
      unint64_t v9 = *((void *)&v27 + 1);
      uint64_t v8 = v27;
      if ((unint64_t)v27 >= *((void *)&v27 + 1) || (unint64_t)(v27 + 1) >= *((void *)&v27 + 1))
      {
LABEL_5:
        goto LABEL_12;
      }
    }

void sub_1880F2168( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t di_asif::details::table::get_next_extent( di_asif::details::table *a1, di_asif::details::ContextASIF *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = *(void *)a3;
  unint64_t v6 = *(void *)(a3 + 8);
  unsigned int v7 = *(unsigned __int8 *)(a3 + 16);
  v62[0] = *(_DWORD *)(a3 + 17);
  *(_DWORD *)((char *)v62 + 3) = *(_DWORD *)(a3 + 20);
  if ((v7 & 2) != 0) {
    unint64_t v8 = v5;
  }
  else {
    unint64_t v8 = v5 + 1;
  }
  uint64_t data_entry_for_offset = (void *)di_asif::details::table::get_data_entry_for_offset( a1,  v8 * *(unsigned __int16 *)(*((void *)a1 + 1) + 18LL));
  unint64_t v11 = atomic_load((unint64_t *)(data_entry_for_offset[7] + 16 * v10 + 8));
  *(void *)uint64_t v48 = v11 >> 62;
  if (v11 >> 62 == 3)
  {
    uint64_t v12 = data_entry_for_offset[1];
    di_asif::details::table::get_bitmap( a1,  a2,  (data_entry_for_offset[44] + (*(void *)(v12 + 48) + *(void *)(v12 + 48) * v10)
     / (unint64_t)(*(void *)(v12 + 48) + 1LL)
     * *(unsigned int *)(v12 + 20))
    / *(unsigned __int16 *)(v12 + 18),
      0,
      1LL,
      v55);
    uint64_t v13 = *((void *)a1 + 1);
    if (v55[0])
    {
      if (*(_BYTE *)(v55[0] + 224)) {
        unint64_t v15 = (di_asif::details::map_element *)(v55[0] + 40);
      }
      else {
        unint64_t v15 = 0LL;
      }
    }

    else
    {
      unint64_t v15 = 0LL;
    }

    unint64_t v14 = *(unsigned __int16 *)(v13 + 18);
    *(void *)uint64_t v48 = di_asif::details::map_element::get_block_bits( v15,  2 * ((v8 * v14 - (*((void *)a1 + 44)
                        + *(void *)(v13 + 48)
                        * *(unsigned int *)(v13 + 20)
                        * ((v8 * v14 / v14 - *((void *)a1 + 44) / v14)
                         / (*(void *)(v13 + 48)
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(v55);
  }

  while (1)
  {
    if ((_BYTE)v7)
    {
      if (v7 == 3)
      {
        if (v6 >= v5) {
          goto LABEL_17;
        }
      }

      else if (v6 > v5)
      {
        goto LABEL_17;
      }
    }

    else if (v6 > v5 && v5 + 1 < v6)
    {
LABEL_17:
      goto LABEL_21;
    }

LABEL_21:
    if ((v7 & 2) != 0) {
      unint64_t v16 = v5;
    }
    else {
      unint64_t v16 = v5 + 1;
    }
    uint64_t v17 = *((void *)a1 + 1);
    unint64_t v18 = v16 * *(unsigned __int16 *)(v17 + 18);
    if (v18 >= *(void *)(v17 + 80) + *((void *)a1 + 44)) {
      goto LABEL_41;
    }
    uint64_t v19 = (void *)di_asif::details::table::get_data_entry_for_offset(a1, v18);
    unint64_t v21 = v19;
    uint64_t v22 = v20;
    __int128 v60 = v19;
    uint64_t v61 = v20;
    uint64_t v23 = *(unsigned __int16 *)(*((void *)a1 + 1) + 18LL);
    uint64_t v24 = v19[1];
    unint64_t v25 = (*(void *)(v24 + 48) + *(void *)(v24 + 48) * v20) / (unint64_t)(*(void *)(v24 + 48) + 1LL);
    uint64_t v26 = *(unsigned int *)(v24 + 20);
    else {
      unint64_t v27 = v19[44] + v26 + v25 * v26;
    }
    uint64_t v28 = (ref::ref_cnt *)(v19[7] + 16 * v20);
    BOOL v29 = ref::ref_cnt::get(v28);
    v58[0] = off_18A1E3FC0;
    v58[1] = v28;
    BOOL v59 = v29;
    if (!v29)
    {
      *(void *)&__int128 v53 = "di_asif::details::table::get_next_extent(ContextASIF &, const interval_sectors &, interval_sectors &)";
      *((void *)&v53 + 1) = 40LL;
      int v54 = 16;
      di_log::logger<di_log::log_printer<2311ul>>::logger(v55, &v53);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v57,  (uint64_t)"Couldn't lock entry ",  20LL);
      di_asif::details::operator<<(v57, &v60);
      di_log::logger<di_log::log_printer<2311ul>>::~logger((uint64_t)v55);
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = off_18A1E43B0;
      unint64_t v41 = std::generic_category();
      exception[1] = 5LL;
      exception[2] = v41;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 48) = 0;
      exception[7] = "Can't lock entry";
    }

    unint64_t v30 = atomic_load((unint64_t *)(v21[7] + 16 * v22 + 8));
    unint64_t v31 = v30 >> 62;
    if (v48[0] == (_DWORD)v31)
    {
      uint64_t v32 = *((void *)a1 + 1);
      unint64_t v47 = v27 / *(unsigned __int16 *)(v32 + 18);
      goto LABEL_39;
    }

    if ((_DWORD)v31 != 3) {
      break;
    }
    uint64_t v33 = v60[1];
    di_asif::details::table::get_bitmap( a1,  a2,  (v60[44] + (*(void *)(v33 + 48) + *(void *)(v33 + 48) * v61)
     / (unint64_t)(*(void *)(v33 + 48) + 1LL)
     * *(unsigned int *)(v33 + 20))
    / *(unsigned __int16 *)(v33 + 18),
      0,
      1LL,
      &v52);
    if (!v52 || *(_BYTE *)(v52 + 344))
    {
      *(void *)&__int128 v53 = "di_asif::details::table::get_next_extent(ContextASIF &, const interval_sectors &, interval_sectors &)";
      *((void *)&v53 + 1) = 40LL;
      int v54 = 16;
      di_log::logger<di_log::log_printer<2321ul>>::logger(v55, &v53);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"Can't read bitmap", 17LL);
      di_log::logger<di_log::log_printer<2321ul>>::~logger((uint64_t)v55);
      uint64_t v42 = __cxa_allocate_exception(0x40uLL);
      void *v42 = off_18A1E43B0;
      unint64_t v43 = std::generic_category();
      v42[1] = 5LL;
      v42[2] = v43;
      *((_BYTE *)v42 + 24) = 0;
      *((_BYTE *)v42 + 48) = 0;
      v42[7] = "Can't read bitmap";
    }

    unint64_t v34 = *(_BYTE *)(v52 + 224) ? (void *)(v52 + 40) : 0LL;
    unint64_t v35 = di_asif::details::map_element::search_for_pattern(v34, a1, v48[0], v18, v27, 0);
    unint64_t v36 = *(unsigned __int16 *)(*((void *)a1 + 1) + 18LL);
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v52);
    unint64_t v47 = v35 / v36;
    if (v35 < v27) {
      break;
    }
    uint64_t v32 = *((void *)a1 + 1);
LABEL_39:
    v49[0] = v5;
    v49[1] = v6;
    char v50 = v7;
    *(_DWORD *)size_t v51 = v62[0];
    *(_DWORD *)&v51[3] = *(_DWORD *)((char *)v62 + 3);
    unint64_t v37 = v27 / *(unsigned __int16 *)(v32 + 18);
    *(void *)&__int128 v53 = v16;
    *((void *)&v53 + 1) = v37;
    LOBYTE(v54) = 2;
    boost::icl::left_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)v49,  (uint64_t)&v53,  (uint64_t)v55);
    unint64_t v5 = v55[0];
    unint64_t v6 = v55[1];
    unsigned int v7 = v56;
    ref::details::ref_cnt_handle::~ref_cnt_handle((ref::details::ref_cnt_handle *)v58);
  }

  ref::details::ref_cnt_handle::~ref_cnt_handle((ref::details::ref_cnt_handle *)v58);
LABEL_41:
  if ((*(_BYTE *)(a3 + 16) & 2) != 0) {
    uint64_t v38 = *(void *)a3;
  }
  else {
    uint64_t v38 = *(void *)a3 + 1LL;
  }
  *(void *)a4 = v38;
  *(void *)(a4 + 8) = v47;
  *(_BYTE *)(a4 + 16) = 2;
  return *(void *)v48;
}

  if ((v2 & 2) != 0) {
    unint64_t v9 = v4;
  }
  else {
    unint64_t v9 = v4 + 1;
  }
  uint64_t v10 = *a2;
  if ((a2[2] & 2) == 0) {
    ++v10;
  }
  return v10 == v9 && (a2[2] & 1) + a2[1] == (v2 & 1) + v3;
}

    uint64_t v24 = 0;
    unint64_t v25 = v15;
    uint64_t v17 = v53;
LABEL_28:
    uint64_t v20 = v54;
    goto LABEL_29;
  }

  uint64_t v22 = (void *)v19;
  uint64_t v23 = +[DIError failWithPOSIXCode:verboseInfo:error:]( &OBJC_CLASS___DIError,  "failWithPOSIXCode:verboseInfo:error:",  22LL,  @"Append of existing image with custom size is not supported.",  a9);
  uint64_t v20 = v22;
  uint64_t v24 = v23;
LABEL_7:
  unint64_t v25 = v15;
LABEL_29:

  return v24;
}

void sub_1880F26C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void *di_log::logger<di_log::log_printer<2311ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<2311ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E1CA0;
  a1[45] = &unk_18A1E1DA0;
  a1[46] = &unk_18A1E1DC8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E1CA0;
  a1[45] = &unk_18A1E1D28;
  a1[46] = &unk_18A1E1D50;
  return a1;
}

void sub_1880F27B8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<2311ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<2321ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<2321ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E1EC0;
  a1[45] = &unk_18A1E1FC0;
  a1[46] = &unk_18A1E1FE8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E1EC0;
  a1[45] = &unk_18A1E1F48;
  a1[46] = &unk_18A1E1F70;
  return a1;
}

void sub_1880F28A0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<2321ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_asif::details::dir::unmap(uint64_t a1, di_asif::details::ContextASIF *a2, uint64_t a3, uint64_t a4)
{
  int v9 = *(unsigned __int8 *)(*(void *)(a1 + 24) + 184LL);
  while (v32 != v40 || v33 != v41 || v34 != v42 || v34 != v32 + 16 * v33 && (v37 != v43 || v38 != v44 || v39 != v45))
  {
    unint64_t v10 = val * *(unsigned __int16 *)(a1 + 18);
    di_asif::details::dir::get_table((di_asif::details::dir *)a1, a2, v10 / *(void *)(a1 + 80), v9 == 0, 1, &v31);
    if (v31 && !*(_BYTE *)(v31 + 520))
    {
      if (*(_BYTE *)(v31 + 400)) {
        uint64_t v15 = v31 + 40;
      }
      else {
        uint64_t v15 = 0LL;
      }
      di_asif::details::table::unmap(v15, a2, a3, a4, &v18);
      uint64_t v34 = v19;
      uint64_t v37 = v22;
      if (v33 != (v19 - v32) >> 4)
      {
        unint64_t val = di_asif::details::unmap_iterator_t::make_val((di_asif::details::unmap_iterator_t *)&v32);
        uint64_t v36 = v16;
      }

      int v12 = 0;
      goto LABEL_37;
    }

    if (v31)
    {
      if (*(_BYTE *)(v31 + 520)) {
        uint64_t v11 = 4294967291LL;
      }
      else {
        uint64_t v11 = 0LL;
      }
      if (!(*(unsigned __int8 *)(v31 + 520) | v9))
      {
LABEL_19:
        di_asif::details::table::make_unmap_iterators( a3,  a4,  *(unsigned int *)(a1 + 20),  *(unsigned __int16 *)(a1 + 18),  v10 / *(void *)(a1 + 80) * *(void *)(a1 + 80),  *(void *)(a1 + 80) + v10 / *(void *)(a1 + 80) * *(void *)(a1 + 80),  (uint64_t)&v18);
        while ((void)v18 != v25
             || *((void *)&v18 + 1) != v26
             || v19 != v27
             || v19 != (void)v18 + 16LL * *((void *)&v18 + 1) && (v22 != v28 || v23 != v29 || v24 != v30))
        {
          v22 += v24 * v21;
          unint64_t v20 = di_asif::details::unmap_iterator_t::make_val((di_asif::details::unmap_iterator_t *)&v18);
          uint64_t v21 = v13;
        }

        uint64_t v34 = v19;
        uint64_t v37 = v22;
        if (v33 != (v19 - v32) >> 4)
        {
          unint64_t val = di_asif::details::unmap_iterator_t::make_val((di_asif::details::unmap_iterator_t *)&v32);
          uint64_t v36 = v14;
        }

        int v12 = 2;
        goto LABEL_37;
      }

      int v12 = 1;
      uint64_t v4 = v11;
    }

    else
    {
      if (!v9) {
        goto LABEL_19;
      }
      uint64_t v4 = 0LL;
      int v12 = 1;
    }

LABEL_37:
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(&v31);
    if ((v12 | 2) != 2) {
      return v4;
    }
  }

  return 0LL;
}

      ref::tagged_ptr<CurrentReader,unsigned long long>::tagged_ptr((unint64_t *)a3, (unint64_t *)&v26);
      *(_DWORD *)(a3 + 8) = v15;
      return ref::tagged_ptr<CurrentReader,unsigned long long>::reset((unint64_t *)&v26);
    }
  }

  ref::tagged_ptr<CurrentReader,unsigned long long>::tagged_ptr((unint64_t *)&v24, (unint64_t *)&v26);
  uint64_t v25 = -2LL;
  *(void *)a3 = 0LL;
  do
    uint64_t v11 = __ldaxr((unint64_t *)&v24);
  while (__stlxr(0LL, (unint64_t *)&v24));
  atomic_store(v11, (unint64_t *)a3);
  *(_DWORD *)(a3 + 8) = v25;
  ref::tagged_ptr<CurrentReader,unsigned long long>::reset((unint64_t *)&v24);
  return ref::tagged_ptr<CurrentReader,unsigned long long>::reset((unint64_t *)&v26);
}

  uint64_t v37 = (_OWORD *)(v14 + 224);
  uint64_t v38 = (__int128 *)(v14 + 280);
  uint64_t v39 = *(std::__shared_weak_count **)(v14 + 216);
  unint64_t v106 = *(void *)(v14 + 208);
  unint64_t v107 = v39;
  if (v39)
  {
    uint64_t v40 = (unint64_t *)&v39->__shared_owners_;
    do
      uint64_t v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }

  v108[0] = *v37;
  *(_OWORD *)((char *)v108 + 9) = *(_OWORD *)(v14 + 233);
  unint64_t v110 = *v26;
  uint64_t v42 = *(_OWORD *)(v14 + 296);
  uint64_t v111 = *v38;
  uint64_t v43 = (__int128 *)(v14 + 336);
  uint64_t v44 = (uint64_t *)(v14 + 352);
  unint64_t v109 = *(void *)(v14 + 256);
  unint64_t v112 = v42;
  char v113 = *(_BYTE *)(v14 + 312);
  uint64_t v45 = *(std::__shared_weak_count **)(v14 + 328);
  __int128 v114 = *(void *)(v14 + 320);
  unint64_t v115 = v45;
  if (v45)
  {
    __int128 v46 = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v47 = __ldxr(v46);
    while (__stxr(v47 + 1, v46));
  }

  uint64_t v116 = *v43;
  uint64_t v117 = *v44;
  unint64_t v118 = *(_BYTE *)(v14 + 360);
  uint64_t v48 = *(std::__shared_weak_count **)(v14 + 216);
  unint64_t v93 = *(void *)(v14 + 208);
  unint64_t v94 = v48;
  if (v48)
  {
    size_t v49 = (unint64_t *)&v48->__shared_owners_;
    do
      char v50 = __ldxr(v49);
    while (__stxr(v50 + 1, v49));
  }

  *(_OWORD *)unint64_t v95 = *v37;
  *(_OWORD *)&v95[9] = *(_OWORD *)(v14 + 233);
  size_t v51 = *v38;
  unint64_t v52 = *(_OWORD *)(v14 + 296);
  uint64_t v97 = *v26;
  unint64_t v98 = v51;
  unint64_t v96 = *(void *)(v14 + 256);
  unint64_t v99 = v52;
  unint64_t v100 = *(_BYTE *)(v14 + 312);
  __int128 v53 = *(std::__shared_weak_count **)(v14 + 328);
  unint64_t v101 = *(void *)(v14 + 320);
  unint64_t v102 = v53;
  if (v53)
  {
    int v54 = (unint64_t *)&v53->__shared_owners_;
    do
      char v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }

  __n128 v103 = *v43;
  unint64_t v104 = *v44;
  unint64_t v105 = *(_BYTE *)(v14 + 360);
  unsigned __int8 v56 = std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>::pair[abi:ne180100]<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator,0>( a4,  (uint64_t)&v106,  (uint64_t)&v93);
  int v57 = v102;
  if (v102)
  {
    unint64_t v58 = (unint64_t *)&v102->__shared_owners_;
    do
      BOOL v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v57->__on_zero_shared)(v57, v56);
      std::__shared_weak_count::__release_weak(v57);
    }
  }

  __int128 v60 = v94;
  if (v94)
  {
    uint64_t v61 = (unint64_t *)&v94->__shared_owners_;
    do
      __int128 v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v60->__on_zero_shared)(v60, v56);
      std::__shared_weak_count::__release_weak(v60);
    }
  }

  char v63 = v115;
  if (v115)
  {
    uint64_t v64 = (unint64_t *)&v115->__shared_owners_;
    do
      char v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v63->__on_zero_shared)(v63, v56);
      std::__shared_weak_count::__release_weak(v63);
    }
  }

  __int128 v66 = v107;
  if (v107)
  {
    uint64_t v67 = (unint64_t *)&v107->__shared_owners_;
    do
      char v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v66->__on_zero_shared)(v66, v56);
      std::__shared_weak_count::__release_weak(v66);
    }
  }

  unint64_t v69 = v128;
  if (v128)
  {
    __int128 v70 = (unint64_t *)&v128->__shared_owners_;
    do
      unint64_t v71 = __ldaxr(v70);
    while (__stlxr(v71 - 1, v70));
    if (!v71)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v69->__on_zero_shared)(v69, v56);
      std::__shared_weak_count::__release_weak(v69);
    }
  }

  unint64_t v72 = v120;
  if (v120)
  {
    unint64_t v73 = (unint64_t *)&v120->__shared_owners_;
    do
      uint64_t v74 = __ldaxr(v73);
    while (__stlxr(v74 - 1, v73));
    if (!v74)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v72->__on_zero_shared)(v72, v56);
      std::__shared_weak_count::__release_weak(v72);
    }
  }

uint64_t di_asif::details::dir::flush( unint64_t **this, di_asif::details::ContextASIF *a2, uint64_t (***a3)())
{
  unint64_t v6 = (std::mutex *)(this + 441);
  std::mutex::lock((std::mutex *)(this + 441));
  ref::Allocator<di_asif::details::map_element,unsigned long long>::wait_for_idle((uint64_t)(this + 260));
  ref::Allocator<di_asif::details::table,unsigned long long>::wait_for_idle((uint64_t)(this + 35));
  unsigned int v7 = (unsigned int *)(this + 449);
  do
    unsigned int v8 = __ldaxr(v7);
  while (__stlxr(0, v7));
  int v9 = (*(uint64_t (**)(void, void))(**((void **)a2 + 2) + 16LL))(*((void *)a2 + 2), 0LL);
  if (v9) {
    goto LABEL_4;
  }
  uint64_t v10 = di_asif::details::dir::handle_all_failures((di_asif::details::dir *)this, a2);
  if ((_DWORD)v10)
  {
LABEL_10:
    if ((v10 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  uint64_t v13 = this[16];
  uint64_t v14 = this[17];
  if (v13 == v14)
  {
    uint64_t v10 = 0LL;
    if (v8) {
      goto LABEL_24;
    }
LABEL_27:
    if (this[450] == (unint64_t *)a3)
    {
LABEL_29:
      if (!v8 && (v10 & 0x80000000) == 0)
      {
        uint64_t v10 = 0LL;
        goto LABEL_8;
      }

      goto LABEL_10;
    }

LABEL_28:
    uint64_t v10 = di_asif::details::dir::flush_dir((di_asif::details::dir *)this, a2, a3);
    goto LABEL_29;
  }

  uint64_t v10 = 0LL;
  unint64_t v15 = 0LL;
  do
  {
    ref::tagged_weak_ptr<di_asif::details::table,unsigned long long>::lock_if_tag( v13,  v15 / (unint64_t)this[10],  (unint64_t *)&v18);
    if (v18 && !v18[520])
    {
      if (v18[400]) {
        uint64_t v16 = (di_asif::details::table *)(v18 + 40);
      }
      else {
        uint64_t v16 = 0LL;
      }
      BOOL v17 = di_asif::details::table::flush(v16, a2);
      if (v8) {
        unsigned int v8 = 1;
      }
      else {
        unsigned int v8 = v17;
      }
    }

    v15 += (unint64_t)this[10];
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v18);
    ++v13;
  }

  while (v13 != v14);
  if (!v8) {
    goto LABEL_27;
  }
LABEL_24:
  int v9 = (*(uint64_t (**)(void, void))(**((void **)a2 + 2) + 16LL))(*((void *)a2 + 2), 0LL);
  if (!v9) {
    goto LABEL_28;
  }
LABEL_4:
  if (v9 < 0) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = -v9;
  }
  do
LABEL_7:
    unsigned int v11 = __ldaxr(v7);
  while (__stlxr(v11 | v8, v7));
LABEL_8:
  std::mutex::unlock(v6);
  return v10;
}

  udif::details::UDIF_base::validate_runs((uint64_t)this);
  *(void *)&size_t v49 = "udif::details::UDIF_base::generate_blocks(CFArrayRef)";
  *((void *)&v49 + 1) = 41LL;
  LODWORD(v50) = 0;
  di_log::logger<di_log::log_printer<500ul>>::logger(v40, &v49);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v47,  (uint64_t)"UDIF - max compressed run size: ",  32LL);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v47,  (uint64_t)", required decompression buffer size: ",  38LL);
  std::ostream::operator<<();
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<500ul>>::~logger_buf((uint64_t)v40);
  MEMORY[0x1895BC2CC](v48);
  udif::details::UDIF_base::create_backends((uint64_t)this, &v38);
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::destroy( (uint64_t)&v38,  v39[0]);
  operator delete[](__p);
}

void sub_1880F2DF8()
{
}

uint64_t di_asif::details::dir::dir( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, uint64_t (***a6)(), uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  BOOL v17 = (void *)di_asif::details::dir_base::dir_base(a1, a2, a4, a5);
  *BOOL v17 = off_18A1DF288;
  v17[11] = off_18A1E3218;
  v17[12] = v17;
  uint64_t v43 = (uint64_t)(v17 + 11);
  v17[14] = v17 + 11;
  v17[15] = a3;
  std::vector<ref::tagged_weak_ptr<di_asif::details::table,unsigned long long>>::vector( v17 + 16,  (unint64_t)(*(void *)(a1 + 80) + a3 - 1) / *(void *)(a1 + 80));
  std::vector<unsigned long long>::vector( (void *)(a1 + 152),  (unint64_t)(*(void *)(a1 + 80) + a3 - 1) / *(void *)(a1 + 80));
  *(void *)(a1 + 176) = a4;
  uint64_t v41 = a5 + 7LL;
  uint64_t v42 = a5 - 1LL;
  unint64_t v18 = (a4
       - 1LL
       + (v42 + (unint64_t)a6) / a5 * a5
       + (v41 + 8 * ((unint64_t)(*(void *)(a1 + 120) + *(void *)(a1 + 80) - 1LL) / *(void *)(a1 + 80)))
       / a5
       * a5
       * a7)
      / a4;
  *(void *)(a1 + 184) = 850045863LL;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(void *)(a1 + 256) = 0LL;
  *(void *)(a1 + 240) = 0LL;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v10 - 248) = a1 + 256;
  *(void *)(a1 + 264) = 0LL;
  *(void *)(a1 + 272) = v18 * a4;
  uint64_t v48 = 0LL;
  ref::Allocator<di_asif::details::table,unsigned long long>::Allocator(a1 + 280, 2uLL, 0LL, (uint64_t)&v46);
  uint64_t v19 = v48;
  if (v48 == (system_properties *)&v46)
  {
    uint64_t v20 = 4LL;
    uint64_t v19 = (system_properties *)&v46;
  }

  else
  {
    if (!v48) {
      goto LABEL_6;
    }
    uint64_t v20 = 5LL;
  }

  uint64_t v19 = (system_properties *)(*(uint64_t (**)(void))(*(void *)v19 + 8 * v20))();
LABEL_6:
  resources = system_properties::get_resources(v19);
  uint64_t v22 = (int *)(a2 + 188);
  if (!*(_BYTE *)(a2 + 192)) {
    uint64_t v22 = (int *)(resources + 4);
  }
  int v23 = *v22;
  uint64_t v24 = 64LL;
  if (v23 == 1) {
    uint64_t v24 = 32LL;
  }
  if (v23) {
    unint64_t v25 = v24;
  }
  else {
    unint64_t v25 = 16LL;
  }
  ref::Allocator<di_asif::details::map_element,unsigned long long>::Allocator(a1 + 2080, v25, 2LL, v43);
  *(void *)(a1 + 3528) = 850045863LL;
  *(_OWORD *)(a1 + 3536) = 0u;
  *(_OWORD *)(a1 + 3552) = 0u;
  *(_OWORD *)(a1 + 3568) = 0u;
  *(void *)(a1 + 3584) = 0LL;
  *(_DWORD *)(a1 + 3592) = a8 == 0;
  *(void *)(a1 + 3600) = a6;
  uint64_t v40 = (pthread_t *)(a1 + 3616);
  *(_OWORD *)(a1 + 3608) = 0u;
  *(void *)(a1 + 3624) = 1018212795LL;
  *(_OWORD *)(a1 + 3632) = 0u;
  *(_OWORD *)(a1 + 3648) = 0u;
  *(_OWORD *)(a1 + 3657) = 0u;
  *(void *)(a1 + 3680) = 850045863LL;
  *(void *)(a1 + 3784) = 0LL;
  *(_OWORD *)(a1 + 3688) = 0u;
  *(_OWORD *)(a1 + 3704) = 0u;
  *(_OWORD *)(a1 + 3720) = 0u;
  *(_OWORD *)(a1 + 3736) = 0u;
  *(_OWORD *)(a1 + 3752) = 0u;
  *(_OWORD *)(a1 + 3768) = 0u;
  *(void *)(a1 + 3792) = 850045863LL;
  *(_OWORD *)(a1 + 3800) = 0u;
  *(_OWORD *)(a1 + 3816) = 0u;
  *(_OWORD *)(a1 + 3832) = 0u;
  *(void *)(a1 + 3848) = 0LL;
  if (*(void *)(a1 + 80) == 1LL && a3 == -1)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    uint64_t v39 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v39;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "asif: chunk size is too small, too many dir indices";
  }

  if (a8
    && (a6 != (uint64_t (***)())512
     || (unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a8 + 40LL))(a8) >= 0x201))
  {
    *(void *)(a1 + 3608) = di_asif::details::dir::load<std::__wrap_iter<unsigned long long *>>( a8,  a6,  *(unsigned __int16 *)(a1 + 18),  (uint64_t)(*(void *)(a1 + 160) - *(void *)(a1 + 152)) >> 3,  *(void **)(a1 + 152))
                           + 1;
  }

  unint64_t v26 = a4
      - 1LL
      + ((unint64_t)a6 + v42) / a5 * a5
      + (v41 + 8 * ((unint64_t)(*(void *)(a1 + 120) + *(void *)(a1 + 80) - 1LL) / *(void *)(a1 + 80)))
      / a5
      * a5
      * a7;
  unint64_t v27 = (~(v26 % a4) + a4 + v26) / a4;
  uint64_t v28 = (unint64_t *)(a1 + 8);
  do
    unint64_t v29 = __ldaxr(v28);
  while (__stlxr(v29 + v27, v28));
  uint64_t v46 = a1;
  uint64_t v30 = v47;
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( (uint64_t)v47,  a9);
  unint64_t v31 = (std::__thread_struct *)operator new(8uLL);
  std::__thread_struct::__thread_struct(v31);
  uint64_t v32 = (uint64_t *)operator new(0x30uLL);
  uint64_t v33 = v46;
  uint64_t v34 = v49;
  *uint64_t v32 = (uint64_t)v31;
  v32[1] = v33;
  if (!v34) {
    goto LABEL_24;
  }
  if (v34 != v47)
  {
    uint64_t v34 = (void *)(*(uint64_t (**)(void *))(*v34 + 16LL))(v34);
LABEL_24:
    v32[5] = (uint64_t)v34;
    goto LABEL_26;
  }

  v32[5] = (uint64_t)(v32 + 2);
  (*(void (**)(void *))(v47[0] + 24LL))(v47);
LABEL_26:
  uint64_t v45 = v32;
  int v35 = pthread_create( &v44,  0LL,  (void *(__cdecl *)(void *))std::__thread_proxy[abi:ne180100]<std::tuple<std::unique_ptr<std::__thread_struct>,di_asif::details::dir::dir(DiskImageASIF &,unsigned long long,unsigned int,unsigned short,unsigned long long,unsigned long,Backend *,std::function<void ()(di_asif::details::ContextASIF &)> const&)::$_0>>,  v32);
  if (v35)
  {
    std::__throw_system_error(v35, "thread constructor failed");
    __break(1u);
LABEL_36:
    std::terminate();
  }

  uint64_t v45 = 0LL;
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,di_asif::details::dir::dir(DiskImageASIF &,unsigned long long,unsigned int,unsigned short,unsigned long long,unsigned long,Backend *,std::function<void ()(di_asif::details::ContextASIF &)> const&)::$_0>>::~unique_ptr[abi:ne180100](&v45);
  if (*v40) {
    goto LABEL_36;
  }
  pthread_t *v40 = v44;
  pthread_t v44 = 0LL;
  std::thread::~thread((std::thread *)&v44);
  if (v49 == v47)
  {
    uint64_t v36 = 4LL;
    goto LABEL_32;
  }

  if (v49)
  {
    uint64_t v36 = 5LL;
    uint64_t v30 = v49;
LABEL_32:
    (*(void (**)(void *))(*v30 + 8 * v36))(v30);
  }

  return a1;
}

void sub_1880F3308( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::condition_variable *a9, uint64_t a10, uint64_t a11, void **a12, void **a13, std::thread *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, char a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29)
{
  if (a29 == v32)
  {
    uint64_t v36 = 4LL;
  }

  else
  {
    if (!a29) {
      goto LABEL_6;
    }
    uint64_t v36 = 5LL;
    uint64_t v32 = a29;
  }

  (*(void (**)(void *))(*v32 + 8 * v36))(v32);
LABEL_6:
  std::mutex::~mutex(v30);
  std::deque<std::atomic<DiskImage::Context *>>::~deque[abi:ne180100]((void *)(v29 + 3744));
  std::mutex::~mutex(v34);
  std::condition_variable::~condition_variable(a9);
  std::thread::~thread(a14);
  std::mutex::~mutex((std::mutex *)(v29 + 3528));
  ref::Allocator<di_asif::details::map_element,unsigned long long>::~Allocator(a10);
  ref::Allocator<di_asif::details::table,unsigned long long>::~Allocator(a11);
  space_allocators::FixedSize::~FixedSize(v31);
  uint64_t v37 = *a12;
  if (*a12)
  {
    *(void *)(v29 + 160) = v37;
    operator delete(v37);
  }

  uint64_t v38 = *a13;
  if (*a13)
  {
    *(void *)(v29 + 136) = v38;
    operator delete(v38);
  }

  uint64_t v39 = *(void **)(v29 + 112);
  if (v39 == a19)
  {
    uint64_t v40 = 4LL;
  }

  else
  {
    if (!v39) {
      goto LABEL_15;
    }
    uint64_t v40 = 5LL;
    a19 = *(void **)(v29 + 112);
  }

  (*(void (**)(void))(*a19 + 8 * v40))();
LABEL_15:
  _Unwind_Resume(a1);
}

void sub_1880F3488()
{
}

uint64_t di_asif::details::dir_base::dir_base(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  *(void *)a1 = off_18A1E20D8;
  *(void *)(a1 + 8) = 0LL;
  *(_BYTE *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 18) = a4;
  *(_DWORD *)(a1 + 20) = a3;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3 >> 3;
  unint64_t v5 = a3 / a4;
  unint64_t v6 = 4LL * a3;
  if (v6 < v5) {
    uint64_t v7 = 1LL;
  }
  else {
    uint64_t v7 = v6 / v5;
  }
  *(void *)(a1 + 40) = v5;
  *(void *)(a1 + 48) = v7;
  uint64_t v8 = di_asif::details::dir_base::calc_num_real_elements((di_asif::details::dir_base *)a1);
  unint64_t v9 = (*(void *)(a1 + 48) + v8) / (unint64_t)(*(void *)(a1 + 48) + 1LL);
  *(void *)(a1 + 56) = v8;
  *(void *)(a1 + 64) = v9;
  unint64_t v10 = v8 - v9;
  unint64_t v11 = v10 * *(unsigned int *)(a1 + 20);
  *(void *)(a1 + 72) = v10;
  *(void *)(a1 + 80) = v11;
  return a1;
}

unint64_t di_asif::details::dir::load<std::__wrap_iter<unsigned long long *>>( uint64_t a1, uint64_t (***a2)(), unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v6 = a4;
  v38[4] = *MEMORY[0x1895F89C0];
  size_t v9 = (a3 + 8 * a4 + 7) / a3 * a3;
  unint64_t v10 = (unint64_t *)valloc(v9);
  if (!v10)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v26 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v26, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  unint64_t v31 = off_18A1DFDC8;
  uint64_t v34 = &v31;
  uint64_t v37 = v10;
  std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)v38, (uint64_t)&v31);
  unint64_t v11 = v34;
  if (v34 == &v31)
  {
    uint64_t v12 = 4LL;
    unint64_t v11 = &v31;
  }

  else
  {
    if (!v34) {
      goto LABEL_7;
    }
    uint64_t v12 = 5LL;
  }

  (*v11)[v12]();
LABEL_7:
  uint64_t v13 = v37;
  uint64_t v14 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  unint64_t v31 = (uint64_t (**)())v13;
  uint64_t v32 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }

  size_t v33 = v9;
  uint64_t v34 = a2;
  size_t v35 = v9;
  char v36 = 0;
  int v17 = (*(uint64_t (**)(uint64_t, uint64_t (***)()))(*(void *)a1 + 88LL))(a1, &v31);
  if (v9 != v17)
  {
    unint64_t v27 = __cxa_allocate_exception(0x40uLL);
    uint64_t v28 = v27;
    if (v17 >= 0) {
      uint64_t v29 = 4294967291LL;
    }
    else {
      uint64_t v29 = v17;
    }
    *unint64_t v27 = off_18A1E43B0;
    uint64_t v30 = std::generic_category();
    v28[1] = v29;
    v28[2] = v30;
    *((_BYTE *)v28 + 24) = 0;
    *((_BYTE *)v28 + 48) = 0;
    v28[7] = "Can't load asif dir table";
  }

  unint64_t v18 = *v13;
  if (v6)
  {
    uint64_t v19 = v13 + 1;
    do
    {
      unint64_t v20 = *v19++;
      *a5++ = bswap64(v20);
      --v6;
    }

    while (v6);
  }

  uint64_t v21 = v32;
  if (v32)
  {
    uint64_t v22 = (unint64_t *)&v32->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v37);
  return bswap64(v18);
}

void sub_1880F3720( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

unint64_t di_asif::details::dir::get_version(unint64_t this, Backend *a2)
{
  uint64_t v4 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  unint64_t v15 = &v21;
  unint64_t v16 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  uint64_t v17 = 8LL;
  unint64_t v18 = a2;
  uint64_t v19 = 8LL;
  char v20 = 0;
  LODWORD(this) = (*(uint64_t (**)(unint64_t, unint64_t **))(*(void *)this + 88LL))( this,  &v15);
  if ((_DWORD)this != 8)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v13 = exception;
    if ((this & 0x80000000) == 0LL) {
      this = 4294967291LL;
    }
    else {
      this = this;
    }
    void *exception = off_18A1E43B0;
    uint64_t v14 = std::generic_category();
    v13[1] = this;
    v13[2] = v14;
    *((_BYTE *)v13 + 24) = 0;
    *((_BYTE *)v13 + 48) = 0;
    v13[7] = "Can't load asif dir version";
  }

  unint64_t v7 = bswap64(v21);
  unint64_t v21 = v7;
  uint64_t v8 = v16;
  if (v16)
  {
    size_t v9 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  return v7;
}

void sub_1880F3868(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *di_asif::details::operator<<(void *result, _DWORD *a2)
{
  switch(*a2)
  {
    case 0:
      uint64_t v2 = "uninit";
      uint64_t v3 = 6LL;
      goto LABEL_3;
    case 1:
      uint64_t v2 = "fully";
      uint64_t v3 = 5LL;
      goto LABEL_3;
    case 2:
      uint64_t v2 = "unmapped";
      uint64_t v3 = 8LL;
      goto LABEL_3;
    case 3:
      uint64_t v2 = "has_bitmap";
      uint64_t v3 = 10LL;
LABEL_3:
      double result = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(result, (uint64_t)v2, v3);
      break;
    default:
      return result;
  }

  return result;
}

void di_asif::details::dir::update_entry_for_table( di_asif::details::dir *this, unint64_t a2, unint64_t a3)
{
  *(void *)(*((void *)this + 19) + 8 * (a2 / *((void *)this + 10))) = a3 / *((unsigned int *)this + 5);
  atomic_store(1u, (unsigned int *)this + 898);
}

void *di_asif::details::dir::trim_last_unused_extents( di_asif::details::dir *this, di_asif::details::ContextASIF *a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t v3 = (void *)(*(uint64_t (**)(di_asif::details::dir *))(*(void *)this + 16LL))(this);
  v6[0] = off_18A1DF6E8;
  v6[1] = a2;
  unint64_t v7 = v6;
  space_allocators::FixedSize::trim_largest(v3, (uint64_t)v6);
  double result = v7;
  if (v7 == v6)
  {
    uint64_t v5 = 4LL;
    double result = v6;
  }

  else
  {
    if (!v7) {
      return result;
    }
    uint64_t v5 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_1880F39B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v14 = a13;
  if (a13 == &a10)
  {
    uint64_t v15 = 4LL;
    uint64_t v14 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*(void *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void space_allocators::FixedSize::trim_largest(void *a1, uint64_t a2)
{
  if (a1[11])
  {
    char v4 = 0;
    uint64_t v5 = (uint64_t **)(a1 + 9);
    unint64_t v6 = (uint64_t **)(a1 + 10);
    while (1)
    {
      unint64_t v7 = *v6;
      uint64_t v8 = *v6;
      size_t v9 = v6;
      if (*v6)
      {
        do
        {
          unint64_t v10 = (uint64_t **)v8;
          uint64_t v8 = (uint64_t *)v8[1];
        }

        while (v8);
      }

      else
      {
        do
        {
          unint64_t v10 = (uint64_t **)v9[2];
          BOOL v11 = *v10 == (uint64_t *)v9;
          size_t v9 = v10;
        }

        while (v11);
      }

      uint64_t v12 = (uint64_t)v10[4] + *a1;
      uint64_t v13 = a1[12];
      if (v12 != v13) {
        break;
      }
      uint64_t v14 = (uint64_t *)v6;
      if (v7)
      {
        do
        {
          uint64_t v15 = v7;
          unint64_t v7 = (uint64_t *)v7[1];
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v15 = (uint64_t *)v14[2];
          BOOL v11 = *v15 == (void)v14;
          uint64_t v14 = v15;
        }

        while (v11);
      }

      std::__tree<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>>>::__remove_node_pointer( v5,  v15);
      operator delete(v15);
      uint64_t v16 = a1[11];
      uint64_t v13 = a1[12] - *a1;
      a1[12] = v13;
      char v4 = 1;
      if (!v16) {
        goto LABEL_15;
      }
    }

    if ((v4 & 1) == 0) {
      return;
    }
LABEL_15:
    uint64_t v17 = *(void *)(a2 + 24);
    if (v17)
    {
      v20[0] = v13;
      if ((*(unsigned int (**)(uint64_t, void *))(*(void *)v17 + 48LL))(v17, v20))
      {
        *(void *)&__int128 v18 = "space_allocators::FixedSize::trim_largest(const size_changed_fn_t &)";
        *((void *)&v18 + 1) = 41LL;
        int v19 = 16;
        di_log::logger<di_log::log_printer<158ul>>::logger(v20, &v18);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v21,  (uint64_t)"trim largest: size change callback failed with ",  47LL);
        std::ostream::operator<<();
        std::ostream::~ostream();
        di_log::logger_buf<di_log::log_printer<158ul>>::~logger_buf((uint64_t)v20);
        MEMORY[0x1895BC2CC](&v22);
      }
    }
  }

void sub_1880F3B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

di_asif::header *di_asif::header::header(di_asif::header *this, Backend *a2)
{
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  if ((unint64_t)(*(uint64_t (**)(Backend *))(*(void *)a2 + 40LL))(a2) <= 0x1FF)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v10 = (*(uint64_t (**)(Backend *))(*(void *)a2 + 40LL))(a2);
    void *exception = off_18A1E2338;
    exception[1] = "asif_header";
    exception[2] = 512LL;
    exception[3] = v10;
  }

  char v4 = (char *)operator new[](0x200uLL);
  *(_OWORD *)char v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((_OWORD *)v4 + 7) = 0u;
  *((_OWORD *)v4 + 8) = 0u;
  *((_OWORD *)v4 + 9) = 0u;
  *((_OWORD *)v4 + 10) = 0u;
  *((_OWORD *)v4 + 11) = 0u;
  *((_OWORD *)v4 + 12) = 0u;
  *((_OWORD *)v4 + 13) = 0u;
  *((_OWORD *)v4 + 14) = 0u;
  *((_OWORD *)v4 + 15) = 0u;
  *((_OWORD *)v4 + 16) = 0u;
  *((_OWORD *)v4 + 17) = 0u;
  *((_OWORD *)v4 + 18) = 0u;
  *((_OWORD *)v4 + 19) = 0u;
  *((_OWORD *)v4 + 20) = 0u;
  *((_OWORD *)v4 + 21) = 0u;
  *((_OWORD *)v4 + 22) = 0u;
  *((_OWORD *)v4 + 23) = 0u;
  *((_OWORD *)v4 + 24) = 0u;
  *((_OWORD *)v4 + 25) = 0u;
  *((_OWORD *)v4 + 26) = 0u;
  *((_OWORD *)v4 + 27) = 0u;
  *((_OWORD *)v4 + 28) = 0u;
  *((_OWORD *)v4 + 29) = 0u;
  *((_OWORD *)v4 + 30) = 0u;
  *((_OWORD *)v4 + 31) = 0u;
  if (Backend::read(a2, v4, 512LL, 0LL) != 512)
  {
    BOOL v11 = __cxa_allocate_exception(0x40uLL);
    void *v11 = off_18A1E43B0;
    uint64_t v12 = std::generic_category();
    v11[1] = 152LL;
    void v11[2] = v12;
    *((_BYTE *)v11 + 24) = 0;
    *((_BYTE *)v11 + 48) = 0;
    v11[7] = "Couldn't read asif's header";
  }

  di_asif::header::init(this, v4);
  for (uint64_t i = 80LL; i != 512; ++i)
  {
    if (v4[i])
    {
      unint64_t v7 = __cxa_allocate_exception(0x40uLL);
      *unint64_t v7 = off_18A1E43B0;
      uint64_t v8 = std::generic_category();
      v7[1] = 161LL;
      v7[2] = v8;
      *((_BYTE *)v7 + 24) = 0;
      *((_BYTE *)v7 + 48) = 0;
      v7[7] = "Unsupported ASIF, contains data beyond current header struct size";
    }
  }

  operator delete[](v4);
  return this;
}

void sub_1880F3D70(_Unwind_Exception *a1)
{
}

_WORD *di_asif::header::init(di_asif::header *this, const char *a2)
{
  int v4 = *(_DWORD *)a2;
  LODWORD(v14[0]) = 2003069043;
  smart_enums::validators::value<unsigned int>((uint64_t)"header_signature", v4, v14, 1LL);
  *(_DWORD *)this = 2003069043;
  *((_DWORD *)this + 1) = bswap32(*((_DWORD *)a2 + 1));
  *((_DWORD *)this + 2) = bswap32(*((_DWORD *)a2 + 2));
  di_asif::header_flags::header_flags(v14, bswap32(*((_DWORD *)a2 + 3)));
  *((_DWORD *)this + 3) = v14[0];
  *((void *)this + 2) = bswap64(*((void *)a2 + 2));
  *((void *)this + 3) = bswap64(*((void *)a2 + 3));
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  *((void *)this + 6) = bswap64(*((void *)a2 + 6));
  *((void *)this + 7) = bswap64(*((void *)a2 + 7));
  *((_DWORD *)this + 16) = bswap32(*((_DWORD *)a2 + 16));
  *((_WORD *)this + 34) = bswap32(*((unsigned __int16 *)a2 + 34)) >> 16;
  double result = di_asif::header::total_segments_t::total_segments_t(v14, *((unsigned __int16 *)a2 + 35));
  *((_WORD *)this + 35) = v14[0];
  *((void *)this + 9) = bswap64(*((void *)a2 + 9));
  if (*((_DWORD *)this + 1) != 1)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v14);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v14,  (uint64_t)"Unsupported ASIF version ",  25LL);
    std::ostream::operator<<();
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v14, 0xA1u);
  }

  if ((*((_DWORD *)this + 2) - 1048577) <= 0xFFF0004E)
  {
    size_t v9 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "Invalid ASIF header size";
LABEL_15:
    unsigned int v12 = 152;
    goto LABEL_19;
  }

  unint64_t v6 = *((unsigned __int16 *)this + 34);
  if (!*((_WORD *)this + 34))
  {
    size_t v9 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "Shadow block size is invalid (0)";
    goto LABEL_15;
  }

  unsigned int v7 = *((_DWORD *)this + 16);
  if (v7 < v6 || v7 % v6)
  {
    size_t v9 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "ASIF max_write size in header exceed the limit";
LABEL_18:
    unsigned int v12 = 22;
LABEL_19:
    DiskImagesRuntimeException::DiskImagesRuntimeException(v9, v10, v12);
  }

  if ((v6 & 0x1FF) != 0)
  {
    size_t v9 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "ASIF block size isn't multiple of 512";
    goto LABEL_15;
  }

  unint64_t v8 = *((void *)this + 7);
  if (v8 >= 0xFFFFFFFFFFFFFFFFLL / v6)
  {
    size_t v9 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "Max sector count is too large";
    goto LABEL_18;
  }

  if (v8 < *((void *)this + 6))
  {
    size_t v9 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "Sector count is too large";
    goto LABEL_18;
  }

  return result;
}

void sub_1880F3FFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

__n128 di_asif::header::header(di_asif::header *this, __n128 *a2)
{
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *(__n128 *)this = *a2;
  __n128 result = a2[1];
  __n128 v3 = a2[2];
  __n128 v4 = a2[4];
  *((__n128 *)this + 3) = a2[3];
  *((__n128 *)this + 4) = v4;
  *((__n128 *)this + 1) = result;
  *((__n128 *)this + 2) = v3;
  return result;
}

char *di_asif::header::write(di_asif::header *this, char *a2)
{
  *(_DWORD *)a2 = *(_DWORD *)this;
  *((_DWORD *)a2 + 1) = bswap32(*((_DWORD *)this + 1));
  *((_DWORD *)a2 + 2) = bswap32(*((_DWORD *)this + 2));
  *((_DWORD *)a2 + 3) = bswap32(*((_DWORD *)this + 3));
  *((void *)a2 + 2) = bswap64(*((void *)this + 2));
  *((void *)a2 + 3) = bswap64(*((void *)this + 3));
  *((_OWORD *)a2 + 2) = *((_OWORD *)this + 2);
  *((void *)a2 + 6) = bswap64(*((void *)this + 6));
  *((void *)a2 + 7) = bswap64(*((void *)this + 7));
  *((_DWORD *)a2 + 16) = bswap32(*((_DWORD *)this + 16));
  *((_WORD *)a2 + 34) = bswap32(*((unsigned __int16 *)this + 34)) >> 16;
  *((_WORD *)a2 + 35) = *((_WORD *)this + 35);
  *((void *)a2 + 9) = bswap64(*((void *)this + 9));
  return a2 + 80;
}

uint64_t di_asif::header::header( uint64_t a1, _DWORD *a2, _OWORD *a3, unint64_t a4, unint64_t a5, unsigned int a6, unsigned int a7)
{
  *(_DWORD *)a1 = 2003069043;
  int v18 = 2003069043;
  smart_enums::validators::value<unsigned int>((uint64_t)"header_signature", 2003069043, &v18, 1LL);
  *(void *)(a1 + 4) = 0x20000000001LL;
  *(_DWORD *)(a1 + 12) = *a2;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 48) = a4;
  *(void *)(a1 + 56) = a5;
  *(_DWORD *)(a1 + 64) = a6;
  *(_WORD *)(a1 + 68) = a7;
  di_asif::header::total_segments_t::total_segments_t((_WORD *)(a1 + 70), 0);
  *(void *)(a1 + 72) = 0LL;
  if (!is_mul_ok(a5, a7) || !is_mul_ok(a4, a7) || (unint64_t v14 = a4 * a7 + 2LL * a6, __CFADD__(a4 * a7, 2LL * a6)))
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "ASIF header calculation overflow", 0x16u);
  }

  if (v14 <= a5 * a7) {
    unint64_t v14 = a5 * a7;
  }
  *(void *)(a1 + 56) = v14 / a7;
  *(_OWORD *)(a1 + 32) = *a3;
  return a1;
}

uint64_t di_asif::header::write_header(di_asif::header *this, Backend *a2)
{
  else {
    size_t v4 = *((unsigned __int16 *)this + 34);
  }
  uint64_t v5 = operator new[](v4);
  bzero(v5, v4);
  unint64_t v6 = di_asif::header::write(this, (char *)v5);
  int64_t v7 = (_BYTE *)v5 + v4 - v6;
  if (v7 >= 1) {
    bzero(v6, v7);
  }
  int v8 = Backend::write(a2, (char *)v5, v4, 0LL);
  if (v8 >= 0) {
    unsigned int v9 = -5;
  }
  else {
    unsigned int v9 = v8;
  }
  if (v4 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = v9;
  }
  operator delete[](v5);
  return v10;
}

void sub_1880F42C8(_Unwind_Exception *a1)
{
}

uint64_t Backend::write(Backend *this, char *a2, uint64_t a3, uint64_t a4)
{
  int v8 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  uint64_t v16 = a2;
  uint64_t v17 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  uint64_t v18 = a3;
  uint64_t v19 = a4;
  uint64_t v20 = a3;
  char v21 = 0;
  uint64_t v11 = (*(uint64_t (**)(Backend *, char **))(*(void *)this + 96LL))(this, &v16);
  unsigned int v12 = v17;
  if (v17)
  {
    uint64_t v13 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  return v11;
}

void sub_1880F4398( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

di_asif::meta_header *di_asif::meta_header::meta_header(di_asif::meta_header *this, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)this = 1635018093;
  int v7 = 1635018093;
  smart_enums::validators::value<unsigned int>((uint64_t)"header_signature", 1635018093, &v7, 1LL);
  *((_DWORD *)this + 1) = 1;
  int v8 = 1;
  smart_enums::validators::value<unsigned int>((uint64_t)"version_t", 1, &v8, 1LL);
  *((_DWORD *)this + 2) = 512;
  int v9 = 512;
  smart_enums::validators::value<unsigned int>((uint64_t)"header_size_t", 512, &v9, 1LL);
  *(void *)((char *)this + 12) = a2;
  *(void *)((char *)this + 20) = a3;
  return this;
}

uint64_t *di_asif::meta_header::write_header( di_asif::meta_header *this, di_asif::details::ContextASIF *a2, di_asif::details::dir *a3, uint64_t a4)
{
  v79[4] = *MEMORY[0x1895F89C0];
  int v8 = valloc(0x200uLL);
  if (!v8)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    int v54 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v54, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  v66[0] = (uint64_t)off_18A1DFDC8;
  uint64_t v67 = v66;
  unint64_t v78 = v8;
  std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)v79, (uint64_t)v66);
  int v9 = v67;
  if (v67 == v66)
  {
    uint64_t v10 = 4LL;
    int v9 = v66;
  }

  else
  {
    if (!v67) {
      goto LABEL_7;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_7:
  uint64_t v11 = v78;
  *unint64_t v78 = *(_DWORD *)this;
  v11[1] = bswap32(*((_DWORD *)this + 1));
  void v11[2] = bswap32(*((_DWORD *)this + 2));
  *(void *)(v11 + 3) = bswap64(*(void *)((char *)this + 12));
  *(void *)(v11 + 5) = bswap64(*(void *)((char *)this + 20));
  unsigned int v12 = v78;
  int64_t v13 = (char *)v78 - (char *)(v11 + 7) + 512;
  if (v13 >= 1) {
    bzero(v11 + 7, v13);
  }
  uint64_t v14 = *((void *)details::get_dummy_shared_ptr() + 1);
  *(void *)&__int128 v60 = v12;
  *((void *)&v60 + 1) = v14;
  if (v14)
  {
    uint64_t v15 = (unint64_t *)(v14 + 8);
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  uint64_t v61 = 512LL;
  uint64_t v62 = a4;
  uint64_t v63 = 512LL;
  char v64 = 0;
  sg_vec::sg_vec(v66, &v60);
  uint64_t v17 = (std::__shared_weak_count *)*((void *)&v60 + 1);
  if (*((void *)&v60 + 1))
  {
    uint64_t v18 = (unint64_t *)(*((void *)&v60 + 1) + 8LL);
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  sg_vec_ref::begin((sg_vec_ref *)v71, (uint64_t)&v60);
  sg_vec_ref::end((sg_vec_ref *)v71, (uint64_t)&v57);
  uint64_t v20 = di_asif::details::dir::do_io( a3,  a2,  (const sg_vec_ns::details::sg_vec_iterator *)&v60,  (const sg_vec_ns::details::sg_vec_iterator *)&v57,  0);
  char v21 = v59;
  if (v59)
  {
    p_shared_owners = (unint64_t *)&v59->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  uint64_t v24 = v58;
  if (v58)
  {
    unint64_t v25 = (unint64_t *)&v58->__shared_owners_;
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  unint64_t v27 = v65;
  if (v65)
  {
    uint64_t v28 = (unint64_t *)&v65->__shared_owners_;
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

  uint64_t v30 = (std::__shared_weak_count *)*((void *)&v60 + 1);
  if (!*((void *)&v60 + 1)) {
    goto LABEL_36;
  }
  unint64_t v31 = (unint64_t *)(*((void *)&v60 + 1) + 8LL);
  do
    unint64_t v32 = __ldaxr(v31);
  while (__stlxr(v32 - 1, v31));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
    if ((v20 & 0x8000000000000000LL) == 0) {
      goto LABEL_38;
    }
  }

  else
  {
LABEL_36:
    if ((v20 & 0x8000000000000000LL) == 0) {
      goto LABEL_38;
    }
  }

  uint64_t v33 = v20;
  if ((_DWORD)v20)
  {
    char v55 = __cxa_allocate_exception(0x40uLL);
    *char v55 = off_18A1E43B0;
    unsigned __int8 v56 = std::generic_category();
    v55[1] = v33;
    unint64_t v55[2] = v56;
    *((_BYTE *)v55 + 24) = 0;
    *((_BYTE *)v55 + 48) = 0;
    v55[7] = "Failed to write metadata header";
  }

void sub_1880F4920( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
}

di_asif::meta_header *di_asif::meta_header::meta_header( di_asif::meta_header *this, di_asif::details::ContextASIF *a2, di_asif::details::dir *a3, uint64_t a4)
{
  v91[4] = *MEMORY[0x1895F89C0];
  *(void *)this = 0LL;
  *((void *)this + 1) = 0LL;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 2) = 0LL;
  int v8 = (const char *)valloc(0x200uLL);
  if (!v8)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v63 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v63, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  v78[0] = (uint64_t)off_18A1DFDC8;
  uint64_t v79 = v78;
  uint64_t v90 = v8;
  std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)v91, (uint64_t)v78);
  int v9 = v79;
  if (v79 == v78)
  {
    uint64_t v10 = 4LL;
    int v9 = v78;
  }

  else
  {
    if (!v79) {
      goto LABEL_7;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_7:
  uint64_t v11 = v90;
  uint64_t v12 = *((void *)details::get_dummy_shared_ptr() + 1);
  *(void *)&__int128 v71 = v11;
  *((void *)&v71 + 1) = v12;
  if (v12)
  {
    int64_t v13 = (unint64_t *)(v12 + 8);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  uint64_t v72 = 512LL;
  uint64_t v73 = a4;
  uint64_t v74 = 512LL;
  char v75 = 0;
  sg_vec::sg_vec(v78, &v71);
  uint64_t v15 = (std::__shared_weak_count *)*((void *)&v71 + 1);
  if (*((void *)&v71 + 1))
  {
    unint64_t v16 = (unint64_t *)(*((void *)&v71 + 1) + 8LL);
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  v18.n128_f64[0] = sg_vec_ref::end((sg_vec_ref *)v83, (uint64_t)&v71);
  unint64_t v19 = *((void *)a3 + 15);
  unint64_t v20 = v77;
  char v21 = v76;
  if (v76)
  {
    p_shared_owners = (unint64_t *)&v76->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v21->__on_zero_shared)(v21, v18);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  uint64_t v24 = (std::__shared_weak_count *)*((void *)&v71 + 1);
  if (*((void *)&v71 + 1))
  {
    unint64_t v25 = (unint64_t *)(*((void *)&v71 + 1) + 8LL);
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v24->__on_zero_shared)(v24, v18);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  if (v20 > v19)
  {
    char v64 = __cxa_allocate_exception(0x40uLL);
    *char v64 = off_18A1E43B0;
    char v65 = std::generic_category();
    v64[1] = 152LL;
    v64[2] = v65;
    *((_BYTE *)v64 + 24) = 0;
    *((_BYTE *)v64 + 48) = 0;
    v64[7] = "Metadata offset is invalid";
  }

  sg_vec_ref::begin((sg_vec_ref *)v83, (uint64_t)&v71);
  sg_vec_ref::end((sg_vec_ref *)v83, (uint64_t)&v68);
  uint64_t v27 = di_asif::details::dir::do_io( a3,  a2,  (const sg_vec_ns::details::sg_vec_iterator *)&v71,  (const sg_vec_ns::details::sg_vec_iterator *)&v68,  1);
  uint64_t v28 = v70;
  if (v70)
  {
    unint64_t v29 = (unint64_t *)&v70->__shared_owners_;
    do
      unint64_t v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }

  unint64_t v31 = v69;
  if (v69)
  {
    unint64_t v32 = (unint64_t *)&v69->__shared_owners_;
    do
      unint64_t v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }

  uint64_t v34 = v76;
  if (v76)
  {
    size_t v35 = (unint64_t *)&v76->__shared_owners_;
    do
      unint64_t v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }

  uint64_t v37 = (std::__shared_weak_count *)*((void *)&v71 + 1);
  if (!*((void *)&v71 + 1)) {
    goto LABEL_45;
  }
  uint64_t v38 = (unint64_t *)(*((void *)&v71 + 1) + 8LL);
  do
    unint64_t v39 = __ldaxr(v38);
  while (__stlxr(v39 - 1, v38));
  if (!v39)
  {
    ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
    std::__shared_weak_count::__release_weak(v37);
    if ((v27 & 0x8000000000000000LL) == 0) {
      goto LABEL_47;
    }
  }

  else
  {
LABEL_45:
    if ((v27 & 0x8000000000000000LL) == 0) {
      goto LABEL_47;
    }
  }

  if ((_DWORD)v27)
  {
    __int128 v66 = __cxa_allocate_exception(0x40uLL);
    void *v66 = off_18A1E43B0;
    uint64_t v67 = std::generic_category();
    v66[1] = v27;
    v66[2] = v67;
    *((_BYTE *)v66 + 24) = 0;
    *((_BYTE *)v66 + 48) = 0;
    v66[7] = "ASIF meta header failed to read";
  }

LABEL_47:
  di_asif::meta_header::init(this, v90, a3);
  for (uint64_t i = 28LL; i != 512; ++i)
  {
    if (v90[i])
    {
      __int128 v60 = __cxa_allocate_exception(0x40uLL);
      *__int128 v60 = off_18A1E43B0;
      uint64_t v61 = std::generic_category();
      v60[1] = 152LL;
      v60[2] = v61;
      *((_BYTE *)v60 + 24) = 0;
      *((_BYTE *)v60 + 48) = 0;
      v60[7] = "ASIF meta header trailer isn't equal to zero";
    }
  }

  uint64_t v41 = v89;
  if (v89)
  {
    unint64_t v42 = (unint64_t *)&v89->__shared_owners_;
    do
      unint64_t v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }

  pthread_t v44 = v88;
  if (v88)
  {
    unint64_t v45 = (unint64_t *)&v88->__shared_owners_;
    do
      unint64_t v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }

  unint64_t v47 = v87;
  if (v87)
  {
    unint64_t v48 = (unint64_t *)&v87->__shared_owners_;
    do
      unint64_t v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }

  uint64_t v50 = v86;
  if (v86)
  {
    unint64_t v51 = (unint64_t *)&v86->__shared_owners_;
    do
      unint64_t v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }

  __int128 v53 = v85;
  if (v85)
  {
    int v54 = (unint64_t *)&v85->__shared_owners_;
    do
      unint64_t v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }

  unsigned __int8 v56 = v84;
  if (v84)
  {
    uint64_t v57 = (unint64_t *)&v84->__shared_owners_;
    do
      unint64_t v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }

  if (v81 && &v82 != __p) {
    operator delete(__p);
  }
  boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)v78);
  std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v90);
  return this;
}

      unint64_t v32 = v4 + 7;
      do
      {
        unint64_t v33 = v19;
        if (v19 >= 1)
        {
          if (*(v32 - 5) >= v19) {
            unint64_t v33 = v19;
          }
          else {
            unint64_t v33 = *(v32 - 5);
          }
        }

        uint64_t v34 = *v32;
        *(_DWORD *)uint64_t v34 = v33;
        *(_BYTE *)(v34 + 4) = 1;
        lw_promise<int>::notify_future((uint64_t)v32);
        v19 -= v33 & ~(v33 >> 63);
        size_t v35 = v32 + 8;
        unint64_t v36 = v32 + 1;
        v32 += 8;
      }

      while ((unint64_t)v36 <= v8);
      if (*((void *)&v42 + 1))
      {
        if (v43 != (void *)v41) {
          operator delete(v41);
        }
      }

      size_t v4 = v35 - 7;
      __n128 v3 = (void *)v2[8];
      uint64_t v1 = v2[9];
      if (v35 - 7 == &v3[8 * v1]) {
        return boost::container::vector<FileLocal::promise_io_t,boost::container::small_vector_allocator<FileLocal::promise_io_t,boost::container::new_allocator<void>,void>,void>::priv_destroy_all(v37);
      }
    }
  }

  return this;
}

void sub_1880F4F70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
}

uint64_t di_asif::meta_header::init(di_asif::meta_header *this, const char *a2, di_asif::details::dir *a3)
{
  int v6 = *(_DWORD *)a2;
  int v14 = 1635018093;
  smart_enums::validators::value<unsigned int>((uint64_t)"header_signature", v6, &v14, 1LL);
  *(_DWORD *)this = 1635018093;
  int v7 = bswap32(*((_DWORD *)a2 + 1));
  int v15 = 1;
  smart_enums::validators::value<unsigned int>((uint64_t)"version_t", v7, &v15, 1LL);
  *((_DWORD *)this + 1) = 1;
  int v8 = bswap32(*((_DWORD *)a2 + 2));
  int v16 = 512;
  uint64_t result = smart_enums::validators::value<unsigned int>((uint64_t)"header_size_t", v8, &v16, 1LL);
  *((_DWORD *)this + 2) = 512;
  unint64_t v10 = bswap64(*(void *)(a2 + 12));
  *(void *)((char *)this + 12) = v10;
  *(void *)((char *)this + 20) = bswap64(*(void *)(a2 + 20));
  if (v10 > (unint64_t)*((unsigned int *)a3 + 5) - 512)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    uint64_t v12 = "ASIF meta header size exceeds its maximum";
    goto LABEL_6;
  }

  if (v10 % *((unsigned __int16 *)a3 + 9))
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    uint64_t v12 = "ASIF meta header data is unaligned";
LABEL_6:
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, v12, 0x98u);
  }

  return result;
}

uint64_t di_asif::Metadata::read_num_blocks(di_asif::Metadata *this, di_asif::details::ContextASIF *a2)
{
  if (!*(void *)(*(void *)this + 72LL)) {
    return 0LL;
  }
  di_asif::Metadata::read_metadata_headers(this, a2, (uint64_t)&v4);
  uint64_t v2 = 0x6DB6DB6DB6DB6DB7LL * ((v5 - v4) >> 2);
  if (v4)
  {
    uint64_t v5 = v4;
    operator delete(v4);
  }

  return v2;
}

di_asif::meta_header *di_asif::Metadata::read_metadata_headers@<X0>( di_asif::Metadata *this@<X0>, di_asif::details::ContextASIF *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  int v6 = (unsigned int *)*((void *)this + 1);
  unint64_t v16 = *(void *)(*(void *)this + 72LL) * v6[5];
  uint64_t result = std::vector<di_asif::meta_header>::__emplace_back_slow_path<di_asif::details::ContextASIF &,di_asif::details::dir &,unsigned long long>( (di_asif::meta_header **)a3,  a2,  (di_asif::details::dir *)v6,  (uint64_t *)&v16);
LABEL_2:
  for (uint64_t i = result; ; *(void *)(a3 + 8) = i)
  {
    *(void *)(a3 + 8) = i;
    uint64_t v9 = *((void *)i - 1);
    if (!v9) {
      break;
    }
    uint64_t v11 = *(void *)this;
    uint64_t v10 = *((void *)this + 1);
    unint64_t v12 = v9 * *(unsigned int *)(v10 + 20);
    unint64_t v16 = v12;
    uint64_t v13 = *(unsigned __int16 *)(v10 + 18);
    if (v12 < *(void *)(v11 + 48) * v13 || *(void *)(v11 + 56) * v13 <= v12)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = off_18A1E43B0;
      int v15 = std::generic_category();
      exception[1] = 152LL;
      exception[2] = v15;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 48) = 0;
      exception[7] = "ASIF: metadata header out of range";
    }

    if ((unint64_t)i >= *(void *)(a3 + 16))
    {
      uint64_t result = std::vector<di_asif::meta_header>::__emplace_back_slow_path<di_asif::details::ContextASIF &,di_asif::details::dir &,unsigned long long const&>( (di_asif::meta_header **)a3,  a2,  (di_asif::details::dir *)v10,  (uint64_t *)&v16);
      goto LABEL_2;
    }

    uint64_t result = di_asif::meta_header::meta_header(i, a2, (di_asif::details::dir *)v10, v12);
    uint64_t i = (di_asif::meta_header *)((char *)i + 28);
  }

  return result;
}

void sub_1880F52C8(_Unwind_Exception *exception_object)
{
  __n128 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void di_asif::Metadata::read( di_asif::details::dir **this@<X0>, di_asif::details::ContextASIF *a2@<X1>, CFMutableDictionaryRef *a3@<X8>)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  if (!*((void *)*this + 9))
  {
    keys = @"internal metadata";
    uint64_t v63 = @"user metadata";
    cf::make_empty_dict((CFMutableDictionaryRef *)&v53);
    cf::make_empty_dict((CFMutableDictionaryRef *)&v56);
    values = v53;
    BOOL v59 = v56;
    cf::make_dict((const void **)&keys, (const void **)&values, 2LL, a3);
    CFAutoRelease<__CFDictionary *>::~CFAutoRelease((const void **)&v56);
    CFAutoRelease<__CFDictionary *>::~CFAutoRelease((const void **)&v53);
    return;
  }

  di_asif::Metadata::read_metadata_entries((di_asif::Metadata *)this, a2, (uint64_t *)&v56);
  int v6 = (uint64_t *)v56;
  int v7 = v57;
  if (v56 == (std::__shared_weak_count *)v57)
  {
LABEL_65:
    int v41 = 0;
    goto LABEL_66;
  }

  do
  {
    sg_vec::sg_vec((uint64_t *)&keys, v6);
    int v8 = this[1];
    sg_vec_ref::begin((sg_vec_ref *)v67, (uint64_t)&values);
    sg_vec_ref::end((sg_vec_ref *)v67, (uint64_t)&v53);
    uint64_t v9 = di_asif::details::dir::do_io( v8,  a2,  (const sg_vec_ns::details::sg_vec_iterator *)&values,  (const sg_vec_ns::details::sg_vec_iterator *)&v53,  1);
    uint64_t v10 = v55;
    if (v55)
    {
      p_shared_owners = (unint64_t *)&v55->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    uint64_t v13 = v54;
    if (v54)
    {
      int v14 = (unint64_t *)&v54->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    unint64_t v16 = v61;
    if (v61)
    {
      unint64_t v17 = (unint64_t *)&v61->__shared_owners_;
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    unint64_t v19 = v59;
    if (!v59) {
      goto LABEL_22;
    }
    unint64_t v20 = (unint64_t *)&v59->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
      if ((v9 & 0x8000000000000000LL) == 0) {
        goto LABEL_24;
      }
    }

    else
    {
LABEL_22:
      if ((v9 & 0x8000000000000000LL) == 0) {
        goto LABEL_24;
      }
    }

    if ((_DWORD)v9)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = off_18A1E43B0;
      uint64_t v50 = std::generic_category();
      exception[1] = v9;
      exception[2] = v50;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 48) = 0;
      exception[7] = "ASIF: failed to deserialize metadata";
    }

void sub_1880F5810( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, const void *a29)
{
}

const void **di_asif::Metadata::default_metadata@<X0>(CFMutableDictionaryRef *a1@<X8>)
{
  keys[2] = *(void **)MEMORY[0x1895F89C0];
  keys[0] = @"internal metadata";
  keys[1] = @"user metadata";
  cf::make_empty_dict((CFMutableDictionaryRef *)&v5);
  cf::make_empty_dict((CFMutableDictionaryRef *)&v4);
  values[0] = v5;
  values[1] = v4;
  cf::make_dict((const void **)keys, (const void **)values, 2LL, a1);
  CFAutoRelease<__CFDictionary *>::~CFAutoRelease((const void **)&v4);
  return CFAutoRelease<__CFDictionary *>::~CFAutoRelease((const void **)&v5);
}

void sub_1880F5AF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  __n128 v3 = va_arg(va1, const void *);
  CFAutoRelease<__CFDictionary *>::~CFAutoRelease((const void **)va);
  CFAutoRelease<__CFDictionary *>::~CFAutoRelease((const void **)va1);
  _Unwind_Resume(a1);
}

void di_asif::Metadata::read_metadata_entries( di_asif::Metadata *this@<X0>, di_asif::details::ContextASIF *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  di_asif::Metadata::read_metadata_headers(this, a2, (uint64_t)&v26);
  uint64_t v5 = v27;
  if (v27 != v26)
  {
    unint64_t v6 = 0LL;
    uint64_t v5 = v26;
    do
    {
      size_t v7 = *(void *)&v5[28 * v6 + 12];
      size_t v25 = v7;
      int v8 = (std::__shared_weak_count_vtbl *)valloc(v7);
      if (!v8)
      {
        exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
        unint64_t v21 = std::bad_alloc::bad_alloc(exception);
        __cxa_throw(v21, MEMORY[0x189614708], MEMORY[0x189614690]);
      }

      uint64_t v9 = v8;
      unint64_t v23 = v8;
      uint64_t v10 = (std::__shared_weak_count *)operator new(0x20uLL);
      v10->__shared_owners_ = 0LL;
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      v10->__vftable = (std::__shared_weak_count_vtbl *)off_18A1E27A8;
      v10->__shared_weak_owners_ = 0LL;
      v10[1].__vftable = v9;
      unint64_t v24 = v10;
      uint64_t v12 = *(unsigned int *)(*((void *)this + 1) + 20LL);
      uint64_t v13 = *(void *)(*(void *)this + 72LL) * v12 + 512;
      uint64_t v22 = v13;
      if (v6)
      {
        uint64_t v13 = *(void *)&v5[28 * v6 - 8] * v12 + 512;
        uint64_t v22 = v13;
      }

      unint64_t v14 = a3[1];
      if (v14 >= a3[2])
      {
        uint64_t v16 = std::vector<sg_entry>::__emplace_back_slow_path<std::shared_ptr<char> const,Wrapper<unsigned long long,std::integral_constant<BOOL,true>,be_type> const&,unsigned long long &,Wrapper<unsigned long long,std::integral_constant<BOOL,true>,be_type> const&>( a3,  &v23,  (uint64_t *)&v25,  &v22,  (uint64_t *)&v25);
      }

      else
      {
        *(void *)unint64_t v14 = v9;
        *(void *)(v14 + 8) = v10;
        do
          unint64_t v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
        *(void *)(v14 + 16) = v7;
        *(void *)(v14 + 24) = v13;
        *(void *)(v14 + 32) = v7;
        uint64_t v16 = v14 + 48;
        *(_BYTE *)(v14 + 40) = 0;
      }

      a3[1] = v16;
      unint64_t v17 = v24;
      if (v24)
      {
        unint64_t v18 = (unint64_t *)&v24->__shared_owners_;
        do
          unint64_t v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }

      ++v6;
      uint64_t v5 = v26;
    }

    while (v6 < 0x6DB6DB6DB6DB6DB7LL * ((v27 - v26) >> 2));
  }

  if (v5)
  {
    unint64_t v27 = v5;
    operator delete(v5);
  }

void sub_1880F5CE8( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
}

void sub_1880F5D18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14, void **a15)
{
  if (a14)
  {
    a15 = a14;
    operator delete(a14);
  }

  std::vector<sg_entry>::__destroy_vector::operator()[abi:ne180100](&a14);
  _Unwind_Resume(a1);
}

void *di_log::logger<di_log::log_printer<2831ul>>::logger(void *a1, __int128 *a2)
{
  __n128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<2831ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E2370;
  a1[45] = &unk_18A1E2470;
  a1[46] = &unk_18A1E2498;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E2370;
  a1[45] = &unk_18A1E23F8;
  a1[46] = &unk_18A1E2420;
  return a1;
}

void sub_1880F5DD4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<2831ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<2828ul>>::logger(void *a1, __int128 *a2)
{
  __n128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<2828ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E2590;
  a1[45] = &unk_18A1E2690;
  a1[46] = &unk_18A1E26B8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E2590;
  a1[45] = &unk_18A1E2618;
  a1[46] = &unk_18A1E2640;
  return a1;
}

void sub_1880F5EBC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<2828ul>>::~logger(uint64_t a1)
{
  return a1;
}

const void **di_asif::Metadata::write( const void **result, di_asif::details::ContextASIF *a2, CFPropertyListRef propertyList, Backend **a4)
{
  v113[4] = *MEMORY[0x1895F89C0];
  if (propertyList)
  {
    unint64_t v6 = (di_asif::details::dir **)result;
    size_t v7 = *result;
    int v8 = (unsigned int *)result[1];
    unint64_t v9 = v8[5];
    unint64_t v10 = *((void *)*result + 9) * v9;
    uint64_t v11 = *((unsigned __int16 *)v8 + 9);
    if (!v10) {
      unint64_t v10 = (v7[7] * v11 - v9) / v9 * v9;
    }
    if (v10 < v7[6] * v11)
    {
      exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
      DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Not enough space for metadata", 0x1Cu);
    }

    cf::serialize_to_xml_plist(propertyList, (const __CFData **)v100);
    unint64_t v12 = (unint64_t)v100[1];
    CFTypeRef cf = v100[0];
    v100[0] = 0LL;
    CFAutoRelease<__CFData const*>::~CFAutoRelease(v100);
    uint64_t v13 = *v6;
    unint64_t v14 = v6[1];
    uint64_t v15 = *((unsigned int *)v14 + 5);
    size_t v16 = v15 - 512;
    unint64_t v17 = v12 + v15 - 512 - 1;
    unint64_t v18 = v17 / (v15 - 512);
    if (v18 * v15 > v10 + v15 - *((void *)*v6 + 6) * *((unsigned __int16 *)v14 + 9))
    {
      uint64_t v81 = __cxa_allocate_exception(0x40uLL);
      *uint64_t v81 = off_18A1E43B0;
      uint64_t v82 = std::generic_category();
      v81[1] = 28LL;
      v81[2] = v82;
      *((_BYTE *)v81 + 24) = 0;
      *((_BYTE *)v81 + 48) = 0;
      v81[7] = "Not enough space for metadata";
    }

    if (v16 <= v17)
    {
      unint64_t v85 = a4;
      uint64_t v19 = 0LL;
      unint64_t v20 = v18 - 1;
      unint64_t v88 = v10;
      if (v18 <= 1) {
        unint64_t v18 = 1LL;
      }
      unint64_t v86 = v18;
      unint64_t v87 = v20;
      while (1)
      {
        if (v19 == v20)
        {
          uint64_t v21 = 0LL;
          uint64_t v22 = v6[1];
          uint64_t v23 = v10 - v20 * *((unsigned int *)v22 + 5);
          size_t v24 = v12 % v16;
        }

        else
        {
          uint64_t v22 = v6[1];
          unint64_t v25 = *((unsigned int *)v22 + 5);
          uint64_t v23 = v10 - v19 * v25;
          uint64_t v21 = (v23 - v25) / v25;
          size_t v24 = v16;
        }

        size_t v26 = v24 - 1;
        di_asif::meta_header::meta_header( (di_asif::meta_header *)v98,  (v24 - 1 + *((unsigned __int16 *)v22 + 9)) / *((unsigned __int16 *)v22 + 9) * *((unsigned __int16 *)v22 + 9),  v21);
        di_asif::meta_header::write_header((di_asif::meta_header *)v98, a2, v6[1], v23);
        if (v12 - v24 >= v19 * v16) {
          unint64_t v27 = v19 * v16;
        }
        else {
          unint64_t v27 = v12 - v24;
        }
        unint64_t v28 = *((unsigned __int16 *)v6[1] + 9);
        unint64_t v29 = (char *)valloc((v26 + v28) / v28 * v28);
        if (!v29)
        {
          char v75 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
          uint64_t v76 = std::bad_alloc::bad_alloc(v75);
          __cxa_throw(v76, MEMORY[0x189614708], MEMORY[0x189614690]);
        }

        v100[0] = off_18A1DFDC8;
        unint64_t v101 = v100;
        unint64_t v112 = v29;
        std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)v113, (uint64_t)v100);
        unint64_t v30 = v101;
        if (v101 == v100)
        {
          unint64_t v30 = v100;
          uint64_t v31 = 4LL;
        }

        else
        {
          if (!v101) {
            goto LABEL_22;
          }
          uint64_t v31 = 5LL;
        }

        (*((void (**)(void))*v30 + v31))();
LABEL_22:
        unint64_t v32 = v112;
        BytePtr = CFDataGetBytePtr((CFDataRef)cf);
        memcpy(v32, &BytePtr[v27], v24);
        unint64_t v34 = *((unsigned __int16 *)v6[1] + 9);
        if (v24 % v34)
        {
          bzero(&v112[v24], v34 - v24 % v34);
          unint64_t v34 = *((unsigned __int16 *)v6[1] + 9);
        }

        uint64_t v35 = (uint64_t)v112;
        uint64_t v36 = *((void *)details::get_dummy_shared_ptr() + 1);
        *(void *)&__int128 v92 = v35;
        *((void *)&v92 + 1) = v36;
        if (v36)
        {
          uint64_t v37 = (unint64_t *)(v36 + 8);
          do
            unint64_t v38 = __ldxr(v37);
          while (__stxr(v38 + 1, v37));
        }

        size_t v93 = (v26 + v34) / v34 * v34;
        uint64_t v94 = v23 + 512;
        size_t v95 = v93;
        char v96 = 0;
        sg_vec::sg_vec((uint64_t *)v100, &v92);
        unint64_t v39 = (std::__shared_weak_count *)*((void *)&v92 + 1);
        if (*((void *)&v92 + 1))
        {
          uint64_t v40 = (unint64_t *)(*((void *)&v92 + 1) + 8LL);
          do
            unint64_t v41 = __ldaxr(v40);
          while (__stlxr(v41 - 1, v40));
          if (!v41)
          {
            ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
            std::__shared_weak_count::__release_weak(v39);
          }
        }

        CFIndex v42 = v6[1];
        sg_vec_ref::begin((sg_vec_ref *)v105, (uint64_t)&v92);
        sg_vec_ref::end((sg_vec_ref *)v105, (uint64_t)v89);
        uint64_t v43 = di_asif::details::dir::do_io( v42,  a2,  (const sg_vec_ns::details::sg_vec_iterator *)&v92,  (const sg_vec_ns::details::sg_vec_iterator *)v89,  0);
        pthread_t v44 = v91;
        if (v91)
        {
          p_shared_owners = (unint64_t *)&v91->__shared_owners_;
          do
            unint64_t v46 = __ldaxr(p_shared_owners);
          while (__stlxr(v46 - 1, p_shared_owners));
          if (!v46)
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
        }

        unint64_t v47 = v90;
        if (v90)
        {
          int v48 = (unint64_t *)&v90->__shared_owners_;
          do
            unint64_t v49 = __ldaxr(v48);
          while (__stlxr(v49 - 1, v48));
          if (!v49)
          {
            ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
            std::__shared_weak_count::__release_weak(v47);
          }
        }

        uint64_t v50 = v97;
        if (v97)
        {
          unint64_t v51 = (unint64_t *)&v97->__shared_owners_;
          do
            unint64_t v52 = __ldaxr(v51);
          while (__stlxr(v52 - 1, v51));
          if (!v52)
          {
            ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
            std::__shared_weak_count::__release_weak(v50);
          }
        }

        __int128 v53 = (std::__shared_weak_count *)*((void *)&v92 + 1);
        if (!*((void *)&v92 + 1)) {
          goto LABEL_51;
        }
        int v54 = (unint64_t *)(*((void *)&v92 + 1) + 8LL);
        do
          unint64_t v55 = __ldaxr(v54);
        while (__stlxr(v55 - 1, v54));
        if (!v55)
        {
          ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
          std::__shared_weak_count::__release_weak(v53);
          if (v43 < 0)
          {
LABEL_52:
            if ((_DWORD)v43)
            {
              unint64_t v77 = __cxa_allocate_exception(0x40uLL);
              *unint64_t v77 = off_18A1E43B0;
              unint64_t v78 = std::generic_category();
              v77[1] = v43;
              v77[2] = v78;
              *((_BYTE *)v77 + 24) = 0;
              *((_BYTE *)v77 + 48) = 0;
              v77[7] = "Failed to write metadata";
            }
          }
        }

        else
        {
LABEL_51:
          if (v43 < 0) {
            goto LABEL_52;
          }
        }

        unsigned __int8 v56 = v111;
        if (v111)
        {
          uint64_t v57 = (unint64_t *)&v111->__shared_owners_;
          do
            unint64_t v58 = __ldaxr(v57);
          while (__stlxr(v58 - 1, v57));
          if (!v58)
          {
            ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
            std::__shared_weak_count::__release_weak(v56);
          }
        }

        BOOL v59 = v110;
        if (v110)
        {
          __int128 v60 = (unint64_t *)&v110->__shared_owners_;
          do
            unint64_t v61 = __ldaxr(v60);
          while (__stlxr(v61 - 1, v60));
          if (!v61)
          {
            ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
            std::__shared_weak_count::__release_weak(v59);
          }
        }

        uint64_t v62 = v109;
        if (v109)
        {
          uint64_t v63 = (unint64_t *)&v109->__shared_owners_;
          do
            unint64_t v64 = __ldaxr(v63);
          while (__stlxr(v64 - 1, v63));
          if (!v64)
          {
            ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
            std::__shared_weak_count::__release_weak(v62);
          }
        }

        uint64_t v65 = v108;
        if (v108)
        {
          uint64_t v66 = (unint64_t *)&v108->__shared_owners_;
          do
            unint64_t v67 = __ldaxr(v66);
          while (__stlxr(v67 - 1, v66));
          if (!v67)
          {
            ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
            std::__shared_weak_count::__release_weak(v65);
          }
        }

        uint64_t v68 = v107;
        if (v107)
        {
          uint64_t v69 = (unint64_t *)&v107->__shared_owners_;
          do
            unint64_t v70 = __ldaxr(v69);
          while (__stlxr(v70 - 1, v69));
          if (!v70)
          {
            ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
            std::__shared_weak_count::__release_weak(v68);
          }
        }

        __int128 v71 = v106;
        if (v106)
        {
          uint64_t v72 = (unint64_t *)&v106->__shared_owners_;
          do
            unint64_t v73 = __ldaxr(v72);
          while (__stlxr(v73 - 1, v72));
          if (!v73)
          {
            ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
            std::__shared_weak_count::__release_weak(v71);
          }
        }

        if (v103 && &v104 != __p) {
          operator delete(__p);
        }
        boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)v100);
        std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v112);
        ++v19;
        unint64_t v20 = v87;
        unint64_t v10 = v88;
        if (v19 == v86)
        {
          uint64_t v13 = *v6;
          a4 = v85;
          break;
        }
      }
    }

    if (!*((void *)v13 + 9))
    {
      *((void *)v13 + 9) = v10 / *((unsigned int *)v6[1] + 5);
      unsigned int v74 = di_asif::header::write_header(v13, *a4);
      if (v74)
      {
        unint64_t v83 = __cxa_allocate_exception(0x40uLL);
        *unint64_t v83 = off_18A1E43B0;
        unint64_t v84 = std::generic_category();
        v83[1] = v74;
        v83[2] = v84;
        *((_BYTE *)v83 + 24) = 0;
        *((_BYTE *)v83 + 48) = 0;
        v83[7] = "Failed to update asif header";
      }
    }

    return CFAutoRelease<__CFData const*>::~CFAutoRelease(&cf);
  }

  return result;
}

void sub_1880F6684( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,const void *a61,const void *a62)
{
}

void DiskImageASIF::get_used_extents(DiskImageASIF *this@<X0>, void *a2@<X8>)
{
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  unint64_t v14 = (uint64_t *)&v15;
  if (*(void *)di_asif::header::get_dir_offset((DiskImageASIF *)((char *)this + 32), *((void *)this + 22)))
  {
    size_t v4 = (di_asif::details::ContextASIF *)(*(uint64_t (**)(DiskImageASIF *))(*(void *)this + 136LL))(this);
    uint64_t v5 = *((void *)this + 44);
    uint64_t v6 = *((void *)this + 45);
    if (v5 != v6)
    {
      uint64_t v7 = 0LL;
      int v8 = 0LL;
      do
      {
        unint64_t v9 = *(void *)(v5 + 8LL * (void)v8) * *((unsigned int *)this + 24);
        unint64_t v13 = v9;
        if (v9)
        {
          di_asif::details::dir::get_extents_for_table<std::insert_iterator<std::set<unsigned long long>>>( (uint64_t)this + 200,  v4,  v8,  v9,  (uint64_t)&v14,  (uint64_t)v14);
          std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long &>( &v14,  &v13,  (uint64_t *)&v13);
        }

        int v8 = (ref::details **)((char *)v8 + 1);
        v7 += 8LL;
      }

      while (v5 + v7 != v6);
    }

    unint64_t v10 = v15;
    *a2 = v14;
    a2[1] = v10;
    uint64_t v11 = a2 + 1;
    uint64_t v12 = v16;
    a2[2] = v16;
    if (v12)
    {
      void v10[2] = v11;
      unint64_t v14 = (uint64_t *)&v15;
      uint64_t v15 = 0LL;
      uint64_t v16 = 0LL;
      if (!v4) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }

    *a2 = v11;
    if (v4) {
LABEL_12:
    }
      (*(void (**)(di_asif::details::ContextASIF *))(*(void *)v4 + 40LL))(v4);
  }

  else
  {
    a2[2] = 0LL;
    a2[1] = 0LL;
    *a2 = a2 + 1;
  }

void sub_1880F6878( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

unint64_t *di_asif::details::dir::get_extents_for_table<std::insert_iterator<std::set<unsigned long long>>>( uint64_t a1, di_asif::details::ContextASIF *a2, ref::details **a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  if (v11 && !v11[520])
  {
    if (v11[400]) {
      unint64_t v9 = (di_asif::details::table *)(v11 + 40);
    }
    else {
      unint64_t v9 = 0LL;
    }
    di_asif::details::table::get_table_extents<std::insert_iterator<std::set<unsigned long long>>>( v9,  (uint64_t)a2,  a5,  a6);
  }

  return ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v11);
}

void sub_1880F693C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *DiskImageASIF::insert_free_extents_to_allocator( void *result, void *a2, unint64_t a3, unsigned int a4)
{
  uint64_t v7 = result;
  if (a2[2])
  {
    int v8 = a2 + 1;
    unint64_t v9 = (void *)a2[1];
    if (v9)
    {
      do
      {
        unint64_t v10 = v9;
        unint64_t v9 = (void *)v9[1];
      }

      while (v9);
    }

    else
    {
      do
      {
        unint64_t v10 = (void *)v8[2];
        BOOL v11 = *v10 == (void)v8;
        int v8 = v10;
      }

      while (v11);
    }

    unint64_t v12 = v10[4] + a4;
    uint64_t result = (void *)(*(uint64_t (**)(void *))(result[25] + 16LL))(result + 25);
    if (result[12] <= v12) {
      result[12] = v12;
    }
  }

  uint64_t v15 = (void *)*a2;
  unint64_t v13 = a2 + 1;
  unint64_t v14 = v15;
  if (v15 != v13)
  {
    uint64_t v16 = (uint64_t)(v7 + 25);
    unint64_t v17 = v7 + 26;
    do
    {
      uint64_t v18 = v14[4];
      do
        unint64_t v19 = __ldaxr(v17);
      while (__stlxr(v19 + 1, v17));
      __int128 v24 = a3;
      uint64_t v25 = a4;
      if ((v18 - a3) % a4) {
        unint64_t v20 = (v18 - a3) / a4 + 1;
      }
      else {
        unint64_t v20 = (v18 - a3) / a4;
      }
      v23[0] = a3;
      v23[1] = v20;
      v23[2] = a4;
      uint64_t result = di_asif::details::dir::insert_space_no_update<boost::range_detail::integer_iterator_with_step<unsigned long long>>( v16,  &v24,  (uint64_t)v23);
      uint64_t v21 = (void *)v14[1];
      if (v21)
      {
        do
        {
          uint64_t v22 = v21;
          uint64_t v21 = (void *)*v21;
        }

        while (v21);
      }

      else
      {
        do
        {
          uint64_t v22 = (void *)v14[2];
          BOOL v11 = *v22 == (void)v14;
          unint64_t v14 = v22;
        }

        while (!v11);
      }

      a3 = v18 + a4;
      unint64_t v14 = v22;
    }

    while (v22 != v13);
  }

  return result;
}

void *di_asif::details::dir::insert_space_no_update<boost::range_detail::integer_iterator_with_step<unsigned long long>>( uint64_t a1, __int128 *a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  __int128 v10 = *a2;
  uint64_t v11 = *((void *)a2 + 2);
  __int128 v8 = *(_OWORD *)a3;
  uint64_t v9 = *(void *)(a3 + 16);
  unint64_t v13 = 0LL;
  space_allocators::FixedSize::insert<boost::range_detail::integer_iterator_with_step<unsigned long long>>( v5,  (uint64_t *)&v10,  &v8,  (uint64_t)v12);
  uint64_t result = v13;
  if (v13 == v12)
  {
    uint64_t v7 = 4LL;
    uint64_t result = v12;
  }

  else
  {
    if (!v13) {
      return result;
    }
    uint64_t v7 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

void sub_1880F6B60( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19)
{
  uint64_t v21 = a19;
  if (a19 == v19)
  {
    uint64_t v22 = 4LL;
    uint64_t v21 = &a16;
  }

  else
  {
    if (!a19) {
      goto LABEL_6;
    }
    uint64_t v22 = 5LL;
  }

  (*(void (**)(void))(*(void *)v21 + 8 * v22))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t DiskImageASIF::DiskImageASIF( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t (***a5)(), uint64_t *a6)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  *(_BYTE *)(a1 + 8) = 0;
  *(void *)a1 = &off_18A1DF2C8;
  *(void *)(a1 + 16) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 24) = v11;
  if (v11)
  {
    unint64_t v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  *(_DWORD *)(a1 + 32) = 2003069043;
  *(void *)(a1 + 36) = *(void *)(a3 + 4);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a3 + 12);
  __int128 v14 = *(_OWORD *)(a3 + 16);
  __int128 v15 = *(_OWORD *)(a3 + 32);
  __int128 v16 = *(_OWORD *)(a3 + 48);
  *(void *)(a1 + 94) = *(void *)(a3 + 62);
  *(_OWORD *)(a1 + 64) = v15;
  *(_OWORD *)(a1 + 80) = v16;
  *(_OWORD *)(a1 + 48) = v14;
  *(_WORD *)(a1 + 102) = 0;
  *(void *)(a1 + 104) = *(void *)(a3 + 72);
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v49 + 112) = 850045863LL;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(void *)(a1 + 168) = 0LL;
  *(void *)(a1 + 176) = a4;
  uint64_t v17 = *a6;
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a6 + 2);
  *(void *)(a1 + 184) = v17;
  uint64_t v18 = *(void *)(a3 + 56);
  uint64_t v19 = *(unsigned __int16 *)(a3 + 68);
  unsigned int v20 = *(_DWORD *)(a3 + 64);
  uint64_t v21 = *a2;
  unint64_t v33 = off_18A1E2808;
  unint64_t v34 = (void *)a1;
  uint64_t v35 = &v33;
  di_asif::details::dir::dir(a1 + 200, a1, v18 * v19, v20, v19, a5, 2LL, v21, (uint64_t)&v33);
  uint64_t v22 = v35;
  if (v35 == &v33)
  {
    uint64_t v23 = 4LL;
    uint64_t v22 = &v33;
  }

  else
  {
    if (!v35) {
      goto LABEL_9;
    }
    uint64_t v23 = 5LL;
  }

  (*v22)[v23]();
LABEL_9:
  *(void *)(a1 + 4056) = a1 + 32;
  *(void *)(a1 + 4064) = a1 + 200;
  *(void *)(a1 + 4072) = 0LL;
  DiskImageASIF::get_used_extents((DiskImageASIF *)a1, &v33);
  unint64_t v24 = *(unsigned __int16 *)(a3 + 68);
  unint64_t v25 = *(unsigned int *)(a3 + 64);
  DiskImageASIF::insert_free_extents_to_allocator( (void *)a1,  &v33,  (v24 + v25 - ((int)v24 + 511) % v24 + 2 * (v24 + 8 * ((unint64_t)(*(void *)(a1 + 320) + *(void *)(a1 + 280) - 1LL) / *(void *)(a1 + 280)) + 7)
   / v24
   * v24
   + 510)
  / v25
  * v25,
    v25);
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::destroy( (uint64_t)&v33,  v34);
  uint64_t v26 = *(void *)(a1 + 176);
  if (v26 == 1) {
    uint64_t v27 = 0LL;
  }
  else {
    uint64_t v27 = v26 + 1;
  }
  *(void *)(a1 + 176) = v27;
  unint64_t v28 = (di_asif::details::ContextASIF *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 136LL))(a1);
  di_asif::details::dir::trim_last_unused_extents((di_asif::details::dir *)(a1 + 200), v28);
  if (!*((_BYTE *)a6 + 2))
  {
    unint64_t v29 = atomic_load((unint64_t *)(a1 + 4072));
    if (v29 != -1LL)
    {
      unint64_t v33 = (uint64_t (**)())&v31;
      unint64_t v32 = &v33;
      std::__call_once( (unint64_t *)(a1 + 4072),  &v32,  (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<DiskImageASIF::DiskImageASIF(std::shared_ptr<Backend> const&,di_asif::header const&,std::pair<unsigned long,unsigned long long>,di_asif::options const&)::$_0 &&>>);
    }
  }

  (*(void (**)(di_asif::details::ContextASIF *))(*(void *)v28 + 40LL))(v28);
  return a1;
}

void sub_1880F6E54(_Unwind_Exception *a1)
{
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 40LL))(v4);
  }
  di_asif::details::dir::~dir(v3);
  std::mutex::~mutex(v2);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t DiskImageASIF::DiskImageASIF( uint64_t a1, unsigned int a2, unsigned int a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, _OWORD *a8, __int128 *a9)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  *(_BYTE *)(a1 + 8) = 0;
  *(void *)a1 = &off_18A1DF2C8;
  *(void *)(a1 + 16) = *(void *)a6;
  uint64_t v17 = *(void *)(a6 + 8);
  *(void *)(a1 + 24) = v17;
  if (v17)
  {
    uint64_t v18 = (unint64_t *)(v17 + 8);
    do
      unint64_t v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }

  di_asif::header_flags::header_flags(&v34, *((unsigned __int8 *)a7 + 1));
  di_asif::header::header(a1 + 32, &v34, a8, a4, a5, a3, a2);
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v49 + 112) = 850045863LL;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  uint64_t v20 = *a7;
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a7 + 2);
  *(void *)(a1 + 184) = v20;
  *(void *)&__int128 v36 = off_18A1E2808;
  *((void *)&v36 + 1) = a1;
  uint64_t v37 = &v36;
  di_asif::details::dir::dir(a1 + 200, a1, a2 * a5, a3, a2, (uint64_t (***)())0x200, 2LL, 0LL, (uint64_t)&v36);
  uint64_t v21 = v37;
  if (v37 == &v36)
  {
    uint64_t v22 = 4LL;
    uint64_t v21 = &v36;
  }

  else
  {
    if (!v37) {
      goto LABEL_9;
    }
    uint64_t v22 = 5LL;
  }

  (*(void (**)(void))(*(void *)v21 + 8 * v22))();
LABEL_9:
  *(void *)(a1 + 4056) = a1 + 32;
  *(void *)(a1 + 4064) = a1 + 200;
  *(void *)(a1 + 4072) = 0LL;
  if ((a2 & 0x1FF) != 0)
  {
    unint64_t v28 = "ASIF: Block size isn't a multiple of 512";
    goto LABEL_21;
  }

  if (*(_DWORD *)(a1 + 40) <= 0x50u)
  {
    unint64_t v28 = "ASIF: Header size is less than the min header size";
LABEL_21:
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    unint64_t v30 = std::generic_category();
    exception[1] = 152LL;
    exception[2] = v30;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = v28;
  }

  if (!*((_BYTE *)a7 + 2))
  {
    unint64_t v23 = atomic_load((unint64_t *)(a1 + 4072));
    if (v23 != -1LL)
    {
      *(void *)&__int128 v36 = &v33;
      uint64_t v35 = &v36;
      std::__call_once( (unint64_t *)(a1 + 4072),  &v35,  (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<DiskImageASIF::DiskImageASIF(unsigned short,unsigned int,unsigned long long,unsigned long long,std::shared_ptr<Backend> const&,di_asif::options const&,boost::uuids::uuid const&,std::optional<boost::uuids::uuid> const&)::$_0 &&>>);
    }
  }

  unint64_t v24 = (di_utils *)di_asif::header::write_header((di_asif::header *)(a1 + 32), *(Backend **)a6);
  unsigned int v25 = v24;
  if ((_DWORD)v24)
  {
    char v31 = __cxa_allocate_exception(0x40uLL);
    *char v31 = off_18A1E43B0;
    unint64_t v32 = std::generic_category();
    v31[1] = v25;
    v31[2] = v32;
    *((_BYTE *)v31 + 24) = 0;
    *((_BYTE *)v31 + 48) = 0;
    v31[7] = "Couldn't write asif's header";
  }

  if (*((_BYTE *)a9 + 16))
  {
    __int128 v36 = *a9;
  }

  else
  {
    *(void *)&__int128 v36 = di_utils::random_uuid(v24);
    *((void *)&v36 + 1) = v26;
  }

  DiskImageASIF::internal_metadata_set_key_uuid(a1, @"stable uuid", (uint64_t)&v36);
  return a1;
}

{
  return DiskImageASIF::DiskImageASIF(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

void sub_1880F71E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
}

uint64_t DiskImageASIF::internal_metadata_set_key_uuid(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = (di_asif::details::ContextASIF *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 136LL))(a1);
  di_asif::Metadata::read((di_asif::details::dir **)(a1 + 4056), v6, &theDict);
  uint64_t v7 = CFDictionaryGetValue(theDict, @"internal metadata");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!v7)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    uint64_t v20 = std::generic_category();
    exception[1] = 152LL;
    exception[2] = v20;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "ASIF: missing internal metadata key";
  }

  if (CFGetTypeID(v7) != TypeID)
  {
    uint64_t v21 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
    CFGetTypeID(v7);
    uint64_t v22 = cf::CFUtilException::CFUtilException(v21);
  }

  CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v7);
  __int128 v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], Count + 1, (CFDictionaryRef)v7);
  value = MutableCopy;
  unint64_t v12 = "ASIF: can't copy metadata to mutable copy";
  if (!MutableCopy)
  {
    uint64_t v23 = 4294967284LL;
    goto LABEL_14;
  }

  unint64_t v13 = operator new(0x28uLL);
  __p = v13;
  __int128 v31 = xmmword_18817DE60;
  *unint64_t v13 = 0u;
  v13[1] = 0u;
  *(void *)((char *)v13 + 29) = 0LL;
  boost::uuids::to_chars<char *>(a3, v13);
  BOOL v14 = addCFStringToDict(MutableCopy, a2, (uint64_t)&__p);
  if (SHIBYTE(v31) < 0) {
    operator delete(__p);
  }
  if (!v14)
  {
    unint64_t v12 = "ASIF: can't set requested uuid";
    uint64_t v23 = 150LL;
LABEL_14:
    unint64_t v24 = __cxa_allocate_exception(0x40uLL);
    *unint64_t v24 = off_18A1E43B0;
    unsigned int v25 = std::generic_category();
    v24[1] = v23;
    v24[2] = v25;
    *((_BYTE *)v24 + 24) = 0;
    *((_BYTE *)v24 + 48) = 0;
    v24[7] = v12;
  }

  CFIndex v15 = CFDictionaryGetCount(theDict);
  CFMutableDictionaryRef v16 = CFDictionaryCreateMutableCopy(v10, v15 + 1, theDict);
  __p = v16;
  if (!v16)
  {
    uint64_t v26 = __cxa_allocate_exception(0x40uLL);
    *uint64_t v26 = off_18A1E43B0;
    uint64_t v27 = std::generic_category();
    v26[1] = 4294967284LL;
    v26[2] = v27;
    *((_BYTE *)v26 + 24) = 0;
    *((_BYTE *)v26 + 48) = 0;
    v26[7] = "ASIF: can't copy metadata to mutable copy";
  }

  CFDictionarySetValue(v16, @"internal metadata", value);
  di_asif::Metadata::write((const void **)(a1 + 4056), v6, __p, (Backend **)(a1 + 16));
  unsigned int v17 = (*(uint64_t (**)(uint64_t, di_asif::details::ContextASIF *, void))(*(void *)a1 + 176LL))( a1,  v6,  0LL);
  if (v17)
  {
    unint64_t v28 = __cxa_allocate_exception(0x40uLL);
    *unint64_t v28 = off_18A1E43B0;
    unint64_t v29 = std::generic_category();
    v28[1] = v17;
    v28[2] = v29;
    *((_BYTE *)v28 + 24) = 0;
    *((_BYTE *)v28 + 48) = 0;
    v28[7] = "ASIF: failed to write metadata";
  }

  CFAutoRelease<__CFDictionary *>::~CFAutoRelease((const void **)&__p);
  CFAutoRelease<__CFDictionary *>::~CFAutoRelease((const void **)&value);
  CFAutoRelease<__CFDictionary const*>::~CFAutoRelease((const void **)&theDict);
  return (*(uint64_t (**)(di_asif::details::ContextASIF *))(*(void *)v6 + 40LL))(v6);
}

void sub_1880F7598( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, const void *a18)
{
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 40LL))(v18);
  }
  _Unwind_Resume(a1);
}

uint64_t DiskImageASIF::get_dir_latest_offset(DiskImageASIF *this, Backend *a2, const di_asif::header *a3)
{
  uint64_t v5 = 0LL;
  int v6 = 0;
  int64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  char v9 = 1;
  do
  {
    char v10 = v9;
    uint64_t v11 = *(Backend **)di_asif::header::get_dir_offset((di_asif::header *)a2, v5);
    if (v11)
    {
      int64_t version = di_asif::details::dir::get_version((unint64_t)this, v11);
      if (!v6 || v7 < version)
      {
        int v6 = 1;
        uint64_t v8 = v5;
        int64_t v7 = version;
      }
    }

    char v9 = 0;
    uint64_t v5 = 1LL;
  }

  while ((v10 & 1) != 0);
  return v8;
}

uint64_t DiskImageASIF::void_stackable_identifier(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  __n128 v3 = (unint64_t *)(a1 + 4072);
  v6[0] = a1;
  v6[1] = &v7;
  v6[2] = a2;
  unint64_t v4 = atomic_load(v3);
  if (v4 != -1LL)
  {
    char v9 = v6;
    uint64_t v8 = &v9;
    std::__call_once( v3,  &v8,  (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<DiskImageASIF::void_stackable_identifier(std::shared_ptr<Backend> &)::$_0 &&>>);
  }

  if (v7 < 0) {
    return v7;
  }
  else {
    return -v7;
  }
}

uint64_t DiskImageASIF::flush(uint64_t a1, Backend **a2, int a3)
{
  int v6 = (std::mutex *)(a1 + 112);
  std::mutex::lock((std::mutex *)(a1 + 112));
  int v7 = *(uint64_t (****)())di_asif::header::get_dir_offset( (di_asif::header *)(a1 + 32),  *(void *)(a1 + 176));
  uint64_t v8 = v7;
  if (!v7)
  {
    unint64_t v9 = *(unsigned __int16 *)(a1 + 100);
    uint64_t v10 = *(void *)(a1 + 176);
    uint64_t v11 = *(void *)(a1 + 320);
    unint64_t v12 = *(void *)(a1 + 280);
    dir_offset = (void *)di_asif::header::get_dir_offset((di_asif::header *)(a1 + 32), v10);
    uint64_t v8 = (uint64_t (***)())(v9
                                    + 511
                                    - ((int)v9 + 511) % v9
                                    + (8 * ((v11 + v12 - 1) / v12) + v9 + 7) / v9 * v9 * v10);
    void *dir_offset = v8;
  }

  uint64_t v14 = di_asif::details::dir::flush((unint64_t **)(a1 + 200), (di_asif::details::ContextASIF *)a2, v8);
  uint64_t v15 = v14;
  if ((v14 & 0x80000000) == 0)
  {
    if ((_DWORD)v14 == 1)
    {
      uint64_t v16 = *(void *)(a1 + 176);
      if (v16 == 1) {
        uint64_t v17 = 0LL;
      }
      else {
        uint64_t v17 = v16 + 1;
      }
      *(void *)(a1 + 176) = v17;
    }

    if (v7
      || (uint64_t v15 = (*(uint64_t (**)(Backend *, void))(*(void *)a2[2] + 16LL))(a2[2], 0LL), !(_DWORD)v15)
      && (uint64_t v15 = di_asif::header::write_header((di_asif::header *)(a1 + 32), a2[2]), !(_DWORD)v15))
    {
      uint64_t v15 = (*(uint64_t (**)(Backend *, void))(*(void *)a2[2] + 16LL))(a2[2], 2 * (a3 == 2));
    }
  }

  std::mutex::unlock(v6);
  return v15;
}

void sub_1880F78A0(_Unwind_Exception *a1)
{
}

__n128 DiskImageASIF::get_extents_iterator_interface@<Q0>( unint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, __n128 *a4@<X3>, unint64_t a5@<X4>, __n128 **a6@<X8>)
{
  unint64_t v12 = a1 + 200;
  unint64_t v13 = (__n128 *)operator new(0x48uLL);
  __n128 result = *a4;
  v13[1] = *a4;
  v13[2].n128_u64[0] = a4[1].n128_u64[0];
  v13[2].n128_u64[1] = a5;
  v13[3].n128_u64[0] = a1;
  v13[3].n128_u64[1] = a3;
  v13->n128_u64[0] = (unint64_t)off_18A1DF3C8;
  v13->n128_u64[1] = a2;
  v13[4].n128_u64[0] = v12;
  *a6 = v13;
  return result;
}

uint64_t DiskImageASIF::get_user_data@<X0>(di_asif::details::dir **this@<X0>, void *a2@<X8>)
{
  unint64_t v4 = (di_asif::details::ContextASIF *)(*((uint64_t (**)(di_asif::details::dir **))*this + 17))(this);
  di_asif::Metadata::read(this + 507, v4, &theDict);
  Value = CFDictionaryGetValue(theDict, @"user metadata");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) != TypeID)
    {
      exception = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
      CFGetTypeID(Value);
      uint64_t v10 = cf::CFUtilException::CFUtilException(exception);
    }

    CFTypeID v7 = CFDictionaryGetTypeID();
    if (CFGetTypeID(Value) != v7)
    {
      uint64_t v11 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
      CFGetTypeID(Value);
      unint64_t v12 = cf::CFUtilException::CFUtilException(v11);
    }

    CFRetain(Value);
    *a2 = Value;
  }

  else
  {
    cf::make_empty_dict((CFMutableDictionaryRef *)&v13);
    *a2 = v13;
    unint64_t v13 = 0LL;
    CFAutoRelease<__CFDictionary *>::~CFAutoRelease(&v13);
  }

  CFAutoRelease<__CFDictionary const*>::~CFAutoRelease((const void **)&theDict);
  return (*(uint64_t (**)(di_asif::details::ContextASIF *))(*(void *)v4 + 40LL))(v4);
}

void sub_1880F7ABC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 40LL))(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t DiskImageASIF::write_user_data(di_asif::details::dir **this, const __CFDictionary *a2)
{
  unint64_t v4 = (di_asif::details::ContextASIF *)(*((uint64_t (**)(di_asif::details::dir **))*this + 17))(this);
  di_asif::Metadata::read(this + 507, v4, &theDict);
  if (!theDict)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    uint64_t v10 = std::generic_category();
    exception[1] = 4294967284LL;
    exception[2] = v10;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "ASIF: can't read/allocate asif metadata";
  }

  CFIndex Count = CFDictionaryGetCount(theDict);
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], Count, theDict);
  CFPropertyListRef propertyList = MutableCopy;
  if (!MutableCopy)
  {
    uint64_t v11 = __cxa_allocate_exception(0x40uLL);
    void *v11 = off_18A1E43B0;
    unint64_t v12 = std::generic_category();
    v11[1] = 4294967284LL;
    void v11[2] = v12;
    *((_BYTE *)v11 + 24) = 0;
    *((_BYTE *)v11 + 48) = 0;
    v11[7] = "ASIF: can't copy metadata to mutable copy";
  }

  CFDictionarySetValue(MutableCopy, @"user metadata", a2);
  di_asif::Metadata::write((const void **)this + 507, v4, propertyList, (Backend **)this + 2);
  unsigned int v7 = (*((uint64_t (**)(di_asif::details::dir **, di_asif::details::ContextASIF *, uint64_t))*this + 22))( this,  v4,  2LL);
  if (v7)
  {
    unint64_t v13 = __cxa_allocate_exception(0x40uLL);
    *unint64_t v13 = off_18A1E43B0;
    uint64_t v14 = std::generic_category();
    v13[1] = v7;
    v13[2] = v14;
    *((_BYTE *)v13 + 24) = 0;
    *((_BYTE *)v13 + 48) = 0;
    v13[7] = "ASIF: failed to write metadata";
  }

  CFAutoRelease<__CFDictionary *>::~CFAutoRelease(&propertyList);
  CFAutoRelease<__CFDictionary const*>::~CFAutoRelease((const void **)&theDict);
  return (*(uint64_t (**)(di_asif::details::ContextASIF *))(*(void *)v4 + 40LL))(v4);
}

void sub_1880F7CE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 40LL))(v2);
  }
  _Unwind_Resume(a1);
}

const __CFString *DiskImageASIF::internal_metadata_get_key_uuid( di_asif::details::dir **this, const __CFString *a2)
{
  unint64_t v4 = (di_asif::details::ContextASIF *)(*((uint64_t (**)(di_asif::details::dir **))*this + 17))(this);
  di_asif::Metadata::read(this + 507, v4, &theDict);
  Value = CFDictionaryGetValue(theDict, @"internal metadata");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!Value)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    unint64_t v13 = std::generic_category();
    exception[1] = 152LL;
    exception[2] = v13;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "ASIF: missing internal metadata key";
  }

  if (CFGetTypeID(Value) != TypeID)
  {
    uint64_t v14 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
    CFGetTypeID(Value);
    uint64_t v15 = cf::CFUtilException::CFUtilException(v14);
  }

  unsigned int v7 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)Value, a2);
  CFTypeID v8 = CFStringGetTypeID();
  if (v7)
  {
    if (CFGetTypeID(v7) != v8)
    {
      uint64_t v16 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
      CFGetTypeID(v7);
      uint64_t v17 = cf::CFUtilException::CFUtilException(v16);
    }

    toNativeType(v7, __p);
    unint64_t v9 = v19;
    if ((v19 & 0x80u) == 0) {
      uint64_t v10 = (unsigned __int8 *)__p;
    }
    else {
      uint64_t v10 = (unsigned __int8 *)__p[0];
    }
    if ((v19 & 0x80u) != 0) {
      unint64_t v9 = (unint64_t)__p[1];
    }
    unsigned int v7 = (const __CFString *)boost::uuids::string_generator::operator()<std::__wrap_iter<char const*>>( (boost::uuids::string_generator *)&v20,  v10,  &v10[v9]);
  }

  CFAutoRelease<__CFDictionary const*>::~CFAutoRelease((const void **)&theDict);
  (*(void (**)(di_asif::details::ContextASIF *))(*(void *)v4 + 40LL))(v4);
  return v7;
}

void sub_1880F7F24( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, const void *a17)
{
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 40LL))(v17);
  }
  _Unwind_Resume(a1);
}

uint64_t DiskImageASIF::set_stackable_source_identifier(uint64_t a1, uint64_t a2)
{
  return DiskImageASIF::internal_metadata_set_key_uuid(a1, @"source uuid", a2);
}

const __CFString *DiskImageASIF::get_stable_uuid(di_asif::details::dir **this)
{
  return DiskImageASIF::internal_metadata_get_key_uuid(this, @"stable uuid");
}

const __CFString *DiskImageASIF::get_stackable_source_identifier(di_asif::details::dir **this)
{
  return DiskImageASIF::internal_metadata_get_key_uuid(this, @"source uuid");
}

uint64_t DiskImageASIF::get_stackable_identifier(DiskImageASIF *this)
{
  return *((void *)this + 8);
}

  ;
}

void DiskImageASIF::~DiskImageASIF(DiskImageASIF *this)
{
  *(void *)this = &off_18A1DF2C8;
  uint64_t v2 = (char *)this + 16;
  di_asif::details::dir::~dir((DiskImageASIF *)((char *)this + 200));
  std::mutex::~mutex((std::mutex *)((char *)this + 112));
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v2);
}

{
  char *v2;
  *(void *)this = &off_18A1DF2C8;
  uint64_t v2 = (char *)this + 16;
  di_asif::details::dir::~dir((DiskImageASIF *)((char *)this + 200));
  std::mutex::~mutex((std::mutex *)((char *)this + 112));
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  operator delete(this);
}

uint64_t DiskImageASIF::get_block_size(DiskImageASIF *this)
{
  return *((unsigned __int16 *)this + 109);
}

uint64_t DiskImageASIF::get_num_blocks(DiskImageASIF *this)
{
  return *((void *)this + 10);
}

uint64_t DiskImageASIF::is_writable(DiskImageASIF *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 48LL))(*((void *)this + 2));
}

info::DiskImageInfoASIF *DiskImageASIF::create_image_info@<X0>( DiskImageASIF *this@<X0>, char a2@<W1>, void *a3@<X8>)
{
  int v6 = (info::DiskImageInfoASIF *)operator new(0x130uLL);
  __n128 result = info::DiskImageInfoASIF::DiskImageInfoASIF(v6, this, a2);
  *a3 = (char *)v6 + *(void *)(*(void *)v6 - 104LL);
  return result;
}

void sub_1880F80D0(_Unwind_Exception *a1)
{
}

uint64_t DiskImageASIF::set_size(DiskImageASIF *this, uint64_t a2)
{
  uint64_t v4 = DiskImage::set_size_unmap_data((DiskImage *)this, a2);
  if (!(_DWORD)v4)
  {
    unint64_t v5 = (*(uint64_t (**)(DiskImageASIF *))(*(void *)this + 24LL))(this);
    unint64_t v6 = (a2 + v5 - 1) / v5;
    if (v6 <= *((void *)this + 11))
    {
      unsigned int v7 = (di_asif::details::ContextASIF *)(*(uint64_t (**)(DiskImageASIF *))(*(void *)this + 136LL))(this);
      uint64_t v8 = *((void *)this + 11);
      if (v8 - v6 >= di_asif::Metadata::read_num_blocks((DiskImageASIF *)((char *)this + 4056), v7))
      {
        *((void *)this + 10) = v6;
        di_asif::header::write_header((DiskImageASIF *)((char *)this + 32), *((Backend **)this + 2));
        uint64_t v4 = (*(uint64_t (**)(DiskImageASIF *, di_asif::details::ContextASIF *, uint64_t))(*(void *)this
                                                                                                  + 176LL))( this,  v7,  2LL);
      }

      else
      {
        uint64_t v4 = 4294967269LL;
      }

      (*(void (**)(di_asif::details::ContextASIF *))(*(void *)v7 + 40LL))(v7);
    }

    else
    {
      return 4294967269LL;
    }
  }

  return v4;
}

void sub_1880F81C0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 40LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t DiskImageASIF::supports_unmap(DiskImageASIF *this)
{
  return 1LL;
}

uint64_t DiskImageASIF::supports_get_extents(DiskImageASIF *this)
{
  return 1LL;
}

void *DiskImageASIF::_create_ctx(DiskImageASIF *this)
{
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_18A1D9CC8;
  v2[1] = this;
  (*(void (**)(void))(**((void **)this + 2) + 72LL))(*((void *)this + 2));
  return v2;
}

void sub_1880F823C(_Unwind_Exception *a1)
{
}

uint64_t DiskImageASIF::read( DiskImageASIF *this, DiskImage::Context *a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4)
{
  uint64_t v9 = *((void *)this + 10);
  else {
    return di_asif::details::dir::do_io((DiskImageASIF *)((char *)this + 200), a2, a3, a4, 1);
  }
}

uint64_t DiskImageASIF::write( DiskImageASIF *this, DiskImage::Context *a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4)
{
  uint64_t v9 = *((void *)this + 10);
  int v10 = DiskImageASIF::void_stackable_identifier((uint64_t)this, (uint64_t)a2 + 16);
  if (!v10) {
    return di_asif::details::dir::do_io((DiskImageASIF *)((char *)this + 200), a2, a3, a4, 0);
  }
  if (v10 >= 0) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = -v10;
  }
  return -v11;
}

uint64_t DiskImageASIF::unmap(void *a1, di_asif::details::ContextASIF *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    unint64_t v8 = (void *)(a3 + 8);
    uint64_t v9 = a4;
    while (1)
    {
      uint64_t v10 = *v8 + *(v8 - 1);
      unint64_t v11 = (*(uint64_t (**)(void *))(*a1 + 24LL))(a1) * v10;
      uint64_t v12 = a1[10];
      v8 += 2;
      if (!--v9) {
        goto LABEL_5;
      }
    }
  }

  else
  {
LABEL_5:
    uint64_t result = DiskImageASIF::void_stackable_identifier((uint64_t)a1, (uint64_t)a2 + 16);
    if (!(_DWORD)result) {
      return di_asif::details::dir::unmap((uint64_t)(a1 + 25), a2, a3, a4);
    }
  }

  return result;
}

__n128 di_asif::details::asif_extents_iterator_interface::clone@<Q0>( di_asif::details::asif_extents_iterator_interface *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x48uLL);
  *(_OWORD *)(v4 + 8) = *(_OWORD *)((char *)this + 8);
  *(_OWORD *)(v4 + 24) = *(_OWORD *)((char *)this + 24);
  *((void *)v4 + 5) = *((void *)this + 5);
  __n128 result = *((__n128 *)this + 3);
  *((__n128 *)v4 + 3) = result;
  *(void *)uint64_t v4 = off_18A1DF3C8;
  *((void *)v4 + 8) = *((void *)this + 8);
  *a2 = v4;
  return result;
}

uint64_t di_asif::details::dir::get_space_allocator(di_asif::details::dir *this)
{
  return (uint64_t)this + 176;
}

unint64_t *di_asif::details::dir::allocate_bitmap@<X0>( di_asif::details::dir *this@<X0>, ref::details **a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  return ref::Allocator<di_asif::details::map_element,unsigned long long>::allocate((uint64_t)this + 2080, a2, a3, a4);
}

void *std::vector<ref::tagged_weak_ptr<di_asif::details::map_element,unsigned long long>>::vector( void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    std::vector<io_rings_sqe_t const*>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }

  return a1;
}

void sub_1880F85A0(_Unwind_Exception *exception_object)
{
  __n128 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t space_allocators::FixedSize::allocate(uint64_t a1, uint64_t a2)
{
  v13.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 8);
  v13.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 8));
  if (*(void *)(a1 + 88))
  {
    uint64_t v4 = *(uint64_t **)(a1 + 72);
    uint64_t v5 = v4[4];
    std::__tree<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>>>::__remove_node_pointer( (uint64_t **)(a1 + 72),  v4);
    operator delete(v4);
  }

  else
  {
    uint64_t v5 = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = *(void *)a1 + v5;
    std::unique_lock<std::mutex>::unlock(&v13);
    uint64_t v7 = *(void *)(a2 + 24);
    if (v7)
    {
      v10[0] = *(void *)a1 + v5;
      if ((*(unsigned int (**)(uint64_t, void *))(*(void *)v7 + 48LL))(v7, v10))
      {
        *(void *)&__int128 v8 = "space_allocators::FixedSize::allocate(const size_changed_fn_t &)";
        *((void *)&v8 + 1) = 37LL;
        int v9 = 16;
        di_log::logger<di_log::log_printer<137ul>>::logger(v10, &v8);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v11,  (uint64_t)"allocated: size change callback failed with ",  44LL);
        std::ostream::operator<<();
        std::ostream::~ostream();
        di_log::logger_buf<di_log::log_printer<137ul>>::~logger_buf((uint64_t)v10);
        MEMORY[0x1895BC2CC](&v12);
      }
    }
  }

  if (v13.__owns_) {
    std::mutex::unlock(v13.__m_);
  }
  return v5;
}

void sub_1880F86F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (*(_BYTE *)(v12 - 40)) {
    std::mutex::unlock(*(std::mutex **)(v12 - 48));
  }
  _Unwind_Resume(exception_object);
}

void *di_log::logger<di_log::log_printer<137ul>>::logger(void *a1, __int128 *a2)
{
  __n128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<137ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1DF440;
  a1[45] = &unk_18A1DF540;
  a1[46] = &unk_18A1DF568;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1DF440;
  a1[45] = &unk_18A1DF4C8;
  a1[46] = &unk_18A1DF4F0;
  return a1;
}

void sub_1880F87A8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<137ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<137ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DF5D8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880F8874(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<137ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1DF5D8;
  di_log::logger_buf<di_log::log_printer<137ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<137ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<137ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<137ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<137ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<137ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<137ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<137ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<137ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<137ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<137ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<137ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<137ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<137ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880F8C28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<137ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 137LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    int v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 137LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  int *result = v5;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZN7di_asif7details8dir_base18write_zeroed_chunkERNS3_11ContextASIFEmEUlT_E_NS_9allocatorIS8_EEFiyEE7__cloneEv( uint64_t a1)
{
  unsigned __int8 v2 = (char *)operator new(0x18uLL);
  *(void *)unsigned __int8 v2 = off_18A1DF658;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZN7di_asif7details8dir_base18write_zeroed_chunkERNS3_11ContextASIFEmEUlT_E_NS_9allocatorIS8_EEFiyEE7__cloneEPNS0_6__baseISB_EE( uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_18A1DF658;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN7di_asif7details8dir_base18write_zeroed_chunkERNS3_11ContextASIFEmEUlT_E_NS_9allocatorIS8_EEFiyEEclEOy( uint64_t a1, uint64_t *a2)
{
  return _ZZN7di_asif7details8dir_base18write_zeroed_chunkERNS0_11ContextASIFEmENKUlT_E_clIyEEDaS4_( (size_t *)(a1 + 8),  *a2);
}

uint64_t _ZNKSt3__110__function6__funcIZN7di_asif7details8dir_base18write_zeroed_chunkERNS3_11ContextASIFEmEUlT_E_NS_9allocatorIS8_EEFiyEE6targetERKSt9type_info( uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100]( a2,  (uint64_t)&_ZTIZN7di_asif7details8dir_base18write_zeroed_chunkERNS0_11ContextASIFEmEUlT_E_))
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *_ZNKSt3__110__function6__funcIZN7di_asif7details8dir_base18write_zeroed_chunkERNS3_11ContextASIFEmEUlT_E_NS_9allocatorIS8_EEFiyEE11target_typeEv()
{
  return &_ZTIZN7di_asif7details8dir_base18write_zeroed_chunkERNS0_11ContextASIFEmEUlT_E_;
}

uint64_t _ZZN7di_asif7details8dir_base18write_zeroed_chunkERNS0_11ContextASIFEmENKUlT_E_clIyEEDaS4_( size_t *a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  int v4 = *(Backend **)(*a1 + 16);
  int v5 = (char *)valloc(a1[1]);
  if (!v5)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    os_log_type_t v12 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v12, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  v15[0] = off_18A1DFDC8;
  uint64_t v16 = v15;
  uint64_t v13 = v5;
  std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)&v14, (uint64_t)v15);
  char v6 = v16;
  if (v16 == v15)
  {
    uint64_t v7 = 4LL;
    char v6 = v15;
  }

  else
  {
    if (!v16) {
      goto LABEL_7;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_7:
  bzero(v13, a1[1]);
  int v8 = Backend::write(v4, v13, a1[1], a2 - a1[1]);
  if (a1[1] == v8)
  {
    uint64_t v9 = 0LL;
  }

  else
  {
    if (v8 >= 0) {
      uint64_t v9 = 4294967291LL;
    }
    else {
      uint64_t v9 = v8;
    }
    DiskImage::Context::terminate_di((DiskImage::Context *)*a1);
  }

  std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v13);
  return v9;
}

void sub_1880F901C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *_ZNKSt3__110__function6__funcIZN7di_asif7details8dir_base15trim_backend_fnERNS3_11ContextASIFEEUlT_E_NS_9allocatorIS8_EEFiyEE7__cloneEv( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1DF6E8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN7di_asif7details8dir_base15trim_backend_fnERNS3_11ContextASIFEEUlT_E_NS_9allocatorIS8_EEFiyEE7__cloneEPNS0_6__baseISB_EE( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1DF6E8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN7di_asif7details8dir_base15trim_backend_fnERNS3_11ContextASIFEEUlT_E_NS_9allocatorIS8_EEFiyEEclEOy( uint64_t a1, unint64_t *a2)
{
  return _ZNSt3__128__invoke_void_return_wrapperIiLb0EE6__callB8ne180100IJRZN7di_asif7details8dir_base15trim_backend_fnERNS4_11ContextASIFEEUlT_E_yEEEiDpOT_( (DiskImage::Context **)(a1 + 8),  a2);
}

uint64_t _ZNKSt3__110__function6__funcIZN7di_asif7details8dir_base15trim_backend_fnERNS3_11ContextASIFEEUlT_E_NS_9allocatorIS8_EEFiyEE6targetERKSt9type_info( uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100]( a2,  (uint64_t)&_ZTIZN7di_asif7details8dir_base15trim_backend_fnERNS0_11ContextASIFEEUlT_E_))
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *_ZNKSt3__110__function6__funcIZN7di_asif7details8dir_base15trim_backend_fnERNS3_11ContextASIFEEUlT_E_NS_9allocatorIS8_EEFiyEE11target_typeEv()
{
  return &_ZTIZN7di_asif7details8dir_base15trim_backend_fnERNS0_11ContextASIFEEUlT_E_;
}

uint64_t _ZNSt3__128__invoke_void_return_wrapperIiLb0EE6__callB8ne180100IJRZN7di_asif7details8dir_base15trim_backend_fnERNS4_11ContextASIFEEUlT_E_yEEEiDpOT_( DiskImage::Context **a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v4 = *((void *)*a1 + 2);
  if ((*(uint64_t (**)(uint64_t))(*(void *)v4 + 40LL))(v4) > v3
    && (*(unsigned int (**)(uint64_t, unint64_t))(*(void *)v4 + 56LL))(v4, v3))
  {
    DiskImage::Context::terminate_di(*a1);
  }

  return 0LL;
}

void space_allocators::FixedSize::insert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a2;
  int v5 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long &>( (uint64_t **)(a1 + 72),  (unint64_t *)&v7,  &v7);
  unint64_t v6 = *(void *)a1 + v7;
  if (*(void *)(a1 + 96) <= v6) {
    *(void *)(a1 + 96) = v6;
  }
  space_allocators::FixedSize::trim_largest((void *)a1, a3);
  std::mutex::unlock(v5);
}

void sub_1880F91C8(_Unwind_Exception *a1)
{
}

uint64_t *std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long &>( uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  unint64_t v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        int v5 = *v8;
        unint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      int v5 = v8[1];
      if (!v5)
      {
        unint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    int v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  (uint64_t)v8,  v6,  v10);
    return v10;
  }

  return (uint64_t *)v8;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<436ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<436ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<436ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<436ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<436ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<436ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<436ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<436ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<436ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<436ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1DF908;
  di_log::logger_buf<di_log::log_printer<436ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<436ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<436ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880F961C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<436ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<436ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<436ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 436LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 436LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<450ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<450ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<450ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<450ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<450ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<450ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<450ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<450ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<450ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<450ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1DFB28;
  di_log::logger_buf<di_log::log_printer<450ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<450ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<450ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880F9BC8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<450ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<450ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<450ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 450LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 450LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  int *result = v5;
  return result;
}

void *di_asif::details::table_entry_data::table_entry_data( void *this, di_asif::details::table *a2, uint64_t a3)
{
  *this = a2;
  this[1] = a3;
  atomic_load((unint64_t *)(*((void *)a2 + 7) + 16 * a3 + 8));
  unint64_t v3 = atomic_load((unint64_t *)(*((void *)a2 + 7) + 16 * a3 + 8));
  if ((v3 & 0x3F80000000000000LL) != 0)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "ASIF: data entry - invalid reserved bits", 0x16u);
  }

  return this;
}

void *di_asif::details::table_entry_map::table_entry_map( void *this, di_asif::details::table *a2, uint64_t a3)
{
  *this = a2;
  this[1] = a3;
  unint64_t v3 = atomic_load((unint64_t *)(*((void *)a2 + 7) + 16 * a3 + 8));
  if ((v3 & 0x7F80000000000000LL) != 0)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "ASIF: data entry - invalid reserved bits", 0x16u);
  }

  return this;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<547ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<547ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<547ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<547ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<547ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<547ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<547ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<547ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<547ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<547ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1DFD48;
  di_log::logger_buf<di_log::log_printer<547ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<547ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<547ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FA23C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<547ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<547ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<547ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 547LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 547LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  int *result = v5;
  return result;
}

uint64_t std::vector<ref::details::ref_cnt_set_handle>::__emplace_back_slow_path<ref::details::ref_cnt_set_handle>( uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  else {
    unint64_t v9 = v5;
  }
  __int16 v18 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::allocator<ref::details::ref_cnt_set_handle>::allocate_at_least[abi:ne180100](v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v14 = v10;
  uint64_t v15 = &v10[32 * v4];
  uint64_t v16 = (uint64_t)v15;
  int v17 = &v10[32 * v9];
  uint64_t v11 = (void *)ref::details::ref_cnt_handle::ref_cnt_handle((uint64_t)v15, a2);
  void *v11 = off_18A1E3FE0;
  void v11[3] = *(void *)(a2 + 24);
  v16 += 32LL;
  std::vector<ref::details::ref_cnt_set_handle>::__swap_out_circular_buffer(a1, &v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<ref::details::ref_cnt_set_handle>::~__split_buffer((uint64_t)&v14);
  return v12;
}

void sub_1880FA5DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t std::vector<ref::details::ref_cnt_set_handle>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ref::details::ref_cnt_set_handle>,std::reverse_iterator<ref::details::ref_cnt_set_handle*>,std::reverse_iterator<ref::details::ref_cnt_set_handle*>,std::reverse_iterator<ref::details::ref_cnt_set_handle*>>( (uint64_t)(a1 + 2),  a1[1],  a1[1],  *a1,  *a1,  a2[1],  a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::allocator<ref::details::ref_cnt_set_handle>::allocate_at_least[abi:ne180100]( uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(32 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ref::details::ref_cnt_set_handle>,std::reverse_iterator<ref::details::ref_cnt_set_handle*>,std::reverse_iterator<ref::details::ref_cnt_set_handle*>,std::reverse_iterator<ref::details::ref_cnt_set_handle*>>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0LL;
    do
    {
      *(void *)ref::details::ref_cnt_handle::ref_cnt_handle(a7 + v11 - 32, a3 + v11 - 32) = off_18A1E3FE0;
      *(void *)(a7 + v11 - 8) = *(void *)(a3 + v11 - 8);
      v11 -= 32LL;
    }

    while (a3 + v11 != a5);
  }

  return a6;
}

void sub_1880FA72C(_Unwind_Exception *exception_object)
{
  for (; v2; v2 += 32LL)
    (**(void (***)(uint64_t))(v1 + v2))(v1 + v2);
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<ref::details::ref_cnt_set_handle>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 32);
    *(void *)(a1 + 16) = i - 32;
    (*v4)();
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<ref::details::ref_cnt_set_handle>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 32;
      uint64_t v7 = v4 - 32;
      do
      {
        uint64_t v8 = *(void (***)(char *))v7;
        v7 -= 32;
        (*v8)(v6);
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }

      while (!v9);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void non-virtual thunk to'di_log::logger<di_log::log_printer<863ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<863ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<863ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<863ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<863ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<863ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<863ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<863ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<863ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<863ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1DFFE8;
  di_log::logger_buf<di_log::log_printer<863ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<863ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<863ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FABB8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<863ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<863ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<863ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 863LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 863LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<888ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<888ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<888ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<888ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<888ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<888ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<888ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<888ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<888ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<888ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E0208;
  di_log::logger_buf<di_log::log_printer<888ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<888ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<888ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FB164( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<888ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<888ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<888ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 888LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 888LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<900ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<900ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<900ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<900ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<900ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<900ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<900ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<900ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<900ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<900ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E0428;
  di_log::logger_buf<di_log::log_printer<900ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<900ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<900ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FB710( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<900ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<900ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<900ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 900LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 900LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void *di_log::logger<di_log::log_printer<258ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<258ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E04B0;
  a1[45] = &unk_18A1E05B0;
  a1[46] = &unk_18A1E05D8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E04B0;
  a1[45] = &unk_18A1E0538;
  a1[46] = &unk_18A1E0560;
  return a1;
}

void sub_1880FB9B8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<258ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<258ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E0648;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880FBA84(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<258ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E0648;
  di_log::logger_buf<di_log::log_printer<258ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<258ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<258ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<258ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<258ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<258ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<258ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<258ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<258ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<258ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<258ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<258ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<258ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<258ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FBE38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<258ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 258LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 258LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<1075ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1075ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1075ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<1075ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1075ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1075ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<1075ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1075ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<1075ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<1075ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E0868;
  di_log::logger_buf<di_log::log_printer<1075ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<1075ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<1075ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FC3CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<1075ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<1075ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<1075ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 1075LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 1075LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<1081ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1081ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1081ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<1081ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1081ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1081ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<1081ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1081ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<1081ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<1081ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E0A88;
  di_log::logger_buf<di_log::log_printer<1081ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<1081ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<1081ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FC978( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<1081ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<1081ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<1081ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 1081LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 1081LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<1090ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1090ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1090ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<1090ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1090ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1090ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<1090ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1090ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<1090ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<1090ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E0CA8;
  di_log::logger_buf<di_log::log_printer<1090ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<1090ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<1090ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FCF24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<1090ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<1090ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<1090ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 1090LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 1090LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<1151ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1151ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1151ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<1151ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1151ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1151ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<1151ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1151ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<1151ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<1151ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E0EC8;
  di_log::logger_buf<di_log::log_printer<1151ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<1151ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<1151ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FD4D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<1151ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<1151ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<1151ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 1151LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 1151LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<1188ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1188ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1188ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<1188ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1188ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1188ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<1188ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1188ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<1188ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<1188ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E10E8;
  di_log::logger_buf<di_log::log_printer<1188ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<1188ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<1188ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FDA7C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<1188ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<1188ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<1188ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 1188LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 1188LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<1441ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1441ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1441ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<1441ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1441ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1441ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<1441ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1441ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<1441ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<1441ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E1308;
  di_log::logger_buf<di_log::log_printer<1441ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<1441ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<1441ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FE028( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<1441ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<1441ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<1441ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 1441LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 1441LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::data_entries_vectorizer_t::finalize_ios( uint64_t a1)
{
  int returned_io_size;
  uint64_t v3;
  uint64_t v4;
  void (***v5)(void);
  void (**v6)(void);
  int v7;
  (*(void (**)(void))(**(void **)(*(void *)(a1 + 5496) + 16LL) + 144LL))(*(void *)(*(void *)(a1 + 5496) + 16LL));
  returned_io_size = Backend::get_returned_io_size(a1 + 5504);
  uint64_t v3 = *(void *)(a1 + 6600);
  if (v3 == returned_io_size)
  {
    sg_vec_ns::details::sg_vec_iterator::operator=(a1 + 5168, a1 + 5328);
    *(void *)(a1 + 5512) = 0LL;
    int v4 = *(void *)(a1 + 6200);
    if (v4)
    {
      int v5 = *(void (****)(void))(a1 + 6192);
      do
      {
        --v4;
        char v6 = *v5;
        v5 += 3;
        (*v6)();
      }

      while (v4);
    }

    *(void *)(a1 + 6200) = 0LL;
    if (*(_BYTE *)(a1 + 6184)) {
      *(_BYTE *)(a1 + 6184) = 0;
    }
    *(void *)(a1 + 6600) = 0LL;
  }

  else
  {
    if (returned_io_size < 0) {
      uint64_t v7 = returned_io_size;
    }
    else {
      uint64_t v7 = -5;
    }
    return -(uint64_t)-v7;
  }

  return v3;
}

void *di_log::logger<di_log::log_printer<1409ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<1409ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E1390;
  a1[45] = &unk_18A1E1490;
  a1[46] = &unk_18A1E14B8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E1390;
  a1[45] = &unk_18A1E1418;
  a1[46] = &unk_18A1E1440;
  return a1;
}

void sub_1880FE3A0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<1409ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<1409ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E1528;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1880FE4F8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1409ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E1528;
  di_log::logger_buf<di_log::log_printer<1409ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<1409ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1409ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<1409ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<1409ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1409ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1409ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<1409ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1409ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1409ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<1409ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<1409ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<1409ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<1409ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1880FE8AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<1409ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 1409LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 1409LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::data_entries_vectorizer_t::finalize( uint64_t a1)
{
  uint64_t v2 = di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::data_entries_vectorizer_t::finalize_ios(a1);
  if (*(_BYTE *)(a1 + 5160))
  {
    di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::bitmap_handle_t::~bitmap_handle_t(a1);
    *(_BYTE *)(a1 + 5160) = 0;
  }

  return v2;
}

uint64_t di_asif::details::table::read(di_asif::details::ContextASIF &,sg_vec_ns::details::sg_vec_iterator const&,sg_vec_ns::details::sg_vec_iterator const&)::bitmap_handle_t::~bitmap_handle_t( uint64_t a1)
{
  uint64_t v158 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    unint64_t v91 = &v3[40 * v2];
    do
    {
      uint64_t v5 = *v3;
      int v4 = (std::__shared_weak_count *)v3[1];
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          unint64_t v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
      }

      *(_OWORD *)char v96 = *((_OWORD *)v3 + 1);
      *(_OWORD *)&v96[9] = *(_OWORD *)((char *)v3 + 25);
      uint64_t v8 = v3[6];
      __int128 v9 = *(_OWORD *)(v3 + 7);
      __int128 v10 = *(_OWORD *)(v3 + 11);
      __int128 v155 = *(_OWORD *)(v3 + 9);
      __int128 v156 = v10;
      char v157 = *((_BYTE *)v3 + 104);
      uint64_t v12 = v3[14];
      uint64_t v11 = (std::__shared_weak_count *)v3[15];
      if (v11)
      {
        uint64_t v13 = (unint64_t *)&v11->__shared_owners_;
        do
          unint64_t v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }

      __int128 v95 = *((_OWORD *)v3 + 8);
      unint64_t v93 = v3[18];
      char v94 = *((_BYTE *)v3 + 152);
      uint64_t v16 = v3[20];
      uint64_t v15 = (std::__shared_weak_count *)v3[21];
      if (v15)
      {
        int v17 = (unint64_t *)&v15->__shared_owners_;
        do
          unint64_t v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }

      *(_OWORD *)__int128 v92 = *((_OWORD *)v3 + 11);
      *(_OWORD *)&v92[9] = *(_OWORD *)((char *)v3 + 185);
      uint64_t v19 = v3[26];
      __int128 v20 = *(_OWORD *)(v3 + 27);
      __int128 v21 = *(_OWORD *)(v3 + 31);
      __int128 v152 = *(_OWORD *)(v3 + 29);
      __int128 v153 = v21;
      char v154 = *((_BYTE *)v3 + 264);
      uint64_t v23 = v3[34];
      __int16 v22 = (std::__shared_weak_count *)v3[35];
      if (v22)
      {
        uint64_t v24 = (unint64_t *)&v22->__shared_owners_;
        do
          unint64_t v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }

      uint64_t v26 = 0LL;
      unint64_t v108 = (std::__shared_weak_count *)v3[38];
      char v109 = *((_BYTE *)v3 + 312);
      __int128 v107 = *((_OWORD *)v3 + 18);
      uint64_t v110 = v5;
      uint64_t v111 = v4;
      v112[0] = *(_OWORD *)v96;
      *(_OWORD *)((char *)v112 + 9) = *(_OWORD *)&v96[9];
      __int128 v114 = v9;
      __int128 v115 = v155;
      __int128 v116 = v156;
      char v117 = v157;
      uint64_t v113 = v8;
      uint64_t v118 = v12;
      unint64_t v119 = v11;
      __int128 v120 = v95;
      char v122 = v94;
      unint64_t v121 = v93;
      uint64_t v97 = v16;
      unint64_t v98 = v15;
      *(_OWORD *)((char *)v99 + 9) = *(_OWORD *)&v92[9];
      v99[0] = *(_OWORD *)v92;
      __int128 v101 = v20;
      char v104 = v154;
      __int128 v102 = v152;
      __int128 v103 = v153;
      uint64_t v100 = v19;
      uint64_t v105 = v23;
      unint64_t v106 = v22;
      uint64_t v27 = v108;
      v151[0] = 0;
      v151[528] = 0;
      while (!sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&v110, (uint64_t)&v97))
      {
        if (DIDebugLogsEnabled())
        {
          *(void *)&__int128 v148 = "details::for_each_sg_in_vec_internal(Fn &&, sg_vec_ref::iterator, sg_vec::iterator, size_t, BOOL) [Fn = (lambda at /Library/Caches/com.apple.xbs/Sources/DiskImages2/app/disk_images/formats/asif.cpp:1274:32)]";
          *((void *)&v148 + 1) = 104LL;
          LODWORD(v149) = 2;
          di_log::logger<di_log::log_printer<545ul>>::logger(&v136, &v148);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v144, (uint64_t)"sg: ", 4LL);
          operator<<(&v144);
          std::ostream::~ostream();
          di_log::logger_buf<di_log::log_printer<545ul>>::~logger_buf((uint64_t)&v136);
          MEMORY[0x1895BC2CC](&v145);
        }

        uint64_t v136 = 0LL;
        __int128 v137 = v27;
        char v138 = 2;
        trim_sg_to_interval(&v110, (uint64_t)&v136, (uint64_t)&v148);
        unint64_t v29 = *(void *)a1;
        if (*(void *)a1)
        {
          if (*(_BYTE *)(v29 + 224)) {
            unint64_t v30 = v29 + 40;
          }
          else {
            unint64_t v30 = 0LL;
          }
        }

        else
        {
          unint64_t v30 = 0LL;
        }

        di_asif::details::map_element::zero_range_in_sg(v30, *(di_asif::details::table **)(a1 + 8), (char **)&v148);
        unint64_t v31 = v149;
        BOOL v32 = (v149 & 0x8000000000000000LL) == 0LL || (_DWORD)v149 == 0;
        char v33 = v32;
        if (v32)
        {
          int v34 = v150;
          if (sg_vec_ns::should_create_new_sg_vec_ref( (sg_vec_ns *)&v110,  (const sg_vec_ns::details::sg_vec_iterator *)&v97,  v150,  v149))
          {
            uint64_t v123 = v110;
            unint64_t v124 = v111;
            if (v111)
            {
              uint64_t v38 = (unint64_t *)&v111->__shared_owners_;
              do
                unint64_t v39 = __ldxr(v38);
              while (__stxr(v39 + 1, v38));
            }

            v125[0] = v112[0];
            *(_OWORD *)((char *)v125 + 9) = *(_OWORD *)((char *)v112 + 9);
            uint64_t v126 = v113;
            __int128 v127 = v114;
            __int128 v128 = v115;
            __int128 v129 = v116;
            char v130 = v117;
            uint64_t v131 = v118;
            char v132 = v119;
            if (v119)
            {
              uint64_t v40 = (unint64_t *)&v119->__shared_owners_;
              do
                unint64_t v41 = __ldxr(v40);
              while (__stxr(v41 + 1, v40));
            }

            __int128 v133 = v120;
            unint64_t v134 = v121;
            char v135 = v122;
            sg_vec_ns::generate_vec_ref( (uint64_t)&v123,  (uint64_t)&v97,  (uint64_t)v34,  v31,  0xFFFFFFFFFFFFFFFFLL,  (sg_vec_ref *)&v136);
            std::optional<sg_vec_ref>::operator=[abi:ne180100]<sg_vec_ref,void>((sg_vec_ref *)v151, (uint64_t)&v136);
            CFIndex v42 = v147;
            if (v147)
            {
              uint64_t v43 = (unint64_t *)&v147->__shared_owners_;
              do
                unint64_t v44 = __ldaxr(v43);
              while (__stlxr(v44 - 1, v43));
              if (!v44)
              {
                ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
                std::__shared_weak_count::__release_weak(v42);
              }
            }

            uint64_t v45 = v146;
            if (v146)
            {
              unint64_t v46 = (unint64_t *)&v146->__shared_owners_;
              do
                unint64_t v47 = __ldaxr(v46);
              while (__stlxr(v47 - 1, v46));
              if (!v47)
              {
                ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
                std::__shared_weak_count::__release_weak(v45);
              }
            }

            int v48 = v143;
            if (v143)
            {
              unint64_t v49 = (unint64_t *)&v143->__shared_owners_;
              do
                unint64_t v50 = __ldaxr(v49);
              while (__stlxr(v50 - 1, v49));
              if (!v50)
              {
                ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
                std::__shared_weak_count::__release_weak(v48);
              }
            }

            unint64_t v51 = v142;
            if (v142)
            {
              unint64_t v52 = (unint64_t *)&v142->__shared_owners_;
              do
                unint64_t v53 = __ldaxr(v52);
              while (__stlxr(v53 - 1, v52));
              if (!v53)
              {
                ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
                std::__shared_weak_count::__release_weak(v51);
              }
            }

            int v54 = v141;
            if (v141)
            {
              unint64_t v55 = (unint64_t *)&v141->__shared_owners_;
              do
                unint64_t v56 = __ldaxr(v55);
              while (__stlxr(v56 - 1, v55));
              if (!v56)
              {
                ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
                std::__shared_weak_count::__release_weak(v54);
              }
            }

            uint64_t v57 = v139;
            if (v139)
            {
              unint64_t v58 = (unint64_t *)&v139->__shared_owners_;
              do
                unint64_t v59 = __ldaxr(v58);
              while (__stlxr(v59 - 1, v58));
              if (!v59)
              {
                ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
                std::__shared_weak_count::__release_weak(v57);
              }
            }

            __int128 v60 = v132;
            if (v132)
            {
              unint64_t v61 = (unint64_t *)&v132->__shared_owners_;
              do
                unint64_t v62 = __ldaxr(v61);
              while (__stlxr(v62 - 1, v61));
              if (!v62)
              {
                ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
                std::__shared_weak_count::__release_weak(v60);
              }
            }

            uint64_t v63 = v124;
            if (v124)
            {
              unint64_t v64 = (unint64_t *)&v124->__shared_owners_;
              do
                unint64_t v65 = __ldaxr(v64);
              while (__stlxr(v65 - 1, v64));
              if (!v65)
              {
                ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
                std::__shared_weak_count::__release_weak(v63);
              }
            }

            sg_vec_ref::begin((sg_vec_ref *)v151, (uint64_t)&v136);
            sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v110, (uint64_t)&v136);
            uint64_t v66 = v140;
            if (v140)
            {
              unint64_t v67 = (unint64_t *)&v140->__shared_owners_;
              do
                unint64_t v68 = __ldaxr(v67);
              while (__stlxr(v68 - 1, v67));
              if (!v68)
              {
                ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
                std::__shared_weak_count::__release_weak(v66);
              }
            }

            uint64_t v69 = v137;
            if (v137)
            {
              unint64_t v70 = (unint64_t *)&v137->__shared_owners_;
              do
                unint64_t v71 = __ldaxr(v70);
              while (__stlxr(v71 - 1, v70));
              if (!v71)
              {
                ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
                std::__shared_weak_count::__release_weak(v69);
              }
            }

            sg_vec_ref::end((sg_vec_ref *)v151, (uint64_t)&v136);
            sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v97, (uint64_t)&v136);
            uint64_t v72 = v140;
            if (v140)
            {
              unint64_t v73 = (unint64_t *)&v140->__shared_owners_;
              do
                unint64_t v74 = __ldaxr(v73);
              while (__stlxr(v74 - 1, v73));
              if (!v74)
              {
                ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
                std::__shared_weak_count::__release_weak(v72);
              }
            }

            char v75 = v137;
            if (v137)
            {
              uint64_t v76 = (unint64_t *)&v137->__shared_owners_;
              do
                unint64_t v77 = __ldaxr(v76);
              while (__stlxr(v77 - 1, v76));
              if (!v77)
              {
                ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
                std::__shared_weak_count::__release_weak(v75);
              }
            }
          }

          sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v110, v31);
          v26 += v31;
        }

        uint64_t v35 = (std::__shared_weak_count *)*((void *)&v148 + 1);
        if (!*((void *)&v148 + 1)) {
          goto LABEL_42;
        }
        __int128 v36 = (unint64_t *)(*((void *)&v148 + 1) + 8LL);
        do
          unint64_t v37 = __ldaxr(v36);
        while (__stlxr(v37 - 1, v36));
        if (!v37)
        {
          ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
          std::__shared_weak_count::__release_weak(v35);
          if ((v33 & 1) == 0) {
            break;
          }
        }

        else
        {
LABEL_42:
          if ((v33 & 1) == 0) {
            break;
          }
        }
      }

      std::__optional_destruct_base<sg_vec_ref,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v151);
      unint64_t v78 = v106;
      if (v106)
      {
        uint64_t v79 = (unint64_t *)&v106->__shared_owners_;
        do
          unint64_t v80 = __ldaxr(v79);
        while (__stlxr(v80 - 1, v79));
        if (!v80)
        {
          ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
          std::__shared_weak_count::__release_weak(v78);
        }
      }

      uint64_t v81 = v98;
      if (v98)
      {
        uint64_t v82 = (unint64_t *)&v98->__shared_owners_;
        do
          unint64_t v83 = __ldaxr(v82);
        while (__stlxr(v83 - 1, v82));
        if (!v83)
        {
          ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
          std::__shared_weak_count::__release_weak(v81);
        }
      }

      unint64_t v84 = v119;
      if (v119)
      {
        unint64_t v85 = (unint64_t *)&v119->__shared_owners_;
        do
          unint64_t v86 = __ldaxr(v85);
        while (__stlxr(v86 - 1, v85));
        if (!v86)
        {
          ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
          std::__shared_weak_count::__release_weak(v84);
        }
      }

      unint64_t v87 = v111;
      if (v111)
      {
        unint64_t v88 = (unint64_t *)&v111->__shared_owners_;
        do
          unint64_t v89 = __ldaxr(v88);
        while (__stlxr(v89 - 1, v88));
        if (!v89)
        {
          ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
          std::__shared_weak_count::__release_weak(v87);
        }
      }

      v3 += 40;
    }

    while (v3 != v91);
  }

  boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::~vector((void **)(a1 + 16));
  ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)a1);
  return a1;
}

void sub_1880FF3AC( _Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, char a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  unint64_t v59 = (std::__shared_weak_count *)STACK[0x4E0];
  if (STACK[0x4E0])
  {
    p_shared_owners = (unint64_t *)&v59->__shared_owners_;
    do
      unint64_t v61 = __ldaxr(p_shared_owners);
    while (__stlxr(v61 - 1, p_shared_owners));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }

  std::__optional_destruct_base<sg_vec_ref,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&STACK[0x508]);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](a10);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&a38);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](a11);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&a58);
  __clang_call_terminate(a1);
}

void **boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::~vector( void **a1)
{
  uint64_t v2 = (char *)a1[1];
  if (v2)
  {
    uint64_t v3 = (char *)*a1;
    do
    {
      --v2;
      std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)(v3 + 272));
      std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)(v3 + 160));
      std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)(v3 + 112));
      std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v3);
      v3 += 320;
    }

    while (v2);
  }

  if (a1[2] && a1 + 3 != *a1) {
    operator delete(*a1);
  }
  return a1;
}

unint64_t *ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::tagged_ptr( unint64_t *a1, unint64_t *a2)
{
  *a1 = 0LL;
  uint64_t v3 = (unint64_t *)atomic_load(a2);
  if (!v3) {
    goto LABEL_9;
  }
  unint64_t v4 = atomic_load(v3);
  if (!v4) {
    goto LABEL_8;
  }
  while (1)
  {
    unint64_t v5 = __ldaxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_7;
    }

    if (!__stlxr(v4 + 1, v3)) {
      break;
    }
LABEL_7:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_8;
    }
  }

  unint64_t v7 = (unint64_t *)v3[41];
  if (v7)
  {
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v3[42] = v8;
  }

  if (!ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::wait_for_ready((uint64_t)v3))
  {
    do
      unint64_t v9 = __ldaxr(v3);
    while (__stlxr(v9 - 1, v3));
    if (v9 == 1)
    {
      uint64_t v10 = v3[4];
      v3[4] = -1LL;
      ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::reset_val((uint64_t)v3, v10, 1u);
    }

BOOL ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::wait_for_ready(uint64_t a1)
{
  uint64_t v2 = (unsigned int *)(a1 + 24);
  unsigned int v3 = atomic_load((unsigned int *)(a1 + 24));
  if (v3 == 2)
  {
    unint64_t v4 = atomic_load((unint64_t *)a1);
    return v4 > 1;
  }

  else
  {
    char v6 = (unint64_t *)(a1 + 8);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
    unsigned int v8 = atomic_load(v2);
    if (v8 != 2 && !*(_BYTE *)(a1 + 344)) {
      std::__atomic_base<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,false>::wait[abi:ne180100]( a1 + 24,  1u,  5u);
    }
    do
      unint64_t v9 = __ldaxr(v6);
    while (__stlxr(v9 - 1, v6));
    unint64_t v10 = atomic_load((unint64_t *)a1);
    if (v10 < 2)
    {
      return 0LL;
    }

    else
    {
      unsigned int v11 = atomic_load(v2);
      return v11 == 2;
    }
  }

BOOL std::__atomic_base<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,false>::wait[abi:ne180100]( uint64_t a1, unsigned int a2, unsigned int a3)
{
  *(void *)&__int128 v4 = a1;
  *((void *)&v4 + 1) = __PAIR64__(a3, a2);
  uint64_t v5 = a1;
  __int128 v6 = v4;
  return std::__libcpp_thread_poll_with_backoff[abi:ne180100]<std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state> &,std::__libcpp_atomic_wait_backoff_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>> &>( (uint64_t)&v4,  (uint64_t)&v5,  0LL);
}

BOOL std::__libcpp_thread_poll_with_backoff[abi:ne180100]<std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state> &,std::__libcpp_atomic_wait_backoff_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>> &>( uint64_t a1, uint64_t a2, std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep a3)
{
  v6.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  unsigned int v7 = 0;
  while (1)
  {
    unsigned int v8 = *(unsigned int **)a1;
    int v9 = *(_DWORD *)(a1 + 12);
    else {
      unsigned int v10 = *v8;
    }
    int v11 = *(_DWORD *)(a1 + 8);
    if (v10 != v11) {
      break;
    }
    if (v7 <= 0x3F)
    {
      ++v7;
    }

    else
    {
      v12.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_ - v6.__d_.__rep_;
      if (a3 && v12.__d_.__rep_ > a3
        || std::__libcpp_atomic_wait_backoff_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>::operator()[abi:ne180100]( a2,  v12.__d_.__rep_))
      {
        return v10 != v11;
      }
    }
  }

  return v10 != v11;
}

uint64_t std::__libcpp_atomic_wait_backoff_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>::operator()[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  if (a2 < 64001)
  {
    if (a2 >= 4001) {
      sched_yield();
    }
    return 0LL;
  }

  std::__cxx_contention_t v3 = std::__libcpp_atomic_monitor(*(const void **)a1);
  __int128 v4 = *(unsigned int **)(a1 + 8);
  int v5 = *(_DWORD *)(a1 + 20);
  else {
    unsigned int v6 = *v4;
  }
  if (v6 == *(_DWORD *)(a1 + 16))
  {
    std::__libcpp_atomic_wait(*(const void **)a1, v3);
    return 0LL;
  }

  return 1LL;
}

void boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::assign<boost::container::vec_iterator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,true>>( uint64_t *a1, const char *a2, uint64_t *a3)
{
  int64_t v4 = *a3 - *(void *)a2;
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * (v4 >> 6);
  if (v5 <= a1[2])
  {
    uint64_t v11 = *(void *)a2;
    boost::container::copy_assign_range_alloc_n<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,boost::container::vec_iterator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,true>,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*>( (uint64_t)a1,  &v11,  v5,  *a1,  a1[1]);
    a1[1] = v5;
  }

  else
  {
    if (v5 >= 0x66666666666667LL) {
      boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", a2);
    }
    unsigned int v8 = operator new(v4);
    int v9 = (uint64_t *)*a1;
    if (*a1)
    {
      boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::priv_destroy_all(a1);
      if (a1 + 3 != v9) {
        operator delete(v9);
      }
    }

    a1[1] = 0LL;
    a1[2] = v5;
    *a1 = (uint64_t)v8;
    uint64_t v10 = *(void *)a2;
    uint64_t v12 = *a3;
    uint64_t v13 = v10;
    boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::priv_uninitialized_construct_at_end<boost::container::vec_iterator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,true>>( a1,  &v13,  &v12);
  }

uint64_t *boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::priv_destroy_all( uint64_t *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[1];
  if (v2)
  {
    uint64_t v3 = *result;
    do
    {
      --v2;
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v3 + 272);
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v3 + 160);
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v3 + 112);
      uint64_t result = (uint64_t *)std::shared_ptr<char>::~shared_ptr[abi:ne180100](v3);
      v3 += 320LL;
    }

    while (v2);
  }

  v1[1] = 0LL;
  return result;
}

void boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::priv_uninitialized_construct_at_end<boost::container::vec_iterator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,true>>( void *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = *a1 + 320 * v4;
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  uint64_t v8 = v5;
  if (*a2 != *a3)
  {
    do
    {
      sg_vec_ns::details::sg_vec_iterator::sg_vec_iterator(v8, v6);
      sg_vec_ns::details::sg_vec_iterator::sg_vec_iterator(v8 + 160, v6 + 160);
      v6 += 320LL;
      v8 += 320LL;
    }

    while (v6 != v7);
    uint64_t v4 = a1[1];
  }

  a1[1] = v4 - 0x3333333333333333LL * ((v8 - v5) >> 6);
}

void boost::container::copy_assign_range_alloc_n<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,boost::container::vec_iterator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,true>,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*>( uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v9 = a5 - a3;
  if (a5 >= a3)
  {
    if (a3)
    {
      uint64_t v13 = *a2;
      unint64_t v14 = a3;
      do
      {
        --v14;
        sg_vec_ns::details::sg_vec_iterator::operator=(a4, v13);
        sg_vec_ns::details::sg_vec_iterator::operator=(a4 + 160, v13 + 160);
        a4 += 320LL;
        v13 += 320LL;
      }

      while (v14);
    }

    if (a5 != a3)
    {
      unint64_t v15 = a3 - a5;
      do
      {
        std::shared_ptr<char>::~shared_ptr[abi:ne180100](a4 + 272);
        std::shared_ptr<char>::~shared_ptr[abi:ne180100](a4 + 160);
        std::shared_ptr<char>::~shared_ptr[abi:ne180100](a4 + 112);
        std::shared_ptr<char>::~shared_ptr[abi:ne180100](a4);
        a4 += 320LL;
        BOOL v12 = __CFADD__(v15++, 1LL);
      }

      while (!v12);
    }
  }

  else
  {
    uint64_t v10 = *a2;
    if (a5)
    {
      unint64_t v11 = a5;
      do
      {
        --v11;
        sg_vec_ns::details::sg_vec_iterator::operator=(a4, v10);
        sg_vec_ns::details::sg_vec_iterator::operator=(a4 + 160, v10 + 160);
        v10 += 320LL;
        a4 += 320LL;
      }

      while (v11);
    }

    *a2 = v10;
    if (a3 != a5)
    {
      do
      {
        sg_vec_ns::details::sg_vec_iterator::sg_vec_iterator(a4, v10);
        sg_vec_ns::details::sg_vec_iterator::sg_vec_iterator(a4 + 160, v10 + 160);
        v10 += 320LL;
        a4 += 320LL;
        BOOL v12 = __CFADD__(v9++, 1LL);
      }

      while (!v12);
    }
  }

void boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>>>( uint64_t *a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = boost::container::vector_alloc_holder<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( (uint64_t)a1,  a3);
  if (v11 >= 0x66666666666667LL) {
    boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v12);
  }
  uint64_t v13 = v11;
  unint64_t v14 = operator new(320 * v11);
  boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>>>( a1,  (uint64_t)v14,  v13,  a2,  (uint64_t)a3,  a4);
  *a5 = *a1 + a2 - v10;
}

__n128 std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>::pair[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  __int128 v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 25) = *(_OWORD *)(a2 + 25);
  *(_OWORD *)(a1 + 16) = v2;
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  __int128 v3 = *(_OWORD *)(a2 + 72);
  __int128 v4 = *(_OWORD *)(a2 + 88);
  *(_BYTE *)(a1 + 104) = *(_BYTE *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = v4;
  *(_OWORD *)(a1 + 72) = v3;
  *(_OWORD *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v49 + 112) = *(_OWORD *)(a2 + 112);
  *(void *)(a2 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v49 + 112) = 0LL;
  *(void *)(a2 + 120) = 0LL;
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  uint64_t v5 = *(void *)(a2 + 144);
  *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
  *(void *)(a1 + 144) = v5;
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(void *)(a2 + 160) = 0LL;
  *(void *)(a2 + 168) = 0LL;
  __int128 v6 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 185) = *(_OWORD *)(a2 + 185);
  *(_OWORD *)(a1 + 176) = v6;
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  *(void *)(a1 + 224) = *(void *)(a2 + 224);
  __int128 v7 = *(_OWORD *)(a2 + 232);
  __int128 v8 = *(_OWORD *)(a2 + 248);
  *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
  *(_OWORD *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v10 - 248) = v8;
  *(_OWORD *)(a1 + 232) = v7;
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
  *(void *)(a2 + 272) = 0LL;
  *(void *)(a2 + 280) = 0LL;
  __n128 result = *(__n128 *)(a2 + 288);
  *(__n128 *)(a1 + 288) = result;
  uint64_t v10 = *(void *)(a2 + 304);
  *(_BYTE *)(a1 + 312) = *(_BYTE *)(a2 + 312);
  *(void *)(a1 + 304) = v10;
  return result;
}

unint64_t boost::container::vector_alloc_holder<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( uint64_t a1, const char *a2)
{
  unint64_t v2 = 0x66666666666666LL;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = v4 >> 61;
  unint64_t v6 = 8 * v4;
  if (v5 > 4) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = v6 / 5;
  if (v5) {
    unint64_t v8 = v7;
  }
  unint64_t v9 = &a2[v3];
  if (v8 < 0x66666666666666LL) {
    unint64_t v2 = v8;
  }
  else {
    return (unint64_t)v9;
  }
}

void boost::container::vector<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>>>( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *a1;
  boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>>>( (uint64_t)a1,  *a1,  a4,  *a1 + 320 * a1[1],  a2,  a5,  a6);
  if (v10)
  {
    for (uint64_t i = a1[1]; i; v10 += 320LL)
    {
      --i;
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v10 + 272);
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v10 + 160);
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v10 + 112);
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v10);
    }
  }

  uint64_t v12 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v12;
  a1[2] = a3;
}

void sub_1880FFF8C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

uint64_t *boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>*,std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>>>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = a3;
  void v16[2] = a1;
  if (a2 != a3)
  {
    uint64_t v12 = a2;
    do
    {
      std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>::pair[abi:ne180100](a5, v12);
      v12 += 320LL;
      a5 += 320LL;
    }

    while (v12 != v11);
  }

  std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>::pair[abi:ne180100](a5, a7);
  if (v11 != a4)
  {
    uint64_t v13 = a5 + 320 * a6;
    do
    {
      std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>::pair[abi:ne180100](v13, v11);
      v11 += 320LL;
      uint64_t v13 = v14 + 320;
    }

    while (v11 != a4);
  }

  v16[0] = 0LL;
  v16[1] = 0LL;
  return boost::container::dtl::scoped_destructor_range<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>>::~scoped_destructor_range(v16);
}

uint64_t *boost::container::dtl::scoped_destructor_range<boost::container::small_vector_allocator<std::pair<sg_vec_ns::details::sg_vec_iterator,sg_vec_ns::details::sg_vec_iterator>,boost::container::new_allocator<void>,void>>::~scoped_destructor_range( uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1 != a1[1])
  {
    do
    {
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v2 + 272);
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v2 + 160);
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v2 + 112);
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v2);
      uint64_t v3 = a1[1];
      uint64_t v2 = *a1 + 320;
      *a1 = v2;
    }

    while (v2 != v3);
  }

  return a1;
}

void boost::container::vector<ref::details::ref_cnt_handle,boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,ref::details::ref_cnt_handle*,ref::details::ref_cnt_handle>>( uint64_t *a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = boost::container::vector_alloc_holder<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( (uint64_t)a1,  a3);
  if (v11 >= 0x555555555555556LL) {
    boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v12);
  }
  uint64_t v13 = v11;
  uint64_t v14 = operator new(24 * v11);
  boost::container::vector<ref::details::ref_cnt_handle,boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,ref::details::ref_cnt_handle*,ref::details::ref_cnt_handle>>( a1,  (uint64_t)v14,  v13,  a2,  (uint64_t)a3,  a4);
  *a5 = *a1 + a2 - v10;
}

unint64_t boost::container::vector_alloc_holder<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( uint64_t a1, const char *a2)
{
  unint64_t v2 = 0x555555555555555LL;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = v4 >> 61;
  unint64_t v6 = 8 * v4;
  if (v5 > 4) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = v6 / 5;
  if (v5) {
    unint64_t v8 = v7;
  }
  unint64_t v9 = &a2[v3];
  if (v8 < 0x555555555555555LL) {
    unint64_t v2 = v8;
  }
  else {
    return (unint64_t)v9;
  }
}

void boost::container::vector<ref::details::ref_cnt_handle,boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,ref::details::ref_cnt_handle*,ref::details::ref_cnt_handle>>( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *a1;
  boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,ref::details::ref_cnt_handle*,ref::details::ref_cnt_handle*,boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,ref::details::ref_cnt_handle*,ref::details::ref_cnt_handle>>( (uint64_t)a1,  *a1,  a4,  *a1 + 24 * a1[1],  a2,  a5,  a6);
  if (v10)
  {
    uint64_t v11 = a1[1];
    if (v11)
    {
      uint64_t v12 = (void (***)(uint64_t))v10;
      do
      {
        --v11;
        uint64_t v13 = *v12;
        v12 += 3;
        (*v13)(v10);
        uint64_t v10 = (uint64_t)v12;
      }

      while (v11);
    }
  }

  uint64_t v14 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v14;
  a1[2] = a3;
}

void sub_1881002A8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

uint64_t boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,ref::details::ref_cnt_handle*,ref::details::ref_cnt_handle*,boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,ref::details::ref_cnt_handle*,ref::details::ref_cnt_handle>>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12 = a5;
  if (a2 != a3)
  {
    uint64_t v14 = 0LL;
    do
    {
      ref::details::ref_cnt_handle::ref_cnt_handle(a5 + v14, a2 + v14);
      v14 += 24LL;
    }

    while (a2 + v14 != a3);
    uint64_t v12 = a5 + v14;
  }

  uint64_t result = ref::details::ref_cnt_handle::ref_cnt_handle(v12, a7);
  if (a3 != a4)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = v12 + 24 * a6;
    do
    {
      uint64_t result = ref::details::ref_cnt_handle::ref_cnt_handle(v17 + v16, a3 + v16);
      v16 += 24LL;
    }

    while (a3 + v16 != a4);
  }

  return result;
}

void sub_188100380(_Unwind_Exception *exception_object)
{
  if (v2 != v1)
  {
    unint64_t v4 = v1;
    do
    {
      unint64_t v5 = *v4;
      v4 += 3;
      (*v5)(v1);
      uint64_t v1 = v4;
    }

    while (v4 != v2);
  }

  _Unwind_Resume(exception_object);
}

uint64_t boost::container::vector<ref::details::ref_cnt_handle,boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,void>::~vector( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void (****)(void))a1;
    do
    {
      --v2;
      unint64_t v4 = *v3;
      v3 += 3;
      (*v4)();
    }

    while (v2);
  }

  if (*(void *)(a1 + 16) && a1 + 24 != *(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<1513ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1513ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1513ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<1513ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1513ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<1513ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<1513ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1513ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<1513ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<1513ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E1748;
  di_log::logger_buf<di_log::log_printer<1513ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<1513ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<1513ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188100828( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<1513ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<1513ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<1513ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 1513LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 1513LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

BOOL ref::ref_cnt::get(ref::ref_cnt *this)
{
  while (1)
  {
    unint64_t v2 = *(void *)this;
    if ((*(void *)this & 0x8000000000000000LL) != 0)
    {
      unint64_t v3 = *(void *)this;
    }

    else
    {
      do
      {
        unint64_t v3 = __ldaxr((unint64_t *)this);
        if (v3 == v2)
        {
        }

        else
        {
          __clrex();
        }

        unint64_t v2 = v3;
      }

      while ((v3 & 0x8000000000000000LL) == 0);
    }

    unint64_t v2 = v3;
    if (v3 != -1LL) {
      break;
    }
    if ((ref::ref_cnt::wait_fn(this, 0LL) & 1) == 0)
    {
      unint64_t v2 = -1LL;
      return v2 != -1LL;
    }
  }

  return v2 != -1LL;
}

uint64_t ref::ref_cnt::wait_fn(ref::ref_cnt *this, const void *a2)
{
  unint64_t v2 = atomic_load((unint64_t *)this);
  BOOL v3 = v2 == 0;
  BOOL v4 = v2 != -1LL;
  if ((_DWORD)a2) {
    BOOL v4 = v3;
  }
  if (!v4)
  {
    int v5 = (int)a2;
    v17.__m_ = (std::unique_lock<std::mutex>::mutex_type *)ref::details::_get_tagged_ptr_lock( (unint64_t)this,  a2);
    v17.__owns_ = 1;
    std::mutex::lock(v17.__m_);
    uint64_t tagged_ptr_cond = ref::details::_get_tagged_ptr_cond((unint64_t)this, v7);
    unint64_t v9 = atomic_load((unint64_t *)this);
    BOOL v10 = v9 == 0;
    BOOL v11 = v9 != -1LL;
    if (v5) {
      BOOL v11 = v10;
    }
    if (!v11)
    {
      os_log_type_t v12 = (std::condition_variable *)tagged_ptr_cond;
      do
      {
        std::condition_variable::wait(v12, &v17);
        unint64_t v13 = atomic_load((unint64_t *)this);
        BOOL v14 = v13 == 0;
        BOOL v15 = v13 != -1LL;
        if (v5) {
          BOOL v15 = v14;
        }
      }

      while (!v15);
    }

    if (v17.__owns_) {
      std::mutex::unlock(v17.__m_);
    }
  }

  return 1LL;
}

void sub_188100BB0(_Unwind_Exception *a1)
{
}

unint64_t for_each_sg_in_vec<io_result_t (&)(sg_entry const&)>( uint64_t (*a1)(__int128 *), __int128 *a2, __int128 *a3, unint64_t a4)
{
  __int128 v4 = *a2;
  __int128 v5 = a2[1];
  *(void *)a2 = 0LL;
  *((void *)a2 + 1) = 0LL;
  __int128 v40 = v4;
  v41[0] = v5;
  *(_OWORD *)((char *)v41 + 9) = *(__int128 *)((char *)a2 + 25);
  uint64_t v42 = *((void *)a2 + 6);
  __int128 v43 = *(__int128 *)((char *)a2 + 56);
  __int128 v44 = *(__int128 *)((char *)a2 + 72);
  __int128 v45 = *(__int128 *)((char *)a2 + 88);
  char v46 = *((_BYTE *)a2 + 104);
  __int128 v6 = a2[7];
  __int128 v7 = a2[8];
  *((void *)a2 + 14) = 0LL;
  *((void *)a2 + 15) = 0LL;
  __int128 v47 = v6;
  __int128 v48 = v7;
  char v50 = *((_BYTE *)a2 + 152);
  uint64_t v49 = *((void *)a2 + 18);
  __int128 v8 = *a3;
  __int128 v9 = a3[1];
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  __int128 v29 = v8;
  v30[0] = v9;
  *(_OWORD *)((char *)v30 + 9) = *(__int128 *)((char *)a3 + 25);
  uint64_t v31 = *((void *)a3 + 6);
  __int128 v32 = *(__int128 *)((char *)a3 + 56);
  __int128 v10 = *(__int128 *)((char *)a3 + 72);
  __int128 v11 = *(__int128 *)((char *)a3 + 88);
  char v35 = *((_BYTE *)a3 + 104);
  __int128 v34 = v11;
  __int128 v33 = v10;
  __int128 v12 = a3[7];
  __int128 v13 = a3[8];
  *((void *)a3 + 14) = 0LL;
  *((void *)a3 + 15) = 0LL;
  __int128 v36 = v12;
  __int128 v37 = v13;
  uint64_t v14 = *((void *)a3 + 18);
  char v39 = *((_BYTE *)a3 + 152);
  uint64_t v38 = v14;
  unint64_t v15 = details::for_each_sg_in_vec_internal<io_result_t (&)(sg_entry const&)>( a1,  (sg_vec_ns *)&v40,  (const sg_vec_ns::details::sg_vec_iterator *)&v29,  a4,  0);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)&v36 + 1);
  if (*((void *)&v36 + 1))
  {
    std::unique_lock<std::mutex> v17 = (unint64_t *)(*((void *)&v36 + 1) + 8LL);
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  uint64_t v19 = (std::__shared_weak_count *)*((void *)&v29 + 1);
  if (*((void *)&v29 + 1))
  {
    __int16 v20 = (unint64_t *)(*((void *)&v29 + 1) + 8LL);
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  __int16 v22 = (std::__shared_weak_count *)*((void *)&v47 + 1);
  if (*((void *)&v47 + 1))
  {
    uint64_t v23 = (unint64_t *)(*((void *)&v47 + 1) + 8LL);
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  unint64_t v25 = (std::__shared_weak_count *)*((void *)&v40 + 1);
  if (*((void *)&v40 + 1))
  {
    uint64_t v26 = (unint64_t *)(*((void *)&v40 + 1) + 8LL);
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  return v15;
}

void sub_188100DB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

unint64_t details::for_each_sg_in_vec_internal<io_result_t (&)(sg_entry const&)>( uint64_t (*a1)(__int128 *), sg_vec_ns *a2, const sg_vec_ns::details::sg_vec_iterator *a3, unint64_t a4, char a5)
{
  unint64_t v7 = 0LL;
  unint64_t v8 = *((void *)a3 + 18);
  v34[0] = 0;
  v34[528] = 0;
  while (!sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)a2, (uint64_t)a3))
  {
    if (*((void *)a2 + 18) >= v8 || v7 >= a4) {
      break;
    }
    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v32 = "details::for_each_sg_in_vec_internal(Fn &&, sg_vec_ref::iterator, sg_vec::iterator, size_t, BOOL) [Fn = io_result_t (&)(const sg_entry &)]";
      *((void *)&v32 + 1) = 119LL;
      int v33 = 2;
      di_log::logger<di_log::log_printer<545ul>>::logger(v27, &v32);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v30, (uint64_t)"sg: ", 4LL);
      operator<<(&v30);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<545ul>>::~logger_buf((uint64_t)v27);
      MEMORY[0x1895BC2CC](&v31);
    }

    v27[0] = 0LL;
    v27[1] = v8;
    char v28 = 2;
    trim_sg_to_interval(a2, (uint64_t)v27, (uint64_t)&v32);
    int64_t v10 = a1(&v32);
    unint64_t v12 = v10;
    BOOL v13 = v10 >= 0 || (_DWORD)v10 == 0;
    char v14 = v13;
    if (v13)
    {
      uint64_t v15 = (uint64_t)v11;
      if (sg_vec_ns::should_create_new_sg_vec_ref(a2, a3, v11, v10))
      {
        sg_vec_ns::details::sg_vec_iterator::sg_vec_iterator((uint64_t)v25, (uint64_t)a2);
        sg_vec_ns::generate_vec_ref((uint64_t)v25, (uint64_t)a3, v15, v12, a4, (sg_vec_ref *)v27);
        std::optional<sg_vec_ref>::operator=[abi:ne180100]<sg_vec_ref,void>((sg_vec_ref *)v34, (uint64_t)v27);
        sg_vec_ref::~sg_vec_ref((sg_vec_ref *)v27);
        std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&v26);
        std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v25);
        sg_vec_ref::begin((sg_vec_ref *)v34, (uint64_t)v27);
        sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)a2, (uint64_t)v27);
        std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v29);
        std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v27);
        sg_vec_ref::end((sg_vec_ref *)v34, (uint64_t)v27);
        sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)a3, (uint64_t)v27);
        std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v29);
        std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v27);
      }

      if ((a5 & 1) != 0) {
        sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)a2, v12);
      }
      else {
        sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)a2, v12);
      }
      v7 += v12;
    }

    else
    {
      else {
        uint64_t v19 = -(int)v10;
      }
      unint64_t v21 = -v19;
    }

    uint64_t v16 = (std::__shared_weak_count *)*((void *)&v32 + 1);
    if (*((void *)&v32 + 1))
    {
      std::unique_lock<std::mutex> v17 = (unint64_t *)(*((void *)&v32 + 1) + 8LL);
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    if ((v14 & 1) == 0) {
      goto LABEL_35;
    }
  }

  unint64_t v21 = v7;
LABEL_35:
  std::__optional_destruct_base<sg_vec_ref,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v34);
  return v21;
}

void sub_18810109C(_Unwind_Exception *a1)
{
}

void *lock_free::bitmap_dynamically_allocated_t::bitmap_dynamically_allocated_t( void *a1, uint64_t a2, char a3)
{
  a1[2] = a2;
  *a1 = off_18A1D9F40;
  unint64_t v5 = ((unint64_t)(a2 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL;
  di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(a1 + 3, v5);
  __int128 v6 = (void *)a1[3];
  a1[8] = v6;
  a1[9] = v5;
  if ((a3 & 1) == 0 && v5) {
    bzero(v6, 8 * v5);
  }
  a1[1] = v6;
  return a1;
}

uint64_t *di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(uint64_t *a1, uint64_t a2)
{
  v12[4] = *MEMORY[0x1895F89C0];
  *a1 = 0LL;
  a1[4] = 0LL;
  BOOL v3 = valloc(8 * a2);
  if (!v3)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v8 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v8, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  v9[0] = off_18A1E17C8;
  int64_t v10 = v9;
  __int128 v11 = v3;
  std::__function::__value_func<void ()(unsigned long long *)>::__value_func[abi:ne180100]((uint64_t)v12, (uint64_t)v9);
  std::unique_ptr<unsigned long long,std::function<void ()(unsigned long long *)>>::operator=[abi:ne180100]( a1,  (uint64_t *)&v11);
  std::unique_ptr<unsigned long long,std::function<void ()(unsigned long long *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v11);
  __int128 v4 = v10;
  if (v10 == v9)
  {
    uint64_t v5 = 4LL;
    __int128 v4 = v9;
    goto LABEL_6;
  }

  if (v10)
  {
    uint64_t v5 = 5LL;
LABEL_6:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }

  return a1;
}

void sub_188101270(_Unwind_Exception *a1)
{
}

uint64_t *std::unique_ptr<unsigned long long,std::function<void ()(unsigned long long *)>>::operator=[abi:ne180100]( uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0LL;
  std::unique_ptr<unsigned long long,std::function<void ()(unsigned long long *)>>::reset[abi:ne180100](a1, v4);
  std::__function::__value_func<void ()(char *)>::operator=[abi:ne180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

void *std::__function::__func<di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(unsigned long)::{lambda(unsigned long long *)#1},std::allocator<di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(unsigned long)::{lambda(unsigned long long *)#1}>,void ()(unsigned long long *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_18A1E17C8;
  return result;
}

void std::__function::__func<di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(unsigned long)::{lambda(unsigned long long *)#1},std::allocator<di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(unsigned long)::{lambda(unsigned long long *)#1}>,void ()(unsigned long long *)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_18A1E17C8;
}

void std::__function::__func<di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(unsigned long)::{lambda(unsigned long long *)#1},std::allocator<di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(unsigned long)::{lambda(unsigned long long *)#1}>,void ()(unsigned long long *)>::operator()( uint64_t a1, void **a2)
{
}

uint64_t std::__function::__func<di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(unsigned long)::{lambda(unsigned long long *)#1},std::allocator<di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(unsigned long)::{lambda(unsigned long long *)#1}>,void ()(unsigned long long *)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(unsigned long)::{lambda(unsigned long long *)#1},std::allocator<di_utils::fixed_vector_buffer_t<unsigned long long>::fixed_vector_buffer_t(unsigned long)::{lambda(unsigned long long *)#1}>,void ()(unsigned long long *)>::target_type()
{
}

uint64_t std::__function::__value_func<void ()(unsigned long long *)>::__value_func[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  BOOL v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    BOOL v3 = (void *)(a1 + 24);
  }

  *BOOL v3 = 0LL;
  return a1;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<2061ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2061ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2061ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<2061ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2061ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2061ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<2061ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2061ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<2061ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<2061ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E19F8;
  di_log::logger_buf<di_log::log_printer<2061ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<2061ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<2061ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188101744( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<2061ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<2061ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<2061ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 2061LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 2061LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<2071ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2071ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2071ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<2071ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2071ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2071ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<2071ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2071ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<2071ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<2071ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E1C18;
  di_log::logger_buf<di_log::log_printer<2071ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<2071ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<2071ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188101CF0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<2071ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<2071ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<2071ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 2071LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 2071LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<2311ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2311ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2311ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<2311ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2311ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2311ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<2311ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2311ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<2311ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<2311ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E1E38;
  di_log::logger_buf<di_log::log_printer<2311ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<2311ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<2311ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18810229C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<2311ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<2311ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<2311ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 2311LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 2311LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<2321ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2321ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2321ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<2321ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2321ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2321ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<2321ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2321ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<2321ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<2321ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E2058;
  di_log::logger_buf<di_log::log_printer<2321ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<2321ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<2321ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188102848( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<2321ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<2321ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<2321ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 2321LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 2321LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void *std::vector<ref::tagged_weak_ptr<di_asif::details::table,unsigned long long>>::vector( void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    std::vector<io_rings_sqe_t const*>::__vallocate[abi:ne180100](a1, a2);
    int v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }

  return a1;
}

void sub_188102AC4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *std::vector<unsigned long long>::vector(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    std::vector<io_rings_sqe_t const*>::__vallocate[abi:ne180100](a1, a2);
    int v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }

  return a1;
}

void sub_188102B38(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *di_log::logger<di_log::log_printer<158ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<158ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E2120;
  a1[45] = &unk_18A1E2220;
  a1[46] = &unk_18A1E2248;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E2120;
  a1[45] = &unk_18A1E21A8;
  a1[46] = &unk_18A1E21D0;
  return a1;
}

void sub_188102BD8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<158ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<158ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E22B8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188102CA4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<158ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E22B8;
  di_log::logger_buf<di_log::log_printer<158ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<158ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<158ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<158ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<158ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<158ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<158ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<158ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<158ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<158ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<158ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<158ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<158ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<158ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188103058( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<158ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 158LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 158LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void DiskImagesHeaderSizeException::~DiskImagesHeaderSizeException(std::exception *this)
{
}

const char *DiskImagesHeaderSizeException::what(DiskImagesHeaderSizeException *this)
{
  return "File too small.";
}

void DiskImagesHeaderSizeException::reason(DiskImagesHeaderSizeException *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = (char *)(*(uint64_t (**)(DiskImagesHeaderSizeException *))(*(void *)this + 16LL))(this);
  std::string::basic_string[abi:ne180100]<0>(v14, v3);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v9);
  if ((v15 & 0x80u) == 0) {
    int v4 = v14;
  }
  else {
    int v4 = (void **)v14[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v5 = v15;
  }
  else {
    uint64_t v5 = (uint64_t)v14[1];
  }
  char v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v10, (uint64_t)v4, v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" header size ", 13LL);
  uint64_t v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)", but file size only ", 21LL);
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v11, a2);
  v9[0] = *MEMORY[0x189614728];
  uint64_t v8 = *(void *)(MEMORY[0x189614728] + 72LL);
  *(void *)((char *)v9 + *(void *)(v9[0] - 24LL)) = *(void *)(MEMORY[0x189614728] + 64LL);
  uint64_t v10 = v8;
  v11[0] = MEMORY[0x189614750] + 16LL;
  if (v12 < 0) {
    operator delete((void *)v11[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1895BC2CC](&v13);
}

void std::vector<sg_entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unsigned __int8 v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void non-virtual thunk to'di_log::logger<di_log::log_printer<2831ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2831ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2831ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<2831ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2831ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2831ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<2831ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2831ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<2831ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<2831ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E2508;
  di_log::logger_buf<di_log::log_printer<2831ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<2831ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<2831ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1881037AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<2831ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<2831ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<2831ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 2831LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 2831LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<2828ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2828ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2828ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<2828ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2828ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<2828ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<2828ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2828ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<2828ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<2828ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E2728;
  di_log::logger_buf<di_log::log_printer<2828ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<2828ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<2828ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188103D58( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<2828ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<2828ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<2828ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 2828LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 2828LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void std::__shared_ptr_pointer<char *,make_shared_buf(unsigned long)::{lambda(char *)#1},std::allocator<char>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<char *,make_shared_buf(unsigned long)::{lambda(char *)#1},std::allocator<char>>::__on_zero_shared( uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<char *,make_shared_buf(unsigned long)::{lambda(char *)#1},std::allocator<char>>::__get_deleter( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

uint64_t std::vector<sg_entry>::__emplace_back_slow_path<std::shared_ptr<char> const,Wrapper<unsigned long long,std::integral_constant<BOOL,true>,be_type> const&,unsigned long long &,Wrapper<unsigned long long,std::integral_constant<BOOL,true>,be_type> const&>( uint64_t *a1, void *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v6 = *a1;
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v8 = v7 + 1;
  if (v7 + 1 > 0x555555555555555LL) {
    std::vector<iovec>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v13 = (uint64_t)(a1 + 2);
  unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v6) >> 4);
  if (2 * v14 > v8) {
    unint64_t v8 = 2 * v14;
  }
  if (v14 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v15 = 0x555555555555555LL;
  }
  else {
    unint64_t v15 = v8;
  }
  v27[4] = a1 + 2;
  if (v15) {
    uint64_t v16 = (char *)std::allocator<sg_entry>::allocate_at_least[abi:ne180100](v13, v15);
  }
  else {
    uint64_t v16 = 0LL;
  }
  int v17 = &v16[48 * v7];
  v27[0] = v16;
  v27[1] = v17;
  v27[3] = &v16[48 * v15];
  uint64_t v18 = *a3;
  uint64_t v19 = *a4;
  uint64_t v20 = *a5;
  *(void *)int v17 = *a2;
  uint64_t v21 = a2[1];
  *((void *)v17 + 1) = v21;
  if (v21)
  {
    __int16 v22 = (unint64_t *)(v21 + 8);
    do
      unint64_t v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }

  uint64_t v24 = &v16[48 * v7];
  *((void *)v24 + 2) = v18;
  *((void *)v24 + 3) = v19;
  *((void *)v24 + 4) = v20;
  v24[40] = 0;
  void v27[2] = v17 + 48;
  std::vector<sg_entry>::__swap_out_circular_buffer(a1, v27);
  uint64_t v25 = a1[1];
  std::__split_buffer<sg_entry>::~__split_buffer((uint64_t)v27);
  return v25;
}

void sub_188104118(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t *std::vector<sg_entry>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    __int128 v5 = *(_OWORD *)(v2 - 48);
    v2 -= 48LL;
    *(_OWORD *)(v4 - 48) = v5;
    v4 -= 48LL;
    *(void *)uint64_t v2 = 0LL;
    *(void *)(v2 + 8) = 0LL;
    __int128 v6 = *(_OWORD *)(v2 + 16);
    *(_OWORD *)(v4 + 25) = *(_OWORD *)(v2 + 25);
    *(_OWORD *)(v4 + 16) = v6;
  }

  a2[1] = v4;
  uint64_t v7 = *result;
  int *result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::allocator<sg_entry>::allocate_at_least[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556LL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(48 * a2);
}

uint64_t std::__split_buffer<sg_entry>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    std::shared_ptr<char>::~shared_ptr[abi:ne180100](i - 48);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

di_asif::meta_header *std::vector<di_asif::meta_header>::__emplace_back_slow_path<di_asif::details::ContextASIF &,di_asif::details::dir &,unsigned long long>( di_asif::meta_header **a1, di_asif::details::ContextASIF *a2, di_asif::details::dir *a3, uint64_t *a4)
{
  __int128 v5 = *a1;
  uint64_t v6 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 2);
  unint64_t v7 = v6 + 1;
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v12 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - v5) >> 2);
  if (2 * v12 > v7) {
    unint64_t v7 = 2 * v12;
  }
  if (v12 >= 0x492492492492492LL) {
    unint64_t v13 = 0x924924924924924LL;
  }
  else {
    unint64_t v13 = v7;
  }
  if (v13)
  {
    unint64_t v14 = (char *)std::allocator<di_asif::meta_header>::allocate_at_least[abi:ne180100](v11, v13);
    uint64_t v16 = v15;
  }

  else
  {
    unint64_t v14 = 0LL;
    uint64_t v16 = 0LL;
  }

  int v17 = di_asif::meta_header::meta_header((di_asif::meta_header *)&v14[28 * v6], a2, a3, *a4);
  uint64_t v18 = (di_asif::meta_header *)((char *)v17 + 28);
  uint64_t v20 = *a1;
  uint64_t v19 = a1[1];
  if (v19 != *a1)
  {
    uint64_t v21 = 0LL;
    do
    {
      __int16 v22 = (char *)v17 + v21;
      *(void *)(v22 - 28) = 0x16174656DLL;
      *((_DWORD *)v22 - 5) = 512;
      *((_OWORD *)v22 - 1) = *(_OWORD *)((char *)v19 + v21 - 16);
      v21 -= 28LL;
    }

    while ((di_asif::meta_header *)((char *)v19 + v21) != v20);
    uint64_t v19 = *a1;
    int v17 = (di_asif::meta_header *)((char *)v17 + v21);
  }

  *a1 = v17;
  a1[1] = v18;
  a1[2] = (di_asif::meta_header *)&v14[28 * v16];
  if (v19) {
    operator delete(v19);
  }
  return v18;
}

void sub_188104384(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::allocator<di_asif::meta_header>::allocate_at_least[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x924924924924925LL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(28 * a2);
}

di_asif::meta_header *std::vector<di_asif::meta_header>::__emplace_back_slow_path<di_asif::details::ContextASIF &,di_asif::details::dir &,unsigned long long const&>( di_asif::meta_header **a1, di_asif::details::ContextASIF *a2, di_asif::details::dir *a3, uint64_t *a4)
{
  __int128 v5 = *a1;
  uint64_t v6 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 2);
  unint64_t v7 = v6 + 1;
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v12 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - v5) >> 2);
  if (2 * v12 > v7) {
    unint64_t v7 = 2 * v12;
  }
  if (v12 >= 0x492492492492492LL) {
    unint64_t v13 = 0x924924924924924LL;
  }
  else {
    unint64_t v13 = v7;
  }
  if (v13)
  {
    unint64_t v14 = (char *)std::allocator<di_asif::meta_header>::allocate_at_least[abi:ne180100](v11, v13);
    uint64_t v16 = v15;
  }

  else
  {
    unint64_t v14 = 0LL;
    uint64_t v16 = 0LL;
  }

  int v17 = di_asif::meta_header::meta_header((di_asif::meta_header *)&v14[28 * v6], a2, a3, *a4);
  uint64_t v18 = (di_asif::meta_header *)((char *)v17 + 28);
  uint64_t v20 = *a1;
  uint64_t v19 = a1[1];
  if (v19 != *a1)
  {
    uint64_t v21 = 0LL;
    do
    {
      __int16 v22 = (char *)v17 + v21;
      *(void *)(v22 - 28) = 0x16174656DLL;
      *((_DWORD *)v22 - 5) = 512;
      *((_OWORD *)v22 - 1) = *(_OWORD *)((char *)v19 + v21 - 16);
      v21 -= 28LL;
    }

    while ((di_asif::meta_header *)((char *)v19 + v21) != v20);
    uint64_t v19 = *a1;
    int v17 = (di_asif::meta_header *)((char *)v17 + v21);
  }

  *a1 = v17;
  a1[1] = v18;
  a1[2] = (di_asif::meta_header *)&v14[28 * v16];
  if (v19) {
    operator delete(v19);
  }
  return v18;
}

void sub_188104540(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<DiskImageASIF::get_flush_fn(void)::{lambda(di_asif::details::ContextASIF &)#1},std::allocator<DiskImageASIF::get_flush_fn(void)::{lambda(di_asif::details::ContextASIF &)#1}>,void ()(di_asif::details::ContextASIF &)>::__clone( uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1E2808;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<DiskImageASIF::get_flush_fn(void)::{lambda(di_asif::details::ContextASIF &)#1},std::allocator<DiskImageASIF::get_flush_fn(void)::{lambda(di_asif::details::ContextASIF &)#1}>,void ()(di_asif::details::ContextASIF &)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1E2808;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<DiskImageASIF::get_flush_fn(void)::{lambda(di_asif::details::ContextASIF &)#1},std::allocator<DiskImageASIF::get_flush_fn(void)::{lambda(di_asif::details::ContextASIF &)#1}>,void ()(di_asif::details::ContextASIF &)>::operator()( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 8) + 176LL))( *(void *)(a1 + 8),  a2,  0LL);
}

uint64_t std::__function::__func<DiskImageASIF::get_flush_fn(void)::{lambda(di_asif::details::ContextASIF &)#1},std::allocator<DiskImageASIF::get_flush_fn(void)::{lambda(di_asif::details::ContextASIF &)#1}>,void ()(di_asif::details::ContextASIF &)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<DiskImageASIF::get_flush_fn(void)::{lambda(di_asif::details::ContextASIF &)#1},std::allocator<DiskImageASIF::get_flush_fn(void)::{lambda(di_asif::details::ContextASIF &)#1}>,void ()(di_asif::details::ContextASIF &)>::target_type()
{
}

_DWORD *di_asif::header_flags::header_flags(_DWORD *this, int a2)
{
  *this = a2;
  if ((a2 & 0xFFFFFFFE) != 0)
  {
    unsigned int v2 = a2 & 0xFFFFFFFE;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid flags";
    exception[3] = "flags validator";
    void *exception = off_18A1CA768;
    exception[1] = "header_flags";
    *((_DWORD *)exception + 8) = v2;
  }

  return this;
}

_BYTE *boost::uuids::to_chars<char *>(uint64_t a1, _BYTE *a2)
{
  for (unint64_t i = 0LL; i != 16; ++i)
  {
    uint64_t v3 = a2;
    else {
      char v4 = 48;
    }
    *a2 = v4 + (*(_BYTE *)(a1 + i) >> 4);
    a2 += 2;
    unsigned int v5 = *(_BYTE *)(a1 + i) & 0xF;
    if (v5 >= 0xA) {
      char v6 = 87;
    }
    else {
      char v6 = 48;
    }
    v3[1] = v6 + v5;
    if (i <= 9 && ((1LL << i) & 0x2A8) != 0)
    {
      a2 = v3 + 3;
      v3[2] = 45;
    }
  }

  return a2;
}

unint64_t *ref::Allocator<di_asif::details::map_element,unsigned long long>::allocate@<X0>( uint64_t a1@<X0>, ref::details **a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  uint64_t v16 = 0LL;
  int v17 = a2;
  ref::Allocator<di_asif::details::map_element,unsigned long long>::add_tag(a1, a2, a3, &v14);
  if (v14 && !*(_BYTE *)(v14 + 344) || v14 && *(_BYTE *)(v14 + 344))
  {
    *a4 = 0LL;
    do
      unint64_t v7 = __ldaxr(&v14);
    while (__stlxr(0LL, &v14));
LABEL_21:
    atomic_store(v7, a4);
    return ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v14);
  }

  if (*(_BYTE *)(a1 + 736) && v15 != (void *)(a1 + 760))
  {
    do
    {
      ref::Allocator<di_asif::details::map_element,unsigned long long>::allocate_from_empty_pool(a1, (uint64_t)a2, &v12);
      uint64_t v16 = v12;
      ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::operator=(&v14, &v13);
      ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v13);
      if (v14)
      {
        if (!*(_BYTE *)(v14 + 344)) {
          break;
        }
      }

      min = (unint64_t *)ref::Allocator<di_asif::details::map_element,unsigned long long>::extract_min((void *)a1);
      if (min)
      {
        uint64_t v16 = min;
        ref::Allocator<di_asif::details::map_element,unsigned long long>::insert_elem( a1,  min,  (uint64_t)a2,  (unint64_t *)&v12);
        ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::operator=(&v14, (unint64_t *)&v12);
        ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)&v12);
        break;
      }
    }

    while (*(_BYTE *)(a1 + 736));
    std::mutex::lock((std::mutex *)(a1 + 776));
    uint64_t v9 = std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *&>( (uint64_t **)(a1 + 752),  v15,  (unint64_t *)&v17,  (uint64_t *)&v17,  (uint64_t *)&v16);
    if (!v10) {
      v9[5] = (uint64_t)v16;
    }
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 840));
    std::mutex::unlock((std::mutex *)(a1 + 776));
    ref::Allocator<di_asif::details::map_element,unsigned long long>::run_failed_dtors_list(a1, 0, 0LL, 0);
    *a4 = 0LL;
    do
      unint64_t v7 = __ldaxr(&v14);
    while (__stlxr(0LL, &v14));
    goto LABEL_21;
  }

  *a4 = 0LL;
  return ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v14);
}

void sub_18810489C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void ref::Allocator<di_asif::details::map_element,unsigned long long>::add_tag( uint64_t a1@<X0>, ref::details **a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  unint64_t v52 = a2;
  unint64_t v7 = (std::mutex *)(a1 + 776);
  uint64_t v8 = (void *)(a1 + 760);
  uint64_t v9 = (ref::details *)(a1 + 1008);
  char v10 = (unint64_t *)(a1 + 592);
  __int128 v45 = (unint64_t *)(a1 + 104);
  char v46 = (std::condition_variable *)(a1 + 840);
  __int128 v47 = (uint64_t **)(a1 + 752);
  while (2)
  {
    __lk.__m_ = v7;
    __lk.__owns_ = 1;
    std::mutex::lock(v7);
    if (a3)
    {
      uint64_t v11 = v52;
    }

    else
    {
      uint64_t v16 = (void *)*v8;
      if (!*v8) {
        goto LABEL_20;
      }
      uint64_t v11 = v52;
      int v17 = v8;
      do
      {
        unint64_t v18 = v16[4];
        BOOL v19 = v18 >= (unint64_t)v52;
        else {
          uint64_t v20 = v16 + 1;
        }
        if (v19) {
          int v17 = v16;
        }
        uint64_t v16 = (void *)*v20;
      }

      while (*v20);
      if (v17 == v8 || (unint64_t)v52 < v17[4] || (ref::details *)v17[5] == v9)
      {
LABEL_20:
        unint64_t v53 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v21 = __ldaxr((unint64_t *)&v53);
        while (__stlxr(0LL, (unint64_t *)&v53));
        atomic_store(v21, a4);
        a4[1] = (unint64_t)v8;
        ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)&v53);
        goto LABEL_23;
      }
    }

    unint64_t v53 = v11;
    int v54 = (unint64_t *)v9;
    unint64_t v12 = std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>( v47,  (unint64_t *)&v53,  (uint64_t *)&v53);
    unint64_t v13 = v12;
    if (v14)
    {
      unint64_t v53 = 0LL;
      *a4 = 0LL;
      do
        unint64_t v15 = __ldaxr((unint64_t *)&v53);
      while (__stlxr(0LL, (unint64_t *)&v53));
      atomic_store(v15, a4);
      a4[1] = (unint64_t)v12;
      ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)&v53);
LABEL_23:
      int v22 = 1;
      goto LABEL_24;
    }

    char v50 = (ref::details *)v12[5];
    if (v50 == v9)
    {
      uint64_t v30 = (void *)*v8;
      if (*v8)
      {
        uint64_t v31 = v52;
        __int128 v32 = v8;
        while (1)
        {
          unint64_t v33 = v30[4];
          BOOL v34 = v33 >= (unint64_t)v31;
          else {
            char v35 = v30 + 1;
          }
          if (v34) {
            __int128 v32 = v30;
          }
          uint64_t v30 = (void *)*v35;
          if (!*v35)
          {
            if (v32 == v8) {
              break;
            }
            __int128 v36 = (ref::details *)v32[5];
            if (v36 != v9)
            {
              uint64_t v37 = *((void *)v36 + 45);
              if (v37)
              {
                if (!*(_BYTE *)(v37 + 344)) {
                  break;
                }
              }
            }

            if (!*(_BYTE *)(a1 + 736)) {
              break;
            }
            std::condition_variable::wait(v46, &__lk);
            uint64_t v30 = (void *)*v8;
            __int128 v32 = v8;
            if (!*v8) {
              break;
            }
          }
        }
      }

      int v22 = 0;
      goto LABEL_24;
    }

    std::unique_lock<std::mutex>::unlock(&__lk);
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::tagged_ptr(&v49, (unint64_t *)v50 + 45);
    if (v49 && !*(_BYTE *)(v49 + 344))
    {
      uint64_t v23 = (uint64_t)v52;
      if (*(ref::details ***)(v49 + 32) == v52)
      {
        *a4 = 0LL;
        do
          unint64_t v39 = __ldaxr(&v49);
        while (__stlxr(0LL, &v49));
        atomic_store(v39, a4);
        a4[1] = (unint64_t)v13;
        goto LABEL_84;
      }

      if (*(void *)(v49 + 32) == -1LL)
      {
        uint64_t v24 = v45;
        if ((a3 & 1) == 0)
        {
          unint64_t v53 = 0LL;
          *a4 = 0LL;
          do
            unint64_t v38 = __ldaxr((unint64_t *)&v53);
          while (__stlxr(0LL, (unint64_t *)&v53));
          goto LABEL_83;
        }

        goto LABEL_35;
      }
    }

    else
    {
      if (!a3)
      {
        unint64_t v53 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v38 = __ldaxr((unint64_t *)&v53);
        while (__stlxr(0LL, (unint64_t *)&v53));
        goto LABEL_83;
      }

      uint64_t v23 = (uint64_t)v52;
    }

    uint64_t v24 = v45;
LABEL_35:
    if (ref::Allocator<di_asif::details::map_element,unsigned long long>::run_failed_dtors_list( a1,  0,  v23,  1u) != -1)
    {
      do
        unint64_t v26 = __ldaxr(v10);
      while (__stlxr(v26 + 1, v10));
      v48.__m_ = (std::unique_lock<std::mutex>::mutex_type *)ref::details::_get_tagged_ptr_lock( (unint64_t)v50,  v25);
      v48.__owns_ = 1;
      std::mutex::lock(v48.__m_);
      uint64_t tagged_ptr_cond = (std::condition_variable *)ref::details::_get_tagged_ptr_cond((unint64_t)v50, v27);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v56 = std::chrono::steady_clock::now().__d_.__rep_ + 200000000;
      unint64_t v53 = &v50;
      int v54 = &v49;
      unint64_t v55 = &v52;
      std::condition_variable::wait_until<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>,ref::Allocator<di_asif::details::map_element,unsigned long long>::add_tag(unsigned long long,BOOL)::{lambda(void)#1}>( tagged_ptr_cond,  &v48,  &v56,  (uint64_t)&v53);
      do
        unint64_t v29 = __ldaxr(v10);
      while (__stlxr(v29 - 1, v10));
      if (v48.__owns_) {
        std::mutex::unlock(v48.__m_);
      }
      int v22 = 3;
      goto LABEL_85;
    }

    unint64_t v53 = 0LL;
    unint64_t v40 = atomic_load(v24);
    if (!v40) {
      goto LABEL_81;
    }
    while (1)
    {
      unint64_t v41 = __ldaxr(v24);
      if (v41 != v40)
      {
        __clrex();
        goto LABEL_71;
      }

      if (!__stlxr(v40 + 1, v24)) {
        break;
      }
LABEL_71:
      unint64_t v40 = v41;
      if (!v41) {
        goto LABEL_81;
      }
    }

    uint64_t v42 = *(unint64_t **)(a1 + 432);
    unint64_t v40 = (unint64_t)v24;
    if (v42)
    {
      do
        unint64_t v43 = __ldxr(v42);
      while (__stxr(v43 + 1, v42));
      *(void *)(a1 + 440) = v43;
      unint64_t v40 = (unint64_t)v24;
    }

LABEL_81:
    atomic_store(v40, (unint64_t *)&v53);
    *a4 = 0LL;
    do
      unint64_t v38 = __ldaxr((unint64_t *)&v53);
    while (__stlxr(0LL, (unint64_t *)&v53));
LABEL_83:
    atomic_store(v38, a4);
    a4[1] = (unint64_t)v8;
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)&v53);
LABEL_84:
    int v22 = 1;
LABEL_85:
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v49);
LABEL_24:
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
    if (v22 != 1)
    {
      if (!*(_BYTE *)(a1 + 736))
      {
        unint64_t v53 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v44 = __ldaxr((unint64_t *)&v53);
        while (__stlxr(0LL, (unint64_t *)&v53));
        atomic_store(v44, a4);
        a4[1] = (unint64_t)v8;
        ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)&v53);
        return;
      }

      continue;
    }

    break;
  }

    atomic_store(v40, (unint64_t *)&v53);
    *a4 = 0LL;
    do
      unint64_t v38 = __ldaxr((unint64_t *)&v53);
    while (__stlxr(0LL, (unint64_t *)&v53));
LABEL_83:
    atomic_store(v38, a4);
    a4[1] = (unint64_t)v8;
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v53);
LABEL_84:
    int v22 = 1;
LABEL_85:
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(&v49);
LABEL_24:
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
    if (v22 != 1)
    {
      if (!*(_BYTE *)(a1 + 912))
      {
        unint64_t v53 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v44 = __ldaxr((unint64_t *)&v53);
        while (__stlxr(0LL, (unint64_t *)&v53));
        atomic_store(v44, a4);
        a4[1] = (unint64_t)v8;
        ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v53);
        return;
      }

      continue;
    }

    break;
  }

    atomic_store(v40, (unint64_t *)&v53);
    *a4 = 0LL;
    do
      unint64_t v38 = __ldaxr((unint64_t *)&v53);
    while (__stlxr(0LL, (unint64_t *)&v53));
LABEL_83:
    atomic_store(v38, a4);
    a4[1] = (unint64_t)v8;
    ref::tagged_ptr<CurrentReader,unsigned long long>::reset((unint64_t *)&v53);
LABEL_84:
    int v22 = 1;
LABEL_85:
    ref::tagged_ptr<CurrentReader,unsigned long long>::reset(&v49);
LABEL_24:
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
    if (v22 != 1)
    {
      if (!*(_BYTE *)(a1 + 704))
      {
        unint64_t v53 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v44 = __ldaxr((unint64_t *)&v53);
        while (__stlxr(0LL, (unint64_t *)&v53));
        atomic_store(v44, a4);
        a4[1] = (unint64_t)v8;
        ref::tagged_ptr<CurrentReader,unsigned long long>::reset((unint64_t *)&v53);
        return;
      }

      continue;
    }

    break;
  }

void sub_188104D3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::mutex *a12, char a13, int a14, unint64_t a15, uint64_t a16, std::mutex *a17, char a18)
{
  if (a18) {
    std::mutex::unlock(a17);
  }
  _Unwind_Resume(a1);
}

unint64_t *ref::Allocator<di_asif::details::map_element,unsigned long long>::allocate_from_empty_pool@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t **a3@<X8>)
{
  unint64_t v12 = 0LL;
  char v6 = (std::mutex *)(a1 + 520);
  std::mutex::lock((std::mutex *)(a1 + 520));
  uint64_t v7 = *(void *)(a1 + 512);
  if (v7)
  {
    ++*(void *)(a1 + 504);
    *(void *)(a1 + 512) = v7 - 1;
    std::deque<std::atomic<DiskImage::Context *>>::__maybe_remove_front_spare[abi:ne180100](a1 + 472, 1);
    ref::Allocator<di_asif::details::map_element,unsigned long long>::insert_elem(a1, v8, a2, v13);
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::operator=(&v12, v13);
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(v13);
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  std::mutex::unlock(v6);
  unint64_t v9 = atomic_load((unint64_t *)(a1 + 608));
  if (v9 + v7 >= *(void *)(a1 + 464))
  {
    ref::Allocator<di_asif::details::map_element,unsigned long long>::run_failed_dtors_list(a1, 0, 0LL, 0);
  }

  else
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 0x40000000LL;
    v13[2] = (unint64_t)___ZN3ref9AllocatorIN7di_asif7details11map_elementEyE9evict_lruEv_block_invoke;
    v13[3] = (unint64_t)&__block_descriptor_tmp_5;
    v13[4] = a1;
    gcd::gcd_queue::async((dispatch_queue_t *)(a1 + 744), v13);
  }

  *a3 = v8;
  a3[1] = 0LL;
  do
    unint64_t v10 = __ldaxr(&v12);
  while (__stlxr(0LL, &v12));
  atomic_store(v10, (unint64_t *)a3 + 1);
  return ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(&v12);
}

void sub_188104EF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
}

unint64_t ref::Allocator<di_asif::details::map_element,unsigned long long>::extract_min(void *a1)
{
  unint64_t v1 = atomic_load(a1 + 75);
  uint64_t v2 = a1[57];
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  int v4 = 0;
  unint64_t v5 = 0LL;
  do
  {
    uint64_t v6 = a1[73];
    uint64_t v7 = *(void *)(v6 + 8 * v3);
    if (v7 && v1 - *(void *)(v7 + 344) != -1LL)
    {
      unint64_t v5 = *(void *)(v6 + 8 * v3);
      int v4 = v3;
    }

    ++v3;
  }

  while (v2 != v3);
  if (!v5) {
    return 0LL;
  }
  uint64_t v8 = (unint64_t *)(a1[73] + 8LL * v4);
  do
  {
    unint64_t v9 = __ldaxr(v8);
    if (v9 != v5)
    {
      __clrex();
      return 0LL;
    }
  }

  while (__stlxr(0LL, v8));
  return v5;
}

unint64_t *ref::Allocator<di_asif::details::map_element,unsigned long long>::insert_elem@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  uint64_t v7 = a2 + 1;
  unint64_t v17 = 0LL;
  unint64_t v8 = atomic_load(a2 + 1);
  if (!v8)
  {
LABEL_7:
    uint64_t v7 = 0LL;
    goto LABEL_11;
  }

  while (1)
  {
    unint64_t v9 = __ldaxr(v7);
    if (v9 != v8)
    {
      __clrex();
      goto LABEL_6;
    }

    if (!__stlxr(v8 + 1, v7)) {
      break;
    }
LABEL_6:
    unint64_t v8 = v9;
    if (!v9) {
      goto LABEL_7;
    }
  }

  unint64_t v10 = (unint64_t *)a2[42];
  if (v10)
  {
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    a2[43] = v11;
  }

uint64_t ref::Allocator<di_asif::details::map_element,unsigned long long>::run_failed_dtors_list( uint64_t a1, int a2, uint64_t a3, unsigned __int8 a4)
{
  if (!*(void *)(a1 + 968)) {
    return 0LL;
  }
  uint64_t v20 = (std::mutex *)(a1 + 888);
  std::mutex::lock((std::mutex *)(a1 + 888));
  if (*(void *)(a1 + 968))
  {
    unint64_t v8 = *(uint64_t **)(a1 + 960);
    if (v8 == (uint64_t *)(a1 + 952))
    {
      uint64_t v11 = 1LL;
    }

    else
    {
      uint64_t v9 = a4;
      if (a2) {
        unsigned int v10 = 6;
      }
      else {
        unsigned int v10 = 4;
      }
      uint64_t v11 = 1LL;
      do
      {
        unint64_t v12 = v8[2];
        if ((ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::reset_val( v12 + 8,  v8[3],  v10) | a2) == 1)
        {
          tagged_ptr_lock = (std::mutex *)ref::details::_get_tagged_ptr_lock(v12, v13);
          std::mutex::lock(tagged_ptr_lock);
          unint64_t v15 = (unsigned int *)(v12 + 368);
          do
            unsigned int v16 = __ldaxr(v15);
          while (__stlxr(v16 & 0xFFFFFFFB, v15));
          std::mutex::unlock(tagged_ptr_lock);
          uint64_t v17 = *v8;
          unint64_t v18 = (uint64_t *)v8[1];
          *(void *)(v17 + 8) = v18;
          *(void *)v8[1] = v17;
          --*(void *)(a1 + 968);
          operator delete(v8);
          unint64_t v8 = v18;
        }

        else
        {
          if (!v9 || v8[3] == a3) {
            uint64_t v11 = 0xFFFFFFFFLL;
          }
          unint64_t v8 = (uint64_t *)v8[1];
        }
      }

      while (v8 != (uint64_t *)(a1 + 952));
    }
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  std::mutex::unlock(v20);
  return v11;
}

void sub_188105230( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10)
{
}

uint64_t *std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>( uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        unint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v8 = a1 + 1;
LABEL_10:
    unsigned int v10 = (uint64_t *)operator new(0x30uLL);
    uint64_t v11 = a3[1];
    v10[4] = *a3;
    _OWORD v10[5] = v11;
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  (uint64_t)v8,  v6,  v10);
    return v10;
  }

  return (uint64_t *)v8;
}

unint64_t *ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::tagged_ptr( unint64_t *a1, unint64_t *a2, int a3)
{
  uint64_t v3 = a2;
  *a1 = 0LL;
  if (!a2) {
    goto LABEL_9;
  }
  unint64_t v5 = atomic_load(a2);
  if (!v5) {
    goto LABEL_8;
  }
  while (1)
  {
    unint64_t v6 = __ldaxr(a2);
    if (v6 != v5)
    {
      __clrex();
      goto LABEL_7;
    }

    if (!__stlxr(v5 + 1, a2)) {
      break;
    }
LABEL_7:
    unint64_t v5 = v6;
    if (!v6) {
      goto LABEL_8;
    }
  }

  unint64_t v8 = (unint64_t *)a2[41];
  if (v8)
  {
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    a2[42] = v9;
  }

  if (a3 && !ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::wait_for_ready((uint64_t)a2))
  {
    do
      unint64_t v10 = __ldaxr(v3);
    while (__stlxr(v10 - 1, v3));
    if (v10 == 1)
    {
      uint64_t v11 = v3[4];
      v3[4] = -1LL;
      ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::reset_val((uint64_t)v3, v11, 1u);
    }

BOOL std::condition_variable::wait_until<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>,ref::Allocator<di_asif::details::map_element,unsigned long long>::add_tag(unsigned long long,BOOL)::{lambda(void)#1}>( std::condition_variable *a1, std::unique_lock<std::mutex> *a2, std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *a3, uint64_t a4)
{
  do
  {
    if ((*(_DWORD *)(**(void **)a4 + 368LL) & 1) != 0) {
      return 1LL;
    }
    uint64_t v8 = *(void *)(a4 + 8);
    if (*(void *)v8)
    {
      if (!*(_BYTE *)(*(void *)v8 + 344LL) && *(void *)(*(void *)v8 + 32LL) == **(void **)(a4 + 16)) {
        return 1LL;
      }
    }

    if (*a3 <= std::chrono::steady_clock::now().__d_.__rep_) {
      break;
    }
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = *a3;
    v10.__d_.__rep_ = v9 - std::chrono::steady_clock::now().__d_.__rep_;
    if (v10.__d_.__rep_ >= 1)
    {
      std::chrono::steady_clock::now();
      v11.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      if (v11.__d_.__rep_)
      {
        if (v11.__d_.__rep_ < 1)
        {
          if ((unint64_t)v11.__d_.__rep_ < 0xFFDF3B645A1CAC09LL)
          {
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x8000000000000000LL;
            goto LABEL_17;
          }
        }

        else if ((unint64_t)v11.__d_.__rep_ > 0x20C49BA5E353F7LL)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x7FFFFFFFFFFFFFFFLL;
          goto LABEL_15;
        }

        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 1000 * v11.__d_.__rep_;
      }

      else
      {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0LL;
      }

uint64_t ___ZN3ref9AllocatorIN7di_asif7details11map_elementEyE9evict_lruEv_block_invoke(uint64_t a1)
{
  unint64_t v1 = *(void **)(a1 + 32);
  unint64_t min = ref::Allocator<di_asif::details::map_element,unsigned long long>::extract_min(v1);
  if (min) {
    ref::Allocator<di_asif::details::map_element,unsigned long long>::add_to_free_pool((uint64_t)v1, min);
  }
  return ref::Allocator<di_asif::details::map_element,unsigned long long>::run_failed_dtors_list((uint64_t)v1, 0, 0LL, 0);
}

void ref::Allocator<di_asif::details::map_element,unsigned long long>::add_to_free_pool( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 520);
  std::mutex::lock((std::mutex *)(a1 + 520));
  std::deque<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>::push_back( (void *)(a1 + 472),  &v4);
  std::mutex::unlock(v3);
}

void sub_1881055E4(_Unwind_Exception *a1)
{
}

void std::deque<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>::push_back( void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void std::deque<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>::__add_back_capacity( void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      BOOL v34 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( v5,  v33);
      char v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_188105944( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t ref::Allocator<di_asif::details::map_element,unsigned long long>::drop_elem( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  uint64_t v8 = a3 & 0x100;
  uint64_t v9 = (a3 >> 8) & 1;
  uint64_t v10 = (unint64_t *)(a1 + 608);
  do
    unint64_t v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  if ((a3 & 1) != 0)
  {
    uint64_t v12 = (unint64_t *)(a1 + 592);
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
  }

  BOOL v14 = (unsigned int *)(a2 + 368);
  do
    unsigned int v15 = __ldaxr(v14);
  while (__stlxr(v15 | 2, v14));
  ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)(a2 + 360));
  if (a4) {
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(a4);
  }
  if ((a3 & 1) != 0)
  {
    char v16 = atomic_load(v14);
    if ((v16 & 4) == 0)
    {
      uint64_t v17 = (a3 >> 16) & 1;
      do
      {
        if ((*v14 & 1) != 0) {
          break;
        }
        if ((_DWORD)v9)
        {
          std::mutex::lock((std::mutex *)(a1 + 520));
          uint64_t v18 = *(void *)(a1 + 512);
          std::mutex::unlock((std::mutex *)(a1 + 520));
          if (v18) {
            break;
          }
        }

        if (ref::Allocator<di_asif::details::map_element,unsigned long long>::run_failed_dtors_list( a1,  v17,  0LL,  0) == -1)
        {
          __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)ref::details::_get_tagged_ptr_lock(a2, v19);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          uint64_t tagged_ptr_cond = (std::condition_variable *)ref::details::_get_tagged_ptr_cond(a2, v26);
          v28.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
          uint64_t v38 = a1;
          std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v39 = v28.__d_.__rep_ + 200000;
          unint64_t v35 = a2;
          char v36 = v9;
          *(_DWORD *)uint64_t v37 = *(_DWORD *)v41;
          *(_DWORD *)&v37[3] = *(_DWORD *)&v41[3];
          std::condition_variable::wait_until<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>,ref::Allocator<di_asif::details::map_element,unsigned long long>::drop_elem(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::Allocator<di_asif::details::map_element,unsigned long long>::drop_elem_options,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> *)::{lambda(void)#1}>( tagged_ptr_cond,  &__lk,  &v39,  (uint64_t)&v35);
        }

        else
        {
          __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)ref::details::_get_tagged_ptr_lock(a2, v19);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          uint64_t v21 = ref::details::_get_tagged_ptr_cond(a2, v20);
          char v22 = atomic_load(v14);
          if ((v22 & 4) == 0)
          {
            uint64_t v23 = (std::condition_variable *)v21;
            do
            {
              if ((*v14 & 1) != 0) {
                break;
              }
              if ((_DWORD)v9)
              {
                std::mutex::lock((std::mutex *)(a1 + 520));
                uint64_t v24 = *(void *)(a1 + 512);
                std::mutex::unlock((std::mutex *)(a1 + 520));
                if (v24) {
                  break;
                }
              }

              std::condition_variable::wait(v23, &__lk);
              char v25 = atomic_load(v14);
            }

            while ((v25 & 4) == 0);
          }
        }

        if (__lk.__owns_) {
          std::mutex::unlock(__lk.__m_);
        }
        unsigned int v29 = *v14;
        if (!v8 || (v29 & 1) != 0)
        {
          if ((v29 & 1) != 0) {
            break;
          }
        }

        else if (*(void *)(a1 + 512))
        {
          break;
        }

        char v30 = atomic_load(v14);
      }

      while ((v30 & 4) == 0);
    }

    __int128 v31 = (unint64_t *)(a1 + 592);
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
  }

  do
    unsigned int v33 = __ldaxr(v14);
  while (__stlxr(v33 & 0xFFFFFFFD, v14));
  return v33 & 1;
}

void sub_188105BC0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::mutex *a14, char a15)
{
  if (a15) {
    std::mutex::unlock(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::condition_variable::wait_until<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>,ref::Allocator<di_asif::details::map_element,unsigned long long>::drop_elem(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::Allocator<di_asif::details::map_element,unsigned long long>::drop_elem_options,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> *)::{lambda(void)#1}>( std::condition_variable *a1, std::unique_lock<std::mutex> *a2, uint64_t *a3, uint64_t a4)
{
  do
  {
    uint64_t v8 = *(void *)(a4 + 16);
    char v9 = atomic_load((unsigned int *)(*(void *)a4 + 368LL));
    if ((v9 & 4) != 0) {
      return 1LL;
    }
    if ((*(_DWORD *)(*(void *)a4 + 368LL) & 1) != 0) {
      return 1LL;
    }
    if (*(_BYTE *)(a4 + 8))
    {
      uint64_t v10 = (std::mutex *)(v8 + 520);
      std::mutex::lock((std::mutex *)(v8 + 520));
      uint64_t v11 = *(void *)(v8 + 512);
      std::mutex::unlock(v10);
      if (v11) {
        return 1LL;
      }
    }

    v12.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    uint64_t v13 = *a3;
    if (*a3 <= v12.__d_.__rep_) {
      break;
    }
    if (!v13)
    {
      v14.__d_.__rep_ = 0LL;
      goto LABEL_14;
    }

    if (v13 < 1)
    {
      if ((unint64_t)v13 < 0xFFDF3B645A1CAC09LL)
      {
        v14.__d_.__rep_ = 0x8000000000000000LL;
        goto LABEL_14;
      }
    }

    else if ((unint64_t)v13 > 0x20C49BA5E353F7LL)
    {
      v14.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
      goto LABEL_14;
    }

    v14.__d_.__rep_ = 1000 * v13;
LABEL_14:
    std::condition_variable::__do_timed_wait(a1, a2, v14);
  }

  while (std::chrono::system_clock::now().__d_.__rep_ < *a3);
  uint64_t v15 = *(void *)(a4 + 16);
  char v16 = atomic_load((unsigned int *)(*(void *)a4 + 368LL));
  if ((v16 & 4) != 0 || (*(_DWORD *)(*(void *)a4 + 368LL) & 1) != 0) {
    return 1LL;
  }
  if (!*(_BYTE *)(a4 + 8)) {
    return 0LL;
  }
  std::mutex::lock((std::mutex *)(v15 + 520));
  BOOL v17 = *(void *)(v15 + 512) != 0LL;
  std::mutex::unlock((std::mutex *)(v15 + 520));
  return v17;
}

unint64_t *ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::mark_used( uint64_t a1, uint64_t a2)
{
  BOOL v3 = (unint64_t *)(a1 + 8);
  ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::init(a1 + 8, a2);
  unint64_t v12 = 0LL;
  unint64_t v4 = atomic_load(v3);
  if (!v4) {
    goto LABEL_11;
  }
  while (1)
  {
    unint64_t v5 = __ldaxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_6;
    }

    if (!__stlxr(v4 + 1, v3)) {
      break;
    }
LABEL_6:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_11;
    }
  }

  uint64_t v6 = *(unint64_t **)(a1 + 336);
  unint64_t v4 = (unint64_t)v3;
  if (v6)
  {
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    *(void *)(a1 + 344) = v7;
    unint64_t v4 = (unint64_t)v3;
  }

uint64_t *ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::init( uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 344) = 0;
  atomic_store(1uLL, (unint64_t *)a1);
  atomic_store(0LL, (unint64_t *)(a1 + 8));
  atomic_store(0LL, (unint64_t *)(a1 + 16));
  uint64_t result = std::__optional_destruct_base<di_asif::details::map_element,false>::reset[abi:ne180100]((uint64_t *)(a1 + 40));
  unint64_t v4 = *(unint64_t **)(a1 + 328);
  if (v4)
  {
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    *(void *)(a1 + 336) = v5;
  }

  atomic_store(1u, (unsigned int *)(a1 + 24));
  __dmb(0xBu);
  return result;
}

uint64_t *std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *&>( uint64_t **a1, void *a2, unint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v8 = (uint64_t **)std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>>::__find_equal<unsigned long long>( a1,  a2,  &v14,  &v13,  a3);
  unint64_t v9 = *v8;
  if (!*v8)
  {
    unint64_t v10 = v8;
    unint64_t v9 = (uint64_t *)operator new(0x30uLL);
    uint64_t v11 = *a5;
    v9[4] = *a4;
    v9[5] = v11;
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  v14,  v10,  v9);
  }

  return v9;
}

void *std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>>::__find_equal<unsigned long long>( void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  unint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (unint64_t v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      unint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      unint64_t v9 = (void *)*a2;
      do
      {
        unint64_t v10 = v9;
        unint64_t v9 = (void *)v9[1];
      }

      while (v9);
    }

    else
    {
      uint64_t v13 = a2;
      do
      {
        unint64_t v10 = (void *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }

      while (v14);
    }

    unint64_t v15 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    char v16 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          BOOL v17 = v16;
          unint64_t v18 = v16[4];
          if (v15 >= v18) {
            break;
          }
          char v16 = (void *)*v17;
          unint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        unint64_t v5 = v17 + 1;
        char v16 = (void *)v17[1];
      }

      while (v16);
    }

    else
    {
      BOOL v17 = a1 + 1;
    }

uint64_t *di_utils::fixed_vector_t<di_asif::details::table_entry>::fixed_vector_t( uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v4 = a2;
  uint64_t result = di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(a1, a2);
  result[5] = *result;
  result[6] = v4;
  if (v4 && a3)
  {
    uint64_t v6 = 0LL;
    do
    {
      unint64_t v7 = (void *)(*result + v6);
      *unint64_t v7 = 0LL;
      v7[1] = 0LL;
      v6 += 16LL;
      --v4;
    }

    while (v4);
  }

  return result;
}

uint64_t *di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t( uint64_t *a1, uint64_t a2)
{
  v12[4] = *MEMORY[0x1895F89C0];
  *a1 = 0LL;
  a1[4] = 0LL;
  BOOL v3 = valloc(16 * a2);
  if (!v3)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v8 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v8, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  v9[0] = off_18A1E28B8;
  unint64_t v10 = v9;
  uint64_t v11 = v3;
  std::__function::__value_func<void ()(di_asif::details::table_entry *)>::__value_func[abi:ne180100]( (uint64_t)v12,  (uint64_t)v9);
  std::unique_ptr<di_asif::details::table_entry,std::function<void ()(di_asif::details::table_entry*)>>::operator=[abi:ne180100]( a1,  (uint64_t *)&v11);
  std::unique_ptr<di_asif::details::table_entry,std::function<void ()(di_asif::details::table_entry*)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v11);
  uint64_t v4 = v10;
  if (v10 == v9)
  {
    uint64_t v5 = 4LL;
    uint64_t v4 = v9;
    goto LABEL_6;
  }

  if (v10)
  {
    uint64_t v5 = 5LL;
LABEL_6:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }

  return a1;
}

void sub_188106230(_Unwind_Exception *a1)
{
}

uint64_t *std::unique_ptr<di_asif::details::table_entry,std::function<void ()(di_asif::details::table_entry*)>>::operator=[abi:ne180100]( uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0LL;
  std::unique_ptr<di_asif::details::table_entry,std::function<void ()(di_asif::details::table_entry*)>>::reset[abi:ne180100]( a1,  v4);
  std::__function::__value_func<void ()(char *)>::operator=[abi:ne180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

void *std::__function::__func<di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(unsigned long)::{lambda(di_asif::details::table_entry*)#1},std::allocator<di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(unsigned long)::{lambda(di_asif::details::table_entry*)#1}>,void ()(di_asif::details::table_entry*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_18A1E28B8;
  return result;
}

void std::__function::__func<di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(unsigned long)::{lambda(di_asif::details::table_entry*)#1},std::allocator<di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(unsigned long)::{lambda(di_asif::details::table_entry*)#1}>,void ()(di_asif::details::table_entry*)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_18A1E28B8;
}

void std::__function::__func<di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(unsigned long)::{lambda(di_asif::details::table_entry*)#1},std::allocator<di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(unsigned long)::{lambda(di_asif::details::table_entry*)#1}>,void ()(di_asif::details::table_entry*)>::operator()( uint64_t a1, void **a2)
{
}

uint64_t std::__function::__func<di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(unsigned long)::{lambda(di_asif::details::table_entry*)#1},std::allocator<di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(unsigned long)::{lambda(di_asif::details::table_entry*)#1}>,void ()(di_asif::details::table_entry*)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(unsigned long)::{lambda(di_asif::details::table_entry*)#1},std::allocator<di_utils::fixed_vector_buffer_t<di_asif::details::table_entry>::fixed_vector_buffer_t(unsigned long)::{lambda(di_asif::details::table_entry*)#1}>,void ()(di_asif::details::table_entry*)>::target_type()
{
}

uint64_t std::__function::__value_func<void ()(di_asif::details::table_entry *)>::__value_func[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  BOOL v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    BOOL v3 = (void *)(a1 + 24);
  }

  *BOOL v3 = 0LL;
  return a1;
}

void std::deque<unsigned long long>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      BOOL v34 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( v5,  v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_188106644( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::make_value<di_asif::details::ContextASIF &,di_asif::details::table &,unsigned long &,unsigned long long &>( uint64_t a1, di_asif::details::ContextASIF *a2, di_asif::details::table *a3, unint64_t *a4, uint64_t *a5)
{
  *(void *)(a1 + 336) = **(void **)(a1 + 328);
  uint64_t v10 = (di_asif::details::map_element *)(a1 + 40);
  std::__optional_destruct_base<di_asif::details::map_element,false>::reset[abi:ne180100]((uint64_t *)(a1 + 40));
  di_asif::details::map_element::map_element(v10, a2, a3, *a4, *a5, 0);
  *(_BYTE *)(a1 + 224) = 1;
  atomic_store(2u, (unsigned int *)(a1 + 24));
  return ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::notify_ready(a1);
}

void sub_188106718(void *a1)
{
  *(_BYTE *)(v1 + 344) = 1;
  ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::notify_ready(v1);
  __cxa_rethrow();
}

void sub_18810673C(_Unwind_Exception *a1)
{
}

uint64_t ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::notify_ready( uint64_t result)
{
  return result;
}

uint64_t ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::make_value<di_asif::details::ContextASIF &,di_asif::details::table &,unsigned long &,unsigned long long &,BOOL>( uint64_t a1, di_asif::details::ContextASIF *a2, di_asif::details::table *a3, unint64_t *a4, uint64_t *a5, char *a6)
{
  *(void *)(a1 + 336) = **(void **)(a1 + 328);
  uint64_t v12 = (di_asif::details::map_element *)(a1 + 40);
  std::__optional_destruct_base<di_asif::details::map_element,false>::reset[abi:ne180100]((uint64_t *)(a1 + 40));
  di_asif::details::map_element::map_element(v12, a2, a3, *a4, *a5, *a6);
  *(_BYTE *)(a1 + 224) = 1;
  atomic_store(2u, (unsigned int *)(a1 + 24));
  return ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::notify_ready(a1);
}

void sub_18810680C(void *a1)
{
  *(_BYTE *)(v1 + 344) = 1;
  ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::notify_ready(v1);
  __cxa_rethrow();
}

void sub_188106830(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<436ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DF908;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881068AC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<450ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DFB28;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188106928(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<547ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DFD48;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881069A4(_Unwind_Exception *a1)
{
}

void *ref::Allocator<di_asif::details::table,unsigned long long>::~Allocator(uint64_t a1)
{
  *(_BYTE *)(a1 + 912) = 0;
  if (*(void *)(a1 + 632))
  {
    unint64_t v3 = 0LL;
    do
    {
      char v4 = (unint64_t *)(*(void *)(a1 + 760) + 8 * v3);
      do
        __int128 v5 = (unint64_t *)__ldaxr(v4);
      while (__stlxr(0LL, v4));
      if (v5)
      {
        unint64_t v1 = v1 & 0xFFFFFFFFFF000000LL | 0x10001;
        ref::Allocator<di_asif::details::table,unsigned long long>::drop_elem(a1, (unint64_t)v5, v1, 0LL);
        ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(v5 + 67);
        ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::~ctrl_blk(v5 + 1);
        operator delete(v5);
      }

      ++v3;
    }

    while (*(void *)(a1 + 632) > v3);
  }

  gcd::gcd_queue::barrier_sync((dispatch_queue_t *)(a1 + 920), &__block_literal_global_7);
  uint64_t v6 = *(void **)(a1 + 760);
  if (v6) {
    operator delete[](v6);
  }
  std::mutex::lock((std::mutex *)(a1 + 696));
  uint64_t v7 = *(void *)(a1 + 656);
  if (*(void *)(a1 + 664) != v7)
  {
    unint64_t v8 = *(void *)(a1 + 680);
    unint64_t v9 = (void *)(v7 + 8 * (v8 >> 9));
    uint64_t v10 = (unint64_t **)(*v9 + 8 * (v8 & 0x1FF));
    uint64_t v11 = *(void *)(v7 + (((*(void *)(a1 + 688) + v8) >> 6) & 0x3FFFFFFFFFFFFF8LL))
        + 8 * ((*(void *)(a1 + 688) + v8) & 0x1FF);
    while (v10 != (unint64_t **)v11)
    {
      uint64_t v12 = *v10;
      if (*v10)
      {
        ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(v12 + 67);
        ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::~ctrl_blk(v12 + 1);
        operator delete(v12);
      }

      if ((unint64_t **)((char *)++v10 - *v9) == (unint64_t **)4096)
      {
        uint64_t v13 = (unint64_t **)v9[1];
        ++v9;
        uint64_t v10 = v13;
      }
    }
  }

  std::mutex::unlock((std::mutex *)(a1 + 696));
  BOOL v14 = *(void **)(a1 + 1792);
  if (v14 == (void *)(a1 + 1768))
  {
    uint64_t v15 = 4LL;
    BOOL v14 = (void *)(a1 + 1768);
  }

  else
  {
    if (!v14) {
      goto LABEL_22;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_22:
  uint64_t v16 = *(void **)(a1 + 1760);
  if (v16 == (void *)(a1 + 1736))
  {
    uint64_t v17 = 4LL;
    uint64_t v16 = (void *)(a1 + 1736);
  }

  else
  {
    if (!v16) {
      goto LABEL_27;
    }
    uint64_t v17 = 5LL;
  }

  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_27:
  ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)(a1 + 1720));
  ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::~ctrl_blk((void *)(a1 + 1192));
  uint64_t v18 = *(void **)(a1 + 1176);
  if (v18 == (void *)(a1 + 1152))
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = (void *)(a1 + 1152);
    goto LABEL_31;
  }

  if (v18)
  {
    uint64_t v19 = 5LL;
LABEL_31:
    (*(void (**)(void))(*v18 + 8 * v19))();
  }

  std::__list_imp<std::pair<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long>>::clear((void *)(a1 + 1128));
  std::mutex::~mutex((std::mutex *)(a1 + 1064));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 1016));
  std::mutex::~mutex((std::mutex *)(a1 + 952));
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::destroy( a1 + 928,  *(void **)(a1 + 936));
  gcd::gcd_group::~gcd_group((dispatch_object_s **)(a1 + 920));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 864));
  std::mutex::~mutex((std::mutex *)(a1 + 800));
  std::mutex::~mutex((std::mutex *)(a1 + 696));
  std::deque<std::atomic<DiskImage::Context *>>::~deque[abi:ne180100]((void *)(a1 + 648));
  return ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::~error_ctrl_blk_t((void *)a1);
}

uint64_t ref::Allocator<di_asif::details::table,unsigned long long>::drop_elem( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  uint64_t v8 = a3 & 0x100;
  uint64_t v9 = (a3 >> 8) & 1;
  uint64_t v10 = (unint64_t *)(a1 + 784);
  do
    unint64_t v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  if ((a3 & 1) != 0)
  {
    uint64_t v12 = (unint64_t *)(a1 + 768);
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
  }

  BOOL v14 = (unsigned int *)(a2 + 544);
  do
    unsigned int v15 = __ldaxr(v14);
  while (__stlxr(v15 | 2, v14));
  ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)(a2 + 536));
  if (a4) {
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(a4);
  }
  if ((a3 & 1) != 0)
  {
    char v16 = atomic_load(v14);
    if ((v16 & 4) == 0)
    {
      uint64_t v17 = (a3 >> 16) & 1;
      do
      {
        if ((*v14 & 1) != 0) {
          break;
        }
        if ((_DWORD)v9)
        {
          std::mutex::lock((std::mutex *)(a1 + 696));
          uint64_t v18 = *(void *)(a1 + 688);
          std::mutex::unlock((std::mutex *)(a1 + 696));
          if (v18) {
            break;
          }
        }

        if (ref::Allocator<di_asif::details::table,unsigned long long>::run_failed_dtors_list( a1,  v17,  0LL,  0) == -1)
        {
          __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)ref::details::_get_tagged_ptr_lock(a2, v19);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          uint64_t tagged_ptr_cond = (std::condition_variable *)ref::details::_get_tagged_ptr_cond(a2, v26);
          v28.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
          uint64_t v38 = a1;
          std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v39 = v28.__d_.__rep_ + 200000;
          unint64_t v35 = a2;
          char v36 = v9;
          *(_DWORD *)uint64_t v37 = *(_DWORD *)v41;
          *(_DWORD *)&v37[3] = *(_DWORD *)&v41[3];
          std::condition_variable::wait_until<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>,ref::Allocator<di_asif::details::table,unsigned long long>::drop_elem(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::Allocator<di_asif::details::table,unsigned long long>::drop_elem_options,ref::tagged_ptr<di_asif::details::table,unsigned long long> *)::{lambda(void)#1}>( tagged_ptr_cond,  &__lk,  &v39,  (uint64_t)&v35);
        }

        else
        {
          __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)ref::details::_get_tagged_ptr_lock(a2, v19);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          uint64_t v21 = ref::details::_get_tagged_ptr_cond(a2, v20);
          char v22 = atomic_load(v14);
          if ((v22 & 4) == 0)
          {
            uint64_t v23 = (std::condition_variable *)v21;
            do
            {
              if ((*v14 & 1) != 0) {
                break;
              }
              if ((_DWORD)v9)
              {
                std::mutex::lock((std::mutex *)(a1 + 696));
                uint64_t v24 = *(void *)(a1 + 688);
                std::mutex::unlock((std::mutex *)(a1 + 696));
                if (v24) {
                  break;
                }
              }

              std::condition_variable::wait(v23, &__lk);
              char v25 = atomic_load(v14);
            }

            while ((v25 & 4) == 0);
          }
        }

        if (__lk.__owns_) {
          std::mutex::unlock(__lk.__m_);
        }
        unsigned int v29 = *v14;
        if (!v8 || (v29 & 1) != 0)
        {
          if ((v29 & 1) != 0) {
            break;
          }
        }

        else if (*(void *)(a1 + 688))
        {
          break;
        }

        char v30 = atomic_load(v14);
      }

      while ((v30 & 4) == 0);
    }

    __int128 v31 = (unint64_t *)(a1 + 768);
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
  }

  do
    unsigned int v33 = __ldaxr(v14);
  while (__stlxr(v33 & 0xFFFFFFFD, v14));
  return v33 & 1;
}

void sub_188106E58( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::mutex *a14, char a15)
{
  if (a15) {
    std::mutex::unlock(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::~tagged_allocated_type( uint64_t a1)
{
  return a1;
}

uint64_t ref::Allocator<di_asif::details::table,unsigned long long>::run_failed_dtors_list( uint64_t a1, int a2, uint64_t a3, unsigned __int8 a4)
{
  if (!*(void *)(a1 + 1144)) {
    return 0LL;
  }
  int64_t v20 = (std::mutex *)(a1 + 1064);
  std::mutex::lock((std::mutex *)(a1 + 1064));
  if (*(void *)(a1 + 1144))
  {
    uint64_t v8 = *(uint64_t **)(a1 + 1136);
    if (v8 == (uint64_t *)(a1 + 1128))
    {
      uint64_t v11 = 1LL;
    }

    else
    {
      uint64_t v9 = a4;
      if (a2) {
        unsigned int v10 = 6;
      }
      else {
        unsigned int v10 = 4;
      }
      uint64_t v11 = 1LL;
      do
      {
        unint64_t v12 = v8[2];
        if ((ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::reset_val( v12 + 8,  v8[3],  v10) | a2) == 1)
        {
          tagged_ptr_lock = (std::mutex *)ref::details::_get_tagged_ptr_lock(v12, v13);
          std::mutex::lock(tagged_ptr_lock);
          unsigned int v15 = (unsigned int *)(v12 + 544);
          do
            unsigned int v16 = __ldaxr(v15);
          while (__stlxr(v16 & 0xFFFFFFFB, v15));
          std::mutex::unlock(tagged_ptr_lock);
          uint64_t v17 = *v8;
          uint64_t v18 = (uint64_t *)v8[1];
          *(void *)(v17 + 8) = v18;
          *(void *)v8[1] = v17;
          --*(void *)(a1 + 1144);
          operator delete(v8);
          uint64_t v8 = v18;
        }

        else
        {
          if (!v9 || v8[3] == a3) {
            uint64_t v11 = 0xFFFFFFFFLL;
          }
          uint64_t v8 = (uint64_t *)v8[1];
        }
      }

      while (v8 != (uint64_t *)(a1 + 1128));
    }
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  std::mutex::unlock(v20);
  return v11;
}

void sub_188107004( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10)
{
}

uint64_t std::condition_variable::wait_until<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>,ref::Allocator<di_asif::details::table,unsigned long long>::drop_elem(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::Allocator<di_asif::details::table,unsigned long long>::drop_elem_options,ref::tagged_ptr<di_asif::details::table,unsigned long long> *)::{lambda(void)#1}>( std::condition_variable *a1, std::unique_lock<std::mutex> *a2, uint64_t *a3, uint64_t a4)
{
  do
  {
    uint64_t v8 = *(void *)(a4 + 16);
    char v9 = atomic_load((unsigned int *)(*(void *)a4 + 544LL));
    if ((v9 & 4) != 0) {
      return 1LL;
    }
    if ((*(_DWORD *)(*(void *)a4 + 544LL) & 1) != 0) {
      return 1LL;
    }
    if (*(_BYTE *)(a4 + 8))
    {
      unsigned int v10 = (std::mutex *)(v8 + 696);
      std::mutex::lock((std::mutex *)(v8 + 696));
      uint64_t v11 = *(void *)(v8 + 688);
      std::mutex::unlock(v10);
      if (v11) {
        return 1LL;
      }
    }

    v12.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    uint64_t v13 = *a3;
    if (*a3 <= v12.__d_.__rep_) {
      break;
    }
    if (!v13)
    {
      v14.__d_.__rep_ = 0LL;
      goto LABEL_14;
    }

    if (v13 < 1)
    {
      if ((unint64_t)v13 < 0xFFDF3B645A1CAC09LL)
      {
        v14.__d_.__rep_ = 0x8000000000000000LL;
        goto LABEL_14;
      }
    }

    else if ((unint64_t)v13 > 0x20C49BA5E353F7LL)
    {
      v14.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
      goto LABEL_14;
    }

    v14.__d_.__rep_ = 1000 * v13;
LABEL_14:
    std::condition_variable::__do_timed_wait(a1, a2, v14);
  }

  while (std::chrono::system_clock::now().__d_.__rep_ < *a3);
  uint64_t v15 = *(void *)(a4 + 16);
  char v16 = atomic_load((unsigned int *)(*(void *)a4 + 544LL));
  if ((v16 & 4) != 0 || (*(_DWORD *)(*(void *)a4 + 544LL) & 1) != 0) {
    return 1LL;
  }
  if (!*(_BYTE *)(a4 + 8)) {
    return 0LL;
  }
  std::mutex::lock((std::mutex *)(v15 + 696));
  BOOL v17 = *(void *)(v15 + 688) != 0LL;
  std::mutex::unlock((std::mutex *)(v15 + 696));
  return v17;
}

void *ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::~ctrl_blk(void *a1)
{
  unint64_t v2 = a1 + 59;
  unint64_t v3 = (void *)a1[62];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    unint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  __int128 v5 = (void *)a1[58];
  if (v5 == a1 + 55)
  {
    uint64_t v6 = 4LL;
    __int128 v5 = a1 + 55;
  }

  else
  {
    if (!v5) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  uint64_t v7 = (void *)a1[54];
  if (v7 == a1 + 51)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = a1 + 51;
    goto LABEL_15;
  }

  if (v7)
  {
    uint64_t v8 = 5LL;
LABEL_15:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  std::__optional_destruct_base<di_asif::details::table,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)(a1 + 5));
  return a1;
}

uint64_t std::__optional_destruct_base<di_asif::details::table,false>::~__optional_destruct_base[abi:ne180100]( uint64_t a1)
{
  if (*(_BYTE *)(a1 + 360))
  {
    std::mutex::~mutex((std::mutex *)(a1 + 280));
    std::deque<std::atomic<DiskImage::Context *>>::~deque[abi:ne180100]((void *)(a1 + 232));
    std::mutex::~mutex((std::mutex *)(a1 + 168));
    std::mutex::~mutex((std::mutex *)(a1 + 104));
    unint64_t v2 = *(void **)(a1 + 72);
    if (v2)
    {
      *(void *)(a1 + 80) = v2;
      operator delete(v2);
    }

    std::unique_ptr<di_asif::details::table_entry,std::function<void ()(di_asif::details::table_entry*)>>::~unique_ptr[abi:ne180100]((uint64_t *)(a1 + 16));
  }

  return a1;
}

void *std::__list_imp<std::pair<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long>>::clear( void *result)
{
  if (result[2])
  {
    unint64_t v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8LL);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0LL;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        uint64_t result = v4;
      }

      while (v4 != v1);
    }
  }

  return result;
}

void *ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::~error_ctrl_blk_t( void *a1)
{
  uint64_t v2 = a1 + 13;
  do
  {
    unint64_t v3 = __ldaxr(v2);
    unint64_t v4 = v3 - 1;
  }

  while (__stlxr(v4, v2));
  if (!v4)
  {
    uint64_t v5 = a1[17];
    a1[17] = -1LL;
    ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::reset_val((uint64_t)(a1 + 13), v5, 1u);
  }

  ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::~ctrl_blk(v2);
  uint64_t v6 = (void *)a1[11];
  if (v6 == a1 + 8)
  {
    uint64_t v7 = 4LL;
    uint64_t v6 = a1 + 8;
  }

  else
  {
    if (!v6) {
      goto LABEL_10;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_10:
  uint64_t v8 = (void *)a1[7];
  if (v8 == a1 + 4)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = a1 + 4;
  }

  else
  {
    if (!v8) {
      goto LABEL_15;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_15:
  unsigned int v10 = (void *)a1[3];
  if (v10 == a1)
  {
    uint64_t v11 = 4LL;
    unsigned int v10 = a1;
    goto LABEL_19;
  }

  if (v10)
  {
    uint64_t v11 = 5LL;
LABEL_19:
    (*(void (**)(void))(*v10 + 8 * v11))();
  }

  return a1;
}

void *ref::Allocator<di_asif::details::map_element,unsigned long long>::~Allocator(uint64_t a1)
{
  *(_BYTE *)(a1 + 736) = 0;
  if (*(void *)(a1 + 456))
  {
    unint64_t v3 = 0LL;
    do
    {
      unint64_t v4 = (unint64_t *)(*(void *)(a1 + 584) + 8 * v3);
      do
        uint64_t v5 = (unint64_t *)__ldaxr(v4);
      while (__stlxr(0LL, v4));
      if (v5)
      {
        unint64_t v1 = v1 & 0xFFFFFFFFFF000000LL | 0x10001;
        ref::Allocator<di_asif::details::map_element,unsigned long long>::drop_elem(a1, (unint64_t)v5, v1, 0LL);
        ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(v5 + 45);
        ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::~ctrl_blk(v5 + 1);
        operator delete(v5);
      }

      ++v3;
    }

    while (*(void *)(a1 + 456) > v3);
  }

  gcd::gcd_queue::barrier_sync((dispatch_queue_t *)(a1 + 744), &__block_literal_global_201);
  uint64_t v6 = *(void **)(a1 + 584);
  if (v6) {
    operator delete[](v6);
  }
  std::mutex::lock((std::mutex *)(a1 + 520));
  uint64_t v7 = *(void *)(a1 + 480);
  if (*(void *)(a1 + 488) != v7)
  {
    unint64_t v8 = *(void *)(a1 + 504);
    uint64_t v9 = (void *)(v7 + 8 * (v8 >> 9));
    unsigned int v10 = (unint64_t **)(*v9 + 8 * (v8 & 0x1FF));
    uint64_t v11 = *(void *)(v7 + (((*(void *)(a1 + 512) + v8) >> 6) & 0x3FFFFFFFFFFFFF8LL))
        + 8 * ((*(void *)(a1 + 512) + v8) & 0x1FF);
    while (v10 != (unint64_t **)v11)
    {
      std::chrono::system_clock::time_point v12 = *v10;
      if (*v10)
      {
        ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset(v12 + 45);
        ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::~ctrl_blk(v12 + 1);
        operator delete(v12);
      }

      if ((unint64_t **)((char *)++v10 - *v9) == (unint64_t **)4096)
      {
        uint64_t v13 = (unint64_t **)v9[1];
        ++v9;
        unsigned int v10 = v13;
      }
    }
  }

  std::mutex::unlock((std::mutex *)(a1 + 520));
  std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v14 = *(void **)(a1 + 1440);
  if (v14 == (void *)(a1 + 1416))
  {
    uint64_t v15 = 4LL;
    std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v14 = (void *)(a1 + 1416);
  }

  else
  {
    if (!v14) {
      goto LABEL_22;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_22:
  char v16 = *(void **)(a1 + 1408);
  if (v16 == (void *)(a1 + 1384))
  {
    uint64_t v17 = 4LL;
    char v16 = (void *)(a1 + 1384);
  }

  else
  {
    if (!v16) {
      goto LABEL_27;
    }
    uint64_t v17 = 5LL;
  }

  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_27:
  ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)(a1 + 1368));
  ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::~ctrl_blk((void *)(a1 + 1016));
  uint64_t v18 = *(void **)(a1 + 1000);
  if (v18 == (void *)(a1 + 976))
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = (void *)(a1 + 976);
    goto LABEL_31;
  }

  if (v18)
  {
    uint64_t v19 = 5LL;
LABEL_31:
    (*(void (**)(void))(*v18 + 8 * v19))();
  }

  std::__list_imp<std::pair<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long>>::clear((void *)(a1 + 952));
  std::mutex::~mutex((std::mutex *)(a1 + 888));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 840));
  std::mutex::~mutex((std::mutex *)(a1 + 776));
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::destroy( a1 + 752,  *(void **)(a1 + 760));
  gcd::gcd_group::~gcd_group((dispatch_object_s **)(a1 + 744));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 688));
  std::mutex::~mutex((std::mutex *)(a1 + 624));
  std::mutex::~mutex((std::mutex *)(a1 + 520));
  std::deque<std::atomic<DiskImage::Context *>>::~deque[abi:ne180100]((void *)(a1 + 472));
  return ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::~error_ctrl_blk_t((void *)a1);
}

uint64_t ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::~tagged_allocated_type( uint64_t a1)
{
  return a1;
}

void *ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::~ctrl_blk(void *a1)
{
  uint64_t v2 = a1 + 37;
  unint64_t v3 = (void *)a1[40];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    unint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  uint64_t v5 = (void *)a1[36];
  if (v5 == a1 + 33)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = a1 + 33;
  }

  else
  {
    if (!v5) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  uint64_t v7 = (void *)a1[32];
  if (v7 == a1 + 29)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = a1 + 29;
    goto LABEL_15;
  }

  if (v7)
  {
    uint64_t v8 = 5LL;
LABEL_15:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  std::__optional_destruct_base<di_asif::details::map_element,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)(a1 + 5));
  return a1;
}

uint64_t std::__optional_destruct_base<di_asif::details::map_element,false>::~__optional_destruct_base[abi:ne180100]( uint64_t a1)
{
  if (*(_BYTE *)(a1 + 184))
  {
    std::mutex::~mutex((std::mutex *)(a1 + 120));
    *(void *)(a1 + 32) = off_18A1D9F40;
    std::unique_ptr<unsigned long long,std::function<void ()(unsigned long long *)>>::~unique_ptr[abi:ne180100]((uint64_t *)(a1 + 56));
  }

  return a1;
}

void *ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::~error_ctrl_blk_t( void *a1)
{
  uint64_t v2 = a1 + 13;
  do
  {
    unint64_t v3 = __ldaxr(v2);
    unint64_t v4 = v3 - 1;
  }

  while (__stlxr(v4, v2));
  if (!v4)
  {
    uint64_t v5 = a1[17];
    a1[17] = -1LL;
    ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::reset_val((uint64_t)(a1 + 13), v5, 1u);
  }

  ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::~ctrl_blk(v2);
  uint64_t v6 = (void *)a1[11];
  if (v6 == a1 + 8)
  {
    uint64_t v7 = 4LL;
    uint64_t v6 = a1 + 8;
  }

  else
  {
    if (!v6) {
      goto LABEL_10;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_10:
  uint64_t v8 = (void *)a1[7];
  if (v8 == a1 + 4)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = a1 + 4;
  }

  else
  {
    if (!v8) {
      goto LABEL_15;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_15:
  unsigned int v10 = (void *)a1[3];
  if (v10 == a1)
  {
    uint64_t v11 = 4LL;
    unsigned int v10 = a1;
    goto LABEL_19;
  }

  if (v10)
  {
    uint64_t v11 = 5LL;
LABEL_19:
    (*(void (**)(void))(*v10 + 8 * v11))();
  }

  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<863ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1DFFE8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881078D8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<888ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E0208;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188107954(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<900ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E0428;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881079D0(_Unwind_Exception *a1)
{
}

__n128 std::__function::__func<di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0,std::allocator<di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0>,void ()(char const*)>::__clone( uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_18A1E29C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0,std::allocator<di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0>,void ()(char const*)>::__clone( uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_18A1E29C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0,std::allocator<di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0>,void ()(char const*)>::operator()( uint64_t a1, uint64_t *a2)
{
}

uint64_t std::__function::__func<di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0,std::allocator<di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0>,void ()(char const*)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0,std::allocator<di_asif::details::table::flush(di_asif::details::ContextASIF &)::$_0>,void ()(char const*)>::target_type()
{
}

void *std::deque<unsigned long long>::__insert_bidirectional[abi:ne180100]<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>( void **a1, char *a2, uint64_t a3, void *a4, char *a5, void *a6, char *a7, unint64_t a8)
{
  unint64_t v8 = a8;
  unint64_t v14 = (unint64_t)a1[4];
  unint64_t v15 = v14 >> 9;
  char v16 = a1[1];
  uint64_t v17 = a1[2];
  uint64_t v18 = &v16[8 * (v14 >> 9)];
  if (v17 == v16) {
    uint64_t v19 = 0LL;
  }
  else {
    uint64_t v19 = *(void *)v18 + 8 * ((unint64_t)a1[4] & 0x1FF);
  }
  if (a3 == v19) {
    unint64_t v20 = 0LL;
  }
  else {
    unint64_t v20 = ((a3 - *(void *)a2) >> 3) + ((a2 - v18) << 6) - ((v19 - *(void *)v18) >> 3);
  }
  uint64_t v21 = (char *)a1[5];
  if (v20 >= (unint64_t)&v21[-v20])
  {
    uint64_t v24 = ((v17 - v16) << 6) - 1;
    if (v17 == v16) {
      uint64_t v24 = 0LL;
    }
    unint64_t v25 = (unint64_t)&v21[v14];
    unint64_t v26 = v24 - v25;
    if (a8 > v26)
    {
      std::deque<unsigned long long>::__add_back_capacity(a1, a8 - v26);
      uint64_t v21 = (char *)a1[5];
      char v16 = a1[1];
      uint64_t v17 = a1[2];
      unint64_t v25 = (unint64_t)&v21[(void)a1[4]];
    }

    unint64_t v88 = (char **)a6;
    unint64_t v27 = (char **)&v16[8 * (v25 >> 9)];
    if (v17 == v16) {
      std::chrono::system_clock::time_point v28 = 0LL;
    }
    else {
      std::chrono::system_clock::time_point v28 = &(*v27)[8 * (v25 & 0x1FF)];
    }
    v90.n128_u64[0] = (unint64_t)&v16[8 * (v25 >> 9)];
    v90.n128_u64[1] = (unint64_t)v28;
    unint64_t v31 = (unint64_t)&v21[-v20];
    unint64_t v87 = (char **)a4;
    if ((unint64_t)&v21[-v20] >= v8)
    {
      BOOL v34 = a7;
      if (!v8) {
        goto LABEL_90;
      }
      goto LABEL_78;
    }

    if (v31 >= v8 >> 1)
    {
      uint64_t v32 = (uint64_t)&v21[-v20 - v8 + ((a7 - *v88) >> 3)];
      if (v32 >= 1)
      {
        v88 += (unint64_t)v32 >> 9;
        unsigned int v33 = *v88;
        goto LABEL_39;
      }

      unint64_t v37 = 511 - v32;
      __int16 v38 = ~(_WORD)v37;
      v88 -= v37 >> 9;
      std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v39 = *v88;
    }

    else
    {
      if (!v31)
      {
        unint64_t v88 = (char **)a4;
        BOOL v34 = a5;
        goto LABEL_69;
      }

      uint64_t v32 = v31 + ((uint64_t)&a5[-*a4] >> 3);
      if (v32 >= 1)
      {
        unint64_t v88 = (char **)&a4[(unint64_t)v32 >> 9];
        unsigned int v33 = *v88;
LABEL_39:
        BOOL v34 = &v33[8 * (v32 & 0x1FF)];
        goto LABEL_69;
      }

      unint64_t v64 = 511 - v32;
      __int16 v38 = ~(_WORD)v64;
      unint64_t v88 = (char **)&a4[-(v64 >> 9)];
      std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v39 = *v88;
    }

    BOOL v34 = &v39[8 * (v38 & 0x1FF)];
LABEL_69:
    if (v34 != a7)
    {
      unint64_t v65 = *v27;
      uint64_t v66 = v88;
      unint64_t v67 = v34;
      do
      {
        *(void *)std::chrono::system_clock::time_point v28 = *(void *)v67;
        v28 += 8;
        if (v28 - v65 == 4096)
        {
          unint64_t v68 = v27[1];
          ++v27;
          unint64_t v65 = v68;
          std::chrono::system_clock::time_point v28 = v68;
        }

        v67 += 8;
        if (v67 - *v66 == 4096)
        {
          uint64_t v69 = v66[1];
          ++v66;
          unint64_t v67 = v69;
        }

        ++v21;
      }

      while (v67 != a7);
      a1[5] = v21;
    }

    unint64_t v8 = v31;
    if (!v31) {
      goto LABEL_90;
    }
LABEL_78:
    unint64_t v70 = (char **)std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>::operator-[abi:ne180100]( (uint64_t)&v90,  v8);
    uint64_t v72 = v70;
    unint64_t v73 = v71;
    unint64_t v74 = (char *)v90.n128_u64[1];
    if ((char *)v90.n128_u64[1] != v71)
    {
      char v75 = (char *)a1[5];
      uint64_t v76 = *v27;
      unint64_t v77 = v70;
      unint64_t v78 = v71;
      do
      {
        *(void *)std::chrono::system_clock::time_point v28 = *(void *)v78;
        v28 += 8;
        if (v28 - v76 == 4096)
        {
          uint64_t v79 = v27[1];
          ++v27;
          uint64_t v76 = v79;
          std::chrono::system_clock::time_point v28 = v79;
        }

        v78 += 8;
        if (&v78[-*v77] == (char *)4096)
        {
          unint64_t v80 = (char *)v77[1];
          ++v77;
          unint64_t v78 = v80;
        }

        ++v75;
      }

      while (v78 != v74);
      a1[5] = v75;
    }

    if (v8 >= v31)
    {
      unint64_t v83 = (void *)v90.n128_u64[0];
    }

    else
    {
      uint64_t v81 = (char **)std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>::operator-[abi:ne180100]( (uint64_t)&v90,  v31);
      std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>( v81,  v82,  v72,  v73,  v90.n128_u64[0],  (char *)v90.n128_u64[1],  &v91);
      unint64_t v74 = (char *)v92.n128_u64[1];
      unint64_t v83 = (void *)v92.n128_u64[0];
      __n128 v90 = v92;
    }

    std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>( v87,  a5,  v88,  v34,  v83,  v74,  &v91);
    goto LABEL_90;
  }

  if (a8 > v14)
  {
    std::deque<unsigned long long>::__add_front_capacity(a1, a8 - v14);
    unint64_t v14 = (unint64_t)a1[4];
    char v16 = a1[1];
    uint64_t v17 = a1[2];
    unint64_t v15 = v14 >> 9;
  }

  char v22 = (uint64_t *)&v16[8 * v15];
  if (v17 == v16) {
    uint64_t v23 = 0LL;
  }
  else {
    uint64_t v23 = *v22 + 8 * (v14 & 0x1FF);
  }
  v90.n128_u64[0] = (unint64_t)&v16[8 * v15];
  v90.n128_u64[1] = v23;
  if (v8 <= v20)
  {
    char v30 = a5;
    if (!v8) {
      goto LABEL_90;
    }
    goto LABEL_55;
  }

  if (v20 >= v8 >> 1)
  {
    uint64_t v29 = v8 - v20 + ((uint64_t)&a5[-*a4] >> 3);
    if (v29 >= 1)
    {
      a4 += (unint64_t)v29 >> 9;
      goto LABEL_36;
    }

    unint64_t v35 = 511 - v29;
    __int16 v36 = ~(_WORD)v35;
    a4 -= v35 >> 9;
  }

  else
  {
    if (!v20)
    {
      a4 = a6;
      char v30 = a7;
      goto LABEL_46;
    }

    uint64_t v29 = ((uint64_t)&a7[-*a6] >> 3) - v20;
    if (v29 >= 1)
    {
      a4 = &a6[(unint64_t)v29 >> 9];
LABEL_36:
      char v30 = (char *)(*a4 + 8 * (v29 & 0x1FF));
      goto LABEL_46;
    }

    unint64_t v40 = 511 - v29;
    __int16 v36 = ~(_WORD)v40;
    a4 = &a6[-(v40 >> 9)];
  }

  char v30 = (char *)(*a4 + 8LL * (v36 & 0x1FF));
LABEL_46:
  if (v30 != a5)
  {
    unint64_t v41 = (char *)a1[5];
    uint64_t v42 = *v22;
    unint64_t v43 = (char **)a4;
    unint64_t v44 = v30;
    do
    {
      if (v23 == v42)
      {
        uint64_t v45 = *--v22;
        uint64_t v42 = v45;
        uint64_t v23 = v45 + 4096;
      }

      if (v44 == *v43)
      {
        uint64_t v46 = (uint64_t)*--v43;
        unint64_t v44 = (char *)(v46 + 4096);
      }

      uint64_t v47 = *((void *)v44 - 1);
      v44 -= 8;
      *(void *)(v23 - 8) = v47;
      v23 -= 8LL;
      --v14;
      ++v41;
    }

    while (v44 != a5);
    a1[4] = (void *)v14;
    a1[5] = v41;
  }

  unint64_t v8 = v20;
  if (v20)
  {
LABEL_55:
    unint64_t v89 = (char **)a6;
    std::unique_lock<std::mutex> v48 = (char **)a4;
    uint64_t v49 = (char **)std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>::operator+[abi:ne180100]( (uint64_t)&v90,  v8);
    unint64_t v51 = v49;
    uint64_t v52 = v50;
    unint64_t v53 = v90.n128_u64[1];
    if ((char *)v90.n128_u64[1] != v50)
    {
      int64x2_t v54 = *((int64x2_t *)a1 + 2);
      uint64_t v55 = *v22;
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v56 = v49;
      uint64_t v57 = v50;
      do
      {
        if (v23 == v55)
        {
          uint64_t v58 = *--v22;
          uint64_t v55 = v58;
          uint64_t v23 = v58 + 4096;
        }

        if (v57 == *v56)
        {
          uint64_t v59 = (uint64_t)*--v56;
          uint64_t v57 = (char *)(v59 + 4096);
        }

        uint64_t v60 = *((void *)v57 - 1);
        v57 -= 8;
        *(void *)(v23 - 8) = v60;
        v23 -= 8LL;
        int64x2_t v54 = vaddq_s64(v54, (int64x2_t)xmmword_18817DE70);
      }

      while (v57 != (char *)v53);
      *((int64x2_t *)a1 + 2) = v54;
    }

    if (v8 >= v20)
    {
      unint64_t v63 = v90.n128_u64[0];
    }

    else
    {
      unint64_t v61 = (char **)std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>::operator+[abi:ne180100]( (uint64_t)&v90,  v20);
      __n128 v91 = v90;
      std::__for_each_segment[abi:ne180100]<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>>( v51,  v52,  v61,  v62,  (uint64_t)&v91);
      unint64_t v53 = v91.n128_u64[1];
      unint64_t v63 = v91.n128_u64[0];
      __n128 v90 = v91;
    }

    v91.n128_u64[0] = v63;
    v91.n128_u64[1] = v53;
    std::__for_each_segment[abi:ne180100]<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>>( v48,  v30,  v89,  a7,  (uint64_t)&v91);
  }

LABEL_90:
  unint64_t v84 = a1[1];
  if (a1[2] == v84) {
    uint64_t v85 = 0LL;
  }
  else {
    uint64_t v85 = v84[(unint64_t)a1[4] >> 9] + 8 * ((unint64_t)a1[4] & 0x1FF);
  }
  v91.n128_u64[0] = (unint64_t)&v84[(unint64_t)a1[4] >> 9];
  v91.n128_u64[1] = v85;
  return std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>::operator+[abi:ne180100]( (uint64_t)&v91,  v20);
}

void std::deque<unsigned long long>::__add_front_capacity(void **a1, unint64_t a2)
{
  unint64_t v3 = a1[1];
  char v4 = a1[2];
  uint64_t v5 = v4 - v3;
  if (v4 == v3) {
    unint64_t v6 = a2 + 1;
  }
  else {
    unint64_t v6 = a2;
  }
  if (v4 == v3) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = ((v4 - v3) << 6) - 1;
  }
  if ((v6 & 0x1FF) != 0) {
    unint64_t v8 = (v6 >> 9) + 1;
  }
  else {
    unint64_t v8 = v6 >> 9;
  }
  uint64_t v9 = (uint64_t)a1[4];
  unint64_t v10 = v7 - ((void)a1[5] + v9);
  if (v8 >= v10 >> 9) {
    unint64_t v11 = v10 >> 9;
  }
  else {
    unint64_t v11 = v8;
  }
  if (v8 <= v10 >> 9)
  {
    for (a1[4] = (void *)(v9 + (v11 << 9)); v11; --v11)
    {
      uint64_t v19 = (void **)a1[2];
      __p[0] = *(v19 - 1);
      a1[2] = v19 - 1;
      std::__split_buffer<std::atomic<DiskImage::Context *> *,std::allocator<std::atomic<DiskImage::Context *> *>>::push_front( (uint64_t)a1,  __p);
    }
  }

  else
  {
    uint64_t v12 = (uint64_t)(a1 + 3);
    unint64_t v13 = v8 - v11;
    uint64_t v14 = (_BYTE *)a1[3] - (_BYTE *)*a1;
    if (v8 - v11 <= (v14 >> 3) - (v5 >> 3))
    {
      if (v13)
      {
        if (v3 == *a1)
        {
LABEL_30:
          unint64_t v22 = v13;
          do
          {
            __p[0] = operator new(0x1000uLL);
            std::__split_buffer<std::atomic<DiskImage::Context *> *,std::allocator<std::atomic<DiskImage::Context *> *>>::push_back( a1,  __p);
            --v22;
          }

          while (v22);
          v11 += v13;
          uint64_t v9 = (uint64_t)a1[4];
        }

        else
        {
          while (1)
          {
            __p[0] = operator new(0x1000uLL);
            std::__split_buffer<std::atomic<DiskImage::Context *> *,std::allocator<std::atomic<DiskImage::Context *> *>>::push_front( (uint64_t)a1,  __p);
            unint64_t v20 = a1[1];
            uint64_t v21 = (_BYTE *)a1[2] - v20 == 8 ? 511LL : 512LL;
            uint64_t v9 = (uint64_t)a1[4] + v21;
            a1[4] = (void *)v9;
            if (!--v13) {
              break;
            }
            if (v20 == *a1) {
              goto LABEL_30;
            }
          }
        }
      }

      for (a1[4] = (void *)(v9 + (v11 << 9)); v11; --v11)
      {
        uint64_t v23 = (void **)a1[2];
        __p[0] = *(v23 - 1);
        a1[2] = v23 - 1;
        std::__split_buffer<std::atomic<DiskImage::Context *> *,std::allocator<std::atomic<DiskImage::Context *> *>>::push_front( (uint64_t)a1,  __p);
      }
    }

    else
    {
      BOOL v15 = v4 == v3;
      unint64_t v16 = v8 << 9;
      if (v14 >> 2 <= v13 + (v5 >> 3)) {
        unint64_t v17 = v13 + (v5 >> 3);
      }
      else {
        unint64_t v17 = v14 >> 2;
      }
      unint64_t v70 = a1 + 3;
      if (v17) {
        uint64_t v18 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( v12,  v17);
      }
      else {
        uint64_t v18 = 0LL;
      }
      unint64_t v24 = v16 - v15;
      __p[0] = v18;
      __p[1] = v18;
      unint64_t v68 = v18;
      uint64_t v69 = &v18[8 * v17];
      do
      {
        uint64_t v66 = operator new(0x1000uLL);
        std::__split_buffer<std::atomic<DiskImage::Context *> *,std::allocator<std::atomic<DiskImage::Context *> *> &>::push_back( __p,  &v66);
        --v13;
      }

      while (v13);
      unint64_t v25 = (char *)a1[2];
      for (unint64_t i = v68; v11; --v11)
      {
        if (i == v69)
        {
          int64_t v27 = (char *)__p[1] - (char *)__p[0];
          if (__p[1] <= __p[0])
          {
            if (i == __p[0]) {
              unint64_t v35 = 1LL;
            }
            else {
              unint64_t v35 = (i - (char *)__p[0]) >> 2;
            }
            __int16 v36 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( (uint64_t)v70,  v35);
            __int16 v38 = (uint64_t *)__p[1];
            unint64_t i = &v36[8 * (v35 >> 2)];
            uint64_t v39 = v68 - (char *)__p[1];
            if (v68 != __p[1])
            {
              unint64_t i = &v36[8 * (v35 >> 2) + (v39 & 0xFFFFFFFFFFFFFFF8LL)];
              uint64_t v40 = 8 * (v39 >> 3);
              unint64_t v41 = &v36[8 * (v35 >> 2)];
              do
              {
                uint64_t v42 = *v38++;
                *(void *)unint64_t v41 = v42;
                v41 += 8;
                v40 -= 8LL;
              }

              while (v40);
            }

            unint64_t v43 = __p[0];
            __p[0] = v36;
            __p[1] = &v36[8 * (v35 >> 2)];
            unint64_t v68 = i;
            uint64_t v69 = &v36[8 * v37];
            if (v43)
            {
              operator delete(v43);
              unint64_t i = v68;
            }
          }

          else
          {
            uint64_t v28 = v27 >> 3;
            BOOL v29 = v27 >> 3 < -1;
            uint64_t v30 = (v27 >> 3) + 2;
            if (v29) {
              uint64_t v31 = v30;
            }
            else {
              uint64_t v31 = v28 + 1;
            }
            uint64_t v32 = (char *)__p[1] - 8 * (v31 >> 1);
            int64_t v33 = i - (char *)__p[1];
            if (i != __p[1])
            {
              memmove((char *)__p[1] - 8 * (v31 >> 1), __p[1], i - (char *)__p[1]);
              unint64_t i = (char *)__p[1];
            }

            BOOL v34 = &i[-8 * (v31 >> 1)];
            unint64_t i = &v32[v33];
            __p[1] = v34;
            unint64_t v68 = &v32[v33];
          }
        }

        *(void *)unint64_t i = *((void *)v25 - 1);
        unint64_t i = v68 + 8;
        v68 += 8;
        unint64_t v25 = (char *)a1[2] - 8;
        a1[2] = v25;
      }

      unint64_t v44 = (char *)a1[1];
      if (v44 == v25)
      {
        unint64_t v44 = v25;
      }

      else
      {
        do
        {
          if (i == v69)
          {
            int64_t v45 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (i == __p[0]) {
                unint64_t v52 = 1LL;
              }
              else {
                unint64_t v52 = (i - (char *)__p[0]) >> 2;
              }
              unint64_t v53 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( (uint64_t)v70,  v52);
              uint64_t v55 = (uint64_t *)__p[1];
              unint64_t i = &v53[8 * (v52 >> 2)];
              uint64_t v56 = v68 - (char *)__p[1];
              if (v68 != __p[1])
              {
                unint64_t i = &v53[8 * (v52 >> 2) + (v56 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v57 = 8 * (v56 >> 3);
                uint64_t v58 = &v53[8 * (v52 >> 2)];
                do
                {
                  uint64_t v59 = *v55++;
                  *(void *)uint64_t v58 = v59;
                  v58 += 8;
                  v57 -= 8LL;
                }

                while (v57);
              }

              uint64_t v60 = __p[0];
              __p[0] = v53;
              __p[1] = &v53[8 * (v52 >> 2)];
              unint64_t v68 = i;
              uint64_t v69 = &v53[8 * v54];
              if (v60)
              {
                operator delete(v60);
                unint64_t i = v68;
              }
            }

            else
            {
              uint64_t v46 = v45 >> 3;
              BOOL v29 = v45 >> 3 < -1;
              uint64_t v47 = (v45 >> 3) + 2;
              if (v29) {
                uint64_t v48 = v47;
              }
              else {
                uint64_t v48 = v46 + 1;
              }
              uint64_t v49 = (char *)__p[1] - 8 * (v48 >> 1);
              int64_t v50 = i - (char *)__p[1];
              if (i != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v48 >> 1), __p[1], i - (char *)__p[1]);
                unint64_t i = (char *)__p[1];
              }

              unint64_t v51 = &i[-8 * (v48 >> 1)];
              unint64_t i = &v49[v50];
              __p[1] = v51;
              unint64_t v68 = &v49[v50];
            }
          }

          uint64_t v61 = *(void *)v44;
          v44 += 8;
          *(void *)unint64_t i = v61;
          unint64_t i = v68 + 8;
          v68 += 8;
        }

        while (v44 != a1[2]);
        unint64_t v25 = (char *)a1[1];
      }

      unint64_t v62 = v69;
      unint64_t v63 = (char *)a1[3];
      unint64_t v64 = (char *)a1[4];
      a1[2] = i;
      a1[3] = v62;
      unint64_t v65 = *a1;
      *(_OWORD *)a1 = *(_OWORD *)__p;
      __p[0] = v65;
      __p[1] = v25;
      unint64_t v68 = v44;
      uint64_t v69 = v63;
      a1[4] = &v64[v24];
      if (v44 != v25) {
        unint64_t v68 = &v44[(v25 - v44 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v65) {
        operator delete(v65);
      }
    }
  }

void sub_18810849C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>::operator+[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = a2 + ((uint64_t)(*(void *)(a1 + 8) - *result) >> 3);
    if (v4 < 1) {
      result -= (unint64_t)(511 - v4) >> 9;
    }
    else {
      result += (unint64_t)v4 >> 9;
    }
  }

  return result;
}

void std::deque<unsigned long long>::__add_back_capacity(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      unint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      unint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          BOOL v29 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( (uint64_t)(a1 + 3),  v28);
          uint64_t v31 = &v29[8 * (v28 >> 2)];
          uint64_t v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            unint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)unint64_t v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          unint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }

          int64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          std::__split_buffer<std::atomic<DiskImage::Context *> *,std::allocator<std::atomic<DiskImage::Context *> *>>::push_back( a1,  __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          std::__split_buffer<std::atomic<DiskImage::Context *> *,std::allocator<std::atomic<DiskImage::Context *> *>>::push_front( (uint64_t)a1,  __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 511LL;
          }
          else {
            uint64_t v64 = 512LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        uint64_t v66 = (char *)a1[2];
        do
        {
          unint64_t v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          unint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              uint64_t v79 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( (uint64_t)(a1 + 3),  v78);
              uint64_t v81 = &v79[8 * (v78 >> 2)];
              uint64_t v82 = (uint64_t *)a1[1];
              uint64_t v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                uint64_t v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                uint64_t v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)uint64_t v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              unint64_t v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                uint64_t v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              char v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                uint64_t v66 = (char *)a1[1];
              }

              unint64_t v77 = &v66[-8 * (v74 >> 1)];
              uint64_t v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)uint64_t v66 = v69;
          uint64_t v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      __n128 v91 = a1 + 3;
      if (v13) {
        BOOL v15 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( (uint64_t)(a1 + 3),  v13);
      }
      else {
        BOOL v15 = 0LL;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        unint64_t v88 = operator new(0x1000uLL);
        std::__split_buffer<std::atomic<DiskImage::Context *> *,std::allocator<std::atomic<DiskImage::Context *> *> &>::push_back( __p,  &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( (uint64_t)v91,  v48);
              unint64_t v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                uint64_t v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)uint64_t v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              uint64_t v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              int64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      uint64_t v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        std::__split_buffer<std::atomic<DiskImage::Context *> *,std::allocator<std::atomic<DiskImage::Context *> *> &>::push_front( (uint64_t)__p,  v57);
      }

      uint64_t v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_188108A88( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>::operator-[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = ((uint64_t)(*(void *)(a1 + 8) - *result) >> 3) - a2;
    if (v4 < 1) {
      result -= (unint64_t)(511 - v4) >> 9;
    }
    else {
      result += (unint64_t)v4 >> 9;
    }
  }

  return result;
}

double std::__for_each_segment[abi:ne180100]<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>>( char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    uint64_t v11 = *(void ***)a5;
    unint64_t v12 = *(char **)(a5 + 8);
    uint64_t v10 = __src;
  }

  else
  {
    unint64_t v8 = a1 + 1;
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,unsigned long long *,unsigned long long *,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>( __src,  *(char **)(a5 + 8),  *a1 + 4096,  *(void ***)a5,  &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      unint64_t v9 = *v8++;
      std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,unsigned long long *,unsigned long long *,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>( v9,  *(char **)(a5 + 8),  v9 + 4096,  *(void ***)a5,  &v14);
    }

    uint64_t v10 = *a3;
    uint64_t v11 = *(void ***)a5;
    unint64_t v12 = *(char **)(a5 + 8);
  }

  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,unsigned long long *,unsigned long long *,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>( v10,  v12,  a4,  v11,  &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

char *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,unsigned long long *,unsigned long long *,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>@<X0>( char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  unint64_t v6 = a4;
  if (__src != a3)
  {
    unint64_t v9 = __src;
    unint64_t v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      uint64_t v12 = (a3 - v9) >> 3 >= v11 >> 3 ? v11 >> 3 : (a3 - v9) >> 3;
      if (v12) {
        __src = (char *)memmove(__dst, v9, 8 * v12);
      }
      v9 += 8 * v12;
      if (v9 == a3) {
        break;
      }
      unint64_t v13 = (char *)*v6++;
      uint64_t v10 = v13;
      __dst = v13;
    }

    __dst += 8 * v12;
    else {
      --v6;
    }
  }

  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

__n128 std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>@<Q0>( char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, void *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    uint64_t v19 = a2;
    uint64_t v18 = a4;
    __int128 v15 = a5;
    unint64_t v16 = a6;
  }

  else
  {
    unint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    unint64_t v14 = a4;
    __int128 v15 = a5;
    unint64_t v16 = a6;
    while (1)
    {
      std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<unsigned long long *,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>( v12,  v14,  v15,  v16,  &v21);
      unint64_t v16 = (char *)v22.n128_u64[1];
      __int128 v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      unint64_t v17 = *v13--;
      uint64_t v12 = v17;
      unint64_t v14 = v17 + 4096;
    }

    uint64_t v18 = *a1 + 4096;
    uint64_t v19 = a2;
  }

  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<unsigned long long *,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>( v19,  v18,  v15,  v16,  &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<unsigned long long *,std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>,0>@<X0>( char *a1@<X1>, char *a2@<X2>, void *a3@<X3>, char *a4@<X4>, void *a5@<X8>)
{
  unint64_t v6 = a3;
  if (a1 == a2)
  {
    unint64_t v9 = a1;
  }

  else
  {
    unint64_t v9 = a2;
    uint64_t v10 = *a3;
    uint64_t v11 = a2;
    while (1)
    {
      uint64_t v12 = (uint64_t)&a4[-v10];
      if ((v11 - a1) >> 3 >= v12 >> 3) {
        uint64_t v13 = v12 >> 3;
      }
      else {
        uint64_t v13 = (v11 - a1) >> 3;
      }
      v11 -= 8 * v13;
      a4 -= 8 * v13;
      if (v13) {
        __n128 result = memmove(a4, v11, 8 * v13);
      }
      if (v11 == a1) {
        break;
      }
      uint64_t v15 = *--v6;
      uint64_t v10 = v15;
      a4 = (char *)(v15 + 4096);
    }

    if ((char *)(*v6 + 4096LL) == a4)
    {
      unint64_t v16 = (char *)v6[1];
      ++v6;
      a4 = v16;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

void space_allocators::FixedSize::insert<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>( uint64_t a1, unint64_t **a2, unint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6)
{
  if (a3 != a5)
  {
    uint64_t v12 = *a2;
    uint64_t v13 = a3;
    unint64_t v14 = a3;
    uint64_t v15 = a2;
    while (1)
    {
      if ((char *)++v14 - (char *)v12 == 4096)
      {
        unint64_t v16 = v15[1];
        ++v15;
        uint64_t v12 = v16;
        unint64_t v14 = v16;
      }

      if (v14 == a5) {
        break;
      }
      if (*v13 < *v14) {
        uint64_t v13 = v14;
      }
    }

    std::mutex::lock((std::mutex *)(a1 + 8));
    std::set<unsigned long long>::insert[abi:ne180100]<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>( (uint64_t *)(a1 + 72),  a2,  a3,  a4,  a5);
    if (*v13 >= *(void *)(a1 + 96)) {
      *(void *)(a1 + 96) = *(void *)a1 + *v13;
    }
    space_allocators::FixedSize::trim_largest((void *)a1, a6);
    std::mutex::unlock((std::mutex *)(a1 + 8));
  }

void sub_188108F6C(_Unwind_Exception *a1)
{
}

uint64_t *std::set<unsigned long long>::insert[abi:ne180100]<std::__deque_iterator<unsigned long long,unsigned long long *,unsigned long long &,unsigned long long **,long,512l>>( uint64_t *result, void *a2, unint64_t *a3, uint64_t a4, unint64_t *a5)
{
  if (a3 != a5)
  {
    unint64_t v6 = a3;
    unint64_t v8 = (uint64_t **)result;
    unint64_t v9 = result + 1;
    do
    {
      __n128 result = std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>( v8,  v9,  v6,  (uint64_t *)v6);
      if ((unint64_t *)((char *)++v6 - *a2) == (unint64_t *)4096)
      {
        uint64_t v10 = (unint64_t *)a2[1];
        ++a2;
        unint64_t v6 = v10;
      }
    }

    while (v6 != a5);
  }

  return result;
}

uint64_t *std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>( uint64_t **a1, void *a2, unint64_t *a3, uint64_t *a4)
{
  unint64_t v6 = (uint64_t **)std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>>::__find_equal<unsigned long long>( a1,  a2,  &v11,  &v10,  a3);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    unint64_t v8 = v6;
    unint64_t v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a4;
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  v11,  v8,  v7);
  }

  return v7;
}

uint64_t di_log::logger_buf<di_log::log_printer<1075ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E0868;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881090E4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1081ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E0A88;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188109160(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1090ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E0CA8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881091DC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1151ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E0EC8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188109258(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1188ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E10E8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881092D4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1441ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E1308;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188109350(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<1513ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E1748;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881093CC(_Unwind_Exception *a1)
{
}

void ref::Allocator<di_asif::details::table,unsigned long long>::add_tag( uint64_t a1@<X0>, ref::details **a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  uint64_t v52 = a2;
  unint64_t v7 = (std::mutex *)(a1 + 952);
  unint64_t v8 = (void *)(a1 + 936);
  unint64_t v9 = (ref::details *)(a1 + 1184);
  uint64_t v10 = (unint64_t *)(a1 + 768);
  int64_t v45 = (unint64_t *)(a1 + 104);
  int64_t v46 = (std::condition_variable *)(a1 + 1016);
  uint64_t v47 = (uint64_t **)(a1 + 928);
  while (2)
  {
    __lk.__m_ = v7;
    __lk.__owns_ = 1;
    std::mutex::lock(v7);
    if (a3)
    {
      uint64_t v11 = v52;
    }

    else
    {
      unint64_t v16 = (void *)*v8;
      if (!*v8) {
        goto LABEL_20;
      }
      uint64_t v11 = v52;
      unint64_t v17 = v8;
      do
      {
        unint64_t v18 = v16[4];
        BOOL v19 = v18 >= (unint64_t)v52;
        else {
          uint64_t v20 = v16 + 1;
        }
        if (v19) {
          unint64_t v17 = v16;
        }
        unint64_t v16 = (void *)*v20;
      }

      while (*v20);
      if (v17 == v8 || (unint64_t)v52 < v17[4] || (ref::details *)v17[5] == v9)
      {
LABEL_20:
        uint64_t v53 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v21 = __ldaxr((unint64_t *)&v53);
        while (__stlxr(0LL, (unint64_t *)&v53));
        atomic_store(v21, a4);
        a4[1] = (unint64_t)v8;
        ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v53);
        goto LABEL_23;
      }
    }

    uint64_t v53 = v11;
    uint64_t v54 = (unint64_t *)v9;
    uint64_t v12 = std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>( v47,  (unint64_t *)&v53,  (uint64_t *)&v53);
    uint64_t v13 = v12;
    if (v14)
    {
      uint64_t v53 = 0LL;
      *a4 = 0LL;
      do
        unint64_t v15 = __ldaxr((unint64_t *)&v53);
      while (__stlxr(0LL, (unint64_t *)&v53));
      atomic_store(v15, a4);
      a4[1] = (unint64_t)v12;
      ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v53);
LABEL_23:
      int v22 = 1;
      goto LABEL_24;
    }

    uint64_t v50 = (ref::details *)v12[5];
    if (v50 == v9)
    {
      uint64_t v30 = (void *)*v8;
      if (*v8)
      {
        uint64_t v31 = v52;
        uint64_t v32 = v8;
        while (1)
        {
          unint64_t v33 = v30[4];
          BOOL v34 = v33 >= (unint64_t)v31;
          else {
            unint64_t v35 = v30 + 1;
          }
          if (v34) {
            uint64_t v32 = v30;
          }
          uint64_t v30 = (void *)*v35;
          if (!*v35)
          {
            if (v32 == v8) {
              break;
            }
            uint64_t v36 = (ref::details *)v32[5];
            if (v36 != v9)
            {
              uint64_t v37 = *((void *)v36 + 67);
              if (v37)
              {
                if (!*(_BYTE *)(v37 + 520)) {
                  break;
                }
              }
            }

            if (!*(_BYTE *)(a1 + 912)) {
              break;
            }
            std::condition_variable::wait(v46, &__lk);
            uint64_t v30 = (void *)*v8;
            uint64_t v32 = v8;
            if (!*v8) {
              break;
            }
          }
        }
      }

      int v22 = 0;
      goto LABEL_24;
    }

    std::unique_lock<std::mutex>::unlock(&__lk);
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::tagged_ptr(&v49, (unint64_t *)v50 + 67);
    if (v49 && !*(_BYTE *)(v49 + 520))
    {
      uint64_t v23 = (uint64_t)v52;
      if (*(ref::details ***)(v49 + 32) == v52)
      {
        *a4 = 0LL;
        do
          unint64_t v39 = __ldaxr(&v49);
        while (__stlxr(0LL, &v49));
        atomic_store(v39, a4);
        a4[1] = (unint64_t)v13;
        goto LABEL_84;
      }

      if (*(void *)(v49 + 32) == -1LL)
      {
        uint64_t v24 = v45;
        if ((a3 & 1) == 0)
        {
          uint64_t v53 = 0LL;
          *a4 = 0LL;
          do
            unint64_t v38 = __ldaxr((unint64_t *)&v53);
          while (__stlxr(0LL, (unint64_t *)&v53));
          goto LABEL_83;
        }

        goto LABEL_35;
      }
    }

    else
    {
      if (!a3)
      {
        uint64_t v53 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v38 = __ldaxr((unint64_t *)&v53);
        while (__stlxr(0LL, (unint64_t *)&v53));
        goto LABEL_83;
      }

      uint64_t v23 = (uint64_t)v52;
    }

    uint64_t v24 = v45;
LABEL_35:
    if (ref::Allocator<di_asif::details::table,unsigned long long>::run_failed_dtors_list(a1, 0, v23, 1u) != -1)
    {
      do
        unint64_t v26 = __ldaxr(v10);
      while (__stlxr(v26 + 1, v10));
      v48.__m_ = (std::unique_lock<std::mutex>::mutex_type *)ref::details::_get_tagged_ptr_lock( (unint64_t)v50,  v25);
      v48.__owns_ = 1;
      std::mutex::lock(v48.__m_);
      uint64_t tagged_ptr_cond = (std::condition_variable *)ref::details::_get_tagged_ptr_cond((unint64_t)v50, v27);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v56 = std::chrono::steady_clock::now().__d_.__rep_ + 200000000;
      uint64_t v53 = &v50;
      uint64_t v54 = &v49;
      uint64_t v55 = &v52;
      std::condition_variable::wait_until<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>,ref::Allocator<di_asif::details::table,unsigned long long>::add_tag(unsigned long long,BOOL)::{lambda(void)#1}>( tagged_ptr_cond,  &v48,  &v56,  (uint64_t)&v53);
      do
        unint64_t v29 = __ldaxr(v10);
      while (__stlxr(v29 - 1, v10));
      if (v48.__owns_) {
        std::mutex::unlock(v48.__m_);
      }
      int v22 = 3;
      goto LABEL_85;
    }

    uint64_t v53 = 0LL;
    unint64_t v40 = atomic_load(v24);
    if (!v40) {
      goto LABEL_81;
    }
    while (1)
    {
      unint64_t v41 = __ldaxr(v24);
      if (v41 != v40)
      {
        __clrex();
        goto LABEL_71;
      }

      if (!__stlxr(v40 + 1, v24)) {
        break;
      }
LABEL_71:
      unint64_t v40 = v41;
      if (!v41) {
        goto LABEL_81;
      }
    }

    uint64_t v42 = *(unint64_t **)(a1 + 608);
    unint64_t v40 = (unint64_t)v24;
    if (v42)
    {
      do
        unint64_t v43 = __ldxr(v42);
      while (__stxr(v43 + 1, v42));
      *(void *)(a1 + 616) = v43;
      unint64_t v40 = (unint64_t)v24;
    }

void sub_188109840( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::mutex *a12, char a13, int a14, unint64_t a15, uint64_t a16, std::mutex *a17, char a18)
{
  if (a18) {
    std::mutex::unlock(a17);
  }
  _Unwind_Resume(a1);
}

unint64_t *ref::Allocator<di_asif::details::table,unsigned long long>::allocate_from_empty_pool@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t **a3@<X8>)
{
  unint64_t v13 = 0LL;
  unint64_t v6 = (std::mutex *)(a1 + 696);
  std::mutex::lock((std::mutex *)(a1 + 696));
  uint64_t v7 = *(void *)(a1 + 688);
  if (v7)
  {
    unint64_t v8 = *(void *)(a1 + 680);
    unint64_t v9 = *(unint64_t **)(*(void *)(*(void *)(a1 + 656) + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF));
    *(void *)(a1 + 688) = v7 - 1;
    *(void *)(a1 + 680) = v8 + 1;
    std::deque<std::atomic<DiskImage::Context *>>::__maybe_remove_front_spare[abi:ne180100](a1 + 648, 1);
    ref::Allocator<di_asif::details::table,unsigned long long>::insert_elem(a1, v9, a2, v14);
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::operator=(&v13, v14);
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(v14);
  }

  else
  {
    unint64_t v9 = 0LL;
  }

  std::mutex::unlock(v6);
  unint64_t v10 = atomic_load((unint64_t *)(a1 + 784));
  if (v10 + v7 >= *(void *)(a1 + 640))
  {
    ref::Allocator<di_asif::details::table,unsigned long long>::run_failed_dtors_list(a1, 0, 0LL, 0);
  }

  else
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 0x40000000LL;
    void v14[2] = (unint64_t)___ZN3ref9AllocatorIN7di_asif7details5tableEyE9evict_lruEv_block_invoke;
    void v14[3] = (unint64_t)&__block_descriptor_tmp_205;
    v14[4] = a1;
    gcd::gcd_queue::async((dispatch_queue_t *)(a1 + 920), v14);
  }

  *a3 = v9;
  a3[1] = 0LL;
  do
    unint64_t v11 = __ldaxr(&v13);
  while (__stlxr(0LL, &v13));
  atomic_store(v11, (unint64_t *)a3 + 1);
  return ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset(&v13);
}

void sub_1881099F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
}

unint64_t ref::Allocator<di_asif::details::table,unsigned long long>::extract_min(void *a1)
{
  unint64_t v1 = atomic_load(a1 + 97);
  uint64_t v2 = a1[79];
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  int v4 = 0;
  unint64_t v5 = 0LL;
  do
  {
    uint64_t v6 = a1[95];
    uint64_t v7 = *(void *)(v6 + 8 * v3);
    if (v7 && v1 - *(void *)(v7 + 520) != -1LL)
    {
      unint64_t v5 = *(void *)(v6 + 8 * v3);
      int v4 = v3;
    }

    ++v3;
  }

  while (v2 != v3);
  if (!v5) {
    return 0LL;
  }
  unint64_t v8 = (unint64_t *)(a1[95] + 8LL * v4);
  do
  {
    unint64_t v9 = __ldaxr(v8);
    if (v9 != v5)
    {
      __clrex();
      return 0LL;
    }
  }

  while (__stlxr(0LL, v8));
  return v5;
}

unint64_t *ref::Allocator<di_asif::details::table,unsigned long long>::insert_elem@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  uint64_t v7 = a2 + 1;
  unint64_t v17 = 0LL;
  unint64_t v8 = atomic_load(a2 + 1);
  if (!v8)
  {
LABEL_7:
    uint64_t v7 = 0LL;
    goto LABEL_11;
  }

  while (1)
  {
    unint64_t v9 = __ldaxr(v7);
    if (v9 != v8)
    {
      __clrex();
      goto LABEL_6;
    }

    if (!__stlxr(v8 + 1, v7)) {
      break;
    }
LABEL_6:
    unint64_t v8 = v9;
    if (!v9) {
      goto LABEL_7;
    }
  }

  unint64_t v10 = (unint64_t *)a2[64];
  if (v10)
  {
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    a2[65] = v11;
  }

unint64_t *ref::tagged_ptr<di_asif::details::table,unsigned long long>::tagged_ptr( unint64_t *a1, unint64_t *a2)
{
  *a1 = 0LL;
  uint64_t v3 = (unint64_t *)atomic_load(a2);
  if (!v3) {
    goto LABEL_9;
  }
  unint64_t v4 = atomic_load(v3);
  if (!v4) {
    goto LABEL_8;
  }
  while (1)
  {
    unint64_t v5 = __ldaxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_7;
    }

    if (!__stlxr(v4 + 1, v3)) {
      break;
    }
LABEL_7:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_8;
    }
  }

  uint64_t v7 = (unint64_t *)v3[63];
  if (v7)
  {
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v3[64] = v8;
  }

  if (!ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::wait_for_ready((uint64_t)v3))
  {
    do
      unint64_t v9 = __ldaxr(v3);
    while (__stlxr(v9 - 1, v3));
    if (v9 == 1)
    {
      uint64_t v10 = v3[4];
      v3[4] = -1LL;
      ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::reset_val((uint64_t)v3, v10, 1u);
    }

BOOL ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::wait_for_ready(uint64_t a1)
{
  uint64_t v2 = (unsigned int *)(a1 + 24);
  unsigned int v3 = atomic_load((unsigned int *)(a1 + 24));
  if (v3 == 2)
  {
    unint64_t v4 = atomic_load((unint64_t *)a1);
    return v4 > 1;
  }

  else
  {
    uint64_t v6 = (unint64_t *)(a1 + 8);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
    unsigned int v8 = atomic_load(v2);
    if (v8 != 2 && !*(_BYTE *)(a1 + 520)) {
      std::__atomic_base<ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::ready_state,false>::wait[abi:ne180100]( a1 + 24,  1u,  5u);
    }
    do
      unint64_t v9 = __ldaxr(v6);
    while (__stlxr(v9 - 1, v6));
    unint64_t v10 = atomic_load((unint64_t *)a1);
    if (v10 < 2)
    {
      return 0LL;
    }

    else
    {
      unsigned int v11 = atomic_load(v2);
      return v11 == 2;
    }
  }

BOOL std::__atomic_base<ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::ready_state,false>::wait[abi:ne180100]( uint64_t a1, unsigned int a2, unsigned int a3)
{
  *(void *)&__int128 v4 = a1;
  *((void *)&v4 + 1) = __PAIR64__(a3, a2);
  uint64_t v5 = a1;
  __int128 v6 = v4;
  return std::__libcpp_thread_poll_with_backoff[abi:ne180100]<std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state> &,std::__libcpp_atomic_wait_backoff_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state,std::__cxx_atomic_base_impl<ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>>,ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ready_state>> &>( (uint64_t)&v4,  (uint64_t)&v5,  0LL);
}

unint64_t *ref::tagged_ptr<di_asif::details::table,unsigned long long>::tagged_ptr( unint64_t *a1, unint64_t *a2, int a3)
{
  unsigned int v3 = a2;
  *a1 = 0LL;
  if (!a2) {
    goto LABEL_9;
  }
  unint64_t v5 = atomic_load(a2);
  if (!v5) {
    goto LABEL_8;
  }
  while (1)
  {
    unint64_t v6 = __ldaxr(a2);
    if (v6 != v5)
    {
      __clrex();
      goto LABEL_7;
    }

    if (!__stlxr(v5 + 1, a2)) {
      break;
    }
LABEL_7:
    unint64_t v5 = v6;
    if (!v6) {
      goto LABEL_8;
    }
  }

  unsigned int v8 = (unint64_t *)a2[63];
  if (v8)
  {
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    a2[64] = v9;
  }

  if (a3 && !ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::wait_for_ready((uint64_t)a2))
  {
    do
      unint64_t v10 = __ldaxr(v3);
    while (__stlxr(v10 - 1, v3));
    if (v10 == 1)
    {
      uint64_t v11 = v3[4];
      v3[4] = -1LL;
      ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::reset_val((uint64_t)v3, v11, 1u);
    }

BOOL std::condition_variable::wait_until<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>,ref::Allocator<di_asif::details::table,unsigned long long>::add_tag(unsigned long long,BOOL)::{lambda(void)#1}>( std::condition_variable *a1, std::unique_lock<std::mutex> *a2, std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *a3, uint64_t a4)
{
  do
  {
    if ((*(_DWORD *)(**(void **)a4 + 544LL) & 1) != 0) {
      return 1LL;
    }
    uint64_t v8 = *(void *)(a4 + 8);
    if (*(void *)v8)
    {
      if (!*(_BYTE *)(*(void *)v8 + 520LL) && *(void *)(*(void *)v8 + 32LL) == **(void **)(a4 + 16)) {
        return 1LL;
      }
    }

    if (*a3 <= std::chrono::steady_clock::now().__d_.__rep_) {
      break;
    }
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = *a3;
    v10.__d_.__rep_ = v9 - std::chrono::steady_clock::now().__d_.__rep_;
    if (v10.__d_.__rep_ >= 1)
    {
      std::chrono::steady_clock::now();
      v11.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      if (v11.__d_.__rep_)
      {
        if (v11.__d_.__rep_ < 1)
        {
          if ((unint64_t)v11.__d_.__rep_ < 0xFFDF3B645A1CAC09LL)
          {
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x8000000000000000LL;
            goto LABEL_17;
          }
        }

        else if ((unint64_t)v11.__d_.__rep_ > 0x20C49BA5E353F7LL)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x7FFFFFFFFFFFFFFFLL;
          goto LABEL_15;
        }

        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 1000 * v11.__d_.__rep_;
      }

      else
      {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0LL;
      }

uint64_t ___ZN3ref9AllocatorIN7di_asif7details5tableEyE9evict_lruEv_block_invoke(uint64_t a1)
{
  unint64_t v1 = *(void **)(a1 + 32);
  unint64_t min = ref::Allocator<di_asif::details::table,unsigned long long>::extract_min(v1);
  if (min) {
    ref::Allocator<di_asif::details::table,unsigned long long>::add_to_free_pool((uint64_t)v1, min);
  }
  return ref::Allocator<di_asif::details::table,unsigned long long>::run_failed_dtors_list((uint64_t)v1, 0, 0LL, 0);
}

void ref::Allocator<di_asif::details::table,unsigned long long>::add_to_free_pool(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  unsigned int v3 = (std::mutex *)(a1 + 696);
  std::mutex::lock((std::mutex *)(a1 + 696));
  std::deque<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>::push_back( (void *)(a1 + 648),  &v4);
  std::mutex::unlock(v3);
}

void sub_18810A08C(_Unwind_Exception *a1)
{
}

void std::deque<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>::push_back( void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void std::deque<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>::__add_back_capacity( void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      BOOL v34 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( v5,  v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_18810A3EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

unint64_t *ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::mark_used( uint64_t a1, uint64_t a2)
{
  BOOL v3 = (unint64_t *)(a1 + 8);
  ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::init(a1 + 8, a2);
  unint64_t v12 = 0LL;
  unint64_t v4 = atomic_load(v3);
  if (!v4) {
    goto LABEL_11;
  }
  while (1)
  {
    unint64_t v5 = __ldaxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_6;
    }

    if (!__stlxr(v4 + 1, v3)) {
      break;
    }
LABEL_6:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_11;
    }
  }

  uint64_t v6 = *(unint64_t **)(a1 + 512);
  unint64_t v4 = (unint64_t)v3;
  if (v6)
  {
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    *(void *)(a1 + 520) = v7;
    unint64_t v4 = (unint64_t)v3;
  }

uint64_t *ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 520) = 0;
  atomic_store(1uLL, (unint64_t *)a1);
  atomic_store(0LL, (unint64_t *)(a1 + 8));
  atomic_store(0LL, (unint64_t *)(a1 + 16));
  __n128 result = std::__optional_destruct_base<di_asif::details::table,false>::reset[abi:ne180100]((uint64_t *)(a1 + 40));
  unint64_t v4 = *(unint64_t **)(a1 + 504);
  if (v4)
  {
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    *(void *)(a1 + 512) = v5;
  }

  atomic_store(1u, (unsigned int *)(a1 + 24));
  __dmb(0xBu);
  return result;
}

uint64_t ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::make_value<di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long,BOOL>( uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5, unsigned __int8 *a6)
{
  *(void *)(a1 + 512) = **(void **)(a1 + 504);
  uint64_t v12 = a1 + 40;
  std::__optional_destruct_base<di_asif::details::table,false>::reset[abi:ne180100]((uint64_t *)(a1 + 40));
  std::construct_at[abi:ne180100]<di_asif::details::table,di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long,BOOL,di_asif::details::table*>( v12,  a2,  a3,  a4,  a5,  a6);
  *(_BYTE *)(a1 + 400) = 1;
  atomic_store(2u, (unsigned int *)(a1 + 24));
  return ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::notify_ready(a1);
}

void sub_18810A628(void *a1)
{
  *(_BYTE *)(v1 + 520) = 1;
  ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::notify_ready(v1);
  __cxa_rethrow();
}

void sub_18810A64C(_Unwind_Exception *a1)
{
}

uint64_t ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::notify_ready(uint64_t result)
{
  return result;
}

uint64_t std::construct_at[abi:ne180100]<di_asif::details::table,di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long,BOOL,di_asif::details::table*>( uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5, unsigned __int8 *a6)
{
  unint64_t v7 = (std::__shared_weak_count *)a3[1];
  v13[0] = *a3;
  v13[1] = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  di_asif::details::table::table(a1, a2, v13, *a4, *a5, *a6);
  if (v7)
  {
    unint64_t v10 = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  return a1;
}

void sub_18810A71C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::make_value<di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long>( uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5)
{
  *(void *)(a1 + 512) = **(void **)(a1 + 504);
  uint64_t v10 = a1 + 40;
  std::__optional_destruct_base<di_asif::details::table,false>::reset[abi:ne180100]((uint64_t *)(a1 + 40));
  std::construct_at[abi:ne180100]<di_asif::details::table,di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long,di_asif::details::table*>( v10,  a2,  a3,  a4,  a5);
  *(_BYTE *)(a1 + 400) = 1;
  atomic_store(2u, (unsigned int *)(a1 + 24));
  return ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::notify_ready(a1);
}

void sub_18810A7B4(void *a1)
{
  *(_BYTE *)(v1 + 520) = 1;
  ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::notify_ready(v1);
  __cxa_rethrow();
}

void sub_18810A7D8(_Unwind_Exception *a1)
{
}

uint64_t std::construct_at[abi:ne180100]<di_asif::details::table,di_asif::details::dir &,std::shared_ptr<Backend> &,unsigned long long &,unsigned long long,di_asif::details::table*>( uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5)
{
  uint64_t v6 = (std::__shared_weak_count *)a3[1];
  v12[0] = *a3;
  v12[1] = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  di_asif::details::table::table(a1, a2, v12, *a4, *a5, 0);
  if (v6)
  {
    unint64_t v9 = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return a1;
}

void sub_18810A880( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2061ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E19F8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18810A8FC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2071ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E1C18;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18810A978(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2311ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E1E38;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18810A9F4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2321ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E2058;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18810AA70(_Unwind_Exception *a1)
{
}

uint64_t ref::Allocator<di_asif::details::table,unsigned long long>::Allocator( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::error_ctrl_blk_t(a1);
  *(void *)(v8 + 632) = a2;
  *(void *)(v8 + 640) = a3;
  unint64_t v9 = (void *)(v8 + 648);
  *(_OWORD *)(v8 + 648) = 0u;
  *(_OWORD *)(v8 + 664) = 0u;
  *(_OWORD *)(v8 + 680) = 0u;
  *(void *)(v8 + 696) = 850045863LL;
  *(_OWORD *)(v8 + 704) = 0u;
  *(_OWORD *)(v8 + 720) = 0u;
  *(_OWORD *)(v8 + 736) = 0u;
  *(void *)(v8 + 752) = 0LL;
  *(_OWORD *)(v8 + 768) = 0u;
  *(_OWORD *)(v8 + 784) = 0u;
  *(void *)(v8 + 800) = 850045863LL;
  *(_OWORD *)(v8 + 808) = 0u;
  *(_OWORD *)(v8 + 824) = 0u;
  *(_OWORD *)(v8 + 840) = 0u;
  *(void *)(v8 + 856) = 0LL;
  *(void *)(v8 + 864) = 1018212795LL;
  *(void *)(v8 + 904) = 0LL;
  *(_OWORD *)(v8 + 888) = 0u;
  *(_BYTE *)(v8 + 912) = 1;
  *(_OWORD *)(v8 + 872) = 0u;
  uint64_t v16 = (dispatch_object_t *)(v8 + 920);
  gcd::gcd_queue::gcd_queue(v8 + 920, "dealloc_queue", 2LL);
  *(void *)(a1 + 944) = 0LL;
  *(void *)(a1 + 936) = 0LL;
  *(void *)(a1 + 928) = a1 + 936;
  *(void *)(a1 + 952) = 850045863LL;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  *(void *)(a1 + 1008) = 0LL;
  *(void *)(a1 + 1016) = 1018212795LL;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(void *)(a1 + 1056) = 0LL;
  *(void *)(a1 + 1064) = 850045863LL;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(_OWORD *)(a1 + 1104) = 0u;
  *(void *)(a1 + 1120) = 0LL;
  *(void *)(a1 + 1128) = a1 + 1128;
  *(void *)(a1 + 1136) = a1 + 1128;
  *(void *)(a1 + 1144) = 0LL;
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( a1 + 1152,  a4);
  ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(a1 + 1184, a1);
  *(void *)(a1 + 1736) = off_18A1E2D28;
  *(void *)(a1 + 1744) = a1;
  *(void *)(a1 + 1760) = a1 + 1736;
  *(void *)(a1 + 1768) = off_18A1E2DB8;
  *(void *)(a1 + 1776) = a1;
  *(void *)(a1 + 1792) = a1 + 1768;
  if (a2 >> 61) {
    size_t v10 = -1LL;
  }
  else {
    size_t v10 = 8 * a2;
  }
  unint64_t v11 = operator new[](v10);
  uint64_t v12 = v11;
  if (a2) {
    bzero(v11, 8 * a2);
  }
  *(void *)(a1 + 760) = v12;
  gcd::gcd_queue::set_target_priority(v16, 3);
  if (a2)
  {
    uint64_t v13 = 0LL;
    do
    {
      BOOL v14 = operator new(0x228uLL);
      ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type( (uint64_t)v14,  a1);
      uint64_t v17 = v14;
      std::deque<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>::emplace_back<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>( v9,  &v17);
      atomic_store(0LL, (unint64_t *)(*(void *)(a1 + 760) + 8 * v13++));
    }

    while (a2 != v13);
  }

  return a1;
}

void sub_18810AC90( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, std::condition_variable *a11, void *a12, dispatch_object_s **a13)
{
  uint64_t v18 = *(void **)(v13 + 1176);
  if (v18 == a12)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = a12;
  }

  else
  {
    if (!v18) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_6:
  std::__list_imp<std::pair<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long>>::clear(v16);
  std::mutex::~mutex((std::mutex *)(v13 + 1064));
  std::condition_variable::~condition_variable((std::condition_variable *)(v13 + 1016));
  std::mutex::~mutex((std::mutex *)(v13 + 952));
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::destroy( v13 + 928,  *a10);
  gcd::gcd_group::~gcd_group(a13);
  std::condition_variable::~condition_variable(a11);
  std::mutex::~mutex(v15);
  std::mutex::~mutex((std::mutex *)(v13 + 696));
  std::deque<std::atomic<DiskImage::Context *>>::~deque[abi:ne180100](v14);
  ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::~error_ctrl_blk_t((void *)v13);
  _Unwind_Resume(a1);
}

uint64_t std::deque<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>::emplace_back<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>( void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[4];
  uint64_t v8 = a1[5];
  unint64_t v9 = v8 + v7;
  if (v6 == v8 + v7)
  {
    std::deque<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>::__add_back_capacity(a1);
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    uint64_t v5 = a1[1];
    unint64_t v9 = v7 + v8;
  }

  *(void *)(*(void *)(v5 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v9 & 0x1FF)) = *a2;
  a1[5] = v8 + 1;
  unint64_t v10 = v7 + v8 + 1;
  uint64_t v11 = a1[1];
  uint64_t v12 = (void *)(v11 + 8 * (v10 >> 9));
  uint64_t v13 = *v12 + 8 * (v10 & 0x1FF);
  if (a1[2] == v11) {
    uint64_t v13 = 0LL;
  }
  if (v13 == *v12) {
    uint64_t v13 = *(v12 - 1) + 4096LL;
  }
  return v13 - 8;
}

uint64_t ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::error_ctrl_blk_t( uint64_t a1)
{
  *(void *)(a1 + 32) = off_18A1E2B08;
  *(void *)(a1 + 56) = a1 + 32;
  *(void *)a1 = off_18A1E2A78;
  *(void *)(a1 + 64) = off_18A1E2B98;
  *(void *)(a1 + 24) = a1;
  *(void *)(a1 + 88) = a1 + 64;
  *(void *)(a1 + 96) = 0LL;
  uint64_t v2 = ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::ctrl_blk( a1 + 104,  a1,  a1 + 32,  a1 + 64,  a1 + 96);
  ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::init(v2, -1LL);
  atomic_store(0, (unsigned int *)(a1 + 128));
  *(_BYTE *)(a1 + 624) = 1;
  return a1;
}

void sub_18810AF2C(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void **)(v1 + 88);
  if (v4 == v2)
  {
    uint64_t v5 = 4LL;
  }

  else
  {
    if (!v4) {
      goto LABEL_6;
    }
    uint64_t v5 = 5LL;
    uint64_t v2 = *(void **)(v1 + 88);
  }

  (*(void (**)(void *))(*v2 + 8 * v5))(v2);
LABEL_6:
  ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::error_ctrl_blk_t();
  _Unwind_Resume(a1);
}

void *std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_18A1E2A78;
  return result;
}

void std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_18A1E2A78;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target_type()
{
}

void *std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_18A1E2B08;
  return result;
}

void std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_18A1E2B08;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::target_type()
{
}

void *std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::table&)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::table&)#1}>,int ()(di_asif::details::table&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_18A1E2B98;
  return result;
}

void std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::table&)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::table&)#1}>,int ()(di_asif::details::table&)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_18A1E2B98;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::table&)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::table&)#1}>,int ()(di_asif::details::table&)>::operator()()
{
  return 0LL;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::table&)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::table&)#1}>,int ()(di_asif::details::table&)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::table&)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::table&)#1}>,int ()(di_asif::details::table&)>::target_type()
{
}

uint64_t ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::ctrl_blk( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 32) = -1LL;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 400) = 0;
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( a1 + 408,  a2);
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( a1 + 440,  a3);
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( a1 + 472,  a4);
  *(void *)(a1 + 504) = a5;
  *(void *)(a1 + 512) = 0LL;
  *(_BYTE *)(a1 + 520) = 0;
  return a1;
}

void sub_18810B1C4(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void **)(v2 + 464);
  if (v6 == v4)
  {
    uint64_t v7 = 4LL;
  }

  else
  {
    if (!v6) {
      goto LABEL_6;
    }
    uint64_t v7 = 5LL;
    uint64_t v4 = *(void **)(v2 + 464);
  }

  (*(void (**)(void *))(*v4 + 8 * v7))(v4);
LABEL_6:
  uint64_t v8 = *(void **)(v2 + 432);
  if (v8 == v3)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = v3;
  }

  else
  {
    if (!v8) {
      goto LABEL_11;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_11:
  std::__optional_destruct_base<di_asif::details::table,false>::~__optional_destruct_base[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type( uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  *(void *)a1 = a2;
  v10[0] = off_18A1E2C28;
  v10[1] = a1;
  uint64_t v11 = v10;
  v8[0] = off_18A1E2CA8;
  v8[1] = a1;
  uint64_t v9 = v8;
  ref::details::ctrl_blk<di_asif::details::table,unsigned long long>::ctrl_blk( a1 + 8,  (uint64_t)v10,  (uint64_t)v8,  a2 + 1152,  a2 + 776);
  BOOL v3 = v9;
  if (v9 == v8)
  {
    uint64_t v4 = 4LL;
    BOOL v3 = v8;
  }

  else
  {
    if (!v9) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  uint64_t v5 = v11;
  if (v11 == v10)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v10;
    goto LABEL_10;
  }

  if (v11)
  {
    uint64_t v6 = 5LL;
LABEL_10:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  *(void *)(a1 + 536) = 0LL;
  *(_DWORD *)(a1 + 544) = 0;
  return a1;
}

void sub_18810B33C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  uint64_t v19 = a13;
  if (a13 == v17)
  {
    uint64_t v20 = 4LL;
    uint64_t v19 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*(void *)v19 + 8 * v20))();
LABEL_6:
  uint64_t v21 = a17;
  if (a17 == &a14)
  {
    uint64_t v22 = 4LL;
    uint64_t v21 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_11;
    }
    uint64_t v22 = 5LL;
  }

  (*(void (**)(void))(*(void *)v21 + 8 * v22))();
LABEL_11:
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1E2C28;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1E2C28;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::operator()( uint64_t a1, uint64_t a2, uint64_t *a3, int *a4)
{
  return std::function<void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::operator()( **(void **)(a1 + 8) + 1736LL,  *(void *)(a1 + 8),  *a3,  *a4);
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target_type()
{
}

void *std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::__clone( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1E2CA8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1E2CA8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::operator()( uint64_t a1)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1} &,ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &>((uint64_t **)(a1 + 8));
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::target_type()
{
}

uint64_t std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::table,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1} &,ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &>( uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v4 = *a1;
  uint64_t v2 = *(void *)(v1 + 1792);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)v2 + 48LL))(v2, &v4);
}

void *std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1E2D28;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1E2D28;
  a2[1] = v2;
  return result;
}

void std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::operator()( uint64_t a1, unint64_t *a2, unint64_t *a3, _DWORD *a4)
{
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target_type()
{
}

void ref::Allocator<di_asif::details::table,unsigned long long>::deleter( uint64_t a1, unint64_t a2, unint64_t a3, char a4)
{
  if ((*(_DWORD *)(a2 + 544) & 1) == 0)
  {
    uint64_t v7 = (unsigned int *)(a2 + 544);
    if ((a4 & 3) == 1LL)
    {
      uint64_t v8 = (std::mutex *)(a1 + 1064);
      std::mutex::lock((std::mutex *)(a1 + 1064));
      uint64_t v9 = operator new(0x20uLL);
      void v9[2] = a2;
      void v9[3] = a3;
      uint64_t v11 = *(void *)(a1 + 1128);
      void *v9 = v11;
      v9[1] = a1 + 1128;
      *(void *)(v11 + 8) = v9;
      *(void *)(a1 + 1128) = v9;
      ++*(void *)(a1 + 1144);
      do
        unsigned int v12 = __ldaxr(v7);
      while (__stlxr(v12 | 4, v7));
      tagged_ptr_lock = (std::mutex *)ref::details::_get_tagged_ptr_lock(a2, v10);
      std::mutex::lock(tagged_ptr_lock);
      uint64_t tagged_ptr_cond = (std::condition_variable *)ref::details::_get_tagged_ptr_cond(a2, v14);
      std::condition_variable::notify_all(tagged_ptr_cond);
      std::mutex::unlock(tagged_ptr_lock);
LABEL_20:
      std::mutex::unlock(v8);
      return;
    }

    ref::Allocator<di_asif::details::table,unsigned long long>::delete_tag(a1, a3);
    ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)(a2 + 536));
    do
      unsigned int v17 = __ldaxr(v7);
    while (__stlxr(v17 | 1, v7));
    if ((v17 & 2) == 0) {
      ref::Allocator<di_asif::details::table,unsigned long long>::add_to_free_pool(a1, a2);
    }
    uint64_t v18 = (unint64_t *)(a1 + 784);
    do
    {
      unint64_t v19 = __ldaxr(v18);
      unint64_t v20 = v19 - 1;
    }

    while (__stlxr(v20, v18));
    if (!v20)
    {
      if (atomic_load((unint64_t *)(a1 + 792)))
      {
        std::mutex::lock((std::mutex *)(a1 + 800));
        std::mutex::unlock((std::mutex *)(a1 + 800));
      }
    }

    uint64_t v23 = (unint64_t *)(a1 + 768);
    if (atomic_load(v23))
    {
      uint64_t v8 = (std::mutex *)ref::details::_get_tagged_ptr_lock(a2, v16);
      std::mutex::lock(v8);
      if (atomic_load(v23))
      {
        int64_t v27 = (std::condition_variable *)ref::details::_get_tagged_ptr_cond(a2, v25);
        std::condition_variable::notify_all(v27);
      }

      goto LABEL_20;
    }
  }

void sub_18810B778(_Unwind_Exception *a1)
{
}

void ref::Allocator<di_asif::details::table,unsigned long long>::delete_tag(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 952);
  std::mutex::lock((std::mutex *)(a1 + 952));
  std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>>::__erase_unique<unsigned long long>( a1 + 928,  &v4);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 1016));
  std::mutex::unlock(v3);
}

void sub_18810B7F4(_Unwind_Exception *a1)
{
}

uint64_t std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>>::__erase_unique<unsigned long long>( uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  unint64_t v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      uint64_t v7 = v2;
    }
    else {
      uint64_t v7 = v2 + 1;
    }
    if (v6) {
      unint64_t v4 = v2;
    }
    uint64_t v2 = (void *)*v7;
  }

  while (*v7);
  std::__tree<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>>>::__remove_node_pointer( (uint64_t **)a1,  v4);
  operator delete(v4);
  return 1LL;
}

void *std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::__clone( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1E2DB8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1E2DB8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::operator()( uint64_t a1, unint64_t *a2, unint64_t *a3)
{
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::table,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,ref::tagged_ptr<di_asif::details::table,unsigned long long> &)>::target_type()
{
}

void ref::Allocator<di_asif::details::table,unsigned long long>::deallocate( uint64_t a1, unint64_t a2, unint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 632);
  if (v3 >= 1)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = *(void *)(a1 + 760);
    unint64_t v8 = v7 + 8 * v3;
    while (!(v7 + v6) || *(void *)(v7 + v6) != a2)
    {
      v6 += 8LL;
      if (v7 + v6 >= v8) {
        return;
      }
    }

    if ((v6 & 0x8000000000000000LL) == 0)
    {
      uint64_t v9 = (unint64_t *)(v7 + v6);
      while (1)
      {
        unint64_t v10 = __ldaxr(v9);
        if (v10 != a2) {
          break;
        }
        if (!__stlxr(0LL, v9))
        {
          ref::Allocator<di_asif::details::table,unsigned long long>::drop_elem(a1, a2, 1uLL, a3);
          ref::Allocator<di_asif::details::table,unsigned long long>::add_to_free_pool(a1, a2);
          return;
        }
      }

      __clrex();
    }
  }

uint64_t ref::Allocator<di_asif::details::map_element,unsigned long long>::Allocator( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::error_ctrl_blk_t(a1);
  *(void *)(v8 + 456) = a2;
  *(void *)(v8 + 464) = a3;
  uint64_t v9 = (void *)(v8 + 472);
  *(_OWORD *)(v8 + 472) = 0u;
  *(_OWORD *)(v8 + 488) = 0u;
  *(_OWORD *)(v8 + 504) = 0u;
  *(void *)(v8 + 520) = 850045863LL;
  *(_OWORD *)(v8 + 528) = 0u;
  *(_OWORD *)(v8 + 544) = 0u;
  *(_OWORD *)(v8 + 560) = 0u;
  *(void *)(v8 + 576) = 0LL;
  *(_OWORD *)(v8 + 592) = 0u;
  *(_OWORD *)(v8 + 608) = 0u;
  *(void *)(v8 + 624) = 850045863LL;
  *(_OWORD *)(v8 + 632) = 0u;
  *(_OWORD *)(v8 + 648) = 0u;
  *(_OWORD *)(v8 + 664) = 0u;
  *(void *)(v8 + 680) = 0LL;
  *(void *)(v8 + 688) = 1018212795LL;
  *(void *)(v8 + 728) = 0LL;
  *(_OWORD *)(v8 + 712) = 0u;
  *(_BYTE *)(v8 + 736) = 1;
  *(_OWORD *)(v8 + 696) = 0u;
  uint64_t v16 = (dispatch_object_t *)(v8 + 744);
  gcd::gcd_queue::gcd_queue(v8 + 744, "dealloc_queue", 2LL);
  *(void *)(a1 + 768) = 0LL;
  *(void *)(a1 + 760) = 0LL;
  *(void *)(a1 + 752) = a1 + 760;
  *(void *)(a1 + 776) = 850045863LL;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(void *)(a1 + 832) = 0LL;
  *(void *)(a1 + 840) = 1018212795LL;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_OWORD *)(a1 + 864) = 0u;
  *(void *)(a1 + 880) = 0LL;
  *(void *)(a1 + 888) = 850045863LL;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_OWORD *)(a1 + 928) = 0u;
  *(void *)(a1 + 944) = 0LL;
  *(void *)(a1 + 952) = a1 + 952;
  *(void *)(a1 + 960) = a1 + 952;
  *(void *)(a1 + 968) = 0LL;
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( a1 + 976,  a4);
  ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type( a1 + 1008,  a1);
  *(void *)(a1 + 1384) = off_18A1E30F8;
  *(void *)(a1 + 1392) = a1;
  *(void *)(a1 + 1408) = a1 + 1384;
  *(void *)(a1 + 1416) = off_18A1E3188;
  *(void *)(a1 + 1424) = a1;
  *(void *)(a1 + 1440) = a1 + 1416;
  if (a2 >> 61) {
    size_t v10 = -1LL;
  }
  else {
    size_t v10 = 8 * a2;
  }
  uint64_t v11 = operator new[](v10);
  unsigned int v12 = v11;
  if (a2) {
    bzero(v11, 8 * a2);
  }
  *(void *)(a1 + 584) = v12;
  gcd::gcd_queue::set_target_priority(v16, 3);
  if (a2)
  {
    uint64_t v13 = 0LL;
    do
    {
      BOOL v14 = operator new(0x178uLL);
      ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type( (uint64_t)v14,  a1);
      unsigned int v17 = v14;
      std::deque<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>::emplace_back<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>( v9,  &v17);
      atomic_store(0LL, (unint64_t *)(*(void *)(a1 + 584) + 8 * v13++));
    }

    while (a2 != v13);
  }

  return a1;
}

void sub_18810BBD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, std::condition_variable *a11, void *a12, dispatch_object_s **a13)
{
  uint64_t v18 = *(void **)(v13 + 1000);
  if (v18 == a12)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = a12;
  }

  else
  {
    if (!v18) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_6:
  std::__list_imp<std::pair<ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *,unsigned long long>>::clear(v16);
  std::mutex::~mutex((std::mutex *)(v13 + 888));
  std::condition_variable::~condition_variable((std::condition_variable *)(v13 + 840));
  std::mutex::~mutex((std::mutex *)(v13 + 776));
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::destroy( v13 + 752,  *a10);
  gcd::gcd_group::~gcd_group(a13);
  std::condition_variable::~condition_variable(a11);
  std::mutex::~mutex(v15);
  std::mutex::~mutex((std::mutex *)(v13 + 520));
  std::deque<std::atomic<DiskImage::Context *>>::~deque[abi:ne180100](v14);
  ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::~error_ctrl_blk_t((void *)v13);
  _Unwind_Resume(a1);
}

uint64_t std::deque<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>::emplace_back<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>( void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[4];
  uint64_t v8 = a1[5];
  unint64_t v9 = v8 + v7;
  if (v6 == v8 + v7)
  {
    std::deque<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *>>::__add_back_capacity(a1);
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    uint64_t v5 = a1[1];
    unint64_t v9 = v7 + v8;
  }

  *(void *)(*(void *)(v5 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v9 & 0x1FF)) = *a2;
  a1[5] = v8 + 1;
  unint64_t v10 = v7 + v8 + 1;
  uint64_t v11 = a1[1];
  unsigned int v12 = (void *)(v11 + 8 * (v10 >> 9));
  uint64_t v13 = *v12 + 8 * (v10 & 0x1FF);
  if (a1[2] == v11) {
    uint64_t v13 = 0LL;
  }
  if (v13 == *v12) {
    uint64_t v13 = *(v12 - 1) + 4096LL;
  }
  return v13 - 8;
}

uint64_t ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::error_ctrl_blk_t( uint64_t a1)
{
  *(void *)(a1 + 32) = off_18A1E2ED8;
  *(void *)(a1 + 56) = a1 + 32;
  *(void *)a1 = off_18A1E2E48;
  *(void *)(a1 + 64) = off_18A1E2F68;
  *(void *)(a1 + 24) = a1;
  *(void *)(a1 + 88) = a1 + 64;
  *(void *)(a1 + 96) = 0LL;
  uint64_t v2 = ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ctrl_blk( a1 + 104,  a1,  a1 + 32,  a1 + 64,  a1 + 96);
  ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::init(v2, -1LL);
  atomic_store(0, (unsigned int *)(a1 + 128));
  *(_BYTE *)(a1 + 448) = 1;
  return a1;
}

void sub_18810BE70(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void **)(v1 + 88);
  if (v4 == v2)
  {
    uint64_t v5 = 4LL;
  }

  else
  {
    if (!v4) {
      goto LABEL_6;
    }
    uint64_t v5 = 5LL;
    uint64_t v2 = *(void **)(v1 + 88);
  }

  (*(void (**)(void *))(*v2 + 8 * v5))(v2);
LABEL_6:
  ref::Allocator<di_asif::details::table,unsigned long long>::error_ctrl_blk_t::error_ctrl_blk_t();
  _Unwind_Resume(a1);
}

void *std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_18A1E2E48;
  return result;
}

void std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_18A1E2E48;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target_type()
{
}

void *std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_18A1E2ED8;
  return result;
}

void std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_18A1E2ED8;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::target_type()
{
}

void *std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::map_element&)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::map_element&)#1}>,int ()(di_asif::details::map_element&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_18A1E2F68;
  return result;
}

void std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::map_element&)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::map_element&)#1}>,int ()(di_asif::details::map_element&)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_18A1E2F68;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::map_element&)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::map_element&)#1}>,int ()(di_asif::details::map_element&)>::operator()()
{
  return 0LL;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::map_element&)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::map_element&)#1}>,int ()(di_asif::details::map_element&)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::map_element&)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::error_ctrl_blk_t::{lambda(di_asif::details::map_element&)#1}>,int ()(di_asif::details::map_element&)>::target_type()
{
}

uint64_t ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ctrl_blk( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 32) = -1LL;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 224) = 0;
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( a1 + 232,  a2);
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( a1 + 264,  a3);
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( a1 + 296,  a4);
  *(void *)(a1 + 328) = a5;
  *(void *)(a1 + 336) = 0LL;
  *(_BYTE *)(a1 + 344) = 0;
  return a1;
}

void sub_18810C108(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void **)(v2 + 288);
  if (v6 == v4)
  {
    uint64_t v7 = 4LL;
  }

  else
  {
    if (!v6) {
      goto LABEL_6;
    }
    uint64_t v7 = 5LL;
    uint64_t v4 = *(void **)(v2 + 288);
  }

  (*(void (**)(void *))(*v4 + 8 * v7))(v4);
LABEL_6:
  uint64_t v8 = *(void **)(v2 + 256);
  if (v8 == v3)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = v3;
  }

  else
  {
    if (!v8) {
      goto LABEL_11;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_11:
  std::__optional_destruct_base<di_asif::details::map_element,false>::~__optional_destruct_base[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type( uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  *(void *)a1 = a2;
  v10[0] = off_18A1E2FF8;
  v10[1] = a1;
  uint64_t v11 = v10;
  v8[0] = off_18A1E3078;
  v8[1] = a1;
  uint64_t v9 = v8;
  ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long>::ctrl_blk( a1 + 8,  (uint64_t)v10,  (uint64_t)v8,  a2 + 976,  a2 + 600);
  uint64_t v3 = v9;
  if (v9 == v8)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v8;
  }

  else
  {
    if (!v9) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  uint64_t v5 = v11;
  if (v11 == v10)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v10;
    goto LABEL_10;
  }

  if (v11)
  {
    uint64_t v6 = 5LL;
LABEL_10:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  *(void *)(a1 + 360) = 0LL;
  *(_DWORD *)(a1 + 368) = 0;
  return a1;
}

void sub_18810C280( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  uint64_t v19 = a13;
  if (a13 == v17)
  {
    uint64_t v20 = 4LL;
    uint64_t v19 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*(void *)v19 + 8 * v20))();
LABEL_6:
  uint64_t v21 = a17;
  if (a17 == &a14)
  {
    uint64_t v22 = 4LL;
    uint64_t v21 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_11;
    }
    uint64_t v22 = 5LL;
  }

  (*(void (**)(void))(*(void *)v21 + 8 * v22))();
LABEL_11:
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1E2FF8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1E2FF8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::operator()( uint64_t a1, uint64_t a2, uint64_t *a3, int *a4)
{
  return std::function<void ()(ref::details::ctrl_blk<di_asif::details::table,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::operator()( **(void **)(a1 + 8) + 1384LL,  *(void *)(a1 + 8),  *a3,  *a4);
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target_type()
{
}

void *std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::__clone( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1E3078;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1E3078;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::operator()( uint64_t a1)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1} &,ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &>((uint64_t **)(a1 + 8));
}

uint64_t std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::target_type()
{
}

uint64_t std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long>::tagged_allocated_type(ref::Allocator<di_asif::details::map_element,unsigned long long> &)::{lambda(ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1} &,ref::details::ctrl_blk<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &>( uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v4 = *a1;
  uint64_t v2 = *(void *)(v1 + 1440);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)v2 + 48LL))(v2, &v4);
}

void *std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1E30F8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1E30F8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::operator()( uint64_t a1, unint64_t *a2, unint64_t *a3, _DWORD *a4)
{
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,unsigned long long,diskimage_uio::option_set_ns::option_set<ref::details::deleter_options>)>::target_type()
{
}

void ref::Allocator<di_asif::details::map_element,unsigned long long>::deleter( uint64_t a1, unint64_t a2, unint64_t a3, char a4)
{
  if ((*(_DWORD *)(a2 + 368) & 1) == 0)
  {
    uint64_t v7 = (unsigned int *)(a2 + 368);
    if ((a4 & 3) == 1LL)
    {
      uint64_t v8 = (std::mutex *)(a1 + 888);
      std::mutex::lock((std::mutex *)(a1 + 888));
      uint64_t v9 = operator new(0x20uLL);
      void v9[2] = a2;
      void v9[3] = a3;
      uint64_t v11 = *(void *)(a1 + 952);
      void *v9 = v11;
      v9[1] = a1 + 952;
      *(void *)(v11 + 8) = v9;
      *(void *)(a1 + 952) = v9;
      ++*(void *)(a1 + 968);
      do
        unsigned int v12 = __ldaxr(v7);
      while (__stlxr(v12 | 4, v7));
      tagged_ptr_lock = (std::mutex *)ref::details::_get_tagged_ptr_lock(a2, v10);
      std::mutex::lock(tagged_ptr_lock);
      uint64_t tagged_ptr_cond = (std::condition_variable *)ref::details::_get_tagged_ptr_cond(a2, v14);
      std::condition_variable::notify_all(tagged_ptr_cond);
      std::mutex::unlock(tagged_ptr_lock);
LABEL_20:
      std::mutex::unlock(v8);
      return;
    }

    ref::Allocator<di_asif::details::map_element,unsigned long long>::delete_tag(a1, a3);
    ref::tagged_ptr<di_asif::details::map_element,unsigned long long>::reset((unint64_t *)(a2 + 360));
    do
      unsigned int v17 = __ldaxr(v7);
    while (__stlxr(v17 | 1, v7));
    if ((v17 & 2) == 0) {
      ref::Allocator<di_asif::details::map_element,unsigned long long>::add_to_free_pool(a1, a2);
    }
    uint64_t v18 = (unint64_t *)(a1 + 608);
    do
    {
      unint64_t v19 = __ldaxr(v18);
      unint64_t v20 = v19 - 1;
    }

    while (__stlxr(v20, v18));
    if (!v20)
    {
      if (atomic_load((unint64_t *)(a1 + 616)))
      {
        std::mutex::lock((std::mutex *)(a1 + 624));
        std::mutex::unlock((std::mutex *)(a1 + 624));
      }
    }

    uint64_t v23 = (unint64_t *)(a1 + 592);
    if (atomic_load(v23))
    {
      uint64_t v8 = (std::mutex *)ref::details::_get_tagged_ptr_lock(a2, v16);
      std::mutex::lock(v8);
      if (atomic_load(v23))
      {
        int64_t v27 = (std::condition_variable *)ref::details::_get_tagged_ptr_cond(a2, v25);
        std::condition_variable::notify_all(v27);
      }

      goto LABEL_20;
    }
  }

void sub_18810C6BC(_Unwind_Exception *a1)
{
}

void ref::Allocator<di_asif::details::map_element,unsigned long long>::delete_tag( uint64_t a1, unint64_t a2)
{
  unint64_t v4 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 776);
  std::mutex::lock((std::mutex *)(a1 + 776));
  std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>>::__erase_unique<unsigned long long>( a1 + 752,  &v4);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 840));
  std::mutex::unlock(v3);
}

void sub_18810C738(_Unwind_Exception *a1)
{
}

void *std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::__clone( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1E3188;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1E3188;
  a2[1] = v2;
  return result;
}

void std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::operator()( uint64_t a1, unint64_t *a2, unint64_t *a3)
{
}

uint64_t std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1},std::allocator<ref::Allocator<di_asif::details::map_element,unsigned long long>::{lambda(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)#1}>,void ()(ref::details::tagged_allocated_type<di_asif::details::map_element,unsigned long long> *,ref::tagged_ptr<di_asif::details::map_element,unsigned long long> &)>::target_type()
{
}

void ref::Allocator<di_asif::details::map_element,unsigned long long>::deallocate( uint64_t a1, unint64_t a2, unint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 456);
  if (v3 >= 1)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = *(void *)(a1 + 584);
    unint64_t v8 = v7 + 8 * v3;
    while (!(v7 + v6) || *(void *)(v7 + v6) != a2)
    {
      v6 += 8LL;
      if (v7 + v6 >= v8) {
        return;
      }
    }

    if ((v6 & 0x8000000000000000LL) == 0)
    {
      uint64_t v9 = (unint64_t *)(v7 + v6);
      while (1)
      {
        unint64_t v10 = __ldaxr(v9);
        if (v10 != a2) {
          break;
        }
        if (!__stlxr(0LL, v9))
        {
          ref::Allocator<di_asif::details::map_element,unsigned long long>::drop_elem(a1, a2, 1uLL, a3);
          ref::Allocator<di_asif::details::map_element,unsigned long long>::add_to_free_pool(a1, a2);
          return;
        }
      }

      __clrex();
    }
  }

void *_ZNKSt3__110__function6__funcIN7di_asif7details3dir20map_element_close_fnMUlRNS3_11map_elementEE_ENS_9allocatorIS7_EEFiS6_EE7__cloneEv( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_18A1E3218;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIN7di_asif7details3dir20map_element_close_fnMUlRNS3_11map_elementEE_ENS_9allocatorIS7_EEFiS6_EE7__cloneEPNS0_6__baseISA_EE( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_18A1E3218;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIN7di_asif7details3dir20map_element_close_fnMUlRNS3_11map_elementEE_ENS_9allocatorIS7_EEFiS6_EEclES6_( uint64_t a1, uint64_t a2)
{
  return _ZNK7di_asif7details3dir20map_element_close_fnMUlRNS0_11map_elementEE_clES3_((uint64_t *)(a1 + 8), a2);
}

uint64_t _ZNKSt3__110__function6__funcIN7di_asif7details3dir20map_element_close_fnMUlRNS3_11map_elementEE_ENS_9allocatorIS7_EEFiS6_EE6targetERKSt9type_info( uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100]( a2,  (uint64_t)&_ZTIN7di_asif7details3dir20map_element_close_fnMUlRNS0_11map_elementEE_E))
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *_ZNKSt3__110__function6__funcIN7di_asif7details3dir20map_element_close_fnMUlRNS3_11map_elementEE_ENS_9allocatorIS7_EEFiS6_EE11target_typeEv()
{
  return &_ZTIN7di_asif7details3dir20map_element_close_fnMUlRNS0_11map_elementEE_E;
}

uint64_t _ZNK7di_asif7details3dir20map_element_close_fnMUlRNS0_11map_elementEE_clES3_( uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 24);
  v12[0] = off_18A1D9CC8;
  v12[1] = v4;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v4 + 16) + 72LL))(&v13);
  if (*(_BYTE *)(a2 + 113)) {
    di_asif::details::dir::get_table( (di_asif::details::dir *)v3,  (di_asif::details::ContextASIF *)v12,  *(void *)(a2 + 8) / *(void *)(v3 + 80),  0,  0,  (unint64_t *)&v11);
  }
  else {
    uint64_t v11 = 0LL;
  }
  if (v11 && !v11[520])
  {
    if (v11[400]) {
      uint64_t v5 = (di_asif::details::table *)(v11 + 40);
    }
    else {
      uint64_t v5 = 0LL;
    }
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  uint64_t v6 = di_asif::details::map_element::close( (di_asif::details::map_element *)a2,  (di_asif::details::ContextASIF *)v12,  v5,  *(unsigned int *)(v3 + 20));
  ref::tagged_ptr<di_asif::details::table,unsigned long long>::reset((unint64_t *)&v11);
  v12[0] = off_18A1D9CC8;
  uint64_t v7 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  return v6;
}

void sub_18810CA64(_Unwind_Exception *a1)
{
}

uint64_t std::__thread_proxy[abi:ne180100]<std::tuple<std::unique_ptr<std::__thread_struct>,di_asif::details::dir::dir(DiskImageASIF &,unsigned long long,unsigned int,unsigned short,unsigned long long,unsigned long,Backend *,std::function<void ()(di_asif::details::ContextASIF &)> const&)::$_0>>( uint64_t *a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v7 = (const void **)a1;
  uint64_t v1 = std::__thread_local_data();
  uint64_t v2 = *v7;
  *uint64_t v7 = 0LL;
  pthread_setspecific(v1->__key_, v2);
  uint64_t v3 = (uint64_t)v7[1];
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( (uint64_t)v8,  (uint64_t)(v7 + 2));
  di_asif::details::dir::defrag(v3, (uint64_t)v8);
  uint64_t v4 = v9;
  if (v9 == v8)
  {
    uint64_t v5 = 4LL;
    uint64_t v4 = v8;
    goto LABEL_5;
  }

  if (v9)
  {
    uint64_t v5 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }

  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,di_asif::details::dir::dir(DiskImageASIF &,unsigned long long,unsigned int,unsigned short,unsigned long long,unsigned long,Backend *,std::function<void ()(di_asif::details::ContextASIF &)> const&)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t **)&v7);
  return 0LL;
}

void sub_18810CB58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,di_asif::details::dir::dir(DiskImageASIF &,unsigned long long,unsigned int,unsigned short,unsigned long long,unsigned long,Backend *,std::function<void ()(di_asif::details::ContextASIF &)> const&)::$_0>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t **std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,di_asif::details::dir::dir(DiskImageASIF &,unsigned long long,unsigned int,unsigned short,unsigned long long,unsigned long,Backend *,std::function<void ()(di_asif::details::ContextASIF &)> const&)::$_0>>::~unique_ptr[abi:ne180100]( uint64_t **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0LL;
  if (v2)
  {
    uint64_t v3 = (uint64_t *)v2[5];
    if (v3 == v2 + 2)
    {
      uint64_t v4 = 4LL;
      uint64_t v3 = v2 + 2;
    }

    else
    {
      if (!v3)
      {
LABEL_7:
        std::unique_ptr<std::__thread_struct>::reset[abi:ne180100](v2, 0LL);
        operator delete(v2);
        return a1;
      }

      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*v3 + 8 * v4))();
    goto LABEL_7;
  }

  return a1;
}

void std::unique_ptr<std::__thread_struct>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    uint64_t v4 = (void *)MEMORY[0x1895BC140]();
    operator delete(v4);
  }

_WORD *di_asif::header::total_segments_t::total_segments_t(_WORD *this, int a2)
{
  *this = 0;
  if (a2)
  {
    __int16 v2 = a2;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid value";
    exception[3] = "value validator";
    void *exception = off_18A1DEF68;
    exception[1] = "total_segments_t";
    *((_WORD *)exception + 16) = v2;
  }

  return this;
}

uint64_t smart_enums::validators::value<unsigned int>(uint64_t result, int a2, _DWORD *a3, uint64_t a4)
{
  if (!a4)
  {
LABEL_5:
    uint64_t v5 = result;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid value";
    exception[3] = "value validator";
    void *exception = off_18A1CA768;
    exception[1] = v5;
    *((_DWORD *)exception + 8) = a2;
  }

  uint64_t v4 = 4 * a4;
  while (*a3 != a2)
  {
    ++a3;
    v4 -= 4LL;
    if (!v4) {
      goto LABEL_5;
    }
  }

  return result;
}

uint64_t di_log::logger_buf<di_log::log_printer<2828ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E2728;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18810CD90(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<2831ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E2508;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18810CE0C(_Unwind_Exception *a1)
{
}

const void **CFAutoRelease<__CFData const*>::~CFAutoRelease(const void **a1)
{
  __int16 v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t di_asif::details::table::get_table_extents<std::insert_iterator<std::set<unsigned long long>>>( di_asif::details::table *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v14[0] = a3;
  v14[1] = a4;
  uint64_t result = di_asif::details::table::make_map_entry_iterators(a1, a2, (uint64_t)v12);
  while (v12[0] != v13[3] || v12[1] != v13[4])
  {
    v7[0] = (*(void *)(*(void *)(v13[0] + 56LL) + 16LL * v13[1] + 8) & 0x7FFFFFFFFFFFFFLL)
          * *(unsigned int *)(*(void *)(v13[0] + 8LL) + 20LL);
    if (v7[0]) {
      std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100]((uint64_t)v14, v7);
    }
    di_asif::details::table::make_data_entry_iterators_for_map( a1,  (const di_asif::details::table_entry_map *)v13,  (uint64_t)v7);
    while (v7[0] != v10 || v7[1] != v11)
    {
      uint64_t v6 = (*(void *)(*(void *)(v8 + 56) + 16 * v9 + 8) & 0x7FFFFFFFFFFFFFLL)
         * *(unsigned int *)(*(void *)(v8 + 8) + 20LL);
      if (v6) {
        std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100]( (uint64_t)v14,  (unint64_t *)&v6);
      }
      di_asif::details::data_entry_iterator_t::operator++((uint64_t)v7);
    }

    uint64_t result = di_asif::details::map_entry_iterator_t::operator++((uint64_t)v12);
  }

  return result;
}

uint64_t std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100]( uint64_t a1, unint64_t *a2)
{
  uint64_t v3 = std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>( *(uint64_t ***)a1,  *(void **)(a1 + 8),  a2,  (uint64_t *)a2);
  *(void *)(a1 + 8) = v3;
  char v4 = (uint64_t *)v3[1];
  if (v4)
  {
    do
    {
      __int128 v5 = v4;
      char v4 = (uint64_t *)*v4;
    }

    while (v4);
  }

  else
  {
    do
    {
      __int128 v5 = (uint64_t *)v3[2];
      BOOL v6 = *v5 == (void)v3;
      uint64_t v3 = v5;
    }

    while (!v6);
  }

  *(void *)(a1 + 8) = v5;
  return a1;
}

void space_allocators::FixedSize::insert<boost::range_detail::integer_iterator_with_step<unsigned long long>>( uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4 = a2[1];
  uint64_t v5 = *((void *)a3 + 1);
  if (v4 != v5)
  {
    uint64_t v10 = *a2;
    uint64_t v11 = a2[2];
    uint64_t v12 = v4 + 1;
    if (v4 + 1 != v5)
    {
      unint64_t v13 = v10 + v11 * v12;
      uint64_t v14 = a2[1];
      do
      {
        if (v10 + v14 * v11 < v13)
        {
          uint64_t v4 = v12;
          uint64_t v14 = v12;
        }

        ++v12;
        v13 += v11;
      }

      while (v5 != v12);
    }

    std::mutex::lock((std::mutex *)(a1 + 8));
    __int128 v18 = *(_OWORD *)a2;
    uint64_t v19 = a2[2];
    __int128 v16 = *a3;
    uint64_t v17 = *((void *)a3 + 2);
    std::set<unsigned long long>::insert[abi:ne180100]<boost::range_detail::integer_iterator_with_step<unsigned long long>>( (uint64_t *)(a1 + 72),  &v18,  (uint64_t)&v16);
    unint64_t v15 = v10 + v4 * v11;
    if (v15 >= *(void *)(a1 + 96)) {
      *(void *)(a1 + 96) = *(void *)a1 + v15;
    }
    space_allocators::FixedSize::trim_largest((void *)a1, a4);
    std::mutex::unlock((std::mutex *)(a1 + 8));
  }

void sub_18810D0C0(_Unwind_Exception *a1)
{
}

uint64_t *std::set<unsigned long long>::insert[abi:ne180100]<boost::range_detail::integer_iterator_with_step<unsigned long long>>( uint64_t *result, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  if (v3 != *(void *)(a3 + 8))
  {
    BOOL v6 = (uint64_t **)result;
    uint64_t v7 = result + 1;
    do
    {
      uint64_t v8 = *a2 + a2[2] * v3;
      uint64_t result = std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>( v6,  v7,  (unint64_t *)&v8,  &v8);
      uint64_t v3 = a2[1] + 1LL;
      a2[1] = v3;
    }

    while (v3 != *(void *)(a3 + 8));
  }

  return result;
}

di_utils *std::__call_once_proxy[abi:ne180100]<std::tuple<DiskImageASIF::void_stackable_identifier(std::shared_ptr<Backend> &)::$_0 &&>>( di_utils *result)
{
  uint64_t v1 = **(uint64_t ***)result;
  uint64_t v2 = *v1;
  if (*(_DWORD *)(*v1 + 44) != 1)
  {
    *(void *)(v2 + 64) = di_utils::random_uuid(result);
    *(void *)(v2 + 72) = v3;
    uint64_t result = (di_utils *)di_asif::header::write_header((di_asif::header *)(v2 + 32), *(Backend **)(v2 + 16));
    *(_DWORD *)v1[1] = (_DWORD)result;
  }

  return result;
}

uint64_t boost::uuids::string_generator::operator()<std::__wrap_iter<char const*>>( boost::uuids::string_generator *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  v17[2] = *MEMORY[0x1895F89C0];
  if (a2 == a3) {
    goto LABEL_32;
  }
  uint64_t v5 = (signed __int8 *)(a2 + 1);
  int v6 = *a2;
  if (v6 == 123)
  {
    uint64_t v5 = (signed __int8 *)(a2 + 2);
    signed __int8 v7 = a2[1];
  }

  else
  {
    signed __int8 v7 = *a2;
  }

  uint64_t v8 = 0LL;
  int v9 = 0;
  while (1)
  {
    do
    {
      if ((_DWORD)v8 == 4)
      {
        if (v7 == 45)
        {
          int v9 = 1;
LABEL_22:
          signed __int8 v12 = *v5++;
          signed __int8 v7 = v12;
          goto LABEL_24;
        }

        int v9 = 0;
      }

      else
      {
        BOOL v11 = (v8 & 0x7FFFFFFD) == 8 || (_DWORD)v8 == 6;
        if (v11 && ((v9 ^ 1) & 1) == 0)
        {
          goto LABEL_22;
        }
      }

void boost::uuids::string_generator::throw_invalid(boost::uuids::string_generator *this)
{
}

uint64_t boost::uuids::string_generator::get_value(boost::uuids::string_generator *this, int a2)
{
  p_opt_inst_meths = &OBJC_PROTOCOL___DIControllerProtocol.opt_inst_meths;
  if ((v3 & 1) == 0)
  {
    int v11 = a2;
    p_opt_inst_meths = &OBJC_PROTOCOL___DIControllerProtocol.opt_inst_meths;
    a2 = v11;
    if (v10)
    {
      boost::uuids::string_generator::get_value(char)const::digits_end = (uint64_t)&boost::uuids::string_generator::get_value(char)const::digits_begin[(void)boost::uuids::string_generator::get_value(char)const::digits_len];
      p_opt_inst_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___DIControllerProtocol + 40);
      a2 = v11;
    }
  }

  uint64_t v5 = p_opt_inst_meths[56];
  int v6 = (__objc2_meth_list *)memchr("0123456789abcdefABCDEF", a2, (char *)v5 - "0123456789abcdefABCDEF");
  if (v6) {
    signed __int8 v7 = v6;
  }
  else {
    signed __int8 v7 = v5;
  }
  unint64_t v8 = (char *)v7 - "0123456789abcdefABCDEF";
  return boost::uuids::string_generator::get_value(char)const::values[v8];
}

uint64_t OUTLINED_FUNCTION_0_1(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

uint64_t OUTLINED_FUNCTION_1_0@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(void *))(*a1 + 8 * a2))(a1);
}

  ;
}

void udsp_header::udsp_header(udsp_header *this, Backend *a2)
{
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  uint64_t v4 = (char *)operator new[](0x40uLL);
  *(_OWORD *)uint64_t v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  unsigned int v5 = Backend::read(a2, v4, 64LL, 0LL);
  if (v5 != 64)
  {
    unsigned int v6 = v5;
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    unint64_t v8 = std::generic_category();
    exception[1] = v6;
    exception[2] = v8;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Couldn't read sparseimage header";
  }

  udsp_header::init(this, v4);
  operator delete[](v4);
}

void sub_18810D57C(_Unwind_Exception *a1)
{
}

_DWORD *udsp_header::init(udsp_header *this, const char *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  int v4 = *(_DWORD *)a2;
  LODWORD(v14) = 1936879731;
  smart_enums::validators::value<unsigned int>((uint64_t)"header_signature", v4, &v14, 1LL);
  *(_DWORD *)this = 1936879731;
  int v5 = bswap32(*((_DWORD *)a2 + 1));
  uint64_t v14 = 0x200000001LL;
  int v15 = 3;
  smart_enums::validators::value<unsigned int>((uint64_t)"version_t", v5, &v14, 3LL);
  *((_DWORD *)this + 1) = v5;
  *((_DWORD *)this + 2) = bswap32(*((_DWORD *)a2 + 2));
  uint64_t result = udsp_header::flags_t::flags_t(&v14, bswap32(*((_DWORD *)a2 + 3)));
  *((_DWORD *)this + 3) = v14;
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)a2 + 4));
  *(void *)((char *)this + 20) = bswap64(*(void *)(a2 + 20));
  *(void *)((char *)this + 28) = bswap64(*(void *)(a2 + 28));
  __int128 v7 = *(_OWORD *)(a2 + 36);
  uint64_t v8 = *(void *)(a2 + 52);
  *((_DWORD *)this + 15) = *((_DWORD *)a2 + 15);
  *(void *)((char *)this + 52) = v8;
  *(_OWORD *)((char *)this + 36) = v7;
  if (!*((_DWORD *)this + 2))
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Band size in sparse is zero", 0x16u);
  }

  for (uint64_t i = 0LL; i != 28; ++i)
  {
    if (*((_BYTE *)this + i + 36))
    {
      int v10 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
      DiskImagesRuntimeException::DiskImagesRuntimeException(v10, "Reserved part isn't zeroed", 0x16u);
    }
  }

  return result;
}

_DWORD *udsp_header::flags_t::flags_t(_DWORD *this, int a2)
{
  *this = a2;
  if ((a2 & 0xFFFFFFFE) != 0)
  {
    unsigned int v2 = a2 & 0xFFFFFFFE;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid flags";
    exception[3] = "flags validator";
    void *exception = off_18A1CA768;
    exception[1] = "flags_t";
    *((_DWORD *)exception + 8) = v2;
  }

  return this;
}

void DiskImage::get_user_data(DiskImage *this)
{
  exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
  DiskImagesRuntimeException::DiskImagesRuntimeException( exception,  "User data is not supported in this image format",  0x2Du);
}

void DiskImage::write_user_data(DiskImage *this, const __CFDictionary *a2)
{
  exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
  DiskImagesRuntimeException::DiskImagesRuntimeException( exception,  "User data is not supported in this image format",  0x2Du);
}

void *operator<<(void *a1, _DWORD *a2)
{
  switch(*a2)
  {
    case 0:
      unsigned __int8 v3 = "uninit";
      goto LABEL_4;
    case 1:
      unsigned __int8 v3 = "mapped";
LABEL_4:
      uint64_t v4 = 6LL;
      goto LABEL_7;
    case 2:
      unsigned __int8 v3 = "unmapped";
      uint64_t v4 = 8LL;
      goto LABEL_7;
    case 3:
      unsigned __int8 v3 = "error";
      uint64_t v4 = 5LL;
LABEL_7:
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v3, v4);
      break;
    default:
      return a1;
  }

  return a1;
}

{
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  int *v5;
  unsigned int v2 = 0LL;
  while (CompressedBackend::algo_t::strings[v2] != *a2)
  {
    v2 += 6LL;
    if (v2 == 30)
    {
      unsigned __int8 v3 = "no_match";
      uint64_t v4 = 8LL;
      return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v3, v4);
    }
  }

  int v5 = &CompressedBackend::algo_t::strings[v2];
  unsigned __int8 v3 = (const char *)*((void *)v5 + 1);
  uint64_t v4 = *((void *)v5 + 2);
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v3, v4);
}

void *boost::icl::operator<<<char,std::char_traits<char>,boost::icl::discrete_interval<unsigned long long,std::less>>( void *a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a2 + 16);
  if (*(_BYTE *)(a2 + 16))
  {
    if (v4 == 3)
    {
      if (*(void *)(a2 + 8) >= *(void *)a2)
      {
LABEL_4:
        if ((v4 & 2) != 0) {
          int v5 = "[";
        }
        else {
          int v5 = "(";
        }
        std::string::basic_string[abi:ne180100]<0>(&v24, v5);
        if ((v26 & 0x80u) == 0) {
          unsigned int v6 = &v24;
        }
        else {
          unsigned int v6 = v24;
        }
        if ((v26 & 0x80u) == 0) {
          uint64_t v7 = v26;
        }
        else {
          uint64_t v7 = v25;
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v6, v7);
        uint64_t v8 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)",", 1LL);
        int v9 = (void *)std::ostream::operator<<();
        if ((*(_BYTE *)(a2 + 16) & 1) != 0) {
          int v10 = "]";
        }
        else {
          int v10 = ")";
        }
        std::string::basic_string[abi:ne180100]<0>(&__p, v10);
        if ((v23 & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = __p;
        }
        if ((v23 & 0x80u) == 0) {
          uint64_t v12 = v23;
        }
        else {
          uint64_t v12 = v22;
        }
        goto LABEL_45;
      }
    }

    else if (*(void *)a2 < *(void *)(a2 + 8))
    {
      goto LABEL_4;
    }
  }

  else
  {
    unint64_t v13 = *(void *)(a2 + 8);
    if (*(void *)a2 < v13 && *(void *)a2 + 1LL < v13) {
      goto LABEL_4;
    }
  }

  if ((v4 & 2) != 0) {
    int v15 = "[";
  }
  else {
    int v15 = "(";
  }
  std::string::basic_string[abi:ne180100]<0>(&v24, v15);
  if ((v26 & 0x80u) == 0) {
    uint64_t v16 = &v24;
  }
  else {
    uint64_t v16 = v24;
  }
  if ((v26 & 0x80u) == 0) {
    uint64_t v17 = v26;
  }
  else {
    uint64_t v17 = v25;
  }
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v16, v17);
  if ((*(_BYTE *)(a2 + 16) & 1) != 0) {
    __int128 v18 = "]";
  }
  else {
    __int128 v18 = ")";
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, v18);
  if ((v23 & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v23 & 0x80u) == 0) {
    uint64_t v12 = v23;
  }
  else {
    uint64_t v12 = v22;
  }
LABEL_45:
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)p_p, v12);
  return v19;
}

void sub_18810DA84( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t DiskImage::const_extents_iterator_t::const_extents_iterator_t(uint64_t a1, void *a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 1);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 3);
  *(_OWORD *)(a1 + 8) = v4;
  *(_DWORD *)(a1 + 40) = *((_DWORD *)a2 + 10);
  return a1;
}

BOOL DiskImage::const_extents_iterator_t::operator==(uint64_t a1, uint64_t a2)
{
  BOOL result = DiskImage::base_extents_iterator_interface::operator==(*(void *)a1, *(void *)a2);
  if (result) {
    return *(_DWORD *)(a1 + 40) == *(_DWORD *)(a2 + 40);
  }
  return result;
}

BOOL DiskImage::base_extents_iterator_interface::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (*(void *)v2 != *(void *)v3) {
    return 0LL;
  }
  BOOL result = boost::icl::operator==<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)(v2 + 8),  (unint64_t *)(v3 + 8));
  if (result)
  {
    if (*(_DWORD *)(v2 + 48) == *(_DWORD *)(v3 + 48)) {
      return *(void *)(a1 + 40) == *(void *)(a2 + 40);
    }
    return 0LL;
  }

  return result;
}

BOOL DiskImage::const_extents_iterator_t::operator!=(uint64_t a1, uint64_t a2)
{
}

void *DiskImage::const_extents_iterator_t::make_val@<X0>( DiskImage::const_extents_iterator_t *this@<X0>, uint64_t a2@<X8>)
{
  BOOL result = *(void **)this;
  unint64_t v5 = result[5];
  unint64_t v6 = result[3];
  *(void *)a2 = v5;
  *(void *)(a2 + 8) = v6;
  *(_BYTE *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 24) = 3;
  if ((*(_BYTE *)(*(void *)result[1] + 8LL) & 1) != 0)
  {
    BOOL result = (void *)DIDebugLogsEnabled();
    if ((_DWORD)result)
    {
      *(void *)uint64_t v7 = "DiskImage::const_extents_iterator_t::make_val() const";
      *(void *)&v7[8] = 45LL;
      *(_DWORD *)&v7[16] = 2;
      di_log::logger<di_log::log_printer<117ul>>::logger(v8, (__int128 *)v7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v9,  (uint64_t)"Disk image is terminated, skipping ...",  38LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<117ul>>::~logger_buf((uint64_t)v8);
      return (void *)MEMORY[0x1895BC2CC](&v10);
    }
  }

  else if (v5 < v6 && *((_DWORD *)this + 8) != 3)
  {
    BOOL result = (*(void *(**)(_BYTE *__return_ptr))*result)(v8);
    if (*(_DWORD *)&v8[24] != 3 && (*((_DWORD *)this + 10) & (1 << v8[24])) == 0)
    {
      do
      {
        BOOL result = *(void **)this;
        if (*(void *)(*(void *)this + 40LL) >= (unint64_t)(*(_BYTE *)(*(void *)this + 32LL) & 1)
                                                  + *(void *)(*(void *)this + 24LL))
          break;
        result[5] = (v8[16] & 1) + *(void *)&v8[8];
        BOOL result = (*(void *(**)(_BYTE *__return_ptr))*result)(v7);
        *(_OWORD *)&v8[12] = *(_OWORD *)&v7[12];
        *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
        if (*(_DWORD *)&v7[24] == 3) {
          break;
        }
      }

      while ((*((_DWORD *)this + 10) & (1 << v7[24])) == 0);
    }

    *(_OWORD *)a2 = *(_OWORD *)v8;
    *(_OWORD *)(a2 + 12) = *(_OWORD *)&v8[12];
  }

  return result;
}

void sub_18810DDAC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    uint64_t v15 = *(void *)(*(void *)v14 + 24LL);
    *(void *)uint64_t v13 = *(void *)(*(void *)v14 + 40LL);
    *(void *)(v13 + 8) = v15;
    *(_BYTE *)(v13 + 16) = 2;
    *(_DWORD *)(v13 + 24) = 3;
    __cxa_end_catch();
    JUMPOUT(0x18810DD98LL);
  }

  _Unwind_Resume(a1);
}

void *di_log::logger<di_log::log_printer<117ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<117ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E32C8;
  a1[45] = &unk_18A1E33C8;
  a1[46] = &unk_18A1E33F0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E32C8;
  a1[45] = &unk_18A1E3350;
  a1[46] = &unk_18A1E3378;
  return a1;
}

void sub_18810DE84(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<117ul>>::~logger(uint64_t a1)
{
  return a1;
}

DiskImage::const_extents_iterator_t *DiskImage::const_extents_iterator_t::operator++( DiskImage::const_extents_iterator_t *this)
{
  uint64_t v2 = *(void *)this;
  unint64_t v3 = (*((_BYTE *)this + 24) & 1) + *((void *)this + 2);
  *(void *)(v2 + 40) = v3;
  if (v3 < (unint64_t)(*(_BYTE *)(v2 + 32) & 1) + *(void *)(v2 + 24))
  {
    DiskImage::const_extents_iterator_t::make_val(this, (uint64_t)v5);
    *(_OWORD *)((char *)this + 8) = v5[0];
    *(_OWORD *)((char *)this + 20) = *(_OWORD *)((char *)v5 + 12);
  }

  return this;
}

DiskImage::const_extents_iterator_t *DiskImage::const_extents_iterator_t::operator++@<X0>( DiskImage::const_extents_iterator_t *a1@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(void *__return_ptr))(**(void **)a1 + 8LL))((void *)a2);
  *(_OWORD *)(a2 + 8) = *(_OWORD *)((char *)a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)a1 + 24);
  *(_DWORD *)(a2 + 40) = *((_DWORD *)a1 + 10);
  return DiskImage::const_extents_iterator_t::operator++(a1);
}

void sub_18810DFB0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  *uint64_t v1 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::function<std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::operator=( void *a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( (uint64_t)v6,  a2);
  std::__function::__value_func<std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::swap[abi:ne180100]( v6,  a1);
  uint64_t v3 = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v6;
    goto LABEL_5;
  }

  if (v7)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

uint64_t DiskImage::extents_t::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v4;
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0LL;
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v5;
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40LL))(v6);
    uint64_t v5 = *(void *)(a1 + 32);
  }

  *(void *)(a1 + 40) = v5;
  std::__function::__value_func<void ()(char *)>::operator=[abi:ne180100]((void *)(a1 + 56), a2 + 56);
  return a1;
}

uint64_t DiskImage::extents_t::back@<X0>(DiskImage::extents_t *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = boost::icl::identity_element<unsigned long long>::value(void)::_value;
  *(void *)a2 = boost::icl::identity_element<unsigned long long>::value(void)::_value;
  *(void *)(a2 + 8) = v4;
  *(_BYTE *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 24) = 0;
  DiskImage::extents_t::begin(this, (uint64_t)v12);
  DiskImage::extents_t::end(this, (uint64_t)v10);
  while (!DiskImage::base_extents_iterator_interface::operator==(v12[0], v10[0]) || v13 != v11)
  {
    DiskImage::const_extents_iterator_t::operator++((DiskImage::const_extents_iterator_t *)v12, (uint64_t)&v8);
    *(_OWORD *)a2 = v9[0];
    *(_OWORD *)(a2 + 12) = *(_OWORD *)((char *)v9 + 12);
    uint64_t v5 = v8;
    uint64_t v8 = 0LL;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
    }
  }

  uint64_t v6 = v10[0];
  v10[0] = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
  }
  uint64_t result = v12[0];
  v12[0] = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

void sub_18810E1C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v17 = *(void *)(v15 - 64);
  *(void *)(v15 - 64) = 0LL;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 24LL))(v17);
  }
  _Unwind_Resume(exception_object);
}

BOOL boost::icl::operator==<boost::icl::discrete_interval<unsigned long long,std::less>>( unint64_t *a1, unint64_t *a2)
{
  int v2 = *((unsigned __int8 *)a1 + 16);
  if (*((_BYTE *)a1 + 16))
  {
    if (v2 == 3)
    {
      unint64_t v4 = *a1;
      unint64_t v3 = a1[1];
      if (v3 >= *a1) {
        goto LABEL_21;
      }
    }

    else
    {
      unint64_t v4 = *a1;
      unint64_t v3 = a1[1];
      if (*a1 < v3) {
        goto LABEL_21;
      }
    }
  }

  else
  {
    unint64_t v4 = *a1;
    unint64_t v3 = a1[1];
    if (*a1 < v3 && *a1 + 1 < v3) {
      goto LABEL_21;
    }
  }

  if (!*((_BYTE *)a2 + 16))
  {
    unint64_t v7 = a2[1];
    if (*a2 < v7 && *a2 + 1 < v7) {
      goto LABEL_21;
    }
    return 1LL;
  }

  if (*((_BYTE *)a2 + 16) == 3)
  {
    if (a2[1] < *a2) {
      return 1LL;
    }
  }

  else if (*a2 >= a2[1])
  {
    return 1LL;
  }

void non-virtual thunk to'di_log::logger<di_log::log_printer<117ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<117ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  int v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<117ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<117ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<117ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<117ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<117ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<117ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<117ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<117ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E3460;
  di_log::logger_buf<di_log::log_printer<117ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<117ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<117ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18810E66C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<117ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<117ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<117ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 117LL;
    __int16 v22 = 2082;
    unsigned __int8 v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      unint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 117LL;
      __int16 v22 = 2082;
      unsigned __int8 v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void *std::__function::__value_func<std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::swap[abi:ne180100]( void *result, void *a2)
{
  void v6[3] = *MEMORY[0x1895F89C0];
  if (a2 != result)
  {
    uint64_t v3 = result;
    int v4 = (void *)result[3];
    int v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = 0LL;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24LL))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
        a2[3] = 0LL;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24LL))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32LL))(v6);
      }

      else
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24LL))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }

  return result;
}

void sub_18810E9F8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t di_log::logger_buf<di_log::log_printer<117ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E3460;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18810EA6C(_Unwind_Exception *a1)
{
}

void *di_log::logger<di_log::log_printer<114ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<114ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E34E8;
  a1[45] = &unk_18A1E35E8;
  a1[46] = &unk_18A1E3610;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E34E8;
  a1[45] = &unk_18A1E3570;
  a1[46] = &unk_18A1E3598;
  return a1;
}

void sub_18810FCAC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<114ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<136ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<136ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E3708;
  a1[45] = &unk_18A1E3808;
  a1[46] = &unk_18A1E3830;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E3708;
  a1[45] = &unk_18A1E3790;
  a1[46] = &unk_18A1E37B8;
  return a1;
}

void sub_18810FD94(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<136ul>>::~logger(uint64_t a1)
{
  return a1;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<114ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<114ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<114ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<114ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<114ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<114ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<114ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<114ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<114ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<114ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E3680;
  di_log::logger_buf<di_log::log_printer<114ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<114ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<114ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188110180( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<114ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<114ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<114ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 114LL;
    __int16 v22 = 2082;
    unsigned __int8 v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      unint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 114LL;
      __int16 v22 = 2082;
      unsigned __int8 v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<136ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<136ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<136ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<136ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<136ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<136ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<136ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<136ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<136ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<136ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E38A0;
  di_log::logger_buf<di_log::log_printer<136ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<136ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<136ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18811072C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<136ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<136ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<136ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 136LL;
    __int16 v22 = 2082;
    unsigned __int8 v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      unint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 136LL;
      __int16 v22 = 2082;
      unsigned __int8 v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t di_log::logger_buf<di_log::log_printer<114ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E3680;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881109B8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<136ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E38A0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188110A34(_Unwind_Exception *a1)
{
}

unint64_t DiskImageIOBreaker::move_data_to_buffer( DiskImage::Context **this, DiskImageIOBreaker::ContextIOBreaker *a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4)
{
  unint64_t result = DiskImage::Context::read(this[2], a2, a3);
  v12[0] = result;
  v12[1] = v7;
  if ((uint64_t)result <= 0)
  {
    if ((result & 0x80000000) == 0LL) {
      uint64_t v11 = result;
    }
    else {
      uint64_t v11 = -(int)result;
    }
    return -v11;
  }

  else
  {
    unint64_t v8 = *((void *)a2 + 18);
    unint64_t v9 = (*((void *)a3 + 18) - v8) & ~((uint64_t)(*((void *)a3 + 18) - v8) >> 63);
    if (v8 > v7 || v9 < result) {
      return trim_data((uint64_t)a2, (uint64_t)a3, v9, v12);
    }
  }

  return result;
}

uint64_t DiskImageIOBreaker::read( DiskImageIOBreaker *this, DiskImage::Context **a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4)
{
  char v4 = a4;
  char v6 = a2;
  uint64_t v215 = *MEMORY[0x1895F89C0];
  if (!*((_BYTE *)this + 56))
  {
    if (!a2[6]
      || (uint64_t v7 = *((void *)a4 + 18) - *((void *)a3 + 18),
          *((void *)a4 + 9) - *((void *)a3 + 9) >= (unint64_t)a2[8] + (v7 & ~(v7 >> 63))))
    {
      DiskImage::Context::read(a2[2], a3, a4);
    }
  }

  unint64_t v8 = (std::__shared_weak_count *)*((void *)a3 + 1);
  __int128 v167 = *(void **)a3;
  __int128 v168 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  *(_OWORD *)char v169 = *((_OWORD *)a3 + 1);
  *(_OWORD *)&v169[9] = *(_OWORD *)((char *)a3 + 25);
  uint64_t v170 = *((void *)a3 + 6);
  __int128 v171 = *(_OWORD *)((char *)a3 + 56);
  __int128 v172 = *(_OWORD *)((char *)a3 + 72);
  __int128 v173 = *(_OWORD *)((char *)a3 + 88);
  char v174 = *((_BYTE *)a3 + 104);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a3 + 15);
  uint64_t v175 = *((void *)a3 + 14);
  __int128 v176 = v11;
  if (v11)
  {
    os_log_type_t v12 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  uint64_t v16 = *((void *)a3 + 18);
  uint64_t v14 = (char *)a3 + 144;
  uint64_t v15 = v16;
  __int128 v177 = *((_OWORD *)v14 - 1);
  uint64_t v178 = v16;
  char v179 = v14[8];
  if ((unint64_t)v6[8] + ((*((void *)v4 + 18) - v16) & ~((*((void *)v4 + 18) - v16) >> 63)) <= *(void *)&v169[16])
  {
    uint64_t v17 = DiskImageIOBreaker::move_data_to_buffer(v6, (DiskImageIOBreaker::ContextIOBreaker *)&v167, v4, a4);
    uint64_t v15 = v18;
    sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v167, v17);
    if (v17 < 0)
    {
      uint64_t v19 = v17;
      goto LABEL_188;
    }
  }

  else
  {
    uint64_t v17 = 0LL;
  }

  uint64_t v19 = v17;
  uint64_t v136 = v4;
  char v138 = v6;
  do
  {
    uint64_t v20 = *((void *)v4 + 18);
    if (v19 == ((v20 - *(void *)v14) & ~((v20 - *(void *)v14) >> 63))) {
      break;
    }
    uint64_t v162 = v17;
    uint64_t v163 = v15;
    uint64_t v21 = (std::__shared_weak_count *)*((void *)this + 9);
    uint64_t v164 = *((void *)this + 8);
    uint64_t v165 = v21;
    uint64_t v139 = v19;
    if (v21)
    {
      __int16 v22 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
      uint64_t v20 = *((void *)v4 + 18);
    }

    uint64_t v25 = v6[6];
    uint64_t v24 = v6[7];
    __int128 v166 = v25;
    int64_t v27 = v6[3];
    unsigned __int8 v26 = v6[4];
    uint64_t v28 = v178;
    unint64_t v29 = (unint64_t)(v26 - v27 - 8) >> 3;
    if (v26 == v27) {
      unint64_t v30 = 0LL;
    }
    else {
      unint64_t v30 = v29 + 1;
    }
    unint64_t v31 = (v20 - v178) & ~((v20 - v178) >> 63);
    unint64_t v32 = (void)v24 * (void)v25;
    if (v32 >= v31) {
      uint64_t v33 = v31;
    }
    else {
      uint64_t v33 = v32;
    }
    __p = v204;
    __int128 v203 = xmmword_188178830;
    if (v30 < 6)
    {
      if (v27 == v26)
      {
        unint64_t v30 = 0LL;
      }

      else
      {
        unint64_t v45 = v29 + 1;
        unint64_t v46 = (unint64_t *)&v21->__shared_owners_;
        uint64_t v47 = v204;
        do
        {
          uint64_t v48 = *(void *)v27;
          if (v21)
          {
            do
              unint64_t v49 = __ldxr(v46);
            while (__stxr(v49 + 1, v46));
          }

          void *v47 = v48;
          v47[1] = v21;
          int64_t v27 = (DiskImage::Context *)((char *)v27 + 8);
          void v47[2] = v25;
          v47 += 3;
          --v45;
        }

        while (v45);
      }
    }

    else
    {
      uint64_t v135 = v178;
      if (v30 >= 0x555555555555556LL) {
        boost::container::throw_length_error( (boost::container *)"get_next_capacity, allocator's max size reached",  (const char *)a2);
      }
      uint64_t v34 = v33;
      unint64_t v35 = v14;
      uint64_t v36 = operator new(24 * v30);
      uint64_t v37 = __p;
      if (__p)
      {
        uint64_t v38 = v203;
        if ((void)v203)
        {
          uint64_t v39 = __p;
          do
          {
            --v38;
            uint64_t v39 = (void *)(std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v39) + 24);
          }

          while (v38);
        }

        *(void *)&__int128 v203 = 0LL;
        if (v204 != v37) {
          operator delete(v37);
        }
      }

      *((void *)&v203 + 1) = v30;
      __p = v36;
      *(void *)&__int128 v203 = 0LL;
      if (v27 == v26)
      {
        uint64_t v44 = 0LL;
        unint64_t v41 = (char *)v36;
        uint64_t v14 = v35;
        char v6 = v138;
        uint64_t v33 = v34;
        uint64_t v28 = v135;
      }

      else
      {
        uint64_t v40 = (unint64_t *)&v21->__shared_owners_;
        unint64_t v41 = (char *)v36;
        uint64_t v14 = v35;
        char v6 = v138;
        uint64_t v33 = v34;
        uint64_t v28 = v135;
        do
        {
          uint64_t v42 = *(void *)v27;
          if (v21)
          {
            do
              unint64_t v43 = __ldxr(v40);
            while (__stxr(v43 + 1, v40));
          }

          *(void *)unint64_t v41 = v42;
          *((void *)v41 + 1) = v21;
          *((void *)v41 + 2) = v25;
          int64_t v27 = (DiskImage::Context *)((char *)v27 + 8);
          v41 += 24;
        }

        while (v27 != v26);
        uint64_t v44 = v203;
      }

      unint64_t v30 = v44 - 0x5555555555555555LL * ((v41 - (_BYTE *)v36) >> 3);
    }

    char v4 = v136;
    uint64_t v19 = v139;
    *(void *)&__int128 v203 = v30;
    __int128 v205 = v207;
    __int128 v206 = xmmword_188178830;
    boost::container::vector<unsigned long,boost::container::small_vector_allocator<unsigned long,boost::container::new_allocator<void>,void>,void>::priv_resize<boost::container::value_init_t,boost::move_detail::integral_constant<unsigned int,1u>>( (uint64_t)&v205,  v30);
    uint64_t v182 = __p;
    __dst = (char *)__p + 24 * v203;
    __int128 v153 = (unint64_t *)v205;
    v187[0] = (unint64_t *)((char *)v205 + 8 * v206);
    sg_vec_ref::sg_vec_ref((uint64_t)v208, (uint64_t *)&v182, (uint64_t *)&__dst, &v153, v187, v28, v33);
    sg_vec_ref::begin((sg_vec_ref *)v208, (uint64_t)&v182);
    sg_vec_ref::end((sg_vec_ref *)v208, (uint64_t)&__dst);
    uint64_t v17 = DiskImageIOBreaker::move_data_to_buffer( v6,  (DiskImageIOBreaker::ContextIOBreaker *)&v182,  (const sg_vec_ns::details::sg_vec_iterator *)&__dst,  v50);
    uint64_t v15 = v51;
    uint64_t v52 = v198;
    if (v198)
    {
      uint64_t v53 = (unint64_t *)&v198->__shared_owners_;
      do
        unint64_t v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
    }

    __int128 v55 = v190;
    if (v190)
    {
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v56 = (unint64_t *)&v190->__shared_owners_;
      do
        unint64_t v57 = __ldaxr(v56);
      while (__stlxr(v57 - 1, v56));
      if (!v57)
      {
        ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
        std::__shared_weak_count::__release_weak(v55);
      }
    }

    uint64_t v58 = v184;
    if (v184)
    {
      uint64_t v59 = (unint64_t *)&v184->__shared_owners_;
      do
        unint64_t v60 = __ldaxr(v59);
      while (__stlxr(v60 - 1, v59));
      if (!v60)
      {
        ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
        std::__shared_weak_count::__release_weak(v58);
      }
    }

    __int128 v61 = v183;
    if (v183)
    {
      __int128 v62 = (unint64_t *)&v183->__shared_owners_;
      do
        unint64_t v63 = __ldaxr(v62);
      while (__stlxr(v63 - 1, v62));
      if (!v63)
      {
        ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
        std::__shared_weak_count::__release_weak(v61);
      }
    }

    if ((v17 & 0x8000000080000000LL) == 0x8000000080000000LL) {
      goto LABEL_147;
    }
    sg_vec_ref::begin((sg_vec_ref *)v208, (uint64_t)&__src);
    sg_vec_ref::end((sg_vec_ref *)v208, (uint64_t)&v153);
    uint64_t v64 = v167;
    uint64_t v140 = v167;
    uint64_t v141 = v168;
    if (v168)
    {
      uint64_t v65 = (unint64_t *)&v168->__shared_owners_;
      do
        unint64_t v66 = __ldxr(v65);
      while (__stxr(v66 + 1, v65));
    }

    v142[0] = *(_OWORD *)v169;
    *(_OWORD *)((char *)v142 + 9) = *(_OWORD *)&v169[9];
    uint64_t v143 = v170;
    __int128 v144 = v171;
    __int128 v145 = v172;
    __int128 v146 = v173;
    char v147 = v174;
    uint64_t v148 = v175;
    unint64_t v149 = v176;
    if (v176)
    {
      unint64_t v67 = (unint64_t *)&v176->__shared_owners_;
      do
        unint64_t v68 = __ldxr(v67);
      while (__stxr(v68 + 1, v67));
    }

    __int128 v150 = v177;
    uint64_t v151 = v178;
    char v152 = v179;
    __dst = v64;
    uint64_t v190 = v141;
    if (v141)
    {
      uint64_t v69 = (unint64_t *)&v141->__shared_owners_;
      do
        unint64_t v70 = __ldxr(v69);
      while (__stxr(v70 + 1, v69));
    }

    char v196 = v147;
    uint64_t v192 = v143;
    uint64_t v197 = v148;
    *(_OWORD *)__int128 v191 = v142[0];
    *(_OWORD *)&v191[9] = *(_OWORD *)((char *)v142 + 9);
    __int128 v193 = v144;
    __int128 v194 = v145;
    __int128 v195 = v146;
    unint64_t v198 = v149;
    if (v149)
    {
      uint64_t v71 = (unint64_t *)&v149->__shared_owners_;
      do
        unint64_t v72 = __ldxr(v71);
      while (__stxr(v72 + 1, v71));
    }

    unint64_t v73 = 0LL;
    __int128 v199 = v150;
    uint64_t v200 = v151;
    char v201 = 0;
    while (!sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&__src, (uint64_t)&v153))
    {
      sg_vec_ns::details::buffer_iterator::sync((sg_vec_ns::details::buffer_iterator *)v159);
      uint64_t v74 = (std::__shared_weak_count *)v160;
      v187[0] = (unint64_t *)v159[7];
      v187[1] = v160;
      if (v160)
      {
        char v75 = v160 + 1;
        do
          unint64_t v76 = __ldxr(v75);
        while (__stxr(v76 + 1, v75));
      }

      __int128 v188 = v161;
      if (*((void *)&v161 + 1))
      {
        unint64_t v77 = *(void *)&v191[16];
        if (v158 < *(void *)&v191[16]) {
          unint64_t v77 = v158;
        }
        if (v77 >= *((void *)&v188 + 1)) {
          int64_t v78 = *((void *)&v188 + 1);
        }
        else {
          int64_t v78 = v77;
        }
        memmove(__dst, __src, v78);
        if (v78 <= 0)
        {
          *(void *)&__int128 v180 = "transform(Fn &&, sg_vec_ref::iterator, const sg_vec_ref::iterator &, sg_vec_ref::iterator) [Fn = (lambda at /Library/Caches/com.apple.xbs/Sources/DiskImages2/app/disk_images/io_breaker.cpp:76:13)]";
          *((void *)&v180 + 1) = 97LL;
          int v181 = 16;
          di_log::logger<di_log::log_printer<615ul>>::logger(&v182, &v180);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v185,  (uint64_t)"IO error with sg: ",  18LL);
          operator<<(&v185);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v185, (uint64_t)" dest ", 6LL);
          operator<<(&v185);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v185,  (uint64_t)" returned status ",  17LL);
          std::ostream::operator<<();
          std::ostream::~ostream();
          di_log::logger_buf<di_log::log_printer<615ul>>::~logger_buf((uint64_t)&v182);
          MEMORY[0x1895BC2CC](&v186);
          int v79 = 1;
          if (v74)
          {
LABEL_97:
            uint64_t v80 = (unint64_t *)&v74->__shared_owners_;
            do
              unint64_t v81 = __ldaxr(v80);
            while (__stlxr(v81 - 1, v80));
            if (!v81)
            {
              ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
              std::__shared_weak_count::__release_weak(v74);
            }
          }
        }

        else
        {
          sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&__src, v78);
          sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&__dst, v78);
          int v79 = 0;
          v73 += v78;
          if (v74) {
            goto LABEL_97;
          }
        }
      }

      else
      {
        sg_vec_ns::details::sg_vec_iterator::operator++((uint64_t)&__src);
        int v79 = 2;
        if (v74) {
          goto LABEL_97;
        }
      }

      if ((v79 | 2) != 2) {
        goto LABEL_106;
      }
    }

    sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v140, v73);
LABEL_106:
    uint64_t v82 = v198;
    if (v198)
    {
      uint64_t v83 = (unint64_t *)&v198->__shared_owners_;
      do
        unint64_t v84 = __ldaxr(v83);
      while (__stlxr(v84 - 1, v83));
      if (!v84)
      {
        ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
        std::__shared_weak_count::__release_weak(v82);
      }
    }

    uint64_t v85 = v190;
    if (v190)
    {
      uint64_t v86 = (unint64_t *)&v190->__shared_owners_;
      do
        unint64_t v87 = __ldaxr(v86);
      while (__stlxr(v87 - 1, v86));
      if (!v87)
      {
        ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
        std::__shared_weak_count::__release_weak(v85);
      }
    }

    unint64_t v88 = v149;
    if (v149)
    {
      unint64_t v89 = (unint64_t *)&v149->__shared_owners_;
      do
        unint64_t v90 = __ldaxr(v89);
      while (__stlxr(v90 - 1, v89));
      if (!v90)
      {
        ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
        std::__shared_weak_count::__release_weak(v88);
      }
    }

    __n128 v91 = v141;
    if (v141)
    {
      __n128 v92 = (unint64_t *)&v141->__shared_owners_;
      do
        unint64_t v93 = __ldaxr(v92);
      while (__stlxr(v93 - 1, v92));
      if (!v93)
      {
        ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
        std::__shared_weak_count::__release_weak(v91);
      }
    }

    char v94 = v155;
    if (v155)
    {
      __int128 v95 = (unint64_t *)&v155->__shared_owners_;
      do
        unint64_t v96 = __ldaxr(v95);
      while (__stlxr(v96 - 1, v95));
      if (!v96)
      {
        ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
        std::__shared_weak_count::__release_weak(v94);
      }
    }

    uint64_t v97 = v154;
    if (v154)
    {
      unint64_t v98 = (unint64_t *)&v154->__shared_owners_;
      do
        unint64_t v99 = __ldaxr(v98);
      while (__stlxr(v99 - 1, v98));
      if (!v99)
      {
        ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
        std::__shared_weak_count::__release_weak(v97);
      }
    }

    uint64_t v100 = (std::__shared_weak_count *)v160;
    if (v160)
    {
      __int128 v101 = v160 + 1;
      do
        unint64_t v102 = __ldaxr(v101);
      while (__stlxr(v102 - 1, v101));
      if (!v102)
      {
        ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
        std::__shared_weak_count::__release_weak(v100);
      }
    }

    __int128 v103 = v157;
    if (v157)
    {
      char v104 = (unint64_t *)&v157->__shared_owners_;
      do
        unint64_t v105 = __ldaxr(v104);
      while (__stlxr(v105 - 1, v104));
      if (!v105)
      {
        ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
        std::__shared_weak_count::__release_weak(v103);
      }
    }

    sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v167, v17);
    sg_vec_ns::details::buffer_iterator::rtrim_written(&v171);
    uint64_t v19 = v17 + v139;
LABEL_147:
    unint64_t v106 = v214;
    if (v214)
    {
      __int128 v107 = (unint64_t *)&v214->__shared_owners_;
      do
        unint64_t v108 = __ldaxr(v107);
      while (__stlxr(v108 - 1, v107));
      if (!v108)
      {
        ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
        std::__shared_weak_count::__release_weak(v106);
      }
    }

    char v109 = v213;
    if (v213)
    {
      uint64_t v110 = (unint64_t *)&v213->__shared_owners_;
      do
        unint64_t v111 = __ldaxr(v110);
      while (__stlxr(v111 - 1, v110));
      if (!v111)
      {
        ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
        std::__shared_weak_count::__release_weak(v109);
      }
    }

    unint64_t v112 = v212;
    if (v212)
    {
      uint64_t v113 = (unint64_t *)&v212->__shared_owners_;
      do
        unint64_t v114 = __ldaxr(v113);
      while (__stlxr(v114 - 1, v113));
      if (!v114)
      {
        ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
        std::__shared_weak_count::__release_weak(v112);
      }
    }

    __int128 v115 = v211;
    if (v211)
    {
      __int128 v116 = (unint64_t *)&v211->__shared_owners_;
      do
        unint64_t v117 = __ldaxr(v116);
      while (__stlxr(v117 - 1, v116));
      if (!v117)
      {
        ((void (*)(std::__shared_weak_count *))v115->__on_zero_shared)(v115);
        std::__shared_weak_count::__release_weak(v115);
      }
    }

    uint64_t v118 = v210;
    if (v210)
    {
      unint64_t v119 = (unint64_t *)&v210->__shared_owners_;
      do
        unint64_t v120 = __ldaxr(v119);
      while (__stlxr(v120 - 1, v119));
      if (!v120)
      {
        ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
        std::__shared_weak_count::__release_weak(v118);
      }
    }

    unint64_t v121 = v209;
    if (v209)
    {
      char v122 = (unint64_t *)&v209->__shared_owners_;
      do
        unint64_t v123 = __ldaxr(v122);
      while (__stlxr(v123 - 1, v122));
      if (!v123)
      {
        ((void (*)(std::__shared_weak_count *))v121->__on_zero_shared)(v121);
        std::__shared_weak_count::__release_weak(v121);
      }
    }

    if (*((void *)&v206 + 1) && v207 != v205) {
      operator delete(v205);
    }
    boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)&__p);
    unint64_t v124 = v165;
    if (v165)
    {
      unint64_t v125 = (unint64_t *)&v165->__shared_owners_;
      do
        unint64_t v126 = __ldaxr(v125);
      while (__stlxr(v126 - 1, v125));
      if (!v126)
      {
        ((void (*)(std::__shared_weak_count *))v124->__on_zero_shared)(v124);
        std::__shared_weak_count::__release_weak(v124);
      }
    }

    char v6 = v138;
  }

  while ((v17 & 0x8000000080000000LL) != 0x8000000080000000LL);
LABEL_188:
  __int128 v127 = v176;
  if (v176)
  {
    __int128 v128 = (unint64_t *)&v176->__shared_owners_;
    do
      unint64_t v129 = __ldaxr(v128);
    while (__stlxr(v129 - 1, v128));
    if (!v129)
    {
      ((void (*)(std::__shared_weak_count *))v127->__on_zero_shared)(v127);
      std::__shared_weak_count::__release_weak(v127);
    }
  }

  char v130 = v168;
  if (v168)
  {
    uint64_t v131 = (unint64_t *)&v168->__shared_owners_;
    do
      unint64_t v132 = __ldaxr(v131);
    while (__stlxr(v132 - 1, v131));
    if (!v132)
    {
      ((void (*)(std::__shared_weak_count *))v130->__on_zero_shared)(v130);
      std::__shared_weak_count::__release_weak(v130);
    }
  }

  if (v17 < 0) {
    int v133 = v17;
  }
  else {
    int v133 = 0;
  }
  if (v133 >= 0) {
    return v19;
  }
  else {
    return v133;
  }
}

void sub_188111854( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, char a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
}

uint64_t DiskImageIOBreaker::verify_image(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 56LL))(*(void *)(a1 + 16));
}

  ;
}

void DiskImageIOBreaker::~DiskImageIOBreaker(DiskImageIOBreaker *this)
{
  *(void *)this = &off_18A1E3920;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 64);
}

{
  *(void *)this = &off_18A1E3920;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 64);
  operator delete(this);
}

uint64_t DiskImageIOBreaker::get_block_size(DiskImageIOBreaker *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 24LL))(*((void *)this + 2));
}

uint64_t DiskImageIOBreaker::get_num_blocks(DiskImageIOBreaker *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 32LL))(*((void *)this + 2));
}

uint64_t DiskImageIOBreaker::is_writable(DiskImageIOBreaker *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 40LL))(*((void *)this + 2));
}

uint64_t DiskImageIOBreaker::supports_unmap(DiskImageIOBreaker *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 80LL))(*((void *)this + 2));
}

uint64_t DiskImageIOBreaker::get_extents_iterator_interface(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 16) + 128LL))( *(void *)(a1 + 16),  a2,  *(void *)(a3 + 16));
}

void *DiskImageIOBreaker::_create_ctx(DiskImageIOBreaker *this)
{
  uint64_t v5 = (*(uint64_t (**)(void))(**((void **)this + 2) + 136LL))(*((void *)this + 2));
  if (!v5) {
    return 0LL;
  }
  uint64_t v2 = operator new(0x48uLL);
  DiskImageIOBreaker::ContextIOBreaker::ContextIOBreaker(v2, (uint64_t)this, &v5);
  uint64_t v3 = v5;
  uint64_t v5 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40LL))(v3);
  }
  return v2;
}

void sub_188111ADC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 40LL))(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t DiskImageIOBreaker::write(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2;
  return _Z8do_on_sgIZN18DiskImageIOBreaker5writeERN9DiskImage7ContextERK8sg_entryEUlRKT_RKT0_E_EDaOS7_S6_( (uint64_t)&v4,  a3);
}

uint64_t DiskImageIOBreaker::flush(uint64_t a1, uint64_t a2)
{
  return DiskImage::Context::flush(*(void **)(a2 + 16));
}

uint64_t DiskImageIOBreaker::unmap(uint64_t a1, uint64_t a2)
{
  return DiskImage::Context::unmap(*(void **)(a2 + 16));
}

void *DiskImageIOBreaker::ContextIOBreaker::ContextIOBreaker(void *a1, uint64_t a2, uint64_t *a3)
{
  *a1 = off_18A1E3A20;
  a1[1] = a2;
  uint64_t v4 = *a3;
  *a3 = 0LL;
  a1[3] = 0LL;
  uint64_t v5 = a1 + 3;
  a1[2] = v4;
  a1[4] = 0LL;
  a1[5] = 0LL;
  unint64_t v6 = *(void *)(a2 + 32);
  uint64_t v7 = *(void *)(a2 + 40);
  unint64_t v8 = v6 + 1;
  a1[7] = v6 + 1;
  a1[8] = v7;
  unint64_t v9 = v7 + v6;
  a1[6] = v9 / (v6 + 1);
  if (v6 < v9)
  {
    unint64_t v10 = 0LL;
    uint64_t v11 = a1 + 5;
    unsigned int v12 = 1;
    do
    {
      size_t v13 = a1[6];
      uint64_t v14 = operator new[](v13);
      bzero(v14, v13);
      if ((unint64_t)v10 >= *v11)
      {
        uint64_t v15 = ((uint64_t)v10 - *v5) >> 3;
        uint64_t v16 = *v11 - *v5;
        uint64_t v17 = v16 >> 2;
        else {
          unint64_t v18 = v17;
        }
        v23[4] = a1 + 5;
        if (v18) {
          uint64_t v19 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( (uint64_t)(a1 + 5),  v18);
        }
        else {
          uint64_t v19 = 0LL;
        }
        uint64_t v20 = &v19[8 * v15];
        v23[0] = v19;
        v23[1] = v20;
        void v23[3] = &v19[8 * v18];
        *(void *)uint64_t v20 = v14;
        v23[2] = v20 + 8;
        std::vector<std::unique_ptr<char []>>::__swap_out_circular_buffer(v5, v23);
        unint64_t v10 = (void *)a1[4];
        std::__split_buffer<std::unique_ptr<char []>>::~__split_buffer((uint64_t)v23);
        unint64_t v8 = a1[7];
      }

      else
      {
        *v10++ = v14;
        a1[4] = v10;
      }

      a1[4] = v10;
    }

    while (v8 > v12++);
  }

  return a1;
}

void sub_188111CC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v17 = *(void *)(v14 + 16);
  *(void *)(v14 + 16) = 0LL;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 40LL))(v17);
  }
  _Unwind_Resume(a1);
}

void DiskImageIOBreaker::ContextIOBreaker::~ContextIOBreaker(DiskImageIOBreaker::ContextIOBreaker *this)
{
  *(void *)this = off_18A1E3A20;
  uint64_t v3 = (void **)((char *)this + 24);
  std::vector<std::unique_ptr<char []>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 40LL))(v2);
  }
}

{
  uint64_t v2;
  void **v3;
  *(void *)this = off_18A1E3A20;
  uint64_t v3 = (void **)((char *)this + 24);
  std::vector<std::unique_ptr<char []>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 40LL))(v2);
  }
  operator delete(this);
}

uint64_t std::vector<std::unique_ptr<char []>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<char []>>,std::reverse_iterator<std::unique_ptr<char []>*>,std::reverse_iterator<std::unique_ptr<char []>*>,std::reverse_iterator<std::unique_ptr<char []>*>>( (uint64_t)(a1 + 2),  a1[1],  (void *)a1[1],  *a1,  (void *)*a1,  a2[1],  a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<char []>>,std::reverse_iterator<std::unique_ptr<char []>*>,std::reverse_iterator<std::unique_ptr<char []>*>,std::reverse_iterator<std::unique_ptr<char []>*>>( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v16 = a6;
  *((void *)&v16 + 1) = a7;
  __int128 v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  void v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }

  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    unint64_t v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0LL;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8LL;
      uint64_t v8 = v9;
    }

    while (a3 != a5);
    uint64_t v11 = v16;
  }

  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<char []>>,std::reverse_iterator<std::unique_ptr<char []>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<char []>>,std::reverse_iterator<std::unique_ptr<char []>*>>>::~__exception_guard_exceptions[abi:ne180100]( uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<char []>>,std::reverse_iterator<std::unique_ptr<char []>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<char []>>,std::reverse_iterator<std::unique_ptr<char []>*>>::operator()[abi:ne180100]( uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void ***)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    uint64_t v3 = *v1;
    *uint64_t v1 = 0LL;
    if (v3) {
      operator delete[](v3);
    }
    ++v1;
  }

uint64_t std::__split_buffer<std::unique_ptr<char []>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::unique_ptr<char []>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v5 = *(void **)(i - 8);
    *(void *)(i - 8) = 0LL;
    if (v5) {
      operator delete[](v5);
    }
  }

void std::vector<std::unique_ptr<char []>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<char []>>::__clear[abi:ne180100](v2);
    operator delete(**a1);
  }

void std::vector<std::unique_ptr<char []>>::__clear[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)*a1;
  uint64_t v3 = (void *)a1[1];
  while (v3 != v2)
  {
    uint64_t v5 = (void *)*--v3;
    uint64_t v4 = v5;
    *uint64_t v3 = 0LL;
    if (v5) {
      operator delete[](v4);
    }
  }

  a1[1] = v2;
}

uint64_t _Z8do_on_sgIZN18DiskImageIOBreaker5writeERN9DiskImage7ContextERK8sg_entryEUlRKT_RKT0_E_EDaOS7_S6_( uint64_t a1, uint64_t *a2)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  sg_vec_ns::make(a2, v41);
  sg_vec_ref::begin((sg_vec_ref *)v45, (uint64_t)v38);
  sg_vec_ref::end((sg_vec_ref *)v45, (uint64_t)v35);
  uint64_t v3 = DiskImage::Context::write( *(DiskImage::Context **)(*(void *)a1 + 16LL),  (const sg_vec_ns::details::sg_vec_iterator *)v38,  (const sg_vec_ns::details::sg_vec_iterator *)v35);
  uint64_t v4 = v37;
  if (v37)
  {
    p_shared_owners = (unint64_t *)&v37->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  uint64_t v7 = v36;
  if (v36)
  {
    uint64_t v8 = (unint64_t *)&v36->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  uint64_t v10 = v40;
  if (v40)
  {
    uint64_t v11 = (unint64_t *)&v40->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  size_t v13 = v39;
  if (v39)
  {
    char v14 = (unint64_t *)&v39->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  __int128 v16 = v51;
  if (v51)
  {
    uint64_t v17 = (unint64_t *)&v51->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  uint64_t v19 = v50;
  if (v50)
  {
    uint64_t v20 = (unint64_t *)&v50->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  __int16 v22 = v49;
  if (v49)
  {
    unint64_t v23 = (unint64_t *)&v49->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  uint64_t v25 = v48;
  if (v48)
  {
    unsigned __int8 v26 = (unint64_t *)&v48->__shared_owners_;
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  uint64_t v28 = v47;
  if (v47)
  {
    unint64_t v29 = (unint64_t *)&v47->__shared_owners_;
    do
      unint64_t v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }

  unint64_t v31 = v46;
  if (v46)
  {
    unint64_t v32 = (unint64_t *)&v46->__shared_owners_;
    do
      unint64_t v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }

  if (v43 && &v44 != __p) {
    operator delete(__p);
  }
  boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)v41);
  return v3;
}

void sub_188112364( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, char a50)
{
}

void *di_log::logger<di_log::log_printer<615ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<615ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E3A80;
  a1[45] = &unk_18A1E3B80;
  a1[46] = &unk_18A1E3BA8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E3A80;
  a1[45] = &unk_18A1E3B08;
  a1[46] = &unk_18A1E3B30;
  return a1;
}

void sub_188112438(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<615ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<615ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E3C18;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188112504(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<615ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E3C18;
  di_log::logger_buf<di_log::log_printer<615ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<615ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<615ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<615ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<615ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<615ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<615ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<615ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<615ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<615ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<615ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<615ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<615ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<615ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1881128B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<615ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 615LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 615LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t di_stackable::get_identifier(di_stackable *this, DiskImage *a2)
{
  v4[0] = (**(uint64_t (***)(di_stackable *, DiskImage *))this)(this, a2);
  v4[1] = v2;
  char v6 = &v5;
  return ((uint64_t (*)(char **, void *))off_18A1E3DF0[v2])(&v6, v4);
}

uint64_t di_stackable::get_stackable_source_identifier(di_stackable *this, DiskImage *a2)
{
  v4[0] = (**(uint64_t (***)(di_stackable *, DiskImage *))this)(this, a2);
  v4[1] = v2;
  char v6 = &v5;
  return ((uint64_t (*)(char **, void *))off_18A1E3E30[v2])(&v6, v4);
}

uint64_t DiskImageStackable::ContextStackable::get_bottom_async_cache(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  uint64_t v3 = *(void *)(a2 + 24) - v2;
  uint64_t v4 = v3 / 48;
  if (v3 < 49)
  {
    uint64_t v5 = 0LL;
  }

  else
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = v4 - 1;
    uint64_t v7 = (int *)(v2 + 48 * v4 - 96);
    do
    {
      int v8 = *v7;
      v7 -= 12;
      if (v8 != 2) {
        break;
      }
      ++v5;
    }

    while (v6-- > 1);
  }

  uint64_t v10 = v4 + ~v5;
  if (v5) {
    return v10;
  }
  else {
    return 0LL;
  }
}

uint64_t DiskImageStackable::write( DiskImageStackable *this, DiskImage::Context *a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4)
{
  unint64_t v8 = *((void *)a4 + 18);
  uint64_t v9 = (*(uint64_t (**)(DiskImageStackable *))(*(void *)this + 32LL))(this);
  if (**((_DWORD **)this + 2)) {
    return -78LL;
  }
  uint64_t v11 = (DiskImage::Context **)*((void *)a2 + 2);
  if (!(*(unsigned int (**)(void))(**((void **)*v11 + 1) + 40LL))(*((void *)*v11 + 1))
    || **((_DWORD **)this + 2))
  {
    return -78LL;
  }

  return DiskImage::Context::write(*v11, a3, a4);
}

uint64_t DiskImageStackable::flush(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void ***)(a2 + 16);
  uint64_t v3 = *(void ***)(a2 + 24);
  if (v2 == v3) {
    return 4294967218LL;
  }
  uint64_t v4 = 4294967218LL;
  do
  {
    if ((*(unsigned int (**)(void))(*(void *)(*v2)[1] + 40LL))((*v2)[1]))
    {
      uint64_t v4 = DiskImage::Context::flush(*v2);
      if ((_DWORD)v4) {
        break;
      }
    }

    v2 += 2;
  }

  while (v2 != v3);
  return v4;
}

uint64_t DiskImageStackable::DiskImageStackable(uint64_t a1, void **a2, _BYTE *a3)
{
  uint64_t v82 = *MEMORY[0x1895F89C0];
  *(_BYTE *)(a1 + 8) = 0;
  *(void *)a1 = &off_18A1E3C98;
  *(void *)(a1 + 16) = 0LL;
  uint64_t v6 = (uint64_t *)(a1 + 16);
  *(_BYTE *)(a1 + 56) = 0;
  uint64_t v7 = (void *)(a1 + 56);
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(_BYTE *)(a1 + 144) = 0;
  *(void *)(a1 + 40) = (*(uint64_t (**)(void))(*(void *)**a2 + 24LL))(**a2);
  *(_BYTE *)(a1 + 48) = 0;
  if ((*a3 & 2) != 0)
  {
    uint64_t v9 = a2[1];
    *(void *)&__int128 v71 = *(v9 - 3);
    uint64_t v10 = *(v9 - 2);
    *((void *)&v71 + 1) = v10;
    if (v10)
    {
      uint64_t v11 = (unint64_t *)(v10 + 8);
      do
        unint64_t v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      uint64_t v9 = a2[1];
    }

    uint64_t v13 = v9 - 3;
    while (v13 != *a2)
    {
      char v14 = (di_stackable *)*(v13 - 3);
      v13 -= 3;
      unint64_t v76 = v14;
      unint64_t v15 = (std::__shared_weak_count *)v13[1];
      unint64_t v77 = v15;
      if (v15)
      {
        p_shared_owners = (unint64_t *)&v15->__shared_owners_;
        do
          unint64_t v17 = __ldxr(p_shared_owners);
        while (__stxr(v17 + 1, p_shared_owners));
      }

      uint64_t identifier = di_stackable::get_identifier((di_stackable *)v71, v8);
      char v19 = identifier;
      uint64_t v80 = identifier;
      unint64_t v81 = v20;
      stackable_source_uint64_t identifier = di_stackable::get_stackable_source_identifier(v76, v20);
      uint64_t v78 = stackable_source_identifier;
      int v79 = v22;
      if (v19)
      {
LABEL_11:
        if ((_BYTE)stackable_source_identifier)
        {
LABEL_12:
          if (v80 != v78 || v81 != v79)
          {
            exception = __cxa_allocate_exception(0x40uLL);
            void *exception = off_18A1E43B0;
            unint64_t v66 = std::generic_category();
            exception[1] = 166LL;
            exception[2] = v66;
            *((_BYTE *)exception + 24) = 0;
            *((_BYTE *)exception + 48) = 0;
            exception[7] = "Corrupted shadow file(s) chain";
          }
        }

        else
        {
          uint64_t v29 = 1LL;
          while (v29 != 16)
          {
            if (*((unsigned __int8 *)&v78 + v29++))
            {
              break;
            }
          }
        }
      }

      else
      {
        uint64_t v27 = 1LL;
        while (v27 != 16)
        {
          if (*((unsigned __int8 *)&v80 + v27++))
          {
            break;
          }
        }
      }

      std::shared_ptr<DiskImage>::operator=[abi:ne180100](&v71, (uint64_t *)&v76);
      uint64_t v24 = v77;
      if (v77)
      {
        uint64_t v25 = (unint64_t *)&v77->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
    }

    unint64_t v31 = (std::__shared_weak_count *)*((void *)&v71 + 1);
    if (*((void *)&v71 + 1))
    {
      unint64_t v32 = (unint64_t *)(*((void *)&v71 + 1) + 8LL);
      do
        unint64_t v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
  }

  uint64_t v34 = (uint64_t)*a2;
  if (a2[1] != *a2)
  {
    int v35 = 0;
    unint64_t v36 = 0LL;
    uint64_t v69 = "Block size mismatch in DiskImageStackable";
    do
    {
      uint64_t v37 = (void *)(v34 + 24 * v36);
      uint64_t v38 = *(void *)(a1 + 40);
      if (*((_DWORD *)v37 + 4) == 2)
      {
        unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2);
        if (v39 >= 2 && v36 != v39 - 2)
        {
          unint64_t v41 = (const void *)(*a2)[a2[1] - *a2 - 3];
          if (v41)
          {
            {
              uint64_t v69 = "Currently, cache can only be added directly above plugin";
LABEL_88:
              unint64_t v67 = __cxa_allocate_exception(0x40uLL);
              void *v67 = off_18A1E43B0;
              unint64_t v68 = std::generic_category();
              v67[1] = 4294967274LL;
              v67[2] = v68;
              *((_BYTE *)v67 + 24) = 0;
              *((_BYTE *)v67 + 48) = 0;
              v67[7] = v69;
            }
          }
        }
      }

      uint64_t v42 = (di_stackable *)*v37;
      unint64_t v76 = v42;
      uint64_t v43 = (std::__shared_weak_count *)v37[1];
      unint64_t v77 = v43;
      uint64_t v44 = v42;
      if (v43)
      {
        unint64_t v45 = (unint64_t *)&v43->__shared_owners_;
        do
          unint64_t v46 = __ldxr(v45);
        while (__stxr(v46 + 1, v45));
        uint64_t v44 = (di_stackable *)*v37;
      }

      if ((*(unsigned int (**)(di_stackable *))(*(void *)v44 + 96LL))(v44))
      {
        LOBYTE(v78) = 1;
        std::allocate_shared[abi:ne180100]<DiskImageIOBreaker,std::allocator<DiskImageIOBreaker>,DiskImage &,BOOL,void>( (uint64_t)v42,  (char *)&v78,  &v71);
        std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100]((uint64_t)v37, &v71);
        uint64_t v47 = (std::__shared_weak_count *)*((void *)&v71 + 1);
        if (*((void *)&v71 + 1))
        {
          uint64_t v48 = (unint64_t *)(*((void *)&v71 + 1) + 8LL);
          do
            unint64_t v49 = __ldaxr(v48);
          while (__stlxr(v49 - 1, v48));
          if (!v49)
          {
            ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
            std::__shared_weak_count::__release_weak(v47);
          }
        }

        *(_BYTE *)(a1 + 48) = 1;
      }

      LODWORD(v71) = *((_DWORD *)v37 + 4);
      *((void *)&v71 + 1) = *v37;
      uint64_t v50 = (std::__shared_weak_count *)v37[1];
      unint64_t v72 = v50;
      if (v50)
      {
        uint64_t v51 = (unint64_t *)&v50->__shared_owners_;
        do
          unint64_t v52 = __ldxr(v51);
        while (__stxr(v52 + 1, v51));
      }

      unint64_t v73 = v76;
      uint64_t v74 = v77;
      if (v77)
      {
        uint64_t v53 = (unint64_t *)&v77->__shared_owners_;
        do
          unint64_t v54 = __ldxr(v53);
        while (__stxr(v54 + 1, v53));
      }

      uint64_t v75 = (*(uint64_t (**)(void))(*(void *)*v37 + 32LL))(*v37);
      std::vector<DiskImageStackable::stackable_layer>::emplace_back<DiskImageStackable::stackable_layer&>( v6,  (uint64_t)&v71);
      if (*((_DWORD *)v37 + 4) == 2) {
        v35 |= (*(uint64_t (**)(void))(*(void *)*v37 + 40LL))(*v37);
      }
      __int128 v55 = v74;
      if (v74)
      {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v56 = (unint64_t *)&v74->__shared_owners_;
        do
          unint64_t v57 = __ldaxr(v56);
        while (__stlxr(v57 - 1, v56));
        if (!v57)
        {
          ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
          std::__shared_weak_count::__release_weak(v55);
        }
      }

      uint64_t v58 = v72;
      if (v72)
      {
        uint64_t v59 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v60 = __ldaxr(v59);
        while (__stlxr(v60 - 1, v59));
        if (!v60)
        {
          ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
          std::__shared_weak_count::__release_weak(v58);
        }
      }

      __int128 v61 = v77;
      if (v77)
      {
        __int128 v62 = (unint64_t *)&v77->__shared_owners_;
        do
          unint64_t v63 = __ldaxr(v62);
        while (__stlxr(v63 - 1, v62));
        if (!v63)
        {
          ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
          std::__shared_weak_count::__release_weak(v61);
        }
      }

      ++v36;
      uint64_t v34 = (uint64_t)*a2;
    }

    while (v36 < 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2));
    if ((v35 & 1) != 0)
    {
      v70[0] = MEMORY[0x1895F87A8];
      v70[1] = 0x40000000LL;
      v70[2] = ___ZN18DiskImageStackableC2EONSt3__16vectorINS0_5tupleIJNS0_10shared_ptrI9DiskImageEENS_4roleEEEENS0_9allocatorIS7_EEEEN12di_stackable8config_tE_block_invoke;
      v70[3] = &__block_descriptor_tmp_6;
      v70[4] = a1;
      std::__optional_destruct_base<DiskImageStackable::cacheFlusher_t,false>::reset[abi:ne180100]((uint64_t)v7);
      DiskImageStackable::cacheFlusher_t::cacheFlusher_t(v7, (uint64_t)v70, 600000000LL);
      *(_BYTE *)(a1 + 144) = 1;
    }
  }

  return a1;
}

void sub_188113328( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t std::vector<DiskImageStackable::stackable_layer>::emplace_back<DiskImageStackable::stackable_layer&>( uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 4);
    if (v9 + 1 > 0x555555555555555LL) {
      std::vector<iovec>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    if (v10 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x555555555555555LL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v19 = v4;
    if (v12) {
      uint64_t v13 = (char *)std::allocator<sg_entry>::allocate_at_least[abi:ne180100](v4, v12);
    }
    else {
      uint64_t v13 = 0LL;
    }
    unint64_t v15 = v13;
    __int128 v16 = &v13[48 * v9];
    __int16 v18 = &v13[48 * v12];
    std::construct_at[abi:ne180100]<DiskImageStackable::stackable_layer,DiskImageStackable::stackable_layer&,DiskImageStackable::stackable_layer*>( (uint64_t)v16,  a2);
    unint64_t v17 = v16 + 48;
    std::vector<DiskImageStackable::stackable_layer>::__swap_out_circular_buffer(a1, &v15);
    uint64_t v8 = a1[1];
    std::__split_buffer<DiskImageStackable::stackable_layer>::~__split_buffer((uint64_t)&v15);
  }

  else
  {
    std::construct_at[abi:ne180100]<DiskImageStackable::stackable_layer,DiskImageStackable::stackable_layer&,DiskImageStackable::stackable_layer*>( *(void *)(v4 - 8),  a2);
    uint64_t v8 = v7 + 48;
    a1[1] = v7 + 48;
  }

  a1[1] = v8;
  return v8 - 48;
}

void sub_1881134BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t ___ZN18DiskImageStackableC2EONSt3__16vectorINS0_5tupleIJNS0_10shared_ptrI9DiskImageEENS_4roleEEEENS0_9allocatorIS7_EEEEN12di_stackable8config_tE_block_invoke( uint64_t a1)
{
  return DiskImageStackable::flush_caches(*(void *)(a1 + 32));
}

uint64_t DiskImageStackable::flush_caches(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 16);
  uint64_t v2 = *(void *)(this + 24);
  while (v1 != v2)
  {
    this = (*(uint64_t (**)(void))(**(void **)(v1 + 8) + 40LL))(*(void *)(v1 + 8));
    if ((_DWORD)this) {
      BOOL v3 = *(_DWORD *)v1 == 2;
    }
    else {
      BOOL v3 = 0;
    }
    if (v3)
    {
      uint64_t v4 = (void *)(*(uint64_t (**)(void))(**(void **)(v1 + 8) + 136LL))(*(void *)(v1 + 8));
      this = DiskImage::Context::flush(v4);
      if (v4) {
        this = (*(uint64_t (**)(void *))(*v4 + 40LL))(v4);
      }
    }

    v1 += 48LL;
  }

  return this;
}

void sub_18811355C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 40LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void DiskImageStackable::~DiskImageStackable(DiskImageStackable *this)
{
  *(void *)this = &off_18A1E3C98;
  DiskImageStackable::flush_caches((uint64_t)this);
  std::__optional_destruct_base<DiskImageStackable::cacheFlusher_t,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)this + 56);
  uint64_t v2 = (void **)((char *)this + 16);
  std::vector<DiskImageStackable::stackable_layer>::__destroy_vector::operator()[abi:ne180100](&v2);
}

{
  void *v1;
  DiskImageStackable::~DiskImageStackable(this);
  operator delete(v1);
}

unint64_t DiskImageStackable::read_from_next( uint64_t a1, DiskImageStackable::ContextStackable *a2, sg_vec_ns::details::sg_vec_iterator *a3, uint64_t a4, unint64_t a5, uint64_t *a6, int a7, int a8, uint64_t a9, DiskImage::extents_t *a10)
{
  uint64_t v15 = *(void *)(a1 + 40);
  unsigned int v16 = *((unsigned __int8 *)a6 + 16);
  uint64_t v17 = *a6;
  uint64_t v18 = a6[1];
  if ((v16 & 2) != 0) {
    uint64_t v19 = *a6;
  }
  else {
    uint64_t v19 = v17 + 1;
  }
  v34[0] = v19 * v15;
  v34[1] = ((v16 & 1) + v18 - v17 + (int)(((v16 >> 1) & 1) - 1) + v19) * v15;
  char v35 = 2;
  sg_vec_ns::details::sg_vec_iterator::subvec(a3, (uint64_t)v34, a4, (uint64_t)v36);
  unint64_t sg_from_next = DiskImageStackable::read_sg_from_next(a1, a2, (uint64_t)v36, (uint64_t)&v39, a5, a7, a8, a9, a10);
  uint64_t v21 = v41;
  if (v41)
  {
    p_shared_owners = (unint64_t *)&v41->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  uint64_t v24 = v40;
  if (v40)
  {
    uint64_t v25 = (unint64_t *)&v40->__shared_owners_;
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  uint64_t v27 = v38;
  if (v38)
  {
    uint64_t v28 = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

  unint64_t v30 = v37;
  if (v37)
  {
    unint64_t v31 = (unint64_t *)&v37->__shared_owners_;
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }

  return sg_from_next;
}

void sub_1881137B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

unint64_t DiskImageStackable::read_sg_from_next( uint64_t a1, DiskImageStackable::ContextStackable *a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6, int a7, int a8, DiskImage::extents_t *a9)
{
  unint64_t v14 = DiskImageStackable::read_from_idx();
  uint64_t v16 = v14;
  unint64_t v80 = v14;
  unint64_t v81 = v15;
  if ((v14 & 0x8000000000000000LL) == 0 || !(_DWORD)v14)
  {
    unint64_t v17 = *(void *)(a3 + 144);
    BOOL v18 = v15 < v17 || v14 > ((*(void *)(a4 + 144) - v17) & ~((uint64_t)(*(void *)(a4 + 144) - v17) >> 63));
    BOOL is_trim_required = 0;
    if (a5 && v18)
    {
      unint64_t v20 = *(void *)(a1 + 40);
      uint64_t v21 = *(void *)(a4 + 144) - v17;
      unint64_t v22 = v21 & ~(v21 >> 63);
      if (v22 <= v20) {
        unint64_t v22 = *(void *)(a1 + 40);
      }
      if (v21 <= 0) {
        unint64_t v23 = 0LL;
      }
      else {
        unint64_t v23 = v22;
      }
      v78[0] = v17 / v20;
      v78[1] = (v17 + v20 + v23 - 1) / v20;
      char v79 = 2;
      BOOL is_trim_required = DiskImageStackable::is_trim_required(a1, (uint64_t)a2, &v80, (uint64_t)v78, a5, a9);
    }

    BOOL v51 = is_trim_required;
    uint64_t v24 = *(std::__shared_weak_count **)(a3 + 8);
    uint64_t v65 = *(void *)a3;
    unint64_t v66 = v24;
    if (v24)
    {
      p_shared_owners = (unint64_t *)&v24->__shared_owners_;
      do
        unint64_t v26 = __ldxr(p_shared_owners);
      while (__stxr(v26 + 1, p_shared_owners));
    }

    v67[0] = *(_OWORD *)(a3 + 16);
    *(_OWORD *)((char *)v67 + 9) = *(_OWORD *)(a3 + 25);
    uint64_t v68 = *(void *)(a3 + 48);
    __int128 v69 = *(_OWORD *)(a3 + 56);
    __int128 v70 = *(_OWORD *)(a3 + 72);
    __int128 v71 = *(_OWORD *)(a3 + 88);
    char v72 = *(_BYTE *)(a3 + 104);
    uint64_t v27 = *(std::__shared_weak_count **)(a3 + 120);
    uint64_t v73 = *(void *)(a3 + 112);
    uint64_t v74 = v27;
    if (v27)
    {
      uint64_t v28 = (unint64_t *)&v27->__shared_owners_;
      do
        unint64_t v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }

    __int128 v75 = *(_OWORD *)(a3 + 128);
    uint64_t v76 = *(void *)(a3 + 144);
    char v77 = *(_BYTE *)(a3 + 152);
    unint64_t v30 = *(std::__shared_weak_count **)(a4 + 8);
    uint64_t v52 = *(void *)a4;
    uint64_t v53 = v30;
    if (v30)
    {
      unint64_t v31 = (unint64_t *)&v30->__shared_owners_;
      do
        unint64_t v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
    }

    v54[0] = *(_OWORD *)(a4 + 16);
    *(_OWORD *)((char *)v54 + 9) = *(_OWORD *)(a4 + 25);
    uint64_t v55 = *(void *)(a4 + 48);
    __int128 v56 = *(_OWORD *)(a4 + 56);
    __int128 v57 = *(_OWORD *)(a4 + 72);
    __int128 v58 = *(_OWORD *)(a4 + 88);
    char v59 = *(_BYTE *)(a4 + 104);
    unint64_t v33 = *(std::__shared_weak_count **)(a4 + 120);
    uint64_t v60 = *(void *)(a4 + 112);
    __int128 v61 = v33;
    if (v33)
    {
      uint64_t v34 = (unint64_t *)&v33->__shared_owners_;
      do
        unint64_t v35 = __ldxr(v34);
      while (__stxr(v35 + 1, v34));
    }

    uint64_t v36 = *(void *)(a4 + 144);
    __int128 v62 = *(_OWORD *)(a4 + 128);
    uint64_t v63 = v36;
    char v64 = *(_BYTE *)(a4 + 152);
    uint64_t v16 = DiskImageStackable::sync_read_data_to_diskimgs(a1, a2, (uint64_t)&v65, (uint64_t)&v52, &v80, a5);
    uint64_t v37 = v61;
    if (v61)
    {
      uint64_t v38 = (unint64_t *)&v61->__shared_owners_;
      do
        unint64_t v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }

    uint64_t v40 = v53;
    if (v53)
    {
      unint64_t v41 = (unint64_t *)&v53->__shared_owners_;
      do
        unint64_t v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }

    uint64_t v43 = v74;
    if (v74)
    {
      uint64_t v44 = (unint64_t *)&v74->__shared_owners_;
      do
        unint64_t v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }

    unint64_t v46 = v66;
    if (v66)
    {
      uint64_t v47 = (unint64_t *)&v66->__shared_owners_;
      do
        unint64_t v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }

    if ((v16 & 0x8000000000000000LL) == 0 || !(_DWORD)v16)
    {
      uint64_t v49 = *(void *)(a4 + 144);
      if (v51) {
        return trim_data(a3, a4, (v49 - *(void *)(a3 + 144)) & ~((v49 - *(void *)(a3 + 144)) >> 63), &v80);
      }
      else {
        return v49 - v81;
      }
    }
  }

  return v16;
}

uint64_t DiskImageStackable::get_di_extents_for_io@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a4 + 16) & 2) != 0) {
    uint64_t v8 = *(void *)a4;
  }
  else {
    uint64_t v8 = *(void *)a4 + 1LL;
  }
  unint64_t v9 = (*(_BYTE *)(a4 + 16) & 1) + *(void *)(a4 + 8);
  uint64_t v10 = *(void *)(result + 16);
  uint64_t v11 = *(void *)(result + 24);
  unint64_t v12 = *(void *)(v10 + 48 * a3 + 40);
  if (v12 < v9) {
    unint64_t v9 = *(void *)(v10 + 48 * a3 + 40);
  }
  *(void *)&__int128 v30 = v8;
  *((void *)&v30 + 1) = v9;
  LOBYTE(v31) = 2;
  if (0xAAAAAAAAAAAAAAABLL * ((v11 - v10) >> 4) - 1 <= a3 || v12 <= *(void *)(v10 + 48 * a3 + 88)) {
    goto LABEL_19;
  }
  uint64_t v13 = result;
  *(void *)&__int128 v28 = *(void *)(v10 + 48 * a3 + 88);
  *((void *)&v28 + 1) = v12;
  LOBYTE(v29) = 2;
  uint64_t result = boost::icl::intersects<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)&v28,  (uint64_t)&v30);
  if ((result & 1) == 0)
  {
    uint64_t v10 = *(void *)(v13 + 16);
LABEL_19:
    uint64_t v20 = *(void *)(*(void *)(a2 + 16) + 16 * a3);
    *(void *)a5 = *(void *)(v10 + 48 * a3 + 8);
    *(_OWORD *)(a5 + 8) = v30;
    *(void *)(a5 + 24) = v31;
    *(void *)(a5 + 32) = 0LL;
    *(void *)(a5 + 40) = v20;
    *(_DWORD *)(a5 + 48) = 6;
    *(void *)(a5 + 56) = off_18A1D1060;
    *(void *)(a5 + 80) = a5 + 56;
    return result;
  }

  __int128 v24 = v28;
  uint64_t v25 = v29;
  boost::icl::operator&<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)&v24,  (unint64_t *)&v30,  (uint64_t)&v26);
  uint64_t v14 = v30;
  if ((v31 & 2) == 0) {
    uint64_t v14 = v30 + 1;
  }
  uint64_t v15 = v26;
  if ((v27 & 2) == 0) {
    uint64_t v15 = v26 + 1;
  }
  *(void *)&__int128 v30 = v14;
  *((void *)&v30 + 1) = v15;
  LOBYTE(v31) = 2;
  uint64_t v16 = *(void *)(*(void *)(a2 + 16) + 16 * a3);
  uint64_t v32 = *(void *)(*(void *)(v13 + 16) + 48 * a3 + 8);
  __int128 v33 = v30;
  uint64_t v34 = v31;
  uint64_t v35 = 0LL;
  uint64_t v36 = v16;
  int v37 = 6;
  unint64_t v17 = v38;
  v38[0] = off_18A1D1060;
  unint64_t v39 = v38;
  BOOL v18 = operator new(0x20uLL);
  unint64_t v22 = v18 + 4;
  unint64_t v23 = (char *)(v18 + 4);
  *(_OWORD *)BOOL v18 = v26;
  void v18[2] = v27;
  *((_DWORD *)v18 + 6) = 1;
  __p = v18;
  DiskImage::extents_t_transformer::make_transformed_extents((DiskImage::extents_t *)&v32, (uint64_t)&__p, a5);
  if (__p)
  {
    unint64_t v22 = __p;
    operator delete(__p);
  }

  if (v39 == v38)
  {
    uint64_t v19 = 4LL;
  }

  else
  {
    if (!v39) {
      goto LABEL_23;
    }
    uint64_t v19 = 5LL;
    unint64_t v17 = v39;
  }

  (*(void (**)(void *))(*v17 + 8 * v19))(v17);
LABEL_23:
  uint64_t result = v35;
  uint64_t v35 = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40LL))(result);
  }
  return result;
}

void sub_188113E38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35)
{
  if (__p) {
    operator delete(__p);
  }
  if (a35 == v35)
  {
    uint64_t v37 = 4LL;
  }

  else
  {
    if (!a35) {
      goto LABEL_8;
    }
    uint64_t v37 = 5LL;
    uint64_t v35 = a35;
  }

  (*(void (**)(void *))(*v35 + 8 * v37))(v35);
LABEL_8:
  if (a29) {
    (*(void (**)(uint64_t))(*(void *)a29 + 40LL))(a29);
  }
  _Unwind_Resume(exception_object);
}

BOOL boost::icl::intersects<boost::icl::discrete_interval<unsigned long long,std::less>>( uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 16);
  if (*(_BYTE *)(a1 + 16))
  {
    if (v2 == 3)
    {
      unint64_t v3 = *(void *)a1;
      unint64_t v4 = *(void *)(a1 + 8);
      if (v4 < *(void *)a1) {
        return 0LL;
      }
    }

    else
    {
      unint64_t v3 = *(void *)a1;
      unint64_t v4 = *(void *)(a1 + 8);
      if (*(void *)a1 >= v4) {
        return 0LL;
      }
    }
  }

  else
  {
    unint64_t v3 = *(void *)a1;
    unint64_t v4 = *(void *)(a1 + 8);
    if (*(void *)a1 >= v4 || *(void *)a1 + 1LL >= v4) {
      return 0LL;
    }
  }

  int v6 = *(unsigned __int8 *)(a2 + 16);
  if (*(_BYTE *)(a2 + 16))
  {
    if (v6 == 3)
    {
      unint64_t v8 = *(void *)a2;
      unint64_t v7 = *(void *)(a2 + 8);
      if (v7 < *(void *)a2) {
        return 0LL;
      }
    }

    else
    {
      unint64_t v8 = *(void *)a2;
      unint64_t v7 = *(void *)(a2 + 8);
      if (*(void *)a2 >= v7) {
        return 0LL;
      }
    }
  }

  else
  {
    unint64_t v8 = *(void *)a2;
    unint64_t v7 = *(void *)(a2 + 8);
    if (*(void *)a2 >= v7 || *(void *)a2 + 1LL >= v7) {
      return 0LL;
    }
  }

  if ((_BYTE)v2)
  {
    if (*(_BYTE *)(a1 + 16) == 3)
    {
      if (v4 < v3) {
        return 0LL;
      }
    }

    else if (v3 >= v4)
    {
      return 0LL;
    }
  }

  else
  {
    BOOL result = 0LL;
    if (v3 >= v4 || v3 + 1 >= v4) {
      return result;
    }
  }

  if ((_BYTE)v6)
  {
    if (*(_BYTE *)(a2 + 16) == 3)
    {
      if (v7 < v8) {
        return 0LL;
      }
    }

    else if (v8 >= v7)
    {
      return 0LL;
    }
  }

  else
  {
    BOOL result = 0LL;
    if (v8 >= v7 || v8 + 1 >= v7) {
      return result;
    }
  }

  if ((v6 & 2) != 0) {
    unint64_t v11 = v8;
  }
  else {
    unint64_t v11 = v8 + 1;
  }
  if ((v2 & 1) + v4 - 1 < v11) {
    return 0LL;
  }
  if ((_BYTE)v6)
  {
    if (*(_BYTE *)(a2 + 16) == 3)
    {
      if (v7 < v8) {
        return 0LL;
      }
    }

    else if (v8 >= v7)
    {
      return 0LL;
    }
  }

  else
  {
    BOOL result = 0LL;
    if (v8 >= v7 || v8 + 1 >= v7) {
      return result;
    }
  }

  if (!(_BYTE)v2)
  {
    BOOL result = 0LL;
    if (v3 >= v4 || v3 + 1 >= v4) {
      return result;
    }
    goto LABEL_60;
  }

  if (v2 == 3)
  {
    if (v4 >= v3) {
      goto LABEL_60;
    }
    return 0LL;
  }

  if (v3 >= v4) {
    return 0LL;
  }
LABEL_60:
  if ((v2 & 2) == 0) {
    ++v3;
  }
  return (v6 & 1) + v7 - 1 >= v3;
}

BOOL DiskImageStackable::is_trim_required( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, unint64_t a5, DiskImage::extents_t *a6)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  unint64_t v6 = *(void *)(a1 + 40);
  unint64_t v7 = a3[1];
  if (*a3 <= v6) {
    unint64_t v8 = *(void *)(a1 + 40);
  }
  else {
    unint64_t v8 = *a3;
  }
  if (*a3) {
    unint64_t v9 = v8;
  }
  else {
    unint64_t v9 = 0LL;
  }
  v35[0] = v7 / v6;
  v35[1] = (v7 + v9) / v6;
  char v36 = 2;
  if (a5)
  {
    uint64_t v14 = 0LL;
    unint64_t v15 = 0LL;
    unint64_t v30 = a5 - 1;
    BOOL v16 = 1;
    while (1)
    {
      if (*(_DWORD *)(*(void *)(a1 + 16) + v14) == 2) {
        goto LABEL_37;
      }
      if (a6 && v30 == v15) {
        DiskImage::extents_t::extents_t((DiskImage::extents_t *)v41, a6);
      }
      else {
        DiskImageStackable::get_di_extents_for_io(a1, a2, v15, a4, (uint64_t)v41);
      }
      DiskImageStackable::get_di_extents_for_io(a1, a2, v15, (uint64_t)v35, (uint64_t)v37);
      DiskImage::extents_t::begin((DiskImage::extents_t *)v37, (uint64_t)v34);
      DiskImage::extents_t::end((DiskImage::extents_t *)v37, (uint64_t)v33);
      DiskImage::extents_t::begin((DiskImage::extents_t *)v41, (uint64_t)v32);
      DiskImage::extents_t::end((DiskImage::extents_t *)v41, (uint64_t)v31);
      BOOL v17 = std::equal[abi:ne180100]<DiskImage::const_extents_iterator_t,DiskImage::const_extents_iterator_t>( v34,  v33,  v32,  v31);
      uint64_t v18 = v31[0];
      v31[0] = 0LL;
      if (v18) {
        (*(void (**)(uint64_t))(*(void *)v18 + 24LL))(v18);
      }
      uint64_t v19 = v32[0];
      v32[0] = 0LL;
      if (v19) {
        (*(void (**)(uint64_t))(*(void *)v19 + 24LL))(v19);
      }
      uint64_t v20 = v33[0];
      v33[0] = 0LL;
      if (v20) {
        (*(void (**)(uint64_t))(*(void *)v20 + 24LL))(v20);
      }
      uint64_t v21 = v34[0];
      v34[0] = 0LL;
      if (v21) {
        (*(void (**)(uint64_t))(*(void *)v21 + 24LL))(v21);
      }
      unint64_t v22 = v40;
      if (v40 == v39)
      {
        unint64_t v22 = v39;
        uint64_t v23 = 4LL;
      }

      else
      {
        if (!v40) {
          goto LABEL_27;
        }
        uint64_t v23 = 5LL;
      }

      (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_27:
      uint64_t v24 = v38;
      uint64_t v38 = 0LL;
      if (v24) {
        (*(void (**)(uint64_t))(*(void *)v24 + 40LL))(v24);
      }
      uint64_t v25 = v44;
      if (v44 == v43)
      {
        uint64_t v25 = v43;
        uint64_t v26 = 4LL;
      }

      else
      {
        if (!v44) {
          goto LABEL_34;
        }
        uint64_t v26 = 5LL;
      }

      (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_34:
      uint64_t v27 = v42;
      uint64_t v42 = 0LL;
      if (v27) {
        (*(void (**)(uint64_t))(*(void *)v27 + 40LL))(v27);
      }
      if (!v17) {
        return v16;
      }
LABEL_37:
      BOOL v16 = ++v15 < a5;
      v14 += 48LL;
      if (a5 == v15) {
        return v16;
      }
    }
  }

  return 0;
}

void sub_188114310( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, void *a49)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 24LL))(a12);
  }
  if (a18) {
    (*(void (**)(uint64_t))(*(void *)a18 + 24LL))(a18);
  }
  if (a24) {
    (*(void (**)(uint64_t))(*(void *)a24 + 24LL))(a24);
  }
  if (a30) {
    (*(void (**)(uint64_t))(*(void *)a30 + 24LL))(a30);
  }
  if (a49 == v50)
  {
    uint64_t v53 = 4LL;
  }

  else
  {
    if (!a49) {
      goto LABEL_14;
    }
    uint64_t v53 = 5LL;
    uint64_t v50 = a49;
  }

  (*(void (**)(void *))(*v50 + 8 * v53))(v50);
LABEL_14:
  if (a43) {
    (*(void (**)(uint64_t))(*(void *)a43 + 40LL))(a43);
  }
  unint64_t v54 = *(void **)(v51 - 104);
  if (v54 == v49)
  {
    uint64_t v55 = 4LL;
  }

  else
  {
    if (!v54) {
      goto LABEL_21;
    }
    uint64_t v55 = 5LL;
    uint64_t v49 = *(void **)(v51 - 104);
  }

  (*(void (**)(void *))(*v49 + 8 * v55))(v49);
LABEL_21:
  uint64_t v56 = *(void *)(v51 - 152);
  *(void *)(v51 - 152) = 0LL;
  if (v56) {
    (*(void (**)(uint64_t))(*(void *)v56 + 40LL))(v56);
  }
  _Unwind_Resume(exception_object);
}

BOOL std::equal[abi:ne180100]<DiskImage::const_extents_iterator_t,DiskImage::const_extents_iterator_t>( void *a1, void *a2, void *a3, void *a4)
{
  if (DiskImage::const_extents_iterator_t::operator!=((uint64_t)&v20, (uint64_t)v19))
  {
    while (DiskImage::const_extents_iterator_t::operator!=((uint64_t)&v16, (uint64_t)v15))
    {
      BOOL v7 = boost::icl::operator==<boost::icl::discrete_interval<unsigned long long,std::less>>(v21, v17);
      if (v22 != v18 || !v7) {
        goto LABEL_10;
      }
      DiskImage::const_extents_iterator_t::operator++((DiskImage::const_extents_iterator_t *)&v20);
      DiskImage::const_extents_iterator_t::operator++((DiskImage::const_extents_iterator_t *)&v16);
    }
  }

  else {
LABEL_10:
  }
    BOOL v9 = 0LL;
  uint64_t v10 = v15[0];
  v15[0] = 0LL;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24LL))(v10);
  }
  uint64_t v11 = v16;
  uint64_t v16 = 0LL;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24LL))(v11);
  }
  uint64_t v12 = v19[0];
  v19[0] = 0LL;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 24LL))(v12);
  }
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24LL))(v13);
  }
  return v9;
}

void sub_1881145A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
  if (a15) {
    (*(void (**)(uint64_t))(*(void *)a15 + 24LL))(a15);
  }
  if (a21) {
    (*(void (**)(uint64_t))(*(void *)a21 + 24LL))(a21);
  }
  uint64_t v23 = *(void *)(v21 - 80);
  *(void *)(v21 - 80) = 0LL;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 24LL))(v23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t DiskImageStackable::sync_read_data_to_diskimgs( uint64_t a1, DiskImageStackable::ContextStackable *a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6)
{
  v200[15] = *MEMORY[0x1895F89C0];
  unint64_t v6 = *(void *)(a1 + 40);
  unint64_t v7 = *a5;
  unint64_t v8 = a5[1] % v6;
  BOOL v9 = v8 == 0;
  unint64_t v10 = v6 - v8;
  if (v9) {
    unint64_t v10 = 0LL;
  }
  if (v7 < v10) {
    return 0LL;
  }
  uint64_t v15 = a1;
  v178[0] = 0;
  char v179 = 0;
  uint64_t v16 = *(std::__shared_weak_count **)(a3 + 8);
  unint64_t v17 = (v7 - v10) / v6 * v6;
  unint64_t v165 = *(void *)a3;
  __int128 v166 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v19 = __ldxr(p_shared_owners);
    while (__stxr(v19 + 1, p_shared_owners));
  }

  __int128 v20 = *(_OWORD *)(a3 + 56);
  v167[0] = *(_OWORD *)(a3 + 16);
  *(_OWORD *)((char *)v167 + 9) = *(_OWORD *)(a3 + 25);
  uint64_t v168 = *(void *)(a3 + 48);
  __int128 v169 = v20;
  __int128 v21 = *(_OWORD *)(a3 + 88);
  __int128 v170 = *(_OWORD *)(a3 + 72);
  __int128 v171 = v21;
  char v172 = *(_BYTE *)(a3 + 104);
  int v22 = *(std::__shared_weak_count **)(a3 + 120);
  uint64_t v173 = *(void *)(a3 + 112);
  char v174 = v22;
  if (v22)
  {
    uint64_t v23 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }

  uint64_t v25 = *(void *)(a3 + 144);
  __int128 v175 = *(_OWORD *)(a3 + 128);
  uint64_t v176 = v25;
  char v177 = *(_BYTE *)(a3 + 152);
  sg_vec_ns::generate_vec_ref((uint64_t)&v165, a4, a5[1] + v10, v17, 0xFFFFFFFFFFFFFFFFLL, (sg_vec_ref *)&v180);
  std::__optional_destruct_base<sg_vec_ref,false>::reset[abi:ne180100]((uint64_t)v178);
  sg_vec_ref::sg_vec_ref((sg_vec_ref *)v178, (uint64_t)&v180);
  char v179 = 1;
  uint64_t v26 = v194;
  if (v194)
  {
    uint64_t v27 = (unint64_t *)&v194->__shared_owners_;
    do
      unint64_t v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  uint64_t v29 = v192;
  if (v192)
  {
    unint64_t v30 = (unint64_t *)&v192->__shared_owners_;
    do
      unint64_t v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

  uint64_t v32 = v190;
  if (v190)
  {
    __int128 v33 = (unint64_t *)&v190->__shared_owners_;
    do
      unint64_t v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }

  uint64_t v35 = v188;
  if (v188)
  {
    char v36 = (unint64_t *)&v188->__shared_owners_;
    do
      unint64_t v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }

  uint64_t v38 = v185;
  if (v185)
  {
    unint64_t v39 = (unint64_t *)&v185->__shared_owners_;
    do
      unint64_t v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }

  unint64_t v41 = v182;
  if (v182)
  {
    uint64_t v42 = (unint64_t *)&v182->__shared_owners_;
    do
      unint64_t v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }

  uint64_t v44 = v174;
  if (v174)
  {
    uint64_t v45 = (unint64_t *)&v174->__shared_owners_;
    do
      unint64_t v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }

  uint64_t v47 = v166;
  if (v166)
  {
    unint64_t v48 = (unint64_t *)&v166->__shared_owners_;
    do
      unint64_t v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }

  sg_vec_ns::details::sg_vec_iterator::operator+=(a3, v17);
  sg_vec_ns::details::buffer_iterator::rtrim_written((void *)(a3 + 56));
  sg_vec_ref::begin((sg_vec_ref *)v178, (uint64_t)&v180);
  sg_vec_ns::details::sg_vec_iterator::operator=(a3, (uint64_t)&v180);
  uint64_t v50 = v183;
  if (v183)
  {
    uint64_t v51 = (unint64_t *)&v183->__shared_owners_;
    do
      unint64_t v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }

  uint64_t v53 = (std::__shared_weak_count *)v180.n128_u64[1];
  if (v180.n128_u64[1])
  {
    unint64_t v54 = (unint64_t *)(v180.n128_u64[1] + 8);
    do
      unint64_t v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }

  sg_vec_ref::end((sg_vec_ref *)v178, (uint64_t)&v180);
  sg_vec_ns::details::sg_vec_iterator::operator=(a4, (uint64_t)&v180);
  uint64_t v56 = v183;
  if (v183)
  {
    __int128 v57 = (unint64_t *)&v183->__shared_owners_;
    do
      unint64_t v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }

  char v59 = (std::__shared_weak_count *)v180.n128_u64[1];
  if (v180.n128_u64[1])
  {
    uint64_t v60 = (unint64_t *)(v180.n128_u64[1] + 8);
    do
      unint64_t v61 = __ldaxr(v60);
    while (__stlxr(v61 - 1, v60));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }

  int64_t v62 = a6 - 1;
  if (v62 < 0)
  {
LABEL_192:
    uint64_t v11 = (*(void *)(a4 + 144) - *(void *)(a3 + 144)) & ~((uint64_t)(*(void *)(a4 + 144) - *(void *)(a3 + 144)) >> 63);
    goto LABEL_193;
  }

  uint64_t v154 = v15;
  while (1)
  {
    int v63 = *(_DWORD *)(*(void *)(v15 + 16) + 48 * v62);
    if (v63 != 1) {
      break;
    }
LABEL_190:
    if (v62-- <= 0) {
      goto LABEL_192;
    }
  }

  if (!v63) {
    goto LABEL_192;
  }
  uint64_t v64 = *(void *)(*(void *)(*((void *)a2 + 2) + 16 * v62) + 8LL);
  unint64_t v198 = v200;
  __int128 v199 = xmmword_188178830;
  uint64_t v65 = *(void *)(a3 + 24);
  uint64_t v66 = *(void *)(a4 + 144) - *(void *)(a3 + 144);
  uint64_t v67 = v66 & ~(v66 >> 63);
  while (!sg_vec_ns::details::sg_vec_iterator::operator==(a3, a4))
  {
    sg_vec_ns::details::buffer_iterator::sync((sg_vec_ns::details::buffer_iterator *)(a3 + 56));
    uint64_t v68 = *(std::__shared_weak_count **)(a3 + 120);
    if (v68)
    {
      __int128 v69 = (unint64_t *)&v68->__shared_owners_;
      do
        unint64_t v70 = __ldxr(v69);
      while (__stxr(v70 + 1, v69));
    }

    uint64_t v71 = *(void *)(a3 + 144);
    else {
      unint64_t v72 = (*(void *)(a4 + 144) - v71) & ~((*(void *)(a4 + 144) - v71) >> 63);
    }
    if (!v68) {
      goto LABEL_88;
    }
    uint64_t v73 = (unint64_t *)&v68->__shared_owners_;
    do
      unint64_t v74 = __ldaxr(v73);
    while (__stlxr(v74 - 1, v73));
    if (!v74)
    {
      ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
      std::__shared_weak_count::__release_weak(v68);
      if (!v72) {
        goto LABEL_96;
      }
LABEL_89:
      unint64_t v75 = *(void *)a3;
      unint64_t v76 = *(void *)(a3 + 8);
      v180.n128_u64[0] = *(void *)a3;
      v180.n128_u64[1] = v76;
      if (v76)
      {
        char v77 = (unint64_t *)(v76 + 8);
        do
          unint64_t v78 = __ldxr(v77);
        while (__stxr(v78 + 1, v77));
      }

      unint64_t v181 = v72;
      uint64_t v80 = (uint64_t)v198;
      uint64_t v79 = v199;
      unint64_t v81 = (__n128 *)&v198[3 * v199];
      if ((void)v199 == *((void *)&v199 + 1))
      {
        boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::shared_ptr<char>,unsigned long>*,std::pair<std::shared_ptr<char>,unsigned long>>>( (uint64_t *)&v198,  v81,  (const char *)1,  &v180,  &v159);
        unint64_t v88 = (std::__shared_weak_count *)v180.n128_u64[1];
        if (v180.n128_u64[1])
        {
          unint64_t v89 = (unint64_t *)(v180.n128_u64[1] + 8);
          do
            unint64_t v90 = __ldaxr(v89);
          while (__stlxr(v90 - 1, v89));
          if (!v90)
          {
            ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
            std::__shared_weak_count::__release_weak(v88);
          }
        }
      }

      else
      {
        v81->n128_u64[0] = v75;
        v81->n128_u64[1] = v180.n128_u64[1];
        *(void *)(v80 + 24 * v79 + 16) = v72;
        *(void *)&__int128 v199 = v79 + 1;
      }

      sg_vec_ns::details::sg_vec_iterator::operator+=(a3, v72);
    }

    else
    {
LABEL_88:
      if (v72) {
        goto LABEL_89;
      }
LABEL_96:
      sg_vec_ns::details::sg_vec_iterator::operator++(a3, (uint64_t)v162);
      uint64_t v82 = v164;
      if (v164)
      {
        uint64_t v83 = (unint64_t *)&v164->__shared_owners_;
        do
          unint64_t v84 = __ldaxr(v83);
        while (__stlxr(v84 - 1, v83));
        if (!v84)
        {
          ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
          std::__shared_weak_count::__release_weak(v82);
        }
      }

      uint64_t v85 = v163;
      if (v163)
      {
        uint64_t v86 = (unint64_t *)&v163->__shared_owners_;
        do
          unint64_t v87 = __ldaxr(v86);
        while (__stlxr(v87 - 1, v86));
        if (!v87)
        {
          ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
          std::__shared_weak_count::__release_weak(v85);
        }
      }
    }
  }

  sg_vec::sg_vec((uint64_t *)&v180, (uint64_t)&v198, v65, v67);
  sg_vec_ref::begin((sg_vec_ref *)&v187, (uint64_t)&v159);
  sg_vec_ref::end((sg_vec_ref *)&v187, (uint64_t)v156);
  BOOL v91 = sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&v159, (uint64_t)v156);
  __n128 v92 = v158;
  if (v158)
  {
    unint64_t v93 = (unint64_t *)&v158->__shared_owners_;
    do
      unint64_t v94 = __ldaxr(v93);
    while (__stlxr(v94 - 1, v93));
    if (!v94)
    {
      ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
      std::__shared_weak_count::__release_weak(v92);
    }
  }

  __int128 v95 = v157;
  if (v157)
  {
    unint64_t v96 = (unint64_t *)&v157->__shared_owners_;
    do
      unint64_t v97 = __ldaxr(v96);
    while (__stlxr(v97 - 1, v96));
    if (!v97)
    {
      ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
      std::__shared_weak_count::__release_weak(v95);
    }
  }

  unint64_t v98 = v161;
  if (v161)
  {
    unint64_t v99 = (unint64_t *)&v161->__shared_owners_;
    do
      unint64_t v100 = __ldaxr(v99);
    while (__stlxr(v100 - 1, v99));
    if (!v100)
    {
      ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
      std::__shared_weak_count::__release_weak(v98);
    }
  }

  __int128 v101 = v160;
  if (v160)
  {
    unint64_t v102 = (unint64_t *)&v160->__shared_owners_;
    do
      unint64_t v103 = __ldaxr(v102);
    while (__stlxr(v103 - 1, v102));
    if (!v103)
    {
      ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
      std::__shared_weak_count::__release_weak(v101);
      if (!v91) {
        goto LABEL_131;
      }
      goto LABEL_156;
    }
  }

  if (v91) {
    goto LABEL_156;
  }
LABEL_131:
  sg_vec_ref::begin((sg_vec_ref *)&v187, (uint64_t)&v159);
  sg_vec_ref::end((sg_vec_ref *)&v187, (uint64_t)v156);
  uint64_t v11 = DiskImageStackable::ContextStackable::write_cache( a2,  v62,  (const sg_vec_ns::details::sg_vec_iterator *)&v159,  (const sg_vec_ns::details::sg_vec_iterator *)v156);
  char v104 = v158;
  if (v158)
  {
    unint64_t v105 = (unint64_t *)&v158->__shared_owners_;
    do
      unint64_t v106 = __ldaxr(v105);
    while (__stlxr(v106 - 1, v105));
    if (!v106)
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
  }

  __int128 v107 = v157;
  if (v157)
  {
    unint64_t v108 = (unint64_t *)&v157->__shared_owners_;
    do
      unint64_t v109 = __ldaxr(v108);
    while (__stlxr(v109 - 1, v108));
    if (!v109)
    {
      ((void (*)(std::__shared_weak_count *))v107->__on_zero_shared)(v107);
      std::__shared_weak_count::__release_weak(v107);
    }
  }

  uint64_t v110 = v161;
  if (v161)
  {
    unint64_t v111 = (unint64_t *)&v161->__shared_owners_;
    do
      unint64_t v112 = __ldaxr(v111);
    while (__stlxr(v112 - 1, v111));
    if (!v112)
    {
      ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
      std::__shared_weak_count::__release_weak(v110);
    }
  }

  uint64_t v113 = v160;
  if (!v160) {
    goto LABEL_150;
  }
  unint64_t v114 = (unint64_t *)&v160->__shared_owners_;
  do
    unint64_t v115 = __ldaxr(v114);
  while (__stlxr(v115 - 1, v114));
  if (v115)
  {
LABEL_150:
    if (v11 < 0) {
      goto LABEL_151;
    }
    goto LABEL_156;
  }

  ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
  std::__shared_weak_count::__release_weak(v113);
  if ((v11 & 0x8000000000000000LL) == 0) {
    goto LABEL_156;
  }
LABEL_151:
  if (!(_DWORD)v11)
  {
LABEL_156:
    __int128 v116 = v197;
    uint64_t v15 = v154;
    if (v197)
    {
      unint64_t v117 = (unint64_t *)&v197->__shared_owners_;
      do
        unint64_t v118 = __ldaxr(v117);
      while (__stlxr(v118 - 1, v117));
      if (!v118)
      {
        ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
        std::__shared_weak_count::__release_weak(v116);
      }
    }

    unint64_t v119 = v196;
    if (v196)
    {
      unint64_t v120 = (unint64_t *)&v196->__shared_owners_;
      do
        unint64_t v121 = __ldaxr(v120);
      while (__stlxr(v121 - 1, v120));
      if (!v121)
      {
        ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
        std::__shared_weak_count::__release_weak(v119);
      }
    }

    char v122 = v195;
    if (v195)
    {
      unint64_t v123 = (unint64_t *)&v195->__shared_owners_;
      do
        unint64_t v124 = __ldaxr(v123);
      while (__stlxr(v124 - 1, v123));
      if (!v124)
      {
        ((void (*)(std::__shared_weak_count *))v122->__on_zero_shared)(v122);
        std::__shared_weak_count::__release_weak(v122);
      }
    }

    unint64_t v125 = v193;
    if (v193)
    {
      unint64_t v126 = (unint64_t *)&v193->__shared_owners_;
      do
        unint64_t v127 = __ldaxr(v126);
      while (__stlxr(v127 - 1, v126));
      if (!v127)
      {
        ((void (*)(std::__shared_weak_count *))v125->__on_zero_shared)(v125);
        std::__shared_weak_count::__release_weak(v125);
      }
    }

    __int128 v128 = v191;
    if (v191)
    {
      unint64_t v129 = (unint64_t *)&v191->__shared_owners_;
      do
        unint64_t v130 = __ldaxr(v129);
      while (__stlxr(v130 - 1, v129));
      if (!v130)
      {
        ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
        std::__shared_weak_count::__release_weak(v128);
      }
    }

    uint64_t v131 = v189;
    if (v189)
    {
      unint64_t v132 = (unint64_t *)&v189->__shared_owners_;
      do
        unint64_t v133 = __ldaxr(v132);
      while (__stlxr(v133 - 1, v132));
      if (!v133)
      {
        ((void (*)(std::__shared_weak_count *))v131->__on_zero_shared)(v131);
        std::__shared_weak_count::__release_weak(v131);
      }
    }

    if (v185 && v186 != __p) {
      operator delete(__p);
    }
    boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)&v180);
    boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)&v198);
    goto LABEL_190;
  }

  uint64_t v136 = v197;
  if (v197)
  {
    __int128 v137 = (unint64_t *)&v197->__shared_owners_;
    do
      unint64_t v138 = __ldaxr(v137);
    while (__stlxr(v138 - 1, v137));
    if (!v138)
    {
      ((void (*)(std::__shared_weak_count *))v136->__on_zero_shared)(v136);
      std::__shared_weak_count::__release_weak(v136);
    }
  }

  uint64_t v139 = v196;
  if (v196)
  {
    uint64_t v140 = (unint64_t *)&v196->__shared_owners_;
    do
      unint64_t v141 = __ldaxr(v140);
    while (__stlxr(v141 - 1, v140));
    if (!v141)
    {
      ((void (*)(std::__shared_weak_count *))v139->__on_zero_shared)(v139);
      std::__shared_weak_count::__release_weak(v139);
    }
  }

  __int128 v142 = v195;
  if (v195)
  {
    uint64_t v143 = (unint64_t *)&v195->__shared_owners_;
    do
      unint64_t v144 = __ldaxr(v143);
    while (__stlxr(v144 - 1, v143));
    if (!v144)
    {
      ((void (*)(std::__shared_weak_count *))v142->__on_zero_shared)(v142);
      std::__shared_weak_count::__release_weak(v142);
    }
  }

  __int128 v145 = v193;
  if (v193)
  {
    __int128 v146 = (unint64_t *)&v193->__shared_owners_;
    do
      unint64_t v147 = __ldaxr(v146);
    while (__stlxr(v147 - 1, v146));
    if (!v147)
    {
      ((void (*)(std::__shared_weak_count *))v145->__on_zero_shared)(v145);
      std::__shared_weak_count::__release_weak(v145);
    }
  }

  uint64_t v148 = v191;
  if (v191)
  {
    unint64_t v149 = (unint64_t *)&v191->__shared_owners_;
    do
      unint64_t v150 = __ldaxr(v149);
    while (__stlxr(v150 - 1, v149));
    if (!v150)
    {
      ((void (*)(std::__shared_weak_count *))v148->__on_zero_shared)(v148);
      std::__shared_weak_count::__release_weak(v148);
    }
  }

  uint64_t v151 = v189;
  if (v189)
  {
    char v152 = (unint64_t *)&v189->__shared_owners_;
    do
      unint64_t v153 = __ldaxr(v152);
    while (__stlxr(v153 - 1, v152));
    if (!v153)
    {
      ((void (*)(std::__shared_weak_count *))v151->__on_zero_shared)(v151);
      std::__shared_weak_count::__release_weak(v151);
    }
  }

  if (v185 && v186 != __p) {
    operator delete(__p);
  }
  boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)&v180);
  boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)&v198);
LABEL_193:
  std::__optional_destruct_base<sg_vec_ref,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v178);
  return v11;
}

void sub_188115298(_Unwind_Exception *a1)
{
}

uint64_t DiskImageStackable::ContextStackable::write_cache( DiskImageStackable::ContextStackable *this, unint64_t a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4)
{
  if (*((_BYTE *)this + 48) && *((void *)this + 5) <= a2) {
    return 0LL;
  }
  else {
    return DiskImage::Context::write(*(DiskImage::Context **)(*((void *)this + 2) + 16 * a2), a3, a4);
  }
}

unint64_t DiskImageStackable::read_from_idx( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, char a6, BOOL a7, sg_vec_ref *a8)
{
  uint64_t v12 = (void *)a1;
  uint64_t v367 = *MEMORY[0x1895F89C0];
  char v249 = (unint64_t *)(a3 + 144);
  unint64_t v13 = *(void *)(a1 + 40);
  unint64_t v252 = *(void *)(a3 + 144);
  unint64_t v14 = v252 % v13;
  uint64_t v15 = v13 - v252 % v13;
  uint64_t v16 = *(void *)(a3 + 8);
  if (v14) {
    uint64_t v17 = v15;
  }
  else {
    uint64_t v17 = 0LL;
  }
  *(void *)&__int128 v334 = *(void *)a3;
  *((void *)&v334 + 1) = v16;
  if (v16)
  {
    int v18 = (unint64_t *)(v16 + 8);
    do
      unint64_t v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }

  v335[0] = *(_OWORD *)(a3 + 16);
  *(_OWORD *)((char *)v335 + 9) = *(_OWORD *)(a3 + 25);
  uint64_t v336 = *(void *)(a3 + 48);
  __int128 v337 = *(_OWORD *)(a3 + 56);
  __int128 v338 = *(_OWORD *)(a3 + 72);
  __int128 v339 = *(_OWORD *)(a3 + 88);
  char v340 = *(_BYTE *)(a3 + 104);
  uint64_t v20 = *(void *)(a3 + 120);
  *(void *)&__int128 v341 = *(void *)(a3 + 112);
  *((void *)&v341 + 1) = v20;
  if (v20)
  {
    __int128 v21 = (unint64_t *)(v20 + 8);
    do
      unint64_t v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }

  __int128 v342 = *(_OWORD *)(a3 + 128);
  unint64_t v343 = *v249;
  char v344 = *(_BYTE *)(a3 + 152);
  uint64_t v23 = (std::__shared_weak_count *)a4[1];
  uint64_t v321 = *a4;
  v322 = v23;
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v25 = __ldxr(p_shared_owners);
    while (__stxr(v25 + 1, p_shared_owners));
  }

  v323[0] = *((_OWORD *)a4 + 1);
  *(_OWORD *)((char *)v323 + 9) = *(_OWORD *)((char *)a4 + 25);
  uint64_t v324 = a4[6];
  __int128 v26 = *(_OWORD *)(a4 + 9);
  __int128 v325 = *(_OWORD *)(a4 + 7);
  __int128 v326 = v26;
  __int128 v327 = *(_OWORD *)(a4 + 11);
  char v328 = *((_BYTE *)a4 + 104);
  uint64_t v27 = (std::__shared_weak_count *)a4[15];
  uint64_t v329 = a4[14];
  v330 = v27;
  if (v27)
  {
    unint64_t v28 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }

  uint64_t v31 = a4[18];
  unint64_t v30 = a4 + 18;
  __int128 v331 = *((_OWORD *)v30 - 1);
  uint64_t v332 = v31;
  char v333 = *((_BYTE *)v30 + 8);
  unint64_t v32 = *(void *)(a1 + 40);
  uint64_t v247 = v30;
  unint64_t v33 = *v249;
  uint64_t v34 = *v30 - *v249;
  unint64_t v35 = v34 & ~(v34 >> 63);
  if (v35 <= v32) {
    unint64_t v35 = *(void *)(a1 + 40);
  }
  if (v34 <= 0) {
    unint64_t v36 = 0LL;
  }
  else {
    unint64_t v36 = v35;
  }
  *(void *)&__int128 v319 = v33 / v32;
  *((void *)&v319 + 1) = (v32 + v33 + v36 - 1) / v32;
  LOBYTE(v320) = 2;
  DiskImageStackable::get_di_extents_for_io(a1, a2, a5, (uint64_t)&v319, (uint64_t)v363);
  unint64_t v37 = operator new(0x20uLL);
  __int128 v280 = (char *)(v37 + 4);
  *(_OWORD *)unint64_t v37 = v319;
  v37[2] = v320;
  *((_DWORD *)v37 + 6) = 1;
  __p = v37;
  uint64_t v279 = (std::__shared_weak_count *)(v37 + 4);
  DiskImage::extents_t_transformer::make_transformed_extents( (DiskImage::extents_t *)v363,  (uint64_t)&__p,  (uint64_t)&v347);
  DiskImage::extents_t::operator=((uint64_t)v363, (uint64_t)&v347);
  uint64_t v38 = (__int128 *)*((void *)&v351 + 1);
  if (*((__int128 **)&v351 + 1) == &v350)
  {
    uint64_t v39 = 4LL;
    uint64_t v38 = &v350;
    goto LABEL_26;
  }

  if (*((void *)&v351 + 1))
  {
    uint64_t v39 = 5LL;
LABEL_26:
    (*(void (**)(void))(*(void *)v38 + 8 * v39))();
  }

  uint64_t v40 = *(void *)&v348[16];
  *(void *)&v348[16] = 0LL;
  if (v40) {
    (*(void (**)(uint64_t))(*(void *)v40 + 40LL))(v40);
  }
  if (__p)
  {
    uint64_t v279 = (std::__shared_weak_count *)__p;
    operator delete(__p);
  }

LABEL_31:
  DiskImage::extents_t::begin((DiskImage::extents_t *)v363, (uint64_t)&v315);
  v255 = a8;
  DiskImage::extents_t::end((DiskImage::extents_t *)v363, (uint64_t)v314);
  unint64_t v254 = 0LL;
  unint64_t v248 = a5 + 1;
  uint64_t v250 = v12;
  unint64_t v251 = a5;
  while (1)
  {
    if (!DiskImage::const_extents_iterator_t::operator!=((uint64_t)&v315, (uint64_t)v314))
    {
      int v123 = 2;
LABEL_267:
      __int128 v184 = v255;
      goto LABEL_268;
    }

    unint64_t v41 = v316;
    uint64_t v42 = v317;
    unsigned int v43 = v318;
    unint64_t v44 = v343;
    unint64_t v45 = v12[5];
    unint64_t v46 = v343 / v45;
    if ((v318 & 2) != 0) {
      unint64_t v47 = v316;
    }
    else {
      unint64_t v47 = v316 + 1;
    }
    unint64_t v311 = v343 / v45;
    unint64_t v312 = v47;
    unsigned __int8 v313 = 2;
    BOOL v48 = v47 >= v46;
    uint64_t v49 = v47 - v46;
    if (v49 == 0 || !v48) {
      uint64_t v49 = boost::icl::identity_element<unsigned long long>::value(void)::_value;
    }
    if (v49) {
      break;
    }
LABEL_150:
    uint64_t v115 = (v43 & 1) + v42 - v41 + (int)(((v43 >> 1) & 1) - 1);
    unint64_t v116 = v45 * v115 - v17;
    if (v332 - v44 < v116) {
      unint64_t v116 = v332 - v44;
    }
    if ((void)v326 - (void)v338 < v116)
    {
      int v123 = 4;
      goto LABEL_267;
    }

    *(void *)&__int128 v347 = v45 * v47;
    *((void *)&v347 + 1) = v45 * (v115 + v47);
    v348[0] = 2;
    sg_vec_ns::details::sg_vec_iterator::subvec( (sg_vec_ns::details::sg_vec_iterator *)&v334,  (uint64_t)&v347,  (uint64_t)&v321,  (uint64_t)&__p);
    unint64_t v345 = -78LL;
    uint64_t v117 = a2;
    if (((uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 4) - 1 != v251 || *(_BYTE *)(a2 + 56) == 0 || a7)
    {
LABEL_157:
      uint64_t v120 = DiskImage::Context::read( *(DiskImage::Context **)(*(void *)(v117 + 16) + 16 * v251),  (const sg_vec_ns::details::sg_vec_iterator *)&__p,  (const sg_vec_ns::details::sg_vec_iterator *)&v284);
      uint64_t v122 = v121;
      unint64_t v345 = v120;
      uint64_t v346 = v121;
      goto LABEL_158;
    }

    (*(void (**)(__int128 *__return_ptr))(**(void **)(v12[2] + 48 * v251 + 24) + 72LL))(&v347);
    if ((void)v347)
    {
      unint64_t v118 = v347 + ((v288 - v283) & ~((uint64_t)(v288 - v283) >> 63)) - 1;
      unint64_t v119 = 1
           - (v347
            + ((v288 - v283) & ~((uint64_t)(v288 - v283) >> 63)))
           + v118 / (unint64_t)v347 * v347
           + *((void *)&v347 + 1) * v347
           + v118;
      uint64_t v117 = a2;
      if (v286 - v281 < v119) {
        goto LABEL_157;
      }
    }

    else
    {
      uint64_t v117 = a2;
      if ((a6 & 1) == 0) {
        goto LABEL_157;
      }
    }

    unint64_t v182 = DiskImage::Context::read( *(DiskImage::Context **)(*(void *)(*(void *)(v117 + 16) + 16 * v251) + 16LL),  (const sg_vec_ns::details::sg_vec_iterator *)&__p,  (const sg_vec_ns::details::sg_vec_iterator *)&v284);
    uint64_t v120 = v182;
    uint64_t v122 = v183;
    unint64_t v345 = v182;
    uint64_t v346 = v183;
    a7 = v183 < v283 || v182 > ((*v247 - *v249) & ~((uint64_t)(*v247 - *v249) >> 63));
LABEL_158:
    if (v120 < 0 && (_DWORD)v120)
    {
      int v123 = 1;
    }

    else
    {
      unint64_t v124 = v283;
      uint64_t v125 = v288;
      if ((a6 & 1) != 0)
      {
        if (a7)
        {
          uint64_t v126 = *v247 - *v249;
          if (v126 <= v120) {
            uint64_t v126 = v120;
          }
          __int128 v267 = v334;
          if (*((void *)&v334 + 1))
          {
            unint64_t v127 = (unint64_t *)(*((void *)&v334 + 1) + 8LL);
            do
              unint64_t v128 = __ldxr(v127);
            while (__stxr(v128 + 1, v127));
          }

          v268[0] = v335[0];
          *(_OWORD *)((char *)v268 + 9) = *(_OWORD *)((char *)v335 + 9);
          uint64_t v269 = v336;
          __int128 v270 = v337;
          __int128 v271 = v338;
          __int128 v272 = v339;
          char v273 = v340;
          __int128 v274 = v341;
          if (*((void *)&v341 + 1))
          {
            unint64_t v129 = (unint64_t *)(*((void *)&v341 + 1) + 8LL);
            do
              unint64_t v130 = __ldxr(v129);
            while (__stxr(v130 + 1, v129));
          }

          __int128 v275 = v342;
          unint64_t v276 = v343;
          char v277 = v344;
          sg_vec_ns::generate_vec_ref( (uint64_t *)&v267,  (uint64_t)&v321,  v126 & ~(v126 >> 63),  v122,  0xFFFFFFFFFFFFFFFFLL,  (sg_vec_ref *)&v347);
          std::__optional_destruct_base<sg_vec_ref,false>::reset[abi:ne180100]((uint64_t)v255);
          sg_vec_ref::sg_vec_ref(v255, (uint64_t)&v347);
          *((_BYTE *)v255 + 528) = 1;
          uint64_t v131 = v362;
          if (v362)
          {
            unint64_t v132 = (unint64_t *)&v362->__shared_owners_;
            do
              unint64_t v133 = __ldaxr(v132);
            while (__stlxr(v133 - 1, v132));
            if (!v133)
            {
              ((void (*)(std::__shared_weak_count *))v131->__on_zero_shared)(v131);
              std::__shared_weak_count::__release_weak(v131);
            }
          }

          unint64_t v134 = v361;
          if (v361)
          {
            uint64_t v135 = (unint64_t *)&v361->__shared_owners_;
            do
              unint64_t v136 = __ldaxr(v135);
            while (__stlxr(v136 - 1, v135));
            if (!v136)
            {
              ((void (*)(std::__shared_weak_count *))v134->__on_zero_shared)(v134);
              std::__shared_weak_count::__release_weak(v134);
            }
          }

          __int128 v137 = v360;
          if (v360)
          {
            unint64_t v138 = (unint64_t *)&v360->__shared_owners_;
            do
              unint64_t v139 = __ldaxr(v138);
            while (__stlxr(v139 - 1, v138));
            if (!v139)
            {
              ((void (*)(std::__shared_weak_count *))v137->__on_zero_shared)(v137);
              std::__shared_weak_count::__release_weak(v137);
            }
          }

          uint64_t v140 = v359;
          if (v359)
          {
            unint64_t v141 = (unint64_t *)&v359->__shared_owners_;
            do
              unint64_t v142 = __ldaxr(v141);
            while (__stlxr(v142 - 1, v141));
            if (!v142)
            {
              ((void (*)(std::__shared_weak_count *))v140->__on_zero_shared)(v140);
              std::__shared_weak_count::__release_weak(v140);
            }
          }

          uint64_t v143 = v358;
          if (v358)
          {
            unint64_t v144 = (unint64_t *)&v358->__shared_owners_;
            do
              unint64_t v145 = __ldaxr(v144);
            while (__stlxr(v145 - 1, v144));
            if (!v145)
            {
              ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
              std::__shared_weak_count::__release_weak(v143);
            }
          }

          __int128 v146 = (std::__shared_weak_count *)v351;
          if ((void)v351)
          {
            unint64_t v147 = (unint64_t *)(v351 + 8);
            do
              unint64_t v148 = __ldaxr(v147);
            while (__stlxr(v148 - 1, v147));
            if (!v148)
            {
              ((void (*)(std::__shared_weak_count *))v146->__on_zero_shared)(v146);
              std::__shared_weak_count::__release_weak(v146);
            }
          }

          unint64_t v149 = (std::__shared_weak_count *)*((void *)&v274 + 1);
          if (*((void *)&v274 + 1))
          {
            unint64_t v150 = (unint64_t *)(*((void *)&v274 + 1) + 8LL);
            do
              unint64_t v151 = __ldaxr(v150);
            while (__stlxr(v151 - 1, v150));
            if (!v151)
            {
              ((void (*)(std::__shared_weak_count *))v149->__on_zero_shared)(v149);
              std::__shared_weak_count::__release_weak(v149);
            }
          }

          char v152 = (std::__shared_weak_count *)*((void *)&v267 + 1);
          if (*((void *)&v267 + 1))
          {
            unint64_t v153 = (unint64_t *)(*((void *)&v267 + 1) + 8LL);
            do
              unint64_t v154 = __ldaxr(v153);
            while (__stlxr(v154 - 1, v153));
            if (!v154)
            {
              ((void (*)(std::__shared_weak_count *))v152->__on_zero_shared)(v152);
              std::__shared_weak_count::__release_weak(v152);
            }
          }

          sg_vec_ref::begin(v255, (uint64_t)&v347);
          sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v334, (uint64_t)&v347);
          __int128 v155 = (std::__shared_weak_count *)*((void *)&v354 + 1);
          if (*((void *)&v354 + 1))
          {
            __int128 v156 = (unint64_t *)(*((void *)&v354 + 1) + 8LL);
            do
              unint64_t v157 = __ldaxr(v156);
            while (__stlxr(v157 - 1, v156));
            if (!v157)
            {
              ((void (*)(std::__shared_weak_count *))v155->__on_zero_shared)(v155);
              std::__shared_weak_count::__release_weak(v155);
            }
          }

          unint64_t v158 = (std::__shared_weak_count *)*((void *)&v347 + 1);
          if (*((void *)&v347 + 1))
          {
            uint64_t v159 = (unint64_t *)(*((void *)&v347 + 1) + 8LL);
            do
              unint64_t v160 = __ldaxr(v159);
            while (__stlxr(v160 - 1, v159));
            if (!v160)
            {
              ((void (*)(std::__shared_weak_count *))v158->__on_zero_shared)(v158);
              std::__shared_weak_count::__release_weak(v158);
            }
          }

          sg_vec_ref::end(v255, (uint64_t)&v347);
          sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v321, (uint64_t)&v347);
          __int128 v161 = (std::__shared_weak_count *)*((void *)&v354 + 1);
          if (*((void *)&v354 + 1))
          {
            uint64_t v162 = (unint64_t *)(*((void *)&v354 + 1) + 8LL);
            do
              unint64_t v163 = __ldaxr(v162);
            while (__stlxr(v163 - 1, v162));
            if (!v163)
            {
              ((void (*)(std::__shared_weak_count *))v161->__on_zero_shared)(v161);
              std::__shared_weak_count::__release_weak(v161);
            }
          }

          uint64_t v164 = (std::__shared_weak_count *)*((void *)&v347 + 1);
          if (*((void *)&v347 + 1))
          {
            unint64_t v165 = (unint64_t *)(*((void *)&v347 + 1) + 8LL);
            do
              unint64_t v166 = __ldaxr(v165);
            while (__stlxr(v166 - 1, v165));
            if (!v166)
            {
              ((void (*)(std::__shared_weak_count *))v164->__on_zero_shared)(v164);
              std::__shared_weak_count::__release_weak(v164);
            }
          }

          a7 = 1;
          unint64_t v167 = v345;
        }

        else
        {
          a7 = 0;
          unint64_t v167 = v120;
        }

        unint64_t v252 = v122;
      }

      else if (v122 == v343)
      {
        unint64_t v167 = v120;
      }

      else
      {
        unint64_t v167 = trim_data((uint64_t)&v334, (uint64_t)&v321, v12[5] * v115, &v345);
        unint64_t v345 = v167;
        uint64_t v346 = v168;
        a7 = v167 != v12[5] * v115;
      }

      uint64_t v169 = v125;
      sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v334, v167);
      uint64_t v17 = 0LL;
      a6 = 0;
      v254 += v345;
      int v123 = 4 * (v122 + v120 < ((v169 - v124) & ~((uint64_t)(v169 - v124) >> 63)) + v124);
    }

    __int128 v170 = v287;
    if (v287)
    {
      __int128 v171 = (unint64_t *)&v287->__shared_owners_;
      do
        unint64_t v172 = __ldaxr(v171);
      while (__stlxr(v172 - 1, v171));
      if (!v172)
      {
        ((void (*)(std::__shared_weak_count *))v170->__on_zero_shared)(v170);
        std::__shared_weak_count::__release_weak(v170);
      }
    }

    uint64_t v173 = v285;
    if (v285)
    {
      char v174 = (unint64_t *)&v285->__shared_owners_;
      do
        unint64_t v175 = __ldaxr(v174);
      while (__stlxr(v175 - 1, v174));
      if (!v175)
      {
        ((void (*)(std::__shared_weak_count *))v173->__on_zero_shared)(v173);
        std::__shared_weak_count::__release_weak(v173);
      }
    }

    uint64_t v176 = v282;
    if (v282)
    {
      char v177 = (unint64_t *)&v282->__shared_owners_;
      do
        unint64_t v178 = __ldaxr(v177);
      while (__stlxr(v178 - 1, v177));
      if (!v178)
      {
        ((void (*)(std::__shared_weak_count *))v176->__on_zero_shared)(v176);
        std::__shared_weak_count::__release_weak(v176);
      }
    }

    char v179 = v279;
    if (v279)
    {
      __n128 v180 = (unint64_t *)&v279->__shared_owners_;
      do
        unint64_t v181 = __ldaxr(v180);
      while (__stlxr(v181 - 1, v180));
      if (!v181)
      {
        ((void (*)(std::__shared_weak_count *))v179->__on_zero_shared)(v179);
        std::__shared_weak_count::__release_weak(v179);
      }
    }

    if (v123) {
      goto LABEL_267;
    }
    DiskImage::const_extents_iterator_t::operator++((DiskImage::const_extents_iterator_t *)&v315);
  }

  unint64_t v50 = DiskImageStackable::read_from_next( (uint64_t)v12,  (DiskImageStackable::ContextStackable *)a2,  (sg_vec_ns::details::sg_vec_iterator *)&v334,  (uint64_t)&v321,  v248,  (uint64_t *)&v311,  a6 & 1,  a7,  (uint64_t)v255,  (DiskImage::extents_t *)v363);
  unint64_t v345 = v50;
  uint64_t v346 = v51;
  if ((v50 & 0x8000000000000000LL) != 0 && (_DWORD)v50)
  {
    int v123 = 1;
    goto LABEL_267;
  }

  unint64_t v52 = v252;
  if (v51 < v44) {
    unint64_t v52 = v51;
  }
  unint64_t v252 = v52;
  unint64_t v53 = v343;
  if (v51 >= v343)
  {
    BOOL v54 = v51 + v50 > v12[5] * (v47 - 1);
    unint64_t v55 = v255;
    if (v50 <= ((*v247 - *v249) & ~((uint64_t)(*v247 - *v249) >> 63)))
    {
      a7 = 0;
      goto LABEL_114;
    }
  }

  else
  {
    BOOL v54 = v51 + v50 > v12[5] * (v47 - 1);
    unint64_t v55 = v255;
  }

  __int128 v300 = v334;
  if (*((void *)&v334 + 1))
  {
    uint64_t v56 = (unint64_t *)(*((void *)&v334 + 1) + 8LL);
    do
      unint64_t v57 = __ldxr(v56);
    while (__stxr(v57 + 1, v56));
  }

  v301[0] = v335[0];
  *(_OWORD *)((char *)v301 + 9) = *(_OWORD *)((char *)v335 + 9);
  __int128 v303 = v337;
  __int128 v304 = v338;
  __int128 v305 = v339;
  char v306 = v340;
  uint64_t v302 = v336;
  __int128 v307 = v341;
  if (*((void *)&v341 + 1))
  {
    unint64_t v58 = (unint64_t *)(*((void *)&v341 + 1) + 8LL);
    do
      unint64_t v59 = __ldxr(v58);
    while (__stxr(v59 + 1, v58));
  }

  __int128 v308 = v342;
  unint64_t v309 = v343;
  char v310 = v344;
  sg_vec_ns::generate_vec_ref((uint64_t *)&v300, (uint64_t)&v321, v50, v346, 0xFFFFFFFFFFFFFFFFLL, (sg_vec_ref *)&v347);
  std::__optional_destruct_base<sg_vec_ref,false>::reset[abi:ne180100]((uint64_t)v55);
  sg_vec_ref::sg_vec_ref(v55, (uint64_t)&v347);
  *((_BYTE *)v55 + 528) = 1;
  uint64_t v60 = v362;
  if (v362)
  {
    unint64_t v61 = (unint64_t *)&v362->__shared_owners_;
    do
      unint64_t v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
    }
  }

  int v63 = v361;
  if (v361)
  {
    uint64_t v64 = (unint64_t *)&v361->__shared_owners_;
    do
      unint64_t v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }

  uint64_t v66 = v360;
  if (v360)
  {
    uint64_t v67 = (unint64_t *)&v360->__shared_owners_;
    do
      unint64_t v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }

  __int128 v69 = v359;
  if (v359)
  {
    unint64_t v70 = (unint64_t *)&v359->__shared_owners_;
    do
      unint64_t v71 = __ldaxr(v70);
    while (__stlxr(v71 - 1, v70));
    if (!v71)
    {
      ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
      std::__shared_weak_count::__release_weak(v69);
    }
  }

  unint64_t v72 = v358;
  if (v358)
  {
    uint64_t v73 = (unint64_t *)&v358->__shared_owners_;
    do
      unint64_t v74 = __ldaxr(v73);
    while (__stlxr(v74 - 1, v73));
    if (!v74)
    {
      ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
      std::__shared_weak_count::__release_weak(v72);
    }
  }

  unint64_t v75 = (std::__shared_weak_count *)v351;
  if ((void)v351)
  {
    unint64_t v76 = (unint64_t *)(v351 + 8);
    do
      unint64_t v77 = __ldaxr(v76);
    while (__stlxr(v77 - 1, v76));
    if (!v77)
    {
      ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
      std::__shared_weak_count::__release_weak(v75);
    }
  }

  unint64_t v78 = (std::__shared_weak_count *)*((void *)&v307 + 1);
  if (*((void *)&v307 + 1))
  {
    uint64_t v79 = (unint64_t *)(*((void *)&v307 + 1) + 8LL);
    do
      unint64_t v80 = __ldaxr(v79);
    while (__stlxr(v80 - 1, v79));
    if (!v80)
    {
      ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
      std::__shared_weak_count::__release_weak(v78);
    }
  }

  unint64_t v81 = (std::__shared_weak_count *)*((void *)&v300 + 1);
  if (*((void *)&v300 + 1))
  {
    uint64_t v82 = (unint64_t *)(*((void *)&v300 + 1) + 8LL);
    do
      unint64_t v83 = __ldaxr(v82);
    while (__stlxr(v83 - 1, v82));
    if (!v83)
    {
      ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
      std::__shared_weak_count::__release_weak(v81);
    }
  }

  sg_vec_ref::begin(v55, (uint64_t)&v347);
  sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v334, (uint64_t)&v347);
  unint64_t v84 = (std::__shared_weak_count *)*((void *)&v354 + 1);
  if (*((void *)&v354 + 1))
  {
    uint64_t v85 = (unint64_t *)(*((void *)&v354 + 1) + 8LL);
    do
      unint64_t v86 = __ldaxr(v85);
    while (__stlxr(v86 - 1, v85));
    if (!v86)
    {
      ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
      std::__shared_weak_count::__release_weak(v84);
    }
  }

  unint64_t v87 = (std::__shared_weak_count *)*((void *)&v347 + 1);
  if (*((void *)&v347 + 1))
  {
    unint64_t v88 = (unint64_t *)(*((void *)&v347 + 1) + 8LL);
    do
      unint64_t v89 = __ldaxr(v88);
    while (__stlxr(v89 - 1, v88));
    if (!v89)
    {
      ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
      std::__shared_weak_count::__release_weak(v87);
    }
  }

  sg_vec_ref::end(v55, (uint64_t)&v347);
  sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v321, (uint64_t)&v347);
  unint64_t v90 = (std::__shared_weak_count *)*((void *)&v354 + 1);
  if (*((void *)&v354 + 1))
  {
    BOOL v91 = (unint64_t *)(*((void *)&v354 + 1) + 8LL);
    do
      unint64_t v92 = __ldaxr(v91);
    while (__stlxr(v92 - 1, v91));
    if (!v92)
    {
      ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
      std::__shared_weak_count::__release_weak(v90);
    }
  }

  unint64_t v93 = (std::__shared_weak_count *)*((void *)&v347 + 1);
  if (*((void *)&v347 + 1))
  {
    unint64_t v94 = (unint64_t *)(*((void *)&v347 + 1) + 8LL);
    do
      unint64_t v95 = __ldaxr(v94);
    while (__stlxr(v95 - 1, v94));
    if (!v95)
    {
      ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
      std::__shared_weak_count::__release_weak(v93);
    }
  }

  a7 = 1;
  unint64_t v53 = v343;
LABEL_114:
  __int128 v289 = v334;
  if (*((void *)&v334 + 1))
  {
    unint64_t v96 = (unint64_t *)(*((void *)&v334 + 1) + 8LL);
    do
      unint64_t v97 = __ldxr(v96);
    while (__stxr(v97 + 1, v96));
  }

  *(_OWORD *)v290 = v335[0];
  *(_OWORD *)&v290[9] = *(_OWORD *)((char *)v335 + 9);
  __int128 v292 = v337;
  __int128 v293 = v338;
  __int128 v294 = v339;
  char v295 = v340;
  uint64_t v291 = v336;
  __int128 v296 = v341;
  if (*((void *)&v341 + 1))
  {
    unint64_t v98 = (unint64_t *)(*((void *)&v341 + 1) + 8LL);
    do
      unint64_t v99 = __ldxr(v98);
    while (__stxr(v99 + 1, v98));
  }

  __int128 v297 = v342;
  unint64_t v298 = v343;
  char v299 = v344;
  if (a7) {
    uint64_t v100 = 0LL;
  }
  else {
    uint64_t v100 = (v312 - v311 + (v313 & 1) + ((v313 >> 1) & 1) - 1) * v250[5];
  }
  unint64_t v101 = v100 - v346 + *(void *)&v290[8];
  if (v345 < v101) {
    unint64_t v101 = v345;
  }
  if (v100) {
    unint64_t v102 = v101;
  }
  else {
    unint64_t v102 = v345;
  }
  sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v289, v102);
  sg_vec_ns::details::buffer_iterator::rtrim_written(&v292);
  __int128 v347 = v289;
  __int128 v289 = 0uLL;
  *(_OWORD *)v348 = *(_OWORD *)v290;
  *(_OWORD *)&v348[9] = *(_OWORD *)&v290[9];
  uint64_t v349 = v291;
  __int128 v350 = v292;
  __int128 v351 = v293;
  __int128 v352 = v294;
  char v353 = v295;
  __int128 v354 = v296;
  __int128 v296 = 0uLL;
  __int128 v355 = v297;
  char v357 = v299;
  unint64_t v356 = v298;
  sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v334, (uint64_t)&v347);
  unint64_t v103 = (std::__shared_weak_count *)*((void *)&v354 + 1);
  if (*((void *)&v354 + 1))
  {
    char v104 = (unint64_t *)(*((void *)&v354 + 1) + 8LL);
    do
      unint64_t v105 = __ldaxr(v104);
    while (__stlxr(v105 - 1, v104));
    if (!v105)
    {
      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
      std::__shared_weak_count::__release_weak(v103);
    }
  }

  unint64_t v106 = (std::__shared_weak_count *)*((void *)&v347 + 1);
  if (*((void *)&v347 + 1))
  {
    __int128 v107 = (unint64_t *)(*((void *)&v347 + 1) + 8LL);
    do
      unint64_t v108 = __ldaxr(v107);
    while (__stlxr(v108 - 1, v107));
    if (!v108)
    {
      ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
      std::__shared_weak_count::__release_weak(v106);
    }
  }

  unint64_t v109 = (std::__shared_weak_count *)*((void *)&v296 + 1);
  if (*((void *)&v296 + 1))
  {
    uint64_t v110 = (unint64_t *)(*((void *)&v296 + 1) + 8LL);
    do
      unint64_t v111 = __ldaxr(v110);
    while (__stlxr(v111 - 1, v110));
    if (!v111)
    {
      ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
      std::__shared_weak_count::__release_weak(v109);
    }
  }

  unint64_t v112 = (std::__shared_weak_count *)*((void *)&v289 + 1);
  if (*((void *)&v289 + 1))
  {
    uint64_t v113 = (unint64_t *)(*((void *)&v289 + 1) + 8LL);
    do
      unint64_t v114 = __ldaxr(v113);
    while (__stlxr(v114 - 1, v113));
    if (!v114)
    {
      ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
      std::__shared_weak_count::__release_weak(v112);
    }
  }

  unint64_t v44 = v343;
  v254 += v343 - v53;
  if (v54)
  {
    uint64_t v17 = 0LL;
    a6 = 0;
    uint64_t v12 = v250;
    unint64_t v45 = v250[5];
    goto LABEL_150;
  }

  a6 = 0;
  int v123 = 4;
  __int128 v184 = v255;
  uint64_t v12 = v250;
LABEL_268:
  uint64_t v185 = v314[0];
  v314[0] = 0LL;
  if (v185) {
    (*(void (**)(uint64_t))(*(void *)v185 + 24LL))(v185);
  }
  uint64_t v186 = v315;
  uint64_t v315 = 0LL;
  if (v186) {
    (*(void (**)(uint64_t))(*(void *)v186 + 24LL))(v186);
  }
  if (v123 != 2)
  {
    if (v123 != 4) {
      goto LABEL_350;
    }
LABEL_349:
    unint64_t v345 = v254;
    uint64_t v346 = v252;
    goto LABEL_350;
  }

  if (!DiskImage::extents_t::empty((DiskImage::extents_t *)v363))
  {
    DiskImage::extents_t::back((DiskImage::extents_t *)v363, (uint64_t)&v347);
  }

  unint64_t sg_from_next = DiskImageStackable::read_sg_from_next( (uint64_t)v12,  (DiskImageStackable::ContextStackable *)a2,  (uint64_t)&v334,  (uint64_t)&v321,  v248,  a6 & 1,  a7,  (int)v184,  (DiskImage::extents_t *)v363);
  unint64_t v188 = sg_from_next;
  unint64_t v190 = v189;
  unint64_t v345 = sg_from_next;
  uint64_t v346 = v189;
  if ((sg_from_next & 0x8000000000000000LL) == 0 || !(_DWORD)sg_from_next)
  {
    if ((a6 & 1) != 0)
    {
      __int128 v256 = v334;
      if (*((void *)&v334 + 1))
      {
        __int128 v191 = (unint64_t *)(*((void *)&v334 + 1) + 8LL);
        do
          unint64_t v192 = __ldxr(v191);
        while (__stxr(v192 + 1, v191));
      }

      v257[0] = v335[0];
      *(_OWORD *)((char *)v257 + 9) = *(_OWORD *)((char *)v335 + 9);
      __int128 v259 = v337;
      __int128 v260 = v338;
      uint64_t v258 = v336;
      __int128 v261 = v339;
      char v262 = v340;
      __int128 v263 = v341;
      if (*((void *)&v341 + 1))
      {
        __int128 v193 = (unint64_t *)(*((void *)&v341 + 1) + 8LL);
        do
          unint64_t v194 = __ldxr(v193);
        while (__stxr(v194 + 1, v193));
      }

      __int128 v264 = v342;
      unint64_t v265 = v343;
      char v266 = v344;
      sg_vec_ns::generate_vec_ref( (uint64_t *)&v256,  (uint64_t)&v321,  sg_from_next,  v346,  0xFFFFFFFFFFFFFFFFLL,  (sg_vec_ref *)&v347);
      std::__optional_destruct_base<sg_vec_ref,false>::reset[abi:ne180100]((uint64_t)v184);
      sg_vec_ref::sg_vec_ref(v184, (uint64_t)&v347);
      *((_BYTE *)v184 + 528) = 1;
      __int128 v195 = v362;
      if (v362)
      {
        char v196 = (unint64_t *)&v362->__shared_owners_;
        do
          unint64_t v197 = __ldaxr(v196);
        while (__stlxr(v197 - 1, v196));
        if (!v197)
        {
          ((void (*)(std::__shared_weak_count *))v195->__on_zero_shared)(v195);
          std::__shared_weak_count::__release_weak(v195);
        }
      }

      unint64_t v198 = v361;
      if (v361)
      {
        __int128 v199 = (unint64_t *)&v361->__shared_owners_;
        do
          unint64_t v200 = __ldaxr(v199);
        while (__stlxr(v200 - 1, v199));
        if (!v200)
        {
          ((void (*)(std::__shared_weak_count *))v198->__on_zero_shared)(v198);
          std::__shared_weak_count::__release_weak(v198);
        }
      }

      char v201 = v360;
      if (v360)
      {
        uint64_t v202 = (unint64_t *)&v360->__shared_owners_;
        do
          unint64_t v203 = __ldaxr(v202);
        while (__stlxr(v203 - 1, v202));
        if (!v203)
        {
          ((void (*)(std::__shared_weak_count *))v201->__on_zero_shared)(v201);
          std::__shared_weak_count::__release_weak(v201);
        }
      }

      __int128 v204 = v359;
      if (v359)
      {
        __int128 v205 = (unint64_t *)&v359->__shared_owners_;
        do
          unint64_t v206 = __ldaxr(v205);
        while (__stlxr(v206 - 1, v205));
        if (!v206)
        {
          ((void (*)(std::__shared_weak_count *))v204->__on_zero_shared)(v204);
          std::__shared_weak_count::__release_weak(v204);
        }
      }

      uint64_t v207 = v358;
      if (v358)
      {
        __int128 v208 = (unint64_t *)&v358->__shared_owners_;
        do
          unint64_t v209 = __ldaxr(v208);
        while (__stlxr(v209 - 1, v208));
        if (!v209)
        {
          ((void (*)(std::__shared_weak_count *))v207->__on_zero_shared)(v207);
          std::__shared_weak_count::__release_weak(v207);
        }
      }

      char v210 = (std::__shared_weak_count *)v351;
      if ((void)v351)
      {
        __int128 v211 = (unint64_t *)(v351 + 8);
        do
          unint64_t v212 = __ldaxr(v211);
        while (__stlxr(v212 - 1, v211));
        if (!v212)
        {
          ((void (*)(std::__shared_weak_count *))v210->__on_zero_shared)(v210);
          std::__shared_weak_count::__release_weak(v210);
        }
      }

      uint64_t v213 = (std::__shared_weak_count *)*((void *)&v263 + 1);
      if (*((void *)&v263 + 1))
      {
        __int128 v214 = (unint64_t *)(*((void *)&v263 + 1) + 8LL);
        do
          unint64_t v215 = __ldaxr(v214);
        while (__stlxr(v215 - 1, v214));
        if (!v215)
        {
          ((void (*)(std::__shared_weak_count *))v213->__on_zero_shared)(v213);
          std::__shared_weak_count::__release_weak(v213);
        }
      }

      __int128 v216 = (std::__shared_weak_count *)*((void *)&v256 + 1);
      if (*((void *)&v256 + 1))
      {
        char v217 = (unint64_t *)(*((void *)&v256 + 1) + 8LL);
        do
          unint64_t v218 = __ldaxr(v217);
        while (__stlxr(v218 - 1, v217));
        if (!v218)
        {
          ((void (*)(std::__shared_weak_count *))v216->__on_zero_shared)(v216);
          std::__shared_weak_count::__release_weak(v216);
        }
      }

      sg_vec_ref::begin(v184, (uint64_t)&v347);
      sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v334, (uint64_t)&v347);
      uint64_t v219 = (std::__shared_weak_count *)*((void *)&v354 + 1);
      if (*((void *)&v354 + 1))
      {
        __int128 v220 = (unint64_t *)(*((void *)&v354 + 1) + 8LL);
        do
          unint64_t v221 = __ldaxr(v220);
        while (__stlxr(v221 - 1, v220));
        if (!v221)
        {
          ((void (*)(std::__shared_weak_count *))v219->__on_zero_shared)(v219);
          std::__shared_weak_count::__release_weak(v219);
        }
      }

      char v222 = (std::__shared_weak_count *)*((void *)&v347 + 1);
      if (*((void *)&v347 + 1))
      {
        uint64_t v223 = (unint64_t *)(*((void *)&v347 + 1) + 8LL);
        do
          unint64_t v224 = __ldaxr(v223);
        while (__stlxr(v224 - 1, v223));
        if (!v224)
        {
          ((void (*)(std::__shared_weak_count *))v222->__on_zero_shared)(v222);
          std::__shared_weak_count::__release_weak(v222);
        }
      }

      sg_vec_ref::end(v184, (uint64_t)&v347);
      sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v321, (uint64_t)&v347);
      __int128 v225 = (std::__shared_weak_count *)*((void *)&v354 + 1);
      if (*((void *)&v354 + 1))
      {
        unint64_t v226 = (unint64_t *)(*((void *)&v354 + 1) + 8LL);
        do
          unint64_t v227 = __ldaxr(v226);
        while (__stlxr(v227 - 1, v226));
        if (!v227)
        {
          ((void (*)(std::__shared_weak_count *))v225->__on_zero_shared)(v225);
          std::__shared_weak_count::__release_weak(v225);
        }
      }

      uint64_t v228 = (std::__shared_weak_count *)*((void *)&v347 + 1);
      if (*((void *)&v347 + 1))
      {
        __int128 v229 = (unint64_t *)(*((void *)&v347 + 1) + 8LL);
        do
          unint64_t v230 = __ldaxr(v229);
        while (__stlxr(v230 - 1, v229));
        if (!v230)
        {
          ((void (*)(std::__shared_weak_count *))v228->__on_zero_shared)(v228);
          std::__shared_weak_count::__release_weak(v228);
        }
      }

      unint64_t v188 = v345;
      unint64_t v252 = v190;
    }

    sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v334, v188);
    v254 += v345;
    goto LABEL_349;
  }

LABEL_350:
  uint64_t v231 = v366;
  if (v366 == v365)
  {
    uint64_t v232 = 4LL;
    uint64_t v231 = v365;
LABEL_354:
    (*(void (**)(void))(*v231 + 8 * v232))();
  }

  else if (v366)
  {
    uint64_t v232 = 5LL;
    goto LABEL_354;
  }

  uint64_t v233 = v364;
  uint64_t v364 = 0LL;
  if (v233) {
    (*(void (**)(uint64_t))(*(void *)v233 + 40LL))(v233);
  }
  __int128 v234 = v330;
  if (v330)
  {
    __int128 v235 = (unint64_t *)&v330->__shared_owners_;
    do
      unint64_t v236 = __ldaxr(v235);
    while (__stlxr(v236 - 1, v235));
    if (!v236)
    {
      ((void (*)(std::__shared_weak_count *))v234->__on_zero_shared)(v234);
      std::__shared_weak_count::__release_weak(v234);
    }
  }

  uint64_t v237 = v322;
  if (v322)
  {
    v238 = (unint64_t *)&v322->__shared_owners_;
    do
      unint64_t v239 = __ldaxr(v238);
    while (__stlxr(v239 - 1, v238));
    if (!v239)
    {
      ((void (*)(std::__shared_weak_count *))v237->__on_zero_shared)(v237);
      std::__shared_weak_count::__release_weak(v237);
    }
  }

  unint64_t v240 = (std::__shared_weak_count *)*((void *)&v341 + 1);
  if (*((void *)&v341 + 1))
  {
    char v241 = (unint64_t *)(*((void *)&v341 + 1) + 8LL);
    do
      unint64_t v242 = __ldaxr(v241);
    while (__stlxr(v242 - 1, v241));
    if (!v242)
    {
      ((void (*)(std::__shared_weak_count *))v240->__on_zero_shared)(v240);
      std::__shared_weak_count::__release_weak(v240);
    }
  }

  v243 = (std::__shared_weak_count *)*((void *)&v334 + 1);
  if (*((void *)&v334 + 1))
  {
    char v244 = (unint64_t *)(*((void *)&v334 + 1) + 8LL);
    do
      unint64_t v245 = __ldaxr(v244);
    while (__stlxr(v245 - 1, v244));
    if (!v245)
    {
      ((void (*)(std::__shared_weak_count *))v243->__on_zero_shared)(v243);
      std::__shared_weak_count::__release_weak(v243);
    }
  }

  return v345;
}

void sub_188116CAC(_Unwind_Exception *a1)
{
  unint64_t v3 = *(void **)(v1 - 112);
  if (v3 == (void *)(v1 - 136))
  {
    uint64_t v4 = 4LL;
    unint64_t v3 = (void *)(v1 - 136);
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  uint64_t v5 = *(void *)(v1 - 160);
  *(void *)(v1 - 160) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 40LL))(v5);
  }
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x5E0]);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x570]);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x680]);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x610]);
  _Unwind_Resume(a1);
}

void sg_vec_ns::generate_vec_ref( uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, sg_vec_ref *a6@<X8>)
{
  unint64_t v6 = (std::__shared_weak_count *)a1[1];
  uint64_t v18 = *a1;
  unint64_t v19 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  v20[0] = *((_OWORD *)a1 + 1);
  *(_OWORD *)((char *)v20 + 9) = *(_OWORD *)((char *)a1 + 25);
  uint64_t v21 = a1[6];
  __int128 v22 = *(_OWORD *)(a1 + 7);
  __int128 v23 = *(_OWORD *)(a1 + 9);
  __int128 v24 = *(_OWORD *)(a1 + 11);
  char v25 = *((_BYTE *)a1 + 104);
  BOOL v9 = (std::__shared_weak_count *)a1[15];
  uint64_t v26 = a1[14];
  uint64_t v27 = v9;
  if (v9)
  {
    unint64_t v10 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  __int128 v28 = *((_OWORD *)a1 + 8);
  uint64_t v29 = a1[18];
  char v30 = *((_BYTE *)a1 + 152);
  sg_vec_ns::generate_vec_ref((uint64_t)&v18, a2, a4, a3, a5, a6);
  uint64_t v12 = v27;
  if (v27)
  {
    unint64_t v13 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  uint64_t v15 = v19;
  if (v19)
  {
    uint64_t v16 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_188116FF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL DiskImage::extents_t::empty(DiskImage::extents_t *this)
{
  BOOL v2 = DiskImage::const_extents_iterator_t::operator==((uint64_t)v7, (uint64_t)v6);
  uint64_t v3 = v6[0];
  v6[0] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  uint64_t v4 = v7[0];
  v7[0] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  }
  return v2;
}

void sub_188117090( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 24LL))(a9);
  }
  if (a15) {
    (*(void (**)(uint64_t))(*(void *)a15 + 24LL))(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t DiskImageStackable::verify_image(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  if (v3 == v4) {
    return 1LL;
  }
  uint64_t v7 = v3 + 48;
  do
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v7 - 40) + 56LL))( *(void *)(v7 - 40),  a2,  a3);
    if ((_DWORD)result) {
      BOOL v9 = v7 == v4;
    }
    else {
      BOOL v9 = 1;
    }
    v7 += 48LL;
  }

  while (!v9);
  return result;
}

uint64_t DiskImageStackable::unmap(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (*(_DWORD *)v2
    || !(*(unsigned int (**)(void))(**(void **)(v2 + 8) + 80LL))(*(void *)(v2 + 8))
    || **(_DWORD **)(a1 + 16))
  {
    return 0LL;
  }

  else
  {
    return DiskImage::Context::unmap(**(void ***)(a2 + 16));
  }

void *DiskImageStackable::cacheFlusher_t::cacheFlusher_t(void *a1, uint64_t a2, uint64_t a3)
{
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  workqueue::workqueue::create_recurrent_block(a1, a2, a3, (uint64_t)(a1 + 8));
  return a1;
}

void sub_188117238( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void *DiskImageStackable::stackable_extents_iterator_interface::make_val@<X0>( DiskImageStackable::stackable_extents_iterator_interface *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *((void *)this + 3);
  v4[0] = *((void *)this + 5);
  v4[1] = v2;
  char v5 = 2;
  return DiskImageStackable::stackable_extents_iterator_interface::get_next_extent_recursive(this, (uint64_t)v4, 0LL, a2);
}

void *DiskImageStackable::stackable_extents_iterator_interface::get_next_extent_recursive@<X0>( void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  uint64_t v6 = result[6];
  uint64_t v7 = *(void *)(v6 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v6 + 24) - v7) >> 4) == a3) {
    goto LABEL_22;
  }
  BOOL v9 = result;
  unsigned int v10 = *(unsigned __int8 *)(a2 + 16);
  if (!*(_BYTE *)(a2 + 16))
  {
    unint64_t v12 = *(void *)a2;
    unint64_t v11 = *(void *)(a2 + 8);
    if (*(void *)a2 >= v11 || *(void *)a2 + 1LL >= v11) {
      goto LABEL_21;
    }
LABEL_5:
LABEL_22:
    *(_OWORD *)a4 = *(_OWORD *)a2;
    *(void *)(a4 + 16) = *(void *)(a2 + 16);
    *(_DWORD *)(a4 + 24) = 0;
    return result;
  }

  if (v10 != 3)
  {
    unint64_t v12 = *(void *)a2;
    unint64_t v11 = *(void *)(a2 + 8);
    if (*(void *)a2 >= v11) {
      goto LABEL_21;
    }
    goto LABEL_5;
  }

  unint64_t v12 = *(void *)a2;
  unint64_t v11 = *(void *)(a2 + 8);
  if (v11 >= *(void *)a2) {
    goto LABEL_5;
  }
LABEL_21:
LABEL_6:
  uint64_t v13 = result[7];
  unint64_t v14 = (*(uint64_t (**)(void))(**(void **)(v7 + 48 * a3 + 8) + 32LL))(*(void *)(v7 + 48 * a3 + 8));
  unint64_t v15 = *(void *)a2;
  unint64_t v16 = *(void *)(a2 + 8);
  if (*(void *)a2 >= v14) {
    unint64_t v17 = v14;
  }
  else {
    unint64_t v17 = *(void *)a2;
  }
  if (v16 >= v14) {
    unint64_t v18 = v14;
  }
  else {
    unint64_t v18 = *(void *)(a2 + 8);
  }
  uint64_t v19 = *(void *)(*(void *)(v13 + 16) + 16 * a3);
  v49[0] = *(void *)(*(void *)(v6 + 16) + 48 * a3 + 8);
  v49[1] = v17;
  void v49[2] = v18;
  char v50 = 2;
  unint64_t v51 = 0LL;
  uint64_t v52 = v19;
  int v53 = 7;
  uint64_t v20 = v54;
  v54[0] = off_18A1D1060;
  unint64_t v55 = v54;
  if (v14 < v16)
  {
    unint64_t v21 = v14;
    __int128 v22 = operator new(0x20uLL);
    uint64_t v42 = v22 + 4;
    unsigned int v43 = (char *)(v22 + 4);
    *__int128 v22 = v21;
    v22[1] = v16;
    *((_BYTE *)v22 + 16) = 2;
    *((_DWORD *)v22 + 6) = 2;
    __p = v22;
    DiskImage::extents_t_transformer::make_transformed_extents((DiskImage::extents_t *)v49, (uint64_t)&__p, (uint64_t)v44);
    DiskImage::extents_t::operator=((uint64_t)v49, (uint64_t)v44);
    __int128 v23 = v48;
    if (v48 == v47)
    {
      uint64_t v24 = 4LL;
      __int128 v23 = v47;
    }

    else
    {
      if (!v48)
      {
LABEL_27:
        uint64_t v26 = v46;
        uint64_t v46 = 0LL;
        if (v26) {
          (*(void (**)(uint64_t))(*(void *)v26 + 40LL))(v26);
        }
        if (__p)
        {
          uint64_t v42 = __p;
          operator delete(__p);
        }

        unint64_t v15 = *(void *)a2;
        goto LABEL_32;
      }

      uint64_t v24 = 5LL;
    }

    (*(void (**)(void))(*v23 + 8 * v24))();
    goto LABEL_27;
  }

void sub_188117648( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *a32)
{
  unint64_t v36 = a32;
  if (a32 == (void *)(v33 + 56))
  {
    uint64_t v37 = 4LL;
    unint64_t v36 = (void *)(v33 + 56);
  }

  else
  {
    if (!a32) {
      goto LABEL_6;
    }
    uint64_t v37 = 5LL;
  }

  (*(void (**)(void))(*v36 + 8 * v37))();
LABEL_6:
  if (a26) {
    (*(void (**)(uint64_t))(*(void *)a26 + 40LL))(a26);
  }
  if (__p) {
    operator delete(__p);
  }
  uint64_t v38 = *(void **)(v34 - 96);
  if (v38 == v32)
  {
    uint64_t v39 = 4LL;
  }

  else
  {
    if (!v38) {
      goto LABEL_15;
    }
    uint64_t v39 = 5LL;
    unint64_t v32 = *(void **)(v34 - 96);
  }

  (*(void (**)(void *))(*v32 + 8 * v39))(v32);
LABEL_15:
  uint64_t v40 = *(void *)(v34 - 144);
  *(void *)(v34 - 144) = 0LL;
  if (v40) {
    (*(void (**)(uint64_t))(*(void *)v40 + 40LL))(v40);
  }
  _Unwind_Resume(exception_object);
}

__n128 DiskImageStackable::stackable_extents_iterator_interface::clone@<Q0>( DiskImageStackable::stackable_extents_iterator_interface *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x40uLL);
  *(_OWORD *)(v4 + 8) = *(_OWORD *)((char *)this + 8);
  *(_OWORD *)(v4 + 24) = *(_OWORD *)((char *)this + 24);
  *((void *)v4 + 5) = *((void *)this + 5);
  __n128 result = *((__n128 *)this + 3);
  *((__n128 *)v4 + 3) = result;
  *(void *)uint64_t v4 = off_18A1E3D88;
  *a2 = v4;
  return result;
}

  ;
}

uint64_t DiskImageStackable::get_block_size(DiskImageStackable *this)
{
  return *((void *)this + 5);
}

uint64_t DiskImageStackable::get_num_blocks(DiskImageStackable *this)
{
  return (*(uint64_t (**)(void))(**(void **)(*((void *)this + 2) + 8LL) + 32LL))(*(void *)(*((void *)this + 2) + 8LL));
}

uint64_t DiskImageStackable::is_writable(DiskImageStackable *this)
{
  uint64_t v1 = *((void *)this + 2);
  uint64_t v2 = *((void *)this + 3);
  if (v1 == v2) {
    return 0LL;
  }
  uint64_t v3 = v1 + 48;
  do
  {
    LODWORD(result) = (*(uint64_t (**)(void))(**(void **)(v3 - 40) + 40LL))(*(void *)(v3 - 40));
    if (*(_DWORD *)(v3 - 48)) {
      uint64_t result = 0LL;
    }
    else {
      uint64_t result = result;
    }
    if ((result & 1) != 0) {
      break;
    }
    BOOL v5 = v3 == v2;
    v3 += 48LL;
  }

  while (!v5);
  return result;
}

info::DiskImageStackableInfo *DiskImageStackable::create_image_info@<X0>( DiskImageStackable *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = (info::DiskImageStackableInfo *)operator new(0xC8uLL);
  uint64_t result = info::DiskImageStackableInfo::DiskImageStackableInfo(v6, this, a2);
  *a3 = (char *)v6 + *(void *)(*(void *)v6 - 104LL);
  return result;
}

void sub_188117888(_Unwind_Exception *a1)
{
}

uint64_t DiskImageStackable::set_size(DiskImageStackable *this)
{
  return (*(uint64_t (**)(void))(**(void **)(*((void *)this + 2) + 24LL) + 64LL))(*(void *)(*((void *)this + 2) + 24LL));
}

uint64_t DiskImageStackable::get_io_constraints(DiskImageStackable *this)
{
  return (*(uint64_t (**)(void))(**(void **)(*((void *)this + 3) - 24LL) + 72LL))(*(void *)(*((void *)this + 3) - 24LL));
}

uint64_t DiskImageStackable::supports_unmap(DiskImageStackable *this)
{
  uint64_t v1 = *((void *)this + 2);
  uint64_t v2 = *((void *)this + 3);
  if (v1 == v2) {
    return 0LL;
  }
  uint64_t v3 = v1 + 48;
  do
  {
    LODWORD(result) = (*(uint64_t (**)(void))(**(void **)(v3 - 40) + 80LL))(*(void *)(v3 - 40));
    if (*(_DWORD *)(v3 - 48)) {
      uint64_t result = 0LL;
    }
    else {
      uint64_t result = result;
    }
    if ((result & 1) != 0) {
      break;
    }
    BOOL v5 = v3 == v2;
    v3 += 48LL;
  }

  while (!v5);
  return result;
}

uint64_t DiskImageStackable::supports_get_extents(DiskImageStackable *this)
{
  return 1LL;
}

uint64_t DiskImageStackable::may_read_extra(DiskImageStackable *this)
{
  return *((unsigned __int8 *)this + 48);
}

__n128 DiskImageStackable::get_extents_iterator_interface@<Q0>( unint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, __n128 *a4@<X3>, unint64_t a5@<X4>, __n128 **a6@<X8>)
{
  unint64_t v12 = (__n128 *)operator new(0x40uLL);
  __n128 result = *a4;
  v12[1] = *a4;
  v12[2].n128_u64[0] = a4[1].n128_u64[0];
  v12[2].n128_u64[1] = a5;
  v12[3].n128_u64[0] = a1;
  v12[3].n128_u64[1] = a3;
  v12->n128_u64[0] = (unint64_t)off_18A1E3D88;
  v12->n128_u64[1] = a2;
  *a6 = v12;
  return result;
}

void *DiskImageStackable::_create_ctx(DiskImageStackable *this)
{
  uint64_t v2 = operator new(0x40uLL);
  DiskImageStackable::ContextStackable::ContextStackable((uint64_t)v2, (uint64_t)this, 0);
  return v2;
}

void sub_1881179D8(_Unwind_Exception *a1)
{
}

unint64_t DiskImageStackable::read( DiskImageStackable *this, DiskImage::Context *a2, const sg_vec_ns::details::sg_vec_iterator *a3, const sg_vec_ns::details::sg_vec_iterator *a4)
{
  unint64_t v8 = *((void *)a4 + 18);
  uint64_t v9 = (*(uint64_t (**)(DiskImageStackable *))(*(void *)this + 32LL))(this);
  v12[0] = 0;
  v12[528] = 0;
  unint64_t v10 = DiskImageStackable::read_from_idx( (uint64_t)this,  (uint64_t)a2,  (uint64_t)a3,  (uint64_t *)a4,  0LL,  1,  0,  (sg_vec_ref *)v12);
  std::__optional_destruct_base<sg_vec_ref,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v12);
  return v10;
}

void sub_188117AB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>( uint64_t a1, DiskImage *a2)
{
  return di_stackable::get_identifier(*(di_stackable **)(*(void *)(*(void *)a2 + 16LL) + 8LL), a2);
}

const void *std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>( uint64_t a1, uint64_t a2)
{
  return udif::details::UDIF_base::get_identifier((udif::details::UDIF_base *)(*(void *)a2 + 64LL));
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>()
{
  return 0LL;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>( uint64_t a1, DiskImageASIF **a2)
{
  return DiskImageASIF::get_stackable_identifier(*a2);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>( uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(*(void *)a2 + 560LL) + 136LL);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<5ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>( uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)a2 + 72LL);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<6ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>()
{
  return 0LL;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<7ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>( uint64_t a1, uint64_t a2)
{
  return plugin_header::get_uuid((plugin_header *)(*(void *)a2 + 16LL));
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_stackable_source_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>()
{
  return 0LL;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_stackable_source_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>()
{
  return 0LL;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_stackable_source_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>()
{
  return 0LL;
}

const __CFString *std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_stackable_source_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>( uint64_t a1, di_asif::details::dir ***a2)
{
  return DiskImageASIF::get_stackable_source_identifier(*a2);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_stackable_source_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>()
{
  return 0LL;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<5ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_stackable_source_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>()
{
  return 0LL;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<6ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_stackable_source_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>()
{
  return 0LL;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<7ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<di_stackable::get_stackable_source_identifier(DiskImage &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<DiskImageStackable>,std::__variant_detail::_Trait<DiskImageUDIF>,std::__variant_detail::_Trait<DiskImageRaw>,std::__variant_detail::_Trait<DiskImageASIF>,std::__variant_detail::_Trait<DiskImageSparseBundle>,std::__variant_detail::_Trait<DiskImageROChunkRaw>,std::__variant_detail::_Trait<DiskImage>,std::__variant_detail::_Trait<DiskImagePlugin>> &&>()
{
  return 0LL;
}

uint64_t std::construct_at[abi:ne180100]<DiskImageStackable::stackable_layer,DiskImageStackable::stackable_layer&,DiskImageStackable::stackable_layer*>( uint64_t result, uint64_t a2)
{
  *(_DWORD *)__n128 result = *(_DWORD *)a2;
  uint64_t v2 = *(void *)(a2 + 16);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(result + 16) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(result + 32) = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  *(void *)(result + 40) = *(void *)(a2 + 40);
  return result;
}

uint64_t std::vector<DiskImageStackable::stackable_layer>::__swap_out_circular_buffer( uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<DiskImageStackable::stackable_layer>,std::reverse_iterator<DiskImageStackable::stackable_layer*>,std::reverse_iterator<DiskImageStackable::stackable_layer*>,std::reverse_iterator<DiskImageStackable::stackable_layer*>>( (uint64_t)(a1 + 2),  a1[1],  a1[1],  *a1,  *a1,  a2[1],  a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<DiskImageStackable::stackable_layer>,std::reverse_iterator<DiskImageStackable::stackable_layer*>,std::reverse_iterator<DiskImageStackable::stackable_layer*>,std::reverse_iterator<DiskImageStackable::stackable_layer*>>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)&__int128 v15 = a6;
  *((void *)&v15 + 1) = a7;
  __int128 v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }

  else
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = a3 + v7;
      *(_DWORD *)(a7 + v7 - 48) = *(_DWORD *)(a3 + v7 - 48);
      uint64_t v9 = a7 + v7 - 48;
      *(_OWORD *)(v9 + 8) = *(_OWORD *)(a3 + v7 - 40);
      *(void *)(v8 - 40) = 0LL;
      *(void *)(v8 - 32) = 0LL;
      *(_OWORD *)(v9 + 24) = *(_OWORD *)(a3 + v7 - 24);
      *(void *)(v8 - 24) = 0LL;
      *(void *)(v8 - 16) = 0LL;
      *(void *)(v9 + 40) = *(void *)(a3 + v7 - 8);
      *((void *)&v15 + 1) = v9;
      v7 -= 48LL;
    }

    while (a3 + v7 != a5);
    uint64_t v10 = v15;
  }

  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<DiskImageStackable::stackable_layer>,std::reverse_iterator<DiskImageStackable::stackable_layer*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<DiskImageStackable::stackable_layer>,std::reverse_iterator<DiskImageStackable::stackable_layer*>>>::~__exception_guard_exceptions[abi:ne180100]( uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<DiskImageStackable::stackable_layer>,std::reverse_iterator<DiskImageStackable::stackable_layer*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

uint64_t std::_AllocatorDestroyRangeReverse<std::allocator<DiskImageStackable::stackable_layer>,std::reverse_iterator<DiskImageStackable::stackable_layer*>>::operator()[abi:ne180100]( uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 16) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(result + 8) + 8LL);
  while (v1 != v2)
  {
    std::shared_ptr<char>::~shared_ptr[abi:ne180100](v1 + 24);
    uint64_t result = std::shared_ptr<char>::~shared_ptr[abi:ne180100](v1 + 8);
    v1 += 48LL;
  }

  return result;
}

uint64_t std::__split_buffer<DiskImageStackable::stackable_layer>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<DiskImageStackable::stackable_layer>::__destruct_at_end[abi:ne180100]( uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2 != a2)
  {
    uint64_t v4 = result;
    do
    {
      *(void *)(v4 + 16) = v2 - 48;
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v2 - 24);
      uint64_t result = std::shared_ptr<char>::~shared_ptr[abi:ne180100](v2 - 40);
      uint64_t v2 = *(void *)(v4 + 16);
    }

    while (v2 != a2);
  }

  return result;
}

void std::__optional_destruct_base<DiskImageStackable::cacheFlusher_t,false>::reset[abi:ne180100]( uint64_t a1)
{
  if (*(_BYTE *)(a1 + 88))
  {
    workqueue::recurrent_block::~recurrent_block((workqueue::recurrent_block *)(a1 + 64));
    uint64_t v2 = (void **)(a1 + 24);
    std::vector<gcd::gcd_queue>::__destroy_vector::operator()[abi:ne180100](&v2);
    *(_BYTE *)(a1 + 88) = 0;
  }

uint64_t std::__optional_destruct_base<DiskImageStackable::cacheFlusher_t,false>::~__optional_destruct_base[abi:ne180100]( uint64_t a1)
{
  if (*(_BYTE *)(a1 + 88))
  {
    workqueue::recurrent_block::~recurrent_block((workqueue::recurrent_block *)(a1 + 64));
    uint64_t v3 = (void **)(a1 + 24);
    std::vector<gcd::gcd_queue>::__destroy_vector::operator()[abi:ne180100](&v3);
  }

  return a1;
}

void std::vector<DiskImageStackable::stackable_layer>::__destroy_vector::operator()[abi:ne180100]( void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<DiskImageStackable::stackable_layer>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }

uint64_t std::vector<DiskImageStackable::stackable_layer>::__base_destruct_at_end[abi:ne180100]( uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  for (uint64_t i = *(void *)(result + 8); i != a2; i -= 48LL)
  {
    std::shared_ptr<char>::~shared_ptr[abi:ne180100](i - 24);
    uint64_t result = std::shared_ptr<char>::~shared_ptr[abi:ne180100](i - 40);
  }

  *(void *)(v3 + 8) = a2;
  return result;
}

DiskImage::extents_t *DiskImage::extents_t::extents_t( DiskImage::extents_t *this, const DiskImage::extents_t *a2)
{
  uint64_t v4 = *(void *)a2;
  *(void *)this = *(void *)a2;
  __int128 v5 = *(_OWORD *)((char *)a2 + 8);
  *((void *)this + 3) = *((void *)a2 + 3);
  *(_OWORD *)((char *)this + 8) = v5;
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 136LL))(v4);
  *((void *)this + 4) = v6;
  *((void *)this + 5) = v6;
  *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
  *((void *)this + 7) = off_18A1D1060;
  *((void *)this + 10) = (char *)this + 56;
  std::function<std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::operator=( (void *)this + 7,  (uint64_t)a2 + 56);
  return this;
}

void sub_188117FD0(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  uint64_t v6 = *(void **)(v2 + 80);
  if (v6 == v4)
  {
    uint64_t v7 = v4;
    uint64_t v8 = 4LL;
  }

  else
  {
    if (!v6) {
      goto LABEL_6;
    }
    uint64_t v8 = 5LL;
    uint64_t v7 = *(void **)(v2 + 80);
  }

  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  DiskImage::extents_t::extents_t(v1);
  _Unwind_Resume(a1);
}

uint64_t *sg_vec::sg_vec(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sg_vec_ns::details::sg_vec_data::sg_vec_data((uint64_t)a1, a2);
  uint64_t v8 = a1[1];
  uint64_t v15 = *a1;
  uint64_t v9 = v15 + 24 * v8;
  uint64_t v10 = a1[19];
  char v13 = (unint64_t *)a1[18];
  uint64_t v14 = v9;
  unint64_t v12 = &v13[v10];
  sg_vec_ref::sg_vec_ref(v7 + 208, &v15, &v14, &v13, &v12, a3, a4);
  return a1;
}

void sub_188118094(_Unwind_Exception *a1)
{
}

void boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::shared_ptr<char>,unsigned long>*,std::pair<std::shared_ptr<char>,unsigned long>>>( uint64_t *a1@<X0>, __n128 *a2@<X1>, const char *a3@<X2>, __n128 *a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = boost::container::vector_alloc_holder<boost::container::small_vector_allocator<ref::details::ref_cnt_handle,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( (uint64_t)a1,  a3);
  if (v11 >= 0x555555555555556LL) {
    boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v12);
  }
  uint64_t v13 = v11;
  uint64_t v14 = (__n128 *)operator new(24 * v11);
  boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::shared_ptr<char>,unsigned long>*,std::pair<std::shared_ptr<char>,unsigned long>>>( (uint64_t)a1,  v14,  v13,  a2,  (uint64_t)a3,  a4);
  *a5 = (char *)a2 + *a1 - v10;
}

void boost::container::vector<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::shared_ptr<char>,unsigned long>*,std::pair<std::shared_ptr<char>,unsigned long>>>( uint64_t a1, __n128 *a2, uint64_t a3, __n128 *a4, uint64_t a5, __n128 *a6)
{
  uint64_t v10 = *(__n128 **)a1;
  boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::shared_ptr<char>,unsigned long>*,std::pair<std::shared_ptr<char>,unsigned long>*,boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::shared_ptr<char>,unsigned long>*,std::pair<std::shared_ptr<char>,unsigned long>>>( a1,  *(__n128 **)a1,  a4,  (__n128 *)(*(void *)a1 + 24LL * *(void *)(a1 + 8)),  a2,  a5,  a6);
  if (v10)
  {
    for (i = *(void *)(a1 + 8); i; uint64_t v10 = (__n128 *)((char *)v10 + 24))
    {
      --i;
      std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v10);
    }

    if (a1 + 24 != *(void *)a1) {
      operator delete(*(void **)a1);
    }
  }

  uint64_t v12 = *(void *)(a1 + 8) + a5;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 16) = a3;
}

void sub_1881181F8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

__n128 boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::shared_ptr<char>,unsigned long>*,std::pair<std::shared_ptr<char>,unsigned long>*,boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<std::pair<std::shared_ptr<char>,unsigned long>,boost::container::new_allocator<void>,void>,std::pair<std::shared_ptr<char>,unsigned long>*,std::pair<std::shared_ptr<char>,unsigned long>>>( uint64_t a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, uint64_t a6, __n128 *a7)
{
  while (a2 != a3)
  {
    *a5 = *a2;
    a2->n128_u64[0] = 0LL;
    a2->n128_u64[1] = 0LL;
    a5[1].n128_u64[0] = a2[1].n128_u64[0];
    a5 = (__n128 *)((char *)a5 + 24);
    a2 = (__n128 *)((char *)a2 + 24);
  }

  __n128 result = *a7;
  *a5 = *a7;
  a7->n128_u64[0] = 0LL;
  a7->n128_u64[1] = 0LL;
  a5[1].n128_u64[0] = a7[1].n128_u64[0];
  if (a3 != a4)
  {
    uint64_t v8 = (__n128 *)((char *)a5 + 24 * a6);
    do
    {
      __n128 result = *a3;
      *uint64_t v8 = *a3;
      a3->n128_u64[0] = 0LL;
      a3->n128_u64[1] = 0LL;
      v8[1].n128_u64[0] = a3[1].n128_u64[0];
      a3 = (__n128 *)((char *)a3 + 24);
      uint64_t v8 = (__n128 *)((char *)v8 + 24);
    }

    while (a3 != a4);
  }

  return result;
}

uint64_t std::allocate_shared[abi:ne180100]<DiskImageIOBreaker,std::allocator<DiskImageIOBreaker>,DiskImage &,BOOL,void>@<X0>( uint64_t a1@<X1>, char *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = (char *)operator new(0x68uLL);
  uint64_t result = std::__shared_ptr_emplace<DiskImageIOBreaker>::__shared_ptr_emplace[abi:ne180100]<DiskImage &,BOOL,std::allocator<DiskImageIOBreaker>,0>( (uint64_t)v6,  a1,  a2);
  *a3 = v6 + 24;
  a3[1] = v6;
  return result;
}

void sub_1881182DC(_Unwind_Exception *a1)
{
}

uint64_t std::__shared_ptr_emplace<DiskImageIOBreaker>::__shared_ptr_emplace[abi:ne180100]<DiskImage &,BOOL,std::allocator<DiskImageIOBreaker>,0>( uint64_t a1, uint64_t a2, char *a3)
{
  *(void *)a1 = off_18A1E3E80;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  char v4 = *a3;
  *(_BYTE *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = &off_18A1E3920;
  *(void *)(a1 + 40) = a2;
  (*(void (**)(uint64_t))(*(void *)a2 + 72LL))(a2);
  *(_BYTE *)(a1 + 80) = v4;
  _ZNSt3__110shared_ptrIcEC2B8ne180100IN18DiskImageIOBreaker10shared_refMUlT_E_EEEDnS4_((void *)(a1 + 88));
  return a1;
}

void sub_188118360(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<DiskImageIOBreaker>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_18A1E3E80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<DiskImageIOBreaker>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_18A1E3E80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<DiskImageIOBreaker>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 8LL))(a1 + 24);
}

void *_ZNSt3__110shared_ptrIcEC2B8ne180100IN18DiskImageIOBreaker10shared_refMUlT_E_EEEDnS4_(void *a1)
{
  *a1 = 0LL;
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_18A1E3ED0;
  v2[1] = 0LL;
  v2[2] = 0LL;
  v2[3] = 0LL;
  a1[1] = v2;
  return a1;
}

void sub_1881183F4(void *a1)
{
}

void sub_188118400(_Unwind_Exception *a1)
{
}

void _ZNSt3__120__shared_ptr_pointerIDnN18DiskImageIOBreaker10shared_refMUlT_E_ENS_9allocatorIcEEED0Ev( std::__shared_weak_count *a1)
{
}

uint64_t _ZNKSt3__120__shared_ptr_pointerIDnN18DiskImageIOBreaker10shared_refMUlT_E_ENS_9allocatorIcEEE13__get_deleterERKSt9type_info( uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

uint64_t getDIOSLog()
{
  if (getDIOSLog_onceToken != -1) {
    dispatch_once(&getDIOSLog_onceToken, &__block_literal_global_8);
  }
  return getDIOSLog_log;
}

os_log_t __getDIOSLog_block_invoke()
{
  os_log_t result = os_log_create("com.apple.DiskImages2", "Default");
  getDIOSLog_log = (uint64_t)result;
  return result;
}

uint64_t DISetForwardLogs(uint64_t result)
{
  forwardLogs = result;
  return result;
}

uint64_t DIForwardLogs()
{
  return forwardLogs;
}

uint64_t DISetDebugLogsEnabled(uint64_t result)
{
  debugLogsEnabled = result;
  return result;
}

uint64_t DIDebugLogsEnabled()
{
  return debugLogsEnabled;
}

uint64_t system_properties::get_logical_cpus(system_properties *this)
{
  unint64_t v1 = atomic_load(&system_properties::get_logical_cpus(void)::flag);
  if (v1 != -1LL)
  {
    __int128 v5 = &v3;
    char v4 = &v5;
    std::__call_once( &system_properties::get_logical_cpus(void)::flag,  &v4,  (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<system_properties::get_logical_cpus(void)::$_0 &&>>);
  }

  return system_properties::get_logical_cpus(void)::num_cpus;
}

uint64_t system_properties::$_2::__invoke(system_properties::$_2 *this)
{
  return 2 * system_properties::get_logical_cpus(this);
}

uint64_t (**system_properties::get_resources( system_properties *this))(system_properties::$_2 *__hidden this)
{
  if ((v1 & 1) == 0
  {
    system_properties::get_resources(void)::total_memory_gb = (unint64_t)(get_memory_size() + 0x3FFFFFFF) >> 30;
  }

  uint64_t v2 = (uint64_t (**)(system_properties::$_3 *__hidden))&system_properties::small_config;
  else {
    return &system_properties::big_config;
  }
}

void sub_188118610(_Unwind_Exception *a1)
{
}

uint64_t get_memory_size(void)
{
  unint64_t v0 = atomic_load(&get_memory_size(void)::flag);
  if (v0 != -1LL)
  {
    char v4 = &v2;
    char v3 = &v4;
    std::__call_once( &get_memory_size(void)::flag,  &v3,  (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<get_memory_size(void)::$_0 &&>>);
  }

  return get_memory_size(void)::memory_size;
}

uint64_t std::__call_once_proxy[abi:ne180100]<std::tuple<get_memory_size(void)::$_0 &&>>()
{
  size_t v1 = 8LL;
  uint64_t v2 = 0LL;
  uint64_t result = sysctlbyname("hw.memsize", &v2, &v1, 0LL, 0LL);
  get_memory_size(void)::memory_size = v2;
  return result;
}

uint64_t std::__call_once_proxy[abi:ne180100]<std::tuple<system_properties::get_logical_cpus(void)::$_0 &&>>()
{
  int v2 = 1;
  size_t v1 = 4LL;
  uint64_t result = sysctlbyname("hw.logicalcpu", &v2, &v1, 0LL, 0LL);
  system_properties::get_logical_cpus(void)::num_cpus = v2;
  return result;
}

uint64_t ref::details::_get_tagged_ptr_lock(unint64_t this, const void *a2)
{
  if ((v2 & 1) == 0)
  {
    uint64_t v7 = (ref::details *)this;
    this = (unint64_t)v7;
    if (v6)
    {
      __cxa_atexit((void (*)(void *))__cxx_global_array_dtor, 0LL, &dword_188046000);
      this = (unint64_t)v7;
    }
  }

  unint64_t v3 = 0x9DDFEA08EB382D69LL * (((8 * this) + 8LL) ^ HIDWORD(this));
  unint64_t v4 = 0x9DDFEA08EB382D69LL * (HIDWORD(this) ^ (v3 >> 47) ^ v3);
  return (uint64_t)&ref::details::_get_tagged_ptr_lock(void const*)::mutexs
       + 64 * (unint64_t)((9 * ((v4 >> 47) ^ v4)) & 0xF);
}

uint64_t ref::details::_get_tagged_ptr_cond(unint64_t this, const void *a2)
{
  if ((v2 & 1) == 0)
  {
    uint64_t v7 = (ref::details *)this;
    this = (unint64_t)v7;
    if (v6)
    {
      __cxa_atexit((void (*)(void *))__cxx_global_array_dtor_1, 0LL, &dword_188046000);
      this = (unint64_t)v7;
    }
  }

  unint64_t v3 = 0x9DDFEA08EB382D69LL * (((8 * this) + 8LL) ^ HIDWORD(this));
  unint64_t v4 = 0x9DDFEA08EB382D69LL * (HIDWORD(this) ^ (v3 >> 47) ^ v3);
  return (uint64_t)&ref::details::_get_tagged_ptr_cond(void const*)::conds
       + 48 * ((9 * ((v4 >> 47) ^ v4)) & 0xF);
}

uint64_t ref::details::ref_cnt_handle::ref_cnt_handle(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)uint64_t result = off_18A1E3FC0;
  *(void *)(result + 8) = v2;
  *(_BYTE *)(result + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a2 + 16) = 0;
  return result;
}

void ref::details::ref_cnt_handle::~ref_cnt_handle(ref::details::ref_cnt_handle *this, const void *a2)
{
  *(void *)this = off_18A1E3FC0;
  if (*((_BYTE *)this + 16))
  {
    uint64_t v2 = (unint64_t *)*((void *)this + 1);
    do
    {
      unint64_t v3 = __ldxr(v2);
      unint64_t v4 = v3 - 1;
    }

    while (__stxr(v4, v2));
    if (!v4) {
      ref::ref_cnt::notify((ref::ref_cnt *)v2, a2);
    }
  }

{
  void *v2;
  ref::details::ref_cnt_handle::~ref_cnt_handle(this, a2);
  operator delete(v2);
}

unint64_t *ref::details::ref_cnt_handle::upgrade_to_exclusive@<X0>( ref::details::ref_cnt_handle *this@<X0>, const void *a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *((unsigned __int8 *)this + 16);
  uint64_t result = (unint64_t *)*((void *)this + 1);
  if (v6)
  {
    do
    {
      unint64_t v8 = __ldxr(result);
      unint64_t v9 = v8 - 1;
    }

    while (__stxr(v9, result));
    if (!v9) {
      ref::ref_cnt::notify((ref::ref_cnt *)result, a2);
    }
    *((_BYTE *)this + 16) = 0;
    return (unint64_t *)ref::ref_cnt::take_exclusive(*((void *)this + 1), (uint64_t)a2, a3);
  }

  else
  {
    *(_BYTE *)(a3 + 16) = 0;
    *(void *)a3 = off_18A1E3FE0;
    *(void *)(a3 + 8) = result;
    *(void *)(a3 + 24) = a2;
  }

  return result;
}

void ref::details::ref_cnt_set_handle::~ref_cnt_set_handle( ref::details::ref_cnt_set_handle *this, const void *a2)
{
  *(void *)this = off_18A1E3FE0;
  if (*((_BYTE *)this + 16))
  {
    atomic_store(*((void *)this + 3), *((unint64_t **)this + 1));
    ref::ref_cnt::notify(*((ref::ref_cnt **)this + 1), a2);
  }

  *((_BYTE *)this + 16) = 0;
  ref::details::ref_cnt_handle::~ref_cnt_handle(this, a2);
}

{
  void *v2;
  ref::details::ref_cnt_set_handle::~ref_cnt_set_handle(this, a2);
  operator delete(v2);
}

void ref::ref_cnt::notify(ref::ref_cnt *this, const void *a2)
{
  tagged_ptr_lock = (std::mutex *)ref::details::_get_tagged_ptr_lock((unint64_t)this, a2);
  std::mutex::lock(tagged_ptr_lock);
  uint64_t tagged_ptr_cond = (std::condition_variable *)ref::details::_get_tagged_ptr_cond((unint64_t)this, v4);
  std::condition_variable::notify_all(tagged_ptr_cond);
  std::mutex::unlock(tagged_ptr_lock);
}

void __cxx_global_array_dtor()
{
  for (uint64_t i = 0x3C0u; i != -64; i -= 64LL)
    std::mutex::~mutex((std::mutex *)((char *)&ref::details::_get_tagged_ptr_lock(void const*)::mutexs + i));
}

void __cxx_global_array_dtor_1()
{
  for (uint64_t i = 0x2D0u; i != -48; i -= 48LL)
    std::condition_variable::~condition_variable((std::condition_variable *)((char *)&ref::details::_get_tagged_ptr_cond(void const*)::conds
                                                                           + i));
}

uint64_t smart_enums::validators::validator_exception_base::what( smart_enums::validators::validator_exception_base *this)
{
  return *((void *)this + 1);
}

const void **CFAutoRelease<__CFNumber const*>::~CFAutoRelease(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *di_log::logger<di_log::log_printer<361ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<361ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E40A0;
  a1[45] = &unk_18A1E41A0;
  a1[46] = &unk_18A1E41C8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E40A0;
  a1[45] = &unk_18A1E4128;
  a1[46] = &unk_18A1E4150;
  return a1;
}

void sub_188118B7C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<361ul>>::~logger(uint64_t a1)
{
  return a1;
}

void smart_enums::validators::validator_exception<int>::~validator_exception(std::exception *a1)
{
}

void smart_enums::validators::validator_exception<int>::reason( smart_enums::validators::validator_exception_base *a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = (char *)smart_enums::validators::validator_exception_base::what(a1);
  std::string::basic_string[abi:ne180100]<0>(v15, v3);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v10);
  if ((v16 & 0x80u) == 0) {
    unint64_t v4 = v15;
  }
  else {
    unint64_t v4 = (void **)v15[0];
  }
  if ((v16 & 0x80u) == 0) {
    uint64_t v5 = v16;
  }
  else {
    uint64_t v5 = (uint64_t)v15[1];
  }
  int v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)v4, v5);
  uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" [", 2LL);
  *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(*v7 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  unint64_t v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"]", 1LL);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v12, a2);
  v10[0] = *MEMORY[0x189614728];
  uint64_t v9 = *(void *)(MEMORY[0x189614728] + 72LL);
  *(void *)((char *)v10 + *(void *)(v10[0] - 24LL)) = *(void *)(MEMORY[0x189614728] + 64LL);
  uint64_t v11 = v9;
  v12[0] = MEMORY[0x189614750] + 16LL;
  if (v13 < 0) {
    operator delete((void *)v12[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1895BC2CC](&v14);
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<361ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<361ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<361ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<361ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<361ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<361ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<361ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<361ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<361ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<361ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E4238;
  di_log::logger_buf<di_log::log_printer<361ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<361ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<361ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1881190C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<361ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<361ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<361ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 361LL;
    __int16 v22 = 2082;
    __int128 v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 361LL;
      __int16 v22 = 2082;
      __int128 v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t std::__function::__value_func<std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::__value_func[abi:ne180100]( uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  *uint64_t v3 = 0LL;
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<361ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E4238;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881193B0(_Unwind_Exception *a1)
{
}

void BufferAllocator::add_buffer(size_t *this)
{
  uint64_t v2 = operator new[](*this);
  unint64_t v3 = this[5];
  char v4 = (void *)this[4];
  if ((unint64_t)v4 >= v3)
  {
    size_t v6 = this[3];
    uint64_t v7 = (uint64_t)((uint64_t)v4 - v6) >> 3;
    uint64_t v8 = v3 - v6;
    uint64_t v9 = v8 >> 2;
    else {
      unint64_t v10 = v9;
    }
    if (v10) {
      uint64_t v11 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( (uint64_t)(this + 5),  v10);
    }
    else {
      uint64_t v11 = 0LL;
    }
    os_log_type_t v12 = &v11[8 * v7];
    uint64_t v13 = &v11[8 * v10];
    *(void *)os_log_type_t v12 = v2;
    __int128 v5 = v12 + 8;
    uint64_t v15 = (char *)this[3];
    uint64_t v14 = (char *)this[4];
    if (v14 != v15)
    {
      do
      {
        uint64_t v16 = *((void *)v14 - 1);
        v14 -= 8;
        *((void *)v12 - 1) = v16;
        v12 -= 8;
      }

      while (v14 != v15);
      uint64_t v14 = (char *)this[3];
    }

    this[3] = (size_t)v12;
    this[4] = (size_t)v5;
    this[5] = (size_t)v13;
    if (v14) {
      operator delete(v14);
    }
  }

  else
  {
    *char v4 = v2;
    __int128 v5 = v4 + 1;
  }

  this[4] = (size_t)v5;
  ++*((_DWORD *)this + 2);
}

void BufferAllocator::~BufferAllocator(BufferAllocator *this)
{
  uint64_t v2 = (void **)*((void *)this + 3);
  unint64_t v3 = (void **)*((void *)this + 4);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {
        operator delete[](*v2);
      }
      ++v2;
    }

    while (v2 != v3);
    uint64_t v2 = (void **)*((void *)this + 3);
  }

  *((void *)this + 4) = v2;
  std::mutex::~mutex((std::mutex *)((char *)this + 96));
  std::condition_variable::~condition_variable((std::condition_variable *)this + 1);
  char v4 = (void *)*((void *)this + 3);
  if (v4)
  {
    *((void *)this + 4) = v4;
    operator delete(v4);
  }

void BufferAllocator::BufferAllocator( BufferAllocator *this, uint64_t a2, unsigned int a3, unint64_t a4)
{
  unsigned int v4 = a3;
  *(void *)this = a2;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 4) = 0LL;
  *((void *)this + 5) = 0LL;
  *((void *)this + 3) = 0LL;
  size_t v6 = (void **)((char *)this + 24);
  *((void *)this + 6) = 1018212795LL;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0LL;
  *((void *)this + 12) = 850045863LL;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((void *)this + 19) = 0LL;
  if (a3 <= a4) {
    unint64_t v7 = a4;
  }
  else {
    unint64_t v7 = a3;
  }
  *((void *)this + 2) = v7;
  std::vector<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *,std::allocator<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *>>::reserve( v6,  a3);
  for (; v4; --v4)
    BufferAllocator::add_buffer((size_t *)this);
}

void sub_1881195B8(_Unwind_Exception *a1)
{
}

void BufferAllocator::allocate(std::condition_variable *this@<X0>, void *a2@<X8>)
{
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)&this[2];
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)&this[2]);
  uint64_t v4 = *(void *)&this->__cv_.__opaque[24];
  if (*(void *)&this->__cv_.__opaque[16] == v4)
  {
    if (*(void *)&this->__cv_.__opaque[8] <= (unint64_t)*(unsigned int *)this->__cv_.__opaque)
    {
      do
      {
        std::condition_variable::wait(this + 1, &__lk);
        uint64_t v4 = *(void *)&this->__cv_.__opaque[24];
      }

      while (*(void *)&this->__cv_.__opaque[16] == v4);
    }

    else
    {
      BufferAllocator::add_buffer((size_t *)this);
      uint64_t v4 = *(void *)&this->__cv_.__opaque[24];
    }
  }

  uint64_t v5 = *(void *)(v4 - 8);
  *(void *)&this->__cv_.__opaque[24] = v4 - 8;
  uint64_t v8 = this;
  *a2 = v5;
  size_t v6 = operator new(0x28uLL);
  *size_t v6 = off_18A1E42B8;
  v6[1] = 0LL;
  v6[2] = 0LL;
  void v6[3] = v5;
  void v6[4] = this;
  a2[1] = v6;
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
}

void sub_1881196A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, char a11, int a12, __int16 a13, char a14, char a15)
{
}

void BufferAllocator::allocate(void)::$_0::operator()<char *>(void *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (std::mutex *)(*a1 + 96LL);
  std::mutex::lock(v4);
  uint64_t v5 = *(void **)(v3 + 32);
  unint64_t v6 = *(void *)(v3 + 40);
  if ((unint64_t)v5 >= v6)
  {
    uint64_t v8 = *(void *)(v3 + 24);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    uint64_t v10 = v6 - v8;
    uint64_t v11 = v10 >> 2;
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      uint64_t v13 = (char *)std::allocator<std::unique_ptr<diskimage_uio::stack_image_node const>>::allocate_at_least[abi:ne180100]( v3 + 40,  v12);
    }
    else {
      uint64_t v13 = 0LL;
    }
    uint64_t v14 = &v13[8 * v9];
    uint64_t v15 = &v13[8 * v12];
    *(void *)uint64_t v14 = a2;
    unint64_t v7 = v14 + 8;
    int v17 = *(char **)(v3 + 24);
    uint64_t v16 = *(char **)(v3 + 32);
    if (v16 != v17)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *((void *)v14 - 1) = v18;
        v14 -= 8;
      }

      while (v16 != v17);
      uint64_t v16 = *(char **)(v3 + 24);
    }

    *(void *)(v3 + 24) = v14;
    *(void *)(v3 + 32) = v7;
    *(void *)(v3 + 40) = v15;
    if (v16) {
      operator delete(v16);
    }
  }

  else
  {
    *uint64_t v5 = a2;
    unint64_t v7 = v5 + 1;
  }

  *(void *)(v3 + 32) = v7;
  std::mutex::unlock(v4);
  std::condition_variable::notify_one((std::condition_variable *)(v3 + 48));
}

void sub_1881197E4(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<char *,BufferAllocator::allocate(void)::$_0,std::allocator<char>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<char *,BufferAllocator::allocate(void)::$_0,std::allocator<char>>::__on_zero_shared( uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<char *,BufferAllocator::allocate(void)::$_0,std::allocator<char>>::__get_deleter( uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

void toNativeType(const __CFString *a1@<X0>, void *a2@<X8>)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v5 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  unint64_t v6 = operator new[](v5);
  bzero(v6, v5);
  if (!CFStringGetCString(a1, (char *)v6, v5, 0x8000100u))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    uint64_t v8 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v8;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Couldn't convert CFStringRef to a proper std string";
  }

  std::string::basic_string[abi:ne180100]<0>(a2, (char *)v6);
  operator delete[](v6);
}

void sub_188119944(_Unwind_Exception *a1)
{
}

uint64_t CFStringGetOSType(const __CFString *a1)
{
  if (!a1)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    CFIndex v5 = "Invalid resource key";
    goto LABEL_8;
  }

  unint64_t Length = CFStringGetLength(a1);
  if (Length >= 5)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    CFIndex v5 = "Resource name is too long to fit uint32_t";
    goto LABEL_8;
  }

  v8.length = Length;
  v8.location = 0LL;
  if (CFStringGetBytes(a1, v8, 0, 0, 0, buffer, 4LL, 0LL) != 4)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    CFIndex v5 = "Can't get key in cstring format";
LABEL_8:
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, v5, 0x16u);
  }

  return bswap32(*(unsigned int *)buffer);
}

BOOL addNumberToCFArray<long long>(__CFArray *a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberLongLongType, &valuePtr);
  CFNumberRef v5 = v3;
  if (v3) {
    CFArrayAppendValue(a1, v3);
  }
  CFAutoRelease<__CFNumber const*>::~CFAutoRelease((const void **)&v5);
  return v3 != 0LL;
}

void sub_188119A88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL addCFNumber64ToDict(__CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberLongLongType, &valuePtr);
  CFNumberRef v7 = v5;
  if (v5) {
    CFDictionarySetValue(a1, a2, v5);
  }
  CFAutoRelease<__CFNumber const*>::~CFAutoRelease((const void **)&v7);
  return v5 != 0LL;
}

void sub_188119B18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

__CFDictionary *cf::make_dict@<X0>( const void **keys@<X0>, const void **values@<X1>, CFIndex numValues@<X2>, CFMutableDictionaryRef *a4@<X8>)
{
  if (keys && values && numValues)
  {
    uint64_t result = CFDictionaryCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  keys,  values,  numValues,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    CFMutableDictionaryRef Mutable = result;
  }

  else
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    CFNumberRef v7 = 0LL;
    uint64_t result = (__CFDictionary *)CFAutoRelease<__CFDictionary *>::~CFAutoRelease(&v7);
  }

  *a4 = Mutable;
  return result;
}

CFMutableDictionaryRef cf::make_empty_dict@<X0>(CFMutableDictionaryRef *a1@<X8>)
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  *a1 = result;
  return result;
}

const void **cf::serialize_to_xml_plist@<X0>(CFPropertyListRef propertyList@<X0>, const __CFData **a2@<X8>)
{
  CFErrorRef error = 0LL;
  uint64_t v4 = CFPropertyListCreateData( (CFAllocatorRef)*MEMORY[0x189604DB0],  propertyList,  kCFPropertyListXMLFormat_v1_0,  0LL,  &error);
  CFNumberRef v5 = v4;
  if (v4) {
    BOOL v6 = error == 0LL;
  }
  else {
    BOOL v6 = 0;
  }
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    uint64_t v11 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v11;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Can't serialize property list";
  }

  CFIndex Length = CFDataGetLength(v4);
  CFTypeID TypeID = CFDataGetTypeID();
  if (CFGetTypeID(v5) != TypeID)
  {
    unint64_t v12 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
    CFGetTypeID(v5);
    uint64_t v13 = cf::CFUtilException::CFUtilException(v12);
  }

  uint64_t v14 = 0LL;
  *a2 = v5;
  a2[1] = (const __CFData *)Length;
  CFAutoRelease<__CFData const*>::~CFAutoRelease(&v14);
  return CFAutoRelease<__CFError *>::~CFAutoRelease((const void **)&error);
}

void sub_188119D3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
}

const void **cf::deserialize_from_xml_plist@<X0>(UInt8 *bytes@<X0>, CFIndex length@<X1>, void *a3@<X8>)
{
  CFErrorRef error = 0LL;
  uint64_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFDataRef v5 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], bytes, length);
  CFDataRef v19 = v5;
  if (v5) {
    BOOL v6 = error == 0LL;
  }
  else {
    BOOL v6 = 0;
  }
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    unint64_t v12 = std::generic_category();
    exception[1] = 12LL;
    exception[2] = v12;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Can't create data for plist deserialization";
  }

  CFPropertyListFormat format = kCFPropertyListXMLFormat_v1_0;
  CFPropertyListRef v7 = CFPropertyListCreateWithData(v4, v5, 0LL, &format, &error);
  if (v7) {
    BOOL v8 = error == 0LL;
  }
  else {
    BOOL v8 = 0;
  }
  if (!v8)
  {
    uint64_t v13 = __cxa_allocate_exception(0x40uLL);
    unsigned int Code = CFErrorGetCode(error);
    *uint64_t v13 = off_18A1E43B0;
    uint64_t v15 = std::generic_category();
    v13[1] = Code;
    void v13[2] = v15;
    *((_BYTE *)v13 + 24) = 0;
    *((_BYTE *)v13 + 48) = 0;
    v13[7] = "Can't convert data to property list";
  }

  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (CFGetTypeID(v7) != TypeID)
  {
    uint64_t v16 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
    CFGetTypeID(v7);
    int v17 = cf::CFUtilException::CFUtilException(v16);
  }

  *a3 = v7;
  CFAutoRelease<__CFData const*>::~CFAutoRelease((const void **)&v19);
  return CFAutoRelease<__CFError *>::~CFAutoRelease((const void **)&error);
}

void sub_188119F18( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12)
{
}

char *CFDataCopyToVector@<X0>( const __CFData *a1@<X0>, unsigned int a2@<W1>, size_t a3@<X2>, unint64_t *a4@<X8>)
{
  unint64_t Length = CFDataGetLength(a1);
  if (!a3) {
    a3 = Length;
  }
  unint64_t v9 = a3 + a2;
  if (__CFADD__(a3, a2) || Length < v9)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Unable to convert data to vector.", 0x16u);
  }

  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  BytePtr = CFDataGetBytePtr(a1);
  std::vector<std::byte>::reserve(a4, a3);
  return std::vector<std::byte>::__insert_with_size[abi:ne180100]<std::byte const*,std::byte const*>( (uint64_t)a4,  (char *)*a4,  (char *)&BytePtr[a2],  (char *)&BytePtr[v9],  a3);
}

void sub_18811A01C(_Unwind_Exception *exception_object)
{
  CFNumberRef v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<std::byte>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000LL) != 0) {
      std::vector<iovec>::__throw_length_error[abi:ne180100]();
    }
    CFDataRef v5 = (char *)a1[1];
    BOOL v6 = operator new(__sz);
    CFPropertyListRef v7 = &v5[(void)v6 - v2];
    BOOL v8 = v7;
    if (v5 != (char *)v2)
    {
      unint64_t v9 = &v5[~v2];
      do
      {
        char v10 = *--v5;
        (v9--)[(void)v6] = v10;
      }

      while (v5 != (char *)v2);
      BOOL v8 = v6;
    }

    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2) {
      operator delete((void *)v2);
    }
  }

BOOL addCFStringToDict(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  else {
    CFDataRef v5 = *(const char **)a3;
  }
  CFStringRef v6 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], v5, 0x8000100u);
  CFStringRef v8 = v6;
  if (v6) {
    CFDictionarySetValue(a1, a2, v6);
  }
  CFAutoRelease<__CFString const*>::~CFAutoRelease((const void **)&v8);
  return v6 != 0LL;
}

void sub_18811A16C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void cf::add_key_value_pairs_to_dict(CFMutableDictionaryRef *a1, uint64_t *a2)
{
  uint64_t v2 = a2[1];
  if (v2)
  {
    uint64_t v4 = *a2;
    uint64_t v5 = *a2 + 16 * v2;
    do
    {
      CFStringRef v6 = *(const void **)v4;
      CFPropertyListRef v7 = *(const void **)(v4 + 8);
      v4 += 16LL;
      CFDictionaryAddValue(*a1, v6, v7);
    }

    while (v4 != v5);
  }

void cf::create_dict_from_list(uint64_t *a1@<X0>, CFMutableDictionaryRef *a2@<X8>)
{
  *a2 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  cf::add_key_value_pairs_to_dict(a2, a1);
}

void sub_18811A21C(_Unwind_Exception *a1)
{
}

char *std::vector<std::byte>::__insert_with_size[abi:ne180100]<std::byte const*,std::byte const*>( uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  uint64_t v5 = __dst;
  if (a5 < 1) {
    return v5;
  }
  char v10 = *(char **)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    uint64_t v11 = *(char **)a1;
    uint64_t v12 = (uint64_t)&v10[a5 - *(void *)a1];
    if (v12 < 0) {
      std::vector<iovec>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v13 = (char *)(__dst - v11);
    unint64_t v14 = v9 - (void)v11;
    if (2 * v14 > v12) {
      uint64_t v12 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v12;
    }
    if (v15)
    {
      size_t v16 = v15;
      int v17 = (char *)operator new(v15);
    }

    else
    {
      size_t v16 = 0LL;
      int v17 = 0LL;
    }

    unint64_t v27 = &v13[(void)v17];
    memcpy(&v13[(void)v17], __src, a5);
    int v28 = &v13[(void)v17];
    size_t v29 = v16;
    if (v11 != v5)
    {
      do
      {
        v13[(void)v17 - 1] = v13[(void)(v11 - 1)];
        --v13;
      }

      while (v13);
      char v10 = *(char **)(a1 + 8);
      int v28 = v17;
    }

    uint64_t v30 = &v27[a5];
    unint64_t v31 = &v17[v29];
    if (v10 != v5) {
      memmove(v30, v5, v10 - v5);
    }
    unint64_t v32 = *(char **)a1;
    *(void *)a1 = v28;
    *(void *)(a1 + 8) = &v30[v10 - v5];
    *(void *)(a1 + 16) = v31;
    if (v32) {
      operator delete(v32);
    }
    return v27;
  }

  uint64_t v18 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    CFDataRef v19 = &__src[a5];
    uint64_t v21 = *(char **)(a1 + 8);
LABEL_17:
    __int16 v22 = &v5[a5];
    __int128 v23 = &v21[-a5];
    uint64_t v24 = v21;
    if (&v21[-a5] < v10)
    {
      int64_t v25 = &v10[a5] - v21;
      uint64_t v24 = v21;
      do
      {
        char v26 = *v23++;
        *v24++ = v26;
        --v25;
      }

      while (v25);
    }

    *(void *)(a1 + 8) = v24;
    if (v21 != v22) {
      memmove(&v5[a5], v5, v21 - v22);
    }
    if (v19 != __src) {
      memmove(v5, __src, v19 - __src);
    }
    return v5;
  }

  CFDataRef v19 = &__src[v18];
  int64_t v20 = a4 - &__src[v18];
  if (a4 != &__src[v18]) {
    memmove(*(void **)(a1 + 8), &__src[v18], a4 - &__src[v18]);
  }
  uint64_t v21 = &v10[v20];
  *(void *)(a1 + 8) = &v10[v20];
  if (v18 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

const void **CFAutoRelease<__CFError *>::~CFAutoRelease(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void convertHexToBytes(char *__s@<X0>, unint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = &v23;
  std::string::basic_string[abi:ne180100]<0>(&v23, __s);
  uint64_t size = v23.__r_.__value_.__s.__size_;
  signed __int8 v7 = v23.__r_.__value_.__s.__size_;
  std::string::size_type v9 = v23.__r_.__value_.__l.__size_;
  std::string::size_type v8 = v23.__r_.__value_.__r.__words[0];
  if ((v23.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    char v10 = (std::string *)((char *)&v23 + v23.__r_.__value_.__s.__size_);
  }
  else {
    char v10 = (std::string *)(v23.__r_.__value_.__r.__words[0] + v23.__r_.__value_.__l.__size_);
  }
  if ((v23.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    uint64_t v5 = (std::string *)v23.__r_.__value_.__r.__words[0];
  }
  if (v5 != v10)
  {
    do
    {
      v5->__r_.__value_.__s.__data_[0] = __tolower(v5->__r_.__value_.__s.__data_[0]);
      uint64_t v5 = (std::string *)((char *)v5 + 1);
    }

    while (v5 != v10);
    uint64_t size = v23.__r_.__value_.__s.__size_;
    std::string::size_type v9 = v23.__r_.__value_.__l.__size_;
    std::string::size_type v8 = v23.__r_.__value_.__r.__words[0];
    signed __int8 v7 = v23.__r_.__value_.__s.__size_;
  }

  if (v7 >= 0)
  {
    uint64_t v11 = &v23;
  }

  else
  {
    uint64_t size = v9;
    uint64_t v11 = (std::string *)v8;
  }

  if (size >= 2)
  {
    uint64_t v12 = (std::string *)((char *)v11 + size);
    uint64_t v13 = v11;
    do
    {
      unint64_t v14 = (std::string *)memchr(v13, 48, size - 1);
      if (!v14) {
        break;
      }
      if (LOWORD(v14->__r_.__value_.__l.__data_) == 30768)
      {
        if (v14 != v12 && v14 == v11)
        {
          size_t v15 = std::string::erase(&v23, 0LL, 2uLL);
          std::string::operator=(&v23, v15);
        }

        break;
      }

      uint64_t v13 = (std::string *)((char *)&v14->__r_.__value_.__l.__data_ + 1);
      uint64_t size = (char *)v12 - (char *)v13;
    }

    while ((char *)v12 - (char *)v13 >= 2);
  }

  int64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  boost::algorithm::unhex<std::string,std::back_insert_iterator<std::vector<unsigned char>>>( (uint64_t)&v23,  (unint64_t *)&v20);
  size_t v16 = v20;
  int v17 = v21;
  size_t v18 = (_BYTE *)v21 - (_BYTE *)v20;
  if (a2) {
    *a2 = v18;
  }
  CFDataRef v19 = operator new[](v18);
  bzero(v19, v18);
  *a3 = v19;
  if (v17 != v16) {
    memmove(v19, v16, v18);
  }
  if (v16)
  {
    uint64_t v21 = v16;
    operator delete(v16);
  }

void sub_18811A5D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  switch(a2)
  {
    case 3:
      __cxa_begin_catch(exception_object);
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = off_18A1E43B0;
      int64_t v20 = std::generic_category();
      exception[1] = 22LL;
      exception[2] = v20;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 48) = 0;
      exception[7] = "Does not contain an even number of hex digits.";
    case 2:
      __cxa_begin_catch(exception_object);
      uint64_t v21 = __cxa_allocate_exception(0x40uLL);
      *uint64_t v21 = off_18A1E43B0;
      uint64_t v22 = std::generic_category();
      v21[1] = 22LL;
      void v21[2] = v22;
      *((_BYTE *)v21 + 24) = 0;
      *((_BYTE *)v21 + 48) = 0;
      v21[7] = "Contains non-hexadecimal characters.";
    case 1:
      __cxa_begin_catch(exception_object);
      std::string v23 = __cxa_allocate_exception(0x40uLL);
      void *v23 = off_18A1E43B0;
      uint64_t v24 = std::generic_category();
      v23[1] = 22LL;
      v23[2] = v24;
      *((_BYTE *)v23 + 24) = 0;
      *((_BYTE *)v23 + 48) = 0;
      v23[7] = "Decoding error.";
  }

  _Unwind_Resume(exception_object);
}

unint64_t *boost::algorithm::unhex<std::string,std::back_insert_iterator<std::vector<unsigned char>>>( uint64_t a1, unint64_t *a2)
{
  int v3 = *(char *)(a1 + 23);
  BOOL v4 = v3 < 0;
  uint64_t v5 = *(void *)a1;
  if (v3 >= 0) {
    uint64_t v5 = a1;
  }
  uint64_t v6 = *(unsigned __int8 *)(a1 + 23);
  if (v4) {
    uint64_t v6 = *(void *)(a1 + 8);
  }
  uint64_t v9 = v5;
  if (v6)
  {
    uint64_t v7 = v5 + v6;
    do
      a2 = boost::algorithm::detail::decode_one<std::__wrap_iter<char const*>,std::back_insert_iterator<std::vector<unsigned char>>,BOOL (*)(std::__wrap_iter<char const*>,std::__wrap_iter<char const*>)>( &v9,  v7,  a2,  (unsigned int (*)(uint64_t, uint64_t))boost::algorithm::detail::iter_end<std::__wrap_iter<char const*>>);
    while (v9 != v7);
  }

  return a2;
}

uint64_t di_utils::buffer_to_uuid(di_utils *this, uint64_t a2)
{
  v3[2] = *MEMORY[0x1895F89C0];
  v3[0] = 0LL;
  v3[1] = 0LL;
  return boost::uuids::basic_name_generator<boost::uuids::detail::sha1>::operator()((uint64_t)v3, (char *)this, a2);
}

void *operator<<(void *a1, uint64_t a2)
{
  int v3 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  size_t v4 = strlen(v3);
  uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v3, v4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)" (error code ", 13LL);
  uint64_t v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)")", 1LL);
  return a1;
}

uint64_t DiskImagesRuntimeException::what(DiskImagesRuntimeException *this)
{
  if (!*((_BYTE *)this + 48))
  {
    uint64_t result = (uint64_t)this + 56;
    return *(void *)result;
  }

  uint64_t result = (uint64_t)this + 24;
  return result;
}

uint64_t di_utils::random_uuid(di_utils *this)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  uuid_generate_random(out);
  return *(void *)out;
}

void *details::get_dummy_shared_ptr(void)
{
  {
    __cxa_atexit( (void (*)(void *))std::shared_ptr<char>::~shared_ptr[abi:ne180100],  &details::get_dummy_shared_ptr(void)::dummy_shared_ptr,  &dword_188046000);
  }

  unint64_t v1 = atomic_load(&details::get_dummy_shared_ptr(void)::dummy_once_flag);
  if (v1 != -1LL)
  {
    uint64_t v5 = &v3;
    size_t v4 = &v5;
    std::__call_once( &details::get_dummy_shared_ptr(void)::dummy_once_flag,  &v4,  (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<details::get_dummy_shared_ptr(void)::$_0 &&>>);
  }

  return &details::get_dummy_shared_ptr(void)::dummy_shared_ptr;
}

uint64_t process_terminator::terminate(process_terminator *this)
{
  if (process_terminator::supports_termination)
  {
    while (!__ldaxr((unsigned __int8 *)&process_terminator::terminated))
    {
      if (!__stlxr(1u, (unsigned __int8 *)&process_terminator::terminated))
      {
        *(void *)&__int128 v3 = "void process_terminator::terminate()";
        *((void *)&v3 + 1) = 34LL;
        int v4 = 16;
        di_log::logger<di_log::log_printer<137ul>>::logger(v5, &v3);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v6,  (uint64_t)"Terminating due to unrecoverable I/O error",  42LL);
        std::ostream::~ostream();
        di_log::logger_buf<di_log::log_printer<137ul>>::~logger_buf((uint64_t)v5);
        MEMORY[0x1895BC2CC](&v7);
        return raise(15);
      }
    }

    __clrex();
  }

  return result;
}

void sub_18811AAA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

unint64_t trim_data(uint64_t a1, uint64_t a2, unint64_t a3, void *a4)
{
  uint64_t v6 = (uint64_t *)(a1 + 144);
  uint64_t v5 = *(void *)(a1 + 144);
  uint64_t v7 = a4[1];
  unint64_t v8 = *a4 - (v5 - v7);
  if (v8 >= a3) {
    unint64_t v8 = a3;
  }
  unint64_t v128 = v8;
  unint64_t v9 = v5 - v7;
  if (v5 == v7) {
    goto LABEL_160;
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 8);
  uint64_t v187 = *(void **)a1;
  unint64_t v188 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }

  v189[0] = *(_OWORD *)(a1 + 16);
  *(_OWORD *)((char *)v189 + 9) = *(_OWORD *)(a1 + 25);
  uint64_t v190 = *(void *)(a1 + 48);
  __int128 v191 = *(_OWORD *)(a1 + 56);
  __int128 v192 = *(_OWORD *)(a1 + 72);
  __int128 v193 = *(_OWORD *)(a1 + 88);
  char v194 = *(_BYTE *)(a1 + 104);
  size_t v15 = *(std::__shared_weak_count **)(a1 + 120);
  uint64_t v195 = *(void *)(a1 + 112);
  char v196 = v15;
  if (v15)
  {
    size_t v16 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }

  __int128 v197 = *(_OWORD *)(a1 + 128);
  uint64_t v198 = *v6;
  char v199 = *(_BYTE *)(a1 + 152);
  unint64_t v18 = v8 + v9;
  sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v187, v8 + v9);
  sg_vec_ns::details::buffer_iterator::rtrim_written(&v191);
  CFDataRef v19 = (_OWORD *)(a1 + 16);
  int64_t v20 = (__int128 *)(a1 + 72);
  uint64_t v21 = *(std::__shared_weak_count **)(a1 + 8);
  __int128 v156 = *(void **)a1;
  unint64_t v157 = v21;
  if (v21)
  {
    uint64_t v22 = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }

  *(_OWORD *)unint64_t v158 = *v19;
  *(_OWORD *)&v158[9] = *(_OWORD *)(a1 + 25);
  __int128 v160 = *(_OWORD *)(a1 + 56);
  __int128 v24 = *(_OWORD *)(a1 + 88);
  __int128 v161 = *v20;
  int64_t v25 = (__int128 *)(a1 + 128);
  uint64_t v159 = *(void *)(a1 + 48);
  __int128 v162 = v24;
  char v163 = *(_BYTE *)(a1 + 104);
  char v26 = *(std::__shared_weak_count **)(a1 + 120);
  uint64_t v164 = *(void *)(a1 + 112);
  unint64_t v165 = v26;
  if (v26)
  {
    unint64_t v27 = (unint64_t *)&v26->__shared_owners_;
    do
      unint64_t v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }

  __int128 v166 = *v25;
  uint64_t v167 = *v6;
  char v168 = *((_BYTE *)v6 + 8);
  sg_vec_ns::generate_vec_ref((uint64_t)&v156, a2, a4[1], v18, 0xFFFFFFFFFFFFFFFFLL, (sg_vec_ref *)&v169);
  size_t v29 = v165;
  if (v165)
  {
    uint64_t v30 = (unint64_t *)&v165->__shared_owners_;
    do
      unint64_t v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

  unint64_t v32 = v157;
  if (v157)
  {
    uint64_t v33 = (unint64_t *)&v157->__shared_owners_;
    do
      unint64_t v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }

  sg_vec_ref::begin((sg_vec_ref *)&v169, (uint64_t)&v218);
  sg_vec_ns::details::sg_vec_iterator::operator=((uint64_t)&v187, (uint64_t)&v218);
  uint64_t v35 = v220;
  if (v220)
  {
    unint64_t v36 = (unint64_t *)&v220->__shared_owners_;
    do
      unint64_t v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }

  uint64_t v38 = v219;
  if (v219)
  {
    uint64_t v39 = (unint64_t *)&v219->__shared_owners_;
    do
      unint64_t v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }

  sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v187, v9);
  sg_vec_ref::end((sg_vec_ref *)&v169, (uint64_t)v153);
  __src = v187;
  uint64_t v143 = v188;
  if (v188)
  {
    unint64_t v41 = (unint64_t *)&v188->__shared_owners_;
    do
      unint64_t v42 = __ldxr(v41);
    while (__stxr(v42 + 1, v41));
  }

  v144[0] = v189[0];
  *(_OWORD *)((char *)v144 + 9) = *(_OWORD *)((char *)v189 + 9);
  v146[0] = v191;
  v146[1] = v192;
  uint64_t v145 = v190;
  _OWORD v146[2] = v193;
  char v147 = v194;
  uint64_t v148 = v195;
  unint64_t v149 = v196;
  if (v196)
  {
    unsigned int v43 = (unint64_t *)&v196->__shared_owners_;
    do
      unint64_t v44 = __ldxr(v43);
    while (__stxr(v44 + 1, v43));
  }

  __int128 v150 = v197;
  uint64_t v151 = v198;
  char v152 = v199;
  uint64_t v46 = *(void **)a1;
  unint64_t v45 = *(std::__shared_weak_count **)(a1 + 8);
  unint64_t v129 = *(void **)a1;
  unint64_t v130 = v45;
  if (v45)
  {
    unint64_t v47 = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v48 = __ldxr(v47);
    while (__stxr(v48 + 1, v47));
  }

  *(_OWORD *)uint64_t v131 = *v19;
  *(_OWORD *)&v131[9] = *(_OWORD *)(a1 + 25);
  __int128 v49 = *v20;
  __int128 v50 = *(_OWORD *)(a1 + 88);
  __int128 v133 = *(_OWORD *)(a1 + 56);
  __int128 v134 = v49;
  uint64_t v132 = *(void *)(a1 + 48);
  __int128 v135 = v50;
  char v136 = *(_BYTE *)(a1 + 104);
  unint64_t v51 = *(std::__shared_weak_count **)(a1 + 120);
  uint64_t v137 = *(void *)(a1 + 112);
  unint64_t v138 = v51;
  if (v51)
  {
    uint64_t v52 = (unint64_t *)&v51->__shared_owners_;
    do
      unint64_t v53 = __ldxr(v52);
    while (__stxr(v53 + 1, v52));
  }

  __int128 v139 = *v25;
  uint64_t v140 = *v6;
  char v141 = *((_BYTE *)v6 + 8);
  __dst = v46;
  __int128 v204 = v130;
  if (v130)
  {
    BOOL v54 = (unint64_t *)&v130->__shared_owners_;
    do
      unint64_t v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }

  *(_OWORD *)__int128 v205 = *(_OWORD *)v131;
  *(_OWORD *)&v205[9] = *(_OWORD *)&v131[9];
  __int128 v207 = v133;
  __int128 v208 = v134;
  uint64_t v206 = v132;
  __int128 v209 = v135;
  char v210 = v136;
  uint64_t v211 = v137;
  unint64_t v212 = v138;
  if (v138)
  {
    uint64_t v56 = (unint64_t *)&v138->__shared_owners_;
    do
      unint64_t v57 = __ldxr(v56);
    while (__stxr(v57 + 1, v56));
  }

  unint64_t v58 = 0LL;
  __int128 v213 = v139;
  uint64_t v214 = v140;
  char v215 = 0;
  while (!sg_vec_ns::details::sg_vec_iterator::operator==((uint64_t)&__src, (uint64_t)v153))
  {
    sg_vec_ns::details::buffer_iterator::sync((sg_vec_ns::details::buffer_iterator *)v146);
    unint64_t v59 = v149;
    uint64_t v200 = v148;
    char v201 = v149;
    if (v149)
    {
      uint64_t v60 = (unint64_t *)&v149->__shared_owners_;
      do
        unint64_t v61 = __ldxr(v60);
      while (__stxr(v61 + 1, v60));
    }

    __int128 v202 = v150;
    if (*((void *)&v150 + 1))
    {
      unint64_t v62 = *(void *)&v205[16];
      if (*(void *)&v144[0] < *(void *)&v205[16]) {
        unint64_t v62 = *(void *)&v144[0];
      }
      if (v62 >= *((void *)&v202 + 1)) {
        int64_t v63 = *((void *)&v202 + 1);
      }
      else {
        int64_t v63 = v62;
      }
      if (v63)
      {
        memmove(__dst, __src, v63);
        if (v63 > 0)
        {
          sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&__src, v63);
          sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&__dst, v63);
          int v64 = 0;
          v58 += v63;
          if (v59) {
            goto LABEL_73;
          }
          goto LABEL_77;
        }
      }

      else
      {
        *(void *)&__int128 v216 = "trim_data(const sg_vec::iterator &, const sg_vec::iterator &, size_t, const io_result_t &)::(anonymous class)::operator()(const auto &, const auto &, size_t) const [src:auto = sg_vec_ns::details::sg_vec_iterator, dst:auto = sg_vec_ns::details::sg_vec_iterator]";
        *((void *)&v216 + 1) = 121LL;
        int v217 = 16;
        di_log::logger<di_log::log_printer<183ul>>::logger(&v218, &v216);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v221,  (uint64_t)"Trimming: Written ",  18LL);
        std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v221,  (uint64_t)", dest buffer_size ",  19LL);
        std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v221, (uint64_t)" src size ", 10LL);
        std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v221, (uint64_t)", trimmed size", 14LL);
        std::ostream::operator<<();
        std::ostream::~ostream();
        di_log::logger_buf<di_log::log_printer<183ul>>::~logger_buf((uint64_t)&v218);
        MEMORY[0x1895BC2CC](v222);
      }

      *(void *)&__int128 v216 = "transform(Fn &&, sg_vec_ref::iterator, const sg_vec_ref::iterator &, sg_vec_ref::iterator) [Fn = (lambda at /Library/Caches/com.apple.xbs/Sources/DiskImages2/app/utils.cpp:180:13)]";
      *((void *)&v216 + 1) = 97LL;
      int v217 = 16;
      di_log::logger<di_log::log_printer<615ul>>::logger(&v218, &v216);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v221,  (uint64_t)"IO error with sg: ",  18LL);
      operator<<(&v221);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v221, (uint64_t)" dest ", 6LL);
      operator<<(&v221);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v221,  (uint64_t)" returned status ",  17LL);
      std::ostream::operator<<();
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<615ul>>::~logger_buf((uint64_t)&v218);
      MEMORY[0x1895BC2CC](v222);
      int v64 = 1;
      if (v59)
      {
LABEL_73:
        unint64_t v65 = (unint64_t *)&v59->__shared_owners_;
        do
          unint64_t v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
          std::__shared_weak_count::__release_weak(v59);
        }
      }
    }

    else
    {
      sg_vec_ns::details::sg_vec_iterator::operator++((uint64_t)&__src);
      int v64 = 2;
      if (v59) {
        goto LABEL_73;
      }
    }

LABEL_77:
    if ((v64 | 2) != 2) {
      goto LABEL_80;
    }
  }

  sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v129, v58);
LABEL_80:
  uint64_t v67 = v212;
  if (v212)
  {
    unint64_t v68 = (unint64_t *)&v212->__shared_owners_;
    do
      unint64_t v69 = __ldaxr(v68);
    while (__stlxr(v69 - 1, v68));
    if (!v69)
    {
      ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
      std::__shared_weak_count::__release_weak(v67);
    }
  }

  unint64_t v70 = v204;
  if (v204)
  {
    unint64_t v71 = (unint64_t *)&v204->__shared_owners_;
    do
      unint64_t v72 = __ldaxr(v71);
    while (__stlxr(v72 - 1, v71));
    if (!v72)
    {
      ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
      std::__shared_weak_count::__release_weak(v70);
    }
  }

  uint64_t v73 = v138;
  if (v138)
  {
    unint64_t v74 = (unint64_t *)&v138->__shared_owners_;
    do
      unint64_t v75 = __ldaxr(v74);
    while (__stlxr(v75 - 1, v74));
    if (!v75)
    {
      ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
      std::__shared_weak_count::__release_weak(v73);
    }
  }

  unint64_t v76 = v130;
  if (v130)
  {
    unint64_t v77 = (unint64_t *)&v130->__shared_owners_;
    do
      unint64_t v78 = __ldaxr(v77);
    while (__stlxr(v78 - 1, v77));
    if (!v78)
    {
      ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
      std::__shared_weak_count::__release_weak(v76);
    }
  }

  uint64_t v79 = v149;
  if (v149)
  {
    unint64_t v80 = (unint64_t *)&v149->__shared_owners_;
    do
      unint64_t v81 = __ldaxr(v80);
    while (__stlxr(v81 - 1, v80));
    if (!v81)
    {
      ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
      std::__shared_weak_count::__release_weak(v79);
    }
  }

  uint64_t v82 = v143;
  if (v143)
  {
    unint64_t v83 = (unint64_t *)&v143->__shared_owners_;
    do
      unint64_t v84 = __ldaxr(v83);
    while (__stlxr(v84 - 1, v83));
    if (!v84)
    {
      ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
      std::__shared_weak_count::__release_weak(v82);
    }
  }

  uint64_t v85 = v155;
  if (v155)
  {
    unint64_t v86 = (unint64_t *)&v155->__shared_owners_;
    do
      unint64_t v87 = __ldaxr(v86);
    while (__stlxr(v87 - 1, v86));
    if (!v87)
    {
      ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
      std::__shared_weak_count::__release_weak(v85);
    }
  }

  unint64_t v88 = v154;
  if (v154)
  {
    unint64_t v89 = (unint64_t *)&v154->__shared_owners_;
    do
      unint64_t v90 = __ldaxr(v89);
    while (__stlxr(v90 - 1, v89));
    if (!v90)
    {
      ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
      std::__shared_weak_count::__release_weak(v88);
    }
  }

  BOOL v91 = v186;
  if (v186)
  {
    unint64_t v92 = (unint64_t *)&v186->__shared_owners_;
    do
      unint64_t v93 = __ldaxr(v92);
    while (__stlxr(v93 - 1, v92));
    if (!v93)
    {
      ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
      std::__shared_weak_count::__release_weak(v91);
    }
  }

  unint64_t v94 = v185;
  if (v185)
  {
    unint64_t v95 = (unint64_t *)&v185->__shared_owners_;
    do
      unint64_t v96 = __ldaxr(v95);
    while (__stlxr(v96 - 1, v95));
    if (!v96)
    {
      ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
      std::__shared_weak_count::__release_weak(v94);
    }
  }

  unint64_t v97 = v184;
  if (v184)
  {
    unint64_t v98 = (unint64_t *)&v184->__shared_owners_;
    do
      unint64_t v99 = __ldaxr(v98);
    while (__stlxr(v99 - 1, v98));
    if (!v99)
    {
      ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
      std::__shared_weak_count::__release_weak(v97);
    }
  }

  uint64_t v100 = v183;
  if (v183)
  {
    unint64_t v101 = (unint64_t *)&v183->__shared_owners_;
    do
      unint64_t v102 = __ldaxr(v101);
    while (__stlxr(v102 - 1, v101));
    if (!v102)
    {
      ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
      std::__shared_weak_count::__release_weak(v100);
    }
  }

  unint64_t v103 = v182;
  if (v182)
  {
    char v104 = (unint64_t *)&v182->__shared_owners_;
    do
      unint64_t v105 = __ldaxr(v104);
    while (__stlxr(v105 - 1, v104));
    if (!v105)
    {
      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
      std::__shared_weak_count::__release_weak(v103);
    }
  }

  unint64_t v106 = (std::__shared_weak_count *)v174;
  if ((void)v174)
  {
    __int128 v107 = (unint64_t *)(v174 + 8);
    do
      unint64_t v108 = __ldaxr(v107);
    while (__stlxr(v108 - 1, v107));
    if (!v108)
    {
      ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
      std::__shared_weak_count::__release_weak(v106);
    }
  }

  unint64_t v109 = v196;
  if (v196)
  {
    uint64_t v110 = (unint64_t *)&v196->__shared_owners_;
    do
      unint64_t v111 = __ldaxr(v110);
    while (__stlxr(v111 - 1, v110));
    if (!v111)
    {
      ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
      std::__shared_weak_count::__release_weak(v109);
    }
  }

  unint64_t v112 = v188;
  if (v188)
  {
    uint64_t v113 = (unint64_t *)&v188->__shared_owners_;
    do
      unint64_t v114 = __ldaxr(v113);
    while (__stlxr(v114 - 1, v113));
    if (!v114)
    {
      ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
      std::__shared_weak_count::__release_weak(v112);
    }
  }

LABEL_160:
  uint64_t v115 = *(std::__shared_weak_count **)(a1 + 8);
  uint64_t v169 = *(void **)a1;
  __int128 v170 = v115;
  if (v115)
  {
    unint64_t v116 = (unint64_t *)&v115->__shared_owners_;
    do
      unint64_t v117 = __ldxr(v116);
    while (__stxr(v117 + 1, v116));
  }

  v171[0] = *(_OWORD *)(a1 + 16);
  *(_OWORD *)((char *)v171 + 9) = *(_OWORD *)(a1 + 25);
  uint64_t v172 = *(void *)(a1 + 48);
  __int128 v173 = *(_OWORD *)(a1 + 56);
  __int128 v174 = *(_OWORD *)(a1 + 72);
  __int128 v175 = *(_OWORD *)(a1 + 88);
  char v176 = *(_BYTE *)(a1 + 104);
  unint64_t v118 = *(std::__shared_weak_count **)(a1 + 120);
  uint64_t v177 = *(void *)(a1 + 112);
  unint64_t v178 = v118;
  if (v118)
  {
    unint64_t v119 = (unint64_t *)&v118->__shared_owners_;
    do
      unint64_t v120 = __ldxr(v119);
    while (__stxr(v120 + 1, v119));
  }

  __int128 v179 = *(_OWORD *)(a1 + 128);
  uint64_t v180 = *v6;
  char v181 = *((_BYTE *)v6 + 8);
  sg_vec_ns::details::sg_vec_iterator::operator+=((uint64_t)&v169, v128);
  sg_vec_ns::details::buffer_iterator::rtrim_written(&v173);
  uint64_t v121 = v178;
  if (v178)
  {
    uint64_t v122 = (unint64_t *)&v178->__shared_owners_;
    do
      unint64_t v123 = __ldaxr(v122);
    while (__stlxr(v123 - 1, v122));
    if (!v123)
    {
      ((void (*)(std::__shared_weak_count *))v121->__on_zero_shared)(v121);
      std::__shared_weak_count::__release_weak(v121);
    }
  }

  unint64_t v124 = v170;
  if (v170)
  {
    uint64_t v125 = (unint64_t *)&v170->__shared_owners_;
    do
      unint64_t v126 = __ldaxr(v125);
    while (__stlxr(v126 - 1, v125));
    if (!v126)
    {
      ((void (*)(std::__shared_weak_count *))v124->__on_zero_shared)(v124);
      std::__shared_weak_count::__release_weak(v124);
    }
  }

  return v128;
}

void sub_18811B74C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
}

unint64_t *boost::algorithm::detail::decode_one<std::__wrap_iter<char const*>,std::back_insert_iterator<std::vector<unsigned char>>,BOOL (*)(std::__wrap_iter<char const*>,std::__wrap_iter<char const*>)>( uint64_t *a1, uint64_t a2, unint64_t *a3, unsigned int (*a4)(uint64_t, uint64_t))
{
  int v7 = 0;
  unint64_t v17 = a3;
  char v16 = 0;
  uint64_t v8 = *a1;
  char v9 = 1;
  do
  {
    char v10 = v9;
    if (a4(v8, a2))
    {
      __int128 v14 = 0u;
      __int128 v15 = 0u;
      DWORD2(v15) = -1;
      v13[0] = off_18A1E4418;
      v13[1] = &unk_18A1E4448;
      boost::throw_exception<boost::algorithm::not_enough_input>(v13);
    }

    int v11 = boost::algorithm::detail::hex_char_to_int<char>(*(char *)*a1);
    char v9 = 0;
    int v7 = v11 + 16 * v7;
    char v16 = v7;
    uint64_t v8 = *a1 + 1;
    *a1 = v8;
  }

  while ((v10 & 1) != 0);
  std::back_insert_iterator<std::vector<unsigned char>>::operator=[abi:ne180100](&v17, &v16);
  return v17;
}

void sub_18811B944( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::exception a13, void *a14, uint64_t a15)
{
  a14 = &unk_18A1E4468;
  if (a15) {
    (*(void (**)(uint64_t))(*(void *)a15 + 32LL))(a15);
  }
  _Unwind_Resume(a1);
}

BOOL boost::algorithm::detail::iter_end<std::__wrap_iter<char const*>>(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

void boost::throw_exception<boost::algorithm::not_enough_input>(void *a1)
{
  exception = __cxa_allocate_exception(0x30uLL);
  boost::algorithm::not_enough_input::not_enough_input((uint64_t)exception, a1);
}

void sub_18811B9C8(_Unwind_Exception *a1)
{
}

void boost::algorithm::not_enough_input::~not_enough_input(std::exception *this)
{
  *(void *)(v1 + 8) = &unk_18A1E4468;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(v1 + 16));
}

{
  uint64_t v2;
  std::exception::~exception(this);
  *(void *)(v2 + 8) = &unk_18A1E4468;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(v2 + 16));
  operator delete(this);
}

uint64_t boost::algorithm::detail::hex_char_to_int<char>(int a1)
{
  unsigned __int8 v1 = a1 - 48;
  if ((a1 - 48) >= 0xA)
  {
    if ((a1 - 65) > 5)
    {
      if ((a1 - 97) > 5)
      {
        __int128 v7 = 0u;
        __int128 v8 = 0u;
        DWORD2(v8) = -1;
        v6[0] = off_18A1E44B0;
        v6[1] = &unk_18A1E44E0;
        int v4 = off_18A1E4528;
        char v5 = a1;
        __int128 v3 = (const boost::algorithm::non_hex_input *)boost::exception_detail::set_info_rv<boost::error_info<boost::algorithm::bad_char_,char>>::set<boost::algorithm::non_hex_input>( v6,  (uint64_t)&v4);
        boost::throw_exception<boost::algorithm::non_hex_input>(v3);
      }

      return (a1 - 87);
    }

    else
    {
      return (a1 - 55);
    }
  }

  return v1;
}

void sub_18811BAD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::exception a15, void *a16, uint64_t a17)
{
  a16 = &unk_18A1E4468;
  if (a17) {
    (*(void (**)(uint64_t))(*(void *)a17 + 32LL))(a17);
  }
  _Unwind_Resume(a1);
}

unint64_t **std::back_insert_iterator<std::vector<unsigned char>>::operator=[abi:ne180100]( unint64_t **a1, _BYTE *a2)
{
  int v4 = *a1;
  uint64_t v6 = (_BYTE *)(*a1)[1];
  unint64_t v5 = (*a1)[2];
  if ((unint64_t)v6 >= v5)
  {
    unint64_t v8 = *v4;
    char v9 = &v6[-*v4];
    unint64_t v10 = (unint64_t)(v9 + 1);
    unint64_t v11 = v5 - v8;
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v12 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v12 = v10;
    }
    if (v12) {
      unint64_t v13 = (unint64_t)operator new(v12);
    }
    else {
      unint64_t v13 = 0LL;
    }
    __int128 v14 = (char *)(v13 + v12);
    v9[v13] = *a2;
    uint64_t v7 = (uint64_t)&v9[v13 + 1];
    if (v6 == (_BYTE *)v8)
    {
      v13 += (unint64_t)v9;
    }

    else
    {
      __int128 v15 = &v6[~v8];
      do
      {
        char v16 = *--v6;
        (v15--)[v13] = v16;
      }

      while (v6 != (_BYTE *)v8);
      uint64_t v6 = (_BYTE *)*v4;
    }

    *int v4 = v13;
    v4[1] = v7;
    void v4[2] = (unint64_t)v14;
    if (v6) {
      operator delete(v6);
    }
  }

  else
  {
    *uint64_t v6 = *a2;
    uint64_t v7 = (uint64_t)(v6 + 1);
  }

  v4[1] = v7;
  return a1;
}

uint64_t boost::algorithm::not_enough_input::not_enough_input(uint64_t a1, void *a2)
{
  __int128 v3 = (char *)a2 + *(void *)(*a2 - 40LL);
  uint64_t v4 = *((void *)v3 + 1);
  *(void *)(a1 + 8) = &unk_18A1E4468;
  *(void *)(a1 + 16) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  }
  __int128 v5 = *((_OWORD *)v3 + 1);
  *(_DWORD *)(a1 + 40) = *((_DWORD *)v3 + 8);
  *(_OWORD *)(a1 + 24) = v5;
  *(void *)a1 = off_18A1E4418;
  *(void *)(a1 + 8) = &unk_18A1E4448;
  return a1;
}

void virtual thunk to'boost::algorithm::not_enough_input::~not_enough_input( boost::algorithm::not_enough_input *this)
{
  *(void *)(v1 + 8) = &unk_18A1E4468;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(v1 + 16));
}

{
  char *v1;
  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 24LL);
  std::exception::~exception((std::exception *)v1);
  *((void *)v1 + 1) = &unk_18A1E4468;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)v1 + 2);
  operator delete(v1);
}

uint64_t *boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr( uint64_t *a1)
{
  uint64_t v2 = *a1;
  return a1;
}

void boost::throw_exception<boost::algorithm::non_hex_input>( const boost::algorithm::non_hex_input *a1)
{
  exception = (boost::algorithm::non_hex_input *)__cxa_allocate_exception(0x30uLL);
  boost::algorithm::non_hex_input::non_hex_input(exception, a1);
}

void sub_18811BDBC(_Unwind_Exception *a1)
{
}

void boost::algorithm::non_hex_input::~non_hex_input(std::exception *this)
{
  *(void *)(v1 + 8) = &unk_18A1E4468;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(v1 + 16));
}

{
  uint64_t v2;
  std::exception::~exception(this);
  *(void *)(v2 + 8) = &unk_18A1E4468;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(v2 + 16));
  operator delete(this);
}

boost::algorithm::non_hex_input *boost::algorithm::non_hex_input::non_hex_input( boost::algorithm::non_hex_input *this, const boost::algorithm::non_hex_input *a2)
{
  __int128 v3 = (char *)a2 + *(void *)(*(void *)a2 - 40LL);
  uint64_t v4 = *((void *)v3 + 1);
  *((void *)this + 1) = &unk_18A1E4468;
  *((void *)this + 2) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  }
  __int128 v5 = *((_OWORD *)v3 + 1);
  *((_DWORD *)this + 10) = *((_DWORD *)v3 + 8);
  *(_OWORD *)((char *)this + 24) = v5;
  *(void *)this = off_18A1E44B0;
  *((void *)this + 1) = &unk_18A1E44E0;
  return this;
}

void virtual thunk to'boost::algorithm::non_hex_input::~non_hex_input( boost::algorithm::non_hex_input *this)
{
  *(void *)(v1 + 8) = &unk_18A1E4468;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(v1 + 16));
}

{
  char *v1;
  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 24LL);
  std::exception::~exception((std::exception *)v1);
  *((void *)v1 + 1) = &unk_18A1E4468;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)v1 + 2);
  operator delete(v1);
}

void *boost::exception_detail::set_info_rv<boost::error_info<boost::algorithm::bad_char_,char>>::set<boost::algorithm::non_hex_input>( void *a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x10uLL);
  *(void *)uint64_t v4 = off_18A1E4528;
  v4[8] = *(_BYTE *)(a2 + 8);
  int64_t v20 = v4;
  __int128 v5 = (std::__shared_weak_count *)operator new(0x20uLL);
  v5->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  v5->__vftable = (std::__shared_weak_count_vtbl *)off_18A1E4558;
  v5->__shared_weak_owners_ = 0LL;
  v5[1].__vftable = (std::__shared_weak_count_vtbl *)v4;
  uint64_t v21 = v5;
  uint64_t v7 = (char *)a1 + *(void *)(*a1 - 40LL);
  unint64_t v8 = (void *)*((void *)v7 + 1);
  if (!v8)
  {
    unint64_t v8 = operator new(0x40uLL);
    void v8[3] = 0LL;
    v8[4] = 0LL;
    v8[2] = 0LL;
    *unint64_t v8 = &off_18A1E45D0;
    v8[1] = v8 + 2;
    v8[5] = 0LL;
    v8[6] = 0LL;
    *((void *)v7 + 1) = v8;
    *((_DWORD *)v8 + 14) = 1;
  }

  unint64_t v18 = v4;
  CFDataRef v19 = v5;
  do
    unint64_t v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  (*(void (**)(void *, _BYTE **, void **))(*v8 + 16LL))(v8, &v18, &v17);
  unint64_t v10 = v19;
  if (v19)
  {
    unint64_t v11 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  unint64_t v13 = v21;
  if (v21)
  {
    __int128 v14 = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  return a1;
}

void sub_18811C0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

_BYTE *boost::error_info<boost::algorithm::bad_char_,char>::clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = off_18A1E4528;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

void boost::to_string<boost::algorithm::bad_char_,char>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (__p[0]) {
    uint64_t v4 = (char *)__p[0];
  }
  else {
    uint64_t v4 = (char *)((unint64_t)"PN5boost9algorithm9bad_char_E" & 0x7FFFFFFFFFFFFFFFLL);
  }
  std::string::basic_string[abi:ne180100]<0>(&v14, v4);
  free(__p[0]);
  if ((v14.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    v5.__i_ = (std::__wrap_iter<const char *>::iterator_type)&v14;
  }
  else {
    v5.__i_ = (std::__wrap_iter<const char *>::iterator_type)v14.__r_.__value_.__r.__words[0];
  }
  std::string::insert(&v14, v5, 91);
  std::string v15 = v14;
  memset(&v14, 0, sizeof(v14));
  uint64_t v6 = std::string::append(&v15, "] = ", 4uLL);
  __int128 v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__l.__cap_ = v6->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0LL;
  v6->__r_.__value_.__l.__cap_ = 0LL;
  v6->__r_.__value_.__r.__words[0] = 0LL;
  boost::to_string<char>((char *)(a1 + 8), __p);
  if ((v13 & 0x80u) == 0) {
    unint64_t v8 = __p;
  }
  else {
    unint64_t v8 = (void **)__p[0];
  }
  if ((v13 & 0x80u) == 0) {
    std::string::size_type v9 = v13;
  }
  else {
    std::string::size_type v9 = (std::string::size_type)__p[1];
  }
  unint64_t v10 = std::string::append(&v16, (const std::string::value_type *)v8, v9);
  __int128 v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v17.__r_.__value_.__l.__cap_ = v10->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0LL;
  v10->__r_.__value_.__l.__cap_ = 0LL;
  v10->__r_.__value_.__r.__words[0] = 0LL;
  std::string::push_back(&v17, 10);
  *a2 = v17;
  memset(&v17, 0, sizeof(v17));
}

void sub_18811C290( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

boost::core::scoped_demangled_name *boost::core::scoped_demangled_name::scoped_demangled_name( boost::core::scoped_demangled_name *this, const char *lpmangled)
{
  int status = 0;
  size_t v4 = 0LL;
  *(void *)this = __cxa_demangle(lpmangled, 0LL, &v4, &status);
  return this;
}

uint64_t boost::to_string<char>@<X0>(char *a1@<X0>, void *a2@<X8>)
{
  char v9 = *a1;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v5, (uint64_t)&v9, 1LL);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v6, a2);
  uint64_t v5 = *MEMORY[0x189614738];
  *(void *)((char *)&v6[-1] + *(void *)(v5 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(MEMORY[0x189614738] + 24LL);
  v6[0] = MEMORY[0x189614750] + 16LL;
  if (v7 < 0) {
    operator delete((void *)v6[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1895BC2CC](&v8);
}

void sub_18811C42C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__shared_ptr_pointer<boost::error_info<boost::algorithm::bad_char_,char> *,std::shared_ptr<boost::error_info<boost::algorithm::bad_char_,char>>::__shared_ptr_default_delete<boost::error_info<boost::algorithm::bad_char_,char>,boost::error_info<boost::algorithm::bad_char_,char>>,std::allocator<boost::error_info<boost::algorithm::bad_char_,char>>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<boost::error_info<boost::algorithm::bad_char_,char> *,std::shared_ptr<boost::error_info<boost::algorithm::bad_char_,char>>::__shared_ptr_default_delete<boost::error_info<boost::algorithm::bad_char_,char>,boost::error_info<boost::algorithm::bad_char_,char>>,std::allocator<boost::error_info<boost::algorithm::bad_char_,char>>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<boost::error_info<boost::algorithm::bad_char_,char> *,std::shared_ptr<boost::error_info<boost::algorithm::bad_char_,char>>::__shared_ptr_default_delete<boost::error_info<boost::algorithm::bad_char_,char>,boost::error_info<boost::algorithm::bad_char_,char>>,std::allocator<boost::error_info<boost::algorithm::bad_char_,char>>>::__get_deleter( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

uint64_t boost::exception_detail::error_info_container_impl::diagnostic_information( boost::exception_detail::error_info_container_impl *this, const char *a2)
{
  if (a2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v16);
    size_t v4 = strlen(a2);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v16, (uint64_t)a2, v4);
    uint64_t v5 = (boost::exception_detail::error_info_container_impl *)*((void *)this + 1);
    if (v5 != (boost::exception_detail::error_info_container_impl *)((char *)this + 16))
    {
      do
      {
        (***((void (****)(void **__return_ptr))v5 + 5))(__p);
        if (v15 >= 0) {
          uint64_t v6 = __p;
        }
        else {
          uint64_t v6 = (void **)__p[0];
        }
        if (v15 >= 0) {
          uint64_t v7 = HIBYTE(v15);
        }
        else {
          uint64_t v7 = (uint64_t)__p[1];
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v16, (uint64_t)v6, v7);
        if (SHIBYTE(v15) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v8 = (boost::exception_detail::error_info_container_impl *)*((void *)v5 + 1);
        if (v8)
        {
          do
          {
            char v9 = v8;
            uint64_t v8 = *(boost::exception_detail::error_info_container_impl **)v8;
          }

          while (v8);
        }

        else
        {
          do
          {
            char v9 = (boost::exception_detail::error_info_container_impl *)*((void *)v5 + 2);
            BOOL v10 = *(void *)v9 == (void)v5;
            uint64_t v5 = v9;
          }

          while (!v10);
        }

        uint64_t v5 = v9;
      }

      while (v9 != (boost::exception_detail::error_info_container_impl *)((char *)this + 16));
    }

    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v17, __p);
    uint64_t v11 = v15;
    __int128 v12 = *(_OWORD *)__p;
    *(_OWORD *)__p = *((_OWORD *)this + 2);
    uint64_t v15 = *((void *)this + 6);
    *((_OWORD *)this + 2) = v12;
    *((void *)this + 6) = v11;
    if (SHIBYTE(v15) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v16 = *MEMORY[0x189614738];
    *(void *)((char *)&v17[-1] + *(void *)(v16 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(MEMORY[0x189614738] + 24LL);
    v17[0] = MEMORY[0x189614750] + 16LL;
    if (v18 < 0) {
      operator delete((void *)v17[8]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x1895BC2CC](&v19);
  }

  uint64_t result = (uint64_t)this + 32;
  return result;
}

void sub_18811C650( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

void *boost::exception_detail::error_info_container_impl::get@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t result = std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::find<boost::exception_detail::type_info_>( a1 + 8,  a2);
  if ((void *)(a1 + 16) == result)
  {
    *a3 = 0LL;
    a3[1] = 0LL;
  }

  else
  {
    uint64_t v6 = result[6];
    *a3 = result[5];
    a3[1] = v6;
    if (v6)
    {
      uint64_t v7 = (unint64_t *)(v6 + 8);
      do
        unint64_t v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
  }

  return result;
}

void *boost::exception_detail::error_info_container_impl::set(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v7 = a3;
  uint64_t v5 = std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::__emplace_unique_key_args<boost::exception_detail::type_info_,std::piecewise_construct_t const&,std::tuple<boost::exception_detail::type_info_ const&>,std::tuple<>>( (uint64_t **)(a1 + 8),  a3,  (uint64_t)&std::piecewise_construct,  &v7);
  uint64_t result = std::shared_ptr<DiskImage>::operator=[abi:ne180100](v5 + 5, a2);
  if (*(char *)(a1 + 55) < 0)
  {
    **(_BYTE **)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0LL;
  }

  else
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 55) = 0;
  }

  return result;
}

uint64_t boost::exception_detail::error_info_container_impl::add_ref(uint64_t this)
{
  return this;
}

BOOL boost::exception_detail::error_info_container_impl::release( boost::exception_detail::error_info_container_impl *this)
{
  int v1 = *((_DWORD *)this + 14) - 1;
  *((_DWORD *)this + 14) = v1;
  if (this && !v1)
  {
    boost::exception_detail::error_info_container_impl::~error_info_container_impl((void **)this);
    operator delete(v2);
  }

  return v1 == 0;
}

void boost::exception_detail::error_info_container_impl::clone( boost::exception_detail::error_info_container_impl *this@<X0>, void *a2@<X8>)
{
  *a2 = 0LL;
  size_t v4 = (char *)operator new(0x40uLL);
  *(void *)size_t v4 = &off_18A1E45D0;
  *((void *)v4 + 2) = 0LL;
  *((void *)v4 + 1) = v4 + 16;
  uint64_t v5 = (uint64_t **)(v4 + 8);
  *((void *)v4 + 3) = 0LL;
  *((void *)v4 + 4) = 0LL;
  *((void *)v4 + 5) = 0LL;
  *((void *)v4 + 6) = 0LL;
  *a2 = v4;
  *((_DWORD *)v4 + 14) = 1;
  uint64_t v6 = (boost::exception_detail::error_info_container_impl *)*((void *)this + 1);
  if (v6 != (boost::exception_detail::error_info_container_impl *)((char *)this + 16))
  {
    do
    {
      uint64_t v7 = (*(uint64_t (**)(void))(**((void **)v6 + 5) + 8LL))(*((void *)v6 + 5));
      std::shared_ptr<boost::exception_detail::error_info_base>::shared_ptr[abi:ne180100]<boost::exception_detail::error_info_base,void>( &v21,  v7);
      v19[0] = *((void *)v6 + 4);
      v19[1] = v21;
      int64_t v20 = v22;
      if (v22)
      {
        p_shared_owners = (unint64_t *)&v22->__shared_owners_;
        do
          unint64_t v9 = __ldxr(p_shared_owners);
        while (__stxr(v9 + 1, p_shared_owners));
      }

      std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::__emplace_unique_key_args<boost::exception_detail::type_info_,std::pair<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>( v5,  v19,  (uint64_t)v19);
      BOOL v10 = v20;
      if (v20)
      {
        uint64_t v11 = (unint64_t *)&v20->__shared_owners_;
        do
          unint64_t v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }

      unsigned __int8 v13 = v22;
      if (v22)
      {
        std::string v14 = (unint64_t *)&v22->__shared_owners_;
        do
          unint64_t v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }

      uint64_t v16 = (boost::exception_detail::error_info_container_impl *)*((void *)v6 + 1);
      if (v16)
      {
        do
        {
          std::string v17 = v16;
          uint64_t v16 = *(boost::exception_detail::error_info_container_impl **)v16;
        }

        while (v16);
      }

      else
      {
        do
        {
          std::string v17 = (boost::exception_detail::error_info_container_impl *)*((void *)v6 + 2);
          BOOL v18 = *(void *)v17 == (void)v6;
          uint64_t v6 = v17;
        }

        while (!v18);
      }

      uint64_t v6 = v17;
    }

    while (v17 != (boost::exception_detail::error_info_container_impl *)((char *)this + 16));
  }

void sub_18811C92C(_Unwind_Exception *a1)
{
}

void *std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::find<boost::exception_detail::type_info_>( uint64_t a1, uint64_t *a2)
{
  __int128 v3 = (void *)(a1 + 8);
  size_t v4 = std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::__lower_bound<boost::exception_detail::type_info_>( a1,  a2,  *(void **)(a1 + 8),  (void *)(a1 + 8));
  if (v3 == v4) {
    return v3;
  }
  uint64_t v5 = v4;
  uint64_t v6 = v4[4];
  if (*a2 != v6
    && strcmp( (const char *)(*(void *)(*a2 + 8) & 0x7FFFFFFFFFFFFFFFLL),  (const char *)(*(void *)(v6 + 8) & 0x7FFFFFFFFFFFFFFFLL)) < 0)
  {
    return v3;
  }

  return v5;
}

void *std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::__lower_bound<boost::exception_detail::type_info_>( uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    uint64_t v6 = *a2;
    do
    {
      uint64_t v7 = v5[4];
      if (v7 == v6)
      {
        a4 = v5;
      }

      else if (strcmp( (const char *)(*(void *)(v7 + 8) & 0x7FFFFFFFFFFFFFFFLL),  (const char *)(*(void *)(v6 + 8) & 0x7FFFFFFFFFFFFFFFLL)) < 0)
      {
        ++v5;
      }

      else
      {
        a4 = v5;
      }

      uint64_t v5 = (void *)*v5;
    }

    while (v5);
  }

  return a4;
}

uint64_t *std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::__emplace_unique_key_args<boost::exception_detail::type_info_,std::piecewise_construct_t const&,std::tuple<boost::exception_detail::type_info_ const&>,std::tuple<>>( uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::__find_equal<boost::exception_detail::type_info_>( (uint64_t)a1,  &v12,  a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    unint64_t v8 = v6;
    uint64_t v7 = (uint64_t *)operator new(0x38uLL);
    v10[1] = a1 + 1;
    v7[4] = **a4;
    v7[5] = 0LL;
    void v7[6] = 0LL;
    char v11 = 1;
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  v12,  v8,  v7);
    v10[0] = 0LL;
    std::unique_ptr<std::__tree_node<std::__value_type<udif::run_type,std::shared_ptr<Backend>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<udif::run_type,std::shared_ptr<Backend>>,void *>>>>::reset[abi:ne180100]( (uint64_t)v10,  0LL);
  }

  return v7;
}

void *std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::__find_equal<boost::exception_detail::type_info_>( uint64_t a1, void *a2, uint64_t *a3)
{
  size_t v4 = (void *)(a1 + 8);
  uint64_t v5 = *(void **)(a1 + 8);
  if (v5)
  {
    uint64_t v6 = *a3;
    uint64_t v7 = v5[4];
    if (*a3 != v7)
    {
      unint64_t v8 = (const char *)(*(void *)(v6 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      do
      {
        unint64_t v9 = (const char *)(*(void *)(v7 + 8) & 0x7FFFFFFFFFFFFFFFLL);
        if (strcmp(v8, v9) < 0)
        {
          BOOL v10 = (void *)*v5;
          size_t v4 = v5;
          if (!*v5) {
            break;
          }
        }

        else
        {
          if ((strcmp(v9, v8) & 0x80000000) == 0) {
            break;
          }
          size_t v4 = v5 + 1;
          BOOL v10 = (void *)v5[1];
          if (!v10) {
            break;
          }
        }

        uint64_t v7 = v10[4];
        uint64_t v5 = v10;
      }

      while (v6 != v7);
    }
  }

  else
  {
    uint64_t v5 = (void *)(a1 + 8);
  }

  *a2 = v5;
  return v4;
}

void boost::exception_detail::error_info_container_impl::~error_info_container_impl(void **this)
{
}

void *std::shared_ptr<boost::exception_detail::error_info_base>::shared_ptr[abi:ne180100]<boost::exception_detail::error_info_base,void>( void *a1, uint64_t a2)
{
  *a1 = a2;
  size_t v4 = operator new(0x20uLL);
  *size_t v4 = off_18A1E4638;
  v4[1] = 0LL;
  void v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_18811CC24(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<boost::exception_detail::error_info_base *,std::shared_ptr<boost::exception_detail::error_info_base>::__shared_ptr_default_delete<boost::exception_detail::error_info_base,boost::exception_detail::error_info_base>,std::allocator<boost::exception_detail::error_info_base>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<boost::exception_detail::error_info_base *,std::shared_ptr<boost::exception_detail::error_info_base>::__shared_ptr_default_delete<boost::exception_detail::error_info_base,boost::exception_detail::error_info_base>,std::allocator<boost::exception_detail::error_info_base>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<boost::exception_detail::error_info_base *,std::shared_ptr<boost::exception_detail::error_info_base>::__shared_ptr_default_delete<boost::exception_detail::error_info_base,boost::exception_detail::error_info_base>,std::allocator<boost::exception_detail::error_info_base>>::__get_deleter( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

char *std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::__emplace_unique_key_args<boost::exception_detail::type_info_,std::pair<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>( uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = (void **)std::__tree<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::__map_value_compare<boost::exception_detail::type_info_,std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>,std::less<boost::exception_detail::type_info_>,true>,std::allocator<std::__value_type<boost::exception_detail::type_info_,std::shared_ptr<boost::exception_detail::error_info_base>>>>::__find_equal<boost::exception_detail::type_info_>( (uint64_t)a1,  &v11,  a2);
  uint64_t v6 = (char *)*v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    uint64_t v6 = (char *)operator new(0x38uLL);
    v9[1] = a1 + 1;
    *((void *)v6 + 4) = *(void *)a3;
    *(_OWORD *)(v6 + 40) = *(_OWORD *)(a3 + 8);
    *(void *)(a3 + 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    char v10 = 1;
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  v11,  v7,  (uint64_t *)v6);
    v9[0] = 0LL;
    std::unique_ptr<std::__tree_node<std::__value_type<udif::run_type,std::shared_ptr<Backend>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<udif::run_type,std::shared_ptr<Backend>>,void *>>>>::reset[abi:ne180100]( (uint64_t)v9,  0LL);
  }

  return v6;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<details::get_dummy_shared_ptr(void)::$_0 &&>>()
{
  unsigned __int8 v0 = operator new(1uLL);
  std::shared_ptr<char>::shared_ptr[abi:ne180100]<char,void>(&v4, (uint64_t)v0);
  std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100]( (uint64_t)&details::get_dummy_shared_ptr(void)::dummy_shared_ptr,  &v4);
  uint64_t v1 = (std::__shared_weak_count *)*((void *)&v4 + 1);
  if (*((void *)&v4 + 1))
  {
    uint64_t v2 = (unint64_t *)(*((void *)&v4 + 1) + 8LL);
    do
      unint64_t v3 = __ldaxr(v2);
    while (__stlxr(v3 - 1, v2));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

void *std::shared_ptr<char>::shared_ptr[abi:ne180100]<char,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  __int128 v4 = operator new(0x20uLL);
  *__int128 v4 = &unk_18A1E46B0;
  v4[1] = 0LL;
  void v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_18811CE2C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<char *,std::shared_ptr<char>::__shared_ptr_default_delete<char,char>,std::allocator<char>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<char *,std::shared_ptr<char>::__shared_ptr_default_delete<char,char>,std::allocator<char>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t std::__shared_ptr_pointer<char *,std::shared_ptr<char>::__shared_ptr_default_delete<char,char>,std::allocator<char>>::__get_deleter( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *di_log::logger<di_log::log_printer<183ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<183ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E4730;
  a1[45] = &unk_18A1E4830;
  a1[46] = &unk_18A1E4858;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E4730;
  a1[45] = &unk_18A1E47B8;
  a1[46] = &unk_18A1E47E0;
  return a1;
}

void sub_18811CF30(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<183ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<183ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E48C8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18811CFFC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<183ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E48C8;
  di_log::logger_buf<di_log::log_printer<183ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<183ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<183ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<183ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<183ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<183ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<183ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<183ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<183ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<183ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<183ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<183ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<183ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<183ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18811D3B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<183ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 183LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      char v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        std::string v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 183LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

BOOL lock_free::bitmap_t::update_pair_element( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  unint64_t v5 = a4 - a3 + 2;
  uint64_t v6 = ~(-1LL << v5) << a3;
  if (a4 - a3 == 62) {
    uint64_t v6 = -1LL;
  }
  int v7 = *a5;
  int v8 = a5[1];
  if (v7 != v8)
  {
    if ((unint64_t)(a4 - a3) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v12 = 0LL;
      unint64_t v13 = v5 >> 1;
      uint64_t v14 = v7 | (2 * v8);
      do
      {
        uint64_t v12 = v14 | (4 * v12);
        --v13;
      }

      while (v13);
    }

    else
    {
      uint64_t v12 = 0LL;
    }

    uint64_t v15 = v12 << a3;
    uint64_t v16 = (unint64_t *)(*(void *)(a1 + 8) + 8 * a2);
    unint64_t v17 = *v16;
    unint64_t v18 = *v16 & ~v6 | v15;
    unint64_t v19 = __ldaxr(v16);
    if (v19 == v17)
    {
      if (!__stlxr(v18, v16))
      {
LABEL_21:
        BOOL v11 = v17 == v18;
        return !v11;
      }
    }

    else
    {
      __clrex();
    }

    uint64_t v20 = ~v6;
    do
    {
      while (1)
      {
        unint64_t v17 = v19;
        uint64_t v21 = (unint64_t *)(*(void *)(a1 + 8) + 8 * a2);
        unint64_t v18 = v19 & v20 | v15;
        unint64_t v19 = __ldaxr(v21);
        if (v19 == v17) {
          break;
        }
        __clrex();
      }
    }

    while (__stlxr(v18, v21));
    goto LABEL_21;
  }

  unint64_t v9 = (unint64_t *)(*(void *)(a1 + 8) + 8 * a2);
  if (*a5)
  {
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 | v6, v9));
    BOOL v11 = (v6 & ~v10) == 0;
  }

  else
  {
    do
      unint64_t v22 = __ldaxr(v9);
    while (__stlxr(v22 & ~v6, v9));
    BOOL v11 = (v22 & v6) == 0;
  }

  return !v11;
}

unint64_t lock_free::first_pair_match( unint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  unint64_t v4 = a3 - a2 + 2;
  if ((unint64_t)(a3 - a2) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = v4 >> 1;
    do
    {
      uint64_t v5 = *a4 | (2LL * a4[1]) | (4 * v5);
      --v6;
    }

    while (v6);
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  if (a3 - a2 == 62) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = ~(-1LL << v4) << a2;
  }
  unint64_t v9 = ((v5 << a2) ^ v7 & a1 | (((v5 << a2) ^ v7 & a1) >> 1)) & 0x5555555555555555LL;
  BOOL v8 = v9 == 0;
  unint64_t v10 = __clz(__rbit64(v9));
  if (v8) {
    return a3 + 2;
  }
  else {
    return v10;
  }
}

unint64_t lock_free::first_pair_mismatch( unint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  unint64_t v4 = a3 - a2 + 2;
  if ((unint64_t)(a3 - a2) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = v4 >> 1;
    do
    {
      uint64_t v5 = *a4 | (2LL * a4[1]) | (4 * v5);
      --v6;
    }

    while (v6);
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  if (a3 - a2 == 62) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = ~(-1LL << v4) << a2;
  }
  unint64_t v9 = v7 & ~((v5 << a2) ^ a1) & ((v7 & ~((v5 << a2) ^ a1)) >> 1) & 0x5555555555555555LL;
  BOOL v8 = v9 == 0;
  unint64_t v10 = __clz(__rbit64(v9));
  if (v8) {
    return a3 + 2;
  }
  else {
    return v10;
  }
}

uint64_t lock_free::bitmap_t::update_bits( lock_free::bitmap_t *this, unint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a2 > a3 || *((void *)this + 2) <= a3)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v26);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"invalid bits range ", 19LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"-", 1LL);
    std::ostream::operator<<();
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v26, 0x16u);
  }

  unint64_t v4 = a2 >> 6;
  uint64_t v5 = a2 & 0x3F;
  uint64_t v6 = a3 & 0x3F;
  if (a2 >> 6 == a3 >> 6)
  {
    uint64_t v7 = v6 - v5 + 1;
    uint64_t v8 = ~(-1LL << v7) << v5;
    if (v7 == 64) {
      uint64_t v9 = -1LL;
    }
    else {
      uint64_t v9 = v8;
    }
    unint64_t v10 = (unint64_t *)(*((void *)this + 1) + 8 * v4);
    if ((_DWORD)a4)
    {
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 | v9, v10));
      uint64_t v5 = v9;
    }

    else
    {
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 & ~v9, v10));
      uint64_t v5 = 0LL;
    }

    LOBYTE(v5) = (v11 & v9) != v5;
  }

  else
  {
    unint64_t v12 = a3 >> 6;
    if ((a2 & 0x3F) != 0)
    {
      uint64_t v5 = ~(-1LL << -(char)v5) << v5;
      unint64_t v13 = (unint64_t *)(*((void *)this + 1) + 8 * v4);
      if ((_DWORD)a4)
      {
        do
          unint64_t v14 = __ldaxr(v13);
        while (__stlxr(v14 | v5, v13));
        uint64_t v15 = v5;
      }

      else
      {
        do
          unint64_t v14 = __ldaxr(v13);
        while (__stlxr(v14 & ~v5, v13));
        uint64_t v15 = 0LL;
      }

      LOBYTE(v5) = (v14 & v5) != v15;
      ++v4;
    }

    if (v6 != 63)
    {
      uint64_t v16 = -2LL << v6;
      uint64_t v17 = ~(-2LL << v6);
      unint64_t v18 = (unint64_t *)(*((void *)this + 1) + 8 * v12);
      if ((a4 & 1) != 0)
      {
        do
          unint64_t v19 = __ldaxr(v18);
        while (__stlxr(v19 | v17, v18));
        uint64_t v20 = v17;
      }

      else
      {
        do
          unint64_t v19 = __ldaxr(v18);
        while (__stlxr(v19 & v16, v18));
        uint64_t v20 = 0LL;
      }

      if ((v19 & v17) != v20) {
        LOBYTE(v5) = 1;
      }
      --v12;
    }

    if (v4 <= v12)
    {
      unint64_t v21 = a4 << 63 >> 63;
      do
      {
        unint64_t v22 = (unint64_t *)(*((void *)this + 1) + 8 * v4);
        do
          unint64_t v23 = __ldxr(v22);
        while (__stxr(v21, v22));
        LOBYTE(v5) = (v23 != v21) | v5;
        ++v4;
      }

      while (v4 <= v12);
    }
  }

  return v5 & 1;
}

void sub_18811DA1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL lock_free::bitmap_t::update_pair_bits( uint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4)
{
  if (a3 <= a2 || *(void *)(a1 + 16) < a3 || (((_DWORD)a3 - (_DWORD)a2) & 1) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v18);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"invalid bits range ", 19LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"-", 1LL);
    std::ostream::operator<<();
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v18, 0x16u);
  }

  unint64_t v6 = a3 - 2;
  unint64_t v7 = a2 >> 6;
  uint64_t v8 = a2 & 0x3F;
  unint64_t v9 = v6 & 0x3F;
  if (a2 >> 6 == v6 >> 6) {
    return lock_free::bitmap_t::update_pair_element(a1, a2 >> 6, v8, v6 & 0x3F, a4);
  }
  unint64_t v11 = v6 >> 6;
  uint64_t v12 = (a2 & 0x3F) != 0 && lock_free::bitmap_t::update_pair_element(a1, v7++, v8, 62LL, a4);
  if (v9 <= 0x3D) {
    uint64_t v12 = lock_free::bitmap_t::update_pair_element(a1, v11--, 0LL, v9, a4) | v12;
  }
  unint64_t v13 = 0LL;
  uint64_t v14 = 32LL;
  do
  {
    unint64_t v13 = *a4 | (2LL * a4[1]) | (4 * v13);
    --v14;
  }

  while (v14);
  while (v7 <= v11)
  {
    uint64_t v15 = (unint64_t *)(*(void *)(a1 + 8) + 8 * v7);
    if ((v12 & 1) != 0)
    {
      *uint64_t v15 = v13;
      uint64_t v12 = 1LL;
    }

    else
    {
      do
        unint64_t v16 = __ldxr(v15);
      while (__stxr(v13, v15));
      uint64_t v12 = v16 != v13;
    }

    ++v7;
  }

  return v12;
}

void sub_18811DC2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

unint64_t lock_free::bitmap_t::find_match_bits( uint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4)
{
  unint64_t v4 = a3;
  if (a3 <= a2 || *(void *)(a1 + 16) < a3 || (((_DWORD)a3 - (_DWORD)a2) & 1) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v26);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"invalid bits range ", 19LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"-", 1LL);
    std::ostream::operator<<();
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v26, 0x16u);
  }

  unint64_t v8 = a3 - 2;
  unint64_t v9 = a2 >> 6;
  uint64_t v10 = a2 & 0x3F;
  unint64_t v11 = (a3 - 2) & 0x3F;
  if (a2 >> 6 == (a3 - 2) >> 6)
  {
    unint64_t v12 = atomic_load((unint64_t *)(*(void *)(a1 + 8) + 8 * v9));
    unint64_t pair_match = lock_free::first_pair_match(v12, v10, (a3 - 2) & 0x3F, a4);
    return pair_match + (a2 & 0xFFFFFFFFFFFFFFC0LL);
  }

  if (v10)
  {
    unint64_t v14 = atomic_load((unint64_t *)(*(void *)(a1 + 8) + 8 * v9));
    unint64_t pair_match = lock_free::first_pair_match(v14, v10, 62LL, a4);
    if (pair_match != 64) {
      return pair_match + (a2 & 0xFFFFFFFFFFFFFFC0LL);
    }
    ++v9;
  }

  uint64_t v15 = 0LL;
  unint64_t v16 = v8 >> 6;
  if (v11 >= 0x3E) {
    uint64_t v17 = 0LL;
  }
  else {
    uint64_t v17 = -1LL;
  }
  uint64_t v18 = 32LL;
  do
  {
    uint64_t v15 = *a4 | (2LL * a4[1]) | (4 * v15);
    --v18;
  }

  while (v18);
  unint64_t v19 = v16 + v17;
  if (v9 > v19)
  {
LABEL_18:
    if (v11 <= 0x3D)
    {
      unint64_t v22 = atomic_load((unint64_t *)(*(void *)(a1 + 8) + 8 * v16));
      unint64_t v23 = lock_free::first_pair_match(v22, 0LL, (v4 - 2) & 0x3F, a4);
      if (v23 != v11 + 2) {
        return v23 + (v8 & 0xFFFFFFFFFFFFFFC0LL);
      }
    }
  }

  else
  {
    uint64_t v20 = *(void *)(a1 + 8);
    uint64_t v21 = v9 << 6;
    while (((*(void *)(v20 + 8 * v9) ^ v15 | ((*(void *)(v20 + 8 * v9) ^ (unint64_t)v15) >> 1)) & 0x5555555555555555LL) == 0)
    {
      ++v9;
      v21 += 64LL;
      if (v9 > v19) {
        goto LABEL_18;
      }
    }
  }

  return v4;
}

void sub_18811DE5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

unint64_t lock_free::bitmap_t::find_mismatch_bits( uint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4)
{
  unint64_t v4 = a3;
  if (a3 <= a2 || *(void *)(a1 + 16) < a3 || (((_DWORD)a3 - (_DWORD)a2) & 1) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v27);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)"invalid bits range ", 19LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)"-", 1LL);
    std::ostream::operator<<();
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v27, 0x16u);
  }

  unint64_t v8 = a3 - 2;
  unint64_t v9 = a2 >> 6;
  uint64_t v10 = a2 & 0x3F;
  unint64_t v11 = (a3 - 2) & 0x3F;
  if (a2 >> 6 == (a3 - 2) >> 6)
  {
    unint64_t v12 = atomic_load((unint64_t *)(*(void *)(a1 + 8) + 8 * v9));
    unint64_t pair_mismatch = lock_free::first_pair_mismatch(v12, v10, (a3 - 2) & 0x3F, a4);
    return pair_mismatch + (a2 & 0xFFFFFFFFFFFFFFC0LL);
  }

  if (v10)
  {
    unint64_t v14 = atomic_load((unint64_t *)(*(void *)(a1 + 8) + 8 * v9));
    unint64_t pair_mismatch = lock_free::first_pair_mismatch(v14, v10, 62LL, a4);
    if (pair_mismatch != 64) {
      return pair_mismatch + (a2 & 0xFFFFFFFFFFFFFFC0LL);
    }
    ++v9;
  }

  uint64_t v15 = 0LL;
  unint64_t v16 = v8 >> 6;
  if (v11 >= 0x3E) {
    uint64_t v17 = 0LL;
  }
  else {
    uint64_t v17 = -1LL;
  }
  uint64_t v18 = 32LL;
  do
  {
    uint64_t v15 = *a4 | (2LL * a4[1]) | (4 * v15);
    --v18;
  }

  while (v18);
  unint64_t v19 = v16 + v17;
  if (v9 > v19)
  {
LABEL_18:
    if (v11 <= 0x3D)
    {
      unint64_t v23 = atomic_load((unint64_t *)(*(void *)(a1 + 8) + 8 * v16));
      unint64_t v24 = lock_free::first_pair_mismatch(v23, 0LL, (v4 - 2) & 0x3F, a4);
      if (v24 != v11 + 2) {
        return v24 + (v8 & 0xFFFFFFFFFFFFFFC0LL);
      }
    }
  }

  else
  {
    uint64_t v20 = v9 << 6;
    while (1)
    {
      uint64_t v21 = *(void *)(*(void *)(a1 + 8) + 8 * v9);
      unint64_t v22 = ((v15 ^ (unint64_t)~v21) >> 1) & ~(v15 ^ v21) & 0x5555555555555555LL;
      if (v22) {
        return __clz(__rbit64(v22)) + v20;
      }
      ++v9;
      v20 += 64LL;
      if (v9 > v19) {
        goto LABEL_18;
      }
    }
  }

  return v4;
}

void sub_18811E094(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL lock_free::bitmap_t::is_reset(lock_free::bitmap_t *this)
{
  unint64_t v1 = *((void *)this + 2) + 63LL;
  if (v1 < 0x40) {
    return 1LL;
  }
  unint64_t v3 = v1 >> 6;
  unint64_t v4 = (void *)*((void *)this + 1);
  if (v3 <= 1) {
    uint64_t v5 = 1LL;
  }
  else {
    uint64_t v5 = v3;
  }
  if (*v4) {
    return 0LL;
  }
  uint64_t v6 = 1LL;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
  }

  while (!v4[v6++]);
  return v7 >= v3;
}

uint64_t lock_free::bitmap_t::get_num_set(lock_free::bitmap_t *this)
{
  unint64_t v1 = *((void *)this + 2) + 63LL;
  if (v1 < 0x40) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v2 = 0LL;
  uint64_t v5 = (v1 >> 3) & 0x1FFFFFFFFFFFFFF8LL;
  do
  {
    unint64_t v6 = atomic_load((unint64_t *)(*((void *)this + 1) + v4));
    unint64_t v8 = v6;
    BYTE6(v9) = 1;
    v2 += std::__count[abi:ne180100]<std::_ClassicAlgPolicy,std::__bitset<1ul,64ul>,true,BOOL,std::__identity,0>( (int8x8_t *)&v8,  0,  (uint64_t)&v9,  0,  (_BYTE *)&v9 + 6);
    v4 += 8LL;
  }

  while (v5 != v4);
  return v2;
}

unint64_t lock_free::bitmap_t::get_bit(lock_free::bitmap_t *this, unint64_t a2)
{
  if (*((void *)this + 2) <= a2)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v5);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"Bit ", 4LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v5,  (uint64_t)" requested while there are only ",  32LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)" bits in the bitmap", 19LL);
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v5, 0x16u);
  }

  unint64_t v2 = atomic_load((unint64_t *)(*((void *)this + 1) + 8 * (a2 >> 6)));
  return (v2 >> a2) & 1;
}

void sub_18811E2C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL lock_free::bitmap_t::set_bit(lock_free::bitmap_t *this, unint64_t a2, int a3)
{
  if (*((void *)this + 2) <= a2)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v8);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"Bit ", 4LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v8,  (uint64_t)" requested while there are only ",  32LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" bits in the bitmap", 19LL);
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v8, 0x16u);
  }

  uint64_t v3 = 1LL << a2;
  uint64_t v4 = (unint64_t *)(*((void *)this + 1) + 8 * (a2 >> 6));
  if (a3)
  {
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 | v3, v4));
  }

  else
  {
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 & ~v3, v4));
  }

  return (v5 & v3) == 0;
}

void sub_18811E414(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t std::__count[abi:ne180100]<std::_ClassicAlgPolicy,std::__bitset<1ul,64ul>,true,BOOL,std::__identity,0>( int8x8_t *a1, unsigned int a2, uint64_t a3, unsigned int a4, _BYTE *a5)
{
  unint64_t v5 = a4 - (unint64_t)a2 + 8 * (a3 - (void)a1);
  if (*a5) {
    return std::__count_BOOL[abi:ne180100]<true,std::__bitset<1ul,64ul>,true>(a1, a2, v5);
  }
  else {
    return std::__count_BOOL[abi:ne180100]<false,std::__bitset<1ul,64ul>,true>((uint64_t *)a1, a2, v5);
  }
}

uint64_t std::__count_BOOL[abi:ne180100]<true,std::__bitset<1ul,64ul>,true>( int8x8_t *a1, unsigned int a2, unint64_t a3)
{
  uint64_t v3 = a2;
  if (a2)
  {
    if (64 - a2 >= a3) {
      unint64_t v4 = a3;
    }
    else {
      unint64_t v4 = 64 - a2;
    }
    uint64_t v5 = (uint64_t)*a1++;
    uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v4)) & (-1LL << a2) & v5));
    v6.i16[0] = vaddlv_u8(v6);
    uint64_t v3 = v6.u32[0];
    a3 -= v4;
  }

  if (a3 >= 0x40)
  {
    do
    {
      int8x8_t v7 = *a1++;
      uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
      v8.i16[0] = vaddlv_u8(v8);
      v3 += v8.u32[0];
      a3 -= 64LL;
    }

    while (a3 > 0x3F);
  }

  if (a3)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)a1 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a3)));
    v9.i16[0] = vaddlv_u8(v9);
    v3 += v9.u32[0];
  }

  return v3;
}

uint64_t std::__count_BOOL[abi:ne180100]<false,std::__bitset<1ul,64ul>,true>( uint64_t *a1, unsigned int a2, unint64_t a3)
{
  uint64_t v3 = a2;
  if (a2)
  {
    if (64 - a2 >= a3) {
      unint64_t v4 = a3;
    }
    else {
      unint64_t v4 = 64 - a2;
    }
    uint64_t v5 = *a1++;
    uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v4)) & (-1LL << a2) & ~v5));
    v6.i16[0] = vaddlv_u8(v6);
    uint64_t v3 = v6.u32[0];
    a3 -= v4;
  }

  if (a3 >= 0x40)
  {
    do
    {
      uint64_t v7 = *a1++;
      uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)~v7);
      v8.i16[0] = vaddlv_u8(v8);
      v3 += v8.u32[0];
      a3 -= 64LL;
    }

    while (a3 > 0x3F);
  }

  if (a3)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> -(char)a3) & ~*a1));
    v9.i16[0] = vaddlv_u8(v9);
    v3 += v9.u32[0];
  }

  return v3;
}

uint64_t crypto::header::header(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)a1 = 1919118949;
  int v7 = 1919118949;
  smart_enums::validators::value<unsigned int>((uint64_t)"sig1_t", 1919118949, &v7, 1LL);
  *(_DWORD *)(a1 + 4) = 1634952291;
  int v7 = 1634952291;
  smart_enums::validators::value<unsigned int>((uint64_t)"sig2_t", 1634952291, &v7, 1LL);
  *(_DWORD *)(a1 + 8) = 2;
  int v7 = 2;
  smart_enums::validators::value<unsigned int>((uint64_t)"version_t", 2, &v7, 1LL);
  *(_DWORD *)(a1 + 12) = 16;
  int v7 = 16;
  smart_enums::validators::value<unsigned int>((uint64_t)"iv_size_t", 16, &v7, 1LL);
  *(_DWORD *)(a1 + 16) = 5;
  int v7 = 5;
  smart_enums::validators::value<unsigned int>((uint64_t)"encryption_mode", 5, &v7, 1LL);
  *(_DWORD *)(a1 + 20) = -2147483647;
  int v7 = -2147483647;
  smart_enums::validators::value<unsigned int>((uint64_t)"algorithm_type", -2147483647, &v7, 1LL);
  *(_DWORD *)(a1 + 24) = *a2;
  *(_DWORD *)(a1 + 28) = 91;
  int v7 = 91;
  smart_enums::validators::value<unsigned int>((uint64_t)"prng_algorithm_type", 91, &v7, 1LL);
  *(_DWORD *)(a1 + 32) = 160;
  int v7 = 160;
  unint64_t v4 = (di_utils *)smart_enums::validators::value<unsigned int>((uint64_t)"prng_key_bits_size_t", 160, &v7, 1LL);
  *(_DWORD *)(a1 + 52) = 512;
  *(_OWORD *)(a1 + ++*(_DWORD *)(this + 56) = xmmword_188181240;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 36) = di_utils::random_uuid(v4);
  *(void *)(a1 + 44) = v5;
  return a1;
}

crypto::header *crypto::header::header(crypto::header *this, Backend *a2)
{
  v28[1] = *MEMORY[0x1895F89C0];
  *((_DWORD *)this + 8) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *(void *)((char *)this + 52) = 0LL;
  *(void *)((char *)this + 68) = 0LL;
  *(void *)((char *)this + 60) = 0LL;
  unint64_t v4 = (*(uint64_t (**)(Backend *))(*(void *)a2 + 40LL))(a2);
  if (v4 >= 0xC
    && (Backend::read(a2, v25, 12LL, v4 - 12) & 0x80000000) == 0
    && *(_DWORD *)v25 == 0x1000000
    && v26 == 1634952291
    && v27 == 1919118949)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException( exception,  "The image is encrypted with obsolete encoding version 1",  0xA0u);
  }

  if ((unint64_t)(*(uint64_t (**)(Backend *))(*(void *)a2 + 40LL))(a2) <= 0x4B)
  {
    uint64_t v18 = __cxa_allocate_exception(0x20uLL);
    uint64_t v19 = (*(uint64_t (**)(Backend *))(*(void *)a2 + 40LL))(a2);
    *uint64_t v18 = off_18A1E2338;
    v18[1] = "crypto";
    void v18[2] = 76LL;
    void v18[3] = v19;
  }

  uint64_t v5 = (char *)operator new[](0x4CuLL);
  *(_OWORD *)(v5 + 60) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *(_OWORD *)uint64_t v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  unsigned int v6 = Backend::read(a2, v5, 76LL, 0LL);
  if ((v6 & 0x80000000) != 0)
  {
    uint64_t v20 = __cxa_allocate_exception(0x40uLL);
    *uint64_t v20 = off_18A1E43B0;
    uint64_t v21 = std::generic_category();
    v20[1] = v6;
    unint64_t v22 = "Crypto: can't read crypto header";
    goto LABEL_13;
  }

  int v7 = *(_DWORD *)v5;
  LODWORD(v28[0]) = 1919118949;
  smart_enums::validators::value<unsigned int>((uint64_t)"sig1_t", v7, v28, 1LL);
  *(_DWORD *)this = 1919118949;
  int v8 = *((_DWORD *)v5 + 1);
  LODWORD(v28[0]) = 1634952291;
  smart_enums::validators::value<unsigned int>((uint64_t)"sig2_t", v8, v28, 1LL);
  *((_DWORD *)this + 1) = 1634952291;
  int v9 = bswap32(*((_DWORD *)v5 + 2));
  LODWORD(v28[0]) = 2;
  smart_enums::validators::value<unsigned int>((uint64_t)"version_t", v9, v28, 1LL);
  *((_DWORD *)this + 2) = v9;
  int v10 = bswap32(*((_DWORD *)v5 + 3));
  LODWORD(v28[0]) = 16;
  smart_enums::validators::value<unsigned int>((uint64_t)"iv_size_t", v10, v28, 1LL);
  *((_DWORD *)this + 3) = v10;
  int v11 = bswap32(*((_DWORD *)v5 + 4));
  LODWORD(v28[0]) = 5;
  smart_enums::validators::value<unsigned int>((uint64_t)"encryption_mode", v11, v28, 1LL);
  *((_DWORD *)this + 4) = v11;
  int v12 = bswap32(*((_DWORD *)v5 + 5));
  LODWORD(v28[0]) = -2147483647;
  smart_enums::validators::value<unsigned int>((uint64_t)"algorithm_type", v12, v28, 1LL);
  *((_DWORD *)this + 5) = v12;
  int v13 = bswap32(*((_DWORD *)v5 + 6));
  v28[0] = 0x10000000080LL;
  smart_enums::validators::value<unsigned int>((uint64_t)"encryption_key_bits_size_t", v13, v28, 2LL);
  *((_DWORD *)this + 6) = v13;
  int v14 = bswap32(*((_DWORD *)v5 + 7));
  LODWORD(v28[0]) = 91;
  smart_enums::validators::value<unsigned int>((uint64_t)"prng_algorithm_type", v14, v28, 1LL);
  *((_DWORD *)this + 7) = v14;
  int v15 = bswap32(*((_DWORD *)v5 + 8));
  LODWORD(v28[0]) = 160;
  smart_enums::validators::value<unsigned int>((uint64_t)"prng_key_bits_size_t", v15, v28, 1LL);
  *((_DWORD *)this + 8) = v15;
  *(_OWORD *)((char *)this + 36) = *(_OWORD *)(v5 + 36);
  *((_DWORD *)this + 13) = bswap32(*((_DWORD *)v5 + 13));
  *(int8x16_t *)((char *)this + ++*(_DWORD *)(this + 56) = vrev64q_s8(*(int8x16_t *)(v5 + 56));
  unsigned int v16 = bswap32(*((_DWORD *)v5 + 18));
  *((_DWORD *)this + 18) = v16;
  if (v16 - 2049 <= 0xFFFFF7FF)
  {
    uint64_t v20 = __cxa_allocate_exception(0x40uLL);
    *uint64_t v20 = off_18A1E43B0;
    uint64_t v21 = std::generic_category();
    v20[1] = 152LL;
    unint64_t v22 = "crypto header contains invalid number of auth entries";
LABEL_13:
    _OWORD v20[2] = v21;
    *((_BYTE *)v20 + 24) = 0;
    *((_BYTE *)v20 + 48) = 0;
    v20[7] = v22;
  }

  operator delete[](v5);
  return this;
}

void sub_18811EB3C(_Unwind_Exception *a1)
{
}

void sub_18811EB4C()
{
}

void sub_18811EB54(_Unwind_Exception *a1)
{
}

void sub_18811EC08(uint64_t a1, ...)
{
}

void sub_18811EC54(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

__n128 crypto::header::header(crypto::header *this, const char *a2)
{
  *((_DWORD *)this + 8) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *(void *)((char *)this + 52) = 0LL;
  *(void *)((char *)this + 68) = 0LL;
  *(void *)((char *)this + 60) = 0LL;
  *(_OWORD *)this = *(_OWORD *)a2;
  __n128 result = *((__n128 *)a2 + 1);
  __int128 v3 = *((_OWORD *)a2 + 2);
  __int128 v4 = *((_OWORD *)a2 + 3);
  *(_OWORD *)((char *)this + 60) = *(_OWORD *)(a2 + 60);
  *((_OWORD *)this + 2) = v3;
  *((_OWORD *)this + 3) = v4;
  *((__n128 *)this + 1) = result;
  return result;
}

char *crypto::header::write(crypto::header *this, char *a2)
{
  *(_DWORD *)a2 = *(_DWORD *)this;
  *((_DWORD *)a2 + 1) = *((_DWORD *)this + 1);
  *((_DWORD *)a2 + 2) = bswap32(*((_DWORD *)this + 2));
  *((_DWORD *)a2 + 3) = bswap32(*((_DWORD *)this + 3));
  *((_DWORD *)a2 + 4) = bswap32(*((_DWORD *)this + 4));
  *((_DWORD *)a2 + 5) = bswap32(*((_DWORD *)this + 5));
  *((_DWORD *)a2 + 6) = bswap32(*((_DWORD *)this + 6));
  *((_DWORD *)a2 + 7) = bswap32(*((_DWORD *)this + 7));
  *((_DWORD *)a2 + 8) = bswap32(*((_DWORD *)this + 8));
  *(_OWORD *)(a2 + 36) = *(_OWORD *)((char *)this + 36);
  *((_DWORD *)a2 + 13) = bswap32(*((_DWORD *)this + 13));
  *((void *)a2 + 7) = bswap64(*((void *)this + 7));
  *((void *)a2 + 8) = bswap64(*((void *)this + 8));
  *((_DWORD *)a2 + 18) = bswap32(*((_DWORD *)this + 18));
  return a2 + 76;
}

const void **crypto::header::populate_crypto_header_info(crypto::header *this, DiskImageInfo *a2)
{
  uint64_t v3 = (*(uint64_t (**)(char *))(*(void *)((char *)a2 + *(void *)(*(void *)a2 - 40LL)) + 16LL))((char *)a2 + *(void *)(*(void *)a2 - 40LL));
  if (!v3)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException( exception,  "Image contains crypto format but info class is missing EncryptionInfo",  0x16u);
  }

  uint64_t v4 = v3;
  uint64_t v5 = *((unsigned int *)this + 6);
  if (!*(_BYTE *)(v3 + 16)) {
    *(_BYTE *)(v3 + 16) = 1;
  }
  *(void *)(v3 + 8) = v5;
  unsigned int v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  int v12 = CFUUIDCreateFromUUIDBytes((CFAllocatorRef)*MEMORY[0x189604DB0], *(CFUUIDBytes *)((char *)this + 36));
  CFStringRef v7 = CFUUIDCreateString(v6, v12);
  int v11 = v7;
  if (*(void *)(v4 + 24))
  {
    CFRelease(*(CFTypeRef *)(v4 + 24));
    CFStringRef v7 = v11;
  }

  *(void *)(v4 + 24) = v7;
  int v11 = 0LL;
  CFAutoRelease<__CFString const*>::~CFAutoRelease((const void **)&v11);
  return CFAutoRelease<__CFUUID const*>::~CFAutoRelease((const void **)&v12);
}

void sub_18811EE34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

crypto::public_key_header *crypto::public_key_header::public_key_header( crypto::public_key_header *this, const char *a2)
{
  v9[1] = *MEMORY[0x1895F89C0];
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  LODWORD(v9[0]) = 0;
  smart_enums::validators::value<unsigned int>((uint64_t)"public_key_crypto_algo_mode", 0, v9, 1LL);
  bzero((char *)this + 48, 0x204uLL);
  LODWORD(v9[0]) = bswap32(*(_DWORD *)a2);
  crypto::public_key_header::_publicKeyHash::set_len(this, v9);
  __int128 v4 = *(_OWORD *)(a2 + 20);
  *(_OWORD *)((char *)this + 4) = *(_OWORD *)(a2 + 4);
  *(_OWORD *)((char *)this + 20) = v4;
  int v5 = bswap32(*((_DWORD *)a2 + 9));
  LODWORD(v9[0]) = 42;
  smart_enums::validators::value<unsigned int>((uint64_t)"public_key_crypto_algo", v5, v9, 1LL);
  *((_DWORD *)this + 9) = v5;
  int v6 = bswap32(*((_DWORD *)a2 + 10));
  v9[0] = 0x800000010000000ALL;
  smart_enums::validators::value<unsigned int>((uint64_t)"public_key_padding_algo", v6, v9, 2LL);
  *((_DWORD *)this + 10) = v6;
  int v7 = bswap32(*((_DWORD *)a2 + 11));
  LODWORD(v9[0]) = 0;
  smart_enums::validators::value<unsigned int>((uint64_t)"public_key_crypto_algo_mode", v7, v9, 1LL);
  *((_DWORD *)this + 11) = v7;
  LODWORD(v9[0]) = bswap32(*((_DWORD *)a2 + 12));
  crypto::public_key_header::_encryptedBlob::set_len((_DWORD *)this + 12, v9);
  memcpy((char *)this + 52, a2 + 52, 0x200uLL);
  return this;
}

crypto::public_key_header *crypto::public_key_header::public_key_header( crypto::public_key_header *this, const crypto::format *a2, __SecKey **a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = 0x2A00000000LL;
  LODWORD(__p) = 42;
  smart_enums::validators::value<unsigned int>((uint64_t)"public_key_crypto_algo", 42, &__p, 1LL);
  *((_DWORD *)this + 10) = 10;
  __p = (void *)0x800000010000000ALL;
  smart_enums::validators::value<unsigned int>((uint64_t)"public_key_padding_algo", 10, &__p, 2LL);
  *((_DWORD *)this + 11) = 0;
  LODWORD(__p) = 0;
  smart_enums::validators::value<unsigned int>((uint64_t)"public_key_crypto_algo_mode", 0, &__p, 1LL);
  bzero((char *)this + 48, 0x204uLL);
  crypto::format::make_key_blob(a2, &__p);
  CFErrorRef error = 0LL;
  CFDataRef v23 = SecKeyCopyExternalRepresentation(*a3, &error);
  if (!v23)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    unsigned int Code = CFErrorGetCode(error);
    void *exception = off_18A1E43B0;
    int v14 = std::generic_category();
    exception[1] = Code;
    exception[2] = v14;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Key from the certificate is not exportable.";
  }

  makeCFAutoReleaseThrowOnNull<__CFData const*>((uint64_t *)&v23, (uint64_t *)&theData);
  BytePtr = CFDataGetBytePtr(theData);
  CC_LONG Length = CFDataGetLength(theData);
  CC_SHA1(BytePtr, Length, (unsigned __int8 *)this + 4);
  LODWORD(plaintext) = 20;
  crypto::public_key_header::_publicKeyHash::set_len(this, &plaintext);
  CFDataRef v20 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)__p, v26 - (_BYTE *)__p);
  makeCFAutoReleaseThrowOnNull<__CFData const*>((uint64_t *)&v20, (uint64_t *)&plaintext);
  int v8 = *a3;
  crypto_algo_and_padding = (const __CFString *)crypto::public_key_header::get_crypto_algo_and_padding(this);
  CFDataRef v20 = SecKeyCreateEncryptedData(v8, crypto_algo_and_padding, plaintext, &error);
  if (!v20)
  {
    int v15 = __cxa_allocate_exception(0x40uLL);
    unsigned int v16 = CFErrorGetCode(error);
    *int v15 = off_18A1E43B0;
    uint64_t v17 = std::generic_category();
    v15[1] = v16;
    v15[2] = v17;
    *((_BYTE *)v15 + 24) = 0;
    *((_BYTE *)v15 + 48) = 0;
    v15[7] = "Failed to encrypt data using public key from certificate.";
  }

  makeCFAutoReleaseThrowOnNull<__CFData const*>((uint64_t *)&v20, (uint64_t *)&v19);
  int v18 = CFDataGetLength(v19);
  crypto::public_key_header::_encryptedBlob::set_len((_DWORD *)this + 12, &v18);
  int v10 = v19;
  v28.length = CFDataGetLength(v19);
  v28.location = 0LL;
  CFDataGetBytes(v10, v28, (UInt8 *)this + 52);
  CFAutoRelease<__CFData const*>::~CFAutoRelease((const void **)&v19);
  CFAutoRelease<__CFData const*>::~CFAutoRelease((const void **)&plaintext);
  CFAutoRelease<__CFData const*>::~CFAutoRelease((const void **)&theData);
  if (__p)
  {
    int v26 = __p;
    operator delete(__p);
  }

  return this;
}

void sub_18811F2A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, const void *a13, const void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void **crypto::format::make_key_blob@<X0>(crypto::format *this@<X0>, void *a2@<X8>)
{
  __n128 result = (void **)std::vector<std::byte>::vector( a2,  *((void *)this + 1) + *((void *)this + 4) - (*(void *)this + *((void *)this + 3)) + 5LL);
  __int128 v4 = (char *)*result;
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = v5 - *(void *)this;
  if (v5 != *(void *)this) {
    __n128 result = (void **)memmove(*result, *(const void **)this, v5 - *(void *)this);
  }
  int v7 = &v4[v6];
  int v8 = (_BYTE *)*((void *)this + 3);
  int v9 = (_BYTE *)*((void *)this + 4);
  int64_t v10 = v9 - v8;
  if (v9 != v8) {
    __n128 result = (void **)memmove(v7, v8, v9 - v8);
  }
  strcpy(&v7[v10], "CKIE");
  return result;
}

uint64_t *makeCFAutoReleaseThrowOnNull<__CFData const*>@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *result;
  *a2 = *result;
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    __int128 v4 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v4;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Failed creating CFAutoRelease instance.";
  }

  return result;
}

void sub_18811F444( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void **a10)
{
}

_DWORD *crypto::public_key_header::_publicKeyHash::set_len(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x21u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = off_18A1E4A78;
    exception[1] = "_publicKeyHash";
    exception[2] = "field size too large";
  }

  int *result = *a2;
  return result;
}

uint64_t crypto::public_key_header::get_crypto_algo_and_padding(crypto::public_key_header *this)
{
  if (*((_DWORD *)this + 9) != 42) {
    goto LABEL_7;
  }
  int v1 = *((_DWORD *)this + 10);
  if (v1 == 10)
  {
    uint64_t v2 = MEMORY[0x18960BCC8];
    return *(void *)v2;
  }

  if (v1 != -2147483647)
  {
LABEL_7:
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Unsupported public key algorithm.", 0xA1u);
  }

  uint64_t v2 = MEMORY[0x18960BCC0];
  return *(void *)v2;
}

_DWORD *crypto::public_key_header::_encryptedBlob::set_len(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x201u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = off_18A1E4A78;
    exception[1] = "_encryptedBlob";
    exception[2] = "field size too large";
  }

  int *result = *a2;
  return result;
}

crypto::password_header *crypto::password_header::password_header( crypto::password_header *this, const char *a2)
{
  v12[1] = *MEMORY[0x1895F89C0];
  __int128 v4 = (_DWORD *)((char *)this + 12);
  uint64_t v5 = (_DWORD *)((char *)this + 48);
  uint64_t v6 = (_DWORD *)((char *)this + 100);
  bzero(this, 0x268uLL);
  int v7 = bswap32(*(_DWORD *)a2);
  LODWORD(v12[0]) = 103;
  smart_enums::validators::value<unsigned int>((uint64_t)"key_derivation_algorithm_t", v7, v12, 1LL);
  *(_DWORD *)this = v7;
  int v8 = bswap32(*((_DWORD *)a2 + 1));
  LODWORD(v12[0]) = 0;
  smart_enums::validators::value<unsigned int>((uint64_t)"key_derivation_prng_algorithm_t", v8, v12, 1LL);
  *((_DWORD *)this + 1) = v8;
  *((_DWORD *)this + 2) = bswap32(*((_DWORD *)a2 + 2));
  LODWORD(v12[0]) = bswap32(*((_DWORD *)a2 + 3));
  crypto::password_header::_salt::set_len(v4, v12);
  __int128 v9 = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 2) = v9;
  LODWORD(v12[0]) = bswap32(*((_DWORD *)a2 + 12));
  crypto::password_header::_blob_encryption_iv::set_len(v5, v12);
  __int128 v10 = *(_OWORD *)(a2 + 68);
  *(_OWORD *)((char *)this + 52) = *(_OWORD *)(a2 + 52);
  *(_OWORD *)((char *)this + 68) = v10;
  *((_DWORD *)this + 21) = bswap32(*((_DWORD *)a2 + 21));
  LODWORD(v5) = bswap32(*((_DWORD *)a2 + 22));
  v12[0] = 0x8000000100000011LL;
  smart_enums::validators::value<unsigned int>((uint64_t)"wrap_key_crypto_algo", (int)v5, v12, 2LL);
  *((_DWORD *)this + 22) = (_DWORD)v5;
  LODWORD(v5) = bswap32(*((_DWORD *)a2 + 23));
  LODWORD(v12[0]) = 7;
  smart_enums::validators::value<unsigned int>((uint64_t)"wrap_key_crypto_padding_algo", (int)v5, v12, 1LL);
  *((_DWORD *)this + 23) = (_DWORD)v5;
  LODWORD(v5) = bswap32(*((_DWORD *)a2 + 24));
  LODWORD(v12[0]) = 6;
  smart_enums::validators::value<unsigned int>((uint64_t)"crypto_mode", (int)v5, v12, 1LL);
  *((_DWORD *)this + 24) = (_DWORD)v5;
  LODWORD(v12[0]) = bswap32(*((_DWORD *)a2 + 25));
  crypto::password_header::_blob::set_len(v6, v12);
  memcpy((char *)this + 104, a2 + 104, 0x200uLL);
  return this;
}

char *crypto::password_header::write(crypto::password_header *this, char *a2)
{
  *(_DWORD *)a2 = bswap32(*(_DWORD *)this);
  *((_DWORD *)a2 + 1) = bswap32(*((_DWORD *)this + 1));
  *((_DWORD *)a2 + 2) = bswap32(*((_DWORD *)this + 2));
  *((_DWORD *)a2 + 3) = bswap32(*((_DWORD *)this + 3));
  __int128 v3 = *((_OWORD *)this + 2);
  *((_OWORD *)a2 + 1) = *((_OWORD *)this + 1);
  *((_OWORD *)a2 + 2) = v3;
  *((_DWORD *)a2 + 12) = bswap32(*((_DWORD *)this + 12));
  __int128 v4 = *(_OWORD *)((char *)this + 52);
  *(_OWORD *)(a2 + 68) = *(_OWORD *)((char *)this + 68);
  *(_OWORD *)(a2 + 52) = v4;
  *((_DWORD *)a2 + 21) = bswap32(*((_DWORD *)this + 21));
  *((_DWORD *)a2 + 22) = bswap32(*((_DWORD *)this + 22));
  *((_DWORD *)a2 + 23) = bswap32(*((_DWORD *)this + 23));
  *((_DWORD *)a2 + 24) = bswap32(*((_DWORD *)this + 24));
  *((_DWORD *)a2 + 25) = bswap32(*((_DWORD *)this + 25));
  memcpy(a2 + 104, (char *)this + 104, 0x200uLL);
  return a2 + 616;
}

crypto::password_header *crypto::password_header::password_header(crypto::password_header *this)
{
  v3[1] = *MEMORY[0x1895F89C0];
  *(_DWORD *)this = 103;
  LODWORD(v3[0]) = 103;
  smart_enums::validators::value<unsigned int>((uint64_t)"key_derivation_algorithm_t", 103, v3, 1LL);
  *((_DWORD *)this + 1) = 0;
  LODWORD(v3[0]) = 0;
  smart_enums::validators::value<unsigned int>((uint64_t)"key_derivation_prng_algorithm_t", 0, v3, 1LL);
  *(_OWORD *)((char *)this + 68) = 0u;
  *(_OWORD *)((char *)this + ++*(_DWORD *)(this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(void *)((char *)this + 84) = 0x11000000C0LL;
  v3[0] = 0x8000000100000011LL;
  smart_enums::validators::value<unsigned int>((uint64_t)"wrap_key_crypto_algo", 17, v3, 2LL);
  *((_DWORD *)this + 23) = 7;
  LODWORD(v3[0]) = 7;
  smart_enums::validators::value<unsigned int>((uint64_t)"wrap_key_crypto_padding_algo", 7, v3, 1LL);
  *((_DWORD *)this + 24) = 6;
  LODWORD(v3[0]) = 6;
  smart_enums::validators::value<unsigned int>((uint64_t)"crypto_mode", 6, v3, 1LL);
  bzero((char *)this + 100, 0x204uLL);
  LODWORD(v3[0]) = 20;
  crypto::password_header::_salt::set_len((_DWORD *)this + 3, v3);
  LODWORD(v3[0]) = 8;
  crypto::password_header::_blob_encryption_iv::set_len((_DWORD *)this + 12, v3);
  crypto::generate_random_bytes((crypto::password_header *)((char *)this + 16), *((unsigned int *)this + 3));
  crypto::generate_random_bytes((crypto::password_header *)((char *)this + 52), *((unsigned int *)this + 12));
  return this;
}

_DWORD *crypto::password_header::_salt::set_len(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x21u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = off_18A1E4A78;
    exception[1] = "_salt";
    exception[2] = "field size too large";
  }

  int *result = *a2;
  return result;
}

_DWORD *crypto::password_header::_blob_encryption_iv::set_len(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x21u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = off_18A1E4A78;
    exception[1] = "_blob_encryption_iv";
    exception[2] = "field size too large";
  }

  int *result = *a2;
  return result;
}

uint64_t crypto::generate_random_bytes(crypto *this, size_t a2)
{
  uint64_t result = CCRandomGenerateBytes(this, a2);
  if ((_DWORD)result)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v4);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v4,  (uint64_t)"random generation failed with err code ",  39LL);
    std::ostream::operator<<();
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v4, 0x9Au);
  }

  return result;
}

void sub_18811FB00(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t crypto::password_header::get_derived_key_encryption_algorithm(crypto::password_header *this)
{
  int v1 = *((_DWORD *)this + 22);
  if (v1 == -2147483647) {
    return 0LL;
  }
  if (v1 != 17)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v4);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v4,  (uint64_t)"Unsupported key decryption algo",  31LL);
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v4, 0xA1u);
  }

  return 2LL;
}

void sub_18811FBD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t crypto::keys::generate_derivation_key@<X0>( crypto::keys *this@<X0>, const crypto::password_header *a2@<X1>, uint8_t **a3@<X8>)
{
  unint64_t v5 = *((unsigned int *)this + 21);
  if ((v5 & 7) != 0)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException( exception,  "crypto_format: key size isn't a multiple of 8",  0x16u);
  }

  char v15 = 0;
  std::vector<std::byte>::vector(a3, v5 >> 3, &v15);
  size_t v8 = strlen((const char *)a2);
  uint64_t result = CCKeyDerivationPBKDF( 2u,  (const char *)a2,  v8,  (const uint8_t *)this + 16,  *((unsigned int *)this + 3),  1u,  *((_DWORD *)this + 2),  *a3,  a3[1] - *a3);
  unsigned int v10 = result;
  if ((_DWORD)result)
  {
    int v13 = __cxa_allocate_exception(0x40uLL);
    *int v13 = off_18A1E43B0;
    int v14 = std::generic_category();
    v13[1] = v10;
    void v13[2] = v14;
    *((_BYTE *)v13 + 24) = 0;
    *((_BYTE *)v13 + 48) = 0;
    v13[7] = "crypto_format: Can't derive key";
  }

  return result;
}

void sub_18811FD14(_Unwind_Exception *exception_object)
{
  __int128 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

_DWORD *crypto::password_header::_blob::set_len(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x201u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = off_18A1E4A78;
    exception[1] = "_blob";
    exception[2] = "field size too large";
  }

  int *result = *a2;
  return result;
}

crypto::password_header *crypto::password_header::password_header( crypto::password_header *this, const crypto::format *a2, const char *a3)
{
  uint64_t v6 = crypto::password_header::password_header(this);
  LODWORD(v11[0]) = 8;
  crypto::password_header::_blob_encryption_iv::set_len((_DWORD *)v6 + 12, v11);
  size_t v7 = strlen(a3);
  *((_DWORD *)this + 2) = CCCalibratePBKDF( 2u,  v7,  *((unsigned int *)this + 3),  1u,  (unint64_t)*((unsigned int *)this + 21) >> 3,  0x64u);
  crypto::format::make_key_blob(a2, &v15);
  size_t dataOutMoved = 0LL;
  crypto::keys::generate_derivation_key(this, (const crypto::password_header *)a3, &v12);
  CCAlgorithm derived_key_encryption_algorithm = crypto::password_header::get_derived_key_encryption_algorithm(this);
  LODWORD(a3) = CCCrypt( 0,  derived_key_encryption_algorithm,  1u,  v12,  v13 - v12,  (char *)this + 52,  v15,  v16 - (_BYTE *)v15,  (char *)this + 104,  0x200uLL,  &dataOutMoved);
  bzero(v12, v13 - v12);
  if ((_DWORD)a3)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v11,  (uint64_t)"Image key encoding failed with err code ",  40LL);
    std::ostream::operator<<();
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v11, 0x9Au);
  }

  LODWORD(v11[0]) = dataOutMoved;
  crypto::password_header::_blob::set_len((_DWORD *)this + 25, v11);
  if (v12)
  {
    int v13 = v12;
    operator delete(v12);
  }

  if (v15)
  {
    unsigned int v16 = v15;
    operator delete(v15);
  }

  return this;
}

void sub_18811FF10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  size_t v7 = *(void **)(v5 - 88);
  if (v7)
  {
    *(void *)(v5 - 80) = v7;
    operator delete(v7);
  }

  size_t v8 = *(void **)(v5 - 56);
  if (v8)
  {
    *(void *)(v5 - 48) = v8;
    operator delete(v8);
  }

  _Unwind_Resume(a1);
}

crypto::auth_table_entry *crypto::auth_table_entry::auth_table_entry( crypto::auth_table_entry *this, const char *a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  *(void *)this = 0LL;
  *((void *)this + 1) = 0LL;
  *((_DWORD *)this + 4) = 0;
  int v4 = bswap32(*(_DWORD *)a2);
  __int128 v6 = xmmword_188181250;
  int v7 = 9;
  smart_enums::validators::value<unsigned int>((uint64_t)"auth_table_entry_mechanism", v4, &v6, 5LL);
  *(_DWORD *)this = v4;
  *(void *)((char *)this + 4) = bswap64(*(void *)(a2 + 4));
  *(void *)((char *)this + 12) = bswap64(*(void *)(a2 + 12));
  return this;
}

void crypto::keys::generate_password_wrapped_key( const crypto::password_header *a1@<X1>, crypto::password_header *a2@<X2>, unint64_t *a3@<X8>)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  crypto::keys::generate_derivation_key(a1, a2, (uint8_t **)&__p);
  CCAlgorithm derived_key_encryption_algorithm = crypto::password_header::get_derived_key_encryption_algorithm(a1);
  unsigned int v7 = CCCrypt( 1u,  derived_key_encryption_algorithm,  1u,  __p,  v11 - (_BYTE *)__p,  (char *)a1 + 52,  (char *)a1 + 104,  *((unsigned int *)a1 + 25),  __src,  *((unsigned int *)a1 + 25),  &__sz);
  if (v7)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    __int128 v9 = std::generic_category();
    exception[1] = v7;
    exception[2] = v9;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "crypto_format: Can't decrypt wrapped key";
  }

  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  std::vector<std::byte>::reserve(a3, __sz);
  std::vector<std::byte>::__insert_with_size[abi:ne180100]<std::byte const*,std::byte const*>( (uint64_t)a3,  (char *)*a3,  __src,  &__src[__sz],  __sz);
  if (__p)
  {
    int v11 = __p;
    operator delete(__p);
  }

void sub_188120178( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  unsigned int v16 = *(void **)v14;
  if (*(void *)v14)
  {
    *(void *)(v14 + 8) = v16;
    operator delete(v16);
  }

  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double crypto::keys::generate_base_key@<D0>(uint64_t a1@<X1>, const void **a2@<X2>, uint64_t a3@<X8>)
{
  if (!crypto::keys::verify_cookie(a1, a2))
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "crypto_format: Cookie differs", 0x23u);
  }

  __int128 v6 = *a2;
  size_t v7 = (unint64_t)*(unsigned int *)(a1 + 24) >> 3;
  uint64_t v18 = 0LL;
  __int128 v17 = 0uLL;
  std::vector<std::byte>::__init_with_size[abi:ne180100]<std::__wrap_iter<std::byte const*>,std::__wrap_iter<std::byte const*>>( &v17,  v6,  (uint64_t)v6 + v7,  v7);
  unint64_t v8 = *(unsigned int *)(a1 + 24);
  __int128 v9 = (char *)*a2 + (v8 >> 3);
  uint64_t v10 = (*(_DWORD *)(a1 + 32) + v8) >> 3;
  uint64_t v11 = (uint64_t)*a2 + v10;
  uint64_t v16 = 0LL;
  __int128 v15 = 0uLL;
  std::vector<std::byte>::__init_with_size[abi:ne180100]<std::__wrap_iter<std::byte const*>,std::__wrap_iter<std::byte const*>>( &v15,  v9,  v11,  v10 - (v8 >> 3));
  *(_OWORD *)a3 = v17;
  *(void *)(a3 + 16) = v18;
  double result = *(double *)&v15;
  *(_OWORD *)(a3 + 24) = v15;
  *(void *)(a3 + 40) = v16;
  return result;
}

void sub_188120298( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL crypto::keys::verify_cookie(uint64_t a1, void *a2)
{
  uint64_t v2 = ((*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 24)) >> 3) + 5;
  if (a2[1] - *a2 != v2) {
    return 0LL;
  }
  uint64_t v3 = *a2 + v2;
  v6.__r_.__value_.__s.__size_ = 4;
  LODWORD(v6.__r_.__value_.__l.__data_) = *(_DWORD *)(v3 - 5);
  v6.__r_.__value_.__s.__data_[4] = 0;
  BOOL v4 = std::string::compare(&v6, "CKIE") == 0;
  return v4;
}

void crypto::keys::generate_password_base_key( Backend *a1@<X1>, const crypto::header *a2@<X2>, crypto::password_header *a3@<X5>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a5 != 616)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException( exception,  "UDIF encryption: password header size mismatch",  0x16u);
  }

  int v12 = operator new[](0x268uLL);
  bzero(v12, 0x268uLL);
  unsigned int v13 = Backend::read(a1, (char *)v12, 616LL, a4);
  if ((v13 & 0x80000000) != 0)
  {
    uint64_t v16 = __cxa_allocate_exception(0x40uLL);
    void *v16 = off_18A1E43B0;
    __int128 v17 = std::generic_category();
    v16[1] = v13;
    void v16[2] = v17;
    *((_BYTE *)v16 + 24) = 0;
    *((_BYTE *)v16 + 48) = 0;
    v16[7] = "Can't read UDIF crypto header";
  }

  crypto::password_header::password_header((crypto::password_header *)v19, (const char *)v12);
  crypto::keys::generate_password_wrapped_key((const crypto::password_header *)v19, a3, (unint64_t *)__p);
  crypto::keys::generate_base_key((uint64_t)a2, (const void **)__p, a6);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  operator delete[](v12);
}

void sub_1881204B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  operator delete[](v11);
  _Unwind_Resume(a1);
}

uint64_t crypto::keys::keys(uint64_t a1, uint64_t a2, uint64_t *a3, __SecKey *a4, uint64_t a5)
{
  __int128 v9 = (void *)(a1 + 24);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)&__int128 v21 = CFDataCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const UInt8 *)(a5 + 52),  *(unsigned int *)(a5 + 48));
  makeCFAutoReleaseThrowOnNull<__CFData const*>((uint64_t *)&v21, (uint64_t *)&v27);
  crypto_algo_and_padding = (const __CFString *)crypto::public_key_header::get_crypto_algo_and_padding((crypto::public_key_header *)a5);
  CFDataRef v26 = SecKeyCreateDecryptedData(a4, crypto_algo_and_padding, v27, &error);
  if (!v26)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    unsigned int Code = CFErrorGetCode(error);
    void *exception = off_18A1E43B0;
    CFDataRef v19 = std::generic_category();
    exception[1] = Code;
    exception[2] = v19;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Error while decrypting data using keychain";
  }

  makeCFAutoReleaseThrowOnNull<__CFData const*>((uint64_t *)&v26, (uint64_t *)&v25);
  uint64_t v11 = *a3;
  CFDataCopyToVector(v25, 0, 0LL, (unint64_t *)__p);
  crypto::keys::generate_base_key(v11, (const void **)__p, (uint64_t)&v21);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  uint64_t v12 = *a3;
  *a3 = 0LL;
  unsigned int v13 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = v12;
  if (v13) {
    operator delete(v13);
  }
  uint64_t v14 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v14;
    operator delete(v14);
    *(void *)a1 = 0LL;
    *(void *)(a1 + 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
  }

  *(_OWORD *)a1 = v21;
  *(void *)(a1 + 16) = v22;
  __int128 v15 = *(void **)(a1 + 24);
  if (v15)
  {
    *(void *)(a1 + 32) = v15;
    operator delete(v15);
    void *v9 = 0LL;
    v9[1] = 0LL;
    void v9[2] = 0LL;
  }

  *(_OWORD *)(a1 + 24) = v23;
  *(void *)(a1 + 40) = v24;
  CFAutoRelease<__CFData const*>::~CFAutoRelease((const void **)&v25);
  CFAutoRelease<__CFData const*>::~CFAutoRelease((const void **)&v27);
  return a1;
}

void sub_1881206AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  uint64_t v24 = *(void **)(v19 + 56);
  if (v24)
  {
    *(void *)(v19 + 64) = v24;
    operator delete(v24);
  }

  int64_t v25 = *(void **)(v19 + 48);
  *(void *)(v19 + 48) = 0LL;
  if (v25) {
    operator delete(v25);
  }
  CFDataRef v26 = *v21;
  if (*v21)
  {
    *(void *)(v19 + 32) = v26;
    operator delete(v26);
  }

  uint64_t v27 = *(void **)v19;
  if (*(void *)v19)
  {
    *(void *)(v19 + 8) = v27;
    operator delete(v27);
  }

  _Unwind_Resume(a1);
}

uint64_t std::tuple<std::vector<std::byte>,std::vector<std::byte>>::~tuple(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }

  return a1;
}

uint64_t crypto::keys::keys(uint64_t a1, Backend *a2, const crypto::header **a3, crypto::password_header *a4)
{
  size_t v7 = (void *)(a1 + 24);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  uint64_t v8 = 20LL * *((unsigned int *)*a3 + 18);
  __int128 v9 = operator new[](v8);
  bzero(v9, v8);
  unsigned int v10 = Backend::read(a2, (char *)v9, v8, 76LL);
  CFDataRef v26 = (char *)v9;
  if ((v10 & 0x80000000) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    int64_t v25 = std::generic_category();
    exception[1] = v10;
    exception[2] = v25;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Crypto: Can't read encryption table";
  }

  if (!*((_DWORD *)*a3 + 18))
  {
LABEL_15:
    uint64_t v22 = __cxa_allocate_exception(0x40uLL);
    *uint64_t v22 = off_18A1E43B0;
    __int128 v23 = std::generic_category();
    v22[1] = 80LL;
    v22[2] = v23;
    *((_BYTE *)v22 + 24) = 0;
    *((_BYTE *)v22 + 48) = 0;
    v22[7] = "Invalid passphrase or key";
  }

  unint64_t v11 = 0LL;
  uint64_t v12 = (const char *)v9;
  while (1)
  {
    crypto::auth_table_entry::auth_table_entry((crypto::auth_table_entry *)&v36, v12);
    if (v36 == 1) {
      break;
    }
    ++v11;
    v12 += 20;
  }

  *(_OWORD *)unint64_t v34 = 0u;
  __int128 v35 = 0u;
  *(_OWORD *)__p = 0u;
  crypto::keys::generate_password_base_key(a2, *a3, a4, v37, v38, (uint64_t)&v29);
  unsigned int v13 = v29;
  __p[0] = v29;
  *(_OWORD *)CFRange v28 = v30;
  __p[1] = (void *)v30;
  uint64_t v14 = v31;
  uint64_t v15 = v32;
  v34[1] = v31;
  __int128 v35 = v32;
  uint64_t v16 = *((void *)&v32 + 1);
  __int128 v17 = *a3;
  *a3 = 0LL;
  uint64_t v18 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = v17;
  if (v18) {
    operator delete(v18);
  }
  uint64_t v19 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v19;
    operator delete(v19);
    *(void *)a1 = 0LL;
    *(void *)(a1 + 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
  }

  *(void *)a1 = v13;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)v28;
  __p[1] = 0LL;
  v34[0] = 0LL;
  __p[0] = 0LL;
  uint64_t v20 = *(void **)(a1 + 24);
  if (v20)
  {
    *(void *)(a1 + 32) = v20;
    operator delete(v20);
    *size_t v7 = 0LL;
    v7[1] = 0LL;
    unint64_t v7[2] = 0LL;
  }

  *(void *)(a1 + 24) = v14;
  *(void *)(a1 + 32) = v15;
  *(void *)(a1 + 40) = v16;
  if (__p[0]) {
    operator delete(__p[0]);
  }
  operator delete[](v26);
  return a1;
}

void sub_188120A34()
{
}

void sub_188120A58()
{
}

__n128 crypto::keys::keys(void *a1, uint64_t a2, __n128 *a3, uint64_t *a4)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = *(void *)(a2 + 16);
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  a1[3] = 0LL;
  a1[4] = 0LL;
  a1[5] = 0LL;
  __n128 result = *a3;
  *(__n128 *)(a1 + 3) = *a3;
  a1[5] = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0LL;
  a3->n128_u64[1] = 0LL;
  a3[1].n128_u64[0] = 0LL;
  uint64_t v5 = *a4;
  *a4 = 0LL;
  a1[6] = v5;
  a1[7] = 0LL;
  a1[8] = 0LL;
  a1[9] = 0LL;
  return result;
}

const void **crypto::format::populate_crypto_info(crypto::header **this, DiskImageInfo *a2)
{
  return crypto::header::populate_crypto_header_info(this[6], a2);
}

uint64_t crypto::format::aes_context::aes_context( uint64_t a1, CCOperation a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(a1 + 24) = 0LL;
  uint64_t v10 = a1 + 24;
  *(_DWORD *)(a1 + 16) = a2;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  std::vector<std::byte>::__init_with_size[abi:ne180100]<std::byte*,std::byte*>( (void *)(a1 + 24),  *(const void **)a3,  *(void *)(a3 + 8),  *(void *)(a3 + 8) - *(void *)a3);
  *(void *)(v10 + 24) = a5;
  *(void *)(v10 + 32) = a4;
  CCCryptorStatus v11 = CCCryptorCreate( a2,  0,  0,  *(const void **)a3,  *(void *)(a3 + 8) - *(void *)a3,  0LL,  (CCCryptorRef *)(v10 - 16));
  if (v11)
  {
    unsigned int v13 = v11;
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    uint64_t v15 = std::generic_category();
    exception[1] = v13;
    exception[2] = v15;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "crypto_format: Can't initialize aes cryptor";
  }

  *(_BYTE *)a1 = 1;
  return a1;
}

void sub_188120C0C(_Unwind_Exception *exception_object)
{
  BOOL v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }

  _Unwind_Resume(exception_object);
}

void crypto::format::aes_context::~aes_context(CCCryptorRef *this)
{
  if (*(_BYTE *)this) {
    CCCryptorRelease(this[1]);
  }
  uint64_t v2 = this[3];
  if (v2)
  {
    this[4] = v2;
    operator delete(v2);
  }

uint64_t crypto::format::format(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0LL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0LL;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0LL;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a2 + 24) = 0u;
  uint64_t v3 = *(void *)(a2 + 48);
  *(_OWORD *)(a2 + 40) = 0u;
  *(void *)(a1 + ++*(_DWORD *)(this + 56) = 0LL;
  uint64_t v4 = a1 + 56;
  *(void *)(a1 + 48) = v3;
  *(void *)(a1 + 64) = 0LL;
  std::allocate_shared[abi:ne180100]<crypto::format::aes_iv,std::allocator<crypto::format::aes_iv>,std::vector<std::byte> &,void>( a1 + 24,  &v9);
  std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100](v4, &v9);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)&v9 + 1);
  if (*((void *)&v9 + 1))
  {
    std::string v6 = (unint64_t *)(*((void *)&v9 + 1) + 8LL);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  return a1;
}

void sub_188120D4C(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4);
  std::string v6 = *(void **)(v1 + 48);
  *(void *)(v1 + 48) = 0LL;
  if (v6) {
    operator delete(v6);
  }
  unint64_t v7 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v7;
    operator delete(v7);
  }

  uint64_t v8 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v8;
    operator delete(v8);
  }

  _Unwind_Resume(a1);
}

uint64_t crypto::format::format(uint64_t a1, uint64_t *a2, uint64_t a3, const char *a4, __SecKey *a5)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  CFRange v28 = a5;
  uint64_t v8 = (unint64_t *)(a1 + 24);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t v9 = *a2;
  *a2 = 0LL;
  *(void *)(a1 + 48) = v9;
  *(void *)(a1 + ++*(_DWORD *)(this + 56) = 0LL;
  uint64_t v10 = a1 + 56;
  *(void *)(a1 + 64) = 0LL;
  unint64_t v11 = (unint64_t)*(unsigned int *)(v9 + 24) >> 3;
  uint64_t v12 = *(crypto **)a1;
  unsigned int v13 = *(char **)(a1 + 8);
  if (v11 <= v13 - (char *)v12)
  {
    if (v11 < v13 - (char *)v12)
    {
      unsigned int v13 = (char *)v12 + v11;
      *(void *)(a1 + 8) = (char *)v12 + v11;
    }
  }

  else
  {
    std::vector<std::byte>::__append((unint64_t *)a1, v11 - (v13 - (char *)v12));
    uint64_t v12 = *(crypto **)a1;
    unsigned int v13 = *(char **)(a1 + 8);
  }

  crypto::generate_random_bytes(v12, v13 - (char *)v12);
  unint64_t v15 = (unint64_t)*(unsigned int *)(*(void *)(a1 + 48) + 32LL) >> 3;
  uint64_t v16 = *(crypto **)(a1 + 24);
  __int128 v17 = *(char **)(a1 + 32);
  if (v15 <= v17 - (char *)v16)
  {
    if (v15 < v17 - (char *)v16)
    {
      __int128 v17 = (char *)v16 + v15;
      *(void *)(a1 + 32) = (char *)v16 + v15;
    }
  }

  else
  {
    std::vector<std::byte>::__append(v8, v15 - (v17 - (char *)v16));
    uint64_t v16 = *(crypto **)(a1 + 24);
    __int128 v17 = *(char **)(a1 + 32);
  }

  crypto::generate_random_bytes(v16, v17 - (char *)v16);
  std::allocate_shared[abi:ne180100]<crypto::format::aes_iv,std::allocator<crypto::format::aes_iv>,std::vector<std::byte> &,void>( (uint64_t)v8,  &v29);
  std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100](v10, (__int128 *)&v29);
  uint64_t v18 = *(std::__shared_weak_count **)((char *)&v30 + 4);
  if (*(void *)((char *)&v30 + 4))
  {
    uint64_t v19 = (unint64_t *)(*(void *)((char *)&v30 + 4) + 8LL);
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  __p = 0LL;
  unint64_t v26 = 0LL;
  unint64_t v27 = 0LL;
  if (a4)
  {
    crypto::password_header::password_header((crypto::password_header *)&v29, (const crypto::format *)a1, a4);
    unint64_t v26 = std::vector<std::variant<crypto::password_header,crypto::public_key_header>>::__emplace_back_slow_path<crypto::password_header>( (uint64_t *)&__p,  (uint64_t)&v29);
  }

  if (v28)
  {
    crypto::public_key_header::public_key_header((crypto::public_key_header *)&v29, (const crypto::format *)a1, &v28);
    unint64_t v21 = v26;
    if (v26 >= v27)
    {
      uint64_t v23 = std::vector<std::variant<crypto::password_header,crypto::public_key_header>>::__emplace_back_slow_path<crypto::public_key_header>( (uint64_t *)&__p,  (uint64_t)&v29);
    }

    else
    {
      *(_DWORD *)(v26 + 32) = 0;
      *(_OWORD *)unint64_t v21 = 0u;
      *(_OWORD *)(v21 + 16) = 0u;
      *(_DWORD *)unint64_t v21 = v29;
      __int128 v22 = v30;
      *(_OWORD *)(v21 + 20) = v31;
      *(_OWORD *)(v21 + 4) = v22;
      *(void *)(v21 + 36) = v32;
      *(_DWORD *)(v21 + 44) = v33;
      bzero((void *)(v21 + 48), 0x204uLL);
      *(_DWORD *)(v21 + 48) = v34;
      memcpy((void *)(v21 + 52), v35, 0x200uLL);
      *(_DWORD *)(v21 + 616) = 1;
      uint64_t v23 = v21 + 620;
    }

    unint64_t v26 = v23;
  }

  crypto::format::write_header_and_keys(a1, a3, (uint64_t *)&__p);
  if (__p)
  {
    unint64_t v26 = (unint64_t)__p;
    operator delete(__p);
  }

  return a1;
}

void sub_1881210B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](v12);
  uint64_t v14 = *(void **)(v10 + 48);
  *(void *)(v10 + 48) = 0LL;
  if (v14) {
    operator delete(v14);
  }
  unint64_t v15 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 32) = v15;
    operator delete(v15);
  }

  uint64_t v16 = *(void **)v10;
  if (*(void *)v10)
  {
    *(void *)(v10 + 8) = v16;
    operator delete(v16);
  }

  _Unwind_Resume(a1);
}

void crypto::format::write_header_and_keys(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = (a3[1] - *a3) >> 2;
  *(_DWORD *)(*(void *)(a1 + 48) + 72LL) = 1496311187 * v6;
  uint64_t v34 = 76LL;
  unint64_t v7 = 0xBDEF7BDEF7BDEF7CLL * v6 + 76;
  unint64_t v33 = v7;
  total_entries_uint64_t size = crypto::format::get_total_entries_size(a1, a3);
  std::vector<char>::vector(&v32, total_entries_size + v7);
  crypto::header::write(*(crypto::header **)(a1 + 48), v32.__begin_);
  uint64_t v9 = *a3;
  for (uint64_t i = a3[1]; v9 != i; v9 += 620LL)
  {
    unint64_t v26 = &v34;
    unint64_t v27 = (std::__shared_weak_count *)&v33;
    CFRange v28 = &v32;
    uint64_t v11 = *(unsigned int *)(v9 + 616);
    if ((_DWORD)v11 == -1) {
      std::__throw_bad_variant_access[abi:ne180100]();
    }
    __int128 v35 = &v26;
    ((void (*)(uint64_t ***, uint64_t))off_18A1E4AB8[v11])(&v35, v9);
  }

  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40LL))(a2) < *(void *)(*(void *)(a1 + 48) + 64LL))
  {
    unsigned int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56LL))(a2);
    if (v12)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = off_18A1E43B0;
      int64_t v25 = std::generic_category();
      exception[1] = v12;
      exception[2] = v25;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 48) = 0;
      exception[7] = "Failed truncating crypto header";
    }
  }

  std::vector<char>::pointer begin = v32.__begin_;
  std::vector<char>::pointer end = v32.__end_;
  unint64_t v15 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  unint64_t v26 = (uint64_t *)begin;
  unint64_t v27 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }

  CFRange v28 = (std::vector<char> *)(end - begin);
  uint64_t v29 = 0LL;
  int64_t v30 = end - begin;
  char v31 = 0;
  unsigned int v18 = (*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)a2 + 80LL))(a2, &v26);
  if (v28 != (std::vector<char> *)(int)v18)
  {
    __int128 v22 = __cxa_allocate_exception(0x40uLL);
    *__int128 v22 = off_18A1E43B0;
    uint64_t v23 = std::generic_category();
    v22[1] = v18;
    v22[2] = v23;
    *((_BYTE *)v22 + 24) = 0;
    *((_BYTE *)v22 + 48) = 0;
    v22[7] = "Failed writing crypto header";
  }

  uint64_t v19 = v27;
  if (v27)
  {
    unint64_t v20 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  if (v32.__begin_)
  {
    v32.__end_ = v32.__begin_;
    operator delete(v32.__begin_);
  }

void sub_1881213B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t crypto::format::get_total_entries_size(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 == v3) {
    return 0LL;
  }
  int v4 = 0;
  do
  {
    uint64_t v5 = *(unsigned int *)(v2 + 616);
    if ((_DWORD)v5 == -1) {
      std::__throw_bad_variant_access[abi:ne180100]();
    }
    uint64_t v8 = &v7;
    v4 += ((uint64_t (*)(char **, uint64_t))off_18A1E4AA8[v5])(&v8, v2);
    v2 += 620LL;
  }

  while (v2 != v3);
  return v4;
}

uint64_t crypto_format_backend::crypt_chunk( crypto_format_backend *this, crypto::format::aes_context *a2, char *a3, uint64_t a4, uint64_t a5)
{
  if (!a4) {
    return 0LL;
  }
  uint64_t v6 = a4;
  uint64_t v9 = 0LL;
  unint64_t v10 = *(unsigned int *)(*(void *)(*((void *)this + 5) + 48LL) + 52LL);
  while (1)
  {
    unsigned int v11 = crypto::format::aes_context::crypt(a2, (a5 + v9) / v10, &a3[v9], &a3[v9], 1LL);
    if (v11) {
      break;
    }
    v9 += v10;
    if (!--v6) {
      return 0LL;
    }
  }

  int v13 = v11;
  *(void *)&__int128 v14 = "crypto_format_backend::crypt_chunk(crypto::format::aes_context &, char *, size_t, uint64_t)";
  *((void *)&v14 + 1) = 34LL;
  int v15 = 16;
  di_log::logger<di_log::log_printer<690ul>>::logger(v16, &v14);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v17,  (uint64_t)"Crypto operation on data of ",  28LL);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, (uint64_t)" failed with ", 13LL);
  std::ostream::operator<<();
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<690ul>>::~logger_buf((uint64_t)v16);
  MEMORY[0x1895BC2CC](&v18);
  if (v13 < 0) {
    return v13;
  }
  else {
    return -v13;
  }
}

void sub_1881215B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

crypto *crypto::format::aes_context::crypt( crypto::format::aes_context *this, unsigned int a2, const void *a3, void *a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  unint64_t v10 = (const void *)*((void *)this + 7);
  LODWORD(v13) = bswap32(a2);
  memcpy(&__dst, v10, sizeof(__dst));
  CCHmacUpdate(&__dst, &v13, 4uLL);
  CCHmacFinal(&__dst, macOut);
  CCCryptorStatus v11 = CCCryptorReset(*((CCCryptorRef *)this + 1), macOut);
  if (v11)
  {
    *(void *)&__int128 v13 = "crypto::format::aes_context::crypt(uint32_t, const void *, void *, size_t)";
    *((void *)&v13 + 1) = 34LL;
    int v14 = 16;
    di_log::logger<di_log::log_printer<564ul>>::logger(&__dst, &v13);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &__dst.ctx[90],  (uint64_t)"CommonCryptoReset @ ",  20LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__dst.ctx[90], (uint64_t)"/", 1LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &__dst.ctx[90],  (uint64_t)" returned ",  10LL);
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<564ul>>::~logger_buf((uint64_t)&__dst);
  }

  else
  {
    CCCryptorStatus v11 = CCCryptorUpdate( *((CCCryptorRef *)this + 1),  a3,  *((void *)this + 6) * a5,  a4,  *((void *)this + 6) * a5,  0LL);
    if (!v11) {
      return 0LL;
    }
    *(void *)&__int128 v13 = "crypto::format::aes_context::crypt(uint32_t, const void *, void *, size_t)";
    *((void *)&v13 + 1) = 34LL;
    int v14 = 16;
    di_log::logger<di_log::log_printer<578ul>>::logger(&__dst, &v13);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &__dst.ctx[90],  (uint64_t)"CommonCryptoUpdate @ ",  21LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__dst.ctx[90], (uint64_t)"/", 1LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &__dst.ctx[90],  (uint64_t)" returned ",  10LL);
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<578ul>>::~logger_buf((uint64_t)&__dst);
  }

  MEMORY[0x1895BC2CC](&__dst.ctx[92]);
  if (v11 < 0) {
    return (crypto *)v11;
  }
  else {
    return (crypto *)-v11;
  }
}

void sub_188121828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<690ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<690ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E4F20;
  a1[45] = &unk_18A1E5020;
  a1[46] = &unk_18A1E5048;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E4F20;
  a1[45] = &unk_18A1E4FA8;
  a1[46] = &unk_18A1E4FD0;
  return a1;
}

void sub_1881218E0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<690ul>>::~logger(uint64_t a1)
{
  return a1;
}

void crypto_format_backend::crypt( crypt *this, crypto::format::aes_context *a2, char *a3, unint64_t a4, uint64_t a5)
{
  if (a4 >= 0x21 && (int v10 = *(_DWORD *)(*(void *)(*((void *)this + 5) + 48LL) + 52LL), qos_class_self() > 0x14))
  {
    unsigned int v13 = 0;
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = ___ZN21crypto_format_backend5cryptERN6crypto6format11aes_contextEPcmy_block_invoke;
    block[3] = &__block_descriptor_tmp_8;
    block[4] = this;
    block[5] = a4;
    block[6] = a2;
    block[7] = a3;
    int v12 = v10;
    block[8] = a5;
    block[9] = &v13;
    dispatch_apply((a4 + 31) >> 5, 0LL, block);
    atomic_load(&v13);
  }

  else
  {
    crypto_format_backend::crypt_chunk(this, a2, a3, a4, a5);
  }

void ___ZN21crypto_format_backend5cryptERN6crypto6format11aes_contextEPcmy_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 32 * a2;
  int v4 = *(crypto_format_backend **)(a1 + 32);
  else {
    uint64_t v5 = *(void *)(a1 + 40) - 32 * a2;
  }
  crypto::format::aes_context::aes_context( (uint64_t)v7,  *(_DWORD *)(*(void *)(a1 + 48) + 16LL),  *(void *)(a1 + 48) + 24LL,  *(void *)(*(void *)(a1 + 48) + 56LL),  *(void *)(*(void *)(a1 + 48) + 48LL));
  unsigned int v6 = crypto_format_backend::crypt_chunk( v4,  (crypto::format::aes_context *)v7,  (char *)(*(void *)(a1 + 56) + v3 * *(unsigned int *)(a1 + 80)),  v5,  v3 * *(unsigned int *)(a1 + 80) + *(void *)(a1 + 64));
  if (v6) {
    atomic_store(v6, *(unsigned int **)(a1 + 72));
  }
  crypto::format::aes_context::~aes_context(v7);
}

void sub_188121AC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CCCryptorRef a9)
{
}

void crypto_format_backend::read_aligned( crypto_format_backend *this, char *a2, unint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v8 = *(void *)(*((void *)this + 5) + 48LL);
    uint64_t v9 = *(unsigned int *)(v8 + 52);
    if ((*((_BYTE *)this + 192) & 1) != 0) {
      uint64_t v10 = 0LL;
    }
    else {
      uint64_t v10 = *(void *)(v8 + 64);
    }
    if ((Backend::read(*((Backend **)this + 3), a2, v9 * a3, v10 + a4) & 0x80000000) != 0)
    {
      *(void *)&__int128 v11 = "crypto_format_backend::read_aligned(char *, ssize_t, uint64_t)";
      *((void *)&v11 + 1) = 35LL;
      int v12 = 16;
      di_log::logger<di_log::log_printer<738ul>>::logger(v13, &v11);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v14,  (uint64_t)"Crypto couldn't read from inner backend @ ",  42LL);
      std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v14, (uint64_t)"/", 1LL);
      std::ostream::operator<<();
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<738ul>>::~logger_buf((uint64_t)v13);
      MEMORY[0x1895BC2CC](&v15);
    }

    else
    {
      crypto_format_backend::crypt(this, (crypto_format_backend *)((char *)this + 120), a2, a3, a4);
    }
  }

void sub_188121C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<738ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<738ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E5140;
  a1[45] = &unk_18A1E5240;
  a1[46] = &unk_18A1E5268;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E5140;
  a1[45] = &unk_18A1E51C8;
  a1[46] = &unk_18A1E51F0;
  return a1;
}

void sub_188121CD0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<738ul>>::~logger(uint64_t a1)
{
  return a1;
}

void crypto_format_backend::read(crypto_format_backend *this, char **a2)
{
  uint64_t v3 = *a2;
  uint64_t v5 = (uint64_t)a2[2];
  int v4 = a2[3];
  uint64_t v6 = *(unsigned int *)(*(void *)(*((void *)this + 5) + 48LL) + 52LL);
  uint64_t v7 = (unint64_t)v4 / v6 * v6;
  unint64_t v8 = (unint64_t)v4 % v6;
  if ((unint64_t)v4 % v6)
  {
    crypto_format_backend::read_aligned(this, *((char **)this + 23), 1uLL, (unint64_t)v4 / v6 * v6);
    if (v10) {
      return;
    }
    unint64_t v11 = v8;
    else {
      size_t v12 = v5;
    }
    memcpy(v3, (const void *)(*((void *)this + 23) + v11), v12);
    v5 -= v12;
    v3 += v12;
    v7 += v6;
  }

  crypto_format_backend::read_aligned(this, v3, v5 / v6, v7);
  if (!v9 && v5 % v6)
  {
    crypto_format_backend::read_aligned(this, *((char **)this + 23), 1uLL, v5 - v5 % v6 + v7);
    if (!v13) {
      memcpy(&v3[v5 / v6 * v6], *((const void **)this + 23), v5 % v6);
    }
  }

uint64_t crypto_format_backend::write_aligned( crypto_format_backend *this, char *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(*((void *)this + 5) + 48LL);
  if ((*((_BYTE *)this + 192) & 1) != 0) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = *(void *)(v8 + 64);
  }
  uint64_t v10 = *(unsigned int *)(v8 + 52);
  crypto_format_backend::crypt(this, (crypto_format_backend *)((char *)this + 56), a2, a3, a4);
  uint64_t v12 = v11;
  if (!(_DWORD)v11)
  {
    uint64_t v13 = Backend::write(*((Backend **)this + 3), a2, v10 * a3, v9 + a4);
    if ((v13 & 0x80000000) != 0)
    {
      uint64_t v12 = v13;
      *(void *)&__int128 v15 = "crypto_format_backend::write_aligned(char *, ssize_t, uint64_t)";
      *((void *)&v15 + 1) = 36LL;
      int v16 = 16;
      di_log::logger<di_log::log_printer<806ul>>::logger(v17, &v15);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v18,  (uint64_t)"Crypto couldn't write to inner backend @ ",  41LL);
      std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v18, (uint64_t)"/", 1LL);
      std::ostream::operator<<();
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<806ul>>::~logger_buf((uint64_t)v17);
      MEMORY[0x1895BC2CC](&v19);
    }

    else
    {
      return 0LL;
    }
  }

  return v12;
}

void sub_188121F88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<806ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<806ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E5360;
  a1[45] = &unk_18A1E5460;
  a1[46] = &unk_18A1E5488;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E5360;
  a1[45] = &unk_18A1E53E8;
  a1[46] = &unk_18A1E5410;
  return a1;
}

void sub_188122024(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<806ul>>::~logger(uint64_t a1)
{
  return a1;
}

void crypto_format_backend::write(crypto_format_backend *this, uint64_t a2)
{
  int v4 = *(char **)a2;
  int64_t v6 = *(void *)(a2 + 16);
  unint64_t v5 = *(void *)(a2 + 24);
  int64_t v7 = *(unsigned int *)(*(void *)(*((void *)this + 5) + 48LL) + 52LL);
  uint64_t v8 = v5 / v7 * v7;
  unint64_t v9 = v5 % v7;
  if (v5 % v7)
  {
    crypto_format_backend::read_aligned(this, *((char **)this + 23), 1uLL, v5 / v7 * v7);
    if (v11) {
      return;
    }
    uint64_t v12 = &v4[v9];
    size_t v13 = v6 >= (uint64_t)(v7 - v9) ? v7 - v9 : v6;
    memcpy(*((void **)this + 23), v12, v13);
    v6 -= v13;
    v4 += v13;
    v8 += v13;
  }

  if (!*(_BYTE *)(a2 + 40))
  {
    uint64_t v10 = v6 / v7;
    v4 += v10 * v7;
    v8 += v10 * v7;
    v6 %= v7;
    goto LABEL_5;
  }

  if (v6 < v7)
  {
LABEL_5:
    if (v6)
    {
      crypto_format_backend::read_aligned(this, *((char **)this + 23), 1uLL, v8);
      if (!v15)
      {
        memcpy(*((void **)this + 23), v4, v6);
        crypto_format_backend::write_aligned(this, *((char **)this + 23), 1uLL, v8);
      }
    }

    return;
  }

  uint64_t v14 = 0LL;
  while (1)
  {
    memcpy(*((void **)this + 23), &v4[v14], v7);
    v6 -= v7;
    v14 += v7;
    if (v6 < v7)
    {
      v4 += v14;
      v8 += v14;
      goto LABEL_5;
    }
  }

uint64_t crypto_format_backend::unmap_range(crypto_format_backend *this, uint64_t a2)
{
  uint64_t v3 = *((void *)this + 3);
  if ((*((_BYTE *)this + 192) & 1) != 0) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = *(void *)(*(void *)(*((void *)this + 5) + 48LL) + 64LL);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 24LL))(v3, v4 + a2);
}

uint64_t crypto_format_backend::truncate(crypto_format_backend *this, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  int v3 = *((_DWORD *)this + 48);
  uint64_t v4 = *(void *)(*((void *)this + 5) + 48LL);
  if ((v3 & 2) == 0) {
    *(void *)(v4 + ++*(_DWORD *)(this + 56) = a2;
  }
  uint64_t v5 = *((void *)this + 3);
  if ((v3 & 1) != 0) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = *(void *)(v4 + 64);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v5 + 56LL))( v5,  (a2 + (unint64_t)*(unsigned int *)(v4 + 52) - 1)
       / *(unsigned int *)(v4 + 52)
  if (!(_DWORD)v7)
  {
    crypto::header::write(*(crypto::header **)(*((void *)this + 5) + 48LL), v21);
    unint64_t v9 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
    int v16 = v21;
    uint64_t v17 = v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }

    __int128 v18 = xmmword_188181260;
    uint64_t v19 = 76LL;
    char v20 = 0;
    unsigned int v12 = (*(uint64_t (**)(void, char **))(**((void **)this + 3) + 80LL))(*((void *)this + 3), &v16);
    size_t v13 = v17;
    if ((void)v18 == v12) {
      uint64_t v7 = 0LL;
    }
    else {
      uint64_t v7 = v12;
    }
    if (v17)
    {
      uint64_t v14 = (unint64_t *)&v17->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  return v7;
}

void sub_188122398(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

const void **crypto_format_backend::populate_backend_info(crypto_format_backend *this, DiskImageInfo *a2)
{
  return crypto::header::populate_crypto_header_info(*(crypto::header **)(*((void *)this + 5) + 48LL), a2);
}

uint64_t crypto_format_backend::crypto_format_backend(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)a2 + 72LL))(&v14);
  BackendInternalBackend::BackendInternalBackend((Backend *)a1, &v14);
  uint64_t v7 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  *(void *)a1 = off_18A1E4968;
  *(void *)(a1 + 40) = *a3;
  uint64_t v10 = a3[1];
  *(void *)(a1 + 48) = v10;
  if (v10)
  {
    unint64_t v11 = (unint64_t *)(v10 + 8);
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  crypto::format::aes_context::aes_context( a1 + 56,  0,  *a3,  *(void *)(*a3 + 56),  *(unsigned int *)(*(void *)(*a3 + 48) + 52LL));
  crypto::format::aes_context::aes_context( a1 + 120,  1u,  *a3,  *(void *)(*a3 + 56),  *(unsigned int *)(*(void *)(*a3 + 48) + 52LL));
  *(void *)(a1 + 184) = operator new[](*(unsigned int *)(*(void *)(*a3 + 48) + 52LL));
  *(_DWORD *)(a1 + 192) = *a4;
  return a1;
}

void sub_1881224E4(_Unwind_Exception *a1)
{
}

void BackendInternalBackend::BackendInternalBackend(Backend *a1, void *a2)
{
  *int v3 = off_18A1E5578;
  uint64_t v4 = a2[1];
  void v3[3] = *a2;
  v3[4] = v4;
  if (v4)
  {
    uint64_t v5 = (unint64_t *)(v4 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

void BackendInternalBackend::~BackendInternalBackend(BackendInternalBackend *this)
{
  *(void *)this = off_18A1E5578;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t crypto_format_backend::crypto_format_backend(uint64_t a1, uint64_t a2, void *a3)
{
  *uint64_t v5 = off_18A1E4968;
  uint64_t v6 = *(void *)(a2 + 48);
  v5[5] = *(void *)(a2 + 40);
  v5[6] = v6;
  if (v6)
  {
    uint64_t v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  crypto::format::aes_context::aes_context( a1 + 56,  *(_DWORD *)(a2 + 72),  a2 + 80,  *(void *)(a2 + 112),  *(void *)(a2 + 104));
  crypto::format::aes_context::aes_context( a1 + 120,  *(_DWORD *)(a2 + 136),  a2 + 144,  *(void *)(a2 + 176),  *(void *)(a2 + 168));
  *(void *)(a1 + 184) = operator new[](*(unsigned int *)(*(void *)(*(void *)(a2 + 40) + 48LL) + 52LL));
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 192);
  return a1;
}

void sub_18812266C(_Unwind_Exception *a1)
{
}

double crypto_format_backend::construct_context_from_inner@<D0>( uint64_t a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  double result = v5[0];
  *a3 = *(_OWORD *)v5;
  return result;
}

uint64_t crypto_format_backend::get_size(crypto_format_backend *this)
{
  if ((*((_BYTE *)this + 192) & 2) != 0
    || (uint64_t result = *(void *)(*(void *)(*((void *)this + 5) + 48LL) + 56LL)) == 0)
  {
    unint64_t v3 = (*(uint64_t (**)(void))(**((void **)this + 3) + 40LL))(*((void *)this + 3));
    if ((*((_BYTE *)this + 192) & 1) != 0) {
      unint64_t v4 = 0LL;
    }
    else {
      unint64_t v4 = *(void *)(*(void *)(*((void *)this + 5) + 48LL) + 64LL);
    }
    if (v3 <= v4)
    {
      return 0LL;
    }

    else
    {
      uint64_t v5 = (*(uint64_t (**)(void))(**((void **)this + 3) + 40LL))(*((void *)this + 3));
      if ((*((_BYTE *)this + 192) & 1) != 0) {
        uint64_t v6 = 0LL;
      }
      else {
        uint64_t v6 = *(void *)(*(void *)(*((void *)this + 5) + 48LL) + 64LL);
      }
      return v5 - v6;
    }
  }

  return result;
}

void crypto_format_backend::~crypto_format_backend(crypto_format_backend *this)
{
}

{
  void *v2;
  std::__shared_weak_count *v3;
  *(void *)this = off_18A1E4968;
  uint64_t v2 = (void *)*((void *)this + 23);
  if (v2) {
    operator delete[](v2);
  }
  crypto::format::aes_context::~aes_context((CCCryptorRef *)this + 15);
  crypto::format::aes_context::~aes_context((CCCryptorRef *)this + 7);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 40);
  *(void *)this = off_18A1E5578;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t BackendInternalBackend::flush(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16LL))(*(void *)(a1 + 24));
}

uint64_t BackendInternalBackend::supports_unmap(BackendInternalBackend *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 32LL))(*((void *)this + 3));
}

uint64_t BackendInternalBackend::is_writable(BackendInternalBackend *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 48LL))(*((void *)this + 3));
}

void *crypto_format_backend::name(uint64_t a1, void *a2)
{
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"crypto", 6LL);
}

void *BackendInternalBackend::full_name(void **a1)
{
  uint64_t v2 = (void *)((uint64_t (*)(void **))(*a1)[8])(a1);
  unint64_t v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)"(", 1LL);
  unint64_t v4 = (void *)(*(uint64_t (**)(void *, void *))(*a1[3] + 64LL))(a1[3], v3);
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)")", 1LL);
}

uint64_t BackendInternalBackend::get_identifier(BackendInternalBackend *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 160LL))(*((void *)this + 3));
}

void vbuf::vbuf_exception::~vbuf_exception(std::exception *this)
{
}

uint64_t vbuf::vbuf_exception::what(vbuf::vbuf_exception *this)
{
  return *((void *)this + 1);
}

uint64_t vbuf::vbuf_exception::reason@<X0>(const char **this@<X0>, std::string *a2@<X8>)
{
  size_t v4 = strlen(this[1]);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)this[1], v4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" - ", 3LL);
  uint64_t v5 = this[2];
  size_t v6 = strlen(v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)v5, v6);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]( (uint64_t)v16,  v12);
  uint64_t v7 = *MEMORY[0x189614728];
  v12[0] = v7;
  uint64_t v9 = *(void *)(MEMORY[0x189614728] + 64LL);
  uint64_t v8 = *(void *)(MEMORY[0x189614728] + 72LL);
  *(uint64_t *)((char *)v12 + *(void *)(v7 - atomic_store(0, (unsigned int *)(v1 + 24)) = v9;
  uint64_t v10 = MEMORY[0x189614750];
  v13[0] = v8;
  v13[1] = MEMORY[0x189614750] + 16LL;
  if (v14 < 0) {
    operator delete((void *)v13[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1895BC2CC](&v15);
  std::stringbuf::str[abi:ne180100]((uint64_t)v17, a2);
  v16[0] = v7;
  *(void *)((char *)v16 + *(void *)(v7 - atomic_store(0, (unsigned int *)(v1 + 24)) = v9;
  void v16[2] = v8;
  v17[0] = v10 + 16;
  if (v18 < 0) {
    operator delete((void *)v17[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1895BC2CC](&v19);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]( uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 128) = MEMORY[0x189614770] + 16LL;
  size_t v4 = (void *)MEMORY[0x189614728];
  uint64_t v5 = *(void *)(MEMORY[0x189614728] + 16LL);
  uint64_t v6 = *(void *)(MEMORY[0x189614728] + 24LL);
  *(void *)a1 = v5;
  *(void *)(a1 + *(void *)(v5 - atomic_store(0, (unsigned int *)(v1 + 24)) = v6;
  uint64_t v7 = *a2;
  *(void *)(a1 + 8) = a2[1];
  a2[1] = 0LL;
  uint64_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24LL));
  uint64_t v9 = (std::ios_base *)((char *)a2 + *(void *)(v7 - 24));
  std::ios_base::move(v8, v9);
  v8[1].__vftable = v9[1].__vftable;
  v9[1].__vftable = 0LL;
  v8[1].__fmtflags_ = v9[1].__fmtflags_;
  uint64_t v10 = v4[4];
  uint64_t v11 = v4[5];
  *(void *)(a1 + 16) = v10;
  *(void *)(a1 + 16 + *(void *)(v10 - atomic_store(0, (unsigned int *)(v1 + 24)) = v11;
  uint64_t v12 = v4[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - atomic_store(0, (unsigned int *)(v1 + 24)) = v4[6];
  uint64_t v13 = MEMORY[0x189614758];
  *(void *)a1 = MEMORY[0x189614758] + 24LL;
  *(void *)(a1 + 128) = v13 + 104;
  *(void *)(a1 + 16) = v13 + 64;
  *(void *)(a1 + *(void *)(*(void *)a1 - 24LL) + 40) = std::stringbuf::basic_stringbuf( (std::stringbuf *)(a1 + 24),  (std::stringbuf *)(a2 + 3));
  return a1;
}

void sub_188122AE0(_Unwind_Exception *a1)
{
}

void std::stringbuf::str[abi:ne180100](uint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v4 = std::stringbuf::view[abi:ne180100](a1);
  if (v5)
  {
    uint64_t v6 = (void *)(a1 + 64);
    std::string::size_type v7 = v4 - (void)v6;
  }

  else
  {
    std::string::size_type v7 = 0LL;
  }

  *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 64);
  a2->__r_.__value_.__l.__cap_ = *(void *)(a1 + 80);
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  std::string::resize(a2, v7 + v5, 0);
  std::string::erase(a2, 0LL, v7);
  std::stringbuf::__init_buf_ptrs[abi:ne180100](a1);
}

void sub_188122B94(_Unwind_Exception *exception_object)
{
}

void *std::vector<std::byte>::vector(void *a1, size_t a2, _BYTE *a3)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    size_t v5 = a2;
    std::vector<std::byte>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = (_BYTE *)a1[1];
    std::string::size_type v7 = &v6[v5];
    do
    {
      *v6++ = *a3;
      --v5;
    }

    while (v5);
    a1[1] = v7;
  }

  return a1;
}

void sub_188122C10(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *std::vector<std::byte>::__init_with_size[abi:ne180100]<std::__wrap_iter<std::byte const*>,std::__wrap_iter<std::byte const*>>( void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<std::byte>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_188122C88(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::vector<std::byte>::__append(unint64_t *a1, size_t a2)
{
  size_t v5 = (char *)a1[1];
  uint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }

    a1[1] = (unint64_t)v5;
  }

  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0LL;
    }
    uint64_t v12 = &v7[v11];
    uint64_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }

    else
    {
      char v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }

      while (v5 != (char *)v6);
      size_t v5 = (char *)*a1;
    }

    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5) {
      operator delete(v5);
    }
  }

uint64_t std::vector<std::variant<crypto::password_header,crypto::public_key_header>>::__emplace_back_slow_path<crypto::password_header>( uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2FE592FE592FE593LL * ((a1[1] - *a1) >> 2);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2FE592FE592FE593LL * ((a1[2] - v3) >> 2);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x34DA034DA034DALL) {
    unint64_t v9 = 0x69B4069B4069B4LL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    size_t v10 = (char *)std::allocator<std::variant<crypto::password_header,crypto::public_key_header>>::allocate_at_least[abi:ne180100]( v7,  v9);
  }
  else {
    size_t v10 = 0LL;
  }
  __p = v10;
  char v14 = &v10[620 * v4];
  uint64_t v15 = (uint64_t)v14;
  int v16 = &v10[620 * v9];
  *(_DWORD *)(std::__variant_detail::__alt<0ul,crypto::password_header>::__alt[abi:ne180100]<crypto::password_header>( (uint64_t)v14,  a2)
            + 616) = 0;
  v15 += 620LL;
  std::vector<std::variant<crypto::password_header,crypto::public_key_header>>::__swap_out_circular_buffer(a1, &__p);
  uint64_t v11 = a1[1];
  if (__p) {
    operator delete(__p);
  }
  return v11;
}

void sub_188122F18( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__variant_detail::__alt<0ul,crypto::password_header>::__alt[abi:ne180100]<crypto::password_header>( uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  __int128 v4 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  __int128 v5 = *(_OWORD *)(a2 + 52);
  *(_OWORD *)(a1 + 68) = *(_OWORD *)(a2 + 68);
  *(_OWORD *)(a1 + 52) = v5;
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  bzero((void *)(a1 + 100), 0x204uLL);
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a2 + 100);
  memcpy((void *)(a1 + 104), (const void *)(a2 + 104), 0x200uLL);
  return a1;
}

uint64_t *std::vector<std::variant<crypto::password_header,crypto::public_key_header>>::__swap_out_circular_buffer( uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = v6 - 620;
    do
    {
      uint64_t v8 = v4 - 620;
      *(_BYTE *)uint64_t v7 = 0;
      *(_DWORD *)(v7 + 616) = -1;
      uint64_t v9 = *(unsigned int *)(v4 - 4);
      if ((_DWORD)v9 != -1)
      {
        uint64_t result = (uint64_t *)((uint64_t (*)(char *, uint64_t, uint64_t))off_18A1E4A98[v9])(&v13, v7, v8);
        *(_DWORD *)(v7 + 616) = v9;
      }

      v7 -= 620LL;
      uint64_t v4 = v8;
    }

    while (v8 != v5);
    uint64_t v6 = v7 + 620;
  }

  a2[1] = v6;
  uint64_t v10 = *v3;
  *uint64_t v3 = v6;
  a2[1] = v10;
  uint64_t v11 = v3[1];
  v3[1] = a2[2];
  a2[2] = v11;
  uint64_t v12 = v3[2];
  void v3[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

void *std::allocator<std::variant<crypto::password_header,crypto::public_key_header>>::allocate_at_least[abi:ne180100]( uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x69B4069B4069B5LL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(620 * a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN6crypto15password_headerENS8_17public_key_headerEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSK_OT0_E_JRNS0_6__baseILSF_0EJS9_SA_EEERKSS_EEEDcSK_DpT0_( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__variant_detail::__alt<0ul,crypto::password_header>::__alt[abi:ne180100]<crypto::password_header>(a2, a3);
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN6crypto15password_headerENS8_17public_key_headerEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSK_OT0_E_JRNS0_6__baseILSF_0EJS9_SA_EEERKSS_EEEDcSK_DpT0_( uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)a2 = *(_DWORD *)a3;
  __int128 v5 = *(_OWORD *)(a3 + 4);
  *(_OWORD *)(a2 + 20) = *(_OWORD *)(a3 + 20);
  *(_OWORD *)(a2 + 4) = v5;
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a3 + 36);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a3 + 44);
  bzero((void *)(a2 + 48), 0x204uLL);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 48);
  return memcpy((void *)(a2 + 52), (const void *)(a3 + 52), 0x200uLL);
}

uint64_t std::vector<std::variant<crypto::password_header,crypto::public_key_header>>::__emplace_back_slow_path<crypto::public_key_header>( uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2FE592FE592FE593LL * ((a1[1] - *a1) >> 2);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2FE592FE592FE593LL * ((a1[2] - v3) >> 2);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x34DA034DA034DALL) {
    unint64_t v9 = 0x69B4069B4069B4LL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v19 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::allocator<std::variant<crypto::password_header,crypto::public_key_header>>::allocate_at_least[abi:ne180100]( v7,  v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v11 = &v10[620 * v4];
  __p = v10;
  int v16 = v11;
  char v18 = &v10[620 * v9];
  *((_DWORD *)v11 + 8) = 0;
  *(_OWORD *)uint64_t v11 = 0u;
  *((_OWORD *)v11 + 1) = 0u;
  *(_DWORD *)uint64_t v11 = *(_DWORD *)a2;
  __int128 v12 = *(_OWORD *)(a2 + 4);
  *(_OWORD *)(v11 + 20) = *(_OWORD *)(a2 + 20);
  *(_OWORD *)(v11 + 4) = v12;
  *((_DWORD *)v11 + 9) = *(_DWORD *)(a2 + 36);
  *((_DWORD *)v11 + 10) = *(_DWORD *)(a2 + 40);
  *((_DWORD *)v11 + 11) = *(_DWORD *)(a2 + 44);
  bzero(v11 + 48, 0x204uLL);
  *((_DWORD *)v11 + 12) = *(_DWORD *)(a2 + 48);
  memcpy(v11 + 52, (const void *)(a2 + 52), 0x200uLL);
  *((_DWORD *)v11 + 154) = 1;
  uint64_t v17 = v11 + 620;
  std::vector<std::variant<crypto::password_header,crypto::public_key_header>>::__swap_out_circular_buffer(a1, &__p);
  uint64_t v13 = a1[1];
  if (v17 != v16) {
    uint64_t v17 = &v16[(v17 - v16 - 620) % 0x26CuLL];
  }
  if (__p) {
    operator delete(__p);
  }
  return v13;
}

void sub_188123378( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<std::byte>::vector(void *a1, size_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    std::vector<std::byte>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    unint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }

  return a1;
}

void sub_188123420(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne180100IONS1_9__variant15__value_visitorIZZN6crypto6format22get_total_entries_sizeERKNS_6vectorINS_7variantIJNS8_15password_headerENS8_17public_key_headerEEEENS_9allocatorISE_EEEEENK3__0clEmRKSE_EUlRKT_E_EEJRKNS0_6__baseILNS0_6_TraitE0EJSC_SD_EEEEEEDcSN_DpT0_()
{
  return 616LL;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IONS1_9__variant15__value_visitorIZZN6crypto6format22get_total_entries_sizeERKNS_6vectorINS_7variantIJNS8_15password_headerENS8_17public_key_headerEEEENS_9allocatorISE_EEEEENK3__0clEmRKSE_EUlRKT_E_EEJRKNS0_6__baseILNS0_6_TraitE0EJSC_SD_EEEEEEDcSN_DpT0_()
{
  return 564LL;
}

std::vector<char> *__cdecl std::vector<char>::vector(std::vector<char> *this, std::vector<char>::size_type __n)
{
  this->__begin_ = 0LL;
  this->__end_ = 0LL;
  this->__end_cap_.__value_ = 0LL;
  if (__n)
  {
    std::vector<std::byte>::__vallocate[abi:ne180100](this, __n);
    std::vector<char>::pointer end = this->__end_;
    unint64_t v5 = &end[__n];
    bzero(end, __n);
    this->__end_ = v5;
  }

  return this;
}

void sub_1881234A0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<crypto::format::write_header_and_keys(Backend &,std::vector<std::variant<crypto::password_header,crypto::public_key_header>> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,crypto::password_header,crypto::public_key_header> const&>( void ***a1, crypto::password_header *a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *a1;
  __int128 v7 = xmmword_188181250;
  int v8 = 9;
  smart_enums::validators::value<unsigned int>((uint64_t)"auth_table_entry_mechanism", 1, &v7, 5LL);
  unint64_t v4 = *v3[1];
  uint64_t v5 = *v3[2] + **v3;
  *(_DWORD *)uint64_t v5 = 0x1000000;
  *(void *)(v5 + 4) = bswap64(v4);
  *(void *)(v5 + 12) = 0x6802000000000000LL;
  **v3 += 20LL;
  uint64_t result = crypto::password_header::write(a2, (char *)(*v3[2] + *v3[1]));
  *v3[1] += 616LL;
  return result;
}

void *std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<crypto::format::write_header_and_keys(Backend &,std::vector<std::variant<crypto::password_header,crypto::public_key_header>> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,crypto::password_header,crypto::public_key_header> const&>( void ***a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *a1;
  __int128 v9 = xmmword_188181250;
  int v10 = 9;
  smart_enums::validators::value<unsigned int>((uint64_t)"auth_table_entry_mechanism", 2, &v9, 5LL);
  unint64_t v4 = *v3[1];
  uint64_t v5 = *v3[2] + **v3;
  *(_DWORD *)uint64_t v5 = 0x2000000;
  *(void *)(v5 + 4) = bswap64(v4);
  *(void *)(v5 + 12) = 0x3402000000000000LL;
  **v3 += 20LL;
  uint64_t v6 = *v3[2] + *v3[1];
  *(_DWORD *)uint64_t v6 = bswap32(*(_DWORD *)a2);
  __int128 v7 = *(_OWORD *)(a2 + 4);
  *(_OWORD *)(v6 + 20) = *(_OWORD *)(a2 + 20);
  *(_OWORD *)(v6 + 4) = v7;
  *(_DWORD *)(v6 + 36) = bswap32(*(_DWORD *)(a2 + 36));
  *(_DWORD *)(v6 + 40) = bswap32(*(_DWORD *)(a2 + 40));
  *(_DWORD *)(v6 + 44) = bswap32(*(_DWORD *)(a2 + 44));
  *(_DWORD *)(v6 + 48) = bswap32(*(_DWORD *)(a2 + 48));
  uint64_t result = memcpy((void *)(v6 + 52), (const void *)(a2 + 52), 0x200uLL);
  *v3[1] += 564LL;
  return result;
}

void *di_log::logger<di_log::log_printer<564ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<564ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E4AE0;
  a1[45] = &unk_18A1E4BE0;
  a1[46] = &unk_18A1E4C08;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E4AE0;
  a1[45] = &unk_18A1E4B68;
  a1[46] = &unk_18A1E4B90;
  return a1;
}

void sub_188123764(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<564ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<578ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<578ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E4D00;
  a1[45] = &unk_18A1E4E00;
  a1[46] = &unk_18A1E4E28;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E4D00;
  a1[45] = &unk_18A1E4D88;
  a1[46] = &unk_18A1E4DB0;
  return a1;
}

void sub_18812384C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<578ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<564ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E4C78;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188123918(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<564ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E4C78;
  di_log::logger_buf<di_log::log_printer<564ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<564ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<564ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<564ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<564ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<564ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<564ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<564ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<564ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<564ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<564ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<564ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<564ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<564ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188123CCC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<564ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 564LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 564LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t di_log::logger_buf<di_log::log_printer<578ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E4E98;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188123F40(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<578ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E4E98;
  di_log::logger_buf<di_log::log_printer<578ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<578ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<578ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<578ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<578ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<578ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<578ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<578ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<578ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<578ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<578ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<578ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<578ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<578ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1881242F4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<578ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 578LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 578LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<690ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<690ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<690ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<690ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<690ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<690ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<690ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<690ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<690ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<690ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E50B8;
  di_log::logger_buf<di_log::log_printer<690ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<690ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<690ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188124888( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<690ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<690ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<690ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 690LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 690LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<738ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<738ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<738ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<738ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<738ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<738ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<738ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<738ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<738ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<738ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E52D8;
  di_log::logger_buf<di_log::log_printer<738ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<738ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<738ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188124E34( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<738ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<738ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<738ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 738LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 738LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<806ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<806ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<806ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<806ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<806ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<806ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<806ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<806ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<806ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<806ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E54F8;
  di_log::logger_buf<di_log::log_printer<806ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<806ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<806ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1881253E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<806ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<806ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<806ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 806LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    __int128 v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        char v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 806LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t BackendInternalBackend::unmap_range(BackendInternalBackend *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 24LL))(*((void *)this + 3));
}

uint64_t BackendInternalBackend::get_size(BackendInternalBackend *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 40LL))(*((void *)this + 3));
}

uint64_t BackendInternalBackend::truncate(BackendInternalBackend *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 56LL))(*((void *)this + 3));
}

uint64_t BackendInternalBackend::write(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 80LL))(*(void *)(a1 + 24));
}

uint64_t BackendInternalBackend::read(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 88LL))(*(void *)(a1 + 24));
}

void BackendInternalBackend::construct_context_from_inner(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v3);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v3,  (uint64_t)"Unexpected context construction by ",  35LL);
  operator<<((uint64_t)v3, a1);
  DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v3, 0x16u);
}

void sub_1881256DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27)
{
  *(void *)(v28 + *(void *)(*MEMORY[0x189614738] - 24LL)) = *(void *)(MEMORY[0x189614738] + 24LL);
  if (a24 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](&a27);
  if (v29) {
    __cxa_free_exception(v27);
  }
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<crypto::format::aes_iv,std::allocator<crypto::format::aes_iv>,std::vector<std::byte> &,void>@<X0>( uint64_t a1@<X1>, void *a2@<X8>)
{
  int v4 = (char *)operator new(0x198uLL);
  uint64_t result = std::__shared_ptr_emplace<crypto::format::aes_iv>::__shared_ptr_emplace[abi:ne180100]<std::vector<std::byte> &,std::allocator<crypto::format::aes_iv>,0>( (uint64_t)v4,  a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_188125810(_Unwind_Exception *a1)
{
}

uint64_t std::__shared_ptr_emplace<crypto::format::aes_iv>::__shared_ptr_emplace[abi:ne180100]<std::vector<std::byte> &,std::allocator<crypto::format::aes_iv>,0>( uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_18A1E5640;
  CCHmacInit((CCHmacContext *)(a1 + 24), 0, *(const void **)a2, *(void *)(a2 + 8) - *(void *)a2);
  return a1;
}

void sub_188125864(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<crypto::format::aes_iv>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_18A1E5640;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<crypto::format::aes_iv>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_18A1E5640;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<690ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E50B8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188125918(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<738ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E52D8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188125994(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<806ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E54F8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188125A10(_Unwind_Exception *a1)
{
}

void std::allocate_shared[abi:ne180100]<crypto_format_backend,std::allocator<crypto_format_backend>,crypto_format_backend&,std::shared_ptr<Backend> const&,void>( uint64_t a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  char v6 = operator new(0xE0uLL);
  std::__shared_ptr_emplace<crypto_format_backend>::__shared_ptr_emplace[abi:ne180100]<crypto_format_backend&,std::shared_ptr<Backend> const&,std::allocator<crypto_format_backend>,0>( v6,  a1,  a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a3,  v6 + 4,  (uint64_t)(v6 + 3));
}

void sub_188125A78(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<crypto_format_backend>::__shared_ptr_emplace[abi:ne180100]<crypto_format_backend&,std::shared_ptr<Backend> const&,std::allocator<crypto_format_backend>,0>( void *a1, uint64_t a2, void *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1CC2E8;
  crypto_format_backend::crypto_format_backend((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_188125AC0(_Unwind_Exception *a1)
{
}

void AEAHelper::create_auth_data(void *a1@<X0>, AEAwrapper::AuthData *a2@<X8>)
{
  int v3 = (*(uint64_t (**)(void))(*(void *)*a1 + 176LL))(*a1);
  if (v3 < 0)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "AEAHelper: Invalid file descriptor.", 0x16u);
  }

  AEAContext v6 = AAFileStreamOpenWithFD(v3, 0);
  AEAwrapper::ByteStream::ByteStream(&v7, &v6);
  AEAwrapper::Context::Context((AEAwrapper::Context *)&v6, (AEAwrapper::ByteStream *)&v7);
  AEAwrapper::AuthData::AuthData(a2, (AEAwrapper::Context *)&v6);
  AEAwrapper::Context::~Context(&v6);
  AEAwrapper::ByteStream::~ByteStream(&v7);
}

void sub_188125B78( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, AAByteStream a10)
{
}

void AEAHelper::create_key_parameters(AEAAuthData *this@<X0>, uint64_t a2@<X8>)
{
  __int128 v5 = operator new[](0x20uLL);
  *__int128 v5 = 0u;
  v5[1] = 0u;
  memset(&v24, 0, sizeof(v24));
  char v25 = 1;
  std::string::basic_string[abi:ne180100]<0>(__p, "encryption_key");
  get_auth_data_value(this, (uint64_t)__p, (uint64_t)&v28);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (!v29)
  {
    std::string::basic_string[abi:ne180100]<0>(v22, "com.apple.wkms.fcs-key-url");
    get_auth_data_value(this, (uint64_t)v22, (uint64_t)&v28);
    int v10 = *(unsigned __int8 *)(std::expected<std::string,std::error_code>::operator=[abi:ne180100]( (uint64_t)&v24,  (__int128 *)&v28)
                             + 24);
    if (v23 < 0)
    {
      operator delete(v22[0]);
      if (v10) {
        goto LABEL_21;
      }
    }

    else if (v10)
    {
LABEL_21:
      else {
        std::string v28 = v24;
      }
      *(std::string *)a2 = v28;
      *(void *)(a2 + 24) = this;
      int v12 = 3;
LABEL_46:
      *(_DWORD *)(a2 + 32) = v12;
      goto LABEL_47;
    }

    std::string::basic_string[abi:ne180100]<0>(v20, "saksKey");
    get_auth_data_value(this, (uint64_t)v20, (uint64_t)&v28);
    int v11 = *(unsigned __int8 *)(std::expected<std::string,std::error_code>::operator=[abi:ne180100]( (uint64_t)&v24,  (__int128 *)&v28)
                             + 24);
    if (v21 < 0)
    {
      operator delete(v20[0]);
      if (v11) {
        goto LABEL_29;
      }
    }

    else if (v11)
    {
LABEL_29:
      else {
        std::string v28 = v24;
      }
      *(std::string *)a2 = v28;
      int v12 = 1;
      goto LABEL_46;
    }

    std::string::basic_string[abi:ne180100]<0>(v18, "com.apple.knox.url");
    get_auth_data_value(this, (uint64_t)v18, (uint64_t)&v28);
    int v13 = *(unsigned __int8 *)(std::expected<std::string,std::error_code>::operator=[abi:ne180100]( (uint64_t)&v24,  (__int128 *)&v28)
                             + 24);
    if (v19 < 0) {
      operator delete(v18[0]);
    }
    if (!v13)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = off_18A1E43B0;
      int v17 = std::generic_category();
      exception[1] = 22LL;
      exception[2] = v17;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 48) = 0;
      exception[7] = "Missing Expected AUTH DATA in AEA.";
    }

    else {
      std::string v28 = v24;
    }
    *(std::string *)a2 = v28;
    int v12 = 2;
    goto LABEL_46;
  }

  if ((v28.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    AEAContext v6 = &v28;
  }
  else {
    AEAContext v6 = (std::string *)v28.__r_.__value_.__r.__words[0];
  }
  if (strlen((const char *)v6) != 64)
  {
    uint64_t v8 = "Key is not 32 bytes size.";
LABEL_54:
    char v14 = __cxa_allocate_exception(0x40uLL);
    void *v14 = off_18A1E43B0;
    uint64_t v15 = std::generic_category();
    v14[1] = 22LL;
    void v14[2] = v15;
    *((_BYTE *)v14 + 24) = 0;
    *((_BYTE *)v14 + 48) = 0;
    v14[7] = v8;
  }

  uint64_t v7 = 0LL;
  char v31 = 0;
  uint64_t v8 = "Key is not hexadecimal number.";
  do
  {
    *(_WORD *)__str = *((_WORD *)&v6->__r_.__value_.__l.__data_ + v7);
    char v9 = strtol(__str, 0LL, 16);
    *((_BYTE *)v5 + v7) = v9;
    ++v7;
  }

  while (v7 != 32);
  *(void *)a2 = v5;
  *(_DWORD *)(a2 + 32) = 0;
  __int128 v5 = 0LL;
LABEL_47:
  if (v5) {
    operator delete[](v5);
  }
}

void sub_188125F74( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, char a33, int a34, __int16 a35, char a36, char a37, uint64_t a38, int a39, __int16 a40, char a41, char a42)
{
  if (a33)
  {
    if (a32 < 0) {
      operator delete(__p);
    }
  }

  operator delete[](v42);
  _Unwind_Resume(a1);
}

uint64_t *get_auth_data_value@<X0>(AEAAuthData *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  AEAContext v6 = (char *)valloc(0x800uLL);
  if (!v6)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    char v23 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v23, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  __s = (char *)off_18A1E5690;
  p_s = &__s;
  __s2 = v6;
  std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)&v31, (uint64_t)&__s);
  uint64_t v7 = p_s;
  if (p_s == &__s)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = &__s;
  }

  else
  {
    if (!p_s) {
      goto LABEL_7;
    }
    uint64_t v8 = 5LL;
  }

  (*(void (**)(void))&(*v7)[8 * v8])();
LABEL_7:
  EntryCFIndex Count = AEAwrapper::AuthData::getEntryCount(a1);
  if (!EntryCount)
  {
LABEL_15:
    char v14 = std::generic_category();
    uint64_t v15 = 22LL;
    goto LABEL_16;
  }

  uint32_t v10 = 0;
  int v11 = __s2;
  while (1)
  {
    bzero(v11, 0x800uLL);
    if (AEAwrapper::AuthData::getEntry(a1, v10, 0x800uLL, v11, 0LL, 0LL, 0LL, &v26))
    {
      char v14 = std::generic_category();
      *(_DWORD *)a3 = 1;
      goto LABEL_18;
    }

    if (*(char *)(a2 + 23) < 0)
    {
      int v13 = *(const char **)a2;
      size_t v12 = *(void *)(a2 + 8);
    }

    else
    {
      size_t v12 = *(unsigned __int8 *)(a2 + 23);
      int v13 = (const char *)a2;
    }

    int v11 = __s2;
    if (!strncmp(v13, __s2, v12)) {
      break;
    }
    if (EntryCount == ++v10) {
      goto LABEL_15;
    }
  }

  if (v26 < 0x100000)
  {
    int v17 = (char *)valloc(v26 + 1);
    if (!v17)
    {
      std::string v24 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      char v25 = std::bad_alloc::bad_alloc(v24);
      __cxa_throw(v25, MEMORY[0x189614708], MEMORY[0x189614690]);
    }

    v32[0] = off_18A1E5690;
    unint64_t v33 = v32;
    __s = v17;
    std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)&v28, (uint64_t)v32);
    __int16 v18 = v33;
    if (v33 == v32)
    {
      uint64_t v19 = 4LL;
      __int16 v18 = v32;
    }

    else
    {
      if (!v33)
      {
LABEL_28:
        bzero(__s, v26 + 1);
        if (AEAwrapper::AuthData::getEntry( a1,  v10,  0x800uLL,  __s2,  0LL,  v26,  (unsigned __int8 *)__s,  0LL))
        {
          __int16 v20 = std::generic_category();
          char v21 = 0;
          *(_DWORD *)a3 = 1;
          *(void *)(a3 + 8) = v20;
        }

        else
        {
          std::string::basic_string[abi:ne180100]<0>((void *)a3, __s);
          char v21 = 1;
        }

        *(_BYTE *)(a3 + 24) = v21;
        std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&__s);
        return std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&__s2);
      }

      uint64_t v19 = 5LL;
    }

    (*(void (**)(void))(*v18 + 8 * v19))();
    goto LABEL_28;
  }

  char v14 = std::generic_category();
  uint64_t v15 = 84LL;
LABEL_16:
  *(void *)a3 = v15;
LABEL_18:
  *(void *)(a3 + 8) = v14;
  *(_BYTE *)(a3 + 24) = 0;
  return std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&__s2);
}

void sub_1881262C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t std::expected<std::string,std::error_code>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    int v4 = *(char *)(a1 + 23);
    if (*((_BYTE *)a2 + 24))
    {
      if (v4 < 0) {
        operator delete(*(void **)a1);
      }
      __int128 v5 = *a2;
      *(void *)(a1 + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v5;
      *((_BYTE *)a2 + 23) = 0;
      *(_BYTE *)a2 = 0;
    }

    else
    {
      if (v4 < 0) {
        operator delete(*(void **)a1);
      }
      *(_OWORD *)a1 = *a2;
      *(_BYTE *)(a1 + 24) = 0;
    }
  }

  else if (*((_BYTE *)a2 + 24))
  {
    __int128 v6 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v6;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    *(_BYTE *)(a1 + 24) = 1;
  }

  else
  {
    *(_OWORD *)a1 = *a2;
  }

  return a1;
}

AEAwrapper::AuthData *AEAHelper::AEAHelper(AEAwrapper::AuthData *a1, void *a2)
{
  return a1;
}

void sub_1881263D8(_Unwind_Exception *a1)
{
}

uint64_t *AEAwrapper::ByteStream::ByteStream(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  int *result = *a2;
  if (!v2)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Error opening ByteStream", 0x16u);
  }

  return result;
}

void AEAwrapper::ByteStream::~ByteStream(AAByteStream *this)
{
}

ssize_t AEAwrapper::ByteStream::pread(AAByteStream *this, void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPRead(*this, a2, a3, a4);
}

uint64_t *AEAwrapper::ByteStream::make_DecryptionRandomAccessInputStream@<X0>( AAByteStream *a1@<X0>, AEAContext *a2@<X1>, size_t a3@<X2>, AAFlagSet a4@<X3>, int a5@<W4>, uint64_t *a6@<X8>)
{
  AAByteStream v8 = AEADecryptionRandomAccessInputStreamOpen(*a1, *a2, a3, a4, a5);
  return AEAwrapper::ByteStream::ByteStream(a6, (uint64_t *)&v8);
}

AEAwrapper::Context *AEAwrapper::Context::Context(AEAwrapper::Context *this, AAByteStream *a2)
{
  AEAContext v3 = AEAContextCreateWithEncryptedStream(*a2);
  *(void *)this = v3;
  if (!v3)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Context creation failed.", 0x16u);
  }

  return this;
}

void AEAwrapper::Context::~Context(AEAContext *this)
{
}

uint64_t AEAwrapper::Context::setSymmetricKey(AEAContext *this, uint8_t *buf, size_t buf_size)
{
  uint64_t result = AEAContextSetFieldBlob(*this, 9u, 0, buf, buf_size);
  if ((result & 0x80000000) != 0)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Context setup failed.", 0x16u);
  }

  return result;
}

uint64_t (**AEAwrapper::Context::getAEAIdentifier(AEAContext_impl **this))()
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *this;
  buf_uint64_t size = 0LL;
  if (AEAContextGetFieldBlob(v1, 0x12u, 0, 0LL, 0LL, &buf_size) < 0) {
    return 0LL;
  }
  size_t v2 = buf_size;
  if (buf_size >= 0x100000) {
    size_t v3 = 0x100000LL;
  }
  else {
    size_t v3 = buf_size;
  }
  int v4 = (uint8_t *)valloc(v3);
  if (!v4)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    size_t v12 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v12, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  CCHmacContext __dst = off_18A1E5710;
  p_dst = &__dst;
  buf = v4;
  std::__function::__value_func<void ()(char *)>::__value_func[abi:ne180100]((uint64_t)&v15, (uint64_t)&__dst);
  __int128 v5 = p_dst;
  if (p_dst == &__dst)
  {
    uint64_t v6 = 4LL;
    __int128 v5 = &__dst;
    goto LABEL_11;
  }

  if (p_dst)
  {
    uint64_t v6 = 5LL;
LABEL_11:
    (*v5)[v6]();
  }

  AAByteStream v8 = buf;
  if (AEAContextGetFieldBlob(v1, 0x12u, 0, v3, buf, 0LL) < 0)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    if (v2 >= 0x10) {
      size_t v9 = 16LL;
    }
    else {
      size_t v9 = v2;
    }
    memcpy(&__dst, v8, v9);
    uint64_t v7 = __dst;
  }

  std::unique_ptr<char,std::function<void ()(char *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&buf);
  return v7;
}

void sub_1881267A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

AEAwrapper::AuthData *AEAwrapper::AuthData::AuthData(AEAwrapper::AuthData *this, AEAContext *a2)
{
  AEAAuthData v3 = AEAAuthDataCreateWithContext(*a2);
  *(void *)this = v3;
  if (!v3)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Authentication Data creation failed.", 0x16u);
  }

  return this;
}

void AEAwrapper::AuthData::~AuthData(AEAAuthData *this)
{
}

uint64_t AEAwrapper::AuthData::getEntryCount(AEAAuthData *this)
{
  return AEAAuthDataGetEntryCount(*this);
}

uint64_t AEAwrapper::AuthData::getEntry( AEAAuthData *this, uint32_t a2, size_t a3, char *a4, unint64_t *a5, size_t a6, unsigned __int8 *a7, unint64_t *a8)
{
  return AEAAuthDataGetEntry(*this, a2, a3, a4, a5, a6, a7, a8);
}

void *AEAwrapper::DecryptionStream::DecryptionStream(void *result, void *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = *a3;
  int *result = *a2;
  *a2 = 0LL;
  result[1] = v4;
  *a3 = 0LL;
  result[2] = *a4;
  *a4 = 0LL;
  return result;
}

uint64_t AEAwrapper::DecryptionStream::getCompressionBlockSize(AEAContext *this)
{
  return AEAContextGetFieldUInt(this[1], 4u);
}

uint64_t AEAwrapper::DecryptionStream::getRawSize(AEAContext *this)
{
  return AEAContextGetFieldUInt(this[1], 0xDu);
}

ssize_t AEAwrapper::DecryptionStream::pread(AAByteStream *this, void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPRead(this[2], a2, a3, a4);
}

uint64_t transformed_extents_iterator_interface::transformed_extents_iterator_interface( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = &unk_18A1E57D8;
  *(void *)(a1 + 8) = v4;
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v5 = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = v6;
  *(void *)(a1 + 40) = v5;
  *(void *)a1 = off_18A1E5790;
  DiskImage::const_extents_iterator_t::const_extents_iterator_t(a1 + 48, (void *)(a2 + 48));
  DiskImage::const_extents_iterator_t::const_extents_iterator_t(a1 + 96, (void *)(a2 + 96));
  uint64_t v7 = *(_OWORD **)(a2 + 144);
  uint64_t v8 = *(void *)(a2 + 152);
  *(void *)(a1 + 144) = v7;
  *(void *)(a1 + 152) = v8;
  if (v8)
  {
    size_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    uint64_t v7 = *(_OWORD **)(a1 + 144);
  }

  *(_OWORD *)(a1 + 160) = *v7;
  return a1;
}

void sub_1881269D4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  *uint64_t v1 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t transformed_extents_iterator_interface::transformed_extents_iterator_interface( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, uint64_t a7)
{
  *(void *)a1 = &unk_18A1E57D8;
  *(void *)(a1 + 8) = a2;
  uint64_t v10 = *(void *)(a3 + 16);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a3;
  *(void *)(a1 + 32) = v10;
  *(void *)(a1 + 40) = a4;
  *(void *)a1 = off_18A1E5790;
  DiskImage::const_extents_iterator_t::const_extents_iterator_t(a1 + 48, a5);
  DiskImage::const_extents_iterator_t::const_extents_iterator_t(a1 + 96, a6);
  std::allocate_shared[abi:ne180100]<std::vector<DiskImage::diskimage_extent_t>,std::allocator<std::vector<DiskImage::diskimage_extent_t>>,std::vector<DiskImage::diskimage_extent_t> const&,void>( a7,  (void *)(a1 + 144));
  int v11 = *(uint64_t **)(a1 + 144);
  uint64_t v13 = *v11;
  uint64_t v12 = v11[1];
  *(void *)(a1 + 160) = v13;
  *(void *)(a1 + 168) = v12;
  if (v12 == v13) {
    unint64_t v14 = 0LL;
  }
  else {
    unint64_t v14 = *(void *)(v12 - 24);
  }
  if (*(void *)(a1 + 24) > v14) {
    unint64_t v14 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 24) = v14;
  *(_BYTE *)(a1 + 32) = 2;
  return a1;
}

void sub_188126AC8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  uint64_t *v2 = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  }
  uint64_t v5 = *v1;
  *uint64_t v1 = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  }
  _Unwind_Resume(exception_object);
}

BOOL transformed_extents_iterator_interface::get_next_extent@<W0>( transformed_extents_iterator_interface *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = a2;
  uint64_t v7 = *((void *)this + 20);
  uint64_t v6 = *((void *)this + 21);
  while (v7 != v6 && *(void *)(v7 + 8) <= a2)
  {
    v7 += 32LL;
    *((void *)this + 20) = v7;
  }

  while (DiskImage::const_extents_iterator_t::operator!=((uint64_t)this + 48, (uint64_t)this + 96))
  {
    if (*((_DWORD *)this + 20) == 3 || *((void *)this + 8) > v3) {
      break;
    }
    DiskImage::const_extents_iterator_t::operator++( (transformed_extents_iterator_interface *)((char *)this + 48),  (uint64_t)v19);
    uint64_t v8 = v19[0];
    v19[0] = 0LL;
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 24LL))(v8);
    }
  }

  BOOL result = DiskImage::const_extents_iterator_t::operator!=((uint64_t)this + 48, (uint64_t)this + 96);
  if (result && *((_DWORD *)this + 20) == 3)
  {
    unint64_t v10 = *((void *)this + 8);
    if (*((void *)this + 7) > v3) {
      unint64_t v3 = *((void *)this + 7);
    }
    int v11 = 3;
    goto LABEL_44;
  }

  BOOL result = DiskImage::const_extents_iterator_t::operator==((uint64_t)this + 48, (uint64_t)this + 96);
  uint64_t v12 = *((void *)this + 20);
  uint64_t v13 = *((void *)this + 21);
  if (result && v12 == v13)
  {
    int v11 = 0;
    unint64_t v10 = *((void *)this + 3);
    goto LABEL_44;
  }

  if (v12 == v13)
  {
    unint64_t v10 = *((void *)this + 7);
    if (v10 <= v3)
    {
      unint64_t v10 = *((void *)this + 8);
      int v11 = *((_DWORD *)this + 20);
      goto LABEL_44;
    }

    goto LABEL_39;
  }

  BOOL result = DiskImage::const_extents_iterator_t::operator==((uint64_t)this + 48, (uint64_t)this + 96);
  if (result)
  {
    unint64_t v14 = (unint64_t *)*((void *)this + 20);
    unint64_t v10 = *v14;
    if (*v14 <= v3)
    {
      unint64_t v10 = v14[1];
      int v11 = *((_DWORD *)v14 + 6);
      goto LABEL_44;
    }

BOOL transformed_extents_iterator_interface::make_val@<W0>( transformed_extents_iterator_interface *this@<X0>, uint64_t a2@<X8>)
{
  BOOL result = transformed_extents_iterator_interface::get_next_extent(this, *((void *)this + 5), (uint64_t)v9);
  int v5 = *(_DWORD *)&v9[24];
  uint64_t v7 = *(void *)v9;
  unint64_t v6 = *(void *)&v9[8];
  do
  {
    if (v6 >= *((void *)this + 3)) {
      break;
    }
    if (v5 == 3) {
      break;
    }
    if (v5 != *(_DWORD *)&v9[24]) {
      break;
    }
    unint64_t v6 = *(void *)&v9[8];
    BOOL result = transformed_extents_iterator_interface::get_next_extent(this, *(unint64_t *)&v9[8], (uint64_t)v8);
    *(_OWORD *)size_t v9 = v8[0];
    *(_OWORD *)&v9[12] = *(_OWORD *)((char *)v8 + 12);
  }

  while (*(void *)&v8[0] == v6);
  *(void *)a2 = v7;
  *(void *)(a2 + 8) = v6;
  *(_BYTE *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 24) = v5;
  return result;
}

void *DiskImage::extents_t_transformer::make_custom_interface_extents@<X0>( __int128 *a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  std::__function::__value_func<diskimage_uio::expected_ns::std::experimental::fundamentals_v3::expected<std::unique_ptr<DiskImage::Context>,std::error_code> ()(void)>::__value_func[abi:ne180100]( (uint64_t)v9,  a2);
  DiskImage::extents_t::extents_t(a4, a1, (uint64_t)v9, a3);
  BOOL result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    BOOL result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_188126E48( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  unint64_t v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    unint64_t v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t DiskImage::extents_t::extents_t(uint64_t a1, __int128 *a2, uint64_t a3, __int128 *a4)
{
  __int128 v7 = *a2;
  *(_OWORD *)(a1 + 9) = *(__int128 *)((char *)a2 + 9);
  *(_OWORD *)a1 = v7;
  uint64_t v8 = *((void *)a2 + 4);
  *((void *)a2 + 4) = 0LL;
  *(void *)(a1 + 32) = v8;
  uint64_t v9 = *((void *)a2 + 5);
  *(_DWORD *)(a1 + 48) = *((_DWORD *)a2 + 12);
  *(void *)(a1 + 40) = v9;
  unint64_t v10 = (void *)std::__function::__value_func<std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::__value_func[abi:ne180100]( a1 + 56,  (uint64_t)a2 + 56);
  std::function<std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::operator=( v10,  a3);
  __int128 v11 = *a4;
  *(_BYTE *)(a1 + 24) = *((_BYTE *)a4 + 16);
  *(_OWORD *)(a1 + 8) = v11;
  return a1;
}

void sub_188126F08(_Unwind_Exception *a1)
{
}

uint64_t DiskImage::extents_t_transformer::make_transformed_extents@<X0>( DiskImage::extents_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  DiskImage::extents_t::begin(a1, (uint64_t)v52);
  DiskImage::extents_t::end(a1, (uint64_t)v51);
  unint64_t v6 = (char *)operator new(0x30uLL);
  *((void *)v6 + 1) = 0LL;
  __int128 v7 = (unint64_t *)(v6 + 8);
  *((void *)v6 + 2) = 0LL;
  *(void *)unint64_t v6 = off_18A1E5808;
  *(_OWORD *)(v6 + 24) = *(_OWORD *)a2;
  *((void *)v6 + 5) = *(void *)(a2 + 16);
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  __int128 v49 = v6 + 24;
  __int128 v50 = (std::__shared_weak_count *)v6;
  DiskImage::const_extents_iterator_t::const_extents_iterator_t((uint64_t)v46, v52);
  DiskImage::const_extents_iterator_t::const_extents_iterator_t((uint64_t)v47, v51);
  *(void *)&__int128 v48 = v6 + 24;
  *((void *)&v48 + 1) = v6;
  do
    unint64_t v8 = __ldxr(v7);
  while (__stxr(v8 + 1, v7));
  uint64_t v9 = *((void *)v6 + 4);
  if (v9 == *((void *)v6 + 3)) {
    unint64_t v10 = 0LL;
  }
  else {
    unint64_t v10 = *(void *)(v9 - 24);
  }
  if (*((void *)a1 + 2) > v10) {
    unint64_t v10 = *((void *)a1 + 2);
  }
  *(void *)&__int128 v44 = *((void *)a1 + 1);
  *((void *)&v44 + 1) = v10;
  char v45 = 2;
  DiskImage::const_extents_iterator_t::const_extents_iterator_t((uint64_t)&v35, v46);
  DiskImage::const_extents_iterator_t::const_extents_iterator_t((uint64_t)&v39, v47);
  __int128 v43 = v48;
  if (*((void *)&v48 + 1))
  {
    __int128 v11 = (unint64_t *)(*((void *)&v48 + 1) + 8LL);
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  BOOL v54 = 0LL;
  uint64_t v13 = (char *)operator new(0x78uLL);
  uint64_t v14 = v35;
  *(void *)uint64_t v13 = off_18A1E5858;
  *((void *)v13 + 1) = v14;
  __int128 v15 = v37;
  *((_OWORD *)v13 + 1) = v36;
  *((_OWORD *)v13 + 2) = v15;
  *((_DWORD *)v13 + 12) = v38;
  uint64_t v16 = v39;
  uint64_t v35 = 0LL;
  uint64_t v39 = 0LL;
  *((void *)v13 + 7) = v16;
  __int128 v17 = v41;
  *((_OWORD *)v13 + 4) = v40;
  *((_OWORD *)v13 + 5) = v17;
  *((_DWORD *)v13 + 24) = v42;
  *(_OWORD *)(v13 + 104) = v43;
  __int128 v43 = 0uLL;
  BOOL v54 = v13;
  DiskImage::extents_t_transformer::make_custom_interface_extents((__int128 *)a1, (uint64_t)v53, &v44, a3);
  uint64_t v18 = v54;
  if (v54 == v53)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = v53;
    goto LABEL_15;
  }

  if (v54)
  {
    uint64_t v19 = 5LL;
LABEL_15:
    (*(void (**)(void))(*v18 + 8 * v19))();
  }

  __int16 v20 = (std::__shared_weak_count *)*((void *)&v43 + 1);
  if (*((void *)&v43 + 1))
  {
    char v21 = (unint64_t *)(*((void *)&v43 + 1) + 8LL);
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  uint64_t v23 = v39;
  uint64_t v39 = 0LL;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 24LL))(v23);
  }
  uint64_t v24 = v35;
  uint64_t v35 = 0LL;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 24LL))(v24);
  }
  char v25 = (std::__shared_weak_count *)*((void *)&v48 + 1);
  if (*((void *)&v48 + 1))
  {
    size_t v26 = (unint64_t *)(*((void *)&v48 + 1) + 8LL);
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  uint64_t v28 = v47[0];
  v47[0] = 0LL;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 24LL))(v28);
  }
  uint64_t v29 = v46[0];
  v46[0] = 0LL;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
  }
  int64_t v30 = v50;
  if (v50)
  {
    p_shared_owners = (unint64_t *)&v50->__shared_owners_;
    do
      unint64_t v32 = __ldaxr(p_shared_owners);
    while (__stlxr(v32 - 1, p_shared_owners));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }

  uint64_t v33 = v51[0];
  v51[0] = 0LL;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 24LL))(v33);
  }
  uint64_t result = v52[0];
  v52[0] = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

void sub_188127268( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26)
{
  uint64_t v29 = *(void **)(v27 - 80);
  if (v29 == v26)
  {
    uint64_t v30 = 4LL;
    uint64_t v29 = (void *)(v27 - 104);
  }

  else
  {
    if (!v29) {
      goto LABEL_6;
    }
    uint64_t v30 = 5LL;
  }

  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_6:
  DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t,DiskImage::extents_t &&::allocator<std::vector>> &&)::$_0::~$_0(&a9);
  DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t,DiskImage::extents_t &&::allocator<std::vector>> &&)::$_0::~$_0(&a26);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](v27 - 216);
  uint64_t v31 = *(void *)(v27 - 200);
  *(void *)(v27 - 200) = 0LL;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 24LL))(v31);
  }
  uint64_t v32 = *(void *)(v27 - 152);
  *(void *)(v27 - 152) = 0LL;
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 24LL))(v32);
  }
  _Unwind_Resume(a1);
}

uint64_t *DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t,DiskImage::extents_t &&::allocator<std::vector>> &&)::$_0::~$_0( uint64_t *a1)
{
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t v3 = *a1;
  *a1 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  return a1;
}

uint64_t transformed_extents_iterator_interface::clone@<X0>( transformed_extents_iterator_interface *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xB0uLL);
  uint64_t result = transformed_extents_iterator_interface::transformed_extents_iterator_interface((uint64_t)v4, (uint64_t)this);
  *a2 = v4;
  return result;
}

void sub_1881273F0(_Unwind_Exception *a1)
{
}

void transformed_extents_iterator_interface::~transformed_extents_iterator_interface( transformed_extents_iterator_interface *this)
{
  uint64_t v2 = *((void *)this + 12);
  *((void *)this + 12) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t v3 = *((void *)this + 6);
  *((void *)this + 6) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 144);
  uint64_t v2 = *((void *)this + 12);
  *((void *)this + 12) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t v3 = *((void *)this + 6);
  *((void *)this + 6) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  operator delete(this);
}

void DiskImage::extents_t::~extents_t(DiskImage::extents_t *this)
{
  uint64_t v2 = (char *)this + 56;
  uint64_t v3 = (char *)*((void *)this + 10);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_6:
  uint64_t v5 = *((void *)this + 4);
  *((void *)this + 4) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 40LL))(v5);
  }
}

uint64_t std::allocate_shared[abi:ne180100]<std::vector<DiskImage::diskimage_extent_t>,std::allocator<std::vector<DiskImage::diskimage_extent_t>>,std::vector<DiskImage::diskimage_extent_t> const&,void>@<X0>( uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x30uLL);
  uint64_t result = std::__shared_ptr_emplace<std::vector<DiskImage::diskimage_extent_t>>::__shared_ptr_emplace[abi:ne180100]<std::vector<DiskImage::diskimage_extent_t> const&,std::allocator<std::vector<DiskImage::diskimage_extent_t>>,0>( (uint64_t)v4,  a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_188127560(_Unwind_Exception *a1)
{
}

uint64_t std::__shared_ptr_emplace<std::vector<DiskImage::diskimage_extent_t>>::__shared_ptr_emplace[abi:ne180100]<std::vector<DiskImage::diskimage_extent_t> const&,std::allocator<std::vector<DiskImage::diskimage_extent_t>>,0>( uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)a1 = off_18A1E5808;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 24) = 0LL;
  std::vector<DiskImage::diskimage_extent_t>::__init_with_size[abi:ne180100]<DiskImage::diskimage_extent_t*,DiskImage::diskimage_extent_t*>( (void *)(a1 + 24),  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5);
  return a1;
}

void sub_1881275C4(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<std::vector<DiskImage::diskimage_extent_t>>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_18A1E5808;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<DiskImage::diskimage_extent_t>>::~__shared_ptr_emplace( std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_18A1E5808;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<std::vector<DiskImage::diskimage_extent_t>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }

void *std::vector<DiskImage::diskimage_extent_t>::__init_with_size[abi:ne180100]<DiskImage::diskimage_extent_t*,DiskImage::diskimage_extent_t*>( void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<DiskImage::diskimage_extent_t>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8 - 4);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_188127680(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *std::vector<DiskImage::diskimage_extent_t>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::vector<iovec>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::allocator<ref::details::ref_cnt_set_handle>::allocate_at_least[abi:ne180100]( (uint64_t)(a1 + 2),  a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void *std::__function::__func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::~__func( void *a1)
{
  *a1 = off_18A1E5858;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 13));
  uint64_t v2 = a1[7];
  a1[7] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t v3 = a1[1];
  a1[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  return a1;
}

void std::__function::__func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::~__func( void *a1)
{
  *a1 = off_18A1E5858;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 13));
  uint64_t v2 = a1[7];
  a1[7] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t v3 = a1[1];
  a1[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  operator delete(a1);
}

void *std::__function::__func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::__clone( uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x78uLL);
  void *v2 = off_18A1E5858;
  std::__compressed_pair_elem<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<std::vector<DiskImage::diskimage_extent_t> & const&,0ul>( (uint64_t)(v2 + 1),  v1);
  return v2;
}

void sub_1881277DC(_Unwind_Exception *a1)
{
}

uint64_t std::__function::__func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_18A1E5858;
  return std::__compressed_pair_elem<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<std::vector<DiskImage::diskimage_extent_t> & const&,0ul>( (uint64_t)(a2 + 1),  (void *)(a1 + 8));
}

uint64_t std::__function::__func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::destroy( uint64_t a1)
{
  return std::__function::__alloc_func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::destroy[abi:ne180100]((uint64_t *)(a1 + 8));
}

void std::__function::__func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::destroy_deallocate( uint64_t *a1)
{
}

uint64_t std::__function::__func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::operator()@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = a1 + 1;
  uint64_t v8 = *a3;
  uint64_t v9 = operator new(0xB0uLL);
  __int128 v11 = *(_OWORD *)(a2 + 8);
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t result = transformed_extents_iterator_interface::transformed_extents_iterator_interface( (uint64_t)v9,  a2,  (uint64_t)&v11,  v8,  v7,  a1 + 7,  a1[13]);
  *a4 = v9;
  return result;
}

void sub_1881278BC(_Unwind_Exception *a1)
{
}

uint64_t std::__function::__func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::target( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

void *std::__function::__func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::target_type()
{
}

uint64_t std::__compressed_pair_elem<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<std::vector<DiskImage::diskimage_extent_t> & const&,0ul>( uint64_t a1, void *a2)
{
  uint64_t v4 = DiskImage::const_extents_iterator_t::const_extents_iterator_t(a1, a2);
  DiskImage::const_extents_iterator_t::const_extents_iterator_t(v4 + 48, a2 + 6);
  uint64_t v5 = a2[13];
  *(void *)(a1 + 96) = a2[12];
  *(void *)(a1 + 104) = v5;
  if (v5)
  {
    unint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return a1;
}

void sub_18812796C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  *uint64_t v1 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__alloc_func<DiskImage::extents_t_transformer::make_transformed_extents(DiskImage::extents_t &&,std::vector<DiskImage::diskimage_extent_t> &&)::$_0,DiskImage::diskimage_extent_t<std::vector<DiskImage::diskimage_extent_t> &>,std::unique_ptr<DiskImage::base_extents_iterator_interface> ()(DiskImage::extents_t const&,unsigned long long)>::destroy[abi:ne180100]( uint64_t *a1)
{
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t result = *a1;
  *a1 = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

uLong udif::get_csum_any(unsigned int *a1)
{
  uLong result = *a1;
  if ((_DWORD)result)
  {
    if ((_DWORD)result != 2)
    {
      exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
      DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "Unknown checksum found", 0x16u);
    }

    return crc32(0LL, 0LL, 0) << 32;
  }

  return result;
}

udif::header *udif::header::header(udif::header *this, const char *a2)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  *((_OWORD *)this + 1) = 0u;
  uint64_t v4 = (void *)((char *)this + 16);
  *((_OWORD *)this + 2) = 0u;
  uint64_t v5 = (void *)((char *)this + 32);
  *(_OWORD *)((char *)this + 44) = 0u;
  *(_OWORD *)this = 0u;
  uint64_t v37 = 0x100000000LL;
  smart_enums::validators::value<unsigned int>((uint64_t)"segment_num_t", 0, &v37, 2LL);
  *((_DWORD *)this + 15) = 0;
  uint64_t v37 = 0x100000000LL;
  smart_enums::validators::value<unsigned int>((uint64_t)"segment_count_t", 0, &v37, 2LL);
  *((_OWORD *)this + 4) = 0u;
  *((void *)this + 26) = 0LL;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 5) = 0u;
  udif::checksum_type::checksum_type((udif::header *)((char *)this + 80));
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_DWORD *)this + 21) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v10 - 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 4++*(_DWORD *)(this + 56) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  udif::checksum_type::checksum_type((udif::header *)((char *)this + 352));
  *((_DWORD *)this + 89) = 0;
  *((_DWORD *)this + 122) = 0;
  uint64_t v37 = 0x100000000LL;
  LODWORD(v38) = 2;
  smart_enums::validators::value<unsigned int>((uint64_t)"image_variant_type", 0, &v37, 3LL);
  *(void *)((char *)this + 492) = 0LL;
  int v6 = *(_DWORD *)a2;
  LODWORD(v37) = 2037149547;
  smart_enums::validators::value<unsigned int>((uint64_t)"header_signature", v6, &v37, 1LL);
  *(_DWORD *)this = 2037149547;
  int v7 = bswap32(*((_DWORD *)a2 + 1));
  LODWORD(v37) = 4;
  smart_enums::validators::value<unsigned int>((uint64_t)"version_t", v7, &v37, 1LL);
  *((_DWORD *)this + 1) = 4;
  int v8 = bswap32(*((_DWORD *)a2 + 2));
  LODWORD(v37) = 512;
  smart_enums::validators::value<unsigned int>((uint64_t)"header_size_t", v8, &v37, 1LL);
  *((_DWORD *)this + 2) = 512;
  udif::header::header_flags::header_flags(&v37, bswap32(*((_DWORD *)a2 + 3)));
  *((_DWORD *)this + 3) = v37;
  *uint64_t v4 = *((void *)a2 + 2);
  *((void *)this + 3) = bswap64(*((void *)a2 + 3));
  *uint64_t v5 = bswap64(*((void *)a2 + 4));
  *((void *)this + 5) = bswap64(*((void *)a2 + 5));
  *((void *)this + 6) = bswap64(*((void *)a2 + 6));
  LODWORD(v5) = bswap32(*((_DWORD *)a2 + 14));
  uint64_t v37 = 0x100000000LL;
  smart_enums::validators::value<unsigned int>((uint64_t)"segment_num_t", (int)v5, &v37, 2LL);
  *((_DWORD *)this + 14) = (_DWORD)v5;
  LODWORD(v5) = bswap32(*((_DWORD *)a2 + 15));
  uint64_t v37 = 0x100000000LL;
  smart_enums::validators::value<unsigned int>((uint64_t)"segment_count_t", (int)v5, &v37, 2LL);
  *((_DWORD *)this + 15) = (_DWORD)v5;
  *((_OWORD *)this + 4) = *((_OWORD *)a2 + 4);
  udif::checksum_type::checksum_type((udif::checksum_type *)v36);
  __int128 v9 = *((_OWORD *)a2 + 12);
  *(_OWORD *)&v36[96] = *((_OWORD *)a2 + 11);
  *(_OWORD *)&v36[112] = v9;
  *(void *)&v36[128] = *((void *)a2 + 26);
  __int128 v10 = *((_OWORD *)a2 + 8);
  *(_OWORD *)&v36[32] = *((_OWORD *)a2 + 7);
  *(_OWORD *)&v36[48] = v10;
  __int128 v11 = *((_OWORD *)a2 + 10);
  *(_OWORD *)&v36[64] = *((_OWORD *)a2 + 9);
  *(_OWORD *)&v36[80] = v11;
  __int128 v12 = *((_OWORD *)a2 + 6);
  *(_OWORD *)__int128 v36 = *((_OWORD *)a2 + 5);
  *(_OWORD *)&v36[16] = v12;
  __int128 v42 = *(_OWORD *)&v36[72];
  __int128 v43 = *(_OWORD *)&v36[88];
  __int128 v44 = *(_OWORD *)&v36[104];
  __int128 v45 = *(_OWORD *)&v36[120];
  __int128 v38 = *(_OWORD *)&v36[8];
  __int128 v39 = *(_OWORD *)&v36[24];
  __int128 v40 = *(_OWORD *)&v36[40];
  __int128 v41 = *(_OWORD *)&v36[56];
  uint64_t v37 = *(void *)v36;
  udif::details::endian_reverse((uint64_t)&v37, (int *)&v27);
  *((void *)this + 10) = v27;
  *(_OWORD *)((char *)this + 152) = v32;
  *(_OWORD *)((char *)this + 168) = v33;
  *(_OWORD *)((char *)this + 184) = v34;
  *(_OWORD *)((char *)this + 200) = v35;
  *(_OWORD *)((char *)this + 88) = v28;
  *(_OWORD *)((char *)this + 104) = v29;
  *(_OWORD *)((char *)this + 120) = v30;
  *(_OWORD *)((char *)this + 136) = v31;
  *((void *)this + 27) = bswap64(*((void *)a2 + 27));
  *((void *)this + 28) = bswap64(*((void *)a2 + 28));
  __int128 v13 = *(_OWORD *)(a2 + 232);
  __int128 v14 = *(_OWORD *)(a2 + 248);
  __int128 v15 = *(_OWORD *)(a2 + 280);
  *(_OWORD *)((char *)this + 264) = *(_OWORD *)(a2 + 264);
  *(_OWORD *)((char *)this + 280) = v15;
  *(_OWORD *)((char *)this + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v10 - 248) = v14;
  *(_OWORD *)((char *)this + 232) = v13;
  *((void *)this + 37) = bswap64(*((void *)a2 + 37));
  *((void *)this + 38) = bswap64(*((void *)a2 + 38));
  __int128 v16 = *(_OWORD *)(a2 + 312);
  __int128 v17 = *(_OWORD *)(a2 + 328);
  *((void *)this + 43) = *((void *)a2 + 43);
  *(_OWORD *)((char *)this + 312) = v16;
  *(_OWORD *)((char *)this + 328) = v17;
  udif::checksum_type::checksum_type((udif::checksum_type *)v36);
  __int128 v18 = *((_OWORD *)a2 + 29);
  *(_OWORD *)&v36[96] = *((_OWORD *)a2 + 28);
  *(_OWORD *)&v36[112] = v18;
  *(void *)&v36[128] = *((void *)a2 + 60);
  __int128 v19 = *((_OWORD *)a2 + 25);
  *(_OWORD *)&v36[32] = *((_OWORD *)a2 + 24);
  *(_OWORD *)&v36[48] = v19;
  __int128 v20 = *((_OWORD *)a2 + 27);
  *(_OWORD *)&v36[64] = *((_OWORD *)a2 + 26);
  *(_OWORD *)&v36[80] = v20;
  __int128 v21 = *((_OWORD *)a2 + 23);
  *(_OWORD *)__int128 v36 = *((_OWORD *)a2 + 22);
  *(_OWORD *)&v36[16] = v21;
  __int128 v42 = *(_OWORD *)&v36[72];
  __int128 v43 = *(_OWORD *)&v36[88];
  __int128 v44 = *(_OWORD *)&v36[104];
  __int128 v45 = *(_OWORD *)&v36[120];
  __int128 v38 = *(_OWORD *)&v36[8];
  __int128 v39 = *(_OWORD *)&v36[24];
  __int128 v40 = *(_OWORD *)&v36[40];
  __int128 v41 = *(_OWORD *)&v36[56];
  uint64_t v37 = *(void *)v36;
  udif::details::endian_reverse((uint64_t)&v37, (int *)&v27);
  *((void *)this + 44) = v27;
  __int128 v22 = v33;
  *(_OWORD *)((char *)this + 424) = v32;
  *(_OWORD *)((char *)this + 440) = v22;
  __int128 v23 = v35;
  *(_OWORD *)((char *)this + 4++*(_DWORD *)(this + 56) = v34;
  *(_OWORD *)((char *)this + 472) = v23;
  __int128 v24 = v29;
  *(_OWORD *)((char *)this + 360) = v28;
  *(_OWORD *)((char *)this + 376) = v24;
  __int128 v25 = v31;
  *(_OWORD *)((char *)this + 392) = v30;
  *(_OWORD *)((char *)this + 408) = v25;
  LODWORD(v5) = bswap32(*((_DWORD *)a2 + 122));
  uint64_t v37 = 0x100000000LL;
  LODWORD(v38) = 2;
  smart_enums::validators::value<unsigned int>((uint64_t)"image_variant_type", (int)v5, &v37, 3LL);
  *((_DWORD *)this + 122) = (_DWORD)v5;
  *(void *)((char *)this + 492) = bswap64(*(void *)(a2 + 492));
  return this;
}

void sub_188127F40(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t udif::header::write(udif::header *this, char *a2)
{
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v12 = "*udif::header::write(char *)";
    *((void *)&v12 + 1) = 20LL;
    int v13 = 2;
    di_log::logger<di_log::log_printer<85ul>>::logger(v14, &v12);
    udif::operator<<(&v15, (uint64_t)this);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<85ul>>::~logger_buf((uint64_t)v14);
    MEMORY[0x1895BC2CC](&v16);
  }

  *(_DWORD *)a2 = *(_DWORD *)this;
  *((_DWORD *)a2 + 1) = bswap32(*((_DWORD *)this + 1));
  *((_DWORD *)a2 + 2) = bswap32(*((_DWORD *)this + 2));
  *((_DWORD *)a2 + 3) = bswap32(*((_DWORD *)this + 3));
  *((void *)a2 + 2) = *((void *)this + 2);
  *((void *)a2 + 3) = bswap64(*((void *)this + 3));
  *((void *)a2 + 4) = bswap64(*((void *)this + 4));
  *((void *)a2 + 5) = bswap64(*((void *)this + 5));
  *((void *)a2 + 6) = bswap64(*((void *)this + 6));
  *((_DWORD *)a2 + 14) = bswap32(*((_DWORD *)this + 14));
  *((_DWORD *)a2 + 15) = bswap32(*((_DWORD *)this + 15));
  *((_OWORD *)a2 + 4) = *((_OWORD *)this + 4);
  uint64_t v4 = udif::details::serialize_field((uint64_t)this + 80, (uint64_t)(a2 + 80));
  *(void *)uint64_t v4 = bswap64(*((void *)this + 27));
  *(void *)(v4 + 8) = bswap64(*((void *)this + 28));
  __int128 v5 = *(_OWORD *)((char *)this + 232);
  __int128 v6 = *(_OWORD *)((char *)this + 248);
  __int128 v7 = *(_OWORD *)((char *)this + 280);
  *(_OWORD *)(v4 + 48) = *(_OWORD *)((char *)this + 264);
  *(_OWORD *)(v4 + 64) = v7;
  *(_OWORD *)(v4 + 16) = v5;
  *(_OWORD *)(v4 + 32) = v6;
  *(void *)(v4 + 80) = bswap64(*((void *)this + 37));
  *(void *)(v4 + 88) = bswap64(*((void *)this + 38));
  __int128 v9 = *(_OWORD *)((char *)this + 312);
  __int128 v8 = *(_OWORD *)((char *)this + 328);
  *(void *)(v4 + 128) = *((void *)this + 43);
  *(_OWORD *)(v4 + 96) = v9;
  *(_OWORD *)(v4 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v50 + 112) = v8;
  uint64_t v10 = udif::details::serialize_field((uint64_t)this + 352, v4 + 136);
  *(_DWORD *)uint64_t v10 = bswap32(*((_DWORD *)this + 122));
  *(void *)(v10 + 4) = bswap64(*(void *)((char *)this + 492));
  return v10 + 12;
}

void sub_1881280F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<85ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<85ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E5940;
  a1[45] = &unk_18A1E5A40;
  a1[46] = &unk_18A1E5A68;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E5940;
  a1[45] = &unk_18A1E59C8;
  a1[46] = &unk_18A1E59F0;
  return a1;
}

void sub_18812818C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<85ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *udif::operator<<(void *a1, uint64_t a2)
{
  uint64_t v143 = *MEMORY[0x1895F89C0];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"header (", 8LL);
  uint64_t v4 = (void *)std::ostream::operator<<();
  __int128 v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"):", 2LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(void *)(*v5 - 24LL)));
  __int128 v6 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  int v7 = *(_DWORD *)(a2 + 12);
  int v112 = *(_DWORD *)(a2 + 60);
  int v113 = *(_DWORD *)(a2 + 56);
  uint64_t v110 = *(void *)(a2 + 72);
  uint64_t v111 = *(void *)(a2 + 64);
  uint64_t v8 = *(void *)(a2 + 80);
  __int128 v9 = *(_OWORD *)(a2 + 168);
  __int128 v134 = *(_OWORD *)(a2 + 152);
  __int128 v135 = v9;
  __int128 v10 = *(_OWORD *)(a2 + 200);
  __int128 v136 = *(_OWORD *)(a2 + 184);
  __int128 v137 = v10;
  __int128 v11 = *(_OWORD *)(a2 + 104);
  __int128 v130 = *(_OWORD *)(a2 + 88);
  __int128 v131 = v11;
  __int128 v12 = *(_OWORD *)(a2 + 136);
  __int128 v132 = *(_OWORD *)(a2 + 120);
  __int128 v133 = v12;
  __int128 v13 = *(_OWORD *)(a2 + 248);
  __int128 v126 = *(_OWORD *)(a2 + 232);
  __int128 v127 = v13;
  __int128 v14 = *(_OWORD *)(a2 + 280);
  __int128 v128 = *(_OWORD *)(a2 + 264);
  __int128 v129 = v14;
  __int128 v15 = *(_OWORD *)(a2 + 328);
  __int128 v123 = *(_OWORD *)(a2 + 312);
  __int128 v124 = v15;
  uint64_t v125 = *(void *)(a2 + 344);
  uint64_t v16 = *(void *)(a2 + 352);
  __int128 v17 = *(_OWORD *)(a2 + 440);
  __int128 v119 = *(_OWORD *)(a2 + 424);
  __int128 v120 = v17;
  __int128 v18 = *(_OWORD *)(a2 + 472);
  __int128 v121 = *(_OWORD *)(a2 + 456);
  __int128 v122 = v18;
  __int128 v19 = *(_OWORD *)(a2 + 376);
  __int128 v115 = *(_OWORD *)(a2 + 360);
  __int128 v116 = v19;
  __int128 v20 = *(_OWORD *)(a2 + 408);
  __int128 v117 = *(_OWORD *)(a2 + 392);
  __int128 v118 = v20;
  int v109 = *(_DWORD *)(a2 + 488);
  __int128 v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"signature", 9LL);
  __int128 v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)": ", 2LL);
  v138[23] = 4;
  strcpy(v138, "koly");
  __int128 v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)v138, 4LL);
  if ((v138[23] & 0x80000000) != 0) {
    operator delete(*(void **)v138);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v23 + *(void *)(*v23 - 24LL)));
  __int128 v24 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v24->__vftable[2].~facet_0)(v24, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  __int128 v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"version", 7LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)": ", 2LL);
  size_t v26 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v26 + *(void *)(*v26 - 24LL)));
  uint64_t v27 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v27->__vftable[2].~facet_0)(v27, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  __int128 v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"header_size", 11LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)": ", 2LL);
  __int128 v29 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v29 + *(void *)(*v29 - 24LL)));
  __int128 v30 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v30->__vftable[2].~facet_0)(v30, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  __int128 v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"flags", 5LL);
  __int128 v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)": ", 2LL);
  LODWORD(v114.__locale_) = v7;
  __int128 v33 = udif::operator<<(v32, (int *)&v114);
  std::ios_base::getloc((const std::ios_base *)((char *)v33 + *(void *)(*v33 - 24LL)));
  __int128 v34 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v34->__vftable[2].~facet_0)(v34, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  __int128 v35 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( a1,  (uint64_t)"run_data_fork_offset",  20LL);
  __int128 v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)": ", 2LL);
  uint64_t v37 = *v36;
  __int128 v38 = (char *)v36 + *(void *)(*v36 - 24);
  int v39 = *((_DWORD *)v38 + 2);
  *((_DWORD *)v38 + 2) = v39 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v36 + *(void *)(v37 - 24) + 8) |= 0x200u;
  v138[0] = 48;
  std::operator<<[abi:ne180100]<std::char_traits<char>>(v36, v138);
  std::ostream::operator<<();
  uint64_t v40 = *v36;
  *(_DWORD *)((char *)v36 + *(void *)(*v36 - 24) + 8) = v39;
  std::ios_base::getloc((const std::ios_base *)((char *)v36 + *(void *)(v40 - 24)));
  __int128 v41 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v41->__vftable[2].~facet_0)(v41, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  __int128 v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"data_fork_offset", 16LL);
  __int128 v43 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)": ", 2LL);
  uint64_t v44 = *v43;
  __int128 v45 = (char *)v43 + *(void *)(*v43 - 24);
  LODWORD(v36) = *((_DWORD *)v45 + 2);
  *((_DWORD *)v45 + 2) = v36 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v43 + *(void *)(v44 - 24) + 8) |= 0x200u;
  v138[0] = 48;
  std::operator<<[abi:ne180100]<std::char_traits<char>>(v43, v138);
  std::ostream::operator<<();
  uint64_t v46 = *v43;
  *(_DWORD *)((char *)v43 + *(void *)(*v43 - 24) + 8) = (_DWORD)v36;
  std::ios_base::getloc((const std::ios_base *)((char *)v43 + *(void *)(v46 - 24)));
  unint64_t v47 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v47->__vftable[2].~facet_0)(v47, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  __int128 v48 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"data_fork_len", 13LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v48, (uint64_t)": ", 2LL);
  __int128 v49 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v49 + *(void *)(*v49 - 24LL)));
  __int128 v50 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v50->__vftable[2].~facet_0)(v50, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  unint64_t v51 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"rsrc_fork_offset", 16LL);
  uint64_t v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v51, (uint64_t)": ", 2LL);
  uint64_t v53 = *v52;
  BOOL v54 = (char *)v52 + *(void *)(*v52 - 24);
  LODWORD(v36) = *((_DWORD *)v54 + 2);
  *((_DWORD *)v54 + 2) = v36 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v52 + *(void *)(v53 - 24) + 8) |= 0x200u;
  v138[0] = 48;
  std::operator<<[abi:ne180100]<std::char_traits<char>>(v52, v138);
  std::ostream::operator<<();
  uint64_t v55 = *v52;
  *(_DWORD *)((char *)v52 + *(void *)(*v52 - 24) + 8) = (_DWORD)v36;
  std::ios_base::getloc((const std::ios_base *)((char *)v52 + *(void *)(v55 - 24)));
  uint64_t v56 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v56->__vftable[2].~facet_0)(v56, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  unint64_t v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"rsrc_fork_len", 13LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)": ", 2LL);
  unint64_t v58 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v58 + *(void *)(*v58 - 24LL)));
  unint64_t v59 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v59->__vftable[2].~facet_0)(v59, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v60 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"segment_num", 11LL);
  unint64_t v61 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v60, (uint64_t)": ", 2LL);
  LODWORD(v114.__locale_) = v113;
  unint64_t v62 = udif::operator<<(v61, &v114);
  std::ios_base::getloc((const std::ios_base *)((char *)v62 + *(void *)(*v62 - 24LL)));
  int64_t v63 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v63->__vftable[2].~facet_0)(v63, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  int v64 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"segment_count", 13LL);
  unint64_t v65 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v64, (uint64_t)": ", 2LL);
  LODWORD(v114.__locale_) = v112;
  unint64_t v66 = udif::operator<<(v65, &v114);
  std::ios_base::getloc((const std::ios_base *)((char *)v66 + *(void *)(*v66 - 24LL)));
  uint64_t v67 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  *(void *)unint64_t v138 = v111;
  *(void *)&v138[8] = v110;
  unint64_t v68 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"segment_id", 10LL);
  unint64_t v69 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)": ", 2LL);
  print_buffer(v69, (uint64_t)v138, 16LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v69 + *(void *)(*v69 - 24LL)));
  unint64_t v70 = std::locale::use_facet(&v114, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v70->__vftable[2].~facet_0)(v70, 10LL);
  std::locale::~locale(&v114);
  std::ostream::put();
  std::ostream::flush();
  *(void *)unint64_t v138 = v8;
  __int128 v139 = v134;
  __int128 v140 = v135;
  __int128 v141 = v136;
  __int128 v142 = v137;
  *(_OWORD *)&v138[8] = v130;
  *(_OWORD *)&v138[24] = v131;
  *(_OWORD *)&v138[40] = v132;
  *(_OWORD *)&v138[56] = v133;
  unint64_t v71 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( a1,  (uint64_t)"data_fork_checksum",  18LL);
  unint64_t v72 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v71, (uint64_t)": ", 2LL);
  udif::details::operator<<(v72, (int *)v138);
  std::ios_base::getloc((const std::ios_base *)((char *)v72 + *(void *)(*v72 - 24LL)));
  uint64_t v73 = std::locale::use_facet(&v114, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v73->__vftable[2].~facet_0)(v73, 10LL);
  std::locale::~locale(&v114);
  std::ostream::put();
  std::ostream::flush();
  unint64_t v74 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"xml_offset", 10LL);
  unint64_t v75 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v74, (uint64_t)": ", 2LL);
  uint64_t v76 = *v75;
  unint64_t v77 = (char *)v75 + *(void *)(*v75 - 24);
  LODWORD(v36) = *((_DWORD *)v77 + 2);
  *((_DWORD *)v77 + 2) = v36 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v75 + *(void *)(v76 - 24) + 8) |= 0x200u;
  v138[0] = 48;
  std::operator<<[abi:ne180100]<std::char_traits<char>>(v75, v138);
  std::ostream::operator<<();
  uint64_t v78 = *v75;
  *(_DWORD *)((char *)v75 + *(void *)(*v75 - 24) + 8) = (_DWORD)v36;
  std::ios_base::getloc((const std::ios_base *)((char *)v75 + *(void *)(v78 - 24)));
  uint64_t v79 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v79->__vftable[2].~facet_0)(v79, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  unint64_t v80 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"xml_length", 10LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v80, (uint64_t)": ", 2LL);
  unint64_t v81 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v81 + *(void *)(*v81 - 24LL)));
  uint64_t v82 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v82->__vftable[2].~facet_0)(v82, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  *(_OWORD *)unint64_t v138 = v126;
  *(_OWORD *)&v138[16] = v127;
  *(_OWORD *)&v138[32] = v128;
  *(_OWORD *)&v138[48] = v129;
  unint64_t v83 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"external", 8LL);
  unint64_t v84 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v83, (uint64_t)": ", 2LL);
  print_buffer(v84, (uint64_t)v138, 64LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v84 + *(void *)(*v84 - 24LL)));
  uint64_t v85 = std::locale::use_facet(&v114, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v85->__vftable[2].~facet_0)(v85, 10LL);
  std::locale::~locale(&v114);
  std::ostream::put();
  std::ostream::flush();
  unint64_t v86 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"code_sign_offset", 16LL);
  unint64_t v87 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v86, (uint64_t)": ", 2LL);
  uint64_t v88 = *v87;
  unint64_t v89 = (char *)v87 + *(void *)(*v87 - 24);
  LODWORD(v36) = *((_DWORD *)v89 + 2);
  *((_DWORD *)v89 + 2) = v36 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v87 + *(void *)(v88 - 24) + 8) |= 0x200u;
  v138[0] = 48;
  std::operator<<[abi:ne180100]<std::char_traits<char>>(v87, v138);
  std::ostream::operator<<();
  uint64_t v90 = *v87;
  *(_DWORD *)((char *)v87 + *(void *)(*v87 - 24) + 8) = (_DWORD)v36;
  std::ios_base::getloc((const std::ios_base *)((char *)v87 + *(void *)(v90 - 24)));
  BOOL v91 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v91->__vftable[2].~facet_0)(v91, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  unint64_t v92 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"code_sign_length", 16LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)": ", 2LL);
  unint64_t v93 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v93 + *(void *)(*v93 - 24LL)));
  unint64_t v94 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v94->__vftable[2].~facet_0)(v94, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  *(_OWORD *)unint64_t v138 = v123;
  *(_OWORD *)&v138[16] = v124;
  *(void *)&v138[32] = v125;
  unint64_t v95 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"reserved", 8LL);
  unint64_t v96 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v95, (uint64_t)": ", 2LL);
  print_buffer(v96, (uint64_t)v138, 40LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v96 + *(void *)(*v96 - 24LL)));
  unint64_t v97 = std::locale::use_facet(&v114, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v97->__vftable[2].~facet_0)(v97, 10LL);
  std::locale::~locale(&v114);
  std::ostream::put();
  std::ostream::flush();
  *(void *)unint64_t v138 = v16;
  __int128 v139 = v119;
  __int128 v140 = v120;
  __int128 v141 = v121;
  __int128 v142 = v122;
  *(_OWORD *)&v138[8] = v115;
  *(_OWORD *)&v138[24] = v116;
  *(_OWORD *)&v138[40] = v117;
  *(_OWORD *)&v138[56] = v118;
  unint64_t v98 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"master_checksum", 15LL);
  unint64_t v99 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v98, (uint64_t)": ", 2LL);
  udif::details::operator<<(v99, (int *)v138);
  std::ios_base::getloc((const std::ios_base *)((char *)v99 + *(void *)(*v99 - 24LL)));
  uint64_t v100 = std::locale::use_facet(&v114, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v100->__vftable[2].~facet_0)(v100, 10LL);
  std::locale::~locale(&v114);
  std::ostream::put();
  std::ostream::flush();
  unint64_t v101 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"image_variant", 13LL);
  unint64_t v102 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v101, (uint64_t)": ", 2LL);
  LODWORD(v114.__locale_) = v109;
  unint64_t v103 = udif::operator<<(v102, &v114);
  std::ios_base::getloc((const std::ios_base *)((char *)v103 + *(void *)(*v103 - 24LL)));
  char v104 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v104->__vftable[2].~facet_0)(v104, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  unint64_t v105 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"sector_count", 12LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v105, (uint64_t)": ", 2LL);
  unint64_t v106 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v106 + *(void *)(*v106 - 24LL)));
  __int128 v107 = std::locale::use_facet((const std::locale *)v138, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v107->__vftable[2].~facet_0)(v107, 10LL);
  std::locale::~locale((std::locale *)v138);
  std::ostream::put();
  std::ostream::flush();
  return a1;
}

void sub_1881291B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

__n128 udif::details::endian_reverse@<Q0>(uint64_t a1@<X0>, int *a2@<X8>)
{
  *a2 = v8;
  a2[1] = 0;
  unsigned int v7 = bswap32(*(_DWORD *)(a1 + 4));
  udif::details::checksum::_checksum::set_len(a2 + 1, &v7);
  int v5 = *a2;
  if (*a2) {
    BOOL v6 = v5 == 10;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (v5 == 2)
    {
      a2[2] = bswap32(*(_DWORD *)(a1 + 8));
    }

    else
    {
      *(_OWORD *)(a2 + 18) = *(_OWORD *)(a1 + 72);
      *(_OWORD *)(a2 + 22) = *(_OWORD *)(a1 + 88);
      *(_OWORD *)(a2 + 26) = *(_OWORD *)(a1 + 104);
      *(_OWORD *)(a2 + 30) = *(_OWORD *)(a1 + 120);
      *(_OWORD *)(a2 + 2) = *(_OWORD *)(a1 + 8);
      *(_OWORD *)(a2 + 6) = *(_OWORD *)(a1 + 24);
      *(_OWORD *)(a2 + 10) = *(_OWORD *)(a1 + 40);
      __n128 result = *(__n128 *)(a1 + 56);
      *(__n128 *)(a2 + 14) = result;
    }
  }

  return result;
}

_DWORD *udif::details::checksum::_checksum::set_len(_DWORD *this, const unsigned int *a2)
{
  if (*a2 >= 0x408)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = off_18A1E4A78;
    exception[1] = "_checksum";
    exception[2] = "field size too large";
  }

  *this = *a2;
  return this;
}

BOOL udif::details::checksum::operator==(_DWORD *a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  udif::details::checksum::checksum((uint64_t)v4, a2);
  return udif::details::checksum::operator==(a1, v4);
}

uint64_t udif::details::checksum::checksum(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(unsigned int *)(a2 + 12);
  if ((_DWORD)v2 == -1) {
    std::__throw_bad_variant_access[abi:ne180100]();
  }
  BOOL v6 = &v5;
  ((void (*)(uint64_t *__return_ptr, char **, uint64_t))off_18A1E5B48[v2])(&v7, &v6, a2 + 4);
  *(void *)a1 = v7;
  *(_OWORD *)(a1 + 72) = v12;
  *(_OWORD *)(a1 + 88) = v13;
  *(_OWORD *)(a1 + 104) = v14;
  *(_OWORD *)(a1 + 120) = v15;
  *(_OWORD *)(a1 + 8) = v8;
  *(_OWORD *)(a1 + 24) = v9;
  *(_OWORD *)(a1 + 40) = v10;
  *(_OWORD *)(a1 + ++*(_DWORD *)(this + 56) = v11;
  return a1;
}

unsigned int *udif::details::endian_reverse@<X0>(unsigned int *result@<X0>, unsigned int *a2@<X8>)
{
  unsigned int v3 = bswap32(*result);
  if ((v3 & 0x80000000) != 0)
  {
    __n128 result = udif::details::descriptor_special::descriptor_special(&v4, v3);
    unsigned int v3 = v4;
  }

  *a2 = v3;
  return result;
}

uint64_t udif::details::serialize_field(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = bswap32(*(_DWORD *)a1);
  *(_DWORD *)(a2 + 4) = bswap32(*(_DWORD *)(a1 + 4));
  uint64_t v2 = (_OWORD *)(a2 + 8);
  unsigned int v3 = *(_DWORD *)a1;
  if (*(_DWORD *)a1) {
    BOOL v4 = v3 == 10;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    uint64_t v5 = 0LL;
  }

  else if (v3 == 2)
  {
    *(_DWORD *)(a2 + 8) = bswap32(*(_DWORD *)(a1 + 8));
    uint64_t v2 = (_OWORD *)(a2 + 12);
    uint64_t v5 = 4LL;
  }

  else
  {
    __int128 v6 = *(_OWORD *)(a1 + 8);
    __int128 v7 = *(_OWORD *)(a1 + 24);
    __int128 v8 = *(_OWORD *)(a1 + 56);
    *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
    *(_OWORD *)(a2 + ++*(_DWORD *)(this + 56) = v8;
    _OWORD *v2 = v6;
    *(_OWORD *)(a2 + 24) = v7;
    __int128 v9 = *(_OWORD *)(a1 + 72);
    __int128 v10 = *(_OWORD *)(a1 + 88);
    __int128 v11 = *(_OWORD *)(a1 + 120);
    *(_OWORD *)(a2 + 104) = *(_OWORD *)(a1 + 104);
    *(_OWORD *)(a2 + 120) = v11;
    *(_OWORD *)(a2 + 72) = v9;
    *(_OWORD *)(a2 + 88) = v10;
    uint64_t v5 = 128LL;
  }

  bzero(v2, 128 - v5);
  return (uint64_t)v2 - v5 + 128;
}

uint64_t udif::details::run_info::make_sectors_interval@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *(void *)(a2 + 8);
  unint64_t v4 = *(void *)(result + 8) + v3;
  unint64_t v5 = v4 + *(void *)(result + 16);
  *(void *)a3 = v4;
  *(void *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 2;
  if (v4 < v5 && (v4 < v3 || v3 + *(void *)(a2 + 16) - 1 < v5 - 1))
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException( exception,  "Invalid UDIF, run is not within block boundary",  0x16u);
  }

  return result;
}

uint64_t udif::details::UDIF_base::get_xml_data@<X0>(udif::details::UDIF_base *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *((void *)this + 9);
  size_t v5 = *(void *)(v4 + 224);
  __int128 v6 = operator new[](v5);
  bzero(v6, v5);
  *a2 = v6;
  uint64_t result = Backend::read(*((Backend **)this + 7), (char *)v6, v5, *(void *)(v4 + 216));
  if ((result & 0x80000000) != 0)
  {
    unsigned int v8 = result;
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    __int128 v10 = std::generic_category();
    exception[1] = v8;
    exception[2] = v10;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Can't read UDIF trailer";
  }

  return result;
}

void sub_1881296DC(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0LL;
  operator delete[](v2);
  _Unwind_Resume(a1);
}

unint64_t udif::details::UDIF_base::write_resources( udif::details::UDIF_base *this, const __CFDictionary *a2)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  values = a2;
  keys[0] = @"resource-fork";
  cf::make_dict((const void **)keys, (const void **)&values, 1LL, (CFMutableDictionaryRef *)&propertyList);
  if (DIDebugLogsEnabled())
  {
    int v3 = *__error();
    if (DIForwardLogs())
    {
      v36[0] = 0LL;
      DIOSLog = (os_log_s *)getDIOSLog();
      os_log_type_enabled(DIOSLog, OS_LOG_TYPE_DEBUG);
      *(_DWORD *)buf = 68158210;
      *(_DWORD *)&uint8_t buf[4] = 41;
      *(_WORD *)int v39 = 2080;
      *(void *)&v39[2] = "udif::details::UDIF_base::write_resources(CFDictionaryRef)";
      *(_WORD *)&v39[10] = 2114;
      *(void *)&v39[12] = propertyList;
      size_t v5 = (const char *)_os_log_send_and_compose_impl();
      if (v5)
      {
        __int128 v6 = (char *)v5;
        fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v5);
        free(v6);
      }
    }

    else
    {
      __int128 v7 = (os_log_s *)getDIOSLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 68158210;
        *(_DWORD *)&uint8_t buf[4] = 41;
        *(_WORD *)int v39 = 2080;
        *(void *)&v39[2] = "udif::details::UDIF_base::write_resources(CFDictionaryRef)";
        *(_WORD *)&v39[10] = 2114;
        *(void *)&v39[12] = propertyList;
        _os_log_impl(&dword_188046000, v7, OS_LOG_TYPE_DEBUG, "%.*s: res_dict: %{public}@", buf, 0x1Cu);
      }
    }

    *__error() = v3;
  }

  cf::serialize_to_xml_plist(propertyList, (const __CFData **)v36);
  uint64_t v8 = *(void *)(*((void *)this + 9) + 216LL);
  uint64_t v9 = *((void *)this + 7);
  __int128 v10 = (char *)v36[1];
  BytePtr = CFDataGetBytePtr((CFDataRef)v36[0]);
  uint64_t v12 = *((void *)details::get_dummy_shared_ptr() + 1);
  *(void *)buf = BytePtr;
  *(void *)int v39 = v12;
  if (v12)
  {
    __int128 v13 = (unint64_t *)(v12 + 8);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  *(void *)&v39[8] = v10;
  *(void *)&v39[16] = v8;
  uint64_t v40 = v10;
  char v41 = 0;
  unsigned int v15 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v9 + 96LL))(v9, buf);
  uint64_t v16 = *(std::__shared_weak_count **)v39;
  if (*(void *)v39)
  {
    __int128 v17 = (unint64_t *)(*(void *)v39 + 8LL);
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  if ((v15 & 0x80000000) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    __int128 v33 = std::generic_category();
    exception[1] = v15;
    exception[2] = v33;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "Can't write UDIF resource part";
  }

  __int128 v19 = (udif::header *)*((void *)this + 9);
  *((void *)v19 + 28) = v10;
  __int128 v20 = &v10[v8];
  unint64_t v21 = (unint64_t)(v20 + 511) & 0xFFFFFFFFFFFFFE00LL;
  __int128 v22 = operator new[](v21 - (void)v20 + 512);
  bzero(v22, v21 - (void)v20 + 512);
  udif::header::write(v19, (char *)v22 + v21 - (void)v20);
  uint64_t v23 = *((void *)this + 7);
  uint64_t v24 = *((void *)details::get_dummy_shared_ptr() + 1);
  *(void *)buf = v22;
  *(void *)int v39 = v24;
  if (v24)
  {
    __int128 v25 = (unint64_t *)(v24 + 8);
    do
      unint64_t v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }

  *(void *)&v39[8] = v21 - (void)v20 + 512;
  *(void *)&v39[16] = v20;
  uint64_t v40 = *(char **)&v39[8];
  char v41 = 0;
  unsigned int v27 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v23 + 96LL))(v23, buf);
  __int128 v28 = *(std::__shared_weak_count **)v39;
  if (*(void *)v39)
  {
    __int128 v29 = (unint64_t *)(*(void *)v39 + 8LL);
    do
      unint64_t v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }

  if ((v27 & 0x80000000) != 0)
  {
    __int128 v34 = __cxa_allocate_exception(0x40uLL);
    void *v34 = off_18A1E43B0;
    __int128 v35 = std::generic_category();
    v34[1] = v27;
    void v34[2] = v35;
    *((_BYTE *)v34 + 24) = 0;
    *((_BYTE *)v34 + 48) = 0;
    v34[7] = "Can't write UDIF header";
  }

  operator delete[](v22);
  CFAutoRelease<__CFData const*>::~CFAutoRelease(v36);
  CFAutoRelease<__CFDictionary const*>::~CFAutoRelease(&propertyList);
  return v21 + 512;
}

void sub_188129AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void *udif::details::operator<<(void *a1, _DWORD *a2)
{
  if ((*a2 & 0x80000000) != 0)
  {
    uint64_t v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"special: ", 9LL);
    if (*a2 == -1) {
      size_t v5 = "ddm";
    }
    else {
      size_t v5 = "entire_device";
    }
    if (*a2 == -1) {
      uint64_t v6 = 3LL;
    }
    else {
      uint64_t v6 = 13LL;
    }
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v5, v6);
  }

  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"partition_num: ", 15LL);
    return (void *)std::ostream::operator<<();
  }

void *udif::details::operator<<(void *a1, uint64_t a2)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  uint64_t v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"Blocks header", 13LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24LL)));
  size_t v5 = std::locale::use_facet((const std::locale *)v60, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10LL);
  std::locale::~locale((std::locale *)v60);
  std::ostream::put();
  std::ostream::flush();
  int v6 = *(_DWORD *)(a2 + 36);
  __int128 v58 = *(_OWORD *)(a2 + 40);
  uint64_t v59 = *(void *)(a2 + 56);
  uint64_t v7 = *(void *)(a2 + 64);
  __int128 v8 = *(_OWORD *)(a2 + 152);
  __int128 v54 = *(_OWORD *)(a2 + 136);
  __int128 v55 = v8;
  __int128 v9 = *(_OWORD *)(a2 + 184);
  __int128 v56 = *(_OWORD *)(a2 + 168);
  __int128 v57 = v9;
  __int128 v10 = *(_OWORD *)(a2 + 88);
  __int128 v50 = *(_OWORD *)(a2 + 72);
  __int128 v51 = v10;
  __int128 v11 = *(_OWORD *)(a2 + 120);
  __int128 v52 = *(_OWORD *)(a2 + 104);
  __int128 v53 = v11;
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"signature", 9LL);
  __int128 v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)": ", 2LL);
  v60[23] = 4;
  strcpy(v60, "mish");
  unint64_t v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)v60, 4LL);
  if ((v60[23] & 0x80000000) != 0) {
    operator delete(*(void **)v60);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24LL)));
  unsigned int v15 = std::locale::use_facet((const std::locale *)v60, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10LL);
  std::locale::~locale((std::locale *)v60);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"version", 7LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)": ", 2LL);
  __int128 v17 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(void *)(*v17 - 24LL)));
  unint64_t v18 = std::locale::use_facet((const std::locale *)v60, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10LL);
  std::locale::~locale((std::locale *)v60);
  std::ostream::put();
  std::ostream::flush();
  __int128 v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( a1,  (uint64_t)"first_sector_number",  19LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)": ", 2LL);
  __int128 v20 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(void *)(*v20 - 24LL)));
  unint64_t v21 = std::locale::use_facet((const std::locale *)v60, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10LL);
  std::locale::~locale((std::locale *)v60);
  std::ostream::put();
  std::ostream::flush();
  __int128 v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"sector_count", 12LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)": ", 2LL);
  uint64_t v23 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v23 + *(void *)(*v23 - 24LL)));
  uint64_t v24 = std::locale::use_facet((const std::locale *)v60, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v24->__vftable[2].~facet_0)(v24, 10LL);
  std::locale::~locale((std::locale *)v60);
  std::ostream::put();
  std::ostream::flush();
  __int128 v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"data_start", 10LL);
  unint64_t v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)": ", 2LL);
  uint64_t v27 = *v26;
  __int128 v28 = (char *)v26 + *(void *)(*v26 - 24);
  int v29 = *((_DWORD *)v28 + 2);
  *((_DWORD *)v28 + 2) = v29 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v26 + *(void *)(v27 - 24) + 8) |= 0x200u;
  v60[0] = 48;
  std::operator<<[abi:ne180100]<std::char_traits<char>>(v26, v60);
  std::ostream::operator<<();
  uint64_t v30 = *v26;
  *(_DWORD *)((char *)v26 + *(void *)(*v26 - 24) + 8) = v29;
  std::ios_base::getloc((const std::ios_base *)((char *)v26 + *(void *)(v30 - 24)));
  __int128 v31 = std::locale::use_facet((const std::locale *)v60, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 10LL);
  std::locale::~locale((std::locale *)v60);
  std::ostream::put();
  std::ostream::flush();
  __int128 v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( a1,  (uint64_t)"decompression_buffer_req",  24LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)": ", 2LL);
  __int128 v33 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v33 + *(void *)(*v33 - 24LL)));
  __int128 v34 = std::locale::use_facet((const std::locale *)v60, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v34->__vftable[2].~facet_0)(v34, 10LL);
  std::locale::~locale((std::locale *)v60);
  std::ostream::put();
  std::ostream::flush();
  LODWORD(v49.__locale_) = v6;
  __int128 v35 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"descriptor", 10LL);
  __int128 v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)": ", 2LL);
  uint64_t v37 = udif::details::operator<<(v36, &v49);
  std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(void *)(*v37 - 24LL)));
  __int128 v38 = std::locale::use_facet((const std::locale *)v60, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10LL);
  std::locale::~locale((std::locale *)v60);
  std::ostream::put();
  std::ostream::flush();
  *(_OWORD *)uint64_t v60 = v58;
  *(void *)&v60[16] = v59;
  int v39 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"reserved", 8LL);
  uint64_t v40 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)": ", 2LL);
  print_buffer(v40, (uint64_t)v60, 24LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v40 + *(void *)(*v40 - 24LL)));
  char v41 = std::locale::use_facet(&v49, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v41->__vftable[2].~facet_0)(v41, 10LL);
  std::locale::~locale(&v49);
  std::ostream::put();
  std::ostream::flush();
  *(void *)uint64_t v60 = v7;
  __int128 v64 = v54;
  __int128 v65 = v55;
  __int128 v66 = v56;
  __int128 v67 = v57;
  *(_OWORD *)&void v60[8] = v50;
  __int128 v61 = v51;
  __int128 v62 = v52;
  __int128 v63 = v53;
  __int128 v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"checksum", 8LL);
  __int128 v43 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)": ", 2LL);
  udif::details::operator<<(v43, (int *)v60);
  std::ios_base::getloc((const std::ios_base *)((char *)v43 + *(void *)(*v43 - 24LL)));
  uint64_t v44 = std::locale::use_facet(&v49, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v44->__vftable[2].~facet_0)(v44, 10LL);
  std::locale::~locale(&v49);
  std::ostream::put();
  std::ostream::flush();
  __int128 v45 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"run_count", 9LL);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)": ", 2LL);
  uint64_t v46 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v46 + *(void *)(*v46 - 24LL)));
  unint64_t v47 = std::locale::use_facet((const std::locale *)v60, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v47->__vftable[2].~facet_0)(v47, 10LL);
  std::locale::~locale((std::locale *)v60);
  std::ostream::put();
  std::ostream::flush();
  return a1;
}

void sub_18812A320( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *udif::details::operator<<(void *a1, int *a2)
{
  int v4 = *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 8);
  size_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"type: ", 6LL);
  int v16 = *a2;
  int v6 = udif::operator<<(v5, &v16);
  uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" ", 1LL);
  *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(*v7 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  char v15 = 48;
  __int128 v8 = std::operator<<[abi:ne180100]<std::char_traits<char>>(v7, &v15);
  uint64_t v9 = *v8;
  *(uint64_t *)((char *)v8 + *(void *)(*v8 - 24) + 24) = 2LL;
  int v10 = *(_DWORD *)((char *)v8 + *(void *)(v9 - 24) + 8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"len: ", 5LL);
  __int128 v11 = (void *)std::ostream::operator<<();
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" data: ", 7LL);
  *(_DWORD *)((char *)v12 + *(void *)(*v12 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v12 + *(void *)(*v12 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v13 = a2[1];
  if ((_DWORD)v13) {
    print_buffer(v8, (uint64_t)(a2 + 2), v13);
  }
  else {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"(empty)", 7LL);
  }
  *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24) + 8) = v10;
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 8) = v4;
  return a1;
}

void *udif::details::UDIF_base::get_compressed_types(udif::details::UDIF_base *this)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if ((v1 & 1) == 0
  {
    udif::run_type::run_type((udif::run_type *)v3, -2147483643);
    v3[1] = 0;
    udif::run_type::run_type((udif::run_type *)v4, -2147483641);
    v4[1] = 1;
    udif::run_type::run_type((udif::run_type *)v5, -2147483640);
    v5[1] = 2;
    udif::run_type::run_type((udif::run_type *)v6, -2147483642);
    v6[1] = 4;
    std::map<udif::run_type,CompressedBackend::algo_t>::map[abi:ne180100]( (uint64_t)&udif::details::UDIF_base::get_compressed_types(void)::compressed_types,  v3,  4LL);
    __cxa_atexit( (void (*)(void *))std::map<udif::run_type,CompressedBackend::algo_t>::~map[abi:ne180100],  &udif::details::UDIF_base::get_compressed_types(void)::compressed_types,  &dword_188046000);
  }

  return &udif::details::UDIF_base::get_compressed_types(void)::compressed_types;
}

void sub_18812A5FC(_Unwind_Exception *a1)
{
}

uint64_t std::map<udif::run_type,CompressedBackend::algo_t>::~map[abi:ne180100](uint64_t a1)
{
  return a1;
}

void *udif::details::UDIF_base::find_compression_algo_by_run@<X0>( udif::details::UDIF_base *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  compressed_types = (udif::details::UDIF_base *)udif::details::UDIF_base::get_compressed_types(a1);
  uint64_t v6 = qword_18C701AD8;
  if (!qword_18C701AD8) {
    goto LABEL_12;
  }
  unsigned int v7 = *a2;
  __int128 v8 = &qword_18C701AD8;
  do
  {
    unsigned int v9 = *(_DWORD *)(v6 + 28);
    BOOL v10 = v9 >= v7;
    if (v9 >= v7) {
      __int128 v11 = (uint64_t *)v6;
    }
    else {
      __int128 v11 = (uint64_t *)(v6 + 8);
    }
    if (v10) {
      __int128 v8 = (uint64_t *)v6;
    }
    uint64_t v6 = *v11;
  }

  while (*v11);
  if (v8 != &qword_18C701AD8 && v7 >= *((_DWORD *)v8 + 7))
  {
    uint64_t result = udif::details::UDIF_base::get_compressed_types(compressed_types);
    *(_DWORD *)a3 = *((_DWORD *)v8 + 8);
    char v13 = 1;
  }

  else
  {
LABEL_12:
    uint64_t result = udif::details::UDIF_base::get_compressed_types(compressed_types);
    char v13 = 0;
    *(_BYTE *)a3 = 0;
  }

  *(_BYTE *)(a3 + 4) = v13;
  return result;
}

uint64_t **udif::details::UDIF_base::update_compressed_types( uint64_t **result, uint64_t **a2, _DWORD *a3, uint64_t *a4, uint64_t *a5)
{
  if (HIBYTE(*a3) == 128)
  {
    unsigned int v9 = result;
    int v14 = *a3;
    ((void (*)(_DWORD **__return_ptr, uint64_t **, int *))(*result)[2])(v13, result, &v14);
    if (!BYTE4(v13[0]))
    {
      exception = __cxa_allocate_exception(0x40uLL);
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v13);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v13,  (uint64_t)"Unsupported compressed run (",  28LL);
      int v15 = *a3;
      udif::operator<<(v13, &v15);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)")", 1LL);
      DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v13, 0x2Du);
    }

    v13[0] = a3;
    BOOL v10 = std::__tree<std::__value_type<udif::run_type,unsigned long long>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,unsigned long long>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,unsigned long long>>>::__emplace_unique_key_args<udif::run_type,std::piecewise_construct_t const&,std::tuple<udif::run_type const&>,std::tuple<>>( a2,  a3,  (uint64_t)&std::piecewise_construct,  v13)[5];
    if (v10)
    {
      v13[0] = a3;
      BOOL v10 = std::__tree<std::__value_type<udif::run_type,unsigned long long>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,unsigned long long>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,unsigned long long>>>::__emplace_unique_key_args<udif::run_type,std::piecewise_construct_t const&,std::tuple<udif::run_type const&>,std::tuple<>>( a2,  a3,  (uint64_t)&std::piecewise_construct,  v13)[5];
    }

    if (v10 > a4) {
      a4 = v10;
    }
    v13[0] = a3;
    uint64_t result = std::__tree<std::__value_type<udif::run_type,unsigned long long>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,unsigned long long>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,unsigned long long>>>::__emplace_unique_key_args<udif::run_type,std::piecewise_construct_t const&,std::tuple<udif::run_type const&>,std::tuple<>>( a2,  a3,  (uint64_t)&std::piecewise_construct,  v13);
    result[5] = a4;
    *((_BYTE *)v9 + 88) = 1;
    __int128 v11 = v9[12];
    if (v11 <= a5) {
      __int128 v11 = a5;
    }
    v9[12] = v11;
  }

  return result;
}

void sub_18812A860( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void udif::details::UDIF_base::create_backends(uint64_t a1, void *a2)
{
  uint64_t v6 = (void *)*a2;
  int v4 = a2 + 1;
  size_t v5 = v6;
  if (v6 != v4)
  {
    do
    {
      int v10 = *((_DWORD *)v5 + 8);
      udif::details::UDIF_base::add_backend_to_map(a1, &v10, v5[5]);
      unsigned int v7 = (void *)v5[1];
      if (v7)
      {
        do
        {
          __int128 v8 = v7;
          unsigned int v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          __int128 v8 = (void *)v5[2];
          BOOL v9 = *v8 == (void)v5;
          size_t v5 = v8;
        }

        while (!v9);
      }

      size_t v5 = v8;
    }

    while (v8 != v4);
  }

void udif::details::UDIF_base::add_backend_to_map(uint64_t a1, _DWORD *a2, size_t a3)
{
  if (*a2 == 1)
  {
    udif::run_type::run_type((udif::run_type *)&v17, 1);
    *(void *)&__int128 v14 = &v17;
    int v4 = std::__tree<std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,std::shared_ptr<Backend>>>>::__emplace_unique_key_args<udif::run_type,std::piecewise_construct_t const&,std::tuple<udif::run_type const&>,std::tuple<>>( (uint64_t **)(a1 + 104),  (unsigned int *)&v17,  (uint64_t)&std::piecewise_construct,  (_DWORD **)&v14);
    std::shared_ptr<DiskImage>::operator=[abi:ne180100](v4 + 5, (uint64_t *)(a1 + 56));
  }

  else
  {
    int v15 = *a2;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(void *)a1 + 16LL))(&v16, a1, &v15);
    if (!BYTE4(v16))
    {
      exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
      DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "UDIF: compression algo is invalid", 0x16u);
    }

    int v13 = v16;
    CompressedBackend::make_backend((void *)(a1 + 56), &v13, a3, &v14);
    __int128 v17 = a2;
    unsigned int v7 = std::__tree<std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,std::shared_ptr<Backend>>>>::__emplace_unique_key_args<udif::run_type,std::piecewise_construct_t const&,std::tuple<udif::run_type const&>,std::tuple<>>( (uint64_t **)(a1 + 104),  a2,  (uint64_t)&std::piecewise_construct,  &v17);
    std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100]((uint64_t)(v7 + 5), &v14);
    __int128 v8 = (std::__shared_weak_count *)*((void *)&v14 + 1);
    if (*((void *)&v14 + 1))
    {
      BOOL v9 = (unint64_t *)(*((void *)&v14 + 1) + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }

void sub_18812AA94(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void udif::details::UDIF_base::make_backend_contexts(udif::details::UDIF_base *this@<X0>, uint64_t a2@<X8>)
{
  __int128 v35 = 0LL;
  uint64_t v36 = 0LL;
  __int128 v34 = (uint64_t *)&v35;
  (*(void (**)(__int128 *__return_ptr))(**((void **)this + 7) + 72LL))(&v33);
  int v4 = (udif::details::UDIF_base *)*((void *)this + 13);
  if (v4 != (udif::details::UDIF_base *)((char *)this + 112))
  {
    do
    {
      size_t v5 = (const void *)*((void *)v4 + 5);
      if (v5 == *((const void **)this + 7))
      {
        __int128 v31 = (_DWORD *)((char *)v4 + 32);
        __int128 v22 = std::__tree<std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,std::shared_ptr<Backend>>>>::__emplace_unique_key_args<udif::run_type,std::piecewise_construct_t const&,std::tuple<udif::run_type const&>,std::tuple<>>( &v34,  (unsigned int *)v4 + 8,  (uint64_t)&std::piecewise_construct,  &v31);
        std::shared_ptr<DiskImage>::operator=[abi:ne180100](v22 + 5, (uint64_t *)&v33);
      }

      else if (v5)
      {
        if (v6)
        {
          unsigned int v7 = (std::__shared_weak_count *)*((void *)v4 + 6);
          __int128 v31 = v6;
          __int128 v32 = v7;
          if (v7)
          {
            p_shared_owners = (unint64_t *)&v7->__shared_owners_;
            do
              unint64_t v9 = __ldxr(p_shared_owners);
            while (__stxr(v9 + 1, p_shared_owners));
          }

          __int128 v29 = v33;
          if (*((void *)&v33 + 1))
          {
            unint64_t v10 = (unint64_t *)(*((void *)&v33 + 1) + 8LL);
            do
              unint64_t v11 = __ldxr(v10);
            while (__stxr(v11 + 1, v10));
          }

          (*(void (**)(__int128 *__return_ptr, _DWORD *, __int128 *))(*(void *)v6 + 176LL))(&v30, v6, &v29);
          uint64_t v37 = (_DWORD *)((char *)v4 + 32);
          uint64_t v12 = std::__tree<std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,std::shared_ptr<Backend>>>>::__emplace_unique_key_args<udif::run_type,std::piecewise_construct_t const&,std::tuple<udif::run_type const&>,std::tuple<>>( &v34,  (unsigned int *)v4 + 8,  (uint64_t)&std::piecewise_construct,  &v37);
          std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100]((uint64_t)(v12 + 5), &v30);
          int v13 = (std::__shared_weak_count *)*((void *)&v30 + 1);
          if (*((void *)&v30 + 1))
          {
            __int128 v14 = (unint64_t *)(*((void *)&v30 + 1) + 8LL);
            do
              unint64_t v15 = __ldaxr(v14);
            while (__stlxr(v15 - 1, v14));
            if (!v15)
            {
              ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
              std::__shared_weak_count::__release_weak(v13);
            }
          }

          uint64_t v16 = (std::__shared_weak_count *)*((void *)&v29 + 1);
          if (*((void *)&v29 + 1))
          {
            __int128 v17 = (unint64_t *)(*((void *)&v29 + 1) + 8LL);
            do
              unint64_t v18 = __ldaxr(v17);
            while (__stlxr(v18 - 1, v17));
            if (!v18)
            {
              ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
              std::__shared_weak_count::__release_weak(v16);
            }
          }

          __int128 v19 = v32;
          if (v32)
          {
            __int128 v20 = (unint64_t *)&v32->__shared_owners_;
            do
              unint64_t v21 = __ldaxr(v20);
            while (__stlxr(v21 - 1, v20));
            if (!v21)
            {
              ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
              std::__shared_weak_count::__release_weak(v19);
            }
          }
        }
      }

      uint64_t v23 = (udif::details::UDIF_base *)*((void *)v4 + 1);
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          uint64_t v23 = *(udif::details::UDIF_base **)v23;
        }

        while (v23);
      }

      else
      {
        do
        {
          uint64_t v24 = (udif::details::UDIF_base *)*((void *)v4 + 2);
          BOOL v25 = *(void *)v24 == (void)v4;
          int v4 = v24;
        }

        while (!v25);
      }

      int v4 = v24;
    }

    while (v24 != (udif::details::UDIF_base *)((char *)this + 112));
  }

  unint64_t v26 = v35;
  *(void *)a2 = v34;
  *(void *)(a2 + 8) = v26;
  uint64_t v27 = a2 + 8;
  uint64_t v28 = v36;
  *(void *)(a2 + 16) = v36;
  if (v28)
  {
    v26[2] = v27;
    __int128 v34 = (uint64_t *)&v35;
    __int128 v35 = 0LL;
    uint64_t v36 = 0LL;
    unint64_t v26 = 0LL;
  }

  else
  {
    *(void *)a2 = v27;
  }

  *(_OWORD *)(a2 + 24) = v33;
  std::__tree<std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,std::shared_ptr<Backend>>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,std::shared_ptr<Backend>>>>::destroy( (uint64_t)&v34,  v26);
}

void sub_18812AD34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *a19)
{
}

uint64_t udif::details::UDIF_base::validate_runs(uint64_t this)
{
  unsigned __int8 v1 = *(void **)(this + 8);
  if (v1 != (void *)(this + 16))
  {
    do
    {
      if (*((unsigned __int8 *)v1 + 59) == 128
        && (v1[5] - v1[4] + (unint64_t)(v1[6] & 1) + ((*((unsigned __int8 *)v1 + 48) >> 1) & 1) - 1) << 9 > 0x400000)
      {
        unsigned int v7 = v1;
        *(void *)&__int128 v9 = "udif::details::UDIF_base::validate_runs()";
        *((void *)&v9 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 39LL;
        int v10 = 16;
        di_log::logger<di_log::log_printer<417ul>>::logger(v11, &v9);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"Run interval: ", 14LL);
        boost::icl::operator<<<char,std::char_traits<char>,boost::icl::discrete_interval<unsigned long long,std::less>>( v12,  (uint64_t)(v7 + 4));
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" of type ", 9LL);
        LODWORD(v8) = *((_DWORD *)v7 + 14);
        udif::operator<<(v12, &v8);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" has size ", 10LL);
        std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v12,  (uint64_t)"which is larger than allowed ",  29LL);
        std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v12,  (uint64_t)" or exceeds size_t size ",  24LL);
        uint64_t v8 = -1LL;
        std::operator<<[abi:ne180100]<di_log::logger<di_log::log_printer<417ul>>,unsigned long,0>((uint64_t)v11);
        di_log::logger<di_log::log_printer<417ul>>::~logger((uint64_t)v11);
        exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
        DiskImagesRuntimeException::DiskImagesRuntimeException( exception,  "UDIF: compressed runs should be <= 1MB",  0x16u);
      }

      uint64_t v2 = (void *)v1[1];
      if (v2)
      {
        do
        {
          int v3 = v2;
          uint64_t v2 = (void *)*v2;
        }

        while (v2);
      }

      else
      {
        do
        {
          int v3 = (void *)v1[2];
          BOOL v4 = *v3 == (void)v1;
          unsigned __int8 v1 = v3;
        }

        while (!v4);
      }

      unsigned __int8 v1 = v3;
    }

    while (v3 != (void *)(this + 16));
  }

  return this;
}

void sub_18812AF40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t std::operator<<[abi:ne180100]<di_log::logger<di_log::log_printer<417ul>>,unsigned long,0>( uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<417ul>>::logger(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<417ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E5B70;
  a1[45] = &unk_18A1E5C70;
  a1[46] = &unk_18A1E5C98;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E5B70;
  a1[45] = &unk_18A1E5BF8;
  a1[46] = &unk_18A1E5C20;
  return a1;
}

void sub_18812B00C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<417ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t *udif::details::UDIF_base::add_block(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  size_t v5 = (uint64_t **)(a1 + 32);
  if (a1 + 40 != std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>>>::find<boost::icl::discrete_interval<unsigned long long,std::less>>( a1 + 32,  a2))
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException( exception,  "Invalid UDIF format, contains intersected blocks",  0x16u);
  }

  int v6 = *((_DWORD *)a3 + 2);
  __int128 v19 = *(_OWORD *)((char *)a3 + 76);
  __int128 v20 = *(_OWORD *)((char *)a3 + 92);
  __int128 v21 = *(_OWORD *)((char *)a3 + 108);
  __int128 v22 = *(_OWORD *)((char *)a3 + 124);
  __int128 v15 = *(_OWORD *)((char *)a3 + 12);
  __int128 v16 = *(_OWORD *)((char *)a3 + 28);
  __int128 v17 = *(_OWORD *)((char *)a3 + 44);
  __int128 v18 = *(_OWORD *)((char *)a3 + 60);
  uint64_t v7 = *a3;
  uint64_t v12 = *(void *)(a2 + 16);
  __int128 v11 = *(_OWORD *)a2;
  uint64_t v13 = v7;
  int v14 = v6;
  char v23 = 1;
  return boost::icl::interval_base_map<boost::icl::split_interval_map<unsigned long long,std::optional<udif::details::block_info>,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,std::optional<udif::details::block_info>,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::_insert( v5,  (uint64_t)&v11);
}

void udif::details::UDIF_base::generate_blocks(uint64_t **this, CFArrayRef theArray)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  unint64_t Count = CFArrayGetCount(theArray);
  CFIndex v5 = Count;
  if (Count >> 61) {
    size_t v6 = -1LL;
  }
  else {
    size_t v6 = 8 * Count;
  }
  uint64_t v7 = operator new[](v6);
  bzero(v7, v6);
  v39[0] = 0LL;
  v39[1] = 0LL;
  __int128 v38 = (uint64_t *)v39;
  v64.location = 0LL;
  v64.length = v5;
  __p = v7;
  CFArrayGetValues(theArray, v64, (const void **)v7);
  if (v5 >= 1)
  {
    unint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    unsigned int v30 = 0;
    CFIndex v27 = v5;
    while (1)
    {
      uint64_t v29 = v9;
      int v10 = (const void *)__p[v9];
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (v10)
      {
        if (CFGetTypeID(v10) != TypeID) {
          break;
        }
      }

      Value = CFDictionaryGetValue((CFDictionaryRef)v10, @"Data");
      CFTypeID v13 = CFDataGetTypeID();
      if (!Value)
      {
        exception = __cxa_allocate_exception(0x40uLL);
        void *exception = off_18A1E43B0;
        uint64_t v24 = std::generic_category();
        exception[1] = 22LL;
        exception[2] = v24;
        *((_BYTE *)exception + 24) = 0;
        *((_BYTE *)exception + 48) = 0;
        exception[7] = "UDIF: Can't find data key in dictionary";
      }

      if (CFGetTypeID(Value) != v13)
      {
        BOOL v25 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
        CFGetTypeID(Value);
        unint64_t v26 = v25;
        goto LABEL_32;
      }

      CFIndex Length = CFDataGetLength((CFDataRef)Value);
      __int128 v15 = (char *)operator new[](Length);
      bzero(v15, Length);
      v65.length = CFDataGetLength((CFDataRef)Value);
      v65.location = 0LL;
      CFDataGetBytes((CFDataRef)Value, v65, (UInt8 *)v15);
      udif::details::blocks::blocks((udif::details::blocks *)&v49, v15);
      if (DIDebugLogsEnabled())
      {
        *(void *)&__int128 v34 = "udif::details::UDIF_base::generate_blocks(CFArrayRef)";
        *((void *)&v34 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 41LL;
        int v35 = 2;
        di_log::logger<di_log::log_printer<458ul>>::logger(v40, &v34);
        udif::details::operator<<(&v47, (uint64_t)&v49);
        std::ios_base::getloc((const std::ios_base *)&v48[*(void *)(v47 - 24) - 8]);
        __int128 v16 = std::locale::use_facet(v32, MEMORY[0x189614558]);
        ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10LL);
        std::locale::~locale(v32);
        std::ostream::put();
        std::ostream::flush();
        std::ostream::~ostream();
        di_log::logger_buf<di_log::log_printer<458ul>>::~logger_buf((uint64_t)v40);
        MEMORY[0x1895BC2CC](v48);
      }

      *(void *)&__int128 v34 = *((void *)&v49 + 1);
      *((void *)&v34 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v50 + *((void *)&v49 + 1);
      LOBYTE(v35) = 2;
      *(_DWORD *)uint64_t v40 = v52;
      *(void *)&v40[4] = v53;
      __int128 v43 = v58;
      __int128 v44 = v59;
      __int128 v45 = v60;
      __int128 v46 = v61;
      *(_OWORD *)&v40[12] = v54;
      *(_OWORD *)char v41 = v55;
      *(_OWORD *)&v41[16] = v56;
      __int128 v42 = v57;
      udif::details::UDIF_base::add_block((uint64_t)this, (uint64_t)&v34, (uint64_t *)v40);
      if (v62)
      {
        unsigned int v17 = 0;
        __int128 v18 = v15 + 204;
        do
        {
          udif::details::run_t::run_t((udif::details::run_t *)&v34, v18);
          udif::details::run_info::make_sectors_interval((uint64_t)&v34, (uint64_t)&v49, (uint64_t)v32);
          if (v34 < 2 || (v34 & 0xFF000000) == 0x80000000)
          {
            int v31 = v34;
            udif::details::UDIF_base::update_compressed_types( this,  &v38,  &v31,  v37,  (uint64_t *)((v32[1].__locale_ - v32[0].__locale_ + (v33 & 1) + ((v33 >> 1) & 1) - 1) << 9));
            uint64_t v20 = v51 + v36 + this[9][3];
            *(_OWORD *)uint64_t v40 = *(_OWORD *)&v32[0].__locale_;
            *(void *)&v40[16] = v33;
            *(_DWORD *)&v40[24] = v34;
            *(void *)&v41[4] = v20;
            *(void *)&v41[12] = v37;
            boost::icl::interval_base_map<boost::icl::interval_map<unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::_insert( this + 1,  (uint64_t)v40);
            unint64_t v21 = v36;
            if (v36 < v8) {
              *((_BYTE *)this + 89) = 0;
            }
          }

          else
          {
            unint64_t v21 = v8;
          }

          ++v17;
          v18 += 40;
          unint64_t v8 = v21;
        }

        while (v17 < v62);
      }

      else
      {
        unint64_t v21 = v8;
      }

      if (v30 <= v52) {
        unsigned int v22 = v52;
      }
      else {
        unsigned int v22 = v30;
      }
      unsigned int v30 = v22;
      operator delete[](v15);
      uint64_t v9 = v29 + 1;
      unint64_t v8 = v21;
      if (v29 + 1 == v27) {
        goto LABEL_28;
      }
    }

    BOOL v25 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
    CFGetTypeID(v10);
    unint64_t v26 = v25;
LABEL_32:
    cf::CFUtilException::CFUtilException(v26);
  }

void sub_18812B6E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, std::locale a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, void *a27, uint64_t a28, char a29)
{
}

void *di_log::logger<di_log::log_printer<458ul>>::logger(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<458ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E5D90;
  a1[45] = &unk_18A1E5E90;
  a1[46] = &unk_18A1E5EB8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E5D90;
  a1[45] = &unk_18A1E5E18;
  a1[46] = &unk_18A1E5E40;
  return a1;
}

void sub_18812B814(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<458ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<500ul>>::logger(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<500ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E5FB0;
  a1[45] = &unk_18A1E60B0;
  a1[46] = &unk_18A1E60D8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E5FB0;
  a1[45] = &unk_18A1E6038;
  a1[46] = &unk_18A1E6060;
  return a1;
}

void sub_18812B900(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<500ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t *udif::details::UDIF_base::get_dummy_runs(udif::details::UDIF_base *this)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if ((v1 & 1) == 0
  {
    udif::run_type::run_type((udif::run_type *)&v3, 0);
    __int128 v4 = xmmword_188181800;
    char v5 = 2;
    int v6 = v3;
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    std::map<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>::map[abi:ne180100]( (uint64_t)&udif::details::UDIF_base::get_dummy_runs(void)::dummy_runs,  (unint64_t *)&v4,  1LL);
    __cxa_atexit( (void (*)(void *))std::map<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>::~map[abi:ne180100],  &udif::details::UDIF_base::get_dummy_runs(void)::dummy_runs,  &dword_188046000);
  }

  return &udif::details::UDIF_base::get_dummy_runs(void)::dummy_runs;
}

void sub_18812BA48(_Unwind_Exception *a1)
{
}

uint64_t std::map<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>::~map[abi:ne180100]( uint64_t a1)
{
  return a1;
}

udif::details::UDIF_base *udif::details::UDIF_base::create_iterator( udif::details::UDIF_base *this, unint64_t a2, uint64_t a3, unint64_t a4)
{
  v6[0] = a2 / a4;
  v6[1] = (a3 + a2) / a4;
  char v7 = 2;
  uint64_t result = (udif::details::UDIF_base *)std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::lower_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)this + 8,  (uint64_t)v6);
  if ((udif::details::UDIF_base *)((char *)this + 16) == result)
  {
    udif::details::UDIF_base::get_dummy_runs(result);
    return (udif::details::UDIF_base *)udif::details::UDIF_base::get_dummy_runs(void)::dummy_runs;
  }

  return result;
}

void udif::details::UDIF_base::_get_runs_for_io( udif::details::UDIF_base *a1, unint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a3;
  iterator = udif::details::UDIF_base::create_iterator(a1, a2, a3, 0x200uLL);
  if (v5)
  {
    uint64_t v9 = iterator;
    int v10 = (udif::details::UDIF_base *)((char *)a1 + 16);
    unint64_t v11 = a2;
    while (v9 != v10)
    {
      uint64_t v12 = *((void *)v9 + 4);
      unint64_t v13 = v12 << 9;
      if (v11 < v12 << 9) {
        goto LABEL_11;
      }
      uint64_t v14 = (*((void *)v9 + 5) - v12) << 9;
      if (v14 - (v11 - v13) >= v5) {
        unint64_t v15 = v5;
      }
      else {
        unint64_t v15 = v14 - (v11 - v13);
      }
      unsigned int v16 = *((_DWORD *)v9 + 14);
      unsigned int v29 = v16;
      if (HIBYTE(v16) == 128)
      {
        __int128 v30 = *((_OWORD *)v9 + 4);
        *(void *)&__int128 v31 = v13;
        *((void *)&v31 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v14;
        *(void *)&__int128 v32 = v11 - a2;
        *((void *)&v32 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v11 - v13;
      }

      else
      {
        *(void *)&__int128 v30 = *((void *)v9 + 8) + v11 - v13;
        *((void *)&v30 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v15;
        *(void *)&__int128 v31 = v11;
        *((void *)&v31 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v15;
        __int128 v32 = v11 - a2;
      }

      unint64_t v33 = v15;
      uint64_t v22 = a4[1];
      uint64_t v23 = *a4 + (v22 << 6);
      if (v22 == a4[2])
      {
        boost::container::vector<udif::run_io_info,boost::container::small_vector_allocator<udif::run_io_info,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<udif::run_io_info,boost::container::new_allocator<void>,void>,udif::run_io_info*,udif::run_io_info>>( a4,  v23,  (const char *)1,  (uint64_t)&v29,  &v34);
      }

      else
      {
        *(_DWORD *)uint64_t v23 = v16;
        __int128 v24 = v30;
        __int128 v25 = v31;
        __int128 v26 = v32;
        *(void *)(v23 + ++*(_DWORD *)(this + 56) = v33;
        *(_OWORD *)(v23 + 40) = v26;
        *(_OWORD *)(v23 + 24) = v25;
        *(_OWORD *)(v23 + 8) = v24;
        ++a4[1];
      }

      CFIndex v27 = (udif::details::UDIF_base *)*((void *)v9 + 1);
      if (v27)
      {
        do
        {
          uint64_t v9 = v27;
          CFIndex v27 = *(udif::details::UDIF_base **)v27;
        }

        while (v27);
      }

      else
      {
        do
        {
          uint64_t v28 = v9;
          uint64_t v9 = (udif::details::UDIF_base *)*((void *)v9 + 2);
        }

        while (*(udif::details::UDIF_base **)v9 != v28);
      }

uint64_t udif::details::UDIF_base::create_runs_range_iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v4 = std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::lower_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( a1 + 8,  a2);
  std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::upper_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( v3,  a2);
  return v4;
}

uint64_t udif::details::UDIF_base::create_runs_iterator(udif::details::UDIF_base *this)
{
  return *((void *)this + 1);
}

uint64_t udif::details::UDIF_base::print_checksum_verification_status( uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  v18[19] = *MEMORY[0x1895F89C0];
  udif::details::checksum::checksum((uint64_t)v16, a3);
  if (udif::details::checksum::operator==(a4, v16))
  {
    *(void *)&__int128 v14 = "udif::details::UDIF_base::print_checksum_verification_status(const std::string &, const csum_any &, const details::checksum &) const";
    *((void *)&v14 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 60LL;
    int v15 = 0;
    di_log::logger<di_log::log_printer<601ul>>::logger(v16, &v14);
    int v7 = *(char *)(a2 + 23);
    if (v7 >= 0) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = *(void *)a2;
    }
    if (v7 >= 0) {
      uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      uint64_t v9 = *(void *)(a2 + 8);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, v8, v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, (uint64_t)" - same ", 8LL);
    checksum::operator<<((uint64_t)&v17, a3);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<601ul>>::~logger_buf((uint64_t)v16);
  }

  else
  {
    *(void *)&__int128 v14 = "udif::details::UDIF_base::print_checksum_verification_status(const std::string &, const csum_any &, const details::checksum &) const";
    *((void *)&v14 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 60LL;
    int v15 = 0;
    di_log::logger<di_log::log_printer<603ul>>::logger(v16, &v14);
    int v10 = *(char *)(a2 + 23);
    if (v10 >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = *(void *)a2;
    }
    if (v10 >= 0) {
      uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      uint64_t v12 = *(void *)(a2 + 8);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, v11, v12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v17,  (uint64_t)" - different calculated: <",  26LL);
    checksum::operator<<((uint64_t)&v17, a3);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, (uint64_t)"> real: <", 9LL);
    udif::details::operator<<(&v17, a4);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, (uint64_t)">", 1LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<603ul>>::~logger_buf((uint64_t)v16);
  }

  return MEMORY[0x1895BC2CC](v18);
}

void sub_18812BF10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *di_log::logger<di_log::log_printer<601ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<601ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E61D0;
  a1[45] = &unk_18A1E62D0;
  a1[46] = &unk_18A1E62F8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E61D0;
  a1[45] = &unk_18A1E6258;
  a1[46] = &unk_18A1E6280;
  return a1;
}

void sub_18812BFC0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<601ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<603ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<603ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E63F0;
  a1[45] = &unk_18A1E64F0;
  a1[46] = &unk_18A1E6518;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E63F0;
  a1[45] = &unk_18A1E6478;
  a1[46] = &unk_18A1E64A0;
  return a1;
}

void sub_18812C0A8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<603ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t udif::details::UDIF_base::UDIF_base(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 16) = 0LL;
  uint64_t v3 = (void *)(a1 + 16);
  *(void *)a1 = off_18A1E58D8;
  *(void *)(a1 + 8) = a1 + 16;
  uint64_t v4 = (void *)(a1 + 8);
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + ++*(_DWORD *)(this + 56) = a2[1];
  uint64_t v5 = a2[2];
  *(void *)(a1 + 64) = v5;
  if (v5)
  {
    int v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = *a2;
  *a2 = 0LL;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v50 + 112) = 0LL;
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 72) = v8;
  *(_BYTE *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 120) = 0LL;
  compressed_types = (udif::details::UDIF_base *)udif::details::UDIF_base::get_compressed_types((udif::details::UDIF_base *)a1);
  udif::details::UDIF_base::get_dummy_runs(compressed_types);
  *(_BYTE *)(a1 + 89) = *(void *)(*(void *)(a1 + 72) + 216LL) >= *(void *)(*(void *)(a1 + 72) + 32LL)
                                                                   + *(void *)(*(void *)(a1 + 72) + 24LL);
  udif::details::UDIF_base::get_rsrc_iterators((udif::details::UDIF_base *)a1, (uint64_t)&v37);
  while (1)
  {
    if (v37 != v42) {
      goto LABEL_15;
    }
    int v10 = v45;
    BOOL v11 = !v40 || v45 == 0;
    if (!v11) {
      break;
    }
    if ((v40 != 0) == (v45 != 0)) {
      goto LABEL_14;
    }
LABEL_15:
    int type = udif::xml_rsrc_iterator::get_type((udif::xml_rsrc_iterator *)&v37);
    udif::xml_rsrc_iterator::get_value(&v37);
    if (type == 1651272568)
    {
      udif::xml_rsrc_iterator::get_type((udif::xml_rsrc_iterator *)&v37);
      char value = (const __CFArray *)udif::xml_rsrc_iterator::get_value(&v37);
      udif::details::UDIF_base::generate_blocks((uint64_t **)a1, value);
    }

    udif::xml_rsrc_iterator::xml_rsrc_iterator((udif::xml_rsrc_iterator *)v33, (const udif::xml_rsrc_iterator *)&v37);
    ++v41;
    if (v36) {
      CFAutoRelease<__CFDictionary const*>::~CFAutoRelease(&v35);
    }
    __int128 v14 = v34;
    if (v34)
    {
      p_shared_owners = (unint64_t *)&v34->__shared_owners_;
      do
        unint64_t v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }

  if (v39 != v44) {
    goto LABEL_15;
  }
LABEL_14:
  if (v41 != v46) {
    goto LABEL_15;
  }
  uint64_t v17 = *(void *)(*(void *)(a1 + 72) + 492LL);
  *(void *)(a1 + 80) = v17;
  if (!v17 && (void *)*v4 != v3)
  {
    uint64_t v18 = (void *)*v3;
    if (*v3)
    {
      do
      {
        __int128 v19 = v18;
        uint64_t v18 = (void *)v18[1];
      }

      while (v18);
    }

    else
    {
      __int128 v20 = v3;
      do
      {
        __int128 v19 = (void *)v20[2];
        BOOL v11 = *v19 == (void)v20;
        __int128 v20 = v19;
      }

      while (v11);
    }

    *(void *)(a1 + 80) = v19[5];
    *(void *)&__int128 v28 = "udif::details::UDIF_base::UDIF_base(UDIF_header &&)";
    *((void *)&v28 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 35LL;
    int v29 = 0;
    di_log::logger<di_log::log_printer<638ul>>::logger(v30, &v28);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v31,  (uint64_t)"UDIF header doesn't contain a valid sector count, using runs upper value: ",  74LL);
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<638ul>>::~logger_buf((uint64_t)v30);
    MEMORY[0x1895BC2CC](&v32);
    int v10 = v45;
  }

  if (v10) {
    CFAutoRelease<__CFDictionary const*>::~CFAutoRelease(&v44);
  }
  __int128 v21 = v43;
  if (v43)
  {
    uint64_t v22 = (unint64_t *)&v43->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  if (v40) {
    CFAutoRelease<__CFDictionary const*>::~CFAutoRelease(&v39);
  }
  __int128 v24 = v38;
  if (v38)
  {
    __int128 v25 = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  return a1;
}

void sub_18812C47C(_Unwind_Exception *a1)
{
  int v10 = *(void **)(v1 + 72);
  *(void *)(v1 + 72) = 0LL;
  if (v10) {
    operator delete(v10);
  }
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4);
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::destroy( v3,  *v6);
  std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::destroy( v2,  *v7);
  _Unwind_Resume(a1);
}

const void **udif::details::UDIF_base::get_rsrc_iterators@<X0>( udif::details::UDIF_base *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t Count = CFDictionaryGetCount(v29);
  uint64_t v4 = Count;
  if (Count >> 61) {
    size_t v5 = -1LL;
  }
  else {
    size_t v5 = 8 * Count;
  }
  int v6 = operator new[](v5);
  std::shared_ptr<__CFString const*>::shared_ptr[abi:ne180100]<__CFString const*,std::default_delete<__CFString const*[]>,void>( &v27,  (uint64_t)v6);
  if (!v27)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    uint64_t v18 = std::generic_category();
    exception[1] = 12LL;
    exception[2] = v18;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "UDIF: Can't get types array from UDIF";
  }

  CFDictionaryGetKeysAndValues(v29, v27, 0LL);
  udif::xml_rsrc_iterator::xml_rsrc_iterator((uint64_t)v23, &v27, (const void **)&v29, 0LL);
  udif::xml_rsrc_iterator::xml_rsrc_iterator((uint64_t)v19, &v27, (const void **)&v29, v4);
  std::pair<udif::xml_rsrc_iterator,udif::xml_rsrc_iterator>::pair[abi:ne180100]<udif::xml_rsrc_iterator,udif::xml_rsrc_iterator,0>( a2,  (uint64_t)v23,  (uint64_t)v19);
  if (v22) {
    CFAutoRelease<__CFDictionary const*>::~CFAutoRelease(&v21);
  }
  unint64_t v7 = v20;
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  if (v26) {
    CFAutoRelease<__CFDictionary const*>::~CFAutoRelease(&v25);
  }
  int v10 = v24;
  if (v24)
  {
    BOOL v11 = (unint64_t *)&v24->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  unint64_t v13 = v28;
  if (v28)
  {
    __int128 v14 = (unint64_t *)&v28->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  return CFAutoRelease<__CFDictionary const*>::~CFAutoRelease((const void **)&v29);
}

void sub_18812C6C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  udif::xml_rsrc_iterator::~xml_rsrc_iterator((const void **)va);
  udif::xml_rsrc_iterator::~xml_rsrc_iterator((const void **)va1);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](v2 - 40);
  CFAutoRelease<__CFDictionary const*>::~CFAutoRelease((const void **)(v2 - 24));
  _Unwind_Resume(a1);
}

void udif::xml_rsrc_iterator::~xml_rsrc_iterator(const void **this)
{
  if (*((_BYTE *)this + 24)) {
    CFAutoRelease<__CFDictionary const*>::~CFAutoRelease(this + 2);
  }
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

void *di_log::logger<di_log::log_printer<638ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<638ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E6610;
  a1[45] = &unk_18A1E6710;
  a1[46] = &unk_18A1E6738;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E6610;
  a1[45] = &unk_18A1E6698;
  a1[46] = &unk_18A1E66C0;
  return a1;
}

void sub_18812C7C4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<638ul>>::~logger(uint64_t a1)
{
  return a1;
}

const void *udif::details::UDIF_base::get_identifier(udif::details::UDIF_base *this)
{
  Value = CFDictionaryGetValue(theDict, @"uuid");
  CFTypeID TypeID = CFArrayGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) != TypeID)
    {
      exception = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
      CFGetTypeID(Value);
      int v10 = cf::CFUtilException::CFUtilException(exception);
    }

    if (CFArrayGetCount((CFArrayRef)Value) < 1) {
      goto LABEL_10;
    }
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)Value, 0LL);
    CFTypeID v4 = CFDictionaryGetTypeID();
    if (ValueAtIndex && CFGetTypeID(ValueAtIndex) != v4)
    {
      BOOL v11 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
      CFGetTypeID(ValueAtIndex);
      unint64_t v12 = cf::CFUtilException::CFUtilException(v11);
    }

    size_t v5 = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"Data");
    CFTypeID v6 = CFDataGetTypeID();
    if (!v5)
    {
      Value = 0LL;
      goto LABEL_11;
    }

    if (CFGetTypeID(v5) != v6)
    {
      unint64_t v13 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
      CFGetTypeID(v5);
      __int128 v14 = cf::CFUtilException::CFUtilException(v13);
    }

    BytePtr = CFDataGetBytePtr((CFDataRef)v5);
    if (BytePtr) {
      Value = *(const void **)BytePtr;
    }
    else {
LABEL_10:
    }
      Value = 0LL;
  }

void sub_18812C9DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
}

void udif::details::UDIF_base::get_resources(udif::details::UDIF_base *this@<X0>, void *a2@<X8>)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  udif::details::UDIF_base::get_xml_data(this, &bytes);
  CFIndex v4 = *(void *)(*((void *)this + 9) + 224LL);
  size_t v5 = bytes;
  cf::deserialize_from_xml_plist(bytes, v4, &theDict);
  Value = CFDictionaryGetValue(theDict, @"resource-fork");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!Value)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = off_18A1E43B0;
    __int128 v14 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v14;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 48) = 0;
    exception[7] = "UDIF: Can't create dictionary resource fork";
  }

  if (CFGetTypeID(Value) != TypeID)
  {
    unint64_t v15 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
    CFGetTypeID(Value);
    unint64_t v16 = cf::CFUtilException::CFUtilException(v15);
  }

  if (DIDebugLogsEnabled())
  {
    int v8 = *__error();
    if (DIForwardLogs())
    {
      DIOSLog = (os_log_s *)getDIOSLog();
      os_log_type_enabled(DIOSLog, OS_LOG_TYPE_DEBUG);
      *(_DWORD *)buf = 68158210;
      int v20 = 39;
      __int16 v21 = 2080;
      char v22 = "udif::details::UDIF_base::get_resources() const";
      __int16 v23 = 2114;
      __int128 v24 = Value;
      int v10 = (const char *)_os_log_send_and_compose_impl();
      if (v10)
      {
        BOOL v11 = (char *)v10;
        fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v10);
        free(v11);
      }
    }

    else
    {
      unint64_t v12 = (os_log_s *)getDIOSLog();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 68158210;
        int v20 = 39;
        __int16 v21 = 2080;
        char v22 = "udif::details::UDIF_base::get_resources() const";
        __int16 v23 = 2114;
        __int128 v24 = Value;
        _os_log_impl(&dword_188046000, v12, OS_LOG_TYPE_DEBUG, "%.*s: XML_RSRC_FORK: %{public}@", buf, 0x1Cu);
      }
    }

    *__error() = v8;
  }

  CFRetain(Value);
  *a2 = Value;
  CFAutoRelease<__CFDictionary const*>::~CFAutoRelease((const void **)&theDict);
  if (v5) {
    operator delete[](v5);
  }
}

void sub_18812CCC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  if (v5) {
    operator delete[](v5);
  }
  _Unwind_Resume(a1);
}

udif::details::blocks *udif::details::blocks::blocks(udif::details::blocks *this, const char *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  *((_OWORD *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0u;
  CFIndex v4 = (void *)((char *)this + 16);
  *((void *)this + 4) = 0xFFFFFFFE00000000LL;
  size_t v5 = (_DWORD *)((char *)this + 32);
  *(_OWORD *)((char *)this + 40) = 0u;
  CFTypeID v6 = (char *)this + 40;
  *(_OWORD *)this = 0u;
  *(_OWORD *)((char *)this + ++*(_DWORD *)(this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + std::pair<udif::xml_rsrc_iterator,udif::xml_rsrc_iterator>::~pair(v8 - 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  udif::checksum_type::checksum_type((udif::details::blocks *)((char *)this + 64));
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 50) = 0;
  int v7 = *(_DWORD *)a2;
  LODWORD(v25) = 1752394093;
  smart_enums::validators::value<unsigned int>((uint64_t)"blocks_signature", v7, &v25, 1LL);
  *(_DWORD *)this = 1752394093;
  int v8 = bswap32(*((_DWORD *)a2 + 1));
  LODWORD(v25) = 1;
  smart_enums::validators::value<unsigned int>((uint64_t)"version", v8, &v25, 1LL);
  *((_DWORD *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = 1;
  *((void *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = bswap64(*((void *)a2 + 1));
  *CFIndex v4 = bswap64(*((void *)a2 + 2));
  *((void *)this + 3) = bswap64(*((void *)a2 + 3));
  *size_t v5 = bswap32(*((_DWORD *)a2 + 8));
  LODWORD(v25) = *((_DWORD *)a2 + 9);
  udif::details::endian_reverse((unsigned int *)&v25, (unsigned int *)v24);
  *((_DWORD *)this + 9) = *(_DWORD *)v24;
  __int128 v9 = *(_OWORD *)(a2 + 40);
  *((void *)v6 + 2) = *((void *)a2 + 7);
  *(_OWORD *)CFTypeID v6 = v9;
  udif::checksum_type::checksum_type((udif::checksum_type *)v24);
  __int128 v10 = *((_OWORD *)a2 + 11);
  *(_OWORD *)&v24[96] = *((_OWORD *)a2 + 10);
  *(_OWORD *)&v24[112] = v10;
  *(void *)&v24[128] = *((void *)a2 + 24);
  __int128 v11 = *((_OWORD *)a2 + 7);
  *(_OWORD *)&v24[32] = *((_OWORD *)a2 + 6);
  *(_OWORD *)&v24[48] = v11;
  __int128 v12 = *((_OWORD *)a2 + 9);
  *(_OWORD *)&v24[64] = *((_OWORD *)a2 + 8);
  *(_OWORD *)&v24[80] = v12;
  __int128 v13 = *((_OWORD *)a2 + 5);
  *(_OWORD *)__int128 v24 = *((_OWORD *)a2 + 4);
  *(_OWORD *)&v24[16] = v13;
  __int128 v30 = *(_OWORD *)&v24[72];
  __int128 v31 = *(_OWORD *)&v24[88];
  __int128 v32 = *(_OWORD *)&v24[104];
  __int128 v33 = *(_OWORD *)&v24[120];
  __int128 v26 = *(_OWORD *)&v24[8];
  __int128 v27 = *(_OWORD *)&v24[24];
  __int128 v28 = *(_OWORD *)&v24[40];
  __int128 v29 = *(_OWORD *)&v24[56];
  uint64_t v25 = *(void *)v24;
  udif::details::endian_reverse((uint64_t)&v25, (int *)&v15);
  *((void *)this + 8) = v15;
  *(_OWORD *)((char *)this + 136) = v20;
  *(_OWORD *)((char *)this + 152) = v21;
  *(_OWORD *)((char *)this + std::pair<udif::xml_rsrc_iterator,udif::xml_rsrc_iterator>::~pair(v8 - 168) = v22;
  *(_OWORD *)((char *)this + 184) = v23;
  *(_OWORD *)((char *)this + 72) = v16;
  *(_OWORD *)((char *)this + 88) = v17;
  *(_OWORD *)((char *)this + 104) = v18;
  *(_OWORD *)((char *)this + 120) = v19;
  *((_DWORD *)this + 50) = bswap32(*((_DWORD *)a2 + 50));
  return this;
}

void sub_18812CF7C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

udif::details::run_t *udif::details::run_t::run_t(udif::details::run_t *this, const char *a2)
{
  CFIndex v4 = udif::run_type::run_type(this);
  *((_DWORD *)v4 + 9) = 0;
  *(_OWORD *)((char *)v4 + 20) = 0u;
  *(_OWORD *)((char *)v4 + 4) = 0u;
  udif::run_type::run_type((udif::run_type *)&v6, bswap32(*(_DWORD *)a2));
  *(_DWORD *)this = v6;
  *((_DWORD *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = bswap32(*((_DWORD *)a2 + 1));
  *((void *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = bswap64(*((void *)a2 + 1));
  *((void *)this + 2) = bswap64(*((void *)a2 + 2));
  *((void *)this + 3) = bswap64(*((void *)a2 + 3));
  *((void *)this + 4) = bswap64(*((void *)a2 + 4));
  return this;
}

const void **udif::details::create_data_wrap_dict@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, void *a4@<X4>, CFDictionaryRef *a5@<X8>)
{
  v31[19] = *MEMORY[0x1895F89C0];
  __int128 v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  else {
    __int128 v10 = *(const char **)a1;
  }
  CFStringRef v11 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], v10, 0x8000100u);
  CFTypeRef cf = 0LL;
  CFStringRef v23 = v11;
  if (*(_BYTE *)(a2 + 24))
  {
    else {
      __int128 v12 = *(const char **)a2;
    }
    CFTypeRef cf = CFStringCreateWithCString(v9, v12, 0x8000100u);
  }

  else
  {
    CFTypeRef cf = &stru_18A1F2380;
  }

  keys[0] = 0LL;
  CFAutoRelease<__CFString const*>::~CFAutoRelease((const void **)keys);
  std::to_string(&v21, a3);
  if ((v21.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    __int128 v13 = &v21;
  }
  else {
    __int128 v13 = (std::string *)v21.__r_.__value_.__r.__words[0];
  }
  CFStringRef v20 = CFStringCreateWithCString(v9, (const char *)v13, 0x600u);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)keys);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v26, (uint64_t)"0x", 2LL);
  *(_DWORD *)((char *)&v26 + *(void *)(v26 - 24) + 8) = *(_DWORD *)((_BYTE *)&v26 + *(void *)(v26 - 24) + 8) & 0xFFFFFFB5 | 8;
  LOBYTE(values[0]) = 48;
  std::operator<<[abi:ne180100]<std::char_traits<char>>(&v26, (char *)values);
  *(void *)&v28[*(void *)(v26 - 24)] = 4LL;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]((uint64_t)&v26 + 8, &v19);
  keys[0] = *(void **)MEMORY[0x189614728];
  uint64_t v14 = *(void *)(MEMORY[0x189614728] + 72LL);
  *(void **)((char *)keys + *((void *)keys[0] - 3)) = *(void **)(MEMORY[0x189614728] + 64LL);
  *(void *)&__int128 v26 = v14;
  *((void *)&v26 + udif::run_type::run_type((udif::run_type *)&v11, 1) = MEMORY[0x189614750] + 16LL;
  if (v30 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1895BC2CC](v31);
  if ((v19.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v15 = &v19;
  }
  else {
    uint64_t v15 = (std::string *)v19.__r_.__value_.__r.__words[0];
  }
  CFStringRef v18 = CFStringCreateWithCString(v9, (const char *)v15, 0x600u);
  *(_OWORD *)keys = xmmword_18A1E58F0;
  __int128 v26 = *(_OWORD *)off_18A1E5900;
  __int128 v27 = @"CFName";
  values[0] = a4;
  values[1] = (void *)v23;
  values[2] = (void *)v20;
  values[3] = (void *)v18;
  if (*(_BYTE *)(a2 + 24)) {
    CFIndex v16 = 5LL;
  }
  else {
    CFIndex v16 = 4LL;
  }
  values[4] = (void *)cf;
  *a5 = CFDictionaryCreate( v9,  (const void **)keys,  (const void **)values,  v16,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFAutoRelease<__CFString const*>::~CFAutoRelease((const void **)&v18);
  CFAutoRelease<__CFString const*>::~CFAutoRelease((const void **)&v20);
  CFAutoRelease<__CFString const*>::~CFAutoRelease(&cf);
  return CFAutoRelease<__CFString const*>::~CFAutoRelease((const void **)&v23);
}

void sub_18812D304( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, const void *a24, const void *a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, const void *a31)
{
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream( uint64_t a1)
{
  uint64_t v2 = MEMORY[0x189614728];
  uint64_t v3 = *MEMORY[0x189614728];
  *(void *)a1 = *MEMORY[0x189614728];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 24) = MEMORY[0x189614750] + 16LL;
  *(void *)(a1 + 16) = v4;
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1895BC2CC](a1 + 128);
  return a1;
}

void *udif::operator<<(void *a1, int *a2)
{
  int v4 = *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 8);
  size_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"type: ", 6LL);
  int v26 = *a2;
  int v6 = udif::operator<<(v5, &v26);
  int v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" data: ", 7LL);
  uint64_t v8 = *v7;
  *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24) + 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(*v7 - 24) + 8) & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v7 + *(void *)(v8 - 24) + 8) |= 0x200u;
  __int128 v9 = (void *)std::ostream::operator<<();
  __int128 v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"/", 1LL);
  uint64_t v11 = *v10;
  *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24) + 8) = *(_DWORD *)((_BYTE *)v10 + *(void *)(*v10 - 24) + 8) & 0xFFFFFFB5 | 2;
  *(_DWORD *)((char *)v10 + *(void *)(v11 - 24) + 8) &= ~0x200u;
  __int128 v12 = (void *)std::ostream::operator<<();
  __int128 v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" logical: ", 10LL);
  uint64_t v14 = *v13;
  *(_DWORD *)((char *)v13 + *(void *)(*v13 - 24) + 8) = *(_DWORD *)((_BYTE *)v13 + *(void *)(*v13 - 24) + 8) & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v13 + *(void *)(v14 - 24) + 8) |= 0x200u;
  uint64_t v15 = (void *)std::ostream::operator<<();
  CFIndex v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"/", 1LL);
  uint64_t v17 = *v16;
  *(_DWORD *)((char *)v16 + *(void *)(*v16 - 24) + 8) = *(_DWORD *)((_BYTE *)v16 + *(void *)(*v16 - 24) + 8) & 0xFFFFFFB5 | 2;
  *(_DWORD *)((char *)v16 + *(void *)(v17 - 24) + 8) &= ~0x200u;
  CFStringRef v18 = (void *)std::ostream::operator<<();
  std::string v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" io: ", 5LL);
  uint64_t v20 = *v19;
  *(_DWORD *)((char *)v19 + *(void *)(*v19 - 24) + 8) = *(_DWORD *)((_BYTE *)v19 + *(void *)(*v19 - 24) + 8) & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v19 + *(void *)(v20 - 24) + 8) |= 0x200u;
  std::string v21 = (void *)std::ostream::operator<<();
  __int128 v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)",", 1LL);
  uint64_t v23 = *v22;
  *(_DWORD *)((char *)v22 + *(void *)(*v22 - 24) + 8) = *(_DWORD *)((_BYTE *)v22 + *(void *)(*v22 - 24) + 8) & 0xFFFFFFB5 | 2;
  *(_DWORD *)((char *)v22 + *(void *)(v23 - 24) + 8) &= ~0x200u;
  __int128 v24 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"/", 1LL);
  std::ostream::operator<<();
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 8) = v4;
  return a1;
}

{
  int v3;
  uint64_t i;
  int v5;
  char v7;
  uint64_t v3 = *a2;
  if (!*a2) {
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"none", 4LL);
  }
  for (uint64_t i = 0LL; i != 18; i += 6LL)
  {
    size_t v5 = udif::header::header_flags::strings[i];
    if ((v5 & v3) != 0)
    {
      v3 &= ~v5;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( a1,  *(void *)&udif::header::header_flags::strings[i + 2],  *(void *)&udif::header::header_flags::strings[i + 4]);
      if (v3)
      {
        int v7 = 44;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)&v7, 1LL);
      }
    }
  }

  return a1;
}

uint64_t udif::xml_rsrc_iterator::get_type(udif::xml_rsrc_iterator *this)
{
  uint64_t result = CFStringGetOSType(*(const __CFString **)(*(void *)this + 8LL * *((void *)this + 4)));
  if (!(_DWORD)result)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v3);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v3,  (uint64_t)"UDIF: Failed converting type array string (",  43LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)") to type", 9LL);
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v3, 0x16u);
  }

  return result;
}

void sub_18812D728(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

const void *udif::xml_rsrc_iterator::get_value(CFDictionaryRef *this)
{
  uint64_t result = CFDictionaryGetValue(this[2], *((const void **)*this + (void)this[4]));
  if (!result)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "UDIF: Can't get resource array", 0x16u);
  }

  return result;
}

BOOL udif::xml_rsrc_iterator::operator==(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 != *(void *)a2) {
    return 0LL;
  }
  int v3 = *(unsigned __int8 *)(a2 + 24);
  if (*(_BYTE *)(a1 + 24)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 24) != 0) == (v3 != 0)) {
      return *(void *)(a1 + 32) == *(void *)(a2 + 32);
    }
    return 0LL;
  }

  if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
    return 0LL;
  }
  return *(void *)(a1 + 32) == *(void *)(a2 + 32);
}

uint64_t *UDIF_header::UDIF_header(uint64_t *a1, Backend **a2)
{
  *a1 = 0LL;
  a1[1] = (uint64_t)*a2;
  BOOL v4 = a2[1];
  a1[2] = (uint64_t)v4;
  if (v4)
  {
    size_t v5 = (unint64_t *)((char *)v4 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  int v7 = operator new[](0x1F4uLL);
  v7[124] = 0;
  *((_OWORD *)v7 + 29) = 0u;
  *((_OWORD *)v7 + 30) = 0u;
  *((_OWORD *)v7 + 27) = 0u;
  *((_OWORD *)v7 + 28) = 0u;
  *((_OWORD *)v7 + 25) = 0u;
  *((_OWORD *)v7 + 26) = 0u;
  *((_OWORD *)v7 + 23) = 0u;
  *((_OWORD *)v7 + 24) = 0u;
  *((_OWORD *)v7 + 2udif::run_type::run_type((udif::run_type *)&v11, 1) = 0u;
  *((_OWORD *)v7 + 22) = 0u;
  *((_OWORD *)v7 + 19) = 0u;
  *((_OWORD *)v7 + 20) = 0u;
  *((_OWORD *)v7 + 17) = 0u;
  *((_OWORD *)v7 + 18) = 0u;
  *((_OWORD *)v7 + 15) = 0u;
  *((_OWORD *)v7 + 16) = 0u;
  *((_OWORD *)v7 + 13) = 0u;
  *((_OWORD *)v7 + 14) = 0u;
  *((_OWORD *)v7 + 1udif::run_type::run_type((udif::run_type *)&v11, 1) = 0u;
  *((_OWORD *)v7 + 12) = 0u;
  *((_OWORD *)v7 + 9) = 0u;
  *((_OWORD *)v7 + 10) = 0u;
  *((_OWORD *)v7 + 7) = 0u;
  *((_OWORD *)v7 + 8) = 0u;
  *((_OWORD *)v7 + 5) = 0u;
  *((_OWORD *)v7 + 6) = 0u;
  *((_OWORD *)v7 + 3) = 0u;
  *((_OWORD *)v7 + 4) = 0u;
  *((_OWORD *)v7 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0u;
  *((_OWORD *)v7 + 2) = 0u;
  *(_OWORD *)int v7 = 0u;
  unint64_t v8 = (*(uint64_t (**)(Backend *))(*(void *)*a2 + 40LL))(*a2);
  if (v8 <= 0x1FF)
  {
    unint64_t v13 = v8;
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = off_18A1E2338;
    exception[1] = "UDIF_header";
    exception[2] = 8LL;
    exception[3] = v13;
  }

  unsigned int v9 = Backend::read(*a2, (char *)v7, 500LL, v8 - 512);
  if ((v9 & 0x80000000) != 0)
  {
    uint64_t v15 = __cxa_allocate_exception(0x40uLL);
    *uint64_t v15 = off_18A1E43B0;
    CFIndex v16 = std::generic_category();
    v15[1] = v9;
    v15[2] = v16;
    *((_BYTE *)v15 + 24) = 0;
    *((_BYTE *)v15 + 48) = 0;
    v15[7] = "UDIF: Can't read UDIF trailer";
  }

  __int128 v10 = (udif::header *)operator new(0x1F4uLL);
  udif::header::header(v10, (const char *)v7);
  uint64_t v11 = (void *)*a1;
  *a1 = (uint64_t)v10;
  if (v11) {
    operator delete(v11);
  }
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v17 = "UDIF_header::UDIF_header(const std::shared_ptr<Backend> &)";
    *((void *)&v17 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 24LL;
    int v18 = 2;
    di_log::logger<di_log::log_printer<898ul>>::logger(v19, &v17);
    udif::operator<<(&v20, *a1);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<898ul>>::~logger_buf((uint64_t)v19);
    MEMORY[0x1895BC2CC](&v21);
  }

  operator delete[](v7);
  return a1;
}

void sub_18812DA30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  unint64_t v8 = *v4;
  *BOOL v4 = 0LL;
  if (v8) {
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void *di_log::logger<di_log::log_printer<898ul>>::logger(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<898ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E6830;
  a1[45] = &unk_18A1E6930;
  a1[46] = &unk_18A1E6958;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E6830;
  a1[45] = &unk_18A1E68B8;
  a1[46] = &unk_18A1E68E0;
  return a1;
}

void sub_18812DB18(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<898ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *UDIF_header::UDIF_header(void *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  *a2 = 0LL;
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  const void *result = v3;
  result[1] = v5;
  result[2] = v4;
  if (v4)
  {
    unint64_t v6 = (unint64_t *)(v4 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<85ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<85ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<85ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<85ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<85ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<85ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<85ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<85ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<85ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<85ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E5AD8;
  di_log::logger_buf<di_log::log_printer<85ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<85ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<85ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18812DF50( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<85ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<85ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<85ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 85LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 85LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

udif::checksum_type *udif::checksum_type::checksum_type(udif::checksum_type *this, int a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  *(_DWORD *)this = a2;
  v4[0] = xmmword_188181250;
  v4[1] = xmmword_188181810;
  uint64_t v5 = 0x900000008LL;
  int v6 = 10;
  smart_enums::validators::value<unsigned int>((uint64_t)"checksum_type", a2, v4, 11LL);
  return this;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<udif::details::checksum::checksum(checksum::Any<locks::None,checksum::None,checksum::CRC32> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,checksum::None<locks::None>,checksum::CRC32<locks::None>> const&>@<X0>( uint64_t a1@<X8>)
{
  return udif::details::checksum::checksum<locks::None,checksum::None<locks::None>>(a1);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<udif::details::checksum::checksum(checksum::Any<locks::None,checksum::None,checksum::CRC32> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,checksum::None<locks::None>,checksum::CRC32<locks::None>> const&>@<X0>( _DWORD *a1@<X1>, uint64_t a2@<X8>)
{
  return udif::details::checksum::checksum<locks::None,checksum::CRC32<locks::None>>(a2, (uint64_t)a1, a1);
}

uint64_t udif::details::checksum::checksum<locks::None,checksum::None<locks::None>>(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  udif::checksum_type::checksum_type((udif::checksum_type *)&v3, 0);
  *(void *)a1 = v3;
  unsigned int v4 = 0;
  udif::details::checksum::_checksum::set_len(v5, &v4);
  *(_DWORD *)(a1 + 4) = v5[0];
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(this + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  return a1;
}

uint64_t udif::details::checksum::checksum<locks::None,checksum::CRC32<locks::None>>( uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  udif::checksum_type::checksum_type((udif::checksum_type *)&v6, 2);
  *(_DWORD *)a1 = v6;
  *(_DWORD *)(a1 + 4) = 0;
  LODWORD(a3) = *a3;
  unsigned int v7 = 32;
  udif::details::checksum::_checksum::set_len(&v8, &v7);
  *(_DWORD *)unsigned int v9 = (_DWORD)a3;
  memset(&v9[4], 0, 124);
  *(_DWORD *)(a1 + 4) = v8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)&v9[64];
  *(_OWORD *)(a1 + 88) = *(_OWORD *)&v9[80];
  *(_OWORD *)(a1 + 104) = *(_OWORD *)&v9[96];
  *(_OWORD *)(a1 + 120) = *(_OWORD *)&v9[112];
  *(_OWORD *)(a1 + 8) = *(_OWORD *)v9;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)&v9[16];
  *(_OWORD *)(a1 + 40) = *(_OWORD *)&v9[32];
  *(_OWORD *)(a1 + ++*(_DWORD *)(this + 56) = *(_OWORD *)&v9[48];
  return a1;
}

unsigned int *udif::details::descriptor_special::descriptor_special(unsigned int *this, unsigned int a2)
{
  *this = a2;
  if (a2 <= 0xFFFFFFFD)
  {
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid value";
    exception[3] = "value validator";
    void *exception = off_18A1E4068;
    exception[1] = "descriptor_special";
    *((_DWORD *)exception + 8) = a2;
  }

  return this;
}

udif::run_type *udif::run_type::run_type(udif::run_type *this, int a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  *(_DWORD *)this = a2;
  v4[0] = xmmword_188181820;
  v4[1] = xmmword_188181830;
  _OWORD v4[2] = xmmword_188181840;
  unint64_t v5 = 0x8000000880000007LL;
  int v6 = -1;
  smart_enums::validators::value<unsigned int>((uint64_t)"run_type", a2, v4, 15LL);
  return this;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<417ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<417ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<417ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<417ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<417ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<417ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<417ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<417ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<417ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<417ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E5D08;
  di_log::logger_buf<di_log::log_printer<417ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<417ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<417ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18812E850( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<417ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<417ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<417ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 417LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 417LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<458ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<458ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<458ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<458ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<458ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<458ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<458ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<458ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<458ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<458ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E5F28;
  di_log::logger_buf<di_log::log_printer<458ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<458ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<458ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18812EDFC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<458ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<458ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<458ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 458LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 458LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<500ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<500ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<500ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<500ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<500ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<500ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<500ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<500ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<500ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<500ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E6148;
  di_log::logger_buf<di_log::log_printer<500ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<500ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<500ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18812F3A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<500ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<500ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<500ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 500LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 500LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<601ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<601ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<601ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<601ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<601ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<601ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<601ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<601ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<601ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<601ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E6368;
  di_log::logger_buf<di_log::log_printer<601ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<601ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<601ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18812F954( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<601ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<601ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<601ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 601LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 601LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<603ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<603ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<603ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<603ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<603ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<603ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<603ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<603ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<603ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<603ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E6588;
  di_log::logger_buf<di_log::log_printer<603ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<603ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<603ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18812FF00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<603ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<603ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<603ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 603LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 603LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<638ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<638ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<638ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<638ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<638ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<638ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<638ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<638ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<638ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<638ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E67A8;
  di_log::logger_buf<di_log::log_printer<638ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<638ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<638ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1881304AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<638ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<638ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<638ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 638LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 638LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t udif::xml_rsrc_iterator::xml_rsrc_iterator(uint64_t a1, void *a2, const void **a3, uint64_t a4)
{
  uint64_t v6 = a2[1];
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = v6;
  if (v6)
  {
    uint64_t v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  *(void *)(a1 + 16) = 0LL;
  unsigned int v9 = *a3;
  *(void *)(a1 + 16) = *a3;
  if (v9) {
    CFRetain(v9);
  }
  *(_BYTE *)(a1 + 24) = 1;
  *(void *)(a1 + 32) = a4;
  return a1;
}

void sub_188130734(_Unwind_Exception *a1)
{
}

uint64_t std::pair<udif::xml_rsrc_iterator,udif::xml_rsrc_iterator>::pair[abi:ne180100]<udif::xml_rsrc_iterator,udif::xml_rsrc_iterator,0>( uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)uint64_t result = *(_OWORD *)a2;
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(_BYTE *)(result + 16) = 0;
  *(_BYTE *)(result + 24) = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 16) = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = 0LL;
    *(_BYTE *)(result + 24) = 1;
  }

  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(_OWORD *)(result + 40) = *(_OWORD *)a3;
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(_BYTE *)(result + ++*(_DWORD *)(this + 56) = 0;
  *(_BYTE *)(result + 64) = 0;
  if (*(_BYTE *)(a3 + 24))
  {
    *(void *)(result + ++*(_DWORD *)(this + 56) = 0LL;
    *(void *)(result + ++*(_DWORD *)(this + 56) = *(void *)(a3 + 16);
    *(void *)(a3 + 16) = 0LL;
    *(_BYTE *)(result + 64) = 1;
  }

  *(void *)(result + 72) = *(void *)(a3 + 32);
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<898ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<898ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<898ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<898ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<898ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<898ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<898ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<898ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<898ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<898ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E69C8;
  di_log::logger_buf<di_log::log_printer<898ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<898ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<898ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188130B4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<898ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<898ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<898ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 898LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 898LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

_DWORD *udif::header::header_flags::header_flags(_DWORD *this, int a2)
{
  uint64_t v2 = 0LL;
  uint64_t v7 = *MEMORY[0x1895F89C0];
  *this = a2;
  uint64_t v5 = 0x200000001LL;
  int v6 = 4;
  do
  {
    a2 &= ~*(_DWORD *)((char *)&v5 + v2);
    v2 += 4LL;
  }

  while (v2 != 12);
  if (a2)
  {
    int v3 = a2;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid flags";
    exception[3] = "flags validator";
    void *exception = off_18A1CA768;
    exception[1] = "header_flags";
    *((_DWORD *)exception + 8) = v3;
  }

  return this;
}

udif::checksum_type *udif::checksum_type::checksum_type(udif::checksum_type *this)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  *(_DWORD *)this = 0;
  v3[0] = xmmword_188181250;
  v3[1] = xmmword_188181810;
  uint64_t v4 = 0x900000008LL;
  int v5 = 10;
  smart_enums::validators::value<unsigned int>((uint64_t)"checksum_type", 0, v3, 11LL);
  return this;
}

uint64_t di_log::logger_buf<di_log::log_printer<85ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E5AD8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188130F40(_Unwind_Exception *a1)
{
}

void *print_buffer(void *a1, uint64_t a2, uint64_t a3)
{
  char v4 = a1 + 1;
  uint64_t v5 = *(void *)(*a1 - 24LL);
  int v6 = *(_DWORD *)((char *)a1 + v5 + 8);
  if (a3 == 1)
  {
    int v11 = *(_DWORD *)((char *)a1 + v5 + 8);
  }

  else
  {
    uint64_t v8 = a3 - 1;
    do
    {
      *(_DWORD *)((char *)v4 + *(void *)(*a1 - 24LL)) = *(_DWORD *)((_BYTE *)v4 + *(void *)(*a1 - 24LL)) & 0xFFFFFFB5 | 8;
      char v15 = 48;
      unsigned int v9 = std::operator<<[abi:ne180100]<std::char_traits<char>>(a1, &v15);
      *(void *)((char *)v9 + *(void *)(*v9 - 24LL) + 24) = 2LL;
      ++a2;
      uint64_t v10 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" ", 1LL);
      --v8;
    }

    while (v8);
    uint64_t v5 = *(void *)(*a1 - 24LL);
    int v11 = *(_DWORD *)((char *)a1 + v5 + 8);
  }

  *(_DWORD *)((char *)a1 + v5 + 8) = v11 & 0xFFFFFFB5 | 8;
  char v14 = 48;
  os_log_type_t v12 = std::operator<<[abi:ne180100]<std::char_traits<char>>(a1, &v14);
  *(void *)((char *)v12 + *(void *)(*v12 - 24LL) + 24) = 2LL;
  std::ostream::operator<<();
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 8) = v6;
  return a1;
}

uint64_t std::map<udif::run_type,CompressedBackend::algo_t>::map[abi:ne180100]( uint64_t a1, unsigned int *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0LL;
  char v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    do
    {
      std::__tree<std::__value_type<udif::run_type,CompressedBackend::algo_t>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,CompressedBackend::algo_t>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,CompressedBackend::algo_t>>>::__emplace_hint_unique_key_args<udif::run_type,std::pair<udif::run_type const,CompressedBackend::algo_t> const&>( (uint64_t **)a1,  v4,  a2,  (uint64_t *)a2);
      a2 += 2;
      v6 -= 8LL;
    }

    while (v6);
  }

  return a1;
}

void sub_18813128C(_Unwind_Exception *a1)
{
}

uint64_t *std::__tree<std::__value_type<udif::run_type,CompressedBackend::algo_t>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,CompressedBackend::algo_t>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,CompressedBackend::algo_t>>>::__emplace_hint_unique_key_args<udif::run_type,std::pair<udif::run_type const,CompressedBackend::algo_t> const&>( uint64_t **a1, uint64_t *a2, unsigned int *a3, uint64_t *a4)
{
  uint64_t v6 = std::__tree<std::__value_type<udif::run_type,CompressedBackend::algo_t>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,CompressedBackend::algo_t>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,CompressedBackend::algo_t>>>::__find_equal<udif::run_type>( a1,  a2,  &v11,  &v10,  a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v7 + 28) = *a4;
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  (uint64_t)v11,  v8,  v7);
  }

  return v7;
}

uint64_t *std::__tree<std::__value_type<udif::run_type,CompressedBackend::algo_t>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,CompressedBackend::algo_t>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,CompressedBackend::algo_t>>>::__find_equal<udif::run_type>( void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (unsigned int v6 = *a5, v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      unsigned int v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        unsigned int v9 = (uint64_t *)v9[1];
      }

      while (v9);
    }

    else
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }

      while (v14);
    }

    unsigned int v15 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          int v17 = (uint64_t *)v16;
          unsigned int v18 = *(_DWORD *)(v16 + 28);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }

      while (v16);
    }

    else
    {
      int v17 = a1 + 1;
    }

uint64_t **std::__tree<std::__value_type<udif::run_type,unsigned long long>,std::__map_value_compare<udif::run_type,std::__value_type<udif::run_type,unsigned long long>,std::less<udif::run_type>,true>,std::allocator<std::__value_type<udif::run_type,unsigned long long>>>::__emplace_unique_key_args<udif::run_type,std::piecewise_construct_t const&,std::tuple<udif::run_type const&>,std::tuple<>>( uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unsigned int v7 = a1 + 1;
  unsigned int v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        unsigned int v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        unsigned int v6 = *v9;
        unsigned int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      unsigned int v6 = v9[1];
      if (!v6)
      {
        unsigned int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unsigned int v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    v11[8] = **a4;
    *((void *)v11 + 5) = 0LL;
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  (uint64_t)v9,  v7,  (uint64_t *)v11);
    return (uint64_t **)v11;
  }

  return v9;
}

uint64_t di_log::logger_buf<di_log::log_printer<417ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E5D08;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881315F8(_Unwind_Exception *a1)
{
}

uint64_t std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>>>::find<boost::icl::discrete_interval<unsigned long long,std::less>>( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  unint64_t v5 = (*(_BYTE *)(a2 + 16) & 2) != 0 ? *(void *)a2 : *(void *)a2 + 1LL;
  uint64_t v6 = v2;
  do
  {
    unint64_t v7 = (*(_BYTE *)(v3 + 48) & 1) + *(void *)(v3 + 40) - 1LL;
    BOOL v8 = v7 >= v5;
    if (v7 >= v5) {
      unsigned int v9 = (uint64_t *)v3;
    }
    else {
      unsigned int v9 = (uint64_t *)(v3 + 8);
    }
    if (v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }

  while (*v9);
  if (v6 == v2) {
    return v2;
  }
  unint64_t v10 = *(void *)(v6 + 32);
  if ((*(_BYTE *)(v6 + 48) & 2) == 0) {
    ++v10;
  }
  return v6;
}

uint64_t *boost::icl::interval_base_map<boost::icl::split_interval_map<unsigned long long,std::optional<udif::details::block_info>,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,std::optional<udif::details::block_info>,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::_insert( uint64_t **a1, uint64_t a2)
{
  __int128 v14 = *(_OWORD *)a2;
  uint64_t v15 = *(void *)(a2 + 16);
  if ((_BYTE)v15)
  {
    if (v15 == 3)
    {
    }

    else if ((unint64_t)v14 >= *((void *)&v14 + 1))
    {
      return (uint64_t *)(a1 + 1);
    }
  }

  else if ((unint64_t)v14 >= *((void *)&v14 + 1) || (unint64_t)(v14 + 1) >= *((void *)&v14 + 1))
  {
    return (uint64_t *)(a1 + 1);
  }

  unint64_t v5 = (uint64_t *)(a2 + 24);
  uint64_t result = std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>>>::__emplace_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,std::pair<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>> const&>( a1,  a2,  a2);
  if ((v7 & 1) == 0)
  {
    BOOL v8 = (uint64_t *)std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::lower_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  (uint64_t)&v14);
    unsigned int v9 = (uint64_t **)std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::upper_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  (uint64_t)&v14);
    unint64_t v10 = *v9;
    if (*v9)
    {
      do
      {
        uint64_t v11 = v10;
        unint64_t v10 = (uint64_t *)v10[1];
      }

      while (v10);
    }

    else
    {
      do
      {
        uint64_t v11 = v9[2];
        BOOL v12 = *v11 == (void)v9;
        unsigned int v9 = (uint64_t **)v11;
      }

      while (v12);
    }

    uint64_t v13 = v11;
    uint64_t v16 = v8;
    boost::icl::interval_base_map<boost::icl::split_interval_map<unsigned long long,std::optional<udif::details::block_info>,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,std::optional<udif::details::block_info>,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::insert_main( a1,  &v14,  v5,  &v16,  &v13);
    return v16;
  }

  return result;
}

BOOL boost::icl::on_absorbtion<boost::icl::interval_base_map<boost::icl::split_interval_map<unsigned long long,std::optional<udif::details::block_info>,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,std::optional<udif::details::block_info>,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,boost::icl::inplace_plus<std::optional<udif::details::block_info>>,true>::is_absorbable( uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  LOBYTE(ContextAllocator<locks::Std,std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>>::allocate(void)::{lambda(locks::Std)#1}::operator()<std::tuple<std::unique_ptr<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF,std::default_delete<DiskImageUDIFRead<UDIFReader<locks::None>,DiskImageUDIF>::ContextUDIF>>,std::shared_ptr<BackendSG>> *>( (uint64_t *)va, v2) = 0;
  char v12 = 0;
  if (byte_18C701964)
  {
    uint64_t v2 = boost::icl::identity_element<std::optional<udif::details::block_info>>::value(void)::_value;
    int v3 = dword_18C7018E0;
    __int128 v8 = unk_18C701924;
    __int128 v9 = unk_18C701934;
    __int128 v10 = unk_18C701944;
    __int128 v11 = unk_18C701954;
    __int128 v4 = *(_OWORD *)algn_18C7018E4;
    __int128 v5 = unk_18C7018F4;
    __int128 v6 = unk_18C701904;
    __int128 v7 = unk_18C701914;
    char v12 = 1;
  }

  return std::operator==[abi:ne180100]<udif::details::block_info,udif::details::block_info>(a1, (uint64_t)&v2);
}

uint64_t boost::icl::interval_base_map<boost::icl::split_interval_map<unsigned long long,std::optional<udif::details::block_info>,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,std::optional<udif::details::block_info>,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::insert_main( uint64_t **a1, __int128 *a2, uint64_t *a3, uint64_t **a4, uint64_t **a5)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  __int128 v8 = *a5;
  __int128 v9 = (uint64_t *)(*a5)[1];
  if (v9)
  {
    do
    {
      __int128 v10 = v9;
      __int128 v9 = (uint64_t *)*v9;
    }

    while (v9);
  }

  else
  {
    __int128 v11 = *a5;
    do
    {
      __int128 v10 = (uint64_t *)v11[2];
      BOOL v12 = *v10 == (void)v11;
      __int128 v11 = v10;
    }

    while (!v12);
  }

  uint64_t v13 = *a4;
  if (*a1 == *a4)
  {
    uint64_t v15 = (uint64_t *)(a1 + 1);
  }

  else
  {
    __int128 v14 = (uint64_t *)*v13;
    if (*v13)
    {
      do
      {
        uint64_t v15 = v14;
        __int128 v14 = (uint64_t *)v14[1];
      }

      while (v14);
    }

    else
    {
      uint64_t v16 = *a4;
      do
      {
        uint64_t v15 = (uint64_t *)v16[2];
        BOOL v12 = *v15 == (void)v16;
        uint64_t v16 = v15;
      }

      while (v12);
    }
  }

  __int128 v39 = *a2;
  uint64_t v40 = *((void *)a2 + 2);
  *(void *)&__int128 v37 = boost::icl::identity_element<unsigned long long>::value(void)::_value;
  *((void *)&v37 + udif::run_type::run_type((udif::run_type *)&v11, 1) = boost::icl::identity_element<unsigned long long>::value(void)::_value;
  char v38 = 2;
  __int128 v35 = *((_OWORD *)v8 + 2);
  uint64_t v36 = v8[6];
  if (v13 != v10)
  {
    int v17 = (__int128 *)((char *)a3 + 12);
    do
    {
      __int128 v37 = *((_OWORD *)v13 + 2);
      char v38 = *((_BYTE *)v13 + 48);
      __int128 v33 = v39;
      uint64_t v34 = v40;
      boost::icl::right_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)&v33,  (uint64_t)&v37,  (uint64_t)&v41);
      if ((_BYTE)v42)
      {
        if (v42 == 3)
        {
        }

        else if ((unint64_t)v41 < *((void *)&v41 + 1))
        {
          goto LABEL_24;
        }
      }

      else if ((unint64_t)v41 < *((void *)&v41 + 1) && (unint64_t)(v41 + 1) < *((void *)&v41 + 1))
      {
LABEL_24:
        LOBYTE(v43) = 0;
        char v53 = 0;
        if (*((_BYTE *)a3 + 140))
        {
          uint64_t v43 = *a3;
          int v44 = *((_DWORD *)a3 + 2);
          __int128 v18 = *(_OWORD *)((char *)a3 + 92);
          __int128 v49 = *(_OWORD *)((char *)a3 + 76);
          __int128 v50 = v18;
          __int128 v19 = *(_OWORD *)((char *)a3 + 124);
          __int128 v51 = *(_OWORD *)((char *)a3 + 108);
          __int128 v52 = v19;
          __int128 v20 = *(_OWORD *)((char *)a3 + 28);
          __int128 v45 = *v17;
          __int128 v46 = v20;
          __int128 v21 = *(_OWORD *)((char *)a3 + 60);
          __int128 v47 = *(_OWORD *)((char *)a3 + 44);
          __int128 v48 = v21;
          char v53 = 1;
        }

        *a4 = std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>>>::__emplace_hint_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,std::pair<boost::icl::discrete_interval<unsigned long long,std::less> const,std::optional<udif::details::block_info>>>( a1,  v15,  (uint64_t)&v41,  (uint64_t)&v41);
      }

      __int128 v31 = v39;
      uint64_t v32 = v40;
      boost::icl::left_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)&v31,  (uint64_t)&v37,  (uint64_t)&v41);
      __int128 v39 = v41;
      LOBYTE(v40) = v42;
      uint64_t v15 = *a4;
      unsigned int v22 = (uint64_t *)(*a4)[1];
      uint64_t v23 = *a4;
      if (v22)
      {
        do
        {
          uint64_t v13 = v22;
          unsigned int v22 = (uint64_t *)*v22;
        }

        while (v22);
      }

      else
      {
        do
        {
          uint64_t v13 = (uint64_t *)v23[2];
          BOOL v12 = *v13 == (void)v23;
          uint64_t v23 = v13;
        }

        while (!v12);
      }

      *a4 = v13;
    }

    while (v13 != v10);
  }

  __int128 v27 = v39;
  uint64_t v28 = v40;
  uint64_t result = boost::icl::left_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)&v27,  (uint64_t)&v35,  (uint64_t)&v29);
  if (!(_BYTE)v30)
  {
    unint64_t v25 = *((void *)&v29 + 1);
    unint64_t v26 = v29 + 1;
    goto LABEL_40;
  }

  if (v30 != 3)
  {
    unint64_t v25 = *((void *)&v29 + 1);
    unint64_t v26 = v29;
LABEL_40:
    if (v26 >= v25) {
      goto LABEL_44;
    }
    goto LABEL_41;
  }

BOOL std::operator==[abi:ne180100]<udif::details::block_info,udif::details::block_info>( uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 140)) {
    BOOL v2 = *(_BYTE *)(a2 + 140) == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return (*(_BYTE *)(a1 + 140) != 0) == (*(_BYTE *)(a2 + 140) != 0);
  }
  if (*(_DWORD *)a1 == *(_DWORD *)a2) {
    return udif::details::checksum::operator==((_DWORD *)(a1 + 4), (_DWORD *)(a2 + 4));
  }
  return 0LL;
}

uint64_t *std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>>>::__emplace_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,std::pair<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>> const&>( uint64_t **a1, uint64_t a2, uint64_t a3)
{
  __int128 v5 = (uint64_t **)std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  &v8,  a2);
  uint64_t result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>>>::__construct_node<std::pair<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>> const&>( (uint64_t)a1,  a3,  (uint64_t)&v7);
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  v8,  v5,  v7);
    return v7;
  }

  return result;
}

_OWORD *std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>>>::__construct_node<std::pair<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>> const&>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t result = operator new(0xC8uLL);
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v5;
  result[2] = *(_OWORD *)a2;
  *((void *)result + 6) = *(void *)(a2 + 16);
  *((_BYTE *)result + ++*(_DWORD *)(this + 56) = 0;
  *((_BYTE *)result + 196) = 0;
  if (*(_BYTE *)(a2 + 164))
  {
    *((void *)result + 7) = *(void *)(a2 + 24);
    *((_DWORD *)result + 16) = *(_DWORD *)(a2 + 32);
    *(_OWORD *)((char *)result + 132) = *(_OWORD *)(a2 + 100);
    *(_OWORD *)((char *)result + 148) = *(_OWORD *)(a2 + 116);
    *(_OWORD *)((char *)result + 164) = *(_OWORD *)(a2 + 132);
    *(_OWORD *)((char *)result + 180) = *(_OWORD *)(a2 + 148);
    *(_OWORD *)((char *)result + 68) = *(_OWORD *)(a2 + 36);
    *(_OWORD *)((char *)result + 84) = *(_OWORD *)(a2 + 52);
    *(_OWORD *)((char *)result + 100) = *(_OWORD *)(a2 + 68);
    *(_OWORD *)((char *)result + 116) = *(_OWORD *)(a2 + 84);
    *((_BYTE *)result + 196) = 1;
  }

  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

uint64_t *std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>>>::__emplace_hint_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,std::pair<boost::icl::discrete_interval<unsigned long long,std::less> const,std::optional<udif::details::block_info>>>( uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  __int128 v6 = (uint64_t **)std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( a1,  a2,  &v10,  &v9,  a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>>>>::__construct_node<std::pair<boost::icl::discrete_interval<unsigned long long,std::less>,std::optional<udif::details::block_info>> const&>( (uint64_t)a1,  a4,  (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  (uint64_t)v10,  v6,  v8);
    return v8;
  }

  return result;
}

uint64_t di_log::logger_buf<di_log::log_printer<458ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E5F28;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188131E5C(_Unwind_Exception *a1)
{
}

uint64_t **boost::icl::interval_base_map<boost::icl::interval_map<unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::_insert( uint64_t **a1, uint64_t a2)
{
  __int128 v14 = *(_OWORD *)a2;
  uint64_t v15 = *(void *)(a2 + 16);
  if ((_BYTE)v15)
  {
    if (v15 == 3)
    {
    }

    else if ((unint64_t)v14 >= *((void *)&v14 + 1))
    {
      return a1 + 1;
    }
  }

  else if ((unint64_t)v14 >= *((void *)&v14 + 1) || (unint64_t)(v14 + 1) >= *((void *)&v14 + 1))
  {
    return a1 + 1;
  }

  __int128 v5 = (int *)(a2 + 24);
  __int128 v7 = (uint64_t *)std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__emplace_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,std::pair<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info> const&>( a1,  a2,  a2);
  if ((v8 & 1) != 0)
  {
    int v17 = v7;
    boost::icl::segmental::join_left<boost::icl::interval_map<unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( a1,  &v17);
    return boost::icl::segmental::join_right<boost::icl::interval_map<unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( a1,  (uint64_t ***)&v17);
  }

  else
  {
    __int128 v9 = (uint64_t *)std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::lower_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  (uint64_t)&v14);
    __int128 v10 = (uint64_t **)std::__tree<boost::icl::discrete_interval<unsigned long long,std::less>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,std::allocator<boost::icl::discrete_interval<unsigned long long,std::less>>>::upper_bound[abi:ne180100]<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  (uint64_t)&v14);
    __int128 v11 = *v10;
    if (*v10)
    {
      do
      {
        BOOL v12 = v11;
        __int128 v11 = (uint64_t *)v11[1];
      }

      while (v11);
    }

    else
    {
      do
      {
        BOOL v12 = v10[2];
        BOOL v13 = *v12 == (void)v10;
        __int128 v10 = (uint64_t **)v12;
      }

      while (v13);
    }

    uint64_t v16 = v9;
    int v17 = v12;
    boost::icl::interval_base_map<boost::icl::interval_map<unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::insert_main( a1,  &v14,  v5,  &v16,  &v17);
    return (uint64_t **)v16;
  }

BOOL boost::icl::on_absorbtion<boost::icl::interval_base_map<boost::icl::interval_map<unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,boost::icl::inplace_plus<udif::details::run_info>,true>::is_absorbable( uint64_t a1)
{
  if ((v2 & 1) == 0
  {
    udif::run_type::run_type( (udif::run_type *)&boost::icl::identity_element<udif::details::run_info>::value(void)::_value,  2);
    qword_18C701970 = 0LL;
    qword_18C701978 = 0LL;
  }

  return *(_DWORD *)a1 == boost::icl::identity_element<udif::details::run_info>::value(void)::_value
      && *(void *)(a1 + 8) == qword_18C701970
      && *(void *)(a1 + 16) == qword_18C701978;
}

void sub_188132050(_Unwind_Exception *a1)
{
}

uint64_t boost::icl::interval_base_map<boost::icl::interval_map<unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>,unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>::insert_main( uint64_t **a1, __int128 *a2, int *a3, uint64_t **a4, uint64_t **a5)
{
  char v8 = *a5;
  __int128 v9 = (uint64_t *)(*a5)[1];
  if (v9)
  {
    do
    {
      __int128 v10 = v9;
      __int128 v9 = (uint64_t *)*v9;
    }

    while (v9);
  }

  else
  {
    __int128 v11 = *a5;
    do
    {
      __int128 v10 = (uint64_t *)v11[2];
      BOOL v12 = *v10 == (void)v11;
      __int128 v11 = v10;
    }

    while (!v12);
  }

  BOOL v13 = *a4;
  if (*a1 == *a4)
  {
    uint64_t v15 = (uint64_t *)(a1 + 1);
  }

  else
  {
    __int128 v14 = (uint64_t *)*v13;
    if (*v13)
    {
      do
      {
        uint64_t v15 = v14;
        __int128 v14 = (uint64_t *)v14[1];
      }

      while (v14);
    }

    else
    {
      uint64_t v16 = *a4;
      do
      {
        uint64_t v15 = (uint64_t *)v16[2];
        BOOL v12 = *v15 == (void)v16;
        uint64_t v16 = v15;
      }

      while (v12);
    }
  }

  __int128 v39 = *a2;
  uint64_t v40 = *((void *)a2 + 2);
  *(void *)&__int128 v37 = boost::icl::identity_element<unsigned long long>::value(void)::_value;
  *((void *)&v37 + udif::run_type::run_type((udif::run_type *)&v11, 1) = boost::icl::identity_element<unsigned long long>::value(void)::_value;
  char v38 = 2;
  __int128 v35 = *((_OWORD *)v8 + 2);
  uint64_t v36 = v8[6];
  if (v13 != v10)
  {
    int v17 = (__int128 *)(a3 + 2);
    while (1)
    {
      __int128 v37 = *((_OWORD *)v13 + 2);
      char v38 = *((_BYTE *)v13 + 48);
      __int128 v33 = v39;
      uint64_t v34 = v40;
      boost::icl::right_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)&v33,  (uint64_t)&v37,  (uint64_t)&v29);
      if ((_BYTE)v30) {
        break;
      }
LABEL_23:
      __int128 v27 = v39;
      uint64_t v28 = v40;
      boost::icl::left_subtract<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)&v27,  (uint64_t)&v37,  (uint64_t)&v29);
      __int128 v39 = v29;
      LOBYTE(v40) = v30;
      uint64_t v15 = *a4;
      __int128 v18 = (uint64_t *)(*a4)[1];
      __int128 v19 = *a4;
      if (v18)
      {
        do
        {
          BOOL v13 = v18;
          __int128 v18 = (uint64_t *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          BOOL v13 = (uint64_t *)v19[2];
          BOOL v12 = *v13 == (void)v19;
          __int128 v19 = v13;
        }

        while (!v12);
      }

      *a4 = v13;
      if (v13 == v10) {
        goto LABEL_32;
      }
    }

    if (v30 == 3)
    {
    }

    else if ((unint64_t)v29 >= *((void *)&v29 + 1))
    {
      goto LABEL_23;
    }

_OWORD *std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__emplace_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,std::pair<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info> const&>( uint64_t **a1, uint64_t a2, uint64_t a3)
{
  __int128 v5 = (void **)std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,boost::icl::exclusive_less_than<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  &v9,  a2);
  __int128 v6 = *v5;
  if (!*v5)
  {
    __int128 v7 = (uint64_t **)v5;
    __int128 v6 = operator new(0x50uLL);
    void v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *((_DWORD *)v6 + 14) = *(_DWORD *)(a3 + 24);
    void v6[4] = *(_OWORD *)(a3 + 32);
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  v9,  v7,  (uint64_t *)v6);
  }

  return v6;
}

uint64_t *boost::icl::segmental::join_left<boost::icl::interval_map<unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( uint64_t **a1, uint64_t **a2)
{
  unsigned __int8 v2 = *a2;
  if (*a2 == *a1) {
    return *a1;
  }
  uint64_t v4 = *v2;
  if (*v2)
  {
    do
    {
      uint64_t v5 = v4;
      uint64_t v4 = *(void *)(v4 + 8);
    }

    while (v4);
  }

  else
  {
    uint64_t v6 = (uint64_t)*a2;
    do
    {
      uint64_t v5 = *(void *)(v6 + 16);
      BOOL v7 = *(void *)v5 == v6;
      uint64_t v6 = v5;
    }

    while (v7);
  }

  uint64_t v8 = v2[4];
  if ((v2[6] & 2) == 0) {
    ++v8;
  }
  if (v8 == (*(_BYTE *)(v5 + 48) & 1) + *(void *)(v5 + 40)
    && *(_DWORD *)(v5 + 56) == *((_DWORD *)v2 + 14)
    && *(void *)(v5 + 64) == v2[8]
    && *(void *)(v5 + 72) == v2[9])
  {
    __int128 v14 = *((_OWORD *)v2 + 2);
    uint64_t v15 = v2[6];
    std::__tree<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>>>::__remove_node_pointer( a1,  v2);
    operator delete(v2);
    __int128 v10 = *(_OWORD *)(v5 + 32);
    uint64_t v11 = *(void *)(v5 + 48);
    boost::icl::hull<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)&v10,  (unint64_t *)&v14,  (uint64_t)&v12);
    *(_OWORD *)(v5 + 32) = v12;
    *(_BYTE *)(v5 + 48) = v13;
    *a2 = (uint64_t *)v5;
    return (uint64_t *)v5;
  }

  return v2;
}

uint64_t **boost::icl::segmental::join_right<boost::icl::interval_map<unsigned long long,udif::details::run_info,boost::icl::partial_absorber,std::less,boost::icl::inplace_plus,boost::icl::inter_section,boost::icl::discrete_interval<unsigned long long,std::less>,std::allocator>>( uint64_t **a1, uint64_t ***a2)
{
  int v3 = a1 + 1;
  uint64_t result = *a2;
  if (*a2 == v3) {
    return v3;
  }
  uint64_t v6 = result[1];
  if (v6)
  {
    do
    {
      BOOL v7 = (uint64_t **)v6;
      uint64_t v6 = (uint64_t *)*v6;
    }

    while (v6);
  }

  else
  {
    uint64_t v8 = *a2;
    do
    {
      BOOL v7 = (uint64_t **)v8[2];
      BOOL v9 = *v7 == (uint64_t *)v8;
      uint64_t v8 = v7;
    }

    while (!v9);
  }

  if (v7 != v3)
  {
    __int128 v10 = v7[4];
    if (((_BYTE)v7[6] & 2) == 0) {
      __int128 v10 = (uint64_t *)((char *)v10 + 1);
    }
    if (v10 == (uint64_t *)((char *)result[5] + ((_BYTE)result[6] & 1))
      && *((_DWORD *)result + 14) == *((_DWORD *)v7 + 14)
      && result[8] == v7[8]
      && result[9] == v7[9])
    {
      __int128 v17 = *((_OWORD *)v7 + 2);
      __int128 v18 = v7[6];
      std::__tree<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<_di_plugin_t>>>>::__remove_node_pointer( a1,  (uint64_t *)v7);
      operator delete(v7);
      uint64_t v11 = *a2;
      __int128 v13 = *((_OWORD *)*a2 + 2);
      __int128 v14 = v11[6];
      boost::icl::hull<boost::icl::discrete_interval<unsigned long long,std::less>>( (unint64_t *)&v13,  (unint64_t *)&v17,  (uint64_t)&v15);
      __int128 v12 = *a2;
      *((_OWORD *)v12 + 2) = v15;
      *((_BYTE *)v12 + 48) = v16;
      return *a2;
    }
  }

  return result;
}

uint64_t di_log::logger_buf<di_log::log_printer<500ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E6148;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881326B8(_Unwind_Exception *a1)
{
}

uint64_t std::map<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>::map[abi:ne180100]( uint64_t a1, unint64_t *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0LL;
  char v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 48 * a3;
    do
    {
      std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__emplace_hint_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,std::pair<boost::icl::discrete_interval<unsigned long long,std::less> const,udif::details::run_info> const&>( (uint64_t **)a1,  v4,  a2,  (uint64_t)a2);
      a2 += 6;
      v6 -= 48LL;
    }

    while (v6);
  }

  return a1;
}

void sub_188132734(_Unwind_Exception *a1)
{
}

_OWORD *std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__emplace_hint_unique_key_args<boost::icl::discrete_interval<unsigned long long,std::less>,std::pair<boost::icl::discrete_interval<unsigned long long,std::less> const,udif::details::run_info> const&>( uint64_t **a1, void *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v6 = std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( a1,  a2,  &v11,  &v10,  a3);
  BOOL v7 = (_OWORD *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    BOOL v7 = operator new(0x50uLL);
    unint64_t v7[2] = *(_OWORD *)a4;
    *((void *)v7 + 6) = *(void *)(a4 + 16);
    *((_DWORD *)v7 + 14) = *(_DWORD *)(a4 + 24);
    v7[4] = *(_OWORD *)(a4 + 32);
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  v11,  v8,  (uint64_t *)v7);
  }

  return v7;
}

uint64_t *std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,udif::details::run_info>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( void *a1, void *a2, void *a3, uint64_t *a4, unint64_t *a5)
{
  BOOL v9 = a1 + 1;
  if (a1 + 1 == a2
    || boost::icl::operator<<boost::icl::discrete_interval<unsigned long long,std::less>>(a5, a2 + 4))
  {
    if ((void *)*a1 == a2)
    {
      __int128 v12 = a2;
LABEL_16:
      if (*a2)
      {
        *a3 = v12;
        return v12 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    uint64_t v11 = (void *)*a2;
    if (*a2)
    {
      do
      {
        __int128 v12 = v11;
        uint64_t v11 = (void *)v11[1];
      }

      while (v11);
    }

    else
    {
      char v16 = a2;
      do
      {
        __int128 v12 = (void *)v16[2];
        BOOL v17 = *v12 == (void)v16;
        char v16 = v12;
      }

      while (v17);
    }

    return std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  a3,  a5);
  }

  if (boost::icl::operator<<boost::icl::discrete_interval<unsigned long long,std::less>>(a2 + 4, a5))
  {
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      __int128 v14 = (void *)a2[1];
      do
      {
        __int128 v15 = v14;
        __int128 v14 = (void *)*v14;
      }

      while (v14);
    }

    else
    {
      __int128 v18 = a2;
      do
      {
        __int128 v15 = (void *)v18[2];
        BOOL v17 = *v15 == (void)v18;
        __int128 v18 = v15;
      }

      while (!v17);
    }

    if (v15 != v9)
    {
      if (!boost::icl::operator<<boost::icl::discrete_interval<unsigned long long,std::less>>( a5,  v15 + 4)) {
        return std::__tree<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::__map_value_compare<boost::icl::discrete_interval<unsigned long long,std::less>,std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>,std::less<boost::icl::discrete_interval<unsigned long long,std::less>>,true>,std::allocator<std::__value_type<boost::icl::discrete_interval<unsigned long long,std::less>,ChecksumScheduler<checksum::Any<locks::None,checksum::None,checksum::CRC32>::bind_algos,details::udif_verify::scheduler_type,locks::Std>::wrapper>>>::__find_equal<boost::icl::discrete_interval<unsigned long long,std::less>>( (uint64_t)a1,  a3,  a5);
      }
      uint64_t v13 = *a4;
    }

    if (v13)
    {
      *a3 = v15;
      return v15;
    }

    else
    {
      *a3 = a2;
    }

    return a4;
  }

  *a3 = a2;
  *a4 = (uint64_t)a2;
  return a4;
}

void boost::container::vector<udif::run_io_info,boost::container::small_vector_allocator<udif::run_io_info,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<udif::run_io_info,boost::container::new_allocator<void>,void>,udif::run_io_info*,udif::run_io_info>>( uint64_t *a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = boost::container::vector_alloc_holder<boost::container::small_vector_allocator<udif::run_io_info,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( (uint64_t)a1,  a3);
  if (v11 >> 57) {
    boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v12);
  }
  uint64_t v13 = v11;
  __int128 v14 = operator new(v11 << 6);
  boost::container::vector<udif::run_io_info,boost::container::small_vector_allocator<udif::run_io_info,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<udif::run_io_info,boost::container::new_allocator<void>,void>,udif::run_io_info*,udif::run_io_info>>( a1,  (uint64_t)v14,  v13,  a2,  (uint64_t)a3,  a4);
  *a5 = *a1 + a2 - v10;
}

unint64_t boost::container::vector_alloc_holder<boost::container::small_vector_allocator<udif::run_io_info,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( uint64_t a1, const char *a2)
{
  unint64_t v2 = 0x1FFFFFFFFFFFFFFLL;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = v4 >> 61;
  unint64_t v6 = 8 * v4;
  if (v5 > 4) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = v6 / 5;
  if (v5) {
    unint64_t v8 = v7;
  }
  BOOL v9 = &a2[v3];
  if (v8 < 0x1FFFFFFFFFFFFFFLL) {
    unint64_t v2 = v8;
  }
  else {
    return (unint64_t)v9;
  }
}

void boost::container::vector<udif::run_io_info,boost::container::small_vector_allocator<udif::run_io_info,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<udif::run_io_info,boost::container::new_allocator<void>,void>,udif::run_io_info*,udif::run_io_info>>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = (void *)*a1;
  uint64_t v11 = *a1 + (a1[1] << 6);
  uint64_t v12 = a2;
  if (*a1 != a4)
  {
    uint64_t v13 = (void *)*a1;
    uint64_t v12 = a2;
    do
    {
      *(_DWORD *)uint64_t v12 = *(_DWORD *)v13;
      __int128 v14 = *(_OWORD *)(v13 + 1);
      __int128 v15 = *(_OWORD *)(v13 + 3);
      __int128 v16 = *(_OWORD *)(v13 + 5);
      *(void *)(v12 + ++*(_DWORD *)(this + 56) = v13[7];
      *(_OWORD *)(v12 + 40) = v16;
      *(_OWORD *)(v12 + 24) = v15;
      *(_OWORD *)(v12 + 8) = v14;
      v12 += 64LL;
      v13 += 8;
    }

    while (v13 != (void *)a4);
  }

  *(_DWORD *)uint64_t v12 = *(_DWORD *)a6;
  __int128 v17 = *(_OWORD *)(a6 + 8);
  __int128 v18 = *(_OWORD *)(a6 + 24);
  __int128 v19 = *(_OWORD *)(a6 + 40);
  *(void *)(v12 + ++*(_DWORD *)(this + 56) = *(void *)(a6 + 56);
  *(_OWORD *)(v12 + 40) = v19;
  *(_OWORD *)(v12 + 24) = v18;
  *(_OWORD *)(v12 + 8) = v17;
  if (v11 != a4)
  {
    uint64_t v20 = v12 + (a5 << 6);
    do
    {
      *(_DWORD *)uint64_t v20 = *(_DWORD *)a4;
      __int128 v21 = *(_OWORD *)(a4 + 8);
      __int128 v22 = *(_OWORD *)(a4 + 24);
      __int128 v23 = *(_OWORD *)(a4 + 40);
      *(void *)(v20 + ++*(_DWORD *)(this + 56) = *(void *)(a4 + 56);
      *(_OWORD *)(v20 + 40) = v23;
      *(_OWORD *)(v20 + 24) = v22;
      *(_OWORD *)(v20 + 8) = v21;
      a4 += 64LL;
      v20 += 64LL;
    }

    while (a4 != v11);
  }

  if (v10)
  {
    uint64_t v24 = (void *)*a1;
    if (a1 + 3 != (void *)*a1) {
      operator delete(v24);
    }
  }

  uint64_t v25 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v25;
  a1[2] = a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<601ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E6368;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188132BFC(_Unwind_Exception *a1)
{
}

uint64_t checksum::operator<<(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  uint64_t v2 = *(unsigned int *)(a2 + 12);
  if ((_DWORD)v2 == -1) {
    std::__throw_bad_variant_access[abi:ne180100]();
  }
  __int128 v5 = &v4;
  return ((uint64_t (*)(uint64_t **, uint64_t))off_18A1E6B28[v2])(&v5, a2 + 4);
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne180100IONS1_9__variant15__value_visitorIZN8checksumlsERNS_13basic_ostreamIcNS_11char_traitsIcEEEERKNS8_3AnyIN5locks4NoneEJNS8_4NoneENS8_5CRC32EEEEEUlRKT_E_EEJRKNS0_6__baseILNS0_6_TraitE0EJNSH_ISG_EENSI_ISG_EEEEEEEEDcSM_DpT0_( void ***a1)
{
  return checksum::operator<<(**a1);
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IONS1_9__variant15__value_visitorIZN8checksumlsERNS_13basic_ostreamIcNS_11char_traitsIcEEEERKNS8_3AnyIN5locks4NoneEJNS8_4NoneENS8_5CRC32EEEEEUlRKT_E_EEJRKNS0_6__baseILNS0_6_TraitE0EJNSH_ISG_EENSI_ISG_EEEEEEEEDcSM_DpT0_( void ***a1, int *a2)
{
  return checksum::operator<<(**a1, a2);
}

void *checksum::operator<<(void *a1)
{
  uint64_t v1 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"none {", 6LL);
  uint64_t v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v1, (uint64_t)"[empty]", 7LL);
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)"}", 1LL);
}

void *checksum::operator<<(void *a1, int *a2)
{
  uint64_t v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"crc32 {", 7LL);
  int v6 = *a2;
  uint64_t v4 = print_buffer(v3, (uint64_t)&v6, 4LL);
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"}", 1LL);
}

uint64_t di_log::logger_buf<di_log::log_printer<603ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E6588;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188132D6C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<638ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E67A8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188132DE8(_Unwind_Exception *a1)
{
}

void *std::shared_ptr<__CFString const*>::shared_ptr[abi:ne180100]<__CFString const*,std::default_delete<__CFString const*[]>,void>( void *a1, uint64_t a2)
{
  *a1 = a2;
  char v4 = operator new(0x20uLL);
  *char v4 = off_18A1E6B48;
  v4[1] = 0LL;
  _OWORD v4[2] = 0LL;
  _OWORD v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_188132E40(void *a1)
{
  if (v1) {
    operator delete[](v1);
  }
  __cxa_rethrow();
}

void sub_188132E58(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<__CFString const* *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<__CFString const* *>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete[](v1);
  }
}

uint64_t std::__shared_ptr_pointer<__CFString const* *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

udif::run_type *udif::run_type::run_type(udif::run_type *this)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  *(_DWORD *)this = 0;
  v3[0] = xmmword_188181820;
  v3[1] = xmmword_188181830;
  _OWORD v3[2] = xmmword_188181840;
  unint64_t v4 = 0x8000000880000007LL;
  int v5 = -1;
  smart_enums::validators::value<unsigned int>((uint64_t)"run_type", 0, v3, 15LL);
  return this;
}

uint64_t di_log::logger_buf<di_log::log_printer<898ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E69C8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188132FE0(_Unwind_Exception *a1)
{
}

uint64_t sparse_bundles::mapped_blocks_t::mapped_blocks_t( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, off_t file_size_from, char a6)
{
  *(void *)a1 = a3;
  *(void *)(a1 + 8) = 0LL;
  uint64_t v10 = *a4;
  *a4 = 0LL;
  *(void *)(a1 + 16) = v10;
  *(_BYTE *)(a1 + 24) = 1;
  unint64_t v11 = *(void *)(a2 + 40);
  uint64_t v12 = operator new(0x50uLL);
  lock_free::bitmap_dynamically_allocated_t::bitmap_dynamically_allocated_t(v12, v11 >> 12, 0);
  uint64_t v13 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v12;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  if ((sparse_bundles::mapped_blocks_t::load_file((sparse_bundles::mapped_blocks_t *)a1) & 1) == 0)
  {
    if (!a6)
    {
      int v14 = (***(uint64_t (****)(void))(a2 + 8))(*(void *)(a2 + 8));
      sparse_bundles::band_to_filename(__p);
      file_size_from = FileLocal::get_file_size_from(v14, (uint64_t)__p);
      if (v17 < 0)
      {
        operator delete(__p[0]);
        if (!file_size_from) {
          return a1;
        }
        goto LABEL_7;
      }
    }

    if (file_size_from) {
LABEL_7:
    }
      sparse_bundles::mapped_blocks_t::map_range((lock_free::bitmap_t **)a1, 0LL, file_size_from);
  }

  return a1;
}

void sub_188133100( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  uint64_t v17 = *(void *)(v15 + 16);
  *(void *)(v15 + 16) = 0LL;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
  }
  uint64_t v18 = *(void *)(v15 + 8);
  *(void *)(v15 + 8) = 0LL;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sparse_bundles::mapped_blocks_t::load_file(sparse_bundles::mapped_blocks_t *this)
{
  unint64_t v2 = (unint64_t)(*(void *)(*((void *)this + 1) + 16LL) + 7LL) >> 3;
  uint64_t v3 = (*(uint64_t (**)(void))(**((void **)this + 2) + 40LL))(*((void *)this + 2));
  BOOL v4 = v3 == v2 || v3 == v2 + 16;
  uint64_t v5 = v4;
  if (v4)
  {
    unint64_t v6 = v3 - v2;
    uint64_t v7 = *(void *)(*((void *)this + 1) + 8LL);
    uint64_t v8 = *((void *)details::get_dummy_shared_ptr() + 1);
    *(void *)&__int128 v25 = v7;
    *((void *)&v25 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v8;
    if (v8)
    {
      BOOL v9 = (unint64_t *)(v8 + 8);
      do
        unint64_t v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }

    unint64_t v26 = v2;
    unint64_t v27 = v6;
    unint64_t v28 = v2;
    char v29 = 0;
    unsigned int v11 = (*(uint64_t (**)(void, __int128 *))(**((void **)this + 2) + 88LL))(*((void *)this + 2), &v25);
    if (v2 != v11)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v22);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"Failed reading ", 15LL);
      sparse_bundles::operator<<(v22);
      DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v22, v11);
    }

    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v20 = "sparse_bundles::mapped_blocks_t::load_file()";
      *((void *)&v20 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 42LL;
      int v21 = 2;
      di_log::logger<di_log::log_printer<89ul>>::logger(v22, &v20);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v23,  (uint64_t)"Found a valid file for ",  23LL);
      sparse_bundles::operator<<(&v23);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<89ul>>::~logger_buf((uint64_t)v22);
      MEMORY[0x1895BC2CC](v24);
    }

    *((_BYTE *)this + 24) = 0;
    uint64_t v12 = (std::__shared_weak_count *)*((void *)&v25 + 1);
    if (*((void *)&v25 + 1))
    {
      uint64_t v13 = (unint64_t *)(*((void *)&v25 + 1) + 8LL);
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }

  else if (v3)
  {
    *(void *)&__int128 v25 = "sparse_bundles::mapped_blocks_t::load_file()";
    *((void *)&v25 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 42LL;
    LODWORD(v26) = 16;
    di_log::logger<di_log::log_printer<93ul>>::logger(v22, &v25);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v23,  (uint64_t)"invalid file size for ",  22LL);
    sparse_bundles::operator<<(&v23);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v23, (uint64_t)", current is ", 13LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v23, (uint64_t)" while expected is ", 19LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v23, (uint64_t)", truncating", 12LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<93ul>>::~logger_buf((uint64_t)v22);
    MEMORY[0x1895BC2CC](v24);
    unsigned int v15 = (*(uint64_t (**)(void, void))(**((void **)this + 2) + 56LL))(*((void *)this + 2), 0LL);
    if (v15)
    {
      unsigned int v16 = v15;
      uint64_t v17 = __cxa_allocate_exception(0x40uLL);
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v22);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"Failed truncating ", 18LL);
      sparse_bundles::operator<<(v22);
      DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)v17, (uint64_t)v22, v16);
    }
  }

  else if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v25 = "sparse_bundles::mapped_blocks_t::load_file()";
    *((void *)&v25 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 42LL;
    LODWORD(v26) = 2;
    di_log::logger<di_log::log_printer<99ul>>::logger(v22, &v25);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v23, (uint64_t)"file of ", 8LL);
    sparse_bundles::operator<<(&v23);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v23,  (uint64_t)" was just created (truncated)",  29LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<99ul>>::~logger_buf((uint64_t)v22);
    MEMORY[0x1895BC2CC](v24);
  }

  return v5;
}

void sub_18813351C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sparse_bundles::mapped_blocks_t::map_range( lock_free::bitmap_t **this, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = a2 + a3 - 1;
  uint64_t result = DIDebugLogsEnabled();
  if ((_DWORD)result)
  {
    *(void *)&__int128 v10 = "sparse_bundles::mapped_blocks_t::map_range(uint64_t, uint64_t)";
    *((void *)&v10 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 42LL;
    int v11 = 2;
    di_log::logger<di_log::log_printer<150ul>>::logger(v12, &v10);
    sparse_bundles::operator<<(&v13);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v13, (uint64_t)" - map_range: [", 15LL);
    uint64_t v8 = v13;
    *(_DWORD *)((char *)&v13 + *(void *)(v13 - 24) + 8) |= 0x200u;
    *(_DWORD *)((char *)&v13 + *(void *)(v8 - 24) + 8) = *(_DWORD *)((_BYTE *)&v13 + *(void *)(v8 - 24) + 8) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v13, (uint64_t)"-", 1LL);
    std::ostream::operator<<();
    uint64_t v9 = v13;
    *(_DWORD *)((char *)&v13 + *(void *)(v13 - 24) + 8) &= ~0x200u;
    *(_DWORD *)((char *)&v13 + *(void *)(v9 - 24) + 8) = *(_DWORD *)((_BYTE *)&v13 + *(void *)(v9 - 24) + 8) & 0xFFFFFFB5 | 2;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v13, (uint64_t)"]", 1LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<150ul>>::~logger_buf((uint64_t)v12);
    uint64_t result = MEMORY[0x1895BC2CC](&v14);
  }

  if (a3)
  {
    uint64_t result = lock_free::bitmap_t::update_bits(this[1], a2 >> 12, v6 >> 12, 1LL);
    if ((_DWORD)result) {
      *((_BYTE *)this + 24) = 1;
    }
  }

  return result;
}

void sub_18813374C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sparse_bundles::mapped_blocks_t::open_mapped_file(void *a1@<X0>, int a2@<W2>, FileLocal **a3@<X8>)
{
  int v5 = (**(uint64_t (***)(void))*a1)(*a1);
  sparse_bundles::band_to_filename(__p);
  unint64_t v6 = (FileLocal *)operator new(0x458uLL);
  int v7 = FileDescriptorWrapper::open_from(v5, (uint64_t)__p, a2);
  FileLocal::FileLocal(v6, v7, (a2 & 3) != 0, 0);
  *a3 = v6;
  if (v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1881337FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sparse_bundles::mapped_blocks_t::mapped_blocks_t( uint64_t a1, uint64_t a2, uint64_t a3, off_t a4, char a5)
{
  __int128 v10 = v12;
  uint64_t v12 = 0LL;
  if (v10) {
    (*(void (**)(FileLocal *))(*(void *)v10 + 8LL))(v10);
  }
  return a1;
}

void sub_1881338B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sparse_bundles::mapped_blocks_t::mapped_blocks_t(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v7 = v9;
  char v9 = 0LL;
  if (v7) {
    (*(void (**)(FileLocal *))(*(void *)v7 + 8LL))(v7);
  }
  return a1;
}

void sub_18813395C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

void *di_log::logger<di_log::log_printer<89ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<89ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E6BB0;
  a1[45] = &unk_18A1E6CB0;
  a1[46] = &unk_18A1E6CD8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E6BB0;
  a1[45] = &unk_18A1E6C38;
  a1[46] = &unk_18A1E6C60;
  return a1;
}

void sub_188133A04(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<89ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<93ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<93ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E6DD0;
  a1[45] = &unk_18A1E6ED0;
  a1[46] = &unk_18A1E6EF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E6DD0;
  a1[45] = &unk_18A1E6E58;
  a1[46] = &unk_18A1E6E80;
  return a1;
}

void sub_188133AEC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<93ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<99ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<99ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E6FF0;
  a1[45] = &unk_18A1E70F0;
  a1[46] = &unk_18A1E7118;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E6FF0;
  a1[45] = &unk_18A1E7078;
  a1[46] = &unk_18A1E70A0;
  return a1;
}

void sub_188133BD4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<99ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t sparse_bundles::mapped_blocks_t::write(lock_free::bitmap_t **a1, uint64_t a2)
{
  return sparse_bundles::mapped_blocks_t::map_range(a1, *(void *)(a2 + 24), *(void *)(a2 + 16));
}

uint64_t sparse_bundles::mapped_blocks_t::flush(sparse_bundles::mapped_blocks_t *this)
{
  if ((*((_BYTE *)this + 24) & 1) != 0)
  {
    unint64_t v3 = *(void *)(*((void *)this + 1) + 16LL) + 7LL;
    if ((*(uint64_t (**)(void))(**((void **)this + 2) + 40LL))(*((void *)this + 2)) == v3 >> 3
      || (uint64_t v2 = (*(uint64_t (**)(void, void))(**((void **)this + 2) + 56LL))(*((void *)this + 2), 0LL),
          !(_DWORD)v2))
    {
      unint64_t v4 = v3 >> 3;
      *((_BYTE *)this + 24) = 0;
      uint64_t v5 = *((void *)this + 2);
      uint64_t v6 = *(void *)(*((void *)this + 1) + 8LL);
      int v7 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
      uint64_t v16 = v6;
      uint64_t v17 = v7;
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          unint64_t v9 = __ldxr(p_shared_owners);
        while (__stxr(v9 + 1, p_shared_owners));
      }

      unint64_t v18 = v4;
      uint64_t v19 = 0LL;
      unint64_t v20 = v4;
      char v21 = 0;
      uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v5 + 80LL))(v5, &v16);
      __int128 v10 = v17;
      if (v17)
      {
        int v11 = (unint64_t *)&v17->__shared_owners_;
        do
          unint64_t v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }

      if (v4 == (int)v2)
      {
        uint64_t v2 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 2) + 16LL))(*((void *)this + 2), 1LL);
        if ((_DWORD)v2) {
          *((_BYTE *)this + 24) = 1;
        }
        if (DIDebugLogsEnabled())
        {
          *(void *)&__int128 v14 = "sparse_bundles::mapped_blocks_t::flush()";
          *((void *)&v14 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 38LL;
          int v15 = 2;
          di_log::logger<di_log::log_printer<141ul>>::logger(&v16, &v14);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Flushed ", 8LL);
          sparse_bundles::operator<<(&v22);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)", res=", 6LL);
          std::ostream::operator<<();
          std::ostream::~ostream();
          di_log::logger_buf<di_log::log_printer<141ul>>::~logger_buf((uint64_t)&v16);
          MEMORY[0x1895BC2CC](v23);
        }
      }

      else
      {
        *((_BYTE *)this + 24) = 1;
      }
    }
  }

  else
  {
    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v14 = "sparse_bundles::mapped_blocks_t::flush()";
      *((void *)&v14 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 38LL;
      int v15 = 2;
      di_log::logger<di_log::log_printer<114ul>>::logger(&v16, &v14);
      sparse_bundles::operator<<(&v22);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v22,  (uint64_t)" is clean, skipping flush",  25LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<114ul>>::~logger_buf((uint64_t)&v16);
      MEMORY[0x1895BC2CC](v23);
    }

    return 0LL;
  }

  return v2;
}

void sub_188133EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<141ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<141ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E7210;
  a1[45] = &unk_18A1E7310;
  a1[46] = &unk_18A1E7338;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E7210;
  a1[45] = &unk_18A1E7298;
  a1[46] = &unk_18A1E72C0;
  return a1;
}

void sub_188133F58(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<141ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<150ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<150ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E7430;
  a1[45] = &unk_18A1E7530;
  a1[46] = &unk_18A1E7558;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E7430;
  a1[45] = &unk_18A1E74B8;
  a1[46] = &unk_18A1E74E0;
  return a1;
}

void sub_188134040(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<150ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t sparse_bundles::mapped_blocks_t::unmap_interval( lock_free::bitmap_t **this, unint64_t a2, unint64_t a3)
{
  uint64_t result = DIDebugLogsEnabled();
  if ((_DWORD)result)
  {
    *(void *)&__int128 v11 = "sparse_bundles::mapped_blocks_t::unmap_interval(uint64_t, uint64_t)";
    *((void *)&v11 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 47LL;
    int v12 = 2;
    di_log::logger<di_log::log_printer<166ul>>::logger(v13, &v11);
    sparse_bundles::operator<<(&v14);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v14, (uint64_t)" - unmap_range: [", 17LL);
    uint64_t v7 = v14;
    *(_DWORD *)((char *)&v14 + *(void *)(v14 - 24) + 8) |= 0x200u;
    *(_DWORD *)((char *)&v14 + *(void *)(v7 - 24) + 8) = *(_DWORD *)((_BYTE *)&v14 + *(void *)(v7 - 24) + 8) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v14, (uint64_t)"-", 1LL);
    std::ostream::operator<<();
    uint64_t v8 = v14;
    *(_DWORD *)((char *)&v14 + *(void *)(v14 - 24) + 8) &= ~0x200u;
    *(_DWORD *)((char *)&v14 + *(void *)(v8 - 24) + 8) = *(_DWORD *)((_BYTE *)&v14 + *(void *)(v8 - 24) + 8) & 0xFFFFFFB5 | 2;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v14, (uint64_t)"]", 1LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<166ul>>::~logger_buf((uint64_t)v13);
    uint64_t result = MEMORY[0x1895BC2CC](&v15);
  }

  if (a3 != a2)
  {
    unint64_t v9 = a2 >> 12;
    unint64_t v10 = a3 >> 12;
    if ((a2 & 0xFFF) != 0)
    {
      if (v9 == v10) {
        return result;
      }
      ++v9;
    }

    if ((~(_WORD)a3 & 0xFFF) != 0)
    {
      if (v9 == v10) {
        return result;
      }
      --v10;
    }

    uint64_t result = lock_free::bitmap_t::update_bits(this[1], v9, v10, 0LL);
    if ((_DWORD)result) {
      *((_BYTE *)this + 24) = 1;
    }
  }

  return result;
}

void sub_188134254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sparse_bundles::operator<<(void *a1)
{
  uint64_t v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( a1,  (uint64_t)"mapped blocks of band ",  22LL);
  *(_DWORD *)((char *)v2 + *(void *)(*v2 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v2 + *(void *)(*v2 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  unint64_t v3 = (void *)std::ostream::operator<<();
  *(_DWORD *)((char *)v3 + *(void *)(*v3 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v3 + *(void *)(*v3 - 24LL) + 8) & 0xFFFFFFB5 | 2;
  return a1;
}

{
  void *v1;
  void *result;
  uint64_t v1 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"band ", 5LL);
  *(_DWORD *)((char *)v1 + *(void *)(*v1 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v1 + *(void *)(*v1 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  uint64_t result = (void *)std::ostream::operator<<();
  *(_DWORD *)((char *)result + *(void *)(*result - 24LL) + 8) = *(_DWORD *)((_BYTE *)result
                                                                            + *(void *)(*result - 24LL)
                                                                            + 8) & 0xFFFFFFB5 | 2;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<89ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<89ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<89ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<89ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<89ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<89ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<89ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<89ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<89ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<89ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E6D48;
  di_log::logger_buf<di_log::log_printer<89ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<89ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<89ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188134670( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<89ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<89ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<89ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 89LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      unint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 89LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<93ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<93ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<93ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<93ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<93ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<93ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<93ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<93ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<93ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<93ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E6F68;
  di_log::logger_buf<di_log::log_printer<93ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<93ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<93ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188134C1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<93ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<93ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<93ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 93LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      unint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 93LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<99ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<99ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<99ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<99ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<99ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<99ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<99ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<99ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<99ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<99ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E7188;
  di_log::logger_buf<di_log::log_printer<99ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<99ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<99ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1881351C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<99ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<99ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<99ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 99LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      unint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 99LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<141ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<141ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<141ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<141ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<141ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<141ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<141ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<141ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<141ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<141ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E73A8;
  di_log::logger_buf<di_log::log_printer<141ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<141ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<141ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188135774( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<141ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<141ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<141ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 141LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      unint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 141LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<150ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<150ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<150ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<150ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<150ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<150ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<150ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<150ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<150ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<150ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E75C8;
  di_log::logger_buf<di_log::log_printer<150ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - atomic_store(0, (unsigned int *)(v1 + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<150ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<150ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188135D20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<150ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<150ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<150ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 150LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      unint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    __int128 v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 150LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t di_log::logger_buf<di_log::log_printer<89ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E6D48;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188135FAC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<93ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E6F68;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188136028(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<99ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E7188;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881360A4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<141ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E73A8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188136120(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<150ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E75C8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813619C(_Unwind_Exception *a1)
{
}

uint64_t sparse_bundles::Band::Band(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(void *)a1 = &off_18A1E7648;
  uint64_t v5 = a2[1];
  *(void *)(a1 + 16) = *a2;
  *(void *)(a1 + 24) = v5;
  if (v5)
  {
    char v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a4;
  *(_WORD *)(a1 + 68) = 0;
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + ++*(_DWORD *)(this + 56) = 0LL;
  *(void *)(a1 + 96) = 850045863LL;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0LL;
  uint64_t v8 = a4[4];
  *(void *)(a1 + 160) = a4[3];
  *(void *)(a1 + std::pair<udif::xml_rsrc_iterator,udif::xml_rsrc_iterator>::~pair(v8 - 168) = v8;
  if (v8)
  {
    unint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  __int128 v11 = (lock_free::bitmap_t *)a4[40];
  if (v11) {
    lock_free::bitmap_t::set_bit(v11, a3, 1);
  }
  return a1;
}

void sub_188136278(_Unwind_Exception *a1)
{
}

uint64_t sparse_bundles::Band::read(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v18 = "io_result_t sparse_bundles::Band::read(DiskImage::Context &, const sg_entry &)";
    *((void *)&v18 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 38LL;
    LODWORD(v19) = 2;
    di_log::logger<di_log::log_printer<47ul>>::logger(v23, &v18);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v24, (uint64_t)"Reading ", 8LL);
    operator<<(&v24);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v24, (uint64_t)" to ", 4LL);
    sparse_bundles::operator<<(&v24);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<47ul>>::~logger_buf((uint64_t)v23);
    MEMORY[0x1895BC2CC](v25);
  }

  unint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 40LL))(*(void *)(a2 + 16));
  unint64_t v6 = *(void *)(a3 + 24);
  if (v5 >= *(void *)(a3 + 16) + v6)
  {
    int v11 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 16) + 88LL))(*(void *)(a2 + 16), a3);
  }

  else if (v5 <= v6)
  {
    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v18 = "io_result_t sparse_bundles::Band::read(DiskImage::Context &, const sg_entry &)";
      *((void *)&v18 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 38LL;
      LODWORD(v19) = 2;
      di_log::logger<di_log::log_printer<63ul>>::logger(v23, &v18);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v24,  (uint64_t)"Band data doesn't exist, zeroing",  32LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<63ul>>::~logger_buf((uint64_t)v23);
      MEMORY[0x1895BC2CC](v25);
    }

    bzero(*(void **)a3, *(void *)(a3 + 16));
    int v11 = *(_DWORD *)(a3 + 16);
  }

  else
  {
    uint64_t v7 = *(void *)(a3 + 32);
    uint64_t v8 = *(void *)(a3 + 8);
    *(void *)&__int128 v18 = *(void *)a3;
    *((void *)&v18 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v8;
    if (v8)
    {
      unint64_t v9 = (unint64_t *)(v8 + 8);
      do
        unint64_t v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }

    uint64_t v19 = v5 - v6;
    unint64_t v20 = v6;
    uint64_t v21 = v7;
    char v22 = 0;
    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v16 = "io_result_t sparse_bundles::Band::read(DiskImage::Context &, const sg_entry &)";
      *((void *)&v16 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 38LL;
      int v17 = 2;
      di_log::logger<di_log::log_printer<56ul>>::logger(v23, &v16);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v24,  (uint64_t)"Band data is partial, reading ",  30LL);
      operator<<(&v24);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<56ul>>::~logger_buf((uint64_t)v23);
      MEMORY[0x1895BC2CC](v25);
    }

    int v11 = (*(uint64_t (**)(void, __int128 *))(**(void **)(a2 + 16) + 88LL))(*(void *)(a2 + 16), &v18);
    bzero((void *)(*(void *)a3 + v19), *(void *)(a3 + 16) - v19);
    os_log_type_t v12 = (std::__shared_weak_count *)*((void *)&v18 + 1);
    if (v19 == v11) {
      int v11 = *(_DWORD *)(a3 + 16);
    }
    if (*((void *)&v18 + 1))
    {
      uint64_t v13 = (unint64_t *)(*((void *)&v18 + 1) + 8LL);
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }

  if (v11 >= 0) {
    return *(void *)(a3 + 16);
  }
  else {
    return v11;
  }
}

void sub_188136554( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void *di_log::logger<di_log::log_printer<47ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<47ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E7778;
  a1[45] = &unk_18A1E7878;
  a1[46] = &unk_18A1E78A0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E7778;
  a1[45] = &unk_18A1E7800;
  a1[46] = &unk_18A1E7828;
  return a1;
}

void sub_188136620(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<47ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<56ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<56ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E7998;
  a1[45] = &unk_18A1E7A98;
  a1[46] = &unk_18A1E7AC0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E7998;
  a1[45] = &unk_18A1E7A20;
  a1[46] = &unk_18A1E7A48;
  return a1;
}

void sub_188136708(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<56ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<63ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<63ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E7BB8;
  a1[45] = &unk_18A1E7CB8;
  a1[46] = &unk_18A1E7CE0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E7BB8;
  a1[45] = &unk_18A1E7C40;
  a1[46] = &unk_18A1E7C68;
  return a1;
}

void sub_1881367F0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<63ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t sparse_bundles::Band::write(sparse_bundles::Band *a1, uint64_t a2, uint64_t a3)
{
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v8 = "io_result_t sparse_bundles::Band::write(DiskImage::Context &, const sg_entry &)";
    *((void *)&v8 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 39LL;
    int v9 = 2;
    di_log::logger<di_log::log_printer<74ul>>::logger(v10, &v8);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)"Writing ", 8LL);
    operator<<(&v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)" to ", 4LL);
    sparse_bundles::operator<<(&v11);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<74ul>>::~logger_buf((uint64_t)v10);
    MEMORY[0x1895BC2CC](&v12);
  }

  mapped_blocks = (lock_free::bitmap_t **)sparse_bundles::Band::get_mapped_blocks(a1);
  sparse_bundles::mapped_blocks_t::write(mapped_blocks, a3);
  LODWORD(result) = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 16) + 80LL))( *(void *)(a2 + 16),  a3);
  *((_BYTE *)a1 + 68) = 1;
  else {
    return (int)result;
  }
}

void sub_188136964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<74ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<74ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E7DD8;
  a1[45] = &unk_18A1E7ED8;
  a1[46] = &unk_18A1E7F00;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E7DD8;
  a1[45] = &unk_18A1E7E60;
  a1[46] = &unk_18A1E7E88;
  return a1;
}

void sub_1881369FC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<74ul>>::~logger(uint64_t a1)
{
  return a1;
}

unint64_t sparse_bundles::Band::get_mapped_blocks(sparse_bundles::Band *this)
{
  unint64_t result = atomic_load((unint64_t *)this + 6);
  if (!result)
  {
    unint64_t v6 = this;
    unint64_t v3 = atomic_load((unint64_t *)this + 7);
    if (v3 != -1LL)
    {
      v5[0] = &v6;
      uint64_t v7 = v5;
      std::__call_once( (unint64_t *)this + 7,  &v7,  (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<sparse_bundles::Band::get_mapped_blocks(void)::$_0 &&>>);
    }

    unint64_t result = atomic_load((unint64_t *)this + 6);
    if (!result)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v5);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( v5,  (uint64_t)"Failed opening mapped blocks file for ",  38LL);
      sparse_bundles::operator<<(v5);
      DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v5, *((_DWORD *)this + 16));
    }
  }

  return result;
}

void sub_188136B38(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL sparse_bundles::Band::unmap_extents(sparse_bundles::Band *a1, void *a2)
{
  mapped_blocks = (lock_free::bitmap_t **)sparse_bundles::Band::get_mapped_blocks(a1);
  unint64_t v6 = (void *)*a2;
  char v4 = a2 + 1;
  unint64_t v5 = v6;
  if (v6 != v4)
  {
    do
    {
      if ((v5[6] & 2) != 0) {
        unint64_t v7 = v5[4];
      }
      else {
        unint64_t v7 = v5[4] + 1LL;
      }
      sparse_bundles::mapped_blocks_t::unmap_interval(mapped_blocks, v7, (v5[6] & 1) + v5[5] - 1LL);
      __int128 v8 = (void *)v5[1];
      if (v8)
      {
        do
        {
          int v9 = v8;
          __int128 v8 = (void *)*v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          int v9 = (void *)v5[2];
          BOOL v10 = *v9 == (void)v5;
          unint64_t v5 = v9;
        }

        while (!v10);
      }

      unint64_t v5 = v9;
    }

    while (v9 != v4);
  }

  return lock_free::bitmap_t::is_reset(mapped_blocks[1]);
}

void *sparse_bundles::Band::new_band(unint64_t a1, uint64_t a2, int a3, void *a4)
{
  int v28 = a3;
  __int128 v27 = 0uLL;
  int v24 = (***(uint64_t (****)(void))(a2 + 8))(*(void *)(a2 + 8));
  sparse_bundles::band_to_filename(__p);
  std::allocate_shared[abi:ne180100]<FileLocal,std::allocator<FileLocal>,int,std::string,int &,void>( &v24,  (uint64_t)__p,  &v28,  &v25);
  if (v23 < 0) {
    operator delete(__p[0]);
  }
  if (*a4)
  {
    int v24 = 3;
    std::allocate_shared[abi:ne180100]<crypto_format_backend,std::allocator<crypto_format_backend>,std::shared_ptr<FileLocal> &,std::shared_ptr<crypto::format> const&,unsigned int,void>( &v25,  (uint64_t)a4,  &v24,  __p);
    __int128 v7 = *(_OWORD *)__p;
    __p[0] = 0LL;
    __p[1] = 0LL;
    __int128 v8 = (std::__shared_weak_count *)*((void *)&v27 + 1);
    __int128 v27 = v7;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        unint64_t v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    uint64_t v11 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      uint64_t v12 = (unint64_t *)((char *)__p[1] + 8);
      do
        unint64_t v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

  else
  {
    std::shared_ptr<DiskImage>::operator=[abi:ne180100](&v27, &v25);
  }

  unint64_t v14 = operator new(0xB0uLL);
  sparse_bundles::Band::Band((uint64_t)v14, &v27, a1, (void *)a2);
  uint64_t v15 = v26;
  if (v26)
  {
    __int128 v16 = (unint64_t *)&v26->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  __int128 v18 = (std::__shared_weak_count *)*((void *)&v27 + 1);
  if (*((void *)&v27 + 1))
  {
    uint64_t v19 = (unint64_t *)(*((void *)&v27 + 1) + 8LL);
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  return v14;
}

void sub_188136DCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18)
{
}

void sparse_bundles::Band::erase(sparse_bundles::Band *this, const sparse_bundles::bundle_commons_t *a2)
{
  if ((*(_BYTE *)(*(void *)this + 8LL) & 1) != 0)
  {
    *(void *)&__int128 __p = "void sparse_bundles::Band::erase(const bundle_commons_t &, uint64_t)";
    *((void *)&__p + udif::run_type::run_type((udif::run_type *)&v11, 1) = 32LL;
    int v12 = 0;
    di_log::logger<di_log::log_printer<116ul>>::logger(v14, &__p);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v15,  (uint64_t)"Skipping erase of band ",  23LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v15,  (uint64_t)", disk image is terminated",  26LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<116ul>>::~logger_buf((uint64_t)v14);
    MEMORY[0x1895BC2CC](v16);
    return;
  }

  sparse_bundles::band_to_filename(&__p);
  int v4 = (***((uint64_t (****)(void))this + 2))(*((void *)this + 2));
  int v5 = FileLocal::unlink_from(v4, (uint64_t *)&__p);
  if (v5)
  {
    if (v5 >= 0) {
      int v6 = v5;
    }
    else {
      int v6 = -v5;
    }
    if (v6 != 2)
    {
      *(void *)&__int128 v9 = "void sparse_bundles::Band::erase(const bundle_commons_t &, uint64_t)";
      *((void *)&v9 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 32LL;
      int v10 = 16;
      di_log::logger<di_log::log_printer<126ul>>::logger(v14, &v9);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v15,  (uint64_t)"Failed to erase mapped file of band ",  36LL);
      *(_DWORD *)&v16[*(void *)(v15 - 24)] = *(_DWORD *)&v16[*(void *)(v15 - 24)] & 0xFFFFFFB5 | 8;
      std::ostream::operator<<();
      *(_DWORD *)&v16[*(void *)(v15 - 24)] = *(_DWORD *)&v16[*(void *)(v15 - 24)] & 0xFFFFFFB5 | 2;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v15, (uint64_t)", error ", 8LL);
      std::ostream::operator<<();
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<126ul>>::~logger_buf((uint64_t)v14);
      goto LABEL_11;
    }

    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v9 = "void sparse_bundles::Band::erase(const bundle_commons_t &, uint64_t)";
      *((void *)&v9 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 32LL;
      int v10 = 2;
      di_log::logger<di_log::log_printer<124ul>>::logger(v14, &v9);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v15,  (uint64_t)"No mapped file for band ",  24LL);
      *(_DWORD *)&v16[*(void *)(v15 - 24)] = *(_DWORD *)&v16[*(void *)(v15 - 24)] & 0xFFFFFFB5 | 8;
      std::ostream::operator<<();
      *(_DWORD *)&v16[*(void *)(v15 - 24)] = *(_DWORD *)&v16[*(void *)(v15 - 24)] & 0xFFFFFFB5 | 2;
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<124ul>>::~logger_buf((uint64_t)v14);
LABEL_11:
      MEMORY[0x1895BC2CC](v16);
    }
  }

  int v7 = (***((uint64_t (****)(void))this + 1))(*((void *)this + 1));
  if (FileLocal::unlink_from(v7, (uint64_t *)&__p))
  {
    *(void *)&__int128 v9 = "void sparse_bundles::Band::erase(const bundle_commons_t &, uint64_t)";
    *((void *)&v9 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 32LL;
    int v10 = 16;
    di_log::logger<di_log::log_printer<136ul>>::logger(v14, &v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v15,  (uint64_t)"Failed to erase band ",  21LL);
    *(_DWORD *)&v16[*(void *)(v15 - 24)] = *(_DWORD *)&v16[*(void *)(v15 - 24)] & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    *(_DWORD *)&v16[*(void *)(v15 - 24)] = *(_DWORD *)&v16[*(void *)(v15 - 24)] & 0xFFFFFFB5 | 2;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v15, (uint64_t)", error ", 8LL);
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<136ul>>::~logger_buf((uint64_t)v14);
    MEMORY[0x1895BC2CC](v16);
  }

  else
  {
    __int128 v8 = (lock_free::bitmap_t *)*((void *)this + 40);
    if (v8) {
      lock_free::bitmap_t::set_bit(v8, (unint64_t)a2, 0);
    }
  }

  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v9 = "void sparse_bundles::Band::erase(const bundle_commons_t &, uint64_t)";
    *((void *)&v9 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 32LL;
    int v10 = 2;
    di_log::logger<di_log::log_printer<139ul>>::logger(v14, &v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v15,  (uint64_t)"Completed erase of band ",  24LL);
    *(_DWORD *)&v16[*(void *)(v15 - 24)] = *(_DWORD *)&v16[*(void *)(v15 - 24)] & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    *(_DWORD *)&v16[*(void *)(v15 - 24)] = *(_DWORD *)&v16[*(void *)(v15 - 24)] & 0xFFFFFFB5 | 2;
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<139ul>>::~logger_buf((uint64_t)v14);
    MEMORY[0x1895BC2CC](v16);
  }

  if (v13 < 0) {
    operator delete((void *)__p);
  }
}

void sub_188137268( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *di_log::logger<di_log::log_printer<116ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<116ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E7FF8;
  a1[45] = &unk_18A1E80F8;
  a1[46] = &unk_18A1E8120;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E7FF8;
  a1[45] = &unk_18A1E8080;
  a1[46] = &unk_18A1E80A8;
  return a1;
}

void sub_188137368(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<116ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<126ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<126ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E8218;
  a1[45] = &unk_18A1E8318;
  a1[46] = &unk_18A1E8340;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E8218;
  a1[45] = &unk_18A1E82A0;
  a1[46] = &unk_18A1E82C8;
  return a1;
}

void sub_188137450(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<126ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<139ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<139ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E8438;
  a1[45] = &unk_18A1E8538;
  a1[46] = &unk_18A1E8560;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E8438;
  a1[45] = &unk_18A1E84C0;
  a1[46] = &unk_18A1E84E8;
  return a1;
}

void sub_188137538(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<139ul>>::~logger(uint64_t a1)
{
  return a1;
}

void sparse_bundles::Band::~Band(sparse_bundles::Band *this)
{
  *(void *)this = &off_18A1E7648;
  sparse_bundles::open_bands_t::mark_as_placed( (sparse_bundles::open_bands_t *)(*((void *)this + 5) + 184LL),  *((void *)this + 4),  0);
  sparse_bundles::Band::ContextsList::clear((uint64_t **)this + 9);
  uint64_t v2 = (sparse_bundles::mapped_blocks_t *)atomic_load((unint64_t *)this + 6);
  if (*((_BYTE *)this + 69))
  {
    if (!v2) {
      goto LABEL_18;
    }
    goto LABEL_13;
  }

  if (v2)
  {
    if ((*(_BYTE *)(**((void **)this + 5) + 8LL) & 1) != 0)
    {
      *(void *)&__int128 v5 = "sparse_bundles::Band::~Band()";
      *((void *)&v5 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 27LL;
      int v6 = 0;
      di_log::logger<di_log::log_printer<152ul>>::logger(v7, &v5);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v8,  (uint64_t)"Disk image is terminated, skipping flush of ",  44LL);
      sparse_bundles::operator<<(&v8);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v8, (uint64_t)", dirty=", 8LL);
      std::ostream::operator<<();
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<152ul>>::~logger_buf((uint64_t)v7);
      MEMORY[0x1895BC2CC](v9);
    }

    else
    {
      if (DIDebugLogsEnabled())
      {
        *(void *)&__int128 v5 = "sparse_bundles::Band::~Band()";
        *((void *)&v5 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 27LL;
        int v6 = 2;
        di_log::logger<di_log::log_printer<154ul>>::logger(v7, &v5);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v8,  (uint64_t)"flushing and closing ",  21LL);
        sparse_bundles::operator<<(&v8);
        std::ostream::~ostream();
        di_log::logger_buf<di_log::log_printer<154ul>>::~logger_buf((uint64_t)v7);
        MEMORY[0x1895BC2CC](v9);
      }

      sparse_bundles::mapped_blocks_t::flush(v2);
      if ((*((_BYTE *)this + 68) & 1) != 0) {
        (*(void (**)(void, uint64_t))(**((void **)this + 2) + 16LL))(*((void *)this + 2), 1LL);
      }
    }

{
  void *v1;
  sparse_bundles::Band::~Band(this);
  operator delete(v1);
}

void sparse_bundles::Band::create_ctx(sparse_bundles::Band *this@<X0>, __int128 *a2@<X8>)
{
  uint64_t v3 = (char *)this + 72;
  uint64_t v4 = (*(uint64_t (**)(sparse_bundles::Band *))(*(void *)this + 136LL))(this);
  std::shared_ptr<sparse_bundles::Band::ContextBand>::shared_ptr[abi:ne180100]<sparse_bundles::Band::ContextBand,void>( a2,  v4);
  sparse_bundles::Band::ContextsList::add((uint64_t)v3, a2);
}

void sub_1881378A4(_Unwind_Exception *a1)
{
}

void sparse_bundles::Band::ContextsList::add(uint64_t a1, __int128 *a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  std::vector<std::shared_ptr<char>>::emplace_back<std::shared_ptr<char> const&>((char **)a1, a2);
  std::mutex::unlock(v4);
}

void sub_1881378FC(_Unwind_Exception *a1)
{
}

uint64_t sparse_bundles::Band::flush(sparse_bundles::Band *this)
{
  if ((*((_BYTE *)this + 68) & 1) == 0) {
    return 0LL;
  }
  *((_BYTE *)this + 68) = 0;
  uint64_t v3 = (sparse_bundles::mapped_blocks_t *)atomic_load((unint64_t *)this + 6);
  uint64_t v1 = sparse_bundles::mapped_blocks_t::flush(v3);
  if ((_DWORD)v1
    || (uint64_t v1 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 2) + 16LL))(*((void *)this + 2), 1LL),
        (_DWORD)v1))
  {
    *((_BYTE *)this + 68) = 1;
    *(void *)&__int128 v5 = "sparse_bundles::Band::flush()";
    *((void *)&v5 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 27LL;
    int v6 = 16;
    di_log::logger<di_log::log_printer<203ul>>::logger(v7, &v5);
    sparse_bundles::operator<<(&v8);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v8, (uint64_t)": flush failed (", 16LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v8, (uint64_t)")", 1LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<203ul>>::~logger_buf((uint64_t)v7);
    MEMORY[0x1895BC2CC](&v9);
  }

  return v1;
}

void sub_188137A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<203ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<203ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E8658;
  a1[45] = &unk_18A1E8758;
  a1[46] = &unk_18A1E8780;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E8658;
  a1[45] = &unk_18A1E86E0;
  a1[46] = &unk_18A1E8708;
  return a1;
}

void sub_188137AB4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<203ul>>::~logger(uint64_t a1)
{
  return a1;
}

void sparse_bundles::band_ptr::release(unint64_t **this)
{
  uint64_t v1 = *this;
  if (*this)
  {
    do
    {
      unint64_t v3 = __ldaxr(v1);
      unint64_t v4 = v3 - 1;
    }

    while (__stlxr(v4, v1));
    if (!v4)
    {
      __int128 v5 = this[1];
      if (v5) {
        (*(void (**)(unint64_t *))(*v5 + 16))(v5);
      }
      if (*this) {
        operator delete(*this);
      }
    }
  }

void sparse_bundles::band_ptr::~band_ptr(unint64_t **this)
{
}

sparse_bundles::band_ptr *sparse_bundles::band_ptr::band_ptr( sparse_bundles::band_ptr *this, const sparse_bundles::band_ptr *a2)
{
  unint64_t v3 = *(unint64_t **)a2;
  *(void *)this = *(void *)a2;
  unint64_t v4 = atomic_load(v3);
  if (!v4)
  {
LABEL_7:
    int v6 = operator new(0x28uLL);
    uint64_t v7 = *(void *)(*(void *)this + 8LL);
    *int v6 = 1LL;
    v6[1] = v7;
    void v6[3] = 0LL;
    void v6[4] = 0LL;
    void v6[2] = 0LL;
    *(void *)this = v6;
    *((void *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0LL;
    uint64_t v8 = -1LL;
    goto LABEL_8;
  }

  while (1)
  {
    unint64_t v5 = __ldaxr(*(unint64_t **)this);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_6;
    }

LABEL_6:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_7;
    }
  }

  uint64_t v8 = *((void *)a2 + 2);
  *((void *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = *((void *)a2 + 1);
LABEL_8:
  *((void *)this + 2) = v8;
  return this;
}

  if ((_DWORD)v4)
  {
    *(void *)&__int128 v16 = "int FileLocal::flush(di_flush_mode)";
    *((void *)&v16 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 20LL;
    unint64_t v17 = 16;
    di_log::logger<di_log::log_printer<398ul>>::logger(v18, &v16);
    operator<<(&v19, a2);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v19, (uint64_t)" failed wih error ", 18LL);
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<398ul>>::~logger_buf((uint64_t)v18);
    MEMORY[0x1895BC2CC](v20);
  }

  return v4;
}

uint64_t sparse_bundles::band_ptr::band_ptr(uint64_t result, uint64_t a2)
{
  *(_OWORD *)unint64_t result = *(_OWORD *)a2;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  if (result != a2) {
    *(void *)a2 = 0LL;
  }
  return result;
}

unint64_t **sparse_bundles::band_ptr::operator=(unint64_t **this, unint64_t **a2)
{
  if (this != a2)
  {
    sparse_bundles::band_ptr::release(this);
    *(_OWORD *)this = *(_OWORD *)a2;
    this[2] = a2[2];
    *a2 = 0LL;
  }

  return this;
}

void *sparse_bundles::band_ptr::replace_if_evictable@<X0>( unint64_t **this@<X0>, sparse_bundles::Band *a2@<X1>, sparse_bundles::band_ptr *a3@<X8>)
{
  unint64_t v6 = atomic_load(*this);
  sparse_bundles::eviction_t::increase((unint64_t *)((*this)[1] + 56));
  if (v6 == 1)
  {
    do
    {
      unint64_t v7 = __ldaxr(*this);
      if (v7 == 1)
      {
        if (!__stlxr(0LL, *this))
        {
          int v10 = this[1];
          if (v10)
          {
            sparse_bundles::Band::ContextsList::clear((uint64_t **)v10 + 9);
            uint64_t v11 = this[1];
            int v12 = (dispatch_group_t *)((*this)[1] + 392);
            v17[0] = MEMORY[0x1895F87A8];
            v17[1] = 0x40000000LL;
            v17[2] = ___ZN14sparse_bundles8band_ptr20replace_if_evictableEPNS_4BandE_block_invoke;
            unint64_t v17[3] = &__block_descriptor_tmp_9;
            v17[4] = this;
            v17[5] = v11;
            workqueue::transaction::add(v12, v17);
          }

          else
          {
            sparse_bundles::eviction_t::decrease((sparse_bundles::eviction_t *)((*this)[1] + 56));
            if (DIDebugLogsEnabled())
            {
              *(void *)&__int128 v18 = "sparse_bundles::band_ptr::replace_if_evictable(Band *)";
              *((void *)&v18 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 46LL;
              int v19 = 2;
              di_log::logger<di_log::log_printer<347ul>>::logger(v20, &v18);
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v21,  (uint64_t)"Replaced an empty slot",  22LL);
              std::ostream::~ostream();
              di_log::logger_buf<di_log::log_printer<347ul>>::~logger_buf((uint64_t)v20);
              MEMORY[0x1895BC2CC](v22);
            }
          }

          this[1] = (unint64_t *)a2;
          if (a2)
          {
            this[2] = (unint64_t *)*((void *)a2 + 4);
            atomic_store(2uLL, *this);
            *((std::chrono::steady_clock::time_point *)*this + 2) = std::chrono::steady_clock::now();
            unint64_t result = sparse_bundles::band_ptr::band_ptr(a3, (const sparse_bundles::band_ptr *)this);
            char v13 = *this;
            do
              unint64_t v14 = __ldaxr(v13);
            while (__stlxr(v14 - 1, v13));
          }

          else
          {
            this[2] = (unint64_t *)-1LL;
            uint64_t v15 = *this;
            unint64_t v16 = v15[1];
            unint64_t result = operator new(0x28uLL);
            void *result = 1LL;
            result[1] = v16;
            result[3] = 0LL;
            result[4] = 0LL;
            result[2] = 0LL;
            *(void *)a3 = result;
            *((void *)a3 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0LL;
            *((void *)a3 + 2) = -1LL;
            atomic_store(1uLL, v15);
          }

          return result;
        }
      }

      else
      {
        __clrex();
      }
    }

    while (v7 == 1);
  }

  sparse_bundles::eviction_t::decrease((sparse_bundles::eviction_t *)((*this)[1] + 56));
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v18 = "sparse_bundles::band_ptr::replace_if_evictable(Band *)";
    *((void *)&v18 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 46LL;
    int v19 = 2;
    di_log::logger<di_log::log_printer<331ul>>::logger(v20, &v18);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v21,  (uint64_t)"Missed an evictable slot",  24LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<331ul>>::~logger_buf((uint64_t)v20);
    MEMORY[0x1895BC2CC](v22);
  }

  unint64_t v8 = (*this)[1];
  unint64_t result = operator new(0x28uLL);
  void *result = 1LL;
  result[1] = v8;
  result[3] = 0LL;
  result[4] = 0LL;
  result[2] = 0LL;
  *(void *)a3 = result;
  *((void *)a3 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0LL;
  *((void *)a3 + 2) = -1LL;
  return result;
}

void *di_log::logger<di_log::log_printer<331ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<331ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E8878;
  a1[45] = &unk_18A1E8978;
  a1[46] = &unk_18A1E89A0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E8878;
  a1[45] = &unk_18A1E8900;
  a1[46] = &unk_18A1E8928;
  return a1;
}

void sub_188138038(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<331ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t ___ZN14sparse_bundles8band_ptr20replace_if_evictableEPNS_4BandE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v5 = "sparse_bundles::band_ptr::replace_if_evictable(Band *)_block_invoke";
    *((void *)&v5 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 46LL;
    int v6 = 2;
    di_log::logger<di_log::log_printer<340ul>>::logger(v7, &v5);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v8, (uint64_t)"Background close of ", 20LL);
    sparse_bundles::operator<<(&v8);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<340ul>>::~logger_buf((uint64_t)v7);
    MEMORY[0x1895BC2CC](v9);
  }

  uint64_t v3 = *(void *)(a1 + 40);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 16LL))(v3);
  }
  sparse_bundles::eviction_t::decrease((sparse_bundles::eviction_t *)(*(void *)(*(void *)v2 + 8LL) + 56LL));
  uint64_t result = DIDebugLogsEnabled();
  if ((_DWORD)result)
  {
    *(void *)&__int128 v5 = "sparse_bundles::band_ptr::replace_if_evictable(Band *)_block_invoke";
    *((void *)&v5 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 46LL;
    int v6 = 2;
    di_log::logger<di_log::log_printer<343ul>>::logger(v7, &v5);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v8, (uint64_t)"Close completed", 15LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<343ul>>::~logger_buf((uint64_t)v7);
    return MEMORY[0x1895BC2CC](v9);
  }

  return result;
}

void sub_1881381D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<340ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<340ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E8A98;
  a1[45] = &unk_18A1E8B98;
  a1[46] = &unk_18A1E8BC0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E8A98;
  a1[45] = &unk_18A1E8B20;
  a1[46] = &unk_18A1E8B48;
  return a1;
}

void sub_188138278(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<340ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<343ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<343ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E8CB8;
  a1[45] = &unk_18A1E8DB8;
  a1[46] = &unk_18A1E8DE0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E8CB8;
  a1[45] = &unk_18A1E8D40;
  a1[46] = &unk_18A1E8D68;
  return a1;
}

void sub_188138360(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<343ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<347ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<347ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E8ED8;
  a1[45] = &unk_18A1E8FD8;
  a1[46] = &unk_18A1E9000;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E8ED8;
  a1[45] = &unk_18A1E8F60;
  a1[46] = &unk_18A1E8F88;
  return a1;
}

void sub_188138448(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<347ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t sparse_bundles::band_ptr::erase_if_unmapped(sparse_bundles::band_ptr *this, uint64_t a2)
{
  unint64_t v4 = atomic_load(*(unint64_t **)this);
  while (v4 == 1)
  {
    unint64_t v4 = __ldaxr(*(unint64_t **)this);
    if (v4 == 1)
    {
      if (!__stlxr(0LL, *(unint64_t **)this))
      {
        unint64_t mapped_blocks = sparse_bundles::Band::get_mapped_blocks(*((sparse_bundles::Band **)this + 1));
        if (lock_free::bitmap_t::is_reset(*(lock_free::bitmap_t **)(mapped_blocks + 8)))
        {
          sparse_bundles::Band::ContextsList::clear((uint64_t **)(*((void *)this + 1) + 72LL));
          uint64_t v6 = *((void *)this + 1);
          unint64_t v7 = (dispatch_group_t *)(*(void *)(*(void *)this + 8LL) + 392LL);
          v11[0] = MEMORY[0x1895F87A8];
          v11[1] = 0x40000000LL;
          void v11[2] = ___ZN14sparse_bundles8band_ptr17erase_if_unmappedEy_block_invoke;
          void v11[3] = &__block_descriptor_tmp_40;
          v11[4] = v6;
          workqueue::transaction::add(v7, v11);
          *((void *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0LL;
          *((void *)this + 2) = -1LL;
          uint64_t v8 = *(unint64_t **)this;
          uint64_t v9 = 1LL;
          atomic_store(1uLL, v8);
        }

        else
        {
          if (DIDebugLogsEnabled())
          {
            *(void *)&__int128 v14 = "sparse_bundles::band_ptr::erase_if_unmapped(uint64_t)";
            *((void *)&v14 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 43LL;
            int v15 = 2;
            di_log::logger<di_log::log_printer<399ul>>::logger(v16, &v14);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v17,  (uint64_t)"Skipping erase of ",  18LL);
            sparse_bundles::operator<<(&v17);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v17,  (uint64_t)", band was written to",  21LL);
            std::ostream::~ostream();
            di_log::logger_buf<di_log::log_printer<399ul>>::~logger_buf((uint64_t)v16);
            MEMORY[0x1895BC2CC](v18);
          }

          return 1LL;
        }

        return v9;
      }
    }

    else
    {
      __clrex();
    }
  }

  if (v4)
  {
    sparse_bundles::band_ptr::band_ptr((sparse_bundles::band_ptr *)&v14, this);
    if (*((void *)&v14 + 1) && *(void *)(*((void *)&v14 + 1) + 32LL) == a2)
    {
      if (DIDebugLogsEnabled())
      {
        *(void *)&__int128 v12 = "sparse_bundles::band_ptr::erase_if_unmapped(uint64_t)";
        *((void *)&v12 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 43LL;
        int v13 = 2;
        di_log::logger<di_log::log_printer<387ul>>::logger(v16, &v12);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v17,  (uint64_t)"Skipping band erase (in use)",  28LL);
        std::ostream::~ostream();
        di_log::logger_buf<di_log::log_printer<387ul>>::~logger_buf((uint64_t)v16);
        MEMORY[0x1895BC2CC](v18);
      }

      uint64_t v9 = 1LL;
    }

    else
    {
      if (DIDebugLogsEnabled())
      {
        *(void *)&__int128 v12 = "sparse_bundles::band_ptr::erase_if_unmapped(uint64_t)";
        *((void *)&v12 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 43LL;
        int v13 = 2;
        di_log::logger<di_log::log_printer<390ul>>::logger(v16, &v12);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v17,  (uint64_t)"Band was evicted by another thread (during retain attempt), retry erase process",  79LL);
        std::ostream::~ostream();
        di_log::logger_buf<di_log::log_printer<390ul>>::~logger_buf((uint64_t)v16);
        MEMORY[0x1895BC2CC](v18);
      }

      uint64_t v9 = 0LL;
    }

    sparse_bundles::band_ptr::release((unint64_t **)&v14);
  }

  else
  {
    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v14 = "sparse_bundles::band_ptr::erase_if_unmapped(uint64_t)";
      *((void *)&v14 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 43LL;
      int v15 = 2;
      di_log::logger<di_log::log_printer<382ul>>::logger(v16, &v14);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v17,  (uint64_t)"Band was evicted by another thread, retry erase process",  55LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<382ul>>::~logger_buf((uint64_t)v16);
      MEMORY[0x1895BC2CC](v18);
    }

    return 0LL;
  }

  return v9;
}

void *di_log::logger<di_log::log_printer<382ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<382ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E90F8;
  a1[45] = &unk_18A1E91F8;
  a1[46] = &unk_18A1E9220;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E90F8;
  a1[45] = &unk_18A1E9180;
  a1[46] = &unk_18A1E91A8;
  return a1;
}

void sub_18813883C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<382ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<399ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<399ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E9318;
  a1[45] = &unk_18A1E9418;
  a1[46] = &unk_18A1E9440;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E9318;
  a1[45] = &unk_18A1E93A0;
  a1[46] = &unk_18A1E93C8;
  return a1;
}

void sub_188138924(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<399ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t ___ZN14sparse_bundles8band_ptr17erase_if_unmappedEy_block_invoke(uint64_t a1)
{
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v4 = "sparse_bundles::band_ptr::erase_if_unmapped(uint64_t)_block_invoke";
    *((void *)&v4 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 43LL;
    int v5 = 2;
    di_log::logger<di_log::log_printer<406ul>>::logger(v6, &v4);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v7, (uint64_t)"Background erase of ", 20LL);
    sparse_bundles::operator<<(&v7);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<406ul>>::~logger_buf((uint64_t)v6);
    MEMORY[0x1895BC2CC](&v8);
  }

  uint64_t v2 = *(_BYTE **)(a1 + 32);
  v2[69] = 1;
  return (*(uint64_t (**)(_BYTE *))(*(void *)v2 + 16LL))(v2);
}

void sub_188138A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<406ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<406ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E9538;
  a1[45] = &unk_18A1E9638;
  a1[46] = &unk_18A1E9660;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E9538;
  a1[45] = &unk_18A1E95C0;
  a1[46] = &unk_18A1E95E8;
  return a1;
}

void sub_188138ADC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<406ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t sparse_bundles::Band::get_block_size(sparse_bundles::Band *this)
{
  return *(void *)(*((void *)this + 5) + 48LL);
}

uint64_t sparse_bundles::Band::get_num_blocks(sparse_bundles::Band *this)
{
  return *(void *)(*((void *)this + 5) + 40LL) / *(void *)(*((void *)this + 5) + 48LL);
}

uint64_t sparse_bundles::Band::is_writable(sparse_bundles::Band *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 48LL))(*((void *)this + 2));
}

void *sparse_bundles::Band::_create_ctx(sparse_bundles::Band *this)
{
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_18A1E9750;
  v2[1] = this;
  (*(void (**)(void))(**((void **)this + 2) + 72LL))(*((void *)this + 2));
  return v2;
}

void sub_188138BB8(_Unwind_Exception *a1)
{
}

void sparse_bundles::Band::ContextsList::~ContextsList(sparse_bundles::Band::ContextsList *this)
{
  uint64_t v2 = (void **)this;
  std::vector<std::shared_ptr<char>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void sparse_bundles::Band::ContextsList::clear(uint64_t **this)
{
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v10 = "sparse_bundles::Band::ContextsList::clear()";
    *((void *)&v10 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 41LL;
    int v11 = 2;
    di_log::logger<di_log::log_printer<92ul>>::logger(v12, &v10);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v13, (uint64_t)"Resetting ", 10LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v13, (uint64_t)" band contexts", 14LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<92ul>>::~logger_buf((uint64_t)v12);
    MEMORY[0x1895BC2CC](&v14);
  }

  uint64_t v2 = *this;
  uint64_t v3 = this[1];
  if (*this != v3)
  {
    __int128 v4 = (uint64_t *)(this + 11);
    do
    {
      uint64_t v5 = *v2;
      uint64_t v6 = (std::__shared_weak_count *)v2[1];
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          unint64_t v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
        std::shared_ptr<DiskImage>::operator=[abi:ne180100]((void *)(v5 + 16), v4);
        do
          unint64_t v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }

      else
      {
        std::shared_ptr<DiskImage>::operator=[abi:ne180100]((void *)(v5 + 16), v4);
      }

      v2 += 2;
    }

    while (v2 != v3);
  }

void sub_188138D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<47ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<47ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<47ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<47ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<47ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<47ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<47ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<47ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<47ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<47ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E7910;
  di_log::logger_buf<di_log::log_printer<47ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<47ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<47ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188139104( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<47ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<47ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<47ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 47LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 47LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<56ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<56ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<56ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<56ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<56ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<56ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<56ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<56ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<56ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<56ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E7B30;
  di_log::logger_buf<di_log::log_printer<56ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<56ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<56ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1881396B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<56ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<56ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<56ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 56LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 56LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<63ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<63ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<63ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<63ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<63ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<63ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<63ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<63ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<63ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<63ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E7D50;
  di_log::logger_buf<di_log::log_printer<63ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<63ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<63ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188139C5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<63ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<63ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<63ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 63LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 63LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<74ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<74ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<74ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<74ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<74ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<74ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<74ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<74ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<74ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<74ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E7F70;
  di_log::logger_buf<di_log::log_printer<74ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<74ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<74ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813A208( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<74ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<74ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<74ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 74LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 74LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<116ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<116ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<116ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<116ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<116ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<116ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<116ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<116ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<116ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<116ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E8190;
  di_log::logger_buf<di_log::log_printer<116ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<116ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<116ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813A7B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<116ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<116ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<116ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 116LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 116LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<126ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<126ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<126ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<126ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<126ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<126ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<126ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<126ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<126ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<126ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E83B0;
  di_log::logger_buf<di_log::log_printer<126ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<126ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<126ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813AD60( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<126ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<126ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<126ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 126LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 126LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<139ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<139ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<139ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<139ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<139ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<139ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<139ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<139ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<139ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<139ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E85D0;
  di_log::logger_buf<di_log::log_printer<139ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<139ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<139ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813B30C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<139ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<139ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<139ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 139LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 139LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<203ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<203ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<203ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<203ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<203ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<203ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<203ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<203ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<203ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<203ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E87F0;
  di_log::logger_buf<di_log::log_printer<203ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<203ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<203ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813B8B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<203ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<203ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<203ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 203LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 203LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<331ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<331ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<331ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<331ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<331ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<331ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<331ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<331ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<331ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<331ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E8A10;
  di_log::logger_buf<di_log::log_printer<331ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<331ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<331ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813BE64( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<331ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<331ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<331ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 331LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 331LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<340ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<340ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<340ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<340ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<340ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<340ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<340ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<340ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<340ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<340ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E8C30;
  di_log::logger_buf<di_log::log_printer<340ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<340ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<340ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813C410( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<340ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<340ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<340ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 340LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 340LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<343ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<343ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<343ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<343ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<343ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<343ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<343ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<343ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<343ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<343ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E8E50;
  di_log::logger_buf<di_log::log_printer<343ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<343ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<343ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813C9BC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<343ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<343ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<343ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 343LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 343LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<347ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<347ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<347ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<347ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<347ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<347ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<347ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<347ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<347ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<347ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E9070;
  di_log::logger_buf<di_log::log_printer<347ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<347ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<347ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813CF68( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<347ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<347ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<347ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 347LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 347LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<382ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<382ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<382ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<382ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<382ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<382ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<382ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<382ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<382ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<382ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E9290;
  di_log::logger_buf<di_log::log_printer<382ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<382ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<382ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813D514( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<382ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<382ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<382ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 382LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 382LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<399ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<399ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<399ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<399ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<399ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<399ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<399ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<399ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<399ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<399ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E94B0;
  di_log::logger_buf<di_log::log_printer<399ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<399ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<399ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813DAC0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<399ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<399ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<399ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 399LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 399LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<406ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<406ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<406ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<406ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<406ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<406ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<406ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<406ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<406ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<406ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E96D0;
  di_log::logger_buf<di_log::log_printer<406ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<406ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<406ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813E06C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<406ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<406ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<406ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 406LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      __int128 v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 406LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

void sparse_bundles::Band::ContextBand::~ContextBand(sparse_bundles::Band::ContextBand *this)
{
  *(void *)this = off_18A1E9750;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
}

{
  *(void *)this = off_18A1E9750;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
  operator delete(this);
}

uint64_t di_log::logger_buf<di_log::log_printer<47ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E7910;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813E358(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<56ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E7B30;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813E3D4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<63ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E7D50;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813E450(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<74ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E7F70;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813E4CC(_Unwind_Exception *a1)
{
}

void std::allocate_shared[abi:ne180100]<FileLocal,std::allocator<FileLocal>,int,std::string,int &,void>( int *a1@<X1>, uint64_t a2@<X2>, int *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x470uLL);
  std::__shared_ptr_emplace<FileLocal>::__shared_ptr_emplace[abi:ne180100]<int,std::string,int &,std::allocator<FileLocal>,0>( v8,  a1,  a2,  a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a4,  v8 + 4,  (uint64_t)(v8 + 3));
}

void sub_18813E544(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<FileLocal>::__shared_ptr_emplace[abi:ne180100]<int,std::string,int &,std::allocator<FileLocal>,0>( void *a1, int *a2, uint64_t a3, int *a4)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1CBC00;
  int v5 = *a4;
  int v6 = FileDescriptorWrapper::open_from(*a2, a3, *a4);
  FileLocal::FileLocal((FileLocal *)(a1 + 3), v6, (v5 & 3) != 0, 0);
  return a1;
}

void sub_18813E5B4(_Unwind_Exception *a1)
{
}

void std::allocate_shared[abi:ne180100]<crypto_format_backend,std::allocator<crypto_format_backend>,std::shared_ptr<FileLocal> &,std::shared_ptr<crypto::format> const&,unsigned int,void>( uint64_t *a1@<X1>, uint64_t a2@<X2>, int *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0xE0uLL);
  std::__shared_ptr_emplace<crypto_format_backend>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<FileLocal> &,std::shared_ptr<crypto::format> const&,unsigned int,std::allocator<crypto_format_backend>,0>( v8,  a1,  a2,  a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a4,  v8 + 4,  (uint64_t)(v8 + 3));
}

void sub_18813E62C(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<crypto_format_backend>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<FileLocal> &,std::shared_ptr<crypto::format> const&,unsigned int,std::allocator<crypto_format_backend>,0>( void *a1, uint64_t *a2, uint64_t a3, int *a4)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1CC2E8;
  std::construct_at[abi:ne180100]<crypto_format_backend,std::shared_ptr<FileLocal> &,std::shared_ptr<crypto::format> const&,unsigned int,crypto_format_backend*>( (uint64_t)(a1 + 3),  a2,  a3,  a4);
  return a1;
}

void sub_18813E674(_Unwind_Exception *a1)
{
}

uint64_t std::construct_at[abi:ne180100]<crypto_format_backend,std::shared_ptr<FileLocal> &,std::shared_ptr<crypto::format> const&,unsigned int,crypto_format_backend*>( uint64_t a1, uint64_t *a2, uint64_t a3, int *a4)
{
  int v6 = (std::__shared_weak_count *)a2[1];
  uint64_t v14 = *a2;
  int v15 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  crypto_format_backend::header_ignore_fields_t::header_ignore_fields_t(&v13, *a4);
  crypto_format_backend::crypto_format_backend(a1, &v14, a3, &v13);
  unint64_t v9 = v15;
  if (v15)
  {
    __int128 v10 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return a1;
}

void sub_18813E72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

_DWORD *crypto_format_backend::header_ignore_fields_t::header_ignore_fields_t(_DWORD *this, int a2)
{
  *this = a2;
  if ((a2 & 0xFFFFFFFC) != 0)
  {
    unsigned int v2 = a2 & 0xFFFFFFFC;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid flags";
    exception[3] = "flags validator";
    void *exception = off_18A1CA768;
    exception[1] = "header_ignore_fields_t";
    *((_DWORD *)exception + 8) = v2;
  }

  return this;
}

uint64_t di_log::logger_buf<di_log::log_printer<116ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E8190;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813E818(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<126ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E83B0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813E894(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<139ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E85D0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813E910(_Unwind_Exception *a1)
{
}

void *std::shared_ptr<sparse_bundles::Band::ContextBand>::shared_ptr[abi:ne180100]<sparse_bundles::Band::ContextBand,void>( void *a1, uint64_t a2)
{
  *a1 = a2;
  char v4 = operator new(0x20uLL);
  *char v4 = off_18A1E97A8;
  v4[1] = 0LL;
  _OWORD v4[2] = 0LL;
  _OWORD v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_18813E968(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 40LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<sparse_bundles::Band::ContextBand *,std::shared_ptr<sparse_bundles::Band::ContextBand>::__shared_ptr_default_delete<sparse_bundles::Band::ContextBand,sparse_bundles::Band::ContextBand>,std::allocator<sparse_bundles::Band::ContextBand>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<sparse_bundles::Band::ContextBand *,std::shared_ptr<sparse_bundles::Band::ContextBand>::__shared_ptr_default_delete<sparse_bundles::Band::ContextBand,sparse_bundles::Band::ContextBand>,std::allocator<sparse_bundles::Band::ContextBand>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40LL))(result);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<sparse_bundles::Band::ContextBand *,std::shared_ptr<sparse_bundles::Band::ContextBand>::__shared_ptr_default_delete<sparse_bundles::Band::ContextBand,sparse_bundles::Band::ContextBand>,std::allocator<sparse_bundles::Band::ContextBand>>::__get_deleter( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

uint64_t di_log::logger_buf<di_log::log_printer<203ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E87F0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813EA60(_Unwind_Exception *a1)
{
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<sparse_bundles::Band::get_mapped_blocks(void)::$_0 &&>>( uint64_t ***a1)
{
  uint64_t v1 = ***a1;
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v3 = "sparse_bundles::Band::get_mapped_blocks()::(anonymous class)::operator()() const";
    *((void *)&v3 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 72LL;
    LODWORD(v4) = 2;
    di_log::logger<di_log::log_printer<219ul>>::logger(v7, &v3);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v8,  (uint64_t)"Opening mapped blocks for ",  26LL);
    sparse_bundles::operator<<(&v8);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<219ul>>::~logger_buf((uint64_t)v7);
    MEMORY[0x1895BC2CC](&v9);
  }

  uint64_t v2 = *(void *)(v1 + 40);
  *(void *)&__int128 v3 = MEMORY[0x1895F87A8];
  *((void *)&v3 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0x40000000LL;
  char v4 = ___ZZN14sparse_bundles4Band17get_mapped_blocksEvENK3__0clEv_block_invoke;
  __int128 v5 = &__block_descriptor_tmp_107;
  uint64_t v6 = v1;
  sparse_bundles::bundle_commons_t::run_in_high_tier(v2, (uint64_t)&v3);
}

void *di_log::logger<di_log::log_printer<219ul>>::logger(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<219ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E9848;
  a1[45] = &unk_18A1E9948;
  a1[46] = &unk_18A1E9970;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E9848;
  a1[45] = &unk_18A1E98D0;
  a1[46] = &unk_18A1E98F8;
  return a1;
}

void sub_18813ECD0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<219ul>>::~logger(uint64_t a1)
{
  return a1;
}

void ___ZZN14sparse_bundles4Band17get_mapped_blocksEvENK3__0clEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  get_sink_backend((uint64_t)(v1 + 2), &v10);
  uint64_t v3 = v10;
  uint64_t v2 = v11;
  uint64_t v12 = v10;
  int v13 = v11;
  char v4 = operator new(0x20uLL);
  uint64_t v6 = v1[4];
  uint64_t v5 = v1[5];
  off_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40LL))(v3);
  sparse_bundles::mapped_blocks_t::mapped_blocks_t((uint64_t)v4, v5, v6, v7, 1);
  atomic_store((unint64_t)v4, v1 + 6);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

void sub_18813EDF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void *di_log::logger<di_log::log_printer<226ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<226ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E9A68;
  a1[45] = &unk_18A1E9B68;
  a1[46] = &unk_18A1E9B90;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E9A68;
  a1[45] = &unk_18A1E9AF0;
  a1[46] = &unk_18A1E9B18;
  return a1;
}

void sub_18813EE98(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<226ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t di_log::logger_buf<di_log::log_printer<219ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E99E0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813EF64(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<219ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E99E0;
  di_log::logger_buf<di_log::log_printer<219ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<219ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<219ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<219ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<219ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<219ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<219ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<219ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<219ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<219ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<219ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<219ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<219ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<219ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813F318( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<219ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 219LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 219LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t di_log::logger_buf<di_log::log_printer<226ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E9C00;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813F58C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<226ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E9C00;
  di_log::logger_buf<di_log::log_printer<226ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

void di_log::logger<di_log::log_printer<226ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<226ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<226ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<226ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<226ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<226ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<226ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<226ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<226ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger_buf<di_log::log_printer<226ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<226ul>>::~logger_buf(a1);
  operator delete(v1);
}

uint64_t di_log::logger_buf<di_log::log_printer<226ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    unsigned __int8 v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<226ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18813F940( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *di_log::log_printer<226ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 226LL;
    __int16 v22 = 2082;
    char v23 = v8;
    unint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 226LL;
      __int16 v22 = 2082;
      char v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  int *result = v5;
  return result;
}

uint64_t di_log::logger_buf<di_log::log_printer<331ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E8A10;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813FBB4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<340ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E8C30;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813FC30(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<343ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E8E50;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813FCAC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<347ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E9070;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813FD28(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<382ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E9290;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813FDA4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<399ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E94B0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813FE20(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<406ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E96D0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_18813FE9C(_Unwind_Exception *a1)
{
}

unint64_t *sparse_bundles::eviction_t::increase(unint64_t *this)
{
  do
    unint64_t v1 = __ldaxr(this);
  while (__stlxr(v1 + 1, this));
  return this;
}

void sparse_bundles::eviction_t::decrease(sparse_bundles::eviction_t *this)
{
  unsigned __int8 v2 = (std::mutex *)((char *)this + 8);
  std::mutex::lock((std::mutex *)((char *)this + 8));
  do
  {
    unint64_t v3 = __ldaxr((unint64_t *)this);
    unint64_t v4 = v3 - 1;
  }

  while (__stlxr(v4, (unint64_t *)this));
  if (!v4 && *((_BYTE *)this + 72))
  {
    *((_BYTE *)this + 72) = 0;
    std::condition_variable::notify_one((std::condition_variable *)((char *)this + 80));
  }

  std::mutex::unlock(v2);
}

uint64_t sparse_bundles::eviction_t::start_flush(uint64_t this)
{
  do
    unint64_t v1 = __ldaxr((unint64_t *)this);
  while (__stlxr(v1 + 1, (unint64_t *)this));
  *(_BYTE *)(this + 72) = 1;
  return this;
}

void sparse_bundles::eviction_t::complete_flush(sparse_bundles::eviction_t *this)
{
  v4.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 8);
  v4.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 8));
  do
  {
    unint64_t v2 = __ldaxr((unint64_t *)this);
    unint64_t v3 = v2 - 1;
  }

  while (__stlxr(v3, (unint64_t *)this));
  if (v3)
  {
    while (*((_BYTE *)this + 72))
      std::condition_variable::wait((std::condition_variable *)((char *)this + 80), &v4);
  }

  else
  {
    *((_BYTE *)this + 72) = 0;
  }

  if (v4.__owns_) {
    std::mutex::unlock(v4.__m_);
  }
}

uint64_t sparse_bundles::open_bands_t::insert(uint64_t **this, unint64_t a2)
{
  unint64_t v19 = a2;
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(this + 3);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)(this + 3));
  LOBYTE(v15[0]) = 0;
  std::__tree<std::__value_type<unsigned long long,BOOL>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,BOOL>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,BOOL>>>::__emplace_unique_key_args<unsigned long long,unsigned long long &,BOOL>( this,  &v19,  &v19,  v15);
  char v4 = v3;
  if ((v3 & 1) == 0)
  {
    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v13 = "sparse_bundles::open_bands_t::insert(uint64_t)";
      *((void *)&v13 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 36LL;
      int v14 = 2;
      di_log::logger<di_log::log_printer<72ul>>::logger(v15, &v13);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v16, (uint64_t)"Band ", 5LL);
      *(_DWORD *)&v17[*(void *)(v16 - 24)] = *(_DWORD *)&v17[*(void *)(v16 - 24)] & 0xFFFFFFB5 | 8;
      std::ostream::operator<<();
      *(_DWORD *)&v17[*(void *)(v16 - 24)] = *(_DWORD *)&v17[*(void *)(v16 - 24)] & 0xFFFFFFB5 | 2;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v16,  (uint64_t)" was opened in the background, waiting for it to become available",  65LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<72ul>>::~logger_buf((uint64_t)v15);
      MEMORY[0x1895BC2CC](v17);
    }

    uint64_t v7 = this[1];
    char v6 = (char *)(this + 1);
    __int128 v5 = v7;
    if (v7)
    {
      do
      {
        uint64_t v8 = v6;
        do
        {
          unint64_t v9 = v5[4];
          BOOL v10 = v9 >= v19;
          if (v9 >= v19) {
            unint64_t v11 = (uint64_t **)v5;
          }
          else {
            unint64_t v11 = (uint64_t **)(v5 + 1);
          }
          if (v10) {
            uint64_t v8 = (char *)v5;
          }
          __int128 v5 = *v11;
        }

        while (*v11);
        if (v8 == v6) {
          break;
        }
        if (v19 < *((void *)v8 + 4)) {
          break;
        }
        if (v8[40]) {
          break;
        }
        std::condition_variable::wait((std::condition_variable *)(v6 + 80), &__lk);
        __int128 v5 = *(uint64_t **)v6;
      }

      while (*(void *)v6);
    }

    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v13 = "sparse_bundles::open_bands_t::insert(uint64_t)";
      *((void *)&v13 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 36LL;
      int v14 = 2;
      di_log::logger<di_log::log_printer<79ul>>::logger(v15, &v13);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v16, (uint64_t)"Band ", 5LL);
      *(_DWORD *)&v17[*(void *)(v16 - 24)] = *(_DWORD *)&v17[*(void *)(v16 - 24)] & 0xFFFFFFB5 | 8;
      std::ostream::operator<<();
      *(_DWORD *)&v17[*(void *)(v16 - 24)] = *(_DWORD *)&v17[*(void *)(v16 - 24)] & 0xFFFFFFB5 | 2;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v16, (uint64_t)" is now available", 17LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<79ul>>::~logger_buf((uint64_t)v15);
      MEMORY[0x1895BC2CC](v17);
    }
  }

  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
  return v4 & 1;
}

void sub_188140228( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (*(_BYTE *)(v13 - 64)) {
    std::mutex::unlock(*(std::mutex **)(v13 - 72));
  }
  _Unwind_Resume(exception_object);
}

void *di_log::logger<di_log::log_printer<72ul>>::logger(void *a1, __int128 *a2)
{
  char v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<72ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E9CB0;
  a1[45] = &unk_18A1E9DB0;
  a1[46] = &unk_18A1E9DD8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E9CB0;
  a1[45] = &unk_18A1E9D38;
  a1[46] = &unk_18A1E9D60;
  return a1;
}

void sub_1881402F4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<72ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<79ul>>::logger(void *a1, __int128 *a2)
{
  char v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<79ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1E9ED0;
  a1[45] = &unk_18A1E9FD0;
  a1[46] = &unk_18A1E9FF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1E9ED0;
  a1[45] = &unk_18A1E9F58;
  a1[46] = &unk_18A1E9F80;
  return a1;
}

void sub_1881403DC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<79ul>>::~logger(uint64_t a1)
{
  return a1;
}

void sparse_bundles::open_bands_t::mark_as_placed( sparse_bundles::open_bands_t *this, unint64_t a2, int a3)
{
  char v6 = (std::mutex *)((char *)this + 24);
  std::mutex::lock((std::mutex *)((char *)this + 24));
  uint64_t v7 = (void *)*((void *)this + 1);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = (char *)this + 8;
  do
  {
    unint64_t v9 = v7[4];
    BOOL v10 = v9 >= a2;
    if (v9 >= a2) {
      unint64_t v11 = v7;
    }
    else {
      unint64_t v11 = v7 + 1;
    }
    if (v10) {
      uint64_t v8 = (char *)v7;
    }
    uint64_t v7 = (void *)*v11;
  }

  while (*v11);
  if (v8 == (char *)this + 8 || *((void *)v8 + 4) > a2) {
LABEL_12:
  }
    uint64_t v8 = (char *)this + 8;
  v8[40] = a3;
  if (a3) {
    std::condition_variable::notify_all((std::condition_variable *)((char *)this + 88));
  }
  std::mutex::unlock(v6);
}

void sparse_bundles::open_bands_t::remove(sparse_bundles::open_bands_t *this, unint64_t a2)
{
  unint64_t v9 = a2;
  char v3 = (std::mutex *)((char *)this + 24);
  std::mutex::lock((std::mutex *)((char *)this + 24));
  std::__tree<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ref::details::tagged_allocated_type<di_asif::details::table,unsigned long long> *>>>::__erase_unique<unsigned long long>( (uint64_t)this,  &v9);
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v4 = "sparse_bundles::open_bands_t::remove(uint64_t)";
    *((void *)&v4 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 36LL;
    int v5 = 2;
    di_log::logger<di_log::log_printer<98ul>>::logger(v6, &v4);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v7, (uint64_t)"Band ", 5LL);
    *(_DWORD *)((char *)&v7 + *(void *)(v7 - 24) + 8) = *(_DWORD *)((_BYTE *)&v7 + *(void *)(v7 - 24) + 8) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    *(_DWORD *)((char *)&v7 + *(void *)(v7 - 24) + 8) = *(_DWORD *)((_BYTE *)&v7 + *(void *)(v7 - 24) + 8) & 0xFFFFFFB5 | 2;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v7,  (uint64_t)" is closed, notifying waiters",  29LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<98ul>>::~logger_buf((uint64_t)v6);
    MEMORY[0x1895BC2CC](&v8);
  }

  std::condition_variable::notify_all((std::condition_variable *)((char *)this + 88));
  std::mutex::unlock(v3);
}

void sub_1881405F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

void *di_log::logger<di_log::log_printer<98ul>>::logger(void *a1, __int128 *a2)
{
  char v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<98ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EA0F0;
  a1[45] = &unk_18A1EA1F0;
  a1[46] = &unk_18A1EA218;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EA0F0;
  a1[45] = &unk_18A1EA178;
  a1[46] = &unk_18A1EA1A0;
  return a1;
}

void sub_1881406A4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<98ul>>::~logger(uint64_t a1)
{
  return a1;
}

sparse_bundles::bundle_commons_t *sparse_bundles::bundle_commons_t::bundle_commons_t( sparse_bundles::bundle_commons_t *this, DiskImageSparseBundle *a2)
{
  *(void *)this = a2;
  *((void *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0LL;
  *((void *)this + 2) = 0LL;
  int v9 = 0;
  std::allocate_shared[abi:ne180100]<BackendNull,std::allocator<BackendNull>,int,void>(&v9, __p);
  __int128 v3 = *(_OWORD *)__p;
  *((void *)this + 24) = 0LL;
  *(_OWORD *)((char *)this + 24) = v3;
  *((void *)this + 23) = (char *)this + 192;
  *((void *)this + 17) = 1018212795LL;
  *(_OWORD *)((char *)this + ++*(_DWORD *)(this + 56) = xmmword_188182690;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 113) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = 0LL;
  *((void *)this + 25) = 0LL;
  *((void *)this + 26) = 850045863LL;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v10 - 248) = 0u;
  *((void *)this + 33) = 0LL;
  *((void *)this + 34) = 1018212795LL;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  __int128 v4 = (system_properties *)std::string::basic_string[abi:ne180100]<0>(__p, "com.apple.diskimages.band_management");
  unsigned int logical_cpus = system_properties::get_logical_cpus(v4);
  workqueue::workqueue::workqueue((char *)this + 328, __p, logical_cpus);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  workqueue::workqueue::create_transaction( (sparse_bundles::bundle_commons_t *)((char *)this + 328),  0LL,  (uint64_t)this + 392);
  workqueue::workqueue::set_target_priority((uint64_t)this + 328, 3);
  return this;
}

void sub_188140830( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v21 = *(void *)(v14 + 320);
  *(void *)(v14 + 320) = 0LL;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
  }
  sparse_bundles::open_bands_t::~open_bands_t(v15);
  std::condition_variable::~condition_variable(v16);
  std::mutex::~mutex((std::mutex *)((char *)v15 - 120));
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](v14 + 24);
  uint64_t v22 = *(void *)(v14 + 16);
  *(void *)(v14 + 16) = 0LL;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 16LL))(v22);
  }
  uint64_t v23 = *v19;
  *unint64_t v19 = 0LL;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 16LL))(v23);
  }
  _Unwind_Resume(a1);
}

void sparse_bundles::open_bands_t::~open_bands_t(sparse_bundles::open_bands_t *this)
{
}

void sparse_bundles::bundle_commons_t::run_in_high_tier(uint64_t a1, uint64_t a2)
{
  v18[18] = *(dispatch_group_t *)MEMORY[0x1895F89C0];
  uint64_t v9 = 0LL;
  BOOL v10 = &v9;
  uint64_t v11 = 0x4802000000LL;
  os_log_type_t v12 = __Block_byref_object_copy__7;
  uint64_t v13 = __Block_byref_object_dispose__7;
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  __int128 __p = 0LL;
  int v17 = 0;
  workqueue::workqueue::create_transaction((workqueue::workqueue *)(a1 + 328), 0LL, (uint64_t)v18);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  _OWORD v8[2] = ___ZN14sparse_bundles16bundle_commons_t16run_in_high_tierEU13block_pointerFvvE_block_invoke;
  void v8[3] = &unk_18A1E9C78;
  v8[4] = a2;
  v8[5] = &v9;
  workqueue::transaction::add(v18, v8);
  workqueue::transaction::~transaction((workqueue::transaction *)v18);
  if (*((_DWORD *)v10 + 16))
  {
    exception = (char *)__cxa_allocate_exception(0x40uLL);
    __int128 v4 = v10;
    uint64_t v5 = *((unsigned int *)v10 + 16);
    *(void *)exception = off_18A1E43B0;
    char v6 = std::generic_category();
    *((void *)exception + udif::run_type::run_type((udif::run_type *)&v11, 1) = v5;
    *((void *)exception + 2) = v6;
    uint64_t v7 = v4[7];
    *(_OWORD *)(exception + 24) = *(_OWORD *)(v4 + 5);
    *((void *)exception + 5) = v7;
    v4[6] = 0LL;
    v4[7] = 0LL;
    v4[5] = 0LL;
    exception[48] = 1;
  }

  _Block_object_dispose(&v9, 8);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p);
  }
}

void sub_188140A98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, char a27)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + ++*(_DWORD *)(this + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 48) = 0LL;
  *(void *)(a2 + ++*(_DWORD *)(this + 56) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  return result;
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
}

uint64_t ___ZN14sparse_bundles16bundle_commons_t16run_in_high_tierEU13block_pointerFvvE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t sparse_bundles::band_to_filename@<X0>(void *a1@<X8>)
{
  *(_DWORD *)((char *)v5 + *(void *)(v4 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(_DWORD *)((_BYTE *)v5 + *(void *)(v4 - 24)) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v5, a1);
  uint64_t v4 = *MEMORY[0x189614738];
  *(void *)((char *)&v5[-1] + *(void *)(v4 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(MEMORY[0x189614738] + 24LL);
  v5[0] = MEMORY[0x189614750] + 16LL;
  if (v6 < 0) {
    operator delete((void *)v5[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1895BC2CC](&v7);
}

void sub_188140CB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<72ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<72ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<72ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<72ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<72ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<72ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<72ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<72ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<72ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<72ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1E9E48;
  di_log::logger_buf<di_log::log_printer<72ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<72ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<72ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188141054( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<72ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<72ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<72ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 72LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      BOOL v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 72LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<79ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<79ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<79ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<79ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<79ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<79ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<79ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<79ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<79ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<79ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EA068;
  di_log::logger_buf<di_log::log_printer<79ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<79ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<79ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188141600( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<79ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<79ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<79ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 79LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      BOOL v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 79LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<98ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<98ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<98ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<98ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<98ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<98ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<98ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<98ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<98ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<98ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EA288;
  di_log::logger_buf<di_log::log_printer<98ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<98ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<98ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188141BAC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<98ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<98ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<98ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 98LL;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      BOOL v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 98LL;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  int *result = v5;
  return result;
}

std::string *__cdecl std::string::__assign_external( std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  LODWORD(v6) = (char)this->__r_.__value_.__s.__size_;
  if ((v6 & 0x80000000) != 0)
  {
    std::string::size_type cap = this->__r_.__value_.__l.__cap_;
    unint64_t v9 = (cap & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }

    std::string::size_type v6 = HIBYTE(cap);
    uint64_t v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }

  else
  {
    uint64_t v7 = this;
    if (__n > 0x16)
    {
      std::string::size_type size = this->__r_.__value_.__s.__size_;
      unint64_t v9 = 22LL;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0LL, size, __n, __s);
      return this;
    }
  }

  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = this->__r_.__value_.__s.__size_;
  }

  if ((v6 & 0x80) != 0) {
    this->__r_.__value_.__l.__size_ = __n;
  }
  else {
    this->__r_.__value_.__s.__size_ = __n & 0x7F;
  }
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  size_t v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

uint64_t **std::__tree<std::__value_type<unsigned long long,BOOL>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,BOOL>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,BOOL>>>::__emplace_unique_key_args<unsigned long long,unsigned long long &,BOOL>( uint64_t **a1, unint64_t *a2, void *a3, _BYTE *a4)
{
  uint64_t v8 = a1 + 1;
  uint64_t v7 = a1[1];
  if (v7)
  {
    unint64_t v9 = *a2;
    while (1)
    {
      while (1)
      {
        BOOL v10 = (uint64_t **)v7;
        unint64_t v11 = v7[4];
        if (v9 >= v11) {
          break;
        }
        uint64_t v7 = *v10;
        uint64_t v8 = v10;
        if (!*v10) {
          goto LABEL_10;
        }
      }

      if (v11 >= v9) {
        break;
      }
      uint64_t v7 = v10[1];
      if (!v7)
      {
        uint64_t v8 = v10 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    BOOL v10 = a1 + 1;
LABEL_10:
    os_log_type_t v12 = operator new(0x30uLL);
    v12[4] = *a3;
    *((_BYTE *)v12 + 40) = *a4;
    std::__tree<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<_di_plugin_t * (*)(unsigned long long),unsigned long long>>>>::__insert_node_at( a1,  (uint64_t)v10,  v8,  v12);
    return (uint64_t **)v12;
  }

  return v10;
}

uint64_t di_log::logger_buf<di_log::log_printer<72ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1E9E48;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188141FEC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<79ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1EA068;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188142068(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<98ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1EA288;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881420E4(_Unwind_Exception *a1)
{
}

void std::allocate_shared[abi:ne180100]<BackendNull,std::allocator<BackendNull>,int,void>( int *a1@<X1>, void *a2@<X8>)
{
  char v4 = operator new(0x48uLL);
  std::__shared_ptr_emplace<BackendNull>::__shared_ptr_emplace[abi:ne180100]<int,std::allocator<BackendNull>,0>( (uint64_t)v4,  a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a2,  v4 + 4,  (uint64_t)(v4 + 3));
}

void sub_188142144(_Unwind_Exception *a1)
{
}

uint64_t std::__shared_ptr_emplace<BackendNull>::__shared_ptr_emplace[abi:ne180100]<int,std::allocator<BackendNull>,0>( uint64_t a1, int *a2)
{
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_18A1CBCA0;
  uint64_t v3 = *a2;
  uint64_t v4 = di_utils::random_uuid((di_utils *)a1);
  uint64_t v6 = v5;
  Backend::Backend((Backend *)(a1 + 24));
  *(void *)(a1 + 24) = off_18A1CBCF0;
  *(void *)(a1 + 48) = v3;
  *(void *)(a1 + ++*(_DWORD *)(this + 56) = v4;
  *(void *)(a1 + 64) = v6;
  return a1;
}

void sub_1881421BC(_Unwind_Exception *a1)
{
}

uint64_t AEA_backend::AEA_backend(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *uint64_t v6 = off_18A1EA308;
  uint64_t v7 = (uint64_t **)(v6 + 5);
  uint64_t v8 = *a2;
  unint64_t v9 = (std::__shared_weak_count *)a2[1];
  __int128 v27 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 176LL))(v8);
  uint64_t v14 = *a3;
  uint64_t v13 = (std::__shared_weak_count *)a3[1];
  if (v13)
  {
    uint64_t v15 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  int v17 = operator new(0x38uLL);
  v17[1] = 0LL;
  v17[2] = 0LL;
  *int v17 = off_18A1EA3E8;
  unint64_t v17[3] = 0LL;
  __int16 v18 = (char *)(v17 + 3);
  *((_DWORD *)v17 + 8) = v12;
  v17[5] = v14;
  void v17[6] = v13;
  if (v13)
  {
    uint64_t v19 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
    *(void *)(a1 + 40) = v18;
    *(void *)(a1 + 48) = v17;
    do
      unint64_t v21 = __ldaxr(v19);
    while (__stlxr(v21 - 1, v19));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  else
  {
    *(void *)(a1 + 40) = v18;
    *(void *)(a1 + 48) = v17;
  }

  if (v27)
  {
    __int16 v22 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

  *(void *)(a1 + ++*(_DWORD *)(this + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  uint64_t v24 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v24 = 850045863LL;
  *(_OWORD *)(v24 + 8) = 0u;
  *(_OWORD *)(v24 + 24) = 0u;
  *(_OWORD *)(v24 + 40) = 0u;
  *((void *)v24 + 7) = 0LL;
  std::shared_ptr<AEA_backend::shared_state_t>::shared_ptr[abi:ne180100]<AEA_backend::shared_state_t,void>( (void *)(a1 + 72),  (uint64_t)v24);
  AEA_backend::create_streams((AEA_backend *)a1, *(_DWORD *)(*(void *)(a1 + 40) + 8LL));
  uint64_t v25 = *v7;
  *uint64_t v25 = AEAwrapper::DecryptionStream::getRawSize(*(AEAContext **)(a1 + 56));
  return a1;
}

void sub_188142394( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void AEA_backend::create_streams(AEA_backend *this, int a2)
{
  uint64_t v4 = (std::mutex *)*((void *)this + 9);
  std::mutex::lock(v4);
  lseek(a2, 0LL, 0);
  AAByteStream v18 = AAFileStreamOpenWithFD(a2, 0);
  AEAwrapper::ByteStream::ByteStream(&v21, &v18);
  AEAwrapper::Context::Context((AEAwrapper::Context *)&v20, (AEAwrapper::ByteStream *)&v21);
  uint64_t v5 = *((void *)this + 5);
  uint64_t v6 = *(uint8_t **)(v5 + 16);
  uint64_t v7 = *(std::__shared_weak_count **)(v5 + 24);
  AAByteStream v18 = (AAByteStream)v6;
  uint64_t v19 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  AEAwrapper::Context::setSymmetricKey(&v20, v6, 0x20uLL);
  AEAwrapper::ByteStream::make_DecryptionRandomAccessInputStream( &v21,  &v20,  0xFFFFFFFFFFFFFFFFLL,  0x4000000000000000uLL,  1,  (uint64_t *)&v17);
  std::allocate_shared[abi:ne180100]<AEAwrapper::DecryptionStream,std::allocator<AEAwrapper::DecryptionStream>,AEAwrapper::ByteStream,AEAwrapper::Context,AEAwrapper::ByteStream,void>( &v21,  (uint64_t *)&v20,  &v17,  &v16);
  std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100]((uint64_t)this + 56, &v16);
  uint64_t v10 = (std::__shared_weak_count *)*((void *)&v16 + 1);
  if (*((void *)&v16 + 1))
  {
    unint64_t v11 = (unint64_t *)(*((void *)&v16 + 1) + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  AEAwrapper::ByteStream::~ByteStream(&v17);
  uint64_t v13 = v19;
  if (v19)
  {
    uint64_t v14 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  AEAwrapper::Context::~Context(&v20);
  AEAwrapper::ByteStream::~ByteStream(&v21);
  std::mutex::unlock(v4);
}

void sub_188142560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  AAByteStream v5 = va_arg(va1, AAByteStream);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  va_copy(va3, va2);
  AEAContext v10 = va_arg(va3, AEAContext);
  AEAwrapper::ByteStream::~ByteStream((AAByteStream *)va);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  AEAwrapper::Context::~Context((AEAContext *)va2);
  AEAwrapper::ByteStream::~ByteStream((AAByteStream *)va3);
  std::mutex::unlock(v3);
  _Unwind_Resume(a1);
}

uint64_t AEA_backend::AEA_backend(uint64_t a1, void *a2, void *a3)
{
  *AAByteStream v5 = off_18A1EA308;
  uint64_t v6 = a2[6];
  v5[5] = a2[5];
  v5[6] = v6;
  if (v6)
  {
    uint64_t v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  *(void *)(a1 + ++*(_DWORD *)(this + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  uint64_t v9 = a2[10];
  *(void *)(a1 + 72) = a2[9];
  *(void *)(a1 + 80) = v9;
  if (v9)
  {
    AEAContext v10 = (unint64_t *)(v9 + 8);
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  AEA_backend::create_streams((AEA_backend *)a1, *(_DWORD *)(*(void *)(a1 + 40) + 8LL));
  return a1;
}

void sub_188142668(_Unwind_Exception *a1)
{
}

double AEA_backend::construct_context_from_inner@<D0>(void *a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  double result = v5[0];
  *a3 = *(_OWORD *)v5;
  return result;
}

ssize_t AEA_backend::read(uint64_t a1, uint64_t a2)
{
  return AEAwrapper::DecryptionStream::pread( *(AAByteStream **)(a1 + 56),  *(void **)a2,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

uint64_t AEA_backend::get_size(AEA_backend *this)
{
  return **((void **)this + 5);
}

uint64_t AEA_backend::get_compressed_blk_size(AEAContext **this)
{
  return AEAwrapper::DecryptionStream::getCompressionBlockSize(this[7]);
}

void AEA_backend::~AEA_backend(AEA_backend *this)
{
  *(void *)this = off_18A1EA308;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 72);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 56);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 40);
  *(void *)this = off_18A1E5578;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

{
  std::__shared_weak_count *v2;
  *(void *)this = off_18A1EA308;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 72);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 56);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 40);
  *(void *)this = off_18A1E5578;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(this);
}

void *AEA_backend::name(uint64_t a1, void *a2)
{
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"AEA", 3LL);
}

void std::__shared_ptr_emplace<aea_format::AEA_format>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_18A1EA3E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<aea_format::AEA_format>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_18A1EA3E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<aea_format::AEA_format>::__on_zero_shared(uint64_t a1)
{
  return std::shared_ptr<char>::~shared_ptr[abi:ne180100](a1 + 40);
}

void *std::shared_ptr<AEA_backend::shared_state_t>::shared_ptr[abi:ne180100]<AEA_backend::shared_state_t,void>( void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = off_18A1EA438;
  v4[1] = 0LL;
  _OWORD v4[2] = 0LL;
  _OWORD v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_188142860(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::mutex::~mutex(v1);
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<AEA_backend::shared_state_t *,std::shared_ptr<AEA_backend::shared_state_t>::__shared_ptr_default_delete<AEA_backend::shared_state_t,AEA_backend::shared_state_t>,std::allocator<AEA_backend::shared_state_t>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<AEA_backend::shared_state_t *,std::shared_ptr<AEA_backend::shared_state_t>::__shared_ptr_default_delete<AEA_backend::shared_state_t,AEA_backend::shared_state_t>,std::allocator<AEA_backend::shared_state_t>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(std::mutex **)(a1 + 24);
  if (v1)
  {
    std::mutex::~mutex(v1);
    operator delete(v2);
  }

uint64_t std::__shared_ptr_pointer<AEA_backend::shared_state_t *,std::shared_ptr<AEA_backend::shared_state_t>::__shared_ptr_default_delete<AEA_backend::shared_state_t,AEA_backend::shared_state_t>,std::allocator<AEA_backend::shared_state_t>>::__get_deleter( uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *std::allocate_shared[abi:ne180100]<AEAwrapper::DecryptionStream,std::allocator<AEAwrapper::DecryptionStream>,AEAwrapper::ByteStream,AEAwrapper::Context,AEAwrapper::ByteStream,void>@<X0>( void *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X3>, void *a4@<X8>)
{
  unint64_t v8 = operator new(0x30uLL);
  double result = std::__shared_ptr_emplace<AEAwrapper::DecryptionStream>::__shared_ptr_emplace[abi:ne180100]<AEAwrapper::ByteStream,AEAwrapper::Context,AEAwrapper::ByteStream,std::allocator<AEAwrapper::DecryptionStream>,0>( v8,  a1,  a2,  a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_188142954(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<AEAwrapper::DecryptionStream>::__shared_ptr_emplace[abi:ne180100]<AEAwrapper::ByteStream,AEAwrapper::Context,AEAwrapper::ByteStream,std::allocator<AEAwrapper::DecryptionStream>,0>( void *a1, void *a2, uint64_t *a3, void *a4)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1EA4B0;
  AEAwrapper::DecryptionStream::DecryptionStream(a1 + 3, a2, a3, a4);
  return a1;
}

void sub_18814299C(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<AEAwrapper::DecryptionStream>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_18A1EA4B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AEAwrapper::DecryptionStream>::~__shared_ptr_emplace( std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_18A1EA4B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<AEAwrapper::DecryptionStream>::__on_zero_shared(AAByteStream *a1)
{
  uint64_t v2 = a1 + 3;
  AEAwrapper::ByteStream::~ByteStream(a1 + 5);
  AEAwrapper::Context::~Context(a1 + 4);
  AEAwrapper::ByteStream::~ByteStream(v2);
}

void std::allocate_shared[abi:ne180100]<AEA_backend,std::allocator<AEA_backend>,AEA_backend&,std::shared_ptr<Backend> const&,void>( void *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  std::__shared_ptr_emplace<AEA_backend>::__shared_ptr_emplace[abi:ne180100]<AEA_backend&,std::shared_ptr<Backend> const&,std::allocator<AEA_backend>,0>( v6,  a1,  a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a3,  v6 + 4,  (uint64_t)(v6 + 3));
}

void sub_188142A6C(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<AEA_backend>::__shared_ptr_emplace[abi:ne180100]<AEA_backend&,std::shared_ptr<Backend> const&,std::allocator<AEA_backend>,0>( void *a1, void *a2, void *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1CC388;
  AEA_backend::AEA_backend((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_188142AB4(_Unwind_Exception *a1)
{
}

void *operator<<(void *a1, int a2)
{
  if (a2 == 2)
  {
    uint64_t v2 = "full_fsync";
    uint64_t v3 = 10LL;
  }

  else if (a2 == 1)
  {
    uint64_t v2 = "fsync";
    uint64_t v3 = 5LL;
  }

  else if (a2)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"bad flush type (", 16LL);
    a1 = (void *)std::ostream::operator<<();
    uint64_t v2 = ")";
    uint64_t v3 = 1LL;
  }

  else
  {
    uint64_t v2 = "barrier";
    uint64_t v3 = 7LL;
  }

  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v2, v3);
}

void *operator<<(void *a1)
{
  uint64_t v2 = (char *)a1 + *(void *)(*a1 - 24LL);
  int v3 = *((_DWORD *)v2 + 2);
  *((_DWORD *)v2 + 2) = v3 & 0xFFFFFFB5 | 8;
  char v16 = 48;
  uint64_t v4 = std::operator<<[abi:ne180100]<std::char_traits<char>>(a1, &v16);
  uint64_t v5 = *v4;
  *(uint64_t *)((char *)v4 + *(void *)(*v4 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v4 + *(void *)(v5 - 24) + 8) |= 0x200u;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"sg: buffer = ", 13LL);
  uint64_t v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" [", 2LL);
  uint64_t v7 = (void *)std::ostream::operator<<();
  unint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"] ", 2LL);
  uint64_t v9 = *v8;
  *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24) + 8) = *(_DWORD *)((_BYTE *)v8 + *(void *)(*v8 - 24) + 8) & 0xFFFFFFB5 | 2;
  *(uint64_t *)((char *)v8 + *(void *)(v9 - 24) + 24) = 0LL;
  *(_DWORD *)((char *)v8 + *(void *)(v9 - 24) + 8) &= ~0x200u;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" std::string::size_type size = ", 8LL);
  AEAContext v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" buffer_std::string::size_type size = ", 15LL);
  unint64_t v11 = (void *)std::ostream::operator<<();
  *(_DWORD *)((char *)v11 + *(void *)(*v11 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v11 + *(void *)(*v11 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  char v15 = 48;
  unint64_t v12 = std::operator<<[abi:ne180100]<std::char_traits<char>>(v11, &v15);
  uint64_t v13 = *v12;
  *(uint64_t *)((char *)v12 + *(void *)(*v12 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v12 + *(void *)(v13 - 24) + 8) |= 0x200u;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" offset = ", 10LL);
  std::ostream::operator<<();
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 8) = v3;
  return a1;
}

void Backend::Backend(Backend *this)
{
  *((void *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0LL;
  *((void *)this + 2) = 0LL;
  *(void *)this = off_18A1EA500;
}

uint64_t operator<<(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 152LL))(a2, a1);
}

void get_sink_backend(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *(const void **)a1;
  if (v4
  {
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 8);
    _OWORD v20[2] = v5;
    AAByteStream v21 = v6;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }

    uint64_t v9 = (std::__shared_weak_count *)*((void *)v5 + 4);
    v20[0] = *((void *)v5 + 3);
    v20[1] = v9;
    if (v9)
    {
      AEAContext v10 = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }

    get_sink_backend(v20);
    if (v9)
    {
      unint64_t v12 = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }

    uint64_t v14 = v21;
    if (v21)
    {
      char v15 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }

  else
  {
    uint64_t v17 = *(void *)(a1 + 8);
    *a2 = *(void *)a1;
    a2[1] = v17;
    if (v17)
    {
      AAByteStream v18 = (unint64_t *)(v17 + 8);
      do
        unint64_t v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
    }
  }

void sub_188142E5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t replace_internal_backend(uint64_t a1, const void **a2, uint64_t *a3)
{
  uint64_t v4 = *(const void **)a1;
  if (v4 == *a2) {
    return 4294967274LL;
  }
  if (!v4) {
    return 4294967294LL;
  }
  if (!v7) {
    return 4294967294LL;
  }
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 8);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  unint64_t v11 = (const void *)*((void *)v7 + 3);
  unint64_t v12 = (std::__shared_weak_count *)*((void *)v7 + 4);
  int v28 = v11;
  char v29 = v12;
  if (v12)
  {
    unint64_t v13 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  if (v11 == *a2)
  {
    uint64_t v17 = *a3;
    uint64_t v16 = a3[1];
    if (v16)
    {
      AAByteStream v18 = (unint64_t *)(v16 + 8);
      do
        unint64_t v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
    }

    char v15 = (std::__shared_weak_count *)*((void *)v7 + 4);
    *((void *)v7 + 3) = v17;
    *((void *)v7 + 4) = v16;
    if (v15)
    {
      AEAContext v20 = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }

      char v15 = 0LL;
    }
  }

  else
  {
    char v15 = (std::__shared_weak_count *)replace_internal_backend(&v28, a2, a3);
  }

  __int16 v22 = v29;
  if (v29)
  {
    unint64_t v23 = (unint64_t *)&v29->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  if (v8)
  {
    uint64_t v25 = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  return (uint64_t)v15;
}

void sub_188143018(_Unwind_Exception *exception_object)
{
  if (v2) {
    replace_internal_backend(v2);
  }
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

  _Unwind_Resume(exception_object);
}

void get_next_backend_in_graph(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *(const void **)a1;
  if (*(void *)a1
  {
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 8);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }

    uint64_t v9 = v5[4];
    *a2 = v5[3];
    a2[1] = v9;
    if (v9)
    {
      unint64_t v10 = (unint64_t *)(v9 + 8);
      do
        unint64_t v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }

    if (v6)
    {
      unint64_t v12 = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

  else
  {
    uint64_t v14 = *(void *)(a1 + 8);
    *a2 = v4;
    a2[1] = v14;
    if (v14)
    {
      char v15 = (unint64_t *)(v14 + 8);
      do
        unint64_t v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
  }

uint64_t BackendSG::BackendSG(uint64_t a1, void *a2, uint64_t a3, unint64_t a4, char a5)
{
  unint64_t v12 = a4;
  uint64_t v13 = a3;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_18A1E5578;
  *(void *)(a1 + 24) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 32) = v7;
  if (v7)
  {
    unint64_t v8 = (unint64_t *)(v7 + 8);
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  *(void *)a1 = off_18A1EA5C0;
  *(void *)(a1 + 40) = a3;
  unsigned int v11 = 0;
  std::allocate_shared[abi:ne180100]<BufferAllocator,std::allocator<BufferAllocator>,unsigned long &,int,unsigned long &,void>( &v13,  &v11,  &v12,  (void *)(a1 + 48));
  *(_OWORD *)(a1 + 89) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_BYTE *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v50 + 112) = a5;
  return a1;
}

void sub_1881431F4(_Unwind_Exception *a1)
{
}

uint64_t BackendSG::write(uint64_t a1, uint64_t a2)
{
  if ((void)v22)
  {
    memcpy((void *)v22, *(const void **)a2, *(void *)(a2 + 16));
    __int128 v4 = *(_OWORD *)(a2 + 16);
    uint64_t v5 = *(void *)(a1 + 40);
    __int128 v18 = v22;
    if (*((void *)&v22 + 1))
    {
      uint64_t v6 = (unint64_t *)(*((void *)&v22 + 1) + 8LL);
      do
        unint64_t v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }

    *(_OWORD *)unint64_t v19 = v4;
    *(void *)&v19[16] = v5;
    v19[24] = 0;
    std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100](a1 + 64, &v18);
    *(_OWORD *)(a1 + 80) = *(_OWORD *)v19;
    *(_OWORD *)(a1 + 89) = *(_OWORD *)&v19[9];
    unint64_t v8 = (std::__shared_weak_count *)*((void *)&v18 + 1);
    if (*((void *)&v18 + 1))
    {
      unint64_t v9 = (unint64_t *)(*((void *)&v18 + 1) + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    uint64_t v11 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 80LL))(*(void *)(a1 + 24), a1 + 64);
  }

  else
  {
    *(void *)&__int128 v16 = "int BackendSG::write(const sg_entry &)";
    *((void *)&v16 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 20LL;
    int v17 = 16;
    di_log::logger<di_log::log_printer<124ul>>::logger(&v18, &v16);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v20,  (uint64_t)"BackendSG: error allocating buffer",  34LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<124ul>>::~logger_buf((uint64_t)&v18);
    MEMORY[0x1895BC2CC](&v21);
    uint64_t v11 = 4294967284LL;
  }

  unint64_t v12 = (std::__shared_weak_count *)*((void *)&v22 + 1);
  if (*((void *)&v22 + 1))
  {
    uint64_t v13 = (unint64_t *)(*((void *)&v22 + 1) + 8LL);
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  return v11;
}

void sub_1881433A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t BackendSG::read(uint64_t a1, uint64_t a2)
{
  if ((void)v22)
  {
    __int128 v4 = *(_OWORD *)(a2 + 16);
    uint64_t v5 = *(void *)(a1 + 40);
    __int128 v18 = v22;
    if (*((void *)&v22 + 1))
    {
      uint64_t v6 = (unint64_t *)(*((void *)&v22 + 1) + 8LL);
      do
        unint64_t v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }

    *(_OWORD *)unint64_t v19 = v4;
    *(void *)&v19[16] = v5;
    v19[24] = 0;
    std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100](a1 + 64, &v18);
    *(_OWORD *)(a1 + 80) = *(_OWORD *)v19;
    *(_OWORD *)(a1 + 89) = *(_OWORD *)&v19[9];
    unint64_t v8 = (std::__shared_weak_count *)*((void *)&v18 + 1);
    if (*((void *)&v18 + 1))
    {
      unint64_t v9 = (unint64_t *)(*((void *)&v18 + 1) + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    uint64_t v11 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 88LL))(*(void *)(a1 + 24), a1 + 64);
    if ((v11 & 0x80000000) == 0 && *(_BYTE *)(a1 + 112)) {
      memcpy(*(void **)a2, *(const void **)(a1 + 64), *(void *)(a1 + 80));
    }
  }

  else
  {
    *(void *)&__int128 v16 = "int BackendSG::read(const sg_entry &)";
    *((void *)&v16 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 19LL;
    int v17 = 16;
    di_log::logger<di_log::log_printer<138ul>>::logger(&v18, &v16);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v20,  (uint64_t)"BackendSG: error allocating buffer",  34LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<138ul>>::~logger_buf((uint64_t)&v18);
    MEMORY[0x1895BC2CC](&v21);
    uint64_t v11 = 4294967284LL;
  }

  unint64_t v12 = (std::__shared_weak_count *)*((void *)&v22 + 1);
  if (*((void *)&v22 + 1))
  {
    uint64_t v13 = (unint64_t *)(*((void *)&v22 + 1) + 8LL);
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  return v11;
}

void sub_188143588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<138ul>>::logger(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<138ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EA788;
  a1[45] = &unk_18A1EA888;
  a1[46] = &unk_18A1EA8B0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EA788;
  a1[45] = &unk_18A1EA810;
  a1[46] = &unk_18A1EA838;
  return a1;
}

void sub_188143634(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<138ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t BackendSG::truncate(BackendSG *this, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 3) + 56LL))(*((void *)this + 3));
  if ((_DWORD)v4)
  {
    *(void *)&__int128 v13 = "int BackendSG::truncate(uint64_t)";
    *((void *)&v13 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 23LL;
    int v14 = 16;
    di_log::logger<di_log::log_printer<157ul>>::logger(&v15, &v13);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v17,  (uint64_t)"BackendSG: truncating the inner backend failed, CFErrorRef error = ",  56LL);
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<157ul>>::~logger_buf((uint64_t)&v15);
    MEMORY[0x1895BC2CC](&v18);
  }

  else
  {
    __int128 v6 = *(_OWORD *)((char *)this + 88);
    uint64_t v7 = *((void *)this + 9);
    *(void *)&__int128 v15 = *((void *)this + 8);
    *((void *)&v15 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v7;
    if (v7)
    {
      unint64_t v8 = (unint64_t *)(v7 + 8);
      do
        unint64_t v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }

    *(void *)__int128 v16 = a2;
    *(_OWORD *)&v16[8] = v6;
    v16[24] = 0;
    std::shared_ptr<_di_plugin_t>::operator=[abi:ne180100]((uint64_t)this + 64, &v15);
    *((_OWORD *)this + 5) = *(_OWORD *)v16;
    *(_OWORD *)((char *)this + 89) = *(_OWORD *)&v16[9];
    unint64_t v10 = (std::__shared_weak_count *)*((void *)&v15 + 1);
    if (*((void *)&v15 + 1))
    {
      uint64_t v11 = (unint64_t *)(*((void *)&v15 + 1) + 8LL);
      do
        unint64_t v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }

  return v4;
}

void sub_1881437E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

__n128 BackendSG::BackendSG(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_18A1E5578;
  uint64_t v3 = a3[1];
  *(void *)(a1 + 24) = *a3;
  *(void *)(a1 + 32) = v3;
  if (v3)
  {
    uint64_t v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  *(void *)a1 = off_18A1EA5C0;
  uint64_t v6 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = v6;
  uint64_t v7 = *(void *)(a2 + 56);
  *(void *)(a1 + ++*(_DWORD *)(this + 56) = v7;
  if (v7)
  {
    unint64_t v8 = (unint64_t *)(v7 + 8);
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  uint64_t v10 = *(void *)(a2 + 72);
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v10;
  if (v10)
  {
    uint64_t v11 = (unint64_t *)(v10 + 8);
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  __n128 result = *(__n128 *)(a2 + 80);
  *(_OWORD *)(a1 + 89) = *(_OWORD *)(a2 + 89);
  *(__n128 *)(a1 + 80) = result;
  *(_BYTE *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v50 + 112) = *(_BYTE *)(a2 + 112);
  return result;
}

double BackendSG::construct_context_from_inner@<D0>(uint64_t a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  double result = v5[0];
  *a3 = *(_OWORD *)v5;
  return result;
}

uint64_t BufferedWriteBackend::BufferedWriteBackend(uint64_t a1, void *a2, std::vector<char>::size_type __n)
{
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_18A1E5578;
  uint64_t v4 = a2[1];
  *(void *)(a1 + 24) = *a2;
  *(void *)(a1 + 32) = v4;
  if (v4)
  {
    unint64_t v5 = (unint64_t *)(v4 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  *(void *)a1 = off_18A1EA688;
  *(void *)(a1 + 40) = 850045863LL;
  *(_OWORD *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = 0u;
  *(_OWORD *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = 0LL;
  std::vector<char>::vector((std::vector<char> *)(a1 + 104), __n);
  *(_BYTE *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  return a1;
}

void sub_18814396C(_Unwind_Exception *a1)
{
}

uint64_t BufferedWriteBackend::reset_last_offset(BufferedWriteBackend *this, unint64_t a2)
{
  uint64_t v4 = *((void *)this + 13);
  unint64_t v5 = a2 % (*((void *)this + 14) - v4);
  if (!v5) {
    goto LABEL_11;
  }
  unint64_t v6 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
  uint64_t v14 = v4;
  __int128 v15 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  unint64_t v16 = v5;
  uint64_t v17 = a2 - v5;
  unint64_t v18 = v5;
  char v19 = 0;
  uint64_t v9 = (*(uint64_t (**)(BufferedWriteBackend *, uint64_t *))(*(void *)this + 104LL))(this, &v14);
  uint64_t v10 = v15;
  if (v15)
  {
    uint64_t v11 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v5 == (int)v9)
  {
LABEL_11:
    uint64_t v9 = 0LL;
    *((void *)this + 16) = a2;
    *((_BYTE *)this + 136) = 1;
  }

  return v9;
}

void sub_188143A78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unint64_t BufferedWriteBackend::write(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 40);
  std::mutex::lock((std::mutex *)(a1 + 40));
  if (!*(_BYTE *)(a1 + 136))
  {
    unint64_t offset = BufferedWriteBackend::reset_last_offset((BufferedWriteBackend *)a1, *(void *)(a2 + 24));
    if ((_DWORD)offset) {
      goto LABEL_34;
    }
  }

  unint64_t v5 = *(void *)(a1 + 128);
  uint64_t v6 = *(void *)(a1 + 104);
  size_t v7 = *(void *)(a1 + 112) - v6;
  unint64_t v8 = v5 % v7;
  if (v5 % v7)
  {
    size_t v9 = v7 - v8;
    if (v9 >= *(void *)(a2 + 16)) {
      size_t v10 = *(void *)(a2 + 16);
    }
    else {
      size_t v10 = v9;
    }
    memcpy((void *)(v6 + v8), *(const void **)a2, v10);
    size_t v11 = *(void *)(a1 + 104);
    size_t v7 = *(void *)(a1 + 112) - v11;
    if (v10 + v8 == v7)
    {
      unint64_t v12 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
      size_t v30 = v11;
      int v31 = v12;
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          unint64_t v14 = __ldxr(p_shared_owners);
        while (__stxr(v14 + 1, p_shared_owners));
      }

      unint64_t v32 = v10 + v8;
      size_t v33 = v5 - v8;
      size_t v34 = v10 + v8;
      char v35 = 0;
      unint64_t offset = (*(uint64_t (**)(void, size_t *))(**(void **)(a1 + 24) + 80LL))(*(void *)(a1 + 24), &v30);
      unint64_t v16 = v31;
      unint64_t v17 = v32;
      if (v31)
      {
        unint64_t v18 = (unint64_t *)&v31->__shared_owners_;
        do
          unint64_t v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }

      size_t v7 = *(void *)(a1 + 112) - *(void *)(a1 + 104);
    }
  }

  else
  {
    size_t v10 = 0LL;
  }

  unint64_t offset = *(void *)(a2 + 16);
  unint64_t v20 = (offset - v10) / v7 * v7;
  if (offset - v10 == (offset - v10) % v7)
  {
LABEL_31:
    if (offset > v10)
    {
      memcpy(*(void **)(a1 + 104), (const void *)(*(void *)a2 + v10), offset - v10);
      unint64_t offset = *(void *)(a2 + 16);
    }

    *(void *)(a1 + 128) += offset;
    goto LABEL_34;
  }

  uint64_t v21 = *(void *)(a2 + 32);
  size_t v22 = *(void *)(a2 + 24) + v10;
  unint64_t v23 = *(std::__shared_weak_count **)(a2 + 8);
  size_t v30 = *(void *)a2 + v10;
  int v31 = v23;
  if (v23)
  {
    unint64_t v24 = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }

  unint64_t v32 = v20;
  size_t v33 = v22;
  size_t v34 = v21 - v10;
  char v35 = 0;
  unint64_t offset = (*(uint64_t (**)(void, size_t *))(**(void **)(a1 + 24) + 80LL))(*(void *)(a1 + 24), &v30);
  unint64_t v26 = v31;
  if (v31)
  {
    __int128 v27 = (unint64_t *)&v31->__shared_owners_;
    do
      unint64_t v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  if (v20 == (int)offset)
  {
    v10 += v20;
    unint64_t offset = *(void *)(a2 + 16);
    goto LABEL_31;
  }

void sub_188143CD8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t BufferedWriteBackend::flush(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 40);
  std::mutex::lock((std::mutex *)(a1 + 40));
  if (*(_BYTE *)(a1 + 136))
  {
    uint64_t v5 = *(void *)(a1 + 104);
    unint64_t v6 = *(void *)(a1 + 112) - v5;
    unint64_t v7 = *(void *)(a1 + 128) % v6;
    if (!v7) {
      goto LABEL_15;
    }
    bzero((void *)(v5 + v7), v6 - v7);
    uint64_t v8 = *(void *)(a1 + 128);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v10 = *(void *)(a1 + 112);
    size_t v11 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
    uint64_t v22 = v9;
    unint64_t v23 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    uint64_t v24 = v10 - v9;
    uint64_t v25 = v8 - v7;
    uint64_t v26 = v10 - v9;
    char v27 = 0;
    int v14 = (*(uint64_t (**)(void, uint64_t *))(**(void **)(a1 + 24) + 80LL))(*(void *)(a1 + 24), &v22);
    uint64_t v15 = v14;
    uint64_t v16 = v14 >= 0 ? 4294967291LL : v14;
    unint64_t v17 = v23;
    uint64_t v18 = v24;
    if (v23)
    {
      unint64_t v19 = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }

    if (v18 == v15) {
LABEL_15:
    }
      uint64_t v16 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 16LL))(*(void *)(a1 + 24), a2);
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  std::mutex::unlock(v4);
  return v16;
}

void sub_188143E4C(_Unwind_Exception *a1)
{
}

void BufferedWriteBackend::~BufferedWriteBackend(BufferedWriteBackend *this)
{
}

{
  void *v2;
  std::__shared_weak_count *v3;
  *(void *)this = off_18A1EA688;
  BufferedWriteBackend::flush((uint64_t)this, 1LL);
  uint64_t v2 = (void *)*((void *)this + 13);
  if (v2)
  {
    *((void *)this + 14) = v2;
    operator delete(v2);
  }

  std::mutex::~mutex((std::mutex *)((char *)this + 40));
  *(void *)this = off_18A1E5578;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *BufferedWriteBackend::name(uint64_t a1, void *a2)
{
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( a2,  (uint64_t)"BufferedWriteBackend",  20LL);
}

void *BufferedWriteBackend::construct_context_from_inner@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return std::shared_ptr<Backend>::shared_ptr[abi:ne180100]<Backend,void>(a2, (void *)(a1 + 8));
}

void BackendSG::~BackendSG(BackendSG *this)
{
  *(void *)this = off_18A1EA5C0;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 64);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 48);
  *(void *)this = off_18A1E5578;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

{
  std::__shared_weak_count *v2;
  *(void *)this = off_18A1EA5C0;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 64);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 48);
  *(void *)this = off_18A1E5578;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(this);
}

void *BackendSG::name(uint64_t a1, void *a2)
{
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"BackendSG", 9LL);
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<138ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<138ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<138ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<138ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<138ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<138ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<138ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<138ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<138ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<138ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EA920;
  di_log::logger_buf<di_log::log_printer<138ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<138ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<138ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1881442F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<138ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<138ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<138ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 138LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    size_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        int v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 138LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  double result = __error();
  int *result = v5;
  return result;
}

void *std::allocate_shared[abi:ne180100]<BufferAllocator,std::allocator<BufferAllocator>,unsigned long &,int,unsigned long &,void>@<X0>( uint64_t *a1@<X1>, unsigned int *a2@<X2>, unint64_t *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0xB8uLL);
  double result = std::__shared_ptr_emplace<BufferAllocator>::__shared_ptr_emplace[abi:ne180100]<unsigned long &,int,unsigned long &,std::allocator<BufferAllocator>,0>( v8,  a1,  a2,  a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1881445E8(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<BufferAllocator>::__shared_ptr_emplace[abi:ne180100]<unsigned long &,int,unsigned long &,std::allocator<BufferAllocator>,0>( void *a1, uint64_t *a2, unsigned int *a3, unint64_t *a4)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1EA9A0;
  BufferAllocator::BufferAllocator((BufferAllocator *)(a1 + 3), *a2, *a3, *a4);
  return a1;
}

void sub_18814463C(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<BufferAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_18A1EA9A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<BufferAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_18A1EA9A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<BufferAllocator>::__on_zero_shared(uint64_t a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<138ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1EA920;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881446F4(_Unwind_Exception *a1)
{
}

void std::allocate_shared[abi:ne180100]<BackendSG,std::allocator<BackendSG>,BackendSG&,std::shared_ptr<Backend> const&,void>( uint64_t a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  char v6 = operator new(0x90uLL);
  v6[1] = 0LL;
  void v6[2] = 0LL;
  *char v6 = off_18A1DF1D8;
  BackendSG::BackendSG((uint64_t)(v6 + 3), a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a3,  v6 + 4,  (uint64_t)(v6 + 3));
}

double CompressedBackend::make_backend@<D0>(void *a1@<X0>, int *a2@<X1>, size_t a3@<X2>, _OWORD *a4@<X8>)
{
  size_t v7 = a3;
  if (*a2 == 4) {
    std::allocate_shared[abi:ne180100]<BZIPCompressedBackend,std::allocator<BZIPCompressedBackend>,std::shared_ptr<Backend> const&,unsigned long &,void>( a1,  &v7,  &v6);
  }
  else {
    std::allocate_shared[abi:ne180100]<StandardCompressedBackend,std::allocator<StandardCompressedBackend>,std::shared_ptr<Backend> const&,CompressedBackend::algo_t &,unsigned long &,void>( a1,  a2,  &v7,  &v6);
  }
  double result = *(double *)&v6;
  *a4 = v6;
  return result;
}

uint64_t CompressedBackend::CompressedBackend(uint64_t a1, void *a2, _DWORD *a3, size_t a4)
{
  *(void *)uint64_t v7 = off_18A1EA9F0;
  *(_DWORD *)(v7 + 40) = *a3;
  *(void *)(v7 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = a4;
  uint64_t v8 = operator new[](a4);
  bzero(v8, a4);
  *(void *)(a1 + ++*(_DWORD *)(this + 56) = v8;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 64) = v8;
  *(void *)(a1 + 72) = a1 + 96;
  *(_OWORD *)(a1 + 80) = xmmword_188179140;
  return a1;
}

void sub_188144860(_Unwind_Exception *a1)
{
}

uint64_t CompressedBackend::CompressedBackend(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)uint64_t v5 = off_18A1EA9F0;
  *(_DWORD *)(v5 + 40) = *(_DWORD *)(a2 + 40);
  size_t v6 = *(void *)(a2 + 48);
  *(void *)(v5 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = v6;
  uint64_t v7 = operator new[](v6);
  bzero(v7, v6);
  *(void *)(a1 + ++*(_DWORD *)(this + 56) = v7;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 64) = v7;
  *(void *)(a1 + 72) = a1 + 96;
  *(_OWORD *)(a1 + 80) = xmmword_188179140;
  return a1;
}

void sub_1881448F0(_Unwind_Exception *a1)
{
}

void CompressedBackend::~CompressedBackend(CompressedBackend *this)
{
  *(void *)this = off_18A1EA9F0;
  boost::container::vector<CompressedBackend::promise_io_t,boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)this + 72);
  uint64_t v2 = (void *)*((void *)this + 7);
  *((void *)this + 7) = 0LL;
  if (v2) {
    operator delete[](v2);
  }
  *(void *)this = off_18A1E5578;
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t CompressedBackend::read(uint64_t a1, uint64_t a2)
{
  char v4 = *(char **)(a1 + 64);
  if (v4 != *(char **)(a1 + 56))
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 144LL))(a1);
    char v4 = *(char **)(a1 + 56);
  }

  uint64_t v5 = Backend::read(*(Backend **)(a1 + 24), v4, *(void *)(a2 + 16), *(void *)(a2 + 24));
  if ((v5 & 0x80000000) != 0)
  {
    uint64_t v7 = v5;
    *(void *)&__int128 v10 = "int CompressedBackend::read(const sg_entry &)";
    *((void *)&v10 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 27LL;
    int v11 = 16;
    di_log::logger<di_log::log_printer<49ul>>::logger(v12, &v10);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v13,  (uint64_t)"Internal backend read() failed. ret=",  36LL);
    std::ostream::operator<<();
    std::ios_base::getloc((const std::ios_base *)&v14[*(void *)(v13 - 24) - 8]);
    uint64_t v8 = std::locale::use_facet(&v15, MEMORY[0x189614558]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10LL);
    std::locale::~locale(&v15);
    std::ostream::put();
    std::ostream::flush();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<49ul>>::~logger_buf((uint64_t)v12);
    MEMORY[0x1895BC2CC](v14);
  }

  else
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 192LL))(a1, a2, *(void *)(a1 + 56));
    if (v6)
    {
      return v6;
    }

    else
    {
      *(void *)&__int128 v10 = "int CompressedBackend::read(const sg_entry &)";
      *((void *)&v10 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 27LL;
      int v11 = 16;
      di_log::logger<di_log::log_printer<55ul>>::logger(v12, &v10);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v13,  (uint64_t)"Decompression failed",  20LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<55ul>>::~logger_buf((uint64_t)v12);
      MEMORY[0x1895BC2CC](v14);
      return 4294967291LL;
    }
  }

  return v7;
}

void sub_188144B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *di_log::logger<di_log::log_printer<49ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<49ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EACC8;
  a1[45] = &unk_18A1EADC8;
  a1[46] = &unk_18A1EADF0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EACC8;
  a1[45] = &unk_18A1EAD50;
  a1[46] = &unk_18A1EAD78;
  return a1;
}

void sub_188144BDC(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<49ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<55ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<55ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EAEE8;
  a1[45] = &unk_18A1EAFE8;
  a1[46] = &unk_18A1EB010;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EAEE8;
  a1[45] = &unk_18A1EAF70;
  a1[46] = &unk_18A1EAF98;
  return a1;
}

void sub_188144CC4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<55ul>>::~logger(uint64_t a1)
{
  return a1;
}

unint64_t CompressedBackend::future_read@<X0>( uint64_t *a1@<X0>, void *a2@<X1>, unint64_t a3@<X8>)
{
  uint64_t v6 = a1[8];
  uint64_t v7 = a2 + 2;
  unint64_t v8 = a2[2];
  if (a1[6] - v6 + a1[7] < v8)
  {
    (*(void (**)(uint64_t *))(*a1 + 144))(a1);
    uint64_t v6 = a1[8];
    unint64_t v8 = *v7;
  }

  uint64_t v9 = a1[3];
  uint64_t v10 = a2[3];
  uint64_t v11 = *((void *)details::get_dummy_shared_ptr() + 1);
  *(void *)&__int128 v34 = v6;
  *((void *)&v34 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v11;
  if (v11)
  {
    os_log_type_t v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  *(void *)char v35 = v8;
  *(void *)&_BYTE v35[8] = v10;
  *(void *)&v35[16] = v8;
  v35[24] = 0;
  (*(void (**)(void *__return_ptr, uint64_t, __int128 *))(*(void *)v9 + 128LL))(v41, v9, &v34);
  std::locale v15 = (std::__shared_weak_count *)*((void *)&v34 + 1);
  if (*((void *)&v34 + 1))
  {
    uint64_t v16 = (unint64_t *)(*((void *)&v34 + 1) + 8LL);
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  if (BYTE4(v41[0])) {
    BOOL v18 = 0;
  }
  else {
    BOOL v18 = v41[4] == 0LL;
  }
  if (v18) {
    return lw_future<int>::lw_future(a3, v41);
  }
  LOBYTE(v34) = 0;
  BYTE4(v34) = 0;
  *((void *)&v34 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0LL;
  *(void *)char v35 = ref::details::_get_tagged_ptr_lock((unint64_t)&v34, v14);
  uint64_t tagged_ptr_cond = ref::details::_get_tagged_ptr_cond((unint64_t)&v34, v19);
  uint64_t v42 = &v34;
  *(void *)&_BYTE v35[8] = tagged_ptr_cond;
  *(void *)&v35[16] = &v42;
  lw_future<int>::lw_future((unint64_t)v39, &v34);
  uint64_t v21 = v42;
  uint64_t v40 = v42;
  *((void *)v42 + 4) = &v40;
  uint64_t v22 = a2[1];
  *(void *)&__int128 v34 = *a2;
  *((void *)&v34 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v22;
  if (v22)
  {
    unint64_t v23 = (unint64_t *)(v22 + 8);
    do
      unint64_t v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
    uint64_t v21 = v40;
  }

  *(_OWORD *)&v35[9] = *(_OWORD *)((char *)v7 + 9);
  *(_OWORD *)char v35 = *(_OWORD *)v7;
  uint64_t v36 = v21;
  uint64_t v40 = 0LL;
  *((void *)v21 + 4) = &v36;
  lw_future<int>::lw_future((unint64_t)v37, v41);
  uint64_t v25 = a1[9];
  uint64_t v38 = a1[8];
  uint64_t v26 = a1[10];
  char v27 = (_OWORD *)(v25 + 104 * v26);
  if (v26 == a1[11])
  {
    boost::container::vector<CompressedBackend::promise_io_t,boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t>>( a1 + 9,  (void *)(v25 + 104 * v26),  (const char *)1,  (uint64_t)&v34,  &v42);
  }

  else
  {
    *char v27 = v34;
    __int128 v34 = 0uLL;
    __int128 v28 = *(_OWORD *)v35;
    *(_OWORD *)((char *)v27 + 25) = *(_OWORD *)&v35[9];
    v27[1] = v28;
    char v29 = (void *)(v25 + 104 * v26);
    v29[6] = v36;
    v29 += 6;
    uint64_t v36 = 0LL;
    *(void *)(*v29 + 32LL) = v29;
    lw_future<int>::lw_future((unint64_t)(v29 + 1), v37);
    *(void *)(v25 + 104 * v26 + 96) = v38;
    ++a1[10];
  }

  if (v36) {
    *((void *)v36 + 4) = 0LL;
  }
  size_t v30 = (std::__shared_weak_count *)*((void *)&v34 + 1);
  if (*((void *)&v34 + 1))
  {
    int v31 = (unint64_t *)(*((void *)&v34 + 1) + 8LL);
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }

  a1[8] += *v7;
  unint64_t result = lw_future<int>::lw_future(a3, v39);
  if (v40) {
    *((void *)v40 + 4) = 0LL;
  }
  return result;
}

void sub_188145008( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28)
{
  if (a15) {
    *(void *)(a15 + 32) = 0LL;
  }
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  if (a28) {
    *(void *)(a28 + 32) = 0LL;
  }
  _Unwind_Resume(a1);
}

void *CompressedBackend::run_futures(CompressedBackend *this)
{
  uint64_t v3 = *((void *)this + 9);
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    uint64_t v4 = v3 + 48;
    uint64_t v5 = 104 * v2;
    do
    {
      unsigned int v6 = lw_future<int>::get((unsigned int *)(v4 + 8));
      unsigned int v7 = v6;
      if ((v6 & 0x80000000) != 0)
      {
        uint64_t v10 = v3 + 48;
        uint64_t v11 = *(unsigned int **)v4;
        unsigned int *v11 = v7;
        uint64_t v9 = v11 + 1;
      }

      else if (*(void *)(v4 - 32) <= (unint64_t)v6)
      {
        uint64_t v12 = (*(uint64_t (**)(CompressedBackend *, uint64_t, void))(*(void *)this + 192LL))( this,  v4 - 48,  *(void *)(v4 + 48));
        if (v12)
        {
          int v13 = v12;
          uint64_t v10 = v3 + 48;
          int v14 = *(unsigned int **)v4;
          **(_DWORD **)uint64_t v4 = v13;
        }

        else
        {
          *(void *)&__int128 v16 = "void CompressedBackend::run_futures()";
          *((void *)&v16 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 35LL;
          int v17 = 16;
          di_log::logger<di_log::log_printer<94ul>>::logger(v18, &v16);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v19,  (uint64_t)"Decompression failed",  20LL);
          std::ostream::~ostream();
          di_log::logger_buf<di_log::log_printer<94ul>>::~logger_buf((uint64_t)v18);
          MEMORY[0x1895BC2CC](&v20);
          uint64_t v10 = v3 + 48;
          int v14 = *(unsigned int **)v4;
          **(_DWORD **)uint64_t v4 = -5;
        }

        uint64_t v9 = v14 + 1;
      }

      else
      {
        unint64_t v8 = *(unsigned int **)v4;
        *unint64_t v8 = -5;
        uint64_t v9 = v8 + 1;
        uint64_t v10 = v4;
      }

      _BYTE *v9 = 1;
      lw_promise<int>::notify_future(v10);
      v3 += 104LL;
      v4 += 104LL;
      v5 -= 104LL;
    }

    while (v5);
  }

  *((void *)this + 8) = *((void *)this + 7);
  return boost::container::vector<CompressedBackend::promise_io_t,boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,void>::priv_destroy_all((void *)this + 9);
}

void sub_1881451F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *di_log::logger<di_log::log_printer<94ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<94ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EB108;
  a1[45] = &unk_18A1EB208;
  a1[46] = &unk_18A1EB230;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EB108;
  a1[45] = &unk_18A1EB190;
  a1[46] = &unk_18A1EB1B8;
  return a1;
}

void sub_188145290(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<94ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t CompressedBackend::write(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 64) != *(void *)(a1 + 56)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 144LL))(a1);
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 184LL))(a1, a2);
  if (!v4) {
    return 4294967291LL;
  }
  uint64_t v5 = v4;
  uint64_t v6 = Backend::write(*(Backend **)(a1 + 24), *(char **)(a1 + 56), v4, *(void *)(a2 + 24));
  if ((v6 & 0x80000000) == 0) {
    return v5;
  }
  uint64_t v7 = v6;
  *(void *)&__int128 v10 = "int CompressedBackend::write(const sg_entry &)";
  *((void *)&v10 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 28LL;
  int v11 = 16;
  di_log::logger<di_log::log_printer<117ul>>::logger(v12, &v10);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v13,  (uint64_t)"Internal backend write() failed. ret=",  37LL);
  std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)&v13 + *(void *)(v13 - 24)));
  unint64_t v8 = std::locale::use_facet(&v15, MEMORY[0x189614558]);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10LL);
  std::locale::~locale(&v15);
  std::ostream::put();
  std::ostream::flush();
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<117ul>>::~logger_buf((uint64_t)v12);
  MEMORY[0x1895BC2CC](&v14);
  return v7;
}

void sub_188145450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *CompressedBackend::name(uint64_t a1, void *a2)
{
  uint64_t v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"Compressed(", 11LL);
  int v6 = *(_DWORD *)(a1 + 40);
  uint64_t v4 = operator<<(v3, &v6);
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)")", 1LL);
}

void *StandardCompressedBackend::StandardCompressedBackend(void *a1, void *a2, int *a3, size_t a4)
{
  int v13 = *a3;
  int v6 = (void *)CompressedBackend::CompressedBackend((uint64_t)a1, a2, &v13, a4);
  *int v6 = off_18A1EAAC8;
  v6[221] = 0LL;
  uint64_t v7 = (compression_algorithm *)operator new(4uLL);
  int v14 = *a3;
  StandardCompressedBackend::pimpl::pimpl(v7, &v14);
  a1[222] = v7;
  size_t v8 = compression_encode_scratch_buffer_size(*v7);
  size_t v9 = compression_decode_scratch_buffer_size((compression_algorithm)*(_DWORD *)a1[222]);
  if (v8 <= v9) {
    size_t v8 = v9;
  }
  a1[220] = v8;
  __int128 v10 = operator new[](v8);
  bzero(v10, v8);
  int v11 = (void *)a1[221];
  a1[221] = v10;
  if (v11) {
    operator delete[](v11);
  }
  return a1;
}

void sub_1881455D0(_Unwind_Exception *a1)
{
  uint64_t v3 = (void *)*((void *)v1 + 222);
  *((void *)v1 + 222) = 0LL;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)v1 + 221);
  *((void *)v1 + 22udif::run_type::run_type((udif::run_type *)&v11, 1) = 0LL;
  if (v4) {
    operator delete[](v4);
  }
  CompressedBackend::~CompressedBackend(v1);
  _Unwind_Resume(a1);
}

uint64_t StandardCompressedBackend::StandardCompressedBackend(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = (void *)CompressedBackend::CompressedBackend(a1, a2, a3);
  *uint64_t v5 = off_18A1EAAC8;
  size_t v6 = *(void *)(a2 + 1760);
  v5[220] = v6;
  v5[221] = 0LL;
  uint64_t v7 = *(_DWORD **)(a2 + 1776);
  size_t v8 = operator new(4uLL);
  *size_t v8 = *v7;
  *(void *)(a1 + 1776) = v8;
  size_t v9 = operator new[](v6);
  bzero(v9, v6);
  *(void *)(a1 + 1768) = v9;
  return a1;
}

void sub_18814569C(_Unwind_Exception *a1)
{
  *((void *)v1 + 222) = 0LL;
  operator delete(v2);
  uint64_t v4 = (void *)*((void *)v1 + 221);
  *((void *)v1 + 22udif::run_type::run_type((udif::run_type *)&v11, 1) = 0LL;
  if (v4) {
    operator delete[](v4);
  }
  CompressedBackend::~CompressedBackend(v1);
  _Unwind_Resume(a1);
}

size_t StandardCompressedBackend::decompress(uint64_t a1, uint64_t a2, const uint8_t *a3)
{
  return compression_decode_buffer( *(uint8_t **)a2,  *(void *)(a2 + 32),  a3,  *(void *)(a2 + 16),  *(void **)(a1 + 1768),  (compression_algorithm)**(_DWORD **)(a1 + 1776));
}

size_t StandardCompressedBackend::compress(uint64_t a1, uint64_t a2)
{
  return compression_encode_buffer( *(uint8_t **)(a1 + 56),  *(void *)(a2 + 16),  *(const uint8_t **)a2,  *(void *)(a2 + 16),  *(void **)(a1 + 1768),  (compression_algorithm)**(_DWORD **)(a1 + 1776));
}

double StandardCompressedBackend::construct_context_from_inner@<D0>( uint64_t a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  double result = v5[0];
  *a3 = *(_OWORD *)v5;
  return result;
}

uint64_t BZIPCompressedBackend::decompress(uint64_t a1, uint64_t a2, char *a3)
{
  unsigned int destLen = *(void *)(a2 + 32);
  *(void *)&__int128 v4 = "size_t BZIPCompressedBackend::decompress(const sg_entry &, char *) const";
  *((void *)&v4 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 40LL;
  int v5 = 16;
  di_log::logger<di_log::log_printer<242ul>>::logger(v6, &v4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v7,  (uint64_t)"BZIP decompression failed, res=",  31LL);
  std::ostream::operator<<();
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<242ul>>::~logger_buf((uint64_t)v6);
  MEMORY[0x1895BC2CC](&v8);
  return 0LL;
}

void sub_18814582C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *di_log::logger<di_log::log_printer<242ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<242ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EB3A0;
  a1[45] = &unk_18A1EB4A0;
  a1[46] = &unk_18A1EB4C8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EB3A0;
  a1[45] = &unk_18A1EB428;
  a1[46] = &unk_18A1EB450;
  return a1;
}

void sub_1881458C4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<242ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t BZIPCompressedBackend::compress(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 16);
  unsigned int destLen = v2;
  unint64_t v3 = v2 / 0x186A0;
  int v4 = BZ2_bzBuffToBuffCompress(*(char **)(a1 + 56), &destLen, *(char **)a2, v2, v3 + 1, 0, 0);
  if (v4 != -8)
  {
    if (!v4) {
      return destLen;
    }
    *(void *)&__int128 v6 = "size_t BZIPCompressedBackend::compress(const sg_entry &) const";
    *((void *)&v6 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 38LL;
    int v7 = 16;
    di_log::logger<di_log::log_printer<265ul>>::logger(v8, &v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v9,  (uint64_t)"BZIP compression failed, res=",  29LL);
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<265ul>>::~logger_buf((uint64_t)v8);
    MEMORY[0x1895BC2CC](&v10);
  }

  return 0LL;
}

void sub_188145A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *di_log::logger<di_log::log_printer<265ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<265ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EB5C0;
  a1[45] = &unk_18A1EB6C0;
  a1[46] = &unk_18A1EB6E8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EB5C0;
  a1[45] = &unk_18A1EB648;
  a1[46] = &unk_18A1EB670;
  return a1;
}

void sub_188145AC0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<265ul>>::~logger(uint64_t a1)
{
  return a1;
}

double BZIPCompressedBackend::construct_context_from_inner@<D0>( uint64_t a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  double result = v5[0];
  *a3 = *(_OWORD *)v5;
  return result;
}

void StandardCompressedBackend::~StandardCompressedBackend(StandardCompressedBackend *this)
{
  *(void *)this = off_18A1EAAC8;
  uint64_t v2 = (void *)*((void *)this + 222);
  *((void *)this + 222) = 0LL;
  if (v2) {
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 221);
  *((void *)this + 22udif::run_type::run_type((udif::run_type *)&v11, 1) = 0LL;
  if (v3) {
    operator delete[](v3);
  }
  CompressedBackend::~CompressedBackend(this);
}

{
  void *v1;
  StandardCompressedBackend::~StandardCompressedBackend(this);
  operator delete(v1);
}

void BZIPCompressedBackend::~BZIPCompressedBackend(BZIPCompressedBackend *this)
{
}

uint64_t boost::container::vector<CompressedBackend::promise_io_t,boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,void>::~vector( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    unint64_t v3 = *(void **)a1;
    do
    {
      uint64_t v4 = v3[6];
      if (v4) {
        *(void *)(v4 + 32) = 0LL;
      }
      --v2;
      unint64_t v3 = (void *)(std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)v3) + 104);
    }

    while (v2);
  }

  if (*(void *)(a1 + 16) && a1 + 24 != *(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<49ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<49ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<49ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<49ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<49ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<49ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<49ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<49ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<49ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<49ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EAE60;
  di_log::logger_buf<di_log::log_printer<49ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<49ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<49ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188145FCC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<49ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<49ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<49ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 49LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        int v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 49LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  double result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<55ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<55ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<55ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<55ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<55ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<55ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<55ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<55ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<55ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<55ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EB080;
  di_log::logger_buf<di_log::log_printer<55ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<55ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<55ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188146578( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<55ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<55ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<55ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 55LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        int v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 55LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  double result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<94ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<94ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<94ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<94ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<94ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<94ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<94ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<94ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<94ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<94ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EB2A0;
  di_log::logger_buf<di_log::log_printer<94ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<94ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<94ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188146B24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<94ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<94ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<94ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 94LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        int v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 94LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  double result = __error();
  int *result = v5;
  return result;
}

_DWORD *StandardCompressedBackend::pimpl::pimpl(_DWORD *a1, int *a2)
{
  *a1 = StandardCompressedBackend::pimpl::pimpl(CompressedBackend::algo_t)::algos[*a2];
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v5 = "StandardCompressedBackend::pimpl::pimpl(algo_t)";
    *((void *)&v5 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 39LL;
    int v6 = 2;
    di_log::logger<di_log::log_printer<175ul>>::logger(v7, &v5);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v8, (uint64_t)"Using compression ", 18LL);
    int v10 = *a2;
    operator<<(&v8, &v10);
    *(_DWORD *)((char *)&v8 + *(void *)(v8 - 24) + 8) = *(_DWORD *)((_BYTE *)&v8 + *(void *)(v8 - 24) + 8) & 0xFFFFFFB5 | 8;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v8, (uint64_t)" constant ", 10LL);
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<175ul>>::~logger_buf((uint64_t)v7);
    MEMORY[0x1895BC2CC](&v9);
  }

  return a1;
}

void sub_188146E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<242ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<242ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<242ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<242ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<242ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<242ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<242ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<242ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<242ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<242ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EB538;
  di_log::logger_buf<di_log::log_printer<242ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<242ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<242ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1881471EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<242ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<242ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<242ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 242LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        int v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 242LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  double result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<265ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<265ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<265ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<265ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<265ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<265ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<265ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<265ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<265ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<265ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EB758;
  di_log::logger_buf<di_log::log_printer<265ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<265ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<265ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_188147798( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<265ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<265ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<265ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 265LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      int v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    int v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        int v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 265LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  double result = __error();
  int *result = v5;
  return result;
}

void std::allocate_shared[abi:ne180100]<BZIPCompressedBackend,std::allocator<BZIPCompressedBackend>,std::shared_ptr<Backend> const&,unsigned long &,void>( void *a1@<X1>, size_t *a2@<X2>, void *a3@<X8>)
{
  char v6 = operator new(0x6F8uLL);
  std::__shared_ptr_emplace<BZIPCompressedBackend>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<Backend> const&,unsigned long &,std::allocator<BZIPCompressedBackend>,0>( v6,  a1,  a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a3,  v6 + 4,  (uint64_t)(v6 + 3));
}

void sub_188147A10(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<BZIPCompressedBackend>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<Backend> const&,unsigned long &,std::allocator<BZIPCompressedBackend>,0>( void *a1, void *a2, size_t *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1EB7D8;
  size_t v4 = *a3;
  int v6 = 4;
  CompressedBackend::CompressedBackend((uint64_t)(a1 + 3), a2, &v6, v4);
  a1[3] = off_18A1EABA0;
  return a1;
}

void sub_188147A7C(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<BZIPCompressedBackend>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_18A1EB7D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<BZIPCompressedBackend>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_18A1EB7D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<BZIPCompressedBackend>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::allocate_shared[abi:ne180100]<StandardCompressedBackend,std::allocator<StandardCompressedBackend>,std::shared_ptr<Backend> const&,CompressedBackend::algo_t &,unsigned long &,void>( void *a1@<X1>, int *a2@<X2>, size_t *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x710uLL);
  std::__shared_ptr_emplace<StandardCompressedBackend>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<Backend> const&,CompressedBackend::algo_t &,unsigned long &,std::allocator<StandardCompressedBackend>,0>( v8,  a1,  a2,  a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a4,  v8 + 4,  (uint64_t)(v8 + 3));
}

void sub_188147B34(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<StandardCompressedBackend>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<Backend> const&,CompressedBackend::algo_t &,unsigned long &,std::allocator<StandardCompressedBackend>,0>( void *a1, void *a2, int *a3, size_t *a4)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1EB828;
  int v6 = *a3;
  StandardCompressedBackend::StandardCompressedBackend(a1 + 3, a2, &v6, *a4);
  return a1;
}

void sub_188147B94(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<StandardCompressedBackend>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_18A1EB828;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<StandardCompressedBackend>::~__shared_ptr_emplace( std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_18A1EB828;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<StandardCompressedBackend>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t di_log::logger_buf<di_log::log_printer<49ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1EAE60;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188147C50(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<55ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1EB080;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188147CCC(_Unwind_Exception *a1)
{
}

void boost::container::vector<CompressedBackend::promise_io_t,boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t>>( uint64_t *a1@<X0>, void *a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = boost::container::vector_alloc_holder<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( (uint64_t)a1,  a3);
  if (v11 >= 0x13B13B13B13B13CLL) {
    boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v12);
  }
  uint64_t v13 = v11;
  int v14 = operator new(104 * v11);
  boost::container::vector<CompressedBackend::promise_io_t,boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t>>( (uint64_t)a1,  (uint64_t)v14,  v13,  a2,  (uint64_t)a3,  a4);
  *a5 = (char *)a2 + *a1 - v10;
}

unint64_t boost::container::vector_alloc_holder<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,unsigned long,boost::move_detail::integral_constant<unsigned int,1u>>::next_capacity<boost::container::growth_factor_60>( uint64_t a1, const char *a2)
{
  unint64_t v2 = 0x13B13B13B13B13BLL;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = v4 >> 61;
  unint64_t v6 = 8 * v4;
  if (v5 > 4) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = v6 / 5;
  if (v5) {
    unint64_t v8 = v7;
  }
  uint64_t v9 = &a2[v3];
  if (v8 < 0x13B13B13B13B13BLL) {
    unint64_t v2 = v8;
  }
  else {
    return (unint64_t)v9;
  }
}

void boost::container::vector<CompressedBackend::promise_io_t,boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_new_allocation<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t>>( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *(void *)a1;
  boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t*,boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t>>( a1,  *(void **)a1,  a4,  (void *)(*(void *)a1 + 104LL * *(void *)(a1 + 8)),  a2,  a5,  a6);
  if (v10)
  {
    for (uint64_t i = *(void *)(a1 + 8); i; v10 += 104LL)
    {
      uint64_t v12 = *(void *)(v10 + 48);
      if (v12) {
        *(void *)(v12 + 32) = 0LL;
      }
      --i;
      std::shared_ptr<char>::~shared_ptr[abi:ne180100](v10);
    }

    if (a1 + 24 != *(void *)a1) {
      operator delete(*(void **)a1);
    }
  }

  uint64_t v13 = *(void *)(a1 + 8) + a5;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v13;
  *(void *)(a1 + 16) = a3;
}

void sub_188147EC0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

uint64_t boost::container::uninitialized_move_and_insert_alloc<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t*,boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t>>( uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12 = boost::container::uninitialized_move_alloc<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t*>( a1,  a2,  a3,  a5);
  *(_OWORD *)uint64_t v12 = *(_OWORD *)a7;
  *(void *)a7 = 0LL;
  *(void *)(a7 + 8) = 0LL;
  __int128 v13 = *(_OWORD *)(a7 + 16);
  *(_OWORD *)(v12 + 25) = *(_OWORD *)(a7 + 25);
  *(_OWORD *)(v12 + 16) = v13;
  *(void *)(v12 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = *(void *)(a7 + 48);
  *(void *)(a7 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = 0LL;
  *(void *)(*(void *)(v12 + 48) + 32LL) = v12 + 48;
  lw_future<int>::lw_future(v12 + 56, (_DWORD *)(a7 + 56));
  *(void *)(v12 + 96) = *(void *)(a7 + 96);
  return boost::container::uninitialized_move_alloc<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t*>( a1,  a3,  a4,  v12 + 104 * a6);
}

void sub_188147FA0(_Unwind_Exception *a1)
{
  if (*(void *)v3) {
    *(void *)(*(void *)v3 + 32LL) = 0LL;
  }
  std::shared_ptr<char>::~shared_ptr[abi:ne180100](v2);
  for (; v1 != v2; v1 += 104LL)
  {
    uint64_t v5 = *(void *)(v1 + 48);
    if (v5) {
      *(void *)(v5 + 32) = 0LL;
    }
    std::shared_ptr<char>::~shared_ptr[abi:ne180100](v1);
  }

  _Unwind_Resume(a1);
}

uint64_t boost::container::uninitialized_move_alloc<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t*>( uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0LL;
    do
    {
      unint64_t v8 = &a2[v7];
      uint64_t v9 = a4 + v7 * 8;
      *(_OWORD *)uint64_t v9 = *(_OWORD *)&a2[v7];
      *unint64_t v8 = 0LL;
      v8[1] = 0LL;
      __int128 v10 = *(_OWORD *)&a2[v7 + 2];
      *(_OWORD *)(v9 + 25) = *(_OWORD *)((char *)&a2[v7 + 3] + 1);
      *(_OWORD *)(v9 + 16) = v10;
      *(void *)(a4 + v7 * 8 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = a2[v7 + 6];
      void v8[6] = 0LL;
      *(void *)(*(void *)(a4 + v7 * 8 + 48) + 32LL) = a4 + v7 * 8 + 48;
      lw_future<int>::lw_future(a4 + v7 * 8 + 56, &a2[v7 + 7]);
      *(void *)(v9 + 96) = a2[v7 + 12];
      v7 += 13LL;
    }

    while (v8 + 13 != a3);
    a4 += v7 * 8;
  }

  return a4;
}

void sub_18814809C(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(v3 + 48);
  if (v4) {
    *(void *)(v4 + 32) = 0LL;
  }
  boost::container::uninitialized_move_alloc<boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,CompressedBackend::promise_io_t*,CompressedBackend::promise_io_t*>( v3,  a1,  a2,  v2);
  __cxa_rethrow();
}

void sub_1881480C4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<94ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1EB2A0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188148140(_Unwind_Exception *a1)
{
}

void *boost::container::vector<CompressedBackend::promise_io_t,boost::container::small_vector_allocator<CompressedBackend::promise_io_t,boost::container::new_allocator<void>,void>,void>::priv_destroy_all( void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[1];
  if (v2)
  {
    double result = (void *)*result;
    do
    {
      uint64_t v3 = result[6];
      if (v3) {
        *(void *)(v3 + 32) = 0LL;
      }
      --v2;
      double result = (void *)(std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)result) + 104);
    }

    while (v2);
  }

  v1[1] = 0LL;
  return result;
}

void std::allocate_shared[abi:ne180100]<StandardCompressedBackend,std::allocator<StandardCompressedBackend>,StandardCompressedBackend&,std::shared_ptr<Backend> const&,void>( uint64_t a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x710uLL);
  std::__shared_ptr_emplace<StandardCompressedBackend>::__shared_ptr_emplace[abi:ne180100]<StandardCompressedBackend&,std::shared_ptr<Backend> const&,std::allocator<StandardCompressedBackend>,0>( v6,  a1,  a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a3,  v6 + 4,  (uint64_t)(v6 + 3));
}

void sub_1881481F0(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<StandardCompressedBackend>::__shared_ptr_emplace[abi:ne180100]<StandardCompressedBackend&,std::shared_ptr<Backend> const&,std::allocator<StandardCompressedBackend>,0>( void *a1, uint64_t a2, void *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1EB828;
  StandardCompressedBackend::StandardCompressedBackend((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_188148238(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<242ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1EB538;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_1881482B4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<265ul>>::logger_buf(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf() = off_18A1EB758;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = DIDebugLogsEnabled();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 88) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100](a1 + 96);
  return a1;
}

void sub_188148330(_Unwind_Exception *a1)
{
}

void std::allocate_shared[abi:ne180100]<BZIPCompressedBackend,std::allocator<BZIPCompressedBackend>,BZIPCompressedBackend&,std::shared_ptr<Backend> const&,void>( uint64_t a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x6F8uLL);
  std::__shared_ptr_emplace<BZIPCompressedBackend>::__shared_ptr_emplace[abi:ne180100]<BZIPCompressedBackend&,std::shared_ptr<Backend> const&,std::allocator<BZIPCompressedBackend>,0>( v6,  a1,  a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<PurgeableFileBackend>::__enable_weak_this[abi:ne180100]<Backend,PurgeableFileBackend,void>( (uint64_t)a3,  v6 + 4,  (uint64_t)(v6 + 3));
}

void sub_188148398(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<BZIPCompressedBackend>::__shared_ptr_emplace[abi:ne180100]<BZIPCompressedBackend&,std::shared_ptr<Backend> const&,std::allocator<BZIPCompressedBackend>,0>( void *a1, uint64_t a2, void *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_18A1EB7D8;
  CompressedBackend::CompressedBackend((uint64_t)(a1 + 3), a2, a3);
  a1[3] = off_18A1EABA0;
  return a1;
}

void sub_1881483EC(_Unwind_Exception *a1)
{
}

uint64_t FileDescriptorWrapper::handle_open_from_error_message@<X0>( int a1@<W0>, uint64_t a2@<X1>, int a3@<W3>, void *a4@<X8>)
{
  unint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v37, (uint64_t)"Couldn't open ", 14LL);
  int v9 = *(char *)(a2 + 23);
  if (v9 >= 0) {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v10 = *(void *)a2;
  }
  if (v9 >= 0) {
    uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v11 = *(void *)(a2 + 8);
  }
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, v10, v11);
  __int128 v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"' with flags ", 13LL);
  uint64_t v14 = *v13;
  *(_DWORD *)((char *)v13 + *(void *)(*v13 - 24) + 8) = *(_DWORD *)((_BYTE *)v13 + *(void *)(*v13 - 24) + 8) & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v13 + *(void *)(v14 - 24) + 8) |= 0x200u;
  std::locale v15 = (void *)std::ostream::operator<<();
  *(_DWORD *)((char *)v15 + *(void *)(*v15 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v15 + *(void *)(*v15 - 24LL) + 8) & 0xFFFFFFB5 | 2;
  if (a3 == 13)
  {
    else {
      __int128 v16 = *(const char **)a2;
    }
    if (fstatat(a1, v16, &v35, 0))
    {
      v34.__r_.__value_.__r.__words[0] = (std::string::size_type)"std::string FileDescriptorWrapper::handle_open_from_error_message(int, const std::string &, int, int)";
      v34.__r_.__value_.__l.__size_ = 65LL;
      LODWORD(v34.__r_.__value_.__r.__words[2]) = 16;
      di_log::logger<di_log::log_printer<66ul>>::logger(&v31, (__int128 *)&v34);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v32,  (uint64_t)"fstatfs failed with err code",  28LL);
      __error();
      std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v32,  (uint64_t)" trying to check permission after EACCES",  40LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<66ul>>::~logger_buf((uint64_t)&v31);
      MEMORY[0x1895BC2CC](&v33);
    }

    else
    {
      std::to_string(&v31, v35.st_gid);
      int v17 = getgrgid(v35.st_gid);
      if (v17) {
        std::string::__assign_external(&v31, v17->gr_name);
      }
      __int16 v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v37,  (uint64_t)", UID:GID(Name)=",  16LL);
      std::to_string(&v34, v35.st_uid);
      if ((v34.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v19 = &v34;
      }
      else {
        uint64_t v19 = (std::string *)v34.__r_.__value_.__r.__words[0];
      }
      if ((v34.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t size = v34.__r_.__value_.__s.__size_;
      }
      else {
        uint64_t size = v34.__r_.__value_.__l.__size_;
      }
      uint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)v19, size);
      __int16 v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)":", 1LL);
      if ((v31.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        unint64_t v23 = &v31;
      }
      else {
        unint64_t v23 = (std::string *)v31.__r_.__value_.__r.__words[0];
      }
      if ((v31.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v24 = v31.__r_.__value_.__s.__size_;
      }
      else {
        uint64_t v24 = v31.__r_.__value_.__l.__size_;
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)v23, v24);
      uint64_t v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v37, (uint64_t)" mode=", 6LL);
      uint64_t v26 = *v25;
      *(_DWORD *)((char *)v25 + *(void *)(*v25 - 24) + 8) = *(_DWORD *)((_BYTE *)v25 + *(void *)(*v25 - 24) + 8) & 0xFFFFFFB5 | 8;
      *(_DWORD *)((char *)v25 + *(void *)(v26 - 24) + 8) |= 0x200u;
      char v27 = (void *)std::ostream::operator<<();
      *(_DWORD *)((char *)v27 + *(void *)(*v27 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v27 + *(void *)(*v27 - 24LL) + 8) & 0xFFFFFFB5 | 2;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)" (our euid is ", 14LL);
      geteuid();
      __int128 v28 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)")", 1LL);
    }
  }

  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v38, a4);
  v36[0] = *MEMORY[0x189614728];
  uint64_t v29 = *(void *)(MEMORY[0x189614728] + 72LL);
  *(void *)((char *)v36 + *(void *)(v36[0] - 24LL)) = *(void *)(MEMORY[0x189614728] + 64LL);
  uint64_t v37 = v29;
  v38[0] = MEMORY[0x189614750] + 16LL;
  if (v39 < 0) {
    operator delete((void *)v38[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1895BC2CC](&v40);
}

void sub_188148788( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&STACK[0x2B8]);
  _Unwind_Resume(a1);
}

void *di_log::logger<di_log::log_printer<66ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<66ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EBBB0;
  a1[45] = &unk_18A1EBCB0;
  a1[46] = &unk_18A1EBCD8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EBBB0;
  a1[45] = &unk_18A1EBC38;
  a1[46] = &unk_18A1EBC60;
  return a1;
}

void sub_188148870(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<66ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t FileDescriptorWrapper::open_file(uint64_t a1, int a2)
{
  uint64_t v2 = a1;
  v31[19] = *MEMORY[0x1895F89C0];
  uint64_t v3 = open((const char *)a1, a2, 438LL);
  if ((_DWORD)v3 == -1)
  {
    int v11 = *__error();
    if (DIForwardLogs())
    {
      *(void *)&__int128 v21 = 0LL;
      DIOSLog = (os_log_s *)getDIOSLog();
      os_log_type_enabled(DIOSLog, OS_LOG_TYPE_ERROR);
      int v13 = *__error();
      *(_DWORD *)buf = 68158467;
      *(_DWORD *)&uint8_t buf[4] = 69;
      __int16 v24 = 2080;
      uint64_t v25 = "static int FileDescriptorWrapper::open_file(const std::string &, int)";
      __int16 v26 = 2081;
      uint64_t v27 = v2;
      __int16 v28 = 1024;
      int v29 = v13;
      uint64_t v14 = (const char *)_os_log_send_and_compose_impl();
      if (v14)
      {
        std::locale v15 = (char *)v14;
        fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v14);
        free(v15);
      }
    }

    else
    {
      __int128 v16 = (os_log_s *)getDIOSLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        int v17 = *__error();
        *(_DWORD *)buf = 68158467;
        *(_DWORD *)&uint8_t buf[4] = 69;
        __int16 v24 = 2080;
        uint64_t v25 = "static int FileDescriptorWrapper::open_file(const std::string &, int)";
        __int16 v26 = 2081;
        uint64_t v27 = v2;
        __int16 v28 = 1024;
        int v29 = v17;
        _os_log_impl(&dword_188046000, v16, OS_LOG_TYPE_ERROR, "%.*s: Failed opening %{private}s, errno %d", buf, 0x22u);
      }
    }

    *__error() = v11;
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)buf);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( buf,  (uint64_t)"Couldn't open file with flags ",  30LL);
    uint64_t v19 = *(void *)buf;
    *(_DWORD *)&buf[*(void *)(*(void *)buf - 24LL) + 8] = *(_DWORD *)&buf[*(void *)(*(void *)buf - 24LL) + 8] & 0xFFFFFFB5 | 8;
    *(_DWORD *)&buf[*(void *)(v19 - 24) + 8] |= 0x200u;
    std::ostream::operator<<();
    __int16 v20 = __error();
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)buf, *v20);
  }

  uint64_t v4 = v3;
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v21 = "int FileDescriptorWrapper::open_file(const std::string &, int)";
    *((void *)&v21 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 36LL;
    int v22 = 2;
    di_log::logger<di_log::log_printer<78ul>>::logger(buf, &v21);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v30, (uint64_t)"'", 1LL);
    int v5 = *(char *)(v2 + 23);
    if (v5 >= 0) {
      uint64_t v6 = v2;
    }
    else {
      uint64_t v6 = *(void *)v2;
    }
    if (v5 >= 0) {
      uint64_t v7 = *(unsigned __int8 *)(v2 + 23);
    }
    else {
      uint64_t v7 = *(void *)(v2 + 8);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v30, v6, v7);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v30,  (uint64_t)"' opened successfully with flags ",  33LL);
    uint64_t v8 = v30;
    *(_DWORD *)((char *)v31 + *(void *)(v30 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(_DWORD *)((_BYTE *)v31 + *(void *)(v30 - 24)) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)v31 + *(void *)(v8 - 24)) |= 0x200u;
    std::ostream::operator<<();
    uint64_t v9 = v30;
    *(_DWORD *)((char *)v31 + *(void *)(v30 - 24)) &= ~0x200u;
    *(_DWORD *)((char *)v31 + *(void *)(v9 - std::mutex::~mutex((std::mutex *)((char *)this + 24)) = *(_DWORD *)((_BYTE *)v31 + *(void *)(v9 - 24)) & 0xFFFFFFB5 | 2;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v30, (uint64_t)", fd=", 5LL);
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<78ul>>::~logger_buf((uint64_t)buf);
    MEMORY[0x1895BC2CC](v31);
  }

  return v4;
}

void sub_188148CBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void *di_log::logger<di_log::log_printer<78ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<78ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EBDD0;
  a1[45] = &unk_18A1EBED0;
  a1[46] = &unk_18A1EBEF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EBDD0;
  a1[45] = &unk_18A1EBE58;
  a1[46] = &unk_18A1EBE80;
  return a1;
}

void sub_188148D8C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<78ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t FileDescriptorWrapper::open_from(int a1, uint64_t a2, int a3)
{
  int v25 = a3 | 0x100;
  __int16 v26 = 438;
  else {
    uint64_t v5 = *(void *)a2;
  }
  uint64_t v27 = v5;
  uint64_t v6 = fcntl(a1, 56, &v25);
  if ((_DWORD)v6 == -1)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v19);
    std::locale v15 = __error();
    FileDescriptorWrapper::handle_open_from_error_message(a1, a2, *v15, &v22);
    if ((v24 & 0x80u) == 0) {
      __int128 v16 = &v22;
    }
    else {
      __int128 v16 = (__int128 *)v22;
    }
    if ((v24 & 0x80u) == 0) {
      uint64_t v17 = v24;
    }
    else {
      uint64_t v17 = *((void *)&v22 + 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)v16, v17);
    __int16 v18 = __error();
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v19, *v18);
  }

  uint64_t v7 = v6;
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v22 = "int FileDescriptorWrapper::open_from(int, const std::string &, int)";
    *((void *)&v22 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 36LL;
    int v23 = 2;
    di_log::logger<di_log::log_printer<95ul>>::logger(v19, &v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v20, (uint64_t)"'", 1LL);
    int v8 = *(char *)(a2 + 23);
    if (v8 >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    if (v8 >= 0) {
      uint64_t v10 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      uint64_t v10 = *(void *)(a2 + 8);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v20, v9, v10);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v20,  (uint64_t)"' opened successfully with flags ",  33LL);
    uint64_t v11 = v20;
    *(_DWORD *)((char *)&v20 + *(void *)(v20 - 24) + 8) = *(_DWORD *)((_BYTE *)&v20 + *(void *)(v20 - 24) + 8) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)&v20 + *(void *)(v11 - 24) + 8) |= 0x200u;
    std::ostream::operator<<();
    uint64_t v12 = v20;
    *(_DWORD *)((char *)&v20 + *(void *)(v20 - 24) + 8) &= ~0x200u;
    *(_DWORD *)((char *)&v20 + *(void *)(v12 - 24) + 8) = *(_DWORD *)((_BYTE *)&v20 + *(void *)(v12 - 24) + 8) & 0xFFFFFFB5 | 2;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v20, (uint64_t)", fd=", 5LL);
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<95ul>>::~logger_buf((uint64_t)v19);
    MEMORY[0x1895BC2CC](&v21);
  }

  return v7;
}

void sub_188149028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  if (*(char *)(v5 - 65) < 0)
  {
    operator delete(*(void **)(v5 - 88));
    std::ostringstream::~ostringstream((uint64_t)va);
    if ((v4 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }

  else
  {
    std::ostringstream::~ostringstream((uint64_t)va);
    if (!v4) {
      goto LABEL_6;
    }
  }

  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *di_log::logger<di_log::log_printer<95ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<95ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EBFF0;
  a1[45] = &unk_18A1EC0F0;
  a1[46] = &unk_18A1EC118;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EBFF0;
  a1[45] = &unk_18A1EC078;
  a1[46] = &unk_18A1EC0A0;
  return a1;
}

void sub_188149114(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<95ul>>::~logger(uint64_t a1)
{
  return a1;
}

void FileDescriptorWrapper::~FileDescriptorWrapper(FileDescriptorWrapper *this)
{
  *(void *)this = &off_18A1EB878;
  int v1 = *((_DWORD *)this + 2);
  if (v1 != -1)
  {
    close(v1);
    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v2 = "FileDescriptorWrapper::~FileDescriptorWrapper()";
      *((void *)&v2 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 45LL;
      int v3 = 2;
      di_log::logger<di_log::log_printer<103ul>>::logger(v4, &v2);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v5, (uint64_t)"File descriptor ", 16LL);
      std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v5, (uint64_t)" closed", 7LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<103ul>>::~logger_buf((uint64_t)v4);
      MEMORY[0x1895BC2CC](&v6);
    }
  }

{
  void *v1;
  FileDescriptorWrapper::~FileDescriptorWrapper(this);
  operator delete(v1);
}

void *di_log::logger<di_log::log_printer<103ul>>::logger(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<103ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EC210;
  a1[45] = &unk_18A1EC310;
  a1[46] = &unk_18A1EC338;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EC210;
  a1[45] = &unk_18A1EC298;
  a1[46] = &unk_18A1EC2C0;
  return a1;
}

void sub_1881492D8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<103ul>>::~logger(uint64_t a1)
{
  return a1;
}

void FileDescriptor::FileDescriptor(FileDescriptor *this, int a2, char a3)
{
  *((_DWORD *)this + 2) = a2;
  *(void *)this = &off_18A1CBAE8;
  *((_BYTE *)this + 12) = a3;
  *((_OWORD *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  FileDescriptor::update_info(this);
}

void sub_188149394(_Unwind_Exception *a1)
{
}

uint64_t FileDescriptor::update_info(FileDescriptor *this)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t result = FileDescriptor::get_stat(this, &v35);
  if ((v35.st_mode & 0xB000) != 0x2000)
  {
    *((void *)this + 2) = v35.st_size;
    goto LABEL_17;
  }

  bzero(v38, 0x400uLL);
  bzero(bsdName, 0x400uLL);
  if (fcntl(*((_DWORD *)this + 2), 50, v38) < 0)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    uint64_t v21 = __error();
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "get path failed", *v21);
  }

  if (!basename_r(v38, bsdName))
  {
    int v23 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    unsigned __int8 v24 = __error();
    DiskImagesRuntimeException::DiskImagesRuntimeException(v23, "basename_r failed", *v24);
  }

  mach_port_t v3 = *MEMORY[0x1896086A8];
  int v4 = IOBSDNameMatching(*MEMORY[0x1896086A8], 0, bsdName);
  io_service_t MatchingService = IOServiceGetMatchingService(v3, v4);
  io_registry_entry_t v6 = MatchingService;
  if (!MatchingService)
  {
    __int16 v26 = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    DiskImagesRuntimeException::DiskImagesRuntimeException(v26, "device not found in registry", 0x13u);
  }

  uint64_t v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(MatchingService, @"Size", (CFAllocatorRef)*MEMORY[0x189604DB0], 0);
  CFTypeID TypeID = CFNumberGetTypeID();
  if (CFProperty)
  {
    unint64_t v10 = TypeID;
    if (CFGetTypeID(CFProperty) != TypeID)
    {
      __int16 v28 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
      CFTypeID v29 = CFGetTypeID(CFProperty);
      uint64_t v30 = (void *)cf::CFUtilException::CFUtilException(v28, v29, v10);
    }
  }

  CFTypeRef cf = CFProperty;
  CFTypeRef v11 = IORegistryEntryCreateCFProperty(v6, @"Preferred Block Size", v7, 0);
  CFTypeID v12 = CFNumberGetTypeID();
  if (v11 && CFGetTypeID(v11) != v12)
  {
    std::string v31 = (cf::CFUtilException *)__cxa_allocate_exception(0x40uLL);
    CFGetTypeID(v11);
    uint64_t v32 = cf::CFUtilException::CFUtilException(v31);
  }

  CFTypeRef v33 = v11;
  IOObjectRelease(v6);
  if (!cf || (CFTypeID v13 = CFGetTypeID(cf), v13 != CFNumberGetTypeID()))
  {
    __int128 v16 = "device size not found in registry";
LABEL_20:
    uint64_t v17 = 19LL;
    goto LABEL_22;
  }

  if (!CFNumberGetValue((CFNumberRef)cf, kCFNumberLongLongType, &valuePtr))
  {
LABEL_21:
    __int128 v16 = "Failed converting CFNumber to longlong";
    uint64_t v17 = 22LL;
LABEL_22:
    __int16 v18 = __cxa_allocate_exception(0x40uLL);
    *__int16 v18 = off_18A1E43B0;
    uint64_t v19 = std::generic_category();
    v18[1] = v17;
    void v18[2] = v19;
    *((_BYTE *)v18 + 24) = 0;
    *((_BYTE *)v18 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = 0;
    v18[7] = v16;
  }

  *((void *)this + 2) = valuePtr;
  if (!v33 || (CFTypeID v14 = CFGetTypeID(v33), v14 != CFNumberGetTypeID()))
  {
    __int128 v16 = "device block size not found in registry";
    goto LABEL_20;
  }

  if (!CFNumberGetValue((CFNumberRef)v33, kCFNumberLongLongType, &valuePtr)) {
    goto LABEL_21;
  }
  *((void *)this + 3) = valuePtr;
  CFAutoRelease<__CFNumber const*>::~CFAutoRelease(&v33);
  uint64_t result = (uint64_t)CFAutoRelease<__CFNumber const*>::~CFAutoRelease(&cf);
LABEL_17:
  __darwin_ino64_t st_ino = v35.st_ino;
  *((void *)this + 4) = v35.st_dev;
  *((void *)this + 5) = st_ino;
  return result;
}

void sub_188149748( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, const void *a13)
{
}

uint64_t FileDescriptor::get_stat@<X0>(FileDescriptor *this@<X0>, stat *a2@<X8>)
{
  uint64_t result = fstat(*((_DWORD *)this + 2), a2);
  if ((_DWORD)result)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    int v4 = __error();
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "fstat failed", *v4);
  }

  return result;
}

void sub_188149800(_Unwind_Exception *a1)
{
}

uint64_t FileDescriptor::get_statfs@<X0>(FileDescriptor *this@<X0>, statfs *a2@<X8>)
{
  uint64_t result = fstatfs(*((_DWORD *)this + 2), a2);
  if ((result & 0x80000000) != 0)
  {
    exception = (DiskImagesRuntimeException *)__cxa_allocate_exception(0x40uLL);
    int v4 = __error();
    DiskImagesRuntimeException::DiskImagesRuntimeException(exception, "fstatfs failed", *v4);
  }

  return result;
}

void sub_188149874(_Unwind_Exception *a1)
{
}

BOOL FileDescriptor::is_device(FileDescriptor *this, const stat *a2)
{
  return (*((_WORD *)this + 2) & 0xB000) == 0x2000;
}

BOOL FileDescriptor::is_device(FileDescriptor *this)
{
  return (v2.st_mode & 0xB000) == 0x2000;
}

uint64_t FileDescriptor::get_mounted_on_fs(FileDescriptor *this)
{
  uint64_t v1 = (FileDescriptor *)MEMORY[0x1895F8858](this);
  uint64_t v3 = v2;
  uint64_t v12 = *MEMORY[0x1895F89C0];
  FileDescriptor::get_statfs(v1, &__src);
  memcpy(__dst, &__src, sizeof(__dst));
  std::string::basic_string[abi:ne180100]<0>((void *)v3, &__dst[72]);
  *(void *)&__int128 v8 = "FileDescriptor::get_mounted_on_fs() const";
  *((void *)&v8 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 33LL;
  int v9 = 2;
  di_log::logger<di_log::log_printer<159ul>>::logger(&__src, &v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &__src.f_mntonname[272],  (uint64_t)"File system is ",  15LL);
  int v4 = *(char *)(v3 + 23);
  if (v4 >= 0) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = *(void *)v3;
  }
  if (v4 >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(v3 + 23);
  }
  else {
    uint64_t v6 = *(void *)(v3 + 8);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__src.f_mntonname[272], v5, v6);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<159ul>>::~logger_buf((uint64_t)&__src);
  return MEMORY[0x1895BC2CC](&__src.f_mntonname[280]);
}

void sub_1881499F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

BOOL FileDescriptor::mounted_on_same_fs( FileDescriptor *this, const FileDescriptor *a2, const FileDescriptor *a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  FileDescriptor::get_statfs(this, &v8);
  int32_t v4 = v8.f_fsid.val[0];
  int32_t v5 = v8.f_fsid.val[1];
  FileDescriptor::get_statfs(a2, &v8);
  return v4 == v8.f_fsid.val[0] && v5 == v8.f_fsid.val[1];
}

void FileLocal::shared_state_t::init_unmap_zeros(FileLocal::shared_state_t *this)
{
  uint64_t v2 = (unint64_t *)((char *)this + 144);
  int32_t v4 = this;
  unint64_t v3 = atomic_load(v2);
  if (v3 != -1LL)
  {
    uint64_t v6 = &v4;
    int32_t v5 = &v6;
    std::__call_once( v2,  &v5,  (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<FileLocal::shared_state_t::init_unmap_zeros(void)::$_0 &&>>);
  }

uint64_t FileLocal::unlink_from(int a1, uint64_t *a2)
{
  else {
    uint64_t v2 = (uint64_t *)*a2;
  }
  if (fcntl(a1, 57, v2) < 0) {
    return -*__error();
  }
  else {
    return 0LL;
  }
}

off_t FileLocal::get_file_size_from(int a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*__error() != 13 && *__error() != 1)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v13);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"Cannot stat ", 12LL);
    int v9 = *(char *)(v2 + 23);
    if (v9 >= 0) {
      uint64_t v10 = v2;
    }
    else {
      uint64_t v10 = *(void *)v2;
    }
    if (v9 >= 0) {
      uint64_t v11 = *(unsigned __int8 *)(v2 + 23);
    }
    else {
      uint64_t v11 = *(void *)(v2 + 8);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v10, v11);
    uint64_t v12 = __error();
    DiskImagesRuntimeException::DiskImagesRuntimeException((uint64_t)exception, (uint64_t)v13, *v12);
  }

  int32_t v4 = (FileLocal *)operator new(0x458uLL);
  int v5 = FileDescriptorWrapper::open_from(a1, v2, 0);
  FileLocal::FileLocal(v4, v5, 0, 0);
  uint64_t v6 = (*(uint64_t (**)(FileLocal *))(*(void *)v4 + 40LL))(v4);
  (*(void (**)(FileLocal *))(*(void *)v4 + 8LL))(v4);
  return v6;
}

void sub_188149CF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t FileLocal::write(uint64_t a1, uint64_t a2)
{
  ssize_t v4 = pwrite(**(_DWORD **)(a1 + 56), *(const void **)a2, *(void *)(a2 + 16), *(void *)(a2 + 24));
  ssize_t v5 = v4;
  if (v4 < 0 || v4 != *(void *)(a2 + 16))
  {
    *(void *)&__int128 v11 = "int FileLocal::write(const sg_entry &)";
    *((void *)&v11 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 20LL;
    int v12 = 16;
    di_log::logger<di_log::log_printer<298ul>>::logger(v13, &v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v14,  (uint64_t)"Error writing file @ ",  21LL);
    operator<<(&v14);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v14, (uint64_t)". returned ", 11LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v14, (uint64_t)" with errno: ", 13LL);
    __error();
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<298ul>>::~logger_buf((uint64_t)v13);
    MEMORY[0x1895BC2CC](&v15);
    if (v5 == -1) {
      return -*__error();
    }
    else {
      return 4294967291LL;
    }
  }

  else
  {
    unint64_t v6 = *(void *)(a2 + 24) + v4;
    uint64_t v7 = (unint64_t *)(*(void *)(a1 + 40) + 64LL);
    unint64_t v8 = atomic_load(v7);
    if (v8 < v6)
    {
      do
      {
        unint64_t v9 = __ldaxr(v7);
        if (v9 == v8)
        {
          if (!__stlxr(v6, v7)) {
            return v5;
          }
        }

        else
        {
          __clrex();
        }

        unint64_t v8 = v9;
      }

      while (v9 < v6);
    }
  }

  return v5;
}

void sub_188149ED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<298ul>>::logger(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<298ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EC430;
  a1[45] = &unk_18A1EC530;
  a1[46] = &unk_18A1EC558;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EC430;
  a1[45] = &unk_18A1EC4B8;
  a1[46] = &unk_18A1EC4E0;
  return a1;
}

void sub_188149F68(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<298ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t FileLocal::read(uint64_t a1, uint64_t a2)
{
  ssize_t v3 = pread(**(_DWORD **)(a1 + 56), *(void **)a2, *(void *)(a2 + 16), *(void *)(a2 + 24));
  ssize_t v4 = v3;
  if (v3 < 0 || v3 != *(void *)(a2 + 16))
  {
    *(void *)&__int128 v6 = "int FileLocal::read(const sg_entry &)";
    *((void *)&v6 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 19LL;
    int v7 = 16;
    di_log::logger<di_log::log_printer<313ul>>::logger(v8, &v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v9,  (uint64_t)"Error reading file @ ",  21LL);
    operator<<(&v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v9, (uint64_t)". returned ", 11LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v9, (uint64_t)" with errno: ", 13LL);
    __error();
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<313ul>>::~logger_buf((uint64_t)v8);
    MEMORY[0x1895BC2CC](&v10);
    if (v4 == -1) {
      return -*__error();
    }
    else {
      return 4294967291LL;
    }
  }

  return v4;
}

void sub_18814A0F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<313ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<313ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EC650;
  a1[45] = &unk_18A1EC750;
  a1[46] = &unk_18A1EC778;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EC650;
  a1[45] = &unk_18A1EC6D8;
  a1[46] = &unk_18A1EC700;
  return a1;
}

void sub_18814A18C(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<313ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t FileLocal::truncate(int **this, unint64_t a2)
{
  unint64_t v4 = (*((uint64_t (**)(int **))*this + 5))(this);
  if (v4 < a2)
  {
    char __buf = 0;
    ssize_t v5 = pwrite(*this[7], &__buf, 1uLL, a2 - 1);
    if (v5 != 1)
    {
      ssize_t v6 = v5;
      *(void *)&__int128 v8 = "int FileLocal::truncate(uint64_t)";
      *((void *)&v8 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 23LL;
      int v9 = 16;
      di_log::logger<di_log::log_printer<331ul>>::logger(v10, &v8);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v11,  (uint64_t)"Failed to increase file size, pwrite returned ",  46LL);
      std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)" errno: ", 8LL);
      __error();
      std::ostream::operator<<();
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<331ul>>::~logger_buf((uint64_t)v10);
      MEMORY[0x1895BC2CC](v12);
      if (v6 != -1) {
        return 4294967291LL;
      }
      return -*__error();
    }

void sub_18814A3B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *di_log::logger<di_log::log_printer<336ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<336ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EC870;
  a1[45] = &unk_18A1EC970;
  a1[46] = &unk_18A1EC998;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EC870;
  a1[45] = &unk_18A1EC8F8;
  a1[46] = &unk_18A1EC920;
  return a1;
}

void sub_18814A458(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<336ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t FileLocal::flush(uint64_t a1, int a2)
{
  if (DIDebugLogsEnabled())
  {
    *(void *)&__int128 v16 = "int FileLocal::flush(di_flush_mode)";
    *((void *)&v16 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 20LL;
    int v17 = 2;
    di_log::logger<di_log::log_printer<370ul>>::logger(v18, &v16);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v19, (uint64_t)"Calling ", 8LL);
    operator<<(&v19, a2);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v19, (uint64_t)" on ", 4LL);
    operator<<((uint64_t)&v19, a1);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<370ul>>::~logger_buf((uint64_t)v18);
    MEMORY[0x1895BC2CC](v20);
  }

  if (a2 == 1)
  {
    if (fsync(**(_DWORD **)(a1 + 56)) == -1)
    {
      uint64_t v4 = -*__error();
      goto LABEL_6;
    }

    return 0LL;
  }

  if (a2 == 2) {
    uint64_t v5 = 2LL;
  }
  else {
    uint64_t v5 = 1LL;
  }
  if ((*(void *)(*(void *)(a1 + 40) + 56LL) & v5) != 0)
  {
    if (DIDebugLogsEnabled())
    {
      *(void *)&__int128 v16 = "int FileLocal::flush(di_flush_mode)";
      *((void *)&v16 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 20LL;
      int v17 = 2;
      di_log::logger<di_log::log_printer<381ul>>::logger(v18, &v16);
      operator<<(&v19, a2);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v19, (uint64_t)" is not supported", 17LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<381ul>>::~logger_buf((uint64_t)v18);
      MEMORY[0x1895BC2CC](v20);
    }

    return (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a1 + 16LL))(a1, a2 != 2);
  }

  int v7 = **(_DWORD **)(a1 + 56);
  if (a2 == 2) {
    int v8 = fcntl(v7, 51, 0LL);
  }
  else {
    int v8 = fcntl(v7, 85, 0LL);
  }
  if (v8 != -1) {
    return 0LL;
  }
  uint64_t v10 = __error();
  uint64_t v4 = -*v10;
  unsigned int v11 = 45 - *v10;
  if (v11 <= 0x17 && ((1 << v11) & 0x900001) != 0)
  {
    int v12 = (unint64_t *)(*(void *)(a1 + 40) + 56LL);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 | v5, v12));
    *(void *)&__int128 v16 = "int FileLocal::flush(di_flush_mode)";
    *((void *)&v16 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 20LL;
    int v17 = 0;
    di_log::logger<di_log::log_printer<388ul>>::logger(v18, &v16);
    operator<<(&v19, a2);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v19,  (uint64_t)" is not supported (err code ",  28LL);
    __error();
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v19, (uint64_t)")", 1LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<388ul>>::~logger_buf((uint64_t)v18);
    MEMORY[0x1895BC2CC](v20);
    if (a2 == 2) {
      return (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 16LL))(a1, 0LL);
    }
    uint64_t v14 = (unint64_t *)(*(void *)(a1 + 40) + 56LL);
    do
      unint64_t v15 = __ldxr(v14);
    while (__stxr(v15 | 2, v14));
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 16LL))(a1, 1LL);
  }

void sub_18814A840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void *di_log::logger<di_log::log_printer<370ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<370ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1ECA90;
  a1[45] = &unk_18A1ECB90;
  a1[46] = &unk_18A1ECBB8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1ECA90;
  a1[45] = &unk_18A1ECB18;
  a1[46] = &unk_18A1ECB40;
  return a1;
}

void sub_18814A908(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<370ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<381ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<381ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1ECCB0;
  a1[45] = &unk_18A1ECDB0;
  a1[46] = &unk_18A1ECDD8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1ECCB0;
  a1[45] = &unk_18A1ECD38;
  a1[46] = &unk_18A1ECD60;
  return a1;
}

void sub_18814A9F0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<381ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<388ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<388ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1ECED0;
  a1[45] = &unk_18A1ECFD0;
  a1[46] = &unk_18A1ECFF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1ECED0;
  a1[45] = &unk_18A1ECF58;
  a1[46] = &unk_18A1ECF80;
  return a1;
}

void sub_18814AAD8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<388ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<398ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<398ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1ED0F0;
  a1[45] = &unk_18A1ED1F0;
  a1[46] = &unk_18A1ED218;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1ED0F0;
  a1[45] = &unk_18A1ED178;
  a1[46] = &unk_18A1ED1A0;
  return a1;
}

void sub_18814ABC0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<398ul>>::~logger(uint64_t a1)
{
  return a1;
}

size_t FileLocal::unmap_range(FileLocal *this, unint64_t a2, size_t a3)
{
  uint64_t v6 = *((void *)this + 5);
  FileLocal::shared_state_t::init_unmap_zeros((FileLocal::shared_state_t *)v6);
  size_t v7 = *(void *)(v6 + 72);
  int v8 = *(unsigned __int8 *)(v6 + 88);
  uint64_t v9 = *((void *)this + 5);
  FileLocal::shared_state_t::init_unmap_zeros((FileLocal::shared_state_t *)v9);
  if (!*(_BYTE *)(v9 + 136) || !v8)
  {
    *(void *)&__int128 v36 = "int FileLocal::unmap_range(uint64_t, uint64_t)";
    *((void *)&v36 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 26LL;
    LODWORD(v37) = 0;
    di_log::logger<di_log::log_printer<411ul>>::logger(&v38, &v36);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v44,  (uint64_t)"fd block size retrieval failed (err code ",  41LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v44, (uint64_t)")", 1LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<411ul>>::~logger_buf((uint64_t)&v38);
    goto LABEL_14;
  }

  uint64_t v10 = *(char **)(v9 + 96);
  unint64_t v11 = (a2 + v7 - 1) / v7 * v7;
  unint64_t v12 = a3 + a2;
  if (a2 <= v11 && v11 < v12)
  {
    unint64_t v14 = a2 - v11 + a3;
    size_t v15 = v14 / v7 * v7;
    unint64_t v16 = v14 == v14 % v7 ? 0LL : (a2 + v7 - 1) / v7 * v7;
    if (v14 != v14 % v7)
    {
      *(void *)&__int128 v36 = 0LL;
      *((void *)&v36 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v16;
      size_t v37 = v14 / v7 * v7;
      size_t v19 = fcntl(**((_DWORD **)this + 7), 99, &v36);
      if (!(_DWORD)v19)
      {
        unint64_t v20 = v16 - a2;
        if (v16 != a2)
        {
          uint64_t v21 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
          uint64_t v38 = v10;
          uint64_t v39 = v21;
          if (v21)
          {
            p_shared_owners = (unint64_t *)&v21->__shared_owners_;
            do
              unint64_t v23 = __ldxr(p_shared_owners);
            while (__stxr(v23 + 1, p_shared_owners));
          }

          unint64_t v40 = v16 - a2;
          unint64_t v41 = a2;
          unint64_t v42 = v16 - a2;
          char v43 = 0;
          size_t v7 = (*(uint64_t (**)(FileLocal *, char **))(*(void *)this + 80LL))(this, &v38);
          unsigned __int8 v24 = v39;
          if (v39)
          {
            int v25 = (unint64_t *)&v39->__shared_owners_;
            do
              unint64_t v26 = __ldaxr(v25);
            while (__stlxr(v26 - 1, v25));
            if (!v26)
            {
              ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
              std::__shared_weak_count::__release_weak(v24);
            }
          }

          if ((v7 & 0x80000000) != 0)
          {
            *(void *)&__int128 v34 = "int FileLocal::unmap_range(uint64_t, uint64_t)";
            *((void *)&v34 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 26LL;
            int v35 = 16;
            di_log::logger<di_log::log_printer<432ul>>::logger(&v38, &v34);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v44,  (uint64_t)"Write zeros to unmap unaligned start region failed (err code",  60LL);
            __error();
            std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v44, (uint64_t)")", 1LL);
            di_log::logger<di_log::log_printer<432ul>>::~logger((uint64_t)&v38);
            return v7;
          }
        }

        if (v15 + v16 < v12)
        {
          size_t v27 = a3 - (v20 + v15);
          __int16 v28 = (std::__shared_weak_count *)*((void *)details::get_dummy_shared_ptr() + 1);
          uint64_t v38 = v10;
          uint64_t v39 = v28;
          if (v28)
          {
            CFTypeID v29 = (unint64_t *)&v28->__shared_owners_;
            do
              unint64_t v30 = __ldxr(v29);
            while (__stxr(v30 + 1, v29));
          }

          unint64_t v40 = v27;
          unint64_t v41 = v15 + v16;
          unint64_t v42 = v27;
          char v43 = 0;
          size_t v7 = (*(uint64_t (**)(FileLocal *, char **))(*(void *)this + 80LL))(this, &v38);
          std::string v31 = v39;
          if (v39)
          {
            uint64_t v32 = (unint64_t *)&v39->__shared_owners_;
            do
              unint64_t v33 = __ldaxr(v32);
            while (__stlxr(v33 - 1, v32));
            if (!v33)
            {
              ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
              std::__shared_weak_count::__release_weak(v31);
            }
          }

          if ((v7 & 0x80000000) != 0)
          {
            *(void *)&__int128 v34 = "int FileLocal::unmap_range(uint64_t, uint64_t)";
            *((void *)&v34 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 26LL;
            int v35 = 16;
            di_log::logger<di_log::log_printer<441ul>>::logger(&v38, &v34);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v44,  (uint64_t)"Write zeros to unmap unaligned end region failed (err code",  58LL);
            __error();
            std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v44, (uint64_t)")", 1LL);
            di_log::logger<di_log::log_printer<441ul>>::~logger((uint64_t)&v38);
            return v7;
          }
        }

        return 0LL;
      }

      size_t v7 = v19;
      *(void *)&__int128 v34 = "int FileLocal::unmap_range(uint64_t, uint64_t)";
      *((void *)&v34 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 26LL;
      int v35 = 0;
      di_log::logger<di_log::log_printer<424ul>>::logger(&v38, &v34);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v44,  (uint64_t)"Punch hole is not supported (err code ",  38LL);
      __error();
      std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v44, (uint64_t)")", 1LL);
      std::ostream::~ostream();
      di_log::logger_buf<di_log::log_printer<424ul>>::~logger_buf((uint64_t)&v38);
LABEL_14:
      MEMORY[0x1895BC2CC](v45);
      return v7;
    }
  }

  ssize_t v17 = FileLocal::write_zeros(this, a2, a3, v7, v10);
  if (v17 == a3) {
    return 0LL;
  }
  size_t v7 = v17;
  *(void *)&__int128 v36 = "int FileLocal::unmap_range(uint64_t, uint64_t)";
  *((void *)&v36 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 26LL;
  LODWORD(v37) = 16;
  di_log::logger<di_log::log_printer<449ul>>::logger(&v38, &v36);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v44,  (uint64_t)"Write zeros to unmap region failed (err code",  44LL);
  __error();
  std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v44, (uint64_t)")", 1LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<449ul>>::~logger_buf((uint64_t)&v38);
  MEMORY[0x1895BC2CC](v45);
  if ((v7 & 0x8000000000000000LL) == 0LL) {
    return 4294967291LL;
  }
  else {
    return v7;
  }
}

void sub_18814B0D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void *di_log::logger<di_log::log_printer<411ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<411ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1ED310;
  a1[45] = &unk_18A1ED410;
  a1[46] = &unk_18A1ED438;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1ED310;
  a1[45] = &unk_18A1ED398;
  a1[46] = &unk_18A1ED3C0;
  return a1;
}

void sub_18814B1C8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<411ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<424ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<424ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1ED530;
  a1[45] = &unk_18A1ED630;
  a1[46] = &unk_18A1ED658;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1ED530;
  a1[45] = &unk_18A1ED5B8;
  a1[46] = &unk_18A1ED5E0;
  return a1;
}

void sub_18814B2B0(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<424ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<432ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<432ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1ED750;
  a1[45] = &unk_18A1ED850;
  a1[46] = &unk_18A1ED878;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1ED750;
  a1[45] = &unk_18A1ED7D8;
  a1[46] = &unk_18A1ED800;
  return a1;
}

void sub_18814B398(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<432ul>>::~logger(uint64_t a1)
{
  return a1;
}

void *di_log::logger<di_log::log_printer<441ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<441ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1ED970;
  a1[45] = &unk_18A1EDA70;
  a1[46] = &unk_18A1EDA98;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1ED970;
  a1[45] = &unk_18A1ED9F8;
  a1[46] = &unk_18A1EDA20;
  return a1;
}

void sub_18814B480(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<441ul>>::~logger(uint64_t a1)
{
  return a1;
}

ssize_t FileLocal::write_zeros(FileLocal *this, off_t a2, size_t a3, size_t a4, char *a5)
{
  size_t v7 = a3;
  __int128 v22 = 0LL;
  unint64_t v23 = 0LL;
  unsigned __int8 v24 = 0LL;
  std::vector<iovec>::reserve((void **)&v22, (a3 + a4 - 1) / a4 * a4);
  if (v7)
  {
    uint64_t v10 = v23;
    do
    {
      if (v7 >= a4) {
        size_t v11 = a4;
      }
      else {
        size_t v11 = v7;
      }
      if (v10 >= v24)
      {
        uint64_t v12 = v10 - v22;
        unint64_t v13 = ((char *)v24 - (char *)v22) >> 3;
        if (v13 <= v12 + 1) {
          unint64_t v13 = v12 + 1;
        }
        else {
          unint64_t v14 = v13;
        }
        if (v14) {
          size_t v15 = (char *)std::allocator<iovec>::allocate_at_least[abi:ne180100]((uint64_t)&v24, v14);
        }
        else {
          size_t v15 = 0LL;
        }
        unint64_t v16 = (iovec *)&v15[16 * v12];
        v16->iov_base = a5;
        v16->iov_len = v11;
        __int16 v18 = v22;
        ssize_t v17 = v23;
        size_t v19 = v16;
        if (v23 != v22)
        {
          do
          {
            v19[-1] = v17[-1];
            --v19;
            --v17;
          }

          while (v17 != v18);
          ssize_t v17 = v22;
        }

        uint64_t v10 = v16 + 1;
        __int128 v22 = v19;
        unint64_t v23 = v16 + 1;
        unsigned __int8 v24 = (iovec *)&v15[16 * v14];
        if (v17) {
          operator delete(v17);
        }
      }

      else
      {
        v10->iov_base = a5;
        v10->iov_len = v11;
        ++v10;
      }

      unint64_t v23 = v10;
      v7 -= v11;
    }

    while (v7);
  }

  else
  {
    uint64_t v10 = v23;
  }

  ssize_t v20 = pwritev(**((_DWORD **)this + 7), v22, (unint64_t)((char *)v10 - (char *)v22) >> 4, a2);
  if (v22)
  {
    unint64_t v23 = v22;
    operator delete(v22);
  }

  return v20;
}

void sub_18814B678( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *di_log::logger<di_log::log_printer<449ul>>::logger(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<449ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EDB90;
  a1[45] = &unk_18A1EDC90;
  a1[46] = &unk_18A1EDCB8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EDB90;
  a1[45] = &unk_18A1EDC18;
  a1[46] = &unk_18A1EDC40;
  return a1;
}

void sub_18814B720(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<449ul>>::~logger(uint64_t a1)
{
  return a1;
}

void std::vector<iovec>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<iovec>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    uint64_t v6 = (char *)std::allocator<iovec>::allocate_at_least[abi:ne180100](v3, a2);
    size_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0LL];
    uint64_t v9 = &v6[16 * v8];
    size_t v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - udif::run_type::run_type((udif::run_type *)&v11, 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }

      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t FileLocal::lock(FileLocal *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (*(_BYTE *)(v1 + 48)
    || ((*(uint64_t (**)(FileLocal *))(*(void *)this + 48LL))(this) & 1) == 0
    && FileDescriptor::is_mounted_on_smb(*((FileDescriptor **)this + 5)))
  {
    return 0LL;
  }

  int v4 = (*(uint64_t (**)(FileLocal *))(*(void *)this + 48LL))(this);
  if (v4) {
    int v5 = 6;
  }
  else {
    int v5 = 5;
  }
  if (!flock(**((_DWORD **)this + 7), v5))
  {
    *(void *)&__int128 v8 = "int FileLocal::lock()";
    *((void *)&v8 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 19LL;
    int v9 = 0;
    di_log::logger<di_log::log_printer<485ul>>::logger(v10, &v8);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)"File (fd ", 9LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)") is locked", 11LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<485ul>>::~logger_buf((uint64_t)v10);
    MEMORY[0x1895BC2CC](v12);
    uint64_t result = 0LL;
    *(_BYTE *)(v1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = 1;
    return result;
  }

  if (*__error() != 35)
  {
    *(void *)&__int128 v8 = "int FileLocal::lock()";
    *((void *)&v8 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 19LL;
    int v9 = 0;
    di_log::logger<di_log::log_printer<492ul>>::logger(v10, &v8);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v11,  (uint64_t)"flock returned errno ",  21LL);
    __error();
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v11,  (uint64_t)", keeping file unlocked",  23LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<492ul>>::~logger_buf((uint64_t)v10);
    MEMORY[0x1895BC2CC](v12);
    return 0LL;
  }

  *(void *)&__int128 v8 = "int FileLocal::lock()";
  *((void *)&v8 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 19LL;
  int v9 = 16;
  di_log::logger<di_log::log_printer<489ul>>::logger(v10, &v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)"Cannot acquire ", 15LL);
  if (v4) {
    uint64_t v6 = "exclusive";
  }
  else {
    uint64_t v6 = "shared";
  }
  if (v4) {
    uint64_t v7 = 9LL;
  }
  else {
    uint64_t v7 = 6LL;
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)v6, v7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)" lock, errno ", 13LL);
  __error();
  std::ostream::operator<<();
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<489ul>>::~logger_buf((uint64_t)v10);
  MEMORY[0x1895BC2CC](v12);
  return -*__error();
}

void sub_18814BA9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<489ul>>::logger(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<489ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EDDB0;
  a1[45] = &unk_18A1EDEB0;
  a1[46] = &unk_18A1EDED8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EDDB0;
  a1[45] = &unk_18A1EDE38;
  a1[46] = &unk_18A1EDE60;
  return a1;
}

void sub_18814BB58(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<489ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t non-virtual thunk to'FileLocal::lock(FileLocal *this)
{
  return FileLocal::lock((FileLocal *)((char *)this - 24));
}

uint64_t FileLocal::unlock_all(FileLocal *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (!*(_BYTE *)(v1 + 48)) {
    return 0LL;
  }
  if (flock(**((_DWORD **)this + 7), 8))
  {
    *(void *)&__int128 v3 = "int FileLocal::unlock_all()";
    *((void *)&v3 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 25LL;
    int v4 = 16;
    di_log::logger<di_log::log_printer<502ul>>::logger(v5, &v3);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v6,  (uint64_t)"Failed unlocking file with fd ",  30LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)", errno ", 8LL);
    __error();
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<502ul>>::~logger_buf((uint64_t)v5);
    MEMORY[0x1895BC2CC](v7);
    return -*__error();
  }

  else
  {
    *(void *)&__int128 v3 = "int FileLocal::unlock_all()";
    *((void *)&v3 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 25LL;
    int v4 = 0;
    di_log::logger<di_log::log_printer<505ul>>::logger(v5, &v3);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)"File (fd ", 9LL);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)") is unlocked", 13LL);
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<505ul>>::~logger_buf((uint64_t)v5);
    MEMORY[0x1895BC2CC](v7);
    uint64_t result = 0LL;
    *(_BYTE *)(v1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = 0;
  }

  return result;
}

void sub_18814BD40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *di_log::logger<di_log::log_printer<502ul>>::logger(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<502ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EDFD0;
  a1[45] = &unk_18A1EE0D0;
  a1[46] = &unk_18A1EE0F8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EDFD0;
  a1[45] = &unk_18A1EE058;
  a1[46] = &unk_18A1EE080;
  return a1;
}

void sub_18814BDE8(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<502ul>>::~logger(uint64_t a1)
{
  return a1;
}

uint64_t non-virtual thunk to'FileLocal::unlock_all(FileLocal *this)
{
  return FileLocal::unlock_all((FileLocal *)((char *)this - 24));
}

uint64_t FileLocal::is_locked(FileLocal *this)
{
  return *(unsigned __int8 *)(*((void *)this + 5) + 48LL);
}

uint64_t non-virtual thunk to'FileLocal::is_locked(FileLocal *this)
{
  return *(unsigned __int8 *)(*((void *)this + 2) + 48LL);
}

uint64_t FileLocal::remove_lock_ownership(FileLocal *this)
{
  uint64_t v1 = *((void *)this + 5);
  uint64_t result = *(unsigned __int8 *)(v1 + 48);
  *(_BYTE *)(v1 + std::shared_ptr<char>::~shared_ptr[abi:ne180100](v4 - 48) = 0;
  return result;
}

void *FileLocal::run_futures(void *this)
{
  v43[32] = *MEMORY[0x1895F89C0];
  uint64_t v1 = this[9];
  if (v1)
  {
    uint64_t v2 = this;
    int v38 = *(unsigned __int8 *)(this[5] + 49LL);
    size_t v37 = this + 8;
    __int128 v3 = (void *)this[8];
    int v4 = v3;
    while (1)
    {
      unint64_t v41 = (iovec *)v43;
      uint64_t v5 = v4[2];
      v43[0] = *v4;
      v43[1] = v5;
      __int128 v42 = xmmword_188182DF0;
      uint64_t v6 = &v3[8 * v1];
      unint64_t v40 = &v41;
      if (v4 == v6)
      {
        uint64_t v7 = 1LL;
        unint64_t v8 = (unint64_t)v4;
      }

      else
      {
        uint64_t v7 = 1LL;
        unint64_t v8 = (unint64_t)v4;
        if (v4 + 8 != v6)
        {
          int v9 = v4;
          while (v9[2] + v9[3] == v9[11] && *((_DWORD *)v9 + 12) == *((_DWORD *)v9 + 28))
          {
            *(void *)&__int128 v39 = v9[8];
            *((void *)&v39 + udif::run_type::run_type((udif::run_type *)&v11, 1) = v9[10];
            std::back_insert_iterator<boost::container::small_vector<iovec,16ul,void,void>>::operator=[abi:ne180100]( (uint64_t *)&v40,  &v39);
            unint64_t v8 = (unint64_t)(v9 + 8);
            uint64_t v10 = v9 + 16;
            v9 += 8;
            if (v10 == v6) {
              goto LABEL_11;
            }
          }

          unint64_t v8 = (unint64_t)v9;
LABEL_11:
          uint64_t v7 = v42;
        }
      }

      unint64_t v11 = v8 + 64;
      int v12 = *((_DWORD *)v4 + 12);
      if (v12 == 1)
      {
        uint64_t v15 = v4[3];
        int v16 = *(_DWORD *)v2[7];
        if (v7 == 1) {
          ssize_t v17 = pwrite(v16, v41->iov_base, v41->iov_len, v4[3]);
        }
        else {
          ssize_t v17 = pwritev(v16, v41, (v11 - (unint64_t)v4) >> 6, v4[3]);
        }
        uint64_t v19 = v17;
        if (v17 < 1) {
          goto LABEL_45;
        }
        unint64_t v28 = v17 + v15;
        CFTypeID v29 = (unint64_t *)(v2[5] + 64LL);
        unint64_t v30 = atomic_load(v29);
        if (v30 < v17 + v15)
        {
          do
          {
            unint64_t v31 = __ldaxr(v29);
            if (v31 == v30)
            {
              if (!__stlxr(v28, v29)) {
                goto LABEL_45;
              }
            }

            else
            {
              __clrex();
            }

            unint64_t v30 = v31;
          }

          while (v31 < v28);
          goto LABEL_45;
        }
      }

      else
      {
        if (!v12)
        {
          off_t v13 = v4[3];
          if (v7 == 1)
          {
            ssize_t v14 = pread(*(_DWORD *)v2[7], v41->iov_base, v41->iov_len, v4[3]);
LABEL_44:
            uint64_t v19 = v14;
LABEL_45:
            if (v19 == -1) {
              uint64_t v19 = -(uint64_t)*__error();
            }
            goto LABEL_47;
          }

          if (!v38)
          {
            ssize_t v14 = preadv(*(_DWORD *)v2[7], v41, (v11 - (unint64_t)v4) >> 6, v13);
            goto LABEL_44;
          }

          uint64_t v18 = v11 - (void)v4;
          if ((v11 - (void)v4) << 26)
          {
            uint64_t v19 = 0LL;
            uint64_t v20 = 0LL;
            int v21 = *(_DWORD *)v2[7];
            uint64_t v22 = 16LL * (int)(v18 >> 6);
            p_iov_len = &v41->iov_len;
            do
            {
              if ((v20 & 0x8000000000000000LL) == 0)
              {
                ssize_t v24 = pread(v21, (void *)*(p_iov_len - 1), *p_iov_len, v20 + v13);
                size_t v25 = *p_iov_len;
                uint64_t v26 = v19 + v24;
                uint64_t v27 = -5LL;
                if (v24 == -1) {
                  uint64_t v27 = -1LL;
                }
                if (v24 == v25) {
                  v19 += v24;
                }
                else {
                  uint64_t v19 = v27;
                }
                if (v24 == v25) {
                  uint64_t v20 = v26;
                }
                else {
                  uint64_t v20 = v27;
                }
              }

              p_iov_len += 2;
              v22 -= 16LL;
            }

            while (v22);
            goto LABEL_45;
          }
        }

        uint64_t v19 = 0LL;
      }

void sub_18814C1E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18)
{
  if (a18)
  {
    if (v18 != __p) {
      operator delete(__p);
    }
  }

  _Unwind_Resume(exception_object);
}

BOOL FileLocal::mounted_on_same_fs( FileDescriptor **this, const FileDescriptor **a2, const FileDescriptor *a3)
{
  return FileDescriptor::mounted_on_same_fs(this[5], a2[5], a3);
}

void PurgeableFileBackend::~PurgeableFileBackend(PurgeableFileBackend *this)
{
  *(void *)this = off_18A1EB8A0;
  *((void *)this + 3) = &unk_18A1EB980;
  *((void *)this + 4) = &unk_18A1EB9B8;
  if (futimes(**((_DWORD **)this + 7), 0LL))
  {
    *(void *)&__int128 v3 = "PurgeableFileBackend::~PurgeableFileBackend()";
    *((void *)&v3 + udif::run_type::run_type((udif::run_type *)&v11, 1) = 43LL;
    int v4 = 16;
    di_log::logger<di_log::log_printer<643ul>>::logger(v5, &v3);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)"futimes failed on ", 18LL);
    operator<<((uint64_t)&v6, (uint64_t)this);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)", errno ", 8LL);
    __error();
    std::ostream::operator<<();
    std::ostream::~ostream();
    di_log::logger_buf<di_log::log_printer<643ul>>::~logger_buf((uint64_t)v5);
    MEMORY[0x1895BC2CC](&v7);
  }

  *(void *)this = off_18A1EBA08;
  *((void *)this + 3) = &unk_18A1EBAE8;
  *((void *)this + 4) = &unk_18A1EBB20;
  boost::container::vector<FileLocal::promise_io_t,boost::container::small_vector_allocator<FileLocal::promise_io_t,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)this + 64);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 40);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

{
  void *v1;
  PurgeableFileBackend::~PurgeableFileBackend(this);
  operator delete(v1);
}

void *di_log::logger<di_log::log_printer<643ul>>::logger(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  a1[46] = MEMORY[0x189614770] + 16LL;
  di_log::logger_buf<di_log::log_printer<643ul>>::logger_buf((uint64_t)a1, a2);
  *a1 = off_18A1EE1F0;
  a1[45] = &unk_18A1EE2F0;
  a1[46] = &unk_18A1EE318;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 128) = -1;
  *a1 = off_18A1EE1F0;
  a1[45] = &unk_18A1EE278;
  a1[46] = &unk_18A1EE2A0;
  return a1;
}

void sub_18814C3D4(_Unwind_Exception *a1)
{
}

uint64_t di_log::logger<di_log::log_printer<643ul>>::~logger(uint64_t a1)
{
  return a1;
}

void non-virtual thunk to'PurgeableFileBackend::~PurgeableFileBackend(PurgeableFileBackend *this)
{
}

{
  PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 32));
}

{
  void *v1;
  PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 24));
  operator delete(v1);
}

{
  void *v1;
  PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 32));
  operator delete(v1);
}

uint64_t get_fd_from_backend(uint64_t a1)
{
  uint64_t v1 = *(const void **)a1;
  if (!*(void *)a1) {
    return 0xFFFFFFFFLL;
  }
  if (!v3)
  {
    if (v11)
    {
      int v4 = *(std::__shared_weak_count **)(a1 + 8);
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          unint64_t v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
      }

      uint64_t v7 = (*(uint64_t (**)(void *))(*(void *)v11 + 176LL))(v11);
      if (v4)
      {
        ssize_t v14 = (unint64_t *)&v4->__shared_owners_;
        do
          unint64_t v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15) {
          goto LABEL_13;
        }
      }

      return v7;
    }

    return 0xFFFFFFFFLL;
  }

  int v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    uint64_t v5 = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  uint64_t v7 = (**v3)(v3);
  if (v4)
  {
    unint64_t v8 = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
LABEL_13:
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  return v7;
}

void sub_18814C5E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

BOOL FileLocal::supports_unmap(FileDescriptor **this)
{
  return FileDescriptor::is_mounted_on_apfs(this[5]);
}

unint64_t FileLocal::get_size(FileLocal *this)
{
  return atomic_load((unint64_t *)(*((void *)this + 5) + 64LL));
}

uint64_t FileLocal::is_writable(FileLocal *this)
{
  return *(unsigned __int8 *)(*((void *)this + 5) + 12LL);
}

void *FileLocal::name(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)std::ostream::operator<<();
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)")", 1LL);
}

double FileLocal::getContext@<D0>(FileLocal *this@<X0>, _OWORD *a2@<X8>)
{
  double result = v4[0];
  *a2 = *(_OWORD *)v4;
  return result;
}

unint64_t FileLocal::future_read@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X8>)
{
  LOBYTE(v22) = 0;
  BYTE4(v22) = 0;
  unint64_t v23 = 0LL;
  *(void *)&v24[0] = ref::details::_get_tagged_ptr_lock((unint64_t)&v22, a2);
  uint64_t tagged_ptr_cond = ref::details::_get_tagged_ptr_cond((unint64_t)&v22, v6);
  CFTypeID v29 = &v22;
  *((void *)&v24[0] + udif::run_type::run_type((udif::run_type *)&v11, 1) = tagged_ptr_cond;
  *(void *)&v24[1] = &v29;
  lw_future<int>::lw_future((unint64_t)v27, &v22);
  unint64_t v8 = v29;
  unint64_t v28 = v29;
  v29[4] = (uint64_t)&v28;
  uint64_t v9 = *a2;
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v22 = *a2;
  unint64_t v23 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    unint64_t v8 = v28;
  }

  *(_OWORD *)((char *)v24 + 9) = *(_OWORD *)((char *)a2 + 25);
  v24[0] = *((_OWORD *)a2 + 1);
  int v25 = 0;
  uint64_t v26 = v8;
  unint64_t v28 = 0LL;
  v8[4] = (uint64_t)&v26;
  uint64_t v13 = a1[9];
  uint64_t v14 = a1[8] + (v13 << 6);
  if (v13 == a1[10])
  {
    boost::container::vector<FileLocal::promise_io_t,boost::container::small_vector_allocator<FileLocal::promise_io_t,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<FileLocal::promise_io_t,boost::container::new_allocator<void>,void>,FileLocal::promise_io_t*,FileLocal::promise_io_t>>( a1 + 8,  v14,  (const char *)1,  (uint64_t)&v22,  &v29);
    if (v26) {
      v26[4] = 0LL;
    }
  }

  else
  {
    *(void *)uint64_t v14 = v9;
    *(void *)(v14 + 8) = v10;
    uint64_t v22 = 0LL;
    unint64_t v23 = 0LL;
    __int128 v15 = v24[0];
    *(_OWORD *)(v14 + 25) = *(_OWORD *)((char *)v24 + 9);
    *(_OWORD *)(v14 + 16) = v15;
    int v16 = v25;
    *(void *)(v14 + ++*(_DWORD *)(this + 56) = v26;
    uint64_t v17 = v14 + 56;
    *(_DWORD *)(v17 - 8) = v16;
    uint64_t v26 = 0LL;
    *(void *)(*(void *)v17 + 32LL) = v17;
    ++a1[9];
  }

  uint64_t v18 = v23;
  if (v23)
  {
    uint64_t v19 = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  unint64_t result = lw_future<int>::lw_future(a3, v27);
  if (v28) {
    v28[4] = 0LL;
  }
  return result;
}

void sub_18814C8A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23)
{
  if (a17) {
    *(void *)(a17 + 32) = 0LL;
  }
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  if (a23) {
    *(void *)(a23 + 32) = 0LL;
  }
  _Unwind_Resume(a1);
}

void sub_18814C8D8()
{
  if (!*(void *)(v0 - 40)) {
    JUMPOUT(0x18814C8D0LL);
  }
  JUMPOUT(0x18814C8CCLL);
}

unint64_t FileLocal::future_write@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X8>)
{
  LOBYTE(v22) = 0;
  BYTE4(v22) = 0;
  unint64_t v23 = 0LL;
  *(void *)&v24[0] = ref::details::_get_tagged_ptr_lock((unint64_t)&v22, a2);
  uint64_t tagged_ptr_cond = ref::details::_get_tagged_ptr_cond((unint64_t)&v22, v6);
  CFTypeID v29 = &v22;
  *((void *)&v24[0] + udif::run_type::run_type((udif::run_type *)&v11, 1) = tagged_ptr_cond;
  *(void *)&v24[1] = &v29;
  lw_future<int>::lw_future((unint64_t)v27, &v22);
  unint64_t v8 = v29;
  unint64_t v28 = v29;
  v29[4] = (uint64_t)&v28;
  uint64_t v9 = *a2;
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v22 = *a2;
  unint64_t v23 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    unint64_t v8 = v28;
  }

  *(_OWORD *)((char *)v24 + 9) = *(_OWORD *)((char *)a2 + 25);
  v24[0] = *((_OWORD *)a2 + 1);
  int v25 = 1;
  uint64_t v26 = v8;
  unint64_t v28 = 0LL;
  v8[4] = (uint64_t)&v26;
  uint64_t v13 = a1[9];
  uint64_t v14 = a1[8] + (v13 << 6);
  if (v13 == a1[10])
  {
    boost::container::vector<FileLocal::promise_io_t,boost::container::small_vector_allocator<FileLocal::promise_io_t,boost::container::new_allocator<void>,void>,void>::priv_insert_forward_range_no_capacity<boost::container::dtl::insert_emplace_proxy<boost::container::small_vector_allocator<FileLocal::promise_io_t,boost::container::new_allocator<void>,void>,FileLocal::promise_io_t*,FileLocal::promise_io_t>>( a1 + 8,  v14,  (const char *)1,  (uint64_t)&v22,  &v29);
    if (v26) {
      v26[4] = 0LL;
    }
  }

  else
  {
    *(void *)uint64_t v14 = v9;
    *(void *)(v14 + 8) = v10;
    uint64_t v22 = 0LL;
    unint64_t v23 = 0LL;
    __int128 v15 = v24[0];
    *(_OWORD *)(v14 + 25) = *(_OWORD *)((char *)v24 + 9);
    *(_OWORD *)(v14 + 16) = v15;
    int v16 = v25;
    *(void *)(v14 + ++*(_DWORD *)(this + 56) = v26;
    uint64_t v17 = v14 + 56;
    *(_DWORD *)(v17 - 8) = v16;
    uint64_t v26 = 0LL;
    *(void *)(*(void *)v17 + 32LL) = v17;
    ++a1[9];
  }

  uint64_t v18 = v23;
  if (v23)
  {
    uint64_t v19 = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  unint64_t result = lw_future<int>::lw_future(a3, v27);
  if (v28) {
    v28[4] = 0LL;
  }
  return result;
}

void sub_18814CA88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23)
{
  if (a17) {
    *(void *)(a17 + 32) = 0LL;
  }
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  if (a23) {
    *(void *)(a23 + 32) = 0LL;
  }
  _Unwind_Resume(a1);
}

void sub_18814CABC()
{
  if (!*(void *)(v0 - 40)) {
    JUMPOUT(0x18814CAB4LL);
  }
  JUMPOUT(0x18814CAB0LL);
}

uint64_t FileLocal::get_identifier(FileLocal *this)
{
  return *(void *)(*((void *)this + 5) + 32LL);
}

uint64_t FileLocal::get_file_descriptor(FileLocal *this)
{
  return **((unsigned int **)this + 7);
}

void non-virtual thunk to'FileLocal::~FileLocal(FileLocal *this)
{
  *((void *)this - 3) = off_18A1EBA08;
  *(void *)this = &unk_18A1EBAE8;
  *((void *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = &unk_18A1EBB20;
  boost::container::vector<FileLocal::promise_io_t,boost::container::small_vector_allocator<FileLocal::promise_io_t,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)this + 40);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this - 1);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

{
  char *v2;
  std::__shared_weak_count *v3;
  *((void *)this - 3) = off_18A1EBA08;
  uint64_t v2 = (char *)this - 24;
  *(void *)this = &unk_18A1EBAE8;
  *((void *)this + udif::run_type::run_type((udif::run_type *)&v11, 1) = &unk_18A1EBB20;
  boost::container::vector<FileLocal::promise_io_t,boost::container::small_vector_allocator<FileLocal::promise_io_t,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)this + 40);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
  __int128 v3 = (std::__shared_weak_count *)*((void *)this - 1);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  operator delete(v2);
}

{
  std::__shared_weak_count *v2;
  *((void *)this - 4) = off_18A1EBA08;
  *((void *)this - udif::run_type::run_type((udif::run_type *)&v11, 1) = &unk_18A1EBAE8;
  *(void *)this = &unk_18A1EBB20;
  boost::container::vector<FileLocal::promise_io_t,boost::container::small_vector_allocator<FileLocal::promise_io_t,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)this + 32);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this - 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

{
  char *v2;
  std::__shared_weak_count *v3;
  *((void *)this - 4) = off_18A1EBA08;
  uint64_t v2 = (char *)this - 32;
  *((void *)this - udif::run_type::run_type((udif::run_type *)&v11, 1) = &unk_18A1EBAE8;
  *(void *)this = &unk_18A1EBB20;
  boost::container::vector<FileLocal::promise_io_t,boost::container::small_vector_allocator<FileLocal::promise_io_t,boost::container::new_allocator<void>,void>,void>::~vector((uint64_t)this + 32);
  std::shared_ptr<char>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  __int128 v3 = (std::__shared_weak_count *)*((void *)this - 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  operator delete(v2);
}

uint64_t non-virtual thunk to'FileLocal::get_file_descriptor(FileLocal *this)
{
  return **((unsigned int **)this + 3);
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<66ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<66ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<66ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<66ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<66ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<66ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<66ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<66ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<66ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<66ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EBD48;
  di_log::logger_buf<di_log::log_printer<66ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<66ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<66ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18814CFC0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<66ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<66ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<66ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 66LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 66LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<78ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<78ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<78ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<78ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<78ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<78ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<78ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<78ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<78ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<78ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EBF68;
  di_log::logger_buf<di_log::log_printer<78ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<78ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<78ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18814D56C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<78ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<78ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<78ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 78LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 78LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<95ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<95ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<95ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<95ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<95ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<95ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<95ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<95ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<95ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<95ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EC188;
  di_log::logger_buf<di_log::log_printer<95ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<95ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<95ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18814DB18( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<95ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<95ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<95ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 95LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 95LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<103ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<103ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<103ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<103ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<103ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<103ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<103ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<103ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<103ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<103ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EC3A8;
  di_log::logger_buf<di_log::log_printer<103ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<103ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<103ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18814E0C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<103ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<103ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<103ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 103LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 103LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<298ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<298ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<298ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<298ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<298ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<298ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<298ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<298ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<298ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<298ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EC5C8;
  di_log::logger_buf<di_log::log_printer<298ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<298ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<298ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18814E670( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<298ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<298ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<298ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 298LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 298LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<313ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<313ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<313ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<313ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<313ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<313ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<313ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<313ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<313ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<313ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1EC7E8;
  di_log::logger_buf<di_log::log_printer<313ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<313ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<313ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18814EC1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<313ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<313ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<313ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 313LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 313LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<336ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<336ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<336ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<336ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<336ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<336ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<336ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<336ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<336ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<336ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1ECA08;
  di_log::logger_buf<di_log::log_printer<336ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<336ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<336ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18814F1C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<336ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<336ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<336ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 336LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 336LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<370ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<370ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<370ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<370ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<370ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<370ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<370ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<370ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<370ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<370ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1ECC28;
  di_log::logger_buf<di_log::log_printer<370ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<370ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<370ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18814F774( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<370ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<370ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<370ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 370LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 370LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<381ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<381ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<381ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<381ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<381ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<381ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}

void di_log::logger<di_log::log_printer<381ul>>::~logger(char *a1)
{
}

uint64_t di_log::logger_buf<di_log::log_printer<381ul>>::xsputn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write();
  }
  return a3;
}

uint64_t di_log::logger_buf<di_log::log_printer<381ul>>::overflow(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put();
    }
  }

  return v2;
}

uint64_t di_log::logger_buf<di_log::log_printer<381ul>>::~logger_buf(uint64_t a1)
{
  *(void *)a1 = off_18A1ECE48;
  di_log::logger_buf<di_log::log_printer<381ul>>::_sync(a1);
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)(a1 + 96) = *MEMORY[0x189614738];
  *(void *)(a1 + 96 + *(void *)(v3 - PurgeableFileBackend::~PurgeableFileBackend((PurgeableFileBackend *)((char *)this - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 104) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1895BC2CC](a1 + 208);
  return std::streambuf::~streambuf();
}

uint64_t di_log::logger_buf<di_log::log_printer<381ul>>::_sync(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a1 + 104, __p);
        di_log::log_printer<381ul>::log((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        std::string::basic_string[abi:ne180100]<0>(__p, "");
        std::stringbuf::str[abi:ne180100](a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_18814FD20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void di_log::logger_buf<di_log::log_printer<381ul>>::~logger_buf(uint64_t a1)
{
  uint64_t v1 = (void *)di_log::logger_buf<di_log::log_printer<381ul>>::~logger_buf(a1);
  operator delete(v1);
}

int *di_log::log_printer<381ul>::log(uint64_t *a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (DIForwardLogs())
  {
    DIOSLog = (os_log_s *)getDIOSLog();
    os_log_type_enabled(DIOSLog, *((os_log_type_t *)a1 + 16));
    uint64_t v7 = *a1;
    else {
      uint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v17 = v4;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    uint64_t v21 = 381LL;
    __int16 v22 = 2082;
    unint64_t v23 = v8;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    if (v9)
    {
      uint64_t v10 = (char *)v9;
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v9);
      free(v10);
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)getDIOSLog();
    os_log_type_t v12 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v11, v12))
    {
      uint64_t v13 = *a1;
      else {
        uint64_t v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 381LL;
      __int16 v22 = 2082;
      unint64_t v23 = v14;
      _os_log_impl(&dword_188046000, v11, v12, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  int *result = v5;
  return result;
}

void non-virtual thunk to'di_log::logger<di_log::log_printer<388ul>>::~logger(uint64_t a1)
{
  uint64_t v1 = a1 - 360;
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<388ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  void *v2;
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<388ul>>::~logger_buf((uint64_t)v2);
  MEMORY[0x1895BC2CC](a1 + 8);
  operator delete(v2);
}

void virtual thunk to'di_log::logger<di_log::log_printer<388ul>>::~logger(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<388ul>>::~logger_buf(v1);
  JUMPOUT(0x1895BC2CCLL);
}

{
  char *v1;
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream();
  di_log::logger_buf<di_log::log_printer<388ul>>::~logger_buf((uint64_t)v1);
  MEMORY[0x1895BC2CC](v1 + 368);
  operator delete(v1);
}